#
# Documentation sccsid[] = "%W% %G% %U% %P%";
#

SSL Debugger Module
-------------------

To integrate this ssl debugger into an ssl program:

*   #include "debug.h"

*   Define a table of variables that can be accessed:

    dbg_variables debug_variables[] = {
        /* "Name", address,    udata,    display_function */
        "",        NULL,       0,        NULL,
    };

*   Create a ssl_restart() function that opens all user input/output files,
    initializes scanner, semantic operations, walker, and debugger:
    [ For now, the debugger calls "ssl_cleanup()" and "ssl_restart()" directly ]

    ssl_restart ()
    {
        ssl_src_file = fopen (...) ...
        ssl_init_scanner();
        ssl_pc = 0; ...

        /* initialize debugger */

        #define DEBUG_FILE    "program.dbg"
        #define DEBUG_SOURCE  "program.lst"

        if (ssl_debug)
            dbg_init (DEBUG_FILE, DEBUG_SOURCE, input_filename, oBreak, debug_variables);

        print title string
    }

*   Change main execution to:

    ssl_restart ();

    /* execute SSL program */

    if (ssl_debug)
        dbg_walkTable();
    else
        ssl_walkTable();

*   In walker function: the return status is now meaningful.

    /*  Return status:
     *    0 = finished execution of program
     *    1 = completed single stepping
     *    2 = hit breakpoint
     */

    ssl_walkTable()
    {
        ssl_walking = 1;       /* For improved error trapping */

        if (ssl_debug)
        {
            if (setjmp (ssl_fatal_jmp_buf))   /* Return here from ssl_fatal() */
            {
                ssl_walking = 0;
                ssl_error ("Stopped at fatal error");
                return (0);
            }
        }


        while (1)
        {
            if (ssl_debug)
            {
                if (dbg_check_step_count ())
                {
                    ssl_walking = 0;
                    return (2);
                }
            }

            switch (ssl_code_table[w_pc++])
            {
                ..
                case oReturn:
                    ...
                    return (0);

                case oBreak:
                    ssl_walking = 0;
                    return (1);    /* Hit breakpoint */
            }
        }


*   Change error handling functions for better error trapping:

    #include <setjmp.h>
    jmp_buf  ssl_fatal_jmp_buf;

    ssl_fatal (msg)
    {
        ssl_error (...msg...)
        ssl_abort ();
    }

    ssl_abort ()
    {
        ssl_traceback();
        ssl_cleanup();
        if (ssl_debug && ssl_walking)
            longjmp (ssl_fatal_jmp_buf, 1);
        exit (5);
    }

*   In makefile

    DEBUG_DIR   = <this_directory>
    SSLTOOL_DIR = <ssltool directory>

    DEBUG_OBJS   = ${DEBUG_DIR}/debug.o
    DEBUG_STUBS  = ${DEBUG_DIR}/dbgstub.o   # for command line debugger
    SSLTOOL_OBJS = ${SSLTOOL_DIR}/ssltool_stubs_new.o \
                   ${SSLTOOL_DIR}/ssltool_ui_new.o
    SSLTOOL_LIB_PATH = -L${GUIDEHOME}/lib -L${OPENWINHOME}/lib
    SSLTOOL_LIBS     = -lguide -lguidexv -lxview -lolgx -lX

    # For program objects:

    cc -c program.c -$I{DEBUG_DIR}   # for "debug.h"

    # For command line debugging:

    cc -o program <program_objs> ${DEBUG_OBJS} ${DEBUG_STUBS}

    # For graphical debugging:

    cc -o program_tool ${SSLTOOL_LIB_PATH} \
                  <program_objs> ${DEBUG_OBJS} ${SSLTOOL_OBJS} ${SSLTOOL_LIBS}


*   Your walker/scanner needs the following functions and variables:

------------ THIS PORTION OF THE DOCUMENTATION IS NOT UP TO DATE YET ---------

    short w_codeTable_size = w_codeTableSize;   /* Number of entries in table */
           /* NOTE: ssl defines macro w_codeTableSize in <program>.h
                    debugger reads value from variable w_codeTable_size */
           /* NOTE: My other programs don't set w_codeTable_size if they use C file,
                    which explains why "stop at #addr" doesn't work for them */

    ssl_get_input_position (line_ptr, col_ptr)
    short                  *line_ptr, *col_ptr;
    {
        if (t_token.accepted == 0)
        {
            *line_ptr = t_token.lineNumber;
            *col_ptr = t_token.colNumber;
        }
        else
        {
            *line_ptr = t_lineNumber;
            *col_ptr = t_ptr - t_lineBuffer;
        }
    }

    nodeDumpTreeNum (node_number)
    long             node_number;
    {
        /* Stub function, if Schema package not used in program */
    }

    short w_rule_addr (name)
    char              *name;
    {
        short    i;

        for (i = 0; i < w_ruleTableSize; i++)
        {
            if (strcmp (name, w_ruleTable[i].name) == 0)
                return (w_ruleTable[i].addr);
        }
        printf ("Unknown rule name: '%s'\n", name);
        return ((short) -1);
    }

    char *w_rule_name (addr)
    short              addr;
    {
        short    i;

        for (i = 1; i < w_ruleTableSize; i++)
        {
            if (addr < w_ruleTable[i].addr)
                return (w_ruleTable[i-1].name);
        }
        return (w_ruleTable[i-1].name);
    }

