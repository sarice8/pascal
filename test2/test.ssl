title: 'Schema 1.3 -- Database Schema Compiler -- Aug 24, 1993';
%
%  Schema.ssl
%
%  HISTORY
%    01May91   1.0   First version
%    05May91         Record attribute class
%    30May91   1.1   Added attribute tags
%    09Jun93   1.2   Use schema to define schema.  Construct tree
%                    of all definitions before tables dumped, allowing
%                    late addition of attributes (after other
%                    classes have been derived from this class)
%    24Aug93   1.3   Error if no class specified to receive attribute 
%

input:
	% General

	pINVALID
	pEOF
	pIDENTIFIER

	% Types

        pBoolean1
        pCharacter1
	pInteger4
        pInteger8
        pIntegerN
        pReal4
        pReal8
        pRealN
        pStringN
        pObjectType
	pNode
	pList

	% Option Tags

	pPri
	pAlt
	pOpt
        pInt
        pExt
        pSys
        pTmp

	% keywords

	pSchema
	pRoot
	pIs
	pEnd

	% Punctuation

	pDERIVES    '::='
	pCONTAINS   '=>'
	pCOLON      ':'
	pCOMMA      ','
	pLPAREN     '('
	pRPAREN     ')'
	pLSQUARE    '['
	pRSQUARE    ']'
	;

output:
	;

error:
	eNoClassForAttribute     % attribute defined while no current class set
	;


type node_type:
	nINVALID
	Object
	nSchema
	nClass
	nAttr
	nConstraint
	nAttrSym
        an_alias     = Object
        another_type = 22
	;

type node_attribute:
	qINVALID
	qClassTree
	qAttrSyms
	qIdent
	qCode
	qAttrs
	qDerived
	qAttrSym
	qType
	qConstraint
	qTags
	;


type aType:              % attribute type
	type_INVALID  = 0
	type_Integer4 = 4
	type_Node     = 100
	type_List     = 150
	;

type aTag:               % attribute tags (defined as bits)
	tag_INVALID = 0
	tag_Pri     = 1
	tag_Opt     = 2
	tag_Alt     = 4
	;

type boolean:
	false       = 0
        true        = 1
        yes = true
        no  = false
	;

mechanism Class:		% operations on classes
	oCreateEmptySchema	% create initial schema database, containing a SchemaRoot,
				% nInvalid class, qInvalid attribute symbol,
				% and 'Object' class for basis of all derivation.
	oFindClass		% find class named by last accepted identifier (must exist).
				% Sets the Current class to that class.
	oDeriveClass		% Create new class named by last accepted identifier
				% (must not exist already).  The new object is derived
				% from the Current class (found with oFindClass).
	oThisClassWillGetAttrs	% Sets the GetsAttrs class to the Current class
				% (found with oFindClass).  attrs defined with the
				% Attr mechanism will be added to the GetsAttrs class.
	oNoClassWillGetAttrs	% Sets GetsAttrs to NULL.  No attribute definitions
				% may be added to any class.
	oAClassWillGetAttrs >> int   % Is there a class defined to accept attributes?
        oOpMultParams(node_type, int, boolean) >> int
	;

mechanism Attr:			% operations on attributes
	oCreateAttrSym		% Searches for an nAttrSym with qIdent = the
				% last accepted identifier.
				% If doesn't exist yet, creates one and assigns
				% a new qCode to it (the code for the AttrSym)
				% and appends it to the schema's AttrSyms list.
				% Sets CurrentAttrSym to that AttrSym.

	oCreateAttr		% create new attribute.
				% Sets qAttrSym to CurrentAttrSym (found/created.
				% by oCreateAttrSym).
				% Sets CurrentAttr to that attribute.
	oAttrType (aType)	% Sets the type of the CurrentAttr
	oAttrTag (aTag)		% Sets a tag in the CurrentAttr.  Tag bits are 'or'd together.
	;

mechanism doc:
	oDocDumpTable     % dump results

   oMyOp (in int p1, out int p2)
   p1 (boolean proceed, out boolean status) >> int
	;


rules

main:
    @Schema;



schema_header:
	pSchema
	pIDENTIFIER    % name of schema
	pRoot
	pIDENTIFIER    % name of root object
	pIs
	;


class_derivation:
	oFindClass
	pIDENTIFIER
	oDeriveClass

	oNoClassWillGetAttrs	% disallow attribute definitions for now
	;

attribute_assignment:
	oFindClass
	oThisClassWillGetAttrs
	;

attribute_definition (int a, out int b, inout boolean c):

        int  local, another_local, third_local

        [ oOpMultParams(an_alias, -3, yes)
	    | 55:
	    | 100:  #eNoClassForAttribute     % attribute defined while no current class set
	]

        oMyOp (1, b)
        oMyOp (another_local, b)

        [ local
            | 10 :
            | * :
        ]

	oCreateAttrSym
	oCreateAttr
	
	[
            | pBoolean1, pCharacter1, pInteger4, pInteger8, pIntegerN,
              pReal4, pReal8, pRealN, pStringN, pObjectType :
                           oAttrType (type_Integer4)
	    | pList :      oAttrType (type_List)
	    | pNode :      oAttrType (type_Node)
	]

	[
	    | '(' :  pIDENTIFIER    % constraint ignored for now
                     ')'
	    | * :
	]

	[
	    | '[' :  {[
	                 | pPri :  oAttrTag (tag_Pri)
	                 | pAlt :  oAttrTag (tag_Alt)
	                 | pOpt :  oAttrTag (tag_Opt)
	                 | ',' :
	                 | * :    >
	             ]}
	             ']'
	    | * :
	]
	;

Schema:
        int     count
        boolean status

        status = true
        count  = -10

	oCreateEmptySchema

	@schema_header

	{
	    [ | pEnd, pEOF : > | * : ]

	    pIDENTIFIER
	    [
		| '::=' :	@class_derivation

		| '=>' :	@attribute_assignment

		| ':' :		@attribute_definition (1, count, status)
	    ]
	}

	oDocDumpTable

        oMyOp (p1(yes, status), count)

   % oMyOp (in int p1, out int p2)
   % p1 (boolean proceed, out boolean status) >> int

	;

end

