   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1480:    ;
      
      
1480: ProcHeaderDecl >> Node:
1482:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1484:    boolean redeclaring = false
1490:    Node decl = oScopeFindInCurrentScope
      
1495:    [ oNodeNull( decl )
1502:       | true :
               % first declaration
1503:          decl = @newIdent( nProc, LAST_ID )
1516:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1527:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1529:          redeclaring = true
1535:          [ oNodeGetBoolean( decl, qBodyDefined )
1545:             | true : #eAlreadyDefined
1548:             | * :
1553:          ]
1553:          [ oNodeGetBoolean( decl, qExternal )
1563:             | true : #eAlreadyDefined
1566:             | * :
1571:          ]
1571:          [ oNodeType( decl )
1578:             | nProc :
1579:             | * : #eAlreadyDefined   % wrong kind
1586:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1586:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1605:          oNodeSet( decl, qParams, Null )
1617:    ]
      
1625:    int level = @ScopeLevel
1631:    boolean nested = greater( level, 0 )
1644:    inc( level )
1650:    oScopeBegin( level, allocUp )
1659:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1664:    [ nested
1667:       | true :
1668:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1683:       | * :
1688:    ]
      
1688:    @FormalArgDecl
1690:    oNodeSet( decl, qParams, paramScope )
1702:    oScopeEnd
1703:    ';'
      
1705:    [ redeclaring
1708:       | false : oScopeDeclare( decl )
1715:       | true :  % TO DO: check that qParams is consistent with qOldParams
1717:    ]
      
1725:    @MethodModifiers( decl )
1732:    >> decl;
      
      
1736: ProcDecl:
1738:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1744:    [
1744:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1746:       | pExternal : @ExternalDecl( decl )
      
1755:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1762:          Node paramScope = oNodeGet( decl, qParams )
1775:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1781:          int level = oNodeGetInt( paramScope, qLevel )
1794:          oScopeBegin( level, allocDown )
1803:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1814:          Label label = oNodeGetLabel( decl, qValue )
1827:          @Block( nLocalVar, label )
1837:          oNodeSetBoolean( decl, qBodyDefined, true )
1849:          oScopeEnd
      
1850:          oScopeEnd  % paramScope
1851:    ]
1851:    ';';
      
      
      
1854: FuncHeaderDecl >> Node:
1856:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1858:    boolean redeclaring = false
1864:    Node decl = oScopeFindInCurrentScope
      
1869:    [ oNodeNull( decl )
1876:       | true :
               % first declaration
1877:          decl = @newIdent( nFunc, LAST_ID )
1890:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1901:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1903:          redeclaring = true
1909:          [ oNodeGetBoolean( decl, qBodyDefined )
1919:             | true : #eAlreadyDefined
1922:             | * :
1927:          ]
1927:          [ oNodeType( decl )
1934:             | nFunc :
1935:             | * : #eAlreadyDefined   % wrong kind
1942:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1942:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1961:          oNodeSet( decl, qParams, Null )
1973:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1992:          oNodeSet( decl, qType, Null )
2004:    ]
      
2012:    int level = @ScopeLevel
2018:    boolean nested = greater( level, 0 )
2031:    inc( level )
2037:    oScopeBegin( level, allocUp )
2046:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2051:    [ nested
2054:       | true :
2055:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2070:       | * :
2075:    ]
      
2075:    @FormalArgDecl
2077:    oNodeSet( decl, qParams, paramScope )
      
2089:    ':'
      
2091:    Node theType
2091:    @TypeRef( theType )
2098:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2110:    Node ptrType = @PointerTypeTo( theType )
2121:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2137:    oScopeEnd
2138:    ';'
      
2140:    [ redeclaring
2143:       | false : oScopeDeclare( decl )
2150:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2152:    ]
      
2160:    @MethodModifiers( decl )
      
2167:    >> decl;
      
      
2171: FuncDecl:
2173:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2179:    [
2179:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2181:       | pExternal : @ExternalDecl( decl )
      
2190:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2197:          Node paramScope = oNodeGet( decl, qParams )
2210:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2216:          int level = oNodeGetInt( paramScope, qLevel )
2229:          oScopeBegin( level, allocDown )
2238:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2249:          Label label = oNodeGetLabel( decl, qValue )
2262:          @Block( nLocalVar, label )
2272:          oNodeSetBoolean( decl, qBodyDefined, true )
2284:          oScopeEnd
      
2285:          oScopeEnd  % paramScope
2286:    ]
2286:    ';';
      
      
2289: FormalArgDecl:
2291:    [
2291:       | '(' :
2293:          {
2293:             NodeVec decls = oNodeVecNew
2298:             Node decl
2298:             boolean isInOut = false
      
2304:             [
2304:                | pVar : isInOut = true
2312:                | * :
2317:             ]
      
2317:             {  pIdent
      
2319:                decl = @newIdent( nParam, LAST_ID )
2332:                oNodeSetBoolean( decl, qInOut, isInOut )
2344:                oNodeVecAppend( decls, decl )
      
2353:                [
2353:                   | ':' : >
2357:                   | ',' :
2359:                ]
2367:             }
      
2369:             Node theType
2369:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2376:             Node allocType
2376:             [ isInOut
2379:                | true :   allocType = @PointerTypeTo( theType )
2391:                | * :      allocType = theType
2402:             ]
      
2402:             int i = 0
2408:             {[ equal( i, oNodeVecSize( decls ) )
2422:                | false :
2423:                   decl = oNodeVecElement( decls, i )
      
2436:                   oNodeSet( decl, qType, theType )
2448:                   oScopeDeclare( decl )
2454:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2470:                   inc( i )
2476:                | * :
2481:                   >
2483:             ]}
      
2485:             oNodeVecDelete( decls )
      
2491:             [
2491:                | ')' : >
2495:                | ';' :
2497:             ]
2505:          }
2507:       | * :
2512:    ];
      
      
2513: ConstDecl:
2515:    {[
2515:       | pIdent :
2517:          [
2517:             | ':' :
2519:                @TypedConstDecl
2521:             | * :
2526:                @TrueConstDecl
2528:          ]
2528:       | * :
2533:          >
2535:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2538: TrueConstDecl:
2540:    int id = LAST_ID
2545:    '='
      
2547:    @ConstExpr
      
2549:    Node decl
2549:    [ oTypeSNodeType
2551:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2552:         nPointerType, nUniversalPointerType :
2552:          decl = @newIdent( nConst, id )
2566:          oNodeSetInt( decl, qValue, oValueTop )
2577:       | nStrLitType :
2579:          decl = @newIdent( nConstStr, id )
2593:          oNodeSetString( decl, qValueStr, oValueTopString )
2604:       | * :  #eNotAllowed
2625:    ]
2625:    oValuePop
2626:    oNodeSet( decl, qType, oTypeSTop )
2637:    oTypeSPop
2638:    oScopeDeclare( decl )
2644:    ';'
2647:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2647: TypedConstDecl:
2649:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2662:    Node theType
2662:    @TypeRef( theType )
2669:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2681:    [ oNodeType( theType )
2688:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2689:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2689:          '='
      
2691:          oTypeSPush( theType )
2697:          @ConstExpr
2699:          @ConstCoerceType
      
2701:          oNodeSetInt( decl, qValue, oValueTop )
2712:          oValuePop
2713:          oTypeSPop
2714:          oScopeDeclare( decl )
2720:          ';'
      
2722:       | nShortStringType, nFileType :
2724:          #eNotImplemented
      
2726:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2728:          oScopeEnter( globalScope )
2734:          int addr = oScopeAllocType( theType )
2744:          oScopeEnd
2745:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2756:          oNodeSetInt( decl, qValue, addr )
2768:          '='
2770:          @TypedConstInit( theType, addr )
2780:          oCodePop
2781:          oScopeDeclare( decl )
2787:          ';'
2789:    ]
2816:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2816: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2818:    [ oNodeType( theType )
2825:       | nArrayType :
2826:          Node baseType = oNodeGet( theType, qBaseType )
2839:          Node indexType = oNodeGet( theType, qIndexType )
2852:          int low = @OrdinalLow( indexType )
2863:          int high = @OrdinalHigh( indexType )
2874:          int elementSize = oNodeGetInt( baseType, qSize )
      
2887:          '('
               % Loop over elements
2889:          int i = low
2895:          {
2895:             @TypedConstInit( baseType, addr )
2905:             [ equal( i, high )
2915:                | true : >
2918:                | false :
2920:             ]
2928:             ','
2930:             addr = add( addr, elementSize )
2943:             inc( i )
2949:          }
2951:          ')'
      
2953:       | nRecordType :
2955:          '('
2957:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2970:          {
2970:             [
2970:                | pIdent :
2972:                | * :  >
2979:             ]
2979:             Node field = oScopeFindRequireInScope( fieldScope )
2989:             ':'
2991:             Node fieldType = oNodeGet( field, qType )
3004:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3024:             @TypedConstInit( fieldType, fieldAddr )
3034:             [
3034:                | ';' :
3036:                | * :  >
3043:             ]
3043:          }
3045:          ')'
      
3047:       | nBooleanType, nByteType, nCharType:
3049:          .tPushAddrGlobal  oEmitInt( addr )
3057:          oTypeSPush( theType )
3063:          @ConstExpr
3065:          @ConstCoerceType
3067:          .tPushConstI  oEmitInt( oValueTop )
3074:          oValuePop
3075:          oTypeSPop
3076:          .tAssignB
      
3078:       | nIntegerType, nEnumType:
3080:          .tPushAddrGlobal  oEmitInt( addr )
3088:          oTypeSPush( theType )
3094:          @ConstExpr
3096:          @ConstCoerceType
3098:          .tPushConstI  oEmitInt( oValueTop )
3105:          oValuePop
3106:          oTypeSPop
3107:          .tAssignI
      
3109:       | nPointerType, nUniversalPointerType :
3111:          .tPushAddrGlobal  oEmitInt( addr )
3119:          oTypeSPush( theType )
3125:          @ConstExpr
3127:          @ConstCoerceType
3129:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3136:          oValuePop
3137:          oTypeSPop
3138:          .tAssignP
      
3140:       | nShortStringType, nFileType :
3142:          #eNotImplemented
3144:    ]
3171:    ;
      
      
3171: TypeDecl:
3173:    {[
3173:       | pIdent :
3175:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3188:          '='
3190:          Node theType
3190:          @TypeRef( theType )
3197:          oNodeSet( decl, qType, theType )
3209:          oScopeDeclare( decl )
3215:          ';'
3217:       | * :
3222:          >
3224:    ]};
      
3227: VarDecl( node_type varNodeType ):
3229:    {[
3229:       | pIdent :
3231:          NodeVec decls = oNodeVecNew
3236:          Node decl
3236:          {
3236:             decl = @newIdent( varNodeType, LAST_ID )
3249:             oNodeVecAppend( decls, decl )
3258:             [
3258:                | ',' :
3260:                   pIdent
3262:                | * :
3267:                   >
3269:             ]
3269:          }
3271:          ':'
3273:          Node theType
3273:          @TypeRef( theType )
      
3280:          int i = 0
3286:          {[ equal( i, oNodeVecSize( decls ) )
3300:             | false :
3301:                decl = oNodeVecElement( decls, i )
3314:                oNodeSet( decl, qType, theType )
3326:                oScopeDeclareAlloc( decl )
3332:                inc( i )
3338:             | * :
3343:               >
3345:          ]}
      
               % optional initialization
3347:          [
3347:             | '=' :
3349:                [ oNodeVecSize( decls )
3356:                   | 1 :
3357:                   | * :  #eOnlyOneVarCanBeInitialized
3364:                ]
      
                     % we need an initCode stream for this scope
3364:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3374:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3380:                boolean changedScope = false
3386:                [ equal_zero( @ScopeLevel )
3393:                   | true : oScopeEnter( initScope )
3400:                            changedScope = true
3406:                   | * :
3411:                ]
                     % generate assignment in initCode stream
3411:                @LValueVar( decl, true )
3421:                @Expr
3423:                @CoerceType
3425:                @Assign
3427:                [ changedScope
3430:                   | true : oScopeEnd
3432:                   | * :
3437:                ]
3437:                oCodePop
                   
3438:             | * :
3443:          ]
      
3443:          oNodeVecDelete( decls )
3449:          ';'
3451:       | * :
3456:          >
3458:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3461: LabelDecl:
3463:    {
3463:       Node decl
3463:       [
3463:          | pIdent :
3465:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3467:             oChangeIntLitToLabelIdent
3468:       ]
3476:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3489:       Label label = oLabelNew
3494:       oNodeSetLabel( decl, qValue, label )
3506:       oScopeDeclare( decl )
3512:       [
3512:          | ',' :
3514:          | * :
3519:             >
3521:       ]
3521:    }
3523:    ';'
3526:    ;
3526: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3526: ConstExpr:
3528:    @ConstBoolExpr
3530:    {[
3530:       | '=' :
3532:          @ConstBoolTerm
3534:          @ConstMatchTypes
3536:          [ oTypeSNodeType
3538:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3547:             | * :             oValueEqual
3553:          ]
3553:          oTypeSPop  oTypeSPush( BooleanType )
3560:       | '<>' :
3562:          @ConstBoolExpr
3564:          @ConstMatchTypes
3566:          [ oTypeSNodeType
3568:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3577:             | * :             oValueNotEqual
3583:          ]
3583:          oTypeSPop  oTypeSPush( BooleanType )
3590:       | '<' :
3592:          @ConstBoolExpr
3594:          @ConstMatchTypes
3596:          [ oTypeSNodeType
3598:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3607:             | * :             oValueLess
3613:          ]
3613:          oTypeSPop  oTypeSPush( BooleanType )
3620:       | '>' :
3622:          @ConstBoolExpr
3624:          @ConstMatchTypes
3626:          [ oTypeSNodeType
3628:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3637:             | * :             oValueGreater
3643:          ]
3643:          oTypeSPop  oTypeSPush( BooleanType )
3650:       | '<=' :
3652:          @ConstBoolExpr
3654:          @ConstMatchTypes
3656:          [ oTypeSNodeType
3658:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3667:             | * :             oValueLessEqual
3673:          ]
3673:          oTypeSPop  oTypeSPush( BooleanType )
3680:       | '>=' :
3682:          @ConstBoolExpr
3684:          @ConstMatchTypes
3686:          [ oTypeSNodeType
3688:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3697:             | * :             oValueGreaterEqual
3703:          ]
3703:          oTypeSPop  oTypeSPush( BooleanType )
3710:       | * :  >
3727:    ]};
      
      
3730: ConstBoolExpr:
3732:    @ConstBoolTerm
3734:    {[
3734:       | pOr :
3736:          @ConstRequireBool
3738:          @ConstBoolTerm
3740:          @ConstRequireBoolPop
3742:          oValueOr
3743:       | * :  >
3750:    ]};
      
      
3753: ConstBoolTerm:
3755:    @ConstBoolFactor
3757:    {[
3757:       | pAnd :
3759:          @ConstRequireBool
3761:          @ConstBoolFactor
3763:          @ConstRequireBoolPop
3765:          oValueAnd
3766:       | * :  >
3773:    ]};
      
      
3776: ConstBoolFactor:
3778:    [
3778:       | pNot :
3780:          @ConstBoolFactor
3782:          @ConstRequireBool
3784:          oValueNot
3785:       | * :
3790:          @ConstArithExpr
3792:    ];
      
      
3793: ConstArithExpr:
3795:    @ConstTerm
3797:    {[
3797:       | '+' :
3799:          @ConstTerm
3801:          @ConstMatchTypes
3803:          [ oTypeSNodeType
3805:             | nStrLitType :   oValueStringConcat
3807:             | * :             oValueAdd
3813:          ]
3813:       | '-' :
3815:          @ConstTerm
3817:          @ConstMatchTypes
3819:          [ oTypeSNodeType
3821:             | nStrLitType :   #eNotAllowed
3824:             | * :             oValueSub
3830:          ]
3830:       | * :  >
3839:    ]};
      
      
3842: ConstTerm:
3844:    @ConstFactor
3846:    {[
3846:       | pTimes :
3848:          @ConstFactor
3850:          @ConstMatchTypes
3852:          [ oTypeSNodeType
3854:             | nStrLitType :   #eNotAllowed
3857:             | * :             oValueMult
3863:          ]
3863:       | pDivide :
3865:          @ConstFactor
3867:          @ConstMatchTypes
3869:          [ oTypeSNodeType
3871:             | nStrLitType :   #eNotAllowed
3874:             | * :             oValueDiv
3880:          ]
3880:       | * :  >
3889:    ]};
      
      
3892: ConstFactor:
3894:    [
3894:       | pPlus :
3896:          @ConstPrimary
3898:       | pMinus :
3900:          @ConstPrimary
3902:          oValueNegate
3903:       | * :
3910:          @ConstPrimary
3912:    ];
      
      
3913: ConstPrimary:
3915:    [
3915:       | pIntLit :
3917:          oValuePush( TOKEN_VALUE )
3922:          oTypeSPush( IntegerType )
3928:       | pCharLit :
3930:          oValuePush( TOKEN_VALUE )
3935:          oTypeSPush( CharType )
3941:       | pStrLit :
3943:          oValuePushString( CURRENT_STRLIT )
3948:          oTypeSPush( StrLitType )
3954:       | '(' :
3956:          @ConstExpr
3958:          ')'
3960:       | pIdent :
3962:          Node decl = oScopeFindRequire
3967:          @ResolveUnitRef( decl )
3974:          [ oNodeType( decl )
3981:             | nBuiltInFunc :
3982:                @ConstBuiltInFunc( decl )
3989:             | nConst :
3991:                oValuePush( oNodeGetInt( decl, qValue ) )
4004:                oTypeSPush( oNodeGet( decl, qType ) )
4017:             | nConstStr :
4019:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4032:                oTypeSPush( oNodeGet( decl, qType ) )
4045:             | nEnumValue :
4047:                oValuePush( oNodeGetInt( decl, qValue ) )
4060:                oTypeSPush( oNodeGet( decl, qType ) )
4073:             | * :
4084:                #eNotConst
4086:                oValuePush( 0 )
4092:                oTypeSPush( IntegerType )
4098:          ]
4098:       | '@' :
4100:          #eNotImplemented
4102:          oValuePush( 0 )
4108:          oTypeSPush( UniversalPointerType )
4114:       | * :
4129:          #eNotConst
4131:          oValuePush( 0 )
4137:          oTypeSPush( IntegerType )
4143:    ];
      
4144: ConstRequireBoolPop:
4146:    [ oTypeSNodeType
4148:       | nBooleanType :
4149:       | * :          #eNotBoolean
4156:    ]
4156:    oTypeSPop;
      
      
4158: ConstRequireBool:
4160:    [ oTypeSNodeType
4162:       | nBooleanType :
4163:       | * :          #eNotBoolean
4170:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4171: ConstMatchTypes:
4173:    node_type nt = oTypeSNodeType
4178:    oTypeSPop
4179:    [ equal_node_type( nt, oTypeSNodeType )
4188:       | false :
               % Some implicit conversion is allowed even here
4189:          [ oTypeSNodeType
4191:             | nPointerType :
4192:                [ nt
4195:                   | nUniversalPointerType :  >>
4197:                   | * :
4202:                ]
4202:             | nUniversalPointerType :
4204:                [ nt
4207:                   | nPointerType :  >>
4209:                   | * :
4214:                ]
4214:             | nStrLitType :
4216:                [ nt
4219:                   | nCharType :
4220:                      oValueCharToString
4221:                      >>
4222:                   | * :
4227:                ]
4227:             | nCharType :
4229:                [ nt
4232:                   | nStrLitType :
4233:                      oValueSwap
4234:                      oValueCharToString
4235:                      oValueSwap
4236:                      oTypeSPop
4237:                      oTypeSPush( StrLitType )
4243:                      >>
4244:                   | * :
4249:                ]
4249:             | * :
4260:          ]
4260:          #eTypeMismatch
4262:       | * :
4267:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4268: ConstCoerceType:
4270:    node_type nt = oTypeSNodeType
4275:    oTypeSPop
4276:    [ equal_node_type( nt, oTypeSNodeType )
4285:       | false :
               % Can we implicitly convert the value to the desired type?
4286:          [ oTypeSNodeType
4288:             | nIntegerType :
4289:                [ nt
4292:                   | nByteType :  >>
4294:                   | * :
4299:                ]
4299:             | nByteType :
4301:                [ nt
4304:                   | nIntegerType :  >>
4306:                   | * :
4311:                ]
4311:             | nPointerType :
4313:                [ nt
4316:                   | nUniversalPointerType :  >>
4318:                   | * :
4323:                ]
4323:             | nUniversalPointerType :
4325:                [ nt
4328:                   | nPointerType :  >>
4330:                   | * :
4335:                ]
4335:             | nStrLitType :
4337:                [ nt
4340:                   | nCharType :
4341:                      oValueCharToString
4342:                      >>
4343:                   | * :
4348:                ]
4348:             | nShortStringType :
4350:                [ nt
4353:                   | nStrLitType :  >>
4355:                   | nCharType :
4357:                      oValueCharToString
4358:                      >>
4359:                   | * :
4366:                ]
4366:             | * :
4381:          ]
4381:          #eTypeMismatch
4383:       | * :
4388:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4389: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4391:    [ oNodeEqual( method, BuiltIn_Ord )
4401:       | true :
4402:          '('
4404:          @ConstExpr
4406:          ')'
4408:          [ oTypeSNodeType
4410:             | nIntegerType, nEnumType :
4411:             | nBooleanType, nByteType, nCharType :
4413:             | * :  #eTypeMismatch
4428:          ]
4428:          oTypeSPop
4429:          oTypeSPush( IntegerType )
4435:          ')'
4437:          >>
4438:       | * :
4443:    ]
      
         % Chr(x)
4443:    [ oNodeEqual( method, BuiltIn_Chr )
4453:       | true :
4454:          '('
4456:          @ConstExpr
4458:          ')'
4460:          [ oTypeSNodeType
4462:             | nIntegerType :
4463:             | nByteType :
4465:             | * :  #eTypeMismatch
4474:          ]
4474:          oTypeSPop
4475:          oTypeSPush( CharType )
4481:          ')'
4483:          >>
4484:       | * :
4489:    ]
      
         % Pred(x)
4489:    [ oNodeEqual( method, BuiltIn_Pred )
4499:       | true :
4500:          '('
4502:          @ConstExpr
4504:          [ oTypeSNodeType
4506:             | nEnumType :
4507:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4516:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4519:                   | * :
4524:                ]
4524:             | * :  #eTypeMismatch
4531:          ]
4531:          oValuePush( 1 )  oValueSub
4538:          ')'
4540:          >>
4541:       | * :
4546:    ]
      
         % Succ(x)
4546:    [ oNodeEqual( method, BuiltIn_Succ )
4556:       | true :
4557:          '('
4559:          @ConstExpr
4561:          [ oTypeSNodeType
4563:             | nEnumType :
4564:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4573:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4576:                   | * :
4581:                ]
4581:             | * :  #eTypeMismatch
4588:          ]
4588:          oValuePush( 1 )  oValueAdd
4595:          ')'
4597:          >>
4598:       | * :
4603:    ]
      
4603:    #eNotImplemented
4606:    ;
      
      
4606: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4606: Expr:
4608:    Label falseLabel = labelNull
      
4614:    @ExprAllowFlow( falseLabel )
4621:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4629: BooleanExprControlFlow( out Label falseLabel ):
4631:    @ExprAllowFlow( falseLabel )
4638:    [ oTypeSNodeType
4640:       | nBooleanFlowType :
4641:       | nBooleanType :
               % convert value to control flow
4643:          falseLabel = oLabelNew
4648:          .tJumpFalse  oEmitLabel( falseLabel )
4656:       | * :
4663:          #eNotBoolean
4665:    ]
4665:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4667: FlowToVal( inout Label falseLabel ):
4669:    [ oTypeSNodeType
4671:       | nBooleanFlowType :
4672:          Label doneLabel = oLabelNew
4677:          .tPushConstI  oEmitInt( 1 )
4685:          .tJump  oEmitLabel( doneLabel )
4693:          .tLabel  oEmitLabel( falseLabel )
4701:          .tPushConstI  oEmitInt( 0 )
4709:          .tLabel  oEmitLabel( doneLabel )
4717:          oTypeSPop
4718:          oTypeSPush( BooleanType )
4724:          falseLabel = labelNull
4730:       | * :
4735:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4736: ValToFlow( out Label falseLabel ):
4738:    [ oTypeSNodeType
4740:       | nBooleanType :
4741:          falseLabel = oLabelNew
4746:          .tJumpFalse  oEmitLabel( falseLabel )
4754:          oTypeSPop
4755:          oTypeSPush( BooleanFlowType )
4761:       | * :
4766:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4767: ExprAllowFlow( out Label falseLabel ):
4769:    @BoolExprAllowFlow( falseLabel )
4776:    {[
4776:       | '=' :
4778:          @FlowToVal( falseLabel )
4785:          @PromoteToIntOptional
4787:          @BoolExprAllowFlow( falseLabel )
4794:          @FlowToVal( falseLabel )
4801:          @PromoteToIntOptional
4803:          @MatchTypes
4805:          [ oTypeSNodeType
4807:             | nBooleanType, nCharType :     .tEqualB
4810:             | nIntegerType, nEnumType :     .tEqualI
4814:             | nPointerType, nUniversalPointerType :    .tEqualP
4818:             | nShortStringType, nStrLitType :
4820:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
4832:             | * :                           #eNotAllowed
4853:          ]
4853:          oTypeSPop
4854:          oTypeSPush( BooleanType )
      
4860:       | '<>' :
4862:          @FlowToVal( falseLabel )
4869:          @PromoteToIntOptional
4871:          @BoolExprAllowFlow( falseLabel )
4878:          @FlowToVal( falseLabel )
4885:          @PromoteToIntOptional
4887:          @MatchTypes
4889:          [ oTypeSNodeType
4891:             | nBooleanType, nCharType :     .tNotEqualB
4894:             | nIntegerType, nEnumType :     .tNotEqualI
4898:             | nPointerType, nUniversalPointerType :    .tNotEqualP
4902:             | nShortStringType, nStrLitType :
4904:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
4916:             | * :                           #eNotAllowed
4937:          ]
4937:          oTypeSPop
4938:          oTypeSPush( BooleanType )
      
4944:       | '<' :
4946:          @FlowToVal( falseLabel )
4953:          @PromoteToIntOptional
4955:          @BoolExprAllowFlow( falseLabel )
4962:          @FlowToVal( falseLabel )
4969:          @PromoteToIntOptional
4971:          @MatchTypes
4973:          [ oTypeSNodeType
4975:             | nBooleanType, nCharType :     .tLessB
4978:             | nIntegerType, nEnumType :     .tLessI
4982:             | nPointerType, nUniversalPointerType :   .tLessP
4986:             | nShortStringType, nStrLitType :
4988:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5000:             | * :                           #eNotAllowed
5021:          ]
5021:          oTypeSPop
5022:          oTypeSPush( BooleanType )
      
5028:       | '>' :
5030:          @FlowToVal( falseLabel )
5037:          @PromoteToIntOptional
5039:          @BoolExprAllowFlow( falseLabel )
5046:          @FlowToVal( falseLabel )
5053:          @PromoteToIntOptional
5055:          @MatchTypes
5057:          [ oTypeSNodeType
5059:             | nBooleanType, nCharType :     .tGreaterB
5062:             | nIntegerType, nEnumType :     .tGreaterI
5066:             | nPointerType, nUniversalPointerType :   .tGreaterP
5070:             | nShortStringType, nStrLitType :
5072:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5084:             | * :                           #eNotAllowed
5105:          ]
5105:          oTypeSPop
5106:          oTypeSPush( BooleanType )
      
5112:       | '<=' :
5114:          @FlowToVal( falseLabel )
5121:          @PromoteToIntOptional
5123:          @BoolExprAllowFlow( falseLabel )
5130:          @FlowToVal( falseLabel )
5137:          @PromoteToIntOptional
5139:          @MatchTypes
5141:          [ oTypeSNodeType
5143:             | nBooleanType, nCharType :     .tLessEqualB
5146:             | nIntegerType, nEnumType :     .tLessEqualI
5150:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5154:             | nShortStringType, nStrLitType :
5156:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5168:             | * :                           #eNotAllowed
5189:          ]
5189:          oTypeSPop
5190:          oTypeSPush( BooleanType )
      
5196:       | '>=' :
5198:          @FlowToVal( falseLabel )
5205:          @PromoteToIntOptional
5207:          @BoolExprAllowFlow( falseLabel )
5214:          @FlowToVal( falseLabel )
5221:          @PromoteToIntOptional
5223:          @MatchTypes
5225:          [ oTypeSNodeType
5227:             | nBooleanType, nCharType :     .tGreaterEqualB
5230:             | nIntegerType, nEnumType :     .tGreaterEqualI
5234:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5238:             | nShortStringType, nStrLitType :
5240:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5252:             | * :                           #eNotAllowed
5273:          ]
5273:          oTypeSPop
5274:          oTypeSPush( BooleanType )
      
5280:       | * :
5295:          >
5297:    ]};
      
      
5300: BoolExprAllowFlow( out Label falseLabel ):
5302:    Label trueLabel = labelNull
      
5308:    @BoolTermAllowFlow( falseLabel )
5315:    {[
5315:       | pOr :
5317:          [ oTypeSNodeType
5319:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5320:                [ equal_label( trueLabel, labelNull )
5330:                   | true :  trueLabel = oLabelNew
5336:                   | * :
5341:                ]
5341:                .tJump  oEmitLabel( trueLabel )
5349:             | nBooleanType :
5351:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5358:                [ equal_label( trueLabel, labelNull )
5368:                   | true :  trueLabel = oLabelNew
5374:                   | * :
5379:                ]
5379:                .tJump  oEmitLabel( trueLabel )
5387:             | * : #eNotBoolean
5396:          ]
5396:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5397:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5405:          falseLabel = labelNull
5411:          @BoolTermAllowFlow( falseLabel )
      
5418:          [ oTypeSNodeType
5420:             | nBooleanFlowType :
5421:             | nBooleanType :
5423:                @ValToFlow( falseLabel )
5430:             | * : #eNotBoolean
5439:          ]
      
5439:          oTypeSPop
5440:          oTypeSPush( BooleanFlowType )
      
5446:       | * :
5451:          >
5453:    ]}
      
         % any short-circuit trues jump here to the end
5455:    [ equal_label( trueLabel, labelNull )
5465:       | false :
5466:          .tLabel  oEmitLabel( trueLabel )
5474:       | * :
5479:    ]
5480:    ;
      
      
5480: BoolTermAllowFlow( out Label falseLabel ):
5482:    Label overallFalseLabel = labelNull
      
5488:    @BoolFactorAllowFlow( falseLabel )
5495:    {[
5495:       | pAnd :
5497:          [ oTypeSNodeType
5499:             | nBooleanFlowType :
5500:             | nBooleanType :
5502:                @ValToFlow( falseLabel )
5509:             | * :
5516:                #eNotBoolean
5518:          ]
5518:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5519:          [ equal_label( overallFalseLabel, labelNull )
5529:             | true :
5530:                overallFalseLabel = oLabelNew
5535:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5549:                falseLabel = overallFalseLabel
5555:             | * :
5560:          ]
      
5560:          Label factorFalseLabel = labelNull
5566:          @BoolFactorAllowFlow( factorFalseLabel )
      
5573:          [ oTypeSNodeType
5575:             | nBooleanFlowType :
5576:             | nBooleanType :
5578:                @ValToFlow( factorFalseLabel )
5585:             | * : #eNotBoolean
5594:          ]
5594:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5608:       | * :
5613:          >
5615:    ]};
      
      
5618: BoolFactorAllowFlow( out Label falseLabel ):
5620:    [
5620:       | pNot :
5622:          Label factorFalseLabel = labelNull
      
5628:          @BoolFactorAllowFlow( factorFalseLabel )
5635:          [ oTypeSNodeType
5637:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5638:                falseLabel = oLabelNew
5643:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5651:                .tLabel  oEmitLabel( factorFalseLabel )
      
5659:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5661:                .tNot
      
5663:             | * : #eNotBoolean
5672:          ]
      
5672:       | * :
5677:          @ArithExprAllowFlow( falseLabel )
5684:    ];
      
      
5685: ArithExprAllowFlow( out Label falseLabel ):
5687:    boolean first = true
5693:    int tempStrOffset
      
5693:    @TermAllowFlow( falseLabel )
5700:    {[
5700:       | '+' :
5702:          [ oTypeSNodeType
5704:             | nIntegerType, nByteType :
5705:                @PromoteToIntPop
5707:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5714:                [ oTypeSNodeType
5716:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5717:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5719:                      @PointerAddition
5721:                   | * :
5728:                      @PromoteToInt
5730:                      .tAddI
5732:                ]
      
5732:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5734:                [ first
5737:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5738:                             tempStrOffset = @MoveIntoTempShortString
5744:                             first = false
5750:                   | * :
5755:                ]
5755:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5762:                [ oTypeSNodeType
5764:                   | nShortStringType, nStrLitType :
5765:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5767:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5775:                      oTypeSPush( ShortStringType )
5781:                   | nCharType :
5783:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5785:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5793:                      oTypeSPush( ShortStringType )
5799:                   | * :
5808:                      #eTypeMismatch
5810:                      oTypeSPop
5811:                ]
      
5811:             | nPointerType, nUniversalPointerType :
5813:                @TermAllowFlow( falseLabel )   % actually not allowing CF
5820:                @PromoteToIntPop
5822:                @PointerAddition
      
5824:             | * :
5841:                #eNotAllowed
5843:          ]
      
5843:       | '-' :
5845:          [ oTypeSNodeType
5847:             | nIntegerType, nByteType :
5848:                @PromoteToIntPop
5850:                @TermAllowFlow( falseLabel )
5857:                @PromoteToInt
5859:                .tSubI
      
5861:             | nPointerType, nUniversalPointerType :
5863:                @TermAllowFlow( falseLabel )
5870:                [ oTypeSNodeType
5872:                   | nIntegerType, nByteType :
5873:                      @PromoteToIntPop
5875:                      @PointerSubInt
5877:                   | nPointerType, nUniversalPointerType :
5879:                      @MatchTypes
5881:                      @PointerSubPointer
5883:                   | * :
5894:                      #eNotAllowed
5896:                ]
      
5896:             | * :  #eNotAllowed
      
5909:          ]
5909:       | * :
5916:          >
5918:    ]};
      
      
5921: TermAllowFlow( out Label falseLabel ):
5923:    @FactorAllowFlow( falseLabel )
5930:    {[
5930:       | pTimes :
5932:          @PromoteToIntPop
5934:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5941:          @PromoteToInt
5943:          .tMultI
5945:       | pDivide :
5947:          @PromoteToIntPop
5949:          @FactorAllowFlow( falseLabel )
5956:          @PromoteToInt
5958:          .tDivI
5960:       | * :
5967:          >
5969:    ]};
      
      
5972: FactorAllowFlow( out Label falseLabel ):
5974:    [
5974:       | pPlus :
5976:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5983:          @PromoteToInt
5985:       | pMinus :
5987:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5994:          @PromoteToInt
5996:          .tNegI
5998:       | * :
6005:          @PrimaryAllowFlow( falseLabel )
6012:    ];
      
      
6013: PrimaryAllowFlow( out Label falseLabel ):
6015:    [
6015:       | pIntLit :
6017:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6024:          oTypeSPush( IntegerType )
      
6030:       | pCharLit :
6032:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6039:          oTypeSPush( CharType )
      
6045:       | '(' :
6047:          @ExprAllowFlow( falseLabel )
6054:          ')'
      
6056:       | pStrLit :
6058:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6067:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6075:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6081:          @LValueIndexes
               % get final value of dereferencing, if any
6083:          @FetchVar
      
6085:       | pIdent :
6087:          Node decl = oScopeFindRequire
6092:          @ResolveUnitRef( decl )
6099:          Node theType
      
6099:          [ oNodeType( decl )
6106:             | nFunc :
6107:                @Call( decl )
      
6114:             | nBuiltInFunc :
6116:                @CallBuiltInFunc( decl )
      
6123:             | nConst, nEnumValue :
6125:                theType = oNodeGet( decl, qType )
6138:                oTypeSPush( theType )
6144:                [ oTypeSNodeType
6146:                   | nIntegerType, nEnumType, nBooleanType :
6147:                      .tPushConstI @EmitValue( decl )
6156:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6158:                      .tPushConstI @EmitValue( decl )
6167:                   | * :
6180:                      #eNotImplemented
6182:                ]
      
6182:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6184:                int addr = oNodeGetInt( decl, qValue )
6197:                [ equal_zero( addr )
6204:                   | true :
6205:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6222:                      oNodeSetInt( decl, qValue, addr )
6234:                   | * :
6239:                ]
6239:                .tPushAddrGlobal oEmitInt( addr )
6247:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6253:                @LValueIndexes
                     % get final value of dereferencing, if any
6255:                @FetchVar
      
6257:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6259:                @VarExpr( decl )
      
6266:             | * :
6287:                #eNotValue
6289:                oTypeSPush( IntegerType )
6295:          ]
      
6295:       | '@' :        % @var -- pointer to var
6297:          pIdent
      
6299:          Node decl = oScopeFindRequire
6304:          @ResolveUnitRef( decl )
6311:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6311:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6321:          theType = oTypeSTop
6326:          oTypeSPop
6327:          Node ptrType = @PointerTypeTo( theType )
6338:          oTypeSPush( ptrType )
      
6344:       | * :
6359:          #eNotValue
6361:          oTypeSPush( IntegerType )
6367:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6368: VarExpr( Node decl ):
6370:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6383:    int uplevels = @DeclUpLevels( decl )
      
6394:    oTypeSPush( theType )
6400:    [ oTypeSNodeType
6402:       | nIntegerType, nEnumType :
6403:          [ oNodeType( decl )
6410:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6420:             | nLocalVar :
6422:                [ equal_zero( uplevels )
6429:                   | true :  .tPushLocalI  @EmitValue( decl )
6439:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6459:                ]
6459:             | nParam :
6461:                [ oNodeGetBoolean( decl, qInOut )
6471:                   | true :    % VAR param points to the var.  Auto dereference.
6472:                      [ equal_zero( uplevels )
6479:                         | true :  .tPushParamP  @EmitValue( decl )
6489:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6509:                      ]
6509:                      .tFetchI
6511:                   | * :
6516:                      [ equal_zero( uplevels )
6523:                         | true :  .tPushParamI  @EmitValue( decl )
6533:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6553:                      ]
6553:                ]
6553:          ]
      
6565:       | nBooleanType, nByteType, nCharType :
6567:          [ oNodeType( decl )
6574:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6584:             | nLocalVar :
6586:                [ equal_zero( uplevels )
6593:                   | true :  .tPushLocalB  @EmitValue( decl )
6603:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6623:                ]
6623:             | nParam :
6625:                [ oNodeGetBoolean( decl, qInOut )
6635:                   | true :    % VAR param points to the var.  Auto dereference.
6636:                      [ equal_zero( uplevels )
6643:                         | true :  .tPushParamP  @EmitValue( decl )
6653:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6673:                      ]
6673:                      .tFetchB
6675:                   | * :
6680:                      [ equal_zero( uplevels )
6687:                         | true :  .tPushParamB  @EmitValue( decl )
6697:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6717:                      ]
6717:                ]
6717:          ]
      
6729:       | nFileType :
6731:          #eNotImplemented
      
6733:       | nPointerType, nUniversalPointerType :
6735:          [ oNodeType( decl )
6742:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6752:             | nLocalVar :
6754:                [ equal_zero( uplevels )
6761:                   | true :  .tPushLocalP  @EmitValue( decl )
6771:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6791:                ]
6791:             | nParam :
6793:                [ oNodeGetBoolean( decl, qInOut )
6803:                   | true :    % VAR param points to the var.  Auto dereference.
6804:                      [ equal_zero( uplevels )
6811:                         | true :  .tPushParamP  @EmitValue( decl )
6821:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6841:                      ]
6841:                      .tFetchP
6843:                   | * :
6848:                      [ equal_zero( uplevels )
6855:                         | true :  .tPushParamP  @EmitValue( decl )
6865:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6885:                      ]
6885:                ]               
6885:          ]
6897:          [
6897:             | '^' :             % dereferenced
6899:                oTypeSPop
6900:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6913:                @LValueIndexes
6915:                @FetchVar
6917:             | '[' :             % dereferencing pointer like an array [0..] of baseType
6919:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
6921:                @LValueIndexes
6923:                @FetchVar
6925:             | * :               % just ptr value alone
6932:          ]
      
6932:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
6934:          [ oNodeType( decl )
6941:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6951:             | nLocalVar :
6953:                [ equal_zero( uplevels )
6960:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6970:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6990:                ]
6990:             | nParam :
6992:                [ oNodeGetBoolean( decl, qInOut )
7002:                   | true :    % VAR param points to the var.  Auto dereference.
7003:                      [ equal_zero( uplevels )
7010:                         | true :  .tPushParamP  @EmitValue( decl )
7020:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7040:                      ]
7040:                   | * :
7045:                      [ equal_zero( uplevels )
7052:                         | true :  .tPushAddrParam  @EmitValue( decl )
7062:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7082:                      ]
7082:                ]
7082:          ]
               % modify addr for subscripts, field references, etc
7094:          @LValueIndexes
               % get final value
7096:          @FetchVar
7098:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7125: FetchVar:
7127:    [ oTypeSNodeType
7129:       | nIntegerType, nEnumType :  .tFetchI
7132:       | nBooleanType, nByteType, nCharType :  .tFetchB
7136:       | nFileType :   #eNotImplemented
7140:       | nPointerType :             .tFetchP
7144:       | nUniversalPointerType :    #eCantDereference
7148:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7150:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7179: LValueIndexes:
7181:    {[
7181:       | '[' :
7183:          [ oTypeSNodeType
7185:             | nArrayType :    @ArraySubscripts
7188:             | nPointerType :  @PointerArraySubscript
7192:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7196:             | * :             #eNotArray
7209:          ]
7209:       | '.' :       @RecordFieldRef
7213:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7217:       | * :         >
7228:    ]};
      
      
7231: ArraySubscripts:
7233:    [ oTypeSNodeType
7235:       | nArrayType :
7236:       | * :       #eNotArray
7243:    ]
7243:    {
7243:       [ oTypeSNodeType
7245:          | nArrayType :
7246:          | * :    #eTooManySubscripts
7253:       ]
      
            % low subscript of this dimension
7253:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7270:       Node baseType
7270:       baseType = oNodeGet( oTypeSTop, qBaseType )
7282:       oTypeSPop
7283:       oTypeSPush( baseType )
      
7289:       @Expr
7291:       @RequireIntPop
            % adjust for low subscript
7293:       [ equal_zero( low )
7300:          | false :
7301:             .tPushConstI oEmitInt( low ) .tSubI
7311:          | * :
7316:       ]
      
            % multiply by element size
7316:       int size = oNodeGetInt( baseType, qSize )
7329:       [ equal( size, 1 )
7339:          | false :
7340:             .tPushConstI oEmitInt( size ) .tMultI
7350:          | * :
7355:       ]
      
            % update start address
7355:       .tAddPI
7357:       [
7357:          | ']' :  >
7361:          | ',' :
7363:       ]
7371:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7374: PointerArraySubscript:
7376:    [ oTypeSNodeType
7378:       | nPointerType :
7379:       | * :    #eCantDereference
7386:    ]
         % replace type stack with base type
7386:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7398:    oTypeSPop
7399:    oTypeSPush( baseType )
         
7405:    @Expr
7407:    @RequireIntPop
         % multiply by element size
7409:    int size = oNodeGetInt( baseType, qSize )
7422:    [ equal( size, 1 )
7432:       | false :
7433:          .tPushConstI  oEmitInt( size )  .tMultI
7443:       | * :
7448:    ]
         % update start address
7448:    .tAddPI
7450:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7453: ShortStringArraySubscript:
7455:    [ oTypeSNodeType
7457:       | nStrLitType, nShortStringType :
7458:       | * :    #eCantDereference
7467:    ]
7467:    oTypeSPop
7468:    oTypeSPush( CharType )
7474:    @Expr
7476:    @RequireIntPop
7478:    .tAddPI
7480:    ']';
      
      
7483: RecordFieldRef:
7485:    [ oTypeSNodeType
7487:       | nRecordType :
7488:       | * :    #eNotRecord
7495:    ]
7495:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7507:    pIdent
7509:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7514:    [ oNodeType( field )
7521:       | nRecordField :
7522:       | * :   #eNotRecordField
7529:    ]
7529:    oScopeEnd
7530:    int offset = oNodeGetInt( field, qValue )
7543:    [ equal_zero( offset )
7550:       | false :
7551:          .tPushConstI oEmitInt( offset ) .tAddPI
7561:       | * :
7566:    ]
      
         % replace the type on the type stack, with the field type
7566:    oTypeSPop
7567:    oTypeSPush( oNodeGet( field, qType ) )
7581:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7581: PointerAddition:
7583:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7595:    int elementSize = oNodeGetInt( elementType, qSize )
7608:    [ equal( elementSize, 1 )
7618:       | false :
7619:          .tPushConstI  oEmitInt( elementSize )
7627:          .tMultI
7629:       | * :
7634:    ]
7634:    .tAddPI
7637:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7637: PointerSubInt:
7639:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7651:    int elementSize = oNodeGetInt( elementType, qSize )
7664:    [ equal( elementSize, 1 )
7674:       | false :
7675:          .tPushConstI  oEmitInt( elementSize )
7683:          .tMultI
7685:       | * :
7690:    ]
7690:    .tSubPI
7693:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7693: PointerSubPointer:
7695:    .tSubP
7697:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7709:    int elementSize = oNodeGetInt( elementType, qSize )
7722:    [ equal( elementSize, 1 )
7732:       | false :
7733:          .tPushConstI  oEmitInt( elementSize )
7741:          .tDivI
7743:       | * :
7748:    ]
7748:    oTypeSPop
7749:    oTypeSPush( IntegerType )
7756:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7756: PointerDeref:
7758:    [ oTypeSNodeType
7760:       | nPointerType :
7761:       | nUniversalPointerType :   #eCantDereference
7765:       | * :       #eNotPointer
7774:    ]
7774:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7776:    Node theType = oTypeSTop
7781:    oTypeSPop
7782:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7796:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7796: CoerceType:
7798:    node_type nt = oTypeSNodeType
7803:    oTypeSPop
7804:    [ equal_node_type( nt, oTypeSNodeType )
7813:       | false :
               % Can we implicitly convert the value to the desired type?
7814:          [ oTypeSNodeType
7816:             | nIntegerType :
7817:                [ nt
7820:                   | nByteType :   .tCastBtoI  >>
7824:                   | * :
7829:                ]
7829:             | nByteType :
7831:                [ nt
7834:                   | nIntegerType :   .tCastItoB  >>
7838:                   | * :
7843:                ]
7843:             | nPointerType :
7845:                [ nt
7848:                   | nUniversalPointerType :  >>
7850:                   | nStrLitType :
7852:                      [ equal_node( oTypeSTop, PCharType )
7861:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7862:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7873:                         | * :
7878:                      ]
7878:                   | * :
7885:                ]
7885:             | nUniversalPointerType :
7887:                [ nt
7890:                   | nPointerType :  >>
7892:                   | * :
7897:                ]
7897:             | nShortStringType :
7899:                [ nt
7902:                   | nStrLitType :  >>
7904:                   | nCharType :
                           % Store char as a temp ShortString.
7906:                      oTypeSPush( CharType )
7912:                      int tempOffset = @MoveIntoTempShortString
7918:                      oTypeSPop
7919:                      >>
7920:                   | * :
7927:                ]
7927:             | * :
7940:          ]
7940:          #eTypeMismatch
7942:       | * :
7947:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7948: MatchTypes:
7950:    node_type nt = oTypeSNodeType
7955:    oTypeSPop
7956:    [ equal_node_type( nt, oTypeSNodeType )
7965:       | false :
               % Some implicit conversion is allowed even here
7966:          [ oTypeSNodeType
7968:             | nPointerType :
7969:                [ nt
7972:                   | nUniversalPointerType :  >>
7974:                   | * :
7979:                ]
7979:             | nUniversalPointerType :
7981:                [ nt
7984:                   | nPointerType :  >>
7986:                   | * :
7991:                ]
7991:             | * :
7998:          ]
7998:          #eTypeMismatch
8000:       | * :
8005:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8006: RequireIntPop:
8008:    [ oTypeSNodeType
8010:       | nIntegerType :
8011:       | * :          #eNotInteger
8018:    ]
8018:    oTypeSPop;
      
8020: RequireInt:
8022:    [ oTypeSNodeType
8024:       | nIntegerType :
8025:       | * :          #eNotInteger
8032:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8033: PromoteToIntPop:
8035:    [ oTypeSNodeType
8037:       | nIntegerType :
8038:       | nByteType :        .tCastBtoI
8042:       | * :                #eNotInteger
8051:    ]
8051:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8053: PromoteToInt:
8055:    [ oTypeSNodeType
8057:       | nIntegerType :
8058:       | nByteType :        .tCastBtoI
8062:                            oTypeSPop
8063:                            oTypeSPush( IntegerType )
8069:       | * :                #eNotInteger
8078:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8079: PromoteToIntOptional:
8081:    [ oTypeSNodeType
8083:       | nByteType :        .tCastBtoI
8086:                            oTypeSPop
8087:                            oTypeSPush( IntegerType )
8093:       | * :
8098:    ];
      
      
8099: RequireBoolPop:
8101:    [ oTypeSNodeType
8103:       | nBooleanType :
8104:       | * :          #eNotBoolean
8111:    ]
8111:    oTypeSPop;
      
8113: RequireBool:
8115:    [ oTypeSNodeType
8117:       | nBooleanType :
8118:       | * :          #eNotBoolean
8125:    ];
      
      
8126: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8126: Statement:
8128:    [
8128:       | pWriteln :     @WritelnStmt
8132:       | pWrite :       @WriteStmt
8136:       | pReadln :      @ReadlnStmt
8140:       | pRead :        @ReadStmt
8144:       | pIf :          @IfStmt
8148:       | pWhile :       @WhileStmt
8152:       | pFor :         @ForStmt
8156:       | pRepeat :      @RepeatStmt
8160:       | pBreak :       @BreakStmt
8164:       | pContinue :    @ContinueStmt
8168:       | pBegin :       @BeginStmt
8172:       | pIdent :       @LabelOrAssignOrCallStmt
8176:       | pCase :        @CaseStmt
8180:       | pGoto :        @GotoStmt
8184:       | pIntLit :      % should be an integer label
8186:                        oChangeIntLitToLabelIdent
8187:                        @LabelOrAssignOrCallStmt
8189:       | * :            % null statement : don't accept any tokens
8222:    ];
      
      
8223: LabelOrAssignOrCallStmt:
8225:    Node decl = oScopeFindRequire
8230:    @ResolveUnitRef( decl )
8237:    [ oNodeType( decl )
8244:       | nLabel :                          @LabelDefinition( decl )
8252:                                           @Statement
8254:       | nProc :                           @Call( decl )
8263:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8272:       | nFunc :                           @AssignResultStmt( decl )
8281:       | * :                               #eBadStatement
8298:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8299: LabelDefinition( Node decl ):
8301:    [ oNodeGetBoolean( decl, qDefined )
8311:       | true :  #eAlreadyDefined
8314:       | * :
8319:    ]
8319:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8334:    oNodeSetBoolean( decl, qDefined, true )
8346:    ':'
8349:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8349: AssignStmt( Node decl ):
      
8351:    @LValueVar( decl, true )
8361:    ':=' 
8363:    @Expr
8365:    @CoerceType
8367:    @Assign
8370:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8370: Assign:
8372:    [ oTypeSNodeType
8374:       | nIntegerType, nEnumType :  .tAssignI
8377:       | nBooleanType, nByteType, nCharType :  .tAssignB
8381:       | nFileType :   #eNotImplemented
8385:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8389:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
8391:           int size = oNodeGetInt( oTypeSTop, qSize )
8403:           .tCopy  oEmitInt( size )    % multi-word copy
8411:    ]
8437:    oTypeSPop
8439:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8439: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8441:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8457:       | false :   #eNotCurrentFunction
8460:       | * :
8465:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8465:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8480:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8493:    ':='
8495:    @Expr
8497:    @CoerceType
8499:    [ oTypeSNodeType
8501:       | nIntegerType, nEnumType : .tAssignI
8504:       | nBooleanType, nByteType, nCharType :  .tAssignB
8508:       | nFileType :   #eNotImplemented
8512:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8516:       | nArrayType, nRecordType, nShortStringType :
8518:           int size = oNodeGetInt( oTypeSTop, qSize )
8530:           .tCopy  oEmitInt( size )    % multi-word copy
8538:    ]
8564:    oTypeSPop
8566:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
8566: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8568:    pIdent
8570:    Node decl = oScopeFindRequire
8575:    @ResolveUnitRef( decl )
8582:    [ oNodeType( decl )
8589:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
8590:       | * :  #eNotVar
8603:    ]
8603:    @LValueVar( decl, writeable )
8614:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8614: LValueVar( Node decl, boolean writeable ):
8616:    [ oNodeType( decl )
8623:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8633:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8644:       | nParam :
8646:          [ oNodeGetBoolean( decl, qInOut )
8656:             | true :   % VAR param points to variable.  No dereference.
8657:                        .tPushParamP @EmitValue( decl )
8666:             | * :      .tPushAddrParam @EmitValue( decl )
8680:          ]
8680:       | nTypedConst :
8682:          [ writeable
8685:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
8695:             | * :      #eNotVar
8702:          ]
8702:       | * :            #eNotVar
8715:    ]
      
8715:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
8728:    [ oTypeSNodeType
8730:       | nPointerType :
8731:          [
8731:             | '[' :
                     % dereference the pointer var first
8733:                .tFetchP
8735:                @PointerArraySubscript
8737:             | * :
8742:          ]
8742:       | * :
8747:    ]
         % additional subscripts, if any
8747:    @LValueIndexes
8750:    ;
      
      
8750: IncVar( Node decl ):
8752:    @LValueVar( decl, true )
8762:    @RequireIntPop
8764:    @VarExpr( decl )
8771:    oTypeSPop
8772:    .tIncI
8774:    .tAssignI;
      
8777: DecVar( Node decl ):
8779:    @LValueVar( decl, true )
8789:    @RequireIntPop
8791:    @VarExpr( decl )
8798:    oTypeSPop
8799:    .tDecI
8801:    .tAssignI;
      
      
8804: IfStmt:
8806:    Label falseLabel = labelNull
      
8812:    @BooleanExprControlFlow( falseLabel )
8819:    pThen
8821:    @Statement
8823:    [
8823:       | pElse :
8825:          Label doneLabel = oLabelNew
      
8830:          .tJump  oEmitLabel( doneLabel )
8838:          .tLabel oEmitLabel( falseLabel )
8846:          @Statement
8848:          .tLabel oEmitLabel( doneLabel )
      
8856:       | * :
8861:          .tLabel oEmitLabel( falseLabel )
8869:    ];
      
      
8870: ForStmt:
8872:    pIdent
      
8874:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8879:    @LValueVar( decl, true )
8889:    @RequireIntPop
      
8891:    ':='
      
8893:    @Expr
8895:    @RequireIntPop
8897:    .tAssignI
      
8899:    Label breakLabel = oLabelNew
      
8904:    Label checkLabel = oLabelNew
8909:    .tJump  oEmitLabel( checkLabel )
      
8917:    Label continueLabel = oLabelNew
8922:    .tLabel  oEmitLabel( continueLabel )
8930:    [
8930:       | pTo :
8932:          @IncVar( decl )
8939:          .tLabel  oEmitLabel( checkLabel )
8947:          @VarExpr( decl )  oTypeSPop
8955:          @Expr
8957:          @RequireIntPop
8959:          .tGreaterI
8961:          .tJumpTrue  oEmitLabel( breakLabel )
8969:       | pDownto :
8971:          @DecVar( decl )
8978:          .tLabel  oEmitLabel( checkLabel )
8986:          @VarExpr( decl )  oTypeSPop
8994:          @Expr
8996:          @RequireIntPop
8998:          .tLessI
9000:          .tJumpTrue  oEmitLabel( breakLabel )
9008:    ]
9016:    oLoopPush( continueLabel, breakLabel )
9025:    pDo
9027:    @Statement
9029:    .tJump  oEmitLabel( continueLabel )
9037:    .tLabel  oEmitLabel( breakLabel )
9045:    oLoopPop;
      
      
9047: RepeatStmt:
9049:    Label continueLabel = oLabelNew
9054:    .tLabel  oEmitLabel( continueLabel )
      
9062:    Label breakLabel = oLabelNew
      
9067:    oLoopPush( continueLabel, breakLabel )
9076:    @Statement
9078:    {[
9078:       | ';' :
9080:          @Statement
9082:       | pUntil :
9084:          Label falseLabel
9084:          @BooleanExprControlFlow( falseLabel )
9091:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9105:          >
9107:    ]}
9117:    .tLabel  oEmitLabel( breakLabel )
9125:    oLoopPop;
      
      
9127: WhileStmt:
9129:    Label continueLabel = oLabelNew
9134:    .tLabel  oEmitLabel( continueLabel )
      
9142:    Label breakLabel
9142:    @BooleanExprControlFlow( breakLabel )
      
9149:    oLoopPush( continueLabel, breakLabel )
9158:    pDo
9160:    @Statement
9162:    .tJump  oEmitLabel( continueLabel )
9170:    .tLabel  oEmitLabel( breakLabel )
9178:    oLoopPop;
      
      
9180: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9182:    [ equal_label( oLoopContinueLabel, labelNull )
9191:       | true :
9192:          #eNotInALoop
9194:       | false :
9196:          .tJump  oEmitLabel( oLoopContinueLabel )
9203:    ];
      
      
9212: BreakStmt:
9214:    [ equal_label( oLoopBreakLabel, labelNull )
9223:       | true :
9224:          #eNotInALoop
9226:       | false :
9228:          .tJump  oEmitLabel( oLoopBreakLabel )
9235:    ];
      
      
9244: CaseStmt:
9246:    Code tableCode = oCodeNew
9251:    Label tableLabel = oLabelNew
9256:    Label doneLabel = oLabelNew
9261:    Label otherwiseLabel = doneLabel
9267:    boolean isString = false
      
9273:    @Expr
         % Leave the expr type on the type stack throughout case statement
9275:    [ oTypeSNodeType
9277:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
9286:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
9296:       | nShortStringType, nStrLitType :        isString = true
9304:                                                .tJumpCaseS  oEmitLabel( tableLabel )
9312:       | * :     #eNotAllowed
9331:    ]
9331:    pOf
      
9333:    {
9333:       [
9333:          | pOtherwise, pElse :
9335:             otherwiseLabel = oLabelNew
9340:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
9348:             {[
9348:                | pEnd :  >
9352:                | * :
9357:                   @Statement
9359:                   [
9359:                      | ';' :
9361:                      | * :   pEnd  >
9370:                   ]
9370:             ]}
9372:             >
      
9374:          | pEnd :
                  % Reached end with no otherwise clause
9376:             >
      
9378:          | * :
9387:             Label caseLabel = oLabelNew
9392:             oCodePush( tableCode )
9398:             {
9398:                @ConstExpr
9400:                @ConstCoerceType
9402:                int val
9402:                [ isString
9405:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
9415:                   | false :   val = oValueTop
9422:                ]
9430:                oValuePop
9431:                [
9431:                   | '..' :  @ConstExpr
9435:                             @ConstCoerceType
9437:                             int highval
9437:                             [ isString
9440:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
9450:                                | false :  highval = oValueTop
9457:                             ]
9465:                             oValuePop
9466:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
9486:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
9505:                ]
9505:                [
9505:                   | ',' :
9507:                   | * :  >
9514:                ]
9514:             }
9516:             oCodePop
9517:             ':'
9519:             .tLabel  oEmitLabel( caseLabel )
9527:             @Statement
9529:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
9537:             [
9537:                | ';' :
9539:                | * :
9544:             ]
                  
9544:       ]
         
9544:    }
      
9546:    .tLabel  oEmitLabel( tableLabel )
9554:    oEmitCode( tableCode )
9560:    .tCaseEnd  oEmitLabel( otherwiseLabel )
9568:    .tLabel  oEmitLabel( doneLabel )
9576:    oTypeSPop
9578:    ;
      
      
9578: GotoStmt:
9580:    [
9580:       | pIdent :
9582:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9584:          oChangeIntLitToLabelIdent
9585:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9593:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9602:    oNodeSetBoolean( decl, qUsed, true )
9614:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9630:    ;
      
      
9630: BeginStmt:
9632:    @Statement
9634:    {[
9634:       | ';' :   @Statement
9638:       | pEnd :  >
9642:    ]};
      
      
9653: WritelnStmt:
9655:    @WriteStmt
9657:    .tWriteCR;
      
      
9660: WriteStmt:
9662:    [
9662:       | '(' :
9664:          {
9664:             @Expr
9666:             [ oTypeSNodeType
9668:                | nIntegerType :             .tWriteI
9671:                | nBooleanType :             .tWriteBool
9675:                | nByteType :                .tCastBtoI  .tWriteI
9681:                | nCharType :                .tWriteChar
9685:                | nShortStringType, nStrLitType :   .tWriteShortStr
9689:                | nFileType :                #eNotImplemented
9693:                | nEnumType :
                        % write name via table lookup
9695:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9709:                   .tWriteEnum
9711:                | nPointerType :
9713:                   [ equal_node( oTypeSTop, PCharType )
9722:                      | true :               .tWritePChar
9725:                      | * :                  .tWriteP
9732:                   ]
9732:                | nUniversalPointerType :    .tWriteP
9736:                | * :                        #eNotAllowed
9761:             ]
9761:             oTypeSPop
9762:             [
9762:                | ')' : >
9766:                | ',' :
9768:             ]
9776:          }
9778:       | * :
9783:    ];
      
      
9784: ReadlnStmt:      % ***
         % TO DO
9787:    ;
      
9787: ReadStmt:
         % TO DO
9790:    ;
9790: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9790: MoveIntoTempShortString >> int:
9792:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9802:    [ oTypeSNodeType
9804:       | nShortStringType, nStrLitType :
9805:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9813:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9815:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9830:       | nCharType :
               % temp[0] = 1
9832:          .tPushAddrLocal  oEmitInt( tempOffset )
9840:          .tPushConstI  oEmitInt( 1 )
9848:          .tAssignB
               % temp[1] = value
9850:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9865:          .tSwap
9867:          .tAssignB
9869:       | * :   #eTypeMismatch
9880:    ]
9880:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9881:    .tPushAddrLocal  oEmitInt( tempOffset )
9889:    oTypeSPush( ShortStringType )
9895:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9899: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9901:    .tAllocActuals  oEmitInt( 16 )
9909:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9921:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9933:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9942:    .tFreeActuals  oEmitInt( 16 )
9950:    oTypeSPop
9951:    oTypeSPop
9953:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9953: ShortStringAppendChar:
         % Note at the moment I don't align params
9955:    .tAllocActuals  oEmitInt( 12 )
9963:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9975:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9987:    .tCall  @EmitValue( System_ShortStringAppendChar )
9996:    .tFreeActuals  oEmitInt( 12 )
10004:    oTypeSPop
10005:    oTypeSPop
10007:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
10007: ShortStringCmp:
10009:    .tAllocActuals  oEmitInt( 24 )
10017:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10029:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10041:    int tempOffset = oScopeAllocType( IntegerType )
10051:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10069:    .tCall  @EmitValue( System_ShortStringCmp )
10078:    .tPushLocalI  oEmitInt( tempOffset )
10086:    .tFreeActuals  oEmitInt( 24 )
10094:    oTypeSPop
10095:    oTypeSPush( IntegerType )
10102:    ;
10102: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10102: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
10104:    [ oNodeGetBoolean( method, qExternal )
10114:       | true :
10115:          [ oNodeGetBoolean( method, qUsed )
10125:             | false :
                     % define the extern label on first use
10126:                @DefineExternLabel( method )
10133:             | * :
10138:          ]
10138:      | * :
10143:    ]
10143:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
10155:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
10168:    Node resultType
10168:    int tempOffset
      
10168:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
10185:    [ isFunc
10188:       | true :
10189:          resultType = oNodeGet( method, qType )
10202:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
10212:       | * :
10217:    ]
         
      
10217:    Node paramScope = oNodeGet( method, qParams )
10230:    int actualsSize = oNodeGetInt( paramScope, qSize )
10243:    [ cdecl
10246:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
10255:       | false :  .tAllocActuals  oEmitInt( actualsSize )
10265:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
10273:    [ greater( @DeclLevel( method ), 0 )
10288:       | true :
10289:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
10297:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
10316:          .tAssignP
10318:       | * :
10323:    ]
      
      
10323:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
10336:    Node param = oNodeIterValue( paramIter )
10346:    [
10346:       | '(' :
            
10348:          {
10348:             [ oNodeNull( param )
10355:                | true : >
10358:                | * :
10363:             ]
      
10363:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
10376:             .tPushAddrActual oEmitInt( offset )
10384:             oTypeSPush( oNodeGet( param, qType ) )
      
10397:             [ oNodeGetBoolean( param, qInOut )
10407:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
10408:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
10415:                           @MatchTypes
      
10417:                           .tAssignP
      
10419:                | false :  @Expr
10423:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
10425:                           [ oTypeSNodeType
10427:                              | nIntegerType, nEnumType : .tAssignI
10430:                              | nBooleanType, nByteType, nCharType :  .tAssignB
10434:                              | nFileType :   #eNotImplemented
10438:                              | nPointerType, nUniversalPointerType :  .tAssignP
10442:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
10444:                                  int size = oNodeGetInt( oTypeSTop, qSize )
10456:                                  .tCopy  oEmitInt( size )    % multi-word copy
10464:                           ]
10490:             ]
10498:             oTypeSPop
      
10499:             oNodeIterNext( paramIter )
10505:             param = oNodeIterValue( paramIter )
10515:             [ oNodeNull( param )
10522:                | true :  >
10525:                | false :
10527:             ]
      
10535:             ','
10537:          }
      
10539:          ')'
      
10541:       | * :
10546:    ]
      
10546:    [ oNodeNull( param )
10553:       | false :    #eMissingParameter
10556:       | * :
10561:    ]
      
10561:    [ isFunc
10564:       | true :
               % Pass result temp as an additional VAR parameter.
10565:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10580:          .tPushAddrLocal  oEmitInt( tempOffset )
10588:          .tAssignP
10590:       | * :
10595:    ]
      
10595:    [ cdecl
10598:       | true :
10599:          .tCallCdecl  @EmitValue( method )
10608:       | false :
10610:          .tCall   @EmitValue( method )
10619:    ]
      
10627:    [ isFunc
10630:       | true :
               % push return value from temp
10631:          oTypeSPush( resultType )
      
10637:          [ oTypeSNodeType
10639:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10648:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10658:             | nFileType :  #eNotImplemented
10662:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10672:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10674:                                .tPushAddrLocal  oEmitInt( tempOffset )
10682:          ]
10708:       | * :
10713:    ]
         
10713:    .tFreeActuals  oEmitInt( actualsSize )
10722:    ;
      
      
      
      % Called on first use of an extern method
      %
10722: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
10724:    int strAddr
10724:    String externalName = oNodeGetString( method, qExternalName )
10737:    [ equal_string( externalName, stringNull )
10747:       | true :
10748:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
10769:       | false :
10771:          strAddr = oStringAllocLit( externalName )
10781:    ]
10789:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
10805:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10805: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10807:    [ oNodeEqual( method, BuiltIn_Ord )
10817:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10818:          '('
10820:          @Expr
10822:          [ oTypeSNodeType
10824:             | nIntegerType, nEnumType :
10825:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10829:             | * :  #eTypeMismatch
10844:          ]
10844:          oTypeSPop
10845:          oTypeSPush( IntegerType )
10851:          ')'
10853:          >>
10854:       | * :
10859:    ]
      
         % Chr(x)
10859:    [ oNodeEqual( method, BuiltIn_Chr )
10869:       | true :
               % parameter is integer
               % result is char
10870:          '('
10872:          @Expr
10874:          [ oTypeSNodeType
10876:             | nIntegerType :    .tCastItoB
10879:             | nByteType :
10881:             | * :  #eTypeMismatch
10890:          ]
10890:          oTypeSPop
10891:          oTypeSPush( CharType )
10897:          ')'
10899:          >>
10900:       | * :
10905:    ]
      
         % Pred(x)
10905:    [ oNodeEqual( method, BuiltIn_Pred )
10915:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10916:          '('
10918:          @Expr
10920:          [ oTypeSNodeType
10922:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10923:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10932:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10935:                   | * :
10940:                ]
10940:             | * :  #eTypeMismatch
10947:          ]
10947:          .tDecI
10949:          ')'
10951:          >>
10952:       | * :
10957:    ]
      
         % Succ(x)
10957:    [ oNodeEqual( method, BuiltIn_Succ )
10967:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10968:          '('
10970:          @Expr
10972:          [ oTypeSNodeType
10974:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10975:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10984:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10987:                   | * :
10992:                ]
10992:             | * :  #eTypeMismatch
10999:          ]
10999:          .tIncI
11001:          ')'
11003:          >>
11004:       | * :
11009:    ]
      
11009:    #eNotImplemented
11012:    ;
      
11012: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11012: newType( node_type nt, int size ) >> Node:
11014:   Node node = oNodeNew( nt )
11024:   oNodeSetInt( node, qSize, size )
11036:   oTypeAdd( node )
11042:   >> node
11046:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11046: TypeRef( out Node resultType ):
11048:    [
11048:       | pIdent :           % previously named type (including intrinsics)
11050:          Node decl = oScopeFindRequire
11055:          @ResolveUnitRef( decl )
11062:          [ oNodeType( decl )
11069:             | nTypeDecl :
11070:                resultType = oNodeGet( decl, qType )
11083:             | * :
11088:                #eNotType
11090:                resultType = IntegerType
11096:          ]
         
11096:       | pArray :
11098:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
11100:          NodeVec dimensions = oNodeVecNew
      
11105:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
11105:             Node subrange = oNodeNew( nSubrangeType )
      
11115:             @ConstExpr
11117:             oNodeSetInt( subrange, qLow, oValueTop )
11128:             oValuePop
11129:             '..'
11131:             @ConstExpr
11133:             oNodeSetInt( subrange, qHigh, oValueTop )
11144:             oValuePop
      
11145:             @ConstMatchTypes
11147:             oNodeSet( subrange, qBaseType, oTypeSTop )
11158:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
11176:             oTypeSPop
11177:             oTypeAdd( subrange )
      
11183:             Node a = oNodeNew( nArrayType )
11193:             oNodeSet( a, qIndexType, subrange )
      
11205:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
11214:             [
11214:                | ']' : >
11218:                | ',' :
11220:             ]
11228:          }
      
11230:          pOf
11232:          Node baseType
11232:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
11239:          int dim = oNodeVecSize( dimensions )
      
11249:          {
11249:              dec(dim)
      
11255:              Node a = oNodeVecElement( dimensions, dim )
      
11268:              oNodeSet( a, qBaseType, baseType )
11280:              Node subrange = oNodeGet( a, qIndexType )
11293:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
11320:              inc( width )
11326:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
11352:              oTypeAdd( a )
11358:              baseType = a
      
11364:              [ equal_zero(dim)
11371:                  | true:  >
11374:                  | *:
11379:              ]
11379:          }
      
11381:          resultType = oNodeVecElement( dimensions, 0 )
11394:          oNodeVecDelete( dimensions )
      
11400:       | '^' :
11402:          Node theType
11402:          @TypeRef( theType )
11409:          resultType = @PointerTypeTo( theType )
      
11420:       | pRecord :
11422:          resultType = oNodeNew( nRecordType )
11432:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
11441:          @VarDecl( nRecordField )
      
11448:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
11460:          [ equal_zero( size )
11467:             | true : #eRecordEmpty
11470:             | * :
11475:          ]
      
11475:          pEnd
      
11477:          oNodeSet( resultType, qScope, oScopeCurrent )
11488:          oNodeSetInt( resultType, qSize, size )
11500:          oScopeEnd
11501:          oTypeAdd( resultType )
      
      
11507:       | '(' :
               % An enum type declaration.
11509:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
11516:       | pSet :
11518:          pOf
11520:          Node theType
11520:          @TypeRef( theType )
11527:          #eNotImplemented
11529:       | * :       % this works for cases except where expr starts with an id
11544:          @ConstExpr '..' @ConstExpr
11550:          @ConstMatchTypes
11552:          #eNotImplemented
11554:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
11555: EnumTypeRef( out Node resultType ):
      
11557:    resultType = oNodeNew( nEnumType )
11567:    int value = 0
11573:    int numValues = 0
11579:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
11585:    Node outerScope = oScopeCurrent
11590:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
11599:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
11599:       pIdent
11601:       Node decl = @newIdent( nEnumValue, LAST_ID )
11614:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
11627:       oNodeSet( decl, qType, resultType )
11639:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
11651:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
11664:       oNodeSetInt( decl, qNameOffset, nameOffset )
11676:       oNodeSetInt( decl2, qNameOffset, nameOffset )
11688:       [
11688:          | '=', ':=' :
11690:             oTypeSPush( IntegerType )
11696:             @ConstExpr
11698:             @ConstCoerceType
11700:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
11701:             [ equal_zero( numValues )
11708:                | false :
11709:                   [ greater( oValueTop, value )
11718:                      | false :   #eEnumValueNotAscending
11721:                      | * :
11726:                   ]
11726:                | * :
11731:             ]
11731:             [ equal( value, oValueTop )
11740:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
11741:                   oNodeSetBoolean( resultType, qHasGap, true )
11753:                | * :
11758:             ]
11758:             value = oValueTop
11763:             oValuePop
11764:          | * :
11771:       ]
11771:       oNodeSetInt( decl, qValue, value )
11783:       oNodeSetInt( decl2, qValue, value )
11795:       oScopeDeclare( decl )
      
11801:       oScopeEnter( outerScope )
11807:       oScopeDeclare( decl2 )
11813:       oScopeEnd
      
11814:       inc( value )
11820:       inc( numValues )
11826:       [
11826:          | ',' :
11828:          | * :    >
11835:       ]
11835:    }
11837:    ')'
      
11839:    oNodeSet( resultType, qScope, oScopeCurrent )
11850:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
11862:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
11863:    oCodePush( @GetOrCreateInitCode( globalScope ) )
11874:    oScopeEnter( globalScope )
11880:    int size = multiply( add( numValues, 1 ), 16 )
11900:    int addr = oScopeAlloc( size, 8 )
11913:    oScopeEnd
11914:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
11926:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
11946:    {
11946:       Node enumValue = oNodeIterValue( it )
11956:       [ oNodeNull( enumValue )
11963:          | true :  >
11966:          | * :
11971:       ]
11971:       .tPushAddrGlobal  oEmitInt( addr )
11979:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
11994:       .tAssignI
11996:       addr = add( addr, 8 )
12009:       .tPushAddrGlobal  oEmitInt( addr )
12017:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12032:       .tAssignP
12034:       addr = add( addr, 8 )
12047:       oNodeIterNext( it )
12053:    }
         % final table entry
12055:    .tPushAddrGlobal  oEmitInt( addr )
12063:    .tPushConstI  oEmitInt( 0 )
12071:    .tAssignI
12073:    addr = add( addr, 8 )
12086:    .tPushAddrGlobal  oEmitInt( addr )
12094:    .tPushConstI  oEmitInt( 0 )
12102:    .tAssignP
12104:    addr = add( addr, 8 )
12117:    oCodePop
      
12118:    oTypeAdd( resultType )
12125:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12125: PointerTypeTo( Node theType ) >> Node:
12127:    Node ptrType = oNodeGet( theType, qPointerType )
12140:    [ oNodeNull( ptrType )
12147:       | true :
12148:          ptrType = oNodeNew( nPointerType )
12158:          oNodeSet( ptrType, qBaseType, theType )
12170:          oNodeSetInt( ptrType, qSize, 8 )
12182:          oTypeAdd( ptrType )
12188:          oNodeSet( theType, qPointerType, ptrType )
12200:       | * :
12205:    ]
12205:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
12209: OrdinalLow( Node theType ) >> int:
12211:    [ oNodeType( theType )
12218:       | nIntegerType :  >> oMININT
12221:       | nBooleanType :  >> 0
12226:       | nCharType :     >> 0
12231:       | nEnumType :
12233:          Node enumScope = oNodeGet( theType, qScope )
12246:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12263:          >> oNodeGetInt( first, qValue )
12273:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12285:       | * :             #eNotOrdinalType
12300:                         >> 0
12303:    ];
      
      
      % Return the high value of an ordinal type
      %
12304: OrdinalHigh( Node theType ) >> int:
12306:    [ oNodeType( theType )
12313:       | nIntegerType :  >> oMAXINT
12316:       | nBooleanType :  >> 1
12321:       | nCharType :     >> 255
12326:       | nEnumType :
12328:          Node enumScope = oNodeGet( theType, qScope )
12341:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12358:          >> oNodeGetInt( last, qValue )
12368:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12380:       | * :             #eNotOrdinalType
12395:                         >> 0
12398:    ];
      
      
      
12399: Program:
12401:    Node t
      
12401:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
12406:    oScopeBegin( 0, allocGlobal )
12415:    Node rootScope = oScopeCurrent
      
12420:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
12422:    .tEnter  oEmitInt( 0 )
12430:    Label mainLabel = oLabelNew
      
12435:    .tAllocActuals  oEmitInt( 0 )
12443:    .tCall  oEmitLabel( mainLabel )
12451:    .tFreeActuals  oEmitInt( 0 )
12459:    .tReturn
      
12461:    pProgram
12463:    pIdent
      
12465:    Node program = oNodeNew( nProgram )
12475:    oNodeSetInt( program, qIdent, LAST_ID )
12486:    oNodeSet( workspace, qProgram, program )
      
      
12498:    [
12498:       | '(' :
12500:          pIdent      % input, output files
      
12502:          t = @newIdent( nVar, LAST_ID )
12515:          oNodeSet( t, qType, FileType )
12527:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
12533:          ','
12535:          pIdent
      
12537:          t = @newIdent( nVar, LAST_ID )
12550:          oNodeSet( t, qType, FileType )
12562:          oScopeDeclareAlloc( t )
      
12568:          ')'
12570:       | * :
12575:    ]
12575:    ';'
      
12577:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
12584:    [
12584:       | pUses :  @UsesClause( program )
12593:       | * :
12598:    ]
12598:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
12605:    oScopeBegin( 0, allocGlobal )
12614:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
12619:    oScopeBegin( 0, allocDown )
12628:    oNodeSet( oScopeCurrent, qExtends, globalScope )
12639:    initScope = oScopeCurrent
12644:    oNodeSet( program, qMainRoutineScope, initScope )
12656:    oScopeEnd
      
12657:    @BlockDecls( nGlobalVar )
      
      
12664:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
12670:    boolean isMain = true
12676:    @BlockStmt( mainLabel, globalScope, isMain )
      
12689:    oScopeEnd   % main routine scope
      
12690:    '.'
12692:    @CheckForUndefinedLabels
12694:    oScopeEnd   % global scope
12695:    @EndUsedUnits( program )   % used units scopes
12703:    ;
      
      
      
      
12703: Block( node_type varNodeType, Label labelForBody ):
12705:    @BlockDecls( varNodeType )
12712:    @BlockStmt( labelForBody, oScopeCurrent, false )
12724:    @CheckForUndefinedLabels
12727:    ;
      
      
12727: BlockDecls( node_type varNodeType ):
12729:    {[
12729:       | pConst :     @ConstDecl
12733:       | pType :      @TypeDecl
12737:       | pVar :       @VarDecl( varNodeType )
12746:       | pLabel :     @LabelDecl
12750:       | pProcedure : @ProcDecl
12754:       | pFunction :  @FuncDecl
12758:       | * :          >
12775:    ]}
12777:    @CheckForUndefinedMethods
12780:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
12780: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
12783:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
12783: CheckForUndefinedLabels:
12785:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
12797:    {
12797:       Node decl = oNodeIterValue( it )
12807:       [ oNodeNull( decl )
12814:          | false :
12815:          | * :  >
12822:       ]
12822:       [ oNodeType( decl )
12829:          | nLabel :
12830:             [ oNodeGetBoolean( decl, qDefined )
12840:                | false :
12841:                   [ oNodeGetBoolean( decl, qUsed )
12851:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
12854:                      | * :
12859:                   ]
12859:                | * :
12864:             ]
12864:          | * :
12869:       ]
12869:       oNodeIterNext( it )
12875:    }
12878:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
12878: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
12880:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
12888:    int patchLS
12888:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
12897:    [ isMain
12900:       | true :  @InitializeUnits
12903:       | * :
12908:    ]
      
         % insert any code for initialization of this scope's variables
12908:    Code initCode = oNodeGetCode( varScope, qInitCode )
12921:    oEmitCode( initCode )
12927:    oNodeSetCode( varScope, qInitCode, codeNull )
      
12939:    @Statement
      
12941:    [ isMain
12944:       | true :  @FinalizeUnits
12947:       | * :
12952:    ]
      
12952:    .tReturn
      
12954:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
12966:    oPatch( patchLS, localSpace )
12976:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
12976: GetOrCreateInitCode( Node scope ) >> Code:
12978:    Code initCode = oNodeGetCode( scope, qInitCode )
12991:    [ equal_code( initCode, codeNull )
13001:       | true :
13002:          initCode = oCodeNew
13007:          oNodeSetCode( scope, qInitCode, initCode )
13019:       | * :
13024:    ]
13024:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
13028: ScopeLevel >> int:
13030:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13040: DeclLevel( Node decl ) >> int:
13042:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
13060: DeclUpLevels( Node decl ) >> int:
13062:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
13078: newIdent( node_type nt, int id ) >> Node:
13080:   Node t = oNodeNew( nt )
13090:   oNodeSetInt( t, qIdent, id )
13102:   >> t
13106:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
13106: EmitValue( Node decl ):
13108:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
13122: DeclareBuiltInFunc( int id ) >> Node:
13124:    Node decl = @newIdent( nBuiltInFunc, id )
13138:    oScopeDeclare( decl )
13144:    >> decl;
      
      
13148: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
13150:    mysystemId = oId_mysystem
      
         % install built-in types
13155:    FileType = @newType( nFileType, 4 )
13169:    IntegerType = @newType( nIntegerType, 4 )
13183:    BooleanType = @newType( nBooleanType, 1 )
13197:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
13211:    CharType = @newType( nCharType, 1 )
13225:    PCharType = @PointerTypeTo( CharType )
13236:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
13250:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
13264:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
13276:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
13290:    ShortStringType = @newType( nShortStringType, 256 )
13304:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
13316:    Node t
      
13316:    t = @newIdent( nTypeDecl, oId_File )
13329:    oNodeSet( t, qType, FileType )
13341:    oScopeDeclare( t )
      
13347:    t = @newIdent( nTypeDecl, oId_Integer )
13360:    oNodeSet( t, qType, IntegerType )
13372:    oScopeDeclare( t )
      
13378:    t = @newIdent( nTypeDecl, oId_Boolean )
13391:    oNodeSet( t, qType, BooleanType )
13403:    oScopeDeclare( t )
      
13409:    t = @newIdent( nTypeDecl, oId_Char )
13422:    oNodeSet( t, qType, CharType )
13434:    oScopeDeclare( t )
      
13440:    t = @newIdent( nTypeDecl, oId_Byte )
13453:    oNodeSet( t, qType, ByteType )
13465:    oScopeDeclare( t )
      
13471:    t = @newIdent( nTypeDecl, oId_Pointer )
13484:    oNodeSet( t, qType, UniversalPointerType )
13496:    oScopeDeclare( t )
      
13502:    t = @newIdent( nTypeDecl, oId_ShortString )
13515:    oNodeSet( t, qType, ShortStringType )
13527:    oScopeDeclare( t )
      
         % Built-in constants
      
13533:    t = @newIdent( nConst, oId_True )
13546:    oNodeSet( t, qType, BooleanType )
13558:    oNodeSetInt( t, qValue, 1 )
13570:    oScopeDeclare( t )
      
13576:    t = @newIdent( nConst, oId_False )
13589:    oNodeSet( t, qType, BooleanType )
13601:    oNodeSetInt( t, qValue, 0 )
13613:    oScopeDeclare( t )
      
13619:    t = @newIdent( nConst, oId_Nil )
13632:    oNodeSet( t, qType, UniversalPointerType )
13644:    oNodeSetInt( t, qValue, 0 )
13656:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13662:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13672:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13682:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13692:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13703:    ;
      
13703: end
      
13703: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 12399
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2513
 844: oJumpForward 920
 846: oCall 3171
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3227
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1480
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1854
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 12727
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8126
1083: oInputChoice 1089
1085: oCall 8126
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8126
1177: oInputChoice 1183
1179: oCall 8126
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13040
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oReturn
1480: oLocalSpace 6
1482: oInput 0
1484: oGetAddrLocal 1
1486: oPushResult
1487: oSetResult 0
1489: oAssign
1490: oGetAddrLocal 2
1492: oPushResult
1493: oScopeFindInCurrentScope
1494: oAssign
1495: oGetLocal 2
1497: oPushResult
1498: oNodeNull
1499: oPop 1
1501: oChoice 1619
1503: oGetAddrLocal 2
1505: oPushResult
1506: oSetResult 12
1508: oPushResult
1509: LAST_ID
1510: oPushResult
1511: oCall 13078
1513: oPop 2
1515: oAssign
1516: oGetLocal 2
1518: oPushResult
1519: oSetResult 22
1521: oPushResult
1522: oLabelNew
1523: oPushResult
1524: oNodeSetLabel
1525: oPop 3
1527: oJumpForward 1625
1529: oGetAddrLocal 1
1531: oPushResult
1532: oSetResult 1
1534: oAssign
1535: oGetLocal 2
1537: oPushResult
1538: oSetResult 24
1540: oPushResult
1541: oNodeGetBoolean
1542: oPop 2
1544: oChoice 1550
1546: oError 21
1548: oJumpForward 1553
1550: Choice Lookup Table
           1   1546
1553: oGetLocal 2
1555: oPushResult
1556: oSetResult 25
1558: oPushResult
1559: oNodeGetBoolean
1560: oPop 2
1562: oChoice 1568
1564: oError 21
1566: oJumpForward 1571
1568: Choice Lookup Table
           1   1564
1571: oGetLocal 2
1573: oPushResult
1574: oNodeType
1575: oPop 1
1577: oChoice 1581
1579: oJumpForward 1586
1581: Choice Lookup Table
          12   1579
1584: oError 21
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 29
1591: oPushResult
1592: oGetLocal 2
1594: oPushResult
1595: oSetResult 23
1597: oPushResult
1598: oNodeGet
1599: oPop 2
1601: oPushResult
1602: oNodeSet
1603: oPop 3
1605: oGetLocal 2
1607: oPushResult
1608: oSetResult 23
1610: oPushResult
1611: oSetResult 0
1613: oPushResult
1614: oNodeSet
1615: oPop 3
1617: oJumpForward 1625
1619: Choice Lookup Table
           0   1529
           1   1503
1624: oEndChoice
1625: oGetAddrLocal 3
1627: oPushResult
1628: oCall 13028
1630: oAssign
1631: oGetAddrLocal 4
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oSetResult 0
1639: oPushResult
1640: greater
1641: oPop 2
1643: oAssign
1644: oGetAddrLocal 3
1646: oPushResult
1647: inc
1648: oPop 1
1650: oGetLocal 3
1652: oPushResult
1653: oSetResult 2
1655: oPushResult
1656: oScopeBegin
1657: oPop 2
1659: oGetAddrLocal 5
1661: oPushResult
1662: oScopeCurrent
1663: oAssign
1664: oGetLocal 4
1666: oChoice 1685
1668: oGetAddrLocal 6
1670: oPushResult
1671: oGetGlobal 6
1673: oPushResult
1674: oCall 12125
1676: oPop 1
1678: oPushResult
1679: oScopeAllocType
1680: oPop 1
1682: oAssign
1683: oJumpForward 1688
1685: Choice Lookup Table
           1   1668
1688: oCall 2289
1690: oGetLocal 2
1692: oPushResult
1693: oSetResult 23
1695: oPushResult
1696: oGetLocal 5
1698: oPushResult
1699: oNodeSet
1700: oPop 3
1702: oScopeEnd
1703: oInput 5
1705: oGetLocal 1
1707: oChoice 1719
1709: oGetLocal 2
1711: oPushResult
1712: oScopeDeclare
1713: oPop 1
1715: oJumpForward 1725
1717: oJumpForward 1725
1719: Choice Lookup Table
           1   1717
           0   1709
1724: oEndChoice
1725: oGetLocal 2
1727: oPushResult
1728: oCall 1390
1730: oPop 1
1732: oGetLocal 2
1734: oReturn
1735: oReturn
1736: oLocalSpace 4
1738: oGetAddrLocal 1
1740: oPushResult
1741: oCall 1480
1743: oAssign
1744: oInputChoice 1757
1746: oJumpForward 1851
1748: oGetLocal 1
1750: oPushResult
1751: oCall 1418
1753: oPop 1
1755: oJumpForward 1851
1757: Choice Lookup Table
          70   1748
          69   1746
1762: oGetAddrLocal 2
1764: oPushResult
1765: oGetLocal 1
1767: oPushResult
1768: oSetResult 23
1770: oPushResult
1771: oNodeGet
1772: oPop 2
1774: oAssign
1775: oGetLocal 2
1777: oPushResult
1778: oScopeEnter
1779: oPop 1
1781: oGetAddrLocal 3
1783: oPushResult
1784: oGetLocal 2
1786: oPushResult
1787: oSetResult 14
1789: oPushResult
1790: oNodeGetInt
1791: oPop 2
1793: oAssign
1794: oGetLocal 3
1796: oPushResult
1797: oSetResult 1
1799: oPushResult
1800: oScopeBegin
1801: oPop 2
1803: oGetLocal 1
1805: oPushResult
1806: oSetResult 6
1808: oPushResult
1809: oScopeCurrent
1810: oPushResult
1811: oNodeSet
1812: oPop 3
1814: oGetAddrLocal 4
1816: oPushResult
1817: oGetLocal 1
1819: oPushResult
1820: oSetResult 22
1822: oPushResult
1823: oNodeGetLabel
1824: oPop 2
1826: oAssign
1827: oSetResult 22
1829: oPushResult
1830: oGetLocal 4
1832: oPushResult
1833: oCall 12703
1835: oPop 2
1837: oGetLocal 1
1839: oPushResult
1840: oSetResult 24
1842: oPushResult
1843: oSetResult 1
1845: oPushResult
1846: oNodeSetBoolean
1847: oPop 3
1849: oScopeEnd
1850: oScopeEnd
1851: oInput 5
1853: oReturn
1854: oLocalSpace 8
1856: oInput 0
1858: oGetAddrLocal 1
1860: oPushResult
1861: oSetResult 0
1863: oAssign
1864: oGetAddrLocal 2
1866: oPushResult
1867: oScopeFindInCurrentScope
1868: oAssign
1869: oGetLocal 2
1871: oPushResult
1872: oNodeNull
1873: oPop 1
1875: oChoice 2006
1877: oGetAddrLocal 2
1879: oPushResult
1880: oSetResult 13
1882: oPushResult
1883: LAST_ID
1884: oPushResult
1885: oCall 13078
1887: oPop 2
1889: oAssign
1890: oGetLocal 2
1892: oPushResult
1893: oSetResult 22
1895: oPushResult
1896: oLabelNew
1897: oPushResult
1898: oNodeSetLabel
1899: oPop 3
1901: oJumpForward 2012
1903: oGetAddrLocal 1
1905: oPushResult
1906: oSetResult 1
1908: oAssign
1909: oGetLocal 2
1911: oPushResult
1912: oSetResult 24
1914: oPushResult
1915: oNodeGetBoolean
1916: oPop 2
1918: oChoice 1924
1920: oError 21
1922: oJumpForward 1927
1924: Choice Lookup Table
           1   1920
1927: oGetLocal 2
1929: oPushResult
1930: oNodeType
1931: oPop 1
1933: oChoice 1937
1935: oJumpForward 1942
1937: Choice Lookup Table
          13   1935
1940: oError 21
1942: oGetLocal 2
1944: oPushResult
1945: oSetResult 29
1947: oPushResult
1948: oGetLocal 2
1950: oPushResult
1951: oSetResult 23
1953: oPushResult
1954: oNodeGet
1955: oPop 2
1957: oPushResult
1958: oNodeSet
1959: oPop 3
1961: oGetLocal 2
1963: oPushResult
1964: oSetResult 23
1966: oPushResult
1967: oSetResult 0
1969: oPushResult
1970: oNodeSet
1971: oPop 3
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 30
1978: oPushResult
1979: oGetLocal 2
1981: oPushResult
1982: oSetResult 21
1984: oPushResult
1985: oNodeGet
1986: oPop 2
1988: oPushResult
1989: oNodeSet
1990: oPop 3
1992: oGetLocal 2
1994: oPushResult
1995: oSetResult 21
1997: oPushResult
1998: oSetResult 0
2000: oPushResult
2001: oNodeSet
2002: oPop 3
2004: oJumpForward 2012
2006: Choice Lookup Table
           0   1903
           1   1877
2011: oEndChoice
2012: oGetAddrLocal 3
2014: oPushResult
2015: oCall 13028
2017: oAssign
2018: oGetAddrLocal 4
2020: oPushResult
2021: oGetLocal 3
2023: oPushResult
2024: oSetResult 0
2026: oPushResult
2027: greater
2028: oPop 2
2030: oAssign
2031: oGetAddrLocal 3
2033: oPushResult
2034: inc
2035: oPop 1
2037: oGetLocal 3
2039: oPushResult
2040: oSetResult 2
2042: oPushResult
2043: oScopeBegin
2044: oPop 2
2046: oGetAddrLocal 5
2048: oPushResult
2049: oScopeCurrent
2050: oAssign
2051: oGetLocal 4
2053: oChoice 2072
2055: oGetAddrLocal 6
2057: oPushResult
2058: oGetGlobal 6
2060: oPushResult
2061: oCall 12125
2063: oPop 1
2065: oPushResult
2066: oScopeAllocType
2067: oPop 1
2069: oAssign
2070: oJumpForward 2075
2072: Choice Lookup Table
           1   2055
2075: oCall 2289
2077: oGetLocal 2
2079: oPushResult
2080: oSetResult 23
2082: oPushResult
2083: oGetLocal 5
2085: oPushResult
2086: oNodeSet
2087: oPop 3
2089: oInput 12
2091: oGetAddrLocal 7
2093: oPushResult
2094: oCall 11046
2096: oPop 1
2098: oGetLocal 2
2100: oPushResult
2101: oSetResult 21
2103: oPushResult
2104: oGetLocal 7
2106: oPushResult
2107: oNodeSet
2108: oPop 3
2110: oGetAddrLocal 8
2112: oPushResult
2113: oGetLocal 7
2115: oPushResult
2116: oCall 12125
2118: oPop 1
2120: oAssign
2121: oGetLocal 2
2123: oPushResult
2124: oSetResult 31
2126: oPushResult
2127: oGetLocal 8
2129: oPushResult
2130: oScopeAllocType
2131: oPop 1
2133: oPushResult
2134: oNodeSetInt
2135: oPop 3
2137: oScopeEnd
2138: oInput 5
2140: oGetLocal 1
2142: oChoice 2154
2144: oGetLocal 2
2146: oPushResult
2147: oScopeDeclare
2148: oPop 1
2150: oJumpForward 2160
2152: oJumpForward 2160
2154: Choice Lookup Table
           1   2152
           0   2144
2159: oEndChoice
2160: oGetLocal 2
2162: oPushResult
2163: oCall 1390
2165: oPop 1
2167: oGetLocal 2
2169: oReturn
2170: oReturn
2171: oLocalSpace 4
2173: oGetAddrLocal 1
2175: oPushResult
2176: oCall 1854
2178: oAssign
2179: oInputChoice 2192
2181: oJumpForward 2286
2183: oGetLocal 1
2185: oPushResult
2186: oCall 1418
2188: oPop 1
2190: oJumpForward 2286
2192: Choice Lookup Table
          70   2183
          69   2181
2197: oGetAddrLocal 2
2199: oPushResult
2200: oGetLocal 1
2202: oPushResult
2203: oSetResult 23
2205: oPushResult
2206: oNodeGet
2207: oPop 2
2209: oAssign
2210: oGetLocal 2
2212: oPushResult
2213: oScopeEnter
2214: oPop 1
2216: oGetAddrLocal 3
2218: oPushResult
2219: oGetLocal 2
2221: oPushResult
2222: oSetResult 14
2224: oPushResult
2225: oNodeGetInt
2226: oPop 2
2228: oAssign
2229: oGetLocal 3
2231: oPushResult
2232: oSetResult 1
2234: oPushResult
2235: oScopeBegin
2236: oPop 2
2238: oGetLocal 1
2240: oPushResult
2241: oSetResult 6
2243: oPushResult
2244: oScopeCurrent
2245: oPushResult
2246: oNodeSet
2247: oPop 3
2249: oGetAddrLocal 4
2251: oPushResult
2252: oGetLocal 1
2254: oPushResult
2255: oSetResult 22
2257: oPushResult
2258: oNodeGetLabel
2259: oPop 2
2261: oAssign
2262: oSetResult 22
2264: oPushResult
2265: oGetLocal 4
2267: oPushResult
2268: oCall 12703
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 24
2277: oPushResult
2278: oSetResult 1
2280: oPushResult
2281: oNodeSetBoolean
2282: oPop 3
2284: oScopeEnd
2285: oScopeEnd
2286: oInput 5
2288: oReturn
2289: oLocalSpace 6
2291: oInputChoice 2509
2293: oGetAddrLocal 1
2295: oPushResult
2296: oNodeVecNew
2297: oAssign
2298: oGetAddrLocal 3
2300: oPushResult
2301: oSetResult 0
2303: oAssign
2304: oInputChoice 2314
2306: oGetAddrLocal 3
2308: oPushResult
2309: oSetResult 1
2311: oAssign
2312: oJumpForward 2317
2314: Choice Lookup Table
          33   2306
2317: oInput 0
2319: oGetAddrLocal 2
2321: oPushResult
2322: oSetResult 24
2324: oPushResult
2325: LAST_ID
2326: oPushResult
2327: oCall 13078
2329: oPop 2
2331: oAssign
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 34
2337: oPushResult
2338: oGetLocal 3
2340: oPushResult
2341: oNodeSetBoolean
2342: oPop 3
2344: oGetLocal 1
2346: oPushResult
2347: oGetLocal 2
2349: oPushResult
2350: oNodeVecAppend
2351: oPop 2
2353: oInputChoice 2361
2355: oJumpForward 2369
2357: oJumpForward 2367
2359: oJumpForward 2367
2361: Choice Lookup Table
          13   2359
          12   2355
2366: oEndChoice
2367: oJumpBack 2317
2369: oGetAddrLocal 4
2371: oPushResult
2372: oCall 11046
2374: oPop 1
2376: oGetLocal 3
2378: oChoice 2393
2380: oGetAddrLocal 5
2382: oPushResult
2383: oGetLocal 4
2385: oPushResult
2386: oCall 12125
2388: oPop 1
2390: oAssign
2391: oJumpForward 2402
2393: Choice Lookup Table
           1   2380
2396: oGetAddrLocal 5
2398: oPushResult
2399: oGetLocal 4
2401: oAssign
2402: oGetAddrLocal 6
2404: oPushResult
2405: oSetResult 0
2407: oAssign
2408: oGetLocal 6
2410: oPushResult
2411: oGetLocal 1
2413: oPushResult
2414: oNodeVecSize
2415: oPop 1
2417: oPushResult
2418: equal
2419: oPop 2
2421: oChoice 2478
2423: oGetAddrLocal 2
2425: oPushResult
2426: oGetLocal 1
2428: oPushResult
2429: oGetLocal 6
2431: oPushResult
2432: oNodeVecElement
2433: oPop 2
2435: oAssign
2436: oGetLocal 2
2438: oPushResult
2439: oSetResult 21
2441: oPushResult
2442: oGetLocal 4
2444: oPushResult
2445: oNodeSet
2446: oPop 3
2448: oGetLocal 2
2450: oPushResult
2451: oScopeDeclare
2452: oPop 1
2454: oGetLocal 2
2456: oPushResult
2457: oSetResult 22
2459: oPushResult
2460: oGetLocal 5
2462: oPushResult
2463: oScopeAllocType
2464: oPop 1
2466: oPushResult
2467: oNodeSetInt
2468: oPop 3
2470: oGetAddrLocal 6
2472: oPushResult
2473: inc
2474: oPop 1
2476: oJumpForward 2483
2478: Choice Lookup Table
           0   2423
2481: oJumpForward 2485
2483: oJumpBack 2408
2485: oGetLocal 1
2487: oPushResult
2488: oNodeVecDelete
2489: oPop 1
2491: oInputChoice 2499
2493: oJumpForward 2507
2495: oJumpForward 2505
2497: oJumpForward 2505
2499: Choice Lookup Table
           5   2497
          15   2493
2504: oEndChoice
2505: oJumpBack 2293
2507: oJumpForward 2512
2509: Choice Lookup Table
          14   2293
2512: oReturn
2513: oLocalSpace 0
2515: oInputChoice 2530
2517: oInputChoice 2523
2519: oCall 2647
2521: oJumpForward 2528
2523: Choice Lookup Table
          12   2519
2526: oCall 2538
2528: oJumpForward 2535
2530: Choice Lookup Table
           0   2517
2533: oJumpForward 2537
2535: oJumpBack 2515
2537: oReturn
2538: oLocalSpace 2
2540: oGetAddrLocal 1
2542: oPushResult
2543: LAST_ID
2544: oAssign
2545: oInput 6
2547: oCall 3526
2549: oTypeSNodeType
2550: oChoice 2606
2552: oGetAddrLocal 2
2554: oPushResult
2555: oSetResult 16
2557: oPushResult
2558: oGetLocal 1
2560: oPushResult
2561: oCall 13078
2563: oPop 2
2565: oAssign
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 22
2571: oPushResult
2572: oValueTop
2573: oPushResult
2574: oNodeSetInt
2575: oPop 3
2577: oJumpForward 2625
2579: oGetAddrLocal 2
2581: oPushResult
2582: oSetResult 18
2584: oPushResult
2585: oGetLocal 1
2587: oPushResult
2588: oCall 13078
2590: oPop 2
2592: oAssign
2593: oGetLocal 2
2595: oPushResult
2596: oSetResult 33
2598: oPushResult
2599: oValueTopString
2600: oPushResult
2601: oNodeSetString
2602: oPop 3
2604: oJumpForward 2625
2606: Choice Lookup Table
          39   2579
          35   2552
          34   2552
          41   2552
          29   2552
          33   2552
          30   2552
          31   2552
2623: oError 17
2625: oValuePop
2626: oGetLocal 2
2628: oPushResult
2629: oSetResult 21
2631: oPushResult
2632: oTypeSTop
2633: oPushResult
2634: oNodeSet
2635: oPop 3
2637: oTypeSPop
2638: oGetLocal 2
2640: oPushResult
2641: oScopeDeclare
2642: oPop 1
2644: oInput 5
2646: oReturn
2647: oLocalSpace 3
2649: oGetAddrLocal 1
2651: oPushResult
2652: oSetResult 25
2654: oPushResult
2655: LAST_ID
2656: oPushResult
2657: oCall 13078
2659: oPop 2
2661: oAssign
2662: oGetAddrLocal 2
2664: oPushResult
2665: oCall 11046
2667: oPop 1
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 21
2674: oPushResult
2675: oGetLocal 2
2677: oPushResult
2678: oNodeSet
2679: oPop 3
2681: oGetLocal 2
2683: oPushResult
2684: oNodeType
2685: oPop 1
2687: oChoice 2791
2689: oInput 6
2691: oGetLocal 2
2693: oPushResult
2694: oTypeSPush
2695: oPop 1
2697: oCall 3526
2699: oCall 4268
2701: oGetLocal 1
2703: oPushResult
2704: oSetResult 22
2706: oPushResult
2707: oValueTop
2708: oPushResult
2709: oNodeSetInt
2710: oPop 3
2712: oValuePop
2713: oTypeSPop
2714: oGetLocal 1
2716: oPushResult
2717: oScopeDeclare
2718: oPop 1
2720: oInput 5
2722: oJumpForward 2815
2724: oError 16
2726: oJumpForward 2815
2728: oGetGlobal 2
2730: oPushResult
2731: oScopeEnter
2732: oPop 1
2734: oGetAddrLocal 3
2736: oPushResult
2737: oGetLocal 2
2739: oPushResult
2740: oScopeAllocType
2741: oPop 1
2743: oAssign
2744: oScopeEnd
2745: oGetGlobal 2
2747: oPushResult
2748: oCall 12976
2750: oPop 1
2752: oPushResult
2753: oCodePush
2754: oPop 1
2756: oGetLocal 1
2758: oPushResult
2759: oSetResult 22
2761: oPushResult
2762: oGetLocal 3
2764: oPushResult
2765: oNodeSetInt
2766: oPop 3
2768: oInput 6
2770: oGetLocal 2
2772: oPushResult
2773: oGetLocal 3
2775: oPushResult
2776: oCall 2816
2778: oPop 2
2780: oCodePop
2781: oGetLocal 1
2783: oPushResult
2784: oScopeDeclare
2785: oPop 1
2787: oInput 5
2789: oJumpForward 2815
2791: Choice Lookup Table
          38   2728
          36   2728
          28   2724
          40   2724
          35   2689
          34   2689
          41   2689
          29   2689
          33   2689
          30   2689
          31   2689
2814: oEndChoice
2815: oReturn
2816: oLocalSpace 10
2818: oGetParam 2
2820: oPushResult
2821: oNodeType
2822: oPop 1
2824: oChoice 3146
2826: oGetAddrLocal 1
2828: oPushResult
2829: oGetParam 2
2831: oPushResult
2832: oSetResult 37
2834: oPushResult
2835: oNodeGet
2836: oPop 2
2838: oAssign
2839: oGetAddrLocal 2
2841: oPushResult
2842: oGetParam 2
2844: oPushResult
2845: oSetResult 38
2847: oPushResult
2848: oNodeGet
2849: oPop 2
2851: oAssign
2852: oGetAddrLocal 3
2854: oPushResult
2855: oGetLocal 2
2857: oPushResult
2858: oCall 12209
2860: oPop 1
2862: oAssign
2863: oGetAddrLocal 4
2865: oPushResult
2866: oGetLocal 2
2868: oPushResult
2869: oCall 12304
2871: oPop 1
2873: oAssign
2874: oGetAddrLocal 5
2876: oPushResult
2877: oGetLocal 1
2879: oPushResult
2880: oSetResult 17
2882: oPushResult
2883: oNodeGetInt
2884: oPop 2
2886: oAssign
2887: oInput 14
2889: oGetAddrLocal 6
2891: oPushResult
2892: oGetLocal 3
2894: oAssign
2895: oGetLocal 1
2897: oPushResult
2898: oGetParam 1
2900: oPushResult
2901: oCall 2816
2903: oPop 2
2905: oGetLocal 6
2907: oPushResult
2908: oGetLocal 4
2910: oPushResult
2911: equal
2912: oPop 2
2914: oChoice 2922
2916: oJumpForward 2951
2918: oJumpForward 2928
2920: oJumpForward 2928
2922: Choice Lookup Table
           0   2920
           1   2916
2927: oEndChoice
2928: oInput 13
2930: oGetAddrParam 1
2932: oPushResult
2933: oGetParam 1
2935: oPushResult
2936: oGetLocal 5
2938: oPushResult
2939: add
2940: oPop 2
2942: oAssign
2943: oGetAddrLocal 6
2945: oPushResult
2946: inc
2947: oPop 1
2949: oJumpBack 2895
2951: oInput 15
2953: oJumpForward 3170
2955: oInput 14
2957: oGetAddrLocal 7
2959: oPushResult
2960: oGetParam 2
2962: oPushResult
2963: oSetResult 41
2965: oPushResult
2966: oNodeGet
2967: oPop 2
2969: oAssign
2970: oInputChoice 2974
2972: oJumpForward 2979
2974: Choice Lookup Table
           0   2972
2977: oJumpForward 3045
2979: oGetAddrLocal 8
2981: oPushResult
2982: oGetLocal 7
2984: oPushResult
2985: oScopeFindRequireInScope
2986: oPop 1
2988: oAssign
2989: oInput 12
2991: oGetAddrLocal 9
2993: oPushResult
2994: oGetLocal 8
2996: oPushResult
2997: oSetResult 21
2999: oPushResult
3000: oNodeGet
3001: oPop 2
3003: oAssign
3004: oGetAddrLocal 10
3006: oPushResult
3007: oGetParam 1
3009: oPushResult
3010: oGetLocal 8
3012: oPushResult
3013: oSetResult 22
3015: oPushResult
3016: oNodeGetInt
3017: oPop 2
3019: oPushResult
3020: add
3021: oPop 2
3023: oAssign
3024: oGetLocal 9
3026: oPushResult
3027: oGetLocal 10
3029: oPushResult
3030: oCall 2816
3032: oPop 2
3034: oInputChoice 3038
3036: oJumpForward 3043
3038: Choice Lookup Table
           5   3036
3041: oJumpForward 3045
3043: oJumpBack 2970
3045: oInput 15
3047: oJumpForward 3170
3049: oEmit 16
3051: oGetParam 1
3053: oPushResult
3054: oEmitInt
3055: oPop 1
3057: oGetParam 2
3059: oPushResult
3060: oTypeSPush
3061: oPop 1
3063: oCall 3526
3065: oCall 4268
3067: oEmit 15
3069: oValueTop
3070: oPushResult
3071: oEmitInt
3072: oPop 1
3074: oValuePop
3075: oTypeSPop
3076: oEmit 27
3078: oJumpForward 3170
3080: oEmit 16
3082: oGetParam 1
3084: oPushResult
3085: oEmitInt
3086: oPop 1
3088: oGetParam 2
3090: oPushResult
3091: oTypeSPush
3092: oPop 1
3094: oCall 3526
3096: oCall 4268
3098: oEmit 15
3100: oValueTop
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oValuePop
3106: oTypeSPop
3107: oEmit 26
3109: oJumpForward 3170
3111: oEmit 16
3113: oGetParam 1
3115: oPushResult
3116: oEmitInt
3117: oPop 1
3119: oGetParam 2
3121: oPushResult
3122: oTypeSPush
3123: oPop 1
3125: oCall 3526
3127: oCall 4268
3129: oEmit 15
3131: oValueTop
3132: oPushResult
3133: oEmitInt
3134: oPop 1
3136: oValuePop
3137: oTypeSPop
3138: oEmit 28
3140: oJumpForward 3170
3142: oError 16
3144: oJumpForward 3170
3146: Choice Lookup Table
          28   3142
          40   3142
          35   3111
          34   3111
          41   3080
          29   3080
          33   3049
          30   3049
          31   3049
          38   2955
          36   2826
3169: oEndChoice
3170: oReturn
3171: oLocalSpace 2
3173: oInputChoice 3219
3175: oGetAddrLocal 1
3177: oPushResult
3178: oSetResult 19
3180: oPushResult
3181: LAST_ID
3182: oPushResult
3183: oCall 13078
3185: oPop 2
3187: oAssign
3188: oInput 6
3190: oGetAddrLocal 2
3192: oPushResult
3193: oCall 11046
3195: oPop 1
3197: oGetLocal 1
3199: oPushResult
3200: oSetResult 21
3202: oPushResult
3203: oGetLocal 2
3205: oPushResult
3206: oNodeSet
3207: oPop 3
3209: oGetLocal 1
3211: oPushResult
3212: oScopeDeclare
3213: oPop 1
3215: oInput 5
3217: oJumpForward 3224
3219: Choice Lookup Table
           0   3175
3222: oJumpForward 3226
3224: oJumpBack 3173
3226: oReturn
3227: oLocalSpace 6
3229: oInputChoice 3453
3231: oGetAddrLocal 1
3233: oPushResult
3234: oNodeVecNew
3235: oAssign
3236: oGetAddrLocal 2
3238: oPushResult
3239: oGetParam 1
3241: oPushResult
3242: LAST_ID
3243: oPushResult
3244: oCall 13078
3246: oPop 2
3248: oAssign
3249: oGetLocal 1
3251: oPushResult
3252: oGetLocal 2
3254: oPushResult
3255: oNodeVecAppend
3256: oPop 2
3258: oInputChoice 3264
3260: oInput 0
3262: oJumpForward 3269
3264: Choice Lookup Table
          13   3260
3267: oJumpForward 3271
3269: oJumpBack 3236
3271: oInput 12
3273: oGetAddrLocal 3
3275: oPushResult
3276: oCall 11046
3278: oPop 1
3280: oGetAddrLocal 4
3282: oPushResult
3283: oSetResult 0
3285: oAssign
3286: oGetLocal 4
3288: oPushResult
3289: oGetLocal 1
3291: oPushResult
3292: oNodeVecSize
3293: oPop 1
3295: oPushResult
3296: equal
3297: oPop 2
3299: oChoice 3340
3301: oGetAddrLocal 2
3303: oPushResult
3304: oGetLocal 1
3306: oPushResult
3307: oGetLocal 4
3309: oPushResult
3310: oNodeVecElement
3311: oPop 2
3313: oAssign
3314: oGetLocal 2
3316: oPushResult
3317: oSetResult 21
3319: oPushResult
3320: oGetLocal 3
3322: oPushResult
3323: oNodeSet
3324: oPop 3
3326: oGetLocal 2
3328: oPushResult
3329: oScopeDeclareAlloc
3330: oPop 1
3332: oGetAddrLocal 4
3334: oPushResult
3335: inc
3336: oPop 1
3338: oJumpForward 3345
3340: Choice Lookup Table
           0   3301
3343: oJumpForward 3347
3345: oJumpBack 3286
3347: oInputChoice 3440
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oChoice 3359
3357: oJumpForward 3364
3359: Choice Lookup Table
           1   3357
3362: oError 22
3364: oGetAddrLocal 5
3366: oPushResult
3367: oScopeCurrent
3368: oPushResult
3369: oCall 12976
3371: oPop 1
3373: oAssign
3374: oGetLocal 5
3376: oPushResult
3377: oCodePush
3378: oPop 1
3380: oGetAddrLocal 6
3382: oPushResult
3383: oSetResult 0
3385: oAssign
3386: oCall 13028
3388: oPushResult
3389: equal_zero
3390: oPop 1
3392: oChoice 3408
3394: oGetGlobal 3
3396: oPushResult
3397: oScopeEnter
3398: oPop 1
3400: oGetAddrLocal 6
3402: oPushResult
3403: oSetResult 1
3405: oAssign
3406: oJumpForward 3411
3408: Choice Lookup Table
           1   3394
3411: oGetLocal 2
3413: oPushResult
3414: oSetResult 1
3416: oPushResult
3417: oCall 8614
3419: oPop 2
3421: oCall 4606
3423: oCall 7796
3425: oCall 8370
3427: oGetLocal 6
3429: oChoice 3434
3431: oScopeEnd
3432: oJumpForward 3437
3434: Choice Lookup Table
           1   3431
3437: oCodePop
3438: oJumpForward 3443
3440: Choice Lookup Table
           6   3349
3443: oGetLocal 1
3445: oPushResult
3446: oNodeVecDelete
3447: oPop 1
3449: oInput 5
3451: oJumpForward 3458
3453: Choice Lookup Table
           0   3231
3456: oJumpForward 3460
3458: oJumpBack 3229
3460: oReturn
3461: oLocalSpace 2
3463: oInputChoice 3470
3465: oJumpForward 3476
3467: oChangeIntLitToLabelIdent
3468: oJumpForward 3476
3470: Choice Lookup Table
           1   3467
           0   3465
3475: oEndChoice
3476: oGetAddrLocal 1
3478: oPushResult
3479: oSetResult 26
3481: oPushResult
3482: LAST_ID
3483: oPushResult
3484: oCall 13078
3486: oPop 2
3488: oAssign
3489: oGetAddrLocal 2
3491: oPushResult
3492: oLabelNew
3493: oAssign
3494: oGetLocal 1
3496: oPushResult
3497: oSetResult 22
3499: oPushResult
3500: oGetLocal 2
3502: oPushResult
3503: oNodeSetLabel
3504: oPop 3
3506: oGetLocal 1
3508: oPushResult
3509: oScopeDeclare
3510: oPop 1
3512: oInputChoice 3516
3514: oJumpForward 3521
3516: Choice Lookup Table
          13   3514
3519: oJumpForward 3523
3521: oJumpBack 3463
3523: oInput 5
3525: oReturn
3526: oLocalSpace 0
3528: oCall 3730
3530: oInputChoice 3712
3532: oCall 3753
3534: oCall 4171
3536: oTypeSNodeType
3537: oChoice 3549
3539: oValueStringCmp
3540: oSetResult 0
3542: oPushResult
3543: oValuePush
3544: oPop 1
3546: oValueEqual
3547: oJumpForward 3553
3549: Choice Lookup Table
          39   3539
3552: oValueEqual
3553: oTypeSPop
3554: oGetGlobal 7
3556: oPushResult
3557: oTypeSPush
3558: oPop 1
3560: oJumpForward 3727
3562: oCall 3730
3564: oCall 4171
3566: oTypeSNodeType
3567: oChoice 3579
3569: oValueStringCmp
3570: oSetResult 0
3572: oPushResult
3573: oValuePush
3574: oPop 1
3576: oValueNotEqual
3577: oJumpForward 3583
3579: Choice Lookup Table
          39   3569
3582: oValueNotEqual
3583: oTypeSPop
3584: oGetGlobal 7
3586: oPushResult
3587: oTypeSPush
3588: oPop 1
3590: oJumpForward 3727
3592: oCall 3730
3594: oCall 4171
3596: oTypeSNodeType
3597: oChoice 3609
3599: oValueStringCmp
3600: oSetResult 0
3602: oPushResult
3603: oValuePush
3604: oPop 1
3606: oValueLess
3607: oJumpForward 3613
3609: Choice Lookup Table
          39   3599
3612: oValueLess
3613: oTypeSPop
3614: oGetGlobal 7
3616: oPushResult
3617: oTypeSPush
3618: oPop 1
3620: oJumpForward 3727
3622: oCall 3730
3624: oCall 4171
3626: oTypeSNodeType
3627: oChoice 3639
3629: oValueStringCmp
3630: oSetResult 0
3632: oPushResult
3633: oValuePush
3634: oPop 1
3636: oValueGreater
3637: oJumpForward 3643
3639: Choice Lookup Table
          39   3629
3642: oValueGreater
3643: oTypeSPop
3644: oGetGlobal 7
3646: oPushResult
3647: oTypeSPush
3648: oPop 1
3650: oJumpForward 3727
3652: oCall 3730
3654: oCall 4171
3656: oTypeSNodeType
3657: oChoice 3669
3659: oValueStringCmp
3660: oSetResult 0
3662: oPushResult
3663: oValuePush
3664: oPop 1
3666: oValueLessEqual
3667: oJumpForward 3673
3669: Choice Lookup Table
          39   3659
3672: oValueLessEqual
3673: oTypeSPop
3674: oGetGlobal 7
3676: oPushResult
3677: oTypeSPush
3678: oPop 1
3680: oJumpForward 3727
3682: oCall 3730
3684: oCall 4171
3686: oTypeSNodeType
3687: oChoice 3699
3689: oValueStringCmp
3690: oSetResult 0
3692: oPushResult
3693: oValuePush
3694: oPop 1
3696: oValueGreaterEqual
3697: oJumpForward 3703
3699: Choice Lookup Table
          39   3689
3702: oValueGreaterEqual
3703: oTypeSPop
3704: oGetGlobal 7
3706: oPushResult
3707: oTypeSPush
3708: oPop 1
3710: oJumpForward 3727
3712: Choice Lookup Table
          11   3682
          10   3652
           9   3622
           8   3592
           7   3562
           6   3532
3725: oJumpForward 3729
3727: oJumpBack 3530
3729: oReturn
3730: oLocalSpace 0
3732: oCall 3753
3734: oInputChoice 3745
3736: oCall 4158
3738: oCall 3753
3740: oCall 4144
3742: oValueOr
3743: oJumpForward 3750
3745: Choice Lookup Table
          57   3736
3748: oJumpForward 3752
3750: oJumpBack 3734
3752: oReturn
3753: oLocalSpace 0
3755: oCall 3776
3757: oInputChoice 3768
3759: oCall 4158
3761: oCall 3776
3763: oCall 4144
3765: oValueAnd
3766: oJumpForward 3773
3768: Choice Lookup Table
          56   3759
3771: oJumpForward 3775
3773: oJumpBack 3757
3775: oReturn
3776: oLocalSpace 0
3778: oInputChoice 3787
3780: oCall 3776
3782: oCall 4158
3784: oValueNot
3785: oJumpForward 3792
3787: Choice Lookup Table
          58   3780
3790: oCall 3793
3792: oReturn
3793: oLocalSpace 0
3795: oCall 3842
3797: oInputChoice 3832
3799: oCall 3842
3801: oCall 4171
3803: oTypeSNodeType
3804: oChoice 3809
3806: oValueStringConcat
3807: oJumpForward 3813
3809: Choice Lookup Table
          39   3806
3812: oValueAdd
3813: oJumpForward 3839
3815: oCall 3842
3817: oCall 4171
3819: oTypeSNodeType
3820: oChoice 3826
3822: oError 17
3824: oJumpForward 3830
3826: Choice Lookup Table
          39   3822
3829: oValueSub
3830: oJumpForward 3839
3832: Choice Lookup Table
          25   3815
          24   3799
3837: oJumpForward 3841
3839: oJumpBack 3797
3841: oReturn
3842: oLocalSpace 0
3844: oCall 3892
3846: oInputChoice 3882
3848: oCall 3892
3850: oCall 4171
3852: oTypeSNodeType
3853: oChoice 3859
3855: oError 17
3857: oJumpForward 3863
3859: Choice Lookup Table
          39   3855
3862: oValueMult
3863: oJumpForward 3889
3865: oCall 3892
3867: oCall 4171
3869: oTypeSNodeType
3870: oChoice 3876
3872: oError 17
3874: oJumpForward 3880
3876: Choice Lookup Table
          39   3872
3879: oValueDiv
3880: oJumpForward 3889
3882: Choice Lookup Table
          23   3865
          22   3848
3887: oJumpForward 3891
3889: oJumpBack 3846
3891: oReturn
3892: oLocalSpace 0
3894: oInputChoice 3905
3896: oCall 3913
3898: oJumpForward 3912
3900: oCall 3913
3902: oValueNegate
3903: oJumpForward 3912
3905: Choice Lookup Table
          25   3900
          24   3896
3910: oCall 3913
3912: oReturn
3913: oLocalSpace 1
3915: oInputChoice 4116
3917: TOKEN_VALUE
3918: oPushResult
3919: oValuePush
3920: oPop 1
3922: oGetGlobal 6
3924: oPushResult
3925: oTypeSPush
3926: oPop 1
3928: oJumpForward 4143
3930: TOKEN_VALUE
3931: oPushResult
3932: oValuePush
3933: oPop 1
3935: oGetGlobal 9
3937: oPushResult
3938: oTypeSPush
3939: oPop 1
3941: oJumpForward 4143
3943: CURRENT_STRLIT
3944: oPushResult
3945: oValuePushString
3946: oPop 1
3948: oGetGlobal 13
3950: oPushResult
3951: oTypeSPush
3952: oPop 1
3954: oJumpForward 4143
3956: oCall 3526
3958: oInput 15
3960: oJumpForward 4143
3962: oGetAddrLocal 1
3964: oPushResult
3965: oScopeFindRequire
3966: oAssign
3967: oGetAddrLocal 1
3969: oPushResult
3970: oCall 244
3972: oPop 1
3974: oGetLocal 1
3976: oPushResult
3977: oNodeType
3978: oPop 1
3980: oChoice 4075
3982: oGetLocal 1
3984: oPushResult
3985: oCall 4389
3987: oPop 1
3989: oJumpForward 4098
3991: oGetLocal 1
3993: oPushResult
3994: oSetResult 22
3996: oPushResult
3997: oNodeGetInt
3998: oPop 2
4000: oPushResult
4001: oValuePush
4002: oPop 1
4004: oGetLocal 1
4006: oPushResult
4007: oSetResult 21
4009: oPushResult
4010: oNodeGet
4011: oPop 2
4013: oPushResult
4014: oTypeSPush
4015: oPop 1
4017: oJumpForward 4098
4019: oGetLocal 1
4021: oPushResult
4022: oSetResult 33
4024: oPushResult
4025: oNodeGetString
4026: oPop 2
4028: oPushResult
4029: oValuePushString
4030: oPop 1
4032: oGetLocal 1
4034: oPushResult
4035: oSetResult 21
4037: oPushResult
4038: oNodeGet
4039: oPop 2
4041: oPushResult
4042: oTypeSPush
4043: oPop 1
4045: oJumpForward 4098
4047: oGetLocal 1
4049: oPushResult
4050: oSetResult 22
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: oValuePush
4058: oPop 1
4060: oGetLocal 1
4062: oPushResult
4063: oSetResult 21
4065: oPushResult
4066: oNodeGet
4067: oPop 2
4069: oPushResult
4070: oTypeSPush
4071: oPop 1
4073: oJumpForward 4098
4075: Choice Lookup Table
          17   4047
          18   4019
          16   3991
          14   3982
4084: oError 1
4086: oSetResult 0
4088: oPushResult
4089: oValuePush
4090: oPop 1
4092: oGetGlobal 6
4094: oPushResult
4095: oTypeSPush
4096: oPop 1
4098: oJumpForward 4143
4100: oError 16
4102: oSetResult 0
4104: oPushResult
4105: oValuePush
4106: oPop 1
4108: oGetGlobal 12
4110: oPushResult
4111: oTypeSPush
4112: oPop 1
4114: oJumpForward 4143
4116: Choice Lookup Table
          19   4100
           0   3962
          14   3956
           2   3943
           3   3930
           1   3917
4129: oError 1
4131: oSetResult 0
4133: oPushResult
4134: oValuePush
4135: oPop 1
4137: oGetGlobal 6
4139: oPushResult
4140: oTypeSPush
4141: oPop 1
4143: oReturn
4144: oLocalSpace 0
4146: oTypeSNodeType
4147: oChoice 4151
4149: oJumpForward 4156
4151: Choice Lookup Table
          31   4149
4154: oError 8
4156: oTypeSPop
4157: oReturn
4158: oLocalSpace 0
4160: oTypeSNodeType
4161: oChoice 4165
4163: oJumpForward 4170
4165: Choice Lookup Table
          31   4163
4168: oError 8
4170: oReturn
4171: oLocalSpace 1
4173: oGetAddrLocal 1
4175: oPushResult
4176: oTypeSNodeType
4177: oAssign
4178: oTypeSPop
4179: oGetLocal 1
4181: oPushResult
4182: oTypeSNodeType
4183: oPushResult
4184: equal_node_type
4185: oPop 2
4187: oChoice 4264
4189: oTypeSNodeType
4190: oChoice 4251
4192: oGetLocal 1
4194: oChoice 4199
4196: oReturn
4197: oJumpForward 4202
4199: Choice Lookup Table
          35   4196
4202: oJumpForward 4260
4204: oGetLocal 1
4206: oChoice 4211
4208: oReturn
4209: oJumpForward 4214
4211: Choice Lookup Table
          34   4208
4214: oJumpForward 4260
4216: oGetLocal 1
4218: oChoice 4224
4220: oValueCharToString
4221: oReturn
4222: oJumpForward 4227
4224: Choice Lookup Table
          33   4220
4227: oJumpForward 4260
4229: oGetLocal 1
4231: oChoice 4246
4233: oValueSwap
4234: oValueCharToString
4235: oValueSwap
4236: oTypeSPop
4237: oGetGlobal 13
4239: oPushResult
4240: oTypeSPush
4241: oPop 1
4243: oReturn
4244: oJumpForward 4249
4246: Choice Lookup Table
          39   4233
4249: oJumpForward 4260
4251: Choice Lookup Table
          33   4229
          39   4216
          35   4204
          34   4192
4260: oError 14
4262: oJumpForward 4267
4264: Choice Lookup Table
           0   4189
4267: oReturn
4268: oLocalSpace 1
4270: oGetAddrLocal 1
4272: oPushResult
4273: oTypeSNodeType
4274: oAssign
4275: oTypeSPop
4276: oGetLocal 1
4278: oPushResult
4279: oTypeSNodeType
4280: oPushResult
4281: equal_node_type
4282: oPop 2
4284: oChoice 4385
4286: oTypeSNodeType
4287: oChoice 4368
4289: oGetLocal 1
4291: oChoice 4296
4293: oReturn
4294: oJumpForward 4299
4296: Choice Lookup Table
          30   4293
4299: oJumpForward 4381
4301: oGetLocal 1
4303: oChoice 4308
4305: oReturn
4306: oJumpForward 4311
4308: Choice Lookup Table
          29   4305
4311: oJumpForward 4381
4313: oGetLocal 1
4315: oChoice 4320
4317: oReturn
4318: oJumpForward 4323
4320: Choice Lookup Table
          35   4317
4323: oJumpForward 4381
4325: oGetLocal 1
4327: oChoice 4332
4329: oReturn
4330: oJumpForward 4335
4332: Choice Lookup Table
          34   4329
4335: oJumpForward 4381
4337: oGetLocal 1
4339: oChoice 4345
4341: oValueCharToString
4342: oReturn
4343: oJumpForward 4348
4345: Choice Lookup Table
          33   4341
4348: oJumpForward 4381
4350: oGetLocal 1
4352: oChoice 4361
4354: oReturn
4355: oJumpForward 4366
4357: oValueCharToString
4358: oReturn
4359: oJumpForward 4366
4361: Choice Lookup Table
          33   4357
          39   4354
4366: oJumpForward 4381
4368: Choice Lookup Table
          40   4350
          39   4337
          35   4325
          34   4313
          30   4301
          29   4289
4381: oError 14
4383: oJumpForward 4388
4385: Choice Lookup Table
           0   4286
4388: oReturn
4389: oLocalSpace 0
4391: oGetParam 1
4393: oPushResult
4394: oGetGlobal 15
4396: oPushResult
4397: oNodeEqual
4398: oPop 2
4400: oChoice 4440
4402: oInput 14
4404: oCall 3526
4406: oInput 15
4408: oTypeSNodeType
4409: oChoice 4415
4411: oJumpForward 4428
4413: oJumpForward 4428
4415: Choice Lookup Table
          33   4413
          30   4413
          31   4413
          41   4411
          29   4411
4426: oError 14
4428: oTypeSPop
4429: oGetGlobal 6
4431: oPushResult
4432: oTypeSPush
4433: oPop 1
4435: oInput 15
4437: oReturn
4438: oJumpForward 4443
4440: Choice Lookup Table
           1   4402
4443: oGetParam 1
4445: oPushResult
4446: oGetGlobal 16
4448: oPushResult
4449: oNodeEqual
4450: oPop 2
4452: oChoice 4486
4454: oInput 14
4456: oCall 3526
4458: oInput 15
4460: oTypeSNodeType
4461: oChoice 4467
4463: oJumpForward 4474
4465: oJumpForward 4474
4467: Choice Lookup Table
          30   4465
          29   4463
4472: oError 14
4474: oTypeSPop
4475: oGetGlobal 9
4477: oPushResult
4478: oTypeSPush
4479: oPop 1
4481: oInput 15
4483: oReturn
4484: oJumpForward 4489
4486: Choice Lookup Table
           1   4454
4489: oGetParam 1
4491: oPushResult
4492: oGetGlobal 17
4494: oPushResult
4495: oNodeEqual
4496: oPop 2
4498: oChoice 4543
4500: oInput 14
4502: oCall 3526
4504: oTypeSNodeType
4505: oChoice 4526
4507: oTypeSTop
4508: oPushResult
4509: oSetResult 44
4511: oPushResult
4512: oNodeGetBoolean
4513: oPop 2
4515: oChoice 4521
4517: oError 28
4519: oJumpForward 4524
4521: Choice Lookup Table
           1   4517
4524: oJumpForward 4531
4526: Choice Lookup Table
          41   4507
4529: oError 14
4531: oSetResult 1
4533: oPushResult
4534: oValuePush
4535: oPop 1
4537: oValueSub
4538: oInput 15
4540: oReturn
4541: oJumpForward 4546
4543: Choice Lookup Table
           1   4500
4546: oGetParam 1
4548: oPushResult
4549: oGetGlobal 18
4551: oPushResult
4552: oNodeEqual
4553: oPop 2
4555: oChoice 4600
4557: oInput 14
4559: oCall 3526
4561: oTypeSNodeType
4562: oChoice 4583
4564: oTypeSTop
4565: oPushResult
4566: oSetResult 44
4568: oPushResult
4569: oNodeGetBoolean
4570: oPop 2
4572: oChoice 4578
4574: oError 28
4576: oJumpForward 4581
4578: Choice Lookup Table
           1   4574
4581: oJumpForward 4588
4583: Choice Lookup Table
          41   4564
4586: oError 14
4588: oSetResult 1
4590: oPushResult
4591: oValuePush
4592: oPop 1
4594: oValueAdd
4595: oInput 15
4597: oReturn
4598: oJumpForward 4603
4600: Choice Lookup Table
           1   4557
4603: oError 16
4605: oReturn
4606: oLocalSpace 1
4608: oGetAddrLocal 1
4610: oPushResult
4611: oSetResult 0
4613: oAssign
4614: oGetAddrLocal 1
4616: oPushResult
4617: oCall 4767
4619: oPop 1
4621: oGetAddrLocal 1
4623: oPushResult
4624: oCall 4667
4626: oPop 1
4628: oReturn
4629: oLocalSpace 0
4631: oGetParam 1
4633: oPushResult
4634: oCall 4767
4636: oPop 1
4638: oTypeSNodeType
4639: oChoice 4658
4641: oJumpForward 4665
4643: oGetParam 1
4645: oPushResult
4646: oLabelNew
4647: oAssign
4648: oEmit 70
4650: oGetFromParam 1
4652: oPushResult
4653: oEmitLabel
4654: oPop 1
4656: oJumpForward 4665
4658: Choice Lookup Table
          31   4643
          32   4641
4663: oError 8
4665: oTypeSPop
4666: oReturn
4667: oLocalSpace 1
4669: oTypeSNodeType
4670: oChoice 4732
4672: oGetAddrLocal 1
4674: oPushResult
4675: oLabelNew
4676: oAssign
4677: oEmit 15
4679: oSetResult 1
4681: oPushResult
4682: oEmitInt
4683: oPop 1
4685: oEmit 68
4687: oGetLocal 1
4689: oPushResult
4690: oEmitLabel
4691: oPop 1
4693: oEmit 77
4695: oGetFromParam 1
4697: oPushResult
4698: oEmitLabel
4699: oPop 1
4701: oEmit 15
4703: oSetResult 0
4705: oPushResult
4706: oEmitInt
4707: oPop 1
4709: oEmit 77
4711: oGetLocal 1
4713: oPushResult
4714: oEmitLabel
4715: oPop 1
4717: oTypeSPop
4718: oGetGlobal 7
4720: oPushResult
4721: oTypeSPush
4722: oPop 1
4724: oGetParam 1
4726: oPushResult
4727: oSetResult 0
4729: oAssign
4730: oJumpForward 4735
4732: Choice Lookup Table
          32   4672
4735: oReturn
4736: oLocalSpace 0
4738: oTypeSNodeType
4739: oChoice 4763
4741: oGetParam 1
4743: oPushResult
4744: oLabelNew
4745: oAssign
4746: oEmit 70
4748: oGetFromParam 1
4750: oPushResult
4751: oEmitLabel
4752: oPop 1
4754: oTypeSPop
4755: oGetGlobal 8
4757: oPushResult
4758: oTypeSPush
4759: oPop 1
4761: oJumpForward 4766
4763: Choice Lookup Table
          31   4741
4766: oReturn
4767: oLocalSpace 0
4769: oGetParam 1
4771: oPushResult
4772: oCall 5300
4774: oPop 1
4776: oInputChoice 5282
4778: oGetParam 1
4780: oPushResult
4781: oCall 4667
4783: oPop 1
4785: oCall 8079
4787: oGetParam 1
4789: oPushResult
4790: oCall 5300
4792: oPop 1
4794: oGetParam 1
4796: oPushResult
4797: oCall 4667
4799: oPop 1
4801: oCall 8079
4803: oCall 7948
4805: oTypeSNodeType
4806: oChoice 4834
4808: oEmit 43
4810: oJumpForward 4853
4812: oEmit 49
4814: oJumpForward 4853
4816: oEmit 55
4818: oJumpForward 4853
4820: oCall 10007
4822: oEmit 15
4824: oSetResult 0
4826: oPushResult
4827: oEmitInt
4828: oPop 1
4830: oEmit 49
4832: oJumpForward 4853
4834: Choice Lookup Table
          39   4820
          40   4820
          35   4816
          34   4816
          41   4812
          29   4812
          33   4808
          31   4808
4851: oError 17
4853: oTypeSPop
4854: oGetGlobal 7
4856: oPushResult
4857: oTypeSPush
4858: oPop 1
4860: oJumpForward 5297
4862: oGetParam 1
4864: oPushResult
4865: oCall 4667
4867: oPop 1
4869: oCall 8079
4871: oGetParam 1
4873: oPushResult
4874: oCall 5300
4876: oPop 1
4878: oGetParam 1
4880: oPushResult
4881: oCall 4667
4883: oPop 1
4885: oCall 8079
4887: oCall 7948
4889: oTypeSNodeType
4890: oChoice 4918
4892: oEmit 44
4894: oJumpForward 4937
4896: oEmit 50
4898: oJumpForward 4937
4900: oEmit 56
4902: oJumpForward 4937
4904: oCall 10007
4906: oEmit 15
4908: oSetResult 0
4910: oPushResult
4911: oEmitInt
4912: oPop 1
4914: oEmit 50
4916: oJumpForward 4937
4918: Choice Lookup Table
          39   4904
          40   4904
          35   4900
          34   4900
          41   4896
          29   4896
          33   4892
          31   4892
4935: oError 17
4937: oTypeSPop
4938: oGetGlobal 7
4940: oPushResult
4941: oTypeSPush
4942: oPop 1
4944: oJumpForward 5297
4946: oGetParam 1
4948: oPushResult
4949: oCall 4667
4951: oPop 1
4953: oCall 8079
4955: oGetParam 1
4957: oPushResult
4958: oCall 5300
4960: oPop 1
4962: oGetParam 1
4964: oPushResult
4965: oCall 4667
4967: oPop 1
4969: oCall 8079
4971: oCall 7948
4973: oTypeSNodeType
4974: oChoice 5002
4976: oEmit 46
4978: oJumpForward 5021
4980: oEmit 52
4982: oJumpForward 5021
4984: oEmit 58
4986: oJumpForward 5021
4988: oCall 10007
4990: oEmit 15
4992: oSetResult 0
4994: oPushResult
4995: oEmitInt
4996: oPop 1
4998: oEmit 52
5000: oJumpForward 5021
5002: Choice Lookup Table
          39   4988
          40   4988
          35   4984
          34   4984
          41   4980
          29   4980
          33   4976
          31   4976
5019: oError 17
5021: oTypeSPop
5022: oGetGlobal 7
5024: oPushResult
5025: oTypeSPush
5026: oPop 1
5028: oJumpForward 5297
5030: oGetParam 1
5032: oPushResult
5033: oCall 4667
5035: oPop 1
5037: oCall 8079
5039: oGetParam 1
5041: oPushResult
5042: oCall 5300
5044: oPop 1
5046: oGetParam 1
5048: oPushResult
5049: oCall 4667
5051: oPop 1
5053: oCall 8079
5055: oCall 7948
5057: oTypeSNodeType
5058: oChoice 5086
5060: oEmit 45
5062: oJumpForward 5105
5064: oEmit 51
5066: oJumpForward 5105
5068: oEmit 57
5070: oJumpForward 5105
5072: oCall 10007
5074: oEmit 15
5076: oSetResult 0
5078: oPushResult
5079: oEmitInt
5080: oPop 1
5082: oEmit 51
5084: oJumpForward 5105
5086: Choice Lookup Table
          39   5072
          40   5072
          35   5068
          34   5068
          41   5064
          29   5064
          33   5060
          31   5060
5103: oError 17
5105: oTypeSPop
5106: oGetGlobal 7
5108: oPushResult
5109: oTypeSPush
5110: oPop 1
5112: oJumpForward 5297
5114: oGetParam 1
5116: oPushResult
5117: oCall 4667
5119: oPop 1
5121: oCall 8079
5123: oGetParam 1
5125: oPushResult
5126: oCall 5300
5128: oPop 1
5130: oGetParam 1
5132: oPushResult
5133: oCall 4667
5135: oPop 1
5137: oCall 8079
5139: oCall 7948
5141: oTypeSNodeType
5142: oChoice 5170
5144: oEmit 48
5146: oJumpForward 5189
5148: oEmit 54
5150: oJumpForward 5189
5152: oEmit 60
5154: oJumpForward 5189
5156: oCall 10007
5158: oEmit 15
5160: oSetResult 0
5162: oPushResult
5163: oEmitInt
5164: oPop 1
5166: oEmit 54
5168: oJumpForward 5189
5170: Choice Lookup Table
          39   5156
          40   5156
          35   5152
          34   5152
          41   5148
          29   5148
          33   5144
          31   5144
5187: oError 17
5189: oTypeSPop
5190: oGetGlobal 7
5192: oPushResult
5193: oTypeSPush
5194: oPop 1
5196: oJumpForward 5297
5198: oGetParam 1
5200: oPushResult
5201: oCall 4667
5203: oPop 1
5205: oCall 8079
5207: oGetParam 1
5209: oPushResult
5210: oCall 5300
5212: oPop 1
5214: oGetParam 1
5216: oPushResult
5217: oCall 4667
5219: oPop 1
5221: oCall 8079
5223: oCall 7948
5225: oTypeSNodeType
5226: oChoice 5254
5228: oEmit 47
5230: oJumpForward 5273
5232: oEmit 53
5234: oJumpForward 5273
5236: oEmit 59
5238: oJumpForward 5273
5240: oCall 10007
5242: oEmit 15
5244: oSetResult 0
5246: oPushResult
5247: oEmitInt
5248: oPop 1
5250: oEmit 53
5252: oJumpForward 5273
5254: Choice Lookup Table
          39   5240
          40   5240
          35   5236
          34   5236
          41   5232
          29   5232
          33   5228
          31   5228
5271: oError 17
5273: oTypeSPop
5274: oGetGlobal 7
5276: oPushResult
5277: oTypeSPush
5278: oPop 1
5280: oJumpForward 5297
5282: Choice Lookup Table
          11   5198
          10   5114
           9   5030
           8   4946
           7   4862
           6   4778
5295: oJumpForward 5299
5297: oJumpBack 4776
5299: oReturn
5300: oLocalSpace 1
5302: oGetAddrLocal 1
5304: oPushResult
5305: oSetResult 0
5307: oAssign
5308: oGetParam 1
5310: oPushResult
5311: oCall 5480
5313: oPop 1
5315: oInputChoice 5448
5317: oTypeSNodeType
5318: oChoice 5389
5320: oGetLocal 1
5322: oPushResult
5323: oSetResult 0
5325: oPushResult
5326: equal_label
5327: oPop 2
5329: oChoice 5338
5331: oGetAddrLocal 1
5333: oPushResult
5334: oLabelNew
5335: oAssign
5336: oJumpForward 5341
5338: Choice Lookup Table
           1   5331
5341: oEmit 68
5343: oGetLocal 1
5345: oPushResult
5346: oEmitLabel
5347: oPop 1
5349: oJumpForward 5396
5351: oGetParam 1
5353: oPushResult
5354: oCall 4736
5356: oPop 1
5358: oGetLocal 1
5360: oPushResult
5361: oSetResult 0
5363: oPushResult
5364: equal_label
5365: oPop 2
5367: oChoice 5376
5369: oGetAddrLocal 1
5371: oPushResult
5372: oLabelNew
5373: oAssign
5374: oJumpForward 5379
5376: Choice Lookup Table
           1   5369
5379: oEmit 68
5381: oGetLocal 1
5383: oPushResult
5384: oEmitLabel
5385: oPop 1
5387: oJumpForward 5396
5389: Choice Lookup Table
          31   5351
          32   5320
5394: oError 8
5396: oTypeSPop
5397: oEmit 77
5399: oGetFromParam 1
5401: oPushResult
5402: oEmitLabel
5403: oPop 1
5405: oGetParam 1
5407: oPushResult
5408: oSetResult 0
5410: oAssign
5411: oGetParam 1
5413: oPushResult
5414: oCall 5480
5416: oPop 1
5418: oTypeSNodeType
5419: oChoice 5432
5421: oJumpForward 5439
5423: oGetParam 1
5425: oPushResult
5426: oCall 4736
5428: oPop 1
5430: oJumpForward 5439
5432: Choice Lookup Table
          31   5423
          32   5421
5437: oError 8
5439: oTypeSPop
5440: oGetGlobal 8
5442: oPushResult
5443: oTypeSPush
5444: oPop 1
5446: oJumpForward 5453
5448: Choice Lookup Table
          57   5317
5451: oJumpForward 5455
5453: oJumpBack 5315
5455: oGetLocal 1
5457: oPushResult
5458: oSetResult 0
5460: oPushResult
5461: equal_label
5462: oPop 2
5464: oChoice 5476
5466: oEmit 77
5468: oGetLocal 1
5470: oPushResult
5471: oEmitLabel
5472: oPop 1
5474: oJumpForward 5479
5476: Choice Lookup Table
           0   5466
5479: oReturn
5480: oLocalSpace 2
5482: oGetAddrLocal 1
5484: oPushResult
5485: oSetResult 0
5487: oAssign
5488: oGetParam 1
5490: oPushResult
5491: oCall 5618
5493: oPop 1
5495: oInputChoice 5610
5497: oTypeSNodeType
5498: oChoice 5511
5500: oJumpForward 5518
5502: oGetParam 1
5504: oPushResult
5505: oCall 4736
5507: oPop 1
5509: oJumpForward 5518
5511: Choice Lookup Table
          31   5502
          32   5500
5516: oError 8
5518: oTypeSPop
5519: oGetLocal 1
5521: oPushResult
5522: oSetResult 0
5524: oPushResult
5525: equal_label
5526: oPop 2
5528: oChoice 5557
5530: oGetAddrLocal 1
5532: oPushResult
5533: oLabelNew
5534: oAssign
5535: oEmit 78
5537: oGetFromParam 1
5539: oPushResult
5540: oEmitLabel
5541: oPop 1
5543: oGetLocal 1
5545: oPushResult
5546: oEmitLabel
5547: oPop 1
5549: oGetParam 1
5551: oPushResult
5552: oGetLocal 1
5554: oAssign
5555: oJumpForward 5560
5557: Choice Lookup Table
           1   5530
5560: oGetAddrLocal 2
5562: oPushResult
5563: oSetResult 0
5565: oAssign
5566: oGetAddrLocal 2
5568: oPushResult
5569: oCall 5618
5571: oPop 1
5573: oTypeSNodeType
5574: oChoice 5587
5576: oJumpForward 5594
5578: oGetAddrLocal 2
5580: oPushResult
5581: oCall 4736
5583: oPop 1
5585: oJumpForward 5594
5587: Choice Lookup Table
          31   5578
          32   5576
5592: oError 8
5594: oEmit 78
5596: oGetLocal 2
5598: oPushResult
5599: oEmitLabel
5600: oPop 1
5602: oGetLocal 1
5604: oPushResult
5605: oEmitLabel
5606: oPop 1
5608: oJumpForward 5615
5610: Choice Lookup Table
          56   5497
5613: oJumpForward 5617
5615: oJumpBack 5495
5617: oReturn
5618: oLocalSpace 1
5620: oInputChoice 5674
5622: oGetAddrLocal 1
5624: oPushResult
5625: oSetResult 0
5627: oAssign
5628: oGetAddrLocal 1
5630: oPushResult
5631: oCall 5618
5633: oPop 1
5635: oTypeSNodeType
5636: oChoice 5665
5638: oGetParam 1
5640: oPushResult
5641: oLabelNew
5642: oAssign
5643: oEmit 68
5645: oGetFromParam 1
5647: oPushResult
5648: oEmitLabel
5649: oPop 1
5651: oEmit 77
5653: oGetLocal 1
5655: oPushResult
5656: oEmitLabel
5657: oPop 1
5659: oJumpForward 5672
5661: oEmit 42
5663: oJumpForward 5672
5665: Choice Lookup Table
          31   5661
          32   5638
5670: oError 8
5672: oJumpForward 5684
5674: Choice Lookup Table
          58   5622
5677: oGetParam 1
5679: oPushResult
5680: oCall 5685
5682: oPop 1
5684: oReturn
5685: oLocalSpace 2
5687: oGetAddrLocal 1
5689: oPushResult
5690: oSetResult 1
5692: oAssign
5693: oGetParam 1
5695: oPushResult
5696: oCall 5921
5698: oPop 1
5700: oInputChoice 5911
5702: oTypeSNodeType
5703: oChoice 5826
5705: oCall 8033
5707: oGetParam 1
5709: oPushResult
5710: oCall 5921
5712: oPop 1
5714: oTypeSNodeType
5715: oChoice 5723
5717: oEmit 22
5719: oCall 7581
5721: oJumpForward 5732
5723: Choice Lookup Table
          35   5717
          34   5717
5728: oCall 8053
5730: oEmit 37
5732: oJumpForward 5843
5734: oGetLocal 1
5736: oChoice 5752
5738: oGetAddrLocal 2
5740: oPushResult
5741: oCall 9790
5743: oAssign
5744: oGetAddrLocal 1
5746: oPushResult
5747: oSetResult 0
5749: oAssign
5750: oJumpForward 5755
5752: Choice Lookup Table
           1   5738
5755: oGetParam 1
5757: oPushResult
5758: oCall 5921
5760: oPop 1
5762: oTypeSNodeType
5763: oChoice 5801
5765: oCall 9899
5767: oEmit 17
5769: oGetLocal 2
5771: oPushResult
5772: oEmitInt
5773: oPop 1
5775: oGetGlobal 14
5777: oPushResult
5778: oTypeSPush
5779: oPop 1
5781: oJumpForward 5811
5783: oCall 9953
5785: oEmit 17
5787: oGetLocal 2
5789: oPushResult
5790: oEmitInt
5791: oPop 1
5793: oGetGlobal 14
5795: oPushResult
5796: oTypeSPush
5797: oPop 1
5799: oJumpForward 5811
5801: Choice Lookup Table
          33   5783
          39   5765
          40   5765
5808: oError 14
5810: oTypeSPop
5811: oJumpForward 5843
5813: oGetParam 1
5815: oPushResult
5816: oCall 5921
5818: oPop 1
5820: oCall 8033
5822: oCall 7581
5824: oJumpForward 5843
5826: Choice Lookup Table
          35   5813
          34   5813
          33   5734
          39   5734
          40   5734
          30   5705
          29   5705
5841: oError 17
5843: oJumpForward 5918
5845: oTypeSNodeType
5846: oChoice 5898
5848: oCall 8033
5850: oGetParam 1
5852: oPushResult
5853: oCall 5921
5855: oPop 1
5857: oCall 8053
5859: oEmit 40
5861: oJumpForward 5909
5863: oGetParam 1
5865: oPushResult
5866: oCall 5921
5868: oPop 1
5870: oTypeSNodeType
5871: oChoice 5885
5873: oCall 8033
5875: oCall 7637
5877: oJumpForward 5896
5879: oCall 7948
5881: oCall 7693
5883: oJumpForward 5896
5885: Choice Lookup Table
          35   5879
          34   5879
          30   5873
          29   5873
5894: oError 17
5896: oJumpForward 5909
5898: Choice Lookup Table
          35   5863
          34   5863
          30   5848
          29   5848
5907: oError 17
5909: oJumpForward 5918
5911: Choice Lookup Table
          25   5845
          24   5702
5916: oJumpForward 5920
5918: oJumpBack 5700
5920: oReturn
5921: oLocalSpace 0
5923: oGetParam 1
5925: oPushResult
5926: oCall 5972
5928: oPop 1
5930: oInputChoice 5962
5932: oCall 8033
5934: oGetParam 1
5936: oPushResult
5937: oCall 5972
5939: oPop 1
5941: oCall 8053
5943: oEmit 34
5945: oJumpForward 5969
5947: oCall 8033
5949: oGetParam 1
5951: oPushResult
5952: oCall 5972
5954: oPop 1
5956: oCall 8053
5958: oEmit 35
5960: oJumpForward 5969
5962: Choice Lookup Table
          23   5947
          22   5932
5967: oJumpForward 5971
5969: oJumpBack 5930
5971: oReturn
5972: oLocalSpace 0
5974: oInputChoice 6000
5976: oGetParam 1
5978: oPushResult
5979: oCall 6013
5981: oPop 1
5983: oCall 8053
5985: oJumpForward 6012
5987: oGetParam 1
5989: oPushResult
5990: oCall 6013
5992: oPop 1
5994: oCall 8053
5996: oEmit 41
5998: oJumpForward 6012
6000: Choice Lookup Table
          25   5987
          24   5976
6005: oGetParam 1
6007: oPushResult
6008: oCall 6013
6010: oPop 1
6012: oReturn
6013: oLocalSpace 7
6015: oInputChoice 6346
6017: oEmit 15
6019: TOKEN_VALUE
6020: oPushResult
6021: oEmitInt
6022: oPop 1
6024: oGetGlobal 6
6026: oPushResult
6027: oTypeSPush
6028: oPop 1
6030: oJumpForward 6367
6032: oEmit 15
6034: TOKEN_VALUE
6035: oPushResult
6036: oEmitInt
6037: oPop 1
6039: oGetGlobal 9
6041: oPushResult
6042: oTypeSPush
6043: oPop 1
6045: oJumpForward 6367
6047: oGetParam 1
6049: oPushResult
6050: oCall 4767
6052: oPop 1
6054: oInput 15
6056: oJumpForward 6367
6058: oGetAddrLocal 1
6060: oPushResult
6061: CURRENT_STRLIT
6062: oPushResult
6063: oStringAllocShortStringLit
6064: oPop 1
6066: oAssign
6067: oEmit 16
6069: oGetLocal 1
6071: oPushResult
6072: oEmitInt
6073: oPop 1
6075: oGetGlobal 13
6077: oPushResult
6078: oTypeSPush
6079: oPop 1
6081: oCall 7179
6083: oCall 7125
6085: oJumpForward 6367
6087: oGetAddrLocal 2
6089: oPushResult
6090: oScopeFindRequire
6091: oAssign
6092: oGetAddrLocal 2
6094: oPushResult
6095: oCall 244
6097: oPop 1
6099: oGetLocal 2
6101: oPushResult
6102: oNodeType
6103: oPop 1
6105: oChoice 6268
6107: oGetLocal 2
6109: oPushResult
6110: oCall 10102
6112: oPop 1
6114: oJumpForward 6295
6116: oGetLocal 2
6118: oPushResult
6119: oCall 10805
6121: oPop 1
6123: oJumpForward 6295
6125: oGetAddrLocal 3
6127: oPushResult
6128: oGetLocal 2
6130: oPushResult
6131: oSetResult 21
6133: oPushResult
6134: oNodeGet
6135: oPop 2
6137: oAssign
6138: oGetLocal 3
6140: oPushResult
6141: oTypeSPush
6142: oPop 1
6144: oTypeSNodeType
6145: oChoice 6169
6147: oEmit 15
6149: oGetLocal 2
6151: oPushResult
6152: oCall 13106
6154: oPop 1
6156: oJumpForward 6182
6158: oEmit 15
6160: oGetLocal 2
6162: oPushResult
6163: oCall 13106
6165: oPop 1
6167: oJumpForward 6182
6169: Choice Lookup Table
          35   6158
          34   6158
          31   6147
          41   6147
          29   6147
6180: oError 16
6182: oJumpForward 6295
6184: oGetAddrLocal 4
6186: oPushResult
6187: oGetLocal 2
6189: oPushResult
6190: oSetResult 22
6192: oPushResult
6193: oNodeGetInt
6194: oPop 2
6196: oAssign
6197: oGetLocal 4
6199: oPushResult
6200: equal_zero
6201: oPop 1
6203: oChoice 6236
6205: oGetAddrLocal 4
6207: oPushResult
6208: oGetLocal 2
6210: oPushResult
6211: oSetResult 33
6213: oPushResult
6214: oNodeGetString
6215: oPop 2
6217: oPushResult
6218: oStringAllocShortStringLit
6219: oPop 1
6221: oAssign
6222: oGetLocal 2
6224: oPushResult
6225: oSetResult 22
6227: oPushResult
6228: oGetLocal 4
6230: oPushResult
6231: oNodeSetInt
6232: oPop 3
6234: oJumpForward 6239
6236: Choice Lookup Table
           1   6205
6239: oEmit 16
6241: oGetLocal 4
6243: oPushResult
6244: oEmitInt
6245: oPop 1
6247: oGetGlobal 13
6249: oPushResult
6250: oTypeSPush
6251: oPop 1
6253: oCall 7179
6255: oCall 7125
6257: oJumpForward 6295
6259: oGetLocal 2
6261: oPushResult
6262: oCall 6368
6264: oPop 1
6266: oJumpForward 6295
6268: Choice Lookup Table
          25   6259
          24   6259
          22   6259
          21   6259
          18   6184
          17   6125
          16   6125
          14   6116
          13   6107
6287: oError 6
6289: oGetGlobal 6
6291: oPushResult
6292: oTypeSPush
6293: oPop 1
6295: oJumpForward 6367
6297: oInput 0
6299: oGetAddrLocal 5
6301: oPushResult
6302: oScopeFindRequire
6303: oAssign
6304: oGetAddrLocal 5
6306: oPushResult
6307: oCall 244
6309: oPop 1
6311: oGetLocal 5
6313: oPushResult
6314: oSetResult 0
6316: oPushResult
6317: oCall 8614
6319: oPop 2
6321: oGetAddrLocal 6
6323: oPushResult
6324: oTypeSTop
6325: oAssign
6326: oTypeSPop
6327: oGetAddrLocal 7
6329: oPushResult
6330: oGetLocal 6
6332: oPushResult
6333: oCall 12125
6335: oPop 1
6337: oAssign
6338: oGetLocal 7
6340: oPushResult
6341: oTypeSPush
6342: oPop 1
6344: oJumpForward 6367
6346: Choice Lookup Table
          19   6297
           0   6087
           2   6058
          14   6047
           3   6032
           1   6017
6359: oError 6
6361: oGetGlobal 6
6363: oPushResult
6364: oTypeSPush
6365: oPop 1
6367: oReturn
6368: oLocalSpace 2
6370: oGetAddrLocal 1
6372: oPushResult
6373: oGetParam 1
6375: oPushResult
6376: oSetResult 21
6378: oPushResult
6379: oNodeGet
6380: oPop 2
6382: oAssign
6383: oGetAddrLocal 2
6385: oPushResult
6386: oGetParam 1
6388: oPushResult
6389: oCall 13060
6391: oPop 1
6393: oAssign
6394: oGetLocal 1
6396: oPushResult
6397: oTypeSPush
6398: oPop 1
6400: oTypeSNodeType
6401: oChoice 7100
6403: oGetParam 1
6405: oPushResult
6406: oNodeType
6407: oPop 1
6409: oChoice 6555
6411: oEmit 0
6413: oGetParam 1
6415: oPushResult
6416: oCall 13106
6418: oPop 1
6420: oJumpForward 6565
6422: oGetLocal 2
6424: oPushResult
6425: equal_zero
6426: oPop 1
6428: oChoice 6441
6430: oEmit 3
6432: oGetParam 1
6434: oPushResult
6435: oCall 13106
6437: oPop 1
6439: oJumpForward 6459
6441: Choice Lookup Table
           1   6430
6444: oEmit 9
6446: oGetLocal 2
6448: oPushResult
6449: oEmitInt
6450: oPop 1
6452: oGetParam 1
6454: oPushResult
6455: oCall 13106
6457: oPop 1
6459: oJumpForward 6565
6461: oGetParam 1
6463: oPushResult
6464: oSetResult 34
6466: oPushResult
6467: oNodeGetBoolean
6468: oPop 2
6470: oChoice 6513
6472: oGetLocal 2
6474: oPushResult
6475: equal_zero
6476: oPop 1
6478: oChoice 6491
6480: oEmit 8
6482: oGetParam 1
6484: oPushResult
6485: oCall 13106
6487: oPop 1
6489: oJumpForward 6509
6491: Choice Lookup Table
           1   6480
6494: oEmit 14
6496: oGetLocal 2
6498: oPushResult
6499: oEmitInt
6500: oPop 1
6502: oGetParam 1
6504: oPushResult
6505: oCall 13106
6507: oPop 1
6509: oEmit 23
6511: oJumpForward 6553
6513: Choice Lookup Table
           1   6472
6516: oGetLocal 2
6518: oPushResult
6519: equal_zero
6520: oPop 1
6522: oChoice 6535
6524: oEmit 6
6526: oGetParam 1
6528: oPushResult
6529: oCall 13106
6531: oPop 1
6533: oJumpForward 6553
6535: Choice Lookup Table
           1   6524
6538: oEmit 12
6540: oGetLocal 2
6542: oPushResult
6543: oEmitInt
6544: oPop 1
6546: oGetParam 1
6548: oPushResult
6549: oCall 13106
6551: oPop 1
6553: oJumpForward 6565
6555: Choice Lookup Table
          24   6461
          22   6422
          25   6411
          21   6411
6564: oEndChoice
6565: oJumpForward 7124
6567: oGetParam 1
6569: oPushResult
6570: oNodeType
6571: oPop 1
6573: oChoice 6719
6575: oEmit 1
6577: oGetParam 1
6579: oPushResult
6580: oCall 13106
6582: oPop 1
6584: oJumpForward 6729
6586: oGetLocal 2
6588: oPushResult
6589: equal_zero
6590: oPop 1
6592: oChoice 6605
6594: oEmit 4
6596: oGetParam 1
6598: oPushResult
6599: oCall 13106
6601: oPop 1
6603: oJumpForward 6623
6605: Choice Lookup Table
           1   6594
6608: oEmit 10
6610: oGetLocal 2
6612: oPushResult
6613: oEmitInt
6614: oPop 1
6616: oGetParam 1
6618: oPushResult
6619: oCall 13106
6621: oPop 1
6623: oJumpForward 6729
6625: oGetParam 1
6627: oPushResult
6628: oSetResult 34
6630: oPushResult
6631: oNodeGetBoolean
6632: oPop 2
6634: oChoice 6677
6636: oGetLocal 2
6638: oPushResult
6639: equal_zero
6640: oPop 1
6642: oChoice 6655
6644: oEmit 8
6646: oGetParam 1
6648: oPushResult
6649: oCall 13106
6651: oPop 1
6653: oJumpForward 6673
6655: Choice Lookup Table
           1   6644
6658: oEmit 14
6660: oGetLocal 2
6662: oPushResult
6663: oEmitInt
6664: oPop 1
6666: oGetParam 1
6668: oPushResult
6669: oCall 13106
6671: oPop 1
6673: oEmit 24
6675: oJumpForward 6717
6677: Choice Lookup Table
           1   6636
6680: oGetLocal 2
6682: oPushResult
6683: equal_zero
6684: oPop 1
6686: oChoice 6699
6688: oEmit 7
6690: oGetParam 1
6692: oPushResult
6693: oCall 13106
6695: oPop 1
6697: oJumpForward 6717
6699: Choice Lookup Table
           1   6688
6702: oEmit 13
6704: oGetLocal 2
6706: oPushResult
6707: oEmitInt
6708: oPop 1
6710: oGetParam 1
6712: oPushResult
6713: oCall 13106
6715: oPop 1
6717: oJumpForward 6729
6719: Choice Lookup Table
          24   6625
          22   6586
          25   6575
          21   6575
6728: oEndChoice
6729: oJumpForward 7124
6731: oError 16
6733: oJumpForward 7124
6735: oGetParam 1
6737: oPushResult
6738: oNodeType
6739: oPop 1
6741: oChoice 6887
6743: oEmit 2
6745: oGetParam 1
6747: oPushResult
6748: oCall 13106
6750: oPop 1
6752: oJumpForward 6897
6754: oGetLocal 2
6756: oPushResult
6757: equal_zero
6758: oPop 1
6760: oChoice 6773
6762: oEmit 5
6764: oGetParam 1
6766: oPushResult
6767: oCall 13106
6769: oPop 1
6771: oJumpForward 6791
6773: Choice Lookup Table
           1   6762
6776: oEmit 11
6778: oGetLocal 2
6780: oPushResult
6781: oEmitInt
6782: oPop 1
6784: oGetParam 1
6786: oPushResult
6787: oCall 13106
6789: oPop 1
6791: oJumpForward 6897
6793: oGetParam 1
6795: oPushResult
6796: oSetResult 34
6798: oPushResult
6799: oNodeGetBoolean
6800: oPop 2
6802: oChoice 6845
6804: oGetLocal 2
6806: oPushResult
6807: equal_zero
6808: oPop 1
6810: oChoice 6823
6812: oEmit 8
6814: oGetParam 1
6816: oPushResult
6817: oCall 13106
6819: oPop 1
6821: oJumpForward 6841
6823: Choice Lookup Table
           1   6812
6826: oEmit 14
6828: oGetLocal 2
6830: oPushResult
6831: oEmitInt
6832: oPop 1
6834: oGetParam 1
6836: oPushResult
6837: oCall 13106
6839: oPop 1
6841: oEmit 25
6843: oJumpForward 6885
6845: Choice Lookup Table
           1   6804
6848: oGetLocal 2
6850: oPushResult
6851: equal_zero
6852: oPop 1
6854: oChoice 6867
6856: oEmit 8
6858: oGetParam 1
6860: oPushResult
6861: oCall 13106
6863: oPop 1
6865: oJumpForward 6885
6867: Choice Lookup Table
           1   6856
6870: oEmit 14
6872: oGetLocal 2
6874: oPushResult
6875: oEmitInt
6876: oPop 1
6878: oGetParam 1
6880: oPushResult
6881: oCall 13106
6883: oPop 1
6885: oJumpForward 6897
6887: Choice Lookup Table
          24   6793
          22   6754
          25   6743
          21   6743
6896: oEndChoice
6897: oInputChoice 6927
6899: oTypeSPop
6900: oGetLocal 1
6902: oPushResult
6903: oSetResult 37
6905: oPushResult
6906: oNodeGet
6907: oPop 2
6909: oPushResult
6910: oTypeSPush
6911: oPop 1
6913: oCall 7179
6915: oCall 7125
6917: oJumpForward 6932
6919: oCall 7374
6921: oCall 7179
6923: oCall 7125
6925: oJumpForward 6932
6927: Choice Lookup Table
          16   6919
          18   6899
6932: oJumpForward 7124
6934: oGetParam 1
6936: oPushResult
6937: oNodeType
6938: oPop 1
6940: oChoice 7084
6942: oEmit 16
6944: oGetParam 1
6946: oPushResult
6947: oCall 13106
6949: oPop 1
6951: oJumpForward 7094
6953: oGetLocal 2
6955: oPushResult
6956: equal_zero
6957: oPop 1
6959: oChoice 6972
6961: oEmit 17
6963: oGetParam 1
6965: oPushResult
6966: oCall 13106
6968: oPop 1
6970: oJumpForward 6990
6972: Choice Lookup Table
           1   6961
6975: oEmit 20
6977: oGetLocal 2
6979: oPushResult
6980: oEmitInt
6981: oPop 1
6983: oGetParam 1
6985: oPushResult
6986: oCall 13106
6988: oPop 1
6990: oJumpForward 7094
6992: oGetParam 1
6994: oPushResult
6995: oSetResult 34
6997: oPushResult
6998: oNodeGetBoolean
6999: oPop 2
7001: oChoice 7042
7003: oGetLocal 2
7005: oPushResult
7006: equal_zero
7007: oPop 1
7009: oChoice 7022
7011: oEmit 8
7013: oGetParam 1
7015: oPushResult
7016: oCall 13106
7018: oPop 1
7020: oJumpForward 7040
7022: Choice Lookup Table
           1   7011
7025: oEmit 14
7027: oGetLocal 2
7029: oPushResult
7030: oEmitInt
7031: oPop 1
7033: oGetParam 1
7035: oPushResult
7036: oCall 13106
7038: oPop 1
7040: oJumpForward 7082
7042: Choice Lookup Table
           1   7003
7045: oGetLocal 2
7047: oPushResult
7048: equal_zero
7049: oPop 1
7051: oChoice 7064
7053: oEmit 18
7055: oGetParam 1
7057: oPushResult
7058: oCall 13106
7060: oPop 1
7062: oJumpForward 7082
7064: Choice Lookup Table
           1   7053
7067: oEmit 21
7069: oGetLocal 2
7071: oPushResult
7072: oEmitInt
7073: oPop 1
7075: oGetParam 1
7077: oPushResult
7078: oCall 13106
7080: oPop 1
7082: oJumpForward 7094
7084: Choice Lookup Table
          24   6992
          22   6953
          25   6942
          21   6942
7093: oEndChoice
7094: oCall 7179
7096: oCall 7125
7098: oJumpForward 7124
7100: Choice Lookup Table
          40   6934
          38   6934
          36   6934
          35   6735
          34   6735
          28   6731
          33   6567
          30   6567
          31   6567
          41   6403
          29   6403
7123: oEndChoice
7124: oReturn
7125: oLocalSpace 0
7127: oTypeSNodeType
7128: oChoice 7152
7130: oEmit 23
7132: oJumpForward 7178
7134: oEmit 24
7136: oJumpForward 7178
7138: oError 16
7140: oJumpForward 7178
7142: oEmit 25
7144: oJumpForward 7178
7146: oError 29
7148: oJumpForward 7178
7150: oJumpForward 7178
7152: Choice Lookup Table
          40   7150
          39   7150
          38   7150
          36   7150
          35   7146
          34   7142
          28   7138
          33   7134
          30   7134
          31   7134
          41   7130
          29   7130
7177: oEndChoice
7178: oReturn
7179: oLocalSpace 0
7181: oInputChoice 7219
7183: oTypeSNodeType
7184: oChoice 7198
7186: oCall 7231
7188: oJumpForward 7209
7190: oCall 7374
7192: oJumpForward 7209
7194: oCall 7453
7196: oJumpForward 7209
7198: Choice Lookup Table
          40   7194
          39   7194
          34   7190
          36   7186
7207: oError 10
7209: oJumpForward 7228
7211: oCall 7483
7213: oJumpForward 7228
7215: oCall 7756
7217: oJumpForward 7228
7219: Choice Lookup Table
          18   7215
          20   7211
          16   7183
7226: oJumpForward 7230
7228: oJumpBack 7181
7230: oReturn
7231: oLocalSpace 3
7233: oTypeSNodeType
7234: oChoice 7238
7236: oJumpForward 7243
7238: Choice Lookup Table
          36   7236
7241: oError 10
7243: oTypeSNodeType
7244: oChoice 7248
7246: oJumpForward 7253
7248: Choice Lookup Table
          36   7246
7251: oError 13
7253: oGetAddrLocal 1
7255: oPushResult
7256: oTypeSTop
7257: oPushResult
7258: oSetResult 38
7260: oPushResult
7261: oNodeGet
7262: oPop 2
7264: oPushResult
7265: oCall 12209
7267: oPop 1
7269: oAssign
7270: oGetAddrLocal 2
7272: oPushResult
7273: oTypeSTop
7274: oPushResult
7275: oSetResult 37
7277: oPushResult
7278: oNodeGet
7279: oPop 2
7281: oAssign
7282: oTypeSPop
7283: oGetLocal 2
7285: oPushResult
7286: oTypeSPush
7287: oPop 1
7289: oCall 4606
7291: oCall 8006
7293: oGetLocal 1
7295: oPushResult
7296: equal_zero
7297: oPop 1
7299: oChoice 7313
7301: oEmit 15
7303: oGetLocal 1
7305: oPushResult
7306: oEmitInt
7307: oPop 1
7309: oEmit 40
7311: oJumpForward 7316
7313: Choice Lookup Table
           0   7301
7316: oGetAddrLocal 3
7318: oPushResult
7319: oGetLocal 2
7321: oPushResult
7322: oSetResult 17
7324: oPushResult
7325: oNodeGetInt
7326: oPop 2
7328: oAssign
7329: oGetLocal 3
7331: oPushResult
7332: oSetResult 1
7334: oPushResult
7335: equal
7336: oPop 2
7338: oChoice 7352
7340: oEmit 15
7342: oGetLocal 3
7344: oPushResult
7345: oEmitInt
7346: oPop 1
7348: oEmit 34
7350: oJumpForward 7355
7352: Choice Lookup Table
           0   7340
7355: oEmit 36
7357: oInputChoice 7365
7359: oJumpForward 7373
7361: oJumpForward 7371
7363: oJumpForward 7371
7365: Choice Lookup Table
          13   7363
          17   7359
7370: oEndChoice
7371: oJumpBack 7243
7373: oReturn
7374: oLocalSpace 2
7376: oTypeSNodeType
7377: oChoice 7381
7379: oJumpForward 7386
7381: Choice Lookup Table
          34   7379
7384: oError 29
7386: oGetAddrLocal 1
7388: oPushResult
7389: oTypeSTop
7390: oPushResult
7391: oSetResult 37
7393: oPushResult
7394: oNodeGet
7395: oPop 2
7397: oAssign
7398: oTypeSPop
7399: oGetLocal 1
7401: oPushResult
7402: oTypeSPush
7403: oPop 1
7405: oCall 4606
7407: oCall 8006
7409: oGetAddrLocal 2
7411: oPushResult
7412: oGetLocal 1
7414: oPushResult
7415: oSetResult 17
7417: oPushResult
7418: oNodeGetInt
7419: oPop 2
7421: oAssign
7422: oGetLocal 2
7424: oPushResult
7425: oSetResult 1
7427: oPushResult
7428: equal
7429: oPop 2
7431: oChoice 7445
7433: oEmit 15
7435: oGetLocal 2
7437: oPushResult
7438: oEmitInt
7439: oPop 1
7441: oEmit 34
7443: oJumpForward 7448
7445: Choice Lookup Table
           0   7433
7448: oEmit 36
7450: oInput 17
7452: oReturn
7453: oLocalSpace 0
7455: oTypeSNodeType
7456: oChoice 7460
7458: oJumpForward 7467
7460: Choice Lookup Table
          40   7458
          39   7458
7465: oError 29
7467: oTypeSPop
7468: oGetGlobal 9
7470: oPushResult
7471: oTypeSPush
7472: oPop 1
7474: oCall 4606
7476: oCall 8006
7478: oEmit 36
7480: oInput 17
7482: oReturn
7483: oLocalSpace 2
7485: oTypeSNodeType
7486: oChoice 7490
7488: oJumpForward 7495
7490: Choice Lookup Table
          38   7488
7493: oError 11
7495: oTypeSTop
7496: oPushResult
7497: oSetResult 41
7499: oPushResult
7500: oNodeGet
7501: oPop 2
7503: oPushResult
7504: oScopeEnter
7505: oPop 1
7507: oInput 0
7509: oGetAddrLocal 1
7511: oPushResult
7512: oScopeFindRequire
7513: oAssign
7514: oGetLocal 1
7516: oPushResult
7517: oNodeType
7518: oPop 1
7520: oChoice 7524
7522: oJumpForward 7529
7524: Choice Lookup Table
          23   7522
7527: oError 12
7529: oScopeEnd
7530: oGetAddrLocal 2
7532: oPushResult
7533: oGetLocal 1
7535: oPushResult
7536: oSetResult 22
7538: oPushResult
7539: oNodeGetInt
7540: oPop 2
7542: oAssign
7543: oGetLocal 2
7545: oPushResult
7546: equal_zero
7547: oPop 1
7549: oChoice 7563
7551: oEmit 15
7553: oGetLocal 2
7555: oPushResult
7556: oEmitInt
7557: oPop 1
7559: oEmit 36
7561: oJumpForward 7566
7563: Choice Lookup Table
           0   7551
7566: oTypeSPop
7567: oGetLocal 1
7569: oPushResult
7570: oSetResult 21
7572: oPushResult
7573: oNodeGet
7574: oPop 2
7576: oPushResult
7577: oTypeSPush
7578: oPop 1
7580: oReturn
7581: oLocalSpace 2
7583: oGetAddrLocal 1
7585: oPushResult
7586: oTypeSTop
7587: oPushResult
7588: oSetResult 37
7590: oPushResult
7591: oNodeGet
7592: oPop 2
7594: oAssign
7595: oGetAddrLocal 2
7597: oPushResult
7598: oGetLocal 1
7600: oPushResult
7601: oSetResult 17
7603: oPushResult
7604: oNodeGetInt
7605: oPop 2
7607: oAssign
7608: oGetLocal 2
7610: oPushResult
7611: oSetResult 1
7613: oPushResult
7614: equal
7615: oPop 2
7617: oChoice 7631
7619: oEmit 15
7621: oGetLocal 2
7623: oPushResult
7624: oEmitInt
7625: oPop 1
7627: oEmit 34
7629: oJumpForward 7634
7631: Choice Lookup Table
           0   7619
7634: oEmit 36
7636: oReturn
7637: oLocalSpace 2
7639: oGetAddrLocal 1
7641: oPushResult
7642: oTypeSTop
7643: oPushResult
7644: oSetResult 37
7646: oPushResult
7647: oNodeGet
7648: oPop 2
7650: oAssign
7651: oGetAddrLocal 2
7653: oPushResult
7654: oGetLocal 1
7656: oPushResult
7657: oSetResult 17
7659: oPushResult
7660: oNodeGetInt
7661: oPop 2
7663: oAssign
7664: oGetLocal 2
7666: oPushResult
7667: oSetResult 1
7669: oPushResult
7670: equal
7671: oPop 2
7673: oChoice 7687
7675: oEmit 15
7677: oGetLocal 2
7679: oPushResult
7680: oEmitInt
7681: oPop 1
7683: oEmit 34
7685: oJumpForward 7690
7687: Choice Lookup Table
           0   7675
7690: oEmit 39
7692: oReturn
7693: oLocalSpace 2
7695: oEmit 38
7697: oGetAddrLocal 1
7699: oPushResult
7700: oTypeSTop
7701: oPushResult
7702: oSetResult 37
7704: oPushResult
7705: oNodeGet
7706: oPop 2
7708: oAssign
7709: oGetAddrLocal 2
7711: oPushResult
7712: oGetLocal 1
7714: oPushResult
7715: oSetResult 17
7717: oPushResult
7718: oNodeGetInt
7719: oPop 2
7721: oAssign
7722: oGetLocal 2
7724: oPushResult
7725: oSetResult 1
7727: oPushResult
7728: equal
7729: oPop 2
7731: oChoice 7745
7733: oEmit 15
7735: oGetLocal 2
7737: oPushResult
7738: oEmitInt
7739: oPop 1
7741: oEmit 35
7743: oJumpForward 7748
7745: Choice Lookup Table
           0   7733
7748: oTypeSPop
7749: oGetGlobal 6
7751: oPushResult
7752: oTypeSPush
7753: oPop 1
7755: oReturn
7756: oLocalSpace 1
7758: oTypeSNodeType
7759: oChoice 7767
7761: oJumpForward 7774
7763: oError 29
7765: oJumpForward 7774
7767: Choice Lookup Table
          35   7763
          34   7761
7772: oError 9
7774: oEmit 25
7776: oGetAddrLocal 1
7778: oPushResult
7779: oTypeSTop
7780: oAssign
7781: oTypeSPop
7782: oGetLocal 1
7784: oPushResult
7785: oSetResult 37
7787: oPushResult
7788: oNodeGet
7789: oPop 2
7791: oPushResult
7792: oTypeSPush
7793: oPop 1
7795: oReturn
7796: oLocalSpace 2
7798: oGetAddrLocal 1
7800: oPushResult
7801: oTypeSNodeType
7802: oAssign
7803: oTypeSPop
7804: oGetLocal 1
7806: oPushResult
7807: oTypeSNodeType
7808: oPushResult
7809: equal_node_type
7810: oPop 2
7812: oChoice 7944
7814: oTypeSNodeType
7815: oChoice 7929
7817: oGetLocal 1
7819: oChoice 7826
7821: oEmit 30
7823: oReturn
7824: oJumpForward 7829
7826: Choice Lookup Table
          30   7821
7829: oJumpForward 7940
7831: oGetLocal 1
7833: oChoice 7840
7835: oEmit 31
7837: oReturn
7838: oJumpForward 7843
7840: Choice Lookup Table
          29   7835
7843: oJumpForward 7940
7845: oGetLocal 1
7847: oChoice 7880
7849: oReturn
7850: oJumpForward 7885
7852: oTypeSTop
7853: oPushResult
7854: oGetGlobal 10
7856: oPushResult
7857: equal_node
7858: oPop 2
7860: oChoice 7875
7862: oEmit 15
7864: oSetResult 1
7866: oPushResult
7867: oEmitInt
7868: oPop 1
7870: oEmit 36
7872: oReturn
7873: oJumpForward 7878
7875: Choice Lookup Table
           1   7862
7878: oJumpForward 7885
7880: Choice Lookup Table
          39   7852
          35   7849
7885: oJumpForward 7940
7887: oGetLocal 1
7889: oChoice 7894
7891: oReturn
7892: oJumpForward 7897
7894: Choice Lookup Table
          34   7891
7897: oJumpForward 7940
7899: oGetLocal 1
7901: oChoice 7922
7903: oReturn
7904: oJumpForward 7927
7906: oGetGlobal 9
7908: oPushResult
7909: oTypeSPush
7910: oPop 1
7912: oGetAddrLocal 2
7914: oPushResult
7915: oCall 9790
7917: oAssign
7918: oTypeSPop
7919: oReturn
7920: oJumpForward 7927
7922: Choice Lookup Table
          33   7906
          39   7903
7927: oJumpForward 7940
7929: Choice Lookup Table
          40   7899
          35   7887
          34   7845
          30   7831
          29   7817
7940: oError 14
7942: oJumpForward 7947
7944: Choice Lookup Table
           0   7814
7947: oReturn
7948: oLocalSpace 1
7950: oGetAddrLocal 1
7952: oPushResult
7953: oTypeSNodeType
7954: oAssign
7955: oTypeSPop
7956: oGetLocal 1
7958: oPushResult
7959: oTypeSNodeType
7960: oPushResult
7961: equal_node_type
7962: oPop 2
7964: oChoice 8002
7966: oTypeSNodeType
7967: oChoice 7993
7969: oGetLocal 1
7971: oChoice 7976
7973: oReturn
7974: oJumpForward 7979
7976: Choice Lookup Table
          35   7973
7979: oJumpForward 7998
7981: oGetLocal 1
7983: oChoice 7988
7985: oReturn
7986: oJumpForward 7991
7988: Choice Lookup Table
          34   7985
7991: oJumpForward 7998
7993: Choice Lookup Table
          35   7981
          34   7969
7998: oError 14
8000: oJumpForward 8005
8002: Choice Lookup Table
           0   7966
8005: oReturn
8006: oLocalSpace 0
8008: oTypeSNodeType
8009: oChoice 8013
8011: oJumpForward 8018
8013: Choice Lookup Table
          29   8011
8016: oError 7
8018: oTypeSPop
8019: oReturn
8020: oLocalSpace 0
8022: oTypeSNodeType
8023: oChoice 8027
8025: oJumpForward 8032
8027: Choice Lookup Table
          29   8025
8030: oError 7
8032: oReturn
8033: oLocalSpace 0
8035: oTypeSNodeType
8036: oChoice 8044
8038: oJumpForward 8051
8040: oEmit 30
8042: oJumpForward 8051
8044: Choice Lookup Table
          30   8040
          29   8038
8049: oError 7
8051: oTypeSPop
8052: oReturn
8053: oLocalSpace 0
8055: oTypeSNodeType
8056: oChoice 8071
8058: oJumpForward 8078
8060: oEmit 30
8062: oTypeSPop
8063: oGetGlobal 6
8065: oPushResult
8066: oTypeSPush
8067: oPop 1
8069: oJumpForward 8078
8071: Choice Lookup Table
          30   8060
          29   8058
8076: oError 7
8078: oReturn
8079: oLocalSpace 0
8081: oTypeSNodeType
8082: oChoice 8095
8084: oEmit 30
8086: oTypeSPop
8087: oGetGlobal 6
8089: oPushResult
8090: oTypeSPush
8091: oPop 1
8093: oJumpForward 8098
8095: Choice Lookup Table
          30   8084
8098: oReturn
8099: oLocalSpace 0
8101: oTypeSNodeType
8102: oChoice 8106
8104: oJumpForward 8111
8106: Choice Lookup Table
          31   8104
8109: oError 8
8111: oTypeSPop
8112: oReturn
8113: oLocalSpace 0
8115: oTypeSNodeType
8116: oChoice 8120
8118: oJumpForward 8125
8120: Choice Lookup Table
          31   8118
8123: oError 8
8125: oReturn
8126: oLocalSpace 0
8128: oInputChoice 8191
8130: oCall 9653
8132: oJumpForward 8222
8134: oCall 9660
8136: oJumpForward 8222
8138: oCall 9784
8140: oJumpForward 8222
8142: oCall 9787
8144: oJumpForward 8222
8146: oCall 8804
8148: oJumpForward 8222
8150: oCall 9127
8152: oJumpForward 8222
8154: oCall 8870
8156: oJumpForward 8222
8158: oCall 9047
8160: oJumpForward 8222
8162: oCall 9212
8164: oJumpForward 8222
8166: oCall 9180
8168: oJumpForward 8222
8170: oCall 9630
8172: oJumpForward 8222
8174: oCall 8223
8176: oJumpForward 8222
8178: oCall 9244
8180: oJumpForward 8222
8182: oCall 9578
8184: oJumpForward 8222
8186: oChangeIntLitToLabelIdent
8187: oCall 8223
8189: oJumpForward 8222
8191: Choice Lookup Table
           1   8186
          55   8182
          53   8178
           0   8174
          35   8170
          51   8166
          52   8162
          49   8158
          44   8154
          48   8150
          41   8146
          68   8142
          67   8138
          66   8134
          65   8130
8222: oReturn
8223: oLocalSpace 1
8225: oGetAddrLocal 1
8227: oPushResult
8228: oScopeFindRequire
8229: oAssign
8230: oGetAddrLocal 1
8232: oPushResult
8233: oCall 244
8235: oPop 1
8237: oGetLocal 1
8239: oPushResult
8240: oNodeType
8241: oPop 1
8243: oChoice 8283
8245: oGetLocal 1
8247: oPushResult
8248: oCall 8299
8250: oPop 1
8252: oCall 8126
8254: oJumpForward 8298
8256: oGetLocal 1
8258: oPushResult
8259: oCall 10102
8261: oPop 1
8263: oJumpForward 8298
8265: oGetLocal 1
8267: oPushResult
8268: oCall 8349
8270: oPop 1
8272: oJumpForward 8298
8274: oGetLocal 1
8276: oPushResult
8277: oCall 8439
8279: oPop 1
8281: oJumpForward 8298
8283: Choice Lookup Table
          13   8274
          24   8265
          22   8265
          21   8265
          12   8256
          26   8245
8296: oError 0
8298: oReturn
8299: oLocalSpace 0
8301: oGetParam 1
8303: oPushResult
8304: oSetResult 35
8306: oPushResult
8307: oNodeGetBoolean
8308: oPop 2
8310: oChoice 8316
8312: oError 21
8314: oJumpForward 8319
8316: Choice Lookup Table
           1   8312
8319: oEmit 77
8321: oGetParam 1
8323: oPushResult
8324: oSetResult 22
8326: oPushResult
8327: oNodeGetLabel
8328: oPop 2
8330: oPushResult
8331: oEmitLabel
8332: oPop 1
8334: oGetParam 1
8336: oPushResult
8337: oSetResult 35
8339: oPushResult
8340: oSetResult 1
8342: oPushResult
8343: oNodeSetBoolean
8344: oPop 3
8346: oInput 12
8348: oReturn
8349: oLocalSpace 0
8351: oGetParam 1
8353: oPushResult
8354: oSetResult 1
8356: oPushResult
8357: oCall 8614
8359: oPop 2
8361: oInput 4
8363: oCall 4606
8365: oCall 7796
8367: oCall 8370
8369: oReturn
8370: oLocalSpace 1
8372: oTypeSNodeType
8373: oChoice 8413
8375: oEmit 26
8377: oJumpForward 8437
8379: oEmit 27
8381: oJumpForward 8437
8383: oError 16
8385: oJumpForward 8437
8387: oEmit 28
8389: oJumpForward 8437
8391: oGetAddrLocal 1
8393: oPushResult
8394: oTypeSTop
8395: oPushResult
8396: oSetResult 17
8398: oPushResult
8399: oNodeGetInt
8400: oPop 2
8402: oAssign
8403: oEmit 29
8405: oGetLocal 1
8407: oPushResult
8408: oEmitInt
8409: oPop 1
8411: oJumpForward 8437
8413: Choice Lookup Table
          40   8391
          38   8391
          36   8391
          35   8387
          34   8387
          28   8383
          33   8379
          30   8379
          31   8379
          41   8375
          29   8375
8436: oEndChoice
8437: oTypeSPop
8438: oReturn
8439: oLocalSpace 1
8441: oGetParam 1
8443: oPushResult
8444: oSetResult 6
8446: oPushResult
8447: oNodeGet
8448: oPop 2
8450: oPushResult
8451: oScopeCurrent
8452: oPushResult
8453: oNodeEqual
8454: oPop 2
8456: oChoice 8462
8458: oError 20
8460: oJumpForward 8465
8462: Choice Lookup Table
           0   8458
8465: oEmit 8
8467: oGetParam 1
8469: oPushResult
8470: oSetResult 31
8472: oPushResult
8473: oNodeGetInt
8474: oPop 2
8476: oPushResult
8477: oEmitInt
8478: oPop 1
8480: oGetParam 1
8482: oPushResult
8483: oSetResult 21
8485: oPushResult
8486: oNodeGet
8487: oPop 2
8489: oPushResult
8490: oTypeSPush
8491: oPop 1
8493: oInput 4
8495: oCall 4606
8497: oCall 7796
8499: oTypeSNodeType
8500: oChoice 8540
8502: oEmit 26
8504: oJumpForward 8564
8506: oEmit 27
8508: oJumpForward 8564
8510: oError 16
8512: oJumpForward 8564
8514: oEmit 28
8516: oJumpForward 8564
8518: oGetAddrLocal 1
8520: oPushResult
8521: oTypeSTop
8522: oPushResult
8523: oSetResult 17
8525: oPushResult
8526: oNodeGetInt
8527: oPop 2
8529: oAssign
8530: oEmit 29
8532: oGetLocal 1
8534: oPushResult
8535: oEmitInt
8536: oPop 1
8538: oJumpForward 8564
8540: Choice Lookup Table
          40   8518
          38   8518
          36   8518
          35   8514
          34   8514
          28   8510
          33   8506
          30   8506
          31   8506
          41   8502
          29   8502
8563: oEndChoice
8564: oTypeSPop
8565: oReturn
8566: oLocalSpace 1
8568: oInput 0
8570: oGetAddrLocal 1
8572: oPushResult
8573: oScopeFindRequire
8574: oAssign
8575: oGetAddrLocal 1
8577: oPushResult
8578: oCall 244
8580: oPop 1
8582: oGetLocal 1
8584: oPushResult
8585: oNodeType
8586: oPop 1
8588: oChoice 8592
8590: oJumpForward 8603
8592: Choice Lookup Table
          25   8590
          24   8590
          22   8590
          21   8590
8601: oError 4
8603: oGetLocal 1
8605: oPushResult
8606: oGetParam 1
8608: oPushResult
8609: oCall 8614
8611: oPop 2
8613: oReturn
8614: oLocalSpace 0
8616: oGetParam 2
8618: oPushResult
8619: oNodeType
8620: oPop 1
8622: oChoice 8704
8624: oEmit 16
8626: oGetParam 2
8628: oPushResult
8629: oCall 13106
8631: oPop 1
8633: oJumpForward 8715
8635: oEmit 17
8637: oGetParam 2
8639: oPushResult
8640: oCall 13106
8642: oPop 1
8644: oJumpForward 8715
8646: oGetParam 2
8648: oPushResult
8649: oSetResult 34
8651: oPushResult
8652: oNodeGetBoolean
8653: oPop 2
8655: oChoice 8668
8657: oEmit 8
8659: oGetParam 2
8661: oPushResult
8662: oCall 13106
8664: oPop 1
8666: oJumpForward 8680
8668: Choice Lookup Table
           1   8657
8671: oEmit 18
8673: oGetParam 2
8675: oPushResult
8676: oCall 13106
8678: oPop 1
8680: oJumpForward 8715
8682: oGetParam 1
8684: oChoice 8697
8686: oEmit 16
8688: oGetParam 2
8690: oPushResult
8691: oCall 13106
8693: oPop 1
8695: oJumpForward 8702
8697: Choice Lookup Table
           0   8686
8700: oError 4
8702: oJumpForward 8715
8704: Choice Lookup Table
          25   8682
          24   8646
          22   8635
          21   8624
8713: oError 4
8715: oGetParam 2
8717: oPushResult
8718: oSetResult 21
8720: oPushResult
8721: oNodeGet
8722: oPop 2
8724: oPushResult
8725: oTypeSPush
8726: oPop 1
8728: oTypeSNodeType
8729: oChoice 8744
8731: oInputChoice 8739
8733: oEmit 25
8735: oCall 7374
8737: oJumpForward 8742
8739: Choice Lookup Table
          16   8733
8742: oJumpForward 8747
8744: Choice Lookup Table
          34   8731
8747: oCall 7179
8749: oReturn
8750: oLocalSpace 0
8752: oGetParam 1
8754: oPushResult
8755: oSetResult 1
8757: oPushResult
8758: oCall 8614
8760: oPop 2
8762: oCall 8006
8764: oGetParam 1
8766: oPushResult
8767: oCall 6368
8769: oPop 1
8771: oTypeSPop
8772: oEmit 32
8774: oEmit 26
8776: oReturn
8777: oLocalSpace 0
8779: oGetParam 1
8781: oPushResult
8782: oSetResult 1
8784: oPushResult
8785: oCall 8614
8787: oPop 2
8789: oCall 8006
8791: oGetParam 1
8793: oPushResult
8794: oCall 6368
8796: oPop 1
8798: oTypeSPop
8799: oEmit 33
8801: oEmit 26
8803: oReturn
8804: oLocalSpace 2
8806: oGetAddrLocal 1
8808: oPushResult
8809: oSetResult 0
8811: oAssign
8812: oGetAddrLocal 1
8814: oPushResult
8815: oCall 4629
8817: oPop 1
8819: oInput 42
8821: oCall 8126
8823: oInputChoice 8858
8825: oGetAddrLocal 2
8827: oPushResult
8828: oLabelNew
8829: oAssign
8830: oEmit 68
8832: oGetLocal 2
8834: oPushResult
8835: oEmitLabel
8836: oPop 1
8838: oEmit 77
8840: oGetLocal 1
8842: oPushResult
8843: oEmitLabel
8844: oPop 1
8846: oCall 8126
8848: oEmit 77
8850: oGetLocal 2
8852: oPushResult
8853: oEmitLabel
8854: oPop 1
8856: oJumpForward 8869
8858: Choice Lookup Table
          43   8825
8861: oEmit 77
8863: oGetLocal 1
8865: oPushResult
8866: oEmitLabel
8867: oPop 1
8869: oReturn
8870: oLocalSpace 4
8872: oInput 0
8874: oGetAddrLocal 1
8876: oPushResult
8877: oScopeFindRequire
8878: oAssign
8879: oGetLocal 1
8881: oPushResult
8882: oSetResult 1
8884: oPushResult
8885: oCall 8614
8887: oPop 2
8889: oCall 8006
8891: oInput 4
8893: oCall 4606
8895: oCall 8006
8897: oEmit 26
8899: oGetAddrLocal 2
8901: oPushResult
8902: oLabelNew
8903: oAssign
8904: oGetAddrLocal 3
8906: oPushResult
8907: oLabelNew
8908: oAssign
8909: oEmit 68
8911: oGetLocal 3
8913: oPushResult
8914: oEmitLabel
8915: oPop 1
8917: oGetAddrLocal 4
8919: oPushResult
8920: oLabelNew
8921: oAssign
8922: oEmit 77
8924: oGetLocal 4
8926: oPushResult
8927: oEmitLabel
8928: oPop 1
8930: oInputChoice 9010
8932: oGetLocal 1
8934: oPushResult
8935: oCall 8750
8937: oPop 1
8939: oEmit 77
8941: oGetLocal 3
8943: oPushResult
8944: oEmitLabel
8945: oPop 1
8947: oGetLocal 1
8949: oPushResult
8950: oCall 6368
8952: oPop 1
8954: oTypeSPop
8955: oCall 4606
8957: oCall 8006
8959: oEmit 51
8961: oEmit 69
8963: oGetLocal 2
8965: oPushResult
8966: oEmitLabel
8967: oPop 1
8969: oJumpForward 9016
8971: oGetLocal 1
8973: oPushResult
8974: oCall 8777
8976: oPop 1
8978: oEmit 77
8980: oGetLocal 3
8982: oPushResult
8983: oEmitLabel
8984: oPop 1
8986: oGetLocal 1
8988: oPushResult
8989: oCall 6368
8991: oPop 1
8993: oTypeSPop
8994: oCall 4606
8996: oCall 8006
8998: oEmit 52
9000: oEmit 69
9002: oGetLocal 2
9004: oPushResult
9005: oEmitLabel
9006: oPop 1
9008: oJumpForward 9016
9010: Choice Lookup Table
          46   8971
          45   8932
9015: oEndChoice
9016: oGetLocal 4
9018: oPushResult
9019: oGetLocal 2
9021: oPushResult
9022: oLoopPush
9023: oPop 2
9025: oInput 47
9027: oCall 8126
9029: oEmit 68
9031: oGetLocal 4
9033: oPushResult
9034: oEmitLabel
9035: oPop 1
9037: oEmit 77
9039: oGetLocal 2
9041: oPushResult
9042: oEmitLabel
9043: oPop 1
9045: oLoopPop
9046: oReturn
9047: oLocalSpace 3
9049: oGetAddrLocal 1
9051: oPushResult
9052: oLabelNew
9053: oAssign
9054: oEmit 77
9056: oGetLocal 1
9058: oPushResult
9059: oEmitLabel
9060: oPop 1
9062: oGetAddrLocal 2
9064: oPushResult
9065: oLabelNew
9066: oAssign
9067: oGetLocal 1
9069: oPushResult
9070: oGetLocal 2
9072: oPushResult
9073: oLoopPush
9074: oPop 2
9076: oCall 8126
9078: oInputChoice 9109
9080: oCall 8126
9082: oJumpForward 9115
9084: oGetAddrLocal 3
9086: oPushResult
9087: oCall 4629
9089: oPop 1
9091: oEmit 78
9093: oGetLocal 3
9095: oPushResult
9096: oEmitLabel
9097: oPop 1
9099: oGetLocal 1
9101: oPushResult
9102: oEmitLabel
9103: oPop 1
9105: oJumpForward 9117
9107: oJumpForward 9115
9109: Choice Lookup Table
          50   9084
           5   9080
9114: oEndChoice
9115: oJumpBack 9078
9117: oEmit 77
9119: oGetLocal 2
9121: oPushResult
9122: oEmitLabel
9123: oPop 1
9125: oLoopPop
9126: oReturn
9127: oLocalSpace 2
9129: oGetAddrLocal 1
9131: oPushResult
9132: oLabelNew
9133: oAssign
9134: oEmit 77
9136: oGetLocal 1
9138: oPushResult
9139: oEmitLabel
9140: oPop 1
9142: oGetAddrLocal 2
9144: oPushResult
9145: oCall 4629
9147: oPop 1
9149: oGetLocal 1
9151: oPushResult
9152: oGetLocal 2
9154: oPushResult
9155: oLoopPush
9156: oPop 2
9158: oInput 47
9160: oCall 8126
9162: oEmit 68
9164: oGetLocal 1
9166: oPushResult
9167: oEmitLabel
9168: oPop 1
9170: oEmit 77
9172: oGetLocal 2
9174: oPushResult
9175: oEmitLabel
9176: oPop 1
9178: oLoopPop
9179: oReturn
9180: oLocalSpace 0
9182: oLoopContinueLabel
9183: oPushResult
9184: oSetResult 0
9186: oPushResult
9187: equal_label
9188: oPop 2
9190: oChoice 9205
9192: oError 18
9194: oJumpForward 9211
9196: oEmit 68
9198: oLoopContinueLabel
9199: oPushResult
9200: oEmitLabel
9201: oPop 1
9203: oJumpForward 9211
9205: Choice Lookup Table
           0   9196
           1   9192
9210: oEndChoice
9211: oReturn
9212: oLocalSpace 0
9214: oLoopBreakLabel
9215: oPushResult
9216: oSetResult 0
9218: oPushResult
9219: equal_label
9220: oPop 2
9222: oChoice 9237
9224: oError 18
9226: oJumpForward 9243
9228: oEmit 68
9230: oLoopBreakLabel
9231: oPushResult
9232: oEmitLabel
9233: oPop 1
9235: oJumpForward 9243
9237: Choice Lookup Table
           0   9228
           1   9224
9242: oEndChoice
9243: oReturn
9244: oLocalSpace 8
9246: oGetAddrLocal 1
9248: oPushResult
9249: oCodeNew
9250: oAssign
9251: oGetAddrLocal 2
9253: oPushResult
9254: oLabelNew
9255: oAssign
9256: oGetAddrLocal 3
9258: oPushResult
9259: oLabelNew
9260: oAssign
9261: oGetAddrLocal 4
9263: oPushResult
9264: oGetLocal 3
9266: oAssign
9267: oGetAddrLocal 5
9269: oPushResult
9270: oSetResult 0
9272: oAssign
9273: oCall 4606
9275: oTypeSNodeType
9276: oChoice 9314
9278: oEmit 71
9280: oGetLocal 2
9282: oPushResult
9283: oEmitLabel
9284: oPop 1
9286: oJumpForward 9331
9288: oEmit 72
9290: oGetLocal 2
9292: oPushResult
9293: oEmitLabel
9294: oPop 1
9296: oJumpForward 9331
9298: oGetAddrLocal 5
9300: oPushResult
9301: oSetResult 1
9303: oAssign
9304: oEmit 73
9306: oGetLocal 2
9308: oPushResult
9309: oEmitLabel
9310: oPop 1
9312: oJumpForward 9331
9314: Choice Lookup Table
          39   9298
          40   9298
          41   9288
          29   9288
          33   9278
          30   9278
          31   9278
9329: oError 17
9331: oInput 40
9333: oInputChoice 9380
9335: oGetAddrLocal 4
9337: oPushResult
9338: oLabelNew
9339: oAssign
9340: oEmit 77
9342: oGetLocal 4
9344: oPushResult
9345: oEmitLabel
9346: oPop 1
9348: oInputChoice 9354
9350: oJumpForward 9372
9352: oJumpForward 9370
9354: Choice Lookup Table
          36   9350
9357: oCall 8126
9359: oInputChoice 9363
9361: oJumpForward 9370
9363: Choice Lookup Table
           5   9361
9366: oInput 36
9368: oJumpForward 9372
9370: oJumpBack 9348
9372: oJumpForward 9546
9374: oJumpForward 9544
9376: oJumpForward 9546
9378: oJumpForward 9544
9380: Choice Lookup Table
          36   9376
          43   9335
          54   9335
9387: oGetAddrLocal 6
9389: oPushResult
9390: oLabelNew
9391: oAssign
9392: oGetLocal 1
9394: oPushResult
9395: oCodePush
9396: oPop 1
9398: oCall 3526
9400: oCall 4268
9402: oGetLocal 5
9404: oChoice 9424
9406: oGetAddrLocal 7
9408: oPushResult
9409: oValueTopString
9410: oPushResult
9411: oStringAllocShortStringLit
9412: oPop 1
9414: oAssign
9415: oJumpForward 9430
9417: oGetAddrLocal 7
9419: oPushResult
9420: oValueTop
9421: oAssign
9422: oJumpForward 9430
9424: Choice Lookup Table
           0   9417
           1   9406
9429: oEndChoice
9430: oValuePop
9431: oInputChoice 9488
9433: oCall 3526
9435: oCall 4268
9437: oGetLocal 5
9439: oChoice 9459
9441: oGetAddrLocal 8
9443: oPushResult
9444: oValueTopString
9445: oPushResult
9446: oStringAllocShortStringLit
9447: oPop 1
9449: oAssign
9450: oJumpForward 9465
9452: oGetAddrLocal 8
9454: oPushResult
9455: oValueTop
9456: oAssign
9457: oJumpForward 9465
9459: Choice Lookup Table
           0   9452
           1   9441
9464: oEndChoice
9465: oValuePop
9466: oEmit 75
9468: oGetLocal 7
9470: oPushResult
9471: oEmitInt
9472: oPop 1
9474: oGetLocal 8
9476: oPushResult
9477: oEmitInt
9478: oPop 1
9480: oGetLocal 6
9482: oPushResult
9483: oEmitLabel
9484: oPop 1
9486: oJumpForward 9505
9488: Choice Lookup Table
          21   9433
9491: oEmit 74
9493: oGetLocal 7
9495: oPushResult
9496: oEmitInt
9497: oPop 1
9499: oGetLocal 6
9501: oPushResult
9502: oEmitLabel
9503: oPop 1
9505: oInputChoice 9509
9507: oJumpForward 9514
9509: Choice Lookup Table
          13   9507
9512: oJumpForward 9516
9514: oJumpBack 9398
9516: oCodePop
9517: oInput 12
9519: oEmit 77
9521: oGetLocal 6
9523: oPushResult
9524: oEmitLabel
9525: oPop 1
9527: oCall 8126
9529: oEmit 68
9531: oGetLocal 3
9533: oPushResult
9534: oEmitLabel
9535: oPop 1
9537: oInputChoice 9541
9539: oJumpForward 9544
9541: Choice Lookup Table
           5   9539
9544: oJumpBack 9333
9546: oEmit 77
9548: oGetLocal 2
9550: oPushResult
9551: oEmitLabel
9552: oPop 1
9554: oGetLocal 1
9556: oPushResult
9557: oEmitCode
9558: oPop 1
9560: oEmit 76
9562: oGetLocal 4
9564: oPushResult
9565: oEmitLabel
9566: oPop 1
9568: oEmit 77
9570: oGetLocal 3
9572: oPushResult
9573: oEmitLabel
9574: oPop 1
9576: oTypeSPop
9577: oReturn
9578: oLocalSpace 1
9580: oInputChoice 9587
9582: oJumpForward 9593
9584: oChangeIntLitToLabelIdent
9585: oJumpForward 9593
9587: Choice Lookup Table
           1   9584
           0   9582
9592: oEndChoice
9593: oGetAddrLocal 1
9595: oPushResult
9596: oScopeCurrent
9597: oPushResult
9598: oScopeFindRequireInScope
9599: oPop 1
9601: oAssign
9602: oGetLocal 1
9604: oPushResult
9605: oSetResult 28
9607: oPushResult
9608: oSetResult 1
9610: oPushResult
9611: oNodeSetBoolean
9612: oPop 3
9614: oEmit 68
9616: oGetLocal 1
9618: oPushResult
9619: oSetResult 22
9621: oPushResult
9622: oNodeGetLabel
9623: oPop 2
9625: oPushResult
9626: oEmitLabel
9627: oPop 1
9629: oReturn
9630: oLocalSpace 0
9632: oCall 8126
9634: oInputChoice 9644
9636: oCall 8126
9638: oJumpForward 9650
9640: oJumpForward 9652
9642: oJumpForward 9650
9644: Choice Lookup Table
          36   9640
           5   9636
9649: oEndChoice
9650: oJumpBack 9634
9652: oReturn
9653: oLocalSpace 0
9655: oCall 9660
9657: oEmit 87
9659: oReturn
9660: oLocalSpace 0
9662: oInputChoice 9780
9664: oCall 4606
9666: oTypeSNodeType
9667: oChoice 9738
9669: oEmit 80
9671: oJumpForward 9761
9673: oEmit 81
9675: oJumpForward 9761
9677: oEmit 30
9679: oEmit 80
9681: oJumpForward 9761
9683: oEmit 82
9685: oJumpForward 9761
9687: oEmit 83
9689: oJumpForward 9761
9691: oError 16
9693: oJumpForward 9761
9695: oEmit 16
9697: oTypeSTop
9698: oPushResult
9699: oSetResult 43
9701: oPushResult
9702: oNodeGetInt
9703: oPop 2
9705: oPushResult
9706: oEmitInt
9707: oPop 1
9709: oEmit 86
9711: oJumpForward 9761
9713: oTypeSTop
9714: oPushResult
9715: oGetGlobal 10
9717: oPushResult
9718: equal_node
9719: oPop 2
9721: oChoice 9727
9723: oEmit 84
9725: oJumpForward 9732
9727: Choice Lookup Table
           1   9723
9730: oEmit 85
9732: oJumpForward 9761
9734: oEmit 85
9736: oJumpForward 9761
9738: Choice Lookup Table
          35   9734
          34   9713
          41   9695
          28   9691
          39   9687
          40   9687
          33   9683
          30   9677
          31   9673
          29   9669
9759: oError 17
9761: oTypeSPop
9762: oInputChoice 9770
9764: oJumpForward 9778
9766: oJumpForward 9776
9768: oJumpForward 9776
9770: Choice Lookup Table
          13   9768
          15   9764
9775: oEndChoice
9776: oJumpBack 9664
9778: oJumpForward 9783
9780: Choice Lookup Table
          14   9664
9783: oReturn
9784: oLocalSpace 0
9786: oReturn
9787: oLocalSpace 0
9789: oReturn
9790: oLocalSpace 1
9792: oGetAddrLocal 1
9794: oPushResult
9795: oGetGlobal 14
9797: oPushResult
9798: oScopeAllocType
9799: oPop 1
9801: oAssign
9802: oTypeSNodeType
9803: oChoice 9871
9805: oEmit 17
9807: oGetLocal 1
9809: oPushResult
9810: oEmitInt
9811: oPop 1
9813: oEmit 22
9815: oEmit 29
9817: oGetGlobal 14
9819: oPushResult
9820: oSetResult 17
9822: oPushResult
9823: oNodeGetInt
9824: oPop 2
9826: oPushResult
9827: oEmitInt
9828: oPop 1
9830: oJumpForward 9880
9832: oEmit 17
9834: oGetLocal 1
9836: oPushResult
9837: oEmitInt
9838: oPop 1
9840: oEmit 15
9842: oSetResult 1
9844: oPushResult
9845: oEmitInt
9846: oPop 1
9848: oEmit 27
9850: oEmit 17
9852: oGetLocal 1
9854: oPushResult
9855: oSetResult 1
9857: oPushResult
9858: add
9859: oPop 2
9861: oPushResult
9862: oEmitInt
9863: oPop 1
9865: oEmit 22
9867: oEmit 27
9869: oJumpForward 9880
9871: Choice Lookup Table
          33   9832
          39   9805
          40   9805
9878: oError 14
9880: oTypeSPop
9881: oEmit 17
9883: oGetLocal 1
9885: oPushResult
9886: oEmitInt
9887: oPop 1
9889: oGetGlobal 14
9891: oPushResult
9892: oTypeSPush
9893: oPop 1
9895: oGetLocal 1
9897: oReturn
9898: oReturn
9899: oLocalSpace 0
9901: oEmit 61
9903: oSetResult 16
9905: oPushResult
9906: oEmitInt
9907: oPop 1
9909: oEmit 19
9911: oSetResult 8
9913: oPushResult
9914: oEmitInt
9915: oPop 1
9917: oEmit 22
9919: oEmit 28
9921: oEmit 19
9923: oSetResult 0
9925: oPushResult
9926: oEmitInt
9927: oPop 1
9929: oEmit 22
9931: oEmit 28
9933: oEmit 64
9935: oGetGlobal 19
9937: oPushResult
9938: oCall 13106
9940: oPop 1
9942: oEmit 63
9944: oSetResult 16
9946: oPushResult
9947: oEmitInt
9948: oPop 1
9950: oTypeSPop
9951: oTypeSPop
9952: oReturn
9953: oLocalSpace 0
9955: oEmit 61
9957: oSetResult 12
9959: oPushResult
9960: oEmitInt
9961: oPop 1
9963: oEmit 19
9965: oSetResult 8
9967: oPushResult
9968: oEmitInt
9969: oPop 1
9971: oEmit 22
9973: oEmit 26
9975: oEmit 19
9977: oSetResult 0
9979: oPushResult
9980: oEmitInt
9981: oPop 1
9983: oEmit 22
9985: oEmit 28
9987: oEmit 64
9989: oGetGlobal 20
9991: oPushResult
9992: oCall 13106
9994: oPop 1
9996: oEmit 63
9998: oSetResult 12
10000: oPushResult
10001: oEmitInt
10002: oPop 1
10004: oTypeSPop
10005: oTypeSPop
10006: oReturn
10007: oLocalSpace 1
10009: oEmit 61
10011: oSetResult 24
10013: oPushResult
10014: oEmitInt
10015: oPop 1
10017: oEmit 19
10019: oSetResult 8
10021: oPushResult
10022: oEmitInt
10023: oPop 1
10025: oEmit 22
10027: oEmit 28
10029: oEmit 19
10031: oSetResult 0
10033: oPushResult
10034: oEmitInt
10035: oPop 1
10037: oEmit 22
10039: oEmit 28
10041: oGetAddrLocal 1
10043: oPushResult
10044: oGetGlobal 6
10046: oPushResult
10047: oScopeAllocType
10048: oPop 1
10050: oAssign
10051: oEmit 19
10053: oSetResult 16
10055: oPushResult
10056: oEmitInt
10057: oPop 1
10059: oEmit 17
10061: oGetLocal 1
10063: oPushResult
10064: oEmitInt
10065: oPop 1
10067: oEmit 28
10069: oEmit 64
10071: oGetGlobal 21
10073: oPushResult
10074: oCall 13106
10076: oPop 1
10078: oEmit 3
10080: oGetLocal 1
10082: oPushResult
10083: oEmitInt
10084: oPop 1
10086: oEmit 63
10088: oSetResult 24
10090: oPushResult
10091: oEmitInt
10092: oPop 1
10094: oTypeSPop
10095: oGetGlobal 6
10097: oPushResult
10098: oTypeSPush
10099: oPop 1
10101: oReturn
10102: oLocalSpace 10
10104: oGetParam 1
10106: oPushResult
10107: oSetResult 25
10109: oPushResult
10110: oNodeGetBoolean
10111: oPop 2
10113: oChoice 10140
10115: oGetParam 1
10117: oPushResult
10118: oSetResult 28
10120: oPushResult
10121: oNodeGetBoolean
10122: oPop 2
10124: oChoice 10135
10126: oGetParam 1
10128: oPushResult
10129: oCall 10722
10131: oPop 1
10133: oJumpForward 10138
10135: Choice Lookup Table
           0   10126
10138: oJumpForward 10143
10140: Choice Lookup Table
           1   10115
10143: oGetParam 1
10145: oPushResult
10146: oSetResult 28
10148: oPushResult
10149: oSetResult 1
10151: oPushResult
10152: oNodeSetBoolean
10153: oPop 3
10155: oGetAddrLocal 1
10157: oPushResult
10158: oGetParam 1
10160: oPushResult
10161: oSetResult 27
10163: oPushResult
10164: oNodeGetBoolean
10165: oPop 2
10167: oAssign
10168: oGetAddrLocal 4
10170: oPushResult
10171: oGetParam 1
10173: oPushResult
10174: oNodeType
10175: oPop 1
10177: oPushResult
10178: oSetResult 13
10180: oPushResult
10181: equal_node_type
10182: oPop 2
10184: oAssign
10185: oGetLocal 4
10187: oChoice 10214
10189: oGetAddrLocal 2
10191: oPushResult
10192: oGetParam 1
10194: oPushResult
10195: oSetResult 21
10197: oPushResult
10198: oNodeGet
10199: oPop 2
10201: oAssign
10202: oGetAddrLocal 3
10204: oPushResult
10205: oGetLocal 2
10207: oPushResult
10208: oScopeAllocType
10209: oPop 1
10211: oAssign
10212: oJumpForward 10217
10214: Choice Lookup Table
           1   10189
10217: oGetAddrLocal 5
10219: oPushResult
10220: oGetParam 1
10222: oPushResult
10223: oSetResult 23
10225: oPushResult
10226: oNodeGet
10227: oPop 2
10229: oAssign
10230: oGetAddrLocal 6
10232: oPushResult
10233: oGetLocal 5
10235: oPushResult
10236: oSetResult 17
10238: oPushResult
10239: oNodeGetInt
10240: oPop 2
10242: oAssign
10243: oGetLocal 1
10245: oChoice 10267
10247: oEmit 62
10249: oGetLocal 6
10251: oPushResult
10252: oEmitInt
10253: oPop 1
10255: oJumpForward 10273
10257: oEmit 61
10259: oGetLocal 6
10261: oPushResult
10262: oEmitInt
10263: oPop 1
10265: oJumpForward 10273
10267: Choice Lookup Table
           0   10257
           1   10247
10272: oEndChoice
10273: oGetParam 1
10275: oPushResult
10276: oCall 13040
10278: oPop 1
10280: oPushResult
10281: oSetResult 0
10283: oPushResult
10284: greater
10285: oPop 2
10287: oChoice 10320
10289: oEmit 19
10291: oSetResult 0
10293: oPushResult
10294: oEmitInt
10295: oPop 1
10297: oEmit 20
10299: oGetParam 1
10301: oPushResult
10302: oCall 13060
10304: oPop 1
10306: oPushResult
10307: oEmitInt
10308: oPop 1
10310: oSetResult 0
10312: oPushResult
10313: oEmitInt
10314: oPop 1
10316: oEmit 28
10318: oJumpForward 10323
10320: Choice Lookup Table
           1   10289
10323: oGetAddrLocal 7
10325: oPushResult
10326: oGetLocal 5
10328: oPushResult
10329: oSetResult 15
10331: oPushResult
10332: oNodeGetIter
10333: oPop 2
10335: oAssign
10336: oGetAddrLocal 8
10338: oPushResult
10339: oGetLocal 7
10341: oPushResult
10342: oNodeIterValue
10343: oPop 1
10345: oAssign
10346: oInputChoice 10543
10348: oGetLocal 8
10350: oPushResult
10351: oNodeNull
10352: oPop 1
10354: oChoice 10360
10356: oJumpForward 10539
10358: oJumpForward 10363
10360: Choice Lookup Table
           1   10356
10363: oGetAddrLocal 9
10365: oPushResult
10366: oGetLocal 8
10368: oPushResult
10369: oSetResult 22
10371: oPushResult
10372: oNodeGetInt
10373: oPop 2
10375: oAssign
10376: oEmit 19
10378: oGetLocal 9
10380: oPushResult
10381: oEmitInt
10382: oPop 1
10384: oGetLocal 8
10386: oPushResult
10387: oSetResult 21
10389: oPushResult
10390: oNodeGet
10391: oPop 2
10393: oPushResult
10394: oTypeSPush
10395: oPop 1
10397: oGetLocal 8
10399: oPushResult
10400: oSetResult 34
10402: oPushResult
10403: oNodeGetBoolean
10404: oPop 2
10406: oChoice 10492
10408: oSetResult 1
10410: oPushResult
10411: oCall 8566
10413: oPop 1
10415: oCall 7948
10417: oEmit 28
10419: oJumpForward 10498
10421: oCall 4606
10423: oCall 7796
10425: oTypeSNodeType
10426: oChoice 10466
10428: oEmit 26
10430: oJumpForward 10490
10432: oEmit 27
10434: oJumpForward 10490
10436: oError 16
10438: oJumpForward 10490
10440: oEmit 28
10442: oJumpForward 10490
10444: oGetAddrLocal 10
10446: oPushResult
10447: oTypeSTop
10448: oPushResult
10449: oSetResult 17
10451: oPushResult
10452: oNodeGetInt
10453: oPop 2
10455: oAssign
10456: oEmit 29
10458: oGetLocal 10
10460: oPushResult
10461: oEmitInt
10462: oPop 1
10464: oJumpForward 10490
10466: Choice Lookup Table
          40   10444
          38   10444
          36   10444
          35   10440
          34   10440
          28   10436
          33   10432
          30   10432
          31   10432
          41   10428
          29   10428
10489: oEndChoice
10490: oJumpForward 10498
10492: Choice Lookup Table
           0   10421
           1   10408
10497: oEndChoice
10498: oTypeSPop
10499: oGetAddrLocal 7
10501: oPushResult
10502: oNodeIterNext
10503: oPop 1
10505: oGetAddrLocal 8
10507: oPushResult
10508: oGetLocal 7
10510: oPushResult
10511: oNodeIterValue
10512: oPop 1
10514: oAssign
10515: oGetLocal 8
10517: oPushResult
10518: oNodeNull
10519: oPop 1
10521: oChoice 10529
10523: oJumpForward 10539
10525: oJumpForward 10535
10527: oJumpForward 10535
10529: Choice Lookup Table
           0   10527
           1   10523
10534: oEndChoice
10535: oInput 13
10537: oJumpBack 10348
10539: oInput 15
10541: oJumpForward 10546
10543: Choice Lookup Table
          14   10348
10546: oGetLocal 8
10548: oPushResult
10549: oNodeNull
10550: oPop 1
10552: oChoice 10558
10554: oError 15
10556: oJumpForward 10561
10558: Choice Lookup Table
           0   10554
10561: oGetLocal 4
10563: oChoice 10592
10565: oEmit 19
10567: oGetParam 1
10569: oPushResult
10570: oSetResult 31
10572: oPushResult
10573: oNodeGetInt
10574: oPop 2
10576: oPushResult
10577: oEmitInt
10578: oPop 1
10580: oEmit 17
10582: oGetLocal 3
10584: oPushResult
10585: oEmitInt
10586: oPop 1
10588: oEmit 28
10590: oJumpForward 10595
10592: Choice Lookup Table
           1   10565
10595: oGetLocal 1
10597: oChoice 10621
10599: oEmit 65
10601: oGetParam 1
10603: oPushResult
10604: oCall 13106
10606: oPop 1
10608: oJumpForward 10627
10610: oEmit 64
10612: oGetParam 1
10614: oPushResult
10615: oCall 13106
10617: oPop 1
10619: oJumpForward 10627
10621: Choice Lookup Table
           0   10610
           1   10599
10626: oEndChoice
10627: oGetLocal 4
10629: oChoice 10710
10631: oGetLocal 2
10633: oPushResult
10634: oTypeSPush
10635: oPop 1
10637: oTypeSNodeType
10638: oChoice 10684
10640: oEmit 3
10642: oGetLocal 3
10644: oPushResult
10645: oEmitInt
10646: oPop 1
10648: oJumpForward 10708
10650: oEmit 4
10652: oGetLocal 3
10654: oPushResult
10655: oEmitInt
10656: oPop 1
10658: oJumpForward 10708
10660: oError 16
10662: oJumpForward 10708
10664: oEmit 5
10666: oGetLocal 3
10668: oPushResult
10669: oEmitInt
10670: oPop 1
10672: oJumpForward 10708
10674: oEmit 17
10676: oGetLocal 3
10678: oPushResult
10679: oEmitInt
10680: oPop 1
10682: oJumpForward 10708
10684: Choice Lookup Table
          40   10674
          38   10674
          36   10674
          35   10664
          34   10664
          28   10660
          33   10650
          30   10650
          31   10650
          41   10640
          29   10640
10707: oEndChoice
10708: oJumpForward 10713
10710: Choice Lookup Table
           1   10631
10713: oEmit 63
10715: oGetLocal 6
10717: oPushResult
10718: oEmitInt
10719: oPop 1
10721: oReturn
10722: oLocalSpace 2
10724: oGetAddrLocal 2
10726: oPushResult
10727: oGetParam 1
10729: oPushResult
10730: oSetResult 26
10732: oPushResult
10733: oNodeGetString
10734: oPop 2
10736: oAssign
10737: oGetLocal 2
10739: oPushResult
10740: oSetResult 0
10742: oPushResult
10743: equal_string
10744: oPop 2
10746: oChoice 10783
10748: oGetAddrLocal 1
10750: oPushResult
10751: oGetParam 1
10753: oPushResult
10754: oSetResult 4
10756: oPushResult
10757: oNodeGetInt
10758: oPop 2
10760: oPushResult
10761: ID_STRING
10762: oPop 1
10764: oPushResult
10765: oStringAllocLit
10766: oPop 1
10768: oAssign
10769: oJumpForward 10789
10771: oGetAddrLocal 1
10773: oPushResult
10774: oGetLocal 2
10776: oPushResult
10777: oStringAllocLit
10778: oPop 1
10780: oAssign
10781: oJumpForward 10789
10783: Choice Lookup Table
           0   10771
           1   10748
10788: oEndChoice
10789: oEmit 79
10791: oGetParam 1
10793: oPushResult
10794: oCall 13106
10796: oPop 1
10798: oGetLocal 1
10800: oPushResult
10801: oEmitInt
10802: oPop 1
10804: oReturn
10805: oLocalSpace 0
10807: oGetParam 1
10809: oPushResult
10810: oGetGlobal 15
10812: oPushResult
10813: oNodeEqual
10814: oPop 2
10816: oChoice 10856
10818: oInput 14
10820: oCall 4606
10822: oTypeSNodeType
10823: oChoice 10831
10825: oJumpForward 10844
10827: oEmit 30
10829: oJumpForward 10844
10831: Choice Lookup Table
          33   10827
          30   10827
          31   10827
          41   10825
          29   10825
10842: oError 14
10844: oTypeSPop
10845: oGetGlobal 6
10847: oPushResult
10848: oTypeSPush
10849: oPop 1
10851: oInput 15
10853: oReturn
10854: oJumpForward 10859
10856: Choice Lookup Table
           1   10818
10859: oGetParam 1
10861: oPushResult
10862: oGetGlobal 16
10864: oPushResult
10865: oNodeEqual
10866: oPop 2
10868: oChoice 10902
10870: oInput 14
10872: oCall 4606
10874: oTypeSNodeType
10875: oChoice 10883
10877: oEmit 31
10879: oJumpForward 10890
10881: oJumpForward 10890
10883: Choice Lookup Table
          30   10881
          29   10877
10888: oError 14
10890: oTypeSPop
10891: oGetGlobal 9
10893: oPushResult
10894: oTypeSPush
10895: oPop 1
10897: oInput 15
10899: oReturn
10900: oJumpForward 10905
10902: Choice Lookup Table
           1   10870
10905: oGetParam 1
10907: oPushResult
10908: oGetGlobal 17
10910: oPushResult
10911: oNodeEqual
10912: oPop 2
10914: oChoice 10954
10916: oInput 14
10918: oCall 4606
10920: oTypeSNodeType
10921: oChoice 10942
10923: oTypeSTop
10924: oPushResult
10925: oSetResult 44
10927: oPushResult
10928: oNodeGetBoolean
10929: oPop 2
10931: oChoice 10937
10933: oError 28
10935: oJumpForward 10940
10937: Choice Lookup Table
           1   10933
10940: oJumpForward 10947
10942: Choice Lookup Table
          41   10923
10945: oError 14
10947: oEmit 33
10949: oInput 15
10951: oReturn
10952: oJumpForward 10957
10954: Choice Lookup Table
           1   10916
10957: oGetParam 1
10959: oPushResult
10960: oGetGlobal 18
10962: oPushResult
10963: oNodeEqual
10964: oPop 2
10966: oChoice 11006
10968: oInput 14
10970: oCall 4606
10972: oTypeSNodeType
10973: oChoice 10994
10975: oTypeSTop
10976: oPushResult
10977: oSetResult 44
10979: oPushResult
10980: oNodeGetBoolean
10981: oPop 2
10983: oChoice 10989
10985: oError 28
10987: oJumpForward 10992
10989: Choice Lookup Table
           1   10985
10992: oJumpForward 10999
10994: Choice Lookup Table
          41   10975
10997: oError 14
10999: oEmit 32
11001: oInput 15
11003: oReturn
11004: oJumpForward 11009
11006: Choice Lookup Table
           1   10968
11009: oError 16
11011: oReturn
11012: oLocalSpace 1
11014: oGetAddrLocal 1
11016: oPushResult
11017: oGetParam 2
11019: oPushResult
11020: oNodeNew
11021: oPop 1
11023: oAssign
11024: oGetLocal 1
11026: oPushResult
11027: oSetResult 17
11029: oPushResult
11030: oGetParam 1
11032: oPushResult
11033: oNodeSetInt
11034: oPop 3
11036: oGetLocal 1
11038: oPushResult
11039: oTypeAdd
11040: oPop 1
11042: oGetLocal 1
11044: oReturn
11045: oReturn
11046: oLocalSpace 12
11048: oInputChoice 11531
11050: oGetAddrLocal 1
11052: oPushResult
11053: oScopeFindRequire
11054: oAssign
11055: oGetAddrLocal 1
11057: oPushResult
11058: oCall 244
11060: oPop 1
11062: oGetLocal 1
11064: oPushResult
11065: oNodeType
11066: oPop 1
11068: oChoice 11085
11070: oGetParam 1
11072: oPushResult
11073: oGetLocal 1
11075: oPushResult
11076: oSetResult 21
11078: oPushResult
11079: oNodeGet
11080: oPop 2
11082: oAssign
11083: oJumpForward 11096
11085: Choice Lookup Table
          19   11070
11088: oError 2
11090: oGetParam 1
11092: oPushResult
11093: oGetGlobal 6
11095: oAssign
11096: oJumpForward 11554
11098: oInput 16
11100: oGetAddrLocal 2
11102: oPushResult
11103: oNodeVecNew
11104: oAssign
11105: oGetAddrLocal 3
11107: oPushResult
11108: oSetResult 37
11110: oPushResult
11111: oNodeNew
11112: oPop 1
11114: oAssign
11115: oCall 3526
11117: oGetLocal 3
11119: oPushResult
11120: oSetResult 39
11122: oPushResult
11123: oValueTop
11124: oPushResult
11125: oNodeSetInt
11126: oPop 3
11128: oValuePop
11129: oInput 21
11131: oCall 3526
11133: oGetLocal 3
11135: oPushResult
11136: oSetResult 40
11138: oPushResult
11139: oValueTop
11140: oPushResult
11141: oNodeSetInt
11142: oPop 3
11144: oValuePop
11145: oCall 4171
11147: oGetLocal 3
11149: oPushResult
11150: oSetResult 37
11152: oPushResult
11153: oTypeSTop
11154: oPushResult
11155: oNodeSet
11156: oPop 3
11158: oGetLocal 3
11160: oPushResult
11161: oSetResult 17
11163: oPushResult
11164: oTypeSTop
11165: oPushResult
11166: oSetResult 17
11168: oPushResult
11169: oNodeGetInt
11170: oPop 2
11172: oPushResult
11173: oNodeSetInt
11174: oPop 3
11176: oTypeSPop
11177: oGetLocal 3
11179: oPushResult
11180: oTypeAdd
11181: oPop 1
11183: oGetAddrLocal 4
11185: oPushResult
11186: oSetResult 36
11188: oPushResult
11189: oNodeNew
11190: oPop 1
11192: oAssign
11193: oGetLocal 4
11195: oPushResult
11196: oSetResult 38
11198: oPushResult
11199: oGetLocal 3
11201: oPushResult
11202: oNodeSet
11203: oPop 3
11205: oGetLocal 2
11207: oPushResult
11208: oGetLocal 4
11210: oPushResult
11211: oNodeVecAppend
11212: oPop 2
11214: oInputChoice 11222
11216: oJumpForward 11230
11218: oJumpForward 11228
11220: oJumpForward 11228
11222: Choice Lookup Table
          13   11220
          17   11216
11227: oEndChoice
11228: oJumpBack 11105
11230: oInput 40
11232: oGetAddrLocal 5
11234: oPushResult
11235: oCall 11046
11237: oPop 1
11239: oGetAddrLocal 6
11241: oPushResult
11242: oGetLocal 2
11244: oPushResult
11245: oNodeVecSize
11246: oPop 1
11248: oAssign
11249: oGetAddrLocal 6
11251: oPushResult
11252: dec
11253: oPop 1
11255: oGetAddrLocal 7
11257: oPushResult
11258: oGetLocal 2
11260: oPushResult
11261: oGetLocal 6
11263: oPushResult
11264: oNodeVecElement
11265: oPop 2
11267: oAssign
11268: oGetLocal 7
11270: oPushResult
11271: oSetResult 37
11273: oPushResult
11274: oGetLocal 5
11276: oPushResult
11277: oNodeSet
11278: oPop 3
11280: oGetAddrLocal 8
11282: oPushResult
11283: oGetLocal 7
11285: oPushResult
11286: oSetResult 38
11288: oPushResult
11289: oNodeGet
11290: oPop 2
11292: oAssign
11293: oGetAddrLocal 9
11295: oPushResult
11296: oGetLocal 8
11298: oPushResult
11299: oSetResult 40
11301: oPushResult
11302: oNodeGetInt
11303: oPop 2
11305: oPushResult
11306: oGetLocal 8
11308: oPushResult
11309: oSetResult 39
11311: oPushResult
11312: oNodeGetInt
11313: oPop 2
11315: oPushResult
11316: subtract
11317: oPop 2
11319: oAssign
11320: oGetAddrLocal 9
11322: oPushResult
11323: inc
11324: oPop 1
11326: oGetLocal 7
11328: oPushResult
11329: oSetResult 17
11331: oPushResult
11332: oGetLocal 9
11334: oPushResult
11335: oGetLocal 5
11337: oPushResult
11338: oSetResult 17
11340: oPushResult
11341: oNodeGetInt
11342: oPop 2
11344: oPushResult
11345: multiply
11346: oPop 2
11348: oPushResult
11349: oNodeSetInt
11350: oPop 3
11352: oGetLocal 7
11354: oPushResult
11355: oTypeAdd
11356: oPop 1
11358: oGetAddrLocal 5
11360: oPushResult
11361: oGetLocal 7
11363: oAssign
11364: oGetLocal 6
11366: oPushResult
11367: equal_zero
11368: oPop 1
11370: oChoice 11376
11372: oJumpForward 11381
11374: oJumpForward 11379
11376: Choice Lookup Table
           1   11372
11379: oJumpBack 11249
11381: oGetParam 1
11383: oPushResult
11384: oGetLocal 2
11386: oPushResult
11387: oSetResult 0
11389: oPushResult
11390: oNodeVecElement
11391: oPop 2
11393: oAssign
11394: oGetLocal 2
11396: oPushResult
11397: oNodeVecDelete
11398: oPop 1
11400: oJumpForward 11554
11402: oGetAddrLocal 10
11404: oPushResult
11405: oCall 11046
11407: oPop 1
11409: oGetParam 1
11411: oPushResult
11412: oGetLocal 10
11414: oPushResult
11415: oCall 12125
11417: oPop 1
11419: oAssign
11420: oJumpForward 11554
11422: oGetParam 1
11424: oPushResult
11425: oSetResult 38
11427: oPushResult
11428: oNodeNew
11429: oPop 1
11431: oAssign
11432: oSetResult -1
11434: oPushResult
11435: oSetResult 2
11437: oPushResult
11438: oScopeBegin
11439: oPop 2
11441: oSetResult 23
11443: oPushResult
11444: oCall 3227
11446: oPop 1
11448: oGetAddrLocal 11
11450: oPushResult
11451: oScopeCurrent
11452: oPushResult
11453: oSetResult 17
11455: oPushResult
11456: oNodeGetInt
11457: oPop 2
11459: oAssign
11460: oGetLocal 11
11462: oPushResult
11463: equal_zero
11464: oPop 1
11466: oChoice 11472
11468: oError 19
11470: oJumpForward 11475
11472: Choice Lookup Table
           1   11468
11475: oInput 36
11477: oGetFromParam 1
11479: oPushResult
11480: oSetResult 41
11482: oPushResult
11483: oScopeCurrent
11484: oPushResult
11485: oNodeSet
11486: oPop 3
11488: oGetFromParam 1
11490: oPushResult
11491: oSetResult 17
11493: oPushResult
11494: oGetLocal 11
11496: oPushResult
11497: oNodeSetInt
11498: oPop 3
11500: oScopeEnd
11501: oGetFromParam 1
11503: oPushResult
11504: oTypeAdd
11505: oPop 1
11507: oJumpForward 11554
11509: oGetParam 1
11511: oPushResult
11512: oCall 11555
11514: oPop 1
11516: oJumpForward 11554
11518: oInput 40
11520: oGetAddrLocal 12
11522: oPushResult
11523: oCall 11046
11525: oPop 1
11527: oError 16
11529: oJumpForward 11554
11531: Choice Lookup Table
          39   11518
          14   11509
          38   11422
          18   11402
          37   11098
           0   11050
11544: oCall 3526
11546: oInput 21
11548: oCall 3526
11550: oCall 4171
11552: oError 16
11554: oReturn
11555: oLocalSpace 11
11557: oGetParam 1
11559: oPushResult
11560: oSetResult 41
11562: oPushResult
11563: oNodeNew
11564: oPop 1
11566: oAssign
11567: oGetAddrLocal 1
11569: oPushResult
11570: oSetResult 0
11572: oAssign
11573: oGetAddrLocal 2
11575: oPushResult
11576: oSetResult 0
11578: oAssign
11579: oGetAddrLocal 3
11581: oPushResult
11582: oSetResult 1
11584: oAssign
11585: oGetAddrLocal 4
11587: oPushResult
11588: oScopeCurrent
11589: oAssign
11590: oSetResult -1
11592: oPushResult
11593: oSetResult 2
11595: oPushResult
11596: oScopeBegin
11597: oPop 2
11599: oInput 0
11601: oGetAddrLocal 5
11603: oPushResult
11604: oSetResult 17
11606: oPushResult
11607: LAST_ID
11608: oPushResult
11609: oCall 13078
11611: oPop 2
11613: oAssign
11614: oGetAddrLocal 6
11616: oPushResult
11617: oSetResult 17
11619: oPushResult
11620: LAST_ID
11621: oPushResult
11622: oCall 13078
11624: oPop 2
11626: oAssign
11627: oGetLocal 5
11629: oPushResult
11630: oSetResult 21
11632: oPushResult
11633: oGetFromParam 1
11635: oPushResult
11636: oNodeSet
11637: oPop 3
11639: oGetLocal 6
11641: oPushResult
11642: oSetResult 21
11644: oPushResult
11645: oGetFromParam 1
11647: oPushResult
11648: oNodeSet
11649: oPop 3
11651: oGetAddrLocal 7
11653: oPushResult
11654: LAST_ID
11655: oPushResult
11656: ID_STRING
11657: oPop 1
11659: oPushResult
11660: oStringAllocLit
11661: oPop 1
11663: oAssign
11664: oGetLocal 5
11666: oPushResult
11667: oSetResult 32
11669: oPushResult
11670: oGetLocal 7
11672: oPushResult
11673: oNodeSetInt
11674: oPop 3
11676: oGetLocal 6
11678: oPushResult
11679: oSetResult 32
11681: oPushResult
11682: oGetLocal 7
11684: oPushResult
11685: oNodeSetInt
11686: oPop 3
11688: oInputChoice 11766
11690: oGetGlobal 6
11692: oPushResult
11693: oTypeSPush
11694: oPop 1
11696: oCall 3526
11698: oCall 4268
11700: oTypeSPop
11701: oGetLocal 2
11703: oPushResult
11704: equal_zero
11705: oPop 1
11707: oChoice 11728
11709: oValueTop
11710: oPushResult
11711: oGetLocal 1
11713: oPushResult
11714: greater
11715: oPop 2
11717: oChoice 11723
11719: oError 26
11721: oJumpForward 11726
11723: Choice Lookup Table
           0   11719
11726: oJumpForward 11731
11728: Choice Lookup Table
           0   11709
11731: oGetLocal 1
11733: oPushResult
11734: oValueTop
11735: oPushResult
11736: equal
11737: oPop 2
11739: oChoice 11755
11741: oGetFromParam 1
11743: oPushResult
11744: oSetResult 44
11746: oPushResult
11747: oSetResult 1
11749: oPushResult
11750: oNodeSetBoolean
11751: oPop 3
11753: oJumpForward 11758
11755: Choice Lookup Table
           0   11741
11758: oGetAddrLocal 1
11760: oPushResult
11761: oValueTop
11762: oAssign
11763: oValuePop
11764: oJumpForward 11771
11766: Choice Lookup Table
           4   11690
           6   11690
11771: oGetLocal 5
11773: oPushResult
11774: oSetResult 22
11776: oPushResult
11777: oGetLocal 1
11779: oPushResult
11780: oNodeSetInt
11781: oPop 3
11783: oGetLocal 6
11785: oPushResult
11786: oSetResult 22
11788: oPushResult
11789: oGetLocal 1
11791: oPushResult
11792: oNodeSetInt
11793: oPop 3
11795: oGetLocal 5
11797: oPushResult
11798: oScopeDeclare
11799: oPop 1
11801: oGetLocal 4
11803: oPushResult
11804: oScopeEnter
11805: oPop 1
11807: oGetLocal 6
11809: oPushResult
11810: oScopeDeclare
11811: oPop 1
11813: oScopeEnd
11814: oGetAddrLocal 1
11816: oPushResult
11817: inc
11818: oPop 1
11820: oGetAddrLocal 2
11822: oPushResult
11823: inc
11824: oPop 1
11826: oInputChoice 11830
11828: oJumpForward 11835
11830: Choice Lookup Table
          13   11828
11833: oJumpForward 11837
11835: oJumpBack 11599
11837: oInput 15
11839: oGetFromParam 1
11841: oPushResult
11842: oSetResult 41
11844: oPushResult
11845: oScopeCurrent
11846: oPushResult
11847: oNodeSet
11848: oPop 3
11850: oGetFromParam 1
11852: oPushResult
11853: oSetResult 17
11855: oPushResult
11856: oSetResult 4
11858: oPushResult
11859: oNodeSetInt
11860: oPop 3
11862: oScopeEnd
11863: oGetGlobal 2
11865: oPushResult
11866: oCall 12976
11868: oPop 1
11870: oPushResult
11871: oCodePush
11872: oPop 1
11874: oGetGlobal 2
11876: oPushResult
11877: oScopeEnter
11878: oPop 1
11880: oGetAddrLocal 8
11882: oPushResult
11883: oGetLocal 2
11885: oPushResult
11886: oSetResult 1
11888: oPushResult
11889: add
11890: oPop 2
11892: oPushResult
11893: oSetResult 16
11895: oPushResult
11896: multiply
11897: oPop 2
11899: oAssign
11900: oGetAddrLocal 9
11902: oPushResult
11903: oGetLocal 8
11905: oPushResult
11906: oSetResult 8
11908: oPushResult
11909: oScopeAlloc
11910: oPop 2
11912: oAssign
11913: oScopeEnd
11914: oGetFromParam 1
11916: oPushResult
11917: oSetResult 43
11919: oPushResult
11920: oGetLocal 9
11922: oPushResult
11923: oNodeSetInt
11924: oPop 3
11926: oGetAddrLocal 10
11928: oPushResult
11929: oGetFromParam 1
11931: oPushResult
11932: oSetResult 41
11934: oPushResult
11935: oNodeGet
11936: oPop 2
11938: oPushResult
11939: oSetResult 15
11941: oPushResult
11942: oNodeGetIter
11943: oPop 2
11945: oAssign
11946: oGetAddrLocal 11
11948: oPushResult
11949: oGetLocal 10
11951: oPushResult
11952: oNodeIterValue
11953: oPop 1
11955: oAssign
11956: oGetLocal 11
11958: oPushResult
11959: oNodeNull
11960: oPop 1
11962: oChoice 11968
11964: oJumpForward 12055
11966: oJumpForward 11971
11968: Choice Lookup Table
           1   11964
11971: oEmit 16
11973: oGetLocal 9
11975: oPushResult
11976: oEmitInt
11977: oPop 1
11979: oEmit 15
11981: oGetLocal 11
11983: oPushResult
11984: oSetResult 22
11986: oPushResult
11987: oNodeGetInt
11988: oPop 2
11990: oPushResult
11991: oEmitInt
11992: oPop 1
11994: oEmit 26
11996: oGetAddrLocal 9
11998: oPushResult
11999: oGetLocal 9
12001: oPushResult
12002: oSetResult 8
12004: oPushResult
12005: add
12006: oPop 2
12008: oAssign
12009: oEmit 16
12011: oGetLocal 9
12013: oPushResult
12014: oEmitInt
12015: oPop 1
12017: oEmit 16
12019: oGetLocal 11
12021: oPushResult
12022: oSetResult 32
12024: oPushResult
12025: oNodeGetInt
12026: oPop 2
12028: oPushResult
12029: oEmitInt
12030: oPop 1
12032: oEmit 28
12034: oGetAddrLocal 9
12036: oPushResult
12037: oGetLocal 9
12039: oPushResult
12040: oSetResult 8
12042: oPushResult
12043: add
12044: oPop 2
12046: oAssign
12047: oGetAddrLocal 10
12049: oPushResult
12050: oNodeIterNext
12051: oPop 1
12053: oJumpBack 11946
12055: oEmit 16
12057: oGetLocal 9
12059: oPushResult
12060: oEmitInt
12061: oPop 1
12063: oEmit 15
12065: oSetResult 0
12067: oPushResult
12068: oEmitInt
12069: oPop 1
12071: oEmit 26
12073: oGetAddrLocal 9
12075: oPushResult
12076: oGetLocal 9
12078: oPushResult
12079: oSetResult 8
12081: oPushResult
12082: add
12083: oPop 2
12085: oAssign
12086: oEmit 16
12088: oGetLocal 9
12090: oPushResult
12091: oEmitInt
12092: oPop 1
12094: oEmit 15
12096: oSetResult 0
12098: oPushResult
12099: oEmitInt
12100: oPop 1
12102: oEmit 28
12104: oGetAddrLocal 9
12106: oPushResult
12107: oGetLocal 9
12109: oPushResult
12110: oSetResult 8
12112: oPushResult
12113: add
12114: oPop 2
12116: oAssign
12117: oCodePop
12118: oGetFromParam 1
12120: oPushResult
12121: oTypeAdd
12122: oPop 1
12124: oReturn
12125: oLocalSpace 1
12127: oGetAddrLocal 1
12129: oPushResult
12130: oGetParam 1
12132: oPushResult
12133: oSetResult 36
12135: oPushResult
12136: oNodeGet
12137: oPop 2
12139: oAssign
12140: oGetLocal 1
12142: oPushResult
12143: oNodeNull
12144: oPop 1
12146: oChoice 12202
12148: oGetAddrLocal 1
12150: oPushResult
12151: oSetResult 34
12153: oPushResult
12154: oNodeNew
12155: oPop 1
12157: oAssign
12158: oGetLocal 1
12160: oPushResult
12161: oSetResult 37
12163: oPushResult
12164: oGetParam 1
12166: oPushResult
12167: oNodeSet
12168: oPop 3
12170: oGetLocal 1
12172: oPushResult
12173: oSetResult 17
12175: oPushResult
12176: oSetResult 8
12178: oPushResult
12179: oNodeSetInt
12180: oPop 3
12182: oGetLocal 1
12184: oPushResult
12185: oTypeAdd
12186: oPop 1
12188: oGetParam 1
12190: oPushResult
12191: oSetResult 36
12193: oPushResult
12194: oGetLocal 1
12196: oPushResult
12197: oNodeSet
12198: oPop 3
12200: oJumpForward 12205
12202: Choice Lookup Table
           1   12148
12205: oGetLocal 1
12207: oReturn
12208: oReturn
12209: oLocalSpace 2
12211: oGetParam 1
12213: oPushResult
12214: oNodeType
12215: oPop 1
12217: oChoice 12287
12219: oMININT
12220: oReturn
12221: oJumpForward 12303
12223: oSetResult 0
12225: oReturn
12226: oJumpForward 12303
12228: oSetResult 0
12230: oReturn
12231: oJumpForward 12303
12233: oGetAddrLocal 1
12235: oPushResult
12236: oGetParam 1
12238: oPushResult
12239: oSetResult 41
12241: oPushResult
12242: oNodeGet
12243: oPop 2
12245: oAssign
12246: oGetAddrLocal 2
12248: oPushResult
12249: oGetLocal 1
12251: oPushResult
12252: oSetResult 15
12254: oPushResult
12255: oNodeGetIter
12256: oPop 2
12258: oPushResult
12259: oNodeIterValue
12260: oPop 1
12262: oAssign
12263: oGetLocal 2
12265: oPushResult
12266: oSetResult 22
12268: oPushResult
12269: oNodeGetInt
12270: oPop 2
12272: oReturn
12273: oJumpForward 12303
12275: oGetParam 1
12277: oPushResult
12278: oSetResult 39
12280: oPushResult
12281: oNodeGetInt
12282: oPop 2
12284: oReturn
12285: oJumpForward 12303
12287: Choice Lookup Table
          37   12275
          41   12233
          33   12228
          31   12223
          29   12219
12298: oError 3
12300: oSetResult 0
12302: oReturn
12303: oReturn
12304: oLocalSpace 2
12306: oGetParam 1
12308: oPushResult
12309: oNodeType
12310: oPop 1
12312: oChoice 12382
12314: oMAXINT
12315: oReturn
12316: oJumpForward 12398
12318: oSetResult 1
12320: oReturn
12321: oJumpForward 12398
12323: oSetResult 255
12325: oReturn
12326: oJumpForward 12398
12328: oGetAddrLocal 1
12330: oPushResult
12331: oGetParam 1
12333: oPushResult
12334: oSetResult 41
12336: oPushResult
12337: oNodeGet
12338: oPop 2
12340: oAssign
12341: oGetAddrLocal 2
12343: oPushResult
12344: oGetLocal 1
12346: oPushResult
12347: oSetResult 15
12349: oPushResult
12350: oNodeGetIterLast
12351: oPop 2
12353: oPushResult
12354: oNodeIterValue
12355: oPop 1
12357: oAssign
12358: oGetLocal 2
12360: oPushResult
12361: oSetResult 22
12363: oPushResult
12364: oNodeGetInt
12365: oPop 2
12367: oReturn
12368: oJumpForward 12398
12370: oGetParam 1
12372: oPushResult
12373: oSetResult 40
12375: oPushResult
12376: oNodeGetInt
12377: oPop 2
12379: oReturn
12380: oJumpForward 12398
12382: Choice Lookup Table
          37   12370
          41   12328
          33   12323
          31   12318
          29   12314
12393: oError 3
12395: oSetResult 0
12397: oReturn
12398: oReturn
12399: oLocalSpace 5
12401: oGetAddrGlobal 1
12403: oPushResult
12404: oWorkspaceNew
12405: oAssign
12406: oSetResult 0
12408: oPushResult
12409: oSetResult 0
12411: oPushResult
12412: oScopeBegin
12413: oPop 2
12415: oGetAddrLocal 2
12417: oPushResult
12418: oScopeCurrent
12419: oAssign
12420: oCall 13148
12422: oEmit 67
12424: oSetResult 0
12426: oPushResult
12427: oEmitInt
12428: oPop 1
12430: oGetAddrLocal 3
12432: oPushResult
12433: oLabelNew
12434: oAssign
12435: oEmit 61
12437: oSetResult 0
12439: oPushResult
12440: oEmitInt
12441: oPop 1
12443: oEmit 64
12445: oGetLocal 3
12447: oPushResult
12448: oEmitLabel
12449: oPop 1
12451: oEmit 63
12453: oSetResult 0
12455: oPushResult
12456: oEmitInt
12457: oPop 1
12459: oEmit 66
12461: oInput 28
12463: oInput 0
12465: oGetAddrLocal 4
12467: oPushResult
12468: oSetResult 4
12470: oPushResult
12471: oNodeNew
12472: oPop 1
12474: oAssign
12475: oGetLocal 4
12477: oPushResult
12478: oSetResult 4
12480: oPushResult
12481: LAST_ID
12482: oPushResult
12483: oNodeSetInt
12484: oPop 3
12486: oGetGlobal 1
12488: oPushResult
12489: oSetResult 2
12491: oPushResult
12492: oGetLocal 4
12494: oPushResult
12495: oNodeSet
12496: oPop 3
12498: oInputChoice 12572
12500: oInput 0
12502: oGetAddrLocal 1
12504: oPushResult
12505: oSetResult 20
12507: oPushResult
12508: LAST_ID
12509: oPushResult
12510: oCall 13078
12512: oPop 2
12514: oAssign
12515: oGetLocal 1
12517: oPushResult
12518: oSetResult 21
12520: oPushResult
12521: oGetGlobal 5
12523: oPushResult
12524: oNodeSet
12525: oPop 3
12527: oGetLocal 1
12529: oPushResult
12530: oScopeDeclareAlloc
12531: oPop 1
12533: oInput 13
12535: oInput 0
12537: oGetAddrLocal 1
12539: oPushResult
12540: oSetResult 20
12542: oPushResult
12543: LAST_ID
12544: oPushResult
12545: oCall 13078
12547: oPop 2
12549: oAssign
12550: oGetLocal 1
12552: oPushResult
12553: oSetResult 21
12555: oPushResult
12556: oGetGlobal 5
12558: oPushResult
12559: oNodeSet
12560: oPop 3
12562: oGetLocal 1
12564: oPushResult
12565: oScopeDeclareAlloc
12566: oPop 1
12568: oInput 15
12570: oJumpForward 12575
12572: Choice Lookup Table
          14   12500
12575: oInput 5
12577: oGetLocal 4
12579: oPushResult
12580: oCall 34
12582: oPop 1
12584: oInputChoice 12595
12586: oGetLocal 4
12588: oPushResult
12589: oCall 7
12591: oPop 1
12593: oJumpForward 12598
12595: Choice Lookup Table
          59   12586
12598: oGetLocal 4
12600: oPushResult
12601: oCall 287
12603: oPop 1
12605: oSetResult 0
12607: oPushResult
12608: oSetResult 0
12610: oPushResult
12611: oScopeBegin
12612: oPop 2
12614: oGetAddrGlobal 2
12616: oPushResult
12617: oScopeCurrent
12618: oAssign
12619: oSetResult 0
12621: oPushResult
12622: oSetResult 1
12624: oPushResult
12625: oScopeBegin
12626: oPop 2
12628: oScopeCurrent
12629: oPushResult
12630: oSetResult 16
12632: oPushResult
12633: oGetGlobal 2
12635: oPushResult
12636: oNodeSet
12637: oPop 3
12639: oGetAddrGlobal 3
12641: oPushResult
12642: oScopeCurrent
12643: oAssign
12644: oGetLocal 4
12646: oPushResult
12647: oSetResult 7
12649: oPushResult
12650: oGetGlobal 3
12652: oPushResult
12653: oNodeSet
12654: oPop 3
12656: oScopeEnd
12657: oSetResult 21
12659: oPushResult
12660: oCall 12727
12662: oPop 1
12664: oGetGlobal 3
12666: oPushResult
12667: oScopeEnter
12668: oPop 1
12670: oGetAddrLocal 5
12672: oPushResult
12673: oSetResult 1
12675: oAssign
12676: oGetLocal 3
12678: oPushResult
12679: oGetGlobal 2
12681: oPushResult
12682: oGetLocal 5
12684: oPushResult
12685: oCall 12878
12687: oPop 3
12689: oScopeEnd
12690: oInput 20
12692: oCall 12783
12694: oScopeEnd
12695: oGetLocal 4
12697: oPushResult
12698: oCall 349
12700: oPop 1
12702: oReturn
12703: oLocalSpace 0
12705: oGetParam 2
12707: oPushResult
12708: oCall 12727
12710: oPop 1
12712: oGetParam 1
12714: oPushResult
12715: oScopeCurrent
12716: oPushResult
12717: oSetResult 0
12719: oPushResult
12720: oCall 12878
12722: oPop 3
12724: oCall 12783
12726: oReturn
12727: oLocalSpace 0
12729: oInputChoice 12760
12731: oCall 2513
12733: oJumpForward 12775
12735: oCall 3171
12737: oJumpForward 12775
12739: oGetParam 1
12741: oPushResult
12742: oCall 3227
12744: oPop 1
12746: oJumpForward 12775
12748: oCall 3461
12750: oJumpForward 12775
12752: oCall 1736
12754: oJumpForward 12775
12756: oCall 2171
12758: oJumpForward 12775
12760: Choice Lookup Table
          30   12756
          29   12752
          34   12748
          33   12739
          32   12735
          31   12731
12773: oJumpForward 12777
12775: oJumpBack 12729
12777: oCall 12780
12779: oReturn
12780: oLocalSpace 0
12782: oReturn
12783: oLocalSpace 2
12785: oGetAddrLocal 1
12787: oPushResult
12788: oScopeCurrent
12789: oPushResult
12790: oSetResult 15
12792: oPushResult
12793: oNodeGetIter
12794: oPop 2
12796: oAssign
12797: oGetAddrLocal 2
12799: oPushResult
12800: oGetLocal 1
12802: oPushResult
12803: oNodeIterValue
12804: oPop 1
12806: oAssign
12807: oGetLocal 2
12809: oPushResult
12810: oNodeNull
12811: oPop 1
12813: oChoice 12817
12815: oJumpForward 12822
12817: Choice Lookup Table
           0   12815
12820: oJumpForward 12877
12822: oGetLocal 2
12824: oPushResult
12825: oNodeType
12826: oPop 1
12828: oChoice 12866
12830: oGetLocal 2
12832: oPushResult
12833: oSetResult 35
12835: oPushResult
12836: oNodeGetBoolean
12837: oPop 2
12839: oChoice 12861
12841: oGetLocal 2
12843: oPushResult
12844: oSetResult 28
12846: oPushResult
12847: oNodeGetBoolean
12848: oPop 2
12850: oChoice 12856
12852: oError 27
12854: oJumpForward 12859
12856: Choice Lookup Table
           1   12852
12859: oJumpForward 12864
12861: Choice Lookup Table
           0   12841
12864: oJumpForward 12869
12866: Choice Lookup Table
          26   12830
12869: oGetAddrLocal 1
12871: oPushResult
12872: oNodeIterNext
12873: oPop 1
12875: oJumpBack 12797
12877: oReturn
12878: oLocalSpace 3
12880: oEmit 77
12882: oGetParam 3
12884: oPushResult
12885: oEmitLabel
12886: oPop 1
12888: oEmit 67
12890: oGetAddrLocal 1
12892: oPushResult
12893: Here
12894: oAssign
12895: oEmit 90
12897: oGetParam 1
12899: oChoice 12905
12901: oCall 1220
12903: oJumpForward 12908
12905: Choice Lookup Table
           1   12901
12908: oGetAddrLocal 2
12910: oPushResult
12911: oGetParam 2
12913: oPushResult
12914: oSetResult 19
12916: oPushResult
12917: oNodeGetCode
12918: oPop 2
12920: oAssign
12921: oGetLocal 2
12923: oPushResult
12924: oEmitCode
12925: oPop 1
12927: oGetParam 2
12929: oPushResult
12930: oSetResult 19
12932: oPushResult
12933: oSetResult 0
12935: oPushResult
12936: oNodeSetCode
12937: oPop 3
12939: oCall 8126
12941: oGetParam 1
12943: oChoice 12949
12945: oCall 1305
12947: oJumpForward 12952
12949: Choice Lookup Table
           1   12945
12952: oEmit 66
12954: oGetAddrLocal 3
12956: oPushResult
12957: oScopeCurrent
12958: oPushResult
12959: oSetResult 17
12961: oPushResult
12962: oNodeGetInt
12963: oPop 2
12965: oAssign
12966: oGetLocal 1
12968: oPushResult
12969: oGetLocal 3
12971: oPushResult
12972: oPatch
12973: oPop 2
12975: oReturn
12976: oLocalSpace 1
12978: oGetAddrLocal 1
12980: oPushResult
12981: oGetParam 1
12983: oPushResult
12984: oSetResult 19
12986: oPushResult
12987: oNodeGetCode
12988: oPop 2
12990: oAssign
12991: oGetLocal 1
12993: oPushResult
12994: oSetResult 0
12996: oPushResult
12997: equal_code
12998: oPop 2
13000: oChoice 13021
13002: oGetAddrLocal 1
13004: oPushResult
13005: oCodeNew
13006: oAssign
13007: oGetParam 1
13009: oPushResult
13010: oSetResult 19
13012: oPushResult
13013: oGetLocal 1
13015: oPushResult
13016: oNodeSetCode
13017: oPop 3
13019: oJumpForward 13024
13021: Choice Lookup Table
           1   13002
13024: oGetLocal 1
13026: oReturn
13027: oReturn
13028: oLocalSpace 0
13030: oScopeCurrent
13031: oPushResult
13032: oSetResult 14
13034: oPushResult
13035: oNodeGetInt
13036: oPop 2
13038: oReturn
13039: oReturn
13040: oLocalSpace 0
13042: oGetParam 1
13044: oPushResult
13045: oSetResult 20
13047: oPushResult
13048: oNodeGet
13049: oPop 2
13051: oPushResult
13052: oSetResult 14
13054: oPushResult
13055: oNodeGetInt
13056: oPop 2
13058: oReturn
13059: oReturn
13060: oLocalSpace 0
13062: oCall 13028
13064: oPushResult
13065: oGetParam 1
13067: oPushResult
13068: oCall 13040
13070: oPop 1
13072: oPushResult
13073: subtract
13074: oPop 2
13076: oReturn
13077: oReturn
13078: oLocalSpace 1
13080: oGetAddrLocal 1
13082: oPushResult
13083: oGetParam 2
13085: oPushResult
13086: oNodeNew
13087: oPop 1
13089: oAssign
13090: oGetLocal 1
13092: oPushResult
13093: oSetResult 4
13095: oPushResult
13096: oGetParam 1
13098: oPushResult
13099: oNodeSetInt
13100: oPop 3
13102: oGetLocal 1
13104: oReturn
13105: oReturn
13106: oLocalSpace 0
13108: oGetParam 1
13110: oPushResult
13111: oSetResult 22
13113: oPushResult
13114: oNodeGetInt
13115: oPop 2
13117: oPushResult
13118: oEmitInt
13119: oPop 1
13121: oReturn
13122: oLocalSpace 1
13124: oGetAddrLocal 1
13126: oPushResult
13127: oSetResult 14
13129: oPushResult
13130: oGetParam 1
13132: oPushResult
13133: oCall 13078
13135: oPop 2
13137: oAssign
13138: oGetLocal 1
13140: oPushResult
13141: oScopeDeclare
13142: oPop 1
13144: oGetLocal 1
13146: oReturn
13147: oReturn
13148: oLocalSpace 1
13150: oGetAddrGlobal 4
13152: oPushResult
13153: oId_mysystem
13154: oAssign
13155: oGetAddrGlobal 5
13157: oPushResult
13158: oSetResult 28
13160: oPushResult
13161: oSetResult 4
13163: oPushResult
13164: oCall 11012
13166: oPop 2
13168: oAssign
13169: oGetAddrGlobal 6
13171: oPushResult
13172: oSetResult 29
13174: oPushResult
13175: oSetResult 4
13177: oPushResult
13178: oCall 11012
13180: oPop 2
13182: oAssign
13183: oGetAddrGlobal 7
13185: oPushResult
13186: oSetResult 31
13188: oPushResult
13189: oSetResult 1
13191: oPushResult
13192: oCall 11012
13194: oPop 2
13196: oAssign
13197: oGetAddrGlobal 8
13199: oPushResult
13200: oSetResult 32
13202: oPushResult
13203: oSetResult 1
13205: oPushResult
13206: oCall 11012
13208: oPop 2
13210: oAssign
13211: oGetAddrGlobal 9
13213: oPushResult
13214: oSetResult 33
13216: oPushResult
13217: oSetResult 1
13219: oPushResult
13220: oCall 11012
13222: oPop 2
13224: oAssign
13225: oGetAddrGlobal 10
13227: oPushResult
13228: oGetGlobal 9
13230: oPushResult
13231: oCall 12125
13233: oPop 1
13235: oAssign
13236: oGetAddrGlobal 11
13238: oPushResult
13239: oSetResult 30
13241: oPushResult
13242: oSetResult 1
13244: oPushResult
13245: oCall 11012
13247: oPop 2
13249: oAssign
13250: oGetAddrGlobal 12
13252: oPushResult
13253: oSetResult 35
13255: oPushResult
13256: oSetResult 8
13258: oPushResult
13259: oCall 11012
13261: oPop 2
13263: oAssign
13264: oGetGlobal 12
13266: oPushResult
13267: oSetResult 37
13269: oPushResult
13270: oGetGlobal 11
13272: oPushResult
13273: oNodeSet
13274: oPop 3
13276: oGetAddrGlobal 13
13278: oPushResult
13279: oSetResult 39
13281: oPushResult
13282: oSetResult 256
13284: oPushResult
13285: oCall 11012
13287: oPop 2
13289: oAssign
13290: oGetAddrGlobal 14
13292: oPushResult
13293: oSetResult 40
13295: oPushResult
13296: oSetResult 256
13298: oPushResult
13299: oCall 11012
13301: oPop 2
13303: oAssign
13304: oGetGlobal 14
13306: oPushResult
13307: oSetResult 42
13309: oPushResult
13310: oSetResult 255
13312: oPushResult
13313: oNodeSetInt
13314: oPop 3
13316: oGetAddrLocal 1
13318: oPushResult
13319: oSetResult 19
13321: oPushResult
13322: oId_File
13323: oPushResult
13324: oCall 13078
13326: oPop 2
13328: oAssign
13329: oGetLocal 1
13331: oPushResult
13332: oSetResult 21
13334: oPushResult
13335: oGetGlobal 5
13337: oPushResult
13338: oNodeSet
13339: oPop 3
13341: oGetLocal 1
13343: oPushResult
13344: oScopeDeclare
13345: oPop 1
13347: oGetAddrLocal 1
13349: oPushResult
13350: oSetResult 19
13352: oPushResult
13353: oId_Integer
13354: oPushResult
13355: oCall 13078
13357: oPop 2
13359: oAssign
13360: oGetLocal 1
13362: oPushResult
13363: oSetResult 21
13365: oPushResult
13366: oGetGlobal 6
13368: oPushResult
13369: oNodeSet
13370: oPop 3
13372: oGetLocal 1
13374: oPushResult
13375: oScopeDeclare
13376: oPop 1
13378: oGetAddrLocal 1
13380: oPushResult
13381: oSetResult 19
13383: oPushResult
13384: oId_Boolean
13385: oPushResult
13386: oCall 13078
13388: oPop 2
13390: oAssign
13391: oGetLocal 1
13393: oPushResult
13394: oSetResult 21
13396: oPushResult
13397: oGetGlobal 7
13399: oPushResult
13400: oNodeSet
13401: oPop 3
13403: oGetLocal 1
13405: oPushResult
13406: oScopeDeclare
13407: oPop 1
13409: oGetAddrLocal 1
13411: oPushResult
13412: oSetResult 19
13414: oPushResult
13415: oId_Char
13416: oPushResult
13417: oCall 13078
13419: oPop 2
13421: oAssign
13422: oGetLocal 1
13424: oPushResult
13425: oSetResult 21
13427: oPushResult
13428: oGetGlobal 9
13430: oPushResult
13431: oNodeSet
13432: oPop 3
13434: oGetLocal 1
13436: oPushResult
13437: oScopeDeclare
13438: oPop 1
13440: oGetAddrLocal 1
13442: oPushResult
13443: oSetResult 19
13445: oPushResult
13446: oId_Byte
13447: oPushResult
13448: oCall 13078
13450: oPop 2
13452: oAssign
13453: oGetLocal 1
13455: oPushResult
13456: oSetResult 21
13458: oPushResult
13459: oGetGlobal 11
13461: oPushResult
13462: oNodeSet
13463: oPop 3
13465: oGetLocal 1
13467: oPushResult
13468: oScopeDeclare
13469: oPop 1
13471: oGetAddrLocal 1
13473: oPushResult
13474: oSetResult 19
13476: oPushResult
13477: oId_Pointer
13478: oPushResult
13479: oCall 13078
13481: oPop 2
13483: oAssign
13484: oGetLocal 1
13486: oPushResult
13487: oSetResult 21
13489: oPushResult
13490: oGetGlobal 12
13492: oPushResult
13493: oNodeSet
13494: oPop 3
13496: oGetLocal 1
13498: oPushResult
13499: oScopeDeclare
13500: oPop 1
13502: oGetAddrLocal 1
13504: oPushResult
13505: oSetResult 19
13507: oPushResult
13508: oId_ShortString
13509: oPushResult
13510: oCall 13078
13512: oPop 2
13514: oAssign
13515: oGetLocal 1
13517: oPushResult
13518: oSetResult 21
13520: oPushResult
13521: oGetGlobal 14
13523: oPushResult
13524: oNodeSet
13525: oPop 3
13527: oGetLocal 1
13529: oPushResult
13530: oScopeDeclare
13531: oPop 1
13533: oGetAddrLocal 1
13535: oPushResult
13536: oSetResult 16
13538: oPushResult
13539: oId_True
13540: oPushResult
13541: oCall 13078
13543: oPop 2
13545: oAssign
13546: oGetLocal 1
13548: oPushResult
13549: oSetResult 21
13551: oPushResult
13552: oGetGlobal 7
13554: oPushResult
13555: oNodeSet
13556: oPop 3
13558: oGetLocal 1
13560: oPushResult
13561: oSetResult 22
13563: oPushResult
13564: oSetResult 1
13566: oPushResult
13567: oNodeSetInt
13568: oPop 3
13570: oGetLocal 1
13572: oPushResult
13573: oScopeDeclare
13574: oPop 1
13576: oGetAddrLocal 1
13578: oPushResult
13579: oSetResult 16
13581: oPushResult
13582: oId_False
13583: oPushResult
13584: oCall 13078
13586: oPop 2
13588: oAssign
13589: oGetLocal 1
13591: oPushResult
13592: oSetResult 21
13594: oPushResult
13595: oGetGlobal 7
13597: oPushResult
13598: oNodeSet
13599: oPop 3
13601: oGetLocal 1
13603: oPushResult
13604: oSetResult 22
13606: oPushResult
13607: oSetResult 0
13609: oPushResult
13610: oNodeSetInt
13611: oPop 3
13613: oGetLocal 1
13615: oPushResult
13616: oScopeDeclare
13617: oPop 1
13619: oGetAddrLocal 1
13621: oPushResult
13622: oSetResult 16
13624: oPushResult
13625: oId_Nil
13626: oPushResult
13627: oCall 13078
13629: oPop 2
13631: oAssign
13632: oGetLocal 1
13634: oPushResult
13635: oSetResult 21
13637: oPushResult
13638: oGetGlobal 12
13640: oPushResult
13641: oNodeSet
13642: oPop 3
13644: oGetLocal 1
13646: oPushResult
13647: oSetResult 22
13649: oPushResult
13650: oSetResult 0
13652: oPushResult
13653: oNodeSetInt
13654: oPop 3
13656: oGetLocal 1
13658: oPushResult
13659: oScopeDeclare
13660: oPop 1
13662: oGetAddrGlobal 15
13664: oPushResult
13665: oId_Ord
13666: oPushResult
13667: oCall 13122
13669: oPop 1
13671: oAssign
13672: oGetAddrGlobal 16
13674: oPushResult
13675: oId_Chr
13676: oPushResult
13677: oCall 13122
13679: oPop 1
13681: oAssign
13682: oGetAddrGlobal 17
13684: oPushResult
13685: oId_Pred
13686: oPushResult
13687: oCall 13122
13689: oPop 1
13691: oAssign
13692: oGetAddrGlobal 18
13694: oPushResult
13695: oId_Succ
13696: oPushResult
13697: oCall 13122
13699: oPop 1
13701: oAssign
13702: oReturn
