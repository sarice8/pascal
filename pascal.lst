   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]}
 241:    @CheckForUndefinedMethods
 244:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 244: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 247:    ;
      
      
      
 247: BlockStmt( Label labelForBody ):
 249:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 257:    int patchLS
 257:    .tEnter  patchLS = Here  .tSpace
      
 266:    @Statement
 268:    .tReturn
      
 270:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 282:    oPatch( patchLS, localSpace )
 292:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 292: MethodModifiers( Node decl ):
 294:    {[
 294:       | pCdecl :
 296:          oNodeSetBoolean( decl, qCdecl, true )
 308:          ';'
      
 310:       | * : >
 317:    ]}
 320:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 320: ExternalDecl( Node decl ):
 322:    oNodeSetBoolean( decl, qExternal, true )
 334:    [
 334:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 336:          [
 336:             | pName :
 338:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
 340:             | * :
 345:          ]
 345:       | * :
 350:    ]
 351:    ;
      
      
 351: ProcDecl:
 353:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 355:    boolean redeclaring = false
 361:    Node decl = oScopeFindInCurrentScope
      
 366:    [ oNodeNull( decl )
 373:       | true :
               % first declaration
 374:          decl = @newIdent( nProc, kProc, LAST_ID )
 390:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 401:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 403:          redeclaring = true
 409:          [ oNodeGetBoolean( decl, qBodyDefined )
 419:             | true : #eAlreadyDefined
 422:             | * :
 427:          ]
 427:          [ oNodeGetBoolean( decl, qExternal )
 437:             | true : #eAlreadyDefined
 440:             | * :
 445:          ]
 445:          [ oNodeType( decl )
 452:             | nProc :
 453:             | * : #eAlreadyDefined   % wrong kind
 460:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 460:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 479:          oNodeSet( decl, qParams, Null )
 491:    ]
      
 499:    oScopeBegin
 500:    Node paramScope = oScopeCurrent
      
 505:    @FormalArgDecl
 507:    oNodeSet( decl, qParams, paramScope )
 519:    oScopeEnd
 520:    ';'
      
 522:    [ redeclaring
 525:       | false : oScopeDeclare( decl )
 532:       | true :  % TO DO: check that qParams is consistent with qOldParams
 534:    ]
      
 542:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 549:    [
 549:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 551:       | pExternal : @ExternalDecl( decl )
      
 560:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 567:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 573:          oScopeBegin
 574:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 585:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 596:          Label label = oNodeGetLabel( decl, qValue )
 609:          @Block( nLocalVar, label )
 619:          oNodeSetBoolean( decl, qBodyDefined, true )
 631:          oScopeEnd
      
 632:          oScopeEnd  % paramScope
 633:    ]
 633:    ';';
      
      
 636: FuncDecl:
 638:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 640:    boolean redeclaring = false
 646:    Node decl = oScopeFindInCurrentScope
      
 651:    [ oNodeNull( decl )
 658:       | true :
               % first declaration
 659:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 675:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 686:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 688:          redeclaring = true
 694:          [ oNodeGetBoolean( decl, qBodyDefined )
 704:             | true : #eAlreadyDefined
 707:             | * :
 712:          ]
 712:          [ oNodeType( decl )
 719:             | nFunc :
 720:             | * : #eAlreadyDefined   % wrong kind
 727:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 727:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 746:          oNodeSet( decl, qParams, Null )
 758:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 777:          oNodeSet( decl, qType, Null )
 789:    ]
      
 797:    oScopeBegin
 798:    Node paramScope = oScopeCurrent
      
 803:    @FormalArgDecl
 805:    oNodeSet( decl, qParams, paramScope )
      
 817:    ':'
      
 819:    Node theType
 819:    @TypeRef( theType )
 826:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 838:    Node ptrType = @PointerTypeTo( theType )
 849:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 865:    oScopeEnd
 866:    ';'
      
 868:    [ redeclaring
 871:       | false : oScopeDeclare( decl )
 878:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 880:    ]
      
 888:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 895:    [
 895:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 897:       | pExternal : @ExternalDecl( decl )
      
 906:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 913:          oScopeEnter( paramScope )
      
 919:          oScopeBegin
 920:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 931:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 942:          Label label = oNodeGetLabel( decl, qValue )
 955:          @Block( nLocalVar, label )
 965:          oNodeSetBoolean( decl, qBodyDefined, true )
 977:          oScopeEnd
      
 978:          oScopeEnd  % paramScope
 979:    ]
 979:    ';';
      
      
 982: FormalArgDecl:
 984:    [
 984:       | '(' :
 986:          {
 986:             NodeVec decls = oNodeVecNew
 991:             Node decl
 991:             boolean isInOut = false
      
 997:             [
 997:                | pVar : isInOut = true
1005:                | * :
1010:             ]
      
1010:             {  pIdent
      
1012:                decl = @newIdent( nParam, kVar, LAST_ID )
1028:                oNodeSetBoolean( decl, qInOut, isInOut )
1040:                oNodeVecAppend( decls, decl )
      
1049:                [
1049:                   | ':' : >
1053:                   | ',' :
1055:                ]
1063:             }
      
1065:             Node theType
1065:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1072:             Node allocType
1072:             [ isInOut
1075:                | true :   allocType = @PointerTypeTo( theType )
1087:                | * :      allocType = theType
1098:             ]
      
1098:             int i = 0
1104:             {[ equal( i, oNodeVecSize( decls ) )
1118:                | false :
1119:                   decl = oNodeVecElement( decls, i )
      
1132:                   oNodeSet( decl, qType, theType )
1144:                   oScopeDeclare( decl )
1150:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1166:                   inc( i )
1172:                | * :
1177:                   >
1179:             ]}
      
1181:             oNodeVecDelete( decls )
      
1187:             [
1187:                | ')' : >
1191:                | ';' :
1193:             ]
1201:          }
1203:       | * :
1208:    ];
      
1209: ConstDecl:
1211:    {[
1211:       | pIdent :
1213:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1229:          '='
      
1231:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1233:          int val = oValueTop
1238:          oValuePop
1239:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1251:          oNodeSet( decl, qType, IntegerType )
      
1263:          oScopeDeclare( decl )
1269:          ';'
1271:       | * :
1276:          >
1278:    ]};
      
1281: TypeDecl:
1283:    {[
1283:       | pIdent :
1285:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1301:          '='
1303:          Node theType
1303:          @TypeRef( theType )
1310:          oNodeSet( decl, qType, theType )
1322:          oScopeDeclare( decl )
1328:          ';'
1330:       | * :
1335:          >
1337:    ]};
      
1340: VarDecl( node_type varNodeType ):
1342:    {[
1342:       | pIdent :
1344:          NodeVec decls = oNodeVecNew
1349:          Node decl
1349:          {
1349:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1365:             oNodeVecAppend( decls, decl )
1374:             [
1374:                | ',' :
1376:                   pIdent
1378:                | * :
1383:                   >
1385:             ]
1385:          }
1387:          ':'
1389:          Node theType
1389:          @TypeRef( theType )
      
1396:          int i = 0
1402:          {[ equal( i, oNodeVecSize( decls ) )
1416:            | false :
1417:              decl = oNodeVecElement( decls, i )
1430:              oNodeSet( decl, qType, theType )
1442:              oScopeDeclareAlloc( decl )
1448:              inc( i )
1454:             | * :
1459:               >
1461:          ]}
      
1463:          oNodeVecDelete( decls )
1469:          ';'
1471:       | * :
1476:          >
1478:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1481: TypeRef( out Node resultType ):
1483:    [
1483:       | pIdent :           % previously named type (including intrinsics)
1485:          Node decl = oScopeFindRequire
1490:          [ oNodeType( decl )
1497:            | nTypeDecl :
1498:                resultType = oNodeGet( decl, qType )
1511:            | * :
1516:                #eNotType
1518:                resultType = IntegerType
1524:          ]
         
1524:       | pArray :
1526:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1528:          NodeVec dimensions = oNodeVecNew
      
1533:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1533:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1543:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1555:             @ConstExpr
1557:             oNodeSetInt( subrange, qLow, oValueTop )
1568:             oValuePop
1569:             '..'
1571:             @ConstExpr
1573:             oNodeSetInt( subrange, qHigh, oValueTop )
1584:             oValuePop
1585:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1597:             oTypeAdd( subrange )
      
1603:             Node a = oNodeNew( nArrayType )
1613:             oNodeSet( a, qIndexType, subrange )
      
1625:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1634:             [
1634:                | ']' : >
1638:                | ',' :
1640:             ]
1648:          }
      
1650:          pOf
1652:          Node baseType
1652:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1659:          int dim = oNodeVecSize( dimensions )
      
1669:          {
1669:              dec(dim)
      
1675:              Node a = oNodeVecElement( dimensions, dim )
      
1688:              oNodeSet( a, qBaseType, baseType )
1700:              Node subrange = oNodeGet( a, qIndexType )
1713:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1740:              inc( width )
1746:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1772:              oTypeAdd( a )
1778:              baseType = a
      
1784:              [ equal_zero(dim)
1791:                  | true:  >
1794:                  | *:
1799:              ]
1799:          }
      
1801:          resultType = oNodeVecElement( dimensions, 0 )
1814:          oNodeVecDelete( dimensions )
      
1820:       | '^' :
1822:          Node theType
1822:          @TypeRef( theType )
1829:          resultType = @PointerTypeTo( theType )
      
1840:       | pRecord :
1842:          resultType = oNodeNew( nRecordType )
1852:          oScopeBegin
      
1853:          @VarDecl( nRecordField )
      
1860:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1872:          [ equal_zero( size )
1879:             | true : #eRecordEmpty
1882:             | * :
1887:          ]
      
1887:          pEnd
      
1889:          oNodeSet( resultType, qScope, oScopeCurrent )
1900:          oNodeSetInt( resultType, qSize, size )
1912:          oScopeEnd
1913:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1919:       | pSet :
1921:          pOf
1923:          Node theType
1923:          @TypeRef( theType )
1930:       | * :       % this works for cases except where expr starts with an id
1943:          @ConstExpr '..' @ConstExpr
1949:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1950: ConstExpr:
1952:    [
1952:       | pIntLit :
1954:          oValuePush( TOKEN_VALUE )
1959:       | pIdent :
1961:          Node decl = oScopeFindRequire
1966:          [ oNodeType( decl )
1973:             | nConst :
1974:                oValuePush( oNodeGetInt( decl, qValue ) )
1987:             | * :
1992:                #eNotConst
1994:                oValuePush( 0 )
2000:          ]
2000:       | pMinus :
2002:          @ConstExpr
2004:          oValueNegate
2005:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2016: Expr:
2018:    Label falseLabel = labelNull
      
2024:    @ExprAllowCF( falseLabel )
2031:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2039: BooleanExprControlFlow( out Label falseLabel ):
2041:    @ExprAllowCF( falseLabel )
2048:    [ oTypeSNodeType
2050:       | nBooleanCFType :
2051:       | nBooleanType :
               % convert value to control flow
2053:          falseLabel = oLabelNew
2058:          .tJumpFalse  oEmitLabel( falseLabel )
2066:       | * :
2073:          #eNotBoolean
2075:    ]
2075:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2077: CFToVal( inout Label falseLabel ):
2079:    [ oTypeSNodeType
2081:       | nBooleanCFType :
2082:          Label doneLabel = oLabelNew
2087:          .tPushConstI  oEmitInt( 1 )
2095:          .tJump  oEmitLabel( doneLabel )
2103:          .tLabel  oEmitLabel( falseLabel )
2111:          .tPushConstI  oEmitInt( 0 )
2119:          .tLabel  oEmitLabel( doneLabel )
2127:          oTypeSPop
2128:          oTypeSPush( BooleanType )
2134:          falseLabel = labelNull
2140:       | * :
2145:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2146: ValToCF( out Label falseLabel ):
2148:    [ oTypeSNodeType
2150:       | nBooleanType :
2151:          falseLabel = oLabelNew
2156:          .tJumpFalse  oEmitLabel( falseLabel )
2164:          oTypeSPop
2165:          oTypeSPush( BooleanCFType )
2171:       | * :
2176:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2177: ExprAllowCF( out Label falseLabel ):
2179:    @BoolExprAllowCF( falseLabel )
2186:    {[
2186:       | '=' :
2188:          @CFToVal( falseLabel )
2195:          @BoolExprAllowCF( falseLabel )
2202:          @CFToVal( falseLabel )
2209:          @MatchTypes
2211:          [ oTypeSNodeType
2213:             | nIntegerType, nBooleanType :  .tEqualI
2216:             | nPointerType :                .tEqualP
2220:             | nCharType, nStringType :      #eNotImplemented
2224:             | * :                           #eNotAllowed
2239:          ]
2239:          oTypeSPop
2240:          oTypeSPush( BooleanType )
      
2246:       | '<>' :
2248:          @CFToVal( falseLabel )
2255:          @BoolExprAllowCF( falseLabel )
2262:          @CFToVal( falseLabel )
2269:          @MatchTypes
2271:          [ oTypeSNodeType
2273:             | nIntegerType, nBooleanType :  .tNotEqualI
2276:             | nPointerType :                .tNotEqualP
2280:             | nCharType, nStringType :      #eNotImplemented
2284:             | * :                           #eNotAllowed
2299:          ]
2299:          oTypeSPop
2300:          oTypeSPush( BooleanType )
      
2306:       | '<' :
2308:          @CFToVal( falseLabel )
2315:          @BoolExprAllowCF( falseLabel )
2322:          @CFToVal( falseLabel )
2329:          @MatchTypes
2331:          [ oTypeSNodeType
2333:             | nIntegerType, nBooleanType :  .tLessI
2336:             | nCharType, nStringType :      #eNotImplemented
2340:             | * :                           #eNotAllowed
2353:          ]
2353:          oTypeSPop
2354:          oTypeSPush( BooleanType )
      
2360:       | '>' :
2362:          @CFToVal( falseLabel )
2369:          @BoolExprAllowCF( falseLabel )
2376:          @CFToVal( falseLabel )
2383:          @MatchTypes
2385:          [ oTypeSNodeType
2387:             | nIntegerType, nBooleanType :  .tGreaterI
2390:             | nCharType, nStringType :      #eNotImplemented
2394:             | * :                           #eNotAllowed
2407:          ]
2407:          oTypeSPop
2408:          oTypeSPush( BooleanType )
      
2414:       | '<=' :
2416:          @CFToVal( falseLabel )
2423:          @BoolExprAllowCF( falseLabel )
2430:          @CFToVal( falseLabel )
2437:          @MatchTypes
2439:          [ oTypeSNodeType
2441:             | nIntegerType, nBooleanType :  .tLessEqualI
2444:             | nCharType, nStringType :      #eNotImplemented
2448:             | * :                           #eNotAllowed
2461:          ]
2461:          oTypeSPop
2462:          oTypeSPush( BooleanType )
      
2468:       | '>=' :
2470:          @CFToVal( falseLabel )
2477:          @BoolExprAllowCF( falseLabel )
2484:          @CFToVal( falseLabel )
2491:          @MatchTypes
2493:          [ oTypeSNodeType
2495:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2498:             | nCharType, nStringType :      #eNotImplemented
2502:             | * :                           #eNotAllowed
2515:          ]
2515:          oTypeSPop
2516:          oTypeSPush( BooleanType )
      
2522:       | * :
2537:          >
2539:    ]};
      
      
2542: BoolExprAllowCF( out Label falseLabel ):
2544:    Label trueLabel = labelNull
      
2550:    @BoolTermAllowCF( falseLabel )
2557:    {[
2557:       | pOr :
2559:          [ oTypeSNodeType
2561:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2562:                [ equal_label( trueLabel, labelNull )
2572:                   | true :  trueLabel = oLabelNew
2578:                   | * :
2583:                ]
2583:                .tJump  oEmitLabel( trueLabel )
2591:             | nBooleanType :
2593:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2600:                [ equal_label( trueLabel, labelNull )
2610:                   | true :  trueLabel = oLabelNew
2616:                   | * :
2621:                ]
2621:                .tJumpTrue  oEmitLabel( trueLabel )
2629:             | * : #eNotBoolean
2638:          ]
2638:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2639:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2647:          falseLabel = labelNull
2653:          @BoolTermAllowCF( falseLabel )
      
2660:          [ oTypeSNodeType
2662:             | nBooleanCFType :
2663:             | nBooleanType :
2665:                @ValToCF( falseLabel )
2672:             | * : #eNotBoolean
2681:          ]
      
2681:          oTypeSPop
2682:          oTypeSPush( BooleanCFType )
      
2688:       | * :
2693:          >
2695:    ]}
      
         % any short-circuit trues jump here to the end
2697:    [ equal_label( trueLabel, labelNull )
2707:       | false :
2708:          .tLabel  oEmitLabel( trueLabel )
2716:       | * :
2721:    ]
2722:    ;
      
      
2722: BoolTermAllowCF( out Label falseLabel ):
2724:    Label overallFalseLabel = labelNull
      
2730:    @BoolFactorAllowCF( falseLabel )
2737:    {[
2737:       | pAnd :
2739:          [ oTypeSNodeType
2741:             | nBooleanCFType :
2742:             | nBooleanType :
2744:                @ValToCF( falseLabel )
2751:             | * :
2758:                #eNotBoolean
2760:          ]
2760:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2761:          [ equal_label( overallFalseLabel, labelNull )
2771:             | true :
2772:                overallFalseLabel = oLabelNew
2777:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2791:                falseLabel = overallFalseLabel
2797:             | * :
2802:          ]
      
2802:          Label factorFalseLabel = labelNull
2808:          @BoolFactorAllowCF( factorFalseLabel )
      
2815:          [ oTypeSNodeType
2817:             | nBooleanCFType :
2818:             | nBooleanType :
2820:                @ValToCF( factorFalseLabel )
2827:             | * : #eNotBoolean
2836:          ]
2836:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2850:       | * :
2855:          >
2857:    ]};
      
2860: BoolFactorAllowCF( out Label falseLabel ):
2862:    [
2862:       | pNot :
2864:          Label factorFalseLabel = labelNull
      
2870:          @BoolFactorAllowCF( factorFalseLabel )
2877:          [ oTypeSNodeType
2879:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2880:                falseLabel = oLabelNew
2885:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2893:                .tLabel  oEmitLabel( factorFalseLabel )
      
2901:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2903:                .tNot
      
2905:             | * : #eNotBoolean
2914:          ]
      
2914:       | * :
2919:          @ArithExprAllowCF( falseLabel )
2926:    ];
      
2927: ArithExprAllowCF( out Label falseLabel ):
2929:    @TermAllowCF( falseLabel )
2936:    {[
2936:       | pPlus :
2938:          @RequireIntPop
2940:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2947:          @RequireInt
2949:          .tAddI
2951:       | pMinus :
2953:          @RequireIntPop
2955:          @TermAllowCF( falseLabel )
2962:          @RequireInt
2964:          .tSubI
2966:       | * :
2973:          >
2975:    ]};
      
2978: TermAllowCF( out Label falseLabel ):
2980:    @FactorAllowCF( falseLabel )
2987:    {[
2987:       | pTimes :
2989:          @RequireIntPop
2991:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2998:          @RequireInt
3000:          .tMultI
3002:       | pDivide :
3004:          @RequireIntPop
3006:          @FactorAllowCF( falseLabel )
3013:          @RequireInt
3015:          .tDivI
3017:       | * :
3024:          >
3026:    ]};
      
3029: FactorAllowCF( out Label falseLabel ):
3031:    [
3031:       | pPlus :
3033:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3040:          @RequireInt
3042:       | pMinus :
3044:          @PrimaryAllowCF( falseLabel )
3051:          @RequireInt
3053:          .tNegI
3055:       | * :
3062:          @PrimaryAllowCF( falseLabel )
3069:    ];
      
3070: PrimaryAllowCF( out Label falseLabel ):
3072:    [
3072:       | pIntLit :
3074:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3081:          oTypeSPush( IntegerType )
      
3087:       | '(' :
3089:          @ExprAllowCF( falseLabel )
3096:          ')'
      
3098:       | pStrLit :
3100:          int addr = oStringAllocLit     % store in global data
3105:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3113:          oTypeSPush( StringType )
      
3119:       | pIdent :
3121:          Node decl = oScopeFindRequire
3126:          Node theType
      
3126:          [ oNodeType( decl )
3133:             | nFunc :
      
3134:                @Call( decl )
      
3141:             | nConst :
3143:                theType = oNodeGet( decl, qType )
3156:                oTypeSPush( theType )
3162:                [ oTypeSNodeType
3164:                   | nIntegerType, nBooleanType :
3165:                      .tPushConstI @EmitValue( decl )
3174:                   | * :
3181:                      #eNotImplemented
3183:                ]
      
3183:             | nGlobalVar, nLocalVar, nParam :
3185:                @VarExpr( decl )
      
3192:             | * :
3205:                #eNotValue
3207:                oTypeSPush( IntegerType )
3213:          ]
      
3213:       | '@' :        % @var -- pointer to var
3215:          pIdent
      
3217:          Node decl = oScopeFindRequire
3222:          Node theType
      
3222:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3229:          theType = oTypeSTop
3234:          oTypeSPop
3235:          Node ptrType = @PointerTypeTo( theType )
3246:          oTypeSPush( ptrType )
      
3252:       | * :
3265:          #eNotValue
3267:          oTypeSPush( IntegerType )
3273:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3274: VarExpr( Node decl ):
3276:    Node theType = oNodeGet( decl, qType )
3289:    oTypeSPush( theType )
3295:    [ oTypeSNodeType
3297:       | nIntegerType :
3298:          [ oNodeType( decl )
3305:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3315:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3326:             | nParam :
3328:                [ oNodeGetBoolean( decl, qInOut )
3338:                   | true :    % VAR param points to the var.  Auto dereference.
3339:                               .tPushParamP @EmitValue( decl )
3348:                               .tFetchI
3350:                   | * :       .tPushParamI @EmitValue( decl )
3364:                ]
3364:          ]
      
3374:       | nBooleanType :
3376:          [ oNodeType( decl )
3383:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3393:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3404:             | nParam :
3406:                [ oNodeGetBoolean( decl, qInOut )
3416:                   | true :    % VAR param points to the var.  Auto derefernce.
3417:                               .tPushParamP @EmitValue( decl )
3426:                               .tFetchB
3428:                   | * :       .tPushParamB @EmitValue( decl )
3442:                ]
3442:          ]
      
3452:       | nCharType, nStringType, nFileType :
3454:          #eNotImplemented
      
3456:       | nPointerType :
3458:          [ oNodeType( decl )
3465:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3475:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3486:             | nParam :
3488:                [ oNodeGetBoolean( decl, qInOut )
3498:                   | true :    % VAR param points to the var.  Auto derefernce.
3499:                               .tPushParamP @EmitValue( decl )
3508:                               .tFetchP
3510:                   | * :       .tPushParamP @EmitValue( decl )
3524:                ]
3524:          ]
3534:          [
3534:             | '^' :             % dereferenced
3536:                oTypeSPop
3537:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3550:                @LValueIndexes
3552:                @FetchVar
3554:             | * :               % just ptr value alone
3559:          ]
      
3559:       | * :
               % compound type
               % first, push addr of start of var
3574:          [ oNodeType( decl )
3581:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3591:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3602:             | nParam :
3604:                [ oNodeGetBoolean( decl, qInOut )
3614:                   | true :    % VAR param points to the var.  Auto derefernce.
3615:                               .tPushParamP @EmitValue( decl )
3624:                   | * :       .tPushAddrParam @EmitValue( decl )
3638:                ]
3638:          ]
               % modify addr for subscripts, field references, etc
3648:          @LValueIndexes
               % get final value
3650:          @FetchVar
3652:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3653: FetchVar:
3655:    [ oTypeSNodeType
3657:       | nIntegerType :   .tFetchI
3660:       | nBooleanType :   .tFetchB
3664:       | nCharType, nStringType, nFileType : #eNotImplemented
3668:       | nPointerType :   .tFetchP
3672:       | * :              % compound type; leave as addr
3687:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3688: LValueIndexes:
3690:    {[
3690:       | '[' :       @ArraySubscripts
3694:       | '.' :       @RecordFieldRef
3698:       | '^' :       @PointerDeref
3702:       | * :         >
3713:    ]};
      
3716: ArraySubscripts:
3718:    [ oTypeSNodeType
3720:       | nArrayType :
3721:       | * :       #eNotArray
3728:    ]
3728:    {
3728:       [ oTypeSNodeType
3730:          | nArrayType :
3731:          | * :    #eTooManySubscripts
3738:       ]
      
            % low subscript of this dimension
3738:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3755:       Node baseType
3755:       baseType = oNodeGet( oTypeSTop, qBaseType )
3767:       oTypeSPop
3768:       oTypeSPush( baseType )
      
3774:       @Expr
3776:       @RequireIntPop
            % adjust for low subscript
3778:       [ equal_zero( low )
3785:          | false :
3786:             .tPushConstI oEmitInt( low ) .tSubI
3796:          | * :
3801:       ]
      
            % multiply by element size
3801:       int size = oNodeGetInt( baseType, qSize )
3814:       [ equal( size, 1 )
3824:          | false :
3825:             .tPushConstI oEmitInt( size ) .tMultI
3835:          | * :
3840:       ]
      
            % update start address
3840:       .tAddPI
3842:       [
3842:          | ']' :  >
3846:          | ',' :
3848:       ]
3856:    };
      
      
3859: RecordFieldRef:
3861:    [ oTypeSNodeType
3863:       | nRecordType :
3864:       | * :    #eNotRecord
3871:    ]
3871:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3883:    pIdent
3885:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3890:    [ oNodeType( field )
3897:       | nRecordField :
3898:       | * :   #eNotRecordField
3905:    ]
3905:    oScopeEnd
3906:    int offset = oNodeGetInt( field, qValue )
3919:    [ equal_zero( offset )
3926:       | false :
3927:          .tPushConstI oEmitInt( offset ) .tAddPI
3937:       | * :
3942:    ]
      
         % replace the type on the type stack, with the field type
3942:    oTypeSPop
3943:    oTypeSPush( oNodeGet( field, qType ) )
3957:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3957: PointerDeref:
3959:    [ oTypeSNodeType
3961:       | nPointerType :
3962:       | * :       #eNotPointer
3969:    ]
3969:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3971:    Node theType = oTypeSTop
3976:    oTypeSPop
3977:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3991:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3991: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3993:    @MatchTypes
3996:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3996: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
3998:    [ oNodeGetBoolean( method, qExternal )
4008:       | true :
4009:          [ oNodeGetBoolean( method, qCalled )
4019:             | false :
                     % define the label as extern
4020:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4037:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4052:             | * :
4057:          ]
4057:      | * :
4062:    ]
4062:    oNodeSetBoolean( method, qCalled, true )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4074:    Node resultType
4074:    int tempOffset
      
4074:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4091:    [ isFunc
4094:       | true :
4095:          resultType = oNodeGet( method, qType )
4108:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4118:       | * :
4123:    ]
         
      
4123:    Node paramScope = oNodeGet( method, qParams )
4136:    int actualsSize = oNodeGetInt( paramScope, qSize )
4149:    .tAllocActuals  oEmitInt( actualsSize )
      
4157:    Node param = oNodeGet( paramScope, qDecls )
4170:    [
4170:       | '(' :
            
4172:          {
4172:             [ oNodeNull( param )
4179:                | true : >
4182:                | * :
4187:             ]
      
4187:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4200:             .tPushAddrActual oEmitInt( offset )
4208:             oTypeSPush( oNodeGet( param, qType ) )
      
4221:             [ oNodeGetBoolean( param, qInOut )
4231:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4232:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4234:                           @MatchTypes
      
4236:                           .tAssignP
      
4238:                | false :  @Expr
4242:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4244:                           [ oTypeSNodeType
4246:                              | nIntegerType :            .tAssignI
4249:                              | nBooleanType :            .tAssignB
4253:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4257:                              | nPointerType :            .tAssignP
4261:                              | * :
                                       % compound types: copy value into actuals space
4276:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4288:                                  .tCopy  oEmitInt( size )    % multi-word copy
4296:                           ]
4296:             ]
4304:             oTypeSPop
      
4305:             oNodeNext( param )
4311:             [ oNodeNull( param )
4318:                | true :  >
4321:                | false :
4323:             ]
      
4331:             ','
4333:          }
      
4335:          ')'
      
4337:       | * :
4342:    ]
      
4342:    [ oNodeNull( param )
4349:       | false :    #eMissingParameter
4352:       | * :
4357:    ]
      
4357:    [ isFunc
4360:       | true :
               % Pass result temp as an additional VAR parameter.
4361:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4376:          .tPushAddrLocal  oEmitInt( tempOffset )
4384:          .tAssignP
4386:       | * :
4391:    ]
      
4391:    [ oNodeGetBoolean( method, qCdecl )
4401:       | true :
4402:          .tCallCdecl  @EmitValue( method )
4411:       | false :
4413:          .tCall   @EmitValue( method )
4422:    ]
      
4430:    [ isFunc
4433:       | true :
               % push return value from temp
4434:          oTypeSPush( resultType )
4440:          .tPushAddrLocal  oEmitInt( tempOffset )
4448:          @FetchVar
4450:       | * :
4455:    ]
         
4455:    .tFreeActuals  oEmitInt( actualsSize )
4464:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4464: Statement:
4466:    [
4466:       | pWriteln :     @WritelnStmt
4470:       | pWrite :       @WriteStmt
4474:       | pReadln :      @ReadlnStmt
4478:       | pRead :        @ReadStmt
4482:       | pIf :          @IfStmt
4486:       | pWhile :       @WhileStmt
4490:       | pFor :         @ForStmt
4494:       | pRepeat :      @RepeatStmt
4498:       | pBreak :       @BreakStmt
4502:       | pContinue :    @ContinueStmt
4506:       | pBegin :       @BeginStmt
4510:       | pIdent :       @AssignOrCallStmt
4514:       | * :            % null statement : don't accept any tokens
4541:    ];
      
      
4542: AssignOrCallStmt:
4544:    Node decl = oScopeFindRequire
4549:    [ oNodeType( decl )
4556:       | nProc :                           @Call( decl )
4564:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4573:       | nFunc :                           @AssignResultStmt( decl )
4582:       | * :                               #eBadStatement
4597:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4598: AssignStmt( Node decl ):
      
4600:    @LValueVar( decl )
      
4607:    ':=' 
4609:    @Expr
4611:    @MatchTypes
4613:    [ oTypeSNodeType
4615:       | nIntegerType :            .tAssignI
4618:       | nBooleanType :            .tAssignB
4622:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4626:       | nPointerType :            .tAssignP
4630:       | * :
4645:           int size = oNodeGetInt( oTypeSTop, qSize )
4657:           .tCopy  oEmitInt( size )    % multi-word copy
4665:    ]
4665:    oTypeSPop
4667:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4667: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4669:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4685:       | false :   #eNotCurrentFunction
4688:       | * :
4693:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4693:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4708:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4721:    ':='
4723:    @Expr
4725:    @MatchTypes
4727:    [ oTypeSNodeType
4729:       | nIntegerType :            .tAssignI
4732:       | nBooleanType :            .tAssignB
4736:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4740:       | nPointerType :            .tAssignP
4744:       | * :
4759:           int size = oNodeGetInt( oTypeSTop, qSize )
4771:           .tCopy  oEmitInt( size )    % multi-word copy
4779:    ]
4779:    oTypeSPop
4781:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4781: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4783:    pIdent
4785:    Node decl = oScopeFindRequire
4790:    [ oNodeType( decl )
4797:       | nGlobalVar, nLocalVar, nParam :
4798:       | * :  #eNotVar
4809:    ]
4809:    @LValueVar( decl )
4817:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4817: LValueVar( Node decl ):
4819:    [ oNodeType( decl )
4826:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4836:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4847:       | nParam :
4849:          [ oNodeGetBoolean( decl, qInOut )
4859:             | true :   % VAR param points to variable.  No dereference.
4860:                        .tPushParamP @EmitValue( decl )
4869:             | * :      .tPushAddrParam @EmitValue( decl )
4883:          ]
4883:       | * :            #eNotVar
4894:    ]
      
4894:    oTypeSPush( oNodeGet( decl, qType ) )
4907:    @LValueIndexes        % handle subscripts, if any
4910:    ;
      
      
4910: IncVar( Node decl ):
4912:    @LValueVar( decl )
4919:    @RequireIntPop
4921:    @VarExpr( decl )
4928:    oTypeSPop
4929:    .tIncI
4931:    .tAssignI;
      
4934: DecVar( Node decl ):
4936:    @LValueVar( decl )
4943:    @RequireIntPop
4945:    @VarExpr( decl )
4952:    oTypeSPop
4953:    .tDecI
4955:    .tAssignI;
      
      
4958: IfStmt:
4960:    Label falseLabel = labelNull
      
4966:    @BooleanExprControlFlow( falseLabel )
4973:    pThen
4975:    @Statement
4977:    [
4977:       | pElse :
4979:          Label doneLabel = oLabelNew
      
4984:          .tJump  oEmitLabel( doneLabel )
4992:          .tLabel oEmitLabel( falseLabel )
5000:          @Statement
5002:          .tLabel oEmitLabel( doneLabel )
      
5010:       | * :
5015:          .tLabel oEmitLabel( falseLabel )
5023:    ];
      
      
5024: ForStmt:
5026:    pIdent
      
5028:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5033:    @LValueVar( decl )
5040:    @RequireIntPop
      
5042:    ':='
      
5044:    @Expr
5046:    @RequireIntPop
5048:    .tAssignI
      
5050:    Label breakLabel = oLabelNew
      
5055:    Label checkLabel = oLabelNew
5060:    .tJump  oEmitLabel( checkLabel )
      
5068:    Label continueLabel = oLabelNew
5073:    .tLabel  oEmitLabel( continueLabel )
5081:    [
5081:       | pTo :
5083:          @IncVar( decl )
5090:          .tLabel  oEmitLabel( checkLabel )
5098:          @VarExpr( decl )  oTypeSPop
5106:          @Expr
5108:          @RequireIntPop
5110:          .tGreaterI
5112:          .tJumpTrue  oEmitLabel( breakLabel )
5120:       | pDownto :
5122:          @DecVar( decl )
5129:          .tLabel  oEmitLabel( checkLabel )
5137:          @VarExpr( decl )  oTypeSPop
5145:          @Expr
5147:          @RequireIntPop
5149:          .tLessI
5151:          .tJumpTrue  oEmitLabel( breakLabel )
5159:    ]
5167:    oLoopPush( continueLabel, breakLabel )
5176:    pDo
5178:    @Statement
5180:    .tJump  oEmitLabel( continueLabel )
5188:    .tLabel  oEmitLabel( breakLabel )
5196:    oLoopPop;
      
      
5198: RepeatStmt:
5200:    Label continueLabel = oLabelNew
5205:    .tLabel  oEmitLabel( continueLabel )
      
5213:    Label breakLabel = oLabelNew
      
5218:    oLoopPush( continueLabel, breakLabel )
5227:    @Statement
5229:    {[
5229:       | ';' :
5231:          @Statement
5233:       | pUntil :
5235:          Label falseLabel
5235:          @BooleanExprControlFlow( falseLabel )
5242:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5256:          >
5258:    ]}
5268:    .tLabel  oEmitLabel( breakLabel )
5276:    oLoopPop;
      
      
5278: WhileStmt:
5280:    Label continueLabel = oLabelNew
5285:    .tLabel  oEmitLabel( continueLabel )
      
5293:    Label breakLabel
5293:    @BooleanExprControlFlow( breakLabel )
      
5300:    oLoopPush( continueLabel, breakLabel )
5309:    pDo
5311:    @Statement
5313:    .tJump  oEmitLabel( continueLabel )
5321:    .tLabel  oEmitLabel( breakLabel )
5329:    oLoopPop;
      
      
5331: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5333:    [ equal_label( oLoopContinueLabel, labelNull )
5342:       | true :
5343:          #eNotInALoop
5345:       | false :
5347:          .tJump  oEmitLabel( oLoopContinueLabel )
5354:    ];
      
      
5363: BreakStmt:
5365:    [ equal_label( oLoopBreakLabel, labelNull )
5374:       | true :
5375:          #eNotInALoop
5377:       | false :
5379:          .tJump  oEmitLabel( oLoopBreakLabel )
5386:    ];
      
      
5395: BeginStmt:
5397:    @Statement
5399:    {[
5399:       | ';' :   @Statement
5403:       | pEnd :  >
5407:    ]};
      
      
5418: WritelnStmt:
5420:    @WriteStmt
5422:    .tWriteCR;
      
      
5425: WriteStmt:
5427:    [
5427:       | '(' :
5429:          {
5429:             @Expr
5431:             [ oTypeSNodeType
5433:                | nIntegerType :             .tWriteI
5436:                | nBooleanType :             .tWriteBool
5440:                | nStringType :              .tWriteStr
5444:                | nCharType, nFileType :     #eNotImplemented
5448:                | nPointerType :             .tWriteP
5452:                | * :                        #eNotAllowed
5469:             ]
5469:             oTypeSPop
5470:             [
5470:                | ')' : >
5474:                | ',' :
5476:             ]
5484:          }
5486:       | * :
5491:    ];
      
      
5492: ReadlnStmt:      % ***
         % TO DO
5495:    ;
      
5495: ReadStmt:
         % TO DO
5498:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5498: MatchTypes:
5500:    node_type nt = oTypeSNodeType
5505:    oTypeSPop
5506:    [ equal_node_type( nt, oTypeSNodeType )
5515:       | false :
5516:          #eTypeMismatch
5518:       | * :
5523:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5524: RequireIntPop:
5526:    [ oTypeSNodeType
5528:       | nIntegerType :
5529:       | * :          #eNotInteger
5536:    ]
5536:    oTypeSPop;
      
5538: RequireInt:
5540:    [ oTypeSNodeType
5542:       | nIntegerType :
5543:       | * :          #eNotInteger
5550:    ];
      
5551: RequireBoolPop:
5553:    [ oTypeSNodeType
5555:       | nBooleanType :
5556:       | * :          #eNotBoolean
5563:    ]
5563:    oTypeSPop;
      
5565: RequireBool:
5567:    [ oTypeSNodeType
5569:       | nBooleanType :
5570:       | * :          #eNotBoolean
5577:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5578: newType( node_type nt, int size ) >> Node:
5580:   Node node = oNodeNew( nt )
5590:   oNodeSetInt( node, qSize, size )
5602:   oTypeAdd( node )
5608:   >> node
5612:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5612: newIdent( node_type nt, kind k, int id ) >> Node:
5614:   Node t = oNodeNew( nt )
5624:   oNodeSetInt( t, qIdent, id )
5636:   >> t
5640:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5640: PointerTypeTo( Node theType ) >> Node:
5642:    Node ptrType = oNodeGet( theType, qPointerType )
5655:    [ oNodeNull( ptrType )
5662:       | true :
5663:          ptrType = oNodeNew( nPointerType )
5673:          oNodeSet( ptrType, qBaseType, theType )
5685:          oNodeSetInt( ptrType, qSize, 8 )
5697:          oTypeAdd( ptrType )
5703:          oNodeSet( theType, qPointerType, ptrType )
5715:       | * :
5720:    ]
5720:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5724: OrdinalLow( Node theType ) >> int:
5726:    [ oNodeType( theType )
5733:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5736:       | nBooleanType :  >> 0
5741:       | nCharType :     >> 0
5746:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5758:       | * :             #eNotOrdinalType
5771:                         >> 0
5774:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5775: EmitValue( Node decl ):
5777:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5791: installBuiltIns:
      
         % install built-in types
5793:    FileType = @newType( nFileType, 4 )
5807:    IntegerType = @newType( nIntegerType, 4 )
5821:    BooleanType = @newType( nBooleanType, 1 )
5835:    BooleanCFType = @newType( nBooleanCFType, 1 )
5849:    CharType = @newType( nCharType, 1 )
5863:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5877:    Node t
      
5877:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5893:    oNodeSet( t, qType, FileType )
5905:    oScopeDeclare( t )
      
5911:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
5927:    oNodeSet( t, qType, IntegerType )
5939:    oScopeDeclare( t )
      
5945:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
5961:    oNodeSet( t, qType, BooleanType )
5973:    oScopeDeclare( t )
      
5979:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
5995:    oNodeSet( t, qType, CharType )
6007:    oScopeDeclare( t )
      
6013:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6029:    oNodeSet( t, qType, StringType )
6041:    oScopeDeclare( t )
      
         % Built-in constants
      
6047:    t = @newIdent( nConst, kConst, oIdAdd_True )
6063:    oNodeSet( t, qType, BooleanType )
6075:    oNodeSetInt( t, qValue, 1 )
6087:    oScopeDeclare( t )
      
6093:    t = @newIdent( nConst, kConst, oIdAdd_False )
6109:    oNodeSet( t, qType, BooleanType )
6121:    oNodeSetInt( t, qValue, 0 )
6133:    oScopeDeclare( t )
      
6140:    ;
      
6140: end
      
6140: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5791
  12: oGetAddrLocal 2
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 40
  19: oGetLocal 2
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 42
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 3
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5612
  44: oPop 3
  46: oAssign
  47: oGetLocal 3
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 1
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5612
  70: oPop 3
  72: oAssign
  73: oGetLocal 1
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 1
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 1
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5612
 108: oPop 3
 110: oAssign
 111: oGetLocal 1
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 1
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 3
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 2
 170: oPushResult
 171: oCall 247
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 247
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 1209
 203: oJumpForward 239
 205: oCall 1281
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 1340
 214: oPop 1
 216: oJumpForward 239
 218: oCall 351
 220: oJumpForward 239
 222: oCall 636
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oCall 244
 243: oReturn
 244: oLocalSpace 0
 246: oReturn
 247: oLocalSpace 2
 249: oEmit 47
 251: oGetParam 1
 253: oPushResult
 254: oEmitLabel
 255: oPop 1
 257: oEmit 43
 259: oGetAddrLocal 1
 261: oPushResult
 262: Here
 263: oAssign
 264: oEmit 55
 266: oCall 4464
 268: oEmit 42
 270: oGetAddrLocal 2
 272: oPushResult
 273: oScopeCurrent
 274: oPushResult
 275: oSetResult 2
 277: oPushResult
 278: oNodeGetInt
 279: oPop 2
 281: oAssign
 282: oGetLocal 1
 284: oPushResult
 285: oGetLocal 2
 287: oPushResult
 288: oPatch
 289: oPop 2
 291: oReturn
 292: oLocalSpace 0
 294: oInputChoice 312
 296: oGetParam 1
 298: oPushResult
 299: oSetResult 12
 301: oPushResult
 302: oSetResult 1
 304: oPushResult
 305: oNodeSetBoolean
 306: oPop 3
 308: oInput 4
 310: oJumpForward 317
 312: Choice Lookup Table
          62    296
 315: oJumpForward 319
 317: oJumpBack 294
 319: oReturn
 320: oLocalSpace 0
 322: oGetParam 1
 324: oPushResult
 325: oSetResult 11
 327: oPushResult
 328: oSetResult 1
 330: oPushResult
 331: oNodeSetBoolean
 332: oPop 3
 334: oInputChoice 347
 336: oInputChoice 342
 338: oInput 2
 340: oJumpForward 345
 342: Choice Lookup Table
          61    338
 345: oJumpForward 350
 347: Choice Lookup Table
           2    336
 350: oReturn
 351: oLocalSpace 4
 353: oInput 0
 355: oGetAddrLocal 1
 357: oPushResult
 358: oSetResult 0
 360: oAssign
 361: oGetAddrLocal 2
 363: oPushResult
 364: oScopeFindInCurrentScope
 365: oAssign
 366: oGetLocal 2
 368: oPushResult
 369: oNodeNull
 370: oPop 1
 372: oChoice 493
 374: oGetAddrLocal 2
 376: oPushResult
 377: oSetResult 7
 379: oPushResult
 380: oSetResult 2
 382: oPushResult
 383: LAST_ID
 384: oPushResult
 385: oCall 5612
 387: oPop 3
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oSetResult 6
 395: oPushResult
 396: oLabelNew
 397: oPushResult
 398: oNodeSetLabel
 399: oPop 3
 401: oJumpForward 499
 403: oGetAddrLocal 1
 405: oPushResult
 406: oSetResult 1
 408: oAssign
 409: oGetLocal 2
 411: oPushResult
 412: oSetResult 10
 414: oPushResult
 415: oNodeGetBoolean
 416: oPop 2
 418: oChoice 424
 420: oError 21
 422: oJumpForward 427
 424: Choice Lookup Table
           1    420
 427: oGetLocal 2
 429: oPushResult
 430: oSetResult 11
 432: oPushResult
 433: oNodeGetBoolean
 434: oPop 2
 436: oChoice 442
 438: oError 21
 440: oJumpForward 445
 442: Choice Lookup Table
           1    438
 445: oGetLocal 2
 447: oPushResult
 448: oNodeType
 449: oPop 1
 451: oChoice 455
 453: oJumpForward 460
 455: Choice Lookup Table
           7    453
 458: oError 21
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 14
 465: oPushResult
 466: oGetLocal 2
 468: oPushResult
 469: oSetResult 8
 471: oPushResult
 472: oNodeGet
 473: oPop 2
 475: oPushResult
 476: oNodeSet
 477: oPop 3
 479: oGetLocal 2
 481: oPushResult
 482: oSetResult 8
 484: oPushResult
 485: oSetResult 0
 487: oPushResult
 488: oNodeSet
 489: oPop 3
 491: oJumpForward 499
 493: Choice Lookup Table
           0    403
           1    374
 498: oEndChoice
 499: oScopeBegin
 500: oGetAddrLocal 3
 502: oPushResult
 503: oScopeCurrent
 504: oAssign
 505: oCall 982
 507: oGetLocal 2
 509: oPushResult
 510: oSetResult 8
 512: oPushResult
 513: oGetLocal 3
 515: oPushResult
 516: oNodeSet
 517: oPop 3
 519: oScopeEnd
 520: oInput 4
 522: oGetLocal 1
 524: oChoice 536
 526: oGetLocal 2
 528: oPushResult
 529: oScopeDeclare
 530: oPop 1
 532: oJumpForward 542
 534: oJumpForward 542
 536: Choice Lookup Table
           1    534
           0    526
 541: oEndChoice
 542: oGetLocal 2
 544: oPushResult
 545: oCall 292
 547: oPop 1
 549: oInputChoice 562
 551: oJumpForward 633
 553: oGetLocal 2
 555: oPushResult
 556: oCall 320
 558: oPop 1
 560: oJumpForward 633
 562: Choice Lookup Table
          60    553
          59    551
 567: oGetLocal 3
 569: oPushResult
 570: oScopeEnter
 571: oPop 1
 573: oScopeBegin
 574: oScopeCurrent
 575: oPushResult
 576: oSetResult 3
 578: oPushResult
 579: oSetResult 1
 581: oPushResult
 582: oNodeSetBoolean
 583: oPop 3
 585: oGetLocal 2
 587: oPushResult
 588: oSetResult 9
 590: oPushResult
 591: oScopeCurrent
 592: oPushResult
 593: oNodeSet
 594: oPop 3
 596: oGetAddrLocal 4
 598: oPushResult
 599: oGetLocal 2
 601: oPushResult
 602: oSetResult 6
 604: oPushResult
 605: oNodeGetLabel
 606: oPop 2
 608: oAssign
 609: oSetResult 13
 611: oPushResult
 612: oGetLocal 4
 614: oPushResult
 615: oCall 180
 617: oPop 2
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 10
 624: oPushResult
 625: oSetResult 1
 627: oPushResult
 628: oNodeSetBoolean
 629: oPop 3
 631: oScopeEnd
 632: oScopeEnd
 633: oInput 4
 635: oReturn
 636: oLocalSpace 6
 638: oInput 0
 640: oGetAddrLocal 1
 642: oPushResult
 643: oSetResult 0
 645: oAssign
 646: oGetAddrLocal 2
 648: oPushResult
 649: oScopeFindInCurrentScope
 650: oAssign
 651: oGetLocal 2
 653: oPushResult
 654: oNodeNull
 655: oPop 1
 657: oChoice 791
 659: oGetAddrLocal 2
 661: oPushResult
 662: oSetResult 8
 664: oPushResult
 665: oSetResult 3
 667: oPushResult
 668: LAST_ID
 669: oPushResult
 670: oCall 5612
 672: oPop 3
 674: oAssign
 675: oGetLocal 2
 677: oPushResult
 678: oSetResult 6
 680: oPushResult
 681: oLabelNew
 682: oPushResult
 683: oNodeSetLabel
 684: oPop 3
 686: oJumpForward 797
 688: oGetAddrLocal 1
 690: oPushResult
 691: oSetResult 1
 693: oAssign
 694: oGetLocal 2
 696: oPushResult
 697: oSetResult 10
 699: oPushResult
 700: oNodeGetBoolean
 701: oPop 2
 703: oChoice 709
 705: oError 21
 707: oJumpForward 712
 709: Choice Lookup Table
           1    705
 712: oGetLocal 2
 714: oPushResult
 715: oNodeType
 716: oPop 1
 718: oChoice 722
 720: oJumpForward 727
 722: Choice Lookup Table
           8    720
 725: oError 21
 727: oGetLocal 2
 729: oPushResult
 730: oSetResult 14
 732: oPushResult
 733: oGetLocal 2
 735: oPushResult
 736: oSetResult 8
 738: oPushResult
 739: oNodeGet
 740: oPop 2
 742: oPushResult
 743: oNodeSet
 744: oPop 3
 746: oGetLocal 2
 748: oPushResult
 749: oSetResult 8
 751: oPushResult
 752: oSetResult 0
 754: oPushResult
 755: oNodeSet
 756: oPop 3
 758: oGetLocal 2
 760: oPushResult
 761: oSetResult 15
 763: oPushResult
 764: oGetLocal 2
 766: oPushResult
 767: oSetResult 5
 769: oPushResult
 770: oNodeGet
 771: oPop 2
 773: oPushResult
 774: oNodeSet
 775: oPop 3
 777: oGetLocal 2
 779: oPushResult
 780: oSetResult 5
 782: oPushResult
 783: oSetResult 0
 785: oPushResult
 786: oNodeSet
 787: oPop 3
 789: oJumpForward 797
 791: Choice Lookup Table
           0    688
           1    659
 796: oEndChoice
 797: oScopeBegin
 798: oGetAddrLocal 3
 800: oPushResult
 801: oScopeCurrent
 802: oAssign
 803: oCall 982
 805: oGetLocal 2
 807: oPushResult
 808: oSetResult 8
 810: oPushResult
 811: oGetLocal 3
 813: oPushResult
 814: oNodeSet
 815: oPop 3
 817: oInput 11
 819: oGetAddrLocal 4
 821: oPushResult
 822: oCall 1481
 824: oPop 1
 826: oGetLocal 2
 828: oPushResult
 829: oSetResult 5
 831: oPushResult
 832: oGetLocal 4
 834: oPushResult
 835: oNodeSet
 836: oPop 3
 838: oGetAddrLocal 5
 840: oPushResult
 841: oGetLocal 4
 843: oPushResult
 844: oCall 5640
 846: oPop 1
 848: oAssign
 849: oGetLocal 2
 851: oPushResult
 852: oSetResult 16
 854: oPushResult
 855: oGetLocal 5
 857: oPushResult
 858: oScopeAllocType
 859: oPop 1
 861: oPushResult
 862: oNodeSetInt
 863: oPop 3
 865: oScopeEnd
 866: oInput 4
 868: oGetLocal 1
 870: oChoice 882
 872: oGetLocal 2
 874: oPushResult
 875: oScopeDeclare
 876: oPop 1
 878: oJumpForward 888
 880: oJumpForward 888
 882: Choice Lookup Table
           1    880
           0    872
 887: oEndChoice
 888: oGetLocal 2
 890: oPushResult
 891: oCall 292
 893: oPop 1
 895: oInputChoice 908
 897: oJumpForward 979
 899: oGetLocal 2
 901: oPushResult
 902: oCall 320
 904: oPop 1
 906: oJumpForward 979
 908: Choice Lookup Table
          60    899
          59    897
 913: oGetLocal 3
 915: oPushResult
 916: oScopeEnter
 917: oPop 1
 919: oScopeBegin
 920: oScopeCurrent
 921: oPushResult
 922: oSetResult 3
 924: oPushResult
 925: oSetResult 1
 927: oPushResult
 928: oNodeSetBoolean
 929: oPop 3
 931: oGetLocal 2
 933: oPushResult
 934: oSetResult 9
 936: oPushResult
 937: oScopeCurrent
 938: oPushResult
 939: oNodeSet
 940: oPop 3
 942: oGetAddrLocal 6
 944: oPushResult
 945: oGetLocal 2
 947: oPushResult
 948: oSetResult 6
 950: oPushResult
 951: oNodeGetLabel
 952: oPop 2
 954: oAssign
 955: oSetResult 13
 957: oPushResult
 958: oGetLocal 6
 960: oPushResult
 961: oCall 180
 963: oPop 2
 965: oGetLocal 2
 967: oPushResult
 968: oSetResult 10
 970: oPushResult
 971: oSetResult 1
 973: oPushResult
 974: oNodeSetBoolean
 975: oPop 3
 977: oScopeEnd
 978: oScopeEnd
 979: oInput 4
 981: oReturn
 982: oLocalSpace 6
 984: oInputChoice 1205
 986: oGetAddrLocal 1
 988: oPushResult
 989: oNodeVecNew
 990: oAssign
 991: oGetAddrLocal 3
 993: oPushResult
 994: oSetResult 0
 996: oAssign
 997: oInputChoice 1007
 999: oGetAddrLocal 3
1001: oPushResult
1002: oSetResult 1
1004: oAssign
1005: oJumpForward 1010
1007: Choice Lookup Table
          32    999
1010: oInput 0
1012: oGetAddrLocal 2
1014: oPushResult
1015: oSetResult 15
1017: oPushResult
1018: oSetResult 6
1020: oPushResult
1021: LAST_ID
1022: oPushResult
1023: oCall 5612
1025: oPop 3
1027: oAssign
1028: oGetLocal 2
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oGetLocal 3
1036: oPushResult
1037: oNodeSetBoolean
1038: oPop 3
1040: oGetLocal 1
1042: oPushResult
1043: oGetLocal 2
1045: oPushResult
1046: oNodeVecAppend
1047: oPop 2
1049: oInputChoice 1057
1051: oJumpForward 1065
1053: oJumpForward 1063
1055: oJumpForward 1063
1057: Choice Lookup Table
          12   1055
          11   1051
1062: oEndChoice
1063: oJumpBack 1010
1065: oGetAddrLocal 4
1067: oPushResult
1068: oCall 1481
1070: oPop 1
1072: oGetLocal 3
1074: oChoice 1089
1076: oGetAddrLocal 5
1078: oPushResult
1079: oGetLocal 4
1081: oPushResult
1082: oCall 5640
1084: oPop 1
1086: oAssign
1087: oJumpForward 1098
1089: Choice Lookup Table
           1   1076
1092: oGetAddrLocal 5
1094: oPushResult
1095: oGetLocal 4
1097: oAssign
1098: oGetAddrLocal 6
1100: oPushResult
1101: oSetResult 0
1103: oAssign
1104: oGetLocal 6
1106: oPushResult
1107: oGetLocal 1
1109: oPushResult
1110: oNodeVecSize
1111: oPop 1
1113: oPushResult
1114: equal
1115: oPop 2
1117: oChoice 1174
1119: oGetAddrLocal 2
1121: oPushResult
1122: oGetLocal 1
1124: oPushResult
1125: oGetLocal 6
1127: oPushResult
1128: oNodeVecElement
1129: oPop 2
1131: oAssign
1132: oGetLocal 2
1134: oPushResult
1135: oSetResult 5
1137: oPushResult
1138: oGetLocal 4
1140: oPushResult
1141: oNodeSet
1142: oPop 3
1144: oGetLocal 2
1146: oPushResult
1147: oScopeDeclare
1148: oPop 1
1150: oGetLocal 2
1152: oPushResult
1153: oSetResult 6
1155: oPushResult
1156: oGetLocal 5
1158: oPushResult
1159: oScopeAllocType
1160: oPop 1
1162: oPushResult
1163: oNodeSetInt
1164: oPop 3
1166: oGetAddrLocal 6
1168: oPushResult
1169: inc
1170: oPop 1
1172: oJumpForward 1179
1174: Choice Lookup Table
           0   1119
1177: oJumpForward 1181
1179: oJumpBack 1104
1181: oGetLocal 1
1183: oPushResult
1184: oNodeVecDelete
1185: oPop 1
1187: oInputChoice 1195
1189: oJumpForward 1203
1191: oJumpForward 1201
1193: oJumpForward 1201
1195: Choice Lookup Table
           4   1193
          14   1189
1200: oEndChoice
1201: oJumpBack 986
1203: oJumpForward 1208
1205: Choice Lookup Table
          13    986
1208: oReturn
1209: oLocalSpace 2
1211: oInputChoice 1273
1213: oGetAddrLocal 1
1215: oPushResult
1216: oSetResult 9
1218: oPushResult
1219: oSetResult 4
1221: oPushResult
1222: LAST_ID
1223: oPushResult
1224: oCall 5612
1226: oPop 3
1228: oAssign
1229: oInput 5
1231: oCall 1950
1233: oGetAddrLocal 2
1235: oPushResult
1236: oValueTop
1237: oAssign
1238: oValuePop
1239: oGetLocal 1
1241: oPushResult
1242: oSetResult 6
1244: oPushResult
1245: oGetLocal 2
1247: oPushResult
1248: oNodeSetInt
1249: oPop 3
1251: oGetLocal 1
1253: oPushResult
1254: oSetResult 5
1256: oPushResult
1257: oGetGlobal 3
1259: oPushResult
1260: oNodeSet
1261: oPop 3
1263: oGetLocal 1
1265: oPushResult
1266: oScopeDeclare
1267: oPop 1
1269: oInput 4
1271: oJumpForward 1278
1273: Choice Lookup Table
           0   1213
1276: oJumpForward 1280
1278: oJumpBack 1211
1280: oReturn
1281: oLocalSpace 2
1283: oInputChoice 1332
1285: oGetAddrLocal 1
1287: oPushResult
1288: oSetResult 10
1290: oPushResult
1291: oSetResult 5
1293: oPushResult
1294: LAST_ID
1295: oPushResult
1296: oCall 5612
1298: oPop 3
1300: oAssign
1301: oInput 5
1303: oGetAddrLocal 2
1305: oPushResult
1306: oCall 1481
1308: oPop 1
1310: oGetLocal 1
1312: oPushResult
1313: oSetResult 5
1315: oPushResult
1316: oGetLocal 2
1318: oPushResult
1319: oNodeSet
1320: oPop 3
1322: oGetLocal 1
1324: oPushResult
1325: oScopeDeclare
1326: oPop 1
1328: oInput 4
1330: oJumpForward 1337
1332: Choice Lookup Table
           0   1285
1335: oJumpForward 1339
1337: oJumpBack 1283
1339: oReturn
1340: oLocalSpace 4
1342: oInputChoice 1473
1344: oGetAddrLocal 1
1346: oPushResult
1347: oNodeVecNew
1348: oAssign
1349: oGetAddrLocal 2
1351: oPushResult
1352: oGetParam 1
1354: oPushResult
1355: oSetResult 6
1357: oPushResult
1358: LAST_ID
1359: oPushResult
1360: oCall 5612
1362: oPop 3
1364: oAssign
1365: oGetLocal 1
1367: oPushResult
1368: oGetLocal 2
1370: oPushResult
1371: oNodeVecAppend
1372: oPop 2
1374: oInputChoice 1380
1376: oInput 0
1378: oJumpForward 1385
1380: Choice Lookup Table
          12   1376
1383: oJumpForward 1387
1385: oJumpBack 1349
1387: oInput 11
1389: oGetAddrLocal 3
1391: oPushResult
1392: oCall 1481
1394: oPop 1
1396: oGetAddrLocal 4
1398: oPushResult
1399: oSetResult 0
1401: oAssign
1402: oGetLocal 4
1404: oPushResult
1405: oGetLocal 1
1407: oPushResult
1408: oNodeVecSize
1409: oPop 1
1411: oPushResult
1412: equal
1413: oPop 2
1415: oChoice 1456
1417: oGetAddrLocal 2
1419: oPushResult
1420: oGetLocal 1
1422: oPushResult
1423: oGetLocal 4
1425: oPushResult
1426: oNodeVecElement
1427: oPop 2
1429: oAssign
1430: oGetLocal 2
1432: oPushResult
1433: oSetResult 5
1435: oPushResult
1436: oGetLocal 3
1438: oPushResult
1439: oNodeSet
1440: oPop 3
1442: oGetLocal 2
1444: oPushResult
1445: oScopeDeclareAlloc
1446: oPop 1
1448: oGetAddrLocal 4
1450: oPushResult
1451: inc
1452: oPop 1
1454: oJumpForward 1461
1456: Choice Lookup Table
           0   1417
1459: oJumpForward 1463
1461: oJumpBack 1402
1463: oGetLocal 1
1465: oPushResult
1466: oNodeVecDelete
1467: oPop 1
1469: oInput 4
1471: oJumpForward 1478
1473: Choice Lookup Table
           0   1344
1476: oJumpForward 1480
1478: oJumpBack 1342
1480: oReturn
1481: oLocalSpace 12
1483: oInputChoice 1932
1485: oGetAddrLocal 1
1487: oPushResult
1488: oScopeFindRequire
1489: oAssign
1490: oGetLocal 1
1492: oPushResult
1493: oNodeType
1494: oPop 1
1496: oChoice 1513
1498: oGetParam 1
1500: oPushResult
1501: oGetLocal 1
1503: oPushResult
1504: oSetResult 5
1506: oPushResult
1507: oNodeGet
1508: oPop 2
1510: oAssign
1511: oJumpForward 1524
1513: Choice Lookup Table
          10   1498
1516: oError 2
1518: oGetParam 1
1520: oPushResult
1521: oGetGlobal 3
1523: oAssign
1524: oJumpForward 1949
1526: oInput 15
1528: oGetAddrLocal 2
1530: oPushResult
1531: oNodeVecNew
1532: oAssign
1533: oGetAddrLocal 3
1535: oPushResult
1536: oSetResult 25
1538: oPushResult
1539: oNodeNew
1540: oPop 1
1542: oAssign
1543: oGetLocal 3
1545: oPushResult
1546: oSetResult 19
1548: oPushResult
1549: oGetGlobal 3
1551: oPushResult
1552: oNodeSet
1553: oPop 3
1555: oCall 1950
1557: oGetLocal 3
1559: oPushResult
1560: oSetResult 21
1562: oPushResult
1563: oValueTop
1564: oPushResult
1565: oNodeSetInt
1566: oPop 3
1568: oValuePop
1569: oInput 20
1571: oCall 1950
1573: oGetLocal 3
1575: oPushResult
1576: oSetResult 22
1578: oPushResult
1579: oValueTop
1580: oPushResult
1581: oNodeSetInt
1582: oPop 3
1584: oValuePop
1585: oGetLocal 3
1587: oPushResult
1588: oSetResult 2
1590: oPushResult
1591: oSetResult 4
1593: oPushResult
1594: oNodeSetInt
1595: oPop 3
1597: oGetLocal 3
1599: oPushResult
1600: oTypeAdd
1601: oPop 1
1603: oGetAddrLocal 4
1605: oPushResult
1606: oSetResult 24
1608: oPushResult
1609: oNodeNew
1610: oPop 1
1612: oAssign
1613: oGetLocal 4
1615: oPushResult
1616: oSetResult 20
1618: oPushResult
1619: oGetLocal 3
1621: oPushResult
1622: oNodeSet
1623: oPop 3
1625: oGetLocal 2
1627: oPushResult
1628: oGetLocal 4
1630: oPushResult
1631: oNodeVecAppend
1632: oPop 2
1634: oInputChoice 1642
1636: oJumpForward 1650
1638: oJumpForward 1648
1640: oJumpForward 1648
1642: Choice Lookup Table
          12   1640
          16   1636
1647: oEndChoice
1648: oJumpBack 1533
1650: oInput 38
1652: oGetAddrLocal 5
1654: oPushResult
1655: oCall 1481
1657: oPop 1
1659: oGetAddrLocal 6
1661: oPushResult
1662: oGetLocal 2
1664: oPushResult
1665: oNodeVecSize
1666: oPop 1
1668: oAssign
1669: oGetAddrLocal 6
1671: oPushResult
1672: dec
1673: oPop 1
1675: oGetAddrLocal 7
1677: oPushResult
1678: oGetLocal 2
1680: oPushResult
1681: oGetLocal 6
1683: oPushResult
1684: oNodeVecElement
1685: oPop 2
1687: oAssign
1688: oGetLocal 7
1690: oPushResult
1691: oSetResult 19
1693: oPushResult
1694: oGetLocal 5
1696: oPushResult
1697: oNodeSet
1698: oPop 3
1700: oGetAddrLocal 8
1702: oPushResult
1703: oGetLocal 7
1705: oPushResult
1706: oSetResult 20
1708: oPushResult
1709: oNodeGet
1710: oPop 2
1712: oAssign
1713: oGetAddrLocal 9
1715: oPushResult
1716: oGetLocal 8
1718: oPushResult
1719: oSetResult 22
1721: oPushResult
1722: oNodeGetInt
1723: oPop 2
1725: oPushResult
1726: oGetLocal 8
1728: oPushResult
1729: oSetResult 21
1731: oPushResult
1732: oNodeGetInt
1733: oPop 2
1735: oPushResult
1736: subtract
1737: oPop 2
1739: oAssign
1740: oGetAddrLocal 9
1742: oPushResult
1743: inc
1744: oPop 1
1746: oGetLocal 7
1748: oPushResult
1749: oSetResult 2
1751: oPushResult
1752: oGetLocal 9
1754: oPushResult
1755: oGetLocal 5
1757: oPushResult
1758: oSetResult 2
1760: oPushResult
1761: oNodeGetInt
1762: oPop 2
1764: oPushResult
1765: multiply
1766: oPop 2
1768: oPushResult
1769: oNodeSetInt
1770: oPop 3
1772: oGetLocal 7
1774: oPushResult
1775: oTypeAdd
1776: oPop 1
1778: oGetAddrLocal 5
1780: oPushResult
1781: oGetLocal 7
1783: oAssign
1784: oGetLocal 6
1786: oPushResult
1787: equal_zero
1788: oPop 1
1790: oChoice 1796
1792: oJumpForward 1801
1794: oJumpForward 1799
1796: Choice Lookup Table
           1   1792
1799: oJumpBack 1669
1801: oGetParam 1
1803: oPushResult
1804: oGetLocal 2
1806: oPushResult
1807: oSetResult 0
1809: oPushResult
1810: oNodeVecElement
1811: oPop 2
1813: oAssign
1814: oGetLocal 2
1816: oPushResult
1817: oNodeVecDelete
1818: oPop 1
1820: oJumpForward 1949
1822: oGetAddrLocal 10
1824: oPushResult
1825: oCall 1481
1827: oPop 1
1829: oGetParam 1
1831: oPushResult
1832: oGetLocal 10
1834: oPushResult
1835: oCall 5640
1837: oPop 1
1839: oAssign
1840: oJumpForward 1949
1842: oGetParam 1
1844: oPushResult
1845: oSetResult 26
1847: oPushResult
1848: oNodeNew
1849: oPop 1
1851: oAssign
1852: oScopeBegin
1853: oSetResult 14
1855: oPushResult
1856: oCall 1340
1858: oPop 1
1860: oGetAddrLocal 11
1862: oPushResult
1863: oScopeCurrent
1864: oPushResult
1865: oSetResult 2
1867: oPushResult
1868: oNodeGetInt
1869: oPop 2
1871: oAssign
1872: oGetLocal 11
1874: oPushResult
1875: equal_zero
1876: oPop 1
1878: oChoice 1884
1880: oError 19
1882: oJumpForward 1887
1884: Choice Lookup Table
           1   1880
1887: oInput 34
1889: oGetFromParam 1
1891: oPushResult
1892: oSetResult 23
1894: oPushResult
1895: oScopeCurrent
1896: oPushResult
1897: oNodeSet
1898: oPop 3
1900: oGetFromParam 1
1902: oPushResult
1903: oSetResult 2
1905: oPushResult
1906: oGetLocal 11
1908: oPushResult
1909: oNodeSetInt
1910: oPop 3
1912: oScopeEnd
1913: oGetFromParam 1
1915: oPushResult
1916: oTypeAdd
1917: oPop 1
1919: oJumpForward 1949
1921: oInput 38
1923: oGetAddrLocal 12
1925: oPushResult
1926: oCall 1481
1928: oPop 1
1930: oJumpForward 1949
1932: Choice Lookup Table
          37   1921
          36   1842
          17   1822
          35   1526
           0   1485
1943: oCall 1950
1945: oInput 20
1947: oCall 1950
1949: oReturn
1950: oLocalSpace 1
1952: oInputChoice 2007
1954: TOKEN_VALUE
1955: oPushResult
1956: oValuePush
1957: oPop 1
1959: oJumpForward 2015
1961: oGetAddrLocal 1
1963: oPushResult
1964: oScopeFindRequire
1965: oAssign
1966: oGetLocal 1
1968: oPushResult
1969: oNodeType
1970: oPop 1
1972: oChoice 1989
1974: oGetLocal 1
1976: oPushResult
1977: oSetResult 6
1979: oPushResult
1980: oNodeGetInt
1981: oPop 2
1983: oPushResult
1984: oValuePush
1985: oPop 1
1987: oJumpForward 2000
1989: Choice Lookup Table
           9   1974
1992: oError 1
1994: oSetResult 0
1996: oPushResult
1997: oValuePush
1998: oPop 1
2000: oJumpForward 2015
2002: oCall 1950
2004: oValueNegate
2005: oJumpForward 2015
2007: Choice Lookup Table
          24   2002
           0   1961
           1   1954
2014: oEndChoice
2015: oReturn
2016: oLocalSpace 1
2018: oGetAddrLocal 1
2020: oPushResult
2021: oSetResult 0
2023: oAssign
2024: oGetAddrLocal 1
2026: oPushResult
2027: oCall 2177
2029: oPop 1
2031: oGetAddrLocal 1
2033: oPushResult
2034: oCall 2077
2036: oPop 1
2038: oReturn
2039: oLocalSpace 0
2041: oGetParam 1
2043: oPushResult
2044: oCall 2177
2046: oPop 1
2048: oTypeSNodeType
2049: oChoice 2068
2051: oJumpForward 2075
2053: oGetParam 1
2055: oPushResult
2056: oLabelNew
2057: oAssign
2058: oEmit 46
2060: oGetFromParam 1
2062: oPushResult
2063: oEmitLabel
2064: oPop 1
2066: oJumpForward 2075
2068: Choice Lookup Table
          19   2053
          20   2051
2073: oError 8
2075: oTypeSPop
2076: oReturn
2077: oLocalSpace 1
2079: oTypeSNodeType
2080: oChoice 2142
2082: oGetAddrLocal 1
2084: oPushResult
2085: oLabelNew
2086: oAssign
2087: oEmit 9
2089: oSetResult 1
2091: oPushResult
2092: oEmitInt
2093: oPop 1
2095: oEmit 44
2097: oGetLocal 1
2099: oPushResult
2100: oEmitLabel
2101: oPop 1
2103: oEmit 47
2105: oGetFromParam 1
2107: oPushResult
2108: oEmitLabel
2109: oPop 1
2111: oEmit 9
2113: oSetResult 0
2115: oPushResult
2116: oEmitInt
2117: oPop 1
2119: oEmit 47
2121: oGetLocal 1
2123: oPushResult
2124: oEmitLabel
2125: oPop 1
2127: oTypeSPop
2128: oGetGlobal 4
2130: oPushResult
2131: oTypeSPush
2132: oPop 1
2134: oGetParam 1
2136: oPushResult
2137: oSetResult 0
2139: oAssign
2140: oJumpForward 2145
2142: Choice Lookup Table
          20   2082
2145: oReturn
2146: oLocalSpace 0
2148: oTypeSNodeType
2149: oChoice 2173
2151: oGetParam 1
2153: oPushResult
2154: oLabelNew
2155: oAssign
2156: oEmit 46
2158: oGetFromParam 1
2160: oPushResult
2161: oEmitLabel
2162: oPop 1
2164: oTypeSPop
2165: oGetGlobal 5
2167: oPushResult
2168: oTypeSPush
2169: oPop 1
2171: oJumpForward 2176
2173: Choice Lookup Table
          19   2151
2176: oReturn
2177: oLocalSpace 0
2179: oGetParam 1
2181: oPushResult
2182: oCall 2542
2184: oPop 1
2186: oInputChoice 2524
2188: oGetParam 1
2190: oPushResult
2191: oCall 2077
2193: oPop 1
2195: oGetParam 1
2197: oPushResult
2198: oCall 2542
2200: oPop 1
2202: oGetParam 1
2204: oPushResult
2205: oCall 2077
2207: oPop 1
2209: oCall 5498
2211: oTypeSNodeType
2212: oChoice 2226
2214: oEmit 30
2216: oJumpForward 2239
2218: oEmit 36
2220: oJumpForward 2239
2222: oError 16
2224: oJumpForward 2239
2226: Choice Lookup Table
          22   2222
          21   2222
          23   2218
          19   2214
          18   2214
2237: oError 17
2239: oTypeSPop
2240: oGetGlobal 4
2242: oPushResult
2243: oTypeSPush
2244: oPop 1
2246: oJumpForward 2539
2248: oGetParam 1
2250: oPushResult
2251: oCall 2077
2253: oPop 1
2255: oGetParam 1
2257: oPushResult
2258: oCall 2542
2260: oPop 1
2262: oGetParam 1
2264: oPushResult
2265: oCall 2077
2267: oPop 1
2269: oCall 5498
2271: oTypeSNodeType
2272: oChoice 2286
2274: oEmit 31
2276: oJumpForward 2299
2278: oEmit 37
2280: oJumpForward 2299
2282: oError 16
2284: oJumpForward 2299
2286: Choice Lookup Table
          22   2282
          21   2282
          23   2278
          19   2274
          18   2274
2297: oError 17
2299: oTypeSPop
2300: oGetGlobal 4
2302: oPushResult
2303: oTypeSPush
2304: oPop 1
2306: oJumpForward 2539
2308: oGetParam 1
2310: oPushResult
2311: oCall 2077
2313: oPop 1
2315: oGetParam 1
2317: oPushResult
2318: oCall 2542
2320: oPop 1
2322: oGetParam 1
2324: oPushResult
2325: oCall 2077
2327: oPop 1
2329: oCall 5498
2331: oTypeSNodeType
2332: oChoice 2342
2334: oEmit 33
2336: oJumpForward 2353
2338: oError 16
2340: oJumpForward 2353
2342: Choice Lookup Table
          22   2338
          21   2338
          19   2334
          18   2334
2351: oError 17
2353: oTypeSPop
2354: oGetGlobal 4
2356: oPushResult
2357: oTypeSPush
2358: oPop 1
2360: oJumpForward 2539
2362: oGetParam 1
2364: oPushResult
2365: oCall 2077
2367: oPop 1
2369: oGetParam 1
2371: oPushResult
2372: oCall 2542
2374: oPop 1
2376: oGetParam 1
2378: oPushResult
2379: oCall 2077
2381: oPop 1
2383: oCall 5498
2385: oTypeSNodeType
2386: oChoice 2396
2388: oEmit 32
2390: oJumpForward 2407
2392: oError 16
2394: oJumpForward 2407
2396: Choice Lookup Table
          22   2392
          21   2392
          19   2388
          18   2388
2405: oError 17
2407: oTypeSPop
2408: oGetGlobal 4
2410: oPushResult
2411: oTypeSPush
2412: oPop 1
2414: oJumpForward 2539
2416: oGetParam 1
2418: oPushResult
2419: oCall 2077
2421: oPop 1
2423: oGetParam 1
2425: oPushResult
2426: oCall 2542
2428: oPop 1
2430: oGetParam 1
2432: oPushResult
2433: oCall 2077
2435: oPop 1
2437: oCall 5498
2439: oTypeSNodeType
2440: oChoice 2450
2442: oEmit 35
2444: oJumpForward 2461
2446: oError 16
2448: oJumpForward 2461
2450: Choice Lookup Table
          22   2446
          21   2446
          19   2442
          18   2442
2459: oError 17
2461: oTypeSPop
2462: oGetGlobal 4
2464: oPushResult
2465: oTypeSPush
2466: oPop 1
2468: oJumpForward 2539
2470: oGetParam 1
2472: oPushResult
2473: oCall 2077
2475: oPop 1
2477: oGetParam 1
2479: oPushResult
2480: oCall 2542
2482: oPop 1
2484: oGetParam 1
2486: oPushResult
2487: oCall 2077
2489: oPop 1
2491: oCall 5498
2493: oTypeSNodeType
2494: oChoice 2504
2496: oEmit 34
2498: oJumpForward 2515
2500: oError 16
2502: oJumpForward 2515
2504: Choice Lookup Table
          22   2500
          21   2500
          19   2496
          18   2496
2513: oError 17
2515: oTypeSPop
2516: oGetGlobal 4
2518: oPushResult
2519: oTypeSPush
2520: oPop 1
2522: oJumpForward 2539
2524: Choice Lookup Table
          10   2470
           9   2416
           8   2362
           7   2308
           6   2248
           5   2188
2537: oJumpForward 2541
2539: oJumpBack 2186
2541: oReturn
2542: oLocalSpace 1
2544: oGetAddrLocal 1
2546: oPushResult
2547: oSetResult 0
2549: oAssign
2550: oGetParam 1
2552: oPushResult
2553: oCall 2722
2555: oPop 1
2557: oInputChoice 2690
2559: oTypeSNodeType
2560: oChoice 2631
2562: oGetLocal 1
2564: oPushResult
2565: oSetResult 0
2567: oPushResult
2568: equal_label
2569: oPop 2
2571: oChoice 2580
2573: oGetAddrLocal 1
2575: oPushResult
2576: oLabelNew
2577: oAssign
2578: oJumpForward 2583
2580: Choice Lookup Table
           1   2573
2583: oEmit 44
2585: oGetLocal 1
2587: oPushResult
2588: oEmitLabel
2589: oPop 1
2591: oJumpForward 2638
2593: oGetParam 1
2595: oPushResult
2596: oCall 2146
2598: oPop 1
2600: oGetLocal 1
2602: oPushResult
2603: oSetResult 0
2605: oPushResult
2606: equal_label
2607: oPop 2
2609: oChoice 2618
2611: oGetAddrLocal 1
2613: oPushResult
2614: oLabelNew
2615: oAssign
2616: oJumpForward 2621
2618: Choice Lookup Table
           1   2611
2621: oEmit 45
2623: oGetLocal 1
2625: oPushResult
2626: oEmitLabel
2627: oPop 1
2629: oJumpForward 2638
2631: Choice Lookup Table
          19   2593
          20   2562
2636: oError 8
2638: oTypeSPop
2639: oEmit 47
2641: oGetFromParam 1
2643: oPushResult
2644: oEmitLabel
2645: oPop 1
2647: oGetParam 1
2649: oPushResult
2650: oSetResult 0
2652: oAssign
2653: oGetParam 1
2655: oPushResult
2656: oCall 2722
2658: oPop 1
2660: oTypeSNodeType
2661: oChoice 2674
2663: oJumpForward 2681
2665: oGetParam 1
2667: oPushResult
2668: oCall 2146
2670: oPop 1
2672: oJumpForward 2681
2674: Choice Lookup Table
          19   2665
          20   2663
2679: oError 8
2681: oTypeSPop
2682: oGetGlobal 5
2684: oPushResult
2685: oTypeSPush
2686: oPop 1
2688: oJumpForward 2695
2690: Choice Lookup Table
          53   2559
2693: oJumpForward 2697
2695: oJumpBack 2557
2697: oGetLocal 1
2699: oPushResult
2700: oSetResult 0
2702: oPushResult
2703: equal_label
2704: oPop 2
2706: oChoice 2718
2708: oEmit 47
2710: oGetLocal 1
2712: oPushResult
2713: oEmitLabel
2714: oPop 1
2716: oJumpForward 2721
2718: Choice Lookup Table
           0   2708
2721: oReturn
2722: oLocalSpace 2
2724: oGetAddrLocal 1
2726: oPushResult
2727: oSetResult 0
2729: oAssign
2730: oGetParam 1
2732: oPushResult
2733: oCall 2860
2735: oPop 1
2737: oInputChoice 2852
2739: oTypeSNodeType
2740: oChoice 2753
2742: oJumpForward 2760
2744: oGetParam 1
2746: oPushResult
2747: oCall 2146
2749: oPop 1
2751: oJumpForward 2760
2753: Choice Lookup Table
          19   2744
          20   2742
2758: oError 8
2760: oTypeSPop
2761: oGetLocal 1
2763: oPushResult
2764: oSetResult 0
2766: oPushResult
2767: equal_label
2768: oPop 2
2770: oChoice 2799
2772: oGetAddrLocal 1
2774: oPushResult
2775: oLabelNew
2776: oAssign
2777: oEmit 48
2779: oGetFromParam 1
2781: oPushResult
2782: oEmitLabel
2783: oPop 1
2785: oGetLocal 1
2787: oPushResult
2788: oEmitLabel
2789: oPop 1
2791: oGetParam 1
2793: oPushResult
2794: oGetLocal 1
2796: oAssign
2797: oJumpForward 2802
2799: Choice Lookup Table
           1   2772
2802: oGetAddrLocal 2
2804: oPushResult
2805: oSetResult 0
2807: oAssign
2808: oGetAddrLocal 2
2810: oPushResult
2811: oCall 2860
2813: oPop 1
2815: oTypeSNodeType
2816: oChoice 2829
2818: oJumpForward 2836
2820: oGetAddrLocal 2
2822: oPushResult
2823: oCall 2146
2825: oPop 1
2827: oJumpForward 2836
2829: Choice Lookup Table
          19   2820
          20   2818
2834: oError 8
2836: oEmit 48
2838: oGetLocal 2
2840: oPushResult
2841: oEmitLabel
2842: oPop 1
2844: oGetLocal 1
2846: oPushResult
2847: oEmitLabel
2848: oPop 1
2850: oJumpForward 2857
2852: Choice Lookup Table
          52   2739
2855: oJumpForward 2859
2857: oJumpBack 2737
2859: oReturn
2860: oLocalSpace 1
2862: oInputChoice 2916
2864: oGetAddrLocal 1
2866: oPushResult
2867: oSetResult 0
2869: oAssign
2870: oGetAddrLocal 1
2872: oPushResult
2873: oCall 2860
2875: oPop 1
2877: oTypeSNodeType
2878: oChoice 2907
2880: oGetParam 1
2882: oPushResult
2883: oLabelNew
2884: oAssign
2885: oEmit 44
2887: oGetFromParam 1
2889: oPushResult
2890: oEmitLabel
2891: oPop 1
2893: oEmit 47
2895: oGetLocal 1
2897: oPushResult
2898: oEmitLabel
2899: oPop 1
2901: oJumpForward 2914
2903: oEmit 29
2905: oJumpForward 2914
2907: Choice Lookup Table
          19   2903
          20   2880
2912: oError 8
2914: oJumpForward 2926
2916: Choice Lookup Table
          54   2864
2919: oGetParam 1
2921: oPushResult
2922: oCall 2927
2924: oPop 1
2926: oReturn
2927: oLocalSpace 0
2929: oGetParam 1
2931: oPushResult
2932: oCall 2978
2934: oPop 1
2936: oInputChoice 2968
2938: oCall 5524
2940: oGetParam 1
2942: oPushResult
2943: oCall 2978
2945: oPop 1
2947: oCall 5538
2949: oEmit 26
2951: oJumpForward 2975
2953: oCall 5524
2955: oGetParam 1
2957: oPushResult
2958: oCall 2978
2960: oPop 1
2962: oCall 5538
2964: oEmit 27
2966: oJumpForward 2975
2968: Choice Lookup Table
          24   2953
          23   2938
2973: oJumpForward 2977
2975: oJumpBack 2936
2977: oReturn
2978: oLocalSpace 0
2980: oGetParam 1
2982: oPushResult
2983: oCall 3029
2985: oPop 1
2987: oInputChoice 3019
2989: oCall 5524
2991: oGetParam 1
2993: oPushResult
2994: oCall 3029
2996: oPop 1
2998: oCall 5538
3000: oEmit 23
3002: oJumpForward 3026
3004: oCall 5524
3006: oGetParam 1
3008: oPushResult
3009: oCall 3029
3011: oPop 1
3013: oCall 5538
3015: oEmit 24
3017: oJumpForward 3026
3019: Choice Lookup Table
          22   3004
          21   2989
3024: oJumpForward 3028
3026: oJumpBack 2987
3028: oReturn
3029: oLocalSpace 0
3031: oInputChoice 3057
3033: oGetParam 1
3035: oPushResult
3036: oCall 3070
3038: oPop 1
3040: oCall 5538
3042: oJumpForward 3069
3044: oGetParam 1
3046: oPushResult
3047: oCall 3070
3049: oPop 1
3051: oCall 5538
3053: oEmit 28
3055: oJumpForward 3069
3057: Choice Lookup Table
          24   3044
          23   3033
3062: oGetParam 1
3064: oPushResult
3065: oCall 3070
3067: oPop 1
3069: oReturn
3070: oLocalSpace 6
3072: oInputChoice 3254
3074: oEmit 9
3076: TOKEN_VALUE
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oGetGlobal 3
3083: oPushResult
3084: oTypeSPush
3085: oPop 1
3087: oJumpForward 3273
3089: oGetParam 1
3091: oPushResult
3092: oCall 2177
3094: oPop 1
3096: oInput 14
3098: oJumpForward 3273
3100: oGetAddrLocal 1
3102: oPushResult
3103: oStringAllocLit
3104: oAssign
3105: oEmit 10
3107: oGetLocal 1
3109: oPushResult
3110: oEmitInt
3111: oPop 1
3113: oGetGlobal 7
3115: oPushResult
3116: oTypeSPush
3117: oPop 1
3119: oJumpForward 3273
3121: oGetAddrLocal 2
3123: oPushResult
3124: oScopeFindRequire
3125: oAssign
3126: oGetLocal 2
3128: oPushResult
3129: oNodeType
3130: oPop 1
3132: oChoice 3194
3134: oGetLocal 2
3136: oPushResult
3137: oCall 3996
3139: oPop 1
3141: oJumpForward 3213
3143: oGetAddrLocal 3
3145: oPushResult
3146: oGetLocal 2
3148: oPushResult
3149: oSetResult 5
3151: oPushResult
3152: oNodeGet
3153: oPop 2
3155: oAssign
3156: oGetLocal 3
3158: oPushResult
3159: oTypeSPush
3160: oPop 1
3162: oTypeSNodeType
3163: oChoice 3176
3165: oEmit 9
3167: oGetLocal 2
3169: oPushResult
3170: oCall 5775
3172: oPop 1
3174: oJumpForward 3183
3176: Choice Lookup Table
          19   3165
          18   3165
3181: oError 16
3183: oJumpForward 3213
3185: oGetLocal 2
3187: oPushResult
3188: oCall 3274
3190: oPop 1
3192: oJumpForward 3213
3194: Choice Lookup Table
          15   3185
          13   3185
          12   3185
           9   3143
           8   3134
3205: oError 6
3207: oGetGlobal 3
3209: oPushResult
3210: oTypeSPush
3211: oPop 1
3213: oJumpForward 3273
3215: oInput 0
3217: oGetAddrLocal 4
3219: oPushResult
3220: oScopeFindRequire
3221: oAssign
3222: oGetLocal 4
3224: oPushResult
3225: oCall 4817
3227: oPop 1
3229: oGetAddrLocal 5
3231: oPushResult
3232: oTypeSTop
3233: oAssign
3234: oTypeSPop
3235: oGetAddrLocal 6
3237: oPushResult
3238: oGetLocal 5
3240: oPushResult
3241: oCall 5640
3243: oPop 1
3245: oAssign
3246: oGetLocal 6
3248: oPushResult
3249: oTypeSPush
3250: oPop 1
3252: oJumpForward 3273
3254: Choice Lookup Table
          18   3215
           0   3121
           2   3100
          13   3089
           1   3074
3265: oError 6
3267: oGetGlobal 3
3269: oPushResult
3270: oTypeSPush
3271: oPop 1
3273: oReturn
3274: oLocalSpace 1
3276: oGetAddrLocal 1
3278: oPushResult
3279: oGetParam 1
3281: oPushResult
3282: oSetResult 5
3284: oPushResult
3285: oNodeGet
3286: oPop 2
3288: oAssign
3289: oGetLocal 1
3291: oPushResult
3292: oTypeSPush
3293: oPop 1
3295: oTypeSNodeType
3296: oChoice 3561
3298: oGetParam 1
3300: oPushResult
3301: oNodeType
3302: oPop 1
3304: oChoice 3366
3306: oEmit 0
3308: oGetParam 1
3310: oPushResult
3311: oCall 5775
3313: oPop 1
3315: oJumpForward 3374
3317: oEmit 3
3319: oGetParam 1
3321: oPushResult
3322: oCall 5775
3324: oPop 1
3326: oJumpForward 3374
3328: oGetParam 1
3330: oPushResult
3331: oSetResult 17
3333: oPushResult
3334: oNodeGetBoolean
3335: oPop 2
3337: oChoice 3352
3339: oEmit 8
3341: oGetParam 1
3343: oPushResult
3344: oCall 5775
3346: oPop 1
3348: oEmit 14
3350: oJumpForward 3364
3352: Choice Lookup Table
           1   3339
3355: oEmit 6
3357: oGetParam 1
3359: oPushResult
3360: oCall 5775
3362: oPop 1
3364: oJumpForward 3374
3366: Choice Lookup Table
          15   3328
          13   3317
          12   3306
3373: oEndChoice
3374: oJumpForward 3652
3376: oGetParam 1
3378: oPushResult
3379: oNodeType
3380: oPop 1
3382: oChoice 3444
3384: oEmit 1
3386: oGetParam 1
3388: oPushResult
3389: oCall 5775
3391: oPop 1
3393: oJumpForward 3452
3395: oEmit 4
3397: oGetParam 1
3399: oPushResult
3400: oCall 5775
3402: oPop 1
3404: oJumpForward 3452
3406: oGetParam 1
3408: oPushResult
3409: oSetResult 17
3411: oPushResult
3412: oNodeGetBoolean
3413: oPop 2
3415: oChoice 3430
3417: oEmit 8
3419: oGetParam 1
3421: oPushResult
3422: oCall 5775
3424: oPop 1
3426: oEmit 15
3428: oJumpForward 3442
3430: Choice Lookup Table
           1   3417
3433: oEmit 7
3435: oGetParam 1
3437: oPushResult
3438: oCall 5775
3440: oPop 1
3442: oJumpForward 3452
3444: Choice Lookup Table
          15   3406
          13   3395
          12   3384
3451: oEndChoice
3452: oJumpForward 3652
3454: oError 16
3456: oJumpForward 3652
3458: oGetParam 1
3460: oPushResult
3461: oNodeType
3462: oPop 1
3464: oChoice 3526
3466: oEmit 2
3468: oGetParam 1
3470: oPushResult
3471: oCall 5775
3473: oPop 1
3475: oJumpForward 3534
3477: oEmit 5
3479: oGetParam 1
3481: oPushResult
3482: oCall 5775
3484: oPop 1
3486: oJumpForward 3534
3488: oGetParam 1
3490: oPushResult
3491: oSetResult 17
3493: oPushResult
3494: oNodeGetBoolean
3495: oPop 2
3497: oChoice 3512
3499: oEmit 8
3501: oGetParam 1
3503: oPushResult
3504: oCall 5775
3506: oPop 1
3508: oEmit 16
3510: oJumpForward 3524
3512: Choice Lookup Table
           1   3499
3515: oEmit 8
3517: oGetParam 1
3519: oPushResult
3520: oCall 5775
3522: oPop 1
3524: oJumpForward 3534
3526: Choice Lookup Table
          15   3488
          13   3477
          12   3466
3533: oEndChoice
3534: oInputChoice 3556
3536: oTypeSPop
3537: oGetLocal 1
3539: oPushResult
3540: oSetResult 19
3542: oPushResult
3543: oNodeGet
3544: oPop 2
3546: oPushResult
3547: oTypeSPush
3548: oPop 1
3550: oCall 3688
3552: oCall 3653
3554: oJumpForward 3559
3556: Choice Lookup Table
          17   3536
3559: oJumpForward 3652
3561: Choice Lookup Table
          23   3458
          17   3454
          22   3454
          21   3454
          19   3376
          18   3298
3574: oGetParam 1
3576: oPushResult
3577: oNodeType
3578: oPop 1
3580: oChoice 3640
3582: oEmit 10
3584: oGetParam 1
3586: oPushResult
3587: oCall 5775
3589: oPop 1
3591: oJumpForward 3648
3593: oEmit 11
3595: oGetParam 1
3597: oPushResult
3598: oCall 5775
3600: oPop 1
3602: oJumpForward 3648
3604: oGetParam 1
3606: oPushResult
3607: oSetResult 17
3609: oPushResult
3610: oNodeGetBoolean
3611: oPop 2
3613: oChoice 3626
3615: oEmit 8
3617: oGetParam 1
3619: oPushResult
3620: oCall 5775
3622: oPop 1
3624: oJumpForward 3638
3626: Choice Lookup Table
           1   3615
3629: oEmit 12
3631: oGetParam 1
3633: oPushResult
3634: oCall 5775
3636: oPop 1
3638: oJumpForward 3648
3640: Choice Lookup Table
          15   3604
          13   3593
          12   3582
3647: oEndChoice
3648: oCall 3688
3650: oCall 3653
3652: oReturn
3653: oLocalSpace 0
3655: oTypeSNodeType
3656: oChoice 3674
3658: oEmit 14
3660: oJumpForward 3687
3662: oEmit 15
3664: oJumpForward 3687
3666: oError 16
3668: oJumpForward 3687
3670: oEmit 16
3672: oJumpForward 3687
3674: Choice Lookup Table
          23   3670
          17   3666
          22   3666
          21   3666
          19   3662
          18   3658
3687: oReturn
3688: oLocalSpace 0
3690: oInputChoice 3704
3692: oCall 3716
3694: oJumpForward 3713
3696: oCall 3859
3698: oJumpForward 3713
3700: oCall 3957
3702: oJumpForward 3713
3704: Choice Lookup Table
          17   3700
          19   3696
          15   3692
3711: oJumpForward 3715
3713: oJumpBack 3690
3715: oReturn
3716: oLocalSpace 3
3718: oTypeSNodeType
3719: oChoice 3723
3721: oJumpForward 3728
3723: Choice Lookup Table
          24   3721
3726: oError 10
3728: oTypeSNodeType
3729: oChoice 3733
3731: oJumpForward 3738
3733: Choice Lookup Table
          24   3731
3736: oError 13
3738: oGetAddrLocal 1
3740: oPushResult
3741: oTypeSTop
3742: oPushResult
3743: oSetResult 20
3745: oPushResult
3746: oNodeGet
3747: oPop 2
3749: oPushResult
3750: oCall 5724
3752: oPop 1
3754: oAssign
3755: oGetAddrLocal 2
3757: oPushResult
3758: oTypeSTop
3759: oPushResult
3760: oSetResult 19
3762: oPushResult
3763: oNodeGet
3764: oPop 2
3766: oAssign
3767: oTypeSPop
3768: oGetLocal 2
3770: oPushResult
3771: oTypeSPush
3772: oPop 1
3774: oCall 2016
3776: oCall 5524
3778: oGetLocal 1
3780: oPushResult
3781: equal_zero
3782: oPop 1
3784: oChoice 3798
3786: oEmit 9
3788: oGetLocal 1
3790: oPushResult
3791: oEmitInt
3792: oPop 1
3794: oEmit 27
3796: oJumpForward 3801
3798: Choice Lookup Table
           0   3786
3801: oGetAddrLocal 3
3803: oPushResult
3804: oGetLocal 2
3806: oPushResult
3807: oSetResult 2
3809: oPushResult
3810: oNodeGetInt
3811: oPop 2
3813: oAssign
3814: oGetLocal 3
3816: oPushResult
3817: oSetResult 1
3819: oPushResult
3820: equal
3821: oPop 2
3823: oChoice 3837
3825: oEmit 9
3827: oGetLocal 3
3829: oPushResult
3830: oEmitInt
3831: oPop 1
3833: oEmit 23
3835: oJumpForward 3840
3837: Choice Lookup Table
           0   3825
3840: oEmit 25
3842: oInputChoice 3850
3844: oJumpForward 3858
3846: oJumpForward 3856
3848: oJumpForward 3856
3850: Choice Lookup Table
          12   3848
          16   3844
3855: oEndChoice
3856: oJumpBack 3728
3858: oReturn
3859: oLocalSpace 2
3861: oTypeSNodeType
3862: oChoice 3866
3864: oJumpForward 3871
3866: Choice Lookup Table
          26   3864
3869: oError 11
3871: oTypeSTop
3872: oPushResult
3873: oSetResult 23
3875: oPushResult
3876: oNodeGet
3877: oPop 2
3879: oPushResult
3880: oScopeEnter
3881: oPop 1
3883: oInput 0
3885: oGetAddrLocal 1
3887: oPushResult
3888: oScopeFindRequire
3889: oAssign
3890: oGetLocal 1
3892: oPushResult
3893: oNodeType
3894: oPop 1
3896: oChoice 3900
3898: oJumpForward 3905
3900: Choice Lookup Table
          14   3898
3903: oError 12
3905: oScopeEnd
3906: oGetAddrLocal 2
3908: oPushResult
3909: oGetLocal 1
3911: oPushResult
3912: oSetResult 6
3914: oPushResult
3915: oNodeGetInt
3916: oPop 2
3918: oAssign
3919: oGetLocal 2
3921: oPushResult
3922: equal_zero
3923: oPop 1
3925: oChoice 3939
3927: oEmit 9
3929: oGetLocal 2
3931: oPushResult
3932: oEmitInt
3933: oPop 1
3935: oEmit 25
3937: oJumpForward 3942
3939: Choice Lookup Table
           0   3927
3942: oTypeSPop
3943: oGetLocal 1
3945: oPushResult
3946: oSetResult 5
3948: oPushResult
3949: oNodeGet
3950: oPop 2
3952: oPushResult
3953: oTypeSPush
3954: oPop 1
3956: oReturn
3957: oLocalSpace 1
3959: oTypeSNodeType
3960: oChoice 3964
3962: oJumpForward 3969
3964: Choice Lookup Table
          23   3962
3967: oError 9
3969: oEmit 16
3971: oGetAddrLocal 1
3973: oPushResult
3974: oTypeSTop
3975: oAssign
3976: oTypeSPop
3977: oGetLocal 1
3979: oPushResult
3980: oSetResult 19
3982: oPushResult
3983: oNodeGet
3984: oPop 2
3986: oPushResult
3987: oTypeSPush
3988: oPop 1
3990: oReturn
3991: oLocalSpace 0
3993: oCall 5498
3995: oReturn
3996: oLocalSpace 9
3998: oGetParam 1
4000: oPushResult
4001: oSetResult 11
4003: oPushResult
4004: oNodeGetBoolean
4005: oPop 2
4007: oChoice 4059
4009: oGetParam 1
4011: oPushResult
4012: oSetResult 13
4014: oPushResult
4015: oNodeGetBoolean
4016: oPop 2
4018: oChoice 4054
4020: oGetAddrLocal 1
4022: oPushResult
4023: oGetParam 1
4025: oPushResult
4026: oSetResult 4
4028: oPushResult
4029: oNodeGetInt
4030: oPop 2
4032: oPushResult
4033: oStringAllocLitFromIdent
4034: oPop 1
4036: oAssign
4037: oEmit 49
4039: oGetParam 1
4041: oPushResult
4042: oCall 5775
4044: oPop 1
4046: oGetLocal 1
4048: oPushResult
4049: oEmitInt
4050: oPop 1
4052: oJumpForward 4057
4054: Choice Lookup Table
           0   4020
4057: oJumpForward 4062
4059: Choice Lookup Table
           1   4009
4062: oGetParam 1
4064: oPushResult
4065: oSetResult 13
4067: oPushResult
4068: oSetResult 1
4070: oPushResult
4071: oNodeSetBoolean
4072: oPop 3
4074: oGetAddrLocal 4
4076: oPushResult
4077: oGetParam 1
4079: oPushResult
4080: oNodeType
4081: oPop 1
4083: oPushResult
4084: oSetResult 8
4086: oPushResult
4087: equal_node_type
4088: oPop 2
4090: oAssign
4091: oGetLocal 4
4093: oChoice 4120
4095: oGetAddrLocal 2
4097: oPushResult
4098: oGetParam 1
4100: oPushResult
4101: oSetResult 5
4103: oPushResult
4104: oNodeGet
4105: oPop 2
4107: oAssign
4108: oGetAddrLocal 3
4110: oPushResult
4111: oGetLocal 2
4113: oPushResult
4114: oScopeAllocType
4115: oPop 1
4117: oAssign
4118: oJumpForward 4123
4120: Choice Lookup Table
           1   4095
4123: oGetAddrLocal 5
4125: oPushResult
4126: oGetParam 1
4128: oPushResult
4129: oSetResult 8
4131: oPushResult
4132: oNodeGet
4133: oPop 2
4135: oAssign
4136: oGetAddrLocal 6
4138: oPushResult
4139: oGetLocal 5
4141: oPushResult
4142: oSetResult 2
4144: oPushResult
4145: oNodeGetInt
4146: oPop 2
4148: oAssign
4149: oEmit 38
4151: oGetLocal 6
4153: oPushResult
4154: oEmitInt
4155: oPop 1
4157: oGetAddrLocal 7
4159: oPushResult
4160: oGetLocal 5
4162: oPushResult
4163: oSetResult 1
4165: oPushResult
4166: oNodeGet
4167: oPop 2
4169: oAssign
4170: oInputChoice 4339
4172: oGetLocal 7
4174: oPushResult
4175: oNodeNull
4176: oPop 1
4178: oChoice 4184
4180: oJumpForward 4335
4182: oJumpForward 4187
4184: Choice Lookup Table
           1   4180
4187: oGetAddrLocal 8
4189: oPushResult
4190: oGetLocal 7
4192: oPushResult
4193: oSetResult 6
4195: oPushResult
4196: oNodeGetInt
4197: oPop 2
4199: oAssign
4200: oEmit 13
4202: oGetLocal 8
4204: oPushResult
4205: oEmitInt
4206: oPop 1
4208: oGetLocal 7
4210: oPushResult
4211: oSetResult 5
4213: oPushResult
4214: oNodeGet
4215: oPop 2
4217: oPushResult
4218: oTypeSPush
4219: oPop 1
4221: oGetLocal 7
4223: oPushResult
4224: oSetResult 17
4226: oPushResult
4227: oNodeGetBoolean
4228: oPop 2
4230: oChoice 4298
4232: oCall 4781
4234: oCall 5498
4236: oEmit 19
4238: oJumpForward 4304
4240: oCall 2016
4242: oCall 3991
4244: oTypeSNodeType
4245: oChoice 4263
4247: oEmit 17
4249: oJumpForward 4296
4251: oEmit 18
4253: oJumpForward 4296
4255: oError 16
4257: oJumpForward 4296
4259: oEmit 19
4261: oJumpForward 4296
4263: Choice Lookup Table
          23   4259
          17   4255
          22   4255
          21   4255
          19   4251
          18   4247
4276: oGetAddrLocal 9
4278: oPushResult
4279: oTypeSTop
4280: oPushResult
4281: oSetResult 2
4283: oPushResult
4284: oNodeGetInt
4285: oPop 2
4287: oAssign
4288: oEmit 20
4290: oGetLocal 9
4292: oPushResult
4293: oEmitInt
4294: oPop 1
4296: oJumpForward 4304
4298: Choice Lookup Table
           0   4240
           1   4232
4303: oEndChoice
4304: oTypeSPop
4305: oGetAddrLocal 7
4307: oPushResult
4308: oNodeNext
4309: oPop 1
4311: oGetLocal 7
4313: oPushResult
4314: oNodeNull
4315: oPop 1
4317: oChoice 4325
4319: oJumpForward 4335
4321: oJumpForward 4331
4323: oJumpForward 4331
4325: Choice Lookup Table
           0   4323
           1   4319
4330: oEndChoice
4331: oInput 12
4333: oJumpBack 4172
4335: oInput 14
4337: oJumpForward 4342
4339: Choice Lookup Table
          13   4172
4342: oGetLocal 7
4344: oPushResult
4345: oNodeNull
4346: oPop 1
4348: oChoice 4354
4350: oError 15
4352: oJumpForward 4357
4354: Choice Lookup Table
           0   4350
4357: oGetLocal 4
4359: oChoice 4388
4361: oEmit 13
4363: oGetParam 1
4365: oPushResult
4366: oSetResult 16
4368: oPushResult
4369: oNodeGetInt
4370: oPop 2
4372: oPushResult
4373: oEmitInt
4374: oPop 1
4376: oEmit 11
4378: oGetLocal 3
4380: oPushResult
4381: oEmitInt
4382: oPop 1
4384: oEmit 19
4386: oJumpForward 4391
4388: Choice Lookup Table
           1   4361
4391: oGetParam 1
4393: oPushResult
4394: oSetResult 12
4396: oPushResult
4397: oNodeGetBoolean
4398: oPop 2
4400: oChoice 4424
4402: oEmit 41
4404: oGetParam 1
4406: oPushResult
4407: oCall 5775
4409: oPop 1
4411: oJumpForward 4430
4413: oEmit 40
4415: oGetParam 1
4417: oPushResult
4418: oCall 5775
4420: oPop 1
4422: oJumpForward 4430
4424: Choice Lookup Table
           0   4413
           1   4402
4429: oEndChoice
4430: oGetLocal 4
4432: oChoice 4452
4434: oGetLocal 2
4436: oPushResult
4437: oTypeSPush
4438: oPop 1
4440: oEmit 11
4442: oGetLocal 3
4444: oPushResult
4445: oEmitInt
4446: oPop 1
4448: oCall 3653
4450: oJumpForward 4455
4452: Choice Lookup Table
           1   4434
4455: oEmit 39
4457: oGetLocal 6
4459: oPushResult
4460: oEmitInt
4461: oPop 1
4463: oReturn
4464: oLocalSpace 0
4466: oInputChoice 4516
4468: oCall 5418
4470: oJumpForward 4541
4472: oCall 5425
4474: oJumpForward 4541
4476: oCall 5492
4478: oJumpForward 4541
4480: oCall 5495
4482: oJumpForward 4541
4484: oCall 4958
4486: oJumpForward 4541
4488: oCall 5278
4490: oJumpForward 4541
4492: oCall 5024
4494: oJumpForward 4541
4496: oCall 5198
4498: oJumpForward 4541
4500: oCall 5363
4502: oJumpForward 4541
4504: oCall 5331
4506: oJumpForward 4541
4508: oCall 5395
4510: oJumpForward 4541
4512: oCall 4542
4514: oJumpForward 4541
4516: Choice Lookup Table
           0   4512
          33   4508
          49   4504
          50   4500
          47   4496
          42   4492
          46   4488
          39   4484
          58   4480
          57   4476
          56   4472
          55   4468
4541: oReturn
4542: oLocalSpace 1
4544: oGetAddrLocal 1
4546: oPushResult
4547: oScopeFindRequire
4548: oAssign
4549: oGetLocal 1
4551: oPushResult
4552: oNodeType
4553: oPop 1
4555: oChoice 4584
4557: oGetLocal 1
4559: oPushResult
4560: oCall 3996
4562: oPop 1
4564: oJumpForward 4597
4566: oGetLocal 1
4568: oPushResult
4569: oCall 4598
4571: oPop 1
4573: oJumpForward 4597
4575: oGetLocal 1
4577: oPushResult
4578: oCall 4667
4580: oPop 1
4582: oJumpForward 4597
4584: Choice Lookup Table
           8   4575
          15   4566
          13   4566
          12   4566
           7   4557
4595: oError 0
4597: oReturn
4598: oLocalSpace 1
4600: oGetParam 1
4602: oPushResult
4603: oCall 4817
4605: oPop 1
4607: oInput 3
4609: oCall 2016
4611: oCall 5498
4613: oTypeSNodeType
4614: oChoice 4632
4616: oEmit 17
4618: oJumpForward 4665
4620: oEmit 18
4622: oJumpForward 4665
4624: oError 16
4626: oJumpForward 4665
4628: oEmit 19
4630: oJumpForward 4665
4632: Choice Lookup Table
          23   4628
          17   4624
          22   4624
          21   4624
          19   4620
          18   4616
4645: oGetAddrLocal 1
4647: oPushResult
4648: oTypeSTop
4649: oPushResult
4650: oSetResult 2
4652: oPushResult
4653: oNodeGetInt
4654: oPop 2
4656: oAssign
4657: oEmit 20
4659: oGetLocal 1
4661: oPushResult
4662: oEmitInt
4663: oPop 1
4665: oTypeSPop
4666: oReturn
4667: oLocalSpace 1
4669: oGetParam 1
4671: oPushResult
4672: oSetResult 9
4674: oPushResult
4675: oNodeGet
4676: oPop 2
4678: oPushResult
4679: oScopeCurrent
4680: oPushResult
4681: oNodeEqual
4682: oPop 2
4684: oChoice 4690
4686: oError 20
4688: oJumpForward 4693
4690: Choice Lookup Table
           0   4686
4693: oEmit 8
4695: oGetParam 1
4697: oPushResult
4698: oSetResult 16
4700: oPushResult
4701: oNodeGetInt
4702: oPop 2
4704: oPushResult
4705: oEmitInt
4706: oPop 1
4708: oGetParam 1
4710: oPushResult
4711: oSetResult 5
4713: oPushResult
4714: oNodeGet
4715: oPop 2
4717: oPushResult
4718: oTypeSPush
4719: oPop 1
4721: oInput 3
4723: oCall 2016
4725: oCall 5498
4727: oTypeSNodeType
4728: oChoice 4746
4730: oEmit 17
4732: oJumpForward 4779
4734: oEmit 18
4736: oJumpForward 4779
4738: oError 16
4740: oJumpForward 4779
4742: oEmit 19
4744: oJumpForward 4779
4746: Choice Lookup Table
          23   4742
          17   4738
          22   4738
          21   4738
          19   4734
          18   4730
4759: oGetAddrLocal 1
4761: oPushResult
4762: oTypeSTop
4763: oPushResult
4764: oSetResult 2
4766: oPushResult
4767: oNodeGetInt
4768: oPop 2
4770: oAssign
4771: oEmit 20
4773: oGetLocal 1
4775: oPushResult
4776: oEmitInt
4777: oPop 1
4779: oTypeSPop
4780: oReturn
4781: oLocalSpace 1
4783: oInput 0
4785: oGetAddrLocal 1
4787: oPushResult
4788: oScopeFindRequire
4789: oAssign
4790: oGetLocal 1
4792: oPushResult
4793: oNodeType
4794: oPop 1
4796: oChoice 4800
4798: oJumpForward 4809
4800: Choice Lookup Table
          15   4798
          13   4798
          12   4798
4807: oError 4
4809: oGetLocal 1
4811: oPushResult
4812: oCall 4817
4814: oPop 1
4816: oReturn
4817: oLocalSpace 0
4819: oGetParam 1
4821: oPushResult
4822: oNodeType
4823: oPop 1
4825: oChoice 4885
4827: oEmit 10
4829: oGetParam 1
4831: oPushResult
4832: oCall 5775
4834: oPop 1
4836: oJumpForward 4894
4838: oEmit 11
4840: oGetParam 1
4842: oPushResult
4843: oCall 5775
4845: oPop 1
4847: oJumpForward 4894
4849: oGetParam 1
4851: oPushResult
4852: oSetResult 17
4854: oPushResult
4855: oNodeGetBoolean
4856: oPop 2
4858: oChoice 4871
4860: oEmit 8
4862: oGetParam 1
4864: oPushResult
4865: oCall 5775
4867: oPop 1
4869: oJumpForward 4883
4871: Choice Lookup Table
           1   4860
4874: oEmit 12
4876: oGetParam 1
4878: oPushResult
4879: oCall 5775
4881: oPop 1
4883: oJumpForward 4894
4885: Choice Lookup Table
          15   4849
          13   4838
          12   4827
4892: oError 4
4894: oGetParam 1
4896: oPushResult
4897: oSetResult 5
4899: oPushResult
4900: oNodeGet
4901: oPop 2
4903: oPushResult
4904: oTypeSPush
4905: oPop 1
4907: oCall 3688
4909: oReturn
4910: oLocalSpace 0
4912: oGetParam 1
4914: oPushResult
4915: oCall 4817
4917: oPop 1
4919: oCall 5524
4921: oGetParam 1
4923: oPushResult
4924: oCall 3274
4926: oPop 1
4928: oTypeSPop
4929: oEmit 21
4931: oEmit 17
4933: oReturn
4934: oLocalSpace 0
4936: oGetParam 1
4938: oPushResult
4939: oCall 4817
4941: oPop 1
4943: oCall 5524
4945: oGetParam 1
4947: oPushResult
4948: oCall 3274
4950: oPop 1
4952: oTypeSPop
4953: oEmit 22
4955: oEmit 17
4957: oReturn
4958: oLocalSpace 2
4960: oGetAddrLocal 1
4962: oPushResult
4963: oSetResult 0
4965: oAssign
4966: oGetAddrLocal 1
4968: oPushResult
4969: oCall 2039
4971: oPop 1
4973: oInput 40
4975: oCall 4464
4977: oInputChoice 5012
4979: oGetAddrLocal 2
4981: oPushResult
4982: oLabelNew
4983: oAssign
4984: oEmit 44
4986: oGetLocal 2
4988: oPushResult
4989: oEmitLabel
4990: oPop 1
4992: oEmit 47
4994: oGetLocal 1
4996: oPushResult
4997: oEmitLabel
4998: oPop 1
5000: oCall 4464
5002: oEmit 47
5004: oGetLocal 2
5006: oPushResult
5007: oEmitLabel
5008: oPop 1
5010: oJumpForward 5023
5012: Choice Lookup Table
          41   4979
5015: oEmit 47
5017: oGetLocal 1
5019: oPushResult
5020: oEmitLabel
5021: oPop 1
5023: oReturn
5024: oLocalSpace 4
5026: oInput 0
5028: oGetAddrLocal 1
5030: oPushResult
5031: oScopeFindRequire
5032: oAssign
5033: oGetLocal 1
5035: oPushResult
5036: oCall 4817
5038: oPop 1
5040: oCall 5524
5042: oInput 3
5044: oCall 2016
5046: oCall 5524
5048: oEmit 17
5050: oGetAddrLocal 2
5052: oPushResult
5053: oLabelNew
5054: oAssign
5055: oGetAddrLocal 3
5057: oPushResult
5058: oLabelNew
5059: oAssign
5060: oEmit 44
5062: oGetLocal 3
5064: oPushResult
5065: oEmitLabel
5066: oPop 1
5068: oGetAddrLocal 4
5070: oPushResult
5071: oLabelNew
5072: oAssign
5073: oEmit 47
5075: oGetLocal 4
5077: oPushResult
5078: oEmitLabel
5079: oPop 1
5081: oInputChoice 5161
5083: oGetLocal 1
5085: oPushResult
5086: oCall 4910
5088: oPop 1
5090: oEmit 47
5092: oGetLocal 3
5094: oPushResult
5095: oEmitLabel
5096: oPop 1
5098: oGetLocal 1
5100: oPushResult
5101: oCall 3274
5103: oPop 1
5105: oTypeSPop
5106: oCall 2016
5108: oCall 5524
5110: oEmit 32
5112: oEmit 45
5114: oGetLocal 2
5116: oPushResult
5117: oEmitLabel
5118: oPop 1
5120: oJumpForward 5167
5122: oGetLocal 1
5124: oPushResult
5125: oCall 4934
5127: oPop 1
5129: oEmit 47
5131: oGetLocal 3
5133: oPushResult
5134: oEmitLabel
5135: oPop 1
5137: oGetLocal 1
5139: oPushResult
5140: oCall 3274
5142: oPop 1
5144: oTypeSPop
5145: oCall 2016
5147: oCall 5524
5149: oEmit 33
5151: oEmit 45
5153: oGetLocal 2
5155: oPushResult
5156: oEmitLabel
5157: oPop 1
5159: oJumpForward 5167
5161: Choice Lookup Table
          44   5122
          43   5083
5166: oEndChoice
5167: oGetLocal 4
5169: oPushResult
5170: oGetLocal 2
5172: oPushResult
5173: oLoopPush
5174: oPop 2
5176: oInput 45
5178: oCall 4464
5180: oEmit 44
5182: oGetLocal 4
5184: oPushResult
5185: oEmitLabel
5186: oPop 1
5188: oEmit 47
5190: oGetLocal 2
5192: oPushResult
5193: oEmitLabel
5194: oPop 1
5196: oLoopPop
5197: oReturn
5198: oLocalSpace 3
5200: oGetAddrLocal 1
5202: oPushResult
5203: oLabelNew
5204: oAssign
5205: oEmit 47
5207: oGetLocal 1
5209: oPushResult
5210: oEmitLabel
5211: oPop 1
5213: oGetAddrLocal 2
5215: oPushResult
5216: oLabelNew
5217: oAssign
5218: oGetLocal 1
5220: oPushResult
5221: oGetLocal 2
5223: oPushResult
5224: oLoopPush
5225: oPop 2
5227: oCall 4464
5229: oInputChoice 5260
5231: oCall 4464
5233: oJumpForward 5266
5235: oGetAddrLocal 3
5237: oPushResult
5238: oCall 2039
5240: oPop 1
5242: oEmit 48
5244: oGetLocal 3
5246: oPushResult
5247: oEmitLabel
5248: oPop 1
5250: oGetLocal 1
5252: oPushResult
5253: oEmitLabel
5254: oPop 1
5256: oJumpForward 5268
5258: oJumpForward 5266
5260: Choice Lookup Table
          48   5235
           4   5231
5265: oEndChoice
5266: oJumpBack 5229
5268: oEmit 47
5270: oGetLocal 2
5272: oPushResult
5273: oEmitLabel
5274: oPop 1
5276: oLoopPop
5277: oReturn
5278: oLocalSpace 2
5280: oGetAddrLocal 1
5282: oPushResult
5283: oLabelNew
5284: oAssign
5285: oEmit 47
5287: oGetLocal 1
5289: oPushResult
5290: oEmitLabel
5291: oPop 1
5293: oGetAddrLocal 2
5295: oPushResult
5296: oCall 2039
5298: oPop 1
5300: oGetLocal 1
5302: oPushResult
5303: oGetLocal 2
5305: oPushResult
5306: oLoopPush
5307: oPop 2
5309: oInput 45
5311: oCall 4464
5313: oEmit 44
5315: oGetLocal 1
5317: oPushResult
5318: oEmitLabel
5319: oPop 1
5321: oEmit 47
5323: oGetLocal 2
5325: oPushResult
5326: oEmitLabel
5327: oPop 1
5329: oLoopPop
5330: oReturn
5331: oLocalSpace 0
5333: oLoopContinueLabel
5334: oPushResult
5335: oSetResult 0
5337: oPushResult
5338: equal_label
5339: oPop 2
5341: oChoice 5356
5343: oError 18
5345: oJumpForward 5362
5347: oEmit 44
5349: oLoopContinueLabel
5350: oPushResult
5351: oEmitLabel
5352: oPop 1
5354: oJumpForward 5362
5356: Choice Lookup Table
           0   5347
           1   5343
5361: oEndChoice
5362: oReturn
5363: oLocalSpace 0
5365: oLoopBreakLabel
5366: oPushResult
5367: oSetResult 0
5369: oPushResult
5370: equal_label
5371: oPop 2
5373: oChoice 5388
5375: oError 18
5377: oJumpForward 5394
5379: oEmit 44
5381: oLoopBreakLabel
5382: oPushResult
5383: oEmitLabel
5384: oPop 1
5386: oJumpForward 5394
5388: Choice Lookup Table
           0   5379
           1   5375
5393: oEndChoice
5394: oReturn
5395: oLocalSpace 0
5397: oCall 4464
5399: oInputChoice 5409
5401: oCall 4464
5403: oJumpForward 5415
5405: oJumpForward 5417
5407: oJumpForward 5415
5409: Choice Lookup Table
          34   5405
           4   5401
5414: oEndChoice
5415: oJumpBack 5399
5417: oReturn
5418: oLocalSpace 0
5420: oCall 5425
5422: oEmit 54
5424: oReturn
5425: oLocalSpace 0
5427: oInputChoice 5488
5429: oCall 2016
5431: oTypeSNodeType
5432: oChoice 5454
5434: oEmit 50
5436: oJumpForward 5469
5438: oEmit 51
5440: oJumpForward 5469
5442: oEmit 52
5444: oJumpForward 5469
5446: oError 16
5448: oJumpForward 5469
5450: oEmit 53
5452: oJumpForward 5469
5454: Choice Lookup Table
          23   5450
          17   5446
          21   5446
          22   5442
          19   5438
          18   5434
5467: oError 17
5469: oTypeSPop
5470: oInputChoice 5478
5472: oJumpForward 5486
5474: oJumpForward 5484
5476: oJumpForward 5484
5478: Choice Lookup Table
          12   5476
          14   5472
5483: oEndChoice
5484: oJumpBack 5429
5486: oJumpForward 5491
5488: Choice Lookup Table
          13   5429
5491: oReturn
5492: oLocalSpace 0
5494: oReturn
5495: oLocalSpace 0
5497: oReturn
5498: oLocalSpace 1
5500: oGetAddrLocal 1
5502: oPushResult
5503: oTypeSNodeType
5504: oAssign
5505: oTypeSPop
5506: oGetLocal 1
5508: oPushResult
5509: oTypeSNodeType
5510: oPushResult
5511: equal_node_type
5512: oPop 2
5514: oChoice 5520
5516: oError 14
5518: oJumpForward 5523
5520: Choice Lookup Table
           0   5516
5523: oReturn
5524: oLocalSpace 0
5526: oTypeSNodeType
5527: oChoice 5531
5529: oJumpForward 5536
5531: Choice Lookup Table
          18   5529
5534: oError 7
5536: oTypeSPop
5537: oReturn
5538: oLocalSpace 0
5540: oTypeSNodeType
5541: oChoice 5545
5543: oJumpForward 5550
5545: Choice Lookup Table
          18   5543
5548: oError 7
5550: oReturn
5551: oLocalSpace 0
5553: oTypeSNodeType
5554: oChoice 5558
5556: oJumpForward 5563
5558: Choice Lookup Table
          19   5556
5561: oError 8
5563: oTypeSPop
5564: oReturn
5565: oLocalSpace 0
5567: oTypeSNodeType
5568: oChoice 5572
5570: oJumpForward 5577
5572: Choice Lookup Table
          19   5570
5575: oError 8
5577: oReturn
5578: oLocalSpace 1
5580: oGetAddrLocal 1
5582: oPushResult
5583: oGetParam 2
5585: oPushResult
5586: oNodeNew
5587: oPop 1
5589: oAssign
5590: oGetLocal 1
5592: oPushResult
5593: oSetResult 2
5595: oPushResult
5596: oGetParam 1
5598: oPushResult
5599: oNodeSetInt
5600: oPop 3
5602: oGetLocal 1
5604: oPushResult
5605: oTypeAdd
5606: oPop 1
5608: oGetLocal 1
5610: oReturn
5611: oReturn
5612: oLocalSpace 1
5614: oGetAddrLocal 1
5616: oPushResult
5617: oGetParam 3
5619: oPushResult
5620: oNodeNew
5621: oPop 1
5623: oAssign
5624: oGetLocal 1
5626: oPushResult
5627: oSetResult 4
5629: oPushResult
5630: oGetParam 1
5632: oPushResult
5633: oNodeSetInt
5634: oPop 3
5636: oGetLocal 1
5638: oReturn
5639: oReturn
5640: oLocalSpace 1
5642: oGetAddrLocal 1
5644: oPushResult
5645: oGetParam 1
5647: oPushResult
5648: oSetResult 18
5650: oPushResult
5651: oNodeGet
5652: oPop 2
5654: oAssign
5655: oGetLocal 1
5657: oPushResult
5658: oNodeNull
5659: oPop 1
5661: oChoice 5717
5663: oGetAddrLocal 1
5665: oPushResult
5666: oSetResult 23
5668: oPushResult
5669: oNodeNew
5670: oPop 1
5672: oAssign
5673: oGetLocal 1
5675: oPushResult
5676: oSetResult 19
5678: oPushResult
5679: oGetParam 1
5681: oPushResult
5682: oNodeSet
5683: oPop 3
5685: oGetLocal 1
5687: oPushResult
5688: oSetResult 2
5690: oPushResult
5691: oSetResult 8
5693: oPushResult
5694: oNodeSetInt
5695: oPop 3
5697: oGetLocal 1
5699: oPushResult
5700: oTypeAdd
5701: oPop 1
5703: oGetParam 1
5705: oPushResult
5706: oSetResult 18
5708: oPushResult
5709: oGetLocal 1
5711: oPushResult
5712: oNodeSet
5713: oPop 3
5715: oJumpForward 5720
5717: Choice Lookup Table
           1   5663
5720: oGetLocal 1
5722: oReturn
5723: oReturn
5724: oLocalSpace 0
5726: oGetParam 1
5728: oPushResult
5729: oNodeType
5730: oPop 1
5732: oChoice 5760
5734: oMININT
5735: oReturn
5736: oJumpForward 5774
5738: oSetResult 0
5740: oReturn
5741: oJumpForward 5774
5743: oSetResult 0
5745: oReturn
5746: oJumpForward 5774
5748: oGetParam 1
5750: oPushResult
5751: oSetResult 21
5753: oPushResult
5754: oNodeGetInt
5755: oPop 2
5757: oReturn
5758: oJumpForward 5774
5760: Choice Lookup Table
          25   5748
          21   5743
          19   5738
          18   5734
5769: oError 3
5771: oSetResult 0
5773: oReturn
5774: oReturn
5775: oLocalSpace 0
5777: oGetParam 1
5779: oPushResult
5780: oSetResult 6
5782: oPushResult
5783: oNodeGetInt
5784: oPop 2
5786: oPushResult
5787: oEmitInt
5788: oPop 1
5790: oReturn
5791: oLocalSpace 1
5793: oGetAddrGlobal 2
5795: oPushResult
5796: oSetResult 17
5798: oPushResult
5799: oSetResult 4
5801: oPushResult
5802: oCall 5578
5804: oPop 2
5806: oAssign
5807: oGetAddrGlobal 3
5809: oPushResult
5810: oSetResult 18
5812: oPushResult
5813: oSetResult 4
5815: oPushResult
5816: oCall 5578
5818: oPop 2
5820: oAssign
5821: oGetAddrGlobal 4
5823: oPushResult
5824: oSetResult 19
5826: oPushResult
5827: oSetResult 1
5829: oPushResult
5830: oCall 5578
5832: oPop 2
5834: oAssign
5835: oGetAddrGlobal 5
5837: oPushResult
5838: oSetResult 20
5840: oPushResult
5841: oSetResult 1
5843: oPushResult
5844: oCall 5578
5846: oPop 2
5848: oAssign
5849: oGetAddrGlobal 6
5851: oPushResult
5852: oSetResult 21
5854: oPushResult
5855: oSetResult 1
5857: oPushResult
5858: oCall 5578
5860: oPop 2
5862: oAssign
5863: oGetAddrGlobal 7
5865: oPushResult
5866: oSetResult 22
5868: oPushResult
5869: oSetResult 256
5871: oPushResult
5872: oCall 5578
5874: oPop 2
5876: oAssign
5877: oGetAddrLocal 1
5879: oPushResult
5880: oSetResult 10
5882: oPushResult
5883: oSetResult 5
5885: oPushResult
5886: oIdAdd_File
5887: oPushResult
5888: oCall 5612
5890: oPop 3
5892: oAssign
5893: oGetLocal 1
5895: oPushResult
5896: oSetResult 5
5898: oPushResult
5899: oGetGlobal 2
5901: oPushResult
5902: oNodeSet
5903: oPop 3
5905: oGetLocal 1
5907: oPushResult
5908: oScopeDeclare
5909: oPop 1
5911: oGetAddrLocal 1
5913: oPushResult
5914: oSetResult 10
5916: oPushResult
5917: oSetResult 5
5919: oPushResult
5920: oIdAdd_Integer
5921: oPushResult
5922: oCall 5612
5924: oPop 3
5926: oAssign
5927: oGetLocal 1
5929: oPushResult
5930: oSetResult 5
5932: oPushResult
5933: oGetGlobal 3
5935: oPushResult
5936: oNodeSet
5937: oPop 3
5939: oGetLocal 1
5941: oPushResult
5942: oScopeDeclare
5943: oPop 1
5945: oGetAddrLocal 1
5947: oPushResult
5948: oSetResult 10
5950: oPushResult
5951: oSetResult 5
5953: oPushResult
5954: oIdAdd_Boolean
5955: oPushResult
5956: oCall 5612
5958: oPop 3
5960: oAssign
5961: oGetLocal 1
5963: oPushResult
5964: oSetResult 5
5966: oPushResult
5967: oGetGlobal 4
5969: oPushResult
5970: oNodeSet
5971: oPop 3
5973: oGetLocal 1
5975: oPushResult
5976: oScopeDeclare
5977: oPop 1
5979: oGetAddrLocal 1
5981: oPushResult
5982: oSetResult 10
5984: oPushResult
5985: oSetResult 5
5987: oPushResult
5988: oIdAdd_Char
5989: oPushResult
5990: oCall 5612
5992: oPop 3
5994: oAssign
5995: oGetLocal 1
5997: oPushResult
5998: oSetResult 5
6000: oPushResult
6001: oGetGlobal 6
6003: oPushResult
6004: oNodeSet
6005: oPop 3
6007: oGetLocal 1
6009: oPushResult
6010: oScopeDeclare
6011: oPop 1
6013: oGetAddrLocal 1
6015: oPushResult
6016: oSetResult 10
6018: oPushResult
6019: oSetResult 5
6021: oPushResult
6022: oIdAdd_String
6023: oPushResult
6024: oCall 5612
6026: oPop 3
6028: oAssign
6029: oGetLocal 1
6031: oPushResult
6032: oSetResult 5
6034: oPushResult
6035: oGetGlobal 7
6037: oPushResult
6038: oNodeSet
6039: oPop 3
6041: oGetLocal 1
6043: oPushResult
6044: oScopeDeclare
6045: oPop 1
6047: oGetAddrLocal 1
6049: oPushResult
6050: oSetResult 9
6052: oPushResult
6053: oSetResult 4
6055: oPushResult
6056: oIdAdd_True
6057: oPushResult
6058: oCall 5612
6060: oPop 3
6062: oAssign
6063: oGetLocal 1
6065: oPushResult
6066: oSetResult 5
6068: oPushResult
6069: oGetGlobal 4
6071: oPushResult
6072: oNodeSet
6073: oPop 3
6075: oGetLocal 1
6077: oPushResult
6078: oSetResult 6
6080: oPushResult
6081: oSetResult 1
6083: oPushResult
6084: oNodeSetInt
6085: oPop 3
6087: oGetLocal 1
6089: oPushResult
6090: oScopeDeclare
6091: oPop 1
6093: oGetAddrLocal 1
6095: oPushResult
6096: oSetResult 9
6098: oPushResult
6099: oSetResult 4
6101: oPushResult
6102: oIdAdd_False
6103: oPushResult
6104: oCall 5612
6106: oPop 3
6108: oAssign
6109: oGetLocal 1
6111: oPushResult
6112: oSetResult 5
6114: oPushResult
6115: oGetGlobal 4
6117: oPushResult
6118: oNodeSet
6119: oPop 3
6121: oGetLocal 1
6123: oPushResult
6124: oSetResult 6
6126: oPushResult
6127: oSetResult 0
6129: oPushResult
6130: oNodeSetInt
6131: oPop 3
6133: oGetLocal 1
6135: oPushResult
6136: oScopeDeclare
6137: oPop 1
6139: oReturn
