   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label cycleLabel, Label exitLabel )
   2:    oLoopCycleLabel >> Label
   2:    oLoopExitLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node progDecl
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel
  12:    mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]};
      
      
 242: BlockStmt( Label labelForBody ):
 244:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 252:    int patchLS
 252:    .tEnter  patchLS = Here  .tSpace
      
 261:    @Statement
 263:    .tReturn
      
 265:    int localSpace
 265:    localSpace = oNodeGetInt( oScopeCurrent, qSize )
 277:    oPatch( patchLS, localSpace )
 287:    ;
      
      
      
 287: ProcDecl:
 289:    Node decl
      
 289:    pIdent
 291:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 307:    oScopeBegin
 308:    Node paramScope
 308:    paramScope = oScopeCurrent
      
 313:    @FormalArgDecl
 315:    oNodeSet( decl, qParams, paramScope )
 327:    oScopeEnd
      
 328:    oScopeDeclare( decl )
 334:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 336:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 342:    oScopeBegin
 343:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 354:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 365:    Label label
 365:    label = oLabelNew
 370:    @Block( nLocalVar, label )
 380:    oNodeSetLabel( decl, qValue, label )
 392:    oNodeSetBoolean( decl, qAddrDefined, true )
 404:    oScopeEnd
      
 405:    oScopeEnd  % paramScope
 406:    ';';
      
 409: FuncDecl:
 411:    Node decl
 411:    Node theType
      
 411:    pIdent
 413:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 429:    oScopeBegin
 430:    Node paramScope
 430:    paramScope = oScopeCurrent
      
 435:    @FormalArgDecl
 437:    oNodeSet( decl, qParams, paramScope )
      
 449:    ':'
      
 451:    @TypeRef( theType )
 458:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 470:    Node ptrType
 470:    ptrType = @PointerTypeTo( theType )
 481:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
      
 497:    ';'
      
 499:    oScopeEnd
 500:    oScopeDeclare( decl )
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 506:    oScopeEnter( paramScope )
      
 512:    oScopeBegin
 513:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 524:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 535:    Label label
 535:    label = oLabelNew
 540:    @Block( nLocalVar, label )
 550:    oNodeSetLabel( decl, qValue, label )
 562:    oNodeSetBoolean( decl, qAddrDefined, true )
 574:    oScopeEnd
      
 575:    oScopeEnd  % paramScope
 576:    ';';
      
      
 579: FormalArgDecl:
 581:    [
 581:       | '(' :
 583:          {
 583:             NodeVec decls
 583:             decls = oNodeVecNew
 588:             Node decl
 588:             boolean isInOut
 588:             isInOut = false
      
 594:             [
 594:                | pVar : isInOut = true
 602:                | * :
 607:             ]
      
 607:             {  pIdent
      
 609:                decl = @newIdent( nParam, kVar, LAST_ID )
 625:                oNodeSetBoolean( decl, qInOut, isInOut )
 637:                oNodeVecAppend( decls, decl )
      
 646:                [
 646:                   | ':' : >
 650:                   | ',' :
 652:                ]
 660:             }
      
 662:             Node theType
 662:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 669:             Node allocType
 669:             [ isInOut
 672:                | true :   allocType = @PointerTypeTo( theType )
 684:                | * :      allocType = theType
 695:             ]
      
 695:             int i
 695:             i = 0
 701:             {[ equal( i, oNodeVecSize( decls ) )
 715:                | false :
 716:                   decl = oNodeVecElement( decls, i )
      
 729:                   oNodeSet( decl, qType, theType )
 741:                   oScopeDeclare( decl )
 747:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 763:                   inc( i )
 769:                | * :
 774:                   >
 776:             ]}
      
 778:             oNodeVecDelete( decls )
      
 784:             [
 784:                | ')' : >
 788:                | ';' :
 790:             ]
 798:          }
 800:       | * :
 805:    ];
      
 806: ConstDecl:
 808:    {[
 808:       | pIdent :
 810:          Node decl
 810:          decl = @newIdent( nConst, kConst, LAST_ID )
 826:          '='
      
 828:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 830:          int val
 830:          val = oValueTop
 835:          oValuePop
 836:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 848:          oNodeSet( decl, qType, IntegerType )
      
 860:          oScopeDeclare( decl )
 866:          ';'
 868:       | * :
 873:          >
 875:    ]};
      
 878: TypeDecl:
 880:    {[
 880:       | pIdent :
 882:          Node decl
 882:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 898:          '='
 900:          Node theType
 900:          @TypeRef( theType )
 907:          oNodeSet( decl, qType, theType )
 919:          oScopeDeclare( decl )
 925:          ';'
 927:       | * :
 932:          >
 934:    ]};
      
 937: VarDecl( node_type varNodeType ):
 939:    {[
 939:       | pIdent :
 941:          NodeVec decls
 941:          decls = oNodeVecNew
 946:          Node decl
 946:          {
 946:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 962:             oNodeVecAppend( decls, decl )
 971:             [
 971:                | ',' :
 973:                   pIdent
 975:                | * :
 980:                   >
 982:             ]
 982:          }
 984:          ':'
 986:          Node theType
 986:          @TypeRef( theType )
      
 993:          int i
 993:          i = 0
 999:          {[ equal( i, oNodeVecSize( decls ) )
1013:            | false :
1014:              decl = oNodeVecElement( decls, i )
1027:              oNodeSet( decl, qType, theType )
1039:              oScopeDeclareAlloc( decl )
1045:              inc( i )
1051:             | * :
1056:               >
1058:          ]}
      
1060:          oNodeVecDelete( decls )
1066:          ';'
1068:       | * :
1073:          >
1075:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1078: TypeRef( out Node resultType ):
1080:    [
1080:       | pIdent :           % previously named type (including intrinsics)
1082:          Node decl
1082:          decl = oScopeFindRequire
1087:          [ oNodeType( decl )
1094:            | nTypeDecl :
1095:                resultType = oNodeGet( decl, qType )
1108:            | * :
1113:                #eNotType
1115:                resultType = IntegerType
1121:          ]
         
1121:       | pArray :
1123:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1125:          NodeVec dimensions
1125:          dimensions = oNodeVecNew
      
1130:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1130:             Node subrange
1130:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1140:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1152:             @ConstExpr
1154:             oNodeSetInt( subrange, qLow, oValueTop )
1165:             oValuePop
1166:             '..'
1168:             @ConstExpr
1170:             oNodeSetInt( subrange, qHigh, oValueTop )
1181:             oValuePop
1182:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1194:             oTypeAdd( subrange )
      
1200:             Node a
1200:             a = oNodeNew( nArrayType )
1210:             oNodeSet( a, qIndexType, subrange )
      
1222:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1231:             [
1231:                | ']' : >
1235:                | ',' :
1237:             ]
1245:          }
1247:          pOf
1249:          Node baseType
1249:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1256:          int dim
1256:          dim = oNodeVecSize( dimensions )
1266:          {
1266:              dec(dim)
      
1272:              Node a
1272:              a = oNodeVecElement( dimensions, dim )
1285:              oNodeSet( a, qBaseType, baseType )
1297:              Node subrange
1297:              subrange = oNodeGet( a, qIndexType )
1310:              int width
1310:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1337:              inc( width )
1343:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1369:              oTypeAdd( a )
1375:              baseType = a
      
1381:              [ equal_zero(dim)
1388:                  | true:  >
1391:                  | *:
1396:              ]
1396:          }
      
1398:          resultType = oNodeVecElement( dimensions, 0 )
1411:          oNodeVecDelete( dimensions )
      
1417:       | '^' :
1419:          Node theType
1419:          @TypeRef( theType )
1426:          resultType = @PointerTypeTo( theType )
      
1437:       | pRecord :
1439:          resultType = oNodeNew( nRecordType )
1449:          oScopeBegin
      
1450:          @VarDecl( nRecordField )
      
1457:          int size
1457:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1469:          [ equal_zero( size )
1476:             | true : #eRecordEmpty
1479:             | * :
1484:          ]
      
1484:          pEnd
      
1486:          oNodeSet( resultType, qScope, oScopeCurrent )
1497:          oNodeSetInt( resultType, qSize, size )
1509:          oScopeEnd
1510:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1516:       | pSet :
1518:          pOf
1520:          Node theType
1520:          @TypeRef( theType )
1527:       | * :       % this works for cases except where expr starts with an id
1540:          @ConstExpr '..' @ConstExpr
1546:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1547: ConstExpr:
1549:    [
1549:       | pIntLit :
1551:          oValuePush( TOKEN_VALUE )
1556:       | pIdent :
1558:          Node decl
1558:          decl = oScopeFindRequire
1563:          [ oNodeType( decl )
1570:             | nConst :
1571:                oValuePush( oNodeGetInt( decl, qValue ) )
1584:             | * :
1589:                #eNotConst
1591:                oValuePush( 0 )
1597:          ]
1597:       | pMinus :
1599:          @ConstExpr
1601:          oValueNegate
1602:    ];
      
      
      
      
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
1613: Expr:
1615:    Label falseLabel
1615:    falseLabel = labelNull
      
1621:    @ExprAllowCF( falseLabel )
1628:    @CFToVal( falseLabel );
      
      
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
1636: BooleanExprControlFlow( out Label falseLabel ):
1638:    @ExprAllowCF( falseLabel )
1645:    [ oTypeSNodeType
1647:       | nBooleanCFType :
1648:       | nBooleanType :
               % convert value to control flow
1650:          falseLabel = oLabelNew
1655:          .tJumpFalse  oEmitLabel( falseLabel )
1663:       | * :
1670:          #eNotBoolean
1672:    ]
1672:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
1674: CFToVal( inout Label falseLabel ):
1676:    [ oTypeSNodeType
1678:       | nBooleanCFType :
1679:          Label doneLabel
1679:          doneLabel = oLabelNew
1684:          .tPushConstI  oEmitInt( 1 )
1692:          .tJump  oEmitLabel( doneLabel )
1700:          .tLabel  oEmitLabel( falseLabel )
1708:          .tPushConstI  oEmitInt( 0 )
1716:          .tLabel  oEmitLabel( doneLabel )
1724:          oTypeSPop
1725:          oTypeSPush( BooleanType )
1731:          falseLabel = labelNull
1737:       | * :
1742:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
1743: ValToCF( out Label falseLabel ):
1745:    [ oTypeSNodeType
1747:       | nBooleanType :
1748:          falseLabel = oLabelNew
1753:          .tJumpFalse  oEmitLabel( falseLabel )
1761:          oTypeSPop
1762:          oTypeSPush( BooleanCFType )
1768:       | * :
1773:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
1774: ExprAllowCF( out Label falseLabel ):
1776:    @BoolExprAllowCF( falseLabel )
1783:    {[
1783:       | '=' :
1785:          @CFToVal( falseLabel )
1792:          @BoolExprAllowCF( falseLabel )
1799:          @CFToVal( falseLabel )
1806:          @MatchTypes
1808:          [ oTypeSNodeType
1810:             | nIntegerType, nBooleanType :  .tEqualI
1813:             | nPointerType :                .tEqualP
1817:             | nCharType, nStringType :      #eNotImplemented
1821:             | * :                           #eNotAllowed
1836:          ]
1836:          oTypeSPop
1837:          oTypeSPush( BooleanType )
      
1843:       | '<>' :
1845:          @CFToVal( falseLabel )
1852:          @BoolExprAllowCF( falseLabel )
1859:          @CFToVal( falseLabel )
1866:          @MatchTypes
1868:          [ oTypeSNodeType
1870:             | nIntegerType, nBooleanType :  .tNotEqualI
1873:             | nPointerType :                .tNotEqualP
1877:             | nCharType, nStringType :      #eNotImplemented
1881:             | * :                           #eNotAllowed
1896:          ]
1896:          oTypeSPop
1897:          oTypeSPush( BooleanType )
      
1903:       | '<' :
1905:          @CFToVal( falseLabel )
1912:          @BoolExprAllowCF( falseLabel )
1919:          @CFToVal( falseLabel )
1926:          @MatchTypes
1928:          [ oTypeSNodeType
1930:             | nIntegerType, nBooleanType :  .tLessI
1933:             | nCharType, nStringType :      #eNotImplemented
1937:             | * :                           #eNotAllowed
1950:          ]
1950:          oTypeSPop
1951:          oTypeSPush( BooleanType )
      
1957:       | '>' :
1959:          @CFToVal( falseLabel )
1966:          @BoolExprAllowCF( falseLabel )
1973:          @CFToVal( falseLabel )
1980:          @MatchTypes
1982:          [ oTypeSNodeType
1984:             | nIntegerType, nBooleanType :  .tGreaterI
1987:             | nCharType, nStringType :      #eNotImplemented
1991:             | * :                           #eNotAllowed
2004:          ]
2004:          oTypeSPop
2005:          oTypeSPush( BooleanType )
      
2011:       | '<=' :
2013:          @CFToVal( falseLabel )
2020:          @BoolExprAllowCF( falseLabel )
2027:          @CFToVal( falseLabel )
2034:          @MatchTypes
2036:          [ oTypeSNodeType
2038:             | nIntegerType, nBooleanType :  .tLessEqualI
2041:             | nCharType, nStringType :      #eNotImplemented
2045:             | * :                           #eNotAllowed
2058:          ]
2058:          oTypeSPop
2059:          oTypeSPush( BooleanType )
      
2065:       | '>=' :
2067:          @CFToVal( falseLabel )
2074:          @BoolExprAllowCF( falseLabel )
2081:          @CFToVal( falseLabel )
2088:          @MatchTypes
2090:          [ oTypeSNodeType
2092:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2095:             | nCharType, nStringType :      #eNotImplemented
2099:             | * :                           #eNotAllowed
2112:          ]
2112:          oTypeSPop
2113:          oTypeSPush( BooleanType )
      
2119:       | * :
2134:          >
2136:    ]};
      
      
2139: BoolExprAllowCF( out Label falseLabel ):
2141:    Label trueLabel
2141:    trueLabel = labelNull
      
2147:    @BoolTermAllowCF( falseLabel )
2154:    {[
2154:       | pOr :
2156:          [ oTypeSNodeType
2158:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2159:                [ equal_label( trueLabel, labelNull )
2169:                   | true :  trueLabel = oLabelNew
2175:                   | * :
2180:                ]
2180:                .tJump  oEmitLabel( trueLabel )
2188:             | nBooleanType :
2190:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2197:                [ equal_label( trueLabel, labelNull )
2207:                   | true :  trueLabel = oLabelNew
2213:                   | * :
2218:                ]
2218:                .tJumpTrue  oEmitLabel( trueLabel )
2226:             | * : #eNotBoolean
2235:          ]
2235:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2236:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2244:          falseLabel = labelNull
2250:          @BoolTermAllowCF( falseLabel )
      
2257:          [ oTypeSNodeType
2259:             | nBooleanCFType :
2260:             | nBooleanType :
2262:                @ValToCF( falseLabel )
2269:             | * : #eNotBoolean
2278:          ]
      
2278:          oTypeSPop
2279:          oTypeSPush( BooleanCFType )
      
2285:       | * :
2290:          >
2292:    ]}
      
         % any short-circuit trues jump here to the end
2294:    [ equal_label( trueLabel, labelNull )
2304:       | false :
2305:          .tLabel  oEmitLabel( trueLabel )
2313:       | * :
2318:    ]
2319:    ;
      
      
2319: BoolTermAllowCF( out Label falseLabel ):
2321:    Label overallFalseLabel
2321:    overallFalseLabel = labelNull
      
2327:    @BoolFactorAllowCF( falseLabel )
2334:    {[
2334:       | pAnd :
2336:          [ oTypeSNodeType
2338:             | nBooleanCFType :
2339:             | nBooleanType :
2341:                @ValToCF( falseLabel )
2348:             | * :
2355:                #eNotBoolean
2357:          ]
2357:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2358:          [ equal_label( overallFalseLabel, labelNull )
2368:             | true :
2369:                overallFalseLabel = oLabelNew
2374:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2388:                falseLabel = overallFalseLabel
2394:             | * :
2399:          ]
      
2399:          Label factorFalseLabel
2399:          factorFalseLabel = labelNull
2405:          @BoolFactorAllowCF( factorFalseLabel )
      
2412:          [ oTypeSNodeType
2414:             | nBooleanCFType :
2415:             | nBooleanType :
2417:                @ValToCF( factorFalseLabel )
2424:             | * : #eNotBoolean
2433:          ]
2433:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2447:       | * :
2452:          >
2454:    ]};
      
2457: BoolFactorAllowCF( out Label falseLabel ):
2459:    [
2459:       | pNot :
2461:          Label factorFalseLabel
2461:          factorFalseLabel = labelNull
      
2467:          @BoolFactorAllowCF( factorFalseLabel )
2474:          [ oTypeSNodeType
2476:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2477:                falseLabel = oLabelNew
2482:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2490:                .tLabel  oEmitLabel( factorFalseLabel )
      
2498:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2500:                .tNot
      
2502:             | * : #eNotBoolean
2511:          ]
      
2511:       | * :
               % TO DO: I'll want to add "AllowCF" for the lower stuff too,
               % so the Primary ( expr ) gets it.
2516:          @ArithExpr
2518:    ];
      
2519: ArithExpr:
2521:    @Term
2523:    {[
2523:       | pPlus :
2525:          @RequireIntPop
2527:          @Term
2529:          @RequireInt
2531:          .tAddI
2533:       | pMinus :
2535:          @RequireIntPop
2537:          @Term
2539:          @RequireInt
2541:          .tSubI
2543:       | * :
2550:          >
2552:    ]};
      
2555: Term:
2557:    @Factor
2559:    {[
2559:       | pTimes :
2561:          @RequireIntPop
2563:          @Factor
2565:          @RequireInt
2567:          .tMultI
2569:       | pDivide :
2571:          @RequireIntPop
2573:          @Factor
2575:          @RequireInt
2577:          .tDivI
2579:       | * :
2586:          >
2588:    ]};
      
2591: Factor:
2593:    [
2593:       | pPlus :
2595:          @Primary
2597:          @RequireInt
2599:       | pMinus :
2601:          @Primary
2603:          @RequireInt
2605:          .tNegI
2607:       | * :
2614:          @Primary
2616:    ];
      
2617: Primary:
2619:    [
2619:       | pIntLit :
2621:          .tPushConstI  oEmitInt( TOKEN_VALUE )
2628:          oTypeSPush( IntegerType )
      
2634:       | '(' :
2636:          @Expr
2638:          ')'
      
2640:       | pStrLit :
2642:          oStringAllocLit     % store in global data, push offset on value stack
2643:          .tPushAddrGlobal oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2651:          oTypeSPush( StringType )
      
2657:       | pIdent :
2659:          Node decl
2659:          Node theType
2659:          decl = oScopeFindRequire
      
2664:          [ oNodeType( decl )
2671:             | nFunc :
      
2672:                @Call( decl )
      
2679:             | nConst :
2681:                theType = oNodeGet( decl, qType )
2694:                oTypeSPush( theType )
2700:                [ oTypeSNodeType
2702:                   | nIntegerType, nBooleanType :
2703:                      .tPushConstI @EmitValue( decl )
2712:                   | * :
2719:                      #eNotImplemented
2721:                ]
      
2721:             | nGlobalVar, nLocalVar, nParam :
2723:                @VarExpr( decl )
      
2730:             | * :
2743:                #eNotValue
2745:                oTypeSPush( IntegerType )
2751:          ]
      
2751:       | '@' :        % @var -- pointer to var
2753:          pIdent
      
2755:          Node decl
2755:          Node theType
2755:          decl = oScopeFindRequire
      
2760:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2767:          theType = oTypeSTop
2772:          oTypeSPop
2773:          Node ptrType
2773:          ptrType = @PointerTypeTo( theType )
2784:          oTypeSPush( ptrType )
      
2790:       | * :
2803:          #eNotValue
2805:          oTypeSPush( IntegerType )
2811:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2812: VarExpr( Node decl ):
2814:    Node theType
2814:    theType = oNodeGet( decl, qType )
2827:    oTypeSPush( theType )
2833:    [ oTypeSNodeType
2835:       | nIntegerType :
2836:          [ oNodeType( decl )
2843:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2853:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2864:             | nParam :
2866:                [ oNodeGetBoolean( decl, qInOut )
2876:                   | true :    % VAR param points to the var.  Auto dereference.
2877:                               .tPushParamP @EmitValue( decl )
2886:                               .tFetchI
2888:                   | * :       .tPushParamI @EmitValue( decl )
2902:                ]
2902:          ]
      
2912:       | nBooleanType :
2914:          [ oNodeType( decl )
2921:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2931:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2942:             | nParam :
2944:                [ oNodeGetBoolean( decl, qInOut )
2954:                   | true :    % VAR param points to the var.  Auto derefernce.
2955:                               .tPushParamP @EmitValue( decl )
2964:                               .tFetchB
2966:                   | * :       .tPushParamB @EmitValue( decl )
2980:                ]
2980:          ]
      
2990:       | nCharType, nStringType, nFileType :
2992:          #eNotImplemented
      
2994:       | nPointerType :
2996:          [ oNodeType( decl )
3003:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3013:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3024:             | nParam :
3026:                [ oNodeGetBoolean( decl, qInOut )
3036:                   | true :    % VAR param points to the var.  Auto derefernce.
3037:                               .tPushParamP @EmitValue( decl )
3046:                               .tFetchP
3048:                   | * :       .tPushParamP @EmitValue( decl )
3062:                ]
3062:          ]
3072:          [
3072:             | '^' :             % dereferenced
3074:                oTypeSPop
3075:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3088:                @LValueIndexes
3090:                @FetchVar
3092:             | * :               % just ptr value alone
3097:          ]
      
3097:       | * :
               % compound type
               % first, push addr of start of var
3112:          [ oNodeType( decl )
3119:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3129:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3140:             | nParam :
3142:                [ oNodeGetBoolean( decl, qInOut )
3152:                   | true :    % VAR param points to the var.  Auto derefernce.
3153:                               .tPushParamP @EmitValue( decl )
3162:                   | * :       .tPushAddrParam @EmitValue( decl )
3176:                ]
3176:          ]
               % modify addr for subscripts, field references, etc
3186:          @LValueIndexes
               % get final value
3188:          @FetchVar
3190:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3191: FetchVar:
3193:    [ oTypeSNodeType
3195:       | nIntegerType :   .tFetchI
3198:       | nBooleanType :   .tFetchB
3202:       | nCharType, nStringType, nFileType : #eNotImplemented
3206:       | nPointerType :   .tFetchP
3210:       | * :              % compound type; leave as addr
3225:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3226: LValueIndexes:
3228:    {[
3228:       | '[' :       @ArraySubscripts
3232:       | '.' :       @RecordFieldRef
3236:       | '^' :       @PointerDeref
3240:       | * :         >
3251:    ]};
      
3254: ArraySubscripts:
3256:    [ oTypeSNodeType
3258:       | nArrayType :
3259:       | * :       #eNotArray
3266:    ]
3266:    {
3266:       [ oTypeSNodeType
3268:          | nArrayType :
3269:          | * :    #eTooManySubscripts
3276:       ]
      
            % low subscript of this dimension
3276:       int low
3276:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3293:       Node baseType
3293:       baseType = oNodeGet( oTypeSTop, qBaseType )
3305:       oTypeSPop
3306:       oTypeSPush( baseType )
      
3312:       @Expr
3314:       @RequireIntPop
            % adjust for low subscript
3316:       [ equal_zero( low )
3323:          | false :
3324:             .tPushConstI oEmitInt( low ) .tSubI
3334:          | * :
3339:       ]
      
            % multiply by element size
3339:       int size
3339:       size = oNodeGetInt( baseType, qSize )
3352:       [ equal( size, 1 )
3362:          | false :
3363:             .tPushConstI oEmitInt( size ) .tMultI
3373:          | * :
3378:       ]
      
            % update start address
3378:       .tAddPI
3380:       [
3380:          | ']' :  >
3384:          | ',' :
3386:       ]
3394:    };
      
      
3397: RecordFieldRef:
3399:    [ oTypeSNodeType
3401:       | nRecordType :
3402:       | * :    #eNotRecord
3409:    ]
3409:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3421:    pIdent
3423:    Node field
3423:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3428:    [ oNodeType( field )
3435:       | nRecordField :
3436:       | * :   #eNotRecordField
3443:    ]
3443:    oScopeEnd
3444:    int offset
3444:    offset = oNodeGetInt( field, qValue )
3457:    [ equal_zero( offset )
3464:       | false :
3465:          .tPushConstI oEmitInt( offset ) .tAddPI
3475:       | * :
3480:    ]
      
         % replace the type on the type stack, with the field type
3480:    oTypeSPop
3481:    oTypeSPush( oNodeGet( field, qType ) )
3495:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3495: PointerDeref:
3497:    [ oTypeSNodeType
3499:       | nPointerType :
3500:       | * :       #eNotPointer
3507:    ]
3507:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3509:    Node theType
3509:    theType = oTypeSTop
3514:    oTypeSPop
3515:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3529:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3529: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3531:    @MatchTypes
3534:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3534: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
3536:    boolean isFunc
3536:    Node resultType
3536:    int tempOffset
      
3536:    isFunc = equal_node_type( oNodeType( method ), nFunc )
      
3553:    [ isFunc
3556:       | true :
3557:          resultType = oNodeGet( method, qType )
3570:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
3580:       | * :
3585:    ]
         
      
3585:    Node paramScope
3585:    paramScope = oNodeGet( method, qParams )
3598:    int actualsSize
3598:    actualsSize = oNodeGetInt( paramScope, qSize )
3611:    .tAllocActuals  oEmitInt( actualsSize )
      
3619:    Node param
3619:    param = oNodeGet( paramScope, qDecls )
3632:    [
3632:       | '(' :
            
3634:          {
3634:             [ oNodeNull( param )
3641:                | true : >
3644:                | * :
3649:             ]
      
3649:             int offset
3649:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
3662:             .tPushAddrActual oEmitInt( offset )
3670:             oTypeSPush( oNodeGet( param, qType ) )
      
3683:             [ oNodeGetBoolean( param, qInOut )
3693:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
3694:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3696:                           @MatchTypes
      
3698:                           .tAssignP
      
3700:                | false :  @Expr
3704:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3706:                           [ oTypeSNodeType
3708:                              | nIntegerType :            .tAssignI
3711:                              | nBooleanType :            .tAssignB
3715:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3719:                              | nPointerType :            .tAssignP
3723:                              | * :
                                       % compound types: copy value into actuals space
3738:                                  int size
3738:                                  size = oNodeGetInt( oTypeSTop, qSize )
3750:                                  .tCopy  oEmitInt( size )    % multi-word copy
3758:                           ]
3758:             ]
3766:             oTypeSPop
      
3767:             oNodeNext( param )
3773:             [ oNodeNull( param )
3780:                | true :  >
3783:                | false :
3785:             ]
      
3793:             ','
3795:          }
      
3797:          ')'
      
3799:       | * :
3804:    ]
      
3804:    [ oNodeNull( param )
3811:       | false :    #eMissingParameter
3814:       | * :
3819:    ]
      
3819:    [ isFunc
3822:       | true :
               % Pass result temp as an additional VAR parameter.
3823:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
3838:          .tPushAddrLocal  oEmitInt( tempOffset )
3846:          .tAssignP
3848:       | * :
3853:    ]
      
3853:    .tCall   @EmitValue( method )
      
3862:    [ isFunc
3865:       | true :
               % push return value from temp
3866:          oTypeSPush( resultType )
3872:          .tPushAddrLocal  oEmitInt( tempOffset )
3880:          @FetchVar
3882:       | * :
3887:    ]
         
3887:    .tFreeActuals  oEmitInt( actualsSize )
3896:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3896: Statement:
3898:    [
3898:       | pWriteln :     @WritelnStmt
3902:       | pWrite :       @WriteStmt
3906:       | pReadln :      @ReadlnStmt
3910:       | pRead :        @ReadStmt
3914:       | pIf :          @IfStmt
3918:       | pWhile :       @WhileStmt
3922:       | pFor :         @ForStmt
3926:       | pRepeat :      @RepeatStmt
3930:       | pExit :        @ExitStmt
3934:       | pCycle :       @CycleStmt
3938:       | pBegin :       @BeginStmt
3942:       | pIdent :       @AssignOrCallStmt
3946:       | * :            % null statement : don't accept any tokens
3973:    ];
      
      
3974: AssignOrCallStmt:
3976:    Node decl
3976:    decl = oScopeFindRequire
3981:    [ oNodeType( decl )
3988:       | nProc :                           @Call( decl )
3996:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4005:       | nFunc :                           @AssignResultStmt( decl )
4014:       | * :                               #eBadStatement
4029:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4030: AssignStmt( Node decl ):
      
4032:    @LValueVar( decl )
      
4039:    ':=' 
4041:    @Expr
4043:    @MatchTypes
4045:    [ oTypeSNodeType
4047:       | nIntegerType :            .tAssignI
4050:       | nBooleanType :            .tAssignB
4054:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4058:       | nPointerType :            .tAssignP
4062:       | * :
4077:           int size
4077:           size = oNodeGetInt( oTypeSTop, qSize )
4089:           .tCopy  oEmitInt( size )    % multi-word copy
4097:    ]
4097:    oTypeSPop
4099:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4099: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4101:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4117:       | false :   #eNotCurrentFunction
4120:       | * :
4125:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4125:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4140:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4153:    ':='
4155:    @Expr
4157:    @MatchTypes
4159:    [ oTypeSNodeType
4161:       | nIntegerType :            .tAssignI
4164:       | nBooleanType :            .tAssignB
4168:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4172:       | nPointerType :            .tAssignP
4176:       | * :
4191:           int size
4191:           size = oNodeGetInt( oTypeSTop, qSize )
4203:           .tCopy  oEmitInt( size )    % multi-word copy
4211:    ]
4211:    oTypeSPop
4213:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4213: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4215:    pIdent
4217:    Node decl
4217:    decl = oScopeFindRequire
4222:    [ oNodeType( decl )
4229:       | nGlobalVar, nLocalVar, nParam :
4230:       | * :  #eNotVar
4241:    ]
4241:    @LValueVar( decl )
4249:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4249: LValueVar( Node decl ):
4251:    [ oNodeType( decl )
4258:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4268:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4279:       | nParam :
4281:          [ oNodeGetBoolean( decl, qInOut )
4291:             | true :   % VAR param points to variable.  No dereference.
4292:                        .tPushParamP @EmitValue( decl )
4301:             | * :      .tPushAddrParam @EmitValue( decl )
4315:          ]
4315:       | * :            #eNotVar
4326:    ]
      
4326:    oTypeSPush( oNodeGet( decl, qType ) )
4339:    @LValueIndexes        % handle subscripts, if any
4342:    ;
      
      
4342: IncVar( Node decl ):
4344:    @LValueVar( decl )
4351:    @RequireIntPop
4353:    @VarExpr( decl )
4360:    oTypeSPop
4361:    .tIncI
4363:    .tAssignI;
      
4366: DecVar( Node decl ):
4368:    @LValueVar( decl )
4375:    @RequireIntPop
4377:    @VarExpr( decl )
4384:    oTypeSPop
4385:    .tDecI
4387:    .tAssignI;
      
      
4390: IfStmt:
4392:    Label falseLabel
4392:    falseLabel = labelNull
      
4398:    @BooleanExprControlFlow( falseLabel )
4405:    pThen
4407:    @Statement
4409:    [
4409:       | pElse :
4411:          Label doneLabel
4411:          doneLabel = oLabelNew
      
4416:          .tJump  oEmitLabel( doneLabel )
4424:          .tLabel oEmitLabel( falseLabel )
4432:          @Statement
4434:          .tLabel oEmitLabel( doneLabel )
      
4442:       | * :
4447:          .tLabel oEmitLabel( falseLabel )
4455:    ];
      
      
4456: ForStmt:
4458:    pIdent
      
4460:    Node decl
4460:    decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
4465:    @LValueVar( decl )
4472:    @RequireIntPop
      
4474:    ':='
      
4476:    @Expr
4478:    @RequireIntPop
4480:    .tAssignI
      
4482:    Label exitLabel
4482:    exitLabel = oLabelNew
      
4487:    Label checkLabel
4487:    checkLabel = oLabelNew
4492:    .tJump  oEmitLabel( checkLabel )
      
4500:    Label cycleLabel
4500:    cycleLabel = oLabelNew
4505:    .tLabel  oEmitLabel( cycleLabel )
4513:    [
4513:       | pTo :
4515:          @IncVar( decl )
4522:          .tLabel  oEmitLabel( checkLabel )
4530:          @VarExpr( decl )  oTypeSPop
4538:          @Expr
4540:          @RequireIntPop
4542:          .tGreaterI
4544:          .tJumpTrue  oEmitLabel( exitLabel )
4552:       | pDownto :
4554:          @DecVar( decl )
4561:          .tLabel  oEmitLabel( checkLabel )
4569:          @VarExpr( decl )  oTypeSPop
4577:          @Expr
4579:          @RequireIntPop
4581:          .tLessI
4583:          .tJumpTrue  oEmitLabel( exitLabel )
4591:    ]
4599:    oLoopPush( cycleLabel, exitLabel )
4608:    pDo
4610:    @Statement
4612:    .tJump  oEmitLabel( cycleLabel )
4620:    .tLabel  oEmitLabel( exitLabel )
4628:    oLoopPop;
      
      
4630: RepeatStmt:
4632:    Label cycleLabel
4632:    cycleLabel = oLabelNew
4637:    .tLabel  oEmitLabel( cycleLabel )
      
4645:    Label exitLabel
4645:    exitLabel = oLabelNew
      
4650:    oLoopPush( cycleLabel, exitLabel )
4659:    @Statement
4661:    {[
4661:       | ';' :
4663:          @Statement
4665:       | pUntil :
4667:          @Expr
4669:          @RequireBoolPop
4671:          .tJumpFalse  oEmitLabel( cycleLabel )
4679:          >
4681:    ]}
4691:    .tLabel  oEmitLabel( exitLabel )
4699:    oLoopPop;
      
      
4701: WhileStmt:
4703:    Label cycleLabel
4703:    cycleLabel = oLabelNew
4708:    .tLabel  oEmitLabel( cycleLabel )
      
4716:    Label exitLabel
4716:    exitLabel = oLabelNew
      
4721:    oLoopPush( cycleLabel, exitLabel )
4730:    @Expr
4732:    @RequireBoolPop
4734:    pDo
4736:    .tJumpFalse  oEmitLabel( exitLabel )
4744:    @Statement
4746:    .tJump  oEmitLabel( cycleLabel )
4754:    .tLabel  oEmitLabel( exitLabel )
4762:    oLoopPop;
      
      
4764: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
4766:    [ equal_label( oLoopCycleLabel, labelNull )
4775:       | true :
4776:          #eNotInALoop
4778:       | false :
4780:          .tJump  oEmitLabel( oLoopCycleLabel )
4787:    ];
      
      
4796: ExitStmt:
4798:    [ equal_label( oLoopExitLabel, labelNull )
4807:       | true :
4808:          #eNotInALoop
4810:       | false :
4812:          .tJump  oEmitLabel( oLoopExitLabel )
4819:    ];
      
      
4828: BeginStmt:
4830:    @Statement
4832:    {[
4832:       | ';' :   @Statement
4836:       | pEnd :  >
4840:    ]};
      
      
4851: WritelnStmt:
4853:    @WriteStmt
4855:    .tWriteCR;
      
      
4858: WriteStmt:
4860:    [
4860:       | '(' :
4862:          {
4862:             @Expr
4864:             [ oTypeSNodeType
4866:                | nIntegerType :             .tWriteI
4869:                | nBooleanType :             .tWriteBool
4873:                | nStringType :              .tWriteStr
4877:                | nCharType, nFileType :     #eNotImplemented
4881:                | nPointerType :             .tWriteP
4885:                | * :                        #eNotAllowed
4902:             ]
4902:             oTypeSPop
4903:             [
4903:                | ')' : >
4907:                | ',' :
4909:             ]
4917:          }
4919:       | * :
4924:    ];
      
      
4925: ReadlnStmt:      % ***
         % TO DO
4928:    ;
      
4928: ReadStmt:
         % TO DO
4931:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4931: MatchTypes:
4933:    node_type nt
4933:    nt = oTypeSNodeType
4938:    oTypeSPop
4939:    [ equal_node_type( nt, oTypeSNodeType )
4948:       | false :
4949:          #eTypeMismatch
4951:       | * :
4956:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
4957: RequireIntPop:
4959:    [ oTypeSNodeType
4961:       | nIntegerType :
4962:       | * :          #eNotInteger
4969:    ]
4969:    oTypeSPop;
      
4971: RequireInt:
4973:    [ oTypeSNodeType
4975:       | nIntegerType :
4976:       | * :          #eNotInteger
4983:    ];
      
4984: RequireBoolPop:
4986:    [ oTypeSNodeType
4988:       | nBooleanType :
4989:       | * :          #eNotBoolean
4996:    ]
4996:    oTypeSPop;
      
4998: RequireBool:
5000:    [ oTypeSNodeType
5002:       | nBooleanType :
5003:       | * :          #eNotBoolean
5010:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5011: newType( node_type nt, int size ) >> Node:
5013:   Node node
5013:   node = oNodeNew( nt )
5023:   oNodeSetInt( node, qSize, size )
5035:   oTypeAdd( node )
5041:   >> node
5045:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5045: newIdent( node_type nt, kind k, int id ) >> Node:
5047:   Node t
5047:   t = oNodeNew( nt )
5057:   oNodeSetInt( t, qIdent, id )
5069:   >> t
5073:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5073: PointerTypeTo( Node theType ) >> Node:
5075:    Node ptrType
5075:    ptrType = oNodeGet( theType, qPointerType )
5088:    [ oNodeNull( ptrType )
5095:       | true :
5096:          ptrType = oNodeNew( nPointerType )
5106:          oNodeSet( ptrType, qBaseType, theType )
5118:          oNodeSetInt( ptrType, qSize, 8 )
5130:          oTypeAdd( ptrType )
5136:          oNodeSet( theType, qPointerType, ptrType )
5148:       | * :
5153:    ]
5153:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5157: OrdinalLow( Node theType ) >> int:
5159:    [ oNodeType( theType )
5166:       | nIntegerType :  >> -2147483648
5170:       | nBooleanType :  >> 0
5175:       | nCharType :     >> 0
5180:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5192:       | * :             #eNotOrdinalType
5205:                         >> 0
5208:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5209: EmitValue( Node decl ):
5211:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5225: installBuiltIns:
      
         % install built-in types
5227:    FileType = @newType( nFileType, 4 )
5241:    IntegerType = @newType( nIntegerType, 4 )
5255:    BooleanType = @newType( nBooleanType, 1 )
5269:    BooleanCFType = @newType( nBooleanCFType, 1 )
5283:    CharType = @newType( nCharType, 1 )
5297:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5311:    Node t
      
5311:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5327:    oNodeSet( t, qType, FileType )
5339:    oScopeDeclare( t )
      
5345:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
5361:    oNodeSet( t, qType, IntegerType )
5373:    oScopeDeclare( t )
      
5379:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
5395:    oNodeSet( t, qType, BooleanType )
5407:    oScopeDeclare( t )
      
5413:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
5429:    oNodeSet( t, qType, CharType )
5441:    oScopeDeclare( t )
      
5447:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
5463:    oNodeSet( t, qType, StringType )
5475:    oScopeDeclare( t )
      
         % Built-in constants
      
5481:    t = @newIdent( nConst, kConst, oIdAdd_True )
5497:    oNodeSet( t, qType, BooleanType )
5509:    oNodeSetInt( t, qValue, 1 )
5521:    oScopeDeclare( t )
      
5527:    t = @newIdent( nConst, kConst, oIdAdd_False )
5543:    oNodeSet( t, qType, BooleanType )
5555:    oNodeSetInt( t, qValue, 0 )
5567:    oScopeDeclare( t )
      
5574:    ;
      
5574: end
      
5574: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5225
  12: oGetAddrLocal 3
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 42
  19: oGetLocal 3
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 43
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 1
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5045
  44: oPop 3
  46: oAssign
  47: oGetLocal 1
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 2
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5045
  70: oPop 3
  72: oAssign
  73: oGetLocal 2
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 2
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 2
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5045
 108: oPop 3
 110: oAssign
 111: oGetLocal 2
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 2
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 1
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 3
 170: oPushResult
 171: oCall 242
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 242
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 806
 203: oJumpForward 239
 205: oCall 878
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 937
 214: oPop 1
 216: oJumpForward 239
 218: oCall 287
 220: oJumpForward 239
 222: oCall 409
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oReturn
 242: oLocalSpace 2
 244: oEmit 48
 246: oGetParam 1
 248: oPushResult
 249: oEmitLabel
 250: oPop 1
 252: oEmit 44
 254: oGetAddrLocal 1
 256: oPushResult
 257: Here
 258: oAssign
 259: oEmit 55
 261: oCall 3896
 263: oEmit 43
 265: oGetAddrLocal 2
 267: oPushResult
 268: oScopeCurrent
 269: oPushResult
 270: oSetResult 2
 272: oPushResult
 273: oNodeGetInt
 274: oPop 2
 276: oAssign
 277: oGetLocal 1
 279: oPushResult
 280: oGetLocal 2
 282: oPushResult
 283: oPatch
 284: oPop 2
 286: oReturn
 287: oLocalSpace 3
 289: oInput 0
 291: oGetAddrLocal 1
 293: oPushResult
 294: oSetResult 7
 296: oPushResult
 297: oSetResult 2
 299: oPushResult
 300: LAST_ID
 301: oPushResult
 302: oCall 5045
 304: oPop 3
 306: oAssign
 307: oScopeBegin
 308: oGetAddrLocal 2
 310: oPushResult
 311: oScopeCurrent
 312: oAssign
 313: oCall 579
 315: oGetLocal 1
 317: oPushResult
 318: oSetResult 8
 320: oPushResult
 321: oGetLocal 2
 323: oPushResult
 324: oNodeSet
 325: oPop 3
 327: oScopeEnd
 328: oGetLocal 1
 330: oPushResult
 331: oScopeDeclare
 332: oPop 1
 334: oInput 4
 336: oGetLocal 2
 338: oPushResult
 339: oScopeEnter
 340: oPop 1
 342: oScopeBegin
 343: oScopeCurrent
 344: oPushResult
 345: oSetResult 3
 347: oPushResult
 348: oSetResult 1
 350: oPushResult
 351: oNodeSetBoolean
 352: oPop 3
 354: oGetLocal 1
 356: oPushResult
 357: oSetResult 9
 359: oPushResult
 360: oScopeCurrent
 361: oPushResult
 362: oNodeSet
 363: oPop 3
 365: oGetAddrLocal 3
 367: oPushResult
 368: oLabelNew
 369: oAssign
 370: oSetResult 13
 372: oPushResult
 373: oGetLocal 3
 375: oPushResult
 376: oCall 180
 378: oPop 2
 380: oGetLocal 1
 382: oPushResult
 383: oSetResult 6
 385: oPushResult
 386: oGetLocal 3
 388: oPushResult
 389: oNodeSetLabel
 390: oPop 3
 392: oGetLocal 1
 394: oPushResult
 395: oSetResult 10
 397: oPushResult
 398: oSetResult 1
 400: oPushResult
 401: oNodeSetBoolean
 402: oPop 3
 404: oScopeEnd
 405: oScopeEnd
 406: oInput 4
 408: oReturn
 409: oLocalSpace 5
 411: oInput 0
 413: oGetAddrLocal 1
 415: oPushResult
 416: oSetResult 8
 418: oPushResult
 419: oSetResult 3
 421: oPushResult
 422: LAST_ID
 423: oPushResult
 424: oCall 5045
 426: oPop 3
 428: oAssign
 429: oScopeBegin
 430: oGetAddrLocal 3
 432: oPushResult
 433: oScopeCurrent
 434: oAssign
 435: oCall 579
 437: oGetLocal 1
 439: oPushResult
 440: oSetResult 8
 442: oPushResult
 443: oGetLocal 3
 445: oPushResult
 446: oNodeSet
 447: oPop 3
 449: oInput 11
 451: oGetAddrLocal 2
 453: oPushResult
 454: oCall 1078
 456: oPop 1
 458: oGetLocal 1
 460: oPushResult
 461: oSetResult 5
 463: oPushResult
 464: oGetLocal 2
 466: oPushResult
 467: oNodeSet
 468: oPop 3
 470: oGetAddrLocal 4
 472: oPushResult
 473: oGetLocal 2
 475: oPushResult
 476: oCall 5073
 478: oPop 1
 480: oAssign
 481: oGetLocal 1
 483: oPushResult
 484: oSetResult 11
 486: oPushResult
 487: oGetLocal 4
 489: oPushResult
 490: oScopeAllocType
 491: oPop 1
 493: oPushResult
 494: oNodeSetInt
 495: oPop 3
 497: oInput 4
 499: oScopeEnd
 500: oGetLocal 1
 502: oPushResult
 503: oScopeDeclare
 504: oPop 1
 506: oGetLocal 3
 508: oPushResult
 509: oScopeEnter
 510: oPop 1
 512: oScopeBegin
 513: oScopeCurrent
 514: oPushResult
 515: oSetResult 3
 517: oPushResult
 518: oSetResult 1
 520: oPushResult
 521: oNodeSetBoolean
 522: oPop 3
 524: oGetLocal 1
 526: oPushResult
 527: oSetResult 9
 529: oPushResult
 530: oScopeCurrent
 531: oPushResult
 532: oNodeSet
 533: oPop 3
 535: oGetAddrLocal 5
 537: oPushResult
 538: oLabelNew
 539: oAssign
 540: oSetResult 13
 542: oPushResult
 543: oGetLocal 5
 545: oPushResult
 546: oCall 180
 548: oPop 2
 550: oGetLocal 1
 552: oPushResult
 553: oSetResult 6
 555: oPushResult
 556: oGetLocal 5
 558: oPushResult
 559: oNodeSetLabel
 560: oPop 3
 562: oGetLocal 1
 564: oPushResult
 565: oSetResult 10
 567: oPushResult
 568: oSetResult 1
 570: oPushResult
 571: oNodeSetBoolean
 572: oPop 3
 574: oScopeEnd
 575: oScopeEnd
 576: oInput 4
 578: oReturn
 579: oLocalSpace 6
 581: oInputChoice 802
 583: oGetAddrLocal 1
 585: oPushResult
 586: oNodeVecNew
 587: oAssign
 588: oGetAddrLocal 3
 590: oPushResult
 591: oSetResult 0
 593: oAssign
 594: oInputChoice 604
 596: oGetAddrLocal 3
 598: oPushResult
 599: oSetResult 1
 601: oAssign
 602: oJumpForward 607
 604: Choice Lookup Table
          32    596
 607: oInput 0
 609: oGetAddrLocal 2
 611: oPushResult
 612: oSetResult 15
 614: oPushResult
 615: oSetResult 6
 617: oPushResult
 618: LAST_ID
 619: oPushResult
 620: oCall 5045
 622: oPop 3
 624: oAssign
 625: oGetLocal 2
 627: oPushResult
 628: oSetResult 12
 630: oPushResult
 631: oGetLocal 3
 633: oPushResult
 634: oNodeSetBoolean
 635: oPop 3
 637: oGetLocal 1
 639: oPushResult
 640: oGetLocal 2
 642: oPushResult
 643: oNodeVecAppend
 644: oPop 2
 646: oInputChoice 654
 648: oJumpForward 662
 650: oJumpForward 660
 652: oJumpForward 660
 654: Choice Lookup Table
          12    652
          11    648
 659: oEndChoice
 660: oJumpBack 607
 662: oGetAddrLocal 4
 664: oPushResult
 665: oCall 1078
 667: oPop 1
 669: oGetLocal 3
 671: oChoice 686
 673: oGetAddrLocal 5
 675: oPushResult
 676: oGetLocal 4
 678: oPushResult
 679: oCall 5073
 681: oPop 1
 683: oAssign
 684: oJumpForward 695
 686: Choice Lookup Table
           1    673
 689: oGetAddrLocal 5
 691: oPushResult
 692: oGetLocal 4
 694: oAssign
 695: oGetAddrLocal 6
 697: oPushResult
 698: oSetResult 0
 700: oAssign
 701: oGetLocal 6
 703: oPushResult
 704: oGetLocal 1
 706: oPushResult
 707: oNodeVecSize
 708: oPop 1
 710: oPushResult
 711: equal
 712: oPop 2
 714: oChoice 771
 716: oGetAddrLocal 2
 718: oPushResult
 719: oGetLocal 1
 721: oPushResult
 722: oGetLocal 6
 724: oPushResult
 725: oNodeVecElement
 726: oPop 2
 728: oAssign
 729: oGetLocal 2
 731: oPushResult
 732: oSetResult 5
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeSet
 739: oPop 3
 741: oGetLocal 2
 743: oPushResult
 744: oScopeDeclare
 745: oPop 1
 747: oGetLocal 2
 749: oPushResult
 750: oSetResult 6
 752: oPushResult
 753: oGetLocal 5
 755: oPushResult
 756: oScopeAllocType
 757: oPop 1
 759: oPushResult
 760: oNodeSetInt
 761: oPop 3
 763: oGetAddrLocal 6
 765: oPushResult
 766: inc
 767: oPop 1
 769: oJumpForward 776
 771: Choice Lookup Table
           0    716
 774: oJumpForward 778
 776: oJumpBack 701
 778: oGetLocal 1
 780: oPushResult
 781: oNodeVecDelete
 782: oPop 1
 784: oInputChoice 792
 786: oJumpForward 800
 788: oJumpForward 798
 790: oJumpForward 798
 792: Choice Lookup Table
           4    790
          14    786
 797: oEndChoice
 798: oJumpBack 583
 800: oJumpForward 805
 802: Choice Lookup Table
          13    583
 805: oReturn
 806: oLocalSpace 2
 808: oInputChoice 870
 810: oGetAddrLocal 1
 812: oPushResult
 813: oSetResult 9
 815: oPushResult
 816: oSetResult 4
 818: oPushResult
 819: LAST_ID
 820: oPushResult
 821: oCall 5045
 823: oPop 3
 825: oAssign
 826: oInput 5
 828: oCall 1547
 830: oGetAddrLocal 2
 832: oPushResult
 833: oValueTop
 834: oAssign
 835: oValuePop
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 6
 841: oPushResult
 842: oGetLocal 2
 844: oPushResult
 845: oNodeSetInt
 846: oPop 3
 848: oGetLocal 1
 850: oPushResult
 851: oSetResult 5
 853: oPushResult
 854: oGetGlobal 3
 856: oPushResult
 857: oNodeSet
 858: oPop 3
 860: oGetLocal 1
 862: oPushResult
 863: oScopeDeclare
 864: oPop 1
 866: oInput 4
 868: oJumpForward 875
 870: Choice Lookup Table
           0    810
 873: oJumpForward 877
 875: oJumpBack 808
 877: oReturn
 878: oLocalSpace 2
 880: oInputChoice 929
 882: oGetAddrLocal 1
 884: oPushResult
 885: oSetResult 10
 887: oPushResult
 888: oSetResult 5
 890: oPushResult
 891: LAST_ID
 892: oPushResult
 893: oCall 5045
 895: oPop 3
 897: oAssign
 898: oInput 5
 900: oGetAddrLocal 2
 902: oPushResult
 903: oCall 1078
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 5
 912: oPushResult
 913: oGetLocal 2
 915: oPushResult
 916: oNodeSet
 917: oPop 3
 919: oGetLocal 1
 921: oPushResult
 922: oScopeDeclare
 923: oPop 1
 925: oInput 4
 927: oJumpForward 934
 929: Choice Lookup Table
           0    882
 932: oJumpForward 936
 934: oJumpBack 880
 936: oReturn
 937: oLocalSpace 4
 939: oInputChoice 1070
 941: oGetAddrLocal 1
 943: oPushResult
 944: oNodeVecNew
 945: oAssign
 946: oGetAddrLocal 2
 948: oPushResult
 949: oGetParam 1
 951: oPushResult
 952: oSetResult 6
 954: oPushResult
 955: LAST_ID
 956: oPushResult
 957: oCall 5045
 959: oPop 3
 961: oAssign
 962: oGetLocal 1
 964: oPushResult
 965: oGetLocal 2
 967: oPushResult
 968: oNodeVecAppend
 969: oPop 2
 971: oInputChoice 977
 973: oInput 0
 975: oJumpForward 982
 977: Choice Lookup Table
          12    973
 980: oJumpForward 984
 982: oJumpBack 946
 984: oInput 11
 986: oGetAddrLocal 3
 988: oPushResult
 989: oCall 1078
 991: oPop 1
 993: oGetAddrLocal 4
 995: oPushResult
 996: oSetResult 0
 998: oAssign
 999: oGetLocal 4
1001: oPushResult
1002: oGetLocal 1
1004: oPushResult
1005: oNodeVecSize
1006: oPop 1
1008: oPushResult
1009: equal
1010: oPop 2
1012: oChoice 1053
1014: oGetAddrLocal 2
1016: oPushResult
1017: oGetLocal 1
1019: oPushResult
1020: oGetLocal 4
1022: oPushResult
1023: oNodeVecElement
1024: oPop 2
1026: oAssign
1027: oGetLocal 2
1029: oPushResult
1030: oSetResult 5
1032: oPushResult
1033: oGetLocal 3
1035: oPushResult
1036: oNodeSet
1037: oPop 3
1039: oGetLocal 2
1041: oPushResult
1042: oScopeDeclareAlloc
1043: oPop 1
1045: oGetAddrLocal 4
1047: oPushResult
1048: inc
1049: oPop 1
1051: oJumpForward 1058
1053: Choice Lookup Table
           0   1014
1056: oJumpForward 1060
1058: oJumpBack 999
1060: oGetLocal 1
1062: oPushResult
1063: oNodeVecDelete
1064: oPop 1
1066: oInput 4
1068: oJumpForward 1075
1070: Choice Lookup Table
           0    941
1073: oJumpForward 1077
1075: oJumpBack 939
1077: oReturn
1078: oLocalSpace 12
1080: oInputChoice 1529
1082: oGetAddrLocal 1
1084: oPushResult
1085: oScopeFindRequire
1086: oAssign
1087: oGetLocal 1
1089: oPushResult
1090: oNodeType
1091: oPop 1
1093: oChoice 1110
1095: oGetParam 1
1097: oPushResult
1098: oGetLocal 1
1100: oPushResult
1101: oSetResult 5
1103: oPushResult
1104: oNodeGet
1105: oPop 2
1107: oAssign
1108: oJumpForward 1121
1110: Choice Lookup Table
          10   1095
1113: oError 2
1115: oGetParam 1
1117: oPushResult
1118: oGetGlobal 3
1120: oAssign
1121: oJumpForward 1546
1123: oInput 15
1125: oGetAddrLocal 2
1127: oPushResult
1128: oNodeVecNew
1129: oAssign
1130: oGetAddrLocal 3
1132: oPushResult
1133: oSetResult 25
1135: oPushResult
1136: oNodeNew
1137: oPop 1
1139: oAssign
1140: oGetLocal 3
1142: oPushResult
1143: oSetResult 14
1145: oPushResult
1146: oGetGlobal 3
1148: oPushResult
1149: oNodeSet
1150: oPop 3
1152: oCall 1547
1154: oGetLocal 3
1156: oPushResult
1157: oSetResult 16
1159: oPushResult
1160: oValueTop
1161: oPushResult
1162: oNodeSetInt
1163: oPop 3
1165: oValuePop
1166: oInput 20
1168: oCall 1547
1170: oGetLocal 3
1172: oPushResult
1173: oSetResult 17
1175: oPushResult
1176: oValueTop
1177: oPushResult
1178: oNodeSetInt
1179: oPop 3
1181: oValuePop
1182: oGetLocal 3
1184: oPushResult
1185: oSetResult 2
1187: oPushResult
1188: oSetResult 4
1190: oPushResult
1191: oNodeSetInt
1192: oPop 3
1194: oGetLocal 3
1196: oPushResult
1197: oTypeAdd
1198: oPop 1
1200: oGetAddrLocal 4
1202: oPushResult
1203: oSetResult 24
1205: oPushResult
1206: oNodeNew
1207: oPop 1
1209: oAssign
1210: oGetLocal 4
1212: oPushResult
1213: oSetResult 15
1215: oPushResult
1216: oGetLocal 3
1218: oPushResult
1219: oNodeSet
1220: oPop 3
1222: oGetLocal 2
1224: oPushResult
1225: oGetLocal 4
1227: oPushResult
1228: oNodeVecAppend
1229: oPop 2
1231: oInputChoice 1239
1233: oJumpForward 1247
1235: oJumpForward 1245
1237: oJumpForward 1245
1239: Choice Lookup Table
          12   1237
          16   1233
1244: oEndChoice
1245: oJumpBack 1130
1247: oInput 38
1249: oGetAddrLocal 5
1251: oPushResult
1252: oCall 1078
1254: oPop 1
1256: oGetAddrLocal 6
1258: oPushResult
1259: oGetLocal 2
1261: oPushResult
1262: oNodeVecSize
1263: oPop 1
1265: oAssign
1266: oGetAddrLocal 6
1268: oPushResult
1269: dec
1270: oPop 1
1272: oGetAddrLocal 4
1274: oPushResult
1275: oGetLocal 2
1277: oPushResult
1278: oGetLocal 6
1280: oPushResult
1281: oNodeVecElement
1282: oPop 2
1284: oAssign
1285: oGetLocal 4
1287: oPushResult
1288: oSetResult 14
1290: oPushResult
1291: oGetLocal 5
1293: oPushResult
1294: oNodeSet
1295: oPop 3
1297: oGetAddrLocal 3
1299: oPushResult
1300: oGetLocal 4
1302: oPushResult
1303: oSetResult 15
1305: oPushResult
1306: oNodeGet
1307: oPop 2
1309: oAssign
1310: oGetAddrLocal 9
1312: oPushResult
1313: oGetLocal 3
1315: oPushResult
1316: oSetResult 17
1318: oPushResult
1319: oNodeGetInt
1320: oPop 2
1322: oPushResult
1323: oGetLocal 3
1325: oPushResult
1326: oSetResult 16
1328: oPushResult
1329: oNodeGetInt
1330: oPop 2
1332: oPushResult
1333: subtract
1334: oPop 2
1336: oAssign
1337: oGetAddrLocal 9
1339: oPushResult
1340: inc
1341: oPop 1
1343: oGetLocal 4
1345: oPushResult
1346: oSetResult 2
1348: oPushResult
1349: oGetLocal 9
1351: oPushResult
1352: oGetLocal 5
1354: oPushResult
1355: oSetResult 2
1357: oPushResult
1358: oNodeGetInt
1359: oPop 2
1361: oPushResult
1362: multiply
1363: oPop 2
1365: oPushResult
1366: oNodeSetInt
1367: oPop 3
1369: oGetLocal 4
1371: oPushResult
1372: oTypeAdd
1373: oPop 1
1375: oGetAddrLocal 5
1377: oPushResult
1378: oGetLocal 4
1380: oAssign
1381: oGetLocal 6
1383: oPushResult
1384: equal_zero
1385: oPop 1
1387: oChoice 1393
1389: oJumpForward 1398
1391: oJumpForward 1396
1393: Choice Lookup Table
           1   1389
1396: oJumpBack 1266
1398: oGetParam 1
1400: oPushResult
1401: oGetLocal 2
1403: oPushResult
1404: oSetResult 0
1406: oPushResult
1407: oNodeVecElement
1408: oPop 2
1410: oAssign
1411: oGetLocal 2
1413: oPushResult
1414: oNodeVecDelete
1415: oPop 1
1417: oJumpForward 1546
1419: oGetAddrLocal 10
1421: oPushResult
1422: oCall 1078
1424: oPop 1
1426: oGetParam 1
1428: oPushResult
1429: oGetLocal 10
1431: oPushResult
1432: oCall 5073
1434: oPop 1
1436: oAssign
1437: oJumpForward 1546
1439: oGetParam 1
1441: oPushResult
1442: oSetResult 26
1444: oPushResult
1445: oNodeNew
1446: oPop 1
1448: oAssign
1449: oScopeBegin
1450: oSetResult 14
1452: oPushResult
1453: oCall 937
1455: oPop 1
1457: oGetAddrLocal 11
1459: oPushResult
1460: oScopeCurrent
1461: oPushResult
1462: oSetResult 2
1464: oPushResult
1465: oNodeGetInt
1466: oPop 2
1468: oAssign
1469: oGetLocal 11
1471: oPushResult
1472: equal_zero
1473: oPop 1
1475: oChoice 1481
1477: oError 19
1479: oJumpForward 1484
1481: Choice Lookup Table
           1   1477
1484: oInput 34
1486: oGetFromParam 1
1488: oPushResult
1489: oSetResult 18
1491: oPushResult
1492: oScopeCurrent
1493: oPushResult
1494: oNodeSet
1495: oPop 3
1497: oGetFromParam 1
1499: oPushResult
1500: oSetResult 2
1502: oPushResult
1503: oGetLocal 11
1505: oPushResult
1506: oNodeSetInt
1507: oPop 3
1509: oScopeEnd
1510: oGetFromParam 1
1512: oPushResult
1513: oTypeAdd
1514: oPop 1
1516: oJumpForward 1546
1518: oInput 38
1520: oGetAddrLocal 10
1522: oPushResult
1523: oCall 1078
1525: oPop 1
1527: oJumpForward 1546
1529: Choice Lookup Table
          37   1518
          36   1439
          17   1419
          35   1123
           0   1082
1540: oCall 1547
1542: oInput 20
1544: oCall 1547
1546: oReturn
1547: oLocalSpace 1
1549: oInputChoice 1604
1551: TOKEN_VALUE
1552: oPushResult
1553: oValuePush
1554: oPop 1
1556: oJumpForward 1612
1558: oGetAddrLocal 1
1560: oPushResult
1561: oScopeFindRequire
1562: oAssign
1563: oGetLocal 1
1565: oPushResult
1566: oNodeType
1567: oPop 1
1569: oChoice 1586
1571: oGetLocal 1
1573: oPushResult
1574: oSetResult 6
1576: oPushResult
1577: oNodeGetInt
1578: oPop 2
1580: oPushResult
1581: oValuePush
1582: oPop 1
1584: oJumpForward 1597
1586: Choice Lookup Table
           9   1571
1589: oError 1
1591: oSetResult 0
1593: oPushResult
1594: oValuePush
1595: oPop 1
1597: oJumpForward 1612
1599: oCall 1547
1601: oValueNegate
1602: oJumpForward 1612
1604: Choice Lookup Table
          24   1599
           0   1558
           1   1551
1611: oEndChoice
1612: oReturn
1613: oLocalSpace 1
1615: oGetAddrLocal 1
1617: oPushResult
1618: oSetResult 0
1620: oAssign
1621: oGetAddrLocal 1
1623: oPushResult
1624: oCall 1774
1626: oPop 1
1628: oGetAddrLocal 1
1630: oPushResult
1631: oCall 1674
1633: oPop 1
1635: oReturn
1636: oLocalSpace 0
1638: oGetParam 1
1640: oPushResult
1641: oCall 1774
1643: oPop 1
1645: oTypeSNodeType
1646: oChoice 1665
1648: oJumpForward 1672
1650: oGetParam 1
1652: oPushResult
1653: oLabelNew
1654: oAssign
1655: oEmit 47
1657: oGetFromParam 1
1659: oPushResult
1660: oEmitLabel
1661: oPop 1
1663: oJumpForward 1672
1665: Choice Lookup Table
          19   1650
          20   1648
1670: oError 8
1672: oTypeSPop
1673: oReturn
1674: oLocalSpace 1
1676: oTypeSNodeType
1677: oChoice 1739
1679: oGetAddrLocal 1
1681: oPushResult
1682: oLabelNew
1683: oAssign
1684: oEmit 9
1686: oSetResult 1
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oEmit 45
1694: oGetLocal 1
1696: oPushResult
1697: oEmitLabel
1698: oPop 1
1700: oEmit 48
1702: oGetFromParam 1
1704: oPushResult
1705: oEmitLabel
1706: oPop 1
1708: oEmit 9
1710: oSetResult 0
1712: oPushResult
1713: oEmitInt
1714: oPop 1
1716: oEmit 48
1718: oGetLocal 1
1720: oPushResult
1721: oEmitLabel
1722: oPop 1
1724: oTypeSPop
1725: oGetGlobal 4
1727: oPushResult
1728: oTypeSPush
1729: oPop 1
1731: oGetParam 1
1733: oPushResult
1734: oSetResult 0
1736: oAssign
1737: oJumpForward 1742
1739: Choice Lookup Table
          20   1679
1742: oReturn
1743: oLocalSpace 0
1745: oTypeSNodeType
1746: oChoice 1770
1748: oGetParam 1
1750: oPushResult
1751: oLabelNew
1752: oAssign
1753: oEmit 47
1755: oGetFromParam 1
1757: oPushResult
1758: oEmitLabel
1759: oPop 1
1761: oTypeSPop
1762: oGetGlobal 5
1764: oPushResult
1765: oTypeSPush
1766: oPop 1
1768: oJumpForward 1773
1770: Choice Lookup Table
          19   1748
1773: oReturn
1774: oLocalSpace 0
1776: oGetParam 1
1778: oPushResult
1779: oCall 2139
1781: oPop 1
1783: oInputChoice 2121
1785: oGetParam 1
1787: oPushResult
1788: oCall 1674
1790: oPop 1
1792: oGetParam 1
1794: oPushResult
1795: oCall 2139
1797: oPop 1
1799: oGetParam 1
1801: oPushResult
1802: oCall 1674
1804: oPop 1
1806: oCall 4931
1808: oTypeSNodeType
1809: oChoice 1823
1811: oEmit 32
1813: oJumpForward 1836
1815: oEmit 38
1817: oJumpForward 1836
1819: oError 16
1821: oJumpForward 1836
1823: Choice Lookup Table
          22   1819
          21   1819
          23   1815
          19   1811
          18   1811
1834: oError 17
1836: oTypeSPop
1837: oGetGlobal 4
1839: oPushResult
1840: oTypeSPush
1841: oPop 1
1843: oJumpForward 2136
1845: oGetParam 1
1847: oPushResult
1848: oCall 1674
1850: oPop 1
1852: oGetParam 1
1854: oPushResult
1855: oCall 2139
1857: oPop 1
1859: oGetParam 1
1861: oPushResult
1862: oCall 1674
1864: oPop 1
1866: oCall 4931
1868: oTypeSNodeType
1869: oChoice 1883
1871: oEmit 33
1873: oJumpForward 1896
1875: oEmit 39
1877: oJumpForward 1896
1879: oError 16
1881: oJumpForward 1896
1883: Choice Lookup Table
          22   1879
          21   1879
          23   1875
          19   1871
          18   1871
1894: oError 17
1896: oTypeSPop
1897: oGetGlobal 4
1899: oPushResult
1900: oTypeSPush
1901: oPop 1
1903: oJumpForward 2136
1905: oGetParam 1
1907: oPushResult
1908: oCall 1674
1910: oPop 1
1912: oGetParam 1
1914: oPushResult
1915: oCall 2139
1917: oPop 1
1919: oGetParam 1
1921: oPushResult
1922: oCall 1674
1924: oPop 1
1926: oCall 4931
1928: oTypeSNodeType
1929: oChoice 1939
1931: oEmit 35
1933: oJumpForward 1950
1935: oError 16
1937: oJumpForward 1950
1939: Choice Lookup Table
          22   1935
          21   1935
          19   1931
          18   1931
1948: oError 17
1950: oTypeSPop
1951: oGetGlobal 4
1953: oPushResult
1954: oTypeSPush
1955: oPop 1
1957: oJumpForward 2136
1959: oGetParam 1
1961: oPushResult
1962: oCall 1674
1964: oPop 1
1966: oGetParam 1
1968: oPushResult
1969: oCall 2139
1971: oPop 1
1973: oGetParam 1
1975: oPushResult
1976: oCall 1674
1978: oPop 1
1980: oCall 4931
1982: oTypeSNodeType
1983: oChoice 1993
1985: oEmit 34
1987: oJumpForward 2004
1989: oError 16
1991: oJumpForward 2004
1993: Choice Lookup Table
          22   1989
          21   1989
          19   1985
          18   1985
2002: oError 17
2004: oTypeSPop
2005: oGetGlobal 4
2007: oPushResult
2008: oTypeSPush
2009: oPop 1
2011: oJumpForward 2136
2013: oGetParam 1
2015: oPushResult
2016: oCall 1674
2018: oPop 1
2020: oGetParam 1
2022: oPushResult
2023: oCall 2139
2025: oPop 1
2027: oGetParam 1
2029: oPushResult
2030: oCall 1674
2032: oPop 1
2034: oCall 4931
2036: oTypeSNodeType
2037: oChoice 2047
2039: oEmit 37
2041: oJumpForward 2058
2043: oError 16
2045: oJumpForward 2058
2047: Choice Lookup Table
          22   2043
          21   2043
          19   2039
          18   2039
2056: oError 17
2058: oTypeSPop
2059: oGetGlobal 4
2061: oPushResult
2062: oTypeSPush
2063: oPop 1
2065: oJumpForward 2136
2067: oGetParam 1
2069: oPushResult
2070: oCall 1674
2072: oPop 1
2074: oGetParam 1
2076: oPushResult
2077: oCall 2139
2079: oPop 1
2081: oGetParam 1
2083: oPushResult
2084: oCall 1674
2086: oPop 1
2088: oCall 4931
2090: oTypeSNodeType
2091: oChoice 2101
2093: oEmit 36
2095: oJumpForward 2112
2097: oError 16
2099: oJumpForward 2112
2101: Choice Lookup Table
          22   2097
          21   2097
          19   2093
          18   2093
2110: oError 17
2112: oTypeSPop
2113: oGetGlobal 4
2115: oPushResult
2116: oTypeSPush
2117: oPop 1
2119: oJumpForward 2136
2121: Choice Lookup Table
          10   2067
           9   2013
           8   1959
           7   1905
           6   1845
           5   1785
2134: oJumpForward 2138
2136: oJumpBack 1783
2138: oReturn
2139: oLocalSpace 1
2141: oGetAddrLocal 1
2143: oPushResult
2144: oSetResult 0
2146: oAssign
2147: oGetParam 1
2149: oPushResult
2150: oCall 2319
2152: oPop 1
2154: oInputChoice 2287
2156: oTypeSNodeType
2157: oChoice 2228
2159: oGetLocal 1
2161: oPushResult
2162: oSetResult 0
2164: oPushResult
2165: equal_label
2166: oPop 2
2168: oChoice 2177
2170: oGetAddrLocal 1
2172: oPushResult
2173: oLabelNew
2174: oAssign
2175: oJumpForward 2180
2177: Choice Lookup Table
           1   2170
2180: oEmit 45
2182: oGetLocal 1
2184: oPushResult
2185: oEmitLabel
2186: oPop 1
2188: oJumpForward 2235
2190: oGetParam 1
2192: oPushResult
2193: oCall 1743
2195: oPop 1
2197: oGetLocal 1
2199: oPushResult
2200: oSetResult 0
2202: oPushResult
2203: equal_label
2204: oPop 2
2206: oChoice 2215
2208: oGetAddrLocal 1
2210: oPushResult
2211: oLabelNew
2212: oAssign
2213: oJumpForward 2218
2215: Choice Lookup Table
           1   2208
2218: oEmit 46
2220: oGetLocal 1
2222: oPushResult
2223: oEmitLabel
2224: oPop 1
2226: oJumpForward 2235
2228: Choice Lookup Table
          19   2190
          20   2159
2233: oError 8
2235: oTypeSPop
2236: oEmit 48
2238: oGetFromParam 1
2240: oPushResult
2241: oEmitLabel
2242: oPop 1
2244: oGetParam 1
2246: oPushResult
2247: oSetResult 0
2249: oAssign
2250: oGetParam 1
2252: oPushResult
2253: oCall 2319
2255: oPop 1
2257: oTypeSNodeType
2258: oChoice 2271
2260: oJumpForward 2278
2262: oGetParam 1
2264: oPushResult
2265: oCall 1743
2267: oPop 1
2269: oJumpForward 2278
2271: Choice Lookup Table
          19   2262
          20   2260
2276: oError 8
2278: oTypeSPop
2279: oGetGlobal 5
2281: oPushResult
2282: oTypeSPush
2283: oPop 1
2285: oJumpForward 2292
2287: Choice Lookup Table
          53   2156
2290: oJumpForward 2294
2292: oJumpBack 2154
2294: oGetLocal 1
2296: oPushResult
2297: oSetResult 0
2299: oPushResult
2300: equal_label
2301: oPop 2
2303: oChoice 2315
2305: oEmit 48
2307: oGetLocal 1
2309: oPushResult
2310: oEmitLabel
2311: oPop 1
2313: oJumpForward 2318
2315: Choice Lookup Table
           0   2305
2318: oReturn
2319: oLocalSpace 2
2321: oGetAddrLocal 1
2323: oPushResult
2324: oSetResult 0
2326: oAssign
2327: oGetParam 1
2329: oPushResult
2330: oCall 2457
2332: oPop 1
2334: oInputChoice 2449
2336: oTypeSNodeType
2337: oChoice 2350
2339: oJumpForward 2357
2341: oGetParam 1
2343: oPushResult
2344: oCall 1743
2346: oPop 1
2348: oJumpForward 2357
2350: Choice Lookup Table
          19   2341
          20   2339
2355: oError 8
2357: oTypeSPop
2358: oGetLocal 1
2360: oPushResult
2361: oSetResult 0
2363: oPushResult
2364: equal_label
2365: oPop 2
2367: oChoice 2396
2369: oGetAddrLocal 1
2371: oPushResult
2372: oLabelNew
2373: oAssign
2374: oEmit 49
2376: oGetFromParam 1
2378: oPushResult
2379: oEmitLabel
2380: oPop 1
2382: oGetLocal 1
2384: oPushResult
2385: oEmitLabel
2386: oPop 1
2388: oGetParam 1
2390: oPushResult
2391: oGetLocal 1
2393: oAssign
2394: oJumpForward 2399
2396: Choice Lookup Table
           1   2369
2399: oGetAddrLocal 2
2401: oPushResult
2402: oSetResult 0
2404: oAssign
2405: oGetAddrLocal 2
2407: oPushResult
2408: oCall 2457
2410: oPop 1
2412: oTypeSNodeType
2413: oChoice 2426
2415: oJumpForward 2433
2417: oGetAddrLocal 2
2419: oPushResult
2420: oCall 1743
2422: oPop 1
2424: oJumpForward 2433
2426: Choice Lookup Table
          19   2417
          20   2415
2431: oError 8
2433: oEmit 49
2435: oGetLocal 2
2437: oPushResult
2438: oEmitLabel
2439: oPop 1
2441: oGetLocal 1
2443: oPushResult
2444: oEmitLabel
2445: oPop 1
2447: oJumpForward 2454
2449: Choice Lookup Table
          52   2336
2452: oJumpForward 2456
2454: oJumpBack 2334
2456: oReturn
2457: oLocalSpace 1
2459: oInputChoice 2513
2461: oGetAddrLocal 1
2463: oPushResult
2464: oSetResult 0
2466: oAssign
2467: oGetAddrLocal 1
2469: oPushResult
2470: oCall 2457
2472: oPop 1
2474: oTypeSNodeType
2475: oChoice 2504
2477: oGetParam 1
2479: oPushResult
2480: oLabelNew
2481: oAssign
2482: oEmit 45
2484: oGetFromParam 1
2486: oPushResult
2487: oEmitLabel
2488: oPop 1
2490: oEmit 48
2492: oGetLocal 1
2494: oPushResult
2495: oEmitLabel
2496: oPop 1
2498: oJumpForward 2511
2500: oEmit 29
2502: oJumpForward 2511
2504: Choice Lookup Table
          19   2500
          20   2477
2509: oError 8
2511: oJumpForward 2518
2513: Choice Lookup Table
          54   2461
2516: oCall 2519
2518: oReturn
2519: oLocalSpace 0
2521: oCall 2555
2523: oInputChoice 2545
2525: oCall 4957
2527: oCall 2555
2529: oCall 4971
2531: oEmit 26
2533: oJumpForward 2552
2535: oCall 4957
2537: oCall 2555
2539: oCall 4971
2541: oEmit 27
2543: oJumpForward 2552
2545: Choice Lookup Table
          24   2535
          23   2525
2550: oJumpForward 2554
2552: oJumpBack 2523
2554: oReturn
2555: oLocalSpace 0
2557: oCall 2591
2559: oInputChoice 2581
2561: oCall 4957
2563: oCall 2591
2565: oCall 4971
2567: oEmit 23
2569: oJumpForward 2588
2571: oCall 4957
2573: oCall 2591
2575: oCall 4971
2577: oEmit 24
2579: oJumpForward 2588
2581: Choice Lookup Table
          22   2571
          21   2561
2586: oJumpForward 2590
2588: oJumpBack 2559
2590: oReturn
2591: oLocalSpace 0
2593: oInputChoice 2609
2595: oCall 2617
2597: oCall 4971
2599: oJumpForward 2616
2601: oCall 2617
2603: oCall 4971
2605: oEmit 28
2607: oJumpForward 2616
2609: Choice Lookup Table
          24   2601
          23   2595
2614: oCall 2617
2616: oReturn
2617: oLocalSpace 5
2619: oInputChoice 2792
2621: oEmit 9
2623: TOKEN_VALUE
2624: oPushResult
2625: oEmitInt
2626: oPop 1
2628: oGetGlobal 3
2630: oPushResult
2631: oTypeSPush
2632: oPop 1
2634: oJumpForward 2811
2636: oCall 1613
2638: oInput 14
2640: oJumpForward 2811
2642: oStringAllocLit
2643: oEmit 10
2645: oValueTop
2646: oPushResult
2647: oEmitInt
2648: oPop 1
2650: oValuePop
2651: oGetGlobal 7
2653: oPushResult
2654: oTypeSPush
2655: oPop 1
2657: oJumpForward 2811
2659: oGetAddrLocal 1
2661: oPushResult
2662: oScopeFindRequire
2663: oAssign
2664: oGetLocal 1
2666: oPushResult
2667: oNodeType
2668: oPop 1
2670: oChoice 2732
2672: oGetLocal 1
2674: oPushResult
2675: oCall 3534
2677: oPop 1
2679: oJumpForward 2751
2681: oGetAddrLocal 2
2683: oPushResult
2684: oGetLocal 1
2686: oPushResult
2687: oSetResult 5
2689: oPushResult
2690: oNodeGet
2691: oPop 2
2693: oAssign
2694: oGetLocal 2
2696: oPushResult
2697: oTypeSPush
2698: oPop 1
2700: oTypeSNodeType
2701: oChoice 2714
2703: oEmit 9
2705: oGetLocal 1
2707: oPushResult
2708: oCall 5209
2710: oPop 1
2712: oJumpForward 2721
2714: Choice Lookup Table
          19   2703
          18   2703
2719: oError 16
2721: oJumpForward 2751
2723: oGetLocal 1
2725: oPushResult
2726: oCall 2812
2728: oPop 1
2730: oJumpForward 2751
2732: Choice Lookup Table
          15   2723
          13   2723
          12   2723
           9   2681
           8   2672
2743: oError 6
2745: oGetGlobal 3
2747: oPushResult
2748: oTypeSPush
2749: oPop 1
2751: oJumpForward 2811
2753: oInput 0
2755: oGetAddrLocal 1
2757: oPushResult
2758: oScopeFindRequire
2759: oAssign
2760: oGetLocal 1
2762: oPushResult
2763: oCall 4249
2765: oPop 1
2767: oGetAddrLocal 2
2769: oPushResult
2770: oTypeSTop
2771: oAssign
2772: oTypeSPop
2773: oGetAddrLocal 5
2775: oPushResult
2776: oGetLocal 2
2778: oPushResult
2779: oCall 5073
2781: oPop 1
2783: oAssign
2784: oGetLocal 5
2786: oPushResult
2787: oTypeSPush
2788: oPop 1
2790: oJumpForward 2811
2792: Choice Lookup Table
          18   2753
           0   2659
           2   2642
          13   2636
           1   2621
2803: oError 6
2805: oGetGlobal 3
2807: oPushResult
2808: oTypeSPush
2809: oPop 1
2811: oReturn
2812: oLocalSpace 1
2814: oGetAddrLocal 1
2816: oPushResult
2817: oGetParam 1
2819: oPushResult
2820: oSetResult 5
2822: oPushResult
2823: oNodeGet
2824: oPop 2
2826: oAssign
2827: oGetLocal 1
2829: oPushResult
2830: oTypeSPush
2831: oPop 1
2833: oTypeSNodeType
2834: oChoice 3099
2836: oGetParam 1
2838: oPushResult
2839: oNodeType
2840: oPop 1
2842: oChoice 2904
2844: oEmit 0
2846: oGetParam 1
2848: oPushResult
2849: oCall 5209
2851: oPop 1
2853: oJumpForward 2912
2855: oEmit 3
2857: oGetParam 1
2859: oPushResult
2860: oCall 5209
2862: oPop 1
2864: oJumpForward 2912
2866: oGetParam 1
2868: oPushResult
2869: oSetResult 12
2871: oPushResult
2872: oNodeGetBoolean
2873: oPop 2
2875: oChoice 2890
2877: oEmit 8
2879: oGetParam 1
2881: oPushResult
2882: oCall 5209
2884: oPop 1
2886: oEmit 14
2888: oJumpForward 2902
2890: Choice Lookup Table
           1   2877
2893: oEmit 6
2895: oGetParam 1
2897: oPushResult
2898: oCall 5209
2900: oPop 1
2902: oJumpForward 2912
2904: Choice Lookup Table
          15   2866
          13   2855
          12   2844
2911: oEndChoice
2912: oJumpForward 3190
2914: oGetParam 1
2916: oPushResult
2917: oNodeType
2918: oPop 1
2920: oChoice 2982
2922: oEmit 1
2924: oGetParam 1
2926: oPushResult
2927: oCall 5209
2929: oPop 1
2931: oJumpForward 2990
2933: oEmit 4
2935: oGetParam 1
2937: oPushResult
2938: oCall 5209
2940: oPop 1
2942: oJumpForward 2990
2944: oGetParam 1
2946: oPushResult
2947: oSetResult 12
2949: oPushResult
2950: oNodeGetBoolean
2951: oPop 2
2953: oChoice 2968
2955: oEmit 8
2957: oGetParam 1
2959: oPushResult
2960: oCall 5209
2962: oPop 1
2964: oEmit 15
2966: oJumpForward 2980
2968: Choice Lookup Table
           1   2955
2971: oEmit 7
2973: oGetParam 1
2975: oPushResult
2976: oCall 5209
2978: oPop 1
2980: oJumpForward 2990
2982: Choice Lookup Table
          15   2944
          13   2933
          12   2922
2989: oEndChoice
2990: oJumpForward 3190
2992: oError 16
2994: oJumpForward 3190
2996: oGetParam 1
2998: oPushResult
2999: oNodeType
3000: oPop 1
3002: oChoice 3064
3004: oEmit 2
3006: oGetParam 1
3008: oPushResult
3009: oCall 5209
3011: oPop 1
3013: oJumpForward 3072
3015: oEmit 5
3017: oGetParam 1
3019: oPushResult
3020: oCall 5209
3022: oPop 1
3024: oJumpForward 3072
3026: oGetParam 1
3028: oPushResult
3029: oSetResult 12
3031: oPushResult
3032: oNodeGetBoolean
3033: oPop 2
3035: oChoice 3050
3037: oEmit 8
3039: oGetParam 1
3041: oPushResult
3042: oCall 5209
3044: oPop 1
3046: oEmit 16
3048: oJumpForward 3062
3050: Choice Lookup Table
           1   3037
3053: oEmit 8
3055: oGetParam 1
3057: oPushResult
3058: oCall 5209
3060: oPop 1
3062: oJumpForward 3072
3064: Choice Lookup Table
          15   3026
          13   3015
          12   3004
3071: oEndChoice
3072: oInputChoice 3094
3074: oTypeSPop
3075: oGetLocal 1
3077: oPushResult
3078: oSetResult 14
3080: oPushResult
3081: oNodeGet
3082: oPop 2
3084: oPushResult
3085: oTypeSPush
3086: oPop 1
3088: oCall 3226
3090: oCall 3191
3092: oJumpForward 3097
3094: Choice Lookup Table
          17   3074
3097: oJumpForward 3190
3099: Choice Lookup Table
          23   2996
          17   2992
          22   2992
          21   2992
          19   2914
          18   2836
3112: oGetParam 1
3114: oPushResult
3115: oNodeType
3116: oPop 1
3118: oChoice 3178
3120: oEmit 10
3122: oGetParam 1
3124: oPushResult
3125: oCall 5209
3127: oPop 1
3129: oJumpForward 3186
3131: oEmit 11
3133: oGetParam 1
3135: oPushResult
3136: oCall 5209
3138: oPop 1
3140: oJumpForward 3186
3142: oGetParam 1
3144: oPushResult
3145: oSetResult 12
3147: oPushResult
3148: oNodeGetBoolean
3149: oPop 2
3151: oChoice 3164
3153: oEmit 8
3155: oGetParam 1
3157: oPushResult
3158: oCall 5209
3160: oPop 1
3162: oJumpForward 3176
3164: Choice Lookup Table
           1   3153
3167: oEmit 12
3169: oGetParam 1
3171: oPushResult
3172: oCall 5209
3174: oPop 1
3176: oJumpForward 3186
3178: Choice Lookup Table
          15   3142
          13   3131
          12   3120
3185: oEndChoice
3186: oCall 3226
3188: oCall 3191
3190: oReturn
3191: oLocalSpace 0
3193: oTypeSNodeType
3194: oChoice 3212
3196: oEmit 14
3198: oJumpForward 3225
3200: oEmit 15
3202: oJumpForward 3225
3204: oError 16
3206: oJumpForward 3225
3208: oEmit 16
3210: oJumpForward 3225
3212: Choice Lookup Table
          23   3208
          17   3204
          22   3204
          21   3204
          19   3200
          18   3196
3225: oReturn
3226: oLocalSpace 0
3228: oInputChoice 3242
3230: oCall 3254
3232: oJumpForward 3251
3234: oCall 3397
3236: oJumpForward 3251
3238: oCall 3495
3240: oJumpForward 3251
3242: Choice Lookup Table
          17   3238
          19   3234
          15   3230
3249: oJumpForward 3253
3251: oJumpBack 3228
3253: oReturn
3254: oLocalSpace 3
3256: oTypeSNodeType
3257: oChoice 3261
3259: oJumpForward 3266
3261: Choice Lookup Table
          24   3259
3264: oError 10
3266: oTypeSNodeType
3267: oChoice 3271
3269: oJumpForward 3276
3271: Choice Lookup Table
          24   3269
3274: oError 13
3276: oGetAddrLocal 1
3278: oPushResult
3279: oTypeSTop
3280: oPushResult
3281: oSetResult 15
3283: oPushResult
3284: oNodeGet
3285: oPop 2
3287: oPushResult
3288: oCall 5157
3290: oPop 1
3292: oAssign
3293: oGetAddrLocal 2
3295: oPushResult
3296: oTypeSTop
3297: oPushResult
3298: oSetResult 14
3300: oPushResult
3301: oNodeGet
3302: oPop 2
3304: oAssign
3305: oTypeSPop
3306: oGetLocal 2
3308: oPushResult
3309: oTypeSPush
3310: oPop 1
3312: oCall 1613
3314: oCall 4957
3316: oGetLocal 1
3318: oPushResult
3319: equal_zero
3320: oPop 1
3322: oChoice 3336
3324: oEmit 9
3326: oGetLocal 1
3328: oPushResult
3329: oEmitInt
3330: oPop 1
3332: oEmit 27
3334: oJumpForward 3339
3336: Choice Lookup Table
           0   3324
3339: oGetAddrLocal 3
3341: oPushResult
3342: oGetLocal 2
3344: oPushResult
3345: oSetResult 2
3347: oPushResult
3348: oNodeGetInt
3349: oPop 2
3351: oAssign
3352: oGetLocal 3
3354: oPushResult
3355: oSetResult 1
3357: oPushResult
3358: equal
3359: oPop 2
3361: oChoice 3375
3363: oEmit 9
3365: oGetLocal 3
3367: oPushResult
3368: oEmitInt
3369: oPop 1
3371: oEmit 23
3373: oJumpForward 3378
3375: Choice Lookup Table
           0   3363
3378: oEmit 25
3380: oInputChoice 3388
3382: oJumpForward 3396
3384: oJumpForward 3394
3386: oJumpForward 3394
3388: Choice Lookup Table
          12   3386
          16   3382
3393: oEndChoice
3394: oJumpBack 3266
3396: oReturn
3397: oLocalSpace 2
3399: oTypeSNodeType
3400: oChoice 3404
3402: oJumpForward 3409
3404: Choice Lookup Table
          26   3402
3407: oError 11
3409: oTypeSTop
3410: oPushResult
3411: oSetResult 18
3413: oPushResult
3414: oNodeGet
3415: oPop 2
3417: oPushResult
3418: oScopeEnter
3419: oPop 1
3421: oInput 0
3423: oGetAddrLocal 1
3425: oPushResult
3426: oScopeFindRequire
3427: oAssign
3428: oGetLocal 1
3430: oPushResult
3431: oNodeType
3432: oPop 1
3434: oChoice 3438
3436: oJumpForward 3443
3438: Choice Lookup Table
          14   3436
3441: oError 12
3443: oScopeEnd
3444: oGetAddrLocal 2
3446: oPushResult
3447: oGetLocal 1
3449: oPushResult
3450: oSetResult 6
3452: oPushResult
3453: oNodeGetInt
3454: oPop 2
3456: oAssign
3457: oGetLocal 2
3459: oPushResult
3460: equal_zero
3461: oPop 1
3463: oChoice 3477
3465: oEmit 9
3467: oGetLocal 2
3469: oPushResult
3470: oEmitInt
3471: oPop 1
3473: oEmit 25
3475: oJumpForward 3480
3477: Choice Lookup Table
           0   3465
3480: oTypeSPop
3481: oGetLocal 1
3483: oPushResult
3484: oSetResult 5
3486: oPushResult
3487: oNodeGet
3488: oPop 2
3490: oPushResult
3491: oTypeSPush
3492: oPop 1
3494: oReturn
3495: oLocalSpace 1
3497: oTypeSNodeType
3498: oChoice 3502
3500: oJumpForward 3507
3502: Choice Lookup Table
          23   3500
3505: oError 9
3507: oEmit 16
3509: oGetAddrLocal 1
3511: oPushResult
3512: oTypeSTop
3513: oAssign
3514: oTypeSPop
3515: oGetLocal 1
3517: oPushResult
3518: oSetResult 14
3520: oPushResult
3521: oNodeGet
3522: oPop 2
3524: oPushResult
3525: oTypeSPush
3526: oPop 1
3528: oReturn
3529: oLocalSpace 0
3531: oCall 4931
3533: oReturn
3534: oLocalSpace 8
3536: oGetAddrLocal 1
3538: oPushResult
3539: oGetParam 1
3541: oPushResult
3542: oNodeType
3543: oPop 1
3545: oPushResult
3546: oSetResult 8
3548: oPushResult
3549: equal_node_type
3550: oPop 2
3552: oAssign
3553: oGetLocal 1
3555: oChoice 3582
3557: oGetAddrLocal 2
3559: oPushResult
3560: oGetParam 1
3562: oPushResult
3563: oSetResult 5
3565: oPushResult
3566: oNodeGet
3567: oPop 2
3569: oAssign
3570: oGetAddrLocal 3
3572: oPushResult
3573: oGetLocal 2
3575: oPushResult
3576: oScopeAllocType
3577: oPop 1
3579: oAssign
3580: oJumpForward 3585
3582: Choice Lookup Table
           1   3557
3585: oGetAddrLocal 4
3587: oPushResult
3588: oGetParam 1
3590: oPushResult
3591: oSetResult 8
3593: oPushResult
3594: oNodeGet
3595: oPop 2
3597: oAssign
3598: oGetAddrLocal 5
3600: oPushResult
3601: oGetLocal 4
3603: oPushResult
3604: oSetResult 2
3606: oPushResult
3607: oNodeGetInt
3608: oPop 2
3610: oAssign
3611: oEmit 40
3613: oGetLocal 5
3615: oPushResult
3616: oEmitInt
3617: oPop 1
3619: oGetAddrLocal 6
3621: oPushResult
3622: oGetLocal 4
3624: oPushResult
3625: oSetResult 1
3627: oPushResult
3628: oNodeGet
3629: oPop 2
3631: oAssign
3632: oInputChoice 3801
3634: oGetLocal 6
3636: oPushResult
3637: oNodeNull
3638: oPop 1
3640: oChoice 3646
3642: oJumpForward 3797
3644: oJumpForward 3649
3646: Choice Lookup Table
           1   3642
3649: oGetAddrLocal 7
3651: oPushResult
3652: oGetLocal 6
3654: oPushResult
3655: oSetResult 6
3657: oPushResult
3658: oNodeGetInt
3659: oPop 2
3661: oAssign
3662: oEmit 13
3664: oGetLocal 7
3666: oPushResult
3667: oEmitInt
3668: oPop 1
3670: oGetLocal 6
3672: oPushResult
3673: oSetResult 5
3675: oPushResult
3676: oNodeGet
3677: oPop 2
3679: oPushResult
3680: oTypeSPush
3681: oPop 1
3683: oGetLocal 6
3685: oPushResult
3686: oSetResult 12
3688: oPushResult
3689: oNodeGetBoolean
3690: oPop 2
3692: oChoice 3760
3694: oCall 4213
3696: oCall 4931
3698: oEmit 19
3700: oJumpForward 3766
3702: oCall 1613
3704: oCall 3529
3706: oTypeSNodeType
3707: oChoice 3725
3709: oEmit 17
3711: oJumpForward 3758
3713: oEmit 18
3715: oJumpForward 3758
3717: oError 16
3719: oJumpForward 3758
3721: oEmit 19
3723: oJumpForward 3758
3725: Choice Lookup Table
          23   3721
          17   3717
          22   3717
          21   3717
          19   3713
          18   3709
3738: oGetAddrLocal 8
3740: oPushResult
3741: oTypeSTop
3742: oPushResult
3743: oSetResult 2
3745: oPushResult
3746: oNodeGetInt
3747: oPop 2
3749: oAssign
3750: oEmit 20
3752: oGetLocal 8
3754: oPushResult
3755: oEmitInt
3756: oPop 1
3758: oJumpForward 3766
3760: Choice Lookup Table
           0   3702
           1   3694
3765: oEndChoice
3766: oTypeSPop
3767: oGetAddrLocal 6
3769: oPushResult
3770: oNodeNext
3771: oPop 1
3773: oGetLocal 6
3775: oPushResult
3776: oNodeNull
3777: oPop 1
3779: oChoice 3787
3781: oJumpForward 3797
3783: oJumpForward 3793
3785: oJumpForward 3793
3787: Choice Lookup Table
           0   3785
           1   3781
3792: oEndChoice
3793: oInput 12
3795: oJumpBack 3634
3797: oInput 14
3799: oJumpForward 3804
3801: Choice Lookup Table
          13   3634
3804: oGetLocal 6
3806: oPushResult
3807: oNodeNull
3808: oPop 1
3810: oChoice 3816
3812: oError 15
3814: oJumpForward 3819
3816: Choice Lookup Table
           0   3812
3819: oGetLocal 1
3821: oChoice 3850
3823: oEmit 13
3825: oGetParam 1
3827: oPushResult
3828: oSetResult 11
3830: oPushResult
3831: oNodeGetInt
3832: oPop 2
3834: oPushResult
3835: oEmitInt
3836: oPop 1
3838: oEmit 11
3840: oGetLocal 3
3842: oPushResult
3843: oEmitInt
3844: oPop 1
3846: oEmit 19
3848: oJumpForward 3853
3850: Choice Lookup Table
           1   3823
3853: oEmit 42
3855: oGetParam 1
3857: oPushResult
3858: oCall 5209
3860: oPop 1
3862: oGetLocal 1
3864: oChoice 3884
3866: oGetLocal 2
3868: oPushResult
3869: oTypeSPush
3870: oPop 1
3872: oEmit 11
3874: oGetLocal 3
3876: oPushResult
3877: oEmitInt
3878: oPop 1
3880: oCall 3191
3882: oJumpForward 3887
3884: Choice Lookup Table
           1   3866
3887: oEmit 41
3889: oGetLocal 5
3891: oPushResult
3892: oEmitInt
3893: oPop 1
3895: oReturn
3896: oLocalSpace 0
3898: oInputChoice 3948
3900: oCall 4851
3902: oJumpForward 3973
3904: oCall 4858
3906: oJumpForward 3973
3908: oCall 4925
3910: oJumpForward 3973
3912: oCall 4928
3914: oJumpForward 3973
3916: oCall 4390
3918: oJumpForward 3973
3920: oCall 4701
3922: oJumpForward 3973
3924: oCall 4456
3926: oJumpForward 3973
3928: oCall 4630
3930: oJumpForward 3973
3932: oCall 4796
3934: oJumpForward 3973
3936: oCall 4764
3938: oJumpForward 3973
3940: oCall 4828
3942: oJumpForward 3973
3944: oCall 3974
3946: oJumpForward 3973
3948: Choice Lookup Table
           0   3944
          33   3940
          49   3936
          50   3932
          47   3928
          42   3924
          46   3920
          39   3916
          58   3912
          57   3908
          56   3904
          55   3900
3973: oReturn
3974: oLocalSpace 1
3976: oGetAddrLocal 1
3978: oPushResult
3979: oScopeFindRequire
3980: oAssign
3981: oGetLocal 1
3983: oPushResult
3984: oNodeType
3985: oPop 1
3987: oChoice 4016
3989: oGetLocal 1
3991: oPushResult
3992: oCall 3534
3994: oPop 1
3996: oJumpForward 4029
3998: oGetLocal 1
4000: oPushResult
4001: oCall 4030
4003: oPop 1
4005: oJumpForward 4029
4007: oGetLocal 1
4009: oPushResult
4010: oCall 4099
4012: oPop 1
4014: oJumpForward 4029
4016: Choice Lookup Table
           8   4007
          15   3998
          13   3998
          12   3998
           7   3989
4027: oError 0
4029: oReturn
4030: oLocalSpace 1
4032: oGetParam 1
4034: oPushResult
4035: oCall 4249
4037: oPop 1
4039: oInput 3
4041: oCall 1613
4043: oCall 4931
4045: oTypeSNodeType
4046: oChoice 4064
4048: oEmit 17
4050: oJumpForward 4097
4052: oEmit 18
4054: oJumpForward 4097
4056: oError 16
4058: oJumpForward 4097
4060: oEmit 19
4062: oJumpForward 4097
4064: Choice Lookup Table
          23   4060
          17   4056
          22   4056
          21   4056
          19   4052
          18   4048
4077: oGetAddrLocal 1
4079: oPushResult
4080: oTypeSTop
4081: oPushResult
4082: oSetResult 2
4084: oPushResult
4085: oNodeGetInt
4086: oPop 2
4088: oAssign
4089: oEmit 20
4091: oGetLocal 1
4093: oPushResult
4094: oEmitInt
4095: oPop 1
4097: oTypeSPop
4098: oReturn
4099: oLocalSpace 1
4101: oGetParam 1
4103: oPushResult
4104: oSetResult 9
4106: oPushResult
4107: oNodeGet
4108: oPop 2
4110: oPushResult
4111: oScopeCurrent
4112: oPushResult
4113: oNodeEqual
4114: oPop 2
4116: oChoice 4122
4118: oError 20
4120: oJumpForward 4125
4122: Choice Lookup Table
           0   4118
4125: oEmit 8
4127: oGetParam 1
4129: oPushResult
4130: oSetResult 11
4132: oPushResult
4133: oNodeGetInt
4134: oPop 2
4136: oPushResult
4137: oEmitInt
4138: oPop 1
4140: oGetParam 1
4142: oPushResult
4143: oSetResult 5
4145: oPushResult
4146: oNodeGet
4147: oPop 2
4149: oPushResult
4150: oTypeSPush
4151: oPop 1
4153: oInput 3
4155: oCall 1613
4157: oCall 4931
4159: oTypeSNodeType
4160: oChoice 4178
4162: oEmit 17
4164: oJumpForward 4211
4166: oEmit 18
4168: oJumpForward 4211
4170: oError 16
4172: oJumpForward 4211
4174: oEmit 19
4176: oJumpForward 4211
4178: Choice Lookup Table
          23   4174
          17   4170
          22   4170
          21   4170
          19   4166
          18   4162
4191: oGetAddrLocal 1
4193: oPushResult
4194: oTypeSTop
4195: oPushResult
4196: oSetResult 2
4198: oPushResult
4199: oNodeGetInt
4200: oPop 2
4202: oAssign
4203: oEmit 20
4205: oGetLocal 1
4207: oPushResult
4208: oEmitInt
4209: oPop 1
4211: oTypeSPop
4212: oReturn
4213: oLocalSpace 1
4215: oInput 0
4217: oGetAddrLocal 1
4219: oPushResult
4220: oScopeFindRequire
4221: oAssign
4222: oGetLocal 1
4224: oPushResult
4225: oNodeType
4226: oPop 1
4228: oChoice 4232
4230: oJumpForward 4241
4232: Choice Lookup Table
          15   4230
          13   4230
          12   4230
4239: oError 4
4241: oGetLocal 1
4243: oPushResult
4244: oCall 4249
4246: oPop 1
4248: oReturn
4249: oLocalSpace 0
4251: oGetParam 1
4253: oPushResult
4254: oNodeType
4255: oPop 1
4257: oChoice 4317
4259: oEmit 10
4261: oGetParam 1
4263: oPushResult
4264: oCall 5209
4266: oPop 1
4268: oJumpForward 4326
4270: oEmit 11
4272: oGetParam 1
4274: oPushResult
4275: oCall 5209
4277: oPop 1
4279: oJumpForward 4326
4281: oGetParam 1
4283: oPushResult
4284: oSetResult 12
4286: oPushResult
4287: oNodeGetBoolean
4288: oPop 2
4290: oChoice 4303
4292: oEmit 8
4294: oGetParam 1
4296: oPushResult
4297: oCall 5209
4299: oPop 1
4301: oJumpForward 4315
4303: Choice Lookup Table
           1   4292
4306: oEmit 12
4308: oGetParam 1
4310: oPushResult
4311: oCall 5209
4313: oPop 1
4315: oJumpForward 4326
4317: Choice Lookup Table
          15   4281
          13   4270
          12   4259
4324: oError 4
4326: oGetParam 1
4328: oPushResult
4329: oSetResult 5
4331: oPushResult
4332: oNodeGet
4333: oPop 2
4335: oPushResult
4336: oTypeSPush
4337: oPop 1
4339: oCall 3226
4341: oReturn
4342: oLocalSpace 0
4344: oGetParam 1
4346: oPushResult
4347: oCall 4249
4349: oPop 1
4351: oCall 4957
4353: oGetParam 1
4355: oPushResult
4356: oCall 2812
4358: oPop 1
4360: oTypeSPop
4361: oEmit 21
4363: oEmit 17
4365: oReturn
4366: oLocalSpace 0
4368: oGetParam 1
4370: oPushResult
4371: oCall 4249
4373: oPop 1
4375: oCall 4957
4377: oGetParam 1
4379: oPushResult
4380: oCall 2812
4382: oPop 1
4384: oTypeSPop
4385: oEmit 22
4387: oEmit 17
4389: oReturn
4390: oLocalSpace 2
4392: oGetAddrLocal 1
4394: oPushResult
4395: oSetResult 0
4397: oAssign
4398: oGetAddrLocal 1
4400: oPushResult
4401: oCall 1636
4403: oPop 1
4405: oInput 40
4407: oCall 3896
4409: oInputChoice 4444
4411: oGetAddrLocal 2
4413: oPushResult
4414: oLabelNew
4415: oAssign
4416: oEmit 45
4418: oGetLocal 2
4420: oPushResult
4421: oEmitLabel
4422: oPop 1
4424: oEmit 48
4426: oGetLocal 1
4428: oPushResult
4429: oEmitLabel
4430: oPop 1
4432: oCall 3896
4434: oEmit 48
4436: oGetLocal 2
4438: oPushResult
4439: oEmitLabel
4440: oPop 1
4442: oJumpForward 4455
4444: Choice Lookup Table
          41   4411
4447: oEmit 48
4449: oGetLocal 1
4451: oPushResult
4452: oEmitLabel
4453: oPop 1
4455: oReturn
4456: oLocalSpace 4
4458: oInput 0
4460: oGetAddrLocal 1
4462: oPushResult
4463: oScopeFindRequire
4464: oAssign
4465: oGetLocal 1
4467: oPushResult
4468: oCall 4249
4470: oPop 1
4472: oCall 4957
4474: oInput 3
4476: oCall 1613
4478: oCall 4957
4480: oEmit 17
4482: oGetAddrLocal 2
4484: oPushResult
4485: oLabelNew
4486: oAssign
4487: oGetAddrLocal 3
4489: oPushResult
4490: oLabelNew
4491: oAssign
4492: oEmit 45
4494: oGetLocal 3
4496: oPushResult
4497: oEmitLabel
4498: oPop 1
4500: oGetAddrLocal 4
4502: oPushResult
4503: oLabelNew
4504: oAssign
4505: oEmit 48
4507: oGetLocal 4
4509: oPushResult
4510: oEmitLabel
4511: oPop 1
4513: oInputChoice 4593
4515: oGetLocal 1
4517: oPushResult
4518: oCall 4342
4520: oPop 1
4522: oEmit 48
4524: oGetLocal 3
4526: oPushResult
4527: oEmitLabel
4528: oPop 1
4530: oGetLocal 1
4532: oPushResult
4533: oCall 2812
4535: oPop 1
4537: oTypeSPop
4538: oCall 1613
4540: oCall 4957
4542: oEmit 34
4544: oEmit 46
4546: oGetLocal 2
4548: oPushResult
4549: oEmitLabel
4550: oPop 1
4552: oJumpForward 4599
4554: oGetLocal 1
4556: oPushResult
4557: oCall 4366
4559: oPop 1
4561: oEmit 48
4563: oGetLocal 3
4565: oPushResult
4566: oEmitLabel
4567: oPop 1
4569: oGetLocal 1
4571: oPushResult
4572: oCall 2812
4574: oPop 1
4576: oTypeSPop
4577: oCall 1613
4579: oCall 4957
4581: oEmit 35
4583: oEmit 46
4585: oGetLocal 2
4587: oPushResult
4588: oEmitLabel
4589: oPop 1
4591: oJumpForward 4599
4593: Choice Lookup Table
          44   4554
          43   4515
4598: oEndChoice
4599: oGetLocal 4
4601: oPushResult
4602: oGetLocal 2
4604: oPushResult
4605: oLoopPush
4606: oPop 2
4608: oInput 45
4610: oCall 3896
4612: oEmit 45
4614: oGetLocal 4
4616: oPushResult
4617: oEmitLabel
4618: oPop 1
4620: oEmit 48
4622: oGetLocal 2
4624: oPushResult
4625: oEmitLabel
4626: oPop 1
4628: oLoopPop
4629: oReturn
4630: oLocalSpace 2
4632: oGetAddrLocal 1
4634: oPushResult
4635: oLabelNew
4636: oAssign
4637: oEmit 48
4639: oGetLocal 1
4641: oPushResult
4642: oEmitLabel
4643: oPop 1
4645: oGetAddrLocal 2
4647: oPushResult
4648: oLabelNew
4649: oAssign
4650: oGetLocal 1
4652: oPushResult
4653: oGetLocal 2
4655: oPushResult
4656: oLoopPush
4657: oPop 2
4659: oCall 3896
4661: oInputChoice 4683
4663: oCall 3896
4665: oJumpForward 4689
4667: oCall 1613
4669: oCall 4984
4671: oEmit 47
4673: oGetLocal 1
4675: oPushResult
4676: oEmitLabel
4677: oPop 1
4679: oJumpForward 4691
4681: oJumpForward 4689
4683: Choice Lookup Table
          48   4667
           4   4663
4688: oEndChoice
4689: oJumpBack 4661
4691: oEmit 48
4693: oGetLocal 2
4695: oPushResult
4696: oEmitLabel
4697: oPop 1
4699: oLoopPop
4700: oReturn
4701: oLocalSpace 2
4703: oGetAddrLocal 1
4705: oPushResult
4706: oLabelNew
4707: oAssign
4708: oEmit 48
4710: oGetLocal 1
4712: oPushResult
4713: oEmitLabel
4714: oPop 1
4716: oGetAddrLocal 2
4718: oPushResult
4719: oLabelNew
4720: oAssign
4721: oGetLocal 1
4723: oPushResult
4724: oGetLocal 2
4726: oPushResult
4727: oLoopPush
4728: oPop 2
4730: oCall 1613
4732: oCall 4984
4734: oInput 45
4736: oEmit 47
4738: oGetLocal 2
4740: oPushResult
4741: oEmitLabel
4742: oPop 1
4744: oCall 3896
4746: oEmit 45
4748: oGetLocal 1
4750: oPushResult
4751: oEmitLabel
4752: oPop 1
4754: oEmit 48
4756: oGetLocal 2
4758: oPushResult
4759: oEmitLabel
4760: oPop 1
4762: oLoopPop
4763: oReturn
4764: oLocalSpace 0
4766: oLoopCycleLabel
4767: oPushResult
4768: oSetResult 0
4770: oPushResult
4771: equal_label
4772: oPop 2
4774: oChoice 4789
4776: oError 18
4778: oJumpForward 4795
4780: oEmit 45
4782: oLoopCycleLabel
4783: oPushResult
4784: oEmitLabel
4785: oPop 1
4787: oJumpForward 4795
4789: Choice Lookup Table
           0   4780
           1   4776
4794: oEndChoice
4795: oReturn
4796: oLocalSpace 0
4798: oLoopExitLabel
4799: oPushResult
4800: oSetResult 0
4802: oPushResult
4803: equal_label
4804: oPop 2
4806: oChoice 4821
4808: oError 18
4810: oJumpForward 4827
4812: oEmit 45
4814: oLoopExitLabel
4815: oPushResult
4816: oEmitLabel
4817: oPop 1
4819: oJumpForward 4827
4821: Choice Lookup Table
           0   4812
           1   4808
4826: oEndChoice
4827: oReturn
4828: oLocalSpace 0
4830: oCall 3896
4832: oInputChoice 4842
4834: oCall 3896
4836: oJumpForward 4848
4838: oJumpForward 4850
4840: oJumpForward 4848
4842: Choice Lookup Table
          34   4838
           4   4834
4847: oEndChoice
4848: oJumpBack 4832
4850: oReturn
4851: oLocalSpace 0
4853: oCall 4858
4855: oEmit 54
4857: oReturn
4858: oLocalSpace 0
4860: oInputChoice 4921
4862: oCall 1613
4864: oTypeSNodeType
4865: oChoice 4887
4867: oEmit 50
4869: oJumpForward 4902
4871: oEmit 51
4873: oJumpForward 4902
4875: oEmit 52
4877: oJumpForward 4902
4879: oError 16
4881: oJumpForward 4902
4883: oEmit 53
4885: oJumpForward 4902
4887: Choice Lookup Table
          23   4883
          17   4879
          21   4879
          22   4875
          19   4871
          18   4867
4900: oError 17
4902: oTypeSPop
4903: oInputChoice 4911
4905: oJumpForward 4919
4907: oJumpForward 4917
4909: oJumpForward 4917
4911: Choice Lookup Table
          12   4909
          14   4905
4916: oEndChoice
4917: oJumpBack 4862
4919: oJumpForward 4924
4921: Choice Lookup Table
          13   4862
4924: oReturn
4925: oLocalSpace 0
4927: oReturn
4928: oLocalSpace 0
4930: oReturn
4931: oLocalSpace 1
4933: oGetAddrLocal 1
4935: oPushResult
4936: oTypeSNodeType
4937: oAssign
4938: oTypeSPop
4939: oGetLocal 1
4941: oPushResult
4942: oTypeSNodeType
4943: oPushResult
4944: equal_node_type
4945: oPop 2
4947: oChoice 4953
4949: oError 14
4951: oJumpForward 4956
4953: Choice Lookup Table
           0   4949
4956: oReturn
4957: oLocalSpace 0
4959: oTypeSNodeType
4960: oChoice 4964
4962: oJumpForward 4969
4964: Choice Lookup Table
          18   4962
4967: oError 7
4969: oTypeSPop
4970: oReturn
4971: oLocalSpace 0
4973: oTypeSNodeType
4974: oChoice 4978
4976: oJumpForward 4983
4978: Choice Lookup Table
          18   4976
4981: oError 7
4983: oReturn
4984: oLocalSpace 0
4986: oTypeSNodeType
4987: oChoice 4991
4989: oJumpForward 4996
4991: Choice Lookup Table
          19   4989
4994: oError 8
4996: oTypeSPop
4997: oReturn
4998: oLocalSpace 0
5000: oTypeSNodeType
5001: oChoice 5005
5003: oJumpForward 5010
5005: Choice Lookup Table
          19   5003
5008: oError 8
5010: oReturn
5011: oLocalSpace 1
5013: oGetAddrLocal 1
5015: oPushResult
5016: oGetParam 2
5018: oPushResult
5019: oNodeNew
5020: oPop 1
5022: oAssign
5023: oGetLocal 1
5025: oPushResult
5026: oSetResult 2
5028: oPushResult
5029: oGetParam 1
5031: oPushResult
5032: oNodeSetInt
5033: oPop 3
5035: oGetLocal 1
5037: oPushResult
5038: oTypeAdd
5039: oPop 1
5041: oGetLocal 1
5043: oReturn
5044: oReturn
5045: oLocalSpace 1
5047: oGetAddrLocal 1
5049: oPushResult
5050: oGetParam 3
5052: oPushResult
5053: oNodeNew
5054: oPop 1
5056: oAssign
5057: oGetLocal 1
5059: oPushResult
5060: oSetResult 4
5062: oPushResult
5063: oGetParam 1
5065: oPushResult
5066: oNodeSetInt
5067: oPop 3
5069: oGetLocal 1
5071: oReturn
5072: oReturn
5073: oLocalSpace 1
5075: oGetAddrLocal 1
5077: oPushResult
5078: oGetParam 1
5080: oPushResult
5081: oSetResult 13
5083: oPushResult
5084: oNodeGet
5085: oPop 2
5087: oAssign
5088: oGetLocal 1
5090: oPushResult
5091: oNodeNull
5092: oPop 1
5094: oChoice 5150
5096: oGetAddrLocal 1
5098: oPushResult
5099: oSetResult 23
5101: oPushResult
5102: oNodeNew
5103: oPop 1
5105: oAssign
5106: oGetLocal 1
5108: oPushResult
5109: oSetResult 14
5111: oPushResult
5112: oGetParam 1
5114: oPushResult
5115: oNodeSet
5116: oPop 3
5118: oGetLocal 1
5120: oPushResult
5121: oSetResult 2
5123: oPushResult
5124: oSetResult 8
5126: oPushResult
5127: oNodeSetInt
5128: oPop 3
5130: oGetLocal 1
5132: oPushResult
5133: oTypeAdd
5134: oPop 1
5136: oGetParam 1
5138: oPushResult
5139: oSetResult 13
5141: oPushResult
5142: oGetLocal 1
5144: oPushResult
5145: oNodeSet
5146: oPop 3
5148: oJumpForward 5153
5150: Choice Lookup Table
           1   5096
5153: oGetLocal 1
5155: oReturn
5156: oReturn
5157: oLocalSpace 0
5159: oGetParam 1
5161: oPushResult
5162: oNodeType
5163: oPop 1
5165: oChoice 5194
5167: oSetResult 0
5169: oReturn
5170: oJumpForward 5208
5172: oSetResult 0
5174: oReturn
5175: oJumpForward 5208
5177: oSetResult 0
5179: oReturn
5180: oJumpForward 5208
5182: oGetParam 1
5184: oPushResult
5185: oSetResult 16
5187: oPushResult
5188: oNodeGetInt
5189: oPop 2
5191: oReturn
5192: oJumpForward 5208
5194: Choice Lookup Table
          25   5182
          21   5177
          19   5172
          18   5167
5203: oError 3
5205: oSetResult 0
5207: oReturn
5208: oReturn
5209: oLocalSpace 0
5211: oGetParam 1
5213: oPushResult
5214: oSetResult 6
5216: oPushResult
5217: oNodeGetInt
5218: oPop 2
5220: oPushResult
5221: oEmitInt
5222: oPop 1
5224: oReturn
5225: oLocalSpace 1
5227: oGetAddrGlobal 2
5229: oPushResult
5230: oSetResult 17
5232: oPushResult
5233: oSetResult 4
5235: oPushResult
5236: oCall 5011
5238: oPop 2
5240: oAssign
5241: oGetAddrGlobal 3
5243: oPushResult
5244: oSetResult 18
5246: oPushResult
5247: oSetResult 4
5249: oPushResult
5250: oCall 5011
5252: oPop 2
5254: oAssign
5255: oGetAddrGlobal 4
5257: oPushResult
5258: oSetResult 19
5260: oPushResult
5261: oSetResult 1
5263: oPushResult
5264: oCall 5011
5266: oPop 2
5268: oAssign
5269: oGetAddrGlobal 5
5271: oPushResult
5272: oSetResult 20
5274: oPushResult
5275: oSetResult 1
5277: oPushResult
5278: oCall 5011
5280: oPop 2
5282: oAssign
5283: oGetAddrGlobal 6
5285: oPushResult
5286: oSetResult 21
5288: oPushResult
5289: oSetResult 1
5291: oPushResult
5292: oCall 5011
5294: oPop 2
5296: oAssign
5297: oGetAddrGlobal 7
5299: oPushResult
5300: oSetResult 22
5302: oPushResult
5303: oSetResult 256
5305: oPushResult
5306: oCall 5011
5308: oPop 2
5310: oAssign
5311: oGetAddrLocal 1
5313: oPushResult
5314: oSetResult 10
5316: oPushResult
5317: oSetResult 5
5319: oPushResult
5320: oIdAdd_File
5321: oPushResult
5322: oCall 5045
5324: oPop 3
5326: oAssign
5327: oGetLocal 1
5329: oPushResult
5330: oSetResult 5
5332: oPushResult
5333: oGetGlobal 2
5335: oPushResult
5336: oNodeSet
5337: oPop 3
5339: oGetLocal 1
5341: oPushResult
5342: oScopeDeclare
5343: oPop 1
5345: oGetAddrLocal 1
5347: oPushResult
5348: oSetResult 10
5350: oPushResult
5351: oSetResult 5
5353: oPushResult
5354: oIdAdd_Integer
5355: oPushResult
5356: oCall 5045
5358: oPop 3
5360: oAssign
5361: oGetLocal 1
5363: oPushResult
5364: oSetResult 5
5366: oPushResult
5367: oGetGlobal 3
5369: oPushResult
5370: oNodeSet
5371: oPop 3
5373: oGetLocal 1
5375: oPushResult
5376: oScopeDeclare
5377: oPop 1
5379: oGetAddrLocal 1
5381: oPushResult
5382: oSetResult 10
5384: oPushResult
5385: oSetResult 5
5387: oPushResult
5388: oIdAdd_Boolean
5389: oPushResult
5390: oCall 5045
5392: oPop 3
5394: oAssign
5395: oGetLocal 1
5397: oPushResult
5398: oSetResult 5
5400: oPushResult
5401: oGetGlobal 4
5403: oPushResult
5404: oNodeSet
5405: oPop 3
5407: oGetLocal 1
5409: oPushResult
5410: oScopeDeclare
5411: oPop 1
5413: oGetAddrLocal 1
5415: oPushResult
5416: oSetResult 10
5418: oPushResult
5419: oSetResult 5
5421: oPushResult
5422: oIdAdd_Char
5423: oPushResult
5424: oCall 5045
5426: oPop 3
5428: oAssign
5429: oGetLocal 1
5431: oPushResult
5432: oSetResult 5
5434: oPushResult
5435: oGetGlobal 6
5437: oPushResult
5438: oNodeSet
5439: oPop 3
5441: oGetLocal 1
5443: oPushResult
5444: oScopeDeclare
5445: oPop 1
5447: oGetAddrLocal 1
5449: oPushResult
5450: oSetResult 10
5452: oPushResult
5453: oSetResult 5
5455: oPushResult
5456: oIdAdd_String
5457: oPushResult
5458: oCall 5045
5460: oPop 3
5462: oAssign
5463: oGetLocal 1
5465: oPushResult
5466: oSetResult 5
5468: oPushResult
5469: oGetGlobal 7
5471: oPushResult
5472: oNodeSet
5473: oPop 3
5475: oGetLocal 1
5477: oPushResult
5478: oScopeDeclare
5479: oPop 1
5481: oGetAddrLocal 1
5483: oPushResult
5484: oSetResult 9
5486: oPushResult
5487: oSetResult 4
5489: oPushResult
5490: oIdAdd_True
5491: oPushResult
5492: oCall 5045
5494: oPop 3
5496: oAssign
5497: oGetLocal 1
5499: oPushResult
5500: oSetResult 5
5502: oPushResult
5503: oGetGlobal 4
5505: oPushResult
5506: oNodeSet
5507: oPop 3
5509: oGetLocal 1
5511: oPushResult
5512: oSetResult 6
5514: oPushResult
5515: oSetResult 1
5517: oPushResult
5518: oNodeSetInt
5519: oPop 3
5521: oGetLocal 1
5523: oPushResult
5524: oScopeDeclare
5525: oPop 1
5527: oGetAddrLocal 1
5529: oPushResult
5530: oSetResult 9
5532: oPushResult
5533: oSetResult 4
5535: oPushResult
5536: oIdAdd_False
5537: oPushResult
5538: oCall 5045
5540: oPop 3
5542: oAssign
5543: oGetLocal 1
5545: oPushResult
5546: oSetResult 5
5548: oPushResult
5549: oGetGlobal 4
5551: oPushResult
5552: oNodeSet
5553: oPop 3
5555: oGetLocal 1
5557: oPushResult
5558: oSetResult 6
5560: oPushResult
5561: oSetResult 0
5563: oPushResult
5564: oNodeSetInt
5565: oPop 3
5567: oGetLocal 1
5569: oPushResult
5570: oScopeDeclare
5571: oPop 1
5573: oReturn
