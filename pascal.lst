   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
 370: FindSelectSystemDecls( Node unit ):
 372:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
 389:       | true :
 390:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 407:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 424:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 441:       | * :
 446:    ]
 447:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 447: Uses( int id, Node user ):
 449:    Node unit = @FindOrCompileUnit( id )
 460:    [ equal_node( unit, Null )
 470:       | false :
 471:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 483:          Node unitRef = oNodeNew( nUnitRef )
 493:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 512:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 531:          oScopeDeclare( unitRef )
 537:       | * :
 542:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 543: ResolveUnitRef( inout Node decl ):
 545:    [ oNodeType( decl )
 552:       | nUnitRef :
 553:          Node scope = oNodeGet( decl, qPublicScope )
 566:          '.'
 568:          pIdent
 570:          decl = oScopeFindRequireInScope( scope )
 580:       | * :
 585:    ];
      
      
 586: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 588:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 601:    {
 601:       Node unit = oNodeIterValue( unitIt )
 611:       [ oNodeNull( unit )
 618:          | false :
 619:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 632:          | * :
 637:             >
 639:       ]
 639:       oNodeIterNext( unitIt )
 645:    }
 648:    ;
      
 648: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 650:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 663:    {
 663:       Node unit = oNodeIterValue( unitIt )
 673:       [ oNodeNull( unit )
 680:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 681:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 697:                | true :
 698:                | false :  #eInternalScopeMismatch
 702:             ]
 710:             oScopeEnd
 711:          | * :
 716:             >
 718:       ]
 718:       oNodeIterPrev( unitIt )
 724:    }
 727:    ;
      
      
 727: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 729:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 748:    [ equal_node( unit, Null )
 758:       | false :  >> unit
 762:       | * :
 767:    ]
      
         % If not, search for the source file on disk
 767:    boolean ok = oIncludeUnitFile( id )
 777:    [ ok
 780:       | false :  #eCantFindUnitFile  >> Null
 786:       | * :
 791:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 791:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 797:    oIncludeEnd
 798:    >> unit;
      
      
      
 802: Unit >> Node:
 804:    pUnit
 806:    pIdent
 808:    Node unit = oNodeNew( nUnit )
 818:    oNodeSetInt( unit, qIdent, LAST_ID )
 829:    Node unitImpl = oNodeNew( nUnitImpl )
 839:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 850:    oNodeSet( unit, qImpl, unitImpl )
 862:    ';'
      
         % mandatory sections
      
 864:    pInterface
 866:    @UsesMySystem( unit )
 873:    [
 873:       | pUses :   @UsesClause( unit )
 882:       | * :
 887:    ]
 887:    @EnterUsedUnits( unit )
      
 894:    oScopeBegin( 0, allocGlobal )
 903:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 914:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 919:    oScopeBegin( 0, allocDown )
 928:    initScope = oScopeCurrent
 933:    oNodeSet( unit, qInitRoutineScope, initScope )
 945:    oScopeEnd
      
 946:    @UnitInterface( unit )
 953:    oScopeEnd  % interface scope
      
 954:    pImplementation
 956:    @UsesMySystem( unitImpl )
 963:    [
 963:       | pUses :   @UsesClause( unitImpl )
 972:       | * :
 977:    ]
 977:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 984:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 997:    oScopeBegin( 0, allocGlobal )
1006:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
1017:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
1035:    globalScope = oScopeCurrent
1040:    @UnitImplementation( unit )
      
1047:    [
1047:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
1059:       | * :                @UnitInitialization( unit, false )  % implicit init routine
1074:    ]
1074:    [
1074:       | pFinalization :  @UnitFinalization( unit, true )
1086:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1101:    ]
1101:    pEnd  '.'
      
1105:    oScopeEnd  % impl scope
1106:    oScopeEnd  % interface scope
1107:    @EndUsedUnits( unitImpl )  % used units scopes
1114:    @EndUsedUnits( unit )
1121:    oNodeAddLast( workspace, qUnits, unit )
1133:    >> unit;
      
      
1137: UnitInterface( Node unit ):
1139:    {[
1139:       | pConst :     @ConstDecl
1143:       | pType :      @TypeDecl
1147:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1156:       | pProcedure :
1158:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1164:          [
1164:             | pExternal :
1166:                @ExternalDecl( decl )
1173:                ';'
1175:             | * :
1180:          ]
      
1180:       | pFunction :
1182:          Node decl = @FuncHeaderDecl
1188:          [
1188:             | pExternal :
1190:                @ExternalDecl( decl )
1197:                ';'
1199:             | * :
1204:          ]
      
1204:       | * :          >
1219:    ]}
1221:    @FindSelectSystemDecls( unit )
1229:    ;
      
1229: UnitImplementation( Node unit ):
1231:    @BlockDecls( nGlobalVar )
1239:    ;
      
      
1239: UnitInitialization( Node unit, boolean hasStmts ):
1241:    Label label = oLabelNew
1246:    .tLabel  oEmitLabel( label )
1254:    oNodeSetLabel( unit, qInitLabel, label )
      
1266:    int patchLS
1266:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1275:    Node scope
1275:    Code initCode
      
1275:    scope = oNodeGet( unit, qPublicScope )
1288:    initCode = oNodeGetCode( scope, qInitCode )
1301:    oEmitCode( initCode )
1307:    oNodeSetCode( scope, qInitCode, codeNull )
      
1319:    scope = oNodeGet( unit, qPrivateScope )
1332:    initCode = oNodeGetCode( scope, qInitCode )
1345:    oEmitCode( initCode )
1351:    oNodeSetCode( scope, qInitCode, codeNull )
      
1363:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1376:    [ hasStmts
1379:       | true :     
1380:          @Statement
1382:          {[
1382:             | ';' :  @Statement
1386:             | * :    >
1393:          ]}
1395:       | * :
1400:    ]
      
1400:    .tReturn
      
1402:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1414:    oPatch( patchLS, localSpace )
1423:    oScopeEnd   % init routine scope, for temporaries
1425:    ;
      
      
1425: UnitFinalization( Node unit, boolean hasStmts ):
1427:    Label label = oLabelNew
1432:    .tLabel  oEmitLabel( label )
1440:    oNodeSetLabel( unit, qFinalLabel, label )
      
1452:    int patchLS
1452:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1461:    oScopeBegin( 0, allocDown )
      
1470:    [ hasStmts
1473:       | true :     
1474:          @Statement
1476:          {[
1476:             | ';' :  @Statement
1480:             | * :    >
1487:          ]}
1489:       | * :
1494:    ]
      
1494:    .tReturn
      
1496:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1508:    oPatch( patchLS, localSpace )
1517:    oScopeEnd   % final routine scope, for temporaries
1519:    ;
      
      
1519: Block( node_type varNodeType, Label labelForBody ):
1521:    @BlockDecls( varNodeType )
1528:    @BlockStmt( labelForBody, oScopeCurrent, false )
1540:    @CheckForUndefinedLabels
1543:    ;
      
      
1543: BlockDecls( node_type varNodeType ):
1545:    {[
1545:       | pConst :     @ConstDecl
1549:       | pType :      @TypeDecl
1553:       | pVar :       @VarDecl( varNodeType )
1562:       | pLabel :     @LabelDecl
1566:       | pProcedure : @ProcDecl
1570:       | pFunction :  @FuncDecl
1574:       | * :          >
1591:    ]}
1593:    @CheckForUndefinedMethods
1596:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1596: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1599:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1599: CheckForUndefinedLabels:
1601:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1613:    {
1613:       Node decl = oNodeIterValue( it )
1623:       [ oNodeNull( decl )
1630:          | false :
1631:          | * :  >
1638:       ]
1638:       [ oNodeType( decl )
1645:          | nLabel :
1646:             [ oNodeGetBoolean( decl, qDefined )
1656:                | false :
1657:                   [ oNodeGetBoolean( decl, qUsed )
1667:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1670:                      | * :
1675:                   ]
1675:                | * :
1680:             ]
1680:          | * :
1685:       ]
1685:       oNodeIterNext( it )
1691:    }
1694:    ;
      
      
1694: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1696:    NodeIter it = oNodeGetIter( workspace, qUnits )
1709:    {
1709:       Node unit = oNodeIterValue( it )
1719:       [ oNodeNull( unit )
1726:          | true :  >
1729:          | false :
1731:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1739:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1754:             .tFreeActuals  oEmitInt( 0 )
1762:             oNodeIterNext( it )
1768:       ]
1776:    };
      
      
1779: FinalizeUnits:
1781:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1794:    {
1794:       Node unit = oNodeIterValue( it )
1804:       [ oNodeNull( unit )
1811:          | true :  >
1814:          | false :
1816:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1824:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1839:             .tFreeActuals  oEmitInt( 0 )
1847:             oNodeIterPrev( it )
1853:       ]
1861:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1864: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1866:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1874:    int patchLS
1874:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1883:    [ isMain
1886:       | true :  @InitializeUnits
1889:       | * :
1894:    ]
      
         % insert any code for initialization of this scope's variables
1894:    Code initCode = oNodeGetCode( varScope, qInitCode )
1907:    oEmitCode( initCode )
1913:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1925:    @Statement
      
1927:    [ isMain
1930:       | true :  @FinalizeUnits
1933:       | * :
1938:    ]
      
1938:    .tReturn
      
1940:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1952:    oPatch( patchLS, localSpace )
1962:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1962: MethodModifiers( Node decl ):
1964:    {[
1964:       | pCdecl :
1966:          oNodeSetBoolean( decl, qCdecl, true )
1978:          ';'
      
1980:       | * : >
1987:    ]}
1990:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1990: GetOrCreateInitCode( Node scope ) >> Code:
1992:    Code initCode = oNodeGetCode( scope, qInitCode )
2005:    [ equal_code( initCode, codeNull )
2015:       | true :
2016:          initCode = oCodeNew
2021:          oNodeSetCode( scope, qInitCode, initCode )
2033:       | * :
2038:    ]
2038:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
2042: ExternalDecl( Node decl ):
2044:    [ equal_zero( @DeclLevel( decl ) )
2056:       | false :  #eExternalMethodCannotBeNested
2059:       | * :
2064:    ]
2064:    oNodeSetBoolean( decl, qExternal, true )
2076:    [
2076:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
2078:          [
2078:             | pName :
2080:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
2082:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2093:             | * :
2098:          ]
2098:       | * :
2103:    ]
2104:    ;
      
      
2104: ProcHeaderDecl >> Node:
2106:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2108:    boolean redeclaring = false
2114:    Node decl = oScopeFindInCurrentScope
      
2119:    [ oNodeNull( decl )
2126:       | true :
               % first declaration
2127:          decl = @newIdent( nProc, LAST_ID )
2140:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2151:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2153:          redeclaring = true
2159:          [ oNodeGetBoolean( decl, qBodyDefined )
2169:             | true : #eAlreadyDefined
2172:             | * :
2177:          ]
2177:          [ oNodeGetBoolean( decl, qExternal )
2187:             | true : #eAlreadyDefined
2190:             | * :
2195:          ]
2195:          [ oNodeType( decl )
2202:             | nProc :
2203:             | * : #eAlreadyDefined   % wrong kind
2210:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2210:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2229:          oNodeSet( decl, qParams, Null )
2241:    ]
      
2249:    int level = @ScopeLevel
2255:    boolean nested = greater( level, 0 )
2268:    inc( level )
2274:    oScopeBegin( level, allocUp )
2283:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2288:    [ nested
2291:       | true :
2292:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2307:       | * :
2312:    ]
      
2312:    @FormalArgDecl
2314:    oNodeSet( decl, qParams, paramScope )
2326:    oScopeEnd
2327:    ';'
      
2329:    [ redeclaring
2332:       | false : oScopeDeclare( decl )
2339:       | true :  % TO DO: check that qParams is consistent with qOldParams
2341:    ]
      
2349:    @MethodModifiers( decl )
2356:    >> decl;
      
      
2360: ProcDecl:
2362:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2368:    [
2368:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2370:       | pExternal : @ExternalDecl( decl )
      
2379:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2386:          Node paramScope = oNodeGet( decl, qParams )
2399:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2405:          int level = oNodeGetInt( paramScope, qLevel )
2418:          oScopeBegin( level, allocDown )
2427:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2438:          Label label = oNodeGetLabel( decl, qValue )
2451:          @Block( nLocalVar, label )
2461:          oNodeSetBoolean( decl, qBodyDefined, true )
2473:          oScopeEnd
      
2474:          oScopeEnd  % paramScope
2475:    ]
2475:    ';';
      
      
      
2478: FuncHeaderDecl >> Node:
2480:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2482:    boolean redeclaring = false
2488:    Node decl = oScopeFindInCurrentScope
      
2493:    [ oNodeNull( decl )
2500:       | true :
               % first declaration
2501:          decl = @newIdent( nFunc, LAST_ID )
2514:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2525:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2527:          redeclaring = true
2533:          [ oNodeGetBoolean( decl, qBodyDefined )
2543:             | true : #eAlreadyDefined
2546:             | * :
2551:          ]
2551:          [ oNodeType( decl )
2558:             | nFunc :
2559:             | * : #eAlreadyDefined   % wrong kind
2566:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2566:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2585:          oNodeSet( decl, qParams, Null )
2597:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2616:          oNodeSet( decl, qType, Null )
2628:    ]
      
2636:    int level = @ScopeLevel
2642:    boolean nested = greater( level, 0 )
2655:    inc( level )
2661:    oScopeBegin( level, allocUp )
2670:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2675:    [ nested
2678:       | true :
2679:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2694:       | * :
2699:    ]
      
2699:    @FormalArgDecl
2701:    oNodeSet( decl, qParams, paramScope )
      
2713:    ':'
      
2715:    Node theType
2715:    @TypeRef( theType )
2722:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2734:    Node ptrType = @PointerTypeTo( theType )
2745:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2761:    oScopeEnd
2762:    ';'
      
2764:    [ redeclaring
2767:       | false : oScopeDeclare( decl )
2774:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2776:    ]
      
2784:    @MethodModifiers( decl )
      
2791:    >> decl;
      
      
2795: FuncDecl:
2797:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2803:    [
2803:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2805:       | pExternal : @ExternalDecl( decl )
      
2814:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2821:          Node paramScope = oNodeGet( decl, qParams )
2834:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2840:          int level = oNodeGetInt( paramScope, qLevel )
2853:          oScopeBegin( level, allocDown )
2862:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2873:          Label label = oNodeGetLabel( decl, qValue )
2886:          @Block( nLocalVar, label )
2896:          oNodeSetBoolean( decl, qBodyDefined, true )
2908:          oScopeEnd
      
2909:          oScopeEnd  % paramScope
2910:    ]
2910:    ';';
      
      
2913: FormalArgDecl:
2915:    [
2915:       | '(' :
2917:          {
2917:             NodeVec decls = oNodeVecNew
2922:             Node decl
2922:             boolean isInOut = false
      
2928:             [
2928:                | pVar : isInOut = true
2936:                | * :
2941:             ]
      
2941:             {  pIdent
      
2943:                decl = @newIdent( nParam, LAST_ID )
2956:                oNodeSetBoolean( decl, qInOut, isInOut )
2968:                oNodeVecAppend( decls, decl )
      
2977:                [
2977:                   | ':' : >
2981:                   | ',' :
2983:                ]
2991:             }
      
2993:             Node theType
2993:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
3000:             Node allocType
3000:             [ isInOut
3003:                | true :   allocType = @PointerTypeTo( theType )
3015:                | * :      allocType = theType
3026:             ]
      
3026:             int i = 0
3032:             {[ equal( i, oNodeVecSize( decls ) )
3046:                | false :
3047:                   decl = oNodeVecElement( decls, i )
      
3060:                   oNodeSet( decl, qType, theType )
3072:                   oScopeDeclare( decl )
3078:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3094:                   inc( i )
3100:                | * :
3105:                   >
3107:             ]}
      
3109:             oNodeVecDelete( decls )
      
3115:             [
3115:                | ')' : >
3119:                | ';' :
3121:             ]
3129:          }
3131:       | * :
3136:    ];
      
      
3137: ConstDecl:
3139:    {[
3139:       | pIdent :
3141:          [
3141:             | ':' :
3143:                @TypedConstDecl
3145:             | * :
3150:                @TrueConstDecl
3152:          ]
3152:       | * :
3157:          >
3159:    ]};
      
      
      % Parse a true const declaration (as opposed to a typed const declaration).
      % The "true" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
3162: TrueConstDecl:
3164:    Node decl = @newIdent( nConst, LAST_ID )
3177:    '='
      
3179:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3181:    int val = oValueTop
3186:    oValuePop
3187:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3199:    oNodeSet( decl, qType, IntegerType )
      
3211:    oScopeDeclare( decl )
3217:    ';'
3220:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3220: TypedConstDecl:
3222:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3235:    Node theType
3235:    @TypeRef( theType )
3242:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3254:    [ oNodeType( theType )
3261:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType :
               % Parse expression and store value in decl
3262:          '='
      
3264:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3266:          int val = oValueTop
3271:          oValuePop
3272:          oNodeSetInt( decl, qValue, val )
3284:          oScopeDeclare( decl )
3290:          ';'
      
3292:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3294:          #eNotImplemented
      
3296:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3298:          oScopeEnter( globalScope )
3304:          int addr = oScopeAllocType( theType )
3314:          oScopeEnd
3315:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3326:          oNodeSetInt( decl, qValue, addr )
3338:          '='
3340:          @TypedConstInit( theType, addr )
3350:          oCodePop
3351:          oScopeDeclare( decl )
3357:          ';'
3359:    ]
3386:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3386: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3388:    [ oNodeType( theType )
3395:       | nArrayType :
3396:          Node baseType = oNodeGet( theType, qBaseType )
3409:          Node indexType = oNodeGet( theType, qIndexType )
3422:          int low = @OrdinalLow( indexType )
3433:          int high = @OrdinalHigh( indexType )
3444:          int elementSize = oNodeGetInt( baseType, qSize )
      
3457:          '('
               % Loop over elements
3459:          int i = low
3465:          {
3465:             @TypedConstInit( baseType, addr )
3475:             [ equal( i, high )
3485:                | true : >
3488:                | false :
3490:             ]
3498:             ','
3500:             addr = add( addr, elementSize )
3513:             inc( i )
3519:          }
3521:          ')'
      
3523:       | nRecordType :
3525:          '('
3527:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3540:          {
3540:             [
3540:                | pIdent :
3542:                | * :  >
3549:             ]
3549:             Node field = oScopeFindRequireInScope( fieldScope )
3559:             ':'
3561:             Node fieldType = oNodeGet( field, qType )
3574:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3594:             @TypedConstInit( fieldType, fieldAddr )
3604:             [
3604:                | ';' :
3606:                | * :  >
3613:             ]
3613:          }
3615:          ')'
      
3617:       | nBooleanType, nByteType, nCharType:
3619:          .tPushAddrGlobal  oEmitInt( addr )
3627:          @ConstExpr
3629:          .tPushConstI  oEmitInt( oValueTop )
3636:          oValuePop
3637:          .tAssignB
      
3639:       | nIntegerType, nEnumType:
3641:          .tPushAddrGlobal  oEmitInt( addr )
3649:          @ConstExpr
3651:          .tPushConstI  oEmitInt( oValueTop )
3658:          oValuePop
3659:          .tAssignI
      
3661:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3663:          #eNotImplemented
3665:    ]
3692:    ;
      
      
3692: TypeDecl:
3694:    {[
3694:       | pIdent :
3696:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3709:          '='
3711:          Node theType
3711:          @TypeRef( theType )
3718:          oNodeSet( decl, qType, theType )
3730:          oScopeDeclare( decl )
3736:          ';'
3738:       | * :
3743:          >
3745:    ]};
      
3748: VarDecl( node_type varNodeType ):
3750:    {[
3750:       | pIdent :
3752:          NodeVec decls = oNodeVecNew
3757:          Node decl
3757:          {
3757:             decl = @newIdent( varNodeType, LAST_ID )
3770:             oNodeVecAppend( decls, decl )
3779:             [
3779:                | ',' :
3781:                   pIdent
3783:                | * :
3788:                   >
3790:             ]
3790:          }
3792:          ':'
3794:          Node theType
3794:          @TypeRef( theType )
      
3801:          int i = 0
3807:          {[ equal( i, oNodeVecSize( decls ) )
3821:             | false :
3822:                decl = oNodeVecElement( decls, i )
3835:                oNodeSet( decl, qType, theType )
3847:                oScopeDeclareAlloc( decl )
3853:                inc( i )
3859:             | * :
3864:               >
3866:          ]}
      
               % optional initialization
3868:          [
3868:             | '=' :
3870:                [ oNodeVecSize( decls )
3877:                   | 1 :
3878:                   | * :  #eOnlyOneVarCanBeInitialized
3885:                ]
      
                     % we need an initCode stream for this scope
3885:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3895:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3901:                boolean changedScope = false
3907:                [ equal_zero( @ScopeLevel )
3914:                   | true : oScopeEnter( initScope )
3921:                            changedScope = true
3927:                   | * :
3932:                ]
                     % generate assignment in initCode stream
3932:                @LValueVar( decl, true )
3942:                @Expr
3944:                @CoerceType
3946:                @Assign
3948:                [ changedScope
3951:                   | true : oScopeEnd
3953:                   | * :
3958:                ]
3958:                oCodePop
                   
3959:             | * :
3964:          ]
      
3964:          oNodeVecDelete( decls )
3970:          ';'
3972:       | * :
3977:          >
3979:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3982: LabelDecl:
3984:    {
3984:       Node decl
3984:       [
3984:          | pIdent :
3986:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3988:             oChangeIntLitToLabelIdent
3989:       ]
3997:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
4010:       Label label = oLabelNew
4015:       oNodeSetLabel( decl, qValue, label )
4027:       oScopeDeclare( decl )
4033:       [
4033:          | ',' :
4035:          | * :
4040:             >
4042:       ]
4042:    }
4044:    ';'
4047:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
4047: TypeRef( out Node resultType ):
4049:    [
4049:       | pIdent :           % previously named type (including intrinsics)
4051:          Node decl = oScopeFindRequire
4056:          @ResolveUnitRef( decl )
4063:          [ oNodeType( decl )
4070:             | nTypeDecl :
4071:                resultType = oNodeGet( decl, qType )
4084:             | * :
4089:                #eNotType
4091:                resultType = IntegerType
4097:          ]
         
4097:       | pArray :
4099:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4101:          NodeVec dimensions = oNodeVecNew
      
4106:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4106:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4116:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4128:             @ConstExpr
4130:             oNodeSetInt( subrange, qLow, oValueTop )
4141:             oValuePop
4142:             '..'
4144:             @ConstExpr
4146:             oNodeSetInt( subrange, qHigh, oValueTop )
4157:             oValuePop
4158:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4170:             oTypeAdd( subrange )
      
4176:             Node a = oNodeNew( nArrayType )
4186:             oNodeSet( a, qIndexType, subrange )
      
4198:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4207:             [
4207:                | ']' : >
4211:                | ',' :
4213:             ]
4221:          }
      
4223:          pOf
4225:          Node baseType
4225:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4232:          int dim = oNodeVecSize( dimensions )
      
4242:          {
4242:              dec(dim)
      
4248:              Node a = oNodeVecElement( dimensions, dim )
      
4261:              oNodeSet( a, qBaseType, baseType )
4273:              Node subrange = oNodeGet( a, qIndexType )
4286:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4313:              inc( width )
4319:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4345:              oTypeAdd( a )
4351:              baseType = a
      
4357:              [ equal_zero(dim)
4364:                  | true:  >
4367:                  | *:
4372:              ]
4372:          }
      
4374:          resultType = oNodeVecElement( dimensions, 0 )
4387:          oNodeVecDelete( dimensions )
      
4393:       | '^' :
4395:          Node theType
4395:          @TypeRef( theType )
4402:          resultType = @PointerTypeTo( theType )
      
4413:       | pRecord :
4415:          resultType = oNodeNew( nRecordType )
4425:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4434:          @VarDecl( nRecordField )
      
4441:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4453:          [ equal_zero( size )
4460:             | true : #eRecordEmpty
4463:             | * :
4468:          ]
      
4468:          pEnd
      
4470:          oNodeSet( resultType, qScope, oScopeCurrent )
4481:          oNodeSetInt( resultType, qSize, size )
4493:          oScopeEnd
4494:          oTypeAdd( resultType )
      
      
4500:       | '(' :
               % An enum type declaration.
4502:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4509:       | pSet :
4511:          pOf
4513:          Node theType
4513:          @TypeRef( theType )
4520:       | * :       % this works for cases except where expr starts with an id
4535:          @ConstExpr '..' @ConstExpr
4541:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4542: EnumTypeRef( out Node resultType ):
      
4544:    resultType = oNodeNew( nEnumType )
4554:    int value = 0
4560:    int numValues = 0
4566:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4572:    Node outerScope = oScopeCurrent
4577:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4586:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4586:       pIdent
4588:       Node decl = @newIdent( nEnumValue, LAST_ID )
4601:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4614:       oNodeSet( decl, qType, resultType )
4626:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4638:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4651:       oNodeSetInt( decl, qNameOffset, nameOffset )
4663:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4675:       [
4675:          | '=', ':=' :
4677:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4679:             [ equal_zero( numValues )
4686:                | false :
4687:                   [ greater( oValueTop, value )
4696:                      | false :   #eEnumValueNotAscending
4699:                      | * :
4704:                   ]
4704:                | * :
4709:             ]
4709:             [ equal( value, oValueTop )
4718:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4719:                   oNodeSetBoolean( resultType, qHasGap, true )
4731:                | * :
4736:             ]
4736:             value = oValueTop
4741:             oValuePop
4742:          | * :
4749:       ]
4749:       oNodeSetInt( decl, qValue, value )
4761:       oNodeSetInt( decl2, qValue, value )
4773:       oScopeDeclare( decl )
      
4779:       oScopeEnter( outerScope )
4785:       oScopeDeclare( decl2 )
4791:       oScopeEnd
      
4792:       inc( value )
4798:       inc( numValues )
4804:       [
4804:          | ',' :
4806:          | * :    >
4813:       ]
4813:    }
4815:    ')'
      
4817:    oNodeSet( resultType, qScope, oScopeCurrent )
4828:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4840:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4841:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4852:    oScopeEnter( globalScope )
4858:    int size = multiply( add( numValues, 1 ), 16 )
4878:    int addr = oScopeAlloc( size, 8 )
4891:    oScopeEnd
4892:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4904:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4924:    {
4924:       Node enumValue = oNodeIterValue( it )
4934:       [ oNodeNull( enumValue )
4941:          | true :  >
4944:          | * :
4949:       ]
4949:       .tPushAddrGlobal  oEmitInt( addr )
4957:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4972:       .tAssignI
4974:       addr = add( addr, 8 )
4987:       .tPushAddrGlobal  oEmitInt( addr )
4995:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
5010:       .tAssignP
5012:       addr = add( addr, 8 )
5025:       oNodeIterNext( it )
5031:    }
         % final table entry
5033:    .tPushAddrGlobal  oEmitInt( addr )
5041:    .tPushConstI  oEmitInt( 0 )
5049:    .tAssignI
5051:    addr = add( addr, 8 )
5064:    .tPushAddrGlobal  oEmitInt( addr )
5072:    .tPushConstI  oEmitInt( 0 )
5080:    .tAssignP
5082:    addr = add( addr, 8 )
5095:    oCodePop
      
5096:    oTypeAdd( resultType )
5103:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      %
      % The value of a constant expression is left on the Value Stack.
      % Currently we don't return the type of the constant expression.  TO DO: leave it on the type stack.
      
5103: ConstExpr:
5105:    @ConstBoolExpr
5107:    {[
5107:       | '=' :
5109:          @ConstBoolTerm
5111:          oValueEqual
5112:       | '<>' :
5114:          @ConstBoolExpr
5116:          oValueNotEqual
5117:       | '<' :
5119:          @ConstBoolExpr
5121:          oValueLess
5122:       | '>' :
5124:          @ConstBoolExpr
5126:          oValueGreater
5127:       | '<=' :
5129:          @ConstBoolExpr
5131:          oValueLessEqual
5132:       | '>=' :
5134:          @ConstBoolExpr
5136:          oValueGreaterEqual
5137:       | * :  >
5154:    ]};
      
      
5157: ConstBoolExpr:
5159:    @ConstBoolTerm
5161:    {[
5161:       | pOr :
5163:          @ConstBoolTerm
5165:          oValueOr
5166:       | * :  >
5173:    ]};
      
      
5176: ConstBoolTerm:
5178:    @ConstBoolFactor
5180:    {[
5180:       | pAnd :
5182:          @ConstBoolFactor
5184:          oValueAnd
5185:       | * :  >
5192:    ]};
      
      
5195: ConstBoolFactor:
5197:    [
5197:       | pNot :
5199:          @ConstBoolFactor
5201:          oValueNot
5202:       | * :
5207:          @ConstArithExpr
5209:    ];
      
      
5210: ConstArithExpr:
5212:    @ConstTerm
5214:    {[
5214:       | '+' :
5216:          @ConstTerm
5218:          oValueAdd
5219:       | '-' :
5221:          @ConstTerm
5223:          oValueSub
5224:       | * :  >
5233:    ]};
      
      
5236: ConstTerm:
5238:    @ConstFactor
5240:    {[
5240:       | pTimes :
5242:          @ConstFactor
5244:          oValueMult
5245:       | pDivide :
5247:          @ConstFactor
5249:          oValueDiv
5250:       | * :  >
5259:    ]};
      
      
5262: ConstFactor:
5264:    [
5264:       | pPlus :
5266:          @ConstPrimary
5268:       | pMinus :
5270:          @ConstPrimary
5272:          oValueNegate
5273:       | * :
5280:          @ConstPrimary
5282:    ];
      
      
5283: ConstPrimary:
5285:    [
5285:       | pIntLit :
5287:          oValuePush( TOKEN_VALUE )
5292:       | pCharLit, pStrLit :  #eNotImplemented
5296:       | '(' :
5298:          @ConstExpr
5300:          ')'
5302:       | pIdent :
5304:          Node decl = oScopeFindRequire
5309:          @ResolveUnitRef( decl )
5316:          [ oNodeType( decl )
5323:             | nBuiltInFunc :
5324:                @ConstBuiltInFunc( decl )
5331:             | nConst, nEnumValue :
5333:                oValuePush( oNodeGetInt( decl, qValue ) )
5346:             | * :
5355:                #eNotConst
5357:                oValuePush( 0 )
5363:          ]
5363:       | '@' :
5365:          #eNotImplemented
5367:       | * :
5382:          #eNotConst
5384:    ];
      
      
5385: ConstBuiltInFunc( Node decl ):
5387:    #eNotImplemented
5390:    ;
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5390: Expr:
5392:    Label falseLabel = labelNull
      
5398:    @ExprAllowFlow( falseLabel )
5405:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5413: BooleanExprControlFlow( out Label falseLabel ):
5415:    @ExprAllowFlow( falseLabel )
5422:    [ oTypeSNodeType
5424:       | nBooleanFlowType :
5425:       | nBooleanType :
               % convert value to control flow
5427:          falseLabel = oLabelNew
5432:          .tJumpFalse  oEmitLabel( falseLabel )
5440:       | * :
5447:          #eNotBoolean
5449:    ]
5449:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5451: FlowToVal( inout Label falseLabel ):
5453:    [ oTypeSNodeType
5455:       | nBooleanFlowType :
5456:          Label doneLabel = oLabelNew
5461:          .tPushConstI  oEmitInt( 1 )
5469:          .tJump  oEmitLabel( doneLabel )
5477:          .tLabel  oEmitLabel( falseLabel )
5485:          .tPushConstI  oEmitInt( 0 )
5493:          .tLabel  oEmitLabel( doneLabel )
5501:          oTypeSPop
5502:          oTypeSPush( BooleanType )
5508:          falseLabel = labelNull
5514:       | * :
5519:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5520: ValToFlow( out Label falseLabel ):
5522:    [ oTypeSNodeType
5524:       | nBooleanType :
5525:          falseLabel = oLabelNew
5530:          .tJumpFalse  oEmitLabel( falseLabel )
5538:          oTypeSPop
5539:          oTypeSPush( BooleanFlowType )
5545:       | * :
5550:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5551: ExprAllowFlow( out Label falseLabel ):
5553:    @BoolExprAllowFlow( falseLabel )
5560:    {[
5560:       | '=' :
5562:          @FlowToVal( falseLabel )
5569:          @PromoteToIntOptional
5571:          @BoolExprAllowFlow( falseLabel )
5578:          @FlowToVal( falseLabel )
5585:          @PromoteToIntOptional
5587:          @MatchTypes
5589:          [ oTypeSNodeType
5591:             | nBooleanType, nCharType :     .tEqualB
5594:             | nIntegerType, nEnumType :     .tEqualI
5598:             | nPointerType, nUniversalPointerType :    .tEqualP
5602:             | nShortStringType, nStrLitType :
5604:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5616:             | * :                           #eNotAllowed
5637:          ]
5637:          oTypeSPop
5638:          oTypeSPush( BooleanType )
      
5644:       | '<>' :
5646:          @FlowToVal( falseLabel )
5653:          @PromoteToIntOptional
5655:          @BoolExprAllowFlow( falseLabel )
5662:          @FlowToVal( falseLabel )
5669:          @PromoteToIntOptional
5671:          @MatchTypes
5673:          [ oTypeSNodeType
5675:             | nBooleanType, nCharType :     .tNotEqualB
5678:             | nIntegerType, nEnumType :     .tNotEqualI
5682:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5686:             | nShortStringType, nStrLitType :
5688:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5700:             | * :                           #eNotAllowed
5721:          ]
5721:          oTypeSPop
5722:          oTypeSPush( BooleanType )
      
5728:       | '<' :
5730:          @FlowToVal( falseLabel )
5737:          @PromoteToIntOptional
5739:          @BoolExprAllowFlow( falseLabel )
5746:          @FlowToVal( falseLabel )
5753:          @PromoteToIntOptional
5755:          @MatchTypes
5757:          [ oTypeSNodeType
5759:             | nBooleanType, nCharType :     .tLessB
5762:             | nIntegerType, nEnumType :     .tLessI
5766:             | nPointerType, nUniversalPointerType :   .tLessP
5770:             | nShortStringType, nStrLitType :
5772:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5784:             | * :                           #eNotAllowed
5805:          ]
5805:          oTypeSPop
5806:          oTypeSPush( BooleanType )
      
5812:       | '>' :
5814:          @FlowToVal( falseLabel )
5821:          @PromoteToIntOptional
5823:          @BoolExprAllowFlow( falseLabel )
5830:          @FlowToVal( falseLabel )
5837:          @PromoteToIntOptional
5839:          @MatchTypes
5841:          [ oTypeSNodeType
5843:             | nBooleanType, nCharType :     .tGreaterB
5846:             | nIntegerType, nEnumType :     .tGreaterI
5850:             | nPointerType, nUniversalPointerType :   .tGreaterP
5854:             | nShortStringType, nStrLitType :
5856:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5868:             | * :                           #eNotAllowed
5889:          ]
5889:          oTypeSPop
5890:          oTypeSPush( BooleanType )
      
5896:       | '<=' :
5898:          @FlowToVal( falseLabel )
5905:          @PromoteToIntOptional
5907:          @BoolExprAllowFlow( falseLabel )
5914:          @FlowToVal( falseLabel )
5921:          @PromoteToIntOptional
5923:          @MatchTypes
5925:          [ oTypeSNodeType
5927:             | nBooleanType, nCharType :     .tLessEqualB
5930:             | nIntegerType, nEnumType :     .tLessEqualI
5934:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5938:             | nShortStringType, nStrLitType :
5940:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5952:             | * :                           #eNotAllowed
5973:          ]
5973:          oTypeSPop
5974:          oTypeSPush( BooleanType )
      
5980:       | '>=' :
5982:          @FlowToVal( falseLabel )
5989:          @PromoteToIntOptional
5991:          @BoolExprAllowFlow( falseLabel )
5998:          @FlowToVal( falseLabel )
6005:          @PromoteToIntOptional
6007:          @MatchTypes
6009:          [ oTypeSNodeType
6011:             | nBooleanType, nCharType :     .tGreaterEqualB
6014:             | nIntegerType, nEnumType :     .tGreaterEqualI
6018:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
6022:             | nShortStringType, nStrLitType :
6024:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
6036:             | * :                           #eNotAllowed
6057:          ]
6057:          oTypeSPop
6058:          oTypeSPush( BooleanType )
      
6064:       | * :
6079:          >
6081:    ]};
      
      
6084: BoolExprAllowFlow( out Label falseLabel ):
6086:    Label trueLabel = labelNull
      
6092:    @BoolTermAllowFlow( falseLabel )
6099:    {[
6099:       | pOr :
6101:          [ oTypeSNodeType
6103:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
6104:                [ equal_label( trueLabel, labelNull )
6114:                   | true :  trueLabel = oLabelNew
6120:                   | * :
6125:                ]
6125:                .tJump  oEmitLabel( trueLabel )
6133:             | nBooleanType :
6135:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
6142:                [ equal_label( trueLabel, labelNull )
6152:                   | true :  trueLabel = oLabelNew
6158:                   | * :
6163:                ]
6163:                .tJump  oEmitLabel( trueLabel )
6171:             | * : #eNotBoolean
6180:          ]
6180:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
6181:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
6189:          falseLabel = labelNull
6195:          @BoolTermAllowFlow( falseLabel )
      
6202:          [ oTypeSNodeType
6204:             | nBooleanFlowType :
6205:             | nBooleanType :
6207:                @ValToFlow( falseLabel )
6214:             | * : #eNotBoolean
6223:          ]
      
6223:          oTypeSPop
6224:          oTypeSPush( BooleanFlowType )
      
6230:       | * :
6235:          >
6237:    ]}
      
         % any short-circuit trues jump here to the end
6239:    [ equal_label( trueLabel, labelNull )
6249:       | false :
6250:          .tLabel  oEmitLabel( trueLabel )
6258:       | * :
6263:    ]
6264:    ;
      
      
6264: BoolTermAllowFlow( out Label falseLabel ):
6266:    Label overallFalseLabel = labelNull
      
6272:    @BoolFactorAllowFlow( falseLabel )
6279:    {[
6279:       | pAnd :
6281:          [ oTypeSNodeType
6283:             | nBooleanFlowType :
6284:             | nBooleanType :
6286:                @ValToFlow( falseLabel )
6293:             | * :
6300:                #eNotBoolean
6302:          ]
6302:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6303:          [ equal_label( overallFalseLabel, labelNull )
6313:             | true :
6314:                overallFalseLabel = oLabelNew
6319:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6333:                falseLabel = overallFalseLabel
6339:             | * :
6344:          ]
      
6344:          Label factorFalseLabel = labelNull
6350:          @BoolFactorAllowFlow( factorFalseLabel )
      
6357:          [ oTypeSNodeType
6359:             | nBooleanFlowType :
6360:             | nBooleanType :
6362:                @ValToFlow( factorFalseLabel )
6369:             | * : #eNotBoolean
6378:          ]
6378:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6392:       | * :
6397:          >
6399:    ]};
      
6402: BoolFactorAllowFlow( out Label falseLabel ):
6404:    [
6404:       | pNot :
6406:          Label factorFalseLabel = labelNull
      
6412:          @BoolFactorAllowFlow( factorFalseLabel )
6419:          [ oTypeSNodeType
6421:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6422:                falseLabel = oLabelNew
6427:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6435:                .tLabel  oEmitLabel( factorFalseLabel )
      
6443:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6445:                .tNot
      
6447:             | * : #eNotBoolean
6456:          ]
      
6456:       | * :
6461:          @ArithExprAllowFlow( falseLabel )
6468:    ];
      
6469: ArithExprAllowFlow( out Label falseLabel ):
6471:    boolean first = true
6477:    int tempStrOffset
      
6477:    @TermAllowFlow( falseLabel )
6484:    {[
6484:       | '+' :
6486:          [ oTypeSNodeType
6488:             | nIntegerType, nByteType :
6489:                @PromoteToIntPop
6491:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6498:                [ oTypeSNodeType
6500:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6501:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6503:                      @PointerAddition
6505:                   | * :
6512:                      @PromoteToInt
6514:                      .tAddI
6516:                ]
      
6516:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6518:                [ first
6521:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6522:                             tempStrOffset = @MoveIntoTempShortString
6528:                             first = false
6534:                   | * :
6539:                ]
6539:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6546:                [ oTypeSNodeType
6548:                   | nShortStringType, nStrLitType :
6549:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6551:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6559:                      oTypeSPush( ShortStringType )
6565:                   | nCharType :
6567:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6569:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6577:                      oTypeSPush( ShortStringType )
6583:                   | * :
6592:                      #eTypeMismatch
6594:                      oTypeSPop
6595:                ]
      
6595:             | nPointerType, nUniversalPointerType :
6597:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6604:                @PromoteToIntPop
6606:                @PointerAddition
      
6608:             | * :
6625:                #eNotAllowed
6627:          ]
      
6627:       | '-' :
6629:          [ oTypeSNodeType
6631:             | nIntegerType, nByteType :
6632:                @PromoteToIntPop
6634:                @TermAllowFlow( falseLabel )
6641:                @PromoteToInt
6643:                .tSubI
      
6645:             | nPointerType, nUniversalPointerType :
6647:                @TermAllowFlow( falseLabel )
6654:                [ oTypeSNodeType
6656:                   | nIntegerType, nByteType :
6657:                      @PromoteToIntPop
6659:                      @PointerSubInt
6661:                   | nPointerType, nUniversalPointerType :
6663:                      @MatchTypes
6665:                      @PointerSubPointer
6667:                   | * :
6678:                      #eNotAllowed
6680:                ]
      
6680:             | * :  #eNotAllowed
      
6693:          ]
6693:       | * :
6700:          >
6702:    ]};
      
6705: TermAllowFlow( out Label falseLabel ):
6707:    @FactorAllowFlow( falseLabel )
6714:    {[
6714:       | pTimes :
6716:          @PromoteToIntPop
6718:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6725:          @PromoteToInt
6727:          .tMultI
6729:       | pDivide :
6731:          @PromoteToIntPop
6733:          @FactorAllowFlow( falseLabel )
6740:          @PromoteToInt
6742:          .tDivI
6744:       | * :
6751:          >
6753:    ]};
      
6756: FactorAllowFlow( out Label falseLabel ):
6758:    [
6758:       | pPlus :
6760:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6767:          @PromoteToInt
6769:       | pMinus :
6771:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6778:          @PromoteToInt
6780:          .tNegI
6782:       | * :
6789:          @PrimaryAllowFlow( falseLabel )
6796:    ];
      
6797: PrimaryAllowFlow( out Label falseLabel ):
6799:    [
6799:       | pIntLit :
6801:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6808:          oTypeSPush( IntegerType )
      
6814:       | pCharLit :
6816:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6823:          oTypeSPush( CharType )
      
6829:       | '(' :
6831:          @ExprAllowFlow( falseLabel )
6838:          ')'
      
6840:       | pStrLit :
6842:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6851:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6859:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6865:          @LValueIndexes
               % get final value of dereferencing, if any
6867:          @FetchVar
      
6869:       | pIdent :
6871:          Node decl = oScopeFindRequire
6876:          @ResolveUnitRef( decl )
6883:          Node theType
      
6883:          [ oNodeType( decl )
6890:             | nFunc :
6891:                @Call( decl )
      
6898:             | nBuiltInFunc :
6900:                @CallBuiltInFunc( decl )
      
6907:             | nConst, nEnumValue :
6909:                theType = oNodeGet( decl, qType )
6922:                oTypeSPush( theType )
6928:                [ oTypeSNodeType
6930:                   | nIntegerType, nEnumType, nBooleanType :
6931:                      .tPushConstI @EmitValue( decl )
6940:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6942:                      .tPushConstI @EmitValue( decl )
6951:                   | * :
6964:                      #eNotImplemented
6966:                ]
      
6966:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6968:                @VarExpr( decl )
      
6975:             | * :
6994:                #eNotValue
6996:                oTypeSPush( IntegerType )
7002:          ]
      
7002:       | '@' :        % @var -- pointer to var
7004:          pIdent
      
7006:          Node decl = oScopeFindRequire
7011:          @ResolveUnitRef( decl )
7018:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
7018:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7028:          theType = oTypeSTop
7033:          oTypeSPop
7034:          Node ptrType = @PointerTypeTo( theType )
7045:          oTypeSPush( ptrType )
      
7051:       | * :
7066:          #eNotValue
7068:          oTypeSPush( IntegerType )
7074:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7075: VarExpr( Node decl ):
7077:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7090:    int uplevels = @DeclUpLevels( decl )
      
7101:    oTypeSPush( theType )
7107:    [ oTypeSNodeType
7109:       | nIntegerType, nEnumType :
7110:          [ oNodeType( decl )
7117:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7127:             | nLocalVar :
7129:                [ equal_zero( uplevels )
7136:                   | true :  .tPushLocalI  @EmitValue( decl )
7146:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7166:                ]
7166:             | nParam :
7168:                [ oNodeGetBoolean( decl, qInOut )
7178:                   | true :    % VAR param points to the var.  Auto dereference.
7179:                      [ equal_zero( uplevels )
7186:                         | true :  .tPushParamP  @EmitValue( decl )
7196:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7216:                      ]
7216:                      .tFetchI
7218:                   | * :
7223:                      [ equal_zero( uplevels )
7230:                         | true :  .tPushParamI  @EmitValue( decl )
7240:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7260:                      ]
7260:                ]
7260:          ]
      
7272:       | nBooleanType, nByteType, nCharType :
7274:          [ oNodeType( decl )
7281:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7291:             | nLocalVar :
7293:                [ equal_zero( uplevels )
7300:                   | true :  .tPushLocalB  @EmitValue( decl )
7310:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7330:                ]
7330:             | nParam :
7332:                [ oNodeGetBoolean( decl, qInOut )
7342:                   | true :    % VAR param points to the var.  Auto dereference.
7343:                      [ equal_zero( uplevels )
7350:                         | true :  .tPushParamP  @EmitValue( decl )
7360:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7380:                      ]
7380:                      .tFetchB
7382:                   | * :
7387:                      [ equal_zero( uplevels )
7394:                         | true :  .tPushParamB  @EmitValue( decl )
7404:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7424:                      ]
7424:                ]
7424:          ]
      
7436:       | nFileType :
7438:          #eNotImplemented
      
7440:       | nPointerType, nUniversalPointerType :
7442:          [ oNodeType( decl )
7449:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7459:             | nLocalVar :
7461:                [ equal_zero( uplevels )
7468:                   | true :  .tPushLocalP  @EmitValue( decl )
7478:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7498:                ]
7498:             | nParam :
7500:                [ oNodeGetBoolean( decl, qInOut )
7510:                   | true :    % VAR param points to the var.  Auto dereference.
7511:                      [ equal_zero( uplevels )
7518:                         | true :  .tPushParamP  @EmitValue( decl )
7528:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7548:                      ]
7548:                      .tFetchP
7550:                   | * :
7555:                      [ equal_zero( uplevels )
7562:                         | true :  .tPushParamP  @EmitValue( decl )
7572:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7592:                      ]
7592:                ]               
7592:          ]
7604:          [
7604:             | '^' :             % dereferenced
7606:                oTypeSPop
7607:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7620:                @LValueIndexes
7622:                @FetchVar
7624:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7626:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7628:                @LValueIndexes
7630:                @FetchVar
7632:             | * :               % just ptr value alone
7639:          ]
      
7639:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7641:          [ oNodeType( decl )
7648:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7658:             | nLocalVar :
7660:                [ equal_zero( uplevels )
7667:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7677:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7697:                ]
7697:             | nParam :
7699:                [ oNodeGetBoolean( decl, qInOut )
7709:                   | true :    % VAR param points to the var.  Auto dereference.
7710:                      [ equal_zero( uplevels )
7717:                         | true :  .tPushParamP  @EmitValue( decl )
7727:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7747:                      ]
7747:                   | * :
7752:                      [ equal_zero( uplevels )
7759:                         | true :  .tPushAddrParam  @EmitValue( decl )
7769:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7789:                      ]
7789:                ]
7789:          ]
               % modify addr for subscripts, field references, etc
7801:          @LValueIndexes
               % get final value
7803:          @FetchVar
7805:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7832: FetchVar:
7834:    [ oTypeSNodeType
7836:       | nIntegerType, nEnumType :  .tFetchI
7839:       | nBooleanType, nByteType, nCharType :  .tFetchB
7843:       | nFileType :   #eNotImplemented
7847:       | nPointerType :             .tFetchP
7851:       | nUniversalPointerType :    #eCantDereference
7855:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7857:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7886: LValueIndexes:
7888:    {[
7888:       | '[' :
7890:          [ oTypeSNodeType
7892:             | nArrayType :    @ArraySubscripts
7895:             | nPointerType :  @PointerArraySubscript
7899:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7903:             | * :             #eNotArray
7916:          ]
7916:       | '.' :       @RecordFieldRef
7920:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7924:       | * :         >
7935:    ]};
      
7938: ArraySubscripts:
7940:    [ oTypeSNodeType
7942:       | nArrayType :
7943:       | * :       #eNotArray
7950:    ]
7950:    {
7950:       [ oTypeSNodeType
7952:          | nArrayType :
7953:          | * :    #eTooManySubscripts
7960:       ]
      
            % low subscript of this dimension
7960:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7977:       Node baseType
7977:       baseType = oNodeGet( oTypeSTop, qBaseType )
7989:       oTypeSPop
7990:       oTypeSPush( baseType )
      
7996:       @Expr
7998:       @RequireIntPop
            % adjust for low subscript
8000:       [ equal_zero( low )
8007:          | false :
8008:             .tPushConstI oEmitInt( low ) .tSubI
8018:          | * :
8023:       ]
      
            % multiply by element size
8023:       int size = oNodeGetInt( baseType, qSize )
8036:       [ equal( size, 1 )
8046:          | false :
8047:             .tPushConstI oEmitInt( size ) .tMultI
8057:          | * :
8062:       ]
      
            % update start address
8062:       .tAddPI
8064:       [
8064:          | ']' :  >
8068:          | ',' :
8070:       ]
8078:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8081: PointerArraySubscript:
8083:    [ oTypeSNodeType
8085:       | nPointerType :
8086:       | * :    #eCantDereference
8093:    ]
         % replace type stack with base type
8093:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8105:    oTypeSPop
8106:    oTypeSPush( baseType )
         
8112:    @Expr
8114:    @RequireIntPop
         % multiply by element size
8116:    int size = oNodeGetInt( baseType, qSize )
8129:    [ equal( size, 1 )
8139:       | false :
8140:          .tPushConstI  oEmitInt( size )  .tMultI
8150:       | * :
8155:    ]
         % update start address
8155:    .tAddPI
8157:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8160: ShortStringArraySubscript:
8162:    [ oTypeSNodeType
8164:       | nStrLitType, nShortStringType :
8165:       | * :    #eCantDereference
8174:    ]
8174:    oTypeSPop
8175:    oTypeSPush( CharType )
8181:    @Expr
8183:    @RequireIntPop
8185:    .tAddPI
8187:    ']';
      
      
8190: RecordFieldRef:
8192:    [ oTypeSNodeType
8194:       | nRecordType :
8195:       | * :    #eNotRecord
8202:    ]
8202:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8214:    pIdent
8216:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8221:    [ oNodeType( field )
8228:       | nRecordField :
8229:       | * :   #eNotRecordField
8236:    ]
8236:    oScopeEnd
8237:    int offset = oNodeGetInt( field, qValue )
8250:    [ equal_zero( offset )
8257:       | false :
8258:          .tPushConstI oEmitInt( offset ) .tAddPI
8268:       | * :
8273:    ]
      
         % replace the type on the type stack, with the field type
8273:    oTypeSPop
8274:    oTypeSPush( oNodeGet( field, qType ) )
8288:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8288: PointerAddition:
8290:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8302:    int elementSize = oNodeGetInt( elementType, qSize )
8315:    [ equal( elementSize, 1 )
8325:       | false :
8326:          .tPushConstI  oEmitInt( elementSize )
8334:          .tMultI
8336:       | * :
8341:    ]
8341:    .tAddPI
8344:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8344: PointerSubInt:
8346:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8358:    int elementSize = oNodeGetInt( elementType, qSize )
8371:    [ equal( elementSize, 1 )
8381:       | false :
8382:          .tPushConstI  oEmitInt( elementSize )
8390:          .tMultI
8392:       | * :
8397:    ]
8397:    .tSubPI
8400:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8400: PointerSubPointer:
8402:    .tSubP
8404:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8416:    int elementSize = oNodeGetInt( elementType, qSize )
8429:    [ equal( elementSize, 1 )
8439:       | false :
8440:          .tPushConstI  oEmitInt( elementSize )
8448:          .tDivI
8450:       | * :
8455:    ]
8455:    oTypeSPop
8456:    oTypeSPush( IntegerType )
8463:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8463: PointerDeref:
8465:    [ oTypeSNodeType
8467:       | nPointerType :
8468:       | nUniversalPointerType :   #eCantDereference
8472:       | * :       #eNotPointer
8481:    ]
8481:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8483:    Node theType = oTypeSTop
8488:    oTypeSPop
8489:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8503:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8503: CoerceType:
8505:    node_type nt = oTypeSNodeType
8510:    oTypeSPop
8511:    [ equal_node_type( nt, oTypeSNodeType )
8520:       | false :
               % Can we implicitly convert the value to the desired type?
8521:          [ oTypeSNodeType
8523:             | nIntegerType :
8524:                [ nt
8527:                   | nByteType :   .tCastBtoI  >>
8531:                   | * :
8536:                ]
8536:             | nByteType :
8538:                [ nt
8541:                   | nIntegerType :   .tCastItoB  >>
8545:                   | * :
8550:                ]
8550:             | nPointerType :
8552:                [ nt
8555:                   | nUniversalPointerType :  >>
8557:                   | nStrLitType :
8559:                      [ equal_node( oTypeSTop, PCharType )
8568:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8569:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8580:                         | * :
8585:                      ]
8585:                   | * :
8592:                ]
8592:             | nUniversalPointerType :
8594:                [ nt
8597:                   | nPointerType :  >>
8599:                   | * :
8604:                ]
8604:             | nShortStringType :
8606:                [ nt
8609:                   | nStrLitType :  >>
8611:                   | nCharType :
                           % Store char as a temp ShortString.
8613:                      oTypeSPush( CharType )
8619:                      int tempOffset = @MoveIntoTempShortString
8625:                      oTypeSPop
8626:                      >>
8627:                   | * :
8634:                ]
8634:             | * :
8647:          ]
8647:          #eTypeMismatch
8649:       | * :
8654:    ];
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
8655: MoveIntoTempShortString >> int:
8657:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
8667:    [ oTypeSNodeType
8669:       | nShortStringType, nStrLitType :
8670:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
8678:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
8680:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
8695:       | nCharType :
               % temp[0] = 1
8697:          .tPushAddrLocal  oEmitInt( tempOffset )
8705:          .tPushConstI  oEmitInt( 1 )
8713:          .tAssignB
               % temp[1] = value
8715:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
8730:          .tSwap
8732:          .tAssignB
8734:       | * :   #eTypeMismatch
8745:    ]
8745:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
8746:    .tPushAddrLocal  oEmitInt( tempOffset )
8754:    oTypeSPush( ShortStringType )
8760:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8764: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
8766:    .tAllocActuals  oEmitInt( 16 )
8774:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
8786:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8798:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
8807:    .tFreeActuals  oEmitInt( 16 )
8815:    oTypeSPop
8816:    oTypeSPop
8818:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8818: ShortStringAppendChar:
         % Note at the moment I don't align params
8820:    .tAllocActuals  oEmitInt( 12 )
8828:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
8840:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8852:    .tCall  @EmitValue( System_ShortStringAppendChar )
8861:    .tFreeActuals  oEmitInt( 12 )
8869:    oTypeSPop
8870:    oTypeSPop
8872:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
8872: ShortStringCmp:
8874:    .tAllocActuals  oEmitInt( 24 )
8882:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
8894:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8906:    int tempOffset = oScopeAllocType( IntegerType )
8916:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
8934:    .tCall  @EmitValue( System_ShortStringCmp )
8943:    .tPushLocalI  oEmitInt( tempOffset )
8951:    .tFreeActuals  oEmitInt( 24 )
8959:    oTypeSPop
8960:    oTypeSPush( IntegerType )
8967:    ;
      
      
      % Called on first use of an extern method
      %
8967: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
8969:    int strAddr
8969:    String externalName = oNodeGetString( method, qExternalName )
8982:    [ equal_string( externalName, stringNull )
8992:       | true :
8993:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
9014:       | false :
9016:          strAddr = oStringAllocLit( externalName )
9026:    ]
9034:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
9050:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9050: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
9052:    [ oNodeGetBoolean( method, qExternal )
9062:       | true :
9063:          [ oNodeGetBoolean( method, qUsed )
9073:             | false :
                     % define the extern label on first use
9074:                @DefineExternLabel( method )
9081:             | * :
9086:          ]
9086:      | * :
9091:    ]
9091:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
9103:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
9116:    Node resultType
9116:    int tempOffset
      
9116:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
9133:    [ isFunc
9136:       | true :
9137:          resultType = oNodeGet( method, qType )
9150:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
9160:       | * :
9165:    ]
         
      
9165:    Node paramScope = oNodeGet( method, qParams )
9178:    int actualsSize = oNodeGetInt( paramScope, qSize )
9191:    [ cdecl
9194:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
9203:       | false :  .tAllocActuals  oEmitInt( actualsSize )
9213:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
9221:    [ greater( @DeclLevel( method ), 0 )
9236:       | true :
9237:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
9245:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
9264:          .tAssignP
9266:       | * :
9271:    ]
      
      
9271:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
9284:    Node param = oNodeIterValue( paramIter )
9294:    [
9294:       | '(' :
            
9296:          {
9296:             [ oNodeNull( param )
9303:                | true : >
9306:                | * :
9311:             ]
      
9311:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
9324:             .tPushAddrActual oEmitInt( offset )
9332:             oTypeSPush( oNodeGet( param, qType ) )
      
9345:             [ oNodeGetBoolean( param, qInOut )
9355:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
9356:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
9363:                           @MatchTypes
      
9365:                           .tAssignP
      
9367:                | false :  @Expr
9371:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
9373:                           [ oTypeSNodeType
9375:                              | nIntegerType, nEnumType : .tAssignI
9378:                              | nBooleanType, nByteType, nCharType :  .tAssignB
9382:                              | nFileType :   #eNotImplemented
9386:                              | nPointerType, nUniversalPointerType :  .tAssignP
9390:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
9392:                                  int size = oNodeGetInt( oTypeSTop, qSize )
9404:                                  .tCopy  oEmitInt( size )    % multi-word copy
9412:                           ]
9438:             ]
9446:             oTypeSPop
      
9447:             oNodeIterNext( paramIter )
9453:             param = oNodeIterValue( paramIter )
9463:             [ oNodeNull( param )
9470:                | true :  >
9473:                | false :
9475:             ]
      
9483:             ','
9485:          }
      
9487:          ')'
      
9489:       | * :
9494:    ]
      
9494:    [ oNodeNull( param )
9501:       | false :    #eMissingParameter
9504:       | * :
9509:    ]
      
9509:    [ isFunc
9512:       | true :
               % Pass result temp as an additional VAR parameter.
9513:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
9528:          .tPushAddrLocal  oEmitInt( tempOffset )
9536:          .tAssignP
9538:       | * :
9543:    ]
      
9543:    [ cdecl
9546:       | true :
9547:          .tCallCdecl  @EmitValue( method )
9556:       | false :
9558:          .tCall   @EmitValue( method )
9567:    ]
      
9575:    [ isFunc
9578:       | true :
               % push return value from temp
9579:          oTypeSPush( resultType )
      
9585:          [ oTypeSNodeType
9587:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
9596:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
9606:             | nFileType :  #eNotImplemented
9610:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
9620:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
9622:                                .tPushAddrLocal  oEmitInt( tempOffset )
9630:          ]
9656:       | * :
9661:    ]
         
9661:    .tFreeActuals  oEmitInt( actualsSize )
9670:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9670: CallBuiltInFunc( Node method ):
      
         % Ord(x)
9672:    [ oNodeEqual( method, BuiltIn_Ord )
9682:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
9683:          '('
9685:          @Expr
9687:          [ oTypeSNodeType
9689:             | nIntegerType, nEnumType :
9690:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
9694:             | * :  #eTypeMismatch
9709:          ]
9709:          oTypeSPop
9710:          oTypeSPush( IntegerType )
9716:          ')'
9718:          >>
9719:       | * :
9724:    ]
      
         % Chr(x)
9724:    [ oNodeEqual( method, BuiltIn_Chr )
9734:       | true :
               % parameter is integer
               % result is char
9735:          '('
9737:          @Expr
9739:          [ oTypeSNodeType
9741:             | nIntegerType :    .tCastItoB
9744:             | nByteType :
9746:             | * :  #eTypeMismatch
9755:          ]
9755:          oTypeSPop
9756:          oTypeSPush( CharType )
9762:          ')'
9764:          >>
9765:       | * :
9770:    ]
      
         % Pred(x)
9770:    [ oNodeEqual( method, BuiltIn_Pred )
9780:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9781:          '('
9783:          @Expr
9785:          [ oTypeSNodeType
9787:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9788:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9797:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9800:                   | * :
9805:                ]
9805:             | * :  #eTypeMismatch
9812:          ]
9812:          .tDecI
9814:          ')'
9816:          >>
9817:       | * :
9822:    ]
      
         % Succ(x)
9822:    [ oNodeEqual( method, BuiltIn_Succ )
9832:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9833:          '('
9835:          @Expr
9837:          [ oTypeSNodeType
9839:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9840:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9849:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9852:                   | * :
9857:                ]
9857:             | * :  #eTypeMismatch
9864:          ]
9864:          .tIncI
9866:          ')'
9868:          >>
9869:       | * :
9874:    ]
      
9874:    #eNotImplemented
9877:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
9877: Statement:
9879:    [
9879:       | pWriteln :     @WritelnStmt
9883:       | pWrite :       @WriteStmt
9887:       | pReadln :      @ReadlnStmt
9891:       | pRead :        @ReadStmt
9895:       | pIf :          @IfStmt
9899:       | pWhile :       @WhileStmt
9903:       | pFor :         @ForStmt
9907:       | pRepeat :      @RepeatStmt
9911:       | pBreak :       @BreakStmt
9915:       | pContinue :    @ContinueStmt
9919:       | pBegin :       @BeginStmt
9923:       | pIdent :       @LabelOrAssignOrCallStmt
9927:       | pCase :        @CaseStmt
9931:       | pGoto :        @GotoStmt
9935:       | pIntLit :      % should be an integer label
9937:                        oChangeIntLitToLabelIdent
9938:                        @LabelOrAssignOrCallStmt
9940:       | * :            % null statement : don't accept any tokens
9973:    ];
      
      
9974: LabelOrAssignOrCallStmt:
9976:    Node decl = oScopeFindRequire
9981:    @ResolveUnitRef( decl )
9988:    [ oNodeType( decl )
9995:       | nLabel :                          @LabelDefinition( decl )
10003:                                           @Statement
10005:       | nProc :                           @Call( decl )
10014:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
10023:       | nFunc :                           @AssignResultStmt( decl )
10032:       | * :                               #eBadStatement
10049:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
10050: LabelDefinition( Node decl ):
10052:    [ oNodeGetBoolean( decl, qDefined )
10062:       | true :  #eAlreadyDefined
10065:       | * :
10070:    ]
10070:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10085:    oNodeSetBoolean( decl, qDefined, true )
10097:    ':'
10100:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
10100: AssignStmt( Node decl ):
      
10102:    @LValueVar( decl, true )
10112:    ':=' 
10114:    @Expr
10116:    @CoerceType
10118:    @Assign
10121:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
10121: Assign:
10123:    [ oTypeSNodeType
10125:       | nIntegerType, nEnumType :  .tAssignI
10128:       | nBooleanType, nByteType, nCharType :  .tAssignB
10132:       | nFileType :   #eNotImplemented
10136:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10140:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
10142:           int size = oNodeGetInt( oTypeSTop, qSize )
10154:           .tCopy  oEmitInt( size )    % multi-word copy
10162:    ]
10188:    oTypeSPop
10190:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
10190: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
10192:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
10208:       | false :   #eNotCurrentFunction
10211:       | * :
10216:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
10216:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
10231:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
10244:    ':='
10246:    @Expr
10248:    @CoerceType
10250:    [ oTypeSNodeType
10252:       | nIntegerType, nEnumType : .tAssignI
10255:       | nBooleanType, nByteType, nCharType :  .tAssignB
10259:       | nFileType :   #eNotImplemented
10263:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
10267:       | nArrayType, nRecordType, nShortStringType :
10269:           int size = oNodeGetInt( oTypeSTop, qSize )
10281:           .tCopy  oEmitInt( size )    % multi-word copy
10289:    ]
10315:    oTypeSPop
10317:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
10317: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
10319:    pIdent
10321:    Node decl = oScopeFindRequire
10326:    @ResolveUnitRef( decl )
10333:    [ oNodeType( decl )
10340:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
10341:       | * :  #eNotVar
10354:    ]
10354:    @LValueVar( decl, writeable )
10365:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10365: LValueVar( Node decl, boolean writeable ):
10367:    [ oNodeType( decl )
10374:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10384:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10395:       | nParam :
10397:          [ oNodeGetBoolean( decl, qInOut )
10407:             | true :   % VAR param points to variable.  No dereference.
10408:                        .tPushParamP @EmitValue( decl )
10417:             | * :      .tPushAddrParam @EmitValue( decl )
10431:          ]
10431:       | nTypedConst :
10433:          [ writeable
10436:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10446:             | * :      #eNotVar
10453:          ]
10453:       | * :            #eNotVar
10466:    ]
      
10466:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10479:    [ oTypeSNodeType
10481:       | nPointerType :
10482:          [
10482:             | '[' :
                     % dereference the pointer var first
10484:                .tFetchP
10486:                @PointerArraySubscript
10488:             | * :
10493:          ]
10493:       | * :
10498:    ]
         % additional subscripts, if any
10498:    @LValueIndexes
10501:    ;
      
      
10501: IncVar( Node decl ):
10503:    @LValueVar( decl, true )
10513:    @RequireIntPop
10515:    @VarExpr( decl )
10522:    oTypeSPop
10523:    .tIncI
10525:    .tAssignI;
      
10528: DecVar( Node decl ):
10530:    @LValueVar( decl, true )
10540:    @RequireIntPop
10542:    @VarExpr( decl )
10549:    oTypeSPop
10550:    .tDecI
10552:    .tAssignI;
      
      
10555: IfStmt:
10557:    Label falseLabel = labelNull
      
10563:    @BooleanExprControlFlow( falseLabel )
10570:    pThen
10572:    @Statement
10574:    [
10574:       | pElse :
10576:          Label doneLabel = oLabelNew
      
10581:          .tJump  oEmitLabel( doneLabel )
10589:          .tLabel oEmitLabel( falseLabel )
10597:          @Statement
10599:          .tLabel oEmitLabel( doneLabel )
      
10607:       | * :
10612:          .tLabel oEmitLabel( falseLabel )
10620:    ];
      
      
10621: ForStmt:
10623:    pIdent
      
10625:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10630:    @LValueVar( decl, true )
10640:    @RequireIntPop
      
10642:    ':='
      
10644:    @Expr
10646:    @RequireIntPop
10648:    .tAssignI
      
10650:    Label breakLabel = oLabelNew
      
10655:    Label checkLabel = oLabelNew
10660:    .tJump  oEmitLabel( checkLabel )
      
10668:    Label continueLabel = oLabelNew
10673:    .tLabel  oEmitLabel( continueLabel )
10681:    [
10681:       | pTo :
10683:          @IncVar( decl )
10690:          .tLabel  oEmitLabel( checkLabel )
10698:          @VarExpr( decl )  oTypeSPop
10706:          @Expr
10708:          @RequireIntPop
10710:          .tGreaterI
10712:          .tJumpTrue  oEmitLabel( breakLabel )
10720:       | pDownto :
10722:          @DecVar( decl )
10729:          .tLabel  oEmitLabel( checkLabel )
10737:          @VarExpr( decl )  oTypeSPop
10745:          @Expr
10747:          @RequireIntPop
10749:          .tLessI
10751:          .tJumpTrue  oEmitLabel( breakLabel )
10759:    ]
10767:    oLoopPush( continueLabel, breakLabel )
10776:    pDo
10778:    @Statement
10780:    .tJump  oEmitLabel( continueLabel )
10788:    .tLabel  oEmitLabel( breakLabel )
10796:    oLoopPop;
      
      
10798: RepeatStmt:
10800:    Label continueLabel = oLabelNew
10805:    .tLabel  oEmitLabel( continueLabel )
      
10813:    Label breakLabel = oLabelNew
      
10818:    oLoopPush( continueLabel, breakLabel )
10827:    @Statement
10829:    {[
10829:       | ';' :
10831:          @Statement
10833:       | pUntil :
10835:          Label falseLabel
10835:          @BooleanExprControlFlow( falseLabel )
10842:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10856:          >
10858:    ]}
10868:    .tLabel  oEmitLabel( breakLabel )
10876:    oLoopPop;
      
      
10878: WhileStmt:
10880:    Label continueLabel = oLabelNew
10885:    .tLabel  oEmitLabel( continueLabel )
      
10893:    Label breakLabel
10893:    @BooleanExprControlFlow( breakLabel )
      
10900:    oLoopPush( continueLabel, breakLabel )
10909:    pDo
10911:    @Statement
10913:    .tJump  oEmitLabel( continueLabel )
10921:    .tLabel  oEmitLabel( breakLabel )
10929:    oLoopPop;
      
      
10931: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10933:    [ equal_label( oLoopContinueLabel, labelNull )
10942:       | true :
10943:          #eNotInALoop
10945:       | false :
10947:          .tJump  oEmitLabel( oLoopContinueLabel )
10954:    ];
      
      
10963: BreakStmt:
10965:    [ equal_label( oLoopBreakLabel, labelNull )
10974:       | true :
10975:          #eNotInALoop
10977:       | false :
10979:          .tJump  oEmitLabel( oLoopBreakLabel )
10986:    ];
      
      
10995: CaseStmt:
10997:    Code tableCode = oCodeNew
11002:    Label tableLabel = oLabelNew
11007:    Label doneLabel = oLabelNew
11012:    Label otherwiseLabel = doneLabel
      
11018:    @Expr
11020:    Node theType = oTypeSTop
11025:    [ oTypeSNodeType
11027:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
11036:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
11046:       | nShortStringType, nStrLitType :        #eNotImplemented
11050:       | * :     #eNotAllowed
11069:    ]
11069:    pOf
      
11071:    {
11071:       [
11071:          | pOtherwise, pElse :
11073:             otherwiseLabel = oLabelNew
11078:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
11086:             {[
11086:                | pEnd :  >
11090:                | * :
11095:                   @Statement
11097:                   [
11097:                      | ';' :
11099:                      | * :   pEnd  >
11108:                   ]
11108:             ]}
11110:             >
      
11112:          | pEnd :
                  % Reached end with no otherwise clause
11114:             >
      
11116:          | * :
11125:             Label caseLabel = oLabelNew
11130:             oCodePush( tableCode )
11136:             {
11136:                @ConstExpr
                     % TO DO: currently ConstExpr leaves int result on oValue stack, and doesn't indicate type
                     % TO DO: match type with earlier expr.  Including coercing char to string if necessary.
11138:                int val = oValueTop
11143:                oValuePop
11144:                [
11144:                   | '..' :  @ConstExpr
11148:                             int highval = oValueTop
11153:                             oValuePop
11154:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11174:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11193:                ]
11193:                [
11193:                   | ',' :
11195:                   | * :  >
11202:                ]
11202:             }
11204:             oCodePop
11205:             ':'
11207:             .tLabel  oEmitLabel( caseLabel )
11215:             @Statement
11217:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11225:             [
11225:                | ';' :
11227:                | * :
11232:             ]
                  
11232:       ]
         
11232:    }
      
11234:    .tLabel  oEmitLabel( tableLabel )
11242:    oEmitCode( tableCode )
11248:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11256:    .tLabel  oEmitLabel( doneLabel )
11265:    ;
      
      
11265: GotoStmt:
11267:    [
11267:       | pIdent :
11269:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11271:          oChangeIntLitToLabelIdent
11272:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11280:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11289:    oNodeSetBoolean( decl, qUsed, true )
11301:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11317:    ;
      
      
11317: BeginStmt:
11319:    @Statement
11321:    {[
11321:       | ';' :   @Statement
11325:       | pEnd :  >
11329:    ]};
      
      
11340: WritelnStmt:
11342:    @WriteStmt
11344:    .tWriteCR;
      
      
11347: WriteStmt:
11349:    [
11349:       | '(' :
11351:          {
11351:             @Expr
11353:             [ oTypeSNodeType
11355:                | nIntegerType :             .tWriteI
11358:                | nBooleanType :             .tWriteBool
11362:                | nByteType :                .tCastBtoI  .tWriteI
11368:                | nCharType :                .tWriteChar
11372:                | nShortStringType, nStrLitType :   .tWriteShortStr
11376:                | nFileType :                #eNotImplemented
11380:                | nEnumType :
                        % write name via table lookup
11382:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11396:                   .tWriteEnum
11398:                | nPointerType :
11400:                   [ equal_node( oTypeSTop, PCharType )
11409:                      | true :               .tWritePChar
11412:                      | * :                  .tWriteP
11419:                   ]
11419:                | nUniversalPointerType :    .tWriteP
11423:                | * :                        #eNotAllowed
11448:             ]
11448:             oTypeSPop
11449:             [
11449:                | ')' : >
11453:                | ',' :
11455:             ]
11463:          }
11465:       | * :
11470:    ];
      
      
11471: ReadlnStmt:      % ***
         % TO DO
11474:    ;
      
11474: ReadStmt:
         % TO DO
11477:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
11477: ScopeLevel >> int:
11479:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
11489: DeclLevel( Node decl ) >> int:
11491:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
11509: DeclUpLevels( Node decl ) >> int:
11511:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
11527: MatchTypes:
11529:    node_type nt = oTypeSNodeType
11534:    oTypeSPop
11535:    [ equal_node_type( nt, oTypeSNodeType )
11544:       | false :
               % Some implicit conversion is allowed even here
11545:          [ oTypeSNodeType
11547:             | nPointerType :
11548:                [ nt
11551:                   | nUniversalPointerType :  >>
11553:                   | * :
11558:                ]
11558:             | nUniversalPointerType :
11560:                [ nt
11563:                   | nPointerType :  >>
11565:                   | * :
11570:                ]
11570:             | * :
11577:          ]
11577:          #eTypeMismatch
11579:       | * :
11584:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
11585: RequireIntPop:
11587:    [ oTypeSNodeType
11589:       | nIntegerType :
11590:       | * :          #eNotInteger
11597:    ]
11597:    oTypeSPop;
      
11599: RequireInt:
11601:    [ oTypeSNodeType
11603:       | nIntegerType :
11604:       | * :          #eNotInteger
11611:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
11612: PromoteToIntPop:
11614:    [ oTypeSNodeType
11616:       | nIntegerType :
11617:       | nByteType :        .tCastBtoI
11621:       | * :                #eNotInteger
11630:    ]
11630:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
11632: PromoteToInt:
11634:    [ oTypeSNodeType
11636:       | nIntegerType :
11637:       | nByteType :        .tCastBtoI
11641:                            oTypeSPop
11642:                            oTypeSPush( IntegerType )
11648:       | * :                #eNotInteger
11657:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
11658: PromoteToIntOptional:
11660:    [ oTypeSNodeType
11662:       | nByteType :        .tCastBtoI
11665:                            oTypeSPop
11666:                            oTypeSPush( IntegerType )
11672:       | * :
11677:    ];
      
      
      
      
11678: RequireBoolPop:
11680:    [ oTypeSNodeType
11682:       | nBooleanType :
11683:       | * :          #eNotBoolean
11690:    ]
11690:    oTypeSPop;
      
11692: RequireBool:
11694:    [ oTypeSNodeType
11696:       | nBooleanType :
11697:       | * :          #eNotBoolean
11704:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11705: newType( node_type nt, int size ) >> Node:
11707:   Node node = oNodeNew( nt )
11717:   oNodeSetInt( node, qSize, size )
11729:   oTypeAdd( node )
11735:   >> node
11739:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
11739: newIdent( node_type nt, int id ) >> Node:
11741:   Node t = oNodeNew( nt )
11751:   oNodeSetInt( t, qIdent, id )
11763:   >> t
11767:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
11767: PointerTypeTo( Node theType ) >> Node:
11769:    Node ptrType = oNodeGet( theType, qPointerType )
11782:    [ oNodeNull( ptrType )
11789:       | true :
11790:          ptrType = oNodeNew( nPointerType )
11800:          oNodeSet( ptrType, qBaseType, theType )
11812:          oNodeSetInt( ptrType, qSize, 8 )
11824:          oTypeAdd( ptrType )
11830:          oNodeSet( theType, qPointerType, ptrType )
11842:       | * :
11847:    ]
11847:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
11851: OrdinalLow( Node theType ) >> int:
11853:    [ oNodeType( theType )
11860:       | nIntegerType :  >> oMININT
11863:       | nBooleanType :  >> 0
11868:       | nCharType :     >> 0
11873:       | nEnumType :
11875:          Node enumScope = oNodeGet( theType, qScope )
11888:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
11905:          >> oNodeGetInt( first, qValue )
11915:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
11927:       | * :             #eNotOrdinalType
11942:                         >> 0
11945:    ];
      
      
      % Return the high value of an ordinal type
      %
11946: OrdinalHigh( Node theType ) >> int:
11948:    [ oNodeType( theType )
11955:       | nIntegerType :  >> oMAXINT
11958:       | nBooleanType :  >> 1
11963:       | nCharType :     >> 255
11968:       | nEnumType :
11970:          Node enumScope = oNodeGet( theType, qScope )
11983:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12000:          >> oNodeGetInt( last, qValue )
12010:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12022:       | * :             #eNotOrdinalType
12037:                         >> 0
12040:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
12041: EmitValue( Node decl ):
12043:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
12057: DeclareBuiltInFunc( int id ) >> Node:
12059:    Node decl = @newIdent( nBuiltInFunc, id )
12073:    oScopeDeclare( decl )
12079:    >> decl;
      
      
12083: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
12085:    mysystemId = oId_mysystem
      
         % install built-in types
12090:    FileType = @newType( nFileType, 4 )
12104:    IntegerType = @newType( nIntegerType, 4 )
12118:    BooleanType = @newType( nBooleanType, 1 )
12132:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
12146:    CharType = @newType( nCharType, 1 )
12160:    PCharType = @PointerTypeTo( CharType )
12171:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
12185:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
12199:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
12211:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
12225:    ShortStringType = @newType( nShortStringType, 256 )
12239:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
12251:    Node t
      
12251:    t = @newIdent( nTypeDecl, oId_File )
12264:    oNodeSet( t, qType, FileType )
12276:    oScopeDeclare( t )
      
12282:    t = @newIdent( nTypeDecl, oId_Integer )
12295:    oNodeSet( t, qType, IntegerType )
12307:    oScopeDeclare( t )
      
12313:    t = @newIdent( nTypeDecl, oId_Boolean )
12326:    oNodeSet( t, qType, BooleanType )
12338:    oScopeDeclare( t )
      
12344:    t = @newIdent( nTypeDecl, oId_Char )
12357:    oNodeSet( t, qType, CharType )
12369:    oScopeDeclare( t )
      
12375:    t = @newIdent( nTypeDecl, oId_Byte )
12388:    oNodeSet( t, qType, ByteType )
12400:    oScopeDeclare( t )
      
12406:    t = @newIdent( nTypeDecl, oId_Pointer )
12419:    oNodeSet( t, qType, UniversalPointerType )
12431:    oScopeDeclare( t )
      
12437:    t = @newIdent( nTypeDecl, oId_ShortString )
12450:    oNodeSet( t, qType, ShortStringType )
12462:    oScopeDeclare( t )
      
         % Built-in constants
      
12468:    t = @newIdent( nConst, oId_True )
12481:    oNodeSet( t, qType, BooleanType )
12493:    oNodeSetInt( t, qValue, 1 )
12505:    oScopeDeclare( t )
      
12511:    t = @newIdent( nConst, oId_False )
12524:    oNodeSet( t, qType, BooleanType )
12536:    oNodeSetInt( t, qValue, 0 )
12548:    oScopeDeclare( t )
      
12554:    t = @newIdent( nConst, oId_Nil )
12567:    oNodeSet( t, qType, UniversalPointerType )
12579:    oNodeSetInt( t, qValue, 0 )
12591:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
12597:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
12607:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
12617:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
12627:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
12638:    ;
      
12638: end
      
12638: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 12083
  25: oEmit 67
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 61
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 64
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 63
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 66
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 11739
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 11739
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          59    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 586
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1543
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1864
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1599
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 648
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 447
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 447
 367: oPop 2
 369: oReturn
 370: oLocalSpace 0
 372: oGetParam 1
 374: oPushResult
 375: oSetResult 4
 377: oPushResult
 378: oNodeGetInt
 379: oPop 2
 381: oPushResult
 382: oGetGlobal 4
 384: oPushResult
 385: equal
 386: oPop 2
 388: oChoice 443
 390: oGetAddrGlobal 19
 392: oPushResult
 393: oScopeCurrent
 394: oPushResult
 395: oSetResult 15
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oId_ShortStringAppendShortString
 402: oPushResult
 403: oNodeFind
 404: oPop 4
 406: oAssign
 407: oGetAddrGlobal 20
 409: oPushResult
 410: oScopeCurrent
 411: oPushResult
 412: oSetResult 15
 414: oPushResult
 415: oSetResult 4
 417: oPushResult
 418: oId_ShortStringAppendChar
 419: oPushResult
 420: oNodeFind
 421: oPop 4
 423: oAssign
 424: oGetAddrGlobal 21
 426: oPushResult
 427: oScopeCurrent
 428: oPushResult
 429: oSetResult 15
 431: oPushResult
 432: oSetResult 4
 434: oPushResult
 435: oId_ShortStringCmp
 436: oPushResult
 437: oNodeFind
 438: oPop 4
 440: oAssign
 441: oJumpForward 446
 443: Choice Lookup Table
           1    390
 446: oReturn
 447: oLocalSpace 2
 449: oGetAddrLocal 1
 451: oPushResult
 452: oGetParam 2
 454: oPushResult
 455: oCall 727
 457: oPop 1
 459: oAssign
 460: oGetLocal 1
 462: oPushResult
 463: oSetResult 0
 465: oPushResult
 466: equal_node
 467: oPop 2
 469: oChoice 539
 471: oGetParam 1
 473: oPushResult
 474: oSetResult 5
 476: oPushResult
 477: oGetLocal 1
 479: oPushResult
 480: oNodeAddLast
 481: oPop 3
 483: oGetAddrLocal 2
 485: oPushResult
 486: oSetResult 10
 488: oPushResult
 489: oNodeNew
 490: oPop 1
 492: oAssign
 493: oGetLocal 2
 495: oPushResult
 496: oSetResult 4
 498: oPushResult
 499: oGetLocal 1
 501: oPushResult
 502: oSetResult 4
 504: oPushResult
 505: oNodeGetInt
 506: oPop 2
 508: oPushResult
 509: oNodeSetInt
 510: oPop 3
 512: oGetLocal 2
 514: oPushResult
 515: oSetResult 9
 517: oPushResult
 518: oGetLocal 1
 520: oPushResult
 521: oSetResult 9
 523: oPushResult
 524: oNodeGet
 525: oPop 2
 527: oPushResult
 528: oNodeSet
 529: oPop 3
 531: oGetLocal 2
 533: oPushResult
 534: oScopeDeclare
 535: oPop 1
 537: oJumpForward 542
 539: Choice Lookup Table
           0    471
 542: oReturn
 543: oLocalSpace 1
 545: oGetFromParam 1
 547: oPushResult
 548: oNodeType
 549: oPop 1
 551: oChoice 582
 553: oGetAddrLocal 1
 555: oPushResult
 556: oGetFromParam 1
 558: oPushResult
 559: oSetResult 9
 561: oPushResult
 562: oNodeGet
 563: oPop 2
 565: oAssign
 566: oInput 20
 568: oInput 0
 570: oGetParam 1
 572: oPushResult
 573: oGetLocal 1
 575: oPushResult
 576: oScopeFindRequireInScope
 577: oPop 1
 579: oAssign
 580: oJumpForward 585
 582: Choice Lookup Table
          10    553
 585: oReturn
 586: oLocalSpace 2
 588: oGetAddrLocal 1
 590: oPushResult
 591: oGetParam 1
 593: oPushResult
 594: oSetResult 5
 596: oPushResult
 597: oNodeGetIter
 598: oPop 2
 600: oAssign
 601: oGetAddrLocal 2
 603: oPushResult
 604: oGetLocal 1
 606: oPushResult
 607: oNodeIterValue
 608: oPop 1
 610: oAssign
 611: oGetLocal 2
 613: oPushResult
 614: oNodeNull
 615: oPop 1
 617: oChoice 634
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 9
 624: oPushResult
 625: oNodeGet
 626: oPop 2
 628: oPushResult
 629: oScopeEnter
 630: oPop 1
 632: oJumpForward 639
 634: Choice Lookup Table
           0    619
 637: oJumpForward 647
 639: oGetAddrLocal 1
 641: oPushResult
 642: oNodeIterNext
 643: oPop 1
 645: oJumpBack 601
 647: oReturn
 648: oLocalSpace 2
 650: oGetAddrLocal 1
 652: oPushResult
 653: oGetParam 1
 655: oPushResult
 656: oSetResult 5
 658: oPushResult
 659: oNodeGetIterLast
 660: oPop 2
 662: oAssign
 663: oGetAddrLocal 2
 665: oPushResult
 666: oGetLocal 1
 668: oPushResult
 669: oNodeIterValue
 670: oPop 1
 672: oAssign
 673: oGetLocal 2
 675: oPushResult
 676: oNodeNull
 677: oPop 1
 679: oChoice 713
 681: oScopeCurrent
 682: oPushResult
 683: oGetLocal 2
 685: oPushResult
 686: oSetResult 9
 688: oPushResult
 689: oNodeGet
 690: oPop 2
 692: oPushResult
 693: oNodeEqual
 694: oPop 2
 696: oChoice 704
 698: oJumpForward 710
 700: oError 25
 702: oJumpForward 710
 704: Choice Lookup Table
           0    700
           1    698
 709: oEndChoice
 710: oScopeEnd
 711: oJumpForward 718
 713: Choice Lookup Table
           0    681
 716: oJumpForward 726
 718: oGetAddrLocal 1
 720: oPushResult
 721: oNodeIterPrev
 722: oPop 1
 724: oJumpBack 663
 726: oReturn
 727: oLocalSpace 2
 729: oGetAddrLocal 1
 731: oPushResult
 732: oGetGlobal 1
 734: oPushResult
 735: oSetResult 1
 737: oPushResult
 738: oSetResult 4
 740: oPushResult
 741: oGetParam 1
 743: oPushResult
 744: oNodeFind
 745: oPop 4
 747: oAssign
 748: oGetLocal 1
 750: oPushResult
 751: oSetResult 0
 753: oPushResult
 754: equal_node
 755: oPop 2
 757: oChoice 764
 759: oGetLocal 1
 761: oReturn
 762: oJumpForward 767
 764: Choice Lookup Table
           0    759
 767: oGetAddrLocal 2
 769: oPushResult
 770: oGetParam 1
 772: oPushResult
 773: oIncludeUnitFile
 774: oPop 1
 776: oAssign
 777: oGetLocal 2
 779: oChoice 788
 781: oError 24
 783: oSetResult 0
 785: oReturn
 786: oJumpForward 791
 788: Choice Lookup Table
           0    781
 791: oGetAddrLocal 1
 793: oPushResult
 794: oCall 802
 796: oAssign
 797: oIncludeEnd
 798: oGetLocal 1
 800: oReturn
 801: oReturn
 802: oLocalSpace 2
 804: oInput 60
 806: oInput 0
 808: oGetAddrLocal 1
 810: oPushResult
 811: oSetResult 5
 813: oPushResult
 814: oNodeNew
 815: oPop 1
 817: oAssign
 818: oGetLocal 1
 820: oPushResult
 821: oSetResult 4
 823: oPushResult
 824: LAST_ID
 825: oPushResult
 826: oNodeSetInt
 827: oPop 3
 829: oGetAddrLocal 2
 831: oPushResult
 832: oSetResult 6
 834: oPushResult
 835: oNodeNew
 836: oPop 1
 838: oAssign
 839: oGetLocal 2
 841: oPushResult
 842: oSetResult 4
 844: oPushResult
 845: LAST_ID
 846: oPushResult
 847: oNodeSetInt
 848: oPop 3
 850: oGetLocal 1
 852: oPushResult
 853: oSetResult 8
 855: oPushResult
 856: oGetLocal 2
 858: oPushResult
 859: oNodeSet
 860: oPop 3
 862: oInput 5
 864: oInput 61
 866: oGetLocal 1
 868: oPushResult
 869: oCall 333
 871: oPop 1
 873: oInputChoice 884
 875: oGetLocal 1
 877: oPushResult
 878: oCall 306
 880: oPop 1
 882: oJumpForward 887
 884: Choice Lookup Table
          59    875
 887: oGetLocal 1
 889: oPushResult
 890: oCall 586
 892: oPop 1
 894: oSetResult 0
 896: oPushResult
 897: oSetResult 0
 899: oPushResult
 900: oScopeBegin
 901: oPop 2
 903: oGetLocal 1
 905: oPushResult
 906: oSetResult 9
 908: oPushResult
 909: oScopeCurrent
 910: oPushResult
 911: oNodeSet
 912: oPop 3
 914: oGetAddrGlobal 2
 916: oPushResult
 917: oScopeCurrent
 918: oAssign
 919: oSetResult 0
 921: oPushResult
 922: oSetResult 1
 924: oPushResult
 925: oScopeBegin
 926: oPop 2
 928: oGetAddrGlobal 3
 930: oPushResult
 931: oScopeCurrent
 932: oAssign
 933: oGetLocal 1
 935: oPushResult
 936: oSetResult 13
 938: oPushResult
 939: oGetGlobal 3
 941: oPushResult
 942: oNodeSet
 943: oPop 3
 945: oScopeEnd
 946: oGetLocal 1
 948: oPushResult
 949: oCall 1137
 951: oPop 1
 953: oScopeEnd
 954: oInput 62
 956: oGetLocal 2
 958: oPushResult
 959: oCall 333
 961: oPop 1
 963: oInputChoice 974
 965: oGetLocal 2
 967: oPushResult
 968: oCall 306
 970: oPop 1
 972: oJumpForward 977
 974: Choice Lookup Table
          59    965
 977: oGetLocal 2
 979: oPushResult
 980: oCall 586
 982: oPop 1
 984: oGetLocal 1
 986: oPushResult
 987: oSetResult 9
 989: oPushResult
 990: oNodeGet
 991: oPop 2
 993: oPushResult
 994: oScopeEnter
 995: oPop 1
 997: oSetResult 0
 999: oPushResult
1000: oSetResult 0
1002: oPushResult
1003: oScopeBegin
1004: oPop 2
1006: oGetLocal 1
1008: oPushResult
1009: oSetResult 10
1011: oPushResult
1012: oScopeCurrent
1013: oPushResult
1014: oNodeSet
1015: oPop 3
1017: oScopeCurrent
1018: oPushResult
1019: oSetResult 16
1021: oPushResult
1022: oGetLocal 1
1024: oPushResult
1025: oSetResult 9
1027: oPushResult
1028: oNodeGet
1029: oPop 2
1031: oPushResult
1032: oNodeSet
1033: oPop 3
1035: oGetAddrGlobal 2
1037: oPushResult
1038: oScopeCurrent
1039: oAssign
1040: oGetLocal 1
1042: oPushResult
1043: oCall 1229
1045: oPop 1
1047: oInputChoice 1061
1049: oGetLocal 1
1051: oPushResult
1052: oSetResult 1
1054: oPushResult
1055: oCall 1239
1057: oPop 2
1059: oJumpForward 1074
1061: Choice Lookup Table
          63   1049
1064: oGetLocal 1
1066: oPushResult
1067: oSetResult 0
1069: oPushResult
1070: oCall 1239
1072: oPop 2
1074: oInputChoice 1088
1076: oGetLocal 1
1078: oPushResult
1079: oSetResult 1
1081: oPushResult
1082: oCall 1425
1084: oPop 2
1086: oJumpForward 1101
1088: Choice Lookup Table
          64   1076
1091: oGetLocal 1
1093: oPushResult
1094: oSetResult 0
1096: oPushResult
1097: oCall 1425
1099: oPop 2
1101: oInput 36
1103: oInput 20
1105: oScopeEnd
1106: oScopeEnd
1107: oGetLocal 2
1109: oPushResult
1110: oCall 648
1112: oPop 1
1114: oGetLocal 1
1116: oPushResult
1117: oCall 648
1119: oPop 1
1121: oGetGlobal 1
1123: oPushResult
1124: oSetResult 1
1126: oPushResult
1127: oGetLocal 1
1129: oPushResult
1130: oNodeAddLast
1131: oPop 3
1133: oGetLocal 1
1135: oReturn
1136: oReturn
1137: oLocalSpace 2
1139: oInputChoice 1206
1141: oCall 3137
1143: oJumpForward 1219
1145: oCall 3692
1147: oJumpForward 1219
1149: oSetResult 20
1151: oPushResult
1152: oCall 3748
1154: oPop 1
1156: oJumpForward 1219
1158: oGetAddrLocal 1
1160: oPushResult
1161: oCall 2104
1163: oAssign
1164: oInputChoice 1177
1166: oGetLocal 1
1168: oPushResult
1169: oCall 2042
1171: oPop 1
1173: oInput 5
1175: oJumpForward 1180
1177: Choice Lookup Table
          70   1166
1180: oJumpForward 1219
1182: oGetAddrLocal 2
1184: oPushResult
1185: oCall 2478
1187: oAssign
1188: oInputChoice 1201
1190: oGetLocal 2
1192: oPushResult
1193: oCall 2042
1195: oPop 1
1197: oInput 5
1199: oJumpForward 1204
1201: Choice Lookup Table
          70   1190
1204: oJumpForward 1219
1206: Choice Lookup Table
          30   1182
          29   1158
          33   1149
          32   1145
          31   1141
1217: oJumpForward 1221
1219: oJumpBack 1139
1221: oGetParam 1
1223: oPushResult
1224: oCall 370
1226: oPop 1
1228: oReturn
1229: oLocalSpace 0
1231: oSetResult 20
1233: oPushResult
1234: oCall 1543
1236: oPop 1
1238: oReturn
1239: oLocalSpace 5
1241: oGetAddrLocal 1
1243: oPushResult
1244: oLabelNew
1245: oAssign
1246: oEmit 77
1248: oGetLocal 1
1250: oPushResult
1251: oEmitLabel
1252: oPop 1
1254: oGetParam 2
1256: oPushResult
1257: oSetResult 11
1259: oPushResult
1260: oGetLocal 1
1262: oPushResult
1263: oNodeSetLabel
1264: oPop 3
1266: oEmit 67
1268: oGetAddrLocal 2
1270: oPushResult
1271: Here
1272: oAssign
1273: oEmit 90
1275: oGetAddrLocal 3
1277: oPushResult
1278: oGetParam 2
1280: oPushResult
1281: oSetResult 9
1283: oPushResult
1284: oNodeGet
1285: oPop 2
1287: oAssign
1288: oGetAddrLocal 4
1290: oPushResult
1291: oGetLocal 3
1293: oPushResult
1294: oSetResult 19
1296: oPushResult
1297: oNodeGetCode
1298: oPop 2
1300: oAssign
1301: oGetLocal 4
1303: oPushResult
1304: oEmitCode
1305: oPop 1
1307: oGetLocal 3
1309: oPushResult
1310: oSetResult 19
1312: oPushResult
1313: oSetResult 0
1315: oPushResult
1316: oNodeSetCode
1317: oPop 3
1319: oGetAddrLocal 3
1321: oPushResult
1322: oGetParam 2
1324: oPushResult
1325: oSetResult 10
1327: oPushResult
1328: oNodeGet
1329: oPop 2
1331: oAssign
1332: oGetAddrLocal 4
1334: oPushResult
1335: oGetLocal 3
1337: oPushResult
1338: oSetResult 19
1340: oPushResult
1341: oNodeGetCode
1342: oPop 2
1344: oAssign
1345: oGetLocal 4
1347: oPushResult
1348: oEmitCode
1349: oPop 1
1351: oGetLocal 3
1353: oPushResult
1354: oSetResult 19
1356: oPushResult
1357: oSetResult 0
1359: oPushResult
1360: oNodeSetCode
1361: oPop 3
1363: oGetParam 2
1365: oPushResult
1366: oSetResult 13
1368: oPushResult
1369: oNodeGet
1370: oPop 2
1372: oPushResult
1373: oScopeEnter
1374: oPop 1
1376: oGetParam 1
1378: oChoice 1397
1380: oCall 9877
1382: oInputChoice 1388
1384: oCall 9877
1386: oJumpForward 1393
1388: Choice Lookup Table
           5   1384
1391: oJumpForward 1395
1393: oJumpBack 1382
1395: oJumpForward 1400
1397: Choice Lookup Table
           1   1380
1400: oEmit 66
1402: oGetAddrLocal 5
1404: oPushResult
1405: oScopeCurrent
1406: oPushResult
1407: oSetResult 17
1409: oPushResult
1410: oNodeGetInt
1411: oPop 2
1413: oAssign
1414: oGetLocal 2
1416: oPushResult
1417: oGetLocal 5
1419: oPushResult
1420: oPatch
1421: oPop 2
1423: oScopeEnd
1424: oReturn
1425: oLocalSpace 3
1427: oGetAddrLocal 1
1429: oPushResult
1430: oLabelNew
1431: oAssign
1432: oEmit 77
1434: oGetLocal 1
1436: oPushResult
1437: oEmitLabel
1438: oPop 1
1440: oGetParam 2
1442: oPushResult
1443: oSetResult 12
1445: oPushResult
1446: oGetLocal 1
1448: oPushResult
1449: oNodeSetLabel
1450: oPop 3
1452: oEmit 67
1454: oGetAddrLocal 2
1456: oPushResult
1457: Here
1458: oAssign
1459: oEmit 90
1461: oSetResult 0
1463: oPushResult
1464: oSetResult 1
1466: oPushResult
1467: oScopeBegin
1468: oPop 2
1470: oGetParam 1
1472: oChoice 1491
1474: oCall 9877
1476: oInputChoice 1482
1478: oCall 9877
1480: oJumpForward 1487
1482: Choice Lookup Table
           5   1478
1485: oJumpForward 1489
1487: oJumpBack 1476
1489: oJumpForward 1494
1491: Choice Lookup Table
           1   1474
1494: oEmit 66
1496: oGetAddrLocal 3
1498: oPushResult
1499: oScopeCurrent
1500: oPushResult
1501: oSetResult 17
1503: oPushResult
1504: oNodeGetInt
1505: oPop 2
1507: oAssign
1508: oGetLocal 2
1510: oPushResult
1511: oGetLocal 3
1513: oPushResult
1514: oPatch
1515: oPop 2
1517: oScopeEnd
1518: oReturn
1519: oLocalSpace 0
1521: oGetParam 2
1523: oPushResult
1524: oCall 1543
1526: oPop 1
1528: oGetParam 1
1530: oPushResult
1531: oScopeCurrent
1532: oPushResult
1533: oSetResult 0
1535: oPushResult
1536: oCall 1864
1538: oPop 3
1540: oCall 1599
1542: oReturn
1543: oLocalSpace 0
1545: oInputChoice 1576
1547: oCall 3137
1549: oJumpForward 1591
1551: oCall 3692
1553: oJumpForward 1591
1555: oGetParam 1
1557: oPushResult
1558: oCall 3748
1560: oPop 1
1562: oJumpForward 1591
1564: oCall 3982
1566: oJumpForward 1591
1568: oCall 2360
1570: oJumpForward 1591
1572: oCall 2795
1574: oJumpForward 1591
1576: Choice Lookup Table
          30   1572
          29   1568
          34   1564
          33   1555
          32   1551
          31   1547
1589: oJumpForward 1593
1591: oJumpBack 1545
1593: oCall 1596
1595: oReturn
1596: oLocalSpace 0
1598: oReturn
1599: oLocalSpace 2
1601: oGetAddrLocal 1
1603: oPushResult
1604: oScopeCurrent
1605: oPushResult
1606: oSetResult 15
1608: oPushResult
1609: oNodeGetIter
1610: oPop 2
1612: oAssign
1613: oGetAddrLocal 2
1615: oPushResult
1616: oGetLocal 1
1618: oPushResult
1619: oNodeIterValue
1620: oPop 1
1622: oAssign
1623: oGetLocal 2
1625: oPushResult
1626: oNodeNull
1627: oPop 1
1629: oChoice 1633
1631: oJumpForward 1638
1633: Choice Lookup Table
           0   1631
1636: oJumpForward 1693
1638: oGetLocal 2
1640: oPushResult
1641: oNodeType
1642: oPop 1
1644: oChoice 1682
1646: oGetLocal 2
1648: oPushResult
1649: oSetResult 34
1651: oPushResult
1652: oNodeGetBoolean
1653: oPop 2
1655: oChoice 1677
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 28
1662: oPushResult
1663: oNodeGetBoolean
1664: oPop 2
1666: oChoice 1672
1668: oError 27
1670: oJumpForward 1675
1672: Choice Lookup Table
           1   1668
1675: oJumpForward 1680
1677: Choice Lookup Table
           0   1657
1680: oJumpForward 1685
1682: Choice Lookup Table
          25   1646
1685: oGetAddrLocal 1
1687: oPushResult
1688: oNodeIterNext
1689: oPop 1
1691: oJumpBack 1613
1693: oReturn
1694: oLocalSpace 2
1696: oGetAddrLocal 1
1698: oPushResult
1699: oGetGlobal 1
1701: oPushResult
1702: oSetResult 1
1704: oPushResult
1705: oNodeGetIter
1706: oPop 2
1708: oAssign
1709: oGetAddrLocal 2
1711: oPushResult
1712: oGetLocal 1
1714: oPushResult
1715: oNodeIterValue
1716: oPop 1
1718: oAssign
1719: oGetLocal 2
1721: oPushResult
1722: oNodeNull
1723: oPop 1
1725: oChoice 1770
1727: oJumpForward 1778
1729: oJumpForward 1776
1731: oEmit 61
1733: oSetResult 0
1735: oPushResult
1736: oEmitInt
1737: oPop 1
1739: oEmit 64
1741: oGetLocal 2
1743: oPushResult
1744: oSetResult 11
1746: oPushResult
1747: oNodeGetLabel
1748: oPop 2
1750: oPushResult
1751: oEmitLabel
1752: oPop 1
1754: oEmit 63
1756: oSetResult 0
1758: oPushResult
1759: oEmitInt
1760: oPop 1
1762: oGetAddrLocal 1
1764: oPushResult
1765: oNodeIterNext
1766: oPop 1
1768: oJumpForward 1776
1770: Choice Lookup Table
           0   1731
           1   1727
1775: oEndChoice
1776: oJumpBack 1709
1778: oReturn
1779: oLocalSpace 2
1781: oGetAddrLocal 1
1783: oPushResult
1784: oGetGlobal 1
1786: oPushResult
1787: oSetResult 1
1789: oPushResult
1790: oNodeGetIterLast
1791: oPop 2
1793: oAssign
1794: oGetAddrLocal 2
1796: oPushResult
1797: oGetLocal 1
1799: oPushResult
1800: oNodeIterValue
1801: oPop 1
1803: oAssign
1804: oGetLocal 2
1806: oPushResult
1807: oNodeNull
1808: oPop 1
1810: oChoice 1855
1812: oJumpForward 1863
1814: oJumpForward 1861
1816: oEmit 61
1818: oSetResult 0
1820: oPushResult
1821: oEmitInt
1822: oPop 1
1824: oEmit 64
1826: oGetLocal 2
1828: oPushResult
1829: oSetResult 12
1831: oPushResult
1832: oNodeGetLabel
1833: oPop 2
1835: oPushResult
1836: oEmitLabel
1837: oPop 1
1839: oEmit 63
1841: oSetResult 0
1843: oPushResult
1844: oEmitInt
1845: oPop 1
1847: oGetAddrLocal 1
1849: oPushResult
1850: oNodeIterPrev
1851: oPop 1
1853: oJumpForward 1861
1855: Choice Lookup Table
           0   1816
           1   1812
1860: oEndChoice
1861: oJumpBack 1794
1863: oReturn
1864: oLocalSpace 3
1866: oEmit 77
1868: oGetParam 3
1870: oPushResult
1871: oEmitLabel
1872: oPop 1
1874: oEmit 67
1876: oGetAddrLocal 1
1878: oPushResult
1879: Here
1880: oAssign
1881: oEmit 90
1883: oGetParam 1
1885: oChoice 1891
1887: oCall 1694
1889: oJumpForward 1894
1891: Choice Lookup Table
           1   1887
1894: oGetAddrLocal 2
1896: oPushResult
1897: oGetParam 2
1899: oPushResult
1900: oSetResult 19
1902: oPushResult
1903: oNodeGetCode
1904: oPop 2
1906: oAssign
1907: oGetLocal 2
1909: oPushResult
1910: oEmitCode
1911: oPop 1
1913: oGetParam 2
1915: oPushResult
1916: oSetResult 19
1918: oPushResult
1919: oSetResult 0
1921: oPushResult
1922: oNodeSetCode
1923: oPop 3
1925: oCall 9877
1927: oGetParam 1
1929: oChoice 1935
1931: oCall 1779
1933: oJumpForward 1938
1935: Choice Lookup Table
           1   1931
1938: oEmit 66
1940: oGetAddrLocal 3
1942: oPushResult
1943: oScopeCurrent
1944: oPushResult
1945: oSetResult 17
1947: oPushResult
1948: oNodeGetInt
1949: oPop 2
1951: oAssign
1952: oGetLocal 1
1954: oPushResult
1955: oGetLocal 3
1957: oPushResult
1958: oPatch
1959: oPop 2
1961: oReturn
1962: oLocalSpace 0
1964: oInputChoice 1982
1966: oGetParam 1
1968: oPushResult
1969: oSetResult 27
1971: oPushResult
1972: oSetResult 1
1974: oPushResult
1975: oNodeSetBoolean
1976: oPop 3
1978: oInput 5
1980: oJumpForward 1987
1982: Choice Lookup Table
          72   1966
1985: oJumpForward 1989
1987: oJumpBack 1964
1989: oReturn
1990: oLocalSpace 1
1992: oGetAddrLocal 1
1994: oPushResult
1995: oGetParam 1
1997: oPushResult
1998: oSetResult 19
2000: oPushResult
2001: oNodeGetCode
2002: oPop 2
2004: oAssign
2005: oGetLocal 1
2007: oPushResult
2008: oSetResult 0
2010: oPushResult
2011: equal_code
2012: oPop 2
2014: oChoice 2035
2016: oGetAddrLocal 1
2018: oPushResult
2019: oCodeNew
2020: oAssign
2021: oGetParam 1
2023: oPushResult
2024: oSetResult 19
2026: oPushResult
2027: oGetLocal 1
2029: oPushResult
2030: oNodeSetCode
2031: oPop 3
2033: oJumpForward 2038
2035: Choice Lookup Table
           1   2016
2038: oGetLocal 1
2040: oReturn
2041: oReturn
2042: oLocalSpace 0
2044: oGetParam 1
2046: oPushResult
2047: oCall 11489
2049: oPop 1
2051: oPushResult
2052: equal_zero
2053: oPop 1
2055: oChoice 2061
2057: oError 23
2059: oJumpForward 2064
2061: Choice Lookup Table
           0   2057
2064: oGetParam 1
2066: oPushResult
2067: oSetResult 25
2069: oPushResult
2070: oSetResult 1
2072: oPushResult
2073: oNodeSetBoolean
2074: oPop 3
2076: oInputChoice 2100
2078: oInputChoice 2095
2080: oInput 2
2082: oGetParam 1
2084: oPushResult
2085: oSetResult 26
2087: oPushResult
2088: CURRENT_STRLIT
2089: oPushResult
2090: oNodeSetString
2091: oPop 3
2093: oJumpForward 2098
2095: Choice Lookup Table
          71   2080
2098: oJumpForward 2103
2100: Choice Lookup Table
           2   2078
2103: oReturn
2104: oLocalSpace 6
2106: oInput 0
2108: oGetAddrLocal 1
2110: oPushResult
2111: oSetResult 0
2113: oAssign
2114: oGetAddrLocal 2
2116: oPushResult
2117: oScopeFindInCurrentScope
2118: oAssign
2119: oGetLocal 2
2121: oPushResult
2122: oNodeNull
2123: oPop 1
2125: oChoice 2243
2127: oGetAddrLocal 2
2129: oPushResult
2130: oSetResult 12
2132: oPushResult
2133: LAST_ID
2134: oPushResult
2135: oCall 11739
2137: oPop 2
2139: oAssign
2140: oGetLocal 2
2142: oPushResult
2143: oSetResult 22
2145: oPushResult
2146: oLabelNew
2147: oPushResult
2148: oNodeSetLabel
2149: oPop 3
2151: oJumpForward 2249
2153: oGetAddrLocal 1
2155: oPushResult
2156: oSetResult 1
2158: oAssign
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 24
2164: oPushResult
2165: oNodeGetBoolean
2166: oPop 2
2168: oChoice 2174
2170: oError 21
2172: oJumpForward 2177
2174: Choice Lookup Table
           1   2170
2177: oGetLocal 2
2179: oPushResult
2180: oSetResult 25
2182: oPushResult
2183: oNodeGetBoolean
2184: oPop 2
2186: oChoice 2192
2188: oError 21
2190: oJumpForward 2195
2192: Choice Lookup Table
           1   2188
2195: oGetLocal 2
2197: oPushResult
2198: oNodeType
2199: oPop 1
2201: oChoice 2205
2203: oJumpForward 2210
2205: Choice Lookup Table
          12   2203
2208: oError 21
2210: oGetLocal 2
2212: oPushResult
2213: oSetResult 29
2215: oPushResult
2216: oGetLocal 2
2218: oPushResult
2219: oSetResult 23
2221: oPushResult
2222: oNodeGet
2223: oPop 2
2225: oPushResult
2226: oNodeSet
2227: oPop 3
2229: oGetLocal 2
2231: oPushResult
2232: oSetResult 23
2234: oPushResult
2235: oSetResult 0
2237: oPushResult
2238: oNodeSet
2239: oPop 3
2241: oJumpForward 2249
2243: Choice Lookup Table
           0   2153
           1   2127
2248: oEndChoice
2249: oGetAddrLocal 3
2251: oPushResult
2252: oCall 11477
2254: oAssign
2255: oGetAddrLocal 4
2257: oPushResult
2258: oGetLocal 3
2260: oPushResult
2261: oSetResult 0
2263: oPushResult
2264: greater
2265: oPop 2
2267: oAssign
2268: oGetAddrLocal 3
2270: oPushResult
2271: inc
2272: oPop 1
2274: oGetLocal 3
2276: oPushResult
2277: oSetResult 2
2279: oPushResult
2280: oScopeBegin
2281: oPop 2
2283: oGetAddrLocal 5
2285: oPushResult
2286: oScopeCurrent
2287: oAssign
2288: oGetLocal 4
2290: oChoice 2309
2292: oGetAddrLocal 6
2294: oPushResult
2295: oGetGlobal 6
2297: oPushResult
2298: oCall 11767
2300: oPop 1
2302: oPushResult
2303: oScopeAllocType
2304: oPop 1
2306: oAssign
2307: oJumpForward 2312
2309: Choice Lookup Table
           1   2292
2312: oCall 2913
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 23
2319: oPushResult
2320: oGetLocal 5
2322: oPushResult
2323: oNodeSet
2324: oPop 3
2326: oScopeEnd
2327: oInput 5
2329: oGetLocal 1
2331: oChoice 2343
2333: oGetLocal 2
2335: oPushResult
2336: oScopeDeclare
2337: oPop 1
2339: oJumpForward 2349
2341: oJumpForward 2349
2343: Choice Lookup Table
           1   2341
           0   2333
2348: oEndChoice
2349: oGetLocal 2
2351: oPushResult
2352: oCall 1962
2354: oPop 1
2356: oGetLocal 2
2358: oReturn
2359: oReturn
2360: oLocalSpace 4
2362: oGetAddrLocal 1
2364: oPushResult
2365: oCall 2104
2367: oAssign
2368: oInputChoice 2381
2370: oJumpForward 2475
2372: oGetLocal 1
2374: oPushResult
2375: oCall 2042
2377: oPop 1
2379: oJumpForward 2475
2381: Choice Lookup Table
          70   2372
          69   2370
2386: oGetAddrLocal 2
2388: oPushResult
2389: oGetLocal 1
2391: oPushResult
2392: oSetResult 23
2394: oPushResult
2395: oNodeGet
2396: oPop 2
2398: oAssign
2399: oGetLocal 2
2401: oPushResult
2402: oScopeEnter
2403: oPop 1
2405: oGetAddrLocal 3
2407: oPushResult
2408: oGetLocal 2
2410: oPushResult
2411: oSetResult 14
2413: oPushResult
2414: oNodeGetInt
2415: oPop 2
2417: oAssign
2418: oGetLocal 3
2420: oPushResult
2421: oSetResult 1
2423: oPushResult
2424: oScopeBegin
2425: oPop 2
2427: oGetLocal 1
2429: oPushResult
2430: oSetResult 6
2432: oPushResult
2433: oScopeCurrent
2434: oPushResult
2435: oNodeSet
2436: oPop 3
2438: oGetAddrLocal 4
2440: oPushResult
2441: oGetLocal 1
2443: oPushResult
2444: oSetResult 22
2446: oPushResult
2447: oNodeGetLabel
2448: oPop 2
2450: oAssign
2451: oSetResult 21
2453: oPushResult
2454: oGetLocal 4
2456: oPushResult
2457: oCall 1519
2459: oPop 2
2461: oGetLocal 1
2463: oPushResult
2464: oSetResult 24
2466: oPushResult
2467: oSetResult 1
2469: oPushResult
2470: oNodeSetBoolean
2471: oPop 3
2473: oScopeEnd
2474: oScopeEnd
2475: oInput 5
2477: oReturn
2478: oLocalSpace 8
2480: oInput 0
2482: oGetAddrLocal 1
2484: oPushResult
2485: oSetResult 0
2487: oAssign
2488: oGetAddrLocal 2
2490: oPushResult
2491: oScopeFindInCurrentScope
2492: oAssign
2493: oGetLocal 2
2495: oPushResult
2496: oNodeNull
2497: oPop 1
2499: oChoice 2630
2501: oGetAddrLocal 2
2503: oPushResult
2504: oSetResult 13
2506: oPushResult
2507: LAST_ID
2508: oPushResult
2509: oCall 11739
2511: oPop 2
2513: oAssign
2514: oGetLocal 2
2516: oPushResult
2517: oSetResult 22
2519: oPushResult
2520: oLabelNew
2521: oPushResult
2522: oNodeSetLabel
2523: oPop 3
2525: oJumpForward 2636
2527: oGetAddrLocal 1
2529: oPushResult
2530: oSetResult 1
2532: oAssign
2533: oGetLocal 2
2535: oPushResult
2536: oSetResult 24
2538: oPushResult
2539: oNodeGetBoolean
2540: oPop 2
2542: oChoice 2548
2544: oError 21
2546: oJumpForward 2551
2548: Choice Lookup Table
           1   2544
2551: oGetLocal 2
2553: oPushResult
2554: oNodeType
2555: oPop 1
2557: oChoice 2561
2559: oJumpForward 2566
2561: Choice Lookup Table
          13   2559
2564: oError 21
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 29
2571: oPushResult
2572: oGetLocal 2
2574: oPushResult
2575: oSetResult 23
2577: oPushResult
2578: oNodeGet
2579: oPop 2
2581: oPushResult
2582: oNodeSet
2583: oPop 3
2585: oGetLocal 2
2587: oPushResult
2588: oSetResult 23
2590: oPushResult
2591: oSetResult 0
2593: oPushResult
2594: oNodeSet
2595: oPop 3
2597: oGetLocal 2
2599: oPushResult
2600: oSetResult 30
2602: oPushResult
2603: oGetLocal 2
2605: oPushResult
2606: oSetResult 21
2608: oPushResult
2609: oNodeGet
2610: oPop 2
2612: oPushResult
2613: oNodeSet
2614: oPop 3
2616: oGetLocal 2
2618: oPushResult
2619: oSetResult 21
2621: oPushResult
2622: oSetResult 0
2624: oPushResult
2625: oNodeSet
2626: oPop 3
2628: oJumpForward 2636
2630: Choice Lookup Table
           0   2527
           1   2501
2635: oEndChoice
2636: oGetAddrLocal 3
2638: oPushResult
2639: oCall 11477
2641: oAssign
2642: oGetAddrLocal 4
2644: oPushResult
2645: oGetLocal 3
2647: oPushResult
2648: oSetResult 0
2650: oPushResult
2651: greater
2652: oPop 2
2654: oAssign
2655: oGetAddrLocal 3
2657: oPushResult
2658: inc
2659: oPop 1
2661: oGetLocal 3
2663: oPushResult
2664: oSetResult 2
2666: oPushResult
2667: oScopeBegin
2668: oPop 2
2670: oGetAddrLocal 5
2672: oPushResult
2673: oScopeCurrent
2674: oAssign
2675: oGetLocal 4
2677: oChoice 2696
2679: oGetAddrLocal 6
2681: oPushResult
2682: oGetGlobal 6
2684: oPushResult
2685: oCall 11767
2687: oPop 1
2689: oPushResult
2690: oScopeAllocType
2691: oPop 1
2693: oAssign
2694: oJumpForward 2699
2696: Choice Lookup Table
           1   2679
2699: oCall 2913
2701: oGetLocal 2
2703: oPushResult
2704: oSetResult 23
2706: oPushResult
2707: oGetLocal 5
2709: oPushResult
2710: oNodeSet
2711: oPop 3
2713: oInput 12
2715: oGetAddrLocal 7
2717: oPushResult
2718: oCall 4047
2720: oPop 1
2722: oGetLocal 2
2724: oPushResult
2725: oSetResult 21
2727: oPushResult
2728: oGetLocal 7
2730: oPushResult
2731: oNodeSet
2732: oPop 3
2734: oGetAddrLocal 8
2736: oPushResult
2737: oGetLocal 7
2739: oPushResult
2740: oCall 11767
2742: oPop 1
2744: oAssign
2745: oGetLocal 2
2747: oPushResult
2748: oSetResult 31
2750: oPushResult
2751: oGetLocal 8
2753: oPushResult
2754: oScopeAllocType
2755: oPop 1
2757: oPushResult
2758: oNodeSetInt
2759: oPop 3
2761: oScopeEnd
2762: oInput 5
2764: oGetLocal 1
2766: oChoice 2778
2768: oGetLocal 2
2770: oPushResult
2771: oScopeDeclare
2772: oPop 1
2774: oJumpForward 2784
2776: oJumpForward 2784
2778: Choice Lookup Table
           1   2776
           0   2768
2783: oEndChoice
2784: oGetLocal 2
2786: oPushResult
2787: oCall 1962
2789: oPop 1
2791: oGetLocal 2
2793: oReturn
2794: oReturn
2795: oLocalSpace 4
2797: oGetAddrLocal 1
2799: oPushResult
2800: oCall 2478
2802: oAssign
2803: oInputChoice 2816
2805: oJumpForward 2910
2807: oGetLocal 1
2809: oPushResult
2810: oCall 2042
2812: oPop 1
2814: oJumpForward 2910
2816: Choice Lookup Table
          70   2807
          69   2805
2821: oGetAddrLocal 2
2823: oPushResult
2824: oGetLocal 1
2826: oPushResult
2827: oSetResult 23
2829: oPushResult
2830: oNodeGet
2831: oPop 2
2833: oAssign
2834: oGetLocal 2
2836: oPushResult
2837: oScopeEnter
2838: oPop 1
2840: oGetAddrLocal 3
2842: oPushResult
2843: oGetLocal 2
2845: oPushResult
2846: oSetResult 14
2848: oPushResult
2849: oNodeGetInt
2850: oPop 2
2852: oAssign
2853: oGetLocal 3
2855: oPushResult
2856: oSetResult 1
2858: oPushResult
2859: oScopeBegin
2860: oPop 2
2862: oGetLocal 1
2864: oPushResult
2865: oSetResult 6
2867: oPushResult
2868: oScopeCurrent
2869: oPushResult
2870: oNodeSet
2871: oPop 3
2873: oGetAddrLocal 4
2875: oPushResult
2876: oGetLocal 1
2878: oPushResult
2879: oSetResult 22
2881: oPushResult
2882: oNodeGetLabel
2883: oPop 2
2885: oAssign
2886: oSetResult 21
2888: oPushResult
2889: oGetLocal 4
2891: oPushResult
2892: oCall 1519
2894: oPop 2
2896: oGetLocal 1
2898: oPushResult
2899: oSetResult 24
2901: oPushResult
2902: oSetResult 1
2904: oPushResult
2905: oNodeSetBoolean
2906: oPop 3
2908: oScopeEnd
2909: oScopeEnd
2910: oInput 5
2912: oReturn
2913: oLocalSpace 6
2915: oInputChoice 3133
2917: oGetAddrLocal 1
2919: oPushResult
2920: oNodeVecNew
2921: oAssign
2922: oGetAddrLocal 3
2924: oPushResult
2925: oSetResult 0
2927: oAssign
2928: oInputChoice 2938
2930: oGetAddrLocal 3
2932: oPushResult
2933: oSetResult 1
2935: oAssign
2936: oJumpForward 2941
2938: Choice Lookup Table
          33   2930
2941: oInput 0
2943: oGetAddrLocal 2
2945: oPushResult
2946: oSetResult 23
2948: oPushResult
2949: LAST_ID
2950: oPushResult
2951: oCall 11739
2953: oPop 2
2955: oAssign
2956: oGetLocal 2
2958: oPushResult
2959: oSetResult 33
2961: oPushResult
2962: oGetLocal 3
2964: oPushResult
2965: oNodeSetBoolean
2966: oPop 3
2968: oGetLocal 1
2970: oPushResult
2971: oGetLocal 2
2973: oPushResult
2974: oNodeVecAppend
2975: oPop 2
2977: oInputChoice 2985
2979: oJumpForward 2993
2981: oJumpForward 2991
2983: oJumpForward 2991
2985: Choice Lookup Table
          13   2983
          12   2979
2990: oEndChoice
2991: oJumpBack 2941
2993: oGetAddrLocal 4
2995: oPushResult
2996: oCall 4047
2998: oPop 1
3000: oGetLocal 3
3002: oChoice 3017
3004: oGetAddrLocal 5
3006: oPushResult
3007: oGetLocal 4
3009: oPushResult
3010: oCall 11767
3012: oPop 1
3014: oAssign
3015: oJumpForward 3026
3017: Choice Lookup Table
           1   3004
3020: oGetAddrLocal 5
3022: oPushResult
3023: oGetLocal 4
3025: oAssign
3026: oGetAddrLocal 6
3028: oPushResult
3029: oSetResult 0
3031: oAssign
3032: oGetLocal 6
3034: oPushResult
3035: oGetLocal 1
3037: oPushResult
3038: oNodeVecSize
3039: oPop 1
3041: oPushResult
3042: equal
3043: oPop 2
3045: oChoice 3102
3047: oGetAddrLocal 2
3049: oPushResult
3050: oGetLocal 1
3052: oPushResult
3053: oGetLocal 6
3055: oPushResult
3056: oNodeVecElement
3057: oPop 2
3059: oAssign
3060: oGetLocal 2
3062: oPushResult
3063: oSetResult 21
3065: oPushResult
3066: oGetLocal 4
3068: oPushResult
3069: oNodeSet
3070: oPop 3
3072: oGetLocal 2
3074: oPushResult
3075: oScopeDeclare
3076: oPop 1
3078: oGetLocal 2
3080: oPushResult
3081: oSetResult 22
3083: oPushResult
3084: oGetLocal 5
3086: oPushResult
3087: oScopeAllocType
3088: oPop 1
3090: oPushResult
3091: oNodeSetInt
3092: oPop 3
3094: oGetAddrLocal 6
3096: oPushResult
3097: inc
3098: oPop 1
3100: oJumpForward 3107
3102: Choice Lookup Table
           0   3047
3105: oJumpForward 3109
3107: oJumpBack 3032
3109: oGetLocal 1
3111: oPushResult
3112: oNodeVecDelete
3113: oPop 1
3115: oInputChoice 3123
3117: oJumpForward 3131
3119: oJumpForward 3129
3121: oJumpForward 3129
3123: Choice Lookup Table
           5   3121
          15   3117
3128: oEndChoice
3129: oJumpBack 2917
3131: oJumpForward 3136
3133: Choice Lookup Table
          14   2917
3136: oReturn
3137: oLocalSpace 0
3139: oInputChoice 3154
3141: oInputChoice 3147
3143: oCall 3220
3145: oJumpForward 3152
3147: Choice Lookup Table
          12   3143
3150: oCall 3162
3152: oJumpForward 3159
3154: Choice Lookup Table
           0   3141
3157: oJumpForward 3161
3159: oJumpBack 3139
3161: oReturn
3162: oLocalSpace 2
3164: oGetAddrLocal 1
3166: oPushResult
3167: oSetResult 16
3169: oPushResult
3170: LAST_ID
3171: oPushResult
3172: oCall 11739
3174: oPop 2
3176: oAssign
3177: oInput 6
3179: oCall 5103
3181: oGetAddrLocal 2
3183: oPushResult
3184: oValueTop
3185: oAssign
3186: oValuePop
3187: oGetLocal 1
3189: oPushResult
3190: oSetResult 22
3192: oPushResult
3193: oGetLocal 2
3195: oPushResult
3196: oNodeSetInt
3197: oPop 3
3199: oGetLocal 1
3201: oPushResult
3202: oSetResult 21
3204: oPushResult
3205: oGetGlobal 6
3207: oPushResult
3208: oNodeSet
3209: oPop 3
3211: oGetLocal 1
3213: oPushResult
3214: oScopeDeclare
3215: oPop 1
3217: oInput 5
3219: oReturn
3220: oLocalSpace 4
3222: oGetAddrLocal 1
3224: oPushResult
3225: oSetResult 24
3227: oPushResult
3228: LAST_ID
3229: oPushResult
3230: oCall 11739
3232: oPop 2
3234: oAssign
3235: oGetAddrLocal 2
3237: oPushResult
3238: oCall 4047
3240: oPop 1
3242: oGetLocal 1
3244: oPushResult
3245: oSetResult 21
3247: oPushResult
3248: oGetLocal 2
3250: oPushResult
3251: oNodeSet
3252: oPop 3
3254: oGetLocal 2
3256: oPushResult
3257: oNodeType
3258: oPop 1
3260: oChoice 3361
3262: oInput 6
3264: oCall 5103
3266: oGetAddrLocal 3
3268: oPushResult
3269: oValueTop
3270: oAssign
3271: oValuePop
3272: oGetLocal 1
3274: oPushResult
3275: oSetResult 22
3277: oPushResult
3278: oGetLocal 3
3280: oPushResult
3281: oNodeSetInt
3282: oPop 3
3284: oGetLocal 1
3286: oPushResult
3287: oScopeDeclare
3288: oPop 1
3290: oInput 5
3292: oJumpForward 3385
3294: oError 16
3296: oJumpForward 3385
3298: oGetGlobal 2
3300: oPushResult
3301: oScopeEnter
3302: oPop 1
3304: oGetAddrLocal 4
3306: oPushResult
3307: oGetLocal 2
3309: oPushResult
3310: oScopeAllocType
3311: oPop 1
3313: oAssign
3314: oScopeEnd
3315: oGetGlobal 2
3317: oPushResult
3318: oCall 1990
3320: oPop 1
3322: oPushResult
3323: oCodePush
3324: oPop 1
3326: oGetLocal 1
3328: oPushResult
3329: oSetResult 22
3331: oPushResult
3332: oGetLocal 4
3334: oPushResult
3335: oNodeSetInt
3336: oPop 3
3338: oInput 6
3340: oGetLocal 2
3342: oPushResult
3343: oGetLocal 4
3345: oPushResult
3346: oCall 3386
3348: oPop 2
3350: oCodePop
3351: oGetLocal 1
3353: oPushResult
3354: oScopeDeclare
3355: oPop 1
3357: oInput 5
3359: oJumpForward 3385
3361: Choice Lookup Table
          37   3298
          35   3298
          34   3294
          33   3294
          27   3294
          39   3294
          40   3262
          28   3262
          32   3262
          29   3262
          30   3262
3384: oEndChoice
3385: oReturn
3386: oLocalSpace 10
3388: oGetParam 2
3390: oPushResult
3391: oNodeType
3392: oPop 1
3394: oChoice 3667
3396: oGetAddrLocal 1
3398: oPushResult
3399: oGetParam 2
3401: oPushResult
3402: oSetResult 36
3404: oPushResult
3405: oNodeGet
3406: oPop 2
3408: oAssign
3409: oGetAddrLocal 2
3411: oPushResult
3412: oGetParam 2
3414: oPushResult
3415: oSetResult 37
3417: oPushResult
3418: oNodeGet
3419: oPop 2
3421: oAssign
3422: oGetAddrLocal 3
3424: oPushResult
3425: oGetLocal 2
3427: oPushResult
3428: oCall 11851
3430: oPop 1
3432: oAssign
3433: oGetAddrLocal 4
3435: oPushResult
3436: oGetLocal 2
3438: oPushResult
3439: oCall 11946
3441: oPop 1
3443: oAssign
3444: oGetAddrLocal 5
3446: oPushResult
3447: oGetLocal 1
3449: oPushResult
3450: oSetResult 17
3452: oPushResult
3453: oNodeGetInt
3454: oPop 2
3456: oAssign
3457: oInput 14
3459: oGetAddrLocal 6
3461: oPushResult
3462: oGetLocal 3
3464: oAssign
3465: oGetLocal 1
3467: oPushResult
3468: oGetParam 1
3470: oPushResult
3471: oCall 3386
3473: oPop 2
3475: oGetLocal 6
3477: oPushResult
3478: oGetLocal 4
3480: oPushResult
3481: equal
3482: oPop 2
3484: oChoice 3492
3486: oJumpForward 3521
3488: oJumpForward 3498
3490: oJumpForward 3498
3492: Choice Lookup Table
           0   3490
           1   3486
3497: oEndChoice
3498: oInput 13
3500: oGetAddrParam 1
3502: oPushResult
3503: oGetParam 1
3505: oPushResult
3506: oGetLocal 5
3508: oPushResult
3509: add
3510: oPop 2
3512: oAssign
3513: oGetAddrLocal 6
3515: oPushResult
3516: inc
3517: oPop 1
3519: oJumpBack 3465
3521: oInput 15
3523: oJumpForward 3691
3525: oInput 14
3527: oGetAddrLocal 7
3529: oPushResult
3530: oGetParam 2
3532: oPushResult
3533: oSetResult 40
3535: oPushResult
3536: oNodeGet
3537: oPop 2
3539: oAssign
3540: oInputChoice 3544
3542: oJumpForward 3549
3544: Choice Lookup Table
           0   3542
3547: oJumpForward 3615
3549: oGetAddrLocal 8
3551: oPushResult
3552: oGetLocal 7
3554: oPushResult
3555: oScopeFindRequireInScope
3556: oPop 1
3558: oAssign
3559: oInput 12
3561: oGetAddrLocal 9
3563: oPushResult
3564: oGetLocal 8
3566: oPushResult
3567: oSetResult 21
3569: oPushResult
3570: oNodeGet
3571: oPop 2
3573: oAssign
3574: oGetAddrLocal 10
3576: oPushResult
3577: oGetParam 1
3579: oPushResult
3580: oGetLocal 8
3582: oPushResult
3583: oSetResult 22
3585: oPushResult
3586: oNodeGetInt
3587: oPop 2
3589: oPushResult
3590: add
3591: oPop 2
3593: oAssign
3594: oGetLocal 9
3596: oPushResult
3597: oGetLocal 10
3599: oPushResult
3600: oCall 3386
3602: oPop 2
3604: oInputChoice 3608
3606: oJumpForward 3613
3608: Choice Lookup Table
           5   3606
3611: oJumpForward 3615
3613: oJumpBack 3540
3615: oInput 15
3617: oJumpForward 3691
3619: oEmit 16
3621: oGetParam 1
3623: oPushResult
3624: oEmitInt
3625: oPop 1
3627: oCall 5103
3629: oEmit 15
3631: oValueTop
3632: oPushResult
3633: oEmitInt
3634: oPop 1
3636: oValuePop
3637: oEmit 27
3639: oJumpForward 3691
3641: oEmit 16
3643: oGetParam 1
3645: oPushResult
3646: oEmitInt
3647: oPop 1
3649: oCall 5103
3651: oEmit 15
3653: oValueTop
3654: oPushResult
3655: oEmitInt
3656: oPop 1
3658: oValuePop
3659: oEmit 26
3661: oJumpForward 3691
3663: oError 16
3665: oJumpForward 3691
3667: Choice Lookup Table
          34   3663
          33   3663
          27   3663
          39   3663
          40   3641
          28   3641
          32   3619
          29   3619
          30   3619
          37   3525
          35   3396
3690: oEndChoice
3691: oReturn
3692: oLocalSpace 2
3694: oInputChoice 3740
3696: oGetAddrLocal 1
3698: oPushResult
3699: oSetResult 18
3701: oPushResult
3702: LAST_ID
3703: oPushResult
3704: oCall 11739
3706: oPop 2
3708: oAssign
3709: oInput 6
3711: oGetAddrLocal 2
3713: oPushResult
3714: oCall 4047
3716: oPop 1
3718: oGetLocal 1
3720: oPushResult
3721: oSetResult 21
3723: oPushResult
3724: oGetLocal 2
3726: oPushResult
3727: oNodeSet
3728: oPop 3
3730: oGetLocal 1
3732: oPushResult
3733: oScopeDeclare
3734: oPop 1
3736: oInput 5
3738: oJumpForward 3745
3740: Choice Lookup Table
           0   3696
3743: oJumpForward 3747
3745: oJumpBack 3694
3747: oReturn
3748: oLocalSpace 6
3750: oInputChoice 3974
3752: oGetAddrLocal 1
3754: oPushResult
3755: oNodeVecNew
3756: oAssign
3757: oGetAddrLocal 2
3759: oPushResult
3760: oGetParam 1
3762: oPushResult
3763: LAST_ID
3764: oPushResult
3765: oCall 11739
3767: oPop 2
3769: oAssign
3770: oGetLocal 1
3772: oPushResult
3773: oGetLocal 2
3775: oPushResult
3776: oNodeVecAppend
3777: oPop 2
3779: oInputChoice 3785
3781: oInput 0
3783: oJumpForward 3790
3785: Choice Lookup Table
          13   3781
3788: oJumpForward 3792
3790: oJumpBack 3757
3792: oInput 12
3794: oGetAddrLocal 3
3796: oPushResult
3797: oCall 4047
3799: oPop 1
3801: oGetAddrLocal 4
3803: oPushResult
3804: oSetResult 0
3806: oAssign
3807: oGetLocal 4
3809: oPushResult
3810: oGetLocal 1
3812: oPushResult
3813: oNodeVecSize
3814: oPop 1
3816: oPushResult
3817: equal
3818: oPop 2
3820: oChoice 3861
3822: oGetAddrLocal 2
3824: oPushResult
3825: oGetLocal 1
3827: oPushResult
3828: oGetLocal 4
3830: oPushResult
3831: oNodeVecElement
3832: oPop 2
3834: oAssign
3835: oGetLocal 2
3837: oPushResult
3838: oSetResult 21
3840: oPushResult
3841: oGetLocal 3
3843: oPushResult
3844: oNodeSet
3845: oPop 3
3847: oGetLocal 2
3849: oPushResult
3850: oScopeDeclareAlloc
3851: oPop 1
3853: oGetAddrLocal 4
3855: oPushResult
3856: inc
3857: oPop 1
3859: oJumpForward 3866
3861: Choice Lookup Table
           0   3822
3864: oJumpForward 3868
3866: oJumpBack 3807
3868: oInputChoice 3961
3870: oGetLocal 1
3872: oPushResult
3873: oNodeVecSize
3874: oPop 1
3876: oChoice 3880
3878: oJumpForward 3885
3880: Choice Lookup Table
           1   3878
3883: oError 22
3885: oGetAddrLocal 5
3887: oPushResult
3888: oScopeCurrent
3889: oPushResult
3890: oCall 1990
3892: oPop 1
3894: oAssign
3895: oGetLocal 5
3897: oPushResult
3898: oCodePush
3899: oPop 1
3901: oGetAddrLocal 6
3903: oPushResult
3904: oSetResult 0
3906: oAssign
3907: oCall 11477
3909: oPushResult
3910: equal_zero
3911: oPop 1
3913: oChoice 3929
3915: oGetGlobal 3
3917: oPushResult
3918: oScopeEnter
3919: oPop 1
3921: oGetAddrLocal 6
3923: oPushResult
3924: oSetResult 1
3926: oAssign
3927: oJumpForward 3932
3929: Choice Lookup Table
           1   3915
3932: oGetLocal 2
3934: oPushResult
3935: oSetResult 1
3937: oPushResult
3938: oCall 10365
3940: oPop 2
3942: oCall 5390
3944: oCall 8503
3946: oCall 10121
3948: oGetLocal 6
3950: oChoice 3955
3952: oScopeEnd
3953: oJumpForward 3958
3955: Choice Lookup Table
           1   3952
3958: oCodePop
3959: oJumpForward 3964
3961: Choice Lookup Table
           6   3870
3964: oGetLocal 1
3966: oPushResult
3967: oNodeVecDelete
3968: oPop 1
3970: oInput 5
3972: oJumpForward 3979
3974: Choice Lookup Table
           0   3752
3977: oJumpForward 3981
3979: oJumpBack 3750
3981: oReturn
3982: oLocalSpace 2
3984: oInputChoice 3991
3986: oJumpForward 3997
3988: oChangeIntLitToLabelIdent
3989: oJumpForward 3997
3991: Choice Lookup Table
           1   3988
           0   3986
3996: oEndChoice
3997: oGetAddrLocal 1
3999: oPushResult
4000: oSetResult 25
4002: oPushResult
4003: LAST_ID
4004: oPushResult
4005: oCall 11739
4007: oPop 2
4009: oAssign
4010: oGetAddrLocal 2
4012: oPushResult
4013: oLabelNew
4014: oAssign
4015: oGetLocal 1
4017: oPushResult
4018: oSetResult 22
4020: oPushResult
4021: oGetLocal 2
4023: oPushResult
4024: oNodeSetLabel
4025: oPop 3
4027: oGetLocal 1
4029: oPushResult
4030: oScopeDeclare
4031: oPop 1
4033: oInputChoice 4037
4035: oJumpForward 4042
4037: Choice Lookup Table
          13   4035
4040: oJumpForward 4044
4042: oJumpBack 3984
4044: oInput 5
4046: oReturn
4047: oLocalSpace 12
4049: oInputChoice 4522
4051: oGetAddrLocal 1
4053: oPushResult
4054: oScopeFindRequire
4055: oAssign
4056: oGetAddrLocal 1
4058: oPushResult
4059: oCall 543
4061: oPop 1
4063: oGetLocal 1
4065: oPushResult
4066: oNodeType
4067: oPop 1
4069: oChoice 4086
4071: oGetParam 1
4073: oPushResult
4074: oGetLocal 1
4076: oPushResult
4077: oSetResult 21
4079: oPushResult
4080: oNodeGet
4081: oPop 2
4083: oAssign
4084: oJumpForward 4097
4086: Choice Lookup Table
          18   4071
4089: oError 2
4091: oGetParam 1
4093: oPushResult
4094: oGetGlobal 6
4096: oAssign
4097: oJumpForward 4541
4099: oInput 16
4101: oGetAddrLocal 2
4103: oPushResult
4104: oNodeVecNew
4105: oAssign
4106: oGetAddrLocal 3
4108: oPushResult
4109: oSetResult 36
4111: oPushResult
4112: oNodeNew
4113: oPop 1
4115: oAssign
4116: oGetLocal 3
4118: oPushResult
4119: oSetResult 36
4121: oPushResult
4122: oGetGlobal 6
4124: oPushResult
4125: oNodeSet
4126: oPop 3
4128: oCall 5103
4130: oGetLocal 3
4132: oPushResult
4133: oSetResult 38
4135: oPushResult
4136: oValueTop
4137: oPushResult
4138: oNodeSetInt
4139: oPop 3
4141: oValuePop
4142: oInput 21
4144: oCall 5103
4146: oGetLocal 3
4148: oPushResult
4149: oSetResult 39
4151: oPushResult
4152: oValueTop
4153: oPushResult
4154: oNodeSetInt
4155: oPop 3
4157: oValuePop
4158: oGetLocal 3
4160: oPushResult
4161: oSetResult 17
4163: oPushResult
4164: oSetResult 4
4166: oPushResult
4167: oNodeSetInt
4168: oPop 3
4170: oGetLocal 3
4172: oPushResult
4173: oTypeAdd
4174: oPop 1
4176: oGetAddrLocal 4
4178: oPushResult
4179: oSetResult 35
4181: oPushResult
4182: oNodeNew
4183: oPop 1
4185: oAssign
4186: oGetLocal 4
4188: oPushResult
4189: oSetResult 37
4191: oPushResult
4192: oGetLocal 3
4194: oPushResult
4195: oNodeSet
4196: oPop 3
4198: oGetLocal 2
4200: oPushResult
4201: oGetLocal 4
4203: oPushResult
4204: oNodeVecAppend
4205: oPop 2
4207: oInputChoice 4215
4209: oJumpForward 4223
4211: oJumpForward 4221
4213: oJumpForward 4221
4215: Choice Lookup Table
          13   4213
          17   4209
4220: oEndChoice
4221: oJumpBack 4106
4223: oInput 40
4225: oGetAddrLocal 5
4227: oPushResult
4228: oCall 4047
4230: oPop 1
4232: oGetAddrLocal 6
4234: oPushResult
4235: oGetLocal 2
4237: oPushResult
4238: oNodeVecSize
4239: oPop 1
4241: oAssign
4242: oGetAddrLocal 6
4244: oPushResult
4245: dec
4246: oPop 1
4248: oGetAddrLocal 7
4250: oPushResult
4251: oGetLocal 2
4253: oPushResult
4254: oGetLocal 6
4256: oPushResult
4257: oNodeVecElement
4258: oPop 2
4260: oAssign
4261: oGetLocal 7
4263: oPushResult
4264: oSetResult 36
4266: oPushResult
4267: oGetLocal 5
4269: oPushResult
4270: oNodeSet
4271: oPop 3
4273: oGetAddrLocal 8
4275: oPushResult
4276: oGetLocal 7
4278: oPushResult
4279: oSetResult 37
4281: oPushResult
4282: oNodeGet
4283: oPop 2
4285: oAssign
4286: oGetAddrLocal 9
4288: oPushResult
4289: oGetLocal 8
4291: oPushResult
4292: oSetResult 39
4294: oPushResult
4295: oNodeGetInt
4296: oPop 2
4298: oPushResult
4299: oGetLocal 8
4301: oPushResult
4302: oSetResult 38
4304: oPushResult
4305: oNodeGetInt
4306: oPop 2
4308: oPushResult
4309: subtract
4310: oPop 2
4312: oAssign
4313: oGetAddrLocal 9
4315: oPushResult
4316: inc
4317: oPop 1
4319: oGetLocal 7
4321: oPushResult
4322: oSetResult 17
4324: oPushResult
4325: oGetLocal 9
4327: oPushResult
4328: oGetLocal 5
4330: oPushResult
4331: oSetResult 17
4333: oPushResult
4334: oNodeGetInt
4335: oPop 2
4337: oPushResult
4338: multiply
4339: oPop 2
4341: oPushResult
4342: oNodeSetInt
4343: oPop 3
4345: oGetLocal 7
4347: oPushResult
4348: oTypeAdd
4349: oPop 1
4351: oGetAddrLocal 5
4353: oPushResult
4354: oGetLocal 7
4356: oAssign
4357: oGetLocal 6
4359: oPushResult
4360: equal_zero
4361: oPop 1
4363: oChoice 4369
4365: oJumpForward 4374
4367: oJumpForward 4372
4369: Choice Lookup Table
           1   4365
4372: oJumpBack 4242
4374: oGetParam 1
4376: oPushResult
4377: oGetLocal 2
4379: oPushResult
4380: oSetResult 0
4382: oPushResult
4383: oNodeVecElement
4384: oPop 2
4386: oAssign
4387: oGetLocal 2
4389: oPushResult
4390: oNodeVecDelete
4391: oPop 1
4393: oJumpForward 4541
4395: oGetAddrLocal 10
4397: oPushResult
4398: oCall 4047
4400: oPop 1
4402: oGetParam 1
4404: oPushResult
4405: oGetLocal 10
4407: oPushResult
4408: oCall 11767
4410: oPop 1
4412: oAssign
4413: oJumpForward 4541
4415: oGetParam 1
4417: oPushResult
4418: oSetResult 37
4420: oPushResult
4421: oNodeNew
4422: oPop 1
4424: oAssign
4425: oSetResult -1
4427: oPushResult
4428: oSetResult 2
4430: oPushResult
4431: oScopeBegin
4432: oPop 2
4434: oSetResult 22
4436: oPushResult
4437: oCall 3748
4439: oPop 1
4441: oGetAddrLocal 11
4443: oPushResult
4444: oScopeCurrent
4445: oPushResult
4446: oSetResult 17
4448: oPushResult
4449: oNodeGetInt
4450: oPop 2
4452: oAssign
4453: oGetLocal 11
4455: oPushResult
4456: equal_zero
4457: oPop 1
4459: oChoice 4465
4461: oError 19
4463: oJumpForward 4468
4465: Choice Lookup Table
           1   4461
4468: oInput 36
4470: oGetFromParam 1
4472: oPushResult
4473: oSetResult 40
4475: oPushResult
4476: oScopeCurrent
4477: oPushResult
4478: oNodeSet
4479: oPop 3
4481: oGetFromParam 1
4483: oPushResult
4484: oSetResult 17
4486: oPushResult
4487: oGetLocal 11
4489: oPushResult
4490: oNodeSetInt
4491: oPop 3
4493: oScopeEnd
4494: oGetFromParam 1
4496: oPushResult
4497: oTypeAdd
4498: oPop 1
4500: oJumpForward 4541
4502: oGetParam 1
4504: oPushResult
4505: oCall 4542
4507: oPop 1
4509: oJumpForward 4541
4511: oInput 40
4513: oGetAddrLocal 12
4515: oPushResult
4516: oCall 4047
4518: oPop 1
4520: oJumpForward 4541
4522: Choice Lookup Table
          39   4511
          14   4502
          38   4415
          18   4395
          37   4099
           0   4051
4535: oCall 5103
4537: oInput 21
4539: oCall 5103
4541: oReturn
4542: oLocalSpace 11
4544: oGetParam 1
4546: oPushResult
4547: oSetResult 40
4549: oPushResult
4550: oNodeNew
4551: oPop 1
4553: oAssign
4554: oGetAddrLocal 1
4556: oPushResult
4557: oSetResult 0
4559: oAssign
4560: oGetAddrLocal 2
4562: oPushResult
4563: oSetResult 0
4565: oAssign
4566: oGetAddrLocal 3
4568: oPushResult
4569: oSetResult 1
4571: oAssign
4572: oGetAddrLocal 4
4574: oPushResult
4575: oScopeCurrent
4576: oAssign
4577: oSetResult -1
4579: oPushResult
4580: oSetResult 2
4582: oPushResult
4583: oScopeBegin
4584: oPop 2
4586: oInput 0
4588: oGetAddrLocal 5
4590: oPushResult
4591: oSetResult 17
4593: oPushResult
4594: LAST_ID
4595: oPushResult
4596: oCall 11739
4598: oPop 2
4600: oAssign
4601: oGetAddrLocal 6
4603: oPushResult
4604: oSetResult 17
4606: oPushResult
4607: LAST_ID
4608: oPushResult
4609: oCall 11739
4611: oPop 2
4613: oAssign
4614: oGetLocal 5
4616: oPushResult
4617: oSetResult 21
4619: oPushResult
4620: oGetFromParam 1
4622: oPushResult
4623: oNodeSet
4624: oPop 3
4626: oGetLocal 6
4628: oPushResult
4629: oSetResult 21
4631: oPushResult
4632: oGetFromParam 1
4634: oPushResult
4635: oNodeSet
4636: oPop 3
4638: oGetAddrLocal 7
4640: oPushResult
4641: LAST_ID
4642: oPushResult
4643: ID_STRING
4644: oPop 1
4646: oPushResult
4647: oStringAllocLit
4648: oPop 1
4650: oAssign
4651: oGetLocal 5
4653: oPushResult
4654: oSetResult 32
4656: oPushResult
4657: oGetLocal 7
4659: oPushResult
4660: oNodeSetInt
4661: oPop 3
4663: oGetLocal 6
4665: oPushResult
4666: oSetResult 32
4668: oPushResult
4669: oGetLocal 7
4671: oPushResult
4672: oNodeSetInt
4673: oPop 3
4675: oInputChoice 4744
4677: oCall 5103
4679: oGetLocal 2
4681: oPushResult
4682: equal_zero
4683: oPop 1
4685: oChoice 4706
4687: oValueTop
4688: oPushResult
4689: oGetLocal 1
4691: oPushResult
4692: greater
4693: oPop 2
4695: oChoice 4701
4697: oError 26
4699: oJumpForward 4704
4701: Choice Lookup Table
           0   4697
4704: oJumpForward 4709
4706: Choice Lookup Table
           0   4687
4709: oGetLocal 1
4711: oPushResult
4712: oValueTop
4713: oPushResult
4714: equal
4715: oPop 2
4717: oChoice 4733
4719: oGetFromParam 1
4721: oPushResult
4722: oSetResult 43
4724: oPushResult
4725: oSetResult 1
4727: oPushResult
4728: oNodeSetBoolean
4729: oPop 3
4731: oJumpForward 4736
4733: Choice Lookup Table
           0   4719
4736: oGetAddrLocal 1
4738: oPushResult
4739: oValueTop
4740: oAssign
4741: oValuePop
4742: oJumpForward 4749
4744: Choice Lookup Table
           4   4677
           6   4677
4749: oGetLocal 5
4751: oPushResult
4752: oSetResult 22
4754: oPushResult
4755: oGetLocal 1
4757: oPushResult
4758: oNodeSetInt
4759: oPop 3
4761: oGetLocal 6
4763: oPushResult
4764: oSetResult 22
4766: oPushResult
4767: oGetLocal 1
4769: oPushResult
4770: oNodeSetInt
4771: oPop 3
4773: oGetLocal 5
4775: oPushResult
4776: oScopeDeclare
4777: oPop 1
4779: oGetLocal 4
4781: oPushResult
4782: oScopeEnter
4783: oPop 1
4785: oGetLocal 6
4787: oPushResult
4788: oScopeDeclare
4789: oPop 1
4791: oScopeEnd
4792: oGetAddrLocal 1
4794: oPushResult
4795: inc
4796: oPop 1
4798: oGetAddrLocal 2
4800: oPushResult
4801: inc
4802: oPop 1
4804: oInputChoice 4808
4806: oJumpForward 4813
4808: Choice Lookup Table
          13   4806
4811: oJumpForward 4815
4813: oJumpBack 4586
4815: oInput 15
4817: oGetFromParam 1
4819: oPushResult
4820: oSetResult 40
4822: oPushResult
4823: oScopeCurrent
4824: oPushResult
4825: oNodeSet
4826: oPop 3
4828: oGetFromParam 1
4830: oPushResult
4831: oSetResult 17
4833: oPushResult
4834: oSetResult 4
4836: oPushResult
4837: oNodeSetInt
4838: oPop 3
4840: oScopeEnd
4841: oGetGlobal 2
4843: oPushResult
4844: oCall 1990
4846: oPop 1
4848: oPushResult
4849: oCodePush
4850: oPop 1
4852: oGetGlobal 2
4854: oPushResult
4855: oScopeEnter
4856: oPop 1
4858: oGetAddrLocal 8
4860: oPushResult
4861: oGetLocal 2
4863: oPushResult
4864: oSetResult 1
4866: oPushResult
4867: add
4868: oPop 2
4870: oPushResult
4871: oSetResult 16
4873: oPushResult
4874: multiply
4875: oPop 2
4877: oAssign
4878: oGetAddrLocal 9
4880: oPushResult
4881: oGetLocal 8
4883: oPushResult
4884: oSetResult 8
4886: oPushResult
4887: oScopeAlloc
4888: oPop 2
4890: oAssign
4891: oScopeEnd
4892: oGetFromParam 1
4894: oPushResult
4895: oSetResult 42
4897: oPushResult
4898: oGetLocal 9
4900: oPushResult
4901: oNodeSetInt
4902: oPop 3
4904: oGetAddrLocal 10
4906: oPushResult
4907: oGetFromParam 1
4909: oPushResult
4910: oSetResult 40
4912: oPushResult
4913: oNodeGet
4914: oPop 2
4916: oPushResult
4917: oSetResult 15
4919: oPushResult
4920: oNodeGetIter
4921: oPop 2
4923: oAssign
4924: oGetAddrLocal 11
4926: oPushResult
4927: oGetLocal 10
4929: oPushResult
4930: oNodeIterValue
4931: oPop 1
4933: oAssign
4934: oGetLocal 11
4936: oPushResult
4937: oNodeNull
4938: oPop 1
4940: oChoice 4946
4942: oJumpForward 5033
4944: oJumpForward 4949
4946: Choice Lookup Table
           1   4942
4949: oEmit 16
4951: oGetLocal 9
4953: oPushResult
4954: oEmitInt
4955: oPop 1
4957: oEmit 15
4959: oGetLocal 11
4961: oPushResult
4962: oSetResult 22
4964: oPushResult
4965: oNodeGetInt
4966: oPop 2
4968: oPushResult
4969: oEmitInt
4970: oPop 1
4972: oEmit 26
4974: oGetAddrLocal 9
4976: oPushResult
4977: oGetLocal 9
4979: oPushResult
4980: oSetResult 8
4982: oPushResult
4983: add
4984: oPop 2
4986: oAssign
4987: oEmit 16
4989: oGetLocal 9
4991: oPushResult
4992: oEmitInt
4993: oPop 1
4995: oEmit 16
4997: oGetLocal 11
4999: oPushResult
5000: oSetResult 32
5002: oPushResult
5003: oNodeGetInt
5004: oPop 2
5006: oPushResult
5007: oEmitInt
5008: oPop 1
5010: oEmit 28
5012: oGetAddrLocal 9
5014: oPushResult
5015: oGetLocal 9
5017: oPushResult
5018: oSetResult 8
5020: oPushResult
5021: add
5022: oPop 2
5024: oAssign
5025: oGetAddrLocal 10
5027: oPushResult
5028: oNodeIterNext
5029: oPop 1
5031: oJumpBack 4924
5033: oEmit 16
5035: oGetLocal 9
5037: oPushResult
5038: oEmitInt
5039: oPop 1
5041: oEmit 15
5043: oSetResult 0
5045: oPushResult
5046: oEmitInt
5047: oPop 1
5049: oEmit 26
5051: oGetAddrLocal 9
5053: oPushResult
5054: oGetLocal 9
5056: oPushResult
5057: oSetResult 8
5059: oPushResult
5060: add
5061: oPop 2
5063: oAssign
5064: oEmit 16
5066: oGetLocal 9
5068: oPushResult
5069: oEmitInt
5070: oPop 1
5072: oEmit 15
5074: oSetResult 0
5076: oPushResult
5077: oEmitInt
5078: oPop 1
5080: oEmit 28
5082: oGetAddrLocal 9
5084: oPushResult
5085: oGetLocal 9
5087: oPushResult
5088: oSetResult 8
5090: oPushResult
5091: add
5092: oPop 2
5094: oAssign
5095: oCodePop
5096: oGetFromParam 1
5098: oPushResult
5099: oTypeAdd
5100: oPop 1
5102: oReturn
5103: oLocalSpace 0
5105: oCall 5157
5107: oInputChoice 5139
5109: oCall 5176
5111: oValueEqual
5112: oJumpForward 5154
5114: oCall 5157
5116: oValueNotEqual
5117: oJumpForward 5154
5119: oCall 5157
5121: oValueLess
5122: oJumpForward 5154
5124: oCall 5157
5126: oValueGreater
5127: oJumpForward 5154
5129: oCall 5157
5131: oValueLessEqual
5132: oJumpForward 5154
5134: oCall 5157
5136: oValueGreaterEqual
5137: oJumpForward 5154
5139: Choice Lookup Table
          11   5134
          10   5129
           9   5124
           8   5119
           7   5114
           6   5109
5152: oJumpForward 5156
5154: oJumpBack 5107
5156: oReturn
5157: oLocalSpace 0
5159: oCall 5176
5161: oInputChoice 5168
5163: oCall 5176
5165: oValueOr
5166: oJumpForward 5173
5168: Choice Lookup Table
          57   5163
5171: oJumpForward 5175
5173: oJumpBack 5161
5175: oReturn
5176: oLocalSpace 0
5178: oCall 5195
5180: oInputChoice 5187
5182: oCall 5195
5184: oValueAnd
5185: oJumpForward 5192
5187: Choice Lookup Table
          56   5182
5190: oJumpForward 5194
5192: oJumpBack 5180
5194: oReturn
5195: oLocalSpace 0
5197: oInputChoice 5204
5199: oCall 5195
5201: oValueNot
5202: oJumpForward 5209
5204: Choice Lookup Table
          58   5199
5207: oCall 5210
5209: oReturn
5210: oLocalSpace 0
5212: oCall 5236
5214: oInputChoice 5226
5216: oCall 5236
5218: oValueAdd
5219: oJumpForward 5233
5221: oCall 5236
5223: oValueSub
5224: oJumpForward 5233
5226: Choice Lookup Table
          25   5221
          24   5216
5231: oJumpForward 5235
5233: oJumpBack 5214
5235: oReturn
5236: oLocalSpace 0
5238: oCall 5262
5240: oInputChoice 5252
5242: oCall 5262
5244: oValueMult
5245: oJumpForward 5259
5247: oCall 5262
5249: oValueDiv
5250: oJumpForward 5259
5252: Choice Lookup Table
          23   5247
          22   5242
5257: oJumpForward 5261
5259: oJumpBack 5240
5261: oReturn
5262: oLocalSpace 0
5264: oInputChoice 5275
5266: oCall 5283
5268: oJumpForward 5282
5270: oCall 5283
5272: oValueNegate
5273: oJumpForward 5282
5275: Choice Lookup Table
          25   5270
          24   5266
5280: oCall 5283
5282: oReturn
5283: oLocalSpace 1
5285: oInputChoice 5369
5287: TOKEN_VALUE
5288: oPushResult
5289: oValuePush
5290: oPop 1
5292: oJumpForward 5384
5294: oError 16
5296: oJumpForward 5384
5298: oCall 5103
5300: oInput 15
5302: oJumpForward 5384
5304: oGetAddrLocal 1
5306: oPushResult
5307: oScopeFindRequire
5308: oAssign
5309: oGetAddrLocal 1
5311: oPushResult
5312: oCall 543
5314: oPop 1
5316: oGetLocal 1
5318: oPushResult
5319: oNodeType
5320: oPop 1
5322: oChoice 5348
5324: oGetLocal 1
5326: oPushResult
5327: oCall 5385
5329: oPop 1
5331: oJumpForward 5363
5333: oGetLocal 1
5335: oPushResult
5336: oSetResult 22
5338: oPushResult
5339: oNodeGetInt
5340: oPop 2
5342: oPushResult
5343: oValuePush
5344: oPop 1
5346: oJumpForward 5363
5348: Choice Lookup Table
          17   5333
          16   5333
          14   5324
5355: oError 1
5357: oSetResult 0
5359: oPushResult
5360: oValuePush
5361: oPop 1
5363: oJumpForward 5384
5365: oError 16
5367: oJumpForward 5384
5369: Choice Lookup Table
          19   5365
           0   5304
          14   5298
           2   5294
           3   5294
           1   5287
5382: oError 1
5384: oReturn
5385: oLocalSpace 0
5387: oError 16
5389: oReturn
5390: oLocalSpace 1
5392: oGetAddrLocal 1
5394: oPushResult
5395: oSetResult 0
5397: oAssign
5398: oGetAddrLocal 1
5400: oPushResult
5401: oCall 5551
5403: oPop 1
5405: oGetAddrLocal 1
5407: oPushResult
5408: oCall 5451
5410: oPop 1
5412: oReturn
5413: oLocalSpace 0
5415: oGetParam 1
5417: oPushResult
5418: oCall 5551
5420: oPop 1
5422: oTypeSNodeType
5423: oChoice 5442
5425: oJumpForward 5449
5427: oGetParam 1
5429: oPushResult
5430: oLabelNew
5431: oAssign
5432: oEmit 70
5434: oGetFromParam 1
5436: oPushResult
5437: oEmitLabel
5438: oPop 1
5440: oJumpForward 5449
5442: Choice Lookup Table
          30   5427
          31   5425
5447: oError 8
5449: oTypeSPop
5450: oReturn
5451: oLocalSpace 1
5453: oTypeSNodeType
5454: oChoice 5516
5456: oGetAddrLocal 1
5458: oPushResult
5459: oLabelNew
5460: oAssign
5461: oEmit 15
5463: oSetResult 1
5465: oPushResult
5466: oEmitInt
5467: oPop 1
5469: oEmit 68
5471: oGetLocal 1
5473: oPushResult
5474: oEmitLabel
5475: oPop 1
5477: oEmit 77
5479: oGetFromParam 1
5481: oPushResult
5482: oEmitLabel
5483: oPop 1
5485: oEmit 15
5487: oSetResult 0
5489: oPushResult
5490: oEmitInt
5491: oPop 1
5493: oEmit 77
5495: oGetLocal 1
5497: oPushResult
5498: oEmitLabel
5499: oPop 1
5501: oTypeSPop
5502: oGetGlobal 7
5504: oPushResult
5505: oTypeSPush
5506: oPop 1
5508: oGetParam 1
5510: oPushResult
5511: oSetResult 0
5513: oAssign
5514: oJumpForward 5519
5516: Choice Lookup Table
          31   5456
5519: oReturn
5520: oLocalSpace 0
5522: oTypeSNodeType
5523: oChoice 5547
5525: oGetParam 1
5527: oPushResult
5528: oLabelNew
5529: oAssign
5530: oEmit 70
5532: oGetFromParam 1
5534: oPushResult
5535: oEmitLabel
5536: oPop 1
5538: oTypeSPop
5539: oGetGlobal 8
5541: oPushResult
5542: oTypeSPush
5543: oPop 1
5545: oJumpForward 5550
5547: Choice Lookup Table
          30   5525
5550: oReturn
5551: oLocalSpace 0
5553: oGetParam 1
5555: oPushResult
5556: oCall 6084
5558: oPop 1
5560: oInputChoice 6066
5562: oGetParam 1
5564: oPushResult
5565: oCall 5451
5567: oPop 1
5569: oCall 11658
5571: oGetParam 1
5573: oPushResult
5574: oCall 6084
5576: oPop 1
5578: oGetParam 1
5580: oPushResult
5581: oCall 5451
5583: oPop 1
5585: oCall 11658
5587: oCall 11527
5589: oTypeSNodeType
5590: oChoice 5618
5592: oEmit 43
5594: oJumpForward 5637
5596: oEmit 49
5598: oJumpForward 5637
5600: oEmit 55
5602: oJumpForward 5637
5604: oCall 8872
5606: oEmit 15
5608: oSetResult 0
5610: oPushResult
5611: oEmitInt
5612: oPop 1
5614: oEmit 49
5616: oJumpForward 5637
5618: Choice Lookup Table
          38   5604
          39   5604
          34   5600
          33   5600
          40   5596
          28   5596
          32   5592
          30   5592
5635: oError 17
5637: oTypeSPop
5638: oGetGlobal 7
5640: oPushResult
5641: oTypeSPush
5642: oPop 1
5644: oJumpForward 6081
5646: oGetParam 1
5648: oPushResult
5649: oCall 5451
5651: oPop 1
5653: oCall 11658
5655: oGetParam 1
5657: oPushResult
5658: oCall 6084
5660: oPop 1
5662: oGetParam 1
5664: oPushResult
5665: oCall 5451
5667: oPop 1
5669: oCall 11658
5671: oCall 11527
5673: oTypeSNodeType
5674: oChoice 5702
5676: oEmit 44
5678: oJumpForward 5721
5680: oEmit 50
5682: oJumpForward 5721
5684: oEmit 56
5686: oJumpForward 5721
5688: oCall 8872
5690: oEmit 15
5692: oSetResult 0
5694: oPushResult
5695: oEmitInt
5696: oPop 1
5698: oEmit 50
5700: oJumpForward 5721
5702: Choice Lookup Table
          38   5688
          39   5688
          34   5684
          33   5684
          40   5680
          28   5680
          32   5676
          30   5676
5719: oError 17
5721: oTypeSPop
5722: oGetGlobal 7
5724: oPushResult
5725: oTypeSPush
5726: oPop 1
5728: oJumpForward 6081
5730: oGetParam 1
5732: oPushResult
5733: oCall 5451
5735: oPop 1
5737: oCall 11658
5739: oGetParam 1
5741: oPushResult
5742: oCall 6084
5744: oPop 1
5746: oGetParam 1
5748: oPushResult
5749: oCall 5451
5751: oPop 1
5753: oCall 11658
5755: oCall 11527
5757: oTypeSNodeType
5758: oChoice 5786
5760: oEmit 46
5762: oJumpForward 5805
5764: oEmit 52
5766: oJumpForward 5805
5768: oEmit 58
5770: oJumpForward 5805
5772: oCall 8872
5774: oEmit 15
5776: oSetResult 0
5778: oPushResult
5779: oEmitInt
5780: oPop 1
5782: oEmit 52
5784: oJumpForward 5805
5786: Choice Lookup Table
          38   5772
          39   5772
          34   5768
          33   5768
          40   5764
          28   5764
          32   5760
          30   5760
5803: oError 17
5805: oTypeSPop
5806: oGetGlobal 7
5808: oPushResult
5809: oTypeSPush
5810: oPop 1
5812: oJumpForward 6081
5814: oGetParam 1
5816: oPushResult
5817: oCall 5451
5819: oPop 1
5821: oCall 11658
5823: oGetParam 1
5825: oPushResult
5826: oCall 6084
5828: oPop 1
5830: oGetParam 1
5832: oPushResult
5833: oCall 5451
5835: oPop 1
5837: oCall 11658
5839: oCall 11527
5841: oTypeSNodeType
5842: oChoice 5870
5844: oEmit 45
5846: oJumpForward 5889
5848: oEmit 51
5850: oJumpForward 5889
5852: oEmit 57
5854: oJumpForward 5889
5856: oCall 8872
5858: oEmit 15
5860: oSetResult 0
5862: oPushResult
5863: oEmitInt
5864: oPop 1
5866: oEmit 51
5868: oJumpForward 5889
5870: Choice Lookup Table
          38   5856
          39   5856
          34   5852
          33   5852
          40   5848
          28   5848
          32   5844
          30   5844
5887: oError 17
5889: oTypeSPop
5890: oGetGlobal 7
5892: oPushResult
5893: oTypeSPush
5894: oPop 1
5896: oJumpForward 6081
5898: oGetParam 1
5900: oPushResult
5901: oCall 5451
5903: oPop 1
5905: oCall 11658
5907: oGetParam 1
5909: oPushResult
5910: oCall 6084
5912: oPop 1
5914: oGetParam 1
5916: oPushResult
5917: oCall 5451
5919: oPop 1
5921: oCall 11658
5923: oCall 11527
5925: oTypeSNodeType
5926: oChoice 5954
5928: oEmit 48
5930: oJumpForward 5973
5932: oEmit 54
5934: oJumpForward 5973
5936: oEmit 60
5938: oJumpForward 5973
5940: oCall 8872
5942: oEmit 15
5944: oSetResult 0
5946: oPushResult
5947: oEmitInt
5948: oPop 1
5950: oEmit 54
5952: oJumpForward 5973
5954: Choice Lookup Table
          38   5940
          39   5940
          34   5936
          33   5936
          40   5932
          28   5932
          32   5928
          30   5928
5971: oError 17
5973: oTypeSPop
5974: oGetGlobal 7
5976: oPushResult
5977: oTypeSPush
5978: oPop 1
5980: oJumpForward 6081
5982: oGetParam 1
5984: oPushResult
5985: oCall 5451
5987: oPop 1
5989: oCall 11658
5991: oGetParam 1
5993: oPushResult
5994: oCall 6084
5996: oPop 1
5998: oGetParam 1
6000: oPushResult
6001: oCall 5451
6003: oPop 1
6005: oCall 11658
6007: oCall 11527
6009: oTypeSNodeType
6010: oChoice 6038
6012: oEmit 47
6014: oJumpForward 6057
6016: oEmit 53
6018: oJumpForward 6057
6020: oEmit 59
6022: oJumpForward 6057
6024: oCall 8872
6026: oEmit 15
6028: oSetResult 0
6030: oPushResult
6031: oEmitInt
6032: oPop 1
6034: oEmit 53
6036: oJumpForward 6057
6038: Choice Lookup Table
          38   6024
          39   6024
          34   6020
          33   6020
          40   6016
          28   6016
          32   6012
          30   6012
6055: oError 17
6057: oTypeSPop
6058: oGetGlobal 7
6060: oPushResult
6061: oTypeSPush
6062: oPop 1
6064: oJumpForward 6081
6066: Choice Lookup Table
          11   5982
          10   5898
           9   5814
           8   5730
           7   5646
           6   5562
6079: oJumpForward 6083
6081: oJumpBack 5560
6083: oReturn
6084: oLocalSpace 1
6086: oGetAddrLocal 1
6088: oPushResult
6089: oSetResult 0
6091: oAssign
6092: oGetParam 1
6094: oPushResult
6095: oCall 6264
6097: oPop 1
6099: oInputChoice 6232
6101: oTypeSNodeType
6102: oChoice 6173
6104: oGetLocal 1
6106: oPushResult
6107: oSetResult 0
6109: oPushResult
6110: equal_label
6111: oPop 2
6113: oChoice 6122
6115: oGetAddrLocal 1
6117: oPushResult
6118: oLabelNew
6119: oAssign
6120: oJumpForward 6125
6122: Choice Lookup Table
           1   6115
6125: oEmit 68
6127: oGetLocal 1
6129: oPushResult
6130: oEmitLabel
6131: oPop 1
6133: oJumpForward 6180
6135: oGetParam 1
6137: oPushResult
6138: oCall 5520
6140: oPop 1
6142: oGetLocal 1
6144: oPushResult
6145: oSetResult 0
6147: oPushResult
6148: equal_label
6149: oPop 2
6151: oChoice 6160
6153: oGetAddrLocal 1
6155: oPushResult
6156: oLabelNew
6157: oAssign
6158: oJumpForward 6163
6160: Choice Lookup Table
           1   6153
6163: oEmit 68
6165: oGetLocal 1
6167: oPushResult
6168: oEmitLabel
6169: oPop 1
6171: oJumpForward 6180
6173: Choice Lookup Table
          30   6135
          31   6104
6178: oError 8
6180: oTypeSPop
6181: oEmit 77
6183: oGetFromParam 1
6185: oPushResult
6186: oEmitLabel
6187: oPop 1
6189: oGetParam 1
6191: oPushResult
6192: oSetResult 0
6194: oAssign
6195: oGetParam 1
6197: oPushResult
6198: oCall 6264
6200: oPop 1
6202: oTypeSNodeType
6203: oChoice 6216
6205: oJumpForward 6223
6207: oGetParam 1
6209: oPushResult
6210: oCall 5520
6212: oPop 1
6214: oJumpForward 6223
6216: Choice Lookup Table
          30   6207
          31   6205
6221: oError 8
6223: oTypeSPop
6224: oGetGlobal 8
6226: oPushResult
6227: oTypeSPush
6228: oPop 1
6230: oJumpForward 6237
6232: Choice Lookup Table
          57   6101
6235: oJumpForward 6239
6237: oJumpBack 6099
6239: oGetLocal 1
6241: oPushResult
6242: oSetResult 0
6244: oPushResult
6245: equal_label
6246: oPop 2
6248: oChoice 6260
6250: oEmit 77
6252: oGetLocal 1
6254: oPushResult
6255: oEmitLabel
6256: oPop 1
6258: oJumpForward 6263
6260: Choice Lookup Table
           0   6250
6263: oReturn
6264: oLocalSpace 2
6266: oGetAddrLocal 1
6268: oPushResult
6269: oSetResult 0
6271: oAssign
6272: oGetParam 1
6274: oPushResult
6275: oCall 6402
6277: oPop 1
6279: oInputChoice 6394
6281: oTypeSNodeType
6282: oChoice 6295
6284: oJumpForward 6302
6286: oGetParam 1
6288: oPushResult
6289: oCall 5520
6291: oPop 1
6293: oJumpForward 6302
6295: Choice Lookup Table
          30   6286
          31   6284
6300: oError 8
6302: oTypeSPop
6303: oGetLocal 1
6305: oPushResult
6306: oSetResult 0
6308: oPushResult
6309: equal_label
6310: oPop 2
6312: oChoice 6341
6314: oGetAddrLocal 1
6316: oPushResult
6317: oLabelNew
6318: oAssign
6319: oEmit 78
6321: oGetFromParam 1
6323: oPushResult
6324: oEmitLabel
6325: oPop 1
6327: oGetLocal 1
6329: oPushResult
6330: oEmitLabel
6331: oPop 1
6333: oGetParam 1
6335: oPushResult
6336: oGetLocal 1
6338: oAssign
6339: oJumpForward 6344
6341: Choice Lookup Table
           1   6314
6344: oGetAddrLocal 2
6346: oPushResult
6347: oSetResult 0
6349: oAssign
6350: oGetAddrLocal 2
6352: oPushResult
6353: oCall 6402
6355: oPop 1
6357: oTypeSNodeType
6358: oChoice 6371
6360: oJumpForward 6378
6362: oGetAddrLocal 2
6364: oPushResult
6365: oCall 5520
6367: oPop 1
6369: oJumpForward 6378
6371: Choice Lookup Table
          30   6362
          31   6360
6376: oError 8
6378: oEmit 78
6380: oGetLocal 2
6382: oPushResult
6383: oEmitLabel
6384: oPop 1
6386: oGetLocal 1
6388: oPushResult
6389: oEmitLabel
6390: oPop 1
6392: oJumpForward 6399
6394: Choice Lookup Table
          56   6281
6397: oJumpForward 6401
6399: oJumpBack 6279
6401: oReturn
6402: oLocalSpace 1
6404: oInputChoice 6458
6406: oGetAddrLocal 1
6408: oPushResult
6409: oSetResult 0
6411: oAssign
6412: oGetAddrLocal 1
6414: oPushResult
6415: oCall 6402
6417: oPop 1
6419: oTypeSNodeType
6420: oChoice 6449
6422: oGetParam 1
6424: oPushResult
6425: oLabelNew
6426: oAssign
6427: oEmit 68
6429: oGetFromParam 1
6431: oPushResult
6432: oEmitLabel
6433: oPop 1
6435: oEmit 77
6437: oGetLocal 1
6439: oPushResult
6440: oEmitLabel
6441: oPop 1
6443: oJumpForward 6456
6445: oEmit 42
6447: oJumpForward 6456
6449: Choice Lookup Table
          30   6445
          31   6422
6454: oError 8
6456: oJumpForward 6468
6458: Choice Lookup Table
          58   6406
6461: oGetParam 1
6463: oPushResult
6464: oCall 6469
6466: oPop 1
6468: oReturn
6469: oLocalSpace 2
6471: oGetAddrLocal 1
6473: oPushResult
6474: oSetResult 1
6476: oAssign
6477: oGetParam 1
6479: oPushResult
6480: oCall 6705
6482: oPop 1
6484: oInputChoice 6695
6486: oTypeSNodeType
6487: oChoice 6610
6489: oCall 11612
6491: oGetParam 1
6493: oPushResult
6494: oCall 6705
6496: oPop 1
6498: oTypeSNodeType
6499: oChoice 6507
6501: oEmit 22
6503: oCall 8288
6505: oJumpForward 6516
6507: Choice Lookup Table
          34   6501
          33   6501
6512: oCall 11632
6514: oEmit 37
6516: oJumpForward 6627
6518: oGetLocal 1
6520: oChoice 6536
6522: oGetAddrLocal 2
6524: oPushResult
6525: oCall 8655
6527: oAssign
6528: oGetAddrLocal 1
6530: oPushResult
6531: oSetResult 0
6533: oAssign
6534: oJumpForward 6539
6536: Choice Lookup Table
           1   6522
6539: oGetParam 1
6541: oPushResult
6542: oCall 6705
6544: oPop 1
6546: oTypeSNodeType
6547: oChoice 6585
6549: oCall 8764
6551: oEmit 17
6553: oGetLocal 2
6555: oPushResult
6556: oEmitInt
6557: oPop 1
6559: oGetGlobal 14
6561: oPushResult
6562: oTypeSPush
6563: oPop 1
6565: oJumpForward 6595
6567: oCall 8818
6569: oEmit 17
6571: oGetLocal 2
6573: oPushResult
6574: oEmitInt
6575: oPop 1
6577: oGetGlobal 14
6579: oPushResult
6580: oTypeSPush
6581: oPop 1
6583: oJumpForward 6595
6585: Choice Lookup Table
          32   6567
          38   6549
          39   6549
6592: oError 14
6594: oTypeSPop
6595: oJumpForward 6627
6597: oGetParam 1
6599: oPushResult
6600: oCall 6705
6602: oPop 1
6604: oCall 11612
6606: oCall 8288
6608: oJumpForward 6627
6610: Choice Lookup Table
          34   6597
          33   6597
          32   6518
          38   6518
          39   6518
          29   6489
          28   6489
6625: oError 17
6627: oJumpForward 6702
6629: oTypeSNodeType
6630: oChoice 6682
6632: oCall 11612
6634: oGetParam 1
6636: oPushResult
6637: oCall 6705
6639: oPop 1
6641: oCall 11632
6643: oEmit 40
6645: oJumpForward 6693
6647: oGetParam 1
6649: oPushResult
6650: oCall 6705
6652: oPop 1
6654: oTypeSNodeType
6655: oChoice 6669
6657: oCall 11612
6659: oCall 8344
6661: oJumpForward 6680
6663: oCall 11527
6665: oCall 8400
6667: oJumpForward 6680
6669: Choice Lookup Table
          34   6663
          33   6663
          29   6657
          28   6657
6678: oError 17
6680: oJumpForward 6693
6682: Choice Lookup Table
          34   6647
          33   6647
          29   6632
          28   6632
6691: oError 17
6693: oJumpForward 6702
6695: Choice Lookup Table
          25   6629
          24   6486
6700: oJumpForward 6704
6702: oJumpBack 6484
6704: oReturn
6705: oLocalSpace 0
6707: oGetParam 1
6709: oPushResult
6710: oCall 6756
6712: oPop 1
6714: oInputChoice 6746
6716: oCall 11612
6718: oGetParam 1
6720: oPushResult
6721: oCall 6756
6723: oPop 1
6725: oCall 11632
6727: oEmit 34
6729: oJumpForward 6753
6731: oCall 11612
6733: oGetParam 1
6735: oPushResult
6736: oCall 6756
6738: oPop 1
6740: oCall 11632
6742: oEmit 35
6744: oJumpForward 6753
6746: Choice Lookup Table
          23   6731
          22   6716
6751: oJumpForward 6755
6753: oJumpBack 6714
6755: oReturn
6756: oLocalSpace 0
6758: oInputChoice 6784
6760: oGetParam 1
6762: oPushResult
6763: oCall 6797
6765: oPop 1
6767: oCall 11632
6769: oJumpForward 6796
6771: oGetParam 1
6773: oPushResult
6774: oCall 6797
6776: oPop 1
6778: oCall 11632
6780: oEmit 41
6782: oJumpForward 6796
6784: Choice Lookup Table
          25   6771
          24   6760
6789: oGetParam 1
6791: oPushResult
6792: oCall 6797
6794: oPop 1
6796: oReturn
6797: oLocalSpace 6
6799: oInputChoice 7053
6801: oEmit 15
6803: TOKEN_VALUE
6804: oPushResult
6805: oEmitInt
6806: oPop 1
6808: oGetGlobal 6
6810: oPushResult
6811: oTypeSPush
6812: oPop 1
6814: oJumpForward 7074
6816: oEmit 15
6818: TOKEN_VALUE
6819: oPushResult
6820: oEmitInt
6821: oPop 1
6823: oGetGlobal 9
6825: oPushResult
6826: oTypeSPush
6827: oPop 1
6829: oJumpForward 7074
6831: oGetParam 1
6833: oPushResult
6834: oCall 5551
6836: oPop 1
6838: oInput 15
6840: oJumpForward 7074
6842: oGetAddrLocal 1
6844: oPushResult
6845: CURRENT_STRLIT
6846: oPushResult
6847: oStringAllocShortStringLit
6848: oPop 1
6850: oAssign
6851: oEmit 16
6853: oGetLocal 1
6855: oPushResult
6856: oEmitInt
6857: oPop 1
6859: oGetGlobal 13
6861: oPushResult
6862: oTypeSPush
6863: oPop 1
6865: oCall 7886
6867: oCall 7832
6869: oJumpForward 7074
6871: oGetAddrLocal 2
6873: oPushResult
6874: oScopeFindRequire
6875: oAssign
6876: oGetAddrLocal 2
6878: oPushResult
6879: oCall 543
6881: oPop 1
6883: oGetLocal 2
6885: oPushResult
6886: oNodeType
6887: oPop 1
6889: oChoice 6977
6891: oGetLocal 2
6893: oPushResult
6894: oCall 9050
6896: oPop 1
6898: oJumpForward 7002
6900: oGetLocal 2
6902: oPushResult
6903: oCall 9670
6905: oPop 1
6907: oJumpForward 7002
6909: oGetAddrLocal 3
6911: oPushResult
6912: oGetLocal 2
6914: oPushResult
6915: oSetResult 21
6917: oPushResult
6918: oNodeGet
6919: oPop 2
6921: oAssign
6922: oGetLocal 3
6924: oPushResult
6925: oTypeSPush
6926: oPop 1
6928: oTypeSNodeType
6929: oChoice 6953
6931: oEmit 15
6933: oGetLocal 2
6935: oPushResult
6936: oCall 12041
6938: oPop 1
6940: oJumpForward 6966
6942: oEmit 15
6944: oGetLocal 2
6946: oPushResult
6947: oCall 12041
6949: oPop 1
6951: oJumpForward 6966
6953: Choice Lookup Table
          34   6942
          33   6942
          30   6931
          40   6931
          28   6931
6964: oError 16
6966: oJumpForward 7002
6968: oGetLocal 2
6970: oPushResult
6971: oCall 7075
6973: oPop 1
6975: oJumpForward 7002
6977: Choice Lookup Table
          24   6968
          23   6968
          21   6968
          20   6968
          17   6909
          16   6909
          14   6900
          13   6891
6994: oError 6
6996: oGetGlobal 6
6998: oPushResult
6999: oTypeSPush
7000: oPop 1
7002: oJumpForward 7074
7004: oInput 0
7006: oGetAddrLocal 4
7008: oPushResult
7009: oScopeFindRequire
7010: oAssign
7011: oGetAddrLocal 4
7013: oPushResult
7014: oCall 543
7016: oPop 1
7018: oGetLocal 4
7020: oPushResult
7021: oSetResult 0
7023: oPushResult
7024: oCall 10365
7026: oPop 2
7028: oGetAddrLocal 5
7030: oPushResult
7031: oTypeSTop
7032: oAssign
7033: oTypeSPop
7034: oGetAddrLocal 6
7036: oPushResult
7037: oGetLocal 5
7039: oPushResult
7040: oCall 11767
7042: oPop 1
7044: oAssign
7045: oGetLocal 6
7047: oPushResult
7048: oTypeSPush
7049: oPop 1
7051: oJumpForward 7074
7053: Choice Lookup Table
          19   7004
           0   6871
           2   6842
          14   6831
           3   6816
           1   6801
7066: oError 6
7068: oGetGlobal 6
7070: oPushResult
7071: oTypeSPush
7072: oPop 1
7074: oReturn
7075: oLocalSpace 2
7077: oGetAddrLocal 1
7079: oPushResult
7080: oGetParam 1
7082: oPushResult
7083: oSetResult 21
7085: oPushResult
7086: oNodeGet
7087: oPop 2
7089: oAssign
7090: oGetAddrLocal 2
7092: oPushResult
7093: oGetParam 1
7095: oPushResult
7096: oCall 11509
7098: oPop 1
7100: oAssign
7101: oGetLocal 1
7103: oPushResult
7104: oTypeSPush
7105: oPop 1
7107: oTypeSNodeType
7108: oChoice 7807
7110: oGetParam 1
7112: oPushResult
7113: oNodeType
7114: oPop 1
7116: oChoice 7262
7118: oEmit 0
7120: oGetParam 1
7122: oPushResult
7123: oCall 12041
7125: oPop 1
7127: oJumpForward 7272
7129: oGetLocal 2
7131: oPushResult
7132: equal_zero
7133: oPop 1
7135: oChoice 7148
7137: oEmit 3
7139: oGetParam 1
7141: oPushResult
7142: oCall 12041
7144: oPop 1
7146: oJumpForward 7166
7148: Choice Lookup Table
           1   7137
7151: oEmit 9
7153: oGetLocal 2
7155: oPushResult
7156: oEmitInt
7157: oPop 1
7159: oGetParam 1
7161: oPushResult
7162: oCall 12041
7164: oPop 1
7166: oJumpForward 7272
7168: oGetParam 1
7170: oPushResult
7171: oSetResult 33
7173: oPushResult
7174: oNodeGetBoolean
7175: oPop 2
7177: oChoice 7220
7179: oGetLocal 2
7181: oPushResult
7182: equal_zero
7183: oPop 1
7185: oChoice 7198
7187: oEmit 8
7189: oGetParam 1
7191: oPushResult
7192: oCall 12041
7194: oPop 1
7196: oJumpForward 7216
7198: Choice Lookup Table
           1   7187
7201: oEmit 14
7203: oGetLocal 2
7205: oPushResult
7206: oEmitInt
7207: oPop 1
7209: oGetParam 1
7211: oPushResult
7212: oCall 12041
7214: oPop 1
7216: oEmit 23
7218: oJumpForward 7260
7220: Choice Lookup Table
           1   7179
7223: oGetLocal 2
7225: oPushResult
7226: equal_zero
7227: oPop 1
7229: oChoice 7242
7231: oEmit 6
7233: oGetParam 1
7235: oPushResult
7236: oCall 12041
7238: oPop 1
7240: oJumpForward 7260
7242: Choice Lookup Table
           1   7231
7245: oEmit 12
7247: oGetLocal 2
7249: oPushResult
7250: oEmitInt
7251: oPop 1
7253: oGetParam 1
7255: oPushResult
7256: oCall 12041
7258: oPop 1
7260: oJumpForward 7272
7262: Choice Lookup Table
          23   7168
          21   7129
          24   7118
          20   7118
7271: oEndChoice
7272: oJumpForward 7831
7274: oGetParam 1
7276: oPushResult
7277: oNodeType
7278: oPop 1
7280: oChoice 7426
7282: oEmit 1
7284: oGetParam 1
7286: oPushResult
7287: oCall 12041
7289: oPop 1
7291: oJumpForward 7436
7293: oGetLocal 2
7295: oPushResult
7296: equal_zero
7297: oPop 1
7299: oChoice 7312
7301: oEmit 4
7303: oGetParam 1
7305: oPushResult
7306: oCall 12041
7308: oPop 1
7310: oJumpForward 7330
7312: Choice Lookup Table
           1   7301
7315: oEmit 10
7317: oGetLocal 2
7319: oPushResult
7320: oEmitInt
7321: oPop 1
7323: oGetParam 1
7325: oPushResult
7326: oCall 12041
7328: oPop 1
7330: oJumpForward 7436
7332: oGetParam 1
7334: oPushResult
7335: oSetResult 33
7337: oPushResult
7338: oNodeGetBoolean
7339: oPop 2
7341: oChoice 7384
7343: oGetLocal 2
7345: oPushResult
7346: equal_zero
7347: oPop 1
7349: oChoice 7362
7351: oEmit 8
7353: oGetParam 1
7355: oPushResult
7356: oCall 12041
7358: oPop 1
7360: oJumpForward 7380
7362: Choice Lookup Table
           1   7351
7365: oEmit 14
7367: oGetLocal 2
7369: oPushResult
7370: oEmitInt
7371: oPop 1
7373: oGetParam 1
7375: oPushResult
7376: oCall 12041
7378: oPop 1
7380: oEmit 24
7382: oJumpForward 7424
7384: Choice Lookup Table
           1   7343
7387: oGetLocal 2
7389: oPushResult
7390: equal_zero
7391: oPop 1
7393: oChoice 7406
7395: oEmit 7
7397: oGetParam 1
7399: oPushResult
7400: oCall 12041
7402: oPop 1
7404: oJumpForward 7424
7406: Choice Lookup Table
           1   7395
7409: oEmit 13
7411: oGetLocal 2
7413: oPushResult
7414: oEmitInt
7415: oPop 1
7417: oGetParam 1
7419: oPushResult
7420: oCall 12041
7422: oPop 1
7424: oJumpForward 7436
7426: Choice Lookup Table
          23   7332
          21   7293
          24   7282
          20   7282
7435: oEndChoice
7436: oJumpForward 7831
7438: oError 16
7440: oJumpForward 7831
7442: oGetParam 1
7444: oPushResult
7445: oNodeType
7446: oPop 1
7448: oChoice 7594
7450: oEmit 2
7452: oGetParam 1
7454: oPushResult
7455: oCall 12041
7457: oPop 1
7459: oJumpForward 7604
7461: oGetLocal 2
7463: oPushResult
7464: equal_zero
7465: oPop 1
7467: oChoice 7480
7469: oEmit 5
7471: oGetParam 1
7473: oPushResult
7474: oCall 12041
7476: oPop 1
7478: oJumpForward 7498
7480: Choice Lookup Table
           1   7469
7483: oEmit 11
7485: oGetLocal 2
7487: oPushResult
7488: oEmitInt
7489: oPop 1
7491: oGetParam 1
7493: oPushResult
7494: oCall 12041
7496: oPop 1
7498: oJumpForward 7604
7500: oGetParam 1
7502: oPushResult
7503: oSetResult 33
7505: oPushResult
7506: oNodeGetBoolean
7507: oPop 2
7509: oChoice 7552
7511: oGetLocal 2
7513: oPushResult
7514: equal_zero
7515: oPop 1
7517: oChoice 7530
7519: oEmit 8
7521: oGetParam 1
7523: oPushResult
7524: oCall 12041
7526: oPop 1
7528: oJumpForward 7548
7530: Choice Lookup Table
           1   7519
7533: oEmit 14
7535: oGetLocal 2
7537: oPushResult
7538: oEmitInt
7539: oPop 1
7541: oGetParam 1
7543: oPushResult
7544: oCall 12041
7546: oPop 1
7548: oEmit 25
7550: oJumpForward 7592
7552: Choice Lookup Table
           1   7511
7555: oGetLocal 2
7557: oPushResult
7558: equal_zero
7559: oPop 1
7561: oChoice 7574
7563: oEmit 8
7565: oGetParam 1
7567: oPushResult
7568: oCall 12041
7570: oPop 1
7572: oJumpForward 7592
7574: Choice Lookup Table
           1   7563
7577: oEmit 14
7579: oGetLocal 2
7581: oPushResult
7582: oEmitInt
7583: oPop 1
7585: oGetParam 1
7587: oPushResult
7588: oCall 12041
7590: oPop 1
7592: oJumpForward 7604
7594: Choice Lookup Table
          23   7500
          21   7461
          24   7450
          20   7450
7603: oEndChoice
7604: oInputChoice 7634
7606: oTypeSPop
7607: oGetLocal 1
7609: oPushResult
7610: oSetResult 36
7612: oPushResult
7613: oNodeGet
7614: oPop 2
7616: oPushResult
7617: oTypeSPush
7618: oPop 1
7620: oCall 7886
7622: oCall 7832
7624: oJumpForward 7639
7626: oCall 8081
7628: oCall 7886
7630: oCall 7832
7632: oJumpForward 7639
7634: Choice Lookup Table
          16   7626
          18   7606
7639: oJumpForward 7831
7641: oGetParam 1
7643: oPushResult
7644: oNodeType
7645: oPop 1
7647: oChoice 7791
7649: oEmit 16
7651: oGetParam 1
7653: oPushResult
7654: oCall 12041
7656: oPop 1
7658: oJumpForward 7801
7660: oGetLocal 2
7662: oPushResult
7663: equal_zero
7664: oPop 1
7666: oChoice 7679
7668: oEmit 17
7670: oGetParam 1
7672: oPushResult
7673: oCall 12041
7675: oPop 1
7677: oJumpForward 7697
7679: Choice Lookup Table
           1   7668
7682: oEmit 20
7684: oGetLocal 2
7686: oPushResult
7687: oEmitInt
7688: oPop 1
7690: oGetParam 1
7692: oPushResult
7693: oCall 12041
7695: oPop 1
7697: oJumpForward 7801
7699: oGetParam 1
7701: oPushResult
7702: oSetResult 33
7704: oPushResult
7705: oNodeGetBoolean
7706: oPop 2
7708: oChoice 7749
7710: oGetLocal 2
7712: oPushResult
7713: equal_zero
7714: oPop 1
7716: oChoice 7729
7718: oEmit 8
7720: oGetParam 1
7722: oPushResult
7723: oCall 12041
7725: oPop 1
7727: oJumpForward 7747
7729: Choice Lookup Table
           1   7718
7732: oEmit 14
7734: oGetLocal 2
7736: oPushResult
7737: oEmitInt
7738: oPop 1
7740: oGetParam 1
7742: oPushResult
7743: oCall 12041
7745: oPop 1
7747: oJumpForward 7789
7749: Choice Lookup Table
           1   7710
7752: oGetLocal 2
7754: oPushResult
7755: equal_zero
7756: oPop 1
7758: oChoice 7771
7760: oEmit 18
7762: oGetParam 1
7764: oPushResult
7765: oCall 12041
7767: oPop 1
7769: oJumpForward 7789
7771: Choice Lookup Table
           1   7760
7774: oEmit 21
7776: oGetLocal 2
7778: oPushResult
7779: oEmitInt
7780: oPop 1
7782: oGetParam 1
7784: oPushResult
7785: oCall 12041
7787: oPop 1
7789: oJumpForward 7801
7791: Choice Lookup Table
          23   7699
          21   7660
          24   7649
          20   7649
7800: oEndChoice
7801: oCall 7886
7803: oCall 7832
7805: oJumpForward 7831
7807: Choice Lookup Table
          39   7641
          37   7641
          35   7641
          34   7442
          33   7442
          27   7438
          32   7274
          29   7274
          30   7274
          40   7110
          28   7110
7830: oEndChoice
7831: oReturn
7832: oLocalSpace 0
7834: oTypeSNodeType
7835: oChoice 7859
7837: oEmit 23
7839: oJumpForward 7885
7841: oEmit 24
7843: oJumpForward 7885
7845: oError 16
7847: oJumpForward 7885
7849: oEmit 25
7851: oJumpForward 7885
7853: oError 29
7855: oJumpForward 7885
7857: oJumpForward 7885
7859: Choice Lookup Table
          39   7857
          38   7857
          37   7857
          35   7857
          34   7853
          33   7849
          27   7845
          32   7841
          29   7841
          30   7841
          40   7837
          28   7837
7884: oEndChoice
7885: oReturn
7886: oLocalSpace 0
7888: oInputChoice 7926
7890: oTypeSNodeType
7891: oChoice 7905
7893: oCall 7938
7895: oJumpForward 7916
7897: oCall 8081
7899: oJumpForward 7916
7901: oCall 8160
7903: oJumpForward 7916
7905: Choice Lookup Table
          39   7901
          38   7901
          33   7897
          35   7893
7914: oError 10
7916: oJumpForward 7935
7918: oCall 8190
7920: oJumpForward 7935
7922: oCall 8463
7924: oJumpForward 7935
7926: Choice Lookup Table
          18   7922
          20   7918
          16   7890
7933: oJumpForward 7937
7935: oJumpBack 7888
7937: oReturn
7938: oLocalSpace 3
7940: oTypeSNodeType
7941: oChoice 7945
7943: oJumpForward 7950
7945: Choice Lookup Table
          35   7943
7948: oError 10
7950: oTypeSNodeType
7951: oChoice 7955
7953: oJumpForward 7960
7955: Choice Lookup Table
          35   7953
7958: oError 13
7960: oGetAddrLocal 1
7962: oPushResult
7963: oTypeSTop
7964: oPushResult
7965: oSetResult 37
7967: oPushResult
7968: oNodeGet
7969: oPop 2
7971: oPushResult
7972: oCall 11851
7974: oPop 1
7976: oAssign
7977: oGetAddrLocal 2
7979: oPushResult
7980: oTypeSTop
7981: oPushResult
7982: oSetResult 36
7984: oPushResult
7985: oNodeGet
7986: oPop 2
7988: oAssign
7989: oTypeSPop
7990: oGetLocal 2
7992: oPushResult
7993: oTypeSPush
7994: oPop 1
7996: oCall 5390
7998: oCall 11585
8000: oGetLocal 1
8002: oPushResult
8003: equal_zero
8004: oPop 1
8006: oChoice 8020
8008: oEmit 15
8010: oGetLocal 1
8012: oPushResult
8013: oEmitInt
8014: oPop 1
8016: oEmit 40
8018: oJumpForward 8023
8020: Choice Lookup Table
           0   8008
8023: oGetAddrLocal 3
8025: oPushResult
8026: oGetLocal 2
8028: oPushResult
8029: oSetResult 17
8031: oPushResult
8032: oNodeGetInt
8033: oPop 2
8035: oAssign
8036: oGetLocal 3
8038: oPushResult
8039: oSetResult 1
8041: oPushResult
8042: equal
8043: oPop 2
8045: oChoice 8059
8047: oEmit 15
8049: oGetLocal 3
8051: oPushResult
8052: oEmitInt
8053: oPop 1
8055: oEmit 34
8057: oJumpForward 8062
8059: Choice Lookup Table
           0   8047
8062: oEmit 36
8064: oInputChoice 8072
8066: oJumpForward 8080
8068: oJumpForward 8078
8070: oJumpForward 8078
8072: Choice Lookup Table
          13   8070
          17   8066
8077: oEndChoice
8078: oJumpBack 7950
8080: oReturn
8081: oLocalSpace 2
8083: oTypeSNodeType
8084: oChoice 8088
8086: oJumpForward 8093
8088: Choice Lookup Table
          33   8086
8091: oError 29
8093: oGetAddrLocal 1
8095: oPushResult
8096: oTypeSTop
8097: oPushResult
8098: oSetResult 36
8100: oPushResult
8101: oNodeGet
8102: oPop 2
8104: oAssign
8105: oTypeSPop
8106: oGetLocal 1
8108: oPushResult
8109: oTypeSPush
8110: oPop 1
8112: oCall 5390
8114: oCall 11585
8116: oGetAddrLocal 2
8118: oPushResult
8119: oGetLocal 1
8121: oPushResult
8122: oSetResult 17
8124: oPushResult
8125: oNodeGetInt
8126: oPop 2
8128: oAssign
8129: oGetLocal 2
8131: oPushResult
8132: oSetResult 1
8134: oPushResult
8135: equal
8136: oPop 2
8138: oChoice 8152
8140: oEmit 15
8142: oGetLocal 2
8144: oPushResult
8145: oEmitInt
8146: oPop 1
8148: oEmit 34
8150: oJumpForward 8155
8152: Choice Lookup Table
           0   8140
8155: oEmit 36
8157: oInput 17
8159: oReturn
8160: oLocalSpace 0
8162: oTypeSNodeType
8163: oChoice 8167
8165: oJumpForward 8174
8167: Choice Lookup Table
          39   8165
          38   8165
8172: oError 29
8174: oTypeSPop
8175: oGetGlobal 9
8177: oPushResult
8178: oTypeSPush
8179: oPop 1
8181: oCall 5390
8183: oCall 11585
8185: oEmit 36
8187: oInput 17
8189: oReturn
8190: oLocalSpace 2
8192: oTypeSNodeType
8193: oChoice 8197
8195: oJumpForward 8202
8197: Choice Lookup Table
          37   8195
8200: oError 11
8202: oTypeSTop
8203: oPushResult
8204: oSetResult 40
8206: oPushResult
8207: oNodeGet
8208: oPop 2
8210: oPushResult
8211: oScopeEnter
8212: oPop 1
8214: oInput 0
8216: oGetAddrLocal 1
8218: oPushResult
8219: oScopeFindRequire
8220: oAssign
8221: oGetLocal 1
8223: oPushResult
8224: oNodeType
8225: oPop 1
8227: oChoice 8231
8229: oJumpForward 8236
8231: Choice Lookup Table
          22   8229
8234: oError 12
8236: oScopeEnd
8237: oGetAddrLocal 2
8239: oPushResult
8240: oGetLocal 1
8242: oPushResult
8243: oSetResult 22
8245: oPushResult
8246: oNodeGetInt
8247: oPop 2
8249: oAssign
8250: oGetLocal 2
8252: oPushResult
8253: equal_zero
8254: oPop 1
8256: oChoice 8270
8258: oEmit 15
8260: oGetLocal 2
8262: oPushResult
8263: oEmitInt
8264: oPop 1
8266: oEmit 36
8268: oJumpForward 8273
8270: Choice Lookup Table
           0   8258
8273: oTypeSPop
8274: oGetLocal 1
8276: oPushResult
8277: oSetResult 21
8279: oPushResult
8280: oNodeGet
8281: oPop 2
8283: oPushResult
8284: oTypeSPush
8285: oPop 1
8287: oReturn
8288: oLocalSpace 2
8290: oGetAddrLocal 1
8292: oPushResult
8293: oTypeSTop
8294: oPushResult
8295: oSetResult 36
8297: oPushResult
8298: oNodeGet
8299: oPop 2
8301: oAssign
8302: oGetAddrLocal 2
8304: oPushResult
8305: oGetLocal 1
8307: oPushResult
8308: oSetResult 17
8310: oPushResult
8311: oNodeGetInt
8312: oPop 2
8314: oAssign
8315: oGetLocal 2
8317: oPushResult
8318: oSetResult 1
8320: oPushResult
8321: equal
8322: oPop 2
8324: oChoice 8338
8326: oEmit 15
8328: oGetLocal 2
8330: oPushResult
8331: oEmitInt
8332: oPop 1
8334: oEmit 34
8336: oJumpForward 8341
8338: Choice Lookup Table
           0   8326
8341: oEmit 36
8343: oReturn
8344: oLocalSpace 2
8346: oGetAddrLocal 1
8348: oPushResult
8349: oTypeSTop
8350: oPushResult
8351: oSetResult 36
8353: oPushResult
8354: oNodeGet
8355: oPop 2
8357: oAssign
8358: oGetAddrLocal 2
8360: oPushResult
8361: oGetLocal 1
8363: oPushResult
8364: oSetResult 17
8366: oPushResult
8367: oNodeGetInt
8368: oPop 2
8370: oAssign
8371: oGetLocal 2
8373: oPushResult
8374: oSetResult 1
8376: oPushResult
8377: equal
8378: oPop 2
8380: oChoice 8394
8382: oEmit 15
8384: oGetLocal 2
8386: oPushResult
8387: oEmitInt
8388: oPop 1
8390: oEmit 34
8392: oJumpForward 8397
8394: Choice Lookup Table
           0   8382
8397: oEmit 39
8399: oReturn
8400: oLocalSpace 2
8402: oEmit 38
8404: oGetAddrLocal 1
8406: oPushResult
8407: oTypeSTop
8408: oPushResult
8409: oSetResult 36
8411: oPushResult
8412: oNodeGet
8413: oPop 2
8415: oAssign
8416: oGetAddrLocal 2
8418: oPushResult
8419: oGetLocal 1
8421: oPushResult
8422: oSetResult 17
8424: oPushResult
8425: oNodeGetInt
8426: oPop 2
8428: oAssign
8429: oGetLocal 2
8431: oPushResult
8432: oSetResult 1
8434: oPushResult
8435: equal
8436: oPop 2
8438: oChoice 8452
8440: oEmit 15
8442: oGetLocal 2
8444: oPushResult
8445: oEmitInt
8446: oPop 1
8448: oEmit 35
8450: oJumpForward 8455
8452: Choice Lookup Table
           0   8440
8455: oTypeSPop
8456: oGetGlobal 6
8458: oPushResult
8459: oTypeSPush
8460: oPop 1
8462: oReturn
8463: oLocalSpace 1
8465: oTypeSNodeType
8466: oChoice 8474
8468: oJumpForward 8481
8470: oError 29
8472: oJumpForward 8481
8474: Choice Lookup Table
          34   8470
          33   8468
8479: oError 9
8481: oEmit 25
8483: oGetAddrLocal 1
8485: oPushResult
8486: oTypeSTop
8487: oAssign
8488: oTypeSPop
8489: oGetLocal 1
8491: oPushResult
8492: oSetResult 36
8494: oPushResult
8495: oNodeGet
8496: oPop 2
8498: oPushResult
8499: oTypeSPush
8500: oPop 1
8502: oReturn
8503: oLocalSpace 2
8505: oGetAddrLocal 1
8507: oPushResult
8508: oTypeSNodeType
8509: oAssign
8510: oTypeSPop
8511: oGetLocal 1
8513: oPushResult
8514: oTypeSNodeType
8515: oPushResult
8516: equal_node_type
8517: oPop 2
8519: oChoice 8651
8521: oTypeSNodeType
8522: oChoice 8636
8524: oGetLocal 1
8526: oChoice 8533
8528: oEmit 30
8530: oReturn
8531: oJumpForward 8536
8533: Choice Lookup Table
          29   8528
8536: oJumpForward 8647
8538: oGetLocal 1
8540: oChoice 8547
8542: oEmit 31
8544: oReturn
8545: oJumpForward 8550
8547: Choice Lookup Table
          28   8542
8550: oJumpForward 8647
8552: oGetLocal 1
8554: oChoice 8587
8556: oReturn
8557: oJumpForward 8592
8559: oTypeSTop
8560: oPushResult
8561: oGetGlobal 10
8563: oPushResult
8564: equal_node
8565: oPop 2
8567: oChoice 8582
8569: oEmit 15
8571: oSetResult 1
8573: oPushResult
8574: oEmitInt
8575: oPop 1
8577: oEmit 36
8579: oReturn
8580: oJumpForward 8585
8582: Choice Lookup Table
           1   8569
8585: oJumpForward 8592
8587: Choice Lookup Table
          38   8559
          34   8556
8592: oJumpForward 8647
8594: oGetLocal 1
8596: oChoice 8601
8598: oReturn
8599: oJumpForward 8604
8601: Choice Lookup Table
          33   8598
8604: oJumpForward 8647
8606: oGetLocal 1
8608: oChoice 8629
8610: oReturn
8611: oJumpForward 8634
8613: oGetGlobal 9
8615: oPushResult
8616: oTypeSPush
8617: oPop 1
8619: oGetAddrLocal 2
8621: oPushResult
8622: oCall 8655
8624: oAssign
8625: oTypeSPop
8626: oReturn
8627: oJumpForward 8634
8629: Choice Lookup Table
          32   8613
          38   8610
8634: oJumpForward 8647
8636: Choice Lookup Table
          39   8606
          34   8594
          33   8552
          29   8538
          28   8524
8647: oError 14
8649: oJumpForward 8654
8651: Choice Lookup Table
           0   8521
8654: oReturn
8655: oLocalSpace 1
8657: oGetAddrLocal 1
8659: oPushResult
8660: oGetGlobal 14
8662: oPushResult
8663: oScopeAllocType
8664: oPop 1
8666: oAssign
8667: oTypeSNodeType
8668: oChoice 8736
8670: oEmit 17
8672: oGetLocal 1
8674: oPushResult
8675: oEmitInt
8676: oPop 1
8678: oEmit 22
8680: oEmit 29
8682: oGetGlobal 14
8684: oPushResult
8685: oSetResult 17
8687: oPushResult
8688: oNodeGetInt
8689: oPop 2
8691: oPushResult
8692: oEmitInt
8693: oPop 1
8695: oJumpForward 8745
8697: oEmit 17
8699: oGetLocal 1
8701: oPushResult
8702: oEmitInt
8703: oPop 1
8705: oEmit 15
8707: oSetResult 1
8709: oPushResult
8710: oEmitInt
8711: oPop 1
8713: oEmit 27
8715: oEmit 17
8717: oGetLocal 1
8719: oPushResult
8720: oSetResult 1
8722: oPushResult
8723: add
8724: oPop 2
8726: oPushResult
8727: oEmitInt
8728: oPop 1
8730: oEmit 22
8732: oEmit 27
8734: oJumpForward 8745
8736: Choice Lookup Table
          32   8697
          38   8670
          39   8670
8743: oError 14
8745: oTypeSPop
8746: oEmit 17
8748: oGetLocal 1
8750: oPushResult
8751: oEmitInt
8752: oPop 1
8754: oGetGlobal 14
8756: oPushResult
8757: oTypeSPush
8758: oPop 1
8760: oGetLocal 1
8762: oReturn
8763: oReturn
8764: oLocalSpace 0
8766: oEmit 61
8768: oSetResult 16
8770: oPushResult
8771: oEmitInt
8772: oPop 1
8774: oEmit 19
8776: oSetResult 8
8778: oPushResult
8779: oEmitInt
8780: oPop 1
8782: oEmit 22
8784: oEmit 28
8786: oEmit 19
8788: oSetResult 0
8790: oPushResult
8791: oEmitInt
8792: oPop 1
8794: oEmit 22
8796: oEmit 28
8798: oEmit 64
8800: oGetGlobal 19
8802: oPushResult
8803: oCall 12041
8805: oPop 1
8807: oEmit 63
8809: oSetResult 16
8811: oPushResult
8812: oEmitInt
8813: oPop 1
8815: oTypeSPop
8816: oTypeSPop
8817: oReturn
8818: oLocalSpace 0
8820: oEmit 61
8822: oSetResult 12
8824: oPushResult
8825: oEmitInt
8826: oPop 1
8828: oEmit 19
8830: oSetResult 8
8832: oPushResult
8833: oEmitInt
8834: oPop 1
8836: oEmit 22
8838: oEmit 26
8840: oEmit 19
8842: oSetResult 0
8844: oPushResult
8845: oEmitInt
8846: oPop 1
8848: oEmit 22
8850: oEmit 28
8852: oEmit 64
8854: oGetGlobal 20
8856: oPushResult
8857: oCall 12041
8859: oPop 1
8861: oEmit 63
8863: oSetResult 12
8865: oPushResult
8866: oEmitInt
8867: oPop 1
8869: oTypeSPop
8870: oTypeSPop
8871: oReturn
8872: oLocalSpace 1
8874: oEmit 61
8876: oSetResult 24
8878: oPushResult
8879: oEmitInt
8880: oPop 1
8882: oEmit 19
8884: oSetResult 8
8886: oPushResult
8887: oEmitInt
8888: oPop 1
8890: oEmit 22
8892: oEmit 28
8894: oEmit 19
8896: oSetResult 0
8898: oPushResult
8899: oEmitInt
8900: oPop 1
8902: oEmit 22
8904: oEmit 28
8906: oGetAddrLocal 1
8908: oPushResult
8909: oGetGlobal 6
8911: oPushResult
8912: oScopeAllocType
8913: oPop 1
8915: oAssign
8916: oEmit 19
8918: oSetResult 16
8920: oPushResult
8921: oEmitInt
8922: oPop 1
8924: oEmit 17
8926: oGetLocal 1
8928: oPushResult
8929: oEmitInt
8930: oPop 1
8932: oEmit 28
8934: oEmit 64
8936: oGetGlobal 21
8938: oPushResult
8939: oCall 12041
8941: oPop 1
8943: oEmit 3
8945: oGetLocal 1
8947: oPushResult
8948: oEmitInt
8949: oPop 1
8951: oEmit 63
8953: oSetResult 24
8955: oPushResult
8956: oEmitInt
8957: oPop 1
8959: oTypeSPop
8960: oGetGlobal 6
8962: oPushResult
8963: oTypeSPush
8964: oPop 1
8966: oReturn
8967: oLocalSpace 2
8969: oGetAddrLocal 2
8971: oPushResult
8972: oGetParam 1
8974: oPushResult
8975: oSetResult 26
8977: oPushResult
8978: oNodeGetString
8979: oPop 2
8981: oAssign
8982: oGetLocal 2
8984: oPushResult
8985: oSetResult 0
8987: oPushResult
8988: equal_string
8989: oPop 2
8991: oChoice 9028
8993: oGetAddrLocal 1
8995: oPushResult
8996: oGetParam 1
8998: oPushResult
8999: oSetResult 4
9001: oPushResult
9002: oNodeGetInt
9003: oPop 2
9005: oPushResult
9006: ID_STRING
9007: oPop 1
9009: oPushResult
9010: oStringAllocLit
9011: oPop 1
9013: oAssign
9014: oJumpForward 9034
9016: oGetAddrLocal 1
9018: oPushResult
9019: oGetLocal 2
9021: oPushResult
9022: oStringAllocLit
9023: oPop 1
9025: oAssign
9026: oJumpForward 9034
9028: Choice Lookup Table
           0   9016
           1   8993
9033: oEndChoice
9034: oEmit 79
9036: oGetParam 1
9038: oPushResult
9039: oCall 12041
9041: oPop 1
9043: oGetLocal 1
9045: oPushResult
9046: oEmitInt
9047: oPop 1
9049: oReturn
9050: oLocalSpace 10
9052: oGetParam 1
9054: oPushResult
9055: oSetResult 25
9057: oPushResult
9058: oNodeGetBoolean
9059: oPop 2
9061: oChoice 9088
9063: oGetParam 1
9065: oPushResult
9066: oSetResult 28
9068: oPushResult
9069: oNodeGetBoolean
9070: oPop 2
9072: oChoice 9083
9074: oGetParam 1
9076: oPushResult
9077: oCall 8967
9079: oPop 1
9081: oJumpForward 9086
9083: Choice Lookup Table
           0   9074
9086: oJumpForward 9091
9088: Choice Lookup Table
           1   9063
9091: oGetParam 1
9093: oPushResult
9094: oSetResult 28
9096: oPushResult
9097: oSetResult 1
9099: oPushResult
9100: oNodeSetBoolean
9101: oPop 3
9103: oGetAddrLocal 1
9105: oPushResult
9106: oGetParam 1
9108: oPushResult
9109: oSetResult 27
9111: oPushResult
9112: oNodeGetBoolean
9113: oPop 2
9115: oAssign
9116: oGetAddrLocal 4
9118: oPushResult
9119: oGetParam 1
9121: oPushResult
9122: oNodeType
9123: oPop 1
9125: oPushResult
9126: oSetResult 13
9128: oPushResult
9129: equal_node_type
9130: oPop 2
9132: oAssign
9133: oGetLocal 4
9135: oChoice 9162
9137: oGetAddrLocal 2
9139: oPushResult
9140: oGetParam 1
9142: oPushResult
9143: oSetResult 21
9145: oPushResult
9146: oNodeGet
9147: oPop 2
9149: oAssign
9150: oGetAddrLocal 3
9152: oPushResult
9153: oGetLocal 2
9155: oPushResult
9156: oScopeAllocType
9157: oPop 1
9159: oAssign
9160: oJumpForward 9165
9162: Choice Lookup Table
           1   9137
9165: oGetAddrLocal 5
9167: oPushResult
9168: oGetParam 1
9170: oPushResult
9171: oSetResult 23
9173: oPushResult
9174: oNodeGet
9175: oPop 2
9177: oAssign
9178: oGetAddrLocal 6
9180: oPushResult
9181: oGetLocal 5
9183: oPushResult
9184: oSetResult 17
9186: oPushResult
9187: oNodeGetInt
9188: oPop 2
9190: oAssign
9191: oGetLocal 1
9193: oChoice 9215
9195: oEmit 62
9197: oGetLocal 6
9199: oPushResult
9200: oEmitInt
9201: oPop 1
9203: oJumpForward 9221
9205: oEmit 61
9207: oGetLocal 6
9209: oPushResult
9210: oEmitInt
9211: oPop 1
9213: oJumpForward 9221
9215: Choice Lookup Table
           0   9205
           1   9195
9220: oEndChoice
9221: oGetParam 1
9223: oPushResult
9224: oCall 11489
9226: oPop 1
9228: oPushResult
9229: oSetResult 0
9231: oPushResult
9232: greater
9233: oPop 2
9235: oChoice 9268
9237: oEmit 19
9239: oSetResult 0
9241: oPushResult
9242: oEmitInt
9243: oPop 1
9245: oEmit 20
9247: oGetParam 1
9249: oPushResult
9250: oCall 11509
9252: oPop 1
9254: oPushResult
9255: oEmitInt
9256: oPop 1
9258: oSetResult 0
9260: oPushResult
9261: oEmitInt
9262: oPop 1
9264: oEmit 28
9266: oJumpForward 9271
9268: Choice Lookup Table
           1   9237
9271: oGetAddrLocal 7
9273: oPushResult
9274: oGetLocal 5
9276: oPushResult
9277: oSetResult 15
9279: oPushResult
9280: oNodeGetIter
9281: oPop 2
9283: oAssign
9284: oGetAddrLocal 8
9286: oPushResult
9287: oGetLocal 7
9289: oPushResult
9290: oNodeIterValue
9291: oPop 1
9293: oAssign
9294: oInputChoice 9491
9296: oGetLocal 8
9298: oPushResult
9299: oNodeNull
9300: oPop 1
9302: oChoice 9308
9304: oJumpForward 9487
9306: oJumpForward 9311
9308: Choice Lookup Table
           1   9304
9311: oGetAddrLocal 9
9313: oPushResult
9314: oGetLocal 8
9316: oPushResult
9317: oSetResult 22
9319: oPushResult
9320: oNodeGetInt
9321: oPop 2
9323: oAssign
9324: oEmit 19
9326: oGetLocal 9
9328: oPushResult
9329: oEmitInt
9330: oPop 1
9332: oGetLocal 8
9334: oPushResult
9335: oSetResult 21
9337: oPushResult
9338: oNodeGet
9339: oPop 2
9341: oPushResult
9342: oTypeSPush
9343: oPop 1
9345: oGetLocal 8
9347: oPushResult
9348: oSetResult 33
9350: oPushResult
9351: oNodeGetBoolean
9352: oPop 2
9354: oChoice 9440
9356: oSetResult 1
9358: oPushResult
9359: oCall 10317
9361: oPop 1
9363: oCall 11527
9365: oEmit 28
9367: oJumpForward 9446
9369: oCall 5390
9371: oCall 8503
9373: oTypeSNodeType
9374: oChoice 9414
9376: oEmit 26
9378: oJumpForward 9438
9380: oEmit 27
9382: oJumpForward 9438
9384: oError 16
9386: oJumpForward 9438
9388: oEmit 28
9390: oJumpForward 9438
9392: oGetAddrLocal 10
9394: oPushResult
9395: oTypeSTop
9396: oPushResult
9397: oSetResult 17
9399: oPushResult
9400: oNodeGetInt
9401: oPop 2
9403: oAssign
9404: oEmit 29
9406: oGetLocal 10
9408: oPushResult
9409: oEmitInt
9410: oPop 1
9412: oJumpForward 9438
9414: Choice Lookup Table
          39   9392
          37   9392
          35   9392
          34   9388
          33   9388
          27   9384
          32   9380
          29   9380
          30   9380
          40   9376
          28   9376
9437: oEndChoice
9438: oJumpForward 9446
9440: Choice Lookup Table
           0   9369
           1   9356
9445: oEndChoice
9446: oTypeSPop
9447: oGetAddrLocal 7
9449: oPushResult
9450: oNodeIterNext
9451: oPop 1
9453: oGetAddrLocal 8
9455: oPushResult
9456: oGetLocal 7
9458: oPushResult
9459: oNodeIterValue
9460: oPop 1
9462: oAssign
9463: oGetLocal 8
9465: oPushResult
9466: oNodeNull
9467: oPop 1
9469: oChoice 9477
9471: oJumpForward 9487
9473: oJumpForward 9483
9475: oJumpForward 9483
9477: Choice Lookup Table
           0   9475
           1   9471
9482: oEndChoice
9483: oInput 13
9485: oJumpBack 9296
9487: oInput 15
9489: oJumpForward 9494
9491: Choice Lookup Table
          14   9296
9494: oGetLocal 8
9496: oPushResult
9497: oNodeNull
9498: oPop 1
9500: oChoice 9506
9502: oError 15
9504: oJumpForward 9509
9506: Choice Lookup Table
           0   9502
9509: oGetLocal 4
9511: oChoice 9540
9513: oEmit 19
9515: oGetParam 1
9517: oPushResult
9518: oSetResult 31
9520: oPushResult
9521: oNodeGetInt
9522: oPop 2
9524: oPushResult
9525: oEmitInt
9526: oPop 1
9528: oEmit 17
9530: oGetLocal 3
9532: oPushResult
9533: oEmitInt
9534: oPop 1
9536: oEmit 28
9538: oJumpForward 9543
9540: Choice Lookup Table
           1   9513
9543: oGetLocal 1
9545: oChoice 9569
9547: oEmit 65
9549: oGetParam 1
9551: oPushResult
9552: oCall 12041
9554: oPop 1
9556: oJumpForward 9575
9558: oEmit 64
9560: oGetParam 1
9562: oPushResult
9563: oCall 12041
9565: oPop 1
9567: oJumpForward 9575
9569: Choice Lookup Table
           0   9558
           1   9547
9574: oEndChoice
9575: oGetLocal 4
9577: oChoice 9658
9579: oGetLocal 2
9581: oPushResult
9582: oTypeSPush
9583: oPop 1
9585: oTypeSNodeType
9586: oChoice 9632
9588: oEmit 3
9590: oGetLocal 3
9592: oPushResult
9593: oEmitInt
9594: oPop 1
9596: oJumpForward 9656
9598: oEmit 4
9600: oGetLocal 3
9602: oPushResult
9603: oEmitInt
9604: oPop 1
9606: oJumpForward 9656
9608: oError 16
9610: oJumpForward 9656
9612: oEmit 5
9614: oGetLocal 3
9616: oPushResult
9617: oEmitInt
9618: oPop 1
9620: oJumpForward 9656
9622: oEmit 17
9624: oGetLocal 3
9626: oPushResult
9627: oEmitInt
9628: oPop 1
9630: oJumpForward 9656
9632: Choice Lookup Table
          39   9622
          37   9622
          35   9622
          34   9612
          33   9612
          27   9608
          32   9598
          29   9598
          30   9598
          40   9588
          28   9588
9655: oEndChoice
9656: oJumpForward 9661
9658: Choice Lookup Table
           1   9579
9661: oEmit 63
9663: oGetLocal 6
9665: oPushResult
9666: oEmitInt
9667: oPop 1
9669: oReturn
9670: oLocalSpace 0
9672: oGetParam 1
9674: oPushResult
9675: oGetGlobal 15
9677: oPushResult
9678: oNodeEqual
9679: oPop 2
9681: oChoice 9721
9683: oInput 14
9685: oCall 5390
9687: oTypeSNodeType
9688: oChoice 9696
9690: oJumpForward 9709
9692: oEmit 30
9694: oJumpForward 9709
9696: Choice Lookup Table
          32   9692
          29   9692
          30   9692
          40   9690
          28   9690
9707: oError 14
9709: oTypeSPop
9710: oGetGlobal 6
9712: oPushResult
9713: oTypeSPush
9714: oPop 1
9716: oInput 15
9718: oReturn
9719: oJumpForward 9724
9721: Choice Lookup Table
           1   9683
9724: oGetParam 1
9726: oPushResult
9727: oGetGlobal 16
9729: oPushResult
9730: oNodeEqual
9731: oPop 2
9733: oChoice 9767
9735: oInput 14
9737: oCall 5390
9739: oTypeSNodeType
9740: oChoice 9748
9742: oEmit 31
9744: oJumpForward 9755
9746: oJumpForward 9755
9748: Choice Lookup Table
          29   9746
          28   9742
9753: oError 14
9755: oTypeSPop
9756: oGetGlobal 9
9758: oPushResult
9759: oTypeSPush
9760: oPop 1
9762: oInput 15
9764: oReturn
9765: oJumpForward 9770
9767: Choice Lookup Table
           1   9735
9770: oGetParam 1
9772: oPushResult
9773: oGetGlobal 17
9775: oPushResult
9776: oNodeEqual
9777: oPop 2
9779: oChoice 9819
9781: oInput 14
9783: oCall 5390
9785: oTypeSNodeType
9786: oChoice 9807
9788: oTypeSTop
9789: oPushResult
9790: oSetResult 43
9792: oPushResult
9793: oNodeGetBoolean
9794: oPop 2
9796: oChoice 9802
9798: oError 28
9800: oJumpForward 9805
9802: Choice Lookup Table
           1   9798
9805: oJumpForward 9812
9807: Choice Lookup Table
          40   9788
9810: oError 14
9812: oEmit 33
9814: oInput 15
9816: oReturn
9817: oJumpForward 9822
9819: Choice Lookup Table
           1   9781
9822: oGetParam 1
9824: oPushResult
9825: oGetGlobal 18
9827: oPushResult
9828: oNodeEqual
9829: oPop 2
9831: oChoice 9871
9833: oInput 14
9835: oCall 5390
9837: oTypeSNodeType
9838: oChoice 9859
9840: oTypeSTop
9841: oPushResult
9842: oSetResult 43
9844: oPushResult
9845: oNodeGetBoolean
9846: oPop 2
9848: oChoice 9854
9850: oError 28
9852: oJumpForward 9857
9854: Choice Lookup Table
           1   9850
9857: oJumpForward 9864
9859: Choice Lookup Table
          40   9840
9862: oError 14
9864: oEmit 32
9866: oInput 15
9868: oReturn
9869: oJumpForward 9874
9871: Choice Lookup Table
           1   9833
9874: oError 16
9876: oReturn
9877: oLocalSpace 0
9879: oInputChoice 9942
9881: oCall 11340
9883: oJumpForward 9973
9885: oCall 11347
9887: oJumpForward 9973
9889: oCall 11471
9891: oJumpForward 9973
9893: oCall 11474
9895: oJumpForward 9973
9897: oCall 10555
9899: oJumpForward 9973
9901: oCall 10878
9903: oJumpForward 9973
9905: oCall 10621
9907: oJumpForward 9973
9909: oCall 10798
9911: oJumpForward 9973
9913: oCall 10963
9915: oJumpForward 9973
9917: oCall 10931
9919: oJumpForward 9973
9921: oCall 11317
9923: oJumpForward 9973
9925: oCall 9974
9927: oJumpForward 9973
9929: oCall 10995
9931: oJumpForward 9973
9933: oCall 11265
9935: oJumpForward 9973
9937: oChangeIntLitToLabelIdent
9938: oCall 9974
9940: oJumpForward 9973
9942: Choice Lookup Table
           1   9937
          55   9933
          53   9929
           0   9925
          35   9921
          51   9917
          52   9913
          49   9909
          44   9905
          48   9901
          41   9897
          68   9893
          67   9889
          66   9885
          65   9881
9973: oReturn
9974: oLocalSpace 1
9976: oGetAddrLocal 1
9978: oPushResult
9979: oScopeFindRequire
9980: oAssign
9981: oGetAddrLocal 1
9983: oPushResult
9984: oCall 543
9986: oPop 1
9988: oGetLocal 1
9990: oPushResult
9991: oNodeType
9992: oPop 1
9994: oChoice 10034
9996: oGetLocal 1
9998: oPushResult
9999: oCall 10050
10001: oPop 1
10003: oCall 9877
10005: oJumpForward 10049
10007: oGetLocal 1
10009: oPushResult
10010: oCall 9050
10012: oPop 1
10014: oJumpForward 10049
10016: oGetLocal 1
10018: oPushResult
10019: oCall 10100
10021: oPop 1
10023: oJumpForward 10049
10025: oGetLocal 1
10027: oPushResult
10028: oCall 10190
10030: oPop 1
10032: oJumpForward 10049
10034: Choice Lookup Table
          13   10025
          23   10016
          21   10016
          20   10016
          12   10007
          25   9996
10047: oError 0
10049: oReturn
10050: oLocalSpace 0
10052: oGetParam 1
10054: oPushResult
10055: oSetResult 34
10057: oPushResult
10058: oNodeGetBoolean
10059: oPop 2
10061: oChoice 10067
10063: oError 21
10065: oJumpForward 10070
10067: Choice Lookup Table
           1   10063
10070: oEmit 77
10072: oGetParam 1
10074: oPushResult
10075: oSetResult 22
10077: oPushResult
10078: oNodeGetLabel
10079: oPop 2
10081: oPushResult
10082: oEmitLabel
10083: oPop 1
10085: oGetParam 1
10087: oPushResult
10088: oSetResult 34
10090: oPushResult
10091: oSetResult 1
10093: oPushResult
10094: oNodeSetBoolean
10095: oPop 3
10097: oInput 12
10099: oReturn
10100: oLocalSpace 0
10102: oGetParam 1
10104: oPushResult
10105: oSetResult 1
10107: oPushResult
10108: oCall 10365
10110: oPop 2
10112: oInput 4
10114: oCall 5390
10116: oCall 8503
10118: oCall 10121
10120: oReturn
10121: oLocalSpace 1
10123: oTypeSNodeType
10124: oChoice 10164
10126: oEmit 26
10128: oJumpForward 10188
10130: oEmit 27
10132: oJumpForward 10188
10134: oError 16
10136: oJumpForward 10188
10138: oEmit 28
10140: oJumpForward 10188
10142: oGetAddrLocal 1
10144: oPushResult
10145: oTypeSTop
10146: oPushResult
10147: oSetResult 17
10149: oPushResult
10150: oNodeGetInt
10151: oPop 2
10153: oAssign
10154: oEmit 29
10156: oGetLocal 1
10158: oPushResult
10159: oEmitInt
10160: oPop 1
10162: oJumpForward 10188
10164: Choice Lookup Table
          39   10142
          37   10142
          35   10142
          34   10138
          33   10138
          27   10134
          32   10130
          29   10130
          30   10130
          40   10126
          28   10126
10187: oEndChoice
10188: oTypeSPop
10189: oReturn
10190: oLocalSpace 1
10192: oGetParam 1
10194: oPushResult
10195: oSetResult 6
10197: oPushResult
10198: oNodeGet
10199: oPop 2
10201: oPushResult
10202: oScopeCurrent
10203: oPushResult
10204: oNodeEqual
10205: oPop 2
10207: oChoice 10213
10209: oError 20
10211: oJumpForward 10216
10213: Choice Lookup Table
           0   10209
10216: oEmit 8
10218: oGetParam 1
10220: oPushResult
10221: oSetResult 31
10223: oPushResult
10224: oNodeGetInt
10225: oPop 2
10227: oPushResult
10228: oEmitInt
10229: oPop 1
10231: oGetParam 1
10233: oPushResult
10234: oSetResult 21
10236: oPushResult
10237: oNodeGet
10238: oPop 2
10240: oPushResult
10241: oTypeSPush
10242: oPop 1
10244: oInput 4
10246: oCall 5390
10248: oCall 8503
10250: oTypeSNodeType
10251: oChoice 10291
10253: oEmit 26
10255: oJumpForward 10315
10257: oEmit 27
10259: oJumpForward 10315
10261: oError 16
10263: oJumpForward 10315
10265: oEmit 28
10267: oJumpForward 10315
10269: oGetAddrLocal 1
10271: oPushResult
10272: oTypeSTop
10273: oPushResult
10274: oSetResult 17
10276: oPushResult
10277: oNodeGetInt
10278: oPop 2
10280: oAssign
10281: oEmit 29
10283: oGetLocal 1
10285: oPushResult
10286: oEmitInt
10287: oPop 1
10289: oJumpForward 10315
10291: Choice Lookup Table
          39   10269
          37   10269
          35   10269
          34   10265
          33   10265
          27   10261
          32   10257
          29   10257
          30   10257
          40   10253
          28   10253
10314: oEndChoice
10315: oTypeSPop
10316: oReturn
10317: oLocalSpace 1
10319: oInput 0
10321: oGetAddrLocal 1
10323: oPushResult
10324: oScopeFindRequire
10325: oAssign
10326: oGetAddrLocal 1
10328: oPushResult
10329: oCall 543
10331: oPop 1
10333: oGetLocal 1
10335: oPushResult
10336: oNodeType
10337: oPop 1
10339: oChoice 10343
10341: oJumpForward 10354
10343: Choice Lookup Table
          24   10341
          23   10341
          21   10341
          20   10341
10352: oError 4
10354: oGetLocal 1
10356: oPushResult
10357: oGetParam 1
10359: oPushResult
10360: oCall 10365
10362: oPop 2
10364: oReturn
10365: oLocalSpace 0
10367: oGetParam 2
10369: oPushResult
10370: oNodeType
10371: oPop 1
10373: oChoice 10455
10375: oEmit 16
10377: oGetParam 2
10379: oPushResult
10380: oCall 12041
10382: oPop 1
10384: oJumpForward 10466
10386: oEmit 17
10388: oGetParam 2
10390: oPushResult
10391: oCall 12041
10393: oPop 1
10395: oJumpForward 10466
10397: oGetParam 2
10399: oPushResult
10400: oSetResult 33
10402: oPushResult
10403: oNodeGetBoolean
10404: oPop 2
10406: oChoice 10419
10408: oEmit 8
10410: oGetParam 2
10412: oPushResult
10413: oCall 12041
10415: oPop 1
10417: oJumpForward 10431
10419: Choice Lookup Table
           1   10408
10422: oEmit 18
10424: oGetParam 2
10426: oPushResult
10427: oCall 12041
10429: oPop 1
10431: oJumpForward 10466
10433: oGetParam 1
10435: oChoice 10448
10437: oEmit 16
10439: oGetParam 2
10441: oPushResult
10442: oCall 12041
10444: oPop 1
10446: oJumpForward 10453
10448: Choice Lookup Table
           0   10437
10451: oError 4
10453: oJumpForward 10466
10455: Choice Lookup Table
          24   10433
          23   10397
          21   10386
          20   10375
10464: oError 4
10466: oGetParam 2
10468: oPushResult
10469: oSetResult 21
10471: oPushResult
10472: oNodeGet
10473: oPop 2
10475: oPushResult
10476: oTypeSPush
10477: oPop 1
10479: oTypeSNodeType
10480: oChoice 10495
10482: oInputChoice 10490
10484: oEmit 25
10486: oCall 8081
10488: oJumpForward 10493
10490: Choice Lookup Table
          16   10484
10493: oJumpForward 10498
10495: Choice Lookup Table
          33   10482
10498: oCall 7886
10500: oReturn
10501: oLocalSpace 0
10503: oGetParam 1
10505: oPushResult
10506: oSetResult 1
10508: oPushResult
10509: oCall 10365
10511: oPop 2
10513: oCall 11585
10515: oGetParam 1
10517: oPushResult
10518: oCall 7075
10520: oPop 1
10522: oTypeSPop
10523: oEmit 32
10525: oEmit 26
10527: oReturn
10528: oLocalSpace 0
10530: oGetParam 1
10532: oPushResult
10533: oSetResult 1
10535: oPushResult
10536: oCall 10365
10538: oPop 2
10540: oCall 11585
10542: oGetParam 1
10544: oPushResult
10545: oCall 7075
10547: oPop 1
10549: oTypeSPop
10550: oEmit 33
10552: oEmit 26
10554: oReturn
10555: oLocalSpace 2
10557: oGetAddrLocal 1
10559: oPushResult
10560: oSetResult 0
10562: oAssign
10563: oGetAddrLocal 1
10565: oPushResult
10566: oCall 5413
10568: oPop 1
10570: oInput 42
10572: oCall 9877
10574: oInputChoice 10609
10576: oGetAddrLocal 2
10578: oPushResult
10579: oLabelNew
10580: oAssign
10581: oEmit 68
10583: oGetLocal 2
10585: oPushResult
10586: oEmitLabel
10587: oPop 1
10589: oEmit 77
10591: oGetLocal 1
10593: oPushResult
10594: oEmitLabel
10595: oPop 1
10597: oCall 9877
10599: oEmit 77
10601: oGetLocal 2
10603: oPushResult
10604: oEmitLabel
10605: oPop 1
10607: oJumpForward 10620
10609: Choice Lookup Table
          43   10576
10612: oEmit 77
10614: oGetLocal 1
10616: oPushResult
10617: oEmitLabel
10618: oPop 1
10620: oReturn
10621: oLocalSpace 4
10623: oInput 0
10625: oGetAddrLocal 1
10627: oPushResult
10628: oScopeFindRequire
10629: oAssign
10630: oGetLocal 1
10632: oPushResult
10633: oSetResult 1
10635: oPushResult
10636: oCall 10365
10638: oPop 2
10640: oCall 11585
10642: oInput 4
10644: oCall 5390
10646: oCall 11585
10648: oEmit 26
10650: oGetAddrLocal 2
10652: oPushResult
10653: oLabelNew
10654: oAssign
10655: oGetAddrLocal 3
10657: oPushResult
10658: oLabelNew
10659: oAssign
10660: oEmit 68
10662: oGetLocal 3
10664: oPushResult
10665: oEmitLabel
10666: oPop 1
10668: oGetAddrLocal 4
10670: oPushResult
10671: oLabelNew
10672: oAssign
10673: oEmit 77
10675: oGetLocal 4
10677: oPushResult
10678: oEmitLabel
10679: oPop 1
10681: oInputChoice 10761
10683: oGetLocal 1
10685: oPushResult
10686: oCall 10501
10688: oPop 1
10690: oEmit 77
10692: oGetLocal 3
10694: oPushResult
10695: oEmitLabel
10696: oPop 1
10698: oGetLocal 1
10700: oPushResult
10701: oCall 7075
10703: oPop 1
10705: oTypeSPop
10706: oCall 5390
10708: oCall 11585
10710: oEmit 51
10712: oEmit 69
10714: oGetLocal 2
10716: oPushResult
10717: oEmitLabel
10718: oPop 1
10720: oJumpForward 10767
10722: oGetLocal 1
10724: oPushResult
10725: oCall 10528
10727: oPop 1
10729: oEmit 77
10731: oGetLocal 3
10733: oPushResult
10734: oEmitLabel
10735: oPop 1
10737: oGetLocal 1
10739: oPushResult
10740: oCall 7075
10742: oPop 1
10744: oTypeSPop
10745: oCall 5390
10747: oCall 11585
10749: oEmit 52
10751: oEmit 69
10753: oGetLocal 2
10755: oPushResult
10756: oEmitLabel
10757: oPop 1
10759: oJumpForward 10767
10761: Choice Lookup Table
          46   10722
          45   10683
10766: oEndChoice
10767: oGetLocal 4
10769: oPushResult
10770: oGetLocal 2
10772: oPushResult
10773: oLoopPush
10774: oPop 2
10776: oInput 47
10778: oCall 9877
10780: oEmit 68
10782: oGetLocal 4
10784: oPushResult
10785: oEmitLabel
10786: oPop 1
10788: oEmit 77
10790: oGetLocal 2
10792: oPushResult
10793: oEmitLabel
10794: oPop 1
10796: oLoopPop
10797: oReturn
10798: oLocalSpace 3
10800: oGetAddrLocal 1
10802: oPushResult
10803: oLabelNew
10804: oAssign
10805: oEmit 77
10807: oGetLocal 1
10809: oPushResult
10810: oEmitLabel
10811: oPop 1
10813: oGetAddrLocal 2
10815: oPushResult
10816: oLabelNew
10817: oAssign
10818: oGetLocal 1
10820: oPushResult
10821: oGetLocal 2
10823: oPushResult
10824: oLoopPush
10825: oPop 2
10827: oCall 9877
10829: oInputChoice 10860
10831: oCall 9877
10833: oJumpForward 10866
10835: oGetAddrLocal 3
10837: oPushResult
10838: oCall 5413
10840: oPop 1
10842: oEmit 78
10844: oGetLocal 3
10846: oPushResult
10847: oEmitLabel
10848: oPop 1
10850: oGetLocal 1
10852: oPushResult
10853: oEmitLabel
10854: oPop 1
10856: oJumpForward 10868
10858: oJumpForward 10866
10860: Choice Lookup Table
          50   10835
           5   10831
10865: oEndChoice
10866: oJumpBack 10829
10868: oEmit 77
10870: oGetLocal 2
10872: oPushResult
10873: oEmitLabel
10874: oPop 1
10876: oLoopPop
10877: oReturn
10878: oLocalSpace 2
10880: oGetAddrLocal 1
10882: oPushResult
10883: oLabelNew
10884: oAssign
10885: oEmit 77
10887: oGetLocal 1
10889: oPushResult
10890: oEmitLabel
10891: oPop 1
10893: oGetAddrLocal 2
10895: oPushResult
10896: oCall 5413
10898: oPop 1
10900: oGetLocal 1
10902: oPushResult
10903: oGetLocal 2
10905: oPushResult
10906: oLoopPush
10907: oPop 2
10909: oInput 47
10911: oCall 9877
10913: oEmit 68
10915: oGetLocal 1
10917: oPushResult
10918: oEmitLabel
10919: oPop 1
10921: oEmit 77
10923: oGetLocal 2
10925: oPushResult
10926: oEmitLabel
10927: oPop 1
10929: oLoopPop
10930: oReturn
10931: oLocalSpace 0
10933: oLoopContinueLabel
10934: oPushResult
10935: oSetResult 0
10937: oPushResult
10938: equal_label
10939: oPop 2
10941: oChoice 10956
10943: oError 18
10945: oJumpForward 10962
10947: oEmit 68
10949: oLoopContinueLabel
10950: oPushResult
10951: oEmitLabel
10952: oPop 1
10954: oJumpForward 10962
10956: Choice Lookup Table
           0   10947
           1   10943
10961: oEndChoice
10962: oReturn
10963: oLocalSpace 0
10965: oLoopBreakLabel
10966: oPushResult
10967: oSetResult 0
10969: oPushResult
10970: equal_label
10971: oPop 2
10973: oChoice 10988
10975: oError 18
10977: oJumpForward 10994
10979: oEmit 68
10981: oLoopBreakLabel
10982: oPushResult
10983: oEmitLabel
10984: oPop 1
10986: oJumpForward 10994
10988: Choice Lookup Table
           0   10979
           1   10975
10993: oEndChoice
10994: oReturn
10995: oLocalSpace 8
10997: oGetAddrLocal 1
10999: oPushResult
11000: oCodeNew
11001: oAssign
11002: oGetAddrLocal 2
11004: oPushResult
11005: oLabelNew
11006: oAssign
11007: oGetAddrLocal 3
11009: oPushResult
11010: oLabelNew
11011: oAssign
11012: oGetAddrLocal 4
11014: oPushResult
11015: oGetLocal 3
11017: oAssign
11018: oCall 5390
11020: oGetAddrLocal 5
11022: oPushResult
11023: oTypeSTop
11024: oAssign
11025: oTypeSNodeType
11026: oChoice 11052
11028: oEmit 71
11030: oGetLocal 2
11032: oPushResult
11033: oEmitLabel
11034: oPop 1
11036: oJumpForward 11069
11038: oEmit 72
11040: oGetLocal 2
11042: oPushResult
11043: oEmitLabel
11044: oPop 1
11046: oJumpForward 11069
11048: oError 16
11050: oJumpForward 11069
11052: Choice Lookup Table
          38   11048
          39   11048
          40   11038
          28   11038
          32   11028
          29   11028
          30   11028
11067: oError 17
11069: oInput 40
11071: oInputChoice 11118
11073: oGetAddrLocal 4
11075: oPushResult
11076: oLabelNew
11077: oAssign
11078: oEmit 77
11080: oGetLocal 4
11082: oPushResult
11083: oEmitLabel
11084: oPop 1
11086: oInputChoice 11092
11088: oJumpForward 11110
11090: oJumpForward 11108
11092: Choice Lookup Table
          36   11088
11095: oCall 9877
11097: oInputChoice 11101
11099: oJumpForward 11108
11101: Choice Lookup Table
           5   11099
11104: oInput 36
11106: oJumpForward 11110
11108: oJumpBack 11086
11110: oJumpForward 11234
11112: oJumpForward 11232
11114: oJumpForward 11234
11116: oJumpForward 11232
11118: Choice Lookup Table
          36   11114
          43   11073
          54   11073
11125: oGetAddrLocal 6
11127: oPushResult
11128: oLabelNew
11129: oAssign
11130: oGetLocal 1
11132: oPushResult
11133: oCodePush
11134: oPop 1
11136: oCall 5103
11138: oGetAddrLocal 7
11140: oPushResult
11141: oValueTop
11142: oAssign
11143: oValuePop
11144: oInputChoice 11176
11146: oCall 5103
11148: oGetAddrLocal 8
11150: oPushResult
11151: oValueTop
11152: oAssign
11153: oValuePop
11154: oEmit 75
11156: oGetLocal 7
11158: oPushResult
11159: oEmitInt
11160: oPop 1
11162: oGetLocal 8
11164: oPushResult
11165: oEmitInt
11166: oPop 1
11168: oGetLocal 6
11170: oPushResult
11171: oEmitLabel
11172: oPop 1
11174: oJumpForward 11193
11176: Choice Lookup Table
          21   11146
11179: oEmit 74
11181: oGetLocal 7
11183: oPushResult
11184: oEmitInt
11185: oPop 1
11187: oGetLocal 6
11189: oPushResult
11190: oEmitLabel
11191: oPop 1
11193: oInputChoice 11197
11195: oJumpForward 11202
11197: Choice Lookup Table
          13   11195
11200: oJumpForward 11204
11202: oJumpBack 11136
11204: oCodePop
11205: oInput 12
11207: oEmit 77
11209: oGetLocal 6
11211: oPushResult
11212: oEmitLabel
11213: oPop 1
11215: oCall 9877
11217: oEmit 68
11219: oGetLocal 3
11221: oPushResult
11222: oEmitLabel
11223: oPop 1
11225: oInputChoice 11229
11227: oJumpForward 11232
11229: Choice Lookup Table
           5   11227
11232: oJumpBack 11071
11234: oEmit 77
11236: oGetLocal 2
11238: oPushResult
11239: oEmitLabel
11240: oPop 1
11242: oGetLocal 1
11244: oPushResult
11245: oEmitCode
11246: oPop 1
11248: oEmit 76
11250: oGetLocal 4
11252: oPushResult
11253: oEmitLabel
11254: oPop 1
11256: oEmit 77
11258: oGetLocal 3
11260: oPushResult
11261: oEmitLabel
11262: oPop 1
11264: oReturn
11265: oLocalSpace 1
11267: oInputChoice 11274
11269: oJumpForward 11280
11271: oChangeIntLitToLabelIdent
11272: oJumpForward 11280
11274: Choice Lookup Table
           1   11271
           0   11269
11279: oEndChoice
11280: oGetAddrLocal 1
11282: oPushResult
11283: oScopeCurrent
11284: oPushResult
11285: oScopeFindRequireInScope
11286: oPop 1
11288: oAssign
11289: oGetLocal 1
11291: oPushResult
11292: oSetResult 28
11294: oPushResult
11295: oSetResult 1
11297: oPushResult
11298: oNodeSetBoolean
11299: oPop 3
11301: oEmit 68
11303: oGetLocal 1
11305: oPushResult
11306: oSetResult 22
11308: oPushResult
11309: oNodeGetLabel
11310: oPop 2
11312: oPushResult
11313: oEmitLabel
11314: oPop 1
11316: oReturn
11317: oLocalSpace 0
11319: oCall 9877
11321: oInputChoice 11331
11323: oCall 9877
11325: oJumpForward 11337
11327: oJumpForward 11339
11329: oJumpForward 11337
11331: Choice Lookup Table
          36   11327
           5   11323
11336: oEndChoice
11337: oJumpBack 11321
11339: oReturn
11340: oLocalSpace 0
11342: oCall 11347
11344: oEmit 87
11346: oReturn
11347: oLocalSpace 0
11349: oInputChoice 11467
11351: oCall 5390
11353: oTypeSNodeType
11354: oChoice 11425
11356: oEmit 80
11358: oJumpForward 11448
11360: oEmit 81
11362: oJumpForward 11448
11364: oEmit 30
11366: oEmit 80
11368: oJumpForward 11448
11370: oEmit 82
11372: oJumpForward 11448
11374: oEmit 83
11376: oJumpForward 11448
11378: oError 16
11380: oJumpForward 11448
11382: oEmit 16
11384: oTypeSTop
11385: oPushResult
11386: oSetResult 42
11388: oPushResult
11389: oNodeGetInt
11390: oPop 2
11392: oPushResult
11393: oEmitInt
11394: oPop 1
11396: oEmit 86
11398: oJumpForward 11448
11400: oTypeSTop
11401: oPushResult
11402: oGetGlobal 10
11404: oPushResult
11405: equal_node
11406: oPop 2
11408: oChoice 11414
11410: oEmit 84
11412: oJumpForward 11419
11414: Choice Lookup Table
           1   11410
11417: oEmit 85
11419: oJumpForward 11448
11421: oEmit 85
11423: oJumpForward 11448
11425: Choice Lookup Table
          34   11421
          33   11400
          40   11382
          27   11378
          38   11374
          39   11374
          32   11370
          29   11364
          30   11360
          28   11356
11446: oError 17
11448: oTypeSPop
11449: oInputChoice 11457
11451: oJumpForward 11465
11453: oJumpForward 11463
11455: oJumpForward 11463
11457: Choice Lookup Table
          13   11455
          15   11451
11462: oEndChoice
11463: oJumpBack 11351
11465: oJumpForward 11470
11467: Choice Lookup Table
          14   11351
11470: oReturn
11471: oLocalSpace 0
11473: oReturn
11474: oLocalSpace 0
11476: oReturn
11477: oLocalSpace 0
11479: oScopeCurrent
11480: oPushResult
11481: oSetResult 14
11483: oPushResult
11484: oNodeGetInt
11485: oPop 2
11487: oReturn
11488: oReturn
11489: oLocalSpace 0
11491: oGetParam 1
11493: oPushResult
11494: oSetResult 20
11496: oPushResult
11497: oNodeGet
11498: oPop 2
11500: oPushResult
11501: oSetResult 14
11503: oPushResult
11504: oNodeGetInt
11505: oPop 2
11507: oReturn
11508: oReturn
11509: oLocalSpace 0
11511: oCall 11477
11513: oPushResult
11514: oGetParam 1
11516: oPushResult
11517: oCall 11489
11519: oPop 1
11521: oPushResult
11522: subtract
11523: oPop 2
11525: oReturn
11526: oReturn
11527: oLocalSpace 1
11529: oGetAddrLocal 1
11531: oPushResult
11532: oTypeSNodeType
11533: oAssign
11534: oTypeSPop
11535: oGetLocal 1
11537: oPushResult
11538: oTypeSNodeType
11539: oPushResult
11540: equal_node_type
11541: oPop 2
11543: oChoice 11581
11545: oTypeSNodeType
11546: oChoice 11572
11548: oGetLocal 1
11550: oChoice 11555
11552: oReturn
11553: oJumpForward 11558
11555: Choice Lookup Table
          34   11552
11558: oJumpForward 11577
11560: oGetLocal 1
11562: oChoice 11567
11564: oReturn
11565: oJumpForward 11570
11567: Choice Lookup Table
          33   11564
11570: oJumpForward 11577
11572: Choice Lookup Table
          34   11560
          33   11548
11577: oError 14
11579: oJumpForward 11584
11581: Choice Lookup Table
           0   11545
11584: oReturn
11585: oLocalSpace 0
11587: oTypeSNodeType
11588: oChoice 11592
11590: oJumpForward 11597
11592: Choice Lookup Table
          28   11590
11595: oError 7
11597: oTypeSPop
11598: oReturn
11599: oLocalSpace 0
11601: oTypeSNodeType
11602: oChoice 11606
11604: oJumpForward 11611
11606: Choice Lookup Table
          28   11604
11609: oError 7
11611: oReturn
11612: oLocalSpace 0
11614: oTypeSNodeType
11615: oChoice 11623
11617: oJumpForward 11630
11619: oEmit 30
11621: oJumpForward 11630
11623: Choice Lookup Table
          29   11619
          28   11617
11628: oError 7
11630: oTypeSPop
11631: oReturn
11632: oLocalSpace 0
11634: oTypeSNodeType
11635: oChoice 11650
11637: oJumpForward 11657
11639: oEmit 30
11641: oTypeSPop
11642: oGetGlobal 6
11644: oPushResult
11645: oTypeSPush
11646: oPop 1
11648: oJumpForward 11657
11650: Choice Lookup Table
          29   11639
          28   11637
11655: oError 7
11657: oReturn
11658: oLocalSpace 0
11660: oTypeSNodeType
11661: oChoice 11674
11663: oEmit 30
11665: oTypeSPop
11666: oGetGlobal 6
11668: oPushResult
11669: oTypeSPush
11670: oPop 1
11672: oJumpForward 11677
11674: Choice Lookup Table
          29   11663
11677: oReturn
11678: oLocalSpace 0
11680: oTypeSNodeType
11681: oChoice 11685
11683: oJumpForward 11690
11685: Choice Lookup Table
          30   11683
11688: oError 8
11690: oTypeSPop
11691: oReturn
11692: oLocalSpace 0
11694: oTypeSNodeType
11695: oChoice 11699
11697: oJumpForward 11704
11699: Choice Lookup Table
          30   11697
11702: oError 8
11704: oReturn
11705: oLocalSpace 1
11707: oGetAddrLocal 1
11709: oPushResult
11710: oGetParam 2
11712: oPushResult
11713: oNodeNew
11714: oPop 1
11716: oAssign
11717: oGetLocal 1
11719: oPushResult
11720: oSetResult 17
11722: oPushResult
11723: oGetParam 1
11725: oPushResult
11726: oNodeSetInt
11727: oPop 3
11729: oGetLocal 1
11731: oPushResult
11732: oTypeAdd
11733: oPop 1
11735: oGetLocal 1
11737: oReturn
11738: oReturn
11739: oLocalSpace 1
11741: oGetAddrLocal 1
11743: oPushResult
11744: oGetParam 2
11746: oPushResult
11747: oNodeNew
11748: oPop 1
11750: oAssign
11751: oGetLocal 1
11753: oPushResult
11754: oSetResult 4
11756: oPushResult
11757: oGetParam 1
11759: oPushResult
11760: oNodeSetInt
11761: oPop 3
11763: oGetLocal 1
11765: oReturn
11766: oReturn
11767: oLocalSpace 1
11769: oGetAddrLocal 1
11771: oPushResult
11772: oGetParam 1
11774: oPushResult
11775: oSetResult 35
11777: oPushResult
11778: oNodeGet
11779: oPop 2
11781: oAssign
11782: oGetLocal 1
11784: oPushResult
11785: oNodeNull
11786: oPop 1
11788: oChoice 11844
11790: oGetAddrLocal 1
11792: oPushResult
11793: oSetResult 33
11795: oPushResult
11796: oNodeNew
11797: oPop 1
11799: oAssign
11800: oGetLocal 1
11802: oPushResult
11803: oSetResult 36
11805: oPushResult
11806: oGetParam 1
11808: oPushResult
11809: oNodeSet
11810: oPop 3
11812: oGetLocal 1
11814: oPushResult
11815: oSetResult 17
11817: oPushResult
11818: oSetResult 8
11820: oPushResult
11821: oNodeSetInt
11822: oPop 3
11824: oGetLocal 1
11826: oPushResult
11827: oTypeAdd
11828: oPop 1
11830: oGetParam 1
11832: oPushResult
11833: oSetResult 35
11835: oPushResult
11836: oGetLocal 1
11838: oPushResult
11839: oNodeSet
11840: oPop 3
11842: oJumpForward 11847
11844: Choice Lookup Table
           1   11790
11847: oGetLocal 1
11849: oReturn
11850: oReturn
11851: oLocalSpace 2
11853: oGetParam 1
11855: oPushResult
11856: oNodeType
11857: oPop 1
11859: oChoice 11929
11861: oMININT
11862: oReturn
11863: oJumpForward 11945
11865: oSetResult 0
11867: oReturn
11868: oJumpForward 11945
11870: oSetResult 0
11872: oReturn
11873: oJumpForward 11945
11875: oGetAddrLocal 1
11877: oPushResult
11878: oGetParam 1
11880: oPushResult
11881: oSetResult 40
11883: oPushResult
11884: oNodeGet
11885: oPop 2
11887: oAssign
11888: oGetAddrLocal 2
11890: oPushResult
11891: oGetLocal 1
11893: oPushResult
11894: oSetResult 15
11896: oPushResult
11897: oNodeGetIter
11898: oPop 2
11900: oPushResult
11901: oNodeIterValue
11902: oPop 1
11904: oAssign
11905: oGetLocal 2
11907: oPushResult
11908: oSetResult 22
11910: oPushResult
11911: oNodeGetInt
11912: oPop 2
11914: oReturn
11915: oJumpForward 11945
11917: oGetParam 1
11919: oPushResult
11920: oSetResult 38
11922: oPushResult
11923: oNodeGetInt
11924: oPop 2
11926: oReturn
11927: oJumpForward 11945
11929: Choice Lookup Table
          36   11917
          40   11875
          32   11870
          30   11865
          28   11861
11940: oError 3
11942: oSetResult 0
11944: oReturn
11945: oReturn
11946: oLocalSpace 2
11948: oGetParam 1
11950: oPushResult
11951: oNodeType
11952: oPop 1
11954: oChoice 12024
11956: oMAXINT
11957: oReturn
11958: oJumpForward 12040
11960: oSetResult 1
11962: oReturn
11963: oJumpForward 12040
11965: oSetResult 255
11967: oReturn
11968: oJumpForward 12040
11970: oGetAddrLocal 1
11972: oPushResult
11973: oGetParam 1
11975: oPushResult
11976: oSetResult 40
11978: oPushResult
11979: oNodeGet
11980: oPop 2
11982: oAssign
11983: oGetAddrLocal 2
11985: oPushResult
11986: oGetLocal 1
11988: oPushResult
11989: oSetResult 15
11991: oPushResult
11992: oNodeGetIterLast
11993: oPop 2
11995: oPushResult
11996: oNodeIterValue
11997: oPop 1
11999: oAssign
12000: oGetLocal 2
12002: oPushResult
12003: oSetResult 22
12005: oPushResult
12006: oNodeGetInt
12007: oPop 2
12009: oReturn
12010: oJumpForward 12040
12012: oGetParam 1
12014: oPushResult
12015: oSetResult 39
12017: oPushResult
12018: oNodeGetInt
12019: oPop 2
12021: oReturn
12022: oJumpForward 12040
12024: Choice Lookup Table
          36   12012
          40   11970
          32   11965
          30   11960
          28   11956
12035: oError 3
12037: oSetResult 0
12039: oReturn
12040: oReturn
12041: oLocalSpace 0
12043: oGetParam 1
12045: oPushResult
12046: oSetResult 22
12048: oPushResult
12049: oNodeGetInt
12050: oPop 2
12052: oPushResult
12053: oEmitInt
12054: oPop 1
12056: oReturn
12057: oLocalSpace 1
12059: oGetAddrLocal 1
12061: oPushResult
12062: oSetResult 14
12064: oPushResult
12065: oGetParam 1
12067: oPushResult
12068: oCall 11739
12070: oPop 2
12072: oAssign
12073: oGetLocal 1
12075: oPushResult
12076: oScopeDeclare
12077: oPop 1
12079: oGetLocal 1
12081: oReturn
12082: oReturn
12083: oLocalSpace 1
12085: oGetAddrGlobal 4
12087: oPushResult
12088: oId_mysystem
12089: oAssign
12090: oGetAddrGlobal 5
12092: oPushResult
12093: oSetResult 27
12095: oPushResult
12096: oSetResult 4
12098: oPushResult
12099: oCall 11705
12101: oPop 2
12103: oAssign
12104: oGetAddrGlobal 6
12106: oPushResult
12107: oSetResult 28
12109: oPushResult
12110: oSetResult 4
12112: oPushResult
12113: oCall 11705
12115: oPop 2
12117: oAssign
12118: oGetAddrGlobal 7
12120: oPushResult
12121: oSetResult 30
12123: oPushResult
12124: oSetResult 1
12126: oPushResult
12127: oCall 11705
12129: oPop 2
12131: oAssign
12132: oGetAddrGlobal 8
12134: oPushResult
12135: oSetResult 31
12137: oPushResult
12138: oSetResult 1
12140: oPushResult
12141: oCall 11705
12143: oPop 2
12145: oAssign
12146: oGetAddrGlobal 9
12148: oPushResult
12149: oSetResult 32
12151: oPushResult
12152: oSetResult 1
12154: oPushResult
12155: oCall 11705
12157: oPop 2
12159: oAssign
12160: oGetAddrGlobal 10
12162: oPushResult
12163: oGetGlobal 9
12165: oPushResult
12166: oCall 11767
12168: oPop 1
12170: oAssign
12171: oGetAddrGlobal 11
12173: oPushResult
12174: oSetResult 29
12176: oPushResult
12177: oSetResult 1
12179: oPushResult
12180: oCall 11705
12182: oPop 2
12184: oAssign
12185: oGetAddrGlobal 12
12187: oPushResult
12188: oSetResult 34
12190: oPushResult
12191: oSetResult 8
12193: oPushResult
12194: oCall 11705
12196: oPop 2
12198: oAssign
12199: oGetGlobal 12
12201: oPushResult
12202: oSetResult 36
12204: oPushResult
12205: oGetGlobal 11
12207: oPushResult
12208: oNodeSet
12209: oPop 3
12211: oGetAddrGlobal 13
12213: oPushResult
12214: oSetResult 38
12216: oPushResult
12217: oSetResult 256
12219: oPushResult
12220: oCall 11705
12222: oPop 2
12224: oAssign
12225: oGetAddrGlobal 14
12227: oPushResult
12228: oSetResult 39
12230: oPushResult
12231: oSetResult 256
12233: oPushResult
12234: oCall 11705
12236: oPop 2
12238: oAssign
12239: oGetGlobal 14
12241: oPushResult
12242: oSetResult 41
12244: oPushResult
12245: oSetResult 255
12247: oPushResult
12248: oNodeSetInt
12249: oPop 3
12251: oGetAddrLocal 1
12253: oPushResult
12254: oSetResult 18
12256: oPushResult
12257: oId_File
12258: oPushResult
12259: oCall 11739
12261: oPop 2
12263: oAssign
12264: oGetLocal 1
12266: oPushResult
12267: oSetResult 21
12269: oPushResult
12270: oGetGlobal 5
12272: oPushResult
12273: oNodeSet
12274: oPop 3
12276: oGetLocal 1
12278: oPushResult
12279: oScopeDeclare
12280: oPop 1
12282: oGetAddrLocal 1
12284: oPushResult
12285: oSetResult 18
12287: oPushResult
12288: oId_Integer
12289: oPushResult
12290: oCall 11739
12292: oPop 2
12294: oAssign
12295: oGetLocal 1
12297: oPushResult
12298: oSetResult 21
12300: oPushResult
12301: oGetGlobal 6
12303: oPushResult
12304: oNodeSet
12305: oPop 3
12307: oGetLocal 1
12309: oPushResult
12310: oScopeDeclare
12311: oPop 1
12313: oGetAddrLocal 1
12315: oPushResult
12316: oSetResult 18
12318: oPushResult
12319: oId_Boolean
12320: oPushResult
12321: oCall 11739
12323: oPop 2
12325: oAssign
12326: oGetLocal 1
12328: oPushResult
12329: oSetResult 21
12331: oPushResult
12332: oGetGlobal 7
12334: oPushResult
12335: oNodeSet
12336: oPop 3
12338: oGetLocal 1
12340: oPushResult
12341: oScopeDeclare
12342: oPop 1
12344: oGetAddrLocal 1
12346: oPushResult
12347: oSetResult 18
12349: oPushResult
12350: oId_Char
12351: oPushResult
12352: oCall 11739
12354: oPop 2
12356: oAssign
12357: oGetLocal 1
12359: oPushResult
12360: oSetResult 21
12362: oPushResult
12363: oGetGlobal 9
12365: oPushResult
12366: oNodeSet
12367: oPop 3
12369: oGetLocal 1
12371: oPushResult
12372: oScopeDeclare
12373: oPop 1
12375: oGetAddrLocal 1
12377: oPushResult
12378: oSetResult 18
12380: oPushResult
12381: oId_Byte
12382: oPushResult
12383: oCall 11739
12385: oPop 2
12387: oAssign
12388: oGetLocal 1
12390: oPushResult
12391: oSetResult 21
12393: oPushResult
12394: oGetGlobal 11
12396: oPushResult
12397: oNodeSet
12398: oPop 3
12400: oGetLocal 1
12402: oPushResult
12403: oScopeDeclare
12404: oPop 1
12406: oGetAddrLocal 1
12408: oPushResult
12409: oSetResult 18
12411: oPushResult
12412: oId_Pointer
12413: oPushResult
12414: oCall 11739
12416: oPop 2
12418: oAssign
12419: oGetLocal 1
12421: oPushResult
12422: oSetResult 21
12424: oPushResult
12425: oGetGlobal 12
12427: oPushResult
12428: oNodeSet
12429: oPop 3
12431: oGetLocal 1
12433: oPushResult
12434: oScopeDeclare
12435: oPop 1
12437: oGetAddrLocal 1
12439: oPushResult
12440: oSetResult 18
12442: oPushResult
12443: oId_ShortString
12444: oPushResult
12445: oCall 11739
12447: oPop 2
12449: oAssign
12450: oGetLocal 1
12452: oPushResult
12453: oSetResult 21
12455: oPushResult
12456: oGetGlobal 14
12458: oPushResult
12459: oNodeSet
12460: oPop 3
12462: oGetLocal 1
12464: oPushResult
12465: oScopeDeclare
12466: oPop 1
12468: oGetAddrLocal 1
12470: oPushResult
12471: oSetResult 16
12473: oPushResult
12474: oId_True
12475: oPushResult
12476: oCall 11739
12478: oPop 2
12480: oAssign
12481: oGetLocal 1
12483: oPushResult
12484: oSetResult 21
12486: oPushResult
12487: oGetGlobal 7
12489: oPushResult
12490: oNodeSet
12491: oPop 3
12493: oGetLocal 1
12495: oPushResult
12496: oSetResult 22
12498: oPushResult
12499: oSetResult 1
12501: oPushResult
12502: oNodeSetInt
12503: oPop 3
12505: oGetLocal 1
12507: oPushResult
12508: oScopeDeclare
12509: oPop 1
12511: oGetAddrLocal 1
12513: oPushResult
12514: oSetResult 16
12516: oPushResult
12517: oId_False
12518: oPushResult
12519: oCall 11739
12521: oPop 2
12523: oAssign
12524: oGetLocal 1
12526: oPushResult
12527: oSetResult 21
12529: oPushResult
12530: oGetGlobal 7
12532: oPushResult
12533: oNodeSet
12534: oPop 3
12536: oGetLocal 1
12538: oPushResult
12539: oSetResult 22
12541: oPushResult
12542: oSetResult 0
12544: oPushResult
12545: oNodeSetInt
12546: oPop 3
12548: oGetLocal 1
12550: oPushResult
12551: oScopeDeclare
12552: oPop 1
12554: oGetAddrLocal 1
12556: oPushResult
12557: oSetResult 16
12559: oPushResult
12560: oId_Nil
12561: oPushResult
12562: oCall 11739
12564: oPop 2
12566: oAssign
12567: oGetLocal 1
12569: oPushResult
12570: oSetResult 21
12572: oPushResult
12573: oGetGlobal 12
12575: oPushResult
12576: oNodeSet
12577: oPop 3
12579: oGetLocal 1
12581: oPushResult
12582: oSetResult 22
12584: oPushResult
12585: oSetResult 0
12587: oPushResult
12588: oNodeSetInt
12589: oPop 3
12591: oGetLocal 1
12593: oPushResult
12594: oScopeDeclare
12595: oPop 1
12597: oGetAddrGlobal 15
12599: oPushResult
12600: oId_Ord
12601: oPushResult
12602: oCall 12057
12604: oPop 1
12606: oAssign
12607: oGetAddrGlobal 16
12609: oPushResult
12610: oId_Chr
12611: oPushResult
12612: oCall 12057
12614: oPop 1
12616: oAssign
12617: oGetAddrGlobal 17
12619: oPushResult
12620: oId_Pred
12621: oPushResult
12622: oCall 12057
12624: oPop 1
12626: oAssign
12627: oGetAddrGlobal 18
12629: oPushResult
12630: oId_Succ
12631: oPushResult
12632: oCall 12057
12634: oPop 1
12636: oAssign
12637: oReturn
