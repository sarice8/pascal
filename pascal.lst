   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qFinalRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oNodeNew( nWorkspace )
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
  14:    oScopeBegin( 0 )
  20:    Node rootScope = oScopeCurrent
      
  25:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  27:    .tEnter  oEmitInt( 0 )
  35:    Label mainLabel = oLabelNew
      
  40:    .tAllocActuals  oEmitInt( 0 )
  48:    .tCall  oEmitLabel( mainLabel )
  56:    .tFreeActuals  oEmitInt( 0 )
  64:    .tReturn
      
  66:    pProgram
  68:    pIdent
      
  70:    Node program = oNodeNew( nProgram )
  80:    oNodeSetInt( program, qIdent, LAST_ID )
  91:    oNodeSet( workspace, qProgram, program )
      
      
 103:    [
 103:       | '(' :
 105:          pIdent      % input, output files
      
 107:          t = @newIdent( nVar, kVar, LAST_ID )
 123:          oNodeSet( t, qType, FileType )
 135:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 141:          ','
 143:          pIdent
      
 145:          t = @newIdent( nVar, kVar, LAST_ID )
 161:          oNodeSet( t, qType, FileType )
 173:          oScopeDeclareAlloc( t )
      
 179:          ')'
 181:       | * :
 186:    ]
 186:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 188:    [
 188:       | pUses :  @UsesClause( program )
 197:       | * :
 202:    ]
      
         % Global scope for the program, below any used units.
         % TO DO: I have a problem here.  I want separate scopes for visibility,
         %    but need to allocate global vars from a common offset counter,
         %    which I have in Scope currently.
         %    I need a way to share allocators.  Should only be necessary for global scopes.
         %    I could make global scope (with allocUp) a special case, and allocate from a
         %    global counter despite having separate Scopes.
         %    Or I could declare Scopes to "extend" another scope, meaning it shares the allocator.
 202:    oScopeBegin( 0 )
 208:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 213:    oScopeBegin( 0 )
 219:    initScope = oScopeCurrent
 224:    oNodeSetBoolean( initScope, qAllocDown, true )
 236:    oNodeSet( program, qMainRoutineScope, initScope )
 248:    oScopeEnd
      
 249:    @BlockDecls( nGlobalVar )
      
      
 256:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 262:    @BlockStmt( mainLabel, globalScope )
      
 272:    oScopeEnd   % main routine scope
      
 273:    '.'
 275:    oScopeEnd   % global scope
 277:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded)
      % and make the public portions of the named units visible to this program.
 277: UsesClause( Node user ):
 279:    {
 279:       pIdent
 281:       Node unit = @FindOrCompileUnit( LAST_ID )
 291:       [ equal_node( unit, Null )
 301:          | false :
 302:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % TO DO: put a declaration in the current scope, naming the unit and pointing to it.
                  %   This is to allow references to  <unit>.<identifier_in_unit>
                  %   Maybe something like nUsedUnit or nImportUnit
      
                  % Make unit's public scope directly visible.
                  % We can do this by entering the unit's public scope, prior to creating the user's scope.
                  % (The user scope will be able to shadow declarations in the unit.)
                  % Need to take care that this scope nesting doesn't confuse me, including with units that
                  % include other units.  But since use clauses are always at the start of a program or unit,
                  % it may work out ok.
 314:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
      
                  % TO DO: generate a call to the unit's initialization method, if any.
                  % This should go in the program's main init routine, prior to
                  % any var initialization for the program itself.
                  % Actually this should be done in the order the units are loaded,
                  % so maybe must be done at the end, iterating over workspace qUnits.
                  % And similarly for finalization, in reverse order.
      
 327:          | * :
 332:       ]
      
 332:       [
 332:          | ',' :
 334:          | * :  >
 341:       ]
 341:    }
 343:    ';'
 346:    ;
      
      
 346: FindOrCompileUnit( int id ) >> Node:
         % TO DO
 348:    oMsg( 10 )  oMsg( id )
         % We might have this unit loaded already
 360:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 379:    [ equal_node( unit, Null )
 389:       | false :  >> unit
 393:       | * :
 398:    ]
      
         % If not, search for the source file on disk
 398:    boolean ok = oIncludeUnitFile( id )
 408:    [ ok
 411:       | false :  #eCantFindUnitFile  >> Null
 417:       | * :
 422:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 422:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 428:    oIncludeEnd
 429:    >> unit;
      
      
      
 433: Unit >> Node:
 435:    pUnit
 437:    pIdent
 439:    Node unit = oNodeNew( nUnit )
 449:    oNodeSetInt( unit, qIdent, LAST_ID )
 460:    oNodeAddLast( workspace, qUnits, unit )
 472:    ';'
 474:    [
 474:       | pUses :   @UsesClause( unit )
 483:       | * :
 488:    ]
      
         % mandatory sections
      
         % NOTE, despite syntax diagrams, method headers in the interface may have 'external' clause.
         % Confirmed this looking at some units shipped with fpc.
 488:    pInterface
 490:    oScopeBegin( 0 )
 496:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 507:    oScopeBegin( 0 )
 513:    initScope = oScopeCurrent
 518:    oNodeSetBoolean( initScope, qAllocDown, true )
 530:    oNodeSet( unit, qInitRoutineScope, initScope )
 542:    oScopeEnd
      
 543:    @UnitInterface( unit )
      
 550:    pImplementation
 552:    oScopeBegin( 0 )
 558:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 569:    @UnitImplementation( unit )
      
 576:    [
 576:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 588:       | * :                @UnitInitialization( unit, false )  % still need an implicit init routine
 603:    ]
 603:    [
 603:       | pFinalization :  @UnitFinalization( unit )
 612:       | * :
 617:    ]
 617:    pEnd  '.'
 621:    oScopeEnd  % impl scope
 622:    oScopeEnd  % interface scope
 623:    >> unit;
      
      
 627: UnitInterface( Node unit ):
 629:    {[
 629:       | pConst :     @ConstDecl
 633:       | pType :      @TypeDecl
 637:       | pVar :       @VarDecl( nGlobalVar )
 646:       | pProcedure : @ProcHeaderDecl
 650:       | pFunction :  @FuncHeaderDecl
 654:       | * :          >
 669:    ]}
 672:    ;
      
 672: UnitImplementation( Node unit ):
 674:    @BlockDecls( nGlobalVar )
 682:    ;
      
      
 682: UnitInitialization( Node unit, boolean hasStmts ):
 684:    Label label = oLabelNew
 689:    .tLabel  oEmitLabel( label )
 697:    oNodeSetLabel( unit, qInitLabel, label )
      
 709:    int patchLS
 709:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 718:    Node scope
 718:    Code initCode
      
 718:    scope = oNodeGet( unit, qPublicScope )
 731:    initCode = oNodeGetCode( scope, qInitCode )
 744:    oMsg( 3000 )
 750:    oMsgNodeLong( scope )
 756:    oMsg( 3001 )
 762:    oEmitCode( initCode )
 768:    oNodeSetCode( scope, qInitCode, codeNull )
      
 780:    scope = oNodeGet( unit, qPrivateScope )
 793:    initCode = oNodeGetCode( scope, qInitCode )
 806:    oEmitCode( initCode )
 812:    oNodeSetCode( scope, qInitCode, codeNull )
      
 824:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
 837:    [ hasStmts
 840:       | true :     
 841:          @Statement
 843:          {[
 843:             | ';' :  @Statement
 847:             | * :
 852:          ]}
 854:       | * :
 859:    ]
      
 859:    .tReturn
      
 861:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 873:    oPatch( patchLS, localSpace )
 882:    oScopeEnd   % init routine scope, for temporaries
 884:    ;
      
 884: UnitFinalization( Node unit ):
 886:    #eNotImplemented
 889:    ;
      
 889: ProcHeaderDecl:
 891:    #eNotImplemented
 894:    ;
      
 894: FuncHeaderDecl:
 896:    #eNotImplemented
 899:    ;
      
      
 899: Block( node_type varNodeType, Label labelForBody ):
 901:    @BlockDecls( varNodeType )
 908:    @BlockStmt( labelForBody, oScopeCurrent )
 918:    ;
      
      
 918: BlockDecls( node_type varNodeType ):
 920:    {[
 920:       | pConst :     @ConstDecl
 924:       | pType :      @TypeDecl
 928:       | pVar :       @VarDecl( varNodeType )
 937:       | pProcedure : @ProcDecl
 941:       | pFunction :  @FuncDecl
 945:       | * :          >
 960:    ]}
 962:    @CheckForUndefinedMethods
 965:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 965: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 968:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 968: BlockStmt( Label labelForBody, Node varScope ):
 970:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 978:    int patchLS
 978:    .tEnter  patchLS = Here  .tSpace
      
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
 987:    NodeIter it = oNodeGetIter( workspace, qUnits )
1000:    {
1000:       Node unit = oNodeIterValue( it )
1010:       [ oNodeNull( unit )
1017:          | true :  >
1020:          | false :
1022:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1030:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1045:             .tFreeActuals  oEmitInt( 0 )
1053:             oNodeIterNext( it )
1059:       ]
1067:    }
      
         % insert any code for initialization of this scope's variables
1069:    Code initCode = oNodeGetCode( varScope, qInitCode )
1082:    oEmitCode( initCode )
1088:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1100:    @Statement
1102:    .tReturn
      
1104:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1116:    oPatch( patchLS, localSpace )
1126:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1126: MethodModifiers( Node decl ):
1128:    {[
1128:       | pCdecl :
1130:          oNodeSetBoolean( decl, qCdecl, true )
1142:          ';'
      
1144:       | * : >
1151:    ]}
1154:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1154: GetOrCreateInitCode >> Code:
1156:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1168:    [ equal_code( initCode, codeNull )
1178:       | true :
1179:          initCode = oCodeNew
1184:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1195:       | * :
1200:    ]
1200:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1204: ExternalDecl( Node decl ):
1206:    [ equal_zero( @DeclLevel( decl ) )
1218:       | false :  #eExternalMethodCannotBeNested
1221:       | * :
1226:    ]
1226:    oNodeSetBoolean( decl, qExternal, true )
1238:    [
1238:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1240:          [
1240:             | pName :
1242:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1244:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1255:             | * :
1260:          ]
1260:       | * :
1265:    ]
1266:    ;
      
      
1266: ProcDecl:
1268:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1270:    boolean redeclaring = false
1276:    Node decl = oScopeFindInCurrentScope
      
1281:    [ oNodeNull( decl )
1288:       | true :
               % first declaration
1289:          decl = @newIdent( nProc, kProc, LAST_ID )
1305:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1316:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1318:          redeclaring = true
1324:          [ oNodeGetBoolean( decl, qBodyDefined )
1334:             | true : #eAlreadyDefined
1337:             | * :
1342:          ]
1342:          [ oNodeGetBoolean( decl, qExternal )
1352:             | true : #eAlreadyDefined
1355:             | * :
1360:          ]
1360:          [ oNodeType( decl )
1367:             | nProc :
1368:             | * : #eAlreadyDefined   % wrong kind
1375:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1375:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1394:          oNodeSet( decl, qParams, Null )
1406:    ]
      
1414:    int level = @ScopeLevel
1420:    boolean nested = greater( level, 0 )
1433:    inc( level )
1439:    oScopeBegin( level )
1445:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1450:    [ nested
1453:       | true :
1454:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1469:       | * :
1474:    ]
      
1474:    @FormalArgDecl
1476:    oNodeSet( decl, qParams, paramScope )
1488:    oScopeEnd
1489:    ';'
      
1491:    [ redeclaring
1494:       | false : oScopeDeclare( decl )
1501:       | true :  % TO DO: check that qParams is consistent with qOldParams
1503:    ]
      
1511:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1518:    [
1518:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1520:       | pExternal : @ExternalDecl( decl )
      
1529:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1536:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1542:          oScopeBegin( level )
1548:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1559:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1570:          Label label = oNodeGetLabel( decl, qValue )
1583:          @Block( nLocalVar, label )
1593:          oNodeSetBoolean( decl, qBodyDefined, true )
1605:          oScopeEnd
      
1606:          oScopeEnd  % paramScope
1607:    ]
1607:    ';';
      
      
1610: FuncDecl:
1612:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1614:    boolean redeclaring = false
1620:    Node decl = oScopeFindInCurrentScope
      
1625:    [ oNodeNull( decl )
1632:       | true :
               % first declaration
1633:          decl = @newIdent( nFunc, kFunc, LAST_ID )
1649:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1660:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1662:          redeclaring = true
1668:          [ oNodeGetBoolean( decl, qBodyDefined )
1678:             | true : #eAlreadyDefined
1681:             | * :
1686:          ]
1686:          [ oNodeType( decl )
1693:             | nFunc :
1694:             | * : #eAlreadyDefined   % wrong kind
1701:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1701:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1720:          oNodeSet( decl, qParams, Null )
1732:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1751:          oNodeSet( decl, qType, Null )
1763:    ]
      
1771:    int level = @ScopeLevel
1777:    boolean nested = greater( level, 0 )
1790:    inc( level )
1796:    oScopeBegin( level )
1802:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1807:    [ nested
1810:       | true :
1811:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1826:       | * :
1831:    ]
      
1831:    @FormalArgDecl
1833:    oNodeSet( decl, qParams, paramScope )
      
1845:    ':'
      
1847:    Node theType
1847:    @TypeRef( theType )
1854:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1866:    Node ptrType = @PointerTypeTo( theType )
1877:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1893:    oScopeEnd
1894:    ';'
      
1896:    [ redeclaring
1899:       | false : oScopeDeclare( decl )
1906:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1908:    ]
      
1916:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1923:    [
1923:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1925:       | pExternal : @ExternalDecl( decl )
      
1934:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1941:          oScopeEnter( paramScope )
      
1947:          oScopeBegin( level )
1953:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1964:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1975:          Label label = oNodeGetLabel( decl, qValue )
1988:          @Block( nLocalVar, label )
1998:          oNodeSetBoolean( decl, qBodyDefined, true )
2010:          oScopeEnd
      
2011:          oScopeEnd  % paramScope
2012:    ]
2012:    ';';
      
      
2015: FormalArgDecl:
2017:    [
2017:       | '(' :
2019:          {
2019:             NodeVec decls = oNodeVecNew
2024:             Node decl
2024:             boolean isInOut = false
      
2030:             [
2030:                | pVar : isInOut = true
2038:                | * :
2043:             ]
      
2043:             {  pIdent
      
2045:                decl = @newIdent( nParam, kVar, LAST_ID )
2061:                oNodeSetBoolean( decl, qInOut, isInOut )
2073:                oNodeVecAppend( decls, decl )
      
2082:                [
2082:                   | ':' : >
2086:                   | ',' :
2088:                ]
2096:             }
      
2098:             Node theType
2098:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2105:             Node allocType
2105:             [ isInOut
2108:                | true :   allocType = @PointerTypeTo( theType )
2120:                | * :      allocType = theType
2131:             ]
      
2131:             int i = 0
2137:             {[ equal( i, oNodeVecSize( decls ) )
2151:                | false :
2152:                   decl = oNodeVecElement( decls, i )
      
2165:                   oNodeSet( decl, qType, theType )
2177:                   oScopeDeclare( decl )
2183:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2199:                   inc( i )
2205:                | * :
2210:                   >
2212:             ]}
      
2214:             oNodeVecDelete( decls )
      
2220:             [
2220:                | ')' : >
2224:                | ';' :
2226:             ]
2234:          }
2236:       | * :
2241:    ];
      
2242: ConstDecl:
2244:    {[
2244:       | pIdent :
2246:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2262:          '='
      
2264:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2266:          int val = oValueTop
2271:          oValuePop
2272:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2284:          oNodeSet( decl, qType, IntegerType )
      
2296:          oScopeDeclare( decl )
2302:          ';'
2304:       | * :
2309:          >
2311:    ]};
      
2314: TypeDecl:
2316:    {[
2316:       | pIdent :
2318:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2334:          '='
2336:          Node theType
2336:          @TypeRef( theType )
2343:          oNodeSet( decl, qType, theType )
2355:          oScopeDeclare( decl )
2361:          ';'
2363:       | * :
2368:          >
2370:    ]};
      
2373: VarDecl( node_type varNodeType ):
2375:    {[
2375:       | pIdent :
2377:          NodeVec decls = oNodeVecNew
2382:          Node decl
2382:          {
2382:             decl = @newIdent( varNodeType, kVar, LAST_ID )
2398:             oNodeVecAppend( decls, decl )
2407:             [
2407:                | ',' :
2409:                   pIdent
2411:                | * :
2416:                   >
2418:             ]
2418:          }
2420:          ':'
2422:          Node theType
2422:          @TypeRef( theType )
      
2429:          int i = 0
2435:          {[ equal( i, oNodeVecSize( decls ) )
2449:             | false :
2450:                decl = oNodeVecElement( decls, i )
2463:                oNodeSet( decl, qType, theType )
2475:                oScopeDeclareAlloc( decl )
2481:                inc( i )
2487:             | * :
2492:               >
2494:          ]}
      
               % optional initialization
2496:          [
2496:             | '=' :
2498:                [ oNodeVecSize( decls )
2505:                   | 1 :
2506:                   | * :  #eOnlyOneVarCanBeInitialized
2513:                ]
      
                     % we need an initCode stream for this scope
2513:                Code initCode = @GetOrCreateInitCode
2519:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
2525:                boolean changedScope = false
2531:                [ equal_zero( @ScopeLevel )
2538:                   | true : oScopeEnter( initScope )
2545:                            changedScope = true
2551:                   | * :
2556:                ]
                     % generate assignment in initCode stream
2556:                @LValueVar( decl )
2563:                @Expr
2565:                @MatchTypes
2567:                @Assign
2569:                [ changedScope
2572:                   | true : oScopeEnd
2574:                   | * :
2579:                ]
2579:                oCodePop
                   
2580:             | * :
2585:          ]
      
2585:          oNodeVecDelete( decls )
2591:          ';'
2593:       | * :
2598:          >
2600:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
2603: TypeRef( out Node resultType ):
2605:    [
2605:       | pIdent :           % previously named type (including intrinsics)
2607:          Node decl = oScopeFindRequire
2612:          [ oNodeType( decl )
2619:            | nTypeDecl :
2620:                resultType = oNodeGet( decl, qType )
2633:            | * :
2638:                #eNotType
2640:                resultType = IntegerType
2646:          ]
         
2646:       | pArray :
2648:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
2650:          NodeVec dimensions = oNodeVecNew
      
2655:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
2655:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
2665:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
2677:             @ConstExpr
2679:             oNodeSetInt( subrange, qLow, oValueTop )
2690:             oValuePop
2691:             '..'
2693:             @ConstExpr
2695:             oNodeSetInt( subrange, qHigh, oValueTop )
2706:             oValuePop
2707:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
2719:             oTypeAdd( subrange )
      
2725:             Node a = oNodeNew( nArrayType )
2735:             oNodeSet( a, qIndexType, subrange )
      
2747:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
2756:             [
2756:                | ']' : >
2760:                | ',' :
2762:             ]
2770:          }
      
2772:          pOf
2774:          Node baseType
2774:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
2781:          int dim = oNodeVecSize( dimensions )
      
2791:          {
2791:              dec(dim)
      
2797:              Node a = oNodeVecElement( dimensions, dim )
      
2810:              oNodeSet( a, qBaseType, baseType )
2822:              Node subrange = oNodeGet( a, qIndexType )
2835:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2862:              inc( width )
2868:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2894:              oTypeAdd( a )
2900:              baseType = a
      
2906:              [ equal_zero(dim)
2913:                  | true:  >
2916:                  | *:
2921:              ]
2921:          }
      
2923:          resultType = oNodeVecElement( dimensions, 0 )
2936:          oNodeVecDelete( dimensions )
      
2942:       | '^' :
2944:          Node theType
2944:          @TypeRef( theType )
2951:          resultType = @PointerTypeTo( theType )
      
2962:       | pRecord :
2964:          resultType = oNodeNew( nRecordType )
2974:          oScopeBegin( -1 )    % level is meaningless here
      
2980:          @VarDecl( nRecordField )
      
2987:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2999:          [ equal_zero( size )
3006:             | true : #eRecordEmpty
3009:             | * :
3014:          ]
      
3014:          pEnd
      
3016:          oNodeSet( resultType, qScope, oScopeCurrent )
3027:          oNodeSetInt( resultType, qSize, size )
3039:          oScopeEnd
3040:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3046:       | pSet :
3048:          pOf
3050:          Node theType
3050:          @TypeRef( theType )
3057:       | * :       % this works for cases except where expr starts with an id
3070:          @ConstExpr '..' @ConstExpr
3076:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3077: ConstExpr:
3079:    [
3079:       | pIntLit :
3081:          oValuePush( TOKEN_VALUE )
3086:       | pIdent :
3088:          Node decl = oScopeFindRequire
3093:          [ oNodeType( decl )
3100:             | nConst :
3101:                oValuePush( oNodeGetInt( decl, qValue ) )
3114:             | * :
3119:                #eNotConst
3121:                oValuePush( 0 )
3127:          ]
3127:       | pMinus :
3129:          @ConstExpr
3131:          oValueNegate
3132:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3143: Expr:
3145:    Label falseLabel = labelNull
      
3151:    @ExprAllowCF( falseLabel )
3158:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3166: BooleanExprControlFlow( out Label falseLabel ):
3168:    @ExprAllowCF( falseLabel )
3175:    [ oTypeSNodeType
3177:       | nBooleanCFType :
3178:       | nBooleanType :
               % convert value to control flow
3180:          falseLabel = oLabelNew
3185:          .tJumpFalse  oEmitLabel( falseLabel )
3193:       | * :
3200:          #eNotBoolean
3202:    ]
3202:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3204: CFToVal( inout Label falseLabel ):
3206:    [ oTypeSNodeType
3208:       | nBooleanCFType :
3209:          Label doneLabel = oLabelNew
3214:          .tPushConstI  oEmitInt( 1 )
3222:          .tJump  oEmitLabel( doneLabel )
3230:          .tLabel  oEmitLabel( falseLabel )
3238:          .tPushConstI  oEmitInt( 0 )
3246:          .tLabel  oEmitLabel( doneLabel )
3254:          oTypeSPop
3255:          oTypeSPush( BooleanType )
3261:          falseLabel = labelNull
3267:       | * :
3272:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3273: ValToCF( out Label falseLabel ):
3275:    [ oTypeSNodeType
3277:       | nBooleanType :
3278:          falseLabel = oLabelNew
3283:          .tJumpFalse  oEmitLabel( falseLabel )
3291:          oTypeSPop
3292:          oTypeSPush( BooleanCFType )
3298:       | * :
3303:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3304: ExprAllowCF( out Label falseLabel ):
3306:    @BoolExprAllowCF( falseLabel )
3313:    {[
3313:       | '=' :
3315:          @CFToVal( falseLabel )
3322:          @BoolExprAllowCF( falseLabel )
3329:          @CFToVal( falseLabel )
3336:          @MatchTypes
3338:          [ oTypeSNodeType
3340:             | nIntegerType, nBooleanType :  .tEqualI
3343:             | nPointerType :                .tEqualP
3347:             | nCharType, nStringType :      #eNotImplemented
3351:             | * :                           #eNotAllowed
3366:          ]
3366:          oTypeSPop
3367:          oTypeSPush( BooleanType )
      
3373:       | '<>' :
3375:          @CFToVal( falseLabel )
3382:          @BoolExprAllowCF( falseLabel )
3389:          @CFToVal( falseLabel )
3396:          @MatchTypes
3398:          [ oTypeSNodeType
3400:             | nIntegerType, nBooleanType :  .tNotEqualI
3403:             | nPointerType :                .tNotEqualP
3407:             | nCharType, nStringType :      #eNotImplemented
3411:             | * :                           #eNotAllowed
3426:          ]
3426:          oTypeSPop
3427:          oTypeSPush( BooleanType )
      
3433:       | '<' :
3435:          @CFToVal( falseLabel )
3442:          @BoolExprAllowCF( falseLabel )
3449:          @CFToVal( falseLabel )
3456:          @MatchTypes
3458:          [ oTypeSNodeType
3460:             | nIntegerType, nBooleanType :  .tLessI
3463:             | nCharType, nStringType :      #eNotImplemented
3467:             | * :                           #eNotAllowed
3480:          ]
3480:          oTypeSPop
3481:          oTypeSPush( BooleanType )
      
3487:       | '>' :
3489:          @CFToVal( falseLabel )
3496:          @BoolExprAllowCF( falseLabel )
3503:          @CFToVal( falseLabel )
3510:          @MatchTypes
3512:          [ oTypeSNodeType
3514:             | nIntegerType, nBooleanType :  .tGreaterI
3517:             | nCharType, nStringType :      #eNotImplemented
3521:             | * :                           #eNotAllowed
3534:          ]
3534:          oTypeSPop
3535:          oTypeSPush( BooleanType )
      
3541:       | '<=' :
3543:          @CFToVal( falseLabel )
3550:          @BoolExprAllowCF( falseLabel )
3557:          @CFToVal( falseLabel )
3564:          @MatchTypes
3566:          [ oTypeSNodeType
3568:             | nIntegerType, nBooleanType :  .tLessEqualI
3571:             | nCharType, nStringType :      #eNotImplemented
3575:             | * :                           #eNotAllowed
3588:          ]
3588:          oTypeSPop
3589:          oTypeSPush( BooleanType )
      
3595:       | '>=' :
3597:          @CFToVal( falseLabel )
3604:          @BoolExprAllowCF( falseLabel )
3611:          @CFToVal( falseLabel )
3618:          @MatchTypes
3620:          [ oTypeSNodeType
3622:             | nIntegerType, nBooleanType :  .tGreaterEqualI
3625:             | nCharType, nStringType :      #eNotImplemented
3629:             | * :                           #eNotAllowed
3642:          ]
3642:          oTypeSPop
3643:          oTypeSPush( BooleanType )
      
3649:       | * :
3664:          >
3666:    ]};
      
      
3669: BoolExprAllowCF( out Label falseLabel ):
3671:    Label trueLabel = labelNull
      
3677:    @BoolTermAllowCF( falseLabel )
3684:    {[
3684:       | pOr :
3686:          [ oTypeSNodeType
3688:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
3689:                [ equal_label( trueLabel, labelNull )
3699:                   | true :  trueLabel = oLabelNew
3705:                   | * :
3710:                ]
3710:                .tJump  oEmitLabel( trueLabel )
3718:             | nBooleanType :
3720:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
3727:                [ equal_label( trueLabel, labelNull )
3737:                   | true :  trueLabel = oLabelNew
3743:                   | * :
3748:                ]
3748:                .tJump  oEmitLabel( trueLabel )
3756:             | * : #eNotBoolean
3765:          ]
3765:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
3766:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
3774:          falseLabel = labelNull
3780:          @BoolTermAllowCF( falseLabel )
      
3787:          [ oTypeSNodeType
3789:             | nBooleanCFType :
3790:             | nBooleanType :
3792:                @ValToCF( falseLabel )
3799:             | * : #eNotBoolean
3808:          ]
      
3808:          oTypeSPop
3809:          oTypeSPush( BooleanCFType )
      
3815:       | * :
3820:          >
3822:    ]}
      
         % any short-circuit trues jump here to the end
3824:    [ equal_label( trueLabel, labelNull )
3834:       | false :
3835:          .tLabel  oEmitLabel( trueLabel )
3843:       | * :
3848:    ]
3849:    ;
      
      
3849: BoolTermAllowCF( out Label falseLabel ):
3851:    Label overallFalseLabel = labelNull
      
3857:    @BoolFactorAllowCF( falseLabel )
3864:    {[
3864:       | pAnd :
3866:          [ oTypeSNodeType
3868:             | nBooleanCFType :
3869:             | nBooleanType :
3871:                @ValToCF( falseLabel )
3878:             | * :
3885:                #eNotBoolean
3887:          ]
3887:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3888:          [ equal_label( overallFalseLabel, labelNull )
3898:             | true :
3899:                overallFalseLabel = oLabelNew
3904:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3918:                falseLabel = overallFalseLabel
3924:             | * :
3929:          ]
      
3929:          Label factorFalseLabel = labelNull
3935:          @BoolFactorAllowCF( factorFalseLabel )
      
3942:          [ oTypeSNodeType
3944:             | nBooleanCFType :
3945:             | nBooleanType :
3947:                @ValToCF( factorFalseLabel )
3954:             | * : #eNotBoolean
3963:          ]
3963:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3977:       | * :
3982:          >
3984:    ]};
      
3987: BoolFactorAllowCF( out Label falseLabel ):
3989:    [
3989:       | pNot :
3991:          Label factorFalseLabel = labelNull
      
3997:          @BoolFactorAllowCF( factorFalseLabel )
4004:          [ oTypeSNodeType
4006:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4007:                falseLabel = oLabelNew
4012:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4020:                .tLabel  oEmitLabel( factorFalseLabel )
      
4028:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4030:                .tNot
      
4032:             | * : #eNotBoolean
4041:          ]
      
4041:       | * :
4046:          @ArithExprAllowCF( falseLabel )
4053:    ];
      
4054: ArithExprAllowCF( out Label falseLabel ):
4056:    @TermAllowCF( falseLabel )
4063:    {[
4063:       | pPlus :
4065:          @RequireIntPop
4067:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4074:          @RequireInt
4076:          .tAddI
4078:       | pMinus :
4080:          @RequireIntPop
4082:          @TermAllowCF( falseLabel )
4089:          @RequireInt
4091:          .tSubI
4093:       | * :
4100:          >
4102:    ]};
      
4105: TermAllowCF( out Label falseLabel ):
4107:    @FactorAllowCF( falseLabel )
4114:    {[
4114:       | pTimes :
4116:          @RequireIntPop
4118:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4125:          @RequireInt
4127:          .tMultI
4129:       | pDivide :
4131:          @RequireIntPop
4133:          @FactorAllowCF( falseLabel )
4140:          @RequireInt
4142:          .tDivI
4144:       | * :
4151:          >
4153:    ]};
      
4156: FactorAllowCF( out Label falseLabel ):
4158:    [
4158:       | pPlus :
4160:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4167:          @RequireInt
4169:       | pMinus :
4171:          @PrimaryAllowCF( falseLabel )
4178:          @RequireInt
4180:          .tNegI
4182:       | * :
4189:          @PrimaryAllowCF( falseLabel )
4196:    ];
      
4197: PrimaryAllowCF( out Label falseLabel ):
4199:    [
4199:       | pIntLit :
4201:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4208:          oTypeSPush( IntegerType )
      
4214:       | '(' :
4216:          @ExprAllowCF( falseLabel )
4223:          ')'
      
4225:       | pStrLit :
4227:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4236:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4244:          oTypeSPush( StringType )
      
4250:       | pIdent :
4252:          Node decl = oScopeFindRequire
4257:          Node theType
      
4257:          [ oNodeType( decl )
4264:             | nFunc :
      
4265:                @Call( decl )
      
4272:             | nConst :
4274:                theType = oNodeGet( decl, qType )
4287:                oTypeSPush( theType )
4293:                [ oTypeSNodeType
4295:                   | nIntegerType, nBooleanType :
4296:                      .tPushConstI @EmitValue( decl )
4305:                   | * :
4312:                      #eNotImplemented
4314:                ]
      
4314:             | nGlobalVar, nLocalVar, nParam :
4316:                @VarExpr( decl )
      
4323:             | * :
4336:                #eNotValue
4338:                oTypeSPush( IntegerType )
4344:          ]
      
4344:       | '@' :        % @var -- pointer to var
4346:          pIdent
      
4348:          Node decl = oScopeFindRequire
4353:          Node theType
      
4353:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
4360:          theType = oTypeSTop
4365:          oTypeSPop
4366:          Node ptrType = @PointerTypeTo( theType )
4377:          oTypeSPush( ptrType )
      
4383:       | * :
4396:          #eNotValue
4398:          oTypeSPush( IntegerType )
4404:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
4405: VarExpr( Node decl ):
4407:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
4420:    int uplevels = @DeclUpLevels( decl )
      
4431:    oTypeSPush( theType )
4437:    [ oTypeSNodeType
4439:       | nIntegerType :
4440:          [ oNodeType( decl )
4447:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
4457:             | nLocalVar :
4459:                [ equal_zero( uplevels )
4466:                   | true :  .tPushLocalI  @EmitValue( decl )
4476:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
4496:                ]
4496:             | nParam :
4498:                [ oNodeGetBoolean( decl, qInOut )
4508:                   | true :    % VAR param points to the var.  Auto dereference.
4509:                      [ equal_zero( uplevels )
4516:                         | true :  .tPushParamP  @EmitValue( decl )
4526:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4546:                      ]
4546:                      .tFetchI
4548:                   | * :
4553:                      [ equal_zero( uplevels )
4560:                         | true :  .tPushParamI  @EmitValue( decl )
4570:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
4590:                      ]
4590:                ]
4590:          ]
      
4600:       | nBooleanType :
4602:          [ oNodeType( decl )
4609:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
4619:             | nLocalVar :
4621:                [ equal_zero( uplevels )
4628:                   | true :  .tPushLocalB  @EmitValue( decl )
4638:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
4658:                ]
4658:             | nParam :
4660:                [ oNodeGetBoolean( decl, qInOut )
4670:                   | true :    % VAR param points to the var.  Auto dereference.
4671:                      [ equal_zero( uplevels )
4678:                         | true :  .tPushParamP  @EmitValue( decl )
4688:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4708:                      ]
4708:                      .tFetchB
4710:                   | * :
4715:                      [ equal_zero( uplevels )
4722:                         | true :  .tPushParamB  @EmitValue( decl )
4732:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
4752:                      ]
4752:                ]
4752:          ]
      
4762:       | nCharType, nStringType, nFileType :
4764:          #eNotImplemented
      
4766:       | nPointerType :
4768:          [ oNodeType( decl )
4775:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
4785:             | nLocalVar :
4787:                [ equal_zero( uplevels )
4794:                   | true :  .tPushLocalP  @EmitValue( decl )
4804:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4824:                ]
4824:             | nParam :
4826:                [ oNodeGetBoolean( decl, qInOut )
4836:                   | true :    % VAR param points to the var.  Auto dereference.
4837:                      [ equal_zero( uplevels )
4844:                         | true :  .tPushParamP  @EmitValue( decl )
4854:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4874:                      ]
4874:                      .tFetchP
4876:                   | * :
4881:                      [ equal_zero( uplevels )
4888:                         | true :  .tPushParamP  @EmitValue( decl )
4898:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4918:                      ]
4918:                ]
4918:          ]
4928:          [
4928:             | '^' :             % dereferenced
4930:                oTypeSPop
4931:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4944:                @LValueIndexes
4946:                @FetchVar
4948:             | * :               % just ptr value alone
4953:          ]
      
4953:       | * :
               % compound type
               % first, push addr of start of var
4968:          [ oNodeType( decl )
4975:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4985:             | nLocalVar :
4987:                [ equal_zero( uplevels )
4994:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5004:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5024:                ]
5024:             | nParam :
5026:                [ oNodeGetBoolean( decl, qInOut )
5036:                   | true :    % VAR param points to the var.  Auto dereference.
5037:                      [ equal_zero( uplevels )
5044:                         | true :  .tPushParamP  @EmitValue( decl )
5054:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5074:                      ]
5074:                   | * :
5079:                      [ equal_zero( uplevels )
5086:                         | true :  .tPushAddrParam  @EmitValue( decl )
5096:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5116:                      ]
5116:                ]
5116:          ]
               % modify addr for subscripts, field references, etc
5126:          @LValueIndexes
               % get final value
5128:          @FetchVar
5130:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5131: FetchVar:
5133:    [ oTypeSNodeType
5135:       | nIntegerType :   .tFetchI
5138:       | nBooleanType :   .tFetchB
5142:       | nCharType, nStringType, nFileType : #eNotImplemented
5146:       | nPointerType :   .tFetchP
5150:       | * :              % compound type; leave as addr
5165:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5166: LValueIndexes:
5168:    {[
5168:       | '[' :       @ArraySubscripts
5172:       | '.' :       @RecordFieldRef
5176:       | '^' :       @PointerDeref
5180:       | * :         >
5191:    ]};
      
5194: ArraySubscripts:
5196:    [ oTypeSNodeType
5198:       | nArrayType :
5199:       | * :       #eNotArray
5206:    ]
5206:    {
5206:       [ oTypeSNodeType
5208:          | nArrayType :
5209:          | * :    #eTooManySubscripts
5216:       ]
      
            % low subscript of this dimension
5216:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5233:       Node baseType
5233:       baseType = oNodeGet( oTypeSTop, qBaseType )
5245:       oTypeSPop
5246:       oTypeSPush( baseType )
      
5252:       @Expr
5254:       @RequireIntPop
            % adjust for low subscript
5256:       [ equal_zero( low )
5263:          | false :
5264:             .tPushConstI oEmitInt( low ) .tSubI
5274:          | * :
5279:       ]
      
            % multiply by element size
5279:       int size = oNodeGetInt( baseType, qSize )
5292:       [ equal( size, 1 )
5302:          | false :
5303:             .tPushConstI oEmitInt( size ) .tMultI
5313:          | * :
5318:       ]
      
            % update start address
5318:       .tAddPI
5320:       [
5320:          | ']' :  >
5324:          | ',' :
5326:       ]
5334:    };
      
      
5337: RecordFieldRef:
5339:    [ oTypeSNodeType
5341:       | nRecordType :
5342:       | * :    #eNotRecord
5349:    ]
5349:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
5361:    pIdent
5363:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
5368:    [ oNodeType( field )
5375:       | nRecordField :
5376:       | * :   #eNotRecordField
5383:    ]
5383:    oScopeEnd
5384:    int offset = oNodeGetInt( field, qValue )
5397:    [ equal_zero( offset )
5404:       | false :
5405:          .tPushConstI oEmitInt( offset ) .tAddPI
5415:       | * :
5420:    ]
      
         % replace the type on the type stack, with the field type
5420:    oTypeSPop
5421:    oTypeSPush( oNodeGet( field, qType ) )
5435:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
5435: PointerDeref:
5437:    [ oTypeSNodeType
5439:       | nPointerType :
5440:       | * :       #eNotPointer
5447:    ]
5447:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
5449:    Node theType = oTypeSTop
5454:    oTypeSPop
5455:    oTypeSPush( oNodeGet( theType, qBaseType ) )
5469:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
5469: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
5471:    @MatchTypes
5474:    ;
      
      
      % Called on first use of an extern method
      %
5474: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
5476:    int strAddr
5476:    String externalName = oNodeGetString( method, qExternalName )
5489:    [ equal_string( externalName, stringNull )
5499:       | true :
5500:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
5521:       | false :
5523:          strAddr = oStringAllocLit( externalName )
5533:    ]
5541:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
5557:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
5557: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
5559:    [ oNodeGetBoolean( method, qExternal )
5569:       | true :
5570:          [ oNodeGetBoolean( method, qCalled )
5580:             | false :
                     % define the extern label on first use
5581:                @DefineExternLabel( method )
5588:             | * :
5593:          ]
5593:      | * :
5598:    ]
5598:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
5610:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
5623:    Node resultType
5623:    int tempOffset
      
5623:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
5640:    [ isFunc
5643:       | true :
5644:          resultType = oNodeGet( method, qType )
5657:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
5667:       | * :
5672:    ]
         
      
5672:    Node paramScope = oNodeGet( method, qParams )
5685:    int actualsSize = oNodeGetInt( paramScope, qSize )
5698:    [ cdecl
5701:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
5710:       | false :  .tAllocActuals  oEmitInt( actualsSize )
5720:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
5728:    [ greater( @DeclLevel( method ), 0 )
5743:       | true :
5744:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
5752:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
5771:          .tAssignP
5773:       | * :
5778:    ]
      
      
5778:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
5791:    Node param = oNodeIterValue( paramIter )
5801:    [
5801:       | '(' :
            
5803:          {
5803:             [ oNodeNull( param )
5810:                | true : >
5813:                | * :
5818:             ]
      
5818:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
5831:             .tPushAddrActual oEmitInt( offset )
5839:             oTypeSPush( oNodeGet( param, qType ) )
      
5852:             [ oNodeGetBoolean( param, qInOut )
5862:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5863:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5865:                           @MatchTypes
      
5867:                           .tAssignP
      
5869:                | false :  @Expr
5873:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5875:                           [ oTypeSNodeType
5877:                              | nIntegerType :            .tAssignI
5880:                              | nBooleanType :            .tAssignB
5884:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5888:                              | nPointerType :            .tAssignP
5892:                              | * :
                                       % compound types: copy value into actuals space
5907:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5919:                                  .tCopy  oEmitInt( size )    % multi-word copy
5927:                           ]
5927:             ]
5935:             oTypeSPop
      
5936:             oNodeIterNext( paramIter )
5942:             param = oNodeIterValue( paramIter )
5952:             [ oNodeNull( param )
5959:                | true :  >
5962:                | false :
5964:             ]
      
5972:             ','
5974:          }
      
5976:          ')'
      
5978:       | * :
5983:    ]
      
5983:    [ oNodeNull( param )
5990:       | false :    #eMissingParameter
5993:       | * :
5998:    ]
      
5998:    [ isFunc
6001:       | true :
               % Pass result temp as an additional VAR parameter.
6002:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6017:          .tPushAddrLocal  oEmitInt( tempOffset )
6025:          .tAssignP
6027:       | * :
6032:    ]
      
6032:    [ cdecl
6035:       | true :
6036:          .tCallCdecl  @EmitValue( method )
6045:       | false :
6047:          .tCall   @EmitValue( method )
6056:    ]
      
6064:    [ isFunc
6067:       | true :
               % push return value from temp
6068:          oTypeSPush( resultType )
      
6074:          [ oTypeSNodeType
6076:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6085:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6095:             | nCharType, nStringType, nFileType : #eNotImplemented
6099:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6109:             | * :              % compound type: push address
6124:                                .tPushAddrLocal  oEmitInt( tempOffset )
6132:          ]
6132:       | * :
6137:    ]
         
6137:    .tFreeActuals  oEmitInt( actualsSize )
6146:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6146: Statement:
6148:    [
6148:       | pWriteln :     @WritelnStmt
6152:       | pWrite :       @WriteStmt
6156:       | pReadln :      @ReadlnStmt
6160:       | pRead :        @ReadStmt
6164:       | pIf :          @IfStmt
6168:       | pWhile :       @WhileStmt
6172:       | pFor :         @ForStmt
6176:       | pRepeat :      @RepeatStmt
6180:       | pBreak :       @BreakStmt
6184:       | pContinue :    @ContinueStmt
6188:       | pBegin :       @BeginStmt
6192:       | pIdent :       @AssignOrCallStmt
6196:       | * :            % null statement : don't accept any tokens
6223:    ];
      
      
6224: AssignOrCallStmt:
6226:    Node decl = oScopeFindRequire
6231:    [ oNodeType( decl )
6238:       | nProc :                           @Call( decl )
6246:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6255:       | nFunc :                           @AssignResultStmt( decl )
6264:       | * :                               #eBadStatement
6279:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6280: AssignStmt( Node decl ):
      
6282:    @LValueVar( decl )
6289:    ':=' 
6291:    @Expr
6293:    @MatchTypes
6295:    @Assign
6298:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6298: Assign:
6300:    [ oTypeSNodeType
6302:       | nIntegerType :            .tAssignI
6305:       | nBooleanType :            .tAssignB
6309:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6313:       | nPointerType :            .tAssignP
6317:       | * :
6332:           int size = oNodeGetInt( oTypeSTop, qSize )
6344:           .tCopy  oEmitInt( size )    % multi-word copy
6352:    ]
6352:    oTypeSPop
6354:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
6354: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
6356:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
6372:       | false :   #eNotCurrentFunction
6375:       | * :
6380:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
6380:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
6395:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
6408:    ':='
6410:    @Expr
6412:    @MatchTypes
6414:    [ oTypeSNodeType
6416:       | nIntegerType :            .tAssignI
6419:       | nBooleanType :            .tAssignB
6423:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6427:       | nPointerType :            .tAssignP
6431:       | * :
6446:           int size = oNodeGetInt( oTypeSTop, qSize )
6458:           .tCopy  oEmitInt( size )    % multi-word copy
6466:    ]
6466:    oTypeSPop
6468:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
6468: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
6470:    pIdent
6472:    Node decl = oScopeFindRequire
6477:    [ oNodeType( decl )
6484:       | nGlobalVar, nLocalVar, nParam :
6485:       | * :  #eNotVar
6496:    ]
6496:    @LValueVar( decl )
6504:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
6504: LValueVar( Node decl ):
6506:    [ oNodeType( decl )
6513:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6523:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
6534:       | nParam :
6536:          [ oNodeGetBoolean( decl, qInOut )
6546:             | true :   % VAR param points to variable.  No dereference.
6547:                        .tPushParamP @EmitValue( decl )
6556:             | * :      .tPushAddrParam @EmitValue( decl )
6570:          ]
6570:       | * :            #eNotVar
6581:    ]
      
6581:    oTypeSPush( oNodeGet( decl, qType ) )
6594:    @LValueIndexes        % handle subscripts, if any
6597:    ;
      
      
6597: IncVar( Node decl ):
6599:    @LValueVar( decl )
6606:    @RequireIntPop
6608:    @VarExpr( decl )
6615:    oTypeSPop
6616:    .tIncI
6618:    .tAssignI;
      
6621: DecVar( Node decl ):
6623:    @LValueVar( decl )
6630:    @RequireIntPop
6632:    @VarExpr( decl )
6639:    oTypeSPop
6640:    .tDecI
6642:    .tAssignI;
      
      
6645: IfStmt:
6647:    Label falseLabel = labelNull
      
6653:    @BooleanExprControlFlow( falseLabel )
6660:    pThen
6662:    @Statement
6664:    [
6664:       | pElse :
6666:          Label doneLabel = oLabelNew
      
6671:          .tJump  oEmitLabel( doneLabel )
6679:          .tLabel oEmitLabel( falseLabel )
6687:          @Statement
6689:          .tLabel oEmitLabel( doneLabel )
      
6697:       | * :
6702:          .tLabel oEmitLabel( falseLabel )
6710:    ];
      
      
6711: ForStmt:
6713:    pIdent
      
6715:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
6720:    @LValueVar( decl )
6727:    @RequireIntPop
      
6729:    ':='
      
6731:    @Expr
6733:    @RequireIntPop
6735:    .tAssignI
      
6737:    Label breakLabel = oLabelNew
      
6742:    Label checkLabel = oLabelNew
6747:    .tJump  oEmitLabel( checkLabel )
      
6755:    Label continueLabel = oLabelNew
6760:    .tLabel  oEmitLabel( continueLabel )
6768:    [
6768:       | pTo :
6770:          @IncVar( decl )
6777:          .tLabel  oEmitLabel( checkLabel )
6785:          @VarExpr( decl )  oTypeSPop
6793:          @Expr
6795:          @RequireIntPop
6797:          .tGreaterI
6799:          .tJumpTrue  oEmitLabel( breakLabel )
6807:       | pDownto :
6809:          @DecVar( decl )
6816:          .tLabel  oEmitLabel( checkLabel )
6824:          @VarExpr( decl )  oTypeSPop
6832:          @Expr
6834:          @RequireIntPop
6836:          .tLessI
6838:          .tJumpTrue  oEmitLabel( breakLabel )
6846:    ]
6854:    oLoopPush( continueLabel, breakLabel )
6863:    pDo
6865:    @Statement
6867:    .tJump  oEmitLabel( continueLabel )
6875:    .tLabel  oEmitLabel( breakLabel )
6883:    oLoopPop;
      
      
6885: RepeatStmt:
6887:    Label continueLabel = oLabelNew
6892:    .tLabel  oEmitLabel( continueLabel )
      
6900:    Label breakLabel = oLabelNew
      
6905:    oLoopPush( continueLabel, breakLabel )
6914:    @Statement
6916:    {[
6916:       | ';' :
6918:          @Statement
6920:       | pUntil :
6922:          Label falseLabel
6922:          @BooleanExprControlFlow( falseLabel )
6929:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6943:          >
6945:    ]}
6955:    .tLabel  oEmitLabel( breakLabel )
6963:    oLoopPop;
      
      
6965: WhileStmt:
6967:    Label continueLabel = oLabelNew
6972:    .tLabel  oEmitLabel( continueLabel )
      
6980:    Label breakLabel
6980:    @BooleanExprControlFlow( breakLabel )
      
6987:    oLoopPush( continueLabel, breakLabel )
6996:    pDo
6998:    @Statement
7000:    .tJump  oEmitLabel( continueLabel )
7008:    .tLabel  oEmitLabel( breakLabel )
7016:    oLoopPop;
      
      
7018: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7020:    [ equal_label( oLoopContinueLabel, labelNull )
7029:       | true :
7030:          #eNotInALoop
7032:       | false :
7034:          .tJump  oEmitLabel( oLoopContinueLabel )
7041:    ];
      
      
7050: BreakStmt:
7052:    [ equal_label( oLoopBreakLabel, labelNull )
7061:       | true :
7062:          #eNotInALoop
7064:       | false :
7066:          .tJump  oEmitLabel( oLoopBreakLabel )
7073:    ];
      
      
7082: BeginStmt:
7084:    @Statement
7086:    {[
7086:       | ';' :   @Statement
7090:       | pEnd :  >
7094:    ]};
      
      
7105: WritelnStmt:
7107:    @WriteStmt
7109:    .tWriteCR;
      
      
7112: WriteStmt:
7114:    [
7114:       | '(' :
7116:          {
7116:             @Expr
7118:             [ oTypeSNodeType
7120:                | nIntegerType :             .tWriteI
7123:                | nBooleanType :             .tWriteBool
7127:                | nStringType :              .tWriteStr
7131:                | nCharType, nFileType :     #eNotImplemented
7135:                | nPointerType :             .tWriteP
7139:                | * :                        #eNotAllowed
7156:             ]
7156:             oTypeSPop
7157:             [
7157:                | ')' : >
7161:                | ',' :
7163:             ]
7171:          }
7173:       | * :
7178:    ];
      
      
7179: ReadlnStmt:      % ***
         % TO DO
7182:    ;
      
7182: ReadStmt:
         % TO DO
7185:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7185: ScopeLevel >> int:
7187:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7197: DeclLevel( Node decl ) >> int:
7199:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7217: DeclUpLevels( Node decl ) >> int:
7219:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7235: MatchTypes:
7237:    node_type nt = oTypeSNodeType
7242:    oTypeSPop
7243:    [ equal_node_type( nt, oTypeSNodeType )
7252:       | false :
7253:          #eTypeMismatch
7255:       | * :
7260:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7261: RequireIntPop:
7263:    [ oTypeSNodeType
7265:       | nIntegerType :
7266:       | * :          #eNotInteger
7273:    ]
7273:    oTypeSPop;
      
7275: RequireInt:
7277:    [ oTypeSNodeType
7279:       | nIntegerType :
7280:       | * :          #eNotInteger
7287:    ];
      
7288: RequireBoolPop:
7290:    [ oTypeSNodeType
7292:       | nBooleanType :
7293:       | * :          #eNotBoolean
7300:    ]
7300:    oTypeSPop;
      
7302: RequireBool:
7304:    [ oTypeSNodeType
7306:       | nBooleanType :
7307:       | * :          #eNotBoolean
7314:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7315: newType( node_type nt, int size ) >> Node:
7317:   Node node = oNodeNew( nt )
7327:   oNodeSetInt( node, qSize, size )
7339:   oTypeAdd( node )
7345:   >> node
7349:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
7349: newIdent( node_type nt, kind k, int id ) >> Node:
7351:   Node t = oNodeNew( nt )
7361:   oNodeSetInt( t, qIdent, id )
7373:   >> t
7377:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
7377: PointerTypeTo( Node theType ) >> Node:
7379:    Node ptrType = oNodeGet( theType, qPointerType )
7392:    [ oNodeNull( ptrType )
7399:       | true :
7400:          ptrType = oNodeNew( nPointerType )
7410:          oNodeSet( ptrType, qBaseType, theType )
7422:          oNodeSetInt( ptrType, qSize, 8 )
7434:          oTypeAdd( ptrType )
7440:          oNodeSet( theType, qPointerType, ptrType )
7452:       | * :
7457:    ]
7457:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
7461: OrdinalLow( Node theType ) >> int:
7463:    [ oNodeType( theType )
7470:       | nIntegerType :  >> oMININT
7473:       | nBooleanType :  >> 0
7478:       | nCharType :     >> 0
7483:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
7495:       | * :             #eNotOrdinalType
7508:                         >> 0
7511:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
7512: EmitValue( Node decl ):
7514:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
7528: installBuiltIns:
      
         % install built-in types
7530:    FileType = @newType( nFileType, 4 )
7544:    IntegerType = @newType( nIntegerType, 4 )
7558:    BooleanType = @newType( nBooleanType, 1 )
7572:    BooleanCFType = @newType( nBooleanCFType, 1 )
7586:    CharType = @newType( nCharType, 1 )
7600:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
7614:    Node t
      
7614:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
7630:    oNodeSet( t, qType, FileType )
7642:    oScopeDeclare( t )
      
7648:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
7664:    oNodeSet( t, qType, IntegerType )
7676:    oScopeDeclare( t )
      
7682:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
7698:    oNodeSet( t, qType, BooleanType )
7710:    oScopeDeclare( t )
      
7716:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
7732:    oNodeSet( t, qType, CharType )
7744:    oScopeDeclare( t )
      
7750:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
7766:    oNodeSet( t, qType, StringType )
7778:    oScopeDeclare( t )
      
         % Built-in constants
      
7784:    t = @newIdent( nConst, kConst, oIdAdd_True )
7800:    oNodeSet( t, qType, BooleanType )
7812:    oNodeSetInt( t, qValue, 1 )
7824:    oScopeDeclare( t )
      
7830:    t = @newIdent( nConst, kConst, oIdAdd_False )
7846:    oNodeSet( t, qType, BooleanType )
7858:    oNodeSetInt( t, qValue, 0 )
7870:    oScopeDeclare( t )
      
7877:    ;
      
7877: end
      
7877: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oSetResult 2
   9: oPushResult
  10: oNodeNew
  11: oPop 1
  13: oAssign
  14: oSetResult 0
  16: oPushResult
  17: oScopeBegin
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oScopeCurrent
  24: oAssign
  25: oCall 7528
  27: oEmit 52
  29: oSetResult 0
  31: oPushResult
  32: oEmitInt
  33: oPop 1
  35: oGetAddrLocal 3
  37: oPushResult
  38: oLabelNew
  39: oAssign
  40: oEmit 46
  42: oSetResult 0
  44: oPushResult
  45: oEmitInt
  46: oPop 1
  48: oEmit 49
  50: oGetLocal 3
  52: oPushResult
  53: oEmitLabel
  54: oPop 1
  56: oEmit 48
  58: oSetResult 0
  60: oPushResult
  61: oEmitInt
  62: oPop 1
  64: oEmit 51
  66: oInput 27
  68: oInput 0
  70: oGetAddrLocal 4
  72: oPushResult
  73: oSetResult 4
  75: oPushResult
  76: oNodeNew
  77: oPop 1
  79: oAssign
  80: oGetLocal 4
  82: oPushResult
  83: oSetResult 3
  85: oPushResult
  86: LAST_ID
  87: oPushResult
  88: oNodeSetInt
  89: oPop 3
  91: oGetGlobal 1
  93: oPushResult
  94: oSetResult 2
  96: oPushResult
  97: oGetLocal 4
  99: oPushResult
 100: oNodeSet
 101: oPop 3
 103: oInputChoice 183
 105: oInput 0
 107: oGetAddrLocal 1
 109: oPushResult
 110: oSetResult 14
 112: oPushResult
 113: oSetResult 6
 115: oPushResult
 116: LAST_ID
 117: oPushResult
 118: oCall 7349
 120: oPop 3
 122: oAssign
 123: oGetLocal 1
 125: oPushResult
 126: oSetResult 19
 128: oPushResult
 129: oGetGlobal 3
 131: oPushResult
 132: oNodeSet
 133: oPop 3
 135: oGetLocal 1
 137: oPushResult
 138: oScopeDeclareAlloc
 139: oPop 1
 141: oInput 12
 143: oInput 0
 145: oGetAddrLocal 1
 147: oPushResult
 148: oSetResult 14
 150: oPushResult
 151: oSetResult 6
 153: oPushResult
 154: LAST_ID
 155: oPushResult
 156: oCall 7349
 158: oPop 3
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 19
 166: oPushResult
 167: oGetGlobal 3
 169: oPushResult
 170: oNodeSet
 171: oPop 3
 173: oGetLocal 1
 175: oPushResult
 176: oScopeDeclareAlloc
 177: oPop 1
 179: oInput 14
 181: oJumpForward 186
 183: Choice Lookup Table
          13    105
 186: oInput 4
 188: oInputChoice 199
 190: oGetLocal 4
 192: oPushResult
 193: oCall 277
 195: oPop 1
 197: oJumpForward 202
 199: Choice Lookup Table
          54    190
 202: oSetResult 0
 204: oPushResult
 205: oScopeBegin
 206: oPop 1
 208: oGetAddrLocal 5
 210: oPushResult
 211: oScopeCurrent
 212: oAssign
 213: oSetResult 0
 215: oPushResult
 216: oScopeBegin
 217: oPop 1
 219: oGetAddrGlobal 2
 221: oPushResult
 222: oScopeCurrent
 223: oAssign
 224: oGetGlobal 2
 226: oPushResult
 227: oSetResult 16
 229: oPushResult
 230: oSetResult 1
 232: oPushResult
 233: oNodeSetBoolean
 234: oPop 3
 236: oGetLocal 4
 238: oPushResult
 239: oSetResult 6
 241: oPushResult
 242: oGetGlobal 2
 244: oPushResult
 245: oNodeSet
 246: oPop 3
 248: oScopeEnd
 249: oSetResult 15
 251: oPushResult
 252: oCall 918
 254: oPop 1
 256: oGetGlobal 2
 258: oPushResult
 259: oScopeEnter
 260: oPop 1
 262: oGetLocal 3
 264: oPushResult
 265: oGetLocal 5
 267: oPushResult
 268: oCall 968
 270: oPop 2
 272: oScopeEnd
 273: oInput 19
 275: oScopeEnd
 276: oReturn
 277: oLocalSpace 1
 279: oInput 0
 281: oGetAddrLocal 1
 283: oPushResult
 284: LAST_ID
 285: oPushResult
 286: oCall 346
 288: oPop 1
 290: oAssign
 291: oGetLocal 1
 293: oPushResult
 294: oSetResult 0
 296: oPushResult
 297: equal_node
 298: oPop 2
 300: oChoice 329
 302: oGetParam 1
 304: oPushResult
 305: oSetResult 4
 307: oPushResult
 308: oGetLocal 1
 310: oPushResult
 311: oNodeAddLast
 312: oPop 3
 314: oGetLocal 1
 316: oPushResult
 317: oSetResult 7
 319: oPushResult
 320: oNodeGet
 321: oPop 2
 323: oPushResult
 324: oScopeEnter
 325: oPop 1
 327: oJumpForward 332
 329: Choice Lookup Table
           0    302
 332: oInputChoice 336
 334: oJumpForward 341
 336: Choice Lookup Table
          12    334
 339: oJumpForward 343
 341: oJumpBack 279
 343: oInput 4
 345: oReturn
 346: oLocalSpace 2
 348: oSetResult 10
 350: oPushResult
 351: oMsg
 352: oPop 1
 354: oGetParam 1
 356: oPushResult
 357: oMsg
 358: oPop 1
 360: oGetAddrLocal 1
 362: oPushResult
 363: oGetGlobal 1
 365: oPushResult
 366: oSetResult 1
 368: oPushResult
 369: oSetResult 3
 371: oPushResult
 372: oGetParam 1
 374: oPushResult
 375: oNodeFind
 376: oPop 4
 378: oAssign
 379: oGetLocal 1
 381: oPushResult
 382: oSetResult 0
 384: oPushResult
 385: equal_node
 386: oPop 2
 388: oChoice 395
 390: oGetLocal 1
 392: oReturn
 393: oJumpForward 398
 395: Choice Lookup Table
           0    390
 398: oGetAddrLocal 2
 400: oPushResult
 401: oGetParam 1
 403: oPushResult
 404: oIncludeUnitFile
 405: oPop 1
 407: oAssign
 408: oGetLocal 2
 410: oChoice 419
 412: oError 24
 414: oSetResult 0
 416: oReturn
 417: oJumpForward 422
 419: Choice Lookup Table
           0    412
 422: oGetAddrLocal 1
 424: oPushResult
 425: oCall 433
 427: oAssign
 428: oIncludeEnd
 429: oGetLocal 1
 431: oReturn
 432: oReturn
 433: oLocalSpace 1
 435: oInput 55
 437: oInput 0
 439: oGetAddrLocal 1
 441: oPushResult
 442: oSetResult 5
 444: oPushResult
 445: oNodeNew
 446: oPop 1
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 3
 454: oPushResult
 455: LAST_ID
 456: oPushResult
 457: oNodeSetInt
 458: oPop 3
 460: oGetGlobal 1
 462: oPushResult
 463: oSetResult 1
 465: oPushResult
 466: oGetLocal 1
 468: oPushResult
 469: oNodeAddLast
 470: oPop 3
 472: oInput 4
 474: oInputChoice 485
 476: oGetLocal 1
 478: oPushResult
 479: oCall 277
 481: oPop 1
 483: oJumpForward 488
 485: Choice Lookup Table
          54    476
 488: oInput 56
 490: oSetResult 0
 492: oPushResult
 493: oScopeBegin
 494: oPop 1
 496: oGetLocal 1
 498: oPushResult
 499: oSetResult 7
 501: oPushResult
 502: oScopeCurrent
 503: oPushResult
 504: oNodeSet
 505: oPop 3
 507: oSetResult 0
 509: oPushResult
 510: oScopeBegin
 511: oPop 1
 513: oGetAddrGlobal 2
 515: oPushResult
 516: oScopeCurrent
 517: oAssign
 518: oGetGlobal 2
 520: oPushResult
 521: oSetResult 16
 523: oPushResult
 524: oSetResult 1
 526: oPushResult
 527: oNodeSetBoolean
 528: oPop 3
 530: oGetLocal 1
 532: oPushResult
 533: oSetResult 11
 535: oPushResult
 536: oGetGlobal 2
 538: oPushResult
 539: oNodeSet
 540: oPop 3
 542: oScopeEnd
 543: oGetLocal 1
 545: oPushResult
 546: oCall 627
 548: oPop 1
 550: oInput 57
 552: oSetResult 0
 554: oPushResult
 555: oScopeBegin
 556: oPop 1
 558: oGetLocal 1
 560: oPushResult
 561: oSetResult 8
 563: oPushResult
 564: oScopeCurrent
 565: oPushResult
 566: oNodeSet
 567: oPop 3
 569: oGetLocal 1
 571: oPushResult
 572: oCall 672
 574: oPop 1
 576: oInputChoice 590
 578: oGetLocal 1
 580: oPushResult
 581: oSetResult 1
 583: oPushResult
 584: oCall 682
 586: oPop 2
 588: oJumpForward 603
 590: Choice Lookup Table
          58    578
 593: oGetLocal 1
 595: oPushResult
 596: oSetResult 0
 598: oPushResult
 599: oCall 682
 601: oPop 2
 603: oInputChoice 614
 605: oGetLocal 1
 607: oPushResult
 608: oCall 884
 610: oPop 1
 612: oJumpForward 617
 614: Choice Lookup Table
          59    605
 617: oInput 34
 619: oInput 19
 621: oScopeEnd
 622: oScopeEnd
 623: oGetLocal 1
 625: oReturn
 626: oReturn
 627: oLocalSpace 0
 629: oInputChoice 656
 631: oCall 2242
 633: oJumpForward 669
 635: oCall 2314
 637: oJumpForward 669
 639: oSetResult 15
 641: oPushResult
 642: oCall 2373
 644: oPop 1
 646: oJumpForward 669
 648: oCall 889
 650: oJumpForward 669
 652: oCall 894
 654: oJumpForward 669
 656: Choice Lookup Table
          29    652
          28    648
          32    639
          31    635
          30    631
 667: oJumpForward 671
 669: oJumpBack 629
 671: oReturn
 672: oLocalSpace 0
 674: oSetResult 15
 676: oPushResult
 677: oCall 918
 679: oPop 1
 681: oReturn
 682: oLocalSpace 5
 684: oGetAddrLocal 1
 686: oPushResult
 687: oLabelNew
 688: oAssign
 689: oEmit 56
 691: oGetLocal 1
 693: oPushResult
 694: oEmitLabel
 695: oPop 1
 697: oGetParam 2
 699: oPushResult
 700: oSetResult 9
 702: oPushResult
 703: oGetLocal 1
 705: oPushResult
 706: oNodeSetLabel
 707: oPop 3
 709: oEmit 52
 711: oGetAddrLocal 2
 713: oPushResult
 714: Here
 715: oAssign
 716: oEmit 64
 718: oGetAddrLocal 3
 720: oPushResult
 721: oGetParam 2
 723: oPushResult
 724: oSetResult 7
 726: oPushResult
 727: oNodeGet
 728: oPop 2
 730: oAssign
 731: oGetAddrLocal 4
 733: oPushResult
 734: oGetLocal 3
 736: oPushResult
 737: oSetResult 17
 739: oPushResult
 740: oNodeGetCode
 741: oPop 2
 743: oAssign
 744: oSetResult 3000
 746: oPushResult
 747: oMsg
 748: oPop 1
 750: oGetLocal 3
 752: oPushResult
 753: oMsgNodeLong
 754: oPop 1
 756: oSetResult 3001
 758: oPushResult
 759: oMsg
 760: oPop 1
 762: oGetLocal 4
 764: oPushResult
 765: oEmitCode
 766: oPop 1
 768: oGetLocal 3
 770: oPushResult
 771: oSetResult 17
 773: oPushResult
 774: oSetResult 0
 776: oPushResult
 777: oNodeSetCode
 778: oPop 3
 780: oGetAddrLocal 3
 782: oPushResult
 783: oGetParam 2
 785: oPushResult
 786: oSetResult 8
 788: oPushResult
 789: oNodeGet
 790: oPop 2
 792: oAssign
 793: oGetAddrLocal 4
 795: oPushResult
 796: oGetLocal 3
 798: oPushResult
 799: oSetResult 17
 801: oPushResult
 802: oNodeGetCode
 803: oPop 2
 805: oAssign
 806: oGetLocal 4
 808: oPushResult
 809: oEmitCode
 810: oPop 1
 812: oGetLocal 3
 814: oPushResult
 815: oSetResult 17
 817: oPushResult
 818: oSetResult 0
 820: oPushResult
 821: oNodeSetCode
 822: oPop 3
 824: oGetParam 2
 826: oPushResult
 827: oSetResult 11
 829: oPushResult
 830: oNodeGet
 831: oPop 2
 833: oPushResult
 834: oScopeEnter
 835: oPop 1
 837: oGetParam 1
 839: oChoice 856
 841: oCall 6146
 843: oInputChoice 849
 845: oCall 6146
 847: oJumpForward 852
 849: Choice Lookup Table
           4    845
 852: oJumpBack 843
 854: oJumpForward 859
 856: Choice Lookup Table
           1    841
 859: oEmit 51
 861: oGetAddrLocal 5
 863: oPushResult
 864: oScopeCurrent
 865: oPushResult
 866: oSetResult 15
 868: oPushResult
 869: oNodeGetInt
 870: oPop 2
 872: oAssign
 873: oGetLocal 2
 875: oPushResult
 876: oGetLocal 5
 878: oPushResult
 879: oPatch
 880: oPop 2
 882: oScopeEnd
 883: oReturn
 884: oLocalSpace 0
 886: oError 16
 888: oReturn
 889: oLocalSpace 0
 891: oError 16
 893: oReturn
 894: oLocalSpace 0
 896: oError 16
 898: oReturn
 899: oLocalSpace 0
 901: oGetParam 2
 903: oPushResult
 904: oCall 918
 906: oPop 1
 908: oGetParam 1
 910: oPushResult
 911: oScopeCurrent
 912: oPushResult
 913: oCall 968
 915: oPop 2
 917: oReturn
 918: oLocalSpace 0
 920: oInputChoice 947
 922: oCall 2242
 924: oJumpForward 960
 926: oCall 2314
 928: oJumpForward 960
 930: oGetParam 1
 932: oPushResult
 933: oCall 2373
 935: oPop 1
 937: oJumpForward 960
 939: oCall 1266
 941: oJumpForward 960
 943: oCall 1610
 945: oJumpForward 960
 947: Choice Lookup Table
          29    943
          28    939
          32    930
          31    926
          30    922
 958: oJumpForward 962
 960: oJumpBack 920
 962: oCall 965
 964: oReturn
 965: oLocalSpace 0
 967: oReturn
 968: oLocalSpace 5
 970: oEmit 56
 972: oGetParam 2
 974: oPushResult
 975: oEmitLabel
 976: oPop 1
 978: oEmit 52
 980: oGetAddrLocal 1
 982: oPushResult
 983: Here
 984: oAssign
 985: oEmit 64
 987: oGetAddrLocal 2
 989: oPushResult
 990: oGetGlobal 1
 992: oPushResult
 993: oSetResult 1
 995: oPushResult
 996: oNodeGetIter
 997: oPop 2
 999: oAssign
1000: oGetAddrLocal 3
1002: oPushResult
1003: oGetLocal 2
1005: oPushResult
1006: oNodeIterValue
1007: oPop 1
1009: oAssign
1010: oGetLocal 3
1012: oPushResult
1013: oNodeNull
1014: oPop 1
1016: oChoice 1061
1018: oJumpForward 1069
1020: oJumpForward 1067
1022: oEmit 46
1024: oSetResult 0
1026: oPushResult
1027: oEmitInt
1028: oPop 1
1030: oEmit 49
1032: oGetLocal 3
1034: oPushResult
1035: oSetResult 9
1037: oPushResult
1038: oNodeGetLabel
1039: oPop 2
1041: oPushResult
1042: oEmitLabel
1043: oPop 1
1045: oEmit 48
1047: oSetResult 0
1049: oPushResult
1050: oEmitInt
1051: oPop 1
1053: oGetAddrLocal 2
1055: oPushResult
1056: oNodeIterNext
1057: oPop 1
1059: oJumpForward 1067
1061: Choice Lookup Table
           0   1022
           1   1018
1066: oEndChoice
1067: oJumpBack 1000
1069: oGetAddrLocal 4
1071: oPushResult
1072: oGetParam 1
1074: oPushResult
1075: oSetResult 17
1077: oPushResult
1078: oNodeGetCode
1079: oPop 2
1081: oAssign
1082: oGetLocal 4
1084: oPushResult
1085: oEmitCode
1086: oPop 1
1088: oGetParam 1
1090: oPushResult
1091: oSetResult 17
1093: oPushResult
1094: oSetResult 0
1096: oPushResult
1097: oNodeSetCode
1098: oPop 3
1100: oCall 6146
1102: oEmit 51
1104: oGetAddrLocal 5
1106: oPushResult
1107: oScopeCurrent
1108: oPushResult
1109: oSetResult 15
1111: oPushResult
1112: oNodeGetInt
1113: oPop 2
1115: oAssign
1116: oGetLocal 1
1118: oPushResult
1119: oGetLocal 5
1121: oPushResult
1122: oPatch
1123: oPop 2
1125: oReturn
1126: oLocalSpace 0
1128: oInputChoice 1146
1130: oGetParam 1
1132: oPushResult
1133: oSetResult 25
1135: oPushResult
1136: oSetResult 1
1138: oPushResult
1139: oNodeSetBoolean
1140: oPop 3
1142: oInput 4
1144: oJumpForward 1151
1146: Choice Lookup Table
          67   1130
1149: oJumpForward 1153
1151: oJumpBack 1128
1153: oReturn
1154: oLocalSpace 1
1156: oGetAddrLocal 1
1158: oPushResult
1159: oScopeCurrent
1160: oPushResult
1161: oSetResult 17
1163: oPushResult
1164: oNodeGetCode
1165: oPop 2
1167: oAssign
1168: oGetLocal 1
1170: oPushResult
1171: oSetResult 0
1173: oPushResult
1174: equal_code
1175: oPop 2
1177: oChoice 1197
1179: oGetAddrLocal 1
1181: oPushResult
1182: oCodeNew
1183: oAssign
1184: oScopeCurrent
1185: oPushResult
1186: oSetResult 17
1188: oPushResult
1189: oGetLocal 1
1191: oPushResult
1192: oNodeSetCode
1193: oPop 3
1195: oJumpForward 1200
1197: Choice Lookup Table
           1   1179
1200: oGetLocal 1
1202: oReturn
1203: oReturn
1204: oLocalSpace 0
1206: oGetParam 1
1208: oPushResult
1209: oCall 7197
1211: oPop 1
1213: oPushResult
1214: equal_zero
1215: oPop 1
1217: oChoice 1223
1219: oError 23
1221: oJumpForward 1226
1223: Choice Lookup Table
           0   1219
1226: oGetParam 1
1228: oPushResult
1229: oSetResult 23
1231: oPushResult
1232: oSetResult 1
1234: oPushResult
1235: oNodeSetBoolean
1236: oPop 3
1238: oInputChoice 1262
1240: oInputChoice 1257
1242: oInput 2
1244: oGetParam 1
1246: oPushResult
1247: oSetResult 24
1249: oPushResult
1250: CURRENT_STRLIT
1251: oPushResult
1252: oNodeSetString
1253: oPop 3
1255: oJumpForward 1260
1257: Choice Lookup Table
          66   1242
1260: oJumpForward 1265
1262: Choice Lookup Table
           2   1240
1265: oReturn
1266: oLocalSpace 7
1268: oInput 0
1270: oGetAddrLocal 1
1272: oPushResult
1273: oSetResult 0
1275: oAssign
1276: oGetAddrLocal 2
1278: oPushResult
1279: oScopeFindInCurrentScope
1280: oAssign
1281: oGetLocal 2
1283: oPushResult
1284: oNodeNull
1285: oPop 1
1287: oChoice 1408
1289: oGetAddrLocal 2
1291: oPushResult
1292: oSetResult 10
1294: oPushResult
1295: oSetResult 2
1297: oPushResult
1298: LAST_ID
1299: oPushResult
1300: oCall 7349
1302: oPop 3
1304: oAssign
1305: oGetLocal 2
1307: oPushResult
1308: oSetResult 20
1310: oPushResult
1311: oLabelNew
1312: oPushResult
1313: oNodeSetLabel
1314: oPop 3
1316: oJumpForward 1414
1318: oGetAddrLocal 1
1320: oPushResult
1321: oSetResult 1
1323: oAssign
1324: oGetLocal 2
1326: oPushResult
1327: oSetResult 22
1329: oPushResult
1330: oNodeGetBoolean
1331: oPop 2
1333: oChoice 1339
1335: oError 21
1337: oJumpForward 1342
1339: Choice Lookup Table
           1   1335
1342: oGetLocal 2
1344: oPushResult
1345: oSetResult 23
1347: oPushResult
1348: oNodeGetBoolean
1349: oPop 2
1351: oChoice 1357
1353: oError 21
1355: oJumpForward 1360
1357: Choice Lookup Table
           1   1353
1360: oGetLocal 2
1362: oPushResult
1363: oNodeType
1364: oPop 1
1366: oChoice 1370
1368: oJumpForward 1375
1370: Choice Lookup Table
          10   1368
1373: oError 21
1375: oGetLocal 2
1377: oPushResult
1378: oSetResult 27
1380: oPushResult
1381: oGetLocal 2
1383: oPushResult
1384: oSetResult 21
1386: oPushResult
1387: oNodeGet
1388: oPop 2
1390: oPushResult
1391: oNodeSet
1392: oPop 3
1394: oGetLocal 2
1396: oPushResult
1397: oSetResult 21
1399: oPushResult
1400: oSetResult 0
1402: oPushResult
1403: oNodeSet
1404: oPop 3
1406: oJumpForward 1414
1408: Choice Lookup Table
           0   1318
           1   1289
1413: oEndChoice
1414: oGetAddrLocal 3
1416: oPushResult
1417: oCall 7185
1419: oAssign
1420: oGetAddrLocal 4
1422: oPushResult
1423: oGetLocal 3
1425: oPushResult
1426: oSetResult 0
1428: oPushResult
1429: greater
1430: oPop 2
1432: oAssign
1433: oGetAddrLocal 3
1435: oPushResult
1436: inc
1437: oPop 1
1439: oGetLocal 3
1441: oPushResult
1442: oScopeBegin
1443: oPop 1
1445: oGetAddrLocal 5
1447: oPushResult
1448: oScopeCurrent
1449: oAssign
1450: oGetLocal 4
1452: oChoice 1471
1454: oGetAddrLocal 6
1456: oPushResult
1457: oGetGlobal 4
1459: oPushResult
1460: oCall 7377
1462: oPop 1
1464: oPushResult
1465: oScopeAllocType
1466: oPop 1
1468: oAssign
1469: oJumpForward 1474
1471: Choice Lookup Table
           1   1454
1474: oCall 2015
1476: oGetLocal 2
1478: oPushResult
1479: oSetResult 21
1481: oPushResult
1482: oGetLocal 5
1484: oPushResult
1485: oNodeSet
1486: oPop 3
1488: oScopeEnd
1489: oInput 4
1491: oGetLocal 1
1493: oChoice 1505
1495: oGetLocal 2
1497: oPushResult
1498: oScopeDeclare
1499: oPop 1
1501: oJumpForward 1511
1503: oJumpForward 1511
1505: Choice Lookup Table
           1   1503
           0   1495
1510: oEndChoice
1511: oGetLocal 2
1513: oPushResult
1514: oCall 1126
1516: oPop 1
1518: oInputChoice 1531
1520: oJumpForward 1607
1522: oGetLocal 2
1524: oPushResult
1525: oCall 1204
1527: oPop 1
1529: oJumpForward 1607
1531: Choice Lookup Table
          65   1522
          64   1520
1536: oGetLocal 5
1538: oPushResult
1539: oScopeEnter
1540: oPop 1
1542: oGetLocal 3
1544: oPushResult
1545: oScopeBegin
1546: oPop 1
1548: oScopeCurrent
1549: oPushResult
1550: oSetResult 16
1552: oPushResult
1553: oSetResult 1
1555: oPushResult
1556: oNodeSetBoolean
1557: oPop 3
1559: oGetLocal 2
1561: oPushResult
1562: oSetResult 5
1564: oPushResult
1565: oScopeCurrent
1566: oPushResult
1567: oNodeSet
1568: oPop 3
1570: oGetAddrLocal 7
1572: oPushResult
1573: oGetLocal 2
1575: oPushResult
1576: oSetResult 20
1578: oPushResult
1579: oNodeGetLabel
1580: oPop 2
1582: oAssign
1583: oSetResult 16
1585: oPushResult
1586: oGetLocal 7
1588: oPushResult
1589: oCall 899
1591: oPop 2
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 22
1598: oPushResult
1599: oSetResult 1
1601: oPushResult
1602: oNodeSetBoolean
1603: oPop 3
1605: oScopeEnd
1606: oScopeEnd
1607: oInput 4
1609: oReturn
1610: oLocalSpace 9
1612: oInput 0
1614: oGetAddrLocal 1
1616: oPushResult
1617: oSetResult 0
1619: oAssign
1620: oGetAddrLocal 2
1622: oPushResult
1623: oScopeFindInCurrentScope
1624: oAssign
1625: oGetLocal 2
1627: oPushResult
1628: oNodeNull
1629: oPop 1
1631: oChoice 1765
1633: oGetAddrLocal 2
1635: oPushResult
1636: oSetResult 11
1638: oPushResult
1639: oSetResult 3
1641: oPushResult
1642: LAST_ID
1643: oPushResult
1644: oCall 7349
1646: oPop 3
1648: oAssign
1649: oGetLocal 2
1651: oPushResult
1652: oSetResult 20
1654: oPushResult
1655: oLabelNew
1656: oPushResult
1657: oNodeSetLabel
1658: oPop 3
1660: oJumpForward 1771
1662: oGetAddrLocal 1
1664: oPushResult
1665: oSetResult 1
1667: oAssign
1668: oGetLocal 2
1670: oPushResult
1671: oSetResult 22
1673: oPushResult
1674: oNodeGetBoolean
1675: oPop 2
1677: oChoice 1683
1679: oError 21
1681: oJumpForward 1686
1683: Choice Lookup Table
           1   1679
1686: oGetLocal 2
1688: oPushResult
1689: oNodeType
1690: oPop 1
1692: oChoice 1696
1694: oJumpForward 1701
1696: Choice Lookup Table
          11   1694
1699: oError 21
1701: oGetLocal 2
1703: oPushResult
1704: oSetResult 27
1706: oPushResult
1707: oGetLocal 2
1709: oPushResult
1710: oSetResult 21
1712: oPushResult
1713: oNodeGet
1714: oPop 2
1716: oPushResult
1717: oNodeSet
1718: oPop 3
1720: oGetLocal 2
1722: oPushResult
1723: oSetResult 21
1725: oPushResult
1726: oSetResult 0
1728: oPushResult
1729: oNodeSet
1730: oPop 3
1732: oGetLocal 2
1734: oPushResult
1735: oSetResult 28
1737: oPushResult
1738: oGetLocal 2
1740: oPushResult
1741: oSetResult 19
1743: oPushResult
1744: oNodeGet
1745: oPop 2
1747: oPushResult
1748: oNodeSet
1749: oPop 3
1751: oGetLocal 2
1753: oPushResult
1754: oSetResult 19
1756: oPushResult
1757: oSetResult 0
1759: oPushResult
1760: oNodeSet
1761: oPop 3
1763: oJumpForward 1771
1765: Choice Lookup Table
           0   1662
           1   1633
1770: oEndChoice
1771: oGetAddrLocal 3
1773: oPushResult
1774: oCall 7185
1776: oAssign
1777: oGetAddrLocal 4
1779: oPushResult
1780: oGetLocal 3
1782: oPushResult
1783: oSetResult 0
1785: oPushResult
1786: greater
1787: oPop 2
1789: oAssign
1790: oGetAddrLocal 3
1792: oPushResult
1793: inc
1794: oPop 1
1796: oGetLocal 3
1798: oPushResult
1799: oScopeBegin
1800: oPop 1
1802: oGetAddrLocal 5
1804: oPushResult
1805: oScopeCurrent
1806: oAssign
1807: oGetLocal 4
1809: oChoice 1828
1811: oGetAddrLocal 6
1813: oPushResult
1814: oGetGlobal 4
1816: oPushResult
1817: oCall 7377
1819: oPop 1
1821: oPushResult
1822: oScopeAllocType
1823: oPop 1
1825: oAssign
1826: oJumpForward 1831
1828: Choice Lookup Table
           1   1811
1831: oCall 2015
1833: oGetLocal 2
1835: oPushResult
1836: oSetResult 21
1838: oPushResult
1839: oGetLocal 5
1841: oPushResult
1842: oNodeSet
1843: oPop 3
1845: oInput 11
1847: oGetAddrLocal 7
1849: oPushResult
1850: oCall 2603
1852: oPop 1
1854: oGetLocal 2
1856: oPushResult
1857: oSetResult 19
1859: oPushResult
1860: oGetLocal 7
1862: oPushResult
1863: oNodeSet
1864: oPop 3
1866: oGetAddrLocal 8
1868: oPushResult
1869: oGetLocal 7
1871: oPushResult
1872: oCall 7377
1874: oPop 1
1876: oAssign
1877: oGetLocal 2
1879: oPushResult
1880: oSetResult 29
1882: oPushResult
1883: oGetLocal 8
1885: oPushResult
1886: oScopeAllocType
1887: oPop 1
1889: oPushResult
1890: oNodeSetInt
1891: oPop 3
1893: oScopeEnd
1894: oInput 4
1896: oGetLocal 1
1898: oChoice 1910
1900: oGetLocal 2
1902: oPushResult
1903: oScopeDeclare
1904: oPop 1
1906: oJumpForward 1916
1908: oJumpForward 1916
1910: Choice Lookup Table
           1   1908
           0   1900
1915: oEndChoice
1916: oGetLocal 2
1918: oPushResult
1919: oCall 1126
1921: oPop 1
1923: oInputChoice 1936
1925: oJumpForward 2012
1927: oGetLocal 2
1929: oPushResult
1930: oCall 1204
1932: oPop 1
1934: oJumpForward 2012
1936: Choice Lookup Table
          65   1927
          64   1925
1941: oGetLocal 5
1943: oPushResult
1944: oScopeEnter
1945: oPop 1
1947: oGetLocal 3
1949: oPushResult
1950: oScopeBegin
1951: oPop 1
1953: oScopeCurrent
1954: oPushResult
1955: oSetResult 16
1957: oPushResult
1958: oSetResult 1
1960: oPushResult
1961: oNodeSetBoolean
1962: oPop 3
1964: oGetLocal 2
1966: oPushResult
1967: oSetResult 5
1969: oPushResult
1970: oScopeCurrent
1971: oPushResult
1972: oNodeSet
1973: oPop 3
1975: oGetAddrLocal 9
1977: oPushResult
1978: oGetLocal 2
1980: oPushResult
1981: oSetResult 20
1983: oPushResult
1984: oNodeGetLabel
1985: oPop 2
1987: oAssign
1988: oSetResult 16
1990: oPushResult
1991: oGetLocal 9
1993: oPushResult
1994: oCall 899
1996: oPop 2
1998: oGetLocal 2
2000: oPushResult
2001: oSetResult 22
2003: oPushResult
2004: oSetResult 1
2006: oPushResult
2007: oNodeSetBoolean
2008: oPop 3
2010: oScopeEnd
2011: oScopeEnd
2012: oInput 4
2014: oReturn
2015: oLocalSpace 6
2017: oInputChoice 2238
2019: oGetAddrLocal 1
2021: oPushResult
2022: oNodeVecNew
2023: oAssign
2024: oGetAddrLocal 3
2026: oPushResult
2027: oSetResult 0
2029: oAssign
2030: oInputChoice 2040
2032: oGetAddrLocal 3
2034: oPushResult
2035: oSetResult 1
2037: oAssign
2038: oJumpForward 2043
2040: Choice Lookup Table
          32   2032
2043: oInput 0
2045: oGetAddrLocal 2
2047: oPushResult
2048: oSetResult 18
2050: oPushResult
2051: oSetResult 6
2053: oPushResult
2054: LAST_ID
2055: oPushResult
2056: oCall 7349
2058: oPop 3
2060: oAssign
2061: oGetLocal 2
2063: oPushResult
2064: oSetResult 30
2066: oPushResult
2067: oGetLocal 3
2069: oPushResult
2070: oNodeSetBoolean
2071: oPop 3
2073: oGetLocal 1
2075: oPushResult
2076: oGetLocal 2
2078: oPushResult
2079: oNodeVecAppend
2080: oPop 2
2082: oInputChoice 2090
2084: oJumpForward 2098
2086: oJumpForward 2096
2088: oJumpForward 2096
2090: Choice Lookup Table
          12   2088
          11   2084
2095: oEndChoice
2096: oJumpBack 2043
2098: oGetAddrLocal 4
2100: oPushResult
2101: oCall 2603
2103: oPop 1
2105: oGetLocal 3
2107: oChoice 2122
2109: oGetAddrLocal 5
2111: oPushResult
2112: oGetLocal 4
2114: oPushResult
2115: oCall 7377
2117: oPop 1
2119: oAssign
2120: oJumpForward 2131
2122: Choice Lookup Table
           1   2109
2125: oGetAddrLocal 5
2127: oPushResult
2128: oGetLocal 4
2130: oAssign
2131: oGetAddrLocal 6
2133: oPushResult
2134: oSetResult 0
2136: oAssign
2137: oGetLocal 6
2139: oPushResult
2140: oGetLocal 1
2142: oPushResult
2143: oNodeVecSize
2144: oPop 1
2146: oPushResult
2147: equal
2148: oPop 2
2150: oChoice 2207
2152: oGetAddrLocal 2
2154: oPushResult
2155: oGetLocal 1
2157: oPushResult
2158: oGetLocal 6
2160: oPushResult
2161: oNodeVecElement
2162: oPop 2
2164: oAssign
2165: oGetLocal 2
2167: oPushResult
2168: oSetResult 19
2170: oPushResult
2171: oGetLocal 4
2173: oPushResult
2174: oNodeSet
2175: oPop 3
2177: oGetLocal 2
2179: oPushResult
2180: oScopeDeclare
2181: oPop 1
2183: oGetLocal 2
2185: oPushResult
2186: oSetResult 20
2188: oPushResult
2189: oGetLocal 5
2191: oPushResult
2192: oScopeAllocType
2193: oPop 1
2195: oPushResult
2196: oNodeSetInt
2197: oPop 3
2199: oGetAddrLocal 6
2201: oPushResult
2202: inc
2203: oPop 1
2205: oJumpForward 2212
2207: Choice Lookup Table
           0   2152
2210: oJumpForward 2214
2212: oJumpBack 2137
2214: oGetLocal 1
2216: oPushResult
2217: oNodeVecDelete
2218: oPop 1
2220: oInputChoice 2228
2222: oJumpForward 2236
2224: oJumpForward 2234
2226: oJumpForward 2234
2228: Choice Lookup Table
           4   2226
          14   2222
2233: oEndChoice
2234: oJumpBack 2019
2236: oJumpForward 2241
2238: Choice Lookup Table
          13   2019
2241: oReturn
2242: oLocalSpace 2
2244: oInputChoice 2306
2246: oGetAddrLocal 1
2248: oPushResult
2249: oSetResult 12
2251: oPushResult
2252: oSetResult 4
2254: oPushResult
2255: LAST_ID
2256: oPushResult
2257: oCall 7349
2259: oPop 3
2261: oAssign
2262: oInput 5
2264: oCall 3077
2266: oGetAddrLocal 2
2268: oPushResult
2269: oValueTop
2270: oAssign
2271: oValuePop
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 20
2277: oPushResult
2278: oGetLocal 2
2280: oPushResult
2281: oNodeSetInt
2282: oPop 3
2284: oGetLocal 1
2286: oPushResult
2287: oSetResult 19
2289: oPushResult
2290: oGetGlobal 4
2292: oPushResult
2293: oNodeSet
2294: oPop 3
2296: oGetLocal 1
2298: oPushResult
2299: oScopeDeclare
2300: oPop 1
2302: oInput 4
2304: oJumpForward 2311
2306: Choice Lookup Table
           0   2246
2309: oJumpForward 2313
2311: oJumpBack 2244
2313: oReturn
2314: oLocalSpace 2
2316: oInputChoice 2365
2318: oGetAddrLocal 1
2320: oPushResult
2321: oSetResult 13
2323: oPushResult
2324: oSetResult 5
2326: oPushResult
2327: LAST_ID
2328: oPushResult
2329: oCall 7349
2331: oPop 3
2333: oAssign
2334: oInput 5
2336: oGetAddrLocal 2
2338: oPushResult
2339: oCall 2603
2341: oPop 1
2343: oGetLocal 1
2345: oPushResult
2346: oSetResult 19
2348: oPushResult
2349: oGetLocal 2
2351: oPushResult
2352: oNodeSet
2353: oPop 3
2355: oGetLocal 1
2357: oPushResult
2358: oScopeDeclare
2359: oPop 1
2361: oInput 4
2363: oJumpForward 2370
2365: Choice Lookup Table
           0   2318
2368: oJumpForward 2372
2370: oJumpBack 2316
2372: oReturn
2373: oLocalSpace 6
2375: oInputChoice 2595
2377: oGetAddrLocal 1
2379: oPushResult
2380: oNodeVecNew
2381: oAssign
2382: oGetAddrLocal 2
2384: oPushResult
2385: oGetParam 1
2387: oPushResult
2388: oSetResult 6
2390: oPushResult
2391: LAST_ID
2392: oPushResult
2393: oCall 7349
2395: oPop 3
2397: oAssign
2398: oGetLocal 1
2400: oPushResult
2401: oGetLocal 2
2403: oPushResult
2404: oNodeVecAppend
2405: oPop 2
2407: oInputChoice 2413
2409: oInput 0
2411: oJumpForward 2418
2413: Choice Lookup Table
          12   2409
2416: oJumpForward 2420
2418: oJumpBack 2382
2420: oInput 11
2422: oGetAddrLocal 3
2424: oPushResult
2425: oCall 2603
2427: oPop 1
2429: oGetAddrLocal 4
2431: oPushResult
2432: oSetResult 0
2434: oAssign
2435: oGetLocal 4
2437: oPushResult
2438: oGetLocal 1
2440: oPushResult
2441: oNodeVecSize
2442: oPop 1
2444: oPushResult
2445: equal
2446: oPop 2
2448: oChoice 2489
2450: oGetAddrLocal 2
2452: oPushResult
2453: oGetLocal 1
2455: oPushResult
2456: oGetLocal 4
2458: oPushResult
2459: oNodeVecElement
2460: oPop 2
2462: oAssign
2463: oGetLocal 2
2465: oPushResult
2466: oSetResult 19
2468: oPushResult
2469: oGetLocal 3
2471: oPushResult
2472: oNodeSet
2473: oPop 3
2475: oGetLocal 2
2477: oPushResult
2478: oScopeDeclareAlloc
2479: oPop 1
2481: oGetAddrLocal 4
2483: oPushResult
2484: inc
2485: oPop 1
2487: oJumpForward 2494
2489: Choice Lookup Table
           0   2450
2492: oJumpForward 2496
2494: oJumpBack 2435
2496: oInputChoice 2582
2498: oGetLocal 1
2500: oPushResult
2501: oNodeVecSize
2502: oPop 1
2504: oChoice 2508
2506: oJumpForward 2513
2508: Choice Lookup Table
           1   2506
2511: oError 22
2513: oGetAddrLocal 5
2515: oPushResult
2516: oCall 1154
2518: oAssign
2519: oGetLocal 5
2521: oPushResult
2522: oCodePush
2523: oPop 1
2525: oGetAddrLocal 6
2527: oPushResult
2528: oSetResult 0
2530: oAssign
2531: oCall 7185
2533: oPushResult
2534: equal_zero
2535: oPop 1
2537: oChoice 2553
2539: oGetGlobal 2
2541: oPushResult
2542: oScopeEnter
2543: oPop 1
2545: oGetAddrLocal 6
2547: oPushResult
2548: oSetResult 1
2550: oAssign
2551: oJumpForward 2556
2553: Choice Lookup Table
           1   2539
2556: oGetLocal 2
2558: oPushResult
2559: oCall 6504
2561: oPop 1
2563: oCall 3143
2565: oCall 7235
2567: oCall 6298
2569: oGetLocal 6
2571: oChoice 2576
2573: oScopeEnd
2574: oJumpForward 2579
2576: Choice Lookup Table
           1   2573
2579: oCodePop
2580: oJumpForward 2585
2582: Choice Lookup Table
           5   2498
2585: oGetLocal 1
2587: oPushResult
2588: oNodeVecDelete
2589: oPop 1
2591: oInput 4
2593: oJumpForward 2600
2595: Choice Lookup Table
           0   2377
2598: oJumpForward 2602
2600: oJumpBack 2375
2602: oReturn
2603: oLocalSpace 12
2605: oInputChoice 3059
2607: oGetAddrLocal 1
2609: oPushResult
2610: oScopeFindRequire
2611: oAssign
2612: oGetLocal 1
2614: oPushResult
2615: oNodeType
2616: oPop 1
2618: oChoice 2635
2620: oGetParam 1
2622: oPushResult
2623: oGetLocal 1
2625: oPushResult
2626: oSetResult 19
2628: oPushResult
2629: oNodeGet
2630: oPop 2
2632: oAssign
2633: oJumpForward 2646
2635: Choice Lookup Table
          13   2620
2638: oError 2
2640: oGetParam 1
2642: oPushResult
2643: oGetGlobal 4
2645: oAssign
2646: oJumpForward 3076
2648: oInput 15
2650: oGetAddrLocal 2
2652: oPushResult
2653: oNodeVecNew
2654: oAssign
2655: oGetAddrLocal 3
2657: oPushResult
2658: oSetResult 28
2660: oPushResult
2661: oNodeNew
2662: oPop 1
2664: oAssign
2665: oGetLocal 3
2667: oPushResult
2668: oSetResult 32
2670: oPushResult
2671: oGetGlobal 4
2673: oPushResult
2674: oNodeSet
2675: oPop 3
2677: oCall 3077
2679: oGetLocal 3
2681: oPushResult
2682: oSetResult 34
2684: oPushResult
2685: oValueTop
2686: oPushResult
2687: oNodeSetInt
2688: oPop 3
2690: oValuePop
2691: oInput 20
2693: oCall 3077
2695: oGetLocal 3
2697: oPushResult
2698: oSetResult 35
2700: oPushResult
2701: oValueTop
2702: oPushResult
2703: oNodeSetInt
2704: oPop 3
2706: oValuePop
2707: oGetLocal 3
2709: oPushResult
2710: oSetResult 15
2712: oPushResult
2713: oSetResult 4
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oGetLocal 3
2721: oPushResult
2722: oTypeAdd
2723: oPop 1
2725: oGetAddrLocal 4
2727: oPushResult
2728: oSetResult 27
2730: oPushResult
2731: oNodeNew
2732: oPop 1
2734: oAssign
2735: oGetLocal 4
2737: oPushResult
2738: oSetResult 33
2740: oPushResult
2741: oGetLocal 3
2743: oPushResult
2744: oNodeSet
2745: oPop 3
2747: oGetLocal 2
2749: oPushResult
2750: oGetLocal 4
2752: oPushResult
2753: oNodeVecAppend
2754: oPop 2
2756: oInputChoice 2764
2758: oJumpForward 2772
2760: oJumpForward 2770
2762: oJumpForward 2770
2764: Choice Lookup Table
          12   2762
          16   2758
2769: oEndChoice
2770: oJumpBack 2655
2772: oInput 38
2774: oGetAddrLocal 5
2776: oPushResult
2777: oCall 2603
2779: oPop 1
2781: oGetAddrLocal 6
2783: oPushResult
2784: oGetLocal 2
2786: oPushResult
2787: oNodeVecSize
2788: oPop 1
2790: oAssign
2791: oGetAddrLocal 6
2793: oPushResult
2794: dec
2795: oPop 1
2797: oGetAddrLocal 7
2799: oPushResult
2800: oGetLocal 2
2802: oPushResult
2803: oGetLocal 6
2805: oPushResult
2806: oNodeVecElement
2807: oPop 2
2809: oAssign
2810: oGetLocal 7
2812: oPushResult
2813: oSetResult 32
2815: oPushResult
2816: oGetLocal 5
2818: oPushResult
2819: oNodeSet
2820: oPop 3
2822: oGetAddrLocal 8
2824: oPushResult
2825: oGetLocal 7
2827: oPushResult
2828: oSetResult 33
2830: oPushResult
2831: oNodeGet
2832: oPop 2
2834: oAssign
2835: oGetAddrLocal 9
2837: oPushResult
2838: oGetLocal 8
2840: oPushResult
2841: oSetResult 35
2843: oPushResult
2844: oNodeGetInt
2845: oPop 2
2847: oPushResult
2848: oGetLocal 8
2850: oPushResult
2851: oSetResult 34
2853: oPushResult
2854: oNodeGetInt
2855: oPop 2
2857: oPushResult
2858: subtract
2859: oPop 2
2861: oAssign
2862: oGetAddrLocal 9
2864: oPushResult
2865: inc
2866: oPop 1
2868: oGetLocal 7
2870: oPushResult
2871: oSetResult 15
2873: oPushResult
2874: oGetLocal 9
2876: oPushResult
2877: oGetLocal 5
2879: oPushResult
2880: oSetResult 15
2882: oPushResult
2883: oNodeGetInt
2884: oPop 2
2886: oPushResult
2887: multiply
2888: oPop 2
2890: oPushResult
2891: oNodeSetInt
2892: oPop 3
2894: oGetLocal 7
2896: oPushResult
2897: oTypeAdd
2898: oPop 1
2900: oGetAddrLocal 5
2902: oPushResult
2903: oGetLocal 7
2905: oAssign
2906: oGetLocal 6
2908: oPushResult
2909: equal_zero
2910: oPop 1
2912: oChoice 2918
2914: oJumpForward 2923
2916: oJumpForward 2921
2918: Choice Lookup Table
           1   2914
2921: oJumpBack 2791
2923: oGetParam 1
2925: oPushResult
2926: oGetLocal 2
2928: oPushResult
2929: oSetResult 0
2931: oPushResult
2932: oNodeVecElement
2933: oPop 2
2935: oAssign
2936: oGetLocal 2
2938: oPushResult
2939: oNodeVecDelete
2940: oPop 1
2942: oJumpForward 3076
2944: oGetAddrLocal 10
2946: oPushResult
2947: oCall 2603
2949: oPop 1
2951: oGetParam 1
2953: oPushResult
2954: oGetLocal 10
2956: oPushResult
2957: oCall 7377
2959: oPop 1
2961: oAssign
2962: oJumpForward 3076
2964: oGetParam 1
2966: oPushResult
2967: oSetResult 29
2969: oPushResult
2970: oNodeNew
2971: oPop 1
2973: oAssign
2974: oSetResult -1
2976: oPushResult
2977: oScopeBegin
2978: oPop 1
2980: oSetResult 17
2982: oPushResult
2983: oCall 2373
2985: oPop 1
2987: oGetAddrLocal 11
2989: oPushResult
2990: oScopeCurrent
2991: oPushResult
2992: oSetResult 15
2994: oPushResult
2995: oNodeGetInt
2996: oPop 2
2998: oAssign
2999: oGetLocal 11
3001: oPushResult
3002: equal_zero
3003: oPop 1
3005: oChoice 3011
3007: oError 19
3009: oJumpForward 3014
3011: Choice Lookup Table
           1   3007
3014: oInput 34
3016: oGetFromParam 1
3018: oPushResult
3019: oSetResult 36
3021: oPushResult
3022: oScopeCurrent
3023: oPushResult
3024: oNodeSet
3025: oPop 3
3027: oGetFromParam 1
3029: oPushResult
3030: oSetResult 15
3032: oPushResult
3033: oGetLocal 11
3035: oPushResult
3036: oNodeSetInt
3037: oPop 3
3039: oScopeEnd
3040: oGetFromParam 1
3042: oPushResult
3043: oTypeAdd
3044: oPop 1
3046: oJumpForward 3076
3048: oInput 38
3050: oGetAddrLocal 12
3052: oPushResult
3053: oCall 2603
3055: oPop 1
3057: oJumpForward 3076
3059: Choice Lookup Table
          37   3048
          36   2964
          17   2944
          35   2648
           0   2607
3070: oCall 3077
3072: oInput 20
3074: oCall 3077
3076: oReturn
3077: oLocalSpace 1
3079: oInputChoice 3134
3081: TOKEN_VALUE
3082: oPushResult
3083: oValuePush
3084: oPop 1
3086: oJumpForward 3142
3088: oGetAddrLocal 1
3090: oPushResult
3091: oScopeFindRequire
3092: oAssign
3093: oGetLocal 1
3095: oPushResult
3096: oNodeType
3097: oPop 1
3099: oChoice 3116
3101: oGetLocal 1
3103: oPushResult
3104: oSetResult 20
3106: oPushResult
3107: oNodeGetInt
3108: oPop 2
3110: oPushResult
3111: oValuePush
3112: oPop 1
3114: oJumpForward 3127
3116: Choice Lookup Table
          12   3101
3119: oError 1
3121: oSetResult 0
3123: oPushResult
3124: oValuePush
3125: oPop 1
3127: oJumpForward 3142
3129: oCall 3077
3131: oValueNegate
3132: oJumpForward 3142
3134: Choice Lookup Table
          24   3129
           0   3088
           1   3081
3141: oEndChoice
3142: oReturn
3143: oLocalSpace 1
3145: oGetAddrLocal 1
3147: oPushResult
3148: oSetResult 0
3150: oAssign
3151: oGetAddrLocal 1
3153: oPushResult
3154: oCall 3304
3156: oPop 1
3158: oGetAddrLocal 1
3160: oPushResult
3161: oCall 3204
3163: oPop 1
3165: oReturn
3166: oLocalSpace 0
3168: oGetParam 1
3170: oPushResult
3171: oCall 3304
3173: oPop 1
3175: oTypeSNodeType
3176: oChoice 3195
3178: oJumpForward 3202
3180: oGetParam 1
3182: oPushResult
3183: oLabelNew
3184: oAssign
3185: oEmit 55
3187: oGetFromParam 1
3189: oPushResult
3190: oEmitLabel
3191: oPop 1
3193: oJumpForward 3202
3195: Choice Lookup Table
          22   3180
          23   3178
3200: oError 8
3202: oTypeSPop
3203: oReturn
3204: oLocalSpace 1
3206: oTypeSNodeType
3207: oChoice 3269
3209: oGetAddrLocal 1
3211: oPushResult
3212: oLabelNew
3213: oAssign
3214: oEmit 15
3216: oSetResult 1
3218: oPushResult
3219: oEmitInt
3220: oPop 1
3222: oEmit 53
3224: oGetLocal 1
3226: oPushResult
3227: oEmitLabel
3228: oPop 1
3230: oEmit 56
3232: oGetFromParam 1
3234: oPushResult
3235: oEmitLabel
3236: oPop 1
3238: oEmit 15
3240: oSetResult 0
3242: oPushResult
3243: oEmitInt
3244: oPop 1
3246: oEmit 56
3248: oGetLocal 1
3250: oPushResult
3251: oEmitLabel
3252: oPop 1
3254: oTypeSPop
3255: oGetGlobal 5
3257: oPushResult
3258: oTypeSPush
3259: oPop 1
3261: oGetParam 1
3263: oPushResult
3264: oSetResult 0
3266: oAssign
3267: oJumpForward 3272
3269: Choice Lookup Table
          23   3209
3272: oReturn
3273: oLocalSpace 0
3275: oTypeSNodeType
3276: oChoice 3300
3278: oGetParam 1
3280: oPushResult
3281: oLabelNew
3282: oAssign
3283: oEmit 55
3285: oGetFromParam 1
3287: oPushResult
3288: oEmitLabel
3289: oPop 1
3291: oTypeSPop
3292: oGetGlobal 6
3294: oPushResult
3295: oTypeSPush
3296: oPop 1
3298: oJumpForward 3303
3300: Choice Lookup Table
          22   3278
3303: oReturn
3304: oLocalSpace 0
3306: oGetParam 1
3308: oPushResult
3309: oCall 3669
3311: oPop 1
3313: oInputChoice 3651
3315: oGetParam 1
3317: oPushResult
3318: oCall 3204
3320: oPop 1
3322: oGetParam 1
3324: oPushResult
3325: oCall 3669
3327: oPop 1
3329: oGetParam 1
3331: oPushResult
3332: oCall 3204
3334: oPop 1
3336: oCall 7235
3338: oTypeSNodeType
3339: oChoice 3353
3341: oEmit 38
3343: oJumpForward 3366
3345: oEmit 44
3347: oJumpForward 3366
3349: oError 16
3351: oJumpForward 3366
3353: Choice Lookup Table
          25   3349
          24   3349
          26   3345
          22   3341
          21   3341
3364: oError 17
3366: oTypeSPop
3367: oGetGlobal 5
3369: oPushResult
3370: oTypeSPush
3371: oPop 1
3373: oJumpForward 3666
3375: oGetParam 1
3377: oPushResult
3378: oCall 3204
3380: oPop 1
3382: oGetParam 1
3384: oPushResult
3385: oCall 3669
3387: oPop 1
3389: oGetParam 1
3391: oPushResult
3392: oCall 3204
3394: oPop 1
3396: oCall 7235
3398: oTypeSNodeType
3399: oChoice 3413
3401: oEmit 39
3403: oJumpForward 3426
3405: oEmit 45
3407: oJumpForward 3426
3409: oError 16
3411: oJumpForward 3426
3413: Choice Lookup Table
          25   3409
          24   3409
          26   3405
          22   3401
          21   3401
3424: oError 17
3426: oTypeSPop
3427: oGetGlobal 5
3429: oPushResult
3430: oTypeSPush
3431: oPop 1
3433: oJumpForward 3666
3435: oGetParam 1
3437: oPushResult
3438: oCall 3204
3440: oPop 1
3442: oGetParam 1
3444: oPushResult
3445: oCall 3669
3447: oPop 1
3449: oGetParam 1
3451: oPushResult
3452: oCall 3204
3454: oPop 1
3456: oCall 7235
3458: oTypeSNodeType
3459: oChoice 3469
3461: oEmit 41
3463: oJumpForward 3480
3465: oError 16
3467: oJumpForward 3480
3469: Choice Lookup Table
          25   3465
          24   3465
          22   3461
          21   3461
3478: oError 17
3480: oTypeSPop
3481: oGetGlobal 5
3483: oPushResult
3484: oTypeSPush
3485: oPop 1
3487: oJumpForward 3666
3489: oGetParam 1
3491: oPushResult
3492: oCall 3204
3494: oPop 1
3496: oGetParam 1
3498: oPushResult
3499: oCall 3669
3501: oPop 1
3503: oGetParam 1
3505: oPushResult
3506: oCall 3204
3508: oPop 1
3510: oCall 7235
3512: oTypeSNodeType
3513: oChoice 3523
3515: oEmit 40
3517: oJumpForward 3534
3519: oError 16
3521: oJumpForward 3534
3523: Choice Lookup Table
          25   3519
          24   3519
          22   3515
          21   3515
3532: oError 17
3534: oTypeSPop
3535: oGetGlobal 5
3537: oPushResult
3538: oTypeSPush
3539: oPop 1
3541: oJumpForward 3666
3543: oGetParam 1
3545: oPushResult
3546: oCall 3204
3548: oPop 1
3550: oGetParam 1
3552: oPushResult
3553: oCall 3669
3555: oPop 1
3557: oGetParam 1
3559: oPushResult
3560: oCall 3204
3562: oPop 1
3564: oCall 7235
3566: oTypeSNodeType
3567: oChoice 3577
3569: oEmit 43
3571: oJumpForward 3588
3573: oError 16
3575: oJumpForward 3588
3577: Choice Lookup Table
          25   3573
          24   3573
          22   3569
          21   3569
3586: oError 17
3588: oTypeSPop
3589: oGetGlobal 5
3591: oPushResult
3592: oTypeSPush
3593: oPop 1
3595: oJumpForward 3666
3597: oGetParam 1
3599: oPushResult
3600: oCall 3204
3602: oPop 1
3604: oGetParam 1
3606: oPushResult
3607: oCall 3669
3609: oPop 1
3611: oGetParam 1
3613: oPushResult
3614: oCall 3204
3616: oPop 1
3618: oCall 7235
3620: oTypeSNodeType
3621: oChoice 3631
3623: oEmit 42
3625: oJumpForward 3642
3627: oError 16
3629: oJumpForward 3642
3631: Choice Lookup Table
          25   3627
          24   3627
          22   3623
          21   3623
3640: oError 17
3642: oTypeSPop
3643: oGetGlobal 5
3645: oPushResult
3646: oTypeSPush
3647: oPop 1
3649: oJumpForward 3666
3651: Choice Lookup Table
          10   3597
           9   3543
           8   3489
           7   3435
           6   3375
           5   3315
3664: oJumpForward 3668
3666: oJumpBack 3313
3668: oReturn
3669: oLocalSpace 1
3671: oGetAddrLocal 1
3673: oPushResult
3674: oSetResult 0
3676: oAssign
3677: oGetParam 1
3679: oPushResult
3680: oCall 3849
3682: oPop 1
3684: oInputChoice 3817
3686: oTypeSNodeType
3687: oChoice 3758
3689: oGetLocal 1
3691: oPushResult
3692: oSetResult 0
3694: oPushResult
3695: equal_label
3696: oPop 2
3698: oChoice 3707
3700: oGetAddrLocal 1
3702: oPushResult
3703: oLabelNew
3704: oAssign
3705: oJumpForward 3710
3707: Choice Lookup Table
           1   3700
3710: oEmit 53
3712: oGetLocal 1
3714: oPushResult
3715: oEmitLabel
3716: oPop 1
3718: oJumpForward 3765
3720: oGetParam 1
3722: oPushResult
3723: oCall 3273
3725: oPop 1
3727: oGetLocal 1
3729: oPushResult
3730: oSetResult 0
3732: oPushResult
3733: equal_label
3734: oPop 2
3736: oChoice 3745
3738: oGetAddrLocal 1
3740: oPushResult
3741: oLabelNew
3742: oAssign
3743: oJumpForward 3748
3745: Choice Lookup Table
           1   3738
3748: oEmit 53
3750: oGetLocal 1
3752: oPushResult
3753: oEmitLabel
3754: oPop 1
3756: oJumpForward 3765
3758: Choice Lookup Table
          22   3720
          23   3689
3763: oError 8
3765: oTypeSPop
3766: oEmit 56
3768: oGetFromParam 1
3770: oPushResult
3771: oEmitLabel
3772: oPop 1
3774: oGetParam 1
3776: oPushResult
3777: oSetResult 0
3779: oAssign
3780: oGetParam 1
3782: oPushResult
3783: oCall 3849
3785: oPop 1
3787: oTypeSNodeType
3788: oChoice 3801
3790: oJumpForward 3808
3792: oGetParam 1
3794: oPushResult
3795: oCall 3273
3797: oPop 1
3799: oJumpForward 3808
3801: Choice Lookup Table
          22   3792
          23   3790
3806: oError 8
3808: oTypeSPop
3809: oGetGlobal 6
3811: oPushResult
3812: oTypeSPush
3813: oPop 1
3815: oJumpForward 3822
3817: Choice Lookup Table
          52   3686
3820: oJumpForward 3824
3822: oJumpBack 3684
3824: oGetLocal 1
3826: oPushResult
3827: oSetResult 0
3829: oPushResult
3830: equal_label
3831: oPop 2
3833: oChoice 3845
3835: oEmit 56
3837: oGetLocal 1
3839: oPushResult
3840: oEmitLabel
3841: oPop 1
3843: oJumpForward 3848
3845: Choice Lookup Table
           0   3835
3848: oReturn
3849: oLocalSpace 2
3851: oGetAddrLocal 1
3853: oPushResult
3854: oSetResult 0
3856: oAssign
3857: oGetParam 1
3859: oPushResult
3860: oCall 3987
3862: oPop 1
3864: oInputChoice 3979
3866: oTypeSNodeType
3867: oChoice 3880
3869: oJumpForward 3887
3871: oGetParam 1
3873: oPushResult
3874: oCall 3273
3876: oPop 1
3878: oJumpForward 3887
3880: Choice Lookup Table
          22   3871
          23   3869
3885: oError 8
3887: oTypeSPop
3888: oGetLocal 1
3890: oPushResult
3891: oSetResult 0
3893: oPushResult
3894: equal_label
3895: oPop 2
3897: oChoice 3926
3899: oGetAddrLocal 1
3901: oPushResult
3902: oLabelNew
3903: oAssign
3904: oEmit 57
3906: oGetFromParam 1
3908: oPushResult
3909: oEmitLabel
3910: oPop 1
3912: oGetLocal 1
3914: oPushResult
3915: oEmitLabel
3916: oPop 1
3918: oGetParam 1
3920: oPushResult
3921: oGetLocal 1
3923: oAssign
3924: oJumpForward 3929
3926: Choice Lookup Table
           1   3899
3929: oGetAddrLocal 2
3931: oPushResult
3932: oSetResult 0
3934: oAssign
3935: oGetAddrLocal 2
3937: oPushResult
3938: oCall 3987
3940: oPop 1
3942: oTypeSNodeType
3943: oChoice 3956
3945: oJumpForward 3963
3947: oGetAddrLocal 2
3949: oPushResult
3950: oCall 3273
3952: oPop 1
3954: oJumpForward 3963
3956: Choice Lookup Table
          22   3947
          23   3945
3961: oError 8
3963: oEmit 57
3965: oGetLocal 2
3967: oPushResult
3968: oEmitLabel
3969: oPop 1
3971: oGetLocal 1
3973: oPushResult
3974: oEmitLabel
3975: oPop 1
3977: oJumpForward 3984
3979: Choice Lookup Table
          51   3866
3982: oJumpForward 3986
3984: oJumpBack 3864
3986: oReturn
3987: oLocalSpace 1
3989: oInputChoice 4043
3991: oGetAddrLocal 1
3993: oPushResult
3994: oSetResult 0
3996: oAssign
3997: oGetAddrLocal 1
3999: oPushResult
4000: oCall 3987
4002: oPop 1
4004: oTypeSNodeType
4005: oChoice 4034
4007: oGetParam 1
4009: oPushResult
4010: oLabelNew
4011: oAssign
4012: oEmit 53
4014: oGetFromParam 1
4016: oPushResult
4017: oEmitLabel
4018: oPop 1
4020: oEmit 56
4022: oGetLocal 1
4024: oPushResult
4025: oEmitLabel
4026: oPop 1
4028: oJumpForward 4041
4030: oEmit 37
4032: oJumpForward 4041
4034: Choice Lookup Table
          22   4030
          23   4007
4039: oError 8
4041: oJumpForward 4053
4043: Choice Lookup Table
          53   3991
4046: oGetParam 1
4048: oPushResult
4049: oCall 4054
4051: oPop 1
4053: oReturn
4054: oLocalSpace 0
4056: oGetParam 1
4058: oPushResult
4059: oCall 4105
4061: oPop 1
4063: oInputChoice 4095
4065: oCall 7261
4067: oGetParam 1
4069: oPushResult
4070: oCall 4105
4072: oPop 1
4074: oCall 7275
4076: oEmit 34
4078: oJumpForward 4102
4080: oCall 7261
4082: oGetParam 1
4084: oPushResult
4085: oCall 4105
4087: oPop 1
4089: oCall 7275
4091: oEmit 35
4093: oJumpForward 4102
4095: Choice Lookup Table
          24   4080
          23   4065
4100: oJumpForward 4104
4102: oJumpBack 4063
4104: oReturn
4105: oLocalSpace 0
4107: oGetParam 1
4109: oPushResult
4110: oCall 4156
4112: oPop 1
4114: oInputChoice 4146
4116: oCall 7261
4118: oGetParam 1
4120: oPushResult
4121: oCall 4156
4123: oPop 1
4125: oCall 7275
4127: oEmit 31
4129: oJumpForward 4153
4131: oCall 7261
4133: oGetParam 1
4135: oPushResult
4136: oCall 4156
4138: oPop 1
4140: oCall 7275
4142: oEmit 32
4144: oJumpForward 4153
4146: Choice Lookup Table
          22   4131
          21   4116
4151: oJumpForward 4155
4153: oJumpBack 4114
4155: oReturn
4156: oLocalSpace 0
4158: oInputChoice 4184
4160: oGetParam 1
4162: oPushResult
4163: oCall 4197
4165: oPop 1
4167: oCall 7275
4169: oJumpForward 4196
4171: oGetParam 1
4173: oPushResult
4174: oCall 4197
4176: oPop 1
4178: oCall 7275
4180: oEmit 36
4182: oJumpForward 4196
4184: Choice Lookup Table
          24   4171
          23   4160
4189: oGetParam 1
4191: oPushResult
4192: oCall 4197
4194: oPop 1
4196: oReturn
4197: oLocalSpace 6
4199: oInputChoice 4385
4201: oEmit 15
4203: TOKEN_VALUE
4204: oPushResult
4205: oEmitInt
4206: oPop 1
4208: oGetGlobal 4
4210: oPushResult
4211: oTypeSPush
4212: oPop 1
4214: oJumpForward 4404
4216: oGetParam 1
4218: oPushResult
4219: oCall 3304
4221: oPop 1
4223: oInput 14
4225: oJumpForward 4404
4227: oGetAddrLocal 1
4229: oPushResult
4230: CURRENT_STRLIT
4231: oPushResult
4232: oStringAllocLit
4233: oPop 1
4235: oAssign
4236: oEmit 16
4238: oGetLocal 1
4240: oPushResult
4241: oEmitInt
4242: oPop 1
4244: oGetGlobal 8
4246: oPushResult
4247: oTypeSPush
4248: oPop 1
4250: oJumpForward 4404
4252: oGetAddrLocal 2
4254: oPushResult
4255: oScopeFindRequire
4256: oAssign
4257: oGetLocal 2
4259: oPushResult
4260: oNodeType
4261: oPop 1
4263: oChoice 4325
4265: oGetLocal 2
4267: oPushResult
4268: oCall 5557
4270: oPop 1
4272: oJumpForward 4344
4274: oGetAddrLocal 3
4276: oPushResult
4277: oGetLocal 2
4279: oPushResult
4280: oSetResult 19
4282: oPushResult
4283: oNodeGet
4284: oPop 2
4286: oAssign
4287: oGetLocal 3
4289: oPushResult
4290: oTypeSPush
4291: oPop 1
4293: oTypeSNodeType
4294: oChoice 4307
4296: oEmit 15
4298: oGetLocal 2
4300: oPushResult
4301: oCall 7512
4303: oPop 1
4305: oJumpForward 4314
4307: Choice Lookup Table
          22   4296
          21   4296
4312: oError 16
4314: oJumpForward 4344
4316: oGetLocal 2
4318: oPushResult
4319: oCall 4405
4321: oPop 1
4323: oJumpForward 4344
4325: Choice Lookup Table
          18   4316
          16   4316
          15   4316
          12   4274
          11   4265
4336: oError 6
4338: oGetGlobal 4
4340: oPushResult
4341: oTypeSPush
4342: oPop 1
4344: oJumpForward 4404
4346: oInput 0
4348: oGetAddrLocal 4
4350: oPushResult
4351: oScopeFindRequire
4352: oAssign
4353: oGetLocal 4
4355: oPushResult
4356: oCall 6504
4358: oPop 1
4360: oGetAddrLocal 5
4362: oPushResult
4363: oTypeSTop
4364: oAssign
4365: oTypeSPop
4366: oGetAddrLocal 6
4368: oPushResult
4369: oGetLocal 5
4371: oPushResult
4372: oCall 7377
4374: oPop 1
4376: oAssign
4377: oGetLocal 6
4379: oPushResult
4380: oTypeSPush
4381: oPop 1
4383: oJumpForward 4404
4385: Choice Lookup Table
          18   4346
           0   4252
           2   4227
          13   4216
           1   4201
4396: oError 6
4398: oGetGlobal 4
4400: oPushResult
4401: oTypeSPush
4402: oPop 1
4404: oReturn
4405: oLocalSpace 2
4407: oGetAddrLocal 1
4409: oPushResult
4410: oGetParam 1
4412: oPushResult
4413: oSetResult 19
4415: oPushResult
4416: oNodeGet
4417: oPop 2
4419: oAssign
4420: oGetAddrLocal 2
4422: oPushResult
4423: oGetParam 1
4425: oPushResult
4426: oCall 7217
4428: oPop 1
4430: oAssign
4431: oGetLocal 1
4433: oPushResult
4434: oTypeSPush
4435: oPop 1
4437: oTypeSNodeType
4438: oChoice 4955
4440: oGetParam 1
4442: oPushResult
4443: oNodeType
4444: oPop 1
4446: oChoice 4592
4448: oEmit 0
4450: oGetParam 1
4452: oPushResult
4453: oCall 7512
4455: oPop 1
4457: oJumpForward 4600
4459: oGetLocal 2
4461: oPushResult
4462: equal_zero
4463: oPop 1
4465: oChoice 4478
4467: oEmit 3
4469: oGetParam 1
4471: oPushResult
4472: oCall 7512
4474: oPop 1
4476: oJumpForward 4496
4478: Choice Lookup Table
           1   4467
4481: oEmit 9
4483: oGetLocal 2
4485: oPushResult
4486: oEmitInt
4487: oPop 1
4489: oGetParam 1
4491: oPushResult
4492: oCall 7512
4494: oPop 1
4496: oJumpForward 4600
4498: oGetParam 1
4500: oPushResult
4501: oSetResult 30
4503: oPushResult
4504: oNodeGetBoolean
4505: oPop 2
4507: oChoice 4550
4509: oGetLocal 2
4511: oPushResult
4512: equal_zero
4513: oPop 1
4515: oChoice 4528
4517: oEmit 8
4519: oGetParam 1
4521: oPushResult
4522: oCall 7512
4524: oPop 1
4526: oJumpForward 4546
4528: Choice Lookup Table
           1   4517
4531: oEmit 14
4533: oGetLocal 2
4535: oPushResult
4536: oEmitInt
4537: oPop 1
4539: oGetParam 1
4541: oPushResult
4542: oCall 7512
4544: oPop 1
4546: oEmit 22
4548: oJumpForward 4590
4550: Choice Lookup Table
           1   4509
4553: oGetLocal 2
4555: oPushResult
4556: equal_zero
4557: oPop 1
4559: oChoice 4572
4561: oEmit 6
4563: oGetParam 1
4565: oPushResult
4566: oCall 7512
4568: oPop 1
4570: oJumpForward 4590
4572: Choice Lookup Table
           1   4561
4575: oEmit 12
4577: oGetLocal 2
4579: oPushResult
4580: oEmitInt
4581: oPop 1
4583: oGetParam 1
4585: oPushResult
4586: oCall 7512
4588: oPop 1
4590: oJumpForward 4600
4592: Choice Lookup Table
          18   4498
          16   4459
          15   4448
4599: oEndChoice
4600: oJumpForward 5130
4602: oGetParam 1
4604: oPushResult
4605: oNodeType
4606: oPop 1
4608: oChoice 4754
4610: oEmit 1
4612: oGetParam 1
4614: oPushResult
4615: oCall 7512
4617: oPop 1
4619: oJumpForward 4762
4621: oGetLocal 2
4623: oPushResult
4624: equal_zero
4625: oPop 1
4627: oChoice 4640
4629: oEmit 4
4631: oGetParam 1
4633: oPushResult
4634: oCall 7512
4636: oPop 1
4638: oJumpForward 4658
4640: Choice Lookup Table
           1   4629
4643: oEmit 10
4645: oGetLocal 2
4647: oPushResult
4648: oEmitInt
4649: oPop 1
4651: oGetParam 1
4653: oPushResult
4654: oCall 7512
4656: oPop 1
4658: oJumpForward 4762
4660: oGetParam 1
4662: oPushResult
4663: oSetResult 30
4665: oPushResult
4666: oNodeGetBoolean
4667: oPop 2
4669: oChoice 4712
4671: oGetLocal 2
4673: oPushResult
4674: equal_zero
4675: oPop 1
4677: oChoice 4690
4679: oEmit 8
4681: oGetParam 1
4683: oPushResult
4684: oCall 7512
4686: oPop 1
4688: oJumpForward 4708
4690: Choice Lookup Table
           1   4679
4693: oEmit 14
4695: oGetLocal 2
4697: oPushResult
4698: oEmitInt
4699: oPop 1
4701: oGetParam 1
4703: oPushResult
4704: oCall 7512
4706: oPop 1
4708: oEmit 23
4710: oJumpForward 4752
4712: Choice Lookup Table
           1   4671
4715: oGetLocal 2
4717: oPushResult
4718: equal_zero
4719: oPop 1
4721: oChoice 4734
4723: oEmit 7
4725: oGetParam 1
4727: oPushResult
4728: oCall 7512
4730: oPop 1
4732: oJumpForward 4752
4734: Choice Lookup Table
           1   4723
4737: oEmit 13
4739: oGetLocal 2
4741: oPushResult
4742: oEmitInt
4743: oPop 1
4745: oGetParam 1
4747: oPushResult
4748: oCall 7512
4750: oPop 1
4752: oJumpForward 4762
4754: Choice Lookup Table
          18   4660
          16   4621
          15   4610
4761: oEndChoice
4762: oJumpForward 5130
4764: oError 16
4766: oJumpForward 5130
4768: oGetParam 1
4770: oPushResult
4771: oNodeType
4772: oPop 1
4774: oChoice 4920
4776: oEmit 2
4778: oGetParam 1
4780: oPushResult
4781: oCall 7512
4783: oPop 1
4785: oJumpForward 4928
4787: oGetLocal 2
4789: oPushResult
4790: equal_zero
4791: oPop 1
4793: oChoice 4806
4795: oEmit 5
4797: oGetParam 1
4799: oPushResult
4800: oCall 7512
4802: oPop 1
4804: oJumpForward 4824
4806: Choice Lookup Table
           1   4795
4809: oEmit 11
4811: oGetLocal 2
4813: oPushResult
4814: oEmitInt
4815: oPop 1
4817: oGetParam 1
4819: oPushResult
4820: oCall 7512
4822: oPop 1
4824: oJumpForward 4928
4826: oGetParam 1
4828: oPushResult
4829: oSetResult 30
4831: oPushResult
4832: oNodeGetBoolean
4833: oPop 2
4835: oChoice 4878
4837: oGetLocal 2
4839: oPushResult
4840: equal_zero
4841: oPop 1
4843: oChoice 4856
4845: oEmit 8
4847: oGetParam 1
4849: oPushResult
4850: oCall 7512
4852: oPop 1
4854: oJumpForward 4874
4856: Choice Lookup Table
           1   4845
4859: oEmit 14
4861: oGetLocal 2
4863: oPushResult
4864: oEmitInt
4865: oPop 1
4867: oGetParam 1
4869: oPushResult
4870: oCall 7512
4872: oPop 1
4874: oEmit 24
4876: oJumpForward 4918
4878: Choice Lookup Table
           1   4837
4881: oGetLocal 2
4883: oPushResult
4884: equal_zero
4885: oPop 1
4887: oChoice 4900
4889: oEmit 8
4891: oGetParam 1
4893: oPushResult
4894: oCall 7512
4896: oPop 1
4898: oJumpForward 4918
4900: Choice Lookup Table
           1   4889
4903: oEmit 14
4905: oGetLocal 2
4907: oPushResult
4908: oEmitInt
4909: oPop 1
4911: oGetParam 1
4913: oPushResult
4914: oCall 7512
4916: oPop 1
4918: oJumpForward 4928
4920: Choice Lookup Table
          18   4826
          16   4787
          15   4776
4927: oEndChoice
4928: oInputChoice 4950
4930: oTypeSPop
4931: oGetLocal 1
4933: oPushResult
4934: oSetResult 32
4936: oPushResult
4937: oNodeGet
4938: oPop 2
4940: oPushResult
4941: oTypeSPush
4942: oPop 1
4944: oCall 5166
4946: oCall 5131
4948: oJumpForward 4953
4950: Choice Lookup Table
          17   4930
4953: oJumpForward 5130
4955: Choice Lookup Table
          26   4768
          20   4764
          25   4764
          24   4764
          22   4602
          21   4440
4968: oGetParam 1
4970: oPushResult
4971: oNodeType
4972: oPop 1
4974: oChoice 5118
4976: oEmit 16
4978: oGetParam 1
4980: oPushResult
4981: oCall 7512
4983: oPop 1
4985: oJumpForward 5126
4987: oGetLocal 2
4989: oPushResult
4990: equal_zero
4991: oPop 1
4993: oChoice 5006
4995: oEmit 17
4997: oGetParam 1
4999: oPushResult
5000: oCall 7512
5002: oPop 1
5004: oJumpForward 5024
5006: Choice Lookup Table
           1   4995
5009: oEmit 20
5011: oGetLocal 2
5013: oPushResult
5014: oEmitInt
5015: oPop 1
5017: oGetParam 1
5019: oPushResult
5020: oCall 7512
5022: oPop 1
5024: oJumpForward 5126
5026: oGetParam 1
5028: oPushResult
5029: oSetResult 30
5031: oPushResult
5032: oNodeGetBoolean
5033: oPop 2
5035: oChoice 5076
5037: oGetLocal 2
5039: oPushResult
5040: equal_zero
5041: oPop 1
5043: oChoice 5056
5045: oEmit 8
5047: oGetParam 1
5049: oPushResult
5050: oCall 7512
5052: oPop 1
5054: oJumpForward 5074
5056: Choice Lookup Table
           1   5045
5059: oEmit 14
5061: oGetLocal 2
5063: oPushResult
5064: oEmitInt
5065: oPop 1
5067: oGetParam 1
5069: oPushResult
5070: oCall 7512
5072: oPop 1
5074: oJumpForward 5116
5076: Choice Lookup Table
           1   5037
5079: oGetLocal 2
5081: oPushResult
5082: equal_zero
5083: oPop 1
5085: oChoice 5098
5087: oEmit 18
5089: oGetParam 1
5091: oPushResult
5092: oCall 7512
5094: oPop 1
5096: oJumpForward 5116
5098: Choice Lookup Table
           1   5087
5101: oEmit 21
5103: oGetLocal 2
5105: oPushResult
5106: oEmitInt
5107: oPop 1
5109: oGetParam 1
5111: oPushResult
5112: oCall 7512
5114: oPop 1
5116: oJumpForward 5126
5118: Choice Lookup Table
          18   5026
          16   4987
          15   4976
5125: oEndChoice
5126: oCall 5166
5128: oCall 5131
5130: oReturn
5131: oLocalSpace 0
5133: oTypeSNodeType
5134: oChoice 5152
5136: oEmit 22
5138: oJumpForward 5165
5140: oEmit 23
5142: oJumpForward 5165
5144: oError 16
5146: oJumpForward 5165
5148: oEmit 24
5150: oJumpForward 5165
5152: Choice Lookup Table
          26   5148
          20   5144
          25   5144
          24   5144
          22   5140
          21   5136
5165: oReturn
5166: oLocalSpace 0
5168: oInputChoice 5182
5170: oCall 5194
5172: oJumpForward 5191
5174: oCall 5337
5176: oJumpForward 5191
5178: oCall 5435
5180: oJumpForward 5191
5182: Choice Lookup Table
          17   5178
          19   5174
          15   5170
5189: oJumpForward 5193
5191: oJumpBack 5168
5193: oReturn
5194: oLocalSpace 3
5196: oTypeSNodeType
5197: oChoice 5201
5199: oJumpForward 5206
5201: Choice Lookup Table
          27   5199
5204: oError 10
5206: oTypeSNodeType
5207: oChoice 5211
5209: oJumpForward 5216
5211: Choice Lookup Table
          27   5209
5214: oError 13
5216: oGetAddrLocal 1
5218: oPushResult
5219: oTypeSTop
5220: oPushResult
5221: oSetResult 33
5223: oPushResult
5224: oNodeGet
5225: oPop 2
5227: oPushResult
5228: oCall 7461
5230: oPop 1
5232: oAssign
5233: oGetAddrLocal 2
5235: oPushResult
5236: oTypeSTop
5237: oPushResult
5238: oSetResult 32
5240: oPushResult
5241: oNodeGet
5242: oPop 2
5244: oAssign
5245: oTypeSPop
5246: oGetLocal 2
5248: oPushResult
5249: oTypeSPush
5250: oPop 1
5252: oCall 3143
5254: oCall 7261
5256: oGetLocal 1
5258: oPushResult
5259: equal_zero
5260: oPop 1
5262: oChoice 5276
5264: oEmit 15
5266: oGetLocal 1
5268: oPushResult
5269: oEmitInt
5270: oPop 1
5272: oEmit 35
5274: oJumpForward 5279
5276: Choice Lookup Table
           0   5264
5279: oGetAddrLocal 3
5281: oPushResult
5282: oGetLocal 2
5284: oPushResult
5285: oSetResult 15
5287: oPushResult
5288: oNodeGetInt
5289: oPop 2
5291: oAssign
5292: oGetLocal 3
5294: oPushResult
5295: oSetResult 1
5297: oPushResult
5298: equal
5299: oPop 2
5301: oChoice 5315
5303: oEmit 15
5305: oGetLocal 3
5307: oPushResult
5308: oEmitInt
5309: oPop 1
5311: oEmit 31
5313: oJumpForward 5318
5315: Choice Lookup Table
           0   5303
5318: oEmit 33
5320: oInputChoice 5328
5322: oJumpForward 5336
5324: oJumpForward 5334
5326: oJumpForward 5334
5328: Choice Lookup Table
          12   5326
          16   5322
5333: oEndChoice
5334: oJumpBack 5206
5336: oReturn
5337: oLocalSpace 2
5339: oTypeSNodeType
5340: oChoice 5344
5342: oJumpForward 5349
5344: Choice Lookup Table
          29   5342
5347: oError 11
5349: oTypeSTop
5350: oPushResult
5351: oSetResult 36
5353: oPushResult
5354: oNodeGet
5355: oPop 2
5357: oPushResult
5358: oScopeEnter
5359: oPop 1
5361: oInput 0
5363: oGetAddrLocal 1
5365: oPushResult
5366: oScopeFindRequire
5367: oAssign
5368: oGetLocal 1
5370: oPushResult
5371: oNodeType
5372: oPop 1
5374: oChoice 5378
5376: oJumpForward 5383
5378: Choice Lookup Table
          17   5376
5381: oError 12
5383: oScopeEnd
5384: oGetAddrLocal 2
5386: oPushResult
5387: oGetLocal 1
5389: oPushResult
5390: oSetResult 20
5392: oPushResult
5393: oNodeGetInt
5394: oPop 2
5396: oAssign
5397: oGetLocal 2
5399: oPushResult
5400: equal_zero
5401: oPop 1
5403: oChoice 5417
5405: oEmit 15
5407: oGetLocal 2
5409: oPushResult
5410: oEmitInt
5411: oPop 1
5413: oEmit 33
5415: oJumpForward 5420
5417: Choice Lookup Table
           0   5405
5420: oTypeSPop
5421: oGetLocal 1
5423: oPushResult
5424: oSetResult 19
5426: oPushResult
5427: oNodeGet
5428: oPop 2
5430: oPushResult
5431: oTypeSPush
5432: oPop 1
5434: oReturn
5435: oLocalSpace 1
5437: oTypeSNodeType
5438: oChoice 5442
5440: oJumpForward 5447
5442: Choice Lookup Table
          26   5440
5445: oError 9
5447: oEmit 24
5449: oGetAddrLocal 1
5451: oPushResult
5452: oTypeSTop
5453: oAssign
5454: oTypeSPop
5455: oGetLocal 1
5457: oPushResult
5458: oSetResult 32
5460: oPushResult
5461: oNodeGet
5462: oPop 2
5464: oPushResult
5465: oTypeSPush
5466: oPop 1
5468: oReturn
5469: oLocalSpace 0
5471: oCall 7235
5473: oReturn
5474: oLocalSpace 2
5476: oGetAddrLocal 2
5478: oPushResult
5479: oGetParam 1
5481: oPushResult
5482: oSetResult 24
5484: oPushResult
5485: oNodeGetString
5486: oPop 2
5488: oAssign
5489: oGetLocal 2
5491: oPushResult
5492: oSetResult 0
5494: oPushResult
5495: equal_string
5496: oPop 2
5498: oChoice 5535
5500: oGetAddrLocal 1
5502: oPushResult
5503: oGetParam 1
5505: oPushResult
5506: oSetResult 3
5508: oPushResult
5509: oNodeGetInt
5510: oPop 2
5512: oPushResult
5513: ID_STRING
5514: oPop 1
5516: oPushResult
5517: oStringAllocLit
5518: oPop 1
5520: oAssign
5521: oJumpForward 5541
5523: oGetAddrLocal 1
5525: oPushResult
5526: oGetLocal 2
5528: oPushResult
5529: oStringAllocLit
5530: oPop 1
5532: oAssign
5533: oJumpForward 5541
5535: Choice Lookup Table
           0   5523
           1   5500
5540: oEndChoice
5541: oEmit 58
5543: oGetParam 1
5545: oPushResult
5546: oCall 7512
5548: oPop 1
5550: oGetLocal 1
5552: oPushResult
5553: oEmitInt
5554: oPop 1
5556: oReturn
5557: oLocalSpace 10
5559: oGetParam 1
5561: oPushResult
5562: oSetResult 23
5564: oPushResult
5565: oNodeGetBoolean
5566: oPop 2
5568: oChoice 5595
5570: oGetParam 1
5572: oPushResult
5573: oSetResult 26
5575: oPushResult
5576: oNodeGetBoolean
5577: oPop 2
5579: oChoice 5590
5581: oGetParam 1
5583: oPushResult
5584: oCall 5474
5586: oPop 1
5588: oJumpForward 5593
5590: Choice Lookup Table
           0   5581
5593: oJumpForward 5598
5595: Choice Lookup Table
           1   5570
5598: oGetParam 1
5600: oPushResult
5601: oSetResult 26
5603: oPushResult
5604: oSetResult 1
5606: oPushResult
5607: oNodeSetBoolean
5608: oPop 3
5610: oGetAddrLocal 1
5612: oPushResult
5613: oGetParam 1
5615: oPushResult
5616: oSetResult 25
5618: oPushResult
5619: oNodeGetBoolean
5620: oPop 2
5622: oAssign
5623: oGetAddrLocal 4
5625: oPushResult
5626: oGetParam 1
5628: oPushResult
5629: oNodeType
5630: oPop 1
5632: oPushResult
5633: oSetResult 11
5635: oPushResult
5636: equal_node_type
5637: oPop 2
5639: oAssign
5640: oGetLocal 4
5642: oChoice 5669
5644: oGetAddrLocal 2
5646: oPushResult
5647: oGetParam 1
5649: oPushResult
5650: oSetResult 19
5652: oPushResult
5653: oNodeGet
5654: oPop 2
5656: oAssign
5657: oGetAddrLocal 3
5659: oPushResult
5660: oGetLocal 2
5662: oPushResult
5663: oScopeAllocType
5664: oPop 1
5666: oAssign
5667: oJumpForward 5672
5669: Choice Lookup Table
           1   5644
5672: oGetAddrLocal 5
5674: oPushResult
5675: oGetParam 1
5677: oPushResult
5678: oSetResult 21
5680: oPushResult
5681: oNodeGet
5682: oPop 2
5684: oAssign
5685: oGetAddrLocal 6
5687: oPushResult
5688: oGetLocal 5
5690: oPushResult
5691: oSetResult 15
5693: oPushResult
5694: oNodeGetInt
5695: oPop 2
5697: oAssign
5698: oGetLocal 1
5700: oChoice 5722
5702: oEmit 47
5704: oGetLocal 6
5706: oPushResult
5707: oEmitInt
5708: oPop 1
5710: oJumpForward 5728
5712: oEmit 46
5714: oGetLocal 6
5716: oPushResult
5717: oEmitInt
5718: oPop 1
5720: oJumpForward 5728
5722: Choice Lookup Table
           0   5712
           1   5702
5727: oEndChoice
5728: oGetParam 1
5730: oPushResult
5731: oCall 7197
5733: oPop 1
5735: oPushResult
5736: oSetResult 0
5738: oPushResult
5739: greater
5740: oPop 2
5742: oChoice 5775
5744: oEmit 19
5746: oSetResult 0
5748: oPushResult
5749: oEmitInt
5750: oPop 1
5752: oEmit 20
5754: oGetParam 1
5756: oPushResult
5757: oCall 7217
5759: oPop 1
5761: oPushResult
5762: oEmitInt
5763: oPop 1
5765: oSetResult 0
5767: oPushResult
5768: oEmitInt
5769: oPop 1
5771: oEmit 27
5773: oJumpForward 5778
5775: Choice Lookup Table
           1   5744
5778: oGetAddrLocal 7
5780: oPushResult
5781: oGetLocal 5
5783: oPushResult
5784: oSetResult 14
5786: oPushResult
5787: oNodeGetIter
5788: oPop 2
5790: oAssign
5791: oGetAddrLocal 8
5793: oPushResult
5794: oGetLocal 7
5796: oPushResult
5797: oNodeIterValue
5798: oPop 1
5800: oAssign
5801: oInputChoice 5980
5803: oGetLocal 8
5805: oPushResult
5806: oNodeNull
5807: oPop 1
5809: oChoice 5815
5811: oJumpForward 5976
5813: oJumpForward 5818
5815: Choice Lookup Table
           1   5811
5818: oGetAddrLocal 9
5820: oPushResult
5821: oGetLocal 8
5823: oPushResult
5824: oSetResult 20
5826: oPushResult
5827: oNodeGetInt
5828: oPop 2
5830: oAssign
5831: oEmit 19
5833: oGetLocal 9
5835: oPushResult
5836: oEmitInt
5837: oPop 1
5839: oGetLocal 8
5841: oPushResult
5842: oSetResult 19
5844: oPushResult
5845: oNodeGet
5846: oPop 2
5848: oPushResult
5849: oTypeSPush
5850: oPop 1
5852: oGetLocal 8
5854: oPushResult
5855: oSetResult 30
5857: oPushResult
5858: oNodeGetBoolean
5859: oPop 2
5861: oChoice 5929
5863: oCall 6468
5865: oCall 7235
5867: oEmit 27
5869: oJumpForward 5935
5871: oCall 3143
5873: oCall 5469
5875: oTypeSNodeType
5876: oChoice 5894
5878: oEmit 25
5880: oJumpForward 5927
5882: oEmit 26
5884: oJumpForward 5927
5886: oError 16
5888: oJumpForward 5927
5890: oEmit 27
5892: oJumpForward 5927
5894: Choice Lookup Table
          26   5890
          20   5886
          25   5886
          24   5886
          22   5882
          21   5878
5907: oGetAddrLocal 10
5909: oPushResult
5910: oTypeSTop
5911: oPushResult
5912: oSetResult 15
5914: oPushResult
5915: oNodeGetInt
5916: oPop 2
5918: oAssign
5919: oEmit 28
5921: oGetLocal 10
5923: oPushResult
5924: oEmitInt
5925: oPop 1
5927: oJumpForward 5935
5929: Choice Lookup Table
           0   5871
           1   5863
5934: oEndChoice
5935: oTypeSPop
5936: oGetAddrLocal 7
5938: oPushResult
5939: oNodeIterNext
5940: oPop 1
5942: oGetAddrLocal 8
5944: oPushResult
5945: oGetLocal 7
5947: oPushResult
5948: oNodeIterValue
5949: oPop 1
5951: oAssign
5952: oGetLocal 8
5954: oPushResult
5955: oNodeNull
5956: oPop 1
5958: oChoice 5966
5960: oJumpForward 5976
5962: oJumpForward 5972
5964: oJumpForward 5972
5966: Choice Lookup Table
           0   5964
           1   5960
5971: oEndChoice
5972: oInput 12
5974: oJumpBack 5803
5976: oInput 14
5978: oJumpForward 5983
5980: Choice Lookup Table
          13   5803
5983: oGetLocal 8
5985: oPushResult
5986: oNodeNull
5987: oPop 1
5989: oChoice 5995
5991: oError 15
5993: oJumpForward 5998
5995: Choice Lookup Table
           0   5991
5998: oGetLocal 4
6000: oChoice 6029
6002: oEmit 19
6004: oGetParam 1
6006: oPushResult
6007: oSetResult 29
6009: oPushResult
6010: oNodeGetInt
6011: oPop 2
6013: oPushResult
6014: oEmitInt
6015: oPop 1
6017: oEmit 17
6019: oGetLocal 3
6021: oPushResult
6022: oEmitInt
6023: oPop 1
6025: oEmit 27
6027: oJumpForward 6032
6029: Choice Lookup Table
           1   6002
6032: oGetLocal 1
6034: oChoice 6058
6036: oEmit 50
6038: oGetParam 1
6040: oPushResult
6041: oCall 7512
6043: oPop 1
6045: oJumpForward 6064
6047: oEmit 49
6049: oGetParam 1
6051: oPushResult
6052: oCall 7512
6054: oPop 1
6056: oJumpForward 6064
6058: Choice Lookup Table
           0   6047
           1   6036
6063: oEndChoice
6064: oGetLocal 4
6066: oChoice 6134
6068: oGetLocal 2
6070: oPushResult
6071: oTypeSPush
6072: oPop 1
6074: oTypeSNodeType
6075: oChoice 6111
6077: oEmit 3
6079: oGetLocal 3
6081: oPushResult
6082: oEmitInt
6083: oPop 1
6085: oJumpForward 6132
6087: oEmit 4
6089: oGetLocal 3
6091: oPushResult
6092: oEmitInt
6093: oPop 1
6095: oJumpForward 6132
6097: oError 16
6099: oJumpForward 6132
6101: oEmit 5
6103: oGetLocal 3
6105: oPushResult
6106: oEmitInt
6107: oPop 1
6109: oJumpForward 6132
6111: Choice Lookup Table
          26   6101
          20   6097
          25   6097
          24   6097
          22   6087
          21   6077
6124: oEmit 17
6126: oGetLocal 3
6128: oPushResult
6129: oEmitInt
6130: oPop 1
6132: oJumpForward 6137
6134: Choice Lookup Table
           1   6068
6137: oEmit 48
6139: oGetLocal 6
6141: oPushResult
6142: oEmitInt
6143: oPop 1
6145: oReturn
6146: oLocalSpace 0
6148: oInputChoice 6198
6150: oCall 7105
6152: oJumpForward 6223
6154: oCall 7112
6156: oJumpForward 6223
6158: oCall 7179
6160: oJumpForward 6223
6162: oCall 7182
6164: oJumpForward 6223
6166: oCall 6645
6168: oJumpForward 6223
6170: oCall 6965
6172: oJumpForward 6223
6174: oCall 6711
6176: oJumpForward 6223
6178: oCall 6885
6180: oJumpForward 6223
6182: oCall 7050
6184: oJumpForward 6223
6186: oCall 7018
6188: oJumpForward 6223
6190: oCall 7082
6192: oJumpForward 6223
6194: oCall 6224
6196: oJumpForward 6223
6198: Choice Lookup Table
           0   6194
          33   6190
          49   6186
          50   6182
          47   6178
          42   6174
          46   6170
          39   6166
          63   6162
          62   6158
          61   6154
          60   6150
6223: oReturn
6224: oLocalSpace 1
6226: oGetAddrLocal 1
6228: oPushResult
6229: oScopeFindRequire
6230: oAssign
6231: oGetLocal 1
6233: oPushResult
6234: oNodeType
6235: oPop 1
6237: oChoice 6266
6239: oGetLocal 1
6241: oPushResult
6242: oCall 5557
6244: oPop 1
6246: oJumpForward 6279
6248: oGetLocal 1
6250: oPushResult
6251: oCall 6280
6253: oPop 1
6255: oJumpForward 6279
6257: oGetLocal 1
6259: oPushResult
6260: oCall 6354
6262: oPop 1
6264: oJumpForward 6279
6266: Choice Lookup Table
          11   6257
          18   6248
          16   6248
          15   6248
          10   6239
6277: oError 0
6279: oReturn
6280: oLocalSpace 0
6282: oGetParam 1
6284: oPushResult
6285: oCall 6504
6287: oPop 1
6289: oInput 3
6291: oCall 3143
6293: oCall 7235
6295: oCall 6298
6297: oReturn
6298: oLocalSpace 1
6300: oTypeSNodeType
6301: oChoice 6319
6303: oEmit 25
6305: oJumpForward 6352
6307: oEmit 26
6309: oJumpForward 6352
6311: oError 16
6313: oJumpForward 6352
6315: oEmit 27
6317: oJumpForward 6352
6319: Choice Lookup Table
          26   6315
          20   6311
          25   6311
          24   6311
          22   6307
          21   6303
6332: oGetAddrLocal 1
6334: oPushResult
6335: oTypeSTop
6336: oPushResult
6337: oSetResult 15
6339: oPushResult
6340: oNodeGetInt
6341: oPop 2
6343: oAssign
6344: oEmit 28
6346: oGetLocal 1
6348: oPushResult
6349: oEmitInt
6350: oPop 1
6352: oTypeSPop
6353: oReturn
6354: oLocalSpace 1
6356: oGetParam 1
6358: oPushResult
6359: oSetResult 5
6361: oPushResult
6362: oNodeGet
6363: oPop 2
6365: oPushResult
6366: oScopeCurrent
6367: oPushResult
6368: oNodeEqual
6369: oPop 2
6371: oChoice 6377
6373: oError 20
6375: oJumpForward 6380
6377: Choice Lookup Table
           0   6373
6380: oEmit 8
6382: oGetParam 1
6384: oPushResult
6385: oSetResult 29
6387: oPushResult
6388: oNodeGetInt
6389: oPop 2
6391: oPushResult
6392: oEmitInt
6393: oPop 1
6395: oGetParam 1
6397: oPushResult
6398: oSetResult 19
6400: oPushResult
6401: oNodeGet
6402: oPop 2
6404: oPushResult
6405: oTypeSPush
6406: oPop 1
6408: oInput 3
6410: oCall 3143
6412: oCall 7235
6414: oTypeSNodeType
6415: oChoice 6433
6417: oEmit 25
6419: oJumpForward 6466
6421: oEmit 26
6423: oJumpForward 6466
6425: oError 16
6427: oJumpForward 6466
6429: oEmit 27
6431: oJumpForward 6466
6433: Choice Lookup Table
          26   6429
          20   6425
          25   6425
          24   6425
          22   6421
          21   6417
6446: oGetAddrLocal 1
6448: oPushResult
6449: oTypeSTop
6450: oPushResult
6451: oSetResult 15
6453: oPushResult
6454: oNodeGetInt
6455: oPop 2
6457: oAssign
6458: oEmit 28
6460: oGetLocal 1
6462: oPushResult
6463: oEmitInt
6464: oPop 1
6466: oTypeSPop
6467: oReturn
6468: oLocalSpace 1
6470: oInput 0
6472: oGetAddrLocal 1
6474: oPushResult
6475: oScopeFindRequire
6476: oAssign
6477: oGetLocal 1
6479: oPushResult
6480: oNodeType
6481: oPop 1
6483: oChoice 6487
6485: oJumpForward 6496
6487: Choice Lookup Table
          18   6485
          16   6485
          15   6485
6494: oError 4
6496: oGetLocal 1
6498: oPushResult
6499: oCall 6504
6501: oPop 1
6503: oReturn
6504: oLocalSpace 0
6506: oGetParam 1
6508: oPushResult
6509: oNodeType
6510: oPop 1
6512: oChoice 6572
6514: oEmit 16
6516: oGetParam 1
6518: oPushResult
6519: oCall 7512
6521: oPop 1
6523: oJumpForward 6581
6525: oEmit 17
6527: oGetParam 1
6529: oPushResult
6530: oCall 7512
6532: oPop 1
6534: oJumpForward 6581
6536: oGetParam 1
6538: oPushResult
6539: oSetResult 30
6541: oPushResult
6542: oNodeGetBoolean
6543: oPop 2
6545: oChoice 6558
6547: oEmit 8
6549: oGetParam 1
6551: oPushResult
6552: oCall 7512
6554: oPop 1
6556: oJumpForward 6570
6558: Choice Lookup Table
           1   6547
6561: oEmit 18
6563: oGetParam 1
6565: oPushResult
6566: oCall 7512
6568: oPop 1
6570: oJumpForward 6581
6572: Choice Lookup Table
          18   6536
          16   6525
          15   6514
6579: oError 4
6581: oGetParam 1
6583: oPushResult
6584: oSetResult 19
6586: oPushResult
6587: oNodeGet
6588: oPop 2
6590: oPushResult
6591: oTypeSPush
6592: oPop 1
6594: oCall 5166
6596: oReturn
6597: oLocalSpace 0
6599: oGetParam 1
6601: oPushResult
6602: oCall 6504
6604: oPop 1
6606: oCall 7261
6608: oGetParam 1
6610: oPushResult
6611: oCall 4405
6613: oPop 1
6615: oTypeSPop
6616: oEmit 29
6618: oEmit 25
6620: oReturn
6621: oLocalSpace 0
6623: oGetParam 1
6625: oPushResult
6626: oCall 6504
6628: oPop 1
6630: oCall 7261
6632: oGetParam 1
6634: oPushResult
6635: oCall 4405
6637: oPop 1
6639: oTypeSPop
6640: oEmit 30
6642: oEmit 25
6644: oReturn
6645: oLocalSpace 2
6647: oGetAddrLocal 1
6649: oPushResult
6650: oSetResult 0
6652: oAssign
6653: oGetAddrLocal 1
6655: oPushResult
6656: oCall 3166
6658: oPop 1
6660: oInput 40
6662: oCall 6146
6664: oInputChoice 6699
6666: oGetAddrLocal 2
6668: oPushResult
6669: oLabelNew
6670: oAssign
6671: oEmit 53
6673: oGetLocal 2
6675: oPushResult
6676: oEmitLabel
6677: oPop 1
6679: oEmit 56
6681: oGetLocal 1
6683: oPushResult
6684: oEmitLabel
6685: oPop 1
6687: oCall 6146
6689: oEmit 56
6691: oGetLocal 2
6693: oPushResult
6694: oEmitLabel
6695: oPop 1
6697: oJumpForward 6710
6699: Choice Lookup Table
          41   6666
6702: oEmit 56
6704: oGetLocal 1
6706: oPushResult
6707: oEmitLabel
6708: oPop 1
6710: oReturn
6711: oLocalSpace 4
6713: oInput 0
6715: oGetAddrLocal 1
6717: oPushResult
6718: oScopeFindRequire
6719: oAssign
6720: oGetLocal 1
6722: oPushResult
6723: oCall 6504
6725: oPop 1
6727: oCall 7261
6729: oInput 3
6731: oCall 3143
6733: oCall 7261
6735: oEmit 25
6737: oGetAddrLocal 2
6739: oPushResult
6740: oLabelNew
6741: oAssign
6742: oGetAddrLocal 3
6744: oPushResult
6745: oLabelNew
6746: oAssign
6747: oEmit 53
6749: oGetLocal 3
6751: oPushResult
6752: oEmitLabel
6753: oPop 1
6755: oGetAddrLocal 4
6757: oPushResult
6758: oLabelNew
6759: oAssign
6760: oEmit 56
6762: oGetLocal 4
6764: oPushResult
6765: oEmitLabel
6766: oPop 1
6768: oInputChoice 6848
6770: oGetLocal 1
6772: oPushResult
6773: oCall 6597
6775: oPop 1
6777: oEmit 56
6779: oGetLocal 3
6781: oPushResult
6782: oEmitLabel
6783: oPop 1
6785: oGetLocal 1
6787: oPushResult
6788: oCall 4405
6790: oPop 1
6792: oTypeSPop
6793: oCall 3143
6795: oCall 7261
6797: oEmit 40
6799: oEmit 54
6801: oGetLocal 2
6803: oPushResult
6804: oEmitLabel
6805: oPop 1
6807: oJumpForward 6854
6809: oGetLocal 1
6811: oPushResult
6812: oCall 6621
6814: oPop 1
6816: oEmit 56
6818: oGetLocal 3
6820: oPushResult
6821: oEmitLabel
6822: oPop 1
6824: oGetLocal 1
6826: oPushResult
6827: oCall 4405
6829: oPop 1
6831: oTypeSPop
6832: oCall 3143
6834: oCall 7261
6836: oEmit 41
6838: oEmit 54
6840: oGetLocal 2
6842: oPushResult
6843: oEmitLabel
6844: oPop 1
6846: oJumpForward 6854
6848: Choice Lookup Table
          44   6809
          43   6770
6853: oEndChoice
6854: oGetLocal 4
6856: oPushResult
6857: oGetLocal 2
6859: oPushResult
6860: oLoopPush
6861: oPop 2
6863: oInput 45
6865: oCall 6146
6867: oEmit 53
6869: oGetLocal 4
6871: oPushResult
6872: oEmitLabel
6873: oPop 1
6875: oEmit 56
6877: oGetLocal 2
6879: oPushResult
6880: oEmitLabel
6881: oPop 1
6883: oLoopPop
6884: oReturn
6885: oLocalSpace 3
6887: oGetAddrLocal 1
6889: oPushResult
6890: oLabelNew
6891: oAssign
6892: oEmit 56
6894: oGetLocal 1
6896: oPushResult
6897: oEmitLabel
6898: oPop 1
6900: oGetAddrLocal 2
6902: oPushResult
6903: oLabelNew
6904: oAssign
6905: oGetLocal 1
6907: oPushResult
6908: oGetLocal 2
6910: oPushResult
6911: oLoopPush
6912: oPop 2
6914: oCall 6146
6916: oInputChoice 6947
6918: oCall 6146
6920: oJumpForward 6953
6922: oGetAddrLocal 3
6924: oPushResult
6925: oCall 3166
6927: oPop 1
6929: oEmit 57
6931: oGetLocal 3
6933: oPushResult
6934: oEmitLabel
6935: oPop 1
6937: oGetLocal 1
6939: oPushResult
6940: oEmitLabel
6941: oPop 1
6943: oJumpForward 6955
6945: oJumpForward 6953
6947: Choice Lookup Table
          48   6922
           4   6918
6952: oEndChoice
6953: oJumpBack 6916
6955: oEmit 56
6957: oGetLocal 2
6959: oPushResult
6960: oEmitLabel
6961: oPop 1
6963: oLoopPop
6964: oReturn
6965: oLocalSpace 2
6967: oGetAddrLocal 1
6969: oPushResult
6970: oLabelNew
6971: oAssign
6972: oEmit 56
6974: oGetLocal 1
6976: oPushResult
6977: oEmitLabel
6978: oPop 1
6980: oGetAddrLocal 2
6982: oPushResult
6983: oCall 3166
6985: oPop 1
6987: oGetLocal 1
6989: oPushResult
6990: oGetLocal 2
6992: oPushResult
6993: oLoopPush
6994: oPop 2
6996: oInput 45
6998: oCall 6146
7000: oEmit 53
7002: oGetLocal 1
7004: oPushResult
7005: oEmitLabel
7006: oPop 1
7008: oEmit 56
7010: oGetLocal 2
7012: oPushResult
7013: oEmitLabel
7014: oPop 1
7016: oLoopPop
7017: oReturn
7018: oLocalSpace 0
7020: oLoopContinueLabel
7021: oPushResult
7022: oSetResult 0
7024: oPushResult
7025: equal_label
7026: oPop 2
7028: oChoice 7043
7030: oError 18
7032: oJumpForward 7049
7034: oEmit 53
7036: oLoopContinueLabel
7037: oPushResult
7038: oEmitLabel
7039: oPop 1
7041: oJumpForward 7049
7043: Choice Lookup Table
           0   7034
           1   7030
7048: oEndChoice
7049: oReturn
7050: oLocalSpace 0
7052: oLoopBreakLabel
7053: oPushResult
7054: oSetResult 0
7056: oPushResult
7057: equal_label
7058: oPop 2
7060: oChoice 7075
7062: oError 18
7064: oJumpForward 7081
7066: oEmit 53
7068: oLoopBreakLabel
7069: oPushResult
7070: oEmitLabel
7071: oPop 1
7073: oJumpForward 7081
7075: Choice Lookup Table
           0   7066
           1   7062
7080: oEndChoice
7081: oReturn
7082: oLocalSpace 0
7084: oCall 6146
7086: oInputChoice 7096
7088: oCall 6146
7090: oJumpForward 7102
7092: oJumpForward 7104
7094: oJumpForward 7102
7096: Choice Lookup Table
          34   7092
           4   7088
7101: oEndChoice
7102: oJumpBack 7086
7104: oReturn
7105: oLocalSpace 0
7107: oCall 7112
7109: oEmit 63
7111: oReturn
7112: oLocalSpace 0
7114: oInputChoice 7175
7116: oCall 3143
7118: oTypeSNodeType
7119: oChoice 7141
7121: oEmit 59
7123: oJumpForward 7156
7125: oEmit 60
7127: oJumpForward 7156
7129: oEmit 61
7131: oJumpForward 7156
7133: oError 16
7135: oJumpForward 7156
7137: oEmit 62
7139: oJumpForward 7156
7141: Choice Lookup Table
          26   7137
          20   7133
          24   7133
          25   7129
          22   7125
          21   7121
7154: oError 17
7156: oTypeSPop
7157: oInputChoice 7165
7159: oJumpForward 7173
7161: oJumpForward 7171
7163: oJumpForward 7171
7165: Choice Lookup Table
          12   7163
          14   7159
7170: oEndChoice
7171: oJumpBack 7116
7173: oJumpForward 7178
7175: Choice Lookup Table
          13   7116
7178: oReturn
7179: oLocalSpace 0
7181: oReturn
7182: oLocalSpace 0
7184: oReturn
7185: oLocalSpace 0
7187: oScopeCurrent
7188: oPushResult
7189: oSetResult 13
7191: oPushResult
7192: oNodeGetInt
7193: oPop 2
7195: oReturn
7196: oReturn
7197: oLocalSpace 0
7199: oGetParam 1
7201: oPushResult
7202: oSetResult 18
7204: oPushResult
7205: oNodeGet
7206: oPop 2
7208: oPushResult
7209: oSetResult 13
7211: oPushResult
7212: oNodeGetInt
7213: oPop 2
7215: oReturn
7216: oReturn
7217: oLocalSpace 0
7219: oCall 7185
7221: oPushResult
7222: oGetParam 1
7224: oPushResult
7225: oCall 7197
7227: oPop 1
7229: oPushResult
7230: subtract
7231: oPop 2
7233: oReturn
7234: oReturn
7235: oLocalSpace 1
7237: oGetAddrLocal 1
7239: oPushResult
7240: oTypeSNodeType
7241: oAssign
7242: oTypeSPop
7243: oGetLocal 1
7245: oPushResult
7246: oTypeSNodeType
7247: oPushResult
7248: equal_node_type
7249: oPop 2
7251: oChoice 7257
7253: oError 14
7255: oJumpForward 7260
7257: Choice Lookup Table
           0   7253
7260: oReturn
7261: oLocalSpace 0
7263: oTypeSNodeType
7264: oChoice 7268
7266: oJumpForward 7273
7268: Choice Lookup Table
          21   7266
7271: oError 7
7273: oTypeSPop
7274: oReturn
7275: oLocalSpace 0
7277: oTypeSNodeType
7278: oChoice 7282
7280: oJumpForward 7287
7282: Choice Lookup Table
          21   7280
7285: oError 7
7287: oReturn
7288: oLocalSpace 0
7290: oTypeSNodeType
7291: oChoice 7295
7293: oJumpForward 7300
7295: Choice Lookup Table
          22   7293
7298: oError 8
7300: oTypeSPop
7301: oReturn
7302: oLocalSpace 0
7304: oTypeSNodeType
7305: oChoice 7309
7307: oJumpForward 7314
7309: Choice Lookup Table
          22   7307
7312: oError 8
7314: oReturn
7315: oLocalSpace 1
7317: oGetAddrLocal 1
7319: oPushResult
7320: oGetParam 2
7322: oPushResult
7323: oNodeNew
7324: oPop 1
7326: oAssign
7327: oGetLocal 1
7329: oPushResult
7330: oSetResult 15
7332: oPushResult
7333: oGetParam 1
7335: oPushResult
7336: oNodeSetInt
7337: oPop 3
7339: oGetLocal 1
7341: oPushResult
7342: oTypeAdd
7343: oPop 1
7345: oGetLocal 1
7347: oReturn
7348: oReturn
7349: oLocalSpace 1
7351: oGetAddrLocal 1
7353: oPushResult
7354: oGetParam 3
7356: oPushResult
7357: oNodeNew
7358: oPop 1
7360: oAssign
7361: oGetLocal 1
7363: oPushResult
7364: oSetResult 3
7366: oPushResult
7367: oGetParam 1
7369: oPushResult
7370: oNodeSetInt
7371: oPop 3
7373: oGetLocal 1
7375: oReturn
7376: oReturn
7377: oLocalSpace 1
7379: oGetAddrLocal 1
7381: oPushResult
7382: oGetParam 1
7384: oPushResult
7385: oSetResult 31
7387: oPushResult
7388: oNodeGet
7389: oPop 2
7391: oAssign
7392: oGetLocal 1
7394: oPushResult
7395: oNodeNull
7396: oPop 1
7398: oChoice 7454
7400: oGetAddrLocal 1
7402: oPushResult
7403: oSetResult 26
7405: oPushResult
7406: oNodeNew
7407: oPop 1
7409: oAssign
7410: oGetLocal 1
7412: oPushResult
7413: oSetResult 32
7415: oPushResult
7416: oGetParam 1
7418: oPushResult
7419: oNodeSet
7420: oPop 3
7422: oGetLocal 1
7424: oPushResult
7425: oSetResult 15
7427: oPushResult
7428: oSetResult 8
7430: oPushResult
7431: oNodeSetInt
7432: oPop 3
7434: oGetLocal 1
7436: oPushResult
7437: oTypeAdd
7438: oPop 1
7440: oGetParam 1
7442: oPushResult
7443: oSetResult 31
7445: oPushResult
7446: oGetLocal 1
7448: oPushResult
7449: oNodeSet
7450: oPop 3
7452: oJumpForward 7457
7454: Choice Lookup Table
           1   7400
7457: oGetLocal 1
7459: oReturn
7460: oReturn
7461: oLocalSpace 0
7463: oGetParam 1
7465: oPushResult
7466: oNodeType
7467: oPop 1
7469: oChoice 7497
7471: oMININT
7472: oReturn
7473: oJumpForward 7511
7475: oSetResult 0
7477: oReturn
7478: oJumpForward 7511
7480: oSetResult 0
7482: oReturn
7483: oJumpForward 7511
7485: oGetParam 1
7487: oPushResult
7488: oSetResult 34
7490: oPushResult
7491: oNodeGetInt
7492: oPop 2
7494: oReturn
7495: oJumpForward 7511
7497: Choice Lookup Table
          28   7485
          24   7480
          22   7475
          21   7471
7506: oError 3
7508: oSetResult 0
7510: oReturn
7511: oReturn
7512: oLocalSpace 0
7514: oGetParam 1
7516: oPushResult
7517: oSetResult 20
7519: oPushResult
7520: oNodeGetInt
7521: oPop 2
7523: oPushResult
7524: oEmitInt
7525: oPop 1
7527: oReturn
7528: oLocalSpace 1
7530: oGetAddrGlobal 3
7532: oPushResult
7533: oSetResult 20
7535: oPushResult
7536: oSetResult 4
7538: oPushResult
7539: oCall 7315
7541: oPop 2
7543: oAssign
7544: oGetAddrGlobal 4
7546: oPushResult
7547: oSetResult 21
7549: oPushResult
7550: oSetResult 4
7552: oPushResult
7553: oCall 7315
7555: oPop 2
7557: oAssign
7558: oGetAddrGlobal 5
7560: oPushResult
7561: oSetResult 22
7563: oPushResult
7564: oSetResult 1
7566: oPushResult
7567: oCall 7315
7569: oPop 2
7571: oAssign
7572: oGetAddrGlobal 6
7574: oPushResult
7575: oSetResult 23
7577: oPushResult
7578: oSetResult 1
7580: oPushResult
7581: oCall 7315
7583: oPop 2
7585: oAssign
7586: oGetAddrGlobal 7
7588: oPushResult
7589: oSetResult 24
7591: oPushResult
7592: oSetResult 1
7594: oPushResult
7595: oCall 7315
7597: oPop 2
7599: oAssign
7600: oGetAddrGlobal 8
7602: oPushResult
7603: oSetResult 25
7605: oPushResult
7606: oSetResult 256
7608: oPushResult
7609: oCall 7315
7611: oPop 2
7613: oAssign
7614: oGetAddrLocal 1
7616: oPushResult
7617: oSetResult 13
7619: oPushResult
7620: oSetResult 5
7622: oPushResult
7623: oIdAdd_File
7624: oPushResult
7625: oCall 7349
7627: oPop 3
7629: oAssign
7630: oGetLocal 1
7632: oPushResult
7633: oSetResult 19
7635: oPushResult
7636: oGetGlobal 3
7638: oPushResult
7639: oNodeSet
7640: oPop 3
7642: oGetLocal 1
7644: oPushResult
7645: oScopeDeclare
7646: oPop 1
7648: oGetAddrLocal 1
7650: oPushResult
7651: oSetResult 13
7653: oPushResult
7654: oSetResult 5
7656: oPushResult
7657: oIdAdd_Integer
7658: oPushResult
7659: oCall 7349
7661: oPop 3
7663: oAssign
7664: oGetLocal 1
7666: oPushResult
7667: oSetResult 19
7669: oPushResult
7670: oGetGlobal 4
7672: oPushResult
7673: oNodeSet
7674: oPop 3
7676: oGetLocal 1
7678: oPushResult
7679: oScopeDeclare
7680: oPop 1
7682: oGetAddrLocal 1
7684: oPushResult
7685: oSetResult 13
7687: oPushResult
7688: oSetResult 5
7690: oPushResult
7691: oIdAdd_Boolean
7692: oPushResult
7693: oCall 7349
7695: oPop 3
7697: oAssign
7698: oGetLocal 1
7700: oPushResult
7701: oSetResult 19
7703: oPushResult
7704: oGetGlobal 5
7706: oPushResult
7707: oNodeSet
7708: oPop 3
7710: oGetLocal 1
7712: oPushResult
7713: oScopeDeclare
7714: oPop 1
7716: oGetAddrLocal 1
7718: oPushResult
7719: oSetResult 13
7721: oPushResult
7722: oSetResult 5
7724: oPushResult
7725: oIdAdd_Char
7726: oPushResult
7727: oCall 7349
7729: oPop 3
7731: oAssign
7732: oGetLocal 1
7734: oPushResult
7735: oSetResult 19
7737: oPushResult
7738: oGetGlobal 7
7740: oPushResult
7741: oNodeSet
7742: oPop 3
7744: oGetLocal 1
7746: oPushResult
7747: oScopeDeclare
7748: oPop 1
7750: oGetAddrLocal 1
7752: oPushResult
7753: oSetResult 13
7755: oPushResult
7756: oSetResult 5
7758: oPushResult
7759: oIdAdd_String
7760: oPushResult
7761: oCall 7349
7763: oPop 3
7765: oAssign
7766: oGetLocal 1
7768: oPushResult
7769: oSetResult 19
7771: oPushResult
7772: oGetGlobal 8
7774: oPushResult
7775: oNodeSet
7776: oPop 3
7778: oGetLocal 1
7780: oPushResult
7781: oScopeDeclare
7782: oPop 1
7784: oGetAddrLocal 1
7786: oPushResult
7787: oSetResult 12
7789: oPushResult
7790: oSetResult 4
7792: oPushResult
7793: oIdAdd_True
7794: oPushResult
7795: oCall 7349
7797: oPop 3
7799: oAssign
7800: oGetLocal 1
7802: oPushResult
7803: oSetResult 19
7805: oPushResult
7806: oGetGlobal 5
7808: oPushResult
7809: oNodeSet
7810: oPop 3
7812: oGetLocal 1
7814: oPushResult
7815: oSetResult 20
7817: oPushResult
7818: oSetResult 1
7820: oPushResult
7821: oNodeSetInt
7822: oPop 3
7824: oGetLocal 1
7826: oPushResult
7827: oScopeDeclare
7828: oPop 1
7830: oGetAddrLocal 1
7832: oPushResult
7833: oSetResult 12
7835: oPushResult
7836: oSetResult 4
7838: oPushResult
7839: oIdAdd_False
7840: oPushResult
7841: oCall 7349
7843: oPop 3
7845: oAssign
7846: oGetLocal 1
7848: oPushResult
7849: oSetResult 19
7851: oPushResult
7852: oGetGlobal 5
7854: oPushResult
7855: oNodeSet
7856: oPop 3
7858: oGetLocal 1
7860: oPushResult
7861: oSetResult 20
7863: oPushResult
7864: oSetResult 0
7866: oPushResult
7867: oNodeSetInt
7868: oPop 3
7870: oGetLocal 1
7872: oPushResult
7873: oScopeDeclare
7874: oPop 1
7876: oReturn
