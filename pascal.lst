   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]}
 241:    @CheckForUndefinedMethods
 244:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 244: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 247:    ;
      
      
      
 247: BlockStmt( Label labelForBody ):
 249:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 257:    int patchLS
 257:    .tEnter  patchLS = Here  .tSpace
      
 266:    @Statement
 268:    .tReturn
      
 270:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 282:    oPatch( patchLS, localSpace )
 292:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 292: MethodModifiers( Node decl ):
 294:    {[
 294:       | pCdecl :
 296:          oNodeSetBoolean( decl, qCdecl, true )
 308:          ';'
      
 310:       | * : >
 317:    ]}
 320:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 320: ExternalDecl( Node decl ):
 322:    oNodeSetBoolean( decl, qExternal, true )
 334:    [
 334:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 336:          [
 336:             | pName :
 338:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 340:             | * :
 345:          ]
 345:       | * :
 350:    ]
 351:    ;
      
      
 351: ProcDecl:
 353:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 355:    boolean redeclaring = false
 361:    Node decl = oScopeFindInCurrentScope
      
 366:    [ oNodeNull( decl )
 373:       | true :
               % first declaration
 374:          decl = @newIdent( nProc, kProc, LAST_ID )
 390:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 401:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 403:          redeclaring = true
 409:          [ oNodeGetBoolean( decl, qBodyDefined )
 419:             | true : #eAlreadyDefined
 422:             | * :
 427:          ]
 427:          [ oNodeGetBoolean( decl, qExternal )
 437:             | true : #eAlreadyDefined
 440:             | * :
 445:          ]
 445:          [ oNodeType( decl )
 452:             | nProc :
 453:             | * : #eAlreadyDefined   % wrong kind
 460:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 460:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 479:          oNodeSet( decl, qParams, Null )
 491:    ]
      
 499:    oScopeBegin
 500:    Node paramScope = oScopeCurrent
      
 505:    @FormalArgDecl
 507:    oNodeSet( decl, qParams, paramScope )
 519:    oScopeEnd
 520:    ';'
      
 522:    [ redeclaring
 525:       | false : oScopeDeclare( decl )
 532:       | true :  % TO DO: check that qParams is consistent with qOldParams
 534:    ]
      
 542:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 549:    [
 549:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 551:       | pExternal : @ExternalDecl( decl )
      
 560:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 567:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 573:          oScopeBegin
 574:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 585:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 596:          Label label = oNodeGetLabel( decl, qValue )
 609:          @Block( nLocalVar, label )
 619:          oNodeSetBoolean( decl, qBodyDefined, true )
 631:          oScopeEnd
      
 632:          oScopeEnd  % paramScope
 633:    ]
 633:    ';';
      
      
 636: FuncDecl:
 638:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 640:    boolean redeclaring = false
 646:    Node decl = oScopeFindInCurrentScope
      
 651:    [ oNodeNull( decl )
 658:       | true :
               % first declaration
 659:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 675:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 686:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 688:          redeclaring = true
 694:          [ oNodeGetBoolean( decl, qBodyDefined )
 704:             | true : #eAlreadyDefined
 707:             | * :
 712:          ]
 712:          [ oNodeType( decl )
 719:             | nFunc :
 720:             | * : #eAlreadyDefined   % wrong kind
 727:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 727:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 746:          oNodeSet( decl, qParams, Null )
 758:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 777:          oNodeSet( decl, qType, Null )
 789:    ]
      
 797:    oScopeBegin
 798:    Node paramScope = oScopeCurrent
      
 803:    @FormalArgDecl
 805:    oNodeSet( decl, qParams, paramScope )
      
 817:    ':'
      
 819:    Node theType
 819:    @TypeRef( theType )
 826:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 838:    Node ptrType = @PointerTypeTo( theType )
 849:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 865:    oScopeEnd
 866:    ';'
      
 868:    [ redeclaring
 871:       | false : oScopeDeclare( decl )
 878:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 880:    ]
      
 888:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 895:    [
 895:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 897:       | pExternal : @ExternalDecl( decl )
      
 906:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 913:          oScopeEnter( paramScope )
      
 919:          oScopeBegin
 920:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 931:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 942:          Label label = oNodeGetLabel( decl, qValue )
 955:          @Block( nLocalVar, label )
 965:          oNodeSetBoolean( decl, qBodyDefined, true )
 977:          oScopeEnd
      
 978:          oScopeEnd  % paramScope
 979:    ]
 979:    ';';
      
      
 982: FormalArgDecl:
 984:    [
 984:       | '(' :
 986:          {
 986:             NodeVec decls = oNodeVecNew
 991:             Node decl
 991:             boolean isInOut = false
      
 997:             [
 997:                | pVar : isInOut = true
1005:                | * :
1010:             ]
      
1010:             {  pIdent
      
1012:                decl = @newIdent( nParam, kVar, LAST_ID )
1028:                oNodeSetBoolean( decl, qInOut, isInOut )
1040:                oNodeVecAppend( decls, decl )
      
1049:                [
1049:                   | ':' : >
1053:                   | ',' :
1055:                ]
1063:             }
      
1065:             Node theType
1065:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1072:             Node allocType
1072:             [ isInOut
1075:                | true :   allocType = @PointerTypeTo( theType )
1087:                | * :      allocType = theType
1098:             ]
      
1098:             int i = 0
1104:             {[ equal( i, oNodeVecSize( decls ) )
1118:                | false :
1119:                   decl = oNodeVecElement( decls, i )
      
1132:                   oNodeSet( decl, qType, theType )
1144:                   oScopeDeclare( decl )
1150:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1166:                   inc( i )
1172:                | * :
1177:                   >
1179:             ]}
      
1181:             oNodeVecDelete( decls )
      
1187:             [
1187:                | ')' : >
1191:                | ';' :
1193:             ]
1201:          }
1203:       | * :
1208:    ];
      
1209: ConstDecl:
1211:    {[
1211:       | pIdent :
1213:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1229:          '='
      
1231:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1233:          int val = oValueTop
1238:          oValuePop
1239:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1251:          oNodeSet( decl, qType, IntegerType )
      
1263:          oScopeDeclare( decl )
1269:          ';'
1271:       | * :
1276:          >
1278:    ]};
      
1281: TypeDecl:
1283:    {[
1283:       | pIdent :
1285:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1301:          '='
1303:          Node theType
1303:          @TypeRef( theType )
1310:          oNodeSet( decl, qType, theType )
1322:          oScopeDeclare( decl )
1328:          ';'
1330:       | * :
1335:          >
1337:    ]};
      
1340: VarDecl( node_type varNodeType ):
1342:    {[
1342:       | pIdent :
1344:          NodeVec decls = oNodeVecNew
1349:          Node decl
1349:          {
1349:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1365:             oNodeVecAppend( decls, decl )
1374:             [
1374:                | ',' :
1376:                   pIdent
1378:                | * :
1383:                   >
1385:             ]
1385:          }
1387:          ':'
1389:          Node theType
1389:          @TypeRef( theType )
      
1396:          int i = 0
1402:          {[ equal( i, oNodeVecSize( decls ) )
1416:            | false :
1417:              decl = oNodeVecElement( decls, i )
1430:              oNodeSet( decl, qType, theType )
1442:              oScopeDeclareAlloc( decl )
1448:              inc( i )
1454:             | * :
1459:               >
1461:          ]}
      
1463:          oNodeVecDelete( decls )
1469:          ';'
1471:       | * :
1476:          >
1478:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1481: TypeRef( out Node resultType ):
1483:    [
1483:       | pIdent :           % previously named type (including intrinsics)
1485:          Node decl = oScopeFindRequire
1490:          [ oNodeType( decl )
1497:            | nTypeDecl :
1498:                resultType = oNodeGet( decl, qType )
1511:            | * :
1516:                #eNotType
1518:                resultType = IntegerType
1524:          ]
         
1524:       | pArray :
1526:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1528:          NodeVec dimensions = oNodeVecNew
      
1533:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1533:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1543:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1555:             @ConstExpr
1557:             oNodeSetInt( subrange, qLow, oValueTop )
1568:             oValuePop
1569:             '..'
1571:             @ConstExpr
1573:             oNodeSetInt( subrange, qHigh, oValueTop )
1584:             oValuePop
1585:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1597:             oTypeAdd( subrange )
      
1603:             Node a = oNodeNew( nArrayType )
1613:             oNodeSet( a, qIndexType, subrange )
      
1625:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1634:             [
1634:                | ']' : >
1638:                | ',' :
1640:             ]
1648:          }
      
1650:          pOf
1652:          Node baseType
1652:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1659:          int dim = oNodeVecSize( dimensions )
      
1669:          {
1669:              dec(dim)
      
1675:              Node a = oNodeVecElement( dimensions, dim )
      
1688:              oNodeSet( a, qBaseType, baseType )
1700:              Node subrange = oNodeGet( a, qIndexType )
1713:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1740:              inc( width )
1746:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1772:              oTypeAdd( a )
1778:              baseType = a
      
1784:              [ equal_zero(dim)
1791:                  | true:  >
1794:                  | *:
1799:              ]
1799:          }
      
1801:          resultType = oNodeVecElement( dimensions, 0 )
1814:          oNodeVecDelete( dimensions )
      
1820:       | '^' :
1822:          Node theType
1822:          @TypeRef( theType )
1829:          resultType = @PointerTypeTo( theType )
      
1840:       | pRecord :
1842:          resultType = oNodeNew( nRecordType )
1852:          oScopeBegin
      
1853:          @VarDecl( nRecordField )
      
1860:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1872:          [ equal_zero( size )
1879:             | true : #eRecordEmpty
1882:             | * :
1887:          ]
      
1887:          pEnd
      
1889:          oNodeSet( resultType, qScope, oScopeCurrent )
1900:          oNodeSetInt( resultType, qSize, size )
1912:          oScopeEnd
1913:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1919:       | pSet :
1921:          pOf
1923:          Node theType
1923:          @TypeRef( theType )
1930:       | * :       % this works for cases except where expr starts with an id
1943:          @ConstExpr '..' @ConstExpr
1949:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1950: ConstExpr:
1952:    [
1952:       | pIntLit :
1954:          oValuePush( TOKEN_VALUE )
1959:       | pIdent :
1961:          Node decl = oScopeFindRequire
1966:          [ oNodeType( decl )
1973:             | nConst :
1974:                oValuePush( oNodeGetInt( decl, qValue ) )
1987:             | * :
1992:                #eNotConst
1994:                oValuePush( 0 )
2000:          ]
2000:       | pMinus :
2002:          @ConstExpr
2004:          oValueNegate
2005:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2016: Expr:
2018:    Label falseLabel = labelNull
      
2024:    @ExprAllowCF( falseLabel )
2031:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2039: BooleanExprControlFlow( out Label falseLabel ):
2041:    @ExprAllowCF( falseLabel )
2048:    [ oTypeSNodeType
2050:       | nBooleanCFType :
2051:       | nBooleanType :
               % convert value to control flow
2053:          falseLabel = oLabelNew
2058:          .tJumpFalse  oEmitLabel( falseLabel )
2066:       | * :
2073:          #eNotBoolean
2075:    ]
2075:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2077: CFToVal( inout Label falseLabel ):
2079:    [ oTypeSNodeType
2081:       | nBooleanCFType :
2082:          Label doneLabel = oLabelNew
2087:          .tPushConstI  oEmitInt( 1 )
2095:          .tJump  oEmitLabel( doneLabel )
2103:          .tLabel  oEmitLabel( falseLabel )
2111:          .tPushConstI  oEmitInt( 0 )
2119:          .tLabel  oEmitLabel( doneLabel )
2127:          oTypeSPop
2128:          oTypeSPush( BooleanType )
2134:          falseLabel = labelNull
2140:       | * :
2145:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2146: ValToCF( out Label falseLabel ):
2148:    [ oTypeSNodeType
2150:       | nBooleanType :
2151:          falseLabel = oLabelNew
2156:          .tJumpFalse  oEmitLabel( falseLabel )
2164:          oTypeSPop
2165:          oTypeSPush( BooleanCFType )
2171:       | * :
2176:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2177: ExprAllowCF( out Label falseLabel ):
2179:    @BoolExprAllowCF( falseLabel )
2186:    {[
2186:       | '=' :
2188:          @CFToVal( falseLabel )
2195:          @BoolExprAllowCF( falseLabel )
2202:          @CFToVal( falseLabel )
2209:          @MatchTypes
2211:          [ oTypeSNodeType
2213:             | nIntegerType, nBooleanType :  .tEqualI
2216:             | nPointerType :                .tEqualP
2220:             | nCharType, nStringType :      #eNotImplemented
2224:             | * :                           #eNotAllowed
2239:          ]
2239:          oTypeSPop
2240:          oTypeSPush( BooleanType )
      
2246:       | '<>' :
2248:          @CFToVal( falseLabel )
2255:          @BoolExprAllowCF( falseLabel )
2262:          @CFToVal( falseLabel )
2269:          @MatchTypes
2271:          [ oTypeSNodeType
2273:             | nIntegerType, nBooleanType :  .tNotEqualI
2276:             | nPointerType :                .tNotEqualP
2280:             | nCharType, nStringType :      #eNotImplemented
2284:             | * :                           #eNotAllowed
2299:          ]
2299:          oTypeSPop
2300:          oTypeSPush( BooleanType )
      
2306:       | '<' :
2308:          @CFToVal( falseLabel )
2315:          @BoolExprAllowCF( falseLabel )
2322:          @CFToVal( falseLabel )
2329:          @MatchTypes
2331:          [ oTypeSNodeType
2333:             | nIntegerType, nBooleanType :  .tLessI
2336:             | nCharType, nStringType :      #eNotImplemented
2340:             | * :                           #eNotAllowed
2353:          ]
2353:          oTypeSPop
2354:          oTypeSPush( BooleanType )
      
2360:       | '>' :
2362:          @CFToVal( falseLabel )
2369:          @BoolExprAllowCF( falseLabel )
2376:          @CFToVal( falseLabel )
2383:          @MatchTypes
2385:          [ oTypeSNodeType
2387:             | nIntegerType, nBooleanType :  .tGreaterI
2390:             | nCharType, nStringType :      #eNotImplemented
2394:             | * :                           #eNotAllowed
2407:          ]
2407:          oTypeSPop
2408:          oTypeSPush( BooleanType )
      
2414:       | '<=' :
2416:          @CFToVal( falseLabel )
2423:          @BoolExprAllowCF( falseLabel )
2430:          @CFToVal( falseLabel )
2437:          @MatchTypes
2439:          [ oTypeSNodeType
2441:             | nIntegerType, nBooleanType :  .tLessEqualI
2444:             | nCharType, nStringType :      #eNotImplemented
2448:             | * :                           #eNotAllowed
2461:          ]
2461:          oTypeSPop
2462:          oTypeSPush( BooleanType )
      
2468:       | '>=' :
2470:          @CFToVal( falseLabel )
2477:          @BoolExprAllowCF( falseLabel )
2484:          @CFToVal( falseLabel )
2491:          @MatchTypes
2493:          [ oTypeSNodeType
2495:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2498:             | nCharType, nStringType :      #eNotImplemented
2502:             | * :                           #eNotAllowed
2515:          ]
2515:          oTypeSPop
2516:          oTypeSPush( BooleanType )
      
2522:       | * :
2537:          >
2539:    ]};
      
      
2542: BoolExprAllowCF( out Label falseLabel ):
2544:    Label trueLabel = labelNull
      
2550:    @BoolTermAllowCF( falseLabel )
2557:    {[
2557:       | pOr :
2559:          [ oTypeSNodeType
2561:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2562:                [ equal_label( trueLabel, labelNull )
2572:                   | true :  trueLabel = oLabelNew
2578:                   | * :
2583:                ]
2583:                .tJump  oEmitLabel( trueLabel )
2591:             | nBooleanType :
2593:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2600:                [ equal_label( trueLabel, labelNull )
2610:                   | true :  trueLabel = oLabelNew
2616:                   | * :
2621:                ]
2621:                .tJumpTrue  oEmitLabel( trueLabel )
2629:             | * : #eNotBoolean
2638:          ]
2638:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2639:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2647:          falseLabel = labelNull
2653:          @BoolTermAllowCF( falseLabel )
      
2660:          [ oTypeSNodeType
2662:             | nBooleanCFType :
2663:             | nBooleanType :
2665:                @ValToCF( falseLabel )
2672:             | * : #eNotBoolean
2681:          ]
      
2681:          oTypeSPop
2682:          oTypeSPush( BooleanCFType )
      
2688:       | * :
2693:          >
2695:    ]}
      
         % any short-circuit trues jump here to the end
2697:    [ equal_label( trueLabel, labelNull )
2707:       | false :
2708:          .tLabel  oEmitLabel( trueLabel )
2716:       | * :
2721:    ]
2722:    ;
      
      
2722: BoolTermAllowCF( out Label falseLabel ):
2724:    Label overallFalseLabel = labelNull
      
2730:    @BoolFactorAllowCF( falseLabel )
2737:    {[
2737:       | pAnd :
2739:          [ oTypeSNodeType
2741:             | nBooleanCFType :
2742:             | nBooleanType :
2744:                @ValToCF( falseLabel )
2751:             | * :
2758:                #eNotBoolean
2760:          ]
2760:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2761:          [ equal_label( overallFalseLabel, labelNull )
2771:             | true :
2772:                overallFalseLabel = oLabelNew
2777:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2791:                falseLabel = overallFalseLabel
2797:             | * :
2802:          ]
      
2802:          Label factorFalseLabel = labelNull
2808:          @BoolFactorAllowCF( factorFalseLabel )
      
2815:          [ oTypeSNodeType
2817:             | nBooleanCFType :
2818:             | nBooleanType :
2820:                @ValToCF( factorFalseLabel )
2827:             | * : #eNotBoolean
2836:          ]
2836:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2850:       | * :
2855:          >
2857:    ]};
      
2860: BoolFactorAllowCF( out Label falseLabel ):
2862:    [
2862:       | pNot :
2864:          Label factorFalseLabel = labelNull
      
2870:          @BoolFactorAllowCF( factorFalseLabel )
2877:          [ oTypeSNodeType
2879:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2880:                falseLabel = oLabelNew
2885:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2893:                .tLabel  oEmitLabel( factorFalseLabel )
      
2901:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2903:                .tNot
      
2905:             | * : #eNotBoolean
2914:          ]
      
2914:       | * :
2919:          @ArithExprAllowCF( falseLabel )
2926:    ];
      
2927: ArithExprAllowCF( out Label falseLabel ):
2929:    @TermAllowCF( falseLabel )
2936:    {[
2936:       | pPlus :
2938:          @RequireIntPop
2940:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2947:          @RequireInt
2949:          .tAddI
2951:       | pMinus :
2953:          @RequireIntPop
2955:          @TermAllowCF( falseLabel )
2962:          @RequireInt
2964:          .tSubI
2966:       | * :
2973:          >
2975:    ]};
      
2978: TermAllowCF( out Label falseLabel ):
2980:    @FactorAllowCF( falseLabel )
2987:    {[
2987:       | pTimes :
2989:          @RequireIntPop
2991:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2998:          @RequireInt
3000:          .tMultI
3002:       | pDivide :
3004:          @RequireIntPop
3006:          @FactorAllowCF( falseLabel )
3013:          @RequireInt
3015:          .tDivI
3017:       | * :
3024:          >
3026:    ]};
      
3029: FactorAllowCF( out Label falseLabel ):
3031:    [
3031:       | pPlus :
3033:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3040:          @RequireInt
3042:       | pMinus :
3044:          @PrimaryAllowCF( falseLabel )
3051:          @RequireInt
3053:          .tNegI
3055:       | * :
3062:          @PrimaryAllowCF( falseLabel )
3069:    ];
      
3070: PrimaryAllowCF( out Label falseLabel ):
3072:    [
3072:       | pIntLit :
3074:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3081:          oTypeSPush( IntegerType )
      
3087:       | '(' :
3089:          @ExprAllowCF( falseLabel )
3096:          ')'
      
3098:       | pStrLit :
3100:          int addr = oStringAllocLit     % store in global data
3105:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3113:          oTypeSPush( StringType )
      
3119:       | pIdent :
3121:          Node decl = oScopeFindRequire
3126:          Node theType
      
3126:          [ oNodeType( decl )
3133:             | nFunc :
      
3134:                @Call( decl )
      
3141:             | nConst :
3143:                theType = oNodeGet( decl, qType )
3156:                oTypeSPush( theType )
3162:                [ oTypeSNodeType
3164:                   | nIntegerType, nBooleanType :
3165:                      .tPushConstI @EmitValue( decl )
3174:                   | * :
3181:                      #eNotImplemented
3183:                ]
      
3183:             | nGlobalVar, nLocalVar, nParam :
3185:                @VarExpr( decl )
      
3192:             | * :
3205:                #eNotValue
3207:                oTypeSPush( IntegerType )
3213:          ]
      
3213:       | '@' :        % @var -- pointer to var
3215:          pIdent
      
3217:          Node decl = oScopeFindRequire
3222:          Node theType
      
3222:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3229:          theType = oTypeSTop
3234:          oTypeSPop
3235:          Node ptrType = @PointerTypeTo( theType )
3246:          oTypeSPush( ptrType )
      
3252:       | * :
3265:          #eNotValue
3267:          oTypeSPush( IntegerType )
3273:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3274: VarExpr( Node decl ):
3276:    Node theType = oNodeGet( decl, qType )
3289:    oTypeSPush( theType )
3295:    [ oTypeSNodeType
3297:       | nIntegerType :
3298:          [ oNodeType( decl )
3305:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3315:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3326:             | nParam :
3328:                [ oNodeGetBoolean( decl, qInOut )
3338:                   | true :    % VAR param points to the var.  Auto dereference.
3339:                               .tPushParamP @EmitValue( decl )
3348:                               .tFetchI
3350:                   | * :       .tPushParamI @EmitValue( decl )
3364:                ]
3364:          ]
      
3374:       | nBooleanType :
3376:          [ oNodeType( decl )
3383:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3393:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3404:             | nParam :
3406:                [ oNodeGetBoolean( decl, qInOut )
3416:                   | true :    % VAR param points to the var.  Auto derefernce.
3417:                               .tPushParamP @EmitValue( decl )
3426:                               .tFetchB
3428:                   | * :       .tPushParamB @EmitValue( decl )
3442:                ]
3442:          ]
      
3452:       | nCharType, nStringType, nFileType :
3454:          #eNotImplemented
      
3456:       | nPointerType :
3458:          [ oNodeType( decl )
3465:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3475:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3486:             | nParam :
3488:                [ oNodeGetBoolean( decl, qInOut )
3498:                   | true :    % VAR param points to the var.  Auto derefernce.
3499:                               .tPushParamP @EmitValue( decl )
3508:                               .tFetchP
3510:                   | * :       .tPushParamP @EmitValue( decl )
3524:                ]
3524:          ]
3534:          [
3534:             | '^' :             % dereferenced
3536:                oTypeSPop
3537:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3550:                @LValueIndexes
3552:                @FetchVar
3554:             | * :               % just ptr value alone
3559:          ]
      
3559:       | * :
               % compound type
               % first, push addr of start of var
3574:          [ oNodeType( decl )
3581:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3591:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3602:             | nParam :
3604:                [ oNodeGetBoolean( decl, qInOut )
3614:                   | true :    % VAR param points to the var.  Auto derefernce.
3615:                               .tPushParamP @EmitValue( decl )
3624:                   | * :       .tPushAddrParam @EmitValue( decl )
3638:                ]
3638:          ]
               % modify addr for subscripts, field references, etc
3648:          @LValueIndexes
               % get final value
3650:          @FetchVar
3652:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3653: FetchVar:
3655:    [ oTypeSNodeType
3657:       | nIntegerType :   .tFetchI
3660:       | nBooleanType :   .tFetchB
3664:       | nCharType, nStringType, nFileType : #eNotImplemented
3668:       | nPointerType :   .tFetchP
3672:       | * :              % compound type; leave as addr
3687:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3688: LValueIndexes:
3690:    {[
3690:       | '[' :       @ArraySubscripts
3694:       | '.' :       @RecordFieldRef
3698:       | '^' :       @PointerDeref
3702:       | * :         >
3713:    ]};
      
3716: ArraySubscripts:
3718:    [ oTypeSNodeType
3720:       | nArrayType :
3721:       | * :       #eNotArray
3728:    ]
3728:    {
3728:       [ oTypeSNodeType
3730:          | nArrayType :
3731:          | * :    #eTooManySubscripts
3738:       ]
      
            % low subscript of this dimension
3738:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3755:       Node baseType
3755:       baseType = oNodeGet( oTypeSTop, qBaseType )
3767:       oTypeSPop
3768:       oTypeSPush( baseType )
      
3774:       @Expr
3776:       @RequireIntPop
            % adjust for low subscript
3778:       [ equal_zero( low )
3785:          | false :
3786:             .tPushConstI oEmitInt( low ) .tSubI
3796:          | * :
3801:       ]
      
            % multiply by element size
3801:       int size = oNodeGetInt( baseType, qSize )
3814:       [ equal( size, 1 )
3824:          | false :
3825:             .tPushConstI oEmitInt( size ) .tMultI
3835:          | * :
3840:       ]
      
            % update start address
3840:       .tAddPI
3842:       [
3842:          | ']' :  >
3846:          | ',' :
3848:       ]
3856:    };
      
      
3859: RecordFieldRef:
3861:    [ oTypeSNodeType
3863:       | nRecordType :
3864:       | * :    #eNotRecord
3871:    ]
3871:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3883:    pIdent
3885:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3890:    [ oNodeType( field )
3897:       | nRecordField :
3898:       | * :   #eNotRecordField
3905:    ]
3905:    oScopeEnd
3906:    int offset = oNodeGetInt( field, qValue )
3919:    [ equal_zero( offset )
3926:       | false :
3927:          .tPushConstI oEmitInt( offset ) .tAddPI
3937:       | * :
3942:    ]
      
         % replace the type on the type stack, with the field type
3942:    oTypeSPop
3943:    oTypeSPush( oNodeGet( field, qType ) )
3957:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3957: PointerDeref:
3959:    [ oTypeSNodeType
3961:       | nPointerType :
3962:       | * :       #eNotPointer
3969:    ]
3969:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3971:    Node theType = oTypeSTop
3976:    oTypeSPop
3977:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3991:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3991: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3993:    @MatchTypes
3996:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3996: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
3998:    [ oNodeGetBoolean( method, qExternal )
4008:       | true :
4009:          [ oNodeGetBoolean( method, qCalled )
4019:             | false :
                     % define the label as extern
4020:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4037:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4052:             | * :
4057:          ]
4057:      | * :
4062:    ]
4062:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4074:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4087:    Node resultType
4087:    int tempOffset
      
4087:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4104:    [ isFunc
4107:       | true :
4108:          resultType = oNodeGet( method, qType )
4121:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4131:       | * :
4136:    ]
         
      
4136:    Node paramScope = oNodeGet( method, qParams )
4149:    int actualsSize = oNodeGetInt( paramScope, qSize )
4162:    [ cdecl
4165:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4174:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4184:    ]
      
4192:    Node param = oNodeGet( paramScope, qDecls )
4205:    [
4205:       | '(' :
            
4207:          {
4207:             [ oNodeNull( param )
4214:                | true : >
4217:                | * :
4222:             ]
      
4222:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4235:             .tPushAddrActual oEmitInt( offset )
4243:             oTypeSPush( oNodeGet( param, qType ) )
      
4256:             [ oNodeGetBoolean( param, qInOut )
4266:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4267:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4269:                           @MatchTypes
      
4271:                           .tAssignP
      
4273:                | false :  @Expr
4277:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4279:                           [ oTypeSNodeType
4281:                              | nIntegerType :            .tAssignI
4284:                              | nBooleanType :            .tAssignB
4288:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4292:                              | nPointerType :            .tAssignP
4296:                              | * :
                                       % compound types: copy value into actuals space
4311:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4323:                                  .tCopy  oEmitInt( size )    % multi-word copy
4331:                           ]
4331:             ]
4339:             oTypeSPop
      
4340:             oNodeNext( param )
4346:             [ oNodeNull( param )
4353:                | true :  >
4356:                | false :
4358:             ]
      
4366:             ','
4368:          }
      
4370:          ')'
      
4372:       | * :
4377:    ]
      
4377:    [ oNodeNull( param )
4384:       | false :    #eMissingParameter
4387:       | * :
4392:    ]
      
4392:    [ isFunc
4395:       | true :
               % Pass result temp as an additional VAR parameter.
4396:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4411:          .tPushAddrLocal  oEmitInt( tempOffset )
4419:          .tAssignP
4421:       | * :
4426:    ]
      
4426:    [ cdecl
4429:       | true :
4430:          .tCallCdecl  @EmitValue( method )
4439:       | false :
4441:          .tCall   @EmitValue( method )
4450:    ]
      
4458:    [ isFunc
4461:       | true :
               % push return value from temp
4462:          oTypeSPush( resultType )
      
4468:          [ oTypeSNodeType
4470:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4479:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4489:             | nCharType, nStringType, nFileType : #eNotImplemented
4493:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4503:             | * :              % compound type: push address
4518:                                .tPushAddrLocal  oEmitInt( tempOffset )
4526:          ]
4526:       | * :
4531:    ]
         
4531:    .tFreeActuals  oEmitInt( actualsSize )
4540:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4540: Statement:
4542:    [
4542:       | pWriteln :     @WritelnStmt
4546:       | pWrite :       @WriteStmt
4550:       | pReadln :      @ReadlnStmt
4554:       | pRead :        @ReadStmt
4558:       | pIf :          @IfStmt
4562:       | pWhile :       @WhileStmt
4566:       | pFor :         @ForStmt
4570:       | pRepeat :      @RepeatStmt
4574:       | pBreak :       @BreakStmt
4578:       | pContinue :    @ContinueStmt
4582:       | pBegin :       @BeginStmt
4586:       | pIdent :       @AssignOrCallStmt
4590:       | * :            % null statement : don't accept any tokens
4617:    ];
      
      
4618: AssignOrCallStmt:
4620:    Node decl = oScopeFindRequire
4625:    [ oNodeType( decl )
4632:       | nProc :                           @Call( decl )
4640:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4649:       | nFunc :                           @AssignResultStmt( decl )
4658:       | * :                               #eBadStatement
4673:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4674: AssignStmt( Node decl ):
      
4676:    @LValueVar( decl )
      
4683:    ':=' 
4685:    @Expr
4687:    @MatchTypes
4689:    [ oTypeSNodeType
4691:       | nIntegerType :            .tAssignI
4694:       | nBooleanType :            .tAssignB
4698:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4702:       | nPointerType :            .tAssignP
4706:       | * :
4721:           int size = oNodeGetInt( oTypeSTop, qSize )
4733:           .tCopy  oEmitInt( size )    % multi-word copy
4741:    ]
4741:    oTypeSPop
4743:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4743: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4745:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4761:       | false :   #eNotCurrentFunction
4764:       | * :
4769:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4769:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4784:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4797:    ':='
4799:    @Expr
4801:    @MatchTypes
4803:    [ oTypeSNodeType
4805:       | nIntegerType :            .tAssignI
4808:       | nBooleanType :            .tAssignB
4812:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4816:       | nPointerType :            .tAssignP
4820:       | * :
4835:           int size = oNodeGetInt( oTypeSTop, qSize )
4847:           .tCopy  oEmitInt( size )    % multi-word copy
4855:    ]
4855:    oTypeSPop
4857:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4857: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4859:    pIdent
4861:    Node decl = oScopeFindRequire
4866:    [ oNodeType( decl )
4873:       | nGlobalVar, nLocalVar, nParam :
4874:       | * :  #eNotVar
4885:    ]
4885:    @LValueVar( decl )
4893:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4893: LValueVar( Node decl ):
4895:    [ oNodeType( decl )
4902:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4912:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4923:       | nParam :
4925:          [ oNodeGetBoolean( decl, qInOut )
4935:             | true :   % VAR param points to variable.  No dereference.
4936:                        .tPushParamP @EmitValue( decl )
4945:             | * :      .tPushAddrParam @EmitValue( decl )
4959:          ]
4959:       | * :            #eNotVar
4970:    ]
      
4970:    oTypeSPush( oNodeGet( decl, qType ) )
4983:    @LValueIndexes        % handle subscripts, if any
4986:    ;
      
      
4986: IncVar( Node decl ):
4988:    @LValueVar( decl )
4995:    @RequireIntPop
4997:    @VarExpr( decl )
5004:    oTypeSPop
5005:    .tIncI
5007:    .tAssignI;
      
5010: DecVar( Node decl ):
5012:    @LValueVar( decl )
5019:    @RequireIntPop
5021:    @VarExpr( decl )
5028:    oTypeSPop
5029:    .tDecI
5031:    .tAssignI;
      
      
5034: IfStmt:
5036:    Label falseLabel = labelNull
      
5042:    @BooleanExprControlFlow( falseLabel )
5049:    pThen
5051:    @Statement
5053:    [
5053:       | pElse :
5055:          Label doneLabel = oLabelNew
      
5060:          .tJump  oEmitLabel( doneLabel )
5068:          .tLabel oEmitLabel( falseLabel )
5076:          @Statement
5078:          .tLabel oEmitLabel( doneLabel )
      
5086:       | * :
5091:          .tLabel oEmitLabel( falseLabel )
5099:    ];
      
      
5100: ForStmt:
5102:    pIdent
      
5104:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5109:    @LValueVar( decl )
5116:    @RequireIntPop
      
5118:    ':='
      
5120:    @Expr
5122:    @RequireIntPop
5124:    .tAssignI
      
5126:    Label breakLabel = oLabelNew
      
5131:    Label checkLabel = oLabelNew
5136:    .tJump  oEmitLabel( checkLabel )
      
5144:    Label continueLabel = oLabelNew
5149:    .tLabel  oEmitLabel( continueLabel )
5157:    [
5157:       | pTo :
5159:          @IncVar( decl )
5166:          .tLabel  oEmitLabel( checkLabel )
5174:          @VarExpr( decl )  oTypeSPop
5182:          @Expr
5184:          @RequireIntPop
5186:          .tGreaterI
5188:          .tJumpTrue  oEmitLabel( breakLabel )
5196:       | pDownto :
5198:          @DecVar( decl )
5205:          .tLabel  oEmitLabel( checkLabel )
5213:          @VarExpr( decl )  oTypeSPop
5221:          @Expr
5223:          @RequireIntPop
5225:          .tLessI
5227:          .tJumpTrue  oEmitLabel( breakLabel )
5235:    ]
5243:    oLoopPush( continueLabel, breakLabel )
5252:    pDo
5254:    @Statement
5256:    .tJump  oEmitLabel( continueLabel )
5264:    .tLabel  oEmitLabel( breakLabel )
5272:    oLoopPop;
      
      
5274: RepeatStmt:
5276:    Label continueLabel = oLabelNew
5281:    .tLabel  oEmitLabel( continueLabel )
      
5289:    Label breakLabel = oLabelNew
      
5294:    oLoopPush( continueLabel, breakLabel )
5303:    @Statement
5305:    {[
5305:       | ';' :
5307:          @Statement
5309:       | pUntil :
5311:          Label falseLabel
5311:          @BooleanExprControlFlow( falseLabel )
5318:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5332:          >
5334:    ]}
5344:    .tLabel  oEmitLabel( breakLabel )
5352:    oLoopPop;
      
      
5354: WhileStmt:
5356:    Label continueLabel = oLabelNew
5361:    .tLabel  oEmitLabel( continueLabel )
      
5369:    Label breakLabel
5369:    @BooleanExprControlFlow( breakLabel )
      
5376:    oLoopPush( continueLabel, breakLabel )
5385:    pDo
5387:    @Statement
5389:    .tJump  oEmitLabel( continueLabel )
5397:    .tLabel  oEmitLabel( breakLabel )
5405:    oLoopPop;
      
      
5407: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5409:    [ equal_label( oLoopContinueLabel, labelNull )
5418:       | true :
5419:          #eNotInALoop
5421:       | false :
5423:          .tJump  oEmitLabel( oLoopContinueLabel )
5430:    ];
      
      
5439: BreakStmt:
5441:    [ equal_label( oLoopBreakLabel, labelNull )
5450:       | true :
5451:          #eNotInALoop
5453:       | false :
5455:          .tJump  oEmitLabel( oLoopBreakLabel )
5462:    ];
      
      
5471: BeginStmt:
5473:    @Statement
5475:    {[
5475:       | ';' :   @Statement
5479:       | pEnd :  >
5483:    ]};
      
      
5494: WritelnStmt:
5496:    @WriteStmt
5498:    .tWriteCR;
      
      
5501: WriteStmt:
5503:    [
5503:       | '(' :
5505:          {
5505:             @Expr
5507:             [ oTypeSNodeType
5509:                | nIntegerType :             .tWriteI
5512:                | nBooleanType :             .tWriteBool
5516:                | nStringType :              .tWriteStr
5520:                | nCharType, nFileType :     #eNotImplemented
5524:                | nPointerType :             .tWriteP
5528:                | * :                        #eNotAllowed
5545:             ]
5545:             oTypeSPop
5546:             [
5546:                | ')' : >
5550:                | ',' :
5552:             ]
5560:          }
5562:       | * :
5567:    ];
      
      
5568: ReadlnStmt:      % ***
         % TO DO
5571:    ;
      
5571: ReadStmt:
         % TO DO
5574:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5574: MatchTypes:
5576:    node_type nt = oTypeSNodeType
5581:    oTypeSPop
5582:    [ equal_node_type( nt, oTypeSNodeType )
5591:       | false :
5592:          #eTypeMismatch
5594:       | * :
5599:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5600: RequireIntPop:
5602:    [ oTypeSNodeType
5604:       | nIntegerType :
5605:       | * :          #eNotInteger
5612:    ]
5612:    oTypeSPop;
      
5614: RequireInt:
5616:    [ oTypeSNodeType
5618:       | nIntegerType :
5619:       | * :          #eNotInteger
5626:    ];
      
5627: RequireBoolPop:
5629:    [ oTypeSNodeType
5631:       | nBooleanType :
5632:       | * :          #eNotBoolean
5639:    ]
5639:    oTypeSPop;
      
5641: RequireBool:
5643:    [ oTypeSNodeType
5645:       | nBooleanType :
5646:       | * :          #eNotBoolean
5653:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5654: newType( node_type nt, int size ) >> Node:
5656:   Node node = oNodeNew( nt )
5666:   oNodeSetInt( node, qSize, size )
5678:   oTypeAdd( node )
5684:   >> node
5688:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5688: newIdent( node_type nt, kind k, int id ) >> Node:
5690:   Node t = oNodeNew( nt )
5700:   oNodeSetInt( t, qIdent, id )
5712:   >> t
5716:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5716: PointerTypeTo( Node theType ) >> Node:
5718:    Node ptrType = oNodeGet( theType, qPointerType )
5731:    [ oNodeNull( ptrType )
5738:       | true :
5739:          ptrType = oNodeNew( nPointerType )
5749:          oNodeSet( ptrType, qBaseType, theType )
5761:          oNodeSetInt( ptrType, qSize, 8 )
5773:          oTypeAdd( ptrType )
5779:          oNodeSet( theType, qPointerType, ptrType )
5791:       | * :
5796:    ]
5796:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5800: OrdinalLow( Node theType ) >> int:
5802:    [ oNodeType( theType )
5809:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5812:       | nBooleanType :  >> 0
5817:       | nCharType :     >> 0
5822:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5834:       | * :             #eNotOrdinalType
5847:                         >> 0
5850:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5851: EmitValue( Node decl ):
5853:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5867: installBuiltIns:
      
         % install built-in types
5869:    FileType = @newType( nFileType, 4 )
5883:    IntegerType = @newType( nIntegerType, 4 )
5897:    BooleanType = @newType( nBooleanType, 1 )
5911:    BooleanCFType = @newType( nBooleanCFType, 1 )
5925:    CharType = @newType( nCharType, 1 )
5939:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5953:    Node t
      
5953:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5969:    oNodeSet( t, qType, FileType )
5981:    oScopeDeclare( t )
      
5987:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6003:    oNodeSet( t, qType, IntegerType )
6015:    oScopeDeclare( t )
      
6021:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6037:    oNodeSet( t, qType, BooleanType )
6049:    oScopeDeclare( t )
      
6055:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6071:    oNodeSet( t, qType, CharType )
6083:    oScopeDeclare( t )
      
6089:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6105:    oNodeSet( t, qType, StringType )
6117:    oScopeDeclare( t )
      
         % Built-in constants
      
6123:    t = @newIdent( nConst, kConst, oIdAdd_True )
6139:    oNodeSet( t, qType, BooleanType )
6151:    oNodeSetInt( t, qValue, 1 )
6163:    oScopeDeclare( t )
      
6169:    t = @newIdent( nConst, kConst, oIdAdd_False )
6185:    oNodeSet( t, qType, BooleanType )
6197:    oNodeSetInt( t, qValue, 0 )
6209:    oScopeDeclare( t )
      
6216:    ;
      
6216: end
      
6216: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5867
  12: oGetAddrLocal 2
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 41
  19: oGetLocal 2
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 43
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 3
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5688
  44: oPop 3
  46: oAssign
  47: oGetLocal 3
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 1
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5688
  70: oPop 3
  72: oAssign
  73: oGetLocal 1
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 1
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 1
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5688
 108: oPop 3
 110: oAssign
 111: oGetLocal 1
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 1
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 3
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 2
 170: oPushResult
 171: oCall 247
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 247
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 1209
 203: oJumpForward 239
 205: oCall 1281
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 1340
 214: oPop 1
 216: oJumpForward 239
 218: oCall 351
 220: oJumpForward 239
 222: oCall 636
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oCall 244
 243: oReturn
 244: oLocalSpace 0
 246: oReturn
 247: oLocalSpace 2
 249: oEmit 48
 251: oGetParam 1
 253: oPushResult
 254: oEmitLabel
 255: oPop 1
 257: oEmit 44
 259: oGetAddrLocal 1
 261: oPushResult
 262: Here
 263: oAssign
 264: oEmit 56
 266: oCall 4540
 268: oEmit 43
 270: oGetAddrLocal 2
 272: oPushResult
 273: oScopeCurrent
 274: oPushResult
 275: oSetResult 2
 277: oPushResult
 278: oNodeGetInt
 279: oPop 2
 281: oAssign
 282: oGetLocal 1
 284: oPushResult
 285: oGetLocal 2
 287: oPushResult
 288: oPatch
 289: oPop 2
 291: oReturn
 292: oLocalSpace 0
 294: oInputChoice 312
 296: oGetParam 1
 298: oPushResult
 299: oSetResult 12
 301: oPushResult
 302: oSetResult 1
 304: oPushResult
 305: oNodeSetBoolean
 306: oPop 3
 308: oInput 4
 310: oJumpForward 317
 312: Choice Lookup Table
          62    296
 315: oJumpForward 319
 317: oJumpBack 294
 319: oReturn
 320: oLocalSpace 0
 322: oGetParam 1
 324: oPushResult
 325: oSetResult 11
 327: oPushResult
 328: oSetResult 1
 330: oPushResult
 331: oNodeSetBoolean
 332: oPop 3
 334: oInputChoice 347
 336: oInputChoice 342
 338: oInput 2
 340: oJumpForward 345
 342: Choice Lookup Table
          61    338
 345: oJumpForward 350
 347: Choice Lookup Table
           2    336
 350: oReturn
 351: oLocalSpace 4
 353: oInput 0
 355: oGetAddrLocal 1
 357: oPushResult
 358: oSetResult 0
 360: oAssign
 361: oGetAddrLocal 2
 363: oPushResult
 364: oScopeFindInCurrentScope
 365: oAssign
 366: oGetLocal 2
 368: oPushResult
 369: oNodeNull
 370: oPop 1
 372: oChoice 493
 374: oGetAddrLocal 2
 376: oPushResult
 377: oSetResult 7
 379: oPushResult
 380: oSetResult 2
 382: oPushResult
 383: LAST_ID
 384: oPushResult
 385: oCall 5688
 387: oPop 3
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oSetResult 6
 395: oPushResult
 396: oLabelNew
 397: oPushResult
 398: oNodeSetLabel
 399: oPop 3
 401: oJumpForward 499
 403: oGetAddrLocal 1
 405: oPushResult
 406: oSetResult 1
 408: oAssign
 409: oGetLocal 2
 411: oPushResult
 412: oSetResult 10
 414: oPushResult
 415: oNodeGetBoolean
 416: oPop 2
 418: oChoice 424
 420: oError 21
 422: oJumpForward 427
 424: Choice Lookup Table
           1    420
 427: oGetLocal 2
 429: oPushResult
 430: oSetResult 11
 432: oPushResult
 433: oNodeGetBoolean
 434: oPop 2
 436: oChoice 442
 438: oError 21
 440: oJumpForward 445
 442: Choice Lookup Table
           1    438
 445: oGetLocal 2
 447: oPushResult
 448: oNodeType
 449: oPop 1
 451: oChoice 455
 453: oJumpForward 460
 455: Choice Lookup Table
           7    453
 458: oError 21
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 14
 465: oPushResult
 466: oGetLocal 2
 468: oPushResult
 469: oSetResult 8
 471: oPushResult
 472: oNodeGet
 473: oPop 2
 475: oPushResult
 476: oNodeSet
 477: oPop 3
 479: oGetLocal 2
 481: oPushResult
 482: oSetResult 8
 484: oPushResult
 485: oSetResult 0
 487: oPushResult
 488: oNodeSet
 489: oPop 3
 491: oJumpForward 499
 493: Choice Lookup Table
           0    403
           1    374
 498: oEndChoice
 499: oScopeBegin
 500: oGetAddrLocal 3
 502: oPushResult
 503: oScopeCurrent
 504: oAssign
 505: oCall 982
 507: oGetLocal 2
 509: oPushResult
 510: oSetResult 8
 512: oPushResult
 513: oGetLocal 3
 515: oPushResult
 516: oNodeSet
 517: oPop 3
 519: oScopeEnd
 520: oInput 4
 522: oGetLocal 1
 524: oChoice 536
 526: oGetLocal 2
 528: oPushResult
 529: oScopeDeclare
 530: oPop 1
 532: oJumpForward 542
 534: oJumpForward 542
 536: Choice Lookup Table
           1    534
           0    526
 541: oEndChoice
 542: oGetLocal 2
 544: oPushResult
 545: oCall 292
 547: oPop 1
 549: oInputChoice 562
 551: oJumpForward 633
 553: oGetLocal 2
 555: oPushResult
 556: oCall 320
 558: oPop 1
 560: oJumpForward 633
 562: Choice Lookup Table
          60    553
          59    551
 567: oGetLocal 3
 569: oPushResult
 570: oScopeEnter
 571: oPop 1
 573: oScopeBegin
 574: oScopeCurrent
 575: oPushResult
 576: oSetResult 3
 578: oPushResult
 579: oSetResult 1
 581: oPushResult
 582: oNodeSetBoolean
 583: oPop 3
 585: oGetLocal 2
 587: oPushResult
 588: oSetResult 9
 590: oPushResult
 591: oScopeCurrent
 592: oPushResult
 593: oNodeSet
 594: oPop 3
 596: oGetAddrLocal 4
 598: oPushResult
 599: oGetLocal 2
 601: oPushResult
 602: oSetResult 6
 604: oPushResult
 605: oNodeGetLabel
 606: oPop 2
 608: oAssign
 609: oSetResult 13
 611: oPushResult
 612: oGetLocal 4
 614: oPushResult
 615: oCall 180
 617: oPop 2
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 10
 624: oPushResult
 625: oSetResult 1
 627: oPushResult
 628: oNodeSetBoolean
 629: oPop 3
 631: oScopeEnd
 632: oScopeEnd
 633: oInput 4
 635: oReturn
 636: oLocalSpace 6
 638: oInput 0
 640: oGetAddrLocal 1
 642: oPushResult
 643: oSetResult 0
 645: oAssign
 646: oGetAddrLocal 2
 648: oPushResult
 649: oScopeFindInCurrentScope
 650: oAssign
 651: oGetLocal 2
 653: oPushResult
 654: oNodeNull
 655: oPop 1
 657: oChoice 791
 659: oGetAddrLocal 2
 661: oPushResult
 662: oSetResult 8
 664: oPushResult
 665: oSetResult 3
 667: oPushResult
 668: LAST_ID
 669: oPushResult
 670: oCall 5688
 672: oPop 3
 674: oAssign
 675: oGetLocal 2
 677: oPushResult
 678: oSetResult 6
 680: oPushResult
 681: oLabelNew
 682: oPushResult
 683: oNodeSetLabel
 684: oPop 3
 686: oJumpForward 797
 688: oGetAddrLocal 1
 690: oPushResult
 691: oSetResult 1
 693: oAssign
 694: oGetLocal 2
 696: oPushResult
 697: oSetResult 10
 699: oPushResult
 700: oNodeGetBoolean
 701: oPop 2
 703: oChoice 709
 705: oError 21
 707: oJumpForward 712
 709: Choice Lookup Table
           1    705
 712: oGetLocal 2
 714: oPushResult
 715: oNodeType
 716: oPop 1
 718: oChoice 722
 720: oJumpForward 727
 722: Choice Lookup Table
           8    720
 725: oError 21
 727: oGetLocal 2
 729: oPushResult
 730: oSetResult 14
 732: oPushResult
 733: oGetLocal 2
 735: oPushResult
 736: oSetResult 8
 738: oPushResult
 739: oNodeGet
 740: oPop 2
 742: oPushResult
 743: oNodeSet
 744: oPop 3
 746: oGetLocal 2
 748: oPushResult
 749: oSetResult 8
 751: oPushResult
 752: oSetResult 0
 754: oPushResult
 755: oNodeSet
 756: oPop 3
 758: oGetLocal 2
 760: oPushResult
 761: oSetResult 15
 763: oPushResult
 764: oGetLocal 2
 766: oPushResult
 767: oSetResult 5
 769: oPushResult
 770: oNodeGet
 771: oPop 2
 773: oPushResult
 774: oNodeSet
 775: oPop 3
 777: oGetLocal 2
 779: oPushResult
 780: oSetResult 5
 782: oPushResult
 783: oSetResult 0
 785: oPushResult
 786: oNodeSet
 787: oPop 3
 789: oJumpForward 797
 791: Choice Lookup Table
           0    688
           1    659
 796: oEndChoice
 797: oScopeBegin
 798: oGetAddrLocal 3
 800: oPushResult
 801: oScopeCurrent
 802: oAssign
 803: oCall 982
 805: oGetLocal 2
 807: oPushResult
 808: oSetResult 8
 810: oPushResult
 811: oGetLocal 3
 813: oPushResult
 814: oNodeSet
 815: oPop 3
 817: oInput 11
 819: oGetAddrLocal 4
 821: oPushResult
 822: oCall 1481
 824: oPop 1
 826: oGetLocal 2
 828: oPushResult
 829: oSetResult 5
 831: oPushResult
 832: oGetLocal 4
 834: oPushResult
 835: oNodeSet
 836: oPop 3
 838: oGetAddrLocal 5
 840: oPushResult
 841: oGetLocal 4
 843: oPushResult
 844: oCall 5716
 846: oPop 1
 848: oAssign
 849: oGetLocal 2
 851: oPushResult
 852: oSetResult 16
 854: oPushResult
 855: oGetLocal 5
 857: oPushResult
 858: oScopeAllocType
 859: oPop 1
 861: oPushResult
 862: oNodeSetInt
 863: oPop 3
 865: oScopeEnd
 866: oInput 4
 868: oGetLocal 1
 870: oChoice 882
 872: oGetLocal 2
 874: oPushResult
 875: oScopeDeclare
 876: oPop 1
 878: oJumpForward 888
 880: oJumpForward 888
 882: Choice Lookup Table
           1    880
           0    872
 887: oEndChoice
 888: oGetLocal 2
 890: oPushResult
 891: oCall 292
 893: oPop 1
 895: oInputChoice 908
 897: oJumpForward 979
 899: oGetLocal 2
 901: oPushResult
 902: oCall 320
 904: oPop 1
 906: oJumpForward 979
 908: Choice Lookup Table
          60    899
          59    897
 913: oGetLocal 3
 915: oPushResult
 916: oScopeEnter
 917: oPop 1
 919: oScopeBegin
 920: oScopeCurrent
 921: oPushResult
 922: oSetResult 3
 924: oPushResult
 925: oSetResult 1
 927: oPushResult
 928: oNodeSetBoolean
 929: oPop 3
 931: oGetLocal 2
 933: oPushResult
 934: oSetResult 9
 936: oPushResult
 937: oScopeCurrent
 938: oPushResult
 939: oNodeSet
 940: oPop 3
 942: oGetAddrLocal 6
 944: oPushResult
 945: oGetLocal 2
 947: oPushResult
 948: oSetResult 6
 950: oPushResult
 951: oNodeGetLabel
 952: oPop 2
 954: oAssign
 955: oSetResult 13
 957: oPushResult
 958: oGetLocal 6
 960: oPushResult
 961: oCall 180
 963: oPop 2
 965: oGetLocal 2
 967: oPushResult
 968: oSetResult 10
 970: oPushResult
 971: oSetResult 1
 973: oPushResult
 974: oNodeSetBoolean
 975: oPop 3
 977: oScopeEnd
 978: oScopeEnd
 979: oInput 4
 981: oReturn
 982: oLocalSpace 6
 984: oInputChoice 1205
 986: oGetAddrLocal 1
 988: oPushResult
 989: oNodeVecNew
 990: oAssign
 991: oGetAddrLocal 3
 993: oPushResult
 994: oSetResult 0
 996: oAssign
 997: oInputChoice 1007
 999: oGetAddrLocal 3
1001: oPushResult
1002: oSetResult 1
1004: oAssign
1005: oJumpForward 1010
1007: Choice Lookup Table
          32    999
1010: oInput 0
1012: oGetAddrLocal 2
1014: oPushResult
1015: oSetResult 15
1017: oPushResult
1018: oSetResult 6
1020: oPushResult
1021: LAST_ID
1022: oPushResult
1023: oCall 5688
1025: oPop 3
1027: oAssign
1028: oGetLocal 2
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oGetLocal 3
1036: oPushResult
1037: oNodeSetBoolean
1038: oPop 3
1040: oGetLocal 1
1042: oPushResult
1043: oGetLocal 2
1045: oPushResult
1046: oNodeVecAppend
1047: oPop 2
1049: oInputChoice 1057
1051: oJumpForward 1065
1053: oJumpForward 1063
1055: oJumpForward 1063
1057: Choice Lookup Table
          12   1055
          11   1051
1062: oEndChoice
1063: oJumpBack 1010
1065: oGetAddrLocal 4
1067: oPushResult
1068: oCall 1481
1070: oPop 1
1072: oGetLocal 3
1074: oChoice 1089
1076: oGetAddrLocal 5
1078: oPushResult
1079: oGetLocal 4
1081: oPushResult
1082: oCall 5716
1084: oPop 1
1086: oAssign
1087: oJumpForward 1098
1089: Choice Lookup Table
           1   1076
1092: oGetAddrLocal 5
1094: oPushResult
1095: oGetLocal 4
1097: oAssign
1098: oGetAddrLocal 6
1100: oPushResult
1101: oSetResult 0
1103: oAssign
1104: oGetLocal 6
1106: oPushResult
1107: oGetLocal 1
1109: oPushResult
1110: oNodeVecSize
1111: oPop 1
1113: oPushResult
1114: equal
1115: oPop 2
1117: oChoice 1174
1119: oGetAddrLocal 2
1121: oPushResult
1122: oGetLocal 1
1124: oPushResult
1125: oGetLocal 6
1127: oPushResult
1128: oNodeVecElement
1129: oPop 2
1131: oAssign
1132: oGetLocal 2
1134: oPushResult
1135: oSetResult 5
1137: oPushResult
1138: oGetLocal 4
1140: oPushResult
1141: oNodeSet
1142: oPop 3
1144: oGetLocal 2
1146: oPushResult
1147: oScopeDeclare
1148: oPop 1
1150: oGetLocal 2
1152: oPushResult
1153: oSetResult 6
1155: oPushResult
1156: oGetLocal 5
1158: oPushResult
1159: oScopeAllocType
1160: oPop 1
1162: oPushResult
1163: oNodeSetInt
1164: oPop 3
1166: oGetAddrLocal 6
1168: oPushResult
1169: inc
1170: oPop 1
1172: oJumpForward 1179
1174: Choice Lookup Table
           0   1119
1177: oJumpForward 1181
1179: oJumpBack 1104
1181: oGetLocal 1
1183: oPushResult
1184: oNodeVecDelete
1185: oPop 1
1187: oInputChoice 1195
1189: oJumpForward 1203
1191: oJumpForward 1201
1193: oJumpForward 1201
1195: Choice Lookup Table
           4   1193
          14   1189
1200: oEndChoice
1201: oJumpBack 986
1203: oJumpForward 1208
1205: Choice Lookup Table
          13    986
1208: oReturn
1209: oLocalSpace 2
1211: oInputChoice 1273
1213: oGetAddrLocal 1
1215: oPushResult
1216: oSetResult 9
1218: oPushResult
1219: oSetResult 4
1221: oPushResult
1222: LAST_ID
1223: oPushResult
1224: oCall 5688
1226: oPop 3
1228: oAssign
1229: oInput 5
1231: oCall 1950
1233: oGetAddrLocal 2
1235: oPushResult
1236: oValueTop
1237: oAssign
1238: oValuePop
1239: oGetLocal 1
1241: oPushResult
1242: oSetResult 6
1244: oPushResult
1245: oGetLocal 2
1247: oPushResult
1248: oNodeSetInt
1249: oPop 3
1251: oGetLocal 1
1253: oPushResult
1254: oSetResult 5
1256: oPushResult
1257: oGetGlobal 3
1259: oPushResult
1260: oNodeSet
1261: oPop 3
1263: oGetLocal 1
1265: oPushResult
1266: oScopeDeclare
1267: oPop 1
1269: oInput 4
1271: oJumpForward 1278
1273: Choice Lookup Table
           0   1213
1276: oJumpForward 1280
1278: oJumpBack 1211
1280: oReturn
1281: oLocalSpace 2
1283: oInputChoice 1332
1285: oGetAddrLocal 1
1287: oPushResult
1288: oSetResult 10
1290: oPushResult
1291: oSetResult 5
1293: oPushResult
1294: LAST_ID
1295: oPushResult
1296: oCall 5688
1298: oPop 3
1300: oAssign
1301: oInput 5
1303: oGetAddrLocal 2
1305: oPushResult
1306: oCall 1481
1308: oPop 1
1310: oGetLocal 1
1312: oPushResult
1313: oSetResult 5
1315: oPushResult
1316: oGetLocal 2
1318: oPushResult
1319: oNodeSet
1320: oPop 3
1322: oGetLocal 1
1324: oPushResult
1325: oScopeDeclare
1326: oPop 1
1328: oInput 4
1330: oJumpForward 1337
1332: Choice Lookup Table
           0   1285
1335: oJumpForward 1339
1337: oJumpBack 1283
1339: oReturn
1340: oLocalSpace 4
1342: oInputChoice 1473
1344: oGetAddrLocal 1
1346: oPushResult
1347: oNodeVecNew
1348: oAssign
1349: oGetAddrLocal 2
1351: oPushResult
1352: oGetParam 1
1354: oPushResult
1355: oSetResult 6
1357: oPushResult
1358: LAST_ID
1359: oPushResult
1360: oCall 5688
1362: oPop 3
1364: oAssign
1365: oGetLocal 1
1367: oPushResult
1368: oGetLocal 2
1370: oPushResult
1371: oNodeVecAppend
1372: oPop 2
1374: oInputChoice 1380
1376: oInput 0
1378: oJumpForward 1385
1380: Choice Lookup Table
          12   1376
1383: oJumpForward 1387
1385: oJumpBack 1349
1387: oInput 11
1389: oGetAddrLocal 3
1391: oPushResult
1392: oCall 1481
1394: oPop 1
1396: oGetAddrLocal 4
1398: oPushResult
1399: oSetResult 0
1401: oAssign
1402: oGetLocal 4
1404: oPushResult
1405: oGetLocal 1
1407: oPushResult
1408: oNodeVecSize
1409: oPop 1
1411: oPushResult
1412: equal
1413: oPop 2
1415: oChoice 1456
1417: oGetAddrLocal 2
1419: oPushResult
1420: oGetLocal 1
1422: oPushResult
1423: oGetLocal 4
1425: oPushResult
1426: oNodeVecElement
1427: oPop 2
1429: oAssign
1430: oGetLocal 2
1432: oPushResult
1433: oSetResult 5
1435: oPushResult
1436: oGetLocal 3
1438: oPushResult
1439: oNodeSet
1440: oPop 3
1442: oGetLocal 2
1444: oPushResult
1445: oScopeDeclareAlloc
1446: oPop 1
1448: oGetAddrLocal 4
1450: oPushResult
1451: inc
1452: oPop 1
1454: oJumpForward 1461
1456: Choice Lookup Table
           0   1417
1459: oJumpForward 1463
1461: oJumpBack 1402
1463: oGetLocal 1
1465: oPushResult
1466: oNodeVecDelete
1467: oPop 1
1469: oInput 4
1471: oJumpForward 1478
1473: Choice Lookup Table
           0   1344
1476: oJumpForward 1480
1478: oJumpBack 1342
1480: oReturn
1481: oLocalSpace 12
1483: oInputChoice 1932
1485: oGetAddrLocal 1
1487: oPushResult
1488: oScopeFindRequire
1489: oAssign
1490: oGetLocal 1
1492: oPushResult
1493: oNodeType
1494: oPop 1
1496: oChoice 1513
1498: oGetParam 1
1500: oPushResult
1501: oGetLocal 1
1503: oPushResult
1504: oSetResult 5
1506: oPushResult
1507: oNodeGet
1508: oPop 2
1510: oAssign
1511: oJumpForward 1524
1513: Choice Lookup Table
          10   1498
1516: oError 2
1518: oGetParam 1
1520: oPushResult
1521: oGetGlobal 3
1523: oAssign
1524: oJumpForward 1949
1526: oInput 15
1528: oGetAddrLocal 2
1530: oPushResult
1531: oNodeVecNew
1532: oAssign
1533: oGetAddrLocal 3
1535: oPushResult
1536: oSetResult 25
1538: oPushResult
1539: oNodeNew
1540: oPop 1
1542: oAssign
1543: oGetLocal 3
1545: oPushResult
1546: oSetResult 19
1548: oPushResult
1549: oGetGlobal 3
1551: oPushResult
1552: oNodeSet
1553: oPop 3
1555: oCall 1950
1557: oGetLocal 3
1559: oPushResult
1560: oSetResult 21
1562: oPushResult
1563: oValueTop
1564: oPushResult
1565: oNodeSetInt
1566: oPop 3
1568: oValuePop
1569: oInput 20
1571: oCall 1950
1573: oGetLocal 3
1575: oPushResult
1576: oSetResult 22
1578: oPushResult
1579: oValueTop
1580: oPushResult
1581: oNodeSetInt
1582: oPop 3
1584: oValuePop
1585: oGetLocal 3
1587: oPushResult
1588: oSetResult 2
1590: oPushResult
1591: oSetResult 4
1593: oPushResult
1594: oNodeSetInt
1595: oPop 3
1597: oGetLocal 3
1599: oPushResult
1600: oTypeAdd
1601: oPop 1
1603: oGetAddrLocal 4
1605: oPushResult
1606: oSetResult 24
1608: oPushResult
1609: oNodeNew
1610: oPop 1
1612: oAssign
1613: oGetLocal 4
1615: oPushResult
1616: oSetResult 20
1618: oPushResult
1619: oGetLocal 3
1621: oPushResult
1622: oNodeSet
1623: oPop 3
1625: oGetLocal 2
1627: oPushResult
1628: oGetLocal 4
1630: oPushResult
1631: oNodeVecAppend
1632: oPop 2
1634: oInputChoice 1642
1636: oJumpForward 1650
1638: oJumpForward 1648
1640: oJumpForward 1648
1642: Choice Lookup Table
          12   1640
          16   1636
1647: oEndChoice
1648: oJumpBack 1533
1650: oInput 38
1652: oGetAddrLocal 5
1654: oPushResult
1655: oCall 1481
1657: oPop 1
1659: oGetAddrLocal 6
1661: oPushResult
1662: oGetLocal 2
1664: oPushResult
1665: oNodeVecSize
1666: oPop 1
1668: oAssign
1669: oGetAddrLocal 6
1671: oPushResult
1672: dec
1673: oPop 1
1675: oGetAddrLocal 7
1677: oPushResult
1678: oGetLocal 2
1680: oPushResult
1681: oGetLocal 6
1683: oPushResult
1684: oNodeVecElement
1685: oPop 2
1687: oAssign
1688: oGetLocal 7
1690: oPushResult
1691: oSetResult 19
1693: oPushResult
1694: oGetLocal 5
1696: oPushResult
1697: oNodeSet
1698: oPop 3
1700: oGetAddrLocal 8
1702: oPushResult
1703: oGetLocal 7
1705: oPushResult
1706: oSetResult 20
1708: oPushResult
1709: oNodeGet
1710: oPop 2
1712: oAssign
1713: oGetAddrLocal 9
1715: oPushResult
1716: oGetLocal 8
1718: oPushResult
1719: oSetResult 22
1721: oPushResult
1722: oNodeGetInt
1723: oPop 2
1725: oPushResult
1726: oGetLocal 8
1728: oPushResult
1729: oSetResult 21
1731: oPushResult
1732: oNodeGetInt
1733: oPop 2
1735: oPushResult
1736: subtract
1737: oPop 2
1739: oAssign
1740: oGetAddrLocal 9
1742: oPushResult
1743: inc
1744: oPop 1
1746: oGetLocal 7
1748: oPushResult
1749: oSetResult 2
1751: oPushResult
1752: oGetLocal 9
1754: oPushResult
1755: oGetLocal 5
1757: oPushResult
1758: oSetResult 2
1760: oPushResult
1761: oNodeGetInt
1762: oPop 2
1764: oPushResult
1765: multiply
1766: oPop 2
1768: oPushResult
1769: oNodeSetInt
1770: oPop 3
1772: oGetLocal 7
1774: oPushResult
1775: oTypeAdd
1776: oPop 1
1778: oGetAddrLocal 5
1780: oPushResult
1781: oGetLocal 7
1783: oAssign
1784: oGetLocal 6
1786: oPushResult
1787: equal_zero
1788: oPop 1
1790: oChoice 1796
1792: oJumpForward 1801
1794: oJumpForward 1799
1796: Choice Lookup Table
           1   1792
1799: oJumpBack 1669
1801: oGetParam 1
1803: oPushResult
1804: oGetLocal 2
1806: oPushResult
1807: oSetResult 0
1809: oPushResult
1810: oNodeVecElement
1811: oPop 2
1813: oAssign
1814: oGetLocal 2
1816: oPushResult
1817: oNodeVecDelete
1818: oPop 1
1820: oJumpForward 1949
1822: oGetAddrLocal 10
1824: oPushResult
1825: oCall 1481
1827: oPop 1
1829: oGetParam 1
1831: oPushResult
1832: oGetLocal 10
1834: oPushResult
1835: oCall 5716
1837: oPop 1
1839: oAssign
1840: oJumpForward 1949
1842: oGetParam 1
1844: oPushResult
1845: oSetResult 26
1847: oPushResult
1848: oNodeNew
1849: oPop 1
1851: oAssign
1852: oScopeBegin
1853: oSetResult 14
1855: oPushResult
1856: oCall 1340
1858: oPop 1
1860: oGetAddrLocal 11
1862: oPushResult
1863: oScopeCurrent
1864: oPushResult
1865: oSetResult 2
1867: oPushResult
1868: oNodeGetInt
1869: oPop 2
1871: oAssign
1872: oGetLocal 11
1874: oPushResult
1875: equal_zero
1876: oPop 1
1878: oChoice 1884
1880: oError 19
1882: oJumpForward 1887
1884: Choice Lookup Table
           1   1880
1887: oInput 34
1889: oGetFromParam 1
1891: oPushResult
1892: oSetResult 23
1894: oPushResult
1895: oScopeCurrent
1896: oPushResult
1897: oNodeSet
1898: oPop 3
1900: oGetFromParam 1
1902: oPushResult
1903: oSetResult 2
1905: oPushResult
1906: oGetLocal 11
1908: oPushResult
1909: oNodeSetInt
1910: oPop 3
1912: oScopeEnd
1913: oGetFromParam 1
1915: oPushResult
1916: oTypeAdd
1917: oPop 1
1919: oJumpForward 1949
1921: oInput 38
1923: oGetAddrLocal 12
1925: oPushResult
1926: oCall 1481
1928: oPop 1
1930: oJumpForward 1949
1932: Choice Lookup Table
          37   1921
          36   1842
          17   1822
          35   1526
           0   1485
1943: oCall 1950
1945: oInput 20
1947: oCall 1950
1949: oReturn
1950: oLocalSpace 1
1952: oInputChoice 2007
1954: TOKEN_VALUE
1955: oPushResult
1956: oValuePush
1957: oPop 1
1959: oJumpForward 2015
1961: oGetAddrLocal 1
1963: oPushResult
1964: oScopeFindRequire
1965: oAssign
1966: oGetLocal 1
1968: oPushResult
1969: oNodeType
1970: oPop 1
1972: oChoice 1989
1974: oGetLocal 1
1976: oPushResult
1977: oSetResult 6
1979: oPushResult
1980: oNodeGetInt
1981: oPop 2
1983: oPushResult
1984: oValuePush
1985: oPop 1
1987: oJumpForward 2000
1989: Choice Lookup Table
           9   1974
1992: oError 1
1994: oSetResult 0
1996: oPushResult
1997: oValuePush
1998: oPop 1
2000: oJumpForward 2015
2002: oCall 1950
2004: oValueNegate
2005: oJumpForward 2015
2007: Choice Lookup Table
          24   2002
           0   1961
           1   1954
2014: oEndChoice
2015: oReturn
2016: oLocalSpace 1
2018: oGetAddrLocal 1
2020: oPushResult
2021: oSetResult 0
2023: oAssign
2024: oGetAddrLocal 1
2026: oPushResult
2027: oCall 2177
2029: oPop 1
2031: oGetAddrLocal 1
2033: oPushResult
2034: oCall 2077
2036: oPop 1
2038: oReturn
2039: oLocalSpace 0
2041: oGetParam 1
2043: oPushResult
2044: oCall 2177
2046: oPop 1
2048: oTypeSNodeType
2049: oChoice 2068
2051: oJumpForward 2075
2053: oGetParam 1
2055: oPushResult
2056: oLabelNew
2057: oAssign
2058: oEmit 47
2060: oGetFromParam 1
2062: oPushResult
2063: oEmitLabel
2064: oPop 1
2066: oJumpForward 2075
2068: Choice Lookup Table
          19   2053
          20   2051
2073: oError 8
2075: oTypeSPop
2076: oReturn
2077: oLocalSpace 1
2079: oTypeSNodeType
2080: oChoice 2142
2082: oGetAddrLocal 1
2084: oPushResult
2085: oLabelNew
2086: oAssign
2087: oEmit 9
2089: oSetResult 1
2091: oPushResult
2092: oEmitInt
2093: oPop 1
2095: oEmit 45
2097: oGetLocal 1
2099: oPushResult
2100: oEmitLabel
2101: oPop 1
2103: oEmit 48
2105: oGetFromParam 1
2107: oPushResult
2108: oEmitLabel
2109: oPop 1
2111: oEmit 9
2113: oSetResult 0
2115: oPushResult
2116: oEmitInt
2117: oPop 1
2119: oEmit 48
2121: oGetLocal 1
2123: oPushResult
2124: oEmitLabel
2125: oPop 1
2127: oTypeSPop
2128: oGetGlobal 4
2130: oPushResult
2131: oTypeSPush
2132: oPop 1
2134: oGetParam 1
2136: oPushResult
2137: oSetResult 0
2139: oAssign
2140: oJumpForward 2145
2142: Choice Lookup Table
          20   2082
2145: oReturn
2146: oLocalSpace 0
2148: oTypeSNodeType
2149: oChoice 2173
2151: oGetParam 1
2153: oPushResult
2154: oLabelNew
2155: oAssign
2156: oEmit 47
2158: oGetFromParam 1
2160: oPushResult
2161: oEmitLabel
2162: oPop 1
2164: oTypeSPop
2165: oGetGlobal 5
2167: oPushResult
2168: oTypeSPush
2169: oPop 1
2171: oJumpForward 2176
2173: Choice Lookup Table
          19   2151
2176: oReturn
2177: oLocalSpace 0
2179: oGetParam 1
2181: oPushResult
2182: oCall 2542
2184: oPop 1
2186: oInputChoice 2524
2188: oGetParam 1
2190: oPushResult
2191: oCall 2077
2193: oPop 1
2195: oGetParam 1
2197: oPushResult
2198: oCall 2542
2200: oPop 1
2202: oGetParam 1
2204: oPushResult
2205: oCall 2077
2207: oPop 1
2209: oCall 5574
2211: oTypeSNodeType
2212: oChoice 2226
2214: oEmit 30
2216: oJumpForward 2239
2218: oEmit 36
2220: oJumpForward 2239
2222: oError 16
2224: oJumpForward 2239
2226: Choice Lookup Table
          22   2222
          21   2222
          23   2218
          19   2214
          18   2214
2237: oError 17
2239: oTypeSPop
2240: oGetGlobal 4
2242: oPushResult
2243: oTypeSPush
2244: oPop 1
2246: oJumpForward 2539
2248: oGetParam 1
2250: oPushResult
2251: oCall 2077
2253: oPop 1
2255: oGetParam 1
2257: oPushResult
2258: oCall 2542
2260: oPop 1
2262: oGetParam 1
2264: oPushResult
2265: oCall 2077
2267: oPop 1
2269: oCall 5574
2271: oTypeSNodeType
2272: oChoice 2286
2274: oEmit 31
2276: oJumpForward 2299
2278: oEmit 37
2280: oJumpForward 2299
2282: oError 16
2284: oJumpForward 2299
2286: Choice Lookup Table
          22   2282
          21   2282
          23   2278
          19   2274
          18   2274
2297: oError 17
2299: oTypeSPop
2300: oGetGlobal 4
2302: oPushResult
2303: oTypeSPush
2304: oPop 1
2306: oJumpForward 2539
2308: oGetParam 1
2310: oPushResult
2311: oCall 2077
2313: oPop 1
2315: oGetParam 1
2317: oPushResult
2318: oCall 2542
2320: oPop 1
2322: oGetParam 1
2324: oPushResult
2325: oCall 2077
2327: oPop 1
2329: oCall 5574
2331: oTypeSNodeType
2332: oChoice 2342
2334: oEmit 33
2336: oJumpForward 2353
2338: oError 16
2340: oJumpForward 2353
2342: Choice Lookup Table
          22   2338
          21   2338
          19   2334
          18   2334
2351: oError 17
2353: oTypeSPop
2354: oGetGlobal 4
2356: oPushResult
2357: oTypeSPush
2358: oPop 1
2360: oJumpForward 2539
2362: oGetParam 1
2364: oPushResult
2365: oCall 2077
2367: oPop 1
2369: oGetParam 1
2371: oPushResult
2372: oCall 2542
2374: oPop 1
2376: oGetParam 1
2378: oPushResult
2379: oCall 2077
2381: oPop 1
2383: oCall 5574
2385: oTypeSNodeType
2386: oChoice 2396
2388: oEmit 32
2390: oJumpForward 2407
2392: oError 16
2394: oJumpForward 2407
2396: Choice Lookup Table
          22   2392
          21   2392
          19   2388
          18   2388
2405: oError 17
2407: oTypeSPop
2408: oGetGlobal 4
2410: oPushResult
2411: oTypeSPush
2412: oPop 1
2414: oJumpForward 2539
2416: oGetParam 1
2418: oPushResult
2419: oCall 2077
2421: oPop 1
2423: oGetParam 1
2425: oPushResult
2426: oCall 2542
2428: oPop 1
2430: oGetParam 1
2432: oPushResult
2433: oCall 2077
2435: oPop 1
2437: oCall 5574
2439: oTypeSNodeType
2440: oChoice 2450
2442: oEmit 35
2444: oJumpForward 2461
2446: oError 16
2448: oJumpForward 2461
2450: Choice Lookup Table
          22   2446
          21   2446
          19   2442
          18   2442
2459: oError 17
2461: oTypeSPop
2462: oGetGlobal 4
2464: oPushResult
2465: oTypeSPush
2466: oPop 1
2468: oJumpForward 2539
2470: oGetParam 1
2472: oPushResult
2473: oCall 2077
2475: oPop 1
2477: oGetParam 1
2479: oPushResult
2480: oCall 2542
2482: oPop 1
2484: oGetParam 1
2486: oPushResult
2487: oCall 2077
2489: oPop 1
2491: oCall 5574
2493: oTypeSNodeType
2494: oChoice 2504
2496: oEmit 34
2498: oJumpForward 2515
2500: oError 16
2502: oJumpForward 2515
2504: Choice Lookup Table
          22   2500
          21   2500
          19   2496
          18   2496
2513: oError 17
2515: oTypeSPop
2516: oGetGlobal 4
2518: oPushResult
2519: oTypeSPush
2520: oPop 1
2522: oJumpForward 2539
2524: Choice Lookup Table
          10   2470
           9   2416
           8   2362
           7   2308
           6   2248
           5   2188
2537: oJumpForward 2541
2539: oJumpBack 2186
2541: oReturn
2542: oLocalSpace 1
2544: oGetAddrLocal 1
2546: oPushResult
2547: oSetResult 0
2549: oAssign
2550: oGetParam 1
2552: oPushResult
2553: oCall 2722
2555: oPop 1
2557: oInputChoice 2690
2559: oTypeSNodeType
2560: oChoice 2631
2562: oGetLocal 1
2564: oPushResult
2565: oSetResult 0
2567: oPushResult
2568: equal_label
2569: oPop 2
2571: oChoice 2580
2573: oGetAddrLocal 1
2575: oPushResult
2576: oLabelNew
2577: oAssign
2578: oJumpForward 2583
2580: Choice Lookup Table
           1   2573
2583: oEmit 45
2585: oGetLocal 1
2587: oPushResult
2588: oEmitLabel
2589: oPop 1
2591: oJumpForward 2638
2593: oGetParam 1
2595: oPushResult
2596: oCall 2146
2598: oPop 1
2600: oGetLocal 1
2602: oPushResult
2603: oSetResult 0
2605: oPushResult
2606: equal_label
2607: oPop 2
2609: oChoice 2618
2611: oGetAddrLocal 1
2613: oPushResult
2614: oLabelNew
2615: oAssign
2616: oJumpForward 2621
2618: Choice Lookup Table
           1   2611
2621: oEmit 46
2623: oGetLocal 1
2625: oPushResult
2626: oEmitLabel
2627: oPop 1
2629: oJumpForward 2638
2631: Choice Lookup Table
          19   2593
          20   2562
2636: oError 8
2638: oTypeSPop
2639: oEmit 48
2641: oGetFromParam 1
2643: oPushResult
2644: oEmitLabel
2645: oPop 1
2647: oGetParam 1
2649: oPushResult
2650: oSetResult 0
2652: oAssign
2653: oGetParam 1
2655: oPushResult
2656: oCall 2722
2658: oPop 1
2660: oTypeSNodeType
2661: oChoice 2674
2663: oJumpForward 2681
2665: oGetParam 1
2667: oPushResult
2668: oCall 2146
2670: oPop 1
2672: oJumpForward 2681
2674: Choice Lookup Table
          19   2665
          20   2663
2679: oError 8
2681: oTypeSPop
2682: oGetGlobal 5
2684: oPushResult
2685: oTypeSPush
2686: oPop 1
2688: oJumpForward 2695
2690: Choice Lookup Table
          53   2559
2693: oJumpForward 2697
2695: oJumpBack 2557
2697: oGetLocal 1
2699: oPushResult
2700: oSetResult 0
2702: oPushResult
2703: equal_label
2704: oPop 2
2706: oChoice 2718
2708: oEmit 48
2710: oGetLocal 1
2712: oPushResult
2713: oEmitLabel
2714: oPop 1
2716: oJumpForward 2721
2718: Choice Lookup Table
           0   2708
2721: oReturn
2722: oLocalSpace 2
2724: oGetAddrLocal 1
2726: oPushResult
2727: oSetResult 0
2729: oAssign
2730: oGetParam 1
2732: oPushResult
2733: oCall 2860
2735: oPop 1
2737: oInputChoice 2852
2739: oTypeSNodeType
2740: oChoice 2753
2742: oJumpForward 2760
2744: oGetParam 1
2746: oPushResult
2747: oCall 2146
2749: oPop 1
2751: oJumpForward 2760
2753: Choice Lookup Table
          19   2744
          20   2742
2758: oError 8
2760: oTypeSPop
2761: oGetLocal 1
2763: oPushResult
2764: oSetResult 0
2766: oPushResult
2767: equal_label
2768: oPop 2
2770: oChoice 2799
2772: oGetAddrLocal 1
2774: oPushResult
2775: oLabelNew
2776: oAssign
2777: oEmit 49
2779: oGetFromParam 1
2781: oPushResult
2782: oEmitLabel
2783: oPop 1
2785: oGetLocal 1
2787: oPushResult
2788: oEmitLabel
2789: oPop 1
2791: oGetParam 1
2793: oPushResult
2794: oGetLocal 1
2796: oAssign
2797: oJumpForward 2802
2799: Choice Lookup Table
           1   2772
2802: oGetAddrLocal 2
2804: oPushResult
2805: oSetResult 0
2807: oAssign
2808: oGetAddrLocal 2
2810: oPushResult
2811: oCall 2860
2813: oPop 1
2815: oTypeSNodeType
2816: oChoice 2829
2818: oJumpForward 2836
2820: oGetAddrLocal 2
2822: oPushResult
2823: oCall 2146
2825: oPop 1
2827: oJumpForward 2836
2829: Choice Lookup Table
          19   2820
          20   2818
2834: oError 8
2836: oEmit 49
2838: oGetLocal 2
2840: oPushResult
2841: oEmitLabel
2842: oPop 1
2844: oGetLocal 1
2846: oPushResult
2847: oEmitLabel
2848: oPop 1
2850: oJumpForward 2857
2852: Choice Lookup Table
          52   2739
2855: oJumpForward 2859
2857: oJumpBack 2737
2859: oReturn
2860: oLocalSpace 1
2862: oInputChoice 2916
2864: oGetAddrLocal 1
2866: oPushResult
2867: oSetResult 0
2869: oAssign
2870: oGetAddrLocal 1
2872: oPushResult
2873: oCall 2860
2875: oPop 1
2877: oTypeSNodeType
2878: oChoice 2907
2880: oGetParam 1
2882: oPushResult
2883: oLabelNew
2884: oAssign
2885: oEmit 45
2887: oGetFromParam 1
2889: oPushResult
2890: oEmitLabel
2891: oPop 1
2893: oEmit 48
2895: oGetLocal 1
2897: oPushResult
2898: oEmitLabel
2899: oPop 1
2901: oJumpForward 2914
2903: oEmit 29
2905: oJumpForward 2914
2907: Choice Lookup Table
          19   2903
          20   2880
2912: oError 8
2914: oJumpForward 2926
2916: Choice Lookup Table
          54   2864
2919: oGetParam 1
2921: oPushResult
2922: oCall 2927
2924: oPop 1
2926: oReturn
2927: oLocalSpace 0
2929: oGetParam 1
2931: oPushResult
2932: oCall 2978
2934: oPop 1
2936: oInputChoice 2968
2938: oCall 5600
2940: oGetParam 1
2942: oPushResult
2943: oCall 2978
2945: oPop 1
2947: oCall 5614
2949: oEmit 26
2951: oJumpForward 2975
2953: oCall 5600
2955: oGetParam 1
2957: oPushResult
2958: oCall 2978
2960: oPop 1
2962: oCall 5614
2964: oEmit 27
2966: oJumpForward 2975
2968: Choice Lookup Table
          24   2953
          23   2938
2973: oJumpForward 2977
2975: oJumpBack 2936
2977: oReturn
2978: oLocalSpace 0
2980: oGetParam 1
2982: oPushResult
2983: oCall 3029
2985: oPop 1
2987: oInputChoice 3019
2989: oCall 5600
2991: oGetParam 1
2993: oPushResult
2994: oCall 3029
2996: oPop 1
2998: oCall 5614
3000: oEmit 23
3002: oJumpForward 3026
3004: oCall 5600
3006: oGetParam 1
3008: oPushResult
3009: oCall 3029
3011: oPop 1
3013: oCall 5614
3015: oEmit 24
3017: oJumpForward 3026
3019: Choice Lookup Table
          22   3004
          21   2989
3024: oJumpForward 3028
3026: oJumpBack 2987
3028: oReturn
3029: oLocalSpace 0
3031: oInputChoice 3057
3033: oGetParam 1
3035: oPushResult
3036: oCall 3070
3038: oPop 1
3040: oCall 5614
3042: oJumpForward 3069
3044: oGetParam 1
3046: oPushResult
3047: oCall 3070
3049: oPop 1
3051: oCall 5614
3053: oEmit 28
3055: oJumpForward 3069
3057: Choice Lookup Table
          24   3044
          23   3033
3062: oGetParam 1
3064: oPushResult
3065: oCall 3070
3067: oPop 1
3069: oReturn
3070: oLocalSpace 6
3072: oInputChoice 3254
3074: oEmit 9
3076: TOKEN_VALUE
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oGetGlobal 3
3083: oPushResult
3084: oTypeSPush
3085: oPop 1
3087: oJumpForward 3273
3089: oGetParam 1
3091: oPushResult
3092: oCall 2177
3094: oPop 1
3096: oInput 14
3098: oJumpForward 3273
3100: oGetAddrLocal 1
3102: oPushResult
3103: oStringAllocLit
3104: oAssign
3105: oEmit 10
3107: oGetLocal 1
3109: oPushResult
3110: oEmitInt
3111: oPop 1
3113: oGetGlobal 7
3115: oPushResult
3116: oTypeSPush
3117: oPop 1
3119: oJumpForward 3273
3121: oGetAddrLocal 2
3123: oPushResult
3124: oScopeFindRequire
3125: oAssign
3126: oGetLocal 2
3128: oPushResult
3129: oNodeType
3130: oPop 1
3132: oChoice 3194
3134: oGetLocal 2
3136: oPushResult
3137: oCall 3996
3139: oPop 1
3141: oJumpForward 3213
3143: oGetAddrLocal 3
3145: oPushResult
3146: oGetLocal 2
3148: oPushResult
3149: oSetResult 5
3151: oPushResult
3152: oNodeGet
3153: oPop 2
3155: oAssign
3156: oGetLocal 3
3158: oPushResult
3159: oTypeSPush
3160: oPop 1
3162: oTypeSNodeType
3163: oChoice 3176
3165: oEmit 9
3167: oGetLocal 2
3169: oPushResult
3170: oCall 5851
3172: oPop 1
3174: oJumpForward 3183
3176: Choice Lookup Table
          19   3165
          18   3165
3181: oError 16
3183: oJumpForward 3213
3185: oGetLocal 2
3187: oPushResult
3188: oCall 3274
3190: oPop 1
3192: oJumpForward 3213
3194: Choice Lookup Table
          15   3185
          13   3185
          12   3185
           9   3143
           8   3134
3205: oError 6
3207: oGetGlobal 3
3209: oPushResult
3210: oTypeSPush
3211: oPop 1
3213: oJumpForward 3273
3215: oInput 0
3217: oGetAddrLocal 4
3219: oPushResult
3220: oScopeFindRequire
3221: oAssign
3222: oGetLocal 4
3224: oPushResult
3225: oCall 4893
3227: oPop 1
3229: oGetAddrLocal 5
3231: oPushResult
3232: oTypeSTop
3233: oAssign
3234: oTypeSPop
3235: oGetAddrLocal 6
3237: oPushResult
3238: oGetLocal 5
3240: oPushResult
3241: oCall 5716
3243: oPop 1
3245: oAssign
3246: oGetLocal 6
3248: oPushResult
3249: oTypeSPush
3250: oPop 1
3252: oJumpForward 3273
3254: Choice Lookup Table
          18   3215
           0   3121
           2   3100
          13   3089
           1   3074
3265: oError 6
3267: oGetGlobal 3
3269: oPushResult
3270: oTypeSPush
3271: oPop 1
3273: oReturn
3274: oLocalSpace 1
3276: oGetAddrLocal 1
3278: oPushResult
3279: oGetParam 1
3281: oPushResult
3282: oSetResult 5
3284: oPushResult
3285: oNodeGet
3286: oPop 2
3288: oAssign
3289: oGetLocal 1
3291: oPushResult
3292: oTypeSPush
3293: oPop 1
3295: oTypeSNodeType
3296: oChoice 3561
3298: oGetParam 1
3300: oPushResult
3301: oNodeType
3302: oPop 1
3304: oChoice 3366
3306: oEmit 0
3308: oGetParam 1
3310: oPushResult
3311: oCall 5851
3313: oPop 1
3315: oJumpForward 3374
3317: oEmit 3
3319: oGetParam 1
3321: oPushResult
3322: oCall 5851
3324: oPop 1
3326: oJumpForward 3374
3328: oGetParam 1
3330: oPushResult
3331: oSetResult 17
3333: oPushResult
3334: oNodeGetBoolean
3335: oPop 2
3337: oChoice 3352
3339: oEmit 8
3341: oGetParam 1
3343: oPushResult
3344: oCall 5851
3346: oPop 1
3348: oEmit 14
3350: oJumpForward 3364
3352: Choice Lookup Table
           1   3339
3355: oEmit 6
3357: oGetParam 1
3359: oPushResult
3360: oCall 5851
3362: oPop 1
3364: oJumpForward 3374
3366: Choice Lookup Table
          15   3328
          13   3317
          12   3306
3373: oEndChoice
3374: oJumpForward 3652
3376: oGetParam 1
3378: oPushResult
3379: oNodeType
3380: oPop 1
3382: oChoice 3444
3384: oEmit 1
3386: oGetParam 1
3388: oPushResult
3389: oCall 5851
3391: oPop 1
3393: oJumpForward 3452
3395: oEmit 4
3397: oGetParam 1
3399: oPushResult
3400: oCall 5851
3402: oPop 1
3404: oJumpForward 3452
3406: oGetParam 1
3408: oPushResult
3409: oSetResult 17
3411: oPushResult
3412: oNodeGetBoolean
3413: oPop 2
3415: oChoice 3430
3417: oEmit 8
3419: oGetParam 1
3421: oPushResult
3422: oCall 5851
3424: oPop 1
3426: oEmit 15
3428: oJumpForward 3442
3430: Choice Lookup Table
           1   3417
3433: oEmit 7
3435: oGetParam 1
3437: oPushResult
3438: oCall 5851
3440: oPop 1
3442: oJumpForward 3452
3444: Choice Lookup Table
          15   3406
          13   3395
          12   3384
3451: oEndChoice
3452: oJumpForward 3652
3454: oError 16
3456: oJumpForward 3652
3458: oGetParam 1
3460: oPushResult
3461: oNodeType
3462: oPop 1
3464: oChoice 3526
3466: oEmit 2
3468: oGetParam 1
3470: oPushResult
3471: oCall 5851
3473: oPop 1
3475: oJumpForward 3534
3477: oEmit 5
3479: oGetParam 1
3481: oPushResult
3482: oCall 5851
3484: oPop 1
3486: oJumpForward 3534
3488: oGetParam 1
3490: oPushResult
3491: oSetResult 17
3493: oPushResult
3494: oNodeGetBoolean
3495: oPop 2
3497: oChoice 3512
3499: oEmit 8
3501: oGetParam 1
3503: oPushResult
3504: oCall 5851
3506: oPop 1
3508: oEmit 16
3510: oJumpForward 3524
3512: Choice Lookup Table
           1   3499
3515: oEmit 8
3517: oGetParam 1
3519: oPushResult
3520: oCall 5851
3522: oPop 1
3524: oJumpForward 3534
3526: Choice Lookup Table
          15   3488
          13   3477
          12   3466
3533: oEndChoice
3534: oInputChoice 3556
3536: oTypeSPop
3537: oGetLocal 1
3539: oPushResult
3540: oSetResult 19
3542: oPushResult
3543: oNodeGet
3544: oPop 2
3546: oPushResult
3547: oTypeSPush
3548: oPop 1
3550: oCall 3688
3552: oCall 3653
3554: oJumpForward 3559
3556: Choice Lookup Table
          17   3536
3559: oJumpForward 3652
3561: Choice Lookup Table
          23   3458
          17   3454
          22   3454
          21   3454
          19   3376
          18   3298
3574: oGetParam 1
3576: oPushResult
3577: oNodeType
3578: oPop 1
3580: oChoice 3640
3582: oEmit 10
3584: oGetParam 1
3586: oPushResult
3587: oCall 5851
3589: oPop 1
3591: oJumpForward 3648
3593: oEmit 11
3595: oGetParam 1
3597: oPushResult
3598: oCall 5851
3600: oPop 1
3602: oJumpForward 3648
3604: oGetParam 1
3606: oPushResult
3607: oSetResult 17
3609: oPushResult
3610: oNodeGetBoolean
3611: oPop 2
3613: oChoice 3626
3615: oEmit 8
3617: oGetParam 1
3619: oPushResult
3620: oCall 5851
3622: oPop 1
3624: oJumpForward 3638
3626: Choice Lookup Table
           1   3615
3629: oEmit 12
3631: oGetParam 1
3633: oPushResult
3634: oCall 5851
3636: oPop 1
3638: oJumpForward 3648
3640: Choice Lookup Table
          15   3604
          13   3593
          12   3582
3647: oEndChoice
3648: oCall 3688
3650: oCall 3653
3652: oReturn
3653: oLocalSpace 0
3655: oTypeSNodeType
3656: oChoice 3674
3658: oEmit 14
3660: oJumpForward 3687
3662: oEmit 15
3664: oJumpForward 3687
3666: oError 16
3668: oJumpForward 3687
3670: oEmit 16
3672: oJumpForward 3687
3674: Choice Lookup Table
          23   3670
          17   3666
          22   3666
          21   3666
          19   3662
          18   3658
3687: oReturn
3688: oLocalSpace 0
3690: oInputChoice 3704
3692: oCall 3716
3694: oJumpForward 3713
3696: oCall 3859
3698: oJumpForward 3713
3700: oCall 3957
3702: oJumpForward 3713
3704: Choice Lookup Table
          17   3700
          19   3696
          15   3692
3711: oJumpForward 3715
3713: oJumpBack 3690
3715: oReturn
3716: oLocalSpace 3
3718: oTypeSNodeType
3719: oChoice 3723
3721: oJumpForward 3728
3723: Choice Lookup Table
          24   3721
3726: oError 10
3728: oTypeSNodeType
3729: oChoice 3733
3731: oJumpForward 3738
3733: Choice Lookup Table
          24   3731
3736: oError 13
3738: oGetAddrLocal 1
3740: oPushResult
3741: oTypeSTop
3742: oPushResult
3743: oSetResult 20
3745: oPushResult
3746: oNodeGet
3747: oPop 2
3749: oPushResult
3750: oCall 5800
3752: oPop 1
3754: oAssign
3755: oGetAddrLocal 2
3757: oPushResult
3758: oTypeSTop
3759: oPushResult
3760: oSetResult 19
3762: oPushResult
3763: oNodeGet
3764: oPop 2
3766: oAssign
3767: oTypeSPop
3768: oGetLocal 2
3770: oPushResult
3771: oTypeSPush
3772: oPop 1
3774: oCall 2016
3776: oCall 5600
3778: oGetLocal 1
3780: oPushResult
3781: equal_zero
3782: oPop 1
3784: oChoice 3798
3786: oEmit 9
3788: oGetLocal 1
3790: oPushResult
3791: oEmitInt
3792: oPop 1
3794: oEmit 27
3796: oJumpForward 3801
3798: Choice Lookup Table
           0   3786
3801: oGetAddrLocal 3
3803: oPushResult
3804: oGetLocal 2
3806: oPushResult
3807: oSetResult 2
3809: oPushResult
3810: oNodeGetInt
3811: oPop 2
3813: oAssign
3814: oGetLocal 3
3816: oPushResult
3817: oSetResult 1
3819: oPushResult
3820: equal
3821: oPop 2
3823: oChoice 3837
3825: oEmit 9
3827: oGetLocal 3
3829: oPushResult
3830: oEmitInt
3831: oPop 1
3833: oEmit 23
3835: oJumpForward 3840
3837: Choice Lookup Table
           0   3825
3840: oEmit 25
3842: oInputChoice 3850
3844: oJumpForward 3858
3846: oJumpForward 3856
3848: oJumpForward 3856
3850: Choice Lookup Table
          12   3848
          16   3844
3855: oEndChoice
3856: oJumpBack 3728
3858: oReturn
3859: oLocalSpace 2
3861: oTypeSNodeType
3862: oChoice 3866
3864: oJumpForward 3871
3866: Choice Lookup Table
          26   3864
3869: oError 11
3871: oTypeSTop
3872: oPushResult
3873: oSetResult 23
3875: oPushResult
3876: oNodeGet
3877: oPop 2
3879: oPushResult
3880: oScopeEnter
3881: oPop 1
3883: oInput 0
3885: oGetAddrLocal 1
3887: oPushResult
3888: oScopeFindRequire
3889: oAssign
3890: oGetLocal 1
3892: oPushResult
3893: oNodeType
3894: oPop 1
3896: oChoice 3900
3898: oJumpForward 3905
3900: Choice Lookup Table
          14   3898
3903: oError 12
3905: oScopeEnd
3906: oGetAddrLocal 2
3908: oPushResult
3909: oGetLocal 1
3911: oPushResult
3912: oSetResult 6
3914: oPushResult
3915: oNodeGetInt
3916: oPop 2
3918: oAssign
3919: oGetLocal 2
3921: oPushResult
3922: equal_zero
3923: oPop 1
3925: oChoice 3939
3927: oEmit 9
3929: oGetLocal 2
3931: oPushResult
3932: oEmitInt
3933: oPop 1
3935: oEmit 25
3937: oJumpForward 3942
3939: Choice Lookup Table
           0   3927
3942: oTypeSPop
3943: oGetLocal 1
3945: oPushResult
3946: oSetResult 5
3948: oPushResult
3949: oNodeGet
3950: oPop 2
3952: oPushResult
3953: oTypeSPush
3954: oPop 1
3956: oReturn
3957: oLocalSpace 1
3959: oTypeSNodeType
3960: oChoice 3964
3962: oJumpForward 3969
3964: Choice Lookup Table
          23   3962
3967: oError 9
3969: oEmit 16
3971: oGetAddrLocal 1
3973: oPushResult
3974: oTypeSTop
3975: oAssign
3976: oTypeSPop
3977: oGetLocal 1
3979: oPushResult
3980: oSetResult 19
3982: oPushResult
3983: oNodeGet
3984: oPop 2
3986: oPushResult
3987: oTypeSPush
3988: oPop 1
3990: oReturn
3991: oLocalSpace 0
3993: oCall 5574
3995: oReturn
3996: oLocalSpace 10
3998: oGetParam 1
4000: oPushResult
4001: oSetResult 11
4003: oPushResult
4004: oNodeGetBoolean
4005: oPop 2
4007: oChoice 4059
4009: oGetParam 1
4011: oPushResult
4012: oSetResult 13
4014: oPushResult
4015: oNodeGetBoolean
4016: oPop 2
4018: oChoice 4054
4020: oGetAddrLocal 1
4022: oPushResult
4023: oGetParam 1
4025: oPushResult
4026: oSetResult 4
4028: oPushResult
4029: oNodeGetInt
4030: oPop 2
4032: oPushResult
4033: oStringAllocLitFromIdent
4034: oPop 1
4036: oAssign
4037: oEmit 50
4039: oGetParam 1
4041: oPushResult
4042: oCall 5851
4044: oPop 1
4046: oGetLocal 1
4048: oPushResult
4049: oEmitInt
4050: oPop 1
4052: oJumpForward 4057
4054: Choice Lookup Table
           0   4020
4057: oJumpForward 4062
4059: Choice Lookup Table
           1   4009
4062: oGetParam 1
4064: oPushResult
4065: oSetResult 13
4067: oPushResult
4068: oSetResult 1
4070: oPushResult
4071: oNodeSetBoolean
4072: oPop 3
4074: oGetAddrLocal 2
4076: oPushResult
4077: oGetParam 1
4079: oPushResult
4080: oSetResult 12
4082: oPushResult
4083: oNodeGetBoolean
4084: oPop 2
4086: oAssign
4087: oGetAddrLocal 5
4089: oPushResult
4090: oGetParam 1
4092: oPushResult
4093: oNodeType
4094: oPop 1
4096: oPushResult
4097: oSetResult 8
4099: oPushResult
4100: equal_node_type
4101: oPop 2
4103: oAssign
4104: oGetLocal 5
4106: oChoice 4133
4108: oGetAddrLocal 3
4110: oPushResult
4111: oGetParam 1
4113: oPushResult
4114: oSetResult 5
4116: oPushResult
4117: oNodeGet
4118: oPop 2
4120: oAssign
4121: oGetAddrLocal 4
4123: oPushResult
4124: oGetLocal 3
4126: oPushResult
4127: oScopeAllocType
4128: oPop 1
4130: oAssign
4131: oJumpForward 4136
4133: Choice Lookup Table
           1   4108
4136: oGetAddrLocal 6
4138: oPushResult
4139: oGetParam 1
4141: oPushResult
4142: oSetResult 8
4144: oPushResult
4145: oNodeGet
4146: oPop 2
4148: oAssign
4149: oGetAddrLocal 7
4151: oPushResult
4152: oGetLocal 6
4154: oPushResult
4155: oSetResult 2
4157: oPushResult
4158: oNodeGetInt
4159: oPop 2
4161: oAssign
4162: oGetLocal 2
4164: oChoice 4186
4166: oEmit 39
4168: oGetLocal 7
4170: oPushResult
4171: oEmitInt
4172: oPop 1
4174: oJumpForward 4192
4176: oEmit 38
4178: oGetLocal 7
4180: oPushResult
4181: oEmitInt
4182: oPop 1
4184: oJumpForward 4192
4186: Choice Lookup Table
           0   4176
           1   4166
4191: oEndChoice
4192: oGetAddrLocal 8
4194: oPushResult
4195: oGetLocal 6
4197: oPushResult
4198: oSetResult 1
4200: oPushResult
4201: oNodeGet
4202: oPop 2
4204: oAssign
4205: oInputChoice 4374
4207: oGetLocal 8
4209: oPushResult
4210: oNodeNull
4211: oPop 1
4213: oChoice 4219
4215: oJumpForward 4370
4217: oJumpForward 4222
4219: Choice Lookup Table
           1   4215
4222: oGetAddrLocal 9
4224: oPushResult
4225: oGetLocal 8
4227: oPushResult
4228: oSetResult 6
4230: oPushResult
4231: oNodeGetInt
4232: oPop 2
4234: oAssign
4235: oEmit 13
4237: oGetLocal 9
4239: oPushResult
4240: oEmitInt
4241: oPop 1
4243: oGetLocal 8
4245: oPushResult
4246: oSetResult 5
4248: oPushResult
4249: oNodeGet
4250: oPop 2
4252: oPushResult
4253: oTypeSPush
4254: oPop 1
4256: oGetLocal 8
4258: oPushResult
4259: oSetResult 17
4261: oPushResult
4262: oNodeGetBoolean
4263: oPop 2
4265: oChoice 4333
4267: oCall 4857
4269: oCall 5574
4271: oEmit 19
4273: oJumpForward 4339
4275: oCall 2016
4277: oCall 3991
4279: oTypeSNodeType
4280: oChoice 4298
4282: oEmit 17
4284: oJumpForward 4331
4286: oEmit 18
4288: oJumpForward 4331
4290: oError 16
4292: oJumpForward 4331
4294: oEmit 19
4296: oJumpForward 4331
4298: Choice Lookup Table
          23   4294
          17   4290
          22   4290
          21   4290
          19   4286
          18   4282
4311: oGetAddrLocal 10
4313: oPushResult
4314: oTypeSTop
4315: oPushResult
4316: oSetResult 2
4318: oPushResult
4319: oNodeGetInt
4320: oPop 2
4322: oAssign
4323: oEmit 20
4325: oGetLocal 10
4327: oPushResult
4328: oEmitInt
4329: oPop 1
4331: oJumpForward 4339
4333: Choice Lookup Table
           0   4275
           1   4267
4338: oEndChoice
4339: oTypeSPop
4340: oGetAddrLocal 8
4342: oPushResult
4343: oNodeNext
4344: oPop 1
4346: oGetLocal 8
4348: oPushResult
4349: oNodeNull
4350: oPop 1
4352: oChoice 4360
4354: oJumpForward 4370
4356: oJumpForward 4366
4358: oJumpForward 4366
4360: Choice Lookup Table
           0   4358
           1   4354
4365: oEndChoice
4366: oInput 12
4368: oJumpBack 4207
4370: oInput 14
4372: oJumpForward 4377
4374: Choice Lookup Table
          13   4207
4377: oGetLocal 8
4379: oPushResult
4380: oNodeNull
4381: oPop 1
4383: oChoice 4389
4385: oError 15
4387: oJumpForward 4392
4389: Choice Lookup Table
           0   4385
4392: oGetLocal 5
4394: oChoice 4423
4396: oEmit 13
4398: oGetParam 1
4400: oPushResult
4401: oSetResult 16
4403: oPushResult
4404: oNodeGetInt
4405: oPop 2
4407: oPushResult
4408: oEmitInt
4409: oPop 1
4411: oEmit 11
4413: oGetLocal 4
4415: oPushResult
4416: oEmitInt
4417: oPop 1
4419: oEmit 19
4421: oJumpForward 4426
4423: Choice Lookup Table
           1   4396
4426: oGetLocal 2
4428: oChoice 4452
4430: oEmit 42
4432: oGetParam 1
4434: oPushResult
4435: oCall 5851
4437: oPop 1
4439: oJumpForward 4458
4441: oEmit 41
4443: oGetParam 1
4445: oPushResult
4446: oCall 5851
4448: oPop 1
4450: oJumpForward 4458
4452: Choice Lookup Table
           0   4441
           1   4430
4457: oEndChoice
4458: oGetLocal 5
4460: oChoice 4528
4462: oGetLocal 3
4464: oPushResult
4465: oTypeSPush
4466: oPop 1
4468: oTypeSNodeType
4469: oChoice 4505
4471: oEmit 3
4473: oGetLocal 4
4475: oPushResult
4476: oEmitInt
4477: oPop 1
4479: oJumpForward 4526
4481: oEmit 4
4483: oGetLocal 4
4485: oPushResult
4486: oEmitInt
4487: oPop 1
4489: oJumpForward 4526
4491: oError 16
4493: oJumpForward 4526
4495: oEmit 5
4497: oGetLocal 4
4499: oPushResult
4500: oEmitInt
4501: oPop 1
4503: oJumpForward 4526
4505: Choice Lookup Table
          23   4495
          17   4491
          22   4491
          21   4491
          19   4481
          18   4471
4518: oEmit 11
4520: oGetLocal 4
4522: oPushResult
4523: oEmitInt
4524: oPop 1
4526: oJumpForward 4531
4528: Choice Lookup Table
           1   4462
4531: oEmit 40
4533: oGetLocal 7
4535: oPushResult
4536: oEmitInt
4537: oPop 1
4539: oReturn
4540: oLocalSpace 0
4542: oInputChoice 4592
4544: oCall 5494
4546: oJumpForward 4617
4548: oCall 5501
4550: oJumpForward 4617
4552: oCall 5568
4554: oJumpForward 4617
4556: oCall 5571
4558: oJumpForward 4617
4560: oCall 5034
4562: oJumpForward 4617
4564: oCall 5354
4566: oJumpForward 4617
4568: oCall 5100
4570: oJumpForward 4617
4572: oCall 5274
4574: oJumpForward 4617
4576: oCall 5439
4578: oJumpForward 4617
4580: oCall 5407
4582: oJumpForward 4617
4584: oCall 5471
4586: oJumpForward 4617
4588: oCall 4618
4590: oJumpForward 4617
4592: Choice Lookup Table
           0   4588
          33   4584
          49   4580
          50   4576
          47   4572
          42   4568
          46   4564
          39   4560
          58   4556
          57   4552
          56   4548
          55   4544
4617: oReturn
4618: oLocalSpace 1
4620: oGetAddrLocal 1
4622: oPushResult
4623: oScopeFindRequire
4624: oAssign
4625: oGetLocal 1
4627: oPushResult
4628: oNodeType
4629: oPop 1
4631: oChoice 4660
4633: oGetLocal 1
4635: oPushResult
4636: oCall 3996
4638: oPop 1
4640: oJumpForward 4673
4642: oGetLocal 1
4644: oPushResult
4645: oCall 4674
4647: oPop 1
4649: oJumpForward 4673
4651: oGetLocal 1
4653: oPushResult
4654: oCall 4743
4656: oPop 1
4658: oJumpForward 4673
4660: Choice Lookup Table
           8   4651
          15   4642
          13   4642
          12   4642
           7   4633
4671: oError 0
4673: oReturn
4674: oLocalSpace 1
4676: oGetParam 1
4678: oPushResult
4679: oCall 4893
4681: oPop 1
4683: oInput 3
4685: oCall 2016
4687: oCall 5574
4689: oTypeSNodeType
4690: oChoice 4708
4692: oEmit 17
4694: oJumpForward 4741
4696: oEmit 18
4698: oJumpForward 4741
4700: oError 16
4702: oJumpForward 4741
4704: oEmit 19
4706: oJumpForward 4741
4708: Choice Lookup Table
          23   4704
          17   4700
          22   4700
          21   4700
          19   4696
          18   4692
4721: oGetAddrLocal 1
4723: oPushResult
4724: oTypeSTop
4725: oPushResult
4726: oSetResult 2
4728: oPushResult
4729: oNodeGetInt
4730: oPop 2
4732: oAssign
4733: oEmit 20
4735: oGetLocal 1
4737: oPushResult
4738: oEmitInt
4739: oPop 1
4741: oTypeSPop
4742: oReturn
4743: oLocalSpace 1
4745: oGetParam 1
4747: oPushResult
4748: oSetResult 9
4750: oPushResult
4751: oNodeGet
4752: oPop 2
4754: oPushResult
4755: oScopeCurrent
4756: oPushResult
4757: oNodeEqual
4758: oPop 2
4760: oChoice 4766
4762: oError 20
4764: oJumpForward 4769
4766: Choice Lookup Table
           0   4762
4769: oEmit 8
4771: oGetParam 1
4773: oPushResult
4774: oSetResult 16
4776: oPushResult
4777: oNodeGetInt
4778: oPop 2
4780: oPushResult
4781: oEmitInt
4782: oPop 1
4784: oGetParam 1
4786: oPushResult
4787: oSetResult 5
4789: oPushResult
4790: oNodeGet
4791: oPop 2
4793: oPushResult
4794: oTypeSPush
4795: oPop 1
4797: oInput 3
4799: oCall 2016
4801: oCall 5574
4803: oTypeSNodeType
4804: oChoice 4822
4806: oEmit 17
4808: oJumpForward 4855
4810: oEmit 18
4812: oJumpForward 4855
4814: oError 16
4816: oJumpForward 4855
4818: oEmit 19
4820: oJumpForward 4855
4822: Choice Lookup Table
          23   4818
          17   4814
          22   4814
          21   4814
          19   4810
          18   4806
4835: oGetAddrLocal 1
4837: oPushResult
4838: oTypeSTop
4839: oPushResult
4840: oSetResult 2
4842: oPushResult
4843: oNodeGetInt
4844: oPop 2
4846: oAssign
4847: oEmit 20
4849: oGetLocal 1
4851: oPushResult
4852: oEmitInt
4853: oPop 1
4855: oTypeSPop
4856: oReturn
4857: oLocalSpace 1
4859: oInput 0
4861: oGetAddrLocal 1
4863: oPushResult
4864: oScopeFindRequire
4865: oAssign
4866: oGetLocal 1
4868: oPushResult
4869: oNodeType
4870: oPop 1
4872: oChoice 4876
4874: oJumpForward 4885
4876: Choice Lookup Table
          15   4874
          13   4874
          12   4874
4883: oError 4
4885: oGetLocal 1
4887: oPushResult
4888: oCall 4893
4890: oPop 1
4892: oReturn
4893: oLocalSpace 0
4895: oGetParam 1
4897: oPushResult
4898: oNodeType
4899: oPop 1
4901: oChoice 4961
4903: oEmit 10
4905: oGetParam 1
4907: oPushResult
4908: oCall 5851
4910: oPop 1
4912: oJumpForward 4970
4914: oEmit 11
4916: oGetParam 1
4918: oPushResult
4919: oCall 5851
4921: oPop 1
4923: oJumpForward 4970
4925: oGetParam 1
4927: oPushResult
4928: oSetResult 17
4930: oPushResult
4931: oNodeGetBoolean
4932: oPop 2
4934: oChoice 4947
4936: oEmit 8
4938: oGetParam 1
4940: oPushResult
4941: oCall 5851
4943: oPop 1
4945: oJumpForward 4959
4947: Choice Lookup Table
           1   4936
4950: oEmit 12
4952: oGetParam 1
4954: oPushResult
4955: oCall 5851
4957: oPop 1
4959: oJumpForward 4970
4961: Choice Lookup Table
          15   4925
          13   4914
          12   4903
4968: oError 4
4970: oGetParam 1
4972: oPushResult
4973: oSetResult 5
4975: oPushResult
4976: oNodeGet
4977: oPop 2
4979: oPushResult
4980: oTypeSPush
4981: oPop 1
4983: oCall 3688
4985: oReturn
4986: oLocalSpace 0
4988: oGetParam 1
4990: oPushResult
4991: oCall 4893
4993: oPop 1
4995: oCall 5600
4997: oGetParam 1
4999: oPushResult
5000: oCall 3274
5002: oPop 1
5004: oTypeSPop
5005: oEmit 21
5007: oEmit 17
5009: oReturn
5010: oLocalSpace 0
5012: oGetParam 1
5014: oPushResult
5015: oCall 4893
5017: oPop 1
5019: oCall 5600
5021: oGetParam 1
5023: oPushResult
5024: oCall 3274
5026: oPop 1
5028: oTypeSPop
5029: oEmit 22
5031: oEmit 17
5033: oReturn
5034: oLocalSpace 2
5036: oGetAddrLocal 1
5038: oPushResult
5039: oSetResult 0
5041: oAssign
5042: oGetAddrLocal 1
5044: oPushResult
5045: oCall 2039
5047: oPop 1
5049: oInput 40
5051: oCall 4540
5053: oInputChoice 5088
5055: oGetAddrLocal 2
5057: oPushResult
5058: oLabelNew
5059: oAssign
5060: oEmit 45
5062: oGetLocal 2
5064: oPushResult
5065: oEmitLabel
5066: oPop 1
5068: oEmit 48
5070: oGetLocal 1
5072: oPushResult
5073: oEmitLabel
5074: oPop 1
5076: oCall 4540
5078: oEmit 48
5080: oGetLocal 2
5082: oPushResult
5083: oEmitLabel
5084: oPop 1
5086: oJumpForward 5099
5088: Choice Lookup Table
          41   5055
5091: oEmit 48
5093: oGetLocal 1
5095: oPushResult
5096: oEmitLabel
5097: oPop 1
5099: oReturn
5100: oLocalSpace 4
5102: oInput 0
5104: oGetAddrLocal 1
5106: oPushResult
5107: oScopeFindRequire
5108: oAssign
5109: oGetLocal 1
5111: oPushResult
5112: oCall 4893
5114: oPop 1
5116: oCall 5600
5118: oInput 3
5120: oCall 2016
5122: oCall 5600
5124: oEmit 17
5126: oGetAddrLocal 2
5128: oPushResult
5129: oLabelNew
5130: oAssign
5131: oGetAddrLocal 3
5133: oPushResult
5134: oLabelNew
5135: oAssign
5136: oEmit 45
5138: oGetLocal 3
5140: oPushResult
5141: oEmitLabel
5142: oPop 1
5144: oGetAddrLocal 4
5146: oPushResult
5147: oLabelNew
5148: oAssign
5149: oEmit 48
5151: oGetLocal 4
5153: oPushResult
5154: oEmitLabel
5155: oPop 1
5157: oInputChoice 5237
5159: oGetLocal 1
5161: oPushResult
5162: oCall 4986
5164: oPop 1
5166: oEmit 48
5168: oGetLocal 3
5170: oPushResult
5171: oEmitLabel
5172: oPop 1
5174: oGetLocal 1
5176: oPushResult
5177: oCall 3274
5179: oPop 1
5181: oTypeSPop
5182: oCall 2016
5184: oCall 5600
5186: oEmit 32
5188: oEmit 46
5190: oGetLocal 2
5192: oPushResult
5193: oEmitLabel
5194: oPop 1
5196: oJumpForward 5243
5198: oGetLocal 1
5200: oPushResult
5201: oCall 5010
5203: oPop 1
5205: oEmit 48
5207: oGetLocal 3
5209: oPushResult
5210: oEmitLabel
5211: oPop 1
5213: oGetLocal 1
5215: oPushResult
5216: oCall 3274
5218: oPop 1
5220: oTypeSPop
5221: oCall 2016
5223: oCall 5600
5225: oEmit 33
5227: oEmit 46
5229: oGetLocal 2
5231: oPushResult
5232: oEmitLabel
5233: oPop 1
5235: oJumpForward 5243
5237: Choice Lookup Table
          44   5198
          43   5159
5242: oEndChoice
5243: oGetLocal 4
5245: oPushResult
5246: oGetLocal 2
5248: oPushResult
5249: oLoopPush
5250: oPop 2
5252: oInput 45
5254: oCall 4540
5256: oEmit 45
5258: oGetLocal 4
5260: oPushResult
5261: oEmitLabel
5262: oPop 1
5264: oEmit 48
5266: oGetLocal 2
5268: oPushResult
5269: oEmitLabel
5270: oPop 1
5272: oLoopPop
5273: oReturn
5274: oLocalSpace 3
5276: oGetAddrLocal 1
5278: oPushResult
5279: oLabelNew
5280: oAssign
5281: oEmit 48
5283: oGetLocal 1
5285: oPushResult
5286: oEmitLabel
5287: oPop 1
5289: oGetAddrLocal 2
5291: oPushResult
5292: oLabelNew
5293: oAssign
5294: oGetLocal 1
5296: oPushResult
5297: oGetLocal 2
5299: oPushResult
5300: oLoopPush
5301: oPop 2
5303: oCall 4540
5305: oInputChoice 5336
5307: oCall 4540
5309: oJumpForward 5342
5311: oGetAddrLocal 3
5313: oPushResult
5314: oCall 2039
5316: oPop 1
5318: oEmit 49
5320: oGetLocal 3
5322: oPushResult
5323: oEmitLabel
5324: oPop 1
5326: oGetLocal 1
5328: oPushResult
5329: oEmitLabel
5330: oPop 1
5332: oJumpForward 5344
5334: oJumpForward 5342
5336: Choice Lookup Table
          48   5311
           4   5307
5341: oEndChoice
5342: oJumpBack 5305
5344: oEmit 48
5346: oGetLocal 2
5348: oPushResult
5349: oEmitLabel
5350: oPop 1
5352: oLoopPop
5353: oReturn
5354: oLocalSpace 2
5356: oGetAddrLocal 1
5358: oPushResult
5359: oLabelNew
5360: oAssign
5361: oEmit 48
5363: oGetLocal 1
5365: oPushResult
5366: oEmitLabel
5367: oPop 1
5369: oGetAddrLocal 2
5371: oPushResult
5372: oCall 2039
5374: oPop 1
5376: oGetLocal 1
5378: oPushResult
5379: oGetLocal 2
5381: oPushResult
5382: oLoopPush
5383: oPop 2
5385: oInput 45
5387: oCall 4540
5389: oEmit 45
5391: oGetLocal 1
5393: oPushResult
5394: oEmitLabel
5395: oPop 1
5397: oEmit 48
5399: oGetLocal 2
5401: oPushResult
5402: oEmitLabel
5403: oPop 1
5405: oLoopPop
5406: oReturn
5407: oLocalSpace 0
5409: oLoopContinueLabel
5410: oPushResult
5411: oSetResult 0
5413: oPushResult
5414: equal_label
5415: oPop 2
5417: oChoice 5432
5419: oError 18
5421: oJumpForward 5438
5423: oEmit 45
5425: oLoopContinueLabel
5426: oPushResult
5427: oEmitLabel
5428: oPop 1
5430: oJumpForward 5438
5432: Choice Lookup Table
           0   5423
           1   5419
5437: oEndChoice
5438: oReturn
5439: oLocalSpace 0
5441: oLoopBreakLabel
5442: oPushResult
5443: oSetResult 0
5445: oPushResult
5446: equal_label
5447: oPop 2
5449: oChoice 5464
5451: oError 18
5453: oJumpForward 5470
5455: oEmit 45
5457: oLoopBreakLabel
5458: oPushResult
5459: oEmitLabel
5460: oPop 1
5462: oJumpForward 5470
5464: Choice Lookup Table
           0   5455
           1   5451
5469: oEndChoice
5470: oReturn
5471: oLocalSpace 0
5473: oCall 4540
5475: oInputChoice 5485
5477: oCall 4540
5479: oJumpForward 5491
5481: oJumpForward 5493
5483: oJumpForward 5491
5485: Choice Lookup Table
          34   5481
           4   5477
5490: oEndChoice
5491: oJumpBack 5475
5493: oReturn
5494: oLocalSpace 0
5496: oCall 5501
5498: oEmit 55
5500: oReturn
5501: oLocalSpace 0
5503: oInputChoice 5564
5505: oCall 2016
5507: oTypeSNodeType
5508: oChoice 5530
5510: oEmit 51
5512: oJumpForward 5545
5514: oEmit 52
5516: oJumpForward 5545
5518: oEmit 53
5520: oJumpForward 5545
5522: oError 16
5524: oJumpForward 5545
5526: oEmit 54
5528: oJumpForward 5545
5530: Choice Lookup Table
          23   5526
          17   5522
          21   5522
          22   5518
          19   5514
          18   5510
5543: oError 17
5545: oTypeSPop
5546: oInputChoice 5554
5548: oJumpForward 5562
5550: oJumpForward 5560
5552: oJumpForward 5560
5554: Choice Lookup Table
          12   5552
          14   5548
5559: oEndChoice
5560: oJumpBack 5505
5562: oJumpForward 5567
5564: Choice Lookup Table
          13   5505
5567: oReturn
5568: oLocalSpace 0
5570: oReturn
5571: oLocalSpace 0
5573: oReturn
5574: oLocalSpace 1
5576: oGetAddrLocal 1
5578: oPushResult
5579: oTypeSNodeType
5580: oAssign
5581: oTypeSPop
5582: oGetLocal 1
5584: oPushResult
5585: oTypeSNodeType
5586: oPushResult
5587: equal_node_type
5588: oPop 2
5590: oChoice 5596
5592: oError 14
5594: oJumpForward 5599
5596: Choice Lookup Table
           0   5592
5599: oReturn
5600: oLocalSpace 0
5602: oTypeSNodeType
5603: oChoice 5607
5605: oJumpForward 5612
5607: Choice Lookup Table
          18   5605
5610: oError 7
5612: oTypeSPop
5613: oReturn
5614: oLocalSpace 0
5616: oTypeSNodeType
5617: oChoice 5621
5619: oJumpForward 5626
5621: Choice Lookup Table
          18   5619
5624: oError 7
5626: oReturn
5627: oLocalSpace 0
5629: oTypeSNodeType
5630: oChoice 5634
5632: oJumpForward 5639
5634: Choice Lookup Table
          19   5632
5637: oError 8
5639: oTypeSPop
5640: oReturn
5641: oLocalSpace 0
5643: oTypeSNodeType
5644: oChoice 5648
5646: oJumpForward 5653
5648: Choice Lookup Table
          19   5646
5651: oError 8
5653: oReturn
5654: oLocalSpace 1
5656: oGetAddrLocal 1
5658: oPushResult
5659: oGetParam 2
5661: oPushResult
5662: oNodeNew
5663: oPop 1
5665: oAssign
5666: oGetLocal 1
5668: oPushResult
5669: oSetResult 2
5671: oPushResult
5672: oGetParam 1
5674: oPushResult
5675: oNodeSetInt
5676: oPop 3
5678: oGetLocal 1
5680: oPushResult
5681: oTypeAdd
5682: oPop 1
5684: oGetLocal 1
5686: oReturn
5687: oReturn
5688: oLocalSpace 1
5690: oGetAddrLocal 1
5692: oPushResult
5693: oGetParam 3
5695: oPushResult
5696: oNodeNew
5697: oPop 1
5699: oAssign
5700: oGetLocal 1
5702: oPushResult
5703: oSetResult 4
5705: oPushResult
5706: oGetParam 1
5708: oPushResult
5709: oNodeSetInt
5710: oPop 3
5712: oGetLocal 1
5714: oReturn
5715: oReturn
5716: oLocalSpace 1
5718: oGetAddrLocal 1
5720: oPushResult
5721: oGetParam 1
5723: oPushResult
5724: oSetResult 18
5726: oPushResult
5727: oNodeGet
5728: oPop 2
5730: oAssign
5731: oGetLocal 1
5733: oPushResult
5734: oNodeNull
5735: oPop 1
5737: oChoice 5793
5739: oGetAddrLocal 1
5741: oPushResult
5742: oSetResult 23
5744: oPushResult
5745: oNodeNew
5746: oPop 1
5748: oAssign
5749: oGetLocal 1
5751: oPushResult
5752: oSetResult 19
5754: oPushResult
5755: oGetParam 1
5757: oPushResult
5758: oNodeSet
5759: oPop 3
5761: oGetLocal 1
5763: oPushResult
5764: oSetResult 2
5766: oPushResult
5767: oSetResult 8
5769: oPushResult
5770: oNodeSetInt
5771: oPop 3
5773: oGetLocal 1
5775: oPushResult
5776: oTypeAdd
5777: oPop 1
5779: oGetParam 1
5781: oPushResult
5782: oSetResult 18
5784: oPushResult
5785: oGetLocal 1
5787: oPushResult
5788: oNodeSet
5789: oPop 3
5791: oJumpForward 5796
5793: Choice Lookup Table
           1   5739
5796: oGetLocal 1
5798: oReturn
5799: oReturn
5800: oLocalSpace 0
5802: oGetParam 1
5804: oPushResult
5805: oNodeType
5806: oPop 1
5808: oChoice 5836
5810: oMININT
5811: oReturn
5812: oJumpForward 5850
5814: oSetResult 0
5816: oReturn
5817: oJumpForward 5850
5819: oSetResult 0
5821: oReturn
5822: oJumpForward 5850
5824: oGetParam 1
5826: oPushResult
5827: oSetResult 21
5829: oPushResult
5830: oNodeGetInt
5831: oPop 2
5833: oReturn
5834: oJumpForward 5850
5836: Choice Lookup Table
          25   5824
          21   5819
          19   5814
          18   5810
5845: oError 3
5847: oSetResult 0
5849: oReturn
5850: oReturn
5851: oLocalSpace 0
5853: oGetParam 1
5855: oPushResult
5856: oSetResult 6
5858: oPushResult
5859: oNodeGetInt
5860: oPop 2
5862: oPushResult
5863: oEmitInt
5864: oPop 1
5866: oReturn
5867: oLocalSpace 1
5869: oGetAddrGlobal 2
5871: oPushResult
5872: oSetResult 17
5874: oPushResult
5875: oSetResult 4
5877: oPushResult
5878: oCall 5654
5880: oPop 2
5882: oAssign
5883: oGetAddrGlobal 3
5885: oPushResult
5886: oSetResult 18
5888: oPushResult
5889: oSetResult 4
5891: oPushResult
5892: oCall 5654
5894: oPop 2
5896: oAssign
5897: oGetAddrGlobal 4
5899: oPushResult
5900: oSetResult 19
5902: oPushResult
5903: oSetResult 1
5905: oPushResult
5906: oCall 5654
5908: oPop 2
5910: oAssign
5911: oGetAddrGlobal 5
5913: oPushResult
5914: oSetResult 20
5916: oPushResult
5917: oSetResult 1
5919: oPushResult
5920: oCall 5654
5922: oPop 2
5924: oAssign
5925: oGetAddrGlobal 6
5927: oPushResult
5928: oSetResult 21
5930: oPushResult
5931: oSetResult 1
5933: oPushResult
5934: oCall 5654
5936: oPop 2
5938: oAssign
5939: oGetAddrGlobal 7
5941: oPushResult
5942: oSetResult 22
5944: oPushResult
5945: oSetResult 256
5947: oPushResult
5948: oCall 5654
5950: oPop 2
5952: oAssign
5953: oGetAddrLocal 1
5955: oPushResult
5956: oSetResult 10
5958: oPushResult
5959: oSetResult 5
5961: oPushResult
5962: oIdAdd_File
5963: oPushResult
5964: oCall 5688
5966: oPop 3
5968: oAssign
5969: oGetLocal 1
5971: oPushResult
5972: oSetResult 5
5974: oPushResult
5975: oGetGlobal 2
5977: oPushResult
5978: oNodeSet
5979: oPop 3
5981: oGetLocal 1
5983: oPushResult
5984: oScopeDeclare
5985: oPop 1
5987: oGetAddrLocal 1
5989: oPushResult
5990: oSetResult 10
5992: oPushResult
5993: oSetResult 5
5995: oPushResult
5996: oIdAdd_Integer
5997: oPushResult
5998: oCall 5688
6000: oPop 3
6002: oAssign
6003: oGetLocal 1
6005: oPushResult
6006: oSetResult 5
6008: oPushResult
6009: oGetGlobal 3
6011: oPushResult
6012: oNodeSet
6013: oPop 3
6015: oGetLocal 1
6017: oPushResult
6018: oScopeDeclare
6019: oPop 1
6021: oGetAddrLocal 1
6023: oPushResult
6024: oSetResult 10
6026: oPushResult
6027: oSetResult 5
6029: oPushResult
6030: oIdAdd_Boolean
6031: oPushResult
6032: oCall 5688
6034: oPop 3
6036: oAssign
6037: oGetLocal 1
6039: oPushResult
6040: oSetResult 5
6042: oPushResult
6043: oGetGlobal 4
6045: oPushResult
6046: oNodeSet
6047: oPop 3
6049: oGetLocal 1
6051: oPushResult
6052: oScopeDeclare
6053: oPop 1
6055: oGetAddrLocal 1
6057: oPushResult
6058: oSetResult 10
6060: oPushResult
6061: oSetResult 5
6063: oPushResult
6064: oIdAdd_Char
6065: oPushResult
6066: oCall 5688
6068: oPop 3
6070: oAssign
6071: oGetLocal 1
6073: oPushResult
6074: oSetResult 5
6076: oPushResult
6077: oGetGlobal 6
6079: oPushResult
6080: oNodeSet
6081: oPop 3
6083: oGetLocal 1
6085: oPushResult
6086: oScopeDeclare
6087: oPop 1
6089: oGetAddrLocal 1
6091: oPushResult
6092: oSetResult 10
6094: oPushResult
6095: oSetResult 5
6097: oPushResult
6098: oIdAdd_String
6099: oPushResult
6100: oCall 5688
6102: oPop 3
6104: oAssign
6105: oGetLocal 1
6107: oPushResult
6108: oSetResult 5
6110: oPushResult
6111: oGetGlobal 7
6113: oPushResult
6114: oNodeSet
6115: oPop 3
6117: oGetLocal 1
6119: oPushResult
6120: oScopeDeclare
6121: oPop 1
6123: oGetAddrLocal 1
6125: oPushResult
6126: oSetResult 9
6128: oPushResult
6129: oSetResult 4
6131: oPushResult
6132: oIdAdd_True
6133: oPushResult
6134: oCall 5688
6136: oPop 3
6138: oAssign
6139: oGetLocal 1
6141: oPushResult
6142: oSetResult 5
6144: oPushResult
6145: oGetGlobal 4
6147: oPushResult
6148: oNodeSet
6149: oPop 3
6151: oGetLocal 1
6153: oPushResult
6154: oSetResult 6
6156: oPushResult
6157: oSetResult 1
6159: oPushResult
6160: oNodeSetInt
6161: oPop 3
6163: oGetLocal 1
6165: oPushResult
6166: oScopeDeclare
6167: oPop 1
6169: oGetAddrLocal 1
6171: oPushResult
6172: oSetResult 9
6174: oPushResult
6175: oSetResult 4
6177: oPushResult
6178: oIdAdd_False
6179: oPushResult
6180: oCall 5688
6182: oPop 3
6184: oAssign
6185: oGetLocal 1
6187: oPushResult
6188: oSetResult 5
6190: oPushResult
6191: oGetGlobal 4
6193: oPushResult
6194: oNodeSet
6195: oPop 3
6197: oGetLocal 1
6199: oPushResult
6200: oSetResult 6
6202: oPushResult
6203: oSetResult 0
6205: oPushResult
6206: oNodeSetInt
6207: oPop 3
6209: oGetLocal 1
6211: oPushResult
6212: oScopeDeclare
6213: oPop 1
6215: oReturn
