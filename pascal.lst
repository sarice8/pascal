   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 215:    oScopeBegin( 0, allocDown )
 224:    initScope = oScopeCurrent
 229:    oNodeSet( program, qMainRoutineScope, initScope )
 241:    oScopeEnd
      
 242:    @BlockDecls( nGlobalVar )
      
      
 249:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 255:    boolean isMain = true
 261:    @BlockStmt( mainLabel, globalScope, isMain )
      
 274:    oScopeEnd   % main routine scope
      
 275:    '.'
 277:    oScopeEnd   % global scope
 278:    @EndUsedUnits( program )   % used units scopes
 286:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 286: UsesClause( Node user ):
 288:    {
 288:       pIdent
 290:       Node unit = @FindOrCompileUnit( LAST_ID )
 300:       [ equal_node( unit, Null )
 310:          | false :
 311:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 323:             Node unitRef = oNodeNew( nUnitRef )
 333:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 352:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 371:             oScopeDeclare( unitRef )
 377:          | * :
 382:       ]
 382:       [
 382:          | ',' :
 384:          | * :  >
 391:       ]
 391:    }   
 393:    ';'
 396:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 396: ResolveUnitRef( inout Node decl ):
 398:    [ oNodeType( decl )
 405:       | nUnitRef :
 406:          Node scope = oNodeGet( decl, qPublicScope )
 419:          '.'
 421:          pIdent
 423:          decl = oScopeFindRequireInScope( scope )
 433:       | * :
 438:    ];
      
      
 439: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 441:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 454:    {
 454:       Node unit = oNodeIterValue( unitIt )
 464:       [ oNodeNull( unit )
 471:          | false :
 472:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 485:          | * :
 490:             >
 492:       ]
 492:       oNodeIterNext( unitIt )
 498:    }
 501:    ;
      
 501: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 503:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 516:    {
 516:       Node unit = oNodeIterValue( unitIt )
 526:       [ oNodeNull( unit )
 533:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 534:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 550:                | true :
 551:                | false :  #eInternalScopeMismatch
 555:             ]
 563:             oScopeEnd
 564:          | * :
 569:             >
 571:       ]
 571:       oNodeIterPrev( unitIt )
 577:    }
 580:    ;
      
      
 580: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 582:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 601:    [ equal_node( unit, Null )
 611:       | false :  >> unit
 615:       | * :
 620:    ]
      
         % If not, search for the source file on disk
 620:    boolean ok = oIncludeUnitFile( id )
 630:    [ ok
 633:       | false :  #eCantFindUnitFile  >> Null
 639:       | * :
 644:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 644:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 650:    oIncludeEnd
 651:    >> unit;
      
      
      
 655: Unit >> Node:
 657:    pUnit
 659:    pIdent
 661:    Node unit = oNodeNew( nUnit )
 671:    oNodeSetInt( unit, qIdent, LAST_ID )
 682:    Node unitImpl = oNodeNew( nUnitImpl )
 692:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 703:    oNodeSet( unit, qImpl, unitImpl )
 715:    ';'
      
         % mandatory sections
      
 717:    pInterface
 719:    [
 719:       | pUses :   @UsesClause( unit )
 728:       | * :
 733:    ]
 733:    @EnterUsedUnits( unit )
      
 740:    oScopeBegin( 0, allocGlobal )
 749:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 760:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 765:    oScopeBegin( 0, allocDown )
 774:    initScope = oScopeCurrent
 779:    oNodeSet( unit, qInitRoutineScope, initScope )
 791:    oScopeEnd
      
 792:    @UnitInterface( unit )
 799:    oScopeEnd  % interface scope
      
 800:    pImplementation
 802:    [
 802:       | pUses :   @UsesClause( unitImpl )
 811:       | * :
 816:    ]
 816:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 823:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 836:    oScopeBegin( 0, allocGlobal )
 845:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 856:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 874:    globalScope = oScopeCurrent
 879:    @UnitImplementation( unit )
      
 886:    [
 886:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 898:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 913:    ]
 913:    [
 913:       | pFinalization :  @UnitFinalization( unit, true )
 925:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 940:    ]
 940:    pEnd  '.'
      
 944:    oScopeEnd  % impl scope
 945:    oScopeEnd  % interface scope
 946:    @EndUsedUnits( unitImpl )  % used units scopes
 953:    @EndUsedUnits( unit )
 960:    oNodeAddLast( workspace, qUnits, unit )
 972:    >> unit;
      
      
 976: UnitInterface( Node unit ):
 978:    {[
 978:       | pConst :     @ConstDecl
 982:       | pType :      @TypeDecl
 986:       | pVar :       @VarDecl( nGlobalVar )
      
 995:       | pProcedure :
 997:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1003:          [
1003:             | pExternal :
1005:                @ExternalDecl( decl )
1012:                ';'
1014:             | * :
1019:          ]
      
1019:       | pFunction :
1021:          Node decl = @FuncHeaderDecl
1027:          [
1027:             | pExternal :
1029:                @ExternalDecl( decl )
1036:                ';'
1038:             | * :
1043:          ]
      
1043:       | * :          >
1058:    ]}
1061:    ;
      
1061: UnitImplementation( Node unit ):
1063:    @BlockDecls( nGlobalVar )
1071:    ;
      
      
1071: UnitInitialization( Node unit, boolean hasStmts ):
1073:    Label label = oLabelNew
1078:    .tLabel  oEmitLabel( label )
1086:    oNodeSetLabel( unit, qInitLabel, label )
      
1098:    int patchLS
1098:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1107:    Node scope
1107:    Code initCode
      
1107:    scope = oNodeGet( unit, qPublicScope )
1120:    initCode = oNodeGetCode( scope, qInitCode )
1133:    oEmitCode( initCode )
1139:    oNodeSetCode( scope, qInitCode, codeNull )
      
1151:    scope = oNodeGet( unit, qPrivateScope )
1164:    initCode = oNodeGetCode( scope, qInitCode )
1177:    oEmitCode( initCode )
1183:    oNodeSetCode( scope, qInitCode, codeNull )
      
1195:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1208:    [ hasStmts
1211:       | true :     
1212:          @Statement
1214:          {[
1214:             | ';' :  @Statement
1218:             | * :    >
1225:          ]}
1227:       | * :
1232:    ]
      
1232:    .tReturn
      
1234:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1246:    oPatch( patchLS, localSpace )
1255:    oScopeEnd   % init routine scope, for temporaries
1257:    ;
      
      
1257: UnitFinalization( Node unit, boolean hasStmts ):
1259:    Label label = oLabelNew
1264:    .tLabel  oEmitLabel( label )
1272:    oNodeSetLabel( unit, qFinalLabel, label )
      
1284:    int patchLS
1284:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1293:    oScopeBegin( 0, allocDown )
      
1302:    [ hasStmts
1305:       | true :     
1306:          @Statement
1308:          {[
1308:             | ';' :  @Statement
1312:             | * :    >
1319:          ]}
1321:       | * :
1326:    ]
      
1326:    .tReturn
      
1328:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1340:    oPatch( patchLS, localSpace )
1349:    oScopeEnd   % final routine scope, for temporaries
1351:    ;
      
      
1351: Block( node_type varNodeType, Label labelForBody ):
1353:    @BlockDecls( varNodeType )
1360:    @BlockStmt( labelForBody, oScopeCurrent, false )
1373:    ;
      
      
1373: BlockDecls( node_type varNodeType ):
1375:    {[
1375:       | pConst :     @ConstDecl
1379:       | pType :      @TypeDecl
1383:       | pVar :       @VarDecl( varNodeType )
1392:       | pProcedure : @ProcDecl
1396:       | pFunction :  @FuncDecl
1400:       | * :          >
1415:    ]}
1417:    @CheckForUndefinedMethods
1420:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1420: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1423:    ;
      
      
1423: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1425:    NodeIter it = oNodeGetIter( workspace, qUnits )
1438:    {
1438:       Node unit = oNodeIterValue( it )
1448:       [ oNodeNull( unit )
1455:          | true :  >
1458:          | false :
1460:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1468:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1483:             .tFreeActuals  oEmitInt( 0 )
1491:             oNodeIterNext( it )
1497:       ]
1505:    };
      
      
1508: FinalizeUnits:
1510:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1523:    {
1523:       Node unit = oNodeIterValue( it )
1533:       [ oNodeNull( unit )
1540:          | true :  >
1543:          | false :
1545:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1553:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1568:             .tFreeActuals  oEmitInt( 0 )
1576:             oNodeIterPrev( it )
1582:       ]
1590:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1593: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1595:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1603:    int patchLS
1603:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1612:    [ isMain
1615:       | true :  @InitializeUnits
1618:       | * :
1623:    ]
      
         % insert any code for initialization of this scope's variables
1623:    Code initCode = oNodeGetCode( varScope, qInitCode )
1636:    oEmitCode( initCode )
1642:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1654:    @Statement
      
1656:    [ isMain
1659:       | true :  @FinalizeUnits
1662:       | * :
1667:    ]
      
1667:    .tReturn
      
1669:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1681:    oPatch( patchLS, localSpace )
1691:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1691: MethodModifiers( Node decl ):
1693:    {[
1693:       | pCdecl :
1695:          oNodeSetBoolean( decl, qCdecl, true )
1707:          ';'
      
1709:       | * : >
1716:    ]}
1719:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1719: GetOrCreateInitCode( Node scope ) >> Code:
1721:    Code initCode = oNodeGetCode( scope, qInitCode )
1734:    [ equal_code( initCode, codeNull )
1744:       | true :
1745:          initCode = oCodeNew
1750:          oNodeSetCode( scope, qInitCode, initCode )
1762:       | * :
1767:    ]
1767:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1771: ExternalDecl( Node decl ):
1773:    [ equal_zero( @DeclLevel( decl ) )
1785:       | false :  #eExternalMethodCannotBeNested
1788:       | * :
1793:    ]
1793:    oNodeSetBoolean( decl, qExternal, true )
1805:    [
1805:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1807:          [
1807:             | pName :
1809:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1811:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1822:             | * :
1827:          ]
1827:       | * :
1832:    ]
1833:    ;
      
      
1833: ProcHeaderDecl >> Node:
1835:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1837:    boolean redeclaring = false
1843:    Node decl = oScopeFindInCurrentScope
      
1848:    [ oNodeNull( decl )
1855:       | true :
               % first declaration
1856:          decl = @newIdent( nProc, LAST_ID )
1869:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1880:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1882:          redeclaring = true
1888:          [ oNodeGetBoolean( decl, qBodyDefined )
1898:             | true : #eAlreadyDefined
1901:             | * :
1906:          ]
1906:          [ oNodeGetBoolean( decl, qExternal )
1916:             | true : #eAlreadyDefined
1919:             | * :
1924:          ]
1924:          [ oNodeType( decl )
1931:             | nProc :
1932:             | * : #eAlreadyDefined   % wrong kind
1939:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1939:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1958:          oNodeSet( decl, qParams, Null )
1970:    ]
      
1978:    int level = @ScopeLevel
1984:    boolean nested = greater( level, 0 )
1997:    inc( level )
2003:    oScopeBegin( level, allocUp )
2012:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2017:    [ nested
2020:       | true :
2021:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2036:       | * :
2041:    ]
      
2041:    @FormalArgDecl
2043:    oNodeSet( decl, qParams, paramScope )
2055:    oScopeEnd
2056:    ';'
      
2058:    [ redeclaring
2061:       | false : oScopeDeclare( decl )
2068:       | true :  % TO DO: check that qParams is consistent with qOldParams
2070:    ]
      
2078:    @MethodModifiers( decl )
2085:    >> decl;
      
      
2089: ProcDecl:
2091:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2097:    [
2097:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2099:       | pExternal : @ExternalDecl( decl )
      
2108:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2115:          Node paramScope = oNodeGet( decl, qParams )
2128:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2134:          int level = oNodeGetInt( paramScope, qLevel )
2147:          oScopeBegin( level, allocDown )
2156:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2167:          Label label = oNodeGetLabel( decl, qValue )
2180:          @Block( nLocalVar, label )
2190:          oNodeSetBoolean( decl, qBodyDefined, true )
2202:          oScopeEnd
      
2203:          oScopeEnd  % paramScope
2204:    ]
2204:    ';';
      
      
      
2207: FuncHeaderDecl >> Node:
2209:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2211:    boolean redeclaring = false
2217:    Node decl = oScopeFindInCurrentScope
      
2222:    [ oNodeNull( decl )
2229:       | true :
               % first declaration
2230:          decl = @newIdent( nFunc, LAST_ID )
2243:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2254:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2256:          redeclaring = true
2262:          [ oNodeGetBoolean( decl, qBodyDefined )
2272:             | true : #eAlreadyDefined
2275:             | * :
2280:          ]
2280:          [ oNodeType( decl )
2287:             | nFunc :
2288:             | * : #eAlreadyDefined   % wrong kind
2295:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2295:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2314:          oNodeSet( decl, qParams, Null )
2326:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2345:          oNodeSet( decl, qType, Null )
2357:    ]
      
2365:    int level = @ScopeLevel
2371:    boolean nested = greater( level, 0 )
2384:    inc( level )
2390:    oScopeBegin( level, allocUp )
2399:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2404:    [ nested
2407:       | true :
2408:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2423:       | * :
2428:    ]
      
2428:    @FormalArgDecl
2430:    oNodeSet( decl, qParams, paramScope )
      
2442:    ':'
      
2444:    Node theType
2444:    @TypeRef( theType )
2451:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2463:    Node ptrType = @PointerTypeTo( theType )
2474:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2490:    oScopeEnd
2491:    ';'
      
2493:    [ redeclaring
2496:       | false : oScopeDeclare( decl )
2503:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2505:    ]
      
2513:    @MethodModifiers( decl )
      
2520:    >> decl;
      
      
2524: FuncDecl:
2526:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2532:    [
2532:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2534:       | pExternal : @ExternalDecl( decl )
      
2543:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2550:          Node paramScope = oNodeGet( decl, qParams )
2563:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2569:          int level = oNodeGetInt( paramScope, qLevel )
2582:          oScopeBegin( level, allocDown )
2591:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2602:          Label label = oNodeGetLabel( decl, qValue )
2615:          @Block( nLocalVar, label )
2625:          oNodeSetBoolean( decl, qBodyDefined, true )
2637:          oScopeEnd
      
2638:          oScopeEnd  % paramScope
2639:    ]
2639:    ';';
      
      
2642: FormalArgDecl:
2644:    [
2644:       | '(' :
2646:          {
2646:             NodeVec decls = oNodeVecNew
2651:             Node decl
2651:             boolean isInOut = false
      
2657:             [
2657:                | pVar : isInOut = true
2665:                | * :
2670:             ]
      
2670:             {  pIdent
      
2672:                decl = @newIdent( nParam, LAST_ID )
2685:                oNodeSetBoolean( decl, qInOut, isInOut )
2697:                oNodeVecAppend( decls, decl )
      
2706:                [
2706:                   | ':' : >
2710:                   | ',' :
2712:                ]
2720:             }
      
2722:             Node theType
2722:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2729:             Node allocType
2729:             [ isInOut
2732:                | true :   allocType = @PointerTypeTo( theType )
2744:                | * :      allocType = theType
2755:             ]
      
2755:             int i = 0
2761:             {[ equal( i, oNodeVecSize( decls ) )
2775:                | false :
2776:                   decl = oNodeVecElement( decls, i )
      
2789:                   oNodeSet( decl, qType, theType )
2801:                   oScopeDeclare( decl )
2807:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2823:                   inc( i )
2829:                | * :
2834:                   >
2836:             ]}
      
2838:             oNodeVecDelete( decls )
      
2844:             [
2844:                | ')' : >
2848:                | ';' :
2850:             ]
2858:          }
2860:       | * :
2865:    ];
      
2866: ConstDecl:
2868:    {[
2868:       | pIdent :
2870:          Node decl = @newIdent( nConst, LAST_ID )
2883:          '='
      
2885:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2887:          int val = oValueTop
2892:          oValuePop
2893:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2905:          oNodeSet( decl, qType, IntegerType )
      
2917:          oScopeDeclare( decl )
2923:          ';'
2925:       | * :
2930:          >
2932:    ]};
      
2935: TypeDecl:
2937:    {[
2937:       | pIdent :
2939:          Node decl = @newIdent( nTypeDecl, LAST_ID )
2952:          '='
2954:          Node theType
2954:          @TypeRef( theType )
2961:          oNodeSet( decl, qType, theType )
2973:          oScopeDeclare( decl )
2979:          ';'
2981:       | * :
2986:          >
2988:    ]};
      
2991: VarDecl( node_type varNodeType ):
2993:    {[
2993:       | pIdent :
2995:          NodeVec decls = oNodeVecNew
3000:          Node decl
3000:          {
3000:             decl = @newIdent( varNodeType, LAST_ID )
3013:             oNodeVecAppend( decls, decl )
3022:             [
3022:                | ',' :
3024:                   pIdent
3026:                | * :
3031:                   >
3033:             ]
3033:          }
3035:          ':'
3037:          Node theType
3037:          @TypeRef( theType )
      
3044:          int i = 0
3050:          {[ equal( i, oNodeVecSize( decls ) )
3064:             | false :
3065:                decl = oNodeVecElement( decls, i )
3078:                oNodeSet( decl, qType, theType )
3090:                oScopeDeclareAlloc( decl )
3096:                inc( i )
3102:             | * :
3107:               >
3109:          ]}
      
               % optional initialization
3111:          [
3111:             | '=' :
3113:                [ oNodeVecSize( decls )
3120:                   | 1 :
3121:                   | * :  #eOnlyOneVarCanBeInitialized
3128:                ]
      
                     % we need an initCode stream for this scope
3128:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3138:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3144:                boolean changedScope = false
3150:                [ equal_zero( @ScopeLevel )
3157:                   | true : oScopeEnter( initScope )
3164:                            changedScope = true
3170:                   | * :
3175:                ]
                     % generate assignment in initCode stream
3175:                @LValueVar( decl )
3182:                @Expr
3184:                @MatchTypes
3186:                @Assign
3188:                [ changedScope
3191:                   | true : oScopeEnd
3193:                   | * :
3198:                ]
3198:                oCodePop
                   
3199:             | * :
3204:          ]
      
3204:          oNodeVecDelete( decls )
3210:          ';'
3212:       | * :
3217:          >
3219:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3222: TypeRef( out Node resultType ):
3224:    [
3224:       | pIdent :           % previously named type (including intrinsics)
3226:          Node decl = oScopeFindRequire
3231:          @ResolveUnitRef( decl )
3238:          [ oNodeType( decl )
3245:             | nTypeDecl :
3246:                resultType = oNodeGet( decl, qType )
3259:             | * :
3264:                #eNotType
3266:                resultType = IntegerType
3272:          ]
         
3272:       | pArray :
3274:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3276:          NodeVec dimensions = oNodeVecNew
      
3281:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3281:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3291:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3303:             @ConstExpr
3305:             oNodeSetInt( subrange, qLow, oValueTop )
3316:             oValuePop
3317:             '..'
3319:             @ConstExpr
3321:             oNodeSetInt( subrange, qHigh, oValueTop )
3332:             oValuePop
3333:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3345:             oTypeAdd( subrange )
      
3351:             Node a = oNodeNew( nArrayType )
3361:             oNodeSet( a, qIndexType, subrange )
      
3373:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3382:             [
3382:                | ']' : >
3386:                | ',' :
3388:             ]
3396:          }
      
3398:          pOf
3400:          Node baseType
3400:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3407:          int dim = oNodeVecSize( dimensions )
      
3417:          {
3417:              dec(dim)
      
3423:              Node a = oNodeVecElement( dimensions, dim )
      
3436:              oNodeSet( a, qBaseType, baseType )
3448:              Node subrange = oNodeGet( a, qIndexType )
3461:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3488:              inc( width )
3494:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3520:              oTypeAdd( a )
3526:              baseType = a
      
3532:              [ equal_zero(dim)
3539:                  | true:  >
3542:                  | *:
3547:              ]
3547:          }
      
3549:          resultType = oNodeVecElement( dimensions, 0 )
3562:          oNodeVecDelete( dimensions )
      
3568:       | '^' :
3570:          Node theType
3570:          @TypeRef( theType )
3577:          resultType = @PointerTypeTo( theType )
      
3588:       | pRecord :
3590:          resultType = oNodeNew( nRecordType )
3600:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3609:          @VarDecl( nRecordField )
      
3616:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3628:          [ equal_zero( size )
3635:             | true : #eRecordEmpty
3638:             | * :
3643:          ]
      
3643:          pEnd
      
3645:          oNodeSet( resultType, qScope, oScopeCurrent )
3656:          oNodeSetInt( resultType, qSize, size )
3668:          oScopeEnd
3669:          oTypeAdd( resultType )
      
      
3675:       | '(' :
               % An enum type declaration.
3677:          resultType = oNodeNew( nEnumType )
3687:          int value = 0
3693:          int numValues = 0
3699:          boolean first = true
      
               % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
               % That will let programs use either <val> or <enumType>.<val>
3705:          Node outerScope = oScopeCurrent
3710:          oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
3719:          {
                  % TO DO: assert that name not already seen in this scope, i.e. this enum.
                  %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
                  %  It might be in some other higher/used scope.
3719:             pIdent
3721:             Node decl = @newIdent( nEnumValue, LAST_ID )
3734:             Node decl2 = @newIdent( nEnumValue, LAST_ID )
3747:             oNodeSet( decl, qType, resultType )
3759:             oNodeSet( decl2, qType, resultType )
      
                  % build up name table, for i/o
3771:             int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
3784:             oNodeSetInt( decl, qNameOffset, nameOffset )
3796:             oNodeSetInt( decl2, qNameOffset, nameOffset )
3808:             [
3808:                | '=', ':=' :
3810:                   @ConstExpr
                        % value must be ascending
                        % this obviously doesn't apply to the first value
3812:                   [ equal_zero( numValues )
3819:                      | false :
3820:                         [ greater( oValueTop, value )
3829:                            | false :   #eEnumValueNotAscending
3832:                            | * :
3837:                         ]
3837:                      | * :
3842:                   ]
3842:                   value = oValueTop
3847:                   oValuePop
3848:                | * :
3855:             ]
3855:             oNodeSetInt( decl, qValue, value )
3867:             oNodeSetInt( decl2, qValue, value )
3879:             oScopeDeclare( decl )
      
3885:             oScopeEnter( outerScope )
3891:             oScopeDeclare( decl2 )
3897:             oScopeEnd
      
3898:             inc( value )
3904:             inc( numValues )
3910:             [
3910:                | ',' :
3912:                | * :    >
3919:             ]
3919:          }
3921:          ')'
      
3923:          oNodeSet( resultType, qScope, oScopeCurrent )
3934:          oNodeSetInt( resultType, qSize, 4 )   % always integer sized
3946:          oScopeEnd
      
               % Finish creation of the name table
               %    struct {
               %      int    value;
               %      int    padding;
               %      char*  name;
               %    } table[ numValues + 1 ];
               %  final entry will have name == nullptr
               %
               % I'll need to generate init code, to store pointers in global data,
               % since I don't have a relocation mechanism for static data at the moment.
3947:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3958:          oScopeEnter( globalScope )
3964:          int size = multiply( add( numValues, 1 ), 16 )
3984:          int addr = oScopeAlloc( size, 8 )
3997:          oScopeEnd
3998:          oNodeSetInt( resultType, qNameTable, addr )
               % loop over enum values
4010:          NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4030:          {
4030:             Node enumValue = oNodeIterValue( it )
4040:             [ oNodeNull( enumValue )
4047:                | true :  >
4050:                | * :
4055:             ]
4055:             .tPushAddrGlobal  oEmitInt( addr )
4063:             .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4078:             .tAssignI
4080:             addr = add( addr, 8 )
4093:             .tPushAddrGlobal  oEmitInt( addr )
4101:             .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4116:             .tAssignP
4118:             addr = add( addr, 8 )
4131:             oNodeIterNext( it )
4137:          }
               % final table entry
4139:          .tPushAddrGlobal  oEmitInt( addr )
4147:          .tPushConstI  oEmitInt( 0 )
4155:          .tAssignI
4157:          addr = add( addr, 8 )
4170:          .tPushAddrGlobal  oEmitInt( addr )
4178:          .tPushConstI  oEmitInt( 0 )
4186:          .tAssignP
4188:          addr = add( addr, 8 )
4201:          oCodePop
      
4202:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4208:       | pSet :
4210:          pOf
4212:          Node theType
4212:          @TypeRef( theType )
4219:       | * :       % this works for cases except where expr starts with an id
4234:          @ConstExpr '..' @ConstExpr
4240:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
4241: ConstExpr:
4243:    [
4243:       | pIntLit :
4245:          oValuePush( TOKEN_VALUE )
4250:       | pIdent :
4252:          Node decl = oScopeFindRequire
4257:          @ResolveUnitRef( decl )
4264:          [ oNodeType( decl )
4271:             | nConst :
4272:                oValuePush( oNodeGetInt( decl, qValue ) )
4285:             | * :
4290:                #eNotConst
4292:                oValuePush( 0 )
4298:          ]
4298:       | pMinus :
4300:          @ConstExpr
4302:          oValueNegate
4303:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4314: Expr:
4316:    Label falseLabel = labelNull
      
4322:    @ExprAllowCF( falseLabel )
4329:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4337: BooleanExprControlFlow( out Label falseLabel ):
4339:    @ExprAllowCF( falseLabel )
4346:    [ oTypeSNodeType
4348:       | nBooleanCFType :
4349:       | nBooleanType :
               % convert value to control flow
4351:          falseLabel = oLabelNew
4356:          .tJumpFalse  oEmitLabel( falseLabel )
4364:       | * :
4371:          #eNotBoolean
4373:    ]
4373:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4375: CFToVal( inout Label falseLabel ):
4377:    [ oTypeSNodeType
4379:       | nBooleanCFType :
4380:          Label doneLabel = oLabelNew
4385:          .tPushConstI  oEmitInt( 1 )
4393:          .tJump  oEmitLabel( doneLabel )
4401:          .tLabel  oEmitLabel( falseLabel )
4409:          .tPushConstI  oEmitInt( 0 )
4417:          .tLabel  oEmitLabel( doneLabel )
4425:          oTypeSPop
4426:          oTypeSPush( BooleanType )
4432:          falseLabel = labelNull
4438:       | * :
4443:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4444: ValToCF( out Label falseLabel ):
4446:    [ oTypeSNodeType
4448:       | nBooleanType :
4449:          falseLabel = oLabelNew
4454:          .tJumpFalse  oEmitLabel( falseLabel )
4462:          oTypeSPop
4463:          oTypeSPush( BooleanCFType )
4469:       | * :
4474:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
4475: ExprAllowCF( out Label falseLabel ):
4477:    @BoolExprAllowCF( falseLabel )
4484:    {[
4484:       | '=' :
4486:          @CFToVal( falseLabel )
4493:          @BoolExprAllowCF( falseLabel )
4500:          @CFToVal( falseLabel )
4507:          @MatchTypes
4509:          [ oTypeSNodeType
4511:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
4514:             | nPointerType :                .tEqualP
4518:             | nCharType, nStringType :      #eNotImplemented
4522:             | * :                           #eNotAllowed
4539:          ]
4539:          oTypeSPop
4540:          oTypeSPush( BooleanType )
      
4546:       | '<>' :
4548:          @CFToVal( falseLabel )
4555:          @BoolExprAllowCF( falseLabel )
4562:          @CFToVal( falseLabel )
4569:          @MatchTypes
4571:          [ oTypeSNodeType
4573:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
4576:             | nPointerType :                .tNotEqualP
4580:             | nCharType, nStringType :      #eNotImplemented
4584:             | * :                           #eNotAllowed
4601:          ]
4601:          oTypeSPop
4602:          oTypeSPush( BooleanType )
      
4608:       | '<' :
4610:          @CFToVal( falseLabel )
4617:          @BoolExprAllowCF( falseLabel )
4624:          @CFToVal( falseLabel )
4631:          @MatchTypes
4633:          [ oTypeSNodeType
4635:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
4638:             | nCharType, nStringType :      #eNotImplemented
4642:             | * :                           #eNotAllowed
4657:          ]
4657:          oTypeSPop
4658:          oTypeSPush( BooleanType )
      
4664:       | '>' :
4666:          @CFToVal( falseLabel )
4673:          @BoolExprAllowCF( falseLabel )
4680:          @CFToVal( falseLabel )
4687:          @MatchTypes
4689:          [ oTypeSNodeType
4691:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
4694:             | nCharType, nStringType :      #eNotImplemented
4698:             | * :                           #eNotAllowed
4713:          ]
4713:          oTypeSPop
4714:          oTypeSPush( BooleanType )
      
4720:       | '<=' :
4722:          @CFToVal( falseLabel )
4729:          @BoolExprAllowCF( falseLabel )
4736:          @CFToVal( falseLabel )
4743:          @MatchTypes
4745:          [ oTypeSNodeType
4747:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
4750:             | nCharType, nStringType :      #eNotImplemented
4754:             | * :                           #eNotAllowed
4769:          ]
4769:          oTypeSPop
4770:          oTypeSPush( BooleanType )
      
4776:       | '>=' :
4778:          @CFToVal( falseLabel )
4785:          @BoolExprAllowCF( falseLabel )
4792:          @CFToVal( falseLabel )
4799:          @MatchTypes
4801:          [ oTypeSNodeType
4803:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
4806:             | nCharType, nStringType :      #eNotImplemented
4810:             | * :                           #eNotAllowed
4825:          ]
4825:          oTypeSPop
4826:          oTypeSPush( BooleanType )
      
4832:       | * :
4847:          >
4849:    ]};
      
      
4852: BoolExprAllowCF( out Label falseLabel ):
4854:    Label trueLabel = labelNull
      
4860:    @BoolTermAllowCF( falseLabel )
4867:    {[
4867:       | pOr :
4869:          [ oTypeSNodeType
4871:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4872:                [ equal_label( trueLabel, labelNull )
4882:                   | true :  trueLabel = oLabelNew
4888:                   | * :
4893:                ]
4893:                .tJump  oEmitLabel( trueLabel )
4901:             | nBooleanType :
4903:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4910:                [ equal_label( trueLabel, labelNull )
4920:                   | true :  trueLabel = oLabelNew
4926:                   | * :
4931:                ]
4931:                .tJump  oEmitLabel( trueLabel )
4939:             | * : #eNotBoolean
4948:          ]
4948:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4949:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4957:          falseLabel = labelNull
4963:          @BoolTermAllowCF( falseLabel )
      
4970:          [ oTypeSNodeType
4972:             | nBooleanCFType :
4973:             | nBooleanType :
4975:                @ValToCF( falseLabel )
4982:             | * : #eNotBoolean
4991:          ]
      
4991:          oTypeSPop
4992:          oTypeSPush( BooleanCFType )
      
4998:       | * :
5003:          >
5005:    ]}
      
         % any short-circuit trues jump here to the end
5007:    [ equal_label( trueLabel, labelNull )
5017:       | false :
5018:          .tLabel  oEmitLabel( trueLabel )
5026:       | * :
5031:    ]
5032:    ;
      
      
5032: BoolTermAllowCF( out Label falseLabel ):
5034:    Label overallFalseLabel = labelNull
      
5040:    @BoolFactorAllowCF( falseLabel )
5047:    {[
5047:       | pAnd :
5049:          [ oTypeSNodeType
5051:             | nBooleanCFType :
5052:             | nBooleanType :
5054:                @ValToCF( falseLabel )
5061:             | * :
5068:                #eNotBoolean
5070:          ]
5070:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5071:          [ equal_label( overallFalseLabel, labelNull )
5081:             | true :
5082:                overallFalseLabel = oLabelNew
5087:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5101:                falseLabel = overallFalseLabel
5107:             | * :
5112:          ]
      
5112:          Label factorFalseLabel = labelNull
5118:          @BoolFactorAllowCF( factorFalseLabel )
      
5125:          [ oTypeSNodeType
5127:             | nBooleanCFType :
5128:             | nBooleanType :
5130:                @ValToCF( factorFalseLabel )
5137:             | * : #eNotBoolean
5146:          ]
5146:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5160:       | * :
5165:          >
5167:    ]};
      
5170: BoolFactorAllowCF( out Label falseLabel ):
5172:    [
5172:       | pNot :
5174:          Label factorFalseLabel = labelNull
      
5180:          @BoolFactorAllowCF( factorFalseLabel )
5187:          [ oTypeSNodeType
5189:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5190:                falseLabel = oLabelNew
5195:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5203:                .tLabel  oEmitLabel( factorFalseLabel )
      
5211:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5213:                .tNot
      
5215:             | * : #eNotBoolean
5224:          ]
      
5224:       | * :
5229:          @ArithExprAllowCF( falseLabel )
5236:    ];
      
5237: ArithExprAllowCF( out Label falseLabel ):
5239:    @TermAllowCF( falseLabel )
5246:    {[
5246:       | pPlus :
5248:          @RequireIntPop
5250:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5257:          @RequireInt
5259:          .tAddI
5261:       | pMinus :
5263:          @RequireIntPop
5265:          @TermAllowCF( falseLabel )
5272:          @RequireInt
5274:          .tSubI
5276:       | * :
5283:          >
5285:    ]};
      
5288: TermAllowCF( out Label falseLabel ):
5290:    @FactorAllowCF( falseLabel )
5297:    {[
5297:       | pTimes :
5299:          @RequireIntPop
5301:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5308:          @RequireInt
5310:          .tMultI
5312:       | pDivide :
5314:          @RequireIntPop
5316:          @FactorAllowCF( falseLabel )
5323:          @RequireInt
5325:          .tDivI
5327:       | * :
5334:          >
5336:    ]};
      
5339: FactorAllowCF( out Label falseLabel ):
5341:    [
5341:       | pPlus :
5343:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5350:          @RequireInt
5352:       | pMinus :
5354:          @PrimaryAllowCF( falseLabel )
5361:          @RequireInt
5363:          .tNegI
5365:       | * :
5372:          @PrimaryAllowCF( falseLabel )
5379:    ];
      
5380: PrimaryAllowCF( out Label falseLabel ):
5382:    [
5382:       | pIntLit :
5384:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5391:          oTypeSPush( IntegerType )
      
5397:       | '(' :
5399:          @ExprAllowCF( falseLabel )
5406:          ')'
      
5408:       | pStrLit :
5410:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
5419:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
5427:          oTypeSPush( StringType )
      
5433:       | pIdent :
5435:          Node decl = oScopeFindRequire
5440:          @ResolveUnitRef( decl )
5447:          Node theType
      
5447:          [ oNodeType( decl )
5454:             | nFunc :
      
5455:                @Call( decl )
      
5462:             | nConst, nEnumValue :
5464:                theType = oNodeGet( decl, qType )
5477:                oTypeSPush( theType )
5483:                [ oTypeSNodeType
5485:                   | nIntegerType, nEnumType, nBooleanType :
5486:                      .tPushConstI @EmitValue( decl )
5495:                   | * :
5504:                      #eNotImplemented
5506:                ]
      
5506:             | nGlobalVar, nLocalVar, nParam :
5508:                @VarExpr( decl )
      
5515:             | * :
5530:                #eNotValue
5532:                oTypeSPush( IntegerType )
5538:          ]
      
5538:       | '@' :        % @var -- pointer to var
5540:          pIdent
      
5542:          Node decl = oScopeFindRequire
5547:          @ResolveUnitRef( decl )
5554:          Node theType
      
5554:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5561:          theType = oTypeSTop
5566:          oTypeSPop
5567:          Node ptrType = @PointerTypeTo( theType )
5578:          oTypeSPush( ptrType )
      
5584:       | * :
5597:          #eNotValue
5599:          oTypeSPush( IntegerType )
5605:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5606: VarExpr( Node decl ):
5608:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5621:    int uplevels = @DeclUpLevels( decl )
      
5632:    oTypeSPush( theType )
5638:    [ oTypeSNodeType
5640:       | nIntegerType, nEnumType :
5641:          [ oNodeType( decl )
5648:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
5658:             | nLocalVar :
5660:                [ equal_zero( uplevels )
5667:                   | true :  .tPushLocalI  @EmitValue( decl )
5677:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5697:                ]
5697:             | nParam :
5699:                [ oNodeGetBoolean( decl, qInOut )
5709:                   | true :    % VAR param points to the var.  Auto dereference.
5710:                      [ equal_zero( uplevels )
5717:                         | true :  .tPushParamP  @EmitValue( decl )
5727:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5747:                      ]
5747:                      .tFetchI
5749:                   | * :
5754:                      [ equal_zero( uplevels )
5761:                         | true :  .tPushParamI  @EmitValue( decl )
5771:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5791:                      ]
5791:                ]
5791:          ]
      
5801:       | nBooleanType :
5803:          [ oNodeType( decl )
5810:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5820:             | nLocalVar :
5822:                [ equal_zero( uplevels )
5829:                   | true :  .tPushLocalB  @EmitValue( decl )
5839:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5859:                ]
5859:             | nParam :
5861:                [ oNodeGetBoolean( decl, qInOut )
5871:                   | true :    % VAR param points to the var.  Auto dereference.
5872:                      [ equal_zero( uplevels )
5879:                         | true :  .tPushParamP  @EmitValue( decl )
5889:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5909:                      ]
5909:                      .tFetchB
5911:                   | * :
5916:                      [ equal_zero( uplevels )
5923:                         | true :  .tPushParamB  @EmitValue( decl )
5933:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5953:                      ]
5953:                ]
5953:          ]
      
5963:       | nCharType, nStringType, nFileType :
5965:          #eNotImplemented
      
5967:       | nPointerType :
5969:          [ oNodeType( decl )
5976:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5986:             | nLocalVar :
5988:                [ equal_zero( uplevels )
5995:                   | true :  .tPushLocalP  @EmitValue( decl )
6005:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6025:                ]
6025:             | nParam :
6027:                [ oNodeGetBoolean( decl, qInOut )
6037:                   | true :    % VAR param points to the var.  Auto dereference.
6038:                      [ equal_zero( uplevels )
6045:                         | true :  .tPushParamP  @EmitValue( decl )
6055:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6075:                      ]
6075:                      .tFetchP
6077:                   | * :
6082:                      [ equal_zero( uplevels )
6089:                         | true :  .tPushParamP  @EmitValue( decl )
6099:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6119:                      ]
6119:                ]
6119:          ]
6129:          [
6129:             | '^' :             % dereferenced
6131:                oTypeSPop
6132:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6145:                @LValueIndexes
6147:                @FetchVar
6149:             | * :               % just ptr value alone
6154:          ]
      
6154:       | * :
               % compound type
               % first, push addr of start of var
6171:          [ oNodeType( decl )
6178:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6188:             | nLocalVar :
6190:                [ equal_zero( uplevels )
6197:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6207:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6227:                ]
6227:             | nParam :
6229:                [ oNodeGetBoolean( decl, qInOut )
6239:                   | true :    % VAR param points to the var.  Auto dereference.
6240:                      [ equal_zero( uplevels )
6247:                         | true :  .tPushParamP  @EmitValue( decl )
6257:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6277:                      ]
6277:                   | * :
6282:                      [ equal_zero( uplevels )
6289:                         | true :  .tPushAddrParam  @EmitValue( decl )
6299:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6319:                      ]
6319:                ]
6319:          ]
               % modify addr for subscripts, field references, etc
6329:          @LValueIndexes
               % get final value
6331:          @FetchVar
6333:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
6334: FetchVar:
6336:    [ oTypeSNodeType
6338:       | nIntegerType, nEnumType :   .tFetchI
6341:       | nBooleanType :   .tFetchB
6345:       | nCharType, nStringType, nFileType : #eNotImplemented
6349:       | nPointerType :   .tFetchP
6353:       | * :              % compound type; leave as addr
6370:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
6371: LValueIndexes:
6373:    {[
6373:       | '[' :       @ArraySubscripts
6377:       | '.' :       @RecordFieldRef
6381:       | '^' :       @PointerDeref
6385:       | * :         >
6396:    ]};
      
6399: ArraySubscripts:
6401:    [ oTypeSNodeType
6403:       | nArrayType :
6404:       | * :       #eNotArray
6411:    ]
6411:    {
6411:       [ oTypeSNodeType
6413:          | nArrayType :
6414:          | * :    #eTooManySubscripts
6421:       ]
      
            % low subscript of this dimension
6421:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
6438:       Node baseType
6438:       baseType = oNodeGet( oTypeSTop, qBaseType )
6450:       oTypeSPop
6451:       oTypeSPush( baseType )
      
6457:       @Expr
6459:       @RequireIntPop
            % adjust for low subscript
6461:       [ equal_zero( low )
6468:          | false :
6469:             .tPushConstI oEmitInt( low ) .tSubI
6479:          | * :
6484:       ]
      
            % multiply by element size
6484:       int size = oNodeGetInt( baseType, qSize )
6497:       [ equal( size, 1 )
6507:          | false :
6508:             .tPushConstI oEmitInt( size ) .tMultI
6518:          | * :
6523:       ]
      
            % update start address
6523:       .tAddPI
6525:       [
6525:          | ']' :  >
6529:          | ',' :
6531:       ]
6539:    };
      
      
6542: RecordFieldRef:
6544:    [ oTypeSNodeType
6546:       | nRecordType :
6547:       | * :    #eNotRecord
6554:    ]
6554:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
6566:    pIdent
6568:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
6573:    [ oNodeType( field )
6580:       | nRecordField :
6581:       | * :   #eNotRecordField
6588:    ]
6588:    oScopeEnd
6589:    int offset = oNodeGetInt( field, qValue )
6602:    [ equal_zero( offset )
6609:       | false :
6610:          .tPushConstI oEmitInt( offset ) .tAddPI
6620:       | * :
6625:    ]
      
         % replace the type on the type stack, with the field type
6625:    oTypeSPop
6626:    oTypeSPush( oNodeGet( field, qType ) )
6640:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
6640: PointerDeref:
6642:    [ oTypeSNodeType
6644:       | nPointerType :
6645:       | * :       #eNotPointer
6652:    ]
6652:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
6654:    Node theType = oTypeSTop
6659:    oTypeSPop
6660:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6674:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6674: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
6676:    @MatchTypes
6679:    ;
      
      
      % Called on first use of an extern method
      %
6679: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
6681:    int strAddr
6681:    String externalName = oNodeGetString( method, qExternalName )
6694:    [ equal_string( externalName, stringNull )
6704:       | true :
6705:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
6726:       | false :
6728:          strAddr = oStringAllocLit( externalName )
6738:    ]
6746:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6762:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6762: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6764:    [ oNodeGetBoolean( method, qExternal )
6774:       | true :
6775:          [ oNodeGetBoolean( method, qCalled )
6785:             | false :
                     % define the extern label on first use
6786:                @DefineExternLabel( method )
6793:             | * :
6798:          ]
6798:      | * :
6803:    ]
6803:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6815:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6828:    Node resultType
6828:    int tempOffset
      
6828:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6845:    [ isFunc
6848:       | true :
6849:          resultType = oNodeGet( method, qType )
6862:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6872:       | * :
6877:    ]
         
      
6877:    Node paramScope = oNodeGet( method, qParams )
6890:    int actualsSize = oNodeGetInt( paramScope, qSize )
6903:    [ cdecl
6906:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6915:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6925:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6933:    [ greater( @DeclLevel( method ), 0 )
6948:       | true :
6949:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6957:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6976:          .tAssignP
6978:       | * :
6983:    ]
      
      
6983:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6996:    Node param = oNodeIterValue( paramIter )
7006:    [
7006:       | '(' :
            
7008:          {
7008:             [ oNodeNull( param )
7015:                | true : >
7018:                | * :
7023:             ]
      
7023:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
7036:             .tPushAddrActual oEmitInt( offset )
7044:             oTypeSPush( oNodeGet( param, qType ) )
      
7057:             [ oNodeGetBoolean( param, qInOut )
7067:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
7068:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
7070:                           @MatchTypes
      
7072:                           .tAssignP
      
7074:                | false :  @Expr
7078:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
7080:                           [ oTypeSNodeType
7082:                              | nIntegerType, nEnumType : .tAssignI
7085:                              | nBooleanType :            .tAssignB
7089:                              | nCharType, nStringType, nFileType :   #eNotImplemented
7093:                              | nPointerType :            .tAssignP
7097:                              | * :
                                       % compound types: copy value into actuals space
7114:                                  int size = oNodeGetInt( oTypeSTop, qSize )
7126:                                  .tCopy  oEmitInt( size )    % multi-word copy
7134:                           ]
7134:             ]
7142:             oTypeSPop
      
7143:             oNodeIterNext( paramIter )
7149:             param = oNodeIterValue( paramIter )
7159:             [ oNodeNull( param )
7166:                | true :  >
7169:                | false :
7171:             ]
      
7179:             ','
7181:          }
      
7183:          ')'
      
7185:       | * :
7190:    ]
      
7190:    [ oNodeNull( param )
7197:       | false :    #eMissingParameter
7200:       | * :
7205:    ]
      
7205:    [ isFunc
7208:       | true :
               % Pass result temp as an additional VAR parameter.
7209:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
7224:          .tPushAddrLocal  oEmitInt( tempOffset )
7232:          .tAssignP
7234:       | * :
7239:    ]
      
7239:    [ cdecl
7242:       | true :
7243:          .tCallCdecl  @EmitValue( method )
7252:       | false :
7254:          .tCall   @EmitValue( method )
7263:    ]
      
7271:    [ isFunc
7274:       | true :
               % push return value from temp
7275:          oTypeSPush( resultType )
      
7281:          [ oTypeSNodeType
7283:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
7292:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
7302:             | nCharType, nStringType, nFileType : #eNotImplemented
7306:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
7316:             | * :              % compound type: push address
7333:                                .tPushAddrLocal  oEmitInt( tempOffset )
7341:          ]
7341:       | * :
7346:    ]
         
7346:    .tFreeActuals  oEmitInt( actualsSize )
7355:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
7355: Statement:
7357:    [
7357:       | pWriteln :     @WritelnStmt
7361:       | pWrite :       @WriteStmt
7365:       | pReadln :      @ReadlnStmt
7369:       | pRead :        @ReadStmt
7373:       | pIf :          @IfStmt
7377:       | pWhile :       @WhileStmt
7381:       | pFor :         @ForStmt
7385:       | pRepeat :      @RepeatStmt
7389:       | pBreak :       @BreakStmt
7393:       | pContinue :    @ContinueStmt
7397:       | pBegin :       @BeginStmt
7401:       | pIdent :       @AssignOrCallStmt
7405:       | * :            % null statement : don't accept any tokens
7432:    ];
      
      
7433: AssignOrCallStmt:
7435:    Node decl = oScopeFindRequire
7440:    @ResolveUnitRef( decl )
7447:    [ oNodeType( decl )
7454:       | nProc :                           @Call( decl )
7462:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
7471:       | nFunc :                           @AssignResultStmt( decl )
7480:       | * :                               #eBadStatement
7495:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
7496: AssignStmt( Node decl ):
      
7498:    @LValueVar( decl )
7505:    ':=' 
7507:    @Expr
7509:    @MatchTypes
7511:    @Assign
7514:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
7514: Assign:
7516:    [ oTypeSNodeType
7518:       | nIntegerType, nEnumType : .tAssignI
7521:       | nBooleanType :            .tAssignB
7525:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
7529:       | nPointerType :            .tAssignP
7533:       | * :
7550:           int size = oNodeGetInt( oTypeSTop, qSize )
7562:           .tCopy  oEmitInt( size )    % multi-word copy
7570:    ]
7570:    oTypeSPop
7572:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
7572: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
7574:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
7590:       | false :   #eNotCurrentFunction
7593:       | * :
7598:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
7598:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
7613:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
7626:    ':='
7628:    @Expr
7630:    @MatchTypes
7632:    [ oTypeSNodeType
7634:       | nIntegerType, nEnumType : .tAssignI
7637:       | nBooleanType :            .tAssignB
7641:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
7645:       | nPointerType :            .tAssignP
7649:       | * :
7666:           int size = oNodeGetInt( oTypeSTop, qSize )
7678:           .tCopy  oEmitInt( size )    % multi-word copy
7686:    ]
7686:    oTypeSPop
7688:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
7688: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
7690:    pIdent
7692:    Node decl = oScopeFindRequire
7697:    @ResolveUnitRef( decl )
7704:    [ oNodeType( decl )
7711:       | nGlobalVar, nLocalVar, nParam :
7712:       | * :  #eNotVar
7723:    ]
7723:    @LValueVar( decl )
7731:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
7731: LValueVar( Node decl ):
7733:    [ oNodeType( decl )
7740:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
7750:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
7761:       | nParam :
7763:          [ oNodeGetBoolean( decl, qInOut )
7773:             | true :   % VAR param points to variable.  No dereference.
7774:                        .tPushParamP @EmitValue( decl )
7783:             | * :      .tPushAddrParam @EmitValue( decl )
7797:          ]
7797:       | * :            #eNotVar
7808:    ]
      
7808:    oTypeSPush( oNodeGet( decl, qType ) )
7821:    @LValueIndexes        % handle subscripts, if any
7824:    ;
      
      
7824: IncVar( Node decl ):
7826:    @LValueVar( decl )
7833:    @RequireIntPop
7835:    @VarExpr( decl )
7842:    oTypeSPop
7843:    .tIncI
7845:    .tAssignI;
      
7848: DecVar( Node decl ):
7850:    @LValueVar( decl )
7857:    @RequireIntPop
7859:    @VarExpr( decl )
7866:    oTypeSPop
7867:    .tDecI
7869:    .tAssignI;
      
      
7872: IfStmt:
7874:    Label falseLabel = labelNull
      
7880:    @BooleanExprControlFlow( falseLabel )
7887:    pThen
7889:    @Statement
7891:    [
7891:       | pElse :
7893:          Label doneLabel = oLabelNew
      
7898:          .tJump  oEmitLabel( doneLabel )
7906:          .tLabel oEmitLabel( falseLabel )
7914:          @Statement
7916:          .tLabel oEmitLabel( doneLabel )
      
7924:       | * :
7929:          .tLabel oEmitLabel( falseLabel )
7937:    ];
      
      
7938: ForStmt:
7940:    pIdent
      
7942:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
7947:    @LValueVar( decl )
7954:    @RequireIntPop
      
7956:    ':='
      
7958:    @Expr
7960:    @RequireIntPop
7962:    .tAssignI
      
7964:    Label breakLabel = oLabelNew
      
7969:    Label checkLabel = oLabelNew
7974:    .tJump  oEmitLabel( checkLabel )
      
7982:    Label continueLabel = oLabelNew
7987:    .tLabel  oEmitLabel( continueLabel )
7995:    [
7995:       | pTo :
7997:          @IncVar( decl )
8004:          .tLabel  oEmitLabel( checkLabel )
8012:          @VarExpr( decl )  oTypeSPop
8020:          @Expr
8022:          @RequireIntPop
8024:          .tGreaterI
8026:          .tJumpTrue  oEmitLabel( breakLabel )
8034:       | pDownto :
8036:          @DecVar( decl )
8043:          .tLabel  oEmitLabel( checkLabel )
8051:          @VarExpr( decl )  oTypeSPop
8059:          @Expr
8061:          @RequireIntPop
8063:          .tLessI
8065:          .tJumpTrue  oEmitLabel( breakLabel )
8073:    ]
8081:    oLoopPush( continueLabel, breakLabel )
8090:    pDo
8092:    @Statement
8094:    .tJump  oEmitLabel( continueLabel )
8102:    .tLabel  oEmitLabel( breakLabel )
8110:    oLoopPop;
      
      
8112: RepeatStmt:
8114:    Label continueLabel = oLabelNew
8119:    .tLabel  oEmitLabel( continueLabel )
      
8127:    Label breakLabel = oLabelNew
      
8132:    oLoopPush( continueLabel, breakLabel )
8141:    @Statement
8143:    {[
8143:       | ';' :
8145:          @Statement
8147:       | pUntil :
8149:          Label falseLabel
8149:          @BooleanExprControlFlow( falseLabel )
8156:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
8170:          >
8172:    ]}
8182:    .tLabel  oEmitLabel( breakLabel )
8190:    oLoopPop;
      
      
8192: WhileStmt:
8194:    Label continueLabel = oLabelNew
8199:    .tLabel  oEmitLabel( continueLabel )
      
8207:    Label breakLabel
8207:    @BooleanExprControlFlow( breakLabel )
      
8214:    oLoopPush( continueLabel, breakLabel )
8223:    pDo
8225:    @Statement
8227:    .tJump  oEmitLabel( continueLabel )
8235:    .tLabel  oEmitLabel( breakLabel )
8243:    oLoopPop;
      
      
8245: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
8247:    [ equal_label( oLoopContinueLabel, labelNull )
8256:       | true :
8257:          #eNotInALoop
8259:       | false :
8261:          .tJump  oEmitLabel( oLoopContinueLabel )
8268:    ];
      
      
8277: BreakStmt:
8279:    [ equal_label( oLoopBreakLabel, labelNull )
8288:       | true :
8289:          #eNotInALoop
8291:       | false :
8293:          .tJump  oEmitLabel( oLoopBreakLabel )
8300:    ];
      
      
8309: BeginStmt:
8311:    @Statement
8313:    {[
8313:       | ';' :   @Statement
8317:       | pEnd :  >
8321:    ]};
      
      
8332: WritelnStmt:
8334:    @WriteStmt
8336:    .tWriteCR;
      
      
8339: WriteStmt:
8341:    [
8341:       | '(' :
8343:          {
8343:             @Expr
8345:             [ oTypeSNodeType
8347:                | nIntegerType :             .tWriteI
8350:                | nBooleanType :             .tWriteBool
8354:                | nStringType :              .tWriteStr
8358:                | nCharType, nFileType :     #eNotImplemented
8362:                | nEnumType :
                        % write name via table lookup
8364:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
8378:                   .tWriteEnum
8380:                | nPointerType :             .tWriteP
8384:                | * :                        #eNotAllowed
8403:             ]
8403:             oTypeSPop
8404:             [
8404:                | ')' : >
8408:                | ',' :
8410:             ]
8418:          }
8420:       | * :
8425:    ];
      
      
8426: ReadlnStmt:      % ***
         % TO DO
8429:    ;
      
8429: ReadStmt:
         % TO DO
8432:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
8432: ScopeLevel >> int:
8434:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
8444: DeclLevel( Node decl ) >> int:
8446:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
8464: DeclUpLevels( Node decl ) >> int:
8466:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8482: MatchTypes:
8484:    node_type nt = oTypeSNodeType
8489:    oTypeSPop
8490:    [ equal_node_type( nt, oTypeSNodeType )
8499:       | false :
8500:          #eTypeMismatch
8502:       | * :
8507:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8508: RequireIntPop:
8510:    [ oTypeSNodeType
8512:       | nIntegerType :
8513:       | * :          #eNotInteger
8520:    ]
8520:    oTypeSPop;
      
8522: RequireInt:
8524:    [ oTypeSNodeType
8526:       | nIntegerType :
8527:       | * :          #eNotInteger
8534:    ];
      
8535: RequireBoolPop:
8537:    [ oTypeSNodeType
8539:       | nBooleanType :
8540:       | * :          #eNotBoolean
8547:    ]
8547:    oTypeSPop;
      
8549: RequireBool:
8551:    [ oTypeSNodeType
8553:       | nBooleanType :
8554:       | * :          #eNotBoolean
8561:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
8562: newType( node_type nt, int size ) >> Node:
8564:   Node node = oNodeNew( nt )
8574:   oNodeSetInt( node, qSize, size )
8586:   oTypeAdd( node )
8592:   >> node
8596:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
8596: newIdent( node_type nt, int id ) >> Node:
8598:   Node t = oNodeNew( nt )
8608:   oNodeSetInt( t, qIdent, id )
8620:   >> t
8624:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
8624: PointerTypeTo( Node theType ) >> Node:
8626:    Node ptrType = oNodeGet( theType, qPointerType )
8639:    [ oNodeNull( ptrType )
8646:       | true :
8647:          ptrType = oNodeNew( nPointerType )
8657:          oNodeSet( ptrType, qBaseType, theType )
8669:          oNodeSetInt( ptrType, qSize, 8 )
8681:          oTypeAdd( ptrType )
8687:          oNodeSet( theType, qPointerType, ptrType )
8699:       | * :
8704:    ]
8704:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
8708: OrdinalLow( Node theType ) >> int:
8710:    [ oNodeType( theType )
8717:       | nIntegerType :  >> oMININT
8720:       | nBooleanType :  >> 0
8725:       | nCharType :     >> 0
8730:       | nEnumType :
8732:          Node enumScope = oNodeGet( theType, qScope )
8745:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
8762:          >> oNodeGetInt( first, qValue )
8772:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
8784:       | * :             #eNotOrdinalType
8799:                         >> 0
8802:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
8803: EmitValue( Node decl ):
8805:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
8819: installBuiltIns:
      
         % install built-in types
8821:    FileType = @newType( nFileType, 4 )
8835:    IntegerType = @newType( nIntegerType, 4 )
8849:    BooleanType = @newType( nBooleanType, 1 )
8863:    BooleanCFType = @newType( nBooleanCFType, 1 )
8877:    CharType = @newType( nCharType, 1 )
8891:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8905:    Node t
      
8905:    t = @newIdent( nTypeDecl, oIdAdd_File )
8918:    oNodeSet( t, qType, FileType )
8930:    oScopeDeclare( t )
      
8936:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
8949:    oNodeSet( t, qType, IntegerType )
8961:    oScopeDeclare( t )
      
8967:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
8980:    oNodeSet( t, qType, BooleanType )
8992:    oScopeDeclare( t )
      
8998:    t = @newIdent( nTypeDecl, oIdAdd_Char )
9011:    oNodeSet( t, qType, CharType )
9023:    oScopeDeclare( t )
      
9029:    t = @newIdent( nTypeDecl, oIdAdd_String )
9042:    oNodeSet( t, qType, StringType )
9054:    oScopeDeclare( t )
      
         % Built-in constants
      
9060:    t = @newIdent( nConst, oIdAdd_True )
9073:    oNodeSet( t, qType, BooleanType )
9085:    oNodeSetInt( t, qValue, 1 )
9097:    oScopeDeclare( t )
      
9103:    t = @newIdent( nConst, oIdAdd_False )
9116:    oNodeSet( t, qType, BooleanType )
9128:    oNodeSetInt( t, qValue, 0 )
9140:    oScopeDeclare( t )
      
9147:    ;
      
9147: end
      
9147: 

Generated code:

   0: oGlobalSpace 10
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 8819
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 17
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 8596
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 4
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 12
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 17
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 8596
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 4
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 14
 173: oJumpForward 178
 175: Choice Lookup Table
          13    103
 178: oInput 4
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 286
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          54    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 439
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrGlobal 2
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oGetAddrGlobal 3
 226: oPushResult
 227: oScopeCurrent
 228: oAssign
 229: oGetLocal 4
 231: oPushResult
 232: oSetResult 7
 234: oPushResult
 235: oGetGlobal 3
 237: oPushResult
 238: oNodeSet
 239: oPop 3
 241: oScopeEnd
 242: oSetResult 18
 244: oPushResult
 245: oCall 1373
 247: oPop 1
 249: oGetGlobal 3
 251: oPushResult
 252: oScopeEnter
 253: oPop 1
 255: oGetAddrLocal 5
 257: oPushResult
 258: oSetResult 1
 260: oAssign
 261: oGetLocal 3
 263: oPushResult
 264: oGetGlobal 2
 266: oPushResult
 267: oGetLocal 5
 269: oPushResult
 270: oCall 1593
 272: oPop 3
 274: oScopeEnd
 275: oInput 19
 277: oScopeEnd
 278: oGetLocal 4
 280: oPushResult
 281: oCall 501
 283: oPop 1
 285: oReturn
 286: oLocalSpace 2
 288: oInput 0
 290: oGetAddrLocal 1
 292: oPushResult
 293: LAST_ID
 294: oPushResult
 295: oCall 580
 297: oPop 1
 299: oAssign
 300: oGetLocal 1
 302: oPushResult
 303: oSetResult 0
 305: oPushResult
 306: equal_node
 307: oPop 2
 309: oChoice 379
 311: oGetParam 1
 313: oPushResult
 314: oSetResult 5
 316: oPushResult
 317: oGetLocal 1
 319: oPushResult
 320: oNodeAddLast
 321: oPop 3
 323: oGetAddrLocal 2
 325: oPushResult
 326: oSetResult 10
 328: oPushResult
 329: oNodeNew
 330: oPop 1
 332: oAssign
 333: oGetLocal 2
 335: oPushResult
 336: oSetResult 4
 338: oPushResult
 339: oGetLocal 1
 341: oPushResult
 342: oSetResult 4
 344: oPushResult
 345: oNodeGetInt
 346: oPop 2
 348: oPushResult
 349: oNodeSetInt
 350: oPop 3
 352: oGetLocal 2
 354: oPushResult
 355: oSetResult 9
 357: oPushResult
 358: oGetLocal 1
 360: oPushResult
 361: oSetResult 9
 363: oPushResult
 364: oNodeGet
 365: oPop 2
 367: oPushResult
 368: oNodeSet
 369: oPop 3
 371: oGetLocal 2
 373: oPushResult
 374: oScopeDeclare
 375: oPop 1
 377: oJumpForward 382
 379: Choice Lookup Table
           0    311
 382: oInputChoice 386
 384: oJumpForward 391
 386: Choice Lookup Table
          12    384
 389: oJumpForward 393
 391: oJumpBack 288
 393: oInput 4
 395: oReturn
 396: oLocalSpace 1
 398: oGetFromParam 1
 400: oPushResult
 401: oNodeType
 402: oPop 1
 404: oChoice 435
 406: oGetAddrLocal 1
 408: oPushResult
 409: oGetFromParam 1
 411: oPushResult
 412: oSetResult 9
 414: oPushResult
 415: oNodeGet
 416: oPop 2
 418: oAssign
 419: oInput 19
 421: oInput 0
 423: oGetParam 1
 425: oPushResult
 426: oGetLocal 1
 428: oPushResult
 429: oScopeFindRequireInScope
 430: oPop 1
 432: oAssign
 433: oJumpForward 438
 435: Choice Lookup Table
          10    406
 438: oReturn
 439: oLocalSpace 2
 441: oGetAddrLocal 1
 443: oPushResult
 444: oGetParam 1
 446: oPushResult
 447: oSetResult 5
 449: oPushResult
 450: oNodeGetIter
 451: oPop 2
 453: oAssign
 454: oGetAddrLocal 2
 456: oPushResult
 457: oGetLocal 1
 459: oPushResult
 460: oNodeIterValue
 461: oPop 1
 463: oAssign
 464: oGetLocal 2
 466: oPushResult
 467: oNodeNull
 468: oPop 1
 470: oChoice 487
 472: oGetLocal 2
 474: oPushResult
 475: oSetResult 9
 477: oPushResult
 478: oNodeGet
 479: oPop 2
 481: oPushResult
 482: oScopeEnter
 483: oPop 1
 485: oJumpForward 492
 487: Choice Lookup Table
           0    472
 490: oJumpForward 500
 492: oGetAddrLocal 1
 494: oPushResult
 495: oNodeIterNext
 496: oPop 1
 498: oJumpBack 454
 500: oReturn
 501: oLocalSpace 2
 503: oGetAddrLocal 1
 505: oPushResult
 506: oGetParam 1
 508: oPushResult
 509: oSetResult 5
 511: oPushResult
 512: oNodeGetIterLast
 513: oPop 2
 515: oAssign
 516: oGetAddrLocal 2
 518: oPushResult
 519: oGetLocal 1
 521: oPushResult
 522: oNodeIterValue
 523: oPop 1
 525: oAssign
 526: oGetLocal 2
 528: oPushResult
 529: oNodeNull
 530: oPop 1
 532: oChoice 566
 534: oScopeCurrent
 535: oPushResult
 536: oGetLocal 2
 538: oPushResult
 539: oSetResult 9
 541: oPushResult
 542: oNodeGet
 543: oPop 2
 545: oPushResult
 546: oNodeEqual
 547: oPop 2
 549: oChoice 557
 551: oJumpForward 563
 553: oError 25
 555: oJumpForward 563
 557: Choice Lookup Table
           0    553
           1    551
 562: oEndChoice
 563: oScopeEnd
 564: oJumpForward 571
 566: Choice Lookup Table
           0    534
 569: oJumpForward 579
 571: oGetAddrLocal 1
 573: oPushResult
 574: oNodeIterPrev
 575: oPop 1
 577: oJumpBack 516
 579: oReturn
 580: oLocalSpace 2
 582: oGetAddrLocal 1
 584: oPushResult
 585: oGetGlobal 1
 587: oPushResult
 588: oSetResult 1
 590: oPushResult
 591: oSetResult 4
 593: oPushResult
 594: oGetParam 1
 596: oPushResult
 597: oNodeFind
 598: oPop 4
 600: oAssign
 601: oGetLocal 1
 603: oPushResult
 604: oSetResult 0
 606: oPushResult
 607: equal_node
 608: oPop 2
 610: oChoice 617
 612: oGetLocal 1
 614: oReturn
 615: oJumpForward 620
 617: Choice Lookup Table
           0    612
 620: oGetAddrLocal 2
 622: oPushResult
 623: oGetParam 1
 625: oPushResult
 626: oIncludeUnitFile
 627: oPop 1
 629: oAssign
 630: oGetLocal 2
 632: oChoice 641
 634: oError 24
 636: oSetResult 0
 638: oReturn
 639: oJumpForward 644
 641: Choice Lookup Table
           0    634
 644: oGetAddrLocal 1
 646: oPushResult
 647: oCall 655
 649: oAssign
 650: oIncludeEnd
 651: oGetLocal 1
 653: oReturn
 654: oReturn
 655: oLocalSpace 2
 657: oInput 55
 659: oInput 0
 661: oGetAddrLocal 1
 663: oPushResult
 664: oSetResult 5
 666: oPushResult
 667: oNodeNew
 668: oPop 1
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 4
 676: oPushResult
 677: LAST_ID
 678: oPushResult
 679: oNodeSetInt
 680: oPop 3
 682: oGetAddrLocal 2
 684: oPushResult
 685: oSetResult 6
 687: oPushResult
 688: oNodeNew
 689: oPop 1
 691: oAssign
 692: oGetLocal 2
 694: oPushResult
 695: oSetResult 4
 697: oPushResult
 698: LAST_ID
 699: oPushResult
 700: oNodeSetInt
 701: oPop 3
 703: oGetLocal 1
 705: oPushResult
 706: oSetResult 8
 708: oPushResult
 709: oGetLocal 2
 711: oPushResult
 712: oNodeSet
 713: oPop 3
 715: oInput 4
 717: oInput 56
 719: oInputChoice 730
 721: oGetLocal 1
 723: oPushResult
 724: oCall 286
 726: oPop 1
 728: oJumpForward 733
 730: Choice Lookup Table
          54    721
 733: oGetLocal 1
 735: oPushResult
 736: oCall 439
 738: oPop 1
 740: oSetResult 0
 742: oPushResult
 743: oSetResult 0
 745: oPushResult
 746: oScopeBegin
 747: oPop 2
 749: oGetLocal 1
 751: oPushResult
 752: oSetResult 9
 754: oPushResult
 755: oScopeCurrent
 756: oPushResult
 757: oNodeSet
 758: oPop 3
 760: oGetAddrGlobal 2
 762: oPushResult
 763: oScopeCurrent
 764: oAssign
 765: oSetResult 0
 767: oPushResult
 768: oSetResult 1
 770: oPushResult
 771: oScopeBegin
 772: oPop 2
 774: oGetAddrGlobal 3
 776: oPushResult
 777: oScopeCurrent
 778: oAssign
 779: oGetLocal 1
 781: oPushResult
 782: oSetResult 13
 784: oPushResult
 785: oGetGlobal 3
 787: oPushResult
 788: oNodeSet
 789: oPop 3
 791: oScopeEnd
 792: oGetLocal 1
 794: oPushResult
 795: oCall 976
 797: oPop 1
 799: oScopeEnd
 800: oInput 57
 802: oInputChoice 813
 804: oGetLocal 2
 806: oPushResult
 807: oCall 286
 809: oPop 1
 811: oJumpForward 816
 813: Choice Lookup Table
          54    804
 816: oGetLocal 2
 818: oPushResult
 819: oCall 439
 821: oPop 1
 823: oGetLocal 1
 825: oPushResult
 826: oSetResult 9
 828: oPushResult
 829: oNodeGet
 830: oPop 2
 832: oPushResult
 833: oScopeEnter
 834: oPop 1
 836: oSetResult 0
 838: oPushResult
 839: oSetResult 0
 841: oPushResult
 842: oScopeBegin
 843: oPop 2
 845: oGetLocal 1
 847: oPushResult
 848: oSetResult 10
 850: oPushResult
 851: oScopeCurrent
 852: oPushResult
 853: oNodeSet
 854: oPop 3
 856: oScopeCurrent
 857: oPushResult
 858: oSetResult 16
 860: oPushResult
 861: oGetLocal 1
 863: oPushResult
 864: oSetResult 9
 866: oPushResult
 867: oNodeGet
 868: oPop 2
 870: oPushResult
 871: oNodeSet
 872: oPop 3
 874: oGetAddrGlobal 2
 876: oPushResult
 877: oScopeCurrent
 878: oAssign
 879: oGetLocal 1
 881: oPushResult
 882: oCall 1061
 884: oPop 1
 886: oInputChoice 900
 888: oGetLocal 1
 890: oPushResult
 891: oSetResult 1
 893: oPushResult
 894: oCall 1071
 896: oPop 2
 898: oJumpForward 913
 900: Choice Lookup Table
          58    888
 903: oGetLocal 1
 905: oPushResult
 906: oSetResult 0
 908: oPushResult
 909: oCall 1071
 911: oPop 2
 913: oInputChoice 927
 915: oGetLocal 1
 917: oPushResult
 918: oSetResult 1
 920: oPushResult
 921: oCall 1257
 923: oPop 2
 925: oJumpForward 940
 927: Choice Lookup Table
          59    915
 930: oGetLocal 1
 932: oPushResult
 933: oSetResult 0
 935: oPushResult
 936: oCall 1257
 938: oPop 2
 940: oInput 34
 942: oInput 19
 944: oScopeEnd
 945: oScopeEnd
 946: oGetLocal 2
 948: oPushResult
 949: oCall 501
 951: oPop 1
 953: oGetLocal 1
 955: oPushResult
 956: oCall 501
 958: oPop 1
 960: oGetGlobal 1
 962: oPushResult
 963: oSetResult 1
 965: oPushResult
 966: oGetLocal 1
 968: oPushResult
 969: oNodeAddLast
 970: oPop 3
 972: oGetLocal 1
 974: oReturn
 975: oReturn
 976: oLocalSpace 2
 978: oInputChoice 1045
 980: oCall 2866
 982: oJumpForward 1058
 984: oCall 2935
 986: oJumpForward 1058
 988: oSetResult 18
 990: oPushResult
 991: oCall 2991
 993: oPop 1
 995: oJumpForward 1058
 997: oGetAddrLocal 1
 999: oPushResult
1000: oCall 1833
1002: oAssign
1003: oInputChoice 1016
1005: oGetLocal 1
1007: oPushResult
1008: oCall 1771
1010: oPop 1
1012: oInput 4
1014: oJumpForward 1019
1016: Choice Lookup Table
          65   1005
1019: oJumpForward 1058
1021: oGetAddrLocal 2
1023: oPushResult
1024: oCall 2207
1026: oAssign
1027: oInputChoice 1040
1029: oGetLocal 2
1031: oPushResult
1032: oCall 1771
1034: oPop 1
1036: oInput 4
1038: oJumpForward 1043
1040: Choice Lookup Table
          65   1029
1043: oJumpForward 1058
1045: Choice Lookup Table
          29   1021
          28    997
          32    988
          31    984
          30    980
1056: oJumpForward 1060
1058: oJumpBack 978
1060: oReturn
1061: oLocalSpace 0
1063: oSetResult 18
1065: oPushResult
1066: oCall 1373
1068: oPop 1
1070: oReturn
1071: oLocalSpace 5
1073: oGetAddrLocal 1
1075: oPushResult
1076: oLabelNew
1077: oAssign
1078: oEmit 56
1080: oGetLocal 1
1082: oPushResult
1083: oEmitLabel
1084: oPop 1
1086: oGetParam 2
1088: oPushResult
1089: oSetResult 11
1091: oPushResult
1092: oGetLocal 1
1094: oPushResult
1095: oNodeSetLabel
1096: oPop 3
1098: oEmit 52
1100: oGetAddrLocal 2
1102: oPushResult
1103: Here
1104: oAssign
1105: oEmit 65
1107: oGetAddrLocal 3
1109: oPushResult
1110: oGetParam 2
1112: oPushResult
1113: oSetResult 9
1115: oPushResult
1116: oNodeGet
1117: oPop 2
1119: oAssign
1120: oGetAddrLocal 4
1122: oPushResult
1123: oGetLocal 3
1125: oPushResult
1126: oSetResult 19
1128: oPushResult
1129: oNodeGetCode
1130: oPop 2
1132: oAssign
1133: oGetLocal 4
1135: oPushResult
1136: oEmitCode
1137: oPop 1
1139: oGetLocal 3
1141: oPushResult
1142: oSetResult 19
1144: oPushResult
1145: oSetResult 0
1147: oPushResult
1148: oNodeSetCode
1149: oPop 3
1151: oGetAddrLocal 3
1153: oPushResult
1154: oGetParam 2
1156: oPushResult
1157: oSetResult 10
1159: oPushResult
1160: oNodeGet
1161: oPop 2
1163: oAssign
1164: oGetAddrLocal 4
1166: oPushResult
1167: oGetLocal 3
1169: oPushResult
1170: oSetResult 19
1172: oPushResult
1173: oNodeGetCode
1174: oPop 2
1176: oAssign
1177: oGetLocal 4
1179: oPushResult
1180: oEmitCode
1181: oPop 1
1183: oGetLocal 3
1185: oPushResult
1186: oSetResult 19
1188: oPushResult
1189: oSetResult 0
1191: oPushResult
1192: oNodeSetCode
1193: oPop 3
1195: oGetParam 2
1197: oPushResult
1198: oSetResult 13
1200: oPushResult
1201: oNodeGet
1202: oPop 2
1204: oPushResult
1205: oScopeEnter
1206: oPop 1
1208: oGetParam 1
1210: oChoice 1229
1212: oCall 7355
1214: oInputChoice 1220
1216: oCall 7355
1218: oJumpForward 1225
1220: Choice Lookup Table
           4   1216
1223: oJumpForward 1227
1225: oJumpBack 1214
1227: oJumpForward 1232
1229: Choice Lookup Table
           1   1212
1232: oEmit 51
1234: oGetAddrLocal 5
1236: oPushResult
1237: oScopeCurrent
1238: oPushResult
1239: oSetResult 17
1241: oPushResult
1242: oNodeGetInt
1243: oPop 2
1245: oAssign
1246: oGetLocal 2
1248: oPushResult
1249: oGetLocal 5
1251: oPushResult
1252: oPatch
1253: oPop 2
1255: oScopeEnd
1256: oReturn
1257: oLocalSpace 3
1259: oGetAddrLocal 1
1261: oPushResult
1262: oLabelNew
1263: oAssign
1264: oEmit 56
1266: oGetLocal 1
1268: oPushResult
1269: oEmitLabel
1270: oPop 1
1272: oGetParam 2
1274: oPushResult
1275: oSetResult 12
1277: oPushResult
1278: oGetLocal 1
1280: oPushResult
1281: oNodeSetLabel
1282: oPop 3
1284: oEmit 52
1286: oGetAddrLocal 2
1288: oPushResult
1289: Here
1290: oAssign
1291: oEmit 65
1293: oSetResult 0
1295: oPushResult
1296: oSetResult 1
1298: oPushResult
1299: oScopeBegin
1300: oPop 2
1302: oGetParam 1
1304: oChoice 1323
1306: oCall 7355
1308: oInputChoice 1314
1310: oCall 7355
1312: oJumpForward 1319
1314: Choice Lookup Table
           4   1310
1317: oJumpForward 1321
1319: oJumpBack 1308
1321: oJumpForward 1326
1323: Choice Lookup Table
           1   1306
1326: oEmit 51
1328: oGetAddrLocal 3
1330: oPushResult
1331: oScopeCurrent
1332: oPushResult
1333: oSetResult 17
1335: oPushResult
1336: oNodeGetInt
1337: oPop 2
1339: oAssign
1340: oGetLocal 2
1342: oPushResult
1343: oGetLocal 3
1345: oPushResult
1346: oPatch
1347: oPop 2
1349: oScopeEnd
1350: oReturn
1351: oLocalSpace 0
1353: oGetParam 2
1355: oPushResult
1356: oCall 1373
1358: oPop 1
1360: oGetParam 1
1362: oPushResult
1363: oScopeCurrent
1364: oPushResult
1365: oSetResult 0
1367: oPushResult
1368: oCall 1593
1370: oPop 3
1372: oReturn
1373: oLocalSpace 0
1375: oInputChoice 1402
1377: oCall 2866
1379: oJumpForward 1415
1381: oCall 2935
1383: oJumpForward 1415
1385: oGetParam 1
1387: oPushResult
1388: oCall 2991
1390: oPop 1
1392: oJumpForward 1415
1394: oCall 2089
1396: oJumpForward 1415
1398: oCall 2524
1400: oJumpForward 1415
1402: Choice Lookup Table
          29   1398
          28   1394
          32   1385
          31   1381
          30   1377
1413: oJumpForward 1417
1415: oJumpBack 1375
1417: oCall 1420
1419: oReturn
1420: oLocalSpace 0
1422: oReturn
1423: oLocalSpace 2
1425: oGetAddrLocal 1
1427: oPushResult
1428: oGetGlobal 1
1430: oPushResult
1431: oSetResult 1
1433: oPushResult
1434: oNodeGetIter
1435: oPop 2
1437: oAssign
1438: oGetAddrLocal 2
1440: oPushResult
1441: oGetLocal 1
1443: oPushResult
1444: oNodeIterValue
1445: oPop 1
1447: oAssign
1448: oGetLocal 2
1450: oPushResult
1451: oNodeNull
1452: oPop 1
1454: oChoice 1499
1456: oJumpForward 1507
1458: oJumpForward 1505
1460: oEmit 46
1462: oSetResult 0
1464: oPushResult
1465: oEmitInt
1466: oPop 1
1468: oEmit 49
1470: oGetLocal 2
1472: oPushResult
1473: oSetResult 11
1475: oPushResult
1476: oNodeGetLabel
1477: oPop 2
1479: oPushResult
1480: oEmitLabel
1481: oPop 1
1483: oEmit 48
1485: oSetResult 0
1487: oPushResult
1488: oEmitInt
1489: oPop 1
1491: oGetAddrLocal 1
1493: oPushResult
1494: oNodeIterNext
1495: oPop 1
1497: oJumpForward 1505
1499: Choice Lookup Table
           0   1460
           1   1456
1504: oEndChoice
1505: oJumpBack 1438
1507: oReturn
1508: oLocalSpace 2
1510: oGetAddrLocal 1
1512: oPushResult
1513: oGetGlobal 1
1515: oPushResult
1516: oSetResult 1
1518: oPushResult
1519: oNodeGetIterLast
1520: oPop 2
1522: oAssign
1523: oGetAddrLocal 2
1525: oPushResult
1526: oGetLocal 1
1528: oPushResult
1529: oNodeIterValue
1530: oPop 1
1532: oAssign
1533: oGetLocal 2
1535: oPushResult
1536: oNodeNull
1537: oPop 1
1539: oChoice 1584
1541: oJumpForward 1592
1543: oJumpForward 1590
1545: oEmit 46
1547: oSetResult 0
1549: oPushResult
1550: oEmitInt
1551: oPop 1
1553: oEmit 49
1555: oGetLocal 2
1557: oPushResult
1558: oSetResult 12
1560: oPushResult
1561: oNodeGetLabel
1562: oPop 2
1564: oPushResult
1565: oEmitLabel
1566: oPop 1
1568: oEmit 48
1570: oSetResult 0
1572: oPushResult
1573: oEmitInt
1574: oPop 1
1576: oGetAddrLocal 1
1578: oPushResult
1579: oNodeIterPrev
1580: oPop 1
1582: oJumpForward 1590
1584: Choice Lookup Table
           0   1545
           1   1541
1589: oEndChoice
1590: oJumpBack 1523
1592: oReturn
1593: oLocalSpace 3
1595: oEmit 56
1597: oGetParam 3
1599: oPushResult
1600: oEmitLabel
1601: oPop 1
1603: oEmit 52
1605: oGetAddrLocal 1
1607: oPushResult
1608: Here
1609: oAssign
1610: oEmit 65
1612: oGetParam 1
1614: oChoice 1620
1616: oCall 1423
1618: oJumpForward 1623
1620: Choice Lookup Table
           1   1616
1623: oGetAddrLocal 2
1625: oPushResult
1626: oGetParam 2
1628: oPushResult
1629: oSetResult 19
1631: oPushResult
1632: oNodeGetCode
1633: oPop 2
1635: oAssign
1636: oGetLocal 2
1638: oPushResult
1639: oEmitCode
1640: oPop 1
1642: oGetParam 2
1644: oPushResult
1645: oSetResult 19
1647: oPushResult
1648: oSetResult 0
1650: oPushResult
1651: oNodeSetCode
1652: oPop 3
1654: oCall 7355
1656: oGetParam 1
1658: oChoice 1664
1660: oCall 1508
1662: oJumpForward 1667
1664: Choice Lookup Table
           1   1660
1667: oEmit 51
1669: oGetAddrLocal 3
1671: oPushResult
1672: oScopeCurrent
1673: oPushResult
1674: oSetResult 17
1676: oPushResult
1677: oNodeGetInt
1678: oPop 2
1680: oAssign
1681: oGetLocal 1
1683: oPushResult
1684: oGetLocal 3
1686: oPushResult
1687: oPatch
1688: oPop 2
1690: oReturn
1691: oLocalSpace 0
1693: oInputChoice 1711
1695: oGetParam 1
1697: oPushResult
1698: oSetResult 27
1700: oPushResult
1701: oSetResult 1
1703: oPushResult
1704: oNodeSetBoolean
1705: oPop 3
1707: oInput 4
1709: oJumpForward 1716
1711: Choice Lookup Table
          67   1695
1714: oJumpForward 1718
1716: oJumpBack 1693
1718: oReturn
1719: oLocalSpace 1
1721: oGetAddrLocal 1
1723: oPushResult
1724: oGetParam 1
1726: oPushResult
1727: oSetResult 19
1729: oPushResult
1730: oNodeGetCode
1731: oPop 2
1733: oAssign
1734: oGetLocal 1
1736: oPushResult
1737: oSetResult 0
1739: oPushResult
1740: equal_code
1741: oPop 2
1743: oChoice 1764
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCodeNew
1749: oAssign
1750: oGetParam 1
1752: oPushResult
1753: oSetResult 19
1755: oPushResult
1756: oGetLocal 1
1758: oPushResult
1759: oNodeSetCode
1760: oPop 3
1762: oJumpForward 1767
1764: Choice Lookup Table
           1   1745
1767: oGetLocal 1
1769: oReturn
1770: oReturn
1771: oLocalSpace 0
1773: oGetParam 1
1775: oPushResult
1776: oCall 8444
1778: oPop 1
1780: oPushResult
1781: equal_zero
1782: oPop 1
1784: oChoice 1790
1786: oError 23
1788: oJumpForward 1793
1790: Choice Lookup Table
           0   1786
1793: oGetParam 1
1795: oPushResult
1796: oSetResult 25
1798: oPushResult
1799: oSetResult 1
1801: oPushResult
1802: oNodeSetBoolean
1803: oPop 3
1805: oInputChoice 1829
1807: oInputChoice 1824
1809: oInput 2
1811: oGetParam 1
1813: oPushResult
1814: oSetResult 26
1816: oPushResult
1817: CURRENT_STRLIT
1818: oPushResult
1819: oNodeSetString
1820: oPop 3
1822: oJumpForward 1827
1824: Choice Lookup Table
          66   1809
1827: oJumpForward 1832
1829: Choice Lookup Table
           2   1807
1832: oReturn
1833: oLocalSpace 6
1835: oInput 0
1837: oGetAddrLocal 1
1839: oPushResult
1840: oSetResult 0
1842: oAssign
1843: oGetAddrLocal 2
1845: oPushResult
1846: oScopeFindInCurrentScope
1847: oAssign
1848: oGetLocal 2
1850: oPushResult
1851: oNodeNull
1852: oPop 1
1854: oChoice 1972
1856: oGetAddrLocal 2
1858: oPushResult
1859: oSetResult 12
1861: oPushResult
1862: LAST_ID
1863: oPushResult
1864: oCall 8596
1866: oPop 2
1868: oAssign
1869: oGetLocal 2
1871: oPushResult
1872: oSetResult 22
1874: oPushResult
1875: oLabelNew
1876: oPushResult
1877: oNodeSetLabel
1878: oPop 3
1880: oJumpForward 1978
1882: oGetAddrLocal 1
1884: oPushResult
1885: oSetResult 1
1887: oAssign
1888: oGetLocal 2
1890: oPushResult
1891: oSetResult 24
1893: oPushResult
1894: oNodeGetBoolean
1895: oPop 2
1897: oChoice 1903
1899: oError 21
1901: oJumpForward 1906
1903: Choice Lookup Table
           1   1899
1906: oGetLocal 2
1908: oPushResult
1909: oSetResult 25
1911: oPushResult
1912: oNodeGetBoolean
1913: oPop 2
1915: oChoice 1921
1917: oError 21
1919: oJumpForward 1924
1921: Choice Lookup Table
           1   1917
1924: oGetLocal 2
1926: oPushResult
1927: oNodeType
1928: oPop 1
1930: oChoice 1934
1932: oJumpForward 1939
1934: Choice Lookup Table
          12   1932
1937: oError 21
1939: oGetLocal 2
1941: oPushResult
1942: oSetResult 29
1944: oPushResult
1945: oGetLocal 2
1947: oPushResult
1948: oSetResult 23
1950: oPushResult
1951: oNodeGet
1952: oPop 2
1954: oPushResult
1955: oNodeSet
1956: oPop 3
1958: oGetLocal 2
1960: oPushResult
1961: oSetResult 23
1963: oPushResult
1964: oSetResult 0
1966: oPushResult
1967: oNodeSet
1968: oPop 3
1970: oJumpForward 1978
1972: Choice Lookup Table
           0   1882
           1   1856
1977: oEndChoice
1978: oGetAddrLocal 3
1980: oPushResult
1981: oCall 8432
1983: oAssign
1984: oGetAddrLocal 4
1986: oPushResult
1987: oGetLocal 3
1989: oPushResult
1990: oSetResult 0
1992: oPushResult
1993: greater
1994: oPop 2
1996: oAssign
1997: oGetAddrLocal 3
1999: oPushResult
2000: inc
2001: oPop 1
2003: oGetLocal 3
2005: oPushResult
2006: oSetResult 2
2008: oPushResult
2009: oScopeBegin
2010: oPop 2
2012: oGetAddrLocal 5
2014: oPushResult
2015: oScopeCurrent
2016: oAssign
2017: oGetLocal 4
2019: oChoice 2038
2021: oGetAddrLocal 6
2023: oPushResult
2024: oGetGlobal 5
2026: oPushResult
2027: oCall 8624
2029: oPop 1
2031: oPushResult
2032: oScopeAllocType
2033: oPop 1
2035: oAssign
2036: oJumpForward 2041
2038: Choice Lookup Table
           1   2021
2041: oCall 2642
2043: oGetLocal 2
2045: oPushResult
2046: oSetResult 23
2048: oPushResult
2049: oGetLocal 5
2051: oPushResult
2052: oNodeSet
2053: oPop 3
2055: oScopeEnd
2056: oInput 4
2058: oGetLocal 1
2060: oChoice 2072
2062: oGetLocal 2
2064: oPushResult
2065: oScopeDeclare
2066: oPop 1
2068: oJumpForward 2078
2070: oJumpForward 2078
2072: Choice Lookup Table
           1   2070
           0   2062
2077: oEndChoice
2078: oGetLocal 2
2080: oPushResult
2081: oCall 1691
2083: oPop 1
2085: oGetLocal 2
2087: oReturn
2088: oReturn
2089: oLocalSpace 4
2091: oGetAddrLocal 1
2093: oPushResult
2094: oCall 1833
2096: oAssign
2097: oInputChoice 2110
2099: oJumpForward 2204
2101: oGetLocal 1
2103: oPushResult
2104: oCall 1771
2106: oPop 1
2108: oJumpForward 2204
2110: Choice Lookup Table
          65   2101
          64   2099
2115: oGetAddrLocal 2
2117: oPushResult
2118: oGetLocal 1
2120: oPushResult
2121: oSetResult 23
2123: oPushResult
2124: oNodeGet
2125: oPop 2
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oScopeEnter
2132: oPop 1
2134: oGetAddrLocal 3
2136: oPushResult
2137: oGetLocal 2
2139: oPushResult
2140: oSetResult 14
2142: oPushResult
2143: oNodeGetInt
2144: oPop 2
2146: oAssign
2147: oGetLocal 3
2149: oPushResult
2150: oSetResult 1
2152: oPushResult
2153: oScopeBegin
2154: oPop 2
2156: oGetLocal 1
2158: oPushResult
2159: oSetResult 6
2161: oPushResult
2162: oScopeCurrent
2163: oPushResult
2164: oNodeSet
2165: oPop 3
2167: oGetAddrLocal 4
2169: oPushResult
2170: oGetLocal 1
2172: oPushResult
2173: oSetResult 22
2175: oPushResult
2176: oNodeGetLabel
2177: oPop 2
2179: oAssign
2180: oSetResult 19
2182: oPushResult
2183: oGetLocal 4
2185: oPushResult
2186: oCall 1351
2188: oPop 2
2190: oGetLocal 1
2192: oPushResult
2193: oSetResult 24
2195: oPushResult
2196: oSetResult 1
2198: oPushResult
2199: oNodeSetBoolean
2200: oPop 3
2202: oScopeEnd
2203: oScopeEnd
2204: oInput 4
2206: oReturn
2207: oLocalSpace 8
2209: oInput 0
2211: oGetAddrLocal 1
2213: oPushResult
2214: oSetResult 0
2216: oAssign
2217: oGetAddrLocal 2
2219: oPushResult
2220: oScopeFindInCurrentScope
2221: oAssign
2222: oGetLocal 2
2224: oPushResult
2225: oNodeNull
2226: oPop 1
2228: oChoice 2359
2230: oGetAddrLocal 2
2232: oPushResult
2233: oSetResult 13
2235: oPushResult
2236: LAST_ID
2237: oPushResult
2238: oCall 8596
2240: oPop 2
2242: oAssign
2243: oGetLocal 2
2245: oPushResult
2246: oSetResult 22
2248: oPushResult
2249: oLabelNew
2250: oPushResult
2251: oNodeSetLabel
2252: oPop 3
2254: oJumpForward 2365
2256: oGetAddrLocal 1
2258: oPushResult
2259: oSetResult 1
2261: oAssign
2262: oGetLocal 2
2264: oPushResult
2265: oSetResult 24
2267: oPushResult
2268: oNodeGetBoolean
2269: oPop 2
2271: oChoice 2277
2273: oError 21
2275: oJumpForward 2280
2277: Choice Lookup Table
           1   2273
2280: oGetLocal 2
2282: oPushResult
2283: oNodeType
2284: oPop 1
2286: oChoice 2290
2288: oJumpForward 2295
2290: Choice Lookup Table
          13   2288
2293: oError 21
2295: oGetLocal 2
2297: oPushResult
2298: oSetResult 29
2300: oPushResult
2301: oGetLocal 2
2303: oPushResult
2304: oSetResult 23
2306: oPushResult
2307: oNodeGet
2308: oPop 2
2310: oPushResult
2311: oNodeSet
2312: oPop 3
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 23
2319: oPushResult
2320: oSetResult 0
2322: oPushResult
2323: oNodeSet
2324: oPop 3
2326: oGetLocal 2
2328: oPushResult
2329: oSetResult 30
2331: oPushResult
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 21
2337: oPushResult
2338: oNodeGet
2339: oPop 2
2341: oPushResult
2342: oNodeSet
2343: oPop 3
2345: oGetLocal 2
2347: oPushResult
2348: oSetResult 21
2350: oPushResult
2351: oSetResult 0
2353: oPushResult
2354: oNodeSet
2355: oPop 3
2357: oJumpForward 2365
2359: Choice Lookup Table
           0   2256
           1   2230
2364: oEndChoice
2365: oGetAddrLocal 3
2367: oPushResult
2368: oCall 8432
2370: oAssign
2371: oGetAddrLocal 4
2373: oPushResult
2374: oGetLocal 3
2376: oPushResult
2377: oSetResult 0
2379: oPushResult
2380: greater
2381: oPop 2
2383: oAssign
2384: oGetAddrLocal 3
2386: oPushResult
2387: inc
2388: oPop 1
2390: oGetLocal 3
2392: oPushResult
2393: oSetResult 2
2395: oPushResult
2396: oScopeBegin
2397: oPop 2
2399: oGetAddrLocal 5
2401: oPushResult
2402: oScopeCurrent
2403: oAssign
2404: oGetLocal 4
2406: oChoice 2425
2408: oGetAddrLocal 6
2410: oPushResult
2411: oGetGlobal 5
2413: oPushResult
2414: oCall 8624
2416: oPop 1
2418: oPushResult
2419: oScopeAllocType
2420: oPop 1
2422: oAssign
2423: oJumpForward 2428
2425: Choice Lookup Table
           1   2408
2428: oCall 2642
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oGetLocal 5
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oInput 11
2444: oGetAddrLocal 7
2446: oPushResult
2447: oCall 3222
2449: oPop 1
2451: oGetLocal 2
2453: oPushResult
2454: oSetResult 21
2456: oPushResult
2457: oGetLocal 7
2459: oPushResult
2460: oNodeSet
2461: oPop 3
2463: oGetAddrLocal 8
2465: oPushResult
2466: oGetLocal 7
2468: oPushResult
2469: oCall 8624
2471: oPop 1
2473: oAssign
2474: oGetLocal 2
2476: oPushResult
2477: oSetResult 31
2479: oPushResult
2480: oGetLocal 8
2482: oPushResult
2483: oScopeAllocType
2484: oPop 1
2486: oPushResult
2487: oNodeSetInt
2488: oPop 3
2490: oScopeEnd
2491: oInput 4
2493: oGetLocal 1
2495: oChoice 2507
2497: oGetLocal 2
2499: oPushResult
2500: oScopeDeclare
2501: oPop 1
2503: oJumpForward 2513
2505: oJumpForward 2513
2507: Choice Lookup Table
           1   2505
           0   2497
2512: oEndChoice
2513: oGetLocal 2
2515: oPushResult
2516: oCall 1691
2518: oPop 1
2520: oGetLocal 2
2522: oReturn
2523: oReturn
2524: oLocalSpace 4
2526: oGetAddrLocal 1
2528: oPushResult
2529: oCall 2207
2531: oAssign
2532: oInputChoice 2545
2534: oJumpForward 2639
2536: oGetLocal 1
2538: oPushResult
2539: oCall 1771
2541: oPop 1
2543: oJumpForward 2639
2545: Choice Lookup Table
          65   2536
          64   2534
2550: oGetAddrLocal 2
2552: oPushResult
2553: oGetLocal 1
2555: oPushResult
2556: oSetResult 23
2558: oPushResult
2559: oNodeGet
2560: oPop 2
2562: oAssign
2563: oGetLocal 2
2565: oPushResult
2566: oScopeEnter
2567: oPop 1
2569: oGetAddrLocal 3
2571: oPushResult
2572: oGetLocal 2
2574: oPushResult
2575: oSetResult 14
2577: oPushResult
2578: oNodeGetInt
2579: oPop 2
2581: oAssign
2582: oGetLocal 3
2584: oPushResult
2585: oSetResult 1
2587: oPushResult
2588: oScopeBegin
2589: oPop 2
2591: oGetLocal 1
2593: oPushResult
2594: oSetResult 6
2596: oPushResult
2597: oScopeCurrent
2598: oPushResult
2599: oNodeSet
2600: oPop 3
2602: oGetAddrLocal 4
2604: oPushResult
2605: oGetLocal 1
2607: oPushResult
2608: oSetResult 22
2610: oPushResult
2611: oNodeGetLabel
2612: oPop 2
2614: oAssign
2615: oSetResult 19
2617: oPushResult
2618: oGetLocal 4
2620: oPushResult
2621: oCall 1351
2623: oPop 2
2625: oGetLocal 1
2627: oPushResult
2628: oSetResult 24
2630: oPushResult
2631: oSetResult 1
2633: oPushResult
2634: oNodeSetBoolean
2635: oPop 3
2637: oScopeEnd
2638: oScopeEnd
2639: oInput 4
2641: oReturn
2642: oLocalSpace 6
2644: oInputChoice 2862
2646: oGetAddrLocal 1
2648: oPushResult
2649: oNodeVecNew
2650: oAssign
2651: oGetAddrLocal 3
2653: oPushResult
2654: oSetResult 0
2656: oAssign
2657: oInputChoice 2667
2659: oGetAddrLocal 3
2661: oPushResult
2662: oSetResult 1
2664: oAssign
2665: oJumpForward 2670
2667: Choice Lookup Table
          32   2659
2670: oInput 0
2672: oGetAddrLocal 2
2674: oPushResult
2675: oSetResult 21
2677: oPushResult
2678: LAST_ID
2679: oPushResult
2680: oCall 8596
2682: oPop 2
2684: oAssign
2685: oGetLocal 2
2687: oPushResult
2688: oSetResult 33
2690: oPushResult
2691: oGetLocal 3
2693: oPushResult
2694: oNodeSetBoolean
2695: oPop 3
2697: oGetLocal 1
2699: oPushResult
2700: oGetLocal 2
2702: oPushResult
2703: oNodeVecAppend
2704: oPop 2
2706: oInputChoice 2714
2708: oJumpForward 2722
2710: oJumpForward 2720
2712: oJumpForward 2720
2714: Choice Lookup Table
          12   2712
          11   2708
2719: oEndChoice
2720: oJumpBack 2670
2722: oGetAddrLocal 4
2724: oPushResult
2725: oCall 3222
2727: oPop 1
2729: oGetLocal 3
2731: oChoice 2746
2733: oGetAddrLocal 5
2735: oPushResult
2736: oGetLocal 4
2738: oPushResult
2739: oCall 8624
2741: oPop 1
2743: oAssign
2744: oJumpForward 2755
2746: Choice Lookup Table
           1   2733
2749: oGetAddrLocal 5
2751: oPushResult
2752: oGetLocal 4
2754: oAssign
2755: oGetAddrLocal 6
2757: oPushResult
2758: oSetResult 0
2760: oAssign
2761: oGetLocal 6
2763: oPushResult
2764: oGetLocal 1
2766: oPushResult
2767: oNodeVecSize
2768: oPop 1
2770: oPushResult
2771: equal
2772: oPop 2
2774: oChoice 2831
2776: oGetAddrLocal 2
2778: oPushResult
2779: oGetLocal 1
2781: oPushResult
2782: oGetLocal 6
2784: oPushResult
2785: oNodeVecElement
2786: oPop 2
2788: oAssign
2789: oGetLocal 2
2791: oPushResult
2792: oSetResult 21
2794: oPushResult
2795: oGetLocal 4
2797: oPushResult
2798: oNodeSet
2799: oPop 3
2801: oGetLocal 2
2803: oPushResult
2804: oScopeDeclare
2805: oPop 1
2807: oGetLocal 2
2809: oPushResult
2810: oSetResult 22
2812: oPushResult
2813: oGetLocal 5
2815: oPushResult
2816: oScopeAllocType
2817: oPop 1
2819: oPushResult
2820: oNodeSetInt
2821: oPop 3
2823: oGetAddrLocal 6
2825: oPushResult
2826: inc
2827: oPop 1
2829: oJumpForward 2836
2831: Choice Lookup Table
           0   2776
2834: oJumpForward 2838
2836: oJumpBack 2761
2838: oGetLocal 1
2840: oPushResult
2841: oNodeVecDelete
2842: oPop 1
2844: oInputChoice 2852
2846: oJumpForward 2860
2848: oJumpForward 2858
2850: oJumpForward 2858
2852: Choice Lookup Table
           4   2850
          14   2846
2857: oEndChoice
2858: oJumpBack 2646
2860: oJumpForward 2865
2862: Choice Lookup Table
          13   2646
2865: oReturn
2866: oLocalSpace 2
2868: oInputChoice 2927
2870: oGetAddrLocal 1
2872: oPushResult
2873: oSetResult 14
2875: oPushResult
2876: LAST_ID
2877: oPushResult
2878: oCall 8596
2880: oPop 2
2882: oAssign
2883: oInput 5
2885: oCall 4241
2887: oGetAddrLocal 2
2889: oPushResult
2890: oValueTop
2891: oAssign
2892: oValuePop
2893: oGetLocal 1
2895: oPushResult
2896: oSetResult 22
2898: oPushResult
2899: oGetLocal 2
2901: oPushResult
2902: oNodeSetInt
2903: oPop 3
2905: oGetLocal 1
2907: oPushResult
2908: oSetResult 21
2910: oPushResult
2911: oGetGlobal 5
2913: oPushResult
2914: oNodeSet
2915: oPop 3
2917: oGetLocal 1
2919: oPushResult
2920: oScopeDeclare
2921: oPop 1
2923: oInput 4
2925: oJumpForward 2932
2927: Choice Lookup Table
           0   2870
2930: oJumpForward 2934
2932: oJumpBack 2868
2934: oReturn
2935: oLocalSpace 2
2937: oInputChoice 2983
2939: oGetAddrLocal 1
2941: oPushResult
2942: oSetResult 16
2944: oPushResult
2945: LAST_ID
2946: oPushResult
2947: oCall 8596
2949: oPop 2
2951: oAssign
2952: oInput 5
2954: oGetAddrLocal 2
2956: oPushResult
2957: oCall 3222
2959: oPop 1
2961: oGetLocal 1
2963: oPushResult
2964: oSetResult 21
2966: oPushResult
2967: oGetLocal 2
2969: oPushResult
2970: oNodeSet
2971: oPop 3
2973: oGetLocal 1
2975: oPushResult
2976: oScopeDeclare
2977: oPop 1
2979: oInput 4
2981: oJumpForward 2988
2983: Choice Lookup Table
           0   2939
2986: oJumpForward 2990
2988: oJumpBack 2937
2990: oReturn
2991: oLocalSpace 6
2993: oInputChoice 3214
2995: oGetAddrLocal 1
2997: oPushResult
2998: oNodeVecNew
2999: oAssign
3000: oGetAddrLocal 2
3002: oPushResult
3003: oGetParam 1
3005: oPushResult
3006: LAST_ID
3007: oPushResult
3008: oCall 8596
3010: oPop 2
3012: oAssign
3013: oGetLocal 1
3015: oPushResult
3016: oGetLocal 2
3018: oPushResult
3019: oNodeVecAppend
3020: oPop 2
3022: oInputChoice 3028
3024: oInput 0
3026: oJumpForward 3033
3028: Choice Lookup Table
          12   3024
3031: oJumpForward 3035
3033: oJumpBack 3000
3035: oInput 11
3037: oGetAddrLocal 3
3039: oPushResult
3040: oCall 3222
3042: oPop 1
3044: oGetAddrLocal 4
3046: oPushResult
3047: oSetResult 0
3049: oAssign
3050: oGetLocal 4
3052: oPushResult
3053: oGetLocal 1
3055: oPushResult
3056: oNodeVecSize
3057: oPop 1
3059: oPushResult
3060: equal
3061: oPop 2
3063: oChoice 3104
3065: oGetAddrLocal 2
3067: oPushResult
3068: oGetLocal 1
3070: oPushResult
3071: oGetLocal 4
3073: oPushResult
3074: oNodeVecElement
3075: oPop 2
3077: oAssign
3078: oGetLocal 2
3080: oPushResult
3081: oSetResult 21
3083: oPushResult
3084: oGetLocal 3
3086: oPushResult
3087: oNodeSet
3088: oPop 3
3090: oGetLocal 2
3092: oPushResult
3093: oScopeDeclareAlloc
3094: oPop 1
3096: oGetAddrLocal 4
3098: oPushResult
3099: inc
3100: oPop 1
3102: oJumpForward 3109
3104: Choice Lookup Table
           0   3065
3107: oJumpForward 3111
3109: oJumpBack 3050
3111: oInputChoice 3201
3113: oGetLocal 1
3115: oPushResult
3116: oNodeVecSize
3117: oPop 1
3119: oChoice 3123
3121: oJumpForward 3128
3123: Choice Lookup Table
           1   3121
3126: oError 22
3128: oGetAddrLocal 5
3130: oPushResult
3131: oScopeCurrent
3132: oPushResult
3133: oCall 1719
3135: oPop 1
3137: oAssign
3138: oGetLocal 5
3140: oPushResult
3141: oCodePush
3142: oPop 1
3144: oGetAddrLocal 6
3146: oPushResult
3147: oSetResult 0
3149: oAssign
3150: oCall 8432
3152: oPushResult
3153: equal_zero
3154: oPop 1
3156: oChoice 3172
3158: oGetGlobal 3
3160: oPushResult
3161: oScopeEnter
3162: oPop 1
3164: oGetAddrLocal 6
3166: oPushResult
3167: oSetResult 1
3169: oAssign
3170: oJumpForward 3175
3172: Choice Lookup Table
           1   3158
3175: oGetLocal 2
3177: oPushResult
3178: oCall 7731
3180: oPop 1
3182: oCall 4314
3184: oCall 8482
3186: oCall 7514
3188: oGetLocal 6
3190: oChoice 3195
3192: oScopeEnd
3193: oJumpForward 3198
3195: Choice Lookup Table
           1   3192
3198: oCodePop
3199: oJumpForward 3204
3201: Choice Lookup Table
           5   3113
3204: oGetLocal 1
3206: oPushResult
3207: oNodeVecDelete
3208: oPop 1
3210: oInput 4
3212: oJumpForward 3219
3214: Choice Lookup Table
           0   2995
3217: oJumpForward 3221
3219: oJumpBack 2993
3221: oReturn
3222: oLocalSpace 23
3224: oInputChoice 4221
3226: oGetAddrLocal 1
3228: oPushResult
3229: oScopeFindRequire
3230: oAssign
3231: oGetAddrLocal 1
3233: oPushResult
3234: oCall 396
3236: oPop 1
3238: oGetLocal 1
3240: oPushResult
3241: oNodeType
3242: oPop 1
3244: oChoice 3261
3246: oGetParam 1
3248: oPushResult
3249: oGetLocal 1
3251: oPushResult
3252: oSetResult 21
3254: oPushResult
3255: oNodeGet
3256: oPop 2
3258: oAssign
3259: oJumpForward 3272
3261: Choice Lookup Table
          16   3246
3264: oError 2
3266: oGetParam 1
3268: oPushResult
3269: oGetGlobal 5
3271: oAssign
3272: oJumpForward 4240
3274: oInput 15
3276: oGetAddrLocal 2
3278: oPushResult
3279: oNodeVecNew
3280: oAssign
3281: oGetAddrLocal 3
3283: oPushResult
3284: oSetResult 31
3286: oPushResult
3287: oNodeNew
3288: oPop 1
3290: oAssign
3291: oGetLocal 3
3293: oPushResult
3294: oSetResult 35
3296: oPushResult
3297: oGetGlobal 5
3299: oPushResult
3300: oNodeSet
3301: oPop 3
3303: oCall 4241
3305: oGetLocal 3
3307: oPushResult
3308: oSetResult 37
3310: oPushResult
3311: oValueTop
3312: oPushResult
3313: oNodeSetInt
3314: oPop 3
3316: oValuePop
3317: oInput 20
3319: oCall 4241
3321: oGetLocal 3
3323: oPushResult
3324: oSetResult 38
3326: oPushResult
3327: oValueTop
3328: oPushResult
3329: oNodeSetInt
3330: oPop 3
3332: oValuePop
3333: oGetLocal 3
3335: oPushResult
3336: oSetResult 17
3338: oPushResult
3339: oSetResult 4
3341: oPushResult
3342: oNodeSetInt
3343: oPop 3
3345: oGetLocal 3
3347: oPushResult
3348: oTypeAdd
3349: oPop 1
3351: oGetAddrLocal 4
3353: oPushResult
3354: oSetResult 30
3356: oPushResult
3357: oNodeNew
3358: oPop 1
3360: oAssign
3361: oGetLocal 4
3363: oPushResult
3364: oSetResult 36
3366: oPushResult
3367: oGetLocal 3
3369: oPushResult
3370: oNodeSet
3371: oPop 3
3373: oGetLocal 2
3375: oPushResult
3376: oGetLocal 4
3378: oPushResult
3379: oNodeVecAppend
3380: oPop 2
3382: oInputChoice 3390
3384: oJumpForward 3398
3386: oJumpForward 3396
3388: oJumpForward 3396
3390: Choice Lookup Table
          12   3388
          16   3384
3395: oEndChoice
3396: oJumpBack 3281
3398: oInput 38
3400: oGetAddrLocal 5
3402: oPushResult
3403: oCall 3222
3405: oPop 1
3407: oGetAddrLocal 6
3409: oPushResult
3410: oGetLocal 2
3412: oPushResult
3413: oNodeVecSize
3414: oPop 1
3416: oAssign
3417: oGetAddrLocal 6
3419: oPushResult
3420: dec
3421: oPop 1
3423: oGetAddrLocal 7
3425: oPushResult
3426: oGetLocal 2
3428: oPushResult
3429: oGetLocal 6
3431: oPushResult
3432: oNodeVecElement
3433: oPop 2
3435: oAssign
3436: oGetLocal 7
3438: oPushResult
3439: oSetResult 35
3441: oPushResult
3442: oGetLocal 5
3444: oPushResult
3445: oNodeSet
3446: oPop 3
3448: oGetAddrLocal 8
3450: oPushResult
3451: oGetLocal 7
3453: oPushResult
3454: oSetResult 36
3456: oPushResult
3457: oNodeGet
3458: oPop 2
3460: oAssign
3461: oGetAddrLocal 9
3463: oPushResult
3464: oGetLocal 8
3466: oPushResult
3467: oSetResult 38
3469: oPushResult
3470: oNodeGetInt
3471: oPop 2
3473: oPushResult
3474: oGetLocal 8
3476: oPushResult
3477: oSetResult 37
3479: oPushResult
3480: oNodeGetInt
3481: oPop 2
3483: oPushResult
3484: subtract
3485: oPop 2
3487: oAssign
3488: oGetAddrLocal 9
3490: oPushResult
3491: inc
3492: oPop 1
3494: oGetLocal 7
3496: oPushResult
3497: oSetResult 17
3499: oPushResult
3500: oGetLocal 9
3502: oPushResult
3503: oGetLocal 5
3505: oPushResult
3506: oSetResult 17
3508: oPushResult
3509: oNodeGetInt
3510: oPop 2
3512: oPushResult
3513: multiply
3514: oPop 2
3516: oPushResult
3517: oNodeSetInt
3518: oPop 3
3520: oGetLocal 7
3522: oPushResult
3523: oTypeAdd
3524: oPop 1
3526: oGetAddrLocal 5
3528: oPushResult
3529: oGetLocal 7
3531: oAssign
3532: oGetLocal 6
3534: oPushResult
3535: equal_zero
3536: oPop 1
3538: oChoice 3544
3540: oJumpForward 3549
3542: oJumpForward 3547
3544: Choice Lookup Table
           1   3540
3547: oJumpBack 3417
3549: oGetParam 1
3551: oPushResult
3552: oGetLocal 2
3554: oPushResult
3555: oSetResult 0
3557: oPushResult
3558: oNodeVecElement
3559: oPop 2
3561: oAssign
3562: oGetLocal 2
3564: oPushResult
3565: oNodeVecDelete
3566: oPop 1
3568: oJumpForward 4240
3570: oGetAddrLocal 10
3572: oPushResult
3573: oCall 3222
3575: oPop 1
3577: oGetParam 1
3579: oPushResult
3580: oGetLocal 10
3582: oPushResult
3583: oCall 8624
3585: oPop 1
3587: oAssign
3588: oJumpForward 4240
3590: oGetParam 1
3592: oPushResult
3593: oSetResult 32
3595: oPushResult
3596: oNodeNew
3597: oPop 1
3599: oAssign
3600: oSetResult -1
3602: oPushResult
3603: oSetResult 2
3605: oPushResult
3606: oScopeBegin
3607: oPop 2
3609: oSetResult 20
3611: oPushResult
3612: oCall 2991
3614: oPop 1
3616: oGetAddrLocal 11
3618: oPushResult
3619: oScopeCurrent
3620: oPushResult
3621: oSetResult 17
3623: oPushResult
3624: oNodeGetInt
3625: oPop 2
3627: oAssign
3628: oGetLocal 11
3630: oPushResult
3631: equal_zero
3632: oPop 1
3634: oChoice 3640
3636: oError 19
3638: oJumpForward 3643
3640: Choice Lookup Table
           1   3636
3643: oInput 34
3645: oGetFromParam 1
3647: oPushResult
3648: oSetResult 39
3650: oPushResult
3651: oScopeCurrent
3652: oPushResult
3653: oNodeSet
3654: oPop 3
3656: oGetFromParam 1
3658: oPushResult
3659: oSetResult 17
3661: oPushResult
3662: oGetLocal 11
3664: oPushResult
3665: oNodeSetInt
3666: oPop 3
3668: oScopeEnd
3669: oGetFromParam 1
3671: oPushResult
3672: oTypeAdd
3673: oPop 1
3675: oJumpForward 4240
3677: oGetParam 1
3679: oPushResult
3680: oSetResult 33
3682: oPushResult
3683: oNodeNew
3684: oPop 1
3686: oAssign
3687: oGetAddrLocal 12
3689: oPushResult
3690: oSetResult 0
3692: oAssign
3693: oGetAddrLocal 13
3695: oPushResult
3696: oSetResult 0
3698: oAssign
3699: oGetAddrLocal 14
3701: oPushResult
3702: oSetResult 1
3704: oAssign
3705: oGetAddrLocal 15
3707: oPushResult
3708: oScopeCurrent
3709: oAssign
3710: oSetResult -1
3712: oPushResult
3713: oSetResult 2
3715: oPushResult
3716: oScopeBegin
3717: oPop 2
3719: oInput 0
3721: oGetAddrLocal 16
3723: oPushResult
3724: oSetResult 15
3726: oPushResult
3727: LAST_ID
3728: oPushResult
3729: oCall 8596
3731: oPop 2
3733: oAssign
3734: oGetAddrLocal 17
3736: oPushResult
3737: oSetResult 15
3739: oPushResult
3740: LAST_ID
3741: oPushResult
3742: oCall 8596
3744: oPop 2
3746: oAssign
3747: oGetLocal 16
3749: oPushResult
3750: oSetResult 21
3752: oPushResult
3753: oGetFromParam 1
3755: oPushResult
3756: oNodeSet
3757: oPop 3
3759: oGetLocal 17
3761: oPushResult
3762: oSetResult 21
3764: oPushResult
3765: oGetFromParam 1
3767: oPushResult
3768: oNodeSet
3769: oPop 3
3771: oGetAddrLocal 18
3773: oPushResult
3774: LAST_ID
3775: oPushResult
3776: ID_STRING
3777: oPop 1
3779: oPushResult
3780: oStringAllocLit
3781: oPop 1
3783: oAssign
3784: oGetLocal 16
3786: oPushResult
3787: oSetResult 32
3789: oPushResult
3790: oGetLocal 18
3792: oPushResult
3793: oNodeSetInt
3794: oPop 3
3796: oGetLocal 17
3798: oPushResult
3799: oSetResult 32
3801: oPushResult
3802: oGetLocal 18
3804: oPushResult
3805: oNodeSetInt
3806: oPop 3
3808: oInputChoice 3850
3810: oCall 4241
3812: oGetLocal 13
3814: oPushResult
3815: equal_zero
3816: oPop 1
3818: oChoice 3839
3820: oValueTop
3821: oPushResult
3822: oGetLocal 12
3824: oPushResult
3825: greater
3826: oPop 2
3828: oChoice 3834
3830: oError 26
3832: oJumpForward 3837
3834: Choice Lookup Table
           0   3830
3837: oJumpForward 3842
3839: Choice Lookup Table
           0   3820
3842: oGetAddrLocal 12
3844: oPushResult
3845: oValueTop
3846: oAssign
3847: oValuePop
3848: oJumpForward 3855
3850: Choice Lookup Table
           3   3810
           5   3810
3855: oGetLocal 16
3857: oPushResult
3858: oSetResult 22
3860: oPushResult
3861: oGetLocal 12
3863: oPushResult
3864: oNodeSetInt
3865: oPop 3
3867: oGetLocal 17
3869: oPushResult
3870: oSetResult 22
3872: oPushResult
3873: oGetLocal 12
3875: oPushResult
3876: oNodeSetInt
3877: oPop 3
3879: oGetLocal 16
3881: oPushResult
3882: oScopeDeclare
3883: oPop 1
3885: oGetLocal 15
3887: oPushResult
3888: oScopeEnter
3889: oPop 1
3891: oGetLocal 17
3893: oPushResult
3894: oScopeDeclare
3895: oPop 1
3897: oScopeEnd
3898: oGetAddrLocal 12
3900: oPushResult
3901: inc
3902: oPop 1
3904: oGetAddrLocal 13
3906: oPushResult
3907: inc
3908: oPop 1
3910: oInputChoice 3914
3912: oJumpForward 3919
3914: Choice Lookup Table
          12   3912
3917: oJumpForward 3921
3919: oJumpBack 3719
3921: oInput 14
3923: oGetFromParam 1
3925: oPushResult
3926: oSetResult 39
3928: oPushResult
3929: oScopeCurrent
3930: oPushResult
3931: oNodeSet
3932: oPop 3
3934: oGetFromParam 1
3936: oPushResult
3937: oSetResult 17
3939: oPushResult
3940: oSetResult 4
3942: oPushResult
3943: oNodeSetInt
3944: oPop 3
3946: oScopeEnd
3947: oGetGlobal 2
3949: oPushResult
3950: oCall 1719
3952: oPop 1
3954: oPushResult
3955: oCodePush
3956: oPop 1
3958: oGetGlobal 2
3960: oPushResult
3961: oScopeEnter
3962: oPop 1
3964: oGetAddrLocal 19
3966: oPushResult
3967: oGetLocal 13
3969: oPushResult
3970: oSetResult 1
3972: oPushResult
3973: add
3974: oPop 2
3976: oPushResult
3977: oSetResult 16
3979: oPushResult
3980: multiply
3981: oPop 2
3983: oAssign
3984: oGetAddrLocal 20
3986: oPushResult
3987: oGetLocal 19
3989: oPushResult
3990: oSetResult 8
3992: oPushResult
3993: oScopeAlloc
3994: oPop 2
3996: oAssign
3997: oScopeEnd
3998: oGetFromParam 1
4000: oPushResult
4001: oSetResult 40
4003: oPushResult
4004: oGetLocal 20
4006: oPushResult
4007: oNodeSetInt
4008: oPop 3
4010: oGetAddrLocal 21
4012: oPushResult
4013: oGetFromParam 1
4015: oPushResult
4016: oSetResult 39
4018: oPushResult
4019: oNodeGet
4020: oPop 2
4022: oPushResult
4023: oSetResult 15
4025: oPushResult
4026: oNodeGetIter
4027: oPop 2
4029: oAssign
4030: oGetAddrLocal 22
4032: oPushResult
4033: oGetLocal 21
4035: oPushResult
4036: oNodeIterValue
4037: oPop 1
4039: oAssign
4040: oGetLocal 22
4042: oPushResult
4043: oNodeNull
4044: oPop 1
4046: oChoice 4052
4048: oJumpForward 4139
4050: oJumpForward 4055
4052: Choice Lookup Table
           1   4048
4055: oEmit 16
4057: oGetLocal 20
4059: oPushResult
4060: oEmitInt
4061: oPop 1
4063: oEmit 15
4065: oGetLocal 22
4067: oPushResult
4068: oSetResult 22
4070: oPushResult
4071: oNodeGetInt
4072: oPop 2
4074: oPushResult
4075: oEmitInt
4076: oPop 1
4078: oEmit 25
4080: oGetAddrLocal 20
4082: oPushResult
4083: oGetLocal 20
4085: oPushResult
4086: oSetResult 8
4088: oPushResult
4089: add
4090: oPop 2
4092: oAssign
4093: oEmit 16
4095: oGetLocal 20
4097: oPushResult
4098: oEmitInt
4099: oPop 1
4101: oEmit 16
4103: oGetLocal 22
4105: oPushResult
4106: oSetResult 32
4108: oPushResult
4109: oNodeGetInt
4110: oPop 2
4112: oPushResult
4113: oEmitInt
4114: oPop 1
4116: oEmit 27
4118: oGetAddrLocal 20
4120: oPushResult
4121: oGetLocal 20
4123: oPushResult
4124: oSetResult 8
4126: oPushResult
4127: add
4128: oPop 2
4130: oAssign
4131: oGetAddrLocal 21
4133: oPushResult
4134: oNodeIterNext
4135: oPop 1
4137: oJumpBack 4030
4139: oEmit 16
4141: oGetLocal 20
4143: oPushResult
4144: oEmitInt
4145: oPop 1
4147: oEmit 15
4149: oSetResult 0
4151: oPushResult
4152: oEmitInt
4153: oPop 1
4155: oEmit 25
4157: oGetAddrLocal 20
4159: oPushResult
4160: oGetLocal 20
4162: oPushResult
4163: oSetResult 8
4165: oPushResult
4166: add
4167: oPop 2
4169: oAssign
4170: oEmit 16
4172: oGetLocal 20
4174: oPushResult
4175: oEmitInt
4176: oPop 1
4178: oEmit 15
4180: oSetResult 0
4182: oPushResult
4183: oEmitInt
4184: oPop 1
4186: oEmit 27
4188: oGetAddrLocal 20
4190: oPushResult
4191: oGetLocal 20
4193: oPushResult
4194: oSetResult 8
4196: oPushResult
4197: add
4198: oPop 2
4200: oAssign
4201: oCodePop
4202: oGetFromParam 1
4204: oPushResult
4205: oTypeAdd
4206: oPop 1
4208: oJumpForward 4240
4210: oInput 38
4212: oGetAddrLocal 23
4214: oPushResult
4215: oCall 3222
4217: oPop 1
4219: oJumpForward 4240
4221: Choice Lookup Table
          37   4210
          13   3677
          36   3590
          17   3570
          35   3274
           0   3226
4234: oCall 4241
4236: oInput 20
4238: oCall 4241
4240: oReturn
4241: oLocalSpace 1
4243: oInputChoice 4305
4245: TOKEN_VALUE
4246: oPushResult
4247: oValuePush
4248: oPop 1
4250: oJumpForward 4313
4252: oGetAddrLocal 1
4254: oPushResult
4255: oScopeFindRequire
4256: oAssign
4257: oGetAddrLocal 1
4259: oPushResult
4260: oCall 396
4262: oPop 1
4264: oGetLocal 1
4266: oPushResult
4267: oNodeType
4268: oPop 1
4270: oChoice 4287
4272: oGetLocal 1
4274: oPushResult
4275: oSetResult 22
4277: oPushResult
4278: oNodeGetInt
4279: oPop 2
4281: oPushResult
4282: oValuePush
4283: oPop 1
4285: oJumpForward 4298
4287: Choice Lookup Table
          14   4272
4290: oError 1
4292: oSetResult 0
4294: oPushResult
4295: oValuePush
4296: oPop 1
4298: oJumpForward 4313
4300: oCall 4241
4302: oValueNegate
4303: oJumpForward 4313
4305: Choice Lookup Table
          24   4300
           0   4252
           1   4245
4312: oEndChoice
4313: oReturn
4314: oLocalSpace 1
4316: oGetAddrLocal 1
4318: oPushResult
4319: oSetResult 0
4321: oAssign
4322: oGetAddrLocal 1
4324: oPushResult
4325: oCall 4475
4327: oPop 1
4329: oGetAddrLocal 1
4331: oPushResult
4332: oCall 4375
4334: oPop 1
4336: oReturn
4337: oLocalSpace 0
4339: oGetParam 1
4341: oPushResult
4342: oCall 4475
4344: oPop 1
4346: oTypeSNodeType
4347: oChoice 4366
4349: oJumpForward 4373
4351: oGetParam 1
4353: oPushResult
4354: oLabelNew
4355: oAssign
4356: oEmit 55
4358: oGetFromParam 1
4360: oPushResult
4361: oEmitLabel
4362: oPop 1
4364: oJumpForward 4373
4366: Choice Lookup Table
          25   4351
          26   4349
4371: oError 8
4373: oTypeSPop
4374: oReturn
4375: oLocalSpace 1
4377: oTypeSNodeType
4378: oChoice 4440
4380: oGetAddrLocal 1
4382: oPushResult
4383: oLabelNew
4384: oAssign
4385: oEmit 15
4387: oSetResult 1
4389: oPushResult
4390: oEmitInt
4391: oPop 1
4393: oEmit 53
4395: oGetLocal 1
4397: oPushResult
4398: oEmitLabel
4399: oPop 1
4401: oEmit 56
4403: oGetFromParam 1
4405: oPushResult
4406: oEmitLabel
4407: oPop 1
4409: oEmit 15
4411: oSetResult 0
4413: oPushResult
4414: oEmitInt
4415: oPop 1
4417: oEmit 56
4419: oGetLocal 1
4421: oPushResult
4422: oEmitLabel
4423: oPop 1
4425: oTypeSPop
4426: oGetGlobal 6
4428: oPushResult
4429: oTypeSPush
4430: oPop 1
4432: oGetParam 1
4434: oPushResult
4435: oSetResult 0
4437: oAssign
4438: oJumpForward 4443
4440: Choice Lookup Table
          26   4380
4443: oReturn
4444: oLocalSpace 0
4446: oTypeSNodeType
4447: oChoice 4471
4449: oGetParam 1
4451: oPushResult
4452: oLabelNew
4453: oAssign
4454: oEmit 55
4456: oGetFromParam 1
4458: oPushResult
4459: oEmitLabel
4460: oPop 1
4462: oTypeSPop
4463: oGetGlobal 7
4465: oPushResult
4466: oTypeSPush
4467: oPop 1
4469: oJumpForward 4474
4471: Choice Lookup Table
          25   4449
4474: oReturn
4475: oLocalSpace 0
4477: oGetParam 1
4479: oPushResult
4480: oCall 4852
4482: oPop 1
4484: oInputChoice 4834
4486: oGetParam 1
4488: oPushResult
4489: oCall 4375
4491: oPop 1
4493: oGetParam 1
4495: oPushResult
4496: oCall 4852
4498: oPop 1
4500: oGetParam 1
4502: oPushResult
4503: oCall 4375
4505: oPop 1
4507: oCall 8482
4509: oTypeSNodeType
4510: oChoice 4524
4512: oEmit 38
4514: oJumpForward 4539
4516: oEmit 44
4518: oJumpForward 4539
4520: oError 16
4522: oJumpForward 4539
4524: Choice Lookup Table
          28   4520
          27   4520
          29   4516
          25   4512
          33   4512
          24   4512
4537: oError 17
4539: oTypeSPop
4540: oGetGlobal 6
4542: oPushResult
4543: oTypeSPush
4544: oPop 1
4546: oJumpForward 4849
4548: oGetParam 1
4550: oPushResult
4551: oCall 4375
4553: oPop 1
4555: oGetParam 1
4557: oPushResult
4558: oCall 4852
4560: oPop 1
4562: oGetParam 1
4564: oPushResult
4565: oCall 4375
4567: oPop 1
4569: oCall 8482
4571: oTypeSNodeType
4572: oChoice 4586
4574: oEmit 39
4576: oJumpForward 4601
4578: oEmit 45
4580: oJumpForward 4601
4582: oError 16
4584: oJumpForward 4601
4586: Choice Lookup Table
          28   4582
          27   4582
          29   4578
          25   4574
          33   4574
          24   4574
4599: oError 17
4601: oTypeSPop
4602: oGetGlobal 6
4604: oPushResult
4605: oTypeSPush
4606: oPop 1
4608: oJumpForward 4849
4610: oGetParam 1
4612: oPushResult
4613: oCall 4375
4615: oPop 1
4617: oGetParam 1
4619: oPushResult
4620: oCall 4852
4622: oPop 1
4624: oGetParam 1
4626: oPushResult
4627: oCall 4375
4629: oPop 1
4631: oCall 8482
4633: oTypeSNodeType
4634: oChoice 4644
4636: oEmit 41
4638: oJumpForward 4657
4640: oError 16
4642: oJumpForward 4657
4644: Choice Lookup Table
          28   4640
          27   4640
          25   4636
          33   4636
          24   4636
4655: oError 17
4657: oTypeSPop
4658: oGetGlobal 6
4660: oPushResult
4661: oTypeSPush
4662: oPop 1
4664: oJumpForward 4849
4666: oGetParam 1
4668: oPushResult
4669: oCall 4375
4671: oPop 1
4673: oGetParam 1
4675: oPushResult
4676: oCall 4852
4678: oPop 1
4680: oGetParam 1
4682: oPushResult
4683: oCall 4375
4685: oPop 1
4687: oCall 8482
4689: oTypeSNodeType
4690: oChoice 4700
4692: oEmit 40
4694: oJumpForward 4713
4696: oError 16
4698: oJumpForward 4713
4700: Choice Lookup Table
          28   4696
          27   4696
          25   4692
          33   4692
          24   4692
4711: oError 17
4713: oTypeSPop
4714: oGetGlobal 6
4716: oPushResult
4717: oTypeSPush
4718: oPop 1
4720: oJumpForward 4849
4722: oGetParam 1
4724: oPushResult
4725: oCall 4375
4727: oPop 1
4729: oGetParam 1
4731: oPushResult
4732: oCall 4852
4734: oPop 1
4736: oGetParam 1
4738: oPushResult
4739: oCall 4375
4741: oPop 1
4743: oCall 8482
4745: oTypeSNodeType
4746: oChoice 4756
4748: oEmit 43
4750: oJumpForward 4769
4752: oError 16
4754: oJumpForward 4769
4756: Choice Lookup Table
          28   4752
          27   4752
          25   4748
          33   4748
          24   4748
4767: oError 17
4769: oTypeSPop
4770: oGetGlobal 6
4772: oPushResult
4773: oTypeSPush
4774: oPop 1
4776: oJumpForward 4849
4778: oGetParam 1
4780: oPushResult
4781: oCall 4375
4783: oPop 1
4785: oGetParam 1
4787: oPushResult
4788: oCall 4852
4790: oPop 1
4792: oGetParam 1
4794: oPushResult
4795: oCall 4375
4797: oPop 1
4799: oCall 8482
4801: oTypeSNodeType
4802: oChoice 4812
4804: oEmit 42
4806: oJumpForward 4825
4808: oError 16
4810: oJumpForward 4825
4812: Choice Lookup Table
          28   4808
          27   4808
          25   4804
          33   4804
          24   4804
4823: oError 17
4825: oTypeSPop
4826: oGetGlobal 6
4828: oPushResult
4829: oTypeSPush
4830: oPop 1
4832: oJumpForward 4849
4834: Choice Lookup Table
          10   4778
           9   4722
           8   4666
           7   4610
           6   4548
           5   4486
4847: oJumpForward 4851
4849: oJumpBack 4484
4851: oReturn
4852: oLocalSpace 1
4854: oGetAddrLocal 1
4856: oPushResult
4857: oSetResult 0
4859: oAssign
4860: oGetParam 1
4862: oPushResult
4863: oCall 5032
4865: oPop 1
4867: oInputChoice 5000
4869: oTypeSNodeType
4870: oChoice 4941
4872: oGetLocal 1
4874: oPushResult
4875: oSetResult 0
4877: oPushResult
4878: equal_label
4879: oPop 2
4881: oChoice 4890
4883: oGetAddrLocal 1
4885: oPushResult
4886: oLabelNew
4887: oAssign
4888: oJumpForward 4893
4890: Choice Lookup Table
           1   4883
4893: oEmit 53
4895: oGetLocal 1
4897: oPushResult
4898: oEmitLabel
4899: oPop 1
4901: oJumpForward 4948
4903: oGetParam 1
4905: oPushResult
4906: oCall 4444
4908: oPop 1
4910: oGetLocal 1
4912: oPushResult
4913: oSetResult 0
4915: oPushResult
4916: equal_label
4917: oPop 2
4919: oChoice 4928
4921: oGetAddrLocal 1
4923: oPushResult
4924: oLabelNew
4925: oAssign
4926: oJumpForward 4931
4928: Choice Lookup Table
           1   4921
4931: oEmit 53
4933: oGetLocal 1
4935: oPushResult
4936: oEmitLabel
4937: oPop 1
4939: oJumpForward 4948
4941: Choice Lookup Table
          25   4903
          26   4872
4946: oError 8
4948: oTypeSPop
4949: oEmit 56
4951: oGetFromParam 1
4953: oPushResult
4954: oEmitLabel
4955: oPop 1
4957: oGetParam 1
4959: oPushResult
4960: oSetResult 0
4962: oAssign
4963: oGetParam 1
4965: oPushResult
4966: oCall 5032
4968: oPop 1
4970: oTypeSNodeType
4971: oChoice 4984
4973: oJumpForward 4991
4975: oGetParam 1
4977: oPushResult
4978: oCall 4444
4980: oPop 1
4982: oJumpForward 4991
4984: Choice Lookup Table
          25   4975
          26   4973
4989: oError 8
4991: oTypeSPop
4992: oGetGlobal 7
4994: oPushResult
4995: oTypeSPush
4996: oPop 1
4998: oJumpForward 5005
5000: Choice Lookup Table
          52   4869
5003: oJumpForward 5007
5005: oJumpBack 4867
5007: oGetLocal 1
5009: oPushResult
5010: oSetResult 0
5012: oPushResult
5013: equal_label
5014: oPop 2
5016: oChoice 5028
5018: oEmit 56
5020: oGetLocal 1
5022: oPushResult
5023: oEmitLabel
5024: oPop 1
5026: oJumpForward 5031
5028: Choice Lookup Table
           0   5018
5031: oReturn
5032: oLocalSpace 2
5034: oGetAddrLocal 1
5036: oPushResult
5037: oSetResult 0
5039: oAssign
5040: oGetParam 1
5042: oPushResult
5043: oCall 5170
5045: oPop 1
5047: oInputChoice 5162
5049: oTypeSNodeType
5050: oChoice 5063
5052: oJumpForward 5070
5054: oGetParam 1
5056: oPushResult
5057: oCall 4444
5059: oPop 1
5061: oJumpForward 5070
5063: Choice Lookup Table
          25   5054
          26   5052
5068: oError 8
5070: oTypeSPop
5071: oGetLocal 1
5073: oPushResult
5074: oSetResult 0
5076: oPushResult
5077: equal_label
5078: oPop 2
5080: oChoice 5109
5082: oGetAddrLocal 1
5084: oPushResult
5085: oLabelNew
5086: oAssign
5087: oEmit 57
5089: oGetFromParam 1
5091: oPushResult
5092: oEmitLabel
5093: oPop 1
5095: oGetLocal 1
5097: oPushResult
5098: oEmitLabel
5099: oPop 1
5101: oGetParam 1
5103: oPushResult
5104: oGetLocal 1
5106: oAssign
5107: oJumpForward 5112
5109: Choice Lookup Table
           1   5082
5112: oGetAddrLocal 2
5114: oPushResult
5115: oSetResult 0
5117: oAssign
5118: oGetAddrLocal 2
5120: oPushResult
5121: oCall 5170
5123: oPop 1
5125: oTypeSNodeType
5126: oChoice 5139
5128: oJumpForward 5146
5130: oGetAddrLocal 2
5132: oPushResult
5133: oCall 4444
5135: oPop 1
5137: oJumpForward 5146
5139: Choice Lookup Table
          25   5130
          26   5128
5144: oError 8
5146: oEmit 57
5148: oGetLocal 2
5150: oPushResult
5151: oEmitLabel
5152: oPop 1
5154: oGetLocal 1
5156: oPushResult
5157: oEmitLabel
5158: oPop 1
5160: oJumpForward 5167
5162: Choice Lookup Table
          51   5049
5165: oJumpForward 5169
5167: oJumpBack 5047
5169: oReturn
5170: oLocalSpace 1
5172: oInputChoice 5226
5174: oGetAddrLocal 1
5176: oPushResult
5177: oSetResult 0
5179: oAssign
5180: oGetAddrLocal 1
5182: oPushResult
5183: oCall 5170
5185: oPop 1
5187: oTypeSNodeType
5188: oChoice 5217
5190: oGetParam 1
5192: oPushResult
5193: oLabelNew
5194: oAssign
5195: oEmit 53
5197: oGetFromParam 1
5199: oPushResult
5200: oEmitLabel
5201: oPop 1
5203: oEmit 56
5205: oGetLocal 1
5207: oPushResult
5208: oEmitLabel
5209: oPop 1
5211: oJumpForward 5224
5213: oEmit 37
5215: oJumpForward 5224
5217: Choice Lookup Table
          25   5213
          26   5190
5222: oError 8
5224: oJumpForward 5236
5226: Choice Lookup Table
          53   5174
5229: oGetParam 1
5231: oPushResult
5232: oCall 5237
5234: oPop 1
5236: oReturn
5237: oLocalSpace 0
5239: oGetParam 1
5241: oPushResult
5242: oCall 5288
5244: oPop 1
5246: oInputChoice 5278
5248: oCall 8508
5250: oGetParam 1
5252: oPushResult
5253: oCall 5288
5255: oPop 1
5257: oCall 8522
5259: oEmit 34
5261: oJumpForward 5285
5263: oCall 8508
5265: oGetParam 1
5267: oPushResult
5268: oCall 5288
5270: oPop 1
5272: oCall 8522
5274: oEmit 35
5276: oJumpForward 5285
5278: Choice Lookup Table
          24   5263
          23   5248
5283: oJumpForward 5287
5285: oJumpBack 5246
5287: oReturn
5288: oLocalSpace 0
5290: oGetParam 1
5292: oPushResult
5293: oCall 5339
5295: oPop 1
5297: oInputChoice 5329
5299: oCall 8508
5301: oGetParam 1
5303: oPushResult
5304: oCall 5339
5306: oPop 1
5308: oCall 8522
5310: oEmit 31
5312: oJumpForward 5336
5314: oCall 8508
5316: oGetParam 1
5318: oPushResult
5319: oCall 5339
5321: oPop 1
5323: oCall 8522
5325: oEmit 32
5327: oJumpForward 5336
5329: Choice Lookup Table
          22   5314
          21   5299
5334: oJumpForward 5338
5336: oJumpBack 5297
5338: oReturn
5339: oLocalSpace 0
5341: oInputChoice 5367
5343: oGetParam 1
5345: oPushResult
5346: oCall 5380
5348: oPop 1
5350: oCall 8522
5352: oJumpForward 5379
5354: oGetParam 1
5356: oPushResult
5357: oCall 5380
5359: oPop 1
5361: oCall 8522
5363: oEmit 36
5365: oJumpForward 5379
5367: Choice Lookup Table
          24   5354
          23   5343
5372: oGetParam 1
5374: oPushResult
5375: oCall 5380
5377: oPop 1
5379: oReturn
5380: oLocalSpace 6
5382: oInputChoice 5586
5384: oEmit 15
5386: TOKEN_VALUE
5387: oPushResult
5388: oEmitInt
5389: oPop 1
5391: oGetGlobal 5
5393: oPushResult
5394: oTypeSPush
5395: oPop 1
5397: oJumpForward 5605
5399: oGetParam 1
5401: oPushResult
5402: oCall 4475
5404: oPop 1
5406: oInput 14
5408: oJumpForward 5605
5410: oGetAddrLocal 1
5412: oPushResult
5413: CURRENT_STRLIT
5414: oPushResult
5415: oStringAllocLit
5416: oPop 1
5418: oAssign
5419: oEmit 16
5421: oGetLocal 1
5423: oPushResult
5424: oEmitInt
5425: oPop 1
5427: oGetGlobal 9
5429: oPushResult
5430: oTypeSPush
5431: oPop 1
5433: oJumpForward 5605
5435: oGetAddrLocal 2
5437: oPushResult
5438: oScopeFindRequire
5439: oAssign
5440: oGetAddrLocal 2
5442: oPushResult
5443: oCall 396
5445: oPop 1
5447: oGetLocal 2
5449: oPushResult
5450: oNodeType
5451: oPop 1
5453: oChoice 5517
5455: oGetLocal 2
5457: oPushResult
5458: oCall 6762
5460: oPop 1
5462: oJumpForward 5538
5464: oGetAddrLocal 3
5466: oPushResult
5467: oGetLocal 2
5469: oPushResult
5470: oSetResult 21
5472: oPushResult
5473: oNodeGet
5474: oPop 2
5476: oAssign
5477: oGetLocal 3
5479: oPushResult
5480: oTypeSPush
5481: oPop 1
5483: oTypeSNodeType
5484: oChoice 5497
5486: oEmit 15
5488: oGetLocal 2
5490: oPushResult
5491: oCall 8803
5493: oPop 1
5495: oJumpForward 5506
5497: Choice Lookup Table
          25   5486
          33   5486
          24   5486
5504: oError 16
5506: oJumpForward 5538
5508: oGetLocal 2
5510: oPushResult
5511: oCall 5606
5513: oPop 1
5515: oJumpForward 5538
5517: Choice Lookup Table
          21   5508
          19   5508
          18   5508
          15   5464
          14   5464
          13   5455
5530: oError 6
5532: oGetGlobal 5
5534: oPushResult
5535: oTypeSPush
5536: oPop 1
5538: oJumpForward 5605
5540: oInput 0
5542: oGetAddrLocal 4
5544: oPushResult
5545: oScopeFindRequire
5546: oAssign
5547: oGetAddrLocal 4
5549: oPushResult
5550: oCall 396
5552: oPop 1
5554: oGetLocal 4
5556: oPushResult
5557: oCall 7731
5559: oPop 1
5561: oGetAddrLocal 5
5563: oPushResult
5564: oTypeSTop
5565: oAssign
5566: oTypeSPop
5567: oGetAddrLocal 6
5569: oPushResult
5570: oGetLocal 5
5572: oPushResult
5573: oCall 8624
5575: oPop 1
5577: oAssign
5578: oGetLocal 6
5580: oPushResult
5581: oTypeSPush
5582: oPop 1
5584: oJumpForward 5605
5586: Choice Lookup Table
          18   5540
           0   5435
           2   5410
          13   5399
           1   5384
5597: oError 6
5599: oGetGlobal 5
5601: oPushResult
5602: oTypeSPush
5603: oPop 1
5605: oReturn
5606: oLocalSpace 2
5608: oGetAddrLocal 1
5610: oPushResult
5611: oGetParam 1
5613: oPushResult
5614: oSetResult 21
5616: oPushResult
5617: oNodeGet
5618: oPop 2
5620: oAssign
5621: oGetAddrLocal 2
5623: oPushResult
5624: oGetParam 1
5626: oPushResult
5627: oCall 8464
5629: oPop 1
5631: oAssign
5632: oGetLocal 1
5634: oPushResult
5635: oTypeSPush
5636: oPop 1
5638: oTypeSNodeType
5639: oChoice 6156
5641: oGetParam 1
5643: oPushResult
5644: oNodeType
5645: oPop 1
5647: oChoice 5793
5649: oEmit 0
5651: oGetParam 1
5653: oPushResult
5654: oCall 8803
5656: oPop 1
5658: oJumpForward 5801
5660: oGetLocal 2
5662: oPushResult
5663: equal_zero
5664: oPop 1
5666: oChoice 5679
5668: oEmit 3
5670: oGetParam 1
5672: oPushResult
5673: oCall 8803
5675: oPop 1
5677: oJumpForward 5697
5679: Choice Lookup Table
           1   5668
5682: oEmit 9
5684: oGetLocal 2
5686: oPushResult
5687: oEmitInt
5688: oPop 1
5690: oGetParam 1
5692: oPushResult
5693: oCall 8803
5695: oPop 1
5697: oJumpForward 5801
5699: oGetParam 1
5701: oPushResult
5702: oSetResult 33
5704: oPushResult
5705: oNodeGetBoolean
5706: oPop 2
5708: oChoice 5751
5710: oGetLocal 2
5712: oPushResult
5713: equal_zero
5714: oPop 1
5716: oChoice 5729
5718: oEmit 8
5720: oGetParam 1
5722: oPushResult
5723: oCall 8803
5725: oPop 1
5727: oJumpForward 5747
5729: Choice Lookup Table
           1   5718
5732: oEmit 14
5734: oGetLocal 2
5736: oPushResult
5737: oEmitInt
5738: oPop 1
5740: oGetParam 1
5742: oPushResult
5743: oCall 8803
5745: oPop 1
5747: oEmit 22
5749: oJumpForward 5791
5751: Choice Lookup Table
           1   5710
5754: oGetLocal 2
5756: oPushResult
5757: equal_zero
5758: oPop 1
5760: oChoice 5773
5762: oEmit 6
5764: oGetParam 1
5766: oPushResult
5767: oCall 8803
5769: oPop 1
5771: oJumpForward 5791
5773: Choice Lookup Table
           1   5762
5776: oEmit 12
5778: oGetLocal 2
5780: oPushResult
5781: oEmitInt
5782: oPop 1
5784: oGetParam 1
5786: oPushResult
5787: oCall 8803
5789: oPop 1
5791: oJumpForward 5801
5793: Choice Lookup Table
          21   5699
          19   5660
          18   5649
5800: oEndChoice
5801: oJumpForward 6333
5803: oGetParam 1
5805: oPushResult
5806: oNodeType
5807: oPop 1
5809: oChoice 5955
5811: oEmit 1
5813: oGetParam 1
5815: oPushResult
5816: oCall 8803
5818: oPop 1
5820: oJumpForward 5963
5822: oGetLocal 2
5824: oPushResult
5825: equal_zero
5826: oPop 1
5828: oChoice 5841
5830: oEmit 4
5832: oGetParam 1
5834: oPushResult
5835: oCall 8803
5837: oPop 1
5839: oJumpForward 5859
5841: Choice Lookup Table
           1   5830
5844: oEmit 10
5846: oGetLocal 2
5848: oPushResult
5849: oEmitInt
5850: oPop 1
5852: oGetParam 1
5854: oPushResult
5855: oCall 8803
5857: oPop 1
5859: oJumpForward 5963
5861: oGetParam 1
5863: oPushResult
5864: oSetResult 33
5866: oPushResult
5867: oNodeGetBoolean
5868: oPop 2
5870: oChoice 5913
5872: oGetLocal 2
5874: oPushResult
5875: equal_zero
5876: oPop 1
5878: oChoice 5891
5880: oEmit 8
5882: oGetParam 1
5884: oPushResult
5885: oCall 8803
5887: oPop 1
5889: oJumpForward 5909
5891: Choice Lookup Table
           1   5880
5894: oEmit 14
5896: oGetLocal 2
5898: oPushResult
5899: oEmitInt
5900: oPop 1
5902: oGetParam 1
5904: oPushResult
5905: oCall 8803
5907: oPop 1
5909: oEmit 23
5911: oJumpForward 5953
5913: Choice Lookup Table
           1   5872
5916: oGetLocal 2
5918: oPushResult
5919: equal_zero
5920: oPop 1
5922: oChoice 5935
5924: oEmit 7
5926: oGetParam 1
5928: oPushResult
5929: oCall 8803
5931: oPop 1
5933: oJumpForward 5953
5935: Choice Lookup Table
           1   5924
5938: oEmit 13
5940: oGetLocal 2
5942: oPushResult
5943: oEmitInt
5944: oPop 1
5946: oGetParam 1
5948: oPushResult
5949: oCall 8803
5951: oPop 1
5953: oJumpForward 5963
5955: Choice Lookup Table
          21   5861
          19   5822
          18   5811
5962: oEndChoice
5963: oJumpForward 6333
5965: oError 16
5967: oJumpForward 6333
5969: oGetParam 1
5971: oPushResult
5972: oNodeType
5973: oPop 1
5975: oChoice 6121
5977: oEmit 2
5979: oGetParam 1
5981: oPushResult
5982: oCall 8803
5984: oPop 1
5986: oJumpForward 6129
5988: oGetLocal 2
5990: oPushResult
5991: equal_zero
5992: oPop 1
5994: oChoice 6007
5996: oEmit 5
5998: oGetParam 1
6000: oPushResult
6001: oCall 8803
6003: oPop 1
6005: oJumpForward 6025
6007: Choice Lookup Table
           1   5996
6010: oEmit 11
6012: oGetLocal 2
6014: oPushResult
6015: oEmitInt
6016: oPop 1
6018: oGetParam 1
6020: oPushResult
6021: oCall 8803
6023: oPop 1
6025: oJumpForward 6129
6027: oGetParam 1
6029: oPushResult
6030: oSetResult 33
6032: oPushResult
6033: oNodeGetBoolean
6034: oPop 2
6036: oChoice 6079
6038: oGetLocal 2
6040: oPushResult
6041: equal_zero
6042: oPop 1
6044: oChoice 6057
6046: oEmit 8
6048: oGetParam 1
6050: oPushResult
6051: oCall 8803
6053: oPop 1
6055: oJumpForward 6075
6057: Choice Lookup Table
           1   6046
6060: oEmit 14
6062: oGetLocal 2
6064: oPushResult
6065: oEmitInt
6066: oPop 1
6068: oGetParam 1
6070: oPushResult
6071: oCall 8803
6073: oPop 1
6075: oEmit 24
6077: oJumpForward 6119
6079: Choice Lookup Table
           1   6038
6082: oGetLocal 2
6084: oPushResult
6085: equal_zero
6086: oPop 1
6088: oChoice 6101
6090: oEmit 8
6092: oGetParam 1
6094: oPushResult
6095: oCall 8803
6097: oPop 1
6099: oJumpForward 6119
6101: Choice Lookup Table
           1   6090
6104: oEmit 14
6106: oGetLocal 2
6108: oPushResult
6109: oEmitInt
6110: oPop 1
6112: oGetParam 1
6114: oPushResult
6115: oCall 8803
6117: oPop 1
6119: oJumpForward 6129
6121: Choice Lookup Table
          21   6027
          19   5988
          18   5977
6128: oEndChoice
6129: oInputChoice 6151
6131: oTypeSPop
6132: oGetLocal 1
6134: oPushResult
6135: oSetResult 35
6137: oPushResult
6138: oNodeGet
6139: oPop 2
6141: oPushResult
6142: oTypeSPush
6143: oPop 1
6145: oCall 6371
6147: oCall 6334
6149: oJumpForward 6154
6151: Choice Lookup Table
          17   6131
6154: oJumpForward 6333
6156: Choice Lookup Table
          29   5969
          23   5965
          28   5965
          27   5965
          25   5803
          33   5641
          24   5641
6171: oGetParam 1
6173: oPushResult
6174: oNodeType
6175: oPop 1
6177: oChoice 6321
6179: oEmit 16
6181: oGetParam 1
6183: oPushResult
6184: oCall 8803
6186: oPop 1
6188: oJumpForward 6329
6190: oGetLocal 2
6192: oPushResult
6193: equal_zero
6194: oPop 1
6196: oChoice 6209
6198: oEmit 17
6200: oGetParam 1
6202: oPushResult
6203: oCall 8803
6205: oPop 1
6207: oJumpForward 6227
6209: Choice Lookup Table
           1   6198
6212: oEmit 20
6214: oGetLocal 2
6216: oPushResult
6217: oEmitInt
6218: oPop 1
6220: oGetParam 1
6222: oPushResult
6223: oCall 8803
6225: oPop 1
6227: oJumpForward 6329
6229: oGetParam 1
6231: oPushResult
6232: oSetResult 33
6234: oPushResult
6235: oNodeGetBoolean
6236: oPop 2
6238: oChoice 6279
6240: oGetLocal 2
6242: oPushResult
6243: equal_zero
6244: oPop 1
6246: oChoice 6259
6248: oEmit 8
6250: oGetParam 1
6252: oPushResult
6253: oCall 8803
6255: oPop 1
6257: oJumpForward 6277
6259: Choice Lookup Table
           1   6248
6262: oEmit 14
6264: oGetLocal 2
6266: oPushResult
6267: oEmitInt
6268: oPop 1
6270: oGetParam 1
6272: oPushResult
6273: oCall 8803
6275: oPop 1
6277: oJumpForward 6319
6279: Choice Lookup Table
           1   6240
6282: oGetLocal 2
6284: oPushResult
6285: equal_zero
6286: oPop 1
6288: oChoice 6301
6290: oEmit 18
6292: oGetParam 1
6294: oPushResult
6295: oCall 8803
6297: oPop 1
6299: oJumpForward 6319
6301: Choice Lookup Table
           1   6290
6304: oEmit 21
6306: oGetLocal 2
6308: oPushResult
6309: oEmitInt
6310: oPop 1
6312: oGetParam 1
6314: oPushResult
6315: oCall 8803
6317: oPop 1
6319: oJumpForward 6329
6321: Choice Lookup Table
          21   6229
          19   6190
          18   6179
6328: oEndChoice
6329: oCall 6371
6331: oCall 6334
6333: oReturn
6334: oLocalSpace 0
6336: oTypeSNodeType
6337: oChoice 6355
6339: oEmit 22
6341: oJumpForward 6370
6343: oEmit 23
6345: oJumpForward 6370
6347: oError 16
6349: oJumpForward 6370
6351: oEmit 24
6353: oJumpForward 6370
6355: Choice Lookup Table
          29   6351
          23   6347
          28   6347
          27   6347
          25   6343
          33   6339
          24   6339
6370: oReturn
6371: oLocalSpace 0
6373: oInputChoice 6387
6375: oCall 6399
6377: oJumpForward 6396
6379: oCall 6542
6381: oJumpForward 6396
6383: oCall 6640
6385: oJumpForward 6396
6387: Choice Lookup Table
          17   6383
          19   6379
          15   6375
6394: oJumpForward 6398
6396: oJumpBack 6373
6398: oReturn
6399: oLocalSpace 3
6401: oTypeSNodeType
6402: oChoice 6406
6404: oJumpForward 6411
6406: Choice Lookup Table
          30   6404
6409: oError 10
6411: oTypeSNodeType
6412: oChoice 6416
6414: oJumpForward 6421
6416: Choice Lookup Table
          30   6414
6419: oError 13
6421: oGetAddrLocal 1
6423: oPushResult
6424: oTypeSTop
6425: oPushResult
6426: oSetResult 36
6428: oPushResult
6429: oNodeGet
6430: oPop 2
6432: oPushResult
6433: oCall 8708
6435: oPop 1
6437: oAssign
6438: oGetAddrLocal 2
6440: oPushResult
6441: oTypeSTop
6442: oPushResult
6443: oSetResult 35
6445: oPushResult
6446: oNodeGet
6447: oPop 2
6449: oAssign
6450: oTypeSPop
6451: oGetLocal 2
6453: oPushResult
6454: oTypeSPush
6455: oPop 1
6457: oCall 4314
6459: oCall 8508
6461: oGetLocal 1
6463: oPushResult
6464: equal_zero
6465: oPop 1
6467: oChoice 6481
6469: oEmit 15
6471: oGetLocal 1
6473: oPushResult
6474: oEmitInt
6475: oPop 1
6477: oEmit 35
6479: oJumpForward 6484
6481: Choice Lookup Table
           0   6469
6484: oGetAddrLocal 3
6486: oPushResult
6487: oGetLocal 2
6489: oPushResult
6490: oSetResult 17
6492: oPushResult
6493: oNodeGetInt
6494: oPop 2
6496: oAssign
6497: oGetLocal 3
6499: oPushResult
6500: oSetResult 1
6502: oPushResult
6503: equal
6504: oPop 2
6506: oChoice 6520
6508: oEmit 15
6510: oGetLocal 3
6512: oPushResult
6513: oEmitInt
6514: oPop 1
6516: oEmit 31
6518: oJumpForward 6523
6520: Choice Lookup Table
           0   6508
6523: oEmit 33
6525: oInputChoice 6533
6527: oJumpForward 6541
6529: oJumpForward 6539
6531: oJumpForward 6539
6533: Choice Lookup Table
          12   6531
          16   6527
6538: oEndChoice
6539: oJumpBack 6411
6541: oReturn
6542: oLocalSpace 2
6544: oTypeSNodeType
6545: oChoice 6549
6547: oJumpForward 6554
6549: Choice Lookup Table
          32   6547
6552: oError 11
6554: oTypeSTop
6555: oPushResult
6556: oSetResult 39
6558: oPushResult
6559: oNodeGet
6560: oPop 2
6562: oPushResult
6563: oScopeEnter
6564: oPop 1
6566: oInput 0
6568: oGetAddrLocal 1
6570: oPushResult
6571: oScopeFindRequire
6572: oAssign
6573: oGetLocal 1
6575: oPushResult
6576: oNodeType
6577: oPop 1
6579: oChoice 6583
6581: oJumpForward 6588
6583: Choice Lookup Table
          20   6581
6586: oError 12
6588: oScopeEnd
6589: oGetAddrLocal 2
6591: oPushResult
6592: oGetLocal 1
6594: oPushResult
6595: oSetResult 22
6597: oPushResult
6598: oNodeGetInt
6599: oPop 2
6601: oAssign
6602: oGetLocal 2
6604: oPushResult
6605: equal_zero
6606: oPop 1
6608: oChoice 6622
6610: oEmit 15
6612: oGetLocal 2
6614: oPushResult
6615: oEmitInt
6616: oPop 1
6618: oEmit 33
6620: oJumpForward 6625
6622: Choice Lookup Table
           0   6610
6625: oTypeSPop
6626: oGetLocal 1
6628: oPushResult
6629: oSetResult 21
6631: oPushResult
6632: oNodeGet
6633: oPop 2
6635: oPushResult
6636: oTypeSPush
6637: oPop 1
6639: oReturn
6640: oLocalSpace 1
6642: oTypeSNodeType
6643: oChoice 6647
6645: oJumpForward 6652
6647: Choice Lookup Table
          29   6645
6650: oError 9
6652: oEmit 24
6654: oGetAddrLocal 1
6656: oPushResult
6657: oTypeSTop
6658: oAssign
6659: oTypeSPop
6660: oGetLocal 1
6662: oPushResult
6663: oSetResult 35
6665: oPushResult
6666: oNodeGet
6667: oPop 2
6669: oPushResult
6670: oTypeSPush
6671: oPop 1
6673: oReturn
6674: oLocalSpace 0
6676: oCall 8482
6678: oReturn
6679: oLocalSpace 2
6681: oGetAddrLocal 2
6683: oPushResult
6684: oGetParam 1
6686: oPushResult
6687: oSetResult 26
6689: oPushResult
6690: oNodeGetString
6691: oPop 2
6693: oAssign
6694: oGetLocal 2
6696: oPushResult
6697: oSetResult 0
6699: oPushResult
6700: equal_string
6701: oPop 2
6703: oChoice 6740
6705: oGetAddrLocal 1
6707: oPushResult
6708: oGetParam 1
6710: oPushResult
6711: oSetResult 4
6713: oPushResult
6714: oNodeGetInt
6715: oPop 2
6717: oPushResult
6718: ID_STRING
6719: oPop 1
6721: oPushResult
6722: oStringAllocLit
6723: oPop 1
6725: oAssign
6726: oJumpForward 6746
6728: oGetAddrLocal 1
6730: oPushResult
6731: oGetLocal 2
6733: oPushResult
6734: oStringAllocLit
6735: oPop 1
6737: oAssign
6738: oJumpForward 6746
6740: Choice Lookup Table
           0   6728
           1   6705
6745: oEndChoice
6746: oEmit 58
6748: oGetParam 1
6750: oPushResult
6751: oCall 8803
6753: oPop 1
6755: oGetLocal 1
6757: oPushResult
6758: oEmitInt
6759: oPop 1
6761: oReturn
6762: oLocalSpace 10
6764: oGetParam 1
6766: oPushResult
6767: oSetResult 25
6769: oPushResult
6770: oNodeGetBoolean
6771: oPop 2
6773: oChoice 6800
6775: oGetParam 1
6777: oPushResult
6778: oSetResult 28
6780: oPushResult
6781: oNodeGetBoolean
6782: oPop 2
6784: oChoice 6795
6786: oGetParam 1
6788: oPushResult
6789: oCall 6679
6791: oPop 1
6793: oJumpForward 6798
6795: Choice Lookup Table
           0   6786
6798: oJumpForward 6803
6800: Choice Lookup Table
           1   6775
6803: oGetParam 1
6805: oPushResult
6806: oSetResult 28
6808: oPushResult
6809: oSetResult 1
6811: oPushResult
6812: oNodeSetBoolean
6813: oPop 3
6815: oGetAddrLocal 1
6817: oPushResult
6818: oGetParam 1
6820: oPushResult
6821: oSetResult 27
6823: oPushResult
6824: oNodeGetBoolean
6825: oPop 2
6827: oAssign
6828: oGetAddrLocal 4
6830: oPushResult
6831: oGetParam 1
6833: oPushResult
6834: oNodeType
6835: oPop 1
6837: oPushResult
6838: oSetResult 13
6840: oPushResult
6841: equal_node_type
6842: oPop 2
6844: oAssign
6845: oGetLocal 4
6847: oChoice 6874
6849: oGetAddrLocal 2
6851: oPushResult
6852: oGetParam 1
6854: oPushResult
6855: oSetResult 21
6857: oPushResult
6858: oNodeGet
6859: oPop 2
6861: oAssign
6862: oGetAddrLocal 3
6864: oPushResult
6865: oGetLocal 2
6867: oPushResult
6868: oScopeAllocType
6869: oPop 1
6871: oAssign
6872: oJumpForward 6877
6874: Choice Lookup Table
           1   6849
6877: oGetAddrLocal 5
6879: oPushResult
6880: oGetParam 1
6882: oPushResult
6883: oSetResult 23
6885: oPushResult
6886: oNodeGet
6887: oPop 2
6889: oAssign
6890: oGetAddrLocal 6
6892: oPushResult
6893: oGetLocal 5
6895: oPushResult
6896: oSetResult 17
6898: oPushResult
6899: oNodeGetInt
6900: oPop 2
6902: oAssign
6903: oGetLocal 1
6905: oChoice 6927
6907: oEmit 47
6909: oGetLocal 6
6911: oPushResult
6912: oEmitInt
6913: oPop 1
6915: oJumpForward 6933
6917: oEmit 46
6919: oGetLocal 6
6921: oPushResult
6922: oEmitInt
6923: oPop 1
6925: oJumpForward 6933
6927: Choice Lookup Table
           0   6917
           1   6907
6932: oEndChoice
6933: oGetParam 1
6935: oPushResult
6936: oCall 8444
6938: oPop 1
6940: oPushResult
6941: oSetResult 0
6943: oPushResult
6944: greater
6945: oPop 2
6947: oChoice 6980
6949: oEmit 19
6951: oSetResult 0
6953: oPushResult
6954: oEmitInt
6955: oPop 1
6957: oEmit 20
6959: oGetParam 1
6961: oPushResult
6962: oCall 8464
6964: oPop 1
6966: oPushResult
6967: oEmitInt
6968: oPop 1
6970: oSetResult 0
6972: oPushResult
6973: oEmitInt
6974: oPop 1
6976: oEmit 27
6978: oJumpForward 6983
6980: Choice Lookup Table
           1   6949
6983: oGetAddrLocal 7
6985: oPushResult
6986: oGetLocal 5
6988: oPushResult
6989: oSetResult 15
6991: oPushResult
6992: oNodeGetIter
6993: oPop 2
6995: oAssign
6996: oGetAddrLocal 8
6998: oPushResult
6999: oGetLocal 7
7001: oPushResult
7002: oNodeIterValue
7003: oPop 1
7005: oAssign
7006: oInputChoice 7187
7008: oGetLocal 8
7010: oPushResult
7011: oNodeNull
7012: oPop 1
7014: oChoice 7020
7016: oJumpForward 7183
7018: oJumpForward 7023
7020: Choice Lookup Table
           1   7016
7023: oGetAddrLocal 9
7025: oPushResult
7026: oGetLocal 8
7028: oPushResult
7029: oSetResult 22
7031: oPushResult
7032: oNodeGetInt
7033: oPop 2
7035: oAssign
7036: oEmit 19
7038: oGetLocal 9
7040: oPushResult
7041: oEmitInt
7042: oPop 1
7044: oGetLocal 8
7046: oPushResult
7047: oSetResult 21
7049: oPushResult
7050: oNodeGet
7051: oPop 2
7053: oPushResult
7054: oTypeSPush
7055: oPop 1
7057: oGetLocal 8
7059: oPushResult
7060: oSetResult 33
7062: oPushResult
7063: oNodeGetBoolean
7064: oPop 2
7066: oChoice 7136
7068: oCall 7688
7070: oCall 8482
7072: oEmit 27
7074: oJumpForward 7142
7076: oCall 4314
7078: oCall 6674
7080: oTypeSNodeType
7081: oChoice 7099
7083: oEmit 25
7085: oJumpForward 7134
7087: oEmit 26
7089: oJumpForward 7134
7091: oError 16
7093: oJumpForward 7134
7095: oEmit 27
7097: oJumpForward 7134
7099: Choice Lookup Table
          29   7095
          23   7091
          28   7091
          27   7091
          25   7087
          33   7083
          24   7083
7114: oGetAddrLocal 10
7116: oPushResult
7117: oTypeSTop
7118: oPushResult
7119: oSetResult 17
7121: oPushResult
7122: oNodeGetInt
7123: oPop 2
7125: oAssign
7126: oEmit 28
7128: oGetLocal 10
7130: oPushResult
7131: oEmitInt
7132: oPop 1
7134: oJumpForward 7142
7136: Choice Lookup Table
           0   7076
           1   7068
7141: oEndChoice
7142: oTypeSPop
7143: oGetAddrLocal 7
7145: oPushResult
7146: oNodeIterNext
7147: oPop 1
7149: oGetAddrLocal 8
7151: oPushResult
7152: oGetLocal 7
7154: oPushResult
7155: oNodeIterValue
7156: oPop 1
7158: oAssign
7159: oGetLocal 8
7161: oPushResult
7162: oNodeNull
7163: oPop 1
7165: oChoice 7173
7167: oJumpForward 7183
7169: oJumpForward 7179
7171: oJumpForward 7179
7173: Choice Lookup Table
           0   7171
           1   7167
7178: oEndChoice
7179: oInput 12
7181: oJumpBack 7008
7183: oInput 14
7185: oJumpForward 7190
7187: Choice Lookup Table
          13   7008
7190: oGetLocal 8
7192: oPushResult
7193: oNodeNull
7194: oPop 1
7196: oChoice 7202
7198: oError 15
7200: oJumpForward 7205
7202: Choice Lookup Table
           0   7198
7205: oGetLocal 4
7207: oChoice 7236
7209: oEmit 19
7211: oGetParam 1
7213: oPushResult
7214: oSetResult 31
7216: oPushResult
7217: oNodeGetInt
7218: oPop 2
7220: oPushResult
7221: oEmitInt
7222: oPop 1
7224: oEmit 17
7226: oGetLocal 3
7228: oPushResult
7229: oEmitInt
7230: oPop 1
7232: oEmit 27
7234: oJumpForward 7239
7236: Choice Lookup Table
           1   7209
7239: oGetLocal 1
7241: oChoice 7265
7243: oEmit 50
7245: oGetParam 1
7247: oPushResult
7248: oCall 8803
7250: oPop 1
7252: oJumpForward 7271
7254: oEmit 49
7256: oGetParam 1
7258: oPushResult
7259: oCall 8803
7261: oPop 1
7263: oJumpForward 7271
7265: Choice Lookup Table
           0   7254
           1   7243
7270: oEndChoice
7271: oGetLocal 4
7273: oChoice 7343
7275: oGetLocal 2
7277: oPushResult
7278: oTypeSPush
7279: oPop 1
7281: oTypeSNodeType
7282: oChoice 7318
7284: oEmit 3
7286: oGetLocal 3
7288: oPushResult
7289: oEmitInt
7290: oPop 1
7292: oJumpForward 7341
7294: oEmit 4
7296: oGetLocal 3
7298: oPushResult
7299: oEmitInt
7300: oPop 1
7302: oJumpForward 7341
7304: oError 16
7306: oJumpForward 7341
7308: oEmit 5
7310: oGetLocal 3
7312: oPushResult
7313: oEmitInt
7314: oPop 1
7316: oJumpForward 7341
7318: Choice Lookup Table
          29   7308
          23   7304
          28   7304
          27   7304
          25   7294
          33   7284
          24   7284
7333: oEmit 17
7335: oGetLocal 3
7337: oPushResult
7338: oEmitInt
7339: oPop 1
7341: oJumpForward 7346
7343: Choice Lookup Table
           1   7275
7346: oEmit 48
7348: oGetLocal 6
7350: oPushResult
7351: oEmitInt
7352: oPop 1
7354: oReturn
7355: oLocalSpace 0
7357: oInputChoice 7407
7359: oCall 8332
7361: oJumpForward 7432
7363: oCall 8339
7365: oJumpForward 7432
7367: oCall 8426
7369: oJumpForward 7432
7371: oCall 8429
7373: oJumpForward 7432
7375: oCall 7872
7377: oJumpForward 7432
7379: oCall 8192
7381: oJumpForward 7432
7383: oCall 7938
7385: oJumpForward 7432
7387: oCall 8112
7389: oJumpForward 7432
7391: oCall 8277
7393: oJumpForward 7432
7395: oCall 8245
7397: oJumpForward 7432
7399: oCall 8309
7401: oJumpForward 7432
7403: oCall 7433
7405: oJumpForward 7432
7407: Choice Lookup Table
           0   7403
          33   7399
          49   7395
          50   7391
          47   7387
          42   7383
          46   7379
          39   7375
          63   7371
          62   7367
          61   7363
          60   7359
7432: oReturn
7433: oLocalSpace 1
7435: oGetAddrLocal 1
7437: oPushResult
7438: oScopeFindRequire
7439: oAssign
7440: oGetAddrLocal 1
7442: oPushResult
7443: oCall 396
7445: oPop 1
7447: oGetLocal 1
7449: oPushResult
7450: oNodeType
7451: oPop 1
7453: oChoice 7482
7455: oGetLocal 1
7457: oPushResult
7458: oCall 6762
7460: oPop 1
7462: oJumpForward 7495
7464: oGetLocal 1
7466: oPushResult
7467: oCall 7496
7469: oPop 1
7471: oJumpForward 7495
7473: oGetLocal 1
7475: oPushResult
7476: oCall 7572
7478: oPop 1
7480: oJumpForward 7495
7482: Choice Lookup Table
          13   7473
          21   7464
          19   7464
          18   7464
          12   7455
7493: oError 0
7495: oReturn
7496: oLocalSpace 0
7498: oGetParam 1
7500: oPushResult
7501: oCall 7731
7503: oPop 1
7505: oInput 3
7507: oCall 4314
7509: oCall 8482
7511: oCall 7514
7513: oReturn
7514: oLocalSpace 1
7516: oTypeSNodeType
7517: oChoice 7535
7519: oEmit 25
7521: oJumpForward 7570
7523: oEmit 26
7525: oJumpForward 7570
7527: oError 16
7529: oJumpForward 7570
7531: oEmit 27
7533: oJumpForward 7570
7535: Choice Lookup Table
          29   7531
          23   7527
          28   7527
          27   7527
          25   7523
          33   7519
          24   7519
7550: oGetAddrLocal 1
7552: oPushResult
7553: oTypeSTop
7554: oPushResult
7555: oSetResult 17
7557: oPushResult
7558: oNodeGetInt
7559: oPop 2
7561: oAssign
7562: oEmit 28
7564: oGetLocal 1
7566: oPushResult
7567: oEmitInt
7568: oPop 1
7570: oTypeSPop
7571: oReturn
7572: oLocalSpace 1
7574: oGetParam 1
7576: oPushResult
7577: oSetResult 6
7579: oPushResult
7580: oNodeGet
7581: oPop 2
7583: oPushResult
7584: oScopeCurrent
7585: oPushResult
7586: oNodeEqual
7587: oPop 2
7589: oChoice 7595
7591: oError 20
7593: oJumpForward 7598
7595: Choice Lookup Table
           0   7591
7598: oEmit 8
7600: oGetParam 1
7602: oPushResult
7603: oSetResult 31
7605: oPushResult
7606: oNodeGetInt
7607: oPop 2
7609: oPushResult
7610: oEmitInt
7611: oPop 1
7613: oGetParam 1
7615: oPushResult
7616: oSetResult 21
7618: oPushResult
7619: oNodeGet
7620: oPop 2
7622: oPushResult
7623: oTypeSPush
7624: oPop 1
7626: oInput 3
7628: oCall 4314
7630: oCall 8482
7632: oTypeSNodeType
7633: oChoice 7651
7635: oEmit 25
7637: oJumpForward 7686
7639: oEmit 26
7641: oJumpForward 7686
7643: oError 16
7645: oJumpForward 7686
7647: oEmit 27
7649: oJumpForward 7686
7651: Choice Lookup Table
          29   7647
          23   7643
          28   7643
          27   7643
          25   7639
          33   7635
          24   7635
7666: oGetAddrLocal 1
7668: oPushResult
7669: oTypeSTop
7670: oPushResult
7671: oSetResult 17
7673: oPushResult
7674: oNodeGetInt
7675: oPop 2
7677: oAssign
7678: oEmit 28
7680: oGetLocal 1
7682: oPushResult
7683: oEmitInt
7684: oPop 1
7686: oTypeSPop
7687: oReturn
7688: oLocalSpace 1
7690: oInput 0
7692: oGetAddrLocal 1
7694: oPushResult
7695: oScopeFindRequire
7696: oAssign
7697: oGetAddrLocal 1
7699: oPushResult
7700: oCall 396
7702: oPop 1
7704: oGetLocal 1
7706: oPushResult
7707: oNodeType
7708: oPop 1
7710: oChoice 7714
7712: oJumpForward 7723
7714: Choice Lookup Table
          21   7712
          19   7712
          18   7712
7721: oError 4
7723: oGetLocal 1
7725: oPushResult
7726: oCall 7731
7728: oPop 1
7730: oReturn
7731: oLocalSpace 0
7733: oGetParam 1
7735: oPushResult
7736: oNodeType
7737: oPop 1
7739: oChoice 7799
7741: oEmit 16
7743: oGetParam 1
7745: oPushResult
7746: oCall 8803
7748: oPop 1
7750: oJumpForward 7808
7752: oEmit 17
7754: oGetParam 1
7756: oPushResult
7757: oCall 8803
7759: oPop 1
7761: oJumpForward 7808
7763: oGetParam 1
7765: oPushResult
7766: oSetResult 33
7768: oPushResult
7769: oNodeGetBoolean
7770: oPop 2
7772: oChoice 7785
7774: oEmit 8
7776: oGetParam 1
7778: oPushResult
7779: oCall 8803
7781: oPop 1
7783: oJumpForward 7797
7785: Choice Lookup Table
           1   7774
7788: oEmit 18
7790: oGetParam 1
7792: oPushResult
7793: oCall 8803
7795: oPop 1
7797: oJumpForward 7808
7799: Choice Lookup Table
          21   7763
          19   7752
          18   7741
7806: oError 4
7808: oGetParam 1
7810: oPushResult
7811: oSetResult 21
7813: oPushResult
7814: oNodeGet
7815: oPop 2
7817: oPushResult
7818: oTypeSPush
7819: oPop 1
7821: oCall 6371
7823: oReturn
7824: oLocalSpace 0
7826: oGetParam 1
7828: oPushResult
7829: oCall 7731
7831: oPop 1
7833: oCall 8508
7835: oGetParam 1
7837: oPushResult
7838: oCall 5606
7840: oPop 1
7842: oTypeSPop
7843: oEmit 29
7845: oEmit 25
7847: oReturn
7848: oLocalSpace 0
7850: oGetParam 1
7852: oPushResult
7853: oCall 7731
7855: oPop 1
7857: oCall 8508
7859: oGetParam 1
7861: oPushResult
7862: oCall 5606
7864: oPop 1
7866: oTypeSPop
7867: oEmit 30
7869: oEmit 25
7871: oReturn
7872: oLocalSpace 2
7874: oGetAddrLocal 1
7876: oPushResult
7877: oSetResult 0
7879: oAssign
7880: oGetAddrLocal 1
7882: oPushResult
7883: oCall 4337
7885: oPop 1
7887: oInput 40
7889: oCall 7355
7891: oInputChoice 7926
7893: oGetAddrLocal 2
7895: oPushResult
7896: oLabelNew
7897: oAssign
7898: oEmit 53
7900: oGetLocal 2
7902: oPushResult
7903: oEmitLabel
7904: oPop 1
7906: oEmit 56
7908: oGetLocal 1
7910: oPushResult
7911: oEmitLabel
7912: oPop 1
7914: oCall 7355
7916: oEmit 56
7918: oGetLocal 2
7920: oPushResult
7921: oEmitLabel
7922: oPop 1
7924: oJumpForward 7937
7926: Choice Lookup Table
          41   7893
7929: oEmit 56
7931: oGetLocal 1
7933: oPushResult
7934: oEmitLabel
7935: oPop 1
7937: oReturn
7938: oLocalSpace 4
7940: oInput 0
7942: oGetAddrLocal 1
7944: oPushResult
7945: oScopeFindRequire
7946: oAssign
7947: oGetLocal 1
7949: oPushResult
7950: oCall 7731
7952: oPop 1
7954: oCall 8508
7956: oInput 3
7958: oCall 4314
7960: oCall 8508
7962: oEmit 25
7964: oGetAddrLocal 2
7966: oPushResult
7967: oLabelNew
7968: oAssign
7969: oGetAddrLocal 3
7971: oPushResult
7972: oLabelNew
7973: oAssign
7974: oEmit 53
7976: oGetLocal 3
7978: oPushResult
7979: oEmitLabel
7980: oPop 1
7982: oGetAddrLocal 4
7984: oPushResult
7985: oLabelNew
7986: oAssign
7987: oEmit 56
7989: oGetLocal 4
7991: oPushResult
7992: oEmitLabel
7993: oPop 1
7995: oInputChoice 8075
7997: oGetLocal 1
7999: oPushResult
8000: oCall 7824
8002: oPop 1
8004: oEmit 56
8006: oGetLocal 3
8008: oPushResult
8009: oEmitLabel
8010: oPop 1
8012: oGetLocal 1
8014: oPushResult
8015: oCall 5606
8017: oPop 1
8019: oTypeSPop
8020: oCall 4314
8022: oCall 8508
8024: oEmit 40
8026: oEmit 54
8028: oGetLocal 2
8030: oPushResult
8031: oEmitLabel
8032: oPop 1
8034: oJumpForward 8081
8036: oGetLocal 1
8038: oPushResult
8039: oCall 7848
8041: oPop 1
8043: oEmit 56
8045: oGetLocal 3
8047: oPushResult
8048: oEmitLabel
8049: oPop 1
8051: oGetLocal 1
8053: oPushResult
8054: oCall 5606
8056: oPop 1
8058: oTypeSPop
8059: oCall 4314
8061: oCall 8508
8063: oEmit 41
8065: oEmit 54
8067: oGetLocal 2
8069: oPushResult
8070: oEmitLabel
8071: oPop 1
8073: oJumpForward 8081
8075: Choice Lookup Table
          44   8036
          43   7997
8080: oEndChoice
8081: oGetLocal 4
8083: oPushResult
8084: oGetLocal 2
8086: oPushResult
8087: oLoopPush
8088: oPop 2
8090: oInput 45
8092: oCall 7355
8094: oEmit 53
8096: oGetLocal 4
8098: oPushResult
8099: oEmitLabel
8100: oPop 1
8102: oEmit 56
8104: oGetLocal 2
8106: oPushResult
8107: oEmitLabel
8108: oPop 1
8110: oLoopPop
8111: oReturn
8112: oLocalSpace 3
8114: oGetAddrLocal 1
8116: oPushResult
8117: oLabelNew
8118: oAssign
8119: oEmit 56
8121: oGetLocal 1
8123: oPushResult
8124: oEmitLabel
8125: oPop 1
8127: oGetAddrLocal 2
8129: oPushResult
8130: oLabelNew
8131: oAssign
8132: oGetLocal 1
8134: oPushResult
8135: oGetLocal 2
8137: oPushResult
8138: oLoopPush
8139: oPop 2
8141: oCall 7355
8143: oInputChoice 8174
8145: oCall 7355
8147: oJumpForward 8180
8149: oGetAddrLocal 3
8151: oPushResult
8152: oCall 4337
8154: oPop 1
8156: oEmit 57
8158: oGetLocal 3
8160: oPushResult
8161: oEmitLabel
8162: oPop 1
8164: oGetLocal 1
8166: oPushResult
8167: oEmitLabel
8168: oPop 1
8170: oJumpForward 8182
8172: oJumpForward 8180
8174: Choice Lookup Table
          48   8149
           4   8145
8179: oEndChoice
8180: oJumpBack 8143
8182: oEmit 56
8184: oGetLocal 2
8186: oPushResult
8187: oEmitLabel
8188: oPop 1
8190: oLoopPop
8191: oReturn
8192: oLocalSpace 2
8194: oGetAddrLocal 1
8196: oPushResult
8197: oLabelNew
8198: oAssign
8199: oEmit 56
8201: oGetLocal 1
8203: oPushResult
8204: oEmitLabel
8205: oPop 1
8207: oGetAddrLocal 2
8209: oPushResult
8210: oCall 4337
8212: oPop 1
8214: oGetLocal 1
8216: oPushResult
8217: oGetLocal 2
8219: oPushResult
8220: oLoopPush
8221: oPop 2
8223: oInput 45
8225: oCall 7355
8227: oEmit 53
8229: oGetLocal 1
8231: oPushResult
8232: oEmitLabel
8233: oPop 1
8235: oEmit 56
8237: oGetLocal 2
8239: oPushResult
8240: oEmitLabel
8241: oPop 1
8243: oLoopPop
8244: oReturn
8245: oLocalSpace 0
8247: oLoopContinueLabel
8248: oPushResult
8249: oSetResult 0
8251: oPushResult
8252: equal_label
8253: oPop 2
8255: oChoice 8270
8257: oError 18
8259: oJumpForward 8276
8261: oEmit 53
8263: oLoopContinueLabel
8264: oPushResult
8265: oEmitLabel
8266: oPop 1
8268: oJumpForward 8276
8270: Choice Lookup Table
           0   8261
           1   8257
8275: oEndChoice
8276: oReturn
8277: oLocalSpace 0
8279: oLoopBreakLabel
8280: oPushResult
8281: oSetResult 0
8283: oPushResult
8284: equal_label
8285: oPop 2
8287: oChoice 8302
8289: oError 18
8291: oJumpForward 8308
8293: oEmit 53
8295: oLoopBreakLabel
8296: oPushResult
8297: oEmitLabel
8298: oPop 1
8300: oJumpForward 8308
8302: Choice Lookup Table
           0   8293
           1   8289
8307: oEndChoice
8308: oReturn
8309: oLocalSpace 0
8311: oCall 7355
8313: oInputChoice 8323
8315: oCall 7355
8317: oJumpForward 8329
8319: oJumpForward 8331
8321: oJumpForward 8329
8323: Choice Lookup Table
          34   8319
           4   8315
8328: oEndChoice
8329: oJumpBack 8313
8331: oReturn
8332: oLocalSpace 0
8334: oCall 8339
8336: oEmit 64
8338: oReturn
8339: oLocalSpace 0
8341: oInputChoice 8422
8343: oCall 4314
8345: oTypeSNodeType
8346: oChoice 8386
8348: oEmit 59
8350: oJumpForward 8403
8352: oEmit 60
8354: oJumpForward 8403
8356: oEmit 61
8358: oJumpForward 8403
8360: oError 16
8362: oJumpForward 8403
8364: oEmit 16
8366: oTypeSTop
8367: oPushResult
8368: oSetResult 40
8370: oPushResult
8371: oNodeGetInt
8372: oPop 2
8374: oPushResult
8375: oEmitInt
8376: oPop 1
8378: oEmit 63
8380: oJumpForward 8403
8382: oEmit 62
8384: oJumpForward 8403
8386: Choice Lookup Table
          29   8382
          33   8364
          23   8360
          27   8360
          28   8356
          25   8352
          24   8348
8401: oError 17
8403: oTypeSPop
8404: oInputChoice 8412
8406: oJumpForward 8420
8408: oJumpForward 8418
8410: oJumpForward 8418
8412: Choice Lookup Table
          12   8410
          14   8406
8417: oEndChoice
8418: oJumpBack 8343
8420: oJumpForward 8425
8422: Choice Lookup Table
          13   8343
8425: oReturn
8426: oLocalSpace 0
8428: oReturn
8429: oLocalSpace 0
8431: oReturn
8432: oLocalSpace 0
8434: oScopeCurrent
8435: oPushResult
8436: oSetResult 14
8438: oPushResult
8439: oNodeGetInt
8440: oPop 2
8442: oReturn
8443: oReturn
8444: oLocalSpace 0
8446: oGetParam 1
8448: oPushResult
8449: oSetResult 20
8451: oPushResult
8452: oNodeGet
8453: oPop 2
8455: oPushResult
8456: oSetResult 14
8458: oPushResult
8459: oNodeGetInt
8460: oPop 2
8462: oReturn
8463: oReturn
8464: oLocalSpace 0
8466: oCall 8432
8468: oPushResult
8469: oGetParam 1
8471: oPushResult
8472: oCall 8444
8474: oPop 1
8476: oPushResult
8477: subtract
8478: oPop 2
8480: oReturn
8481: oReturn
8482: oLocalSpace 1
8484: oGetAddrLocal 1
8486: oPushResult
8487: oTypeSNodeType
8488: oAssign
8489: oTypeSPop
8490: oGetLocal 1
8492: oPushResult
8493: oTypeSNodeType
8494: oPushResult
8495: equal_node_type
8496: oPop 2
8498: oChoice 8504
8500: oError 14
8502: oJumpForward 8507
8504: Choice Lookup Table
           0   8500
8507: oReturn
8508: oLocalSpace 0
8510: oTypeSNodeType
8511: oChoice 8515
8513: oJumpForward 8520
8515: Choice Lookup Table
          24   8513
8518: oError 7
8520: oTypeSPop
8521: oReturn
8522: oLocalSpace 0
8524: oTypeSNodeType
8525: oChoice 8529
8527: oJumpForward 8534
8529: Choice Lookup Table
          24   8527
8532: oError 7
8534: oReturn
8535: oLocalSpace 0
8537: oTypeSNodeType
8538: oChoice 8542
8540: oJumpForward 8547
8542: Choice Lookup Table
          25   8540
8545: oError 8
8547: oTypeSPop
8548: oReturn
8549: oLocalSpace 0
8551: oTypeSNodeType
8552: oChoice 8556
8554: oJumpForward 8561
8556: Choice Lookup Table
          25   8554
8559: oError 8
8561: oReturn
8562: oLocalSpace 1
8564: oGetAddrLocal 1
8566: oPushResult
8567: oGetParam 2
8569: oPushResult
8570: oNodeNew
8571: oPop 1
8573: oAssign
8574: oGetLocal 1
8576: oPushResult
8577: oSetResult 17
8579: oPushResult
8580: oGetParam 1
8582: oPushResult
8583: oNodeSetInt
8584: oPop 3
8586: oGetLocal 1
8588: oPushResult
8589: oTypeAdd
8590: oPop 1
8592: oGetLocal 1
8594: oReturn
8595: oReturn
8596: oLocalSpace 1
8598: oGetAddrLocal 1
8600: oPushResult
8601: oGetParam 2
8603: oPushResult
8604: oNodeNew
8605: oPop 1
8607: oAssign
8608: oGetLocal 1
8610: oPushResult
8611: oSetResult 4
8613: oPushResult
8614: oGetParam 1
8616: oPushResult
8617: oNodeSetInt
8618: oPop 3
8620: oGetLocal 1
8622: oReturn
8623: oReturn
8624: oLocalSpace 1
8626: oGetAddrLocal 1
8628: oPushResult
8629: oGetParam 1
8631: oPushResult
8632: oSetResult 34
8634: oPushResult
8635: oNodeGet
8636: oPop 2
8638: oAssign
8639: oGetLocal 1
8641: oPushResult
8642: oNodeNull
8643: oPop 1
8645: oChoice 8701
8647: oGetAddrLocal 1
8649: oPushResult
8650: oSetResult 29
8652: oPushResult
8653: oNodeNew
8654: oPop 1
8656: oAssign
8657: oGetLocal 1
8659: oPushResult
8660: oSetResult 35
8662: oPushResult
8663: oGetParam 1
8665: oPushResult
8666: oNodeSet
8667: oPop 3
8669: oGetLocal 1
8671: oPushResult
8672: oSetResult 17
8674: oPushResult
8675: oSetResult 8
8677: oPushResult
8678: oNodeSetInt
8679: oPop 3
8681: oGetLocal 1
8683: oPushResult
8684: oTypeAdd
8685: oPop 1
8687: oGetParam 1
8689: oPushResult
8690: oSetResult 34
8692: oPushResult
8693: oGetLocal 1
8695: oPushResult
8696: oNodeSet
8697: oPop 3
8699: oJumpForward 8704
8701: Choice Lookup Table
           1   8647
8704: oGetLocal 1
8706: oReturn
8707: oReturn
8708: oLocalSpace 2
8710: oGetParam 1
8712: oPushResult
8713: oNodeType
8714: oPop 1
8716: oChoice 8786
8718: oMININT
8719: oReturn
8720: oJumpForward 8802
8722: oSetResult 0
8724: oReturn
8725: oJumpForward 8802
8727: oSetResult 0
8729: oReturn
8730: oJumpForward 8802
8732: oGetAddrLocal 1
8734: oPushResult
8735: oGetParam 1
8737: oPushResult
8738: oSetResult 39
8740: oPushResult
8741: oNodeGet
8742: oPop 2
8744: oAssign
8745: oGetAddrLocal 2
8747: oPushResult
8748: oGetLocal 1
8750: oPushResult
8751: oSetResult 15
8753: oPushResult
8754: oNodeGetIter
8755: oPop 2
8757: oPushResult
8758: oNodeIterValue
8759: oPop 1
8761: oAssign
8762: oGetLocal 2
8764: oPushResult
8765: oSetResult 22
8767: oPushResult
8768: oNodeGetInt
8769: oPop 2
8771: oReturn
8772: oJumpForward 8802
8774: oGetParam 1
8776: oPushResult
8777: oSetResult 37
8779: oPushResult
8780: oNodeGetInt
8781: oPop 2
8783: oReturn
8784: oJumpForward 8802
8786: Choice Lookup Table
          31   8774
          33   8732
          27   8727
          25   8722
          24   8718
8797: oError 3
8799: oSetResult 0
8801: oReturn
8802: oReturn
8803: oLocalSpace 0
8805: oGetParam 1
8807: oPushResult
8808: oSetResult 22
8810: oPushResult
8811: oNodeGetInt
8812: oPop 2
8814: oPushResult
8815: oEmitInt
8816: oPop 1
8818: oReturn
8819: oLocalSpace 1
8821: oGetAddrGlobal 4
8823: oPushResult
8824: oSetResult 23
8826: oPushResult
8827: oSetResult 4
8829: oPushResult
8830: oCall 8562
8832: oPop 2
8834: oAssign
8835: oGetAddrGlobal 5
8837: oPushResult
8838: oSetResult 24
8840: oPushResult
8841: oSetResult 4
8843: oPushResult
8844: oCall 8562
8846: oPop 2
8848: oAssign
8849: oGetAddrGlobal 6
8851: oPushResult
8852: oSetResult 25
8854: oPushResult
8855: oSetResult 1
8857: oPushResult
8858: oCall 8562
8860: oPop 2
8862: oAssign
8863: oGetAddrGlobal 7
8865: oPushResult
8866: oSetResult 26
8868: oPushResult
8869: oSetResult 1
8871: oPushResult
8872: oCall 8562
8874: oPop 2
8876: oAssign
8877: oGetAddrGlobal 8
8879: oPushResult
8880: oSetResult 27
8882: oPushResult
8883: oSetResult 1
8885: oPushResult
8886: oCall 8562
8888: oPop 2
8890: oAssign
8891: oGetAddrGlobal 9
8893: oPushResult
8894: oSetResult 28
8896: oPushResult
8897: oSetResult 256
8899: oPushResult
8900: oCall 8562
8902: oPop 2
8904: oAssign
8905: oGetAddrLocal 1
8907: oPushResult
8908: oSetResult 16
8910: oPushResult
8911: oIdAdd_File
8912: oPushResult
8913: oCall 8596
8915: oPop 2
8917: oAssign
8918: oGetLocal 1
8920: oPushResult
8921: oSetResult 21
8923: oPushResult
8924: oGetGlobal 4
8926: oPushResult
8927: oNodeSet
8928: oPop 3
8930: oGetLocal 1
8932: oPushResult
8933: oScopeDeclare
8934: oPop 1
8936: oGetAddrLocal 1
8938: oPushResult
8939: oSetResult 16
8941: oPushResult
8942: oIdAdd_Integer
8943: oPushResult
8944: oCall 8596
8946: oPop 2
8948: oAssign
8949: oGetLocal 1
8951: oPushResult
8952: oSetResult 21
8954: oPushResult
8955: oGetGlobal 5
8957: oPushResult
8958: oNodeSet
8959: oPop 3
8961: oGetLocal 1
8963: oPushResult
8964: oScopeDeclare
8965: oPop 1
8967: oGetAddrLocal 1
8969: oPushResult
8970: oSetResult 16
8972: oPushResult
8973: oIdAdd_Boolean
8974: oPushResult
8975: oCall 8596
8977: oPop 2
8979: oAssign
8980: oGetLocal 1
8982: oPushResult
8983: oSetResult 21
8985: oPushResult
8986: oGetGlobal 6
8988: oPushResult
8989: oNodeSet
8990: oPop 3
8992: oGetLocal 1
8994: oPushResult
8995: oScopeDeclare
8996: oPop 1
8998: oGetAddrLocal 1
9000: oPushResult
9001: oSetResult 16
9003: oPushResult
9004: oIdAdd_Char
9005: oPushResult
9006: oCall 8596
9008: oPop 2
9010: oAssign
9011: oGetLocal 1
9013: oPushResult
9014: oSetResult 21
9016: oPushResult
9017: oGetGlobal 8
9019: oPushResult
9020: oNodeSet
9021: oPop 3
9023: oGetLocal 1
9025: oPushResult
9026: oScopeDeclare
9027: oPop 1
9029: oGetAddrLocal 1
9031: oPushResult
9032: oSetResult 16
9034: oPushResult
9035: oIdAdd_String
9036: oPushResult
9037: oCall 8596
9039: oPop 2
9041: oAssign
9042: oGetLocal 1
9044: oPushResult
9045: oSetResult 21
9047: oPushResult
9048: oGetGlobal 9
9050: oPushResult
9051: oNodeSet
9052: oPop 3
9054: oGetLocal 1
9056: oPushResult
9057: oScopeDeclare
9058: oPop 1
9060: oGetAddrLocal 1
9062: oPushResult
9063: oSetResult 14
9065: oPushResult
9066: oIdAdd_True
9067: oPushResult
9068: oCall 8596
9070: oPop 2
9072: oAssign
9073: oGetLocal 1
9075: oPushResult
9076: oSetResult 21
9078: oPushResult
9079: oGetGlobal 6
9081: oPushResult
9082: oNodeSet
9083: oPop 3
9085: oGetLocal 1
9087: oPushResult
9088: oSetResult 22
9090: oPushResult
9091: oSetResult 1
9093: oPushResult
9094: oNodeSetInt
9095: oPop 3
9097: oGetLocal 1
9099: oPushResult
9100: oScopeDeclare
9101: oPop 1
9103: oGetAddrLocal 1
9105: oPushResult
9106: oSetResult 14
9108: oPushResult
9109: oIdAdd_False
9110: oPushResult
9111: oCall 8596
9113: oPop 2
9115: oAssign
9116: oGetLocal 1
9118: oPushResult
9119: oSetResult 21
9121: oPushResult
9122: oGetGlobal 6
9124: oPushResult
9125: oNodeSet
9126: oPop 3
9128: oGetLocal 1
9130: oPushResult
9131: oSetResult 22
9133: oPushResult
9134: oSetResult 0
9136: oPushResult
9137: oNodeSetInt
9138: oPop 3
9140: oGetLocal 1
9142: oPushResult
9143: oScopeDeclare
9144: oPop 1
9146: oReturn
