   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
 162:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 169:    oScopeBegin
 170:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 181:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 192:    @BlockStmt( mainLabel )
      
 199:    oScopeEnd   % main routine scope
      
 200:    '.'
 202:    oScopeEnd   % global scope
 204:    ;
      
      
 204: Block( node_type varNodeType, Label labelForBody ):
 206:    @BlockDecls( varNodeType )
 213:    @BlockStmt( labelForBody )
 221:    ;
      
      
 221: BlockDecls( node_type varNodeType ):
 223:    {[
 223:       | pConst :     @ConstDecl
 227:       | pType :      @TypeDecl
 231:       | pVar :       @VarDecl( varNodeType )
 240:       | pProcedure : @ProcDecl
 244:       | pFunction :  @FuncDecl
 248:       | * :          >
 263:    ]}
 265:    @CheckForUndefinedMethods
 268:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 268: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 271:    ;
      
      
      
 271: BlockStmt( Label labelForBody ):
 273:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 281:    int patchLS
 281:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 290:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 302:    oEmitCode( initCode )
 308:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 319:    @Statement
 321:    .tReturn
      
 323:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 335:    oPatch( patchLS, localSpace )
 345:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 345: MethodModifiers( Node decl ):
 347:    {[
 347:       | pCdecl :
 349:          oNodeSetBoolean( decl, qCdecl, true )
 361:          ';'
      
 363:       | * : >
 370:    ]}
 373:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 373: ExternalDecl( Node decl ):
 375:    oNodeSetBoolean( decl, qExternal, true )
 387:    [
 387:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 389:          [
 389:             | pName :
 391:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 393:             | * :
 398:          ]
 398:       | * :
 403:    ]
 404:    ;
      
      
 404: ProcDecl:
 406:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 408:    boolean redeclaring = false
 414:    Node decl = oScopeFindInCurrentScope
      
 419:    [ oNodeNull( decl )
 426:       | true :
               % first declaration
 427:          decl = @newIdent( nProc, kProc, LAST_ID )
 443:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 454:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 456:          redeclaring = true
 462:          [ oNodeGetBoolean( decl, qBodyDefined )
 472:             | true : #eAlreadyDefined
 475:             | * :
 480:          ]
 480:          [ oNodeGetBoolean( decl, qExternal )
 490:             | true : #eAlreadyDefined
 493:             | * :
 498:          ]
 498:          [ oNodeType( decl )
 505:             | nProc :
 506:             | * : #eAlreadyDefined   % wrong kind
 513:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 513:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 532:          oNodeSet( decl, qParams, Null )
 544:    ]
      
 552:    oScopeBegin
 553:    Node paramScope = oScopeCurrent
      
 558:    @FormalArgDecl
 560:    oNodeSet( decl, qParams, paramScope )
 572:    oScopeEnd
 573:    ';'
      
 575:    [ redeclaring
 578:       | false : oScopeDeclare( decl )
 585:       | true :  % TO DO: check that qParams is consistent with qOldParams
 587:    ]
      
 595:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 602:    [
 602:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 604:       | pExternal : @ExternalDecl( decl )
      
 613:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 620:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 626:          oScopeBegin
 627:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 638:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 649:          Label label = oNodeGetLabel( decl, qValue )
 662:          @Block( nLocalVar, label )
 672:          oNodeSetBoolean( decl, qBodyDefined, true )
 684:          oScopeEnd
      
 685:          oScopeEnd  % paramScope
 686:    ]
 686:    ';';
      
      
 689: FuncDecl:
 691:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 693:    boolean redeclaring = false
 699:    Node decl = oScopeFindInCurrentScope
      
 704:    [ oNodeNull( decl )
 711:       | true :
               % first declaration
 712:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 728:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 739:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 741:          redeclaring = true
 747:          [ oNodeGetBoolean( decl, qBodyDefined )
 757:             | true : #eAlreadyDefined
 760:             | * :
 765:          ]
 765:          [ oNodeType( decl )
 772:             | nFunc :
 773:             | * : #eAlreadyDefined   % wrong kind
 780:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 780:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 799:          oNodeSet( decl, qParams, Null )
 811:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 830:          oNodeSet( decl, qType, Null )
 842:    ]
      
 850:    oScopeBegin
 851:    Node paramScope = oScopeCurrent
      
 856:    @FormalArgDecl
 858:    oNodeSet( decl, qParams, paramScope )
      
 870:    ':'
      
 872:    Node theType
 872:    @TypeRef( theType )
 879:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 891:    Node ptrType = @PointerTypeTo( theType )
 902:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 918:    oScopeEnd
 919:    ';'
      
 921:    [ redeclaring
 924:       | false : oScopeDeclare( decl )
 931:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 933:    ]
      
 941:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 948:    [
 948:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 950:       | pExternal : @ExternalDecl( decl )
      
 959:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 966:          oScopeEnter( paramScope )
      
 972:          oScopeBegin
 973:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 984:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 995:          Label label = oNodeGetLabel( decl, qValue )
1008:          @Block( nLocalVar, label )
1018:          oNodeSetBoolean( decl, qBodyDefined, true )
1030:          oScopeEnd
      
1031:          oScopeEnd  % paramScope
1032:    ]
1032:    ';';
      
      
1035: FormalArgDecl:
1037:    [
1037:       | '(' :
1039:          {
1039:             NodeVec decls = oNodeVecNew
1044:             Node decl
1044:             boolean isInOut = false
      
1050:             [
1050:                | pVar : isInOut = true
1058:                | * :
1063:             ]
      
1063:             {  pIdent
      
1065:                decl = @newIdent( nParam, kVar, LAST_ID )
1081:                oNodeSetBoolean( decl, qInOut, isInOut )
1093:                oNodeVecAppend( decls, decl )
      
1102:                [
1102:                   | ':' : >
1106:                   | ',' :
1108:                ]
1116:             }
      
1118:             Node theType
1118:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1125:             Node allocType
1125:             [ isInOut
1128:                | true :   allocType = @PointerTypeTo( theType )
1140:                | * :      allocType = theType
1151:             ]
      
1151:             int i = 0
1157:             {[ equal( i, oNodeVecSize( decls ) )
1171:                | false :
1172:                   decl = oNodeVecElement( decls, i )
      
1185:                   oNodeSet( decl, qType, theType )
1197:                   oScopeDeclare( decl )
1203:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1219:                   inc( i )
1225:                | * :
1230:                   >
1232:             ]}
      
1234:             oNodeVecDelete( decls )
      
1240:             [
1240:                | ')' : >
1244:                | ';' :
1246:             ]
1254:          }
1256:       | * :
1261:    ];
      
1262: ConstDecl:
1264:    {[
1264:       | pIdent :
1266:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1282:          '='
      
1284:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1286:          int val = oValueTop
1291:          oValuePop
1292:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1304:          oNodeSet( decl, qType, IntegerType )
      
1316:          oScopeDeclare( decl )
1322:          ';'
1324:       | * :
1329:          >
1331:    ]};
      
1334: TypeDecl:
1336:    {[
1336:       | pIdent :
1338:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1354:          '='
1356:          Node theType
1356:          @TypeRef( theType )
1363:          oNodeSet( decl, qType, theType )
1375:          oScopeDeclare( decl )
1381:          ';'
1383:       | * :
1388:          >
1390:    ]};
      
1393: VarDecl( node_type varNodeType ):
1395:    {[
1395:       | pIdent :
1397:          NodeVec decls = oNodeVecNew
1402:          Node decl
1402:          {
1402:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1418:             oNodeVecAppend( decls, decl )
1427:             [
1427:                | ',' :
1429:                   pIdent
1431:                | * :
1436:                   >
1438:             ]
1438:          }
1440:          ':'
1442:          Node theType
1442:          @TypeRef( theType )
      
1449:          int i = 0
1455:          {[ equal( i, oNodeVecSize( decls ) )
1469:            | false :
1470:              decl = oNodeVecElement( decls, i )
1483:              oNodeSet( decl, qType, theType )
1495:              oScopeDeclareAlloc( decl )
1501:              inc( i )
1507:             | * :
1512:               >
1514:          ]}
      
1516:          oNodeVecDelete( decls )
1522:          ';'
1524:       | * :
1529:          >
1531:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1534: TypeRef( out Node resultType ):
1536:    [
1536:       | pIdent :           % previously named type (including intrinsics)
1538:          Node decl = oScopeFindRequire
1543:          [ oNodeType( decl )
1550:            | nTypeDecl :
1551:                resultType = oNodeGet( decl, qType )
1564:            | * :
1569:                #eNotType
1571:                resultType = IntegerType
1577:          ]
         
1577:       | pArray :
1579:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1581:          NodeVec dimensions = oNodeVecNew
      
1586:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1586:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1596:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1608:             @ConstExpr
1610:             oNodeSetInt( subrange, qLow, oValueTop )
1621:             oValuePop
1622:             '..'
1624:             @ConstExpr
1626:             oNodeSetInt( subrange, qHigh, oValueTop )
1637:             oValuePop
1638:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1650:             oTypeAdd( subrange )
      
1656:             Node a = oNodeNew( nArrayType )
1666:             oNodeSet( a, qIndexType, subrange )
      
1678:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1687:             [
1687:                | ']' : >
1691:                | ',' :
1693:             ]
1701:          }
      
1703:          pOf
1705:          Node baseType
1705:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1712:          int dim = oNodeVecSize( dimensions )
      
1722:          {
1722:              dec(dim)
      
1728:              Node a = oNodeVecElement( dimensions, dim )
      
1741:              oNodeSet( a, qBaseType, baseType )
1753:              Node subrange = oNodeGet( a, qIndexType )
1766:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1793:              inc( width )
1799:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1825:              oTypeAdd( a )
1831:              baseType = a
      
1837:              [ equal_zero(dim)
1844:                  | true:  >
1847:                  | *:
1852:              ]
1852:          }
      
1854:          resultType = oNodeVecElement( dimensions, 0 )
1867:          oNodeVecDelete( dimensions )
      
1873:       | '^' :
1875:          Node theType
1875:          @TypeRef( theType )
1882:          resultType = @PointerTypeTo( theType )
      
1893:       | pRecord :
1895:          resultType = oNodeNew( nRecordType )
1905:          oScopeBegin
      
1906:          @VarDecl( nRecordField )
      
1913:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1925:          [ equal_zero( size )
1932:             | true : #eRecordEmpty
1935:             | * :
1940:          ]
      
1940:          pEnd
      
1942:          oNodeSet( resultType, qScope, oScopeCurrent )
1953:          oNodeSetInt( resultType, qSize, size )
1965:          oScopeEnd
1966:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1972:       | pSet :
1974:          pOf
1976:          Node theType
1976:          @TypeRef( theType )
1983:       | * :       % this works for cases except where expr starts with an id
1996:          @ConstExpr '..' @ConstExpr
2002:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2003: ConstExpr:
2005:    [
2005:       | pIntLit :
2007:          oValuePush( TOKEN_VALUE )
2012:       | pIdent :
2014:          Node decl = oScopeFindRequire
2019:          [ oNodeType( decl )
2026:             | nConst :
2027:                oValuePush( oNodeGetInt( decl, qValue ) )
2040:             | * :
2045:                #eNotConst
2047:                oValuePush( 0 )
2053:          ]
2053:       | pMinus :
2055:          @ConstExpr
2057:          oValueNegate
2058:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2069: Expr:
2071:    Label falseLabel = labelNull
      
2077:    @ExprAllowCF( falseLabel )
2084:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2092: BooleanExprControlFlow( out Label falseLabel ):
2094:    @ExprAllowCF( falseLabel )
2101:    [ oTypeSNodeType
2103:       | nBooleanCFType :
2104:       | nBooleanType :
               % convert value to control flow
2106:          falseLabel = oLabelNew
2111:          .tJumpFalse  oEmitLabel( falseLabel )
2119:       | * :
2126:          #eNotBoolean
2128:    ]
2128:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2130: CFToVal( inout Label falseLabel ):
2132:    [ oTypeSNodeType
2134:       | nBooleanCFType :
2135:          Label doneLabel = oLabelNew
2140:          .tPushConstI  oEmitInt( 1 )
2148:          .tJump  oEmitLabel( doneLabel )
2156:          .tLabel  oEmitLabel( falseLabel )
2164:          .tPushConstI  oEmitInt( 0 )
2172:          .tLabel  oEmitLabel( doneLabel )
2180:          oTypeSPop
2181:          oTypeSPush( BooleanType )
2187:          falseLabel = labelNull
2193:       | * :
2198:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2199: ValToCF( out Label falseLabel ):
2201:    [ oTypeSNodeType
2203:       | nBooleanType :
2204:          falseLabel = oLabelNew
2209:          .tJumpFalse  oEmitLabel( falseLabel )
2217:          oTypeSPop
2218:          oTypeSPush( BooleanCFType )
2224:       | * :
2229:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2230: ExprAllowCF( out Label falseLabel ):
2232:    @BoolExprAllowCF( falseLabel )
2239:    {[
2239:       | '=' :
2241:          @CFToVal( falseLabel )
2248:          @BoolExprAllowCF( falseLabel )
2255:          @CFToVal( falseLabel )
2262:          @MatchTypes
2264:          [ oTypeSNodeType
2266:             | nIntegerType, nBooleanType :  .tEqualI
2269:             | nPointerType :                .tEqualP
2273:             | nCharType, nStringType :      #eNotImplemented
2277:             | * :                           #eNotAllowed
2292:          ]
2292:          oTypeSPop
2293:          oTypeSPush( BooleanType )
      
2299:       | '<>' :
2301:          @CFToVal( falseLabel )
2308:          @BoolExprAllowCF( falseLabel )
2315:          @CFToVal( falseLabel )
2322:          @MatchTypes
2324:          [ oTypeSNodeType
2326:             | nIntegerType, nBooleanType :  .tNotEqualI
2329:             | nPointerType :                .tNotEqualP
2333:             | nCharType, nStringType :      #eNotImplemented
2337:             | * :                           #eNotAllowed
2352:          ]
2352:          oTypeSPop
2353:          oTypeSPush( BooleanType )
      
2359:       | '<' :
2361:          @CFToVal( falseLabel )
2368:          @BoolExprAllowCF( falseLabel )
2375:          @CFToVal( falseLabel )
2382:          @MatchTypes
2384:          [ oTypeSNodeType
2386:             | nIntegerType, nBooleanType :  .tLessI
2389:             | nCharType, nStringType :      #eNotImplemented
2393:             | * :                           #eNotAllowed
2406:          ]
2406:          oTypeSPop
2407:          oTypeSPush( BooleanType )
      
2413:       | '>' :
2415:          @CFToVal( falseLabel )
2422:          @BoolExprAllowCF( falseLabel )
2429:          @CFToVal( falseLabel )
2436:          @MatchTypes
2438:          [ oTypeSNodeType
2440:             | nIntegerType, nBooleanType :  .tGreaterI
2443:             | nCharType, nStringType :      #eNotImplemented
2447:             | * :                           #eNotAllowed
2460:          ]
2460:          oTypeSPop
2461:          oTypeSPush( BooleanType )
      
2467:       | '<=' :
2469:          @CFToVal( falseLabel )
2476:          @BoolExprAllowCF( falseLabel )
2483:          @CFToVal( falseLabel )
2490:          @MatchTypes
2492:          [ oTypeSNodeType
2494:             | nIntegerType, nBooleanType :  .tLessEqualI
2497:             | nCharType, nStringType :      #eNotImplemented
2501:             | * :                           #eNotAllowed
2514:          ]
2514:          oTypeSPop
2515:          oTypeSPush( BooleanType )
      
2521:       | '>=' :
2523:          @CFToVal( falseLabel )
2530:          @BoolExprAllowCF( falseLabel )
2537:          @CFToVal( falseLabel )
2544:          @MatchTypes
2546:          [ oTypeSNodeType
2548:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2551:             | nCharType, nStringType :      #eNotImplemented
2555:             | * :                           #eNotAllowed
2568:          ]
2568:          oTypeSPop
2569:          oTypeSPush( BooleanType )
      
2575:       | * :
2590:          >
2592:    ]};
      
      
2595: BoolExprAllowCF( out Label falseLabel ):
2597:    Label trueLabel = labelNull
      
2603:    @BoolTermAllowCF( falseLabel )
2610:    {[
2610:       | pOr :
2612:          [ oTypeSNodeType
2614:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2615:                [ equal_label( trueLabel, labelNull )
2625:                   | true :  trueLabel = oLabelNew
2631:                   | * :
2636:                ]
2636:                .tJump  oEmitLabel( trueLabel )
2644:             | nBooleanType :
2646:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2653:                [ equal_label( trueLabel, labelNull )
2663:                   | true :  trueLabel = oLabelNew
2669:                   | * :
2674:                ]
2674:                .tJump  oEmitLabel( trueLabel )
2682:             | * : #eNotBoolean
2691:          ]
2691:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2692:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2700:          falseLabel = labelNull
2706:          @BoolTermAllowCF( falseLabel )
      
2713:          [ oTypeSNodeType
2715:             | nBooleanCFType :
2716:             | nBooleanType :
2718:                @ValToCF( falseLabel )
2725:             | * : #eNotBoolean
2734:          ]
      
2734:          oTypeSPop
2735:          oTypeSPush( BooleanCFType )
      
2741:       | * :
2746:          >
2748:    ]}
      
         % any short-circuit trues jump here to the end
2750:    [ equal_label( trueLabel, labelNull )
2760:       | false :
2761:          .tLabel  oEmitLabel( trueLabel )
2769:       | * :
2774:    ]
2775:    ;
      
      
2775: BoolTermAllowCF( out Label falseLabel ):
2777:    Label overallFalseLabel = labelNull
      
2783:    @BoolFactorAllowCF( falseLabel )
2790:    {[
2790:       | pAnd :
2792:          [ oTypeSNodeType
2794:             | nBooleanCFType :
2795:             | nBooleanType :
2797:                @ValToCF( falseLabel )
2804:             | * :
2811:                #eNotBoolean
2813:          ]
2813:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2814:          [ equal_label( overallFalseLabel, labelNull )
2824:             | true :
2825:                overallFalseLabel = oLabelNew
2830:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2844:                falseLabel = overallFalseLabel
2850:             | * :
2855:          ]
      
2855:          Label factorFalseLabel = labelNull
2861:          @BoolFactorAllowCF( factorFalseLabel )
      
2868:          [ oTypeSNodeType
2870:             | nBooleanCFType :
2871:             | nBooleanType :
2873:                @ValToCF( factorFalseLabel )
2880:             | * : #eNotBoolean
2889:          ]
2889:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2903:       | * :
2908:          >
2910:    ]};
      
2913: BoolFactorAllowCF( out Label falseLabel ):
2915:    [
2915:       | pNot :
2917:          Label factorFalseLabel = labelNull
      
2923:          @BoolFactorAllowCF( factorFalseLabel )
2930:          [ oTypeSNodeType
2932:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2933:                falseLabel = oLabelNew
2938:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2946:                .tLabel  oEmitLabel( factorFalseLabel )
      
2954:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2956:                .tNot
      
2958:             | * : #eNotBoolean
2967:          ]
      
2967:       | * :
2972:          @ArithExprAllowCF( falseLabel )
2979:    ];
      
2980: ArithExprAllowCF( out Label falseLabel ):
2982:    @TermAllowCF( falseLabel )
2989:    {[
2989:       | pPlus :
2991:          @RequireIntPop
2993:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3000:          @RequireInt
3002:          .tAddI
3004:       | pMinus :
3006:          @RequireIntPop
3008:          @TermAllowCF( falseLabel )
3015:          @RequireInt
3017:          .tSubI
3019:       | * :
3026:          >
3028:    ]};
      
3031: TermAllowCF( out Label falseLabel ):
3033:    @FactorAllowCF( falseLabel )
3040:    {[
3040:       | pTimes :
3042:          @RequireIntPop
3044:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3051:          @RequireInt
3053:          .tMultI
3055:       | pDivide :
3057:          @RequireIntPop
3059:          @FactorAllowCF( falseLabel )
3066:          @RequireInt
3068:          .tDivI
3070:       | * :
3077:          >
3079:    ]};
      
3082: FactorAllowCF( out Label falseLabel ):
3084:    [
3084:       | pPlus :
3086:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3093:          @RequireInt
3095:       | pMinus :
3097:          @PrimaryAllowCF( falseLabel )
3104:          @RequireInt
3106:          .tNegI
3108:       | * :
3115:          @PrimaryAllowCF( falseLabel )
3122:    ];
      
3123: PrimaryAllowCF( out Label falseLabel ):
3125:    [
3125:       | pIntLit :
3127:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3134:          oTypeSPush( IntegerType )
      
3140:       | '(' :
3142:          @ExprAllowCF( falseLabel )
3149:          ')'
      
3151:       | pStrLit :
3153:          int addr = oStringAllocLit     % store in global data
3158:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3166:          oTypeSPush( StringType )
      
3172:       | pIdent :
3174:          Node decl = oScopeFindRequire
3179:          Node theType
      
3179:          [ oNodeType( decl )
3186:             | nFunc :
      
3187:                @Call( decl )
      
3194:             | nConst :
3196:                theType = oNodeGet( decl, qType )
3209:                oTypeSPush( theType )
3215:                [ oTypeSNodeType
3217:                   | nIntegerType, nBooleanType :
3218:                      .tPushConstI @EmitValue( decl )
3227:                   | * :
3234:                      #eNotImplemented
3236:                ]
      
3236:             | nGlobalVar, nLocalVar, nParam :
3238:                @VarExpr( decl )
      
3245:             | * :
3258:                #eNotValue
3260:                oTypeSPush( IntegerType )
3266:          ]
      
3266:       | '@' :        % @var -- pointer to var
3268:          pIdent
      
3270:          Node decl = oScopeFindRequire
3275:          Node theType
      
3275:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3282:          theType = oTypeSTop
3287:          oTypeSPop
3288:          Node ptrType = @PointerTypeTo( theType )
3299:          oTypeSPush( ptrType )
      
3305:       | * :
3318:          #eNotValue
3320:          oTypeSPush( IntegerType )
3326:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3327: VarExpr( Node decl ):
3329:    Node theType = oNodeGet( decl, qType )
3342:    oTypeSPush( theType )
3348:    [ oTypeSNodeType
3350:       | nIntegerType :
3351:          [ oNodeType( decl )
3358:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3368:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3379:             | nParam :
3381:                [ oNodeGetBoolean( decl, qInOut )
3391:                   | true :    % VAR param points to the var.  Auto dereference.
3392:                               .tPushParamP @EmitValue( decl )
3401:                               .tFetchI
3403:                   | * :       .tPushParamI @EmitValue( decl )
3417:                ]
3417:          ]
      
3427:       | nBooleanType :
3429:          [ oNodeType( decl )
3436:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3446:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3457:             | nParam :
3459:                [ oNodeGetBoolean( decl, qInOut )
3469:                   | true :    % VAR param points to the var.  Auto derefernce.
3470:                               .tPushParamP @EmitValue( decl )
3479:                               .tFetchB
3481:                   | * :       .tPushParamB @EmitValue( decl )
3495:                ]
3495:          ]
      
3505:       | nCharType, nStringType, nFileType :
3507:          #eNotImplemented
      
3509:       | nPointerType :
3511:          [ oNodeType( decl )
3518:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3528:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3539:             | nParam :
3541:                [ oNodeGetBoolean( decl, qInOut )
3551:                   | true :    % VAR param points to the var.  Auto derefernce.
3552:                               .tPushParamP @EmitValue( decl )
3561:                               .tFetchP
3563:                   | * :       .tPushParamP @EmitValue( decl )
3577:                ]
3577:          ]
3587:          [
3587:             | '^' :             % dereferenced
3589:                oTypeSPop
3590:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3603:                @LValueIndexes
3605:                @FetchVar
3607:             | * :               % just ptr value alone
3612:          ]
      
3612:       | * :
               % compound type
               % first, push addr of start of var
3627:          [ oNodeType( decl )
3634:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3644:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3655:             | nParam :
3657:                [ oNodeGetBoolean( decl, qInOut )
3667:                   | true :    % VAR param points to the var.  Auto derefernce.
3668:                               .tPushParamP @EmitValue( decl )
3677:                   | * :       .tPushAddrParam @EmitValue( decl )
3691:                ]
3691:          ]
               % modify addr for subscripts, field references, etc
3701:          @LValueIndexes
               % get final value
3703:          @FetchVar
3705:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3706: FetchVar:
3708:    [ oTypeSNodeType
3710:       | nIntegerType :   .tFetchI
3713:       | nBooleanType :   .tFetchB
3717:       | nCharType, nStringType, nFileType : #eNotImplemented
3721:       | nPointerType :   .tFetchP
3725:       | * :              % compound type; leave as addr
3740:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3741: LValueIndexes:
3743:    {[
3743:       | '[' :       @ArraySubscripts
3747:       | '.' :       @RecordFieldRef
3751:       | '^' :       @PointerDeref
3755:       | * :         >
3766:    ]};
      
3769: ArraySubscripts:
3771:    [ oTypeSNodeType
3773:       | nArrayType :
3774:       | * :       #eNotArray
3781:    ]
3781:    {
3781:       [ oTypeSNodeType
3783:          | nArrayType :
3784:          | * :    #eTooManySubscripts
3791:       ]
      
            % low subscript of this dimension
3791:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3808:       Node baseType
3808:       baseType = oNodeGet( oTypeSTop, qBaseType )
3820:       oTypeSPop
3821:       oTypeSPush( baseType )
      
3827:       @Expr
3829:       @RequireIntPop
            % adjust for low subscript
3831:       [ equal_zero( low )
3838:          | false :
3839:             .tPushConstI oEmitInt( low ) .tSubI
3849:          | * :
3854:       ]
      
            % multiply by element size
3854:       int size = oNodeGetInt( baseType, qSize )
3867:       [ equal( size, 1 )
3877:          | false :
3878:             .tPushConstI oEmitInt( size ) .tMultI
3888:          | * :
3893:       ]
      
            % update start address
3893:       .tAddPI
3895:       [
3895:          | ']' :  >
3899:          | ',' :
3901:       ]
3909:    };
      
      
3912: RecordFieldRef:
3914:    [ oTypeSNodeType
3916:       | nRecordType :
3917:       | * :    #eNotRecord
3924:    ]
3924:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3936:    pIdent
3938:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3943:    [ oNodeType( field )
3950:       | nRecordField :
3951:       | * :   #eNotRecordField
3958:    ]
3958:    oScopeEnd
3959:    int offset = oNodeGetInt( field, qValue )
3972:    [ equal_zero( offset )
3979:       | false :
3980:          .tPushConstI oEmitInt( offset ) .tAddPI
3990:       | * :
3995:    ]
      
         % replace the type on the type stack, with the field type
3995:    oTypeSPop
3996:    oTypeSPush( oNodeGet( field, qType ) )
4010:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4010: PointerDeref:
4012:    [ oTypeSNodeType
4014:       | nPointerType :
4015:       | * :       #eNotPointer
4022:    ]
4022:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4024:    Node theType = oTypeSTop
4029:    oTypeSPop
4030:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4044:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4044: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4046:    @MatchTypes
4049:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4049: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4051:    [ oNodeGetBoolean( method, qExternal )
4061:       | true :
4062:          [ oNodeGetBoolean( method, qCalled )
4072:             | false :
                     % define the label as extern
4073:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4090:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4105:             | * :
4110:          ]
4110:      | * :
4115:    ]
4115:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4127:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4140:    Node resultType
4140:    int tempOffset
      
4140:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4157:    [ isFunc
4160:       | true :
4161:          resultType = oNodeGet( method, qType )
4174:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4184:       | * :
4189:    ]
         
      
4189:    Node paramScope = oNodeGet( method, qParams )
4202:    int actualsSize = oNodeGetInt( paramScope, qSize )
4215:    [ cdecl
4218:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4227:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4237:    ]
      
4245:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4258:    Node param = oNodeIterValue( paramIter )
4268:    [
4268:       | '(' :
            
4270:          {
4270:             [ oNodeNull( param )
4277:                | true : >
4280:                | * :
4285:             ]
      
4285:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4298:             .tPushAddrActual oEmitInt( offset )
4306:             oTypeSPush( oNodeGet( param, qType ) )
      
4319:             [ oNodeGetBoolean( param, qInOut )
4329:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4330:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4332:                           @MatchTypes
      
4334:                           .tAssignP
      
4336:                | false :  @Expr
4340:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4342:                           [ oTypeSNodeType
4344:                              | nIntegerType :            .tAssignI
4347:                              | nBooleanType :            .tAssignB
4351:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4355:                              | nPointerType :            .tAssignP
4359:                              | * :
                                       % compound types: copy value into actuals space
4374:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4386:                                  .tCopy  oEmitInt( size )    % multi-word copy
4394:                           ]
4394:             ]
4402:             oTypeSPop
      
4403:             oNodeIterNext( paramIter )
4409:             param = oNodeIterValue( paramIter )
4419:             [ oNodeNull( param )
4426:                | true :  >
4429:                | false :
4431:             ]
      
4439:             ','
4441:          }
      
4443:          ')'
      
4445:       | * :
4450:    ]
      
4450:    [ oNodeNull( param )
4457:       | false :    #eMissingParameter
4460:       | * :
4465:    ]
      
4465:    [ isFunc
4468:       | true :
               % Pass result temp as an additional VAR parameter.
4469:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4484:          .tPushAddrLocal  oEmitInt( tempOffset )
4492:          .tAssignP
4494:       | * :
4499:    ]
      
4499:    [ cdecl
4502:       | true :
4503:          .tCallCdecl  @EmitValue( method )
4512:       | false :
4514:          .tCall   @EmitValue( method )
4523:    ]
      
4531:    [ isFunc
4534:       | true :
               % push return value from temp
4535:          oTypeSPush( resultType )
      
4541:          [ oTypeSNodeType
4543:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4552:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4562:             | nCharType, nStringType, nFileType : #eNotImplemented
4566:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4576:             | * :              % compound type: push address
4591:                                .tPushAddrLocal  oEmitInt( tempOffset )
4599:          ]
4599:       | * :
4604:    ]
         
4604:    .tFreeActuals  oEmitInt( actualsSize )
4613:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4613: Statement:
4615:    [
4615:       | pWriteln :     @WritelnStmt
4619:       | pWrite :       @WriteStmt
4623:       | pReadln :      @ReadlnStmt
4627:       | pRead :        @ReadStmt
4631:       | pIf :          @IfStmt
4635:       | pWhile :       @WhileStmt
4639:       | pFor :         @ForStmt
4643:       | pRepeat :      @RepeatStmt
4647:       | pBreak :       @BreakStmt
4651:       | pContinue :    @ContinueStmt
4655:       | pBegin :       @BeginStmt
4659:       | pIdent :       @AssignOrCallStmt
4663:       | * :            % null statement : don't accept any tokens
4690:    ];
      
      
4691: AssignOrCallStmt:
4693:    Node decl = oScopeFindRequire
4698:    [ oNodeType( decl )
4705:       | nProc :                           @Call( decl )
4713:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4722:       | nFunc :                           @AssignResultStmt( decl )
4731:       | * :                               #eBadStatement
4746:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4747: AssignStmt( Node decl ):
      
4749:    @LValueVar( decl )
      
4756:    ':=' 
4758:    @Expr
4760:    @MatchTypes
4762:    [ oTypeSNodeType
4764:       | nIntegerType :            .tAssignI
4767:       | nBooleanType :            .tAssignB
4771:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4775:       | nPointerType :            .tAssignP
4779:       | * :
4794:           int size = oNodeGetInt( oTypeSTop, qSize )
4806:           .tCopy  oEmitInt( size )    % multi-word copy
4814:    ]
4814:    oTypeSPop
4816:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4816: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4818:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4834:       | false :   #eNotCurrentFunction
4837:       | * :
4842:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4842:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4857:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4870:    ':='
4872:    @Expr
4874:    @MatchTypes
4876:    [ oTypeSNodeType
4878:       | nIntegerType :            .tAssignI
4881:       | nBooleanType :            .tAssignB
4885:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4889:       | nPointerType :            .tAssignP
4893:       | * :
4908:           int size = oNodeGetInt( oTypeSTop, qSize )
4920:           .tCopy  oEmitInt( size )    % multi-word copy
4928:    ]
4928:    oTypeSPop
4930:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4930: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4932:    pIdent
4934:    Node decl = oScopeFindRequire
4939:    [ oNodeType( decl )
4946:       | nGlobalVar, nLocalVar, nParam :
4947:       | * :  #eNotVar
4958:    ]
4958:    @LValueVar( decl )
4966:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4966: LValueVar( Node decl ):
4968:    [ oNodeType( decl )
4975:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4985:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4996:       | nParam :
4998:          [ oNodeGetBoolean( decl, qInOut )
5008:             | true :   % VAR param points to variable.  No dereference.
5009:                        .tPushParamP @EmitValue( decl )
5018:             | * :      .tPushAddrParam @EmitValue( decl )
5032:          ]
5032:       | * :            #eNotVar
5043:    ]
      
5043:    oTypeSPush( oNodeGet( decl, qType ) )
5056:    @LValueIndexes        % handle subscripts, if any
5059:    ;
      
      
5059: IncVar( Node decl ):
5061:    @LValueVar( decl )
5068:    @RequireIntPop
5070:    @VarExpr( decl )
5077:    oTypeSPop
5078:    .tIncI
5080:    .tAssignI;
      
5083: DecVar( Node decl ):
5085:    @LValueVar( decl )
5092:    @RequireIntPop
5094:    @VarExpr( decl )
5101:    oTypeSPop
5102:    .tDecI
5104:    .tAssignI;
      
      
5107: IfStmt:
5109:    Label falseLabel = labelNull
      
5115:    @BooleanExprControlFlow( falseLabel )
5122:    pThen
5124:    @Statement
5126:    [
5126:       | pElse :
5128:          Label doneLabel = oLabelNew
      
5133:          .tJump  oEmitLabel( doneLabel )
5141:          .tLabel oEmitLabel( falseLabel )
5149:          @Statement
5151:          .tLabel oEmitLabel( doneLabel )
      
5159:       | * :
5164:          .tLabel oEmitLabel( falseLabel )
5172:    ];
      
      
5173: ForStmt:
5175:    pIdent
      
5177:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5182:    @LValueVar( decl )
5189:    @RequireIntPop
      
5191:    ':='
      
5193:    @Expr
5195:    @RequireIntPop
5197:    .tAssignI
      
5199:    Label breakLabel = oLabelNew
      
5204:    Label checkLabel = oLabelNew
5209:    .tJump  oEmitLabel( checkLabel )
      
5217:    Label continueLabel = oLabelNew
5222:    .tLabel  oEmitLabel( continueLabel )
5230:    [
5230:       | pTo :
5232:          @IncVar( decl )
5239:          .tLabel  oEmitLabel( checkLabel )
5247:          @VarExpr( decl )  oTypeSPop
5255:          @Expr
5257:          @RequireIntPop
5259:          .tGreaterI
5261:          .tJumpTrue  oEmitLabel( breakLabel )
5269:       | pDownto :
5271:          @DecVar( decl )
5278:          .tLabel  oEmitLabel( checkLabel )
5286:          @VarExpr( decl )  oTypeSPop
5294:          @Expr
5296:          @RequireIntPop
5298:          .tLessI
5300:          .tJumpTrue  oEmitLabel( breakLabel )
5308:    ]
5316:    oLoopPush( continueLabel, breakLabel )
5325:    pDo
5327:    @Statement
5329:    .tJump  oEmitLabel( continueLabel )
5337:    .tLabel  oEmitLabel( breakLabel )
5345:    oLoopPop;
      
      
5347: RepeatStmt:
5349:    Label continueLabel = oLabelNew
5354:    .tLabel  oEmitLabel( continueLabel )
      
5362:    Label breakLabel = oLabelNew
      
5367:    oLoopPush( continueLabel, breakLabel )
5376:    @Statement
5378:    {[
5378:       | ';' :
5380:          @Statement
5382:       | pUntil :
5384:          Label falseLabel
5384:          @BooleanExprControlFlow( falseLabel )
5391:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5405:          >
5407:    ]}
5417:    .tLabel  oEmitLabel( breakLabel )
5425:    oLoopPop;
      
      
5427: WhileStmt:
5429:    Label continueLabel = oLabelNew
5434:    .tLabel  oEmitLabel( continueLabel )
      
5442:    Label breakLabel
5442:    @BooleanExprControlFlow( breakLabel )
      
5449:    oLoopPush( continueLabel, breakLabel )
5458:    pDo
5460:    @Statement
5462:    .tJump  oEmitLabel( continueLabel )
5470:    .tLabel  oEmitLabel( breakLabel )
5478:    oLoopPop;
      
      
5480: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5482:    [ equal_label( oLoopContinueLabel, labelNull )
5491:       | true :
5492:          #eNotInALoop
5494:       | false :
5496:          .tJump  oEmitLabel( oLoopContinueLabel )
5503:    ];
      
      
5512: BreakStmt:
5514:    [ equal_label( oLoopBreakLabel, labelNull )
5523:       | true :
5524:          #eNotInALoop
5526:       | false :
5528:          .tJump  oEmitLabel( oLoopBreakLabel )
5535:    ];
      
      
5544: BeginStmt:
5546:    @Statement
5548:    {[
5548:       | ';' :   @Statement
5552:       | pEnd :  >
5556:    ]};
      
      
5567: WritelnStmt:
5569:    @WriteStmt
5571:    .tWriteCR;
      
      
5574: WriteStmt:
5576:    [
5576:       | '(' :
5578:          {
5578:             @Expr
5580:             [ oTypeSNodeType
5582:                | nIntegerType :             .tWriteI
5585:                | nBooleanType :             .tWriteBool
5589:                | nStringType :              .tWriteStr
5593:                | nCharType, nFileType :     #eNotImplemented
5597:                | nPointerType :             .tWriteP
5601:                | * :                        #eNotAllowed
5618:             ]
5618:             oTypeSPop
5619:             [
5619:                | ')' : >
5623:                | ',' :
5625:             ]
5633:          }
5635:       | * :
5640:    ];
      
      
5641: ReadlnStmt:      % ***
         % TO DO
5644:    ;
      
5644: ReadStmt:
         % TO DO
5647:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5647: MatchTypes:
5649:    node_type nt = oTypeSNodeType
5654:    oTypeSPop
5655:    [ equal_node_type( nt, oTypeSNodeType )
5664:       | false :
5665:          #eTypeMismatch
5667:       | * :
5672:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5673: RequireIntPop:
5675:    [ oTypeSNodeType
5677:       | nIntegerType :
5678:       | * :          #eNotInteger
5685:    ]
5685:    oTypeSPop;
      
5687: RequireInt:
5689:    [ oTypeSNodeType
5691:       | nIntegerType :
5692:       | * :          #eNotInteger
5699:    ];
      
5700: RequireBoolPop:
5702:    [ oTypeSNodeType
5704:       | nBooleanType :
5705:       | * :          #eNotBoolean
5712:    ]
5712:    oTypeSPop;
      
5714: RequireBool:
5716:    [ oTypeSNodeType
5718:       | nBooleanType :
5719:       | * :          #eNotBoolean
5726:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5727: newType( node_type nt, int size ) >> Node:
5729:   Node node = oNodeNew( nt )
5739:   oNodeSetInt( node, qSize, size )
5751:   oTypeAdd( node )
5757:   >> node
5761:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5761: newIdent( node_type nt, kind k, int id ) >> Node:
5763:   Node t = oNodeNew( nt )
5773:   oNodeSetInt( t, qIdent, id )
5785:   >> t
5789:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5789: PointerTypeTo( Node theType ) >> Node:
5791:    Node ptrType = oNodeGet( theType, qPointerType )
5804:    [ oNodeNull( ptrType )
5811:       | true :
5812:          ptrType = oNodeNew( nPointerType )
5822:          oNodeSet( ptrType, qBaseType, theType )
5834:          oNodeSetInt( ptrType, qSize, 8 )
5846:          oTypeAdd( ptrType )
5852:          oNodeSet( theType, qPointerType, ptrType )
5864:       | * :
5869:    ]
5869:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5873: OrdinalLow( Node theType ) >> int:
5875:    [ oNodeType( theType )
5882:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5885:       | nBooleanType :  >> 0
5890:       | nCharType :     >> 0
5895:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5907:       | * :             #eNotOrdinalType
5920:                         >> 0
5923:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5924: EmitValue( Node decl ):
5926:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5940: installBuiltIns:
      
         % install built-in types
5942:    FileType = @newType( nFileType, 4 )
5956:    IntegerType = @newType( nIntegerType, 4 )
5970:    BooleanType = @newType( nBooleanType, 1 )
5984:    BooleanCFType = @newType( nBooleanCFType, 1 )
5998:    CharType = @newType( nCharType, 1 )
6012:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6026:    Node t
      
6026:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6042:    oNodeSet( t, qType, FileType )
6054:    oScopeDeclare( t )
      
6060:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6076:    oNodeSet( t, qType, IntegerType )
6088:    oScopeDeclare( t )
      
6094:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6110:    oNodeSet( t, qType, BooleanType )
6122:    oScopeDeclare( t )
      
6128:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6144:    oNodeSet( t, qType, CharType )
6156:    oScopeDeclare( t )
      
6162:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6178:    oNodeSet( t, qType, StringType )
6190:    oScopeDeclare( t )
      
         % Built-in constants
      
6196:    t = @newIdent( nConst, kConst, oIdAdd_True )
6212:    oNodeSet( t, qType, BooleanType )
6224:    oNodeSetInt( t, qValue, 1 )
6236:    oScopeDeclare( t )
      
6242:    t = @newIdent( nConst, kConst, oIdAdd_False )
6258:    oNodeSet( t, qType, BooleanType )
6270:    oNodeSetInt( t, qValue, 0 )
6282:    oScopeDeclare( t )
      
6289:    ;
      
6289: end
      
6289: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5940
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5761
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5761
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 6
 102: oPushResult
 103: oGetGlobal 2
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5761
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 6
 140: oPushResult
 141: oGetGlobal 2
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oSetResult 12
 164: oPushResult
 165: oCall 221
 167: oPop 1
 169: oScopeBegin
 170: oScopeCurrent
 171: oPushResult
 172: oSetResult 3
 174: oPushResult
 175: oSetResult 1
 177: oPushResult
 178: oNodeSetBoolean
 179: oPop 3
 181: oGetLocal 3
 183: oPushResult
 184: oSetResult 8
 186: oPushResult
 187: oScopeCurrent
 188: oPushResult
 189: oNodeSet
 190: oPop 3
 192: oGetLocal 2
 194: oPushResult
 195: oCall 271
 197: oPop 1
 199: oScopeEnd
 200: oInput 19
 202: oScopeEnd
 203: oReturn
 204: oLocalSpace 0
 206: oGetParam 2
 208: oPushResult
 209: oCall 221
 211: oPop 1
 213: oGetParam 1
 215: oPushResult
 216: oCall 271
 218: oPop 1
 220: oReturn
 221: oLocalSpace 0
 223: oInputChoice 250
 225: oCall 1262
 227: oJumpForward 263
 229: oCall 1334
 231: oJumpForward 263
 233: oGetParam 1
 235: oPushResult
 236: oCall 1393
 238: oPop 1
 240: oJumpForward 263
 242: oCall 404
 244: oJumpForward 263
 246: oCall 689
 248: oJumpForward 263
 250: Choice Lookup Table
          29    246
          28    242
          32    233
          31    229
          30    225
 261: oJumpForward 265
 263: oJumpBack 223
 265: oCall 268
 267: oReturn
 268: oLocalSpace 0
 270: oReturn
 271: oLocalSpace 3
 273: oEmit 48
 275: oGetParam 1
 277: oPushResult
 278: oEmitLabel
 279: oPop 1
 281: oEmit 44
 283: oGetAddrLocal 1
 285: oPushResult
 286: Here
 287: oAssign
 288: oEmit 56
 290: oGetAddrLocal 2
 292: oPushResult
 293: oScopeCurrent
 294: oPushResult
 295: oSetResult 4
 297: oPushResult
 298: oNodeGetCode
 299: oPop 2
 301: oAssign
 302: oGetLocal 2
 304: oPushResult
 305: oEmitCode
 306: oPop 1
 308: oScopeCurrent
 309: oPushResult
 310: oSetResult 4
 312: oPushResult
 313: oSetResult 0
 315: oPushResult
 316: oNodeSetCode
 317: oPop 3
 319: oCall 4613
 321: oEmit 43
 323: oGetAddrLocal 3
 325: oPushResult
 326: oScopeCurrent
 327: oPushResult
 328: oSetResult 2
 330: oPushResult
 331: oNodeGetInt
 332: oPop 2
 334: oAssign
 335: oGetLocal 1
 337: oPushResult
 338: oGetLocal 3
 340: oPushResult
 341: oPatch
 342: oPop 2
 344: oReturn
 345: oLocalSpace 0
 347: oInputChoice 365
 349: oGetParam 1
 351: oPushResult
 352: oSetResult 13
 354: oPushResult
 355: oSetResult 1
 357: oPushResult
 358: oNodeSetBoolean
 359: oPop 3
 361: oInput 4
 363: oJumpForward 370
 365: Choice Lookup Table
          61    349
 368: oJumpForward 372
 370: oJumpBack 347
 372: oReturn
 373: oLocalSpace 0
 375: oGetParam 1
 377: oPushResult
 378: oSetResult 12
 380: oPushResult
 381: oSetResult 1
 383: oPushResult
 384: oNodeSetBoolean
 385: oPop 3
 387: oInputChoice 400
 389: oInputChoice 395
 391: oInput 2
 393: oJumpForward 398
 395: Choice Lookup Table
          60    391
 398: oJumpForward 403
 400: Choice Lookup Table
           2    389
 403: oReturn
 404: oLocalSpace 4
 406: oInput 0
 408: oGetAddrLocal 1
 410: oPushResult
 411: oSetResult 0
 413: oAssign
 414: oGetAddrLocal 2
 416: oPushResult
 417: oScopeFindInCurrentScope
 418: oAssign
 419: oGetLocal 2
 421: oPushResult
 422: oNodeNull
 423: oPop 1
 425: oChoice 546
 427: oGetAddrLocal 2
 429: oPushResult
 430: oSetResult 7
 432: oPushResult
 433: oSetResult 2
 435: oPushResult
 436: LAST_ID
 437: oPushResult
 438: oCall 5761
 440: oPop 3
 442: oAssign
 443: oGetLocal 2
 445: oPushResult
 446: oSetResult 7
 448: oPushResult
 449: oLabelNew
 450: oPushResult
 451: oNodeSetLabel
 452: oPop 3
 454: oJumpForward 552
 456: oGetAddrLocal 1
 458: oPushResult
 459: oSetResult 1
 461: oAssign
 462: oGetLocal 2
 464: oPushResult
 465: oSetResult 11
 467: oPushResult
 468: oNodeGetBoolean
 469: oPop 2
 471: oChoice 477
 473: oError 21
 475: oJumpForward 480
 477: Choice Lookup Table
           1    473
 480: oGetLocal 2
 482: oPushResult
 483: oSetResult 12
 485: oPushResult
 486: oNodeGetBoolean
 487: oPop 2
 489: oChoice 495
 491: oError 21
 493: oJumpForward 498
 495: Choice Lookup Table
           1    491
 498: oGetLocal 2
 500: oPushResult
 501: oNodeType
 502: oPop 1
 504: oChoice 508
 506: oJumpForward 513
 508: Choice Lookup Table
           7    506
 511: oError 21
 513: oGetLocal 2
 515: oPushResult
 516: oSetResult 15
 518: oPushResult
 519: oGetLocal 2
 521: oPushResult
 522: oSetResult 9
 524: oPushResult
 525: oNodeGet
 526: oPop 2
 528: oPushResult
 529: oNodeSet
 530: oPop 3
 532: oGetLocal 2
 534: oPushResult
 535: oSetResult 9
 537: oPushResult
 538: oSetResult 0
 540: oPushResult
 541: oNodeSet
 542: oPop 3
 544: oJumpForward 552
 546: Choice Lookup Table
           0    456
           1    427
 551: oEndChoice
 552: oScopeBegin
 553: oGetAddrLocal 3
 555: oPushResult
 556: oScopeCurrent
 557: oAssign
 558: oCall 1035
 560: oGetLocal 2
 562: oPushResult
 563: oSetResult 9
 565: oPushResult
 566: oGetLocal 3
 568: oPushResult
 569: oNodeSet
 570: oPop 3
 572: oScopeEnd
 573: oInput 4
 575: oGetLocal 1
 577: oChoice 589
 579: oGetLocal 2
 581: oPushResult
 582: oScopeDeclare
 583: oPop 1
 585: oJumpForward 595
 587: oJumpForward 595
 589: Choice Lookup Table
           1    587
           0    579
 594: oEndChoice
 595: oGetLocal 2
 597: oPushResult
 598: oCall 345
 600: oPop 1
 602: oInputChoice 615
 604: oJumpForward 686
 606: oGetLocal 2
 608: oPushResult
 609: oCall 373
 611: oPop 1
 613: oJumpForward 686
 615: Choice Lookup Table
          59    606
          58    604
 620: oGetLocal 3
 622: oPushResult
 623: oScopeEnter
 624: oPop 1
 626: oScopeBegin
 627: oScopeCurrent
 628: oPushResult
 629: oSetResult 3
 631: oPushResult
 632: oSetResult 1
 634: oPushResult
 635: oNodeSetBoolean
 636: oPop 3
 638: oGetLocal 2
 640: oPushResult
 641: oSetResult 10
 643: oPushResult
 644: oScopeCurrent
 645: oPushResult
 646: oNodeSet
 647: oPop 3
 649: oGetAddrLocal 4
 651: oPushResult
 652: oGetLocal 2
 654: oPushResult
 655: oSetResult 7
 657: oPushResult
 658: oNodeGetLabel
 659: oPop 2
 661: oAssign
 662: oSetResult 13
 664: oPushResult
 665: oGetLocal 4
 667: oPushResult
 668: oCall 204
 670: oPop 2
 672: oGetLocal 2
 674: oPushResult
 675: oSetResult 11
 677: oPushResult
 678: oSetResult 1
 680: oPushResult
 681: oNodeSetBoolean
 682: oPop 3
 684: oScopeEnd
 685: oScopeEnd
 686: oInput 4
 688: oReturn
 689: oLocalSpace 6
 691: oInput 0
 693: oGetAddrLocal 1
 695: oPushResult
 696: oSetResult 0
 698: oAssign
 699: oGetAddrLocal 2
 701: oPushResult
 702: oScopeFindInCurrentScope
 703: oAssign
 704: oGetLocal 2
 706: oPushResult
 707: oNodeNull
 708: oPop 1
 710: oChoice 844
 712: oGetAddrLocal 2
 714: oPushResult
 715: oSetResult 8
 717: oPushResult
 718: oSetResult 3
 720: oPushResult
 721: LAST_ID
 722: oPushResult
 723: oCall 5761
 725: oPop 3
 727: oAssign
 728: oGetLocal 2
 730: oPushResult
 731: oSetResult 7
 733: oPushResult
 734: oLabelNew
 735: oPushResult
 736: oNodeSetLabel
 737: oPop 3
 739: oJumpForward 850
 741: oGetAddrLocal 1
 743: oPushResult
 744: oSetResult 1
 746: oAssign
 747: oGetLocal 2
 749: oPushResult
 750: oSetResult 11
 752: oPushResult
 753: oNodeGetBoolean
 754: oPop 2
 756: oChoice 762
 758: oError 21
 760: oJumpForward 765
 762: Choice Lookup Table
           1    758
 765: oGetLocal 2
 767: oPushResult
 768: oNodeType
 769: oPop 1
 771: oChoice 775
 773: oJumpForward 780
 775: Choice Lookup Table
           8    773
 778: oError 21
 780: oGetLocal 2
 782: oPushResult
 783: oSetResult 15
 785: oPushResult
 786: oGetLocal 2
 788: oPushResult
 789: oSetResult 9
 791: oPushResult
 792: oNodeGet
 793: oPop 2
 795: oPushResult
 796: oNodeSet
 797: oPop 3
 799: oGetLocal 2
 801: oPushResult
 802: oSetResult 9
 804: oPushResult
 805: oSetResult 0
 807: oPushResult
 808: oNodeSet
 809: oPop 3
 811: oGetLocal 2
 813: oPushResult
 814: oSetResult 16
 816: oPushResult
 817: oGetLocal 2
 819: oPushResult
 820: oSetResult 6
 822: oPushResult
 823: oNodeGet
 824: oPop 2
 826: oPushResult
 827: oNodeSet
 828: oPop 3
 830: oGetLocal 2
 832: oPushResult
 833: oSetResult 6
 835: oPushResult
 836: oSetResult 0
 838: oPushResult
 839: oNodeSet
 840: oPop 3
 842: oJumpForward 850
 844: Choice Lookup Table
           0    741
           1    712
 849: oEndChoice
 850: oScopeBegin
 851: oGetAddrLocal 3
 853: oPushResult
 854: oScopeCurrent
 855: oAssign
 856: oCall 1035
 858: oGetLocal 2
 860: oPushResult
 861: oSetResult 9
 863: oPushResult
 864: oGetLocal 3
 866: oPushResult
 867: oNodeSet
 868: oPop 3
 870: oInput 11
 872: oGetAddrLocal 4
 874: oPushResult
 875: oCall 1534
 877: oPop 1
 879: oGetLocal 2
 881: oPushResult
 882: oSetResult 6
 884: oPushResult
 885: oGetLocal 4
 887: oPushResult
 888: oNodeSet
 889: oPop 3
 891: oGetAddrLocal 5
 893: oPushResult
 894: oGetLocal 4
 896: oPushResult
 897: oCall 5789
 899: oPop 1
 901: oAssign
 902: oGetLocal 2
 904: oPushResult
 905: oSetResult 17
 907: oPushResult
 908: oGetLocal 5
 910: oPushResult
 911: oScopeAllocType
 912: oPop 1
 914: oPushResult
 915: oNodeSetInt
 916: oPop 3
 918: oScopeEnd
 919: oInput 4
 921: oGetLocal 1
 923: oChoice 935
 925: oGetLocal 2
 927: oPushResult
 928: oScopeDeclare
 929: oPop 1
 931: oJumpForward 941
 933: oJumpForward 941
 935: Choice Lookup Table
           1    933
           0    925
 940: oEndChoice
 941: oGetLocal 2
 943: oPushResult
 944: oCall 345
 946: oPop 1
 948: oInputChoice 961
 950: oJumpForward 1032
 952: oGetLocal 2
 954: oPushResult
 955: oCall 373
 957: oPop 1
 959: oJumpForward 1032
 961: Choice Lookup Table
          59    952
          58    950
 966: oGetLocal 3
 968: oPushResult
 969: oScopeEnter
 970: oPop 1
 972: oScopeBegin
 973: oScopeCurrent
 974: oPushResult
 975: oSetResult 3
 977: oPushResult
 978: oSetResult 1
 980: oPushResult
 981: oNodeSetBoolean
 982: oPop 3
 984: oGetLocal 2
 986: oPushResult
 987: oSetResult 10
 989: oPushResult
 990: oScopeCurrent
 991: oPushResult
 992: oNodeSet
 993: oPop 3
 995: oGetAddrLocal 6
 997: oPushResult
 998: oGetLocal 2
1000: oPushResult
1001: oSetResult 7
1003: oPushResult
1004: oNodeGetLabel
1005: oPop 2
1007: oAssign
1008: oSetResult 13
1010: oPushResult
1011: oGetLocal 6
1013: oPushResult
1014: oCall 204
1016: oPop 2
1018: oGetLocal 2
1020: oPushResult
1021: oSetResult 11
1023: oPushResult
1024: oSetResult 1
1026: oPushResult
1027: oNodeSetBoolean
1028: oPop 3
1030: oScopeEnd
1031: oScopeEnd
1032: oInput 4
1034: oReturn
1035: oLocalSpace 6
1037: oInputChoice 1258
1039: oGetAddrLocal 1
1041: oPushResult
1042: oNodeVecNew
1043: oAssign
1044: oGetAddrLocal 3
1046: oPushResult
1047: oSetResult 0
1049: oAssign
1050: oInputChoice 1060
1052: oGetAddrLocal 3
1054: oPushResult
1055: oSetResult 1
1057: oAssign
1058: oJumpForward 1063
1060: Choice Lookup Table
          32   1052
1063: oInput 0
1065: oGetAddrLocal 2
1067: oPushResult
1068: oSetResult 15
1070: oPushResult
1071: oSetResult 6
1073: oPushResult
1074: LAST_ID
1075: oPushResult
1076: oCall 5761
1078: oPop 3
1080: oAssign
1081: oGetLocal 2
1083: oPushResult
1084: oSetResult 18
1086: oPushResult
1087: oGetLocal 3
1089: oPushResult
1090: oNodeSetBoolean
1091: oPop 3
1093: oGetLocal 1
1095: oPushResult
1096: oGetLocal 2
1098: oPushResult
1099: oNodeVecAppend
1100: oPop 2
1102: oInputChoice 1110
1104: oJumpForward 1118
1106: oJumpForward 1116
1108: oJumpForward 1116
1110: Choice Lookup Table
          12   1108
          11   1104
1115: oEndChoice
1116: oJumpBack 1063
1118: oGetAddrLocal 4
1120: oPushResult
1121: oCall 1534
1123: oPop 1
1125: oGetLocal 3
1127: oChoice 1142
1129: oGetAddrLocal 5
1131: oPushResult
1132: oGetLocal 4
1134: oPushResult
1135: oCall 5789
1137: oPop 1
1139: oAssign
1140: oJumpForward 1151
1142: Choice Lookup Table
           1   1129
1145: oGetAddrLocal 5
1147: oPushResult
1148: oGetLocal 4
1150: oAssign
1151: oGetAddrLocal 6
1153: oPushResult
1154: oSetResult 0
1156: oAssign
1157: oGetLocal 6
1159: oPushResult
1160: oGetLocal 1
1162: oPushResult
1163: oNodeVecSize
1164: oPop 1
1166: oPushResult
1167: equal
1168: oPop 2
1170: oChoice 1227
1172: oGetAddrLocal 2
1174: oPushResult
1175: oGetLocal 1
1177: oPushResult
1178: oGetLocal 6
1180: oPushResult
1181: oNodeVecElement
1182: oPop 2
1184: oAssign
1185: oGetLocal 2
1187: oPushResult
1188: oSetResult 6
1190: oPushResult
1191: oGetLocal 4
1193: oPushResult
1194: oNodeSet
1195: oPop 3
1197: oGetLocal 2
1199: oPushResult
1200: oScopeDeclare
1201: oPop 1
1203: oGetLocal 2
1205: oPushResult
1206: oSetResult 7
1208: oPushResult
1209: oGetLocal 5
1211: oPushResult
1212: oScopeAllocType
1213: oPop 1
1215: oPushResult
1216: oNodeSetInt
1217: oPop 3
1219: oGetAddrLocal 6
1221: oPushResult
1222: inc
1223: oPop 1
1225: oJumpForward 1232
1227: Choice Lookup Table
           0   1172
1230: oJumpForward 1234
1232: oJumpBack 1157
1234: oGetLocal 1
1236: oPushResult
1237: oNodeVecDelete
1238: oPop 1
1240: oInputChoice 1248
1242: oJumpForward 1256
1244: oJumpForward 1254
1246: oJumpForward 1254
1248: Choice Lookup Table
           4   1246
          14   1242
1253: oEndChoice
1254: oJumpBack 1039
1256: oJumpForward 1261
1258: Choice Lookup Table
          13   1039
1261: oReturn
1262: oLocalSpace 2
1264: oInputChoice 1326
1266: oGetAddrLocal 1
1268: oPushResult
1269: oSetResult 9
1271: oPushResult
1272: oSetResult 4
1274: oPushResult
1275: LAST_ID
1276: oPushResult
1277: oCall 5761
1279: oPop 3
1281: oAssign
1282: oInput 5
1284: oCall 2003
1286: oGetAddrLocal 2
1288: oPushResult
1289: oValueTop
1290: oAssign
1291: oValuePop
1292: oGetLocal 1
1294: oPushResult
1295: oSetResult 7
1297: oPushResult
1298: oGetLocal 2
1300: oPushResult
1301: oNodeSetInt
1302: oPop 3
1304: oGetLocal 1
1306: oPushResult
1307: oSetResult 6
1309: oPushResult
1310: oGetGlobal 3
1312: oPushResult
1313: oNodeSet
1314: oPop 3
1316: oGetLocal 1
1318: oPushResult
1319: oScopeDeclare
1320: oPop 1
1322: oInput 4
1324: oJumpForward 1331
1326: Choice Lookup Table
           0   1266
1329: oJumpForward 1333
1331: oJumpBack 1264
1333: oReturn
1334: oLocalSpace 2
1336: oInputChoice 1385
1338: oGetAddrLocal 1
1340: oPushResult
1341: oSetResult 10
1343: oPushResult
1344: oSetResult 5
1346: oPushResult
1347: LAST_ID
1348: oPushResult
1349: oCall 5761
1351: oPop 3
1353: oAssign
1354: oInput 5
1356: oGetAddrLocal 2
1358: oPushResult
1359: oCall 1534
1361: oPop 1
1363: oGetLocal 1
1365: oPushResult
1366: oSetResult 6
1368: oPushResult
1369: oGetLocal 2
1371: oPushResult
1372: oNodeSet
1373: oPop 3
1375: oGetLocal 1
1377: oPushResult
1378: oScopeDeclare
1379: oPop 1
1381: oInput 4
1383: oJumpForward 1390
1385: Choice Lookup Table
           0   1338
1388: oJumpForward 1392
1390: oJumpBack 1336
1392: oReturn
1393: oLocalSpace 4
1395: oInputChoice 1526
1397: oGetAddrLocal 1
1399: oPushResult
1400: oNodeVecNew
1401: oAssign
1402: oGetAddrLocal 2
1404: oPushResult
1405: oGetParam 1
1407: oPushResult
1408: oSetResult 6
1410: oPushResult
1411: LAST_ID
1412: oPushResult
1413: oCall 5761
1415: oPop 3
1417: oAssign
1418: oGetLocal 1
1420: oPushResult
1421: oGetLocal 2
1423: oPushResult
1424: oNodeVecAppend
1425: oPop 2
1427: oInputChoice 1433
1429: oInput 0
1431: oJumpForward 1438
1433: Choice Lookup Table
          12   1429
1436: oJumpForward 1440
1438: oJumpBack 1402
1440: oInput 11
1442: oGetAddrLocal 3
1444: oPushResult
1445: oCall 1534
1447: oPop 1
1449: oGetAddrLocal 4
1451: oPushResult
1452: oSetResult 0
1454: oAssign
1455: oGetLocal 4
1457: oPushResult
1458: oGetLocal 1
1460: oPushResult
1461: oNodeVecSize
1462: oPop 1
1464: oPushResult
1465: equal
1466: oPop 2
1468: oChoice 1509
1470: oGetAddrLocal 2
1472: oPushResult
1473: oGetLocal 1
1475: oPushResult
1476: oGetLocal 4
1478: oPushResult
1479: oNodeVecElement
1480: oPop 2
1482: oAssign
1483: oGetLocal 2
1485: oPushResult
1486: oSetResult 6
1488: oPushResult
1489: oGetLocal 3
1491: oPushResult
1492: oNodeSet
1493: oPop 3
1495: oGetLocal 2
1497: oPushResult
1498: oScopeDeclareAlloc
1499: oPop 1
1501: oGetAddrLocal 4
1503: oPushResult
1504: inc
1505: oPop 1
1507: oJumpForward 1514
1509: Choice Lookup Table
           0   1470
1512: oJumpForward 1516
1514: oJumpBack 1455
1516: oGetLocal 1
1518: oPushResult
1519: oNodeVecDelete
1520: oPop 1
1522: oInput 4
1524: oJumpForward 1531
1526: Choice Lookup Table
           0   1397
1529: oJumpForward 1533
1531: oJumpBack 1395
1533: oReturn
1534: oLocalSpace 12
1536: oInputChoice 1985
1538: oGetAddrLocal 1
1540: oPushResult
1541: oScopeFindRequire
1542: oAssign
1543: oGetLocal 1
1545: oPushResult
1546: oNodeType
1547: oPop 1
1549: oChoice 1566
1551: oGetParam 1
1553: oPushResult
1554: oGetLocal 1
1556: oPushResult
1557: oSetResult 6
1559: oPushResult
1560: oNodeGet
1561: oPop 2
1563: oAssign
1564: oJumpForward 1577
1566: Choice Lookup Table
          10   1551
1569: oError 2
1571: oGetParam 1
1573: oPushResult
1574: oGetGlobal 3
1576: oAssign
1577: oJumpForward 2002
1579: oInput 15
1581: oGetAddrLocal 2
1583: oPushResult
1584: oNodeVecNew
1585: oAssign
1586: oGetAddrLocal 3
1588: oPushResult
1589: oSetResult 25
1591: oPushResult
1592: oNodeNew
1593: oPop 1
1595: oAssign
1596: oGetLocal 3
1598: oPushResult
1599: oSetResult 20
1601: oPushResult
1602: oGetGlobal 3
1604: oPushResult
1605: oNodeSet
1606: oPop 3
1608: oCall 2003
1610: oGetLocal 3
1612: oPushResult
1613: oSetResult 22
1615: oPushResult
1616: oValueTop
1617: oPushResult
1618: oNodeSetInt
1619: oPop 3
1621: oValuePop
1622: oInput 20
1624: oCall 2003
1626: oGetLocal 3
1628: oPushResult
1629: oSetResult 23
1631: oPushResult
1632: oValueTop
1633: oPushResult
1634: oNodeSetInt
1635: oPop 3
1637: oValuePop
1638: oGetLocal 3
1640: oPushResult
1641: oSetResult 2
1643: oPushResult
1644: oSetResult 4
1646: oPushResult
1647: oNodeSetInt
1648: oPop 3
1650: oGetLocal 3
1652: oPushResult
1653: oTypeAdd
1654: oPop 1
1656: oGetAddrLocal 4
1658: oPushResult
1659: oSetResult 24
1661: oPushResult
1662: oNodeNew
1663: oPop 1
1665: oAssign
1666: oGetLocal 4
1668: oPushResult
1669: oSetResult 21
1671: oPushResult
1672: oGetLocal 3
1674: oPushResult
1675: oNodeSet
1676: oPop 3
1678: oGetLocal 2
1680: oPushResult
1681: oGetLocal 4
1683: oPushResult
1684: oNodeVecAppend
1685: oPop 2
1687: oInputChoice 1695
1689: oJumpForward 1703
1691: oJumpForward 1701
1693: oJumpForward 1701
1695: Choice Lookup Table
          12   1693
          16   1689
1700: oEndChoice
1701: oJumpBack 1586
1703: oInput 38
1705: oGetAddrLocal 5
1707: oPushResult
1708: oCall 1534
1710: oPop 1
1712: oGetAddrLocal 6
1714: oPushResult
1715: oGetLocal 2
1717: oPushResult
1718: oNodeVecSize
1719: oPop 1
1721: oAssign
1722: oGetAddrLocal 6
1724: oPushResult
1725: dec
1726: oPop 1
1728: oGetAddrLocal 7
1730: oPushResult
1731: oGetLocal 2
1733: oPushResult
1734: oGetLocal 6
1736: oPushResult
1737: oNodeVecElement
1738: oPop 2
1740: oAssign
1741: oGetLocal 7
1743: oPushResult
1744: oSetResult 20
1746: oPushResult
1747: oGetLocal 5
1749: oPushResult
1750: oNodeSet
1751: oPop 3
1753: oGetAddrLocal 8
1755: oPushResult
1756: oGetLocal 7
1758: oPushResult
1759: oSetResult 21
1761: oPushResult
1762: oNodeGet
1763: oPop 2
1765: oAssign
1766: oGetAddrLocal 9
1768: oPushResult
1769: oGetLocal 8
1771: oPushResult
1772: oSetResult 23
1774: oPushResult
1775: oNodeGetInt
1776: oPop 2
1778: oPushResult
1779: oGetLocal 8
1781: oPushResult
1782: oSetResult 22
1784: oPushResult
1785: oNodeGetInt
1786: oPop 2
1788: oPushResult
1789: subtract
1790: oPop 2
1792: oAssign
1793: oGetAddrLocal 9
1795: oPushResult
1796: inc
1797: oPop 1
1799: oGetLocal 7
1801: oPushResult
1802: oSetResult 2
1804: oPushResult
1805: oGetLocal 9
1807: oPushResult
1808: oGetLocal 5
1810: oPushResult
1811: oSetResult 2
1813: oPushResult
1814: oNodeGetInt
1815: oPop 2
1817: oPushResult
1818: multiply
1819: oPop 2
1821: oPushResult
1822: oNodeSetInt
1823: oPop 3
1825: oGetLocal 7
1827: oPushResult
1828: oTypeAdd
1829: oPop 1
1831: oGetAddrLocal 5
1833: oPushResult
1834: oGetLocal 7
1836: oAssign
1837: oGetLocal 6
1839: oPushResult
1840: equal_zero
1841: oPop 1
1843: oChoice 1849
1845: oJumpForward 1854
1847: oJumpForward 1852
1849: Choice Lookup Table
           1   1845
1852: oJumpBack 1722
1854: oGetParam 1
1856: oPushResult
1857: oGetLocal 2
1859: oPushResult
1860: oSetResult 0
1862: oPushResult
1863: oNodeVecElement
1864: oPop 2
1866: oAssign
1867: oGetLocal 2
1869: oPushResult
1870: oNodeVecDelete
1871: oPop 1
1873: oJumpForward 2002
1875: oGetAddrLocal 10
1877: oPushResult
1878: oCall 1534
1880: oPop 1
1882: oGetParam 1
1884: oPushResult
1885: oGetLocal 10
1887: oPushResult
1888: oCall 5789
1890: oPop 1
1892: oAssign
1893: oJumpForward 2002
1895: oGetParam 1
1897: oPushResult
1898: oSetResult 26
1900: oPushResult
1901: oNodeNew
1902: oPop 1
1904: oAssign
1905: oScopeBegin
1906: oSetResult 14
1908: oPushResult
1909: oCall 1393
1911: oPop 1
1913: oGetAddrLocal 11
1915: oPushResult
1916: oScopeCurrent
1917: oPushResult
1918: oSetResult 2
1920: oPushResult
1921: oNodeGetInt
1922: oPop 2
1924: oAssign
1925: oGetLocal 11
1927: oPushResult
1928: equal_zero
1929: oPop 1
1931: oChoice 1937
1933: oError 19
1935: oJumpForward 1940
1937: Choice Lookup Table
           1   1933
1940: oInput 34
1942: oGetFromParam 1
1944: oPushResult
1945: oSetResult 24
1947: oPushResult
1948: oScopeCurrent
1949: oPushResult
1950: oNodeSet
1951: oPop 3
1953: oGetFromParam 1
1955: oPushResult
1956: oSetResult 2
1958: oPushResult
1959: oGetLocal 11
1961: oPushResult
1962: oNodeSetInt
1963: oPop 3
1965: oScopeEnd
1966: oGetFromParam 1
1968: oPushResult
1969: oTypeAdd
1970: oPop 1
1972: oJumpForward 2002
1974: oInput 38
1976: oGetAddrLocal 12
1978: oPushResult
1979: oCall 1534
1981: oPop 1
1983: oJumpForward 2002
1985: Choice Lookup Table
          37   1974
          36   1895
          17   1875
          35   1579
           0   1538
1996: oCall 2003
1998: oInput 20
2000: oCall 2003
2002: oReturn
2003: oLocalSpace 1
2005: oInputChoice 2060
2007: TOKEN_VALUE
2008: oPushResult
2009: oValuePush
2010: oPop 1
2012: oJumpForward 2068
2014: oGetAddrLocal 1
2016: oPushResult
2017: oScopeFindRequire
2018: oAssign
2019: oGetLocal 1
2021: oPushResult
2022: oNodeType
2023: oPop 1
2025: oChoice 2042
2027: oGetLocal 1
2029: oPushResult
2030: oSetResult 7
2032: oPushResult
2033: oNodeGetInt
2034: oPop 2
2036: oPushResult
2037: oValuePush
2038: oPop 1
2040: oJumpForward 2053
2042: Choice Lookup Table
           9   2027
2045: oError 1
2047: oSetResult 0
2049: oPushResult
2050: oValuePush
2051: oPop 1
2053: oJumpForward 2068
2055: oCall 2003
2057: oValueNegate
2058: oJumpForward 2068
2060: Choice Lookup Table
          24   2055
           0   2014
           1   2007
2067: oEndChoice
2068: oReturn
2069: oLocalSpace 1
2071: oGetAddrLocal 1
2073: oPushResult
2074: oSetResult 0
2076: oAssign
2077: oGetAddrLocal 1
2079: oPushResult
2080: oCall 2230
2082: oPop 1
2084: oGetAddrLocal 1
2086: oPushResult
2087: oCall 2130
2089: oPop 1
2091: oReturn
2092: oLocalSpace 0
2094: oGetParam 1
2096: oPushResult
2097: oCall 2230
2099: oPop 1
2101: oTypeSNodeType
2102: oChoice 2121
2104: oJumpForward 2128
2106: oGetParam 1
2108: oPushResult
2109: oLabelNew
2110: oAssign
2111: oEmit 47
2113: oGetFromParam 1
2115: oPushResult
2116: oEmitLabel
2117: oPop 1
2119: oJumpForward 2128
2121: Choice Lookup Table
          19   2106
          20   2104
2126: oError 8
2128: oTypeSPop
2129: oReturn
2130: oLocalSpace 1
2132: oTypeSNodeType
2133: oChoice 2195
2135: oGetAddrLocal 1
2137: oPushResult
2138: oLabelNew
2139: oAssign
2140: oEmit 9
2142: oSetResult 1
2144: oPushResult
2145: oEmitInt
2146: oPop 1
2148: oEmit 45
2150: oGetLocal 1
2152: oPushResult
2153: oEmitLabel
2154: oPop 1
2156: oEmit 48
2158: oGetFromParam 1
2160: oPushResult
2161: oEmitLabel
2162: oPop 1
2164: oEmit 9
2166: oSetResult 0
2168: oPushResult
2169: oEmitInt
2170: oPop 1
2172: oEmit 48
2174: oGetLocal 1
2176: oPushResult
2177: oEmitLabel
2178: oPop 1
2180: oTypeSPop
2181: oGetGlobal 4
2183: oPushResult
2184: oTypeSPush
2185: oPop 1
2187: oGetParam 1
2189: oPushResult
2190: oSetResult 0
2192: oAssign
2193: oJumpForward 2198
2195: Choice Lookup Table
          20   2135
2198: oReturn
2199: oLocalSpace 0
2201: oTypeSNodeType
2202: oChoice 2226
2204: oGetParam 1
2206: oPushResult
2207: oLabelNew
2208: oAssign
2209: oEmit 47
2211: oGetFromParam 1
2213: oPushResult
2214: oEmitLabel
2215: oPop 1
2217: oTypeSPop
2218: oGetGlobal 5
2220: oPushResult
2221: oTypeSPush
2222: oPop 1
2224: oJumpForward 2229
2226: Choice Lookup Table
          19   2204
2229: oReturn
2230: oLocalSpace 0
2232: oGetParam 1
2234: oPushResult
2235: oCall 2595
2237: oPop 1
2239: oInputChoice 2577
2241: oGetParam 1
2243: oPushResult
2244: oCall 2130
2246: oPop 1
2248: oGetParam 1
2250: oPushResult
2251: oCall 2595
2253: oPop 1
2255: oGetParam 1
2257: oPushResult
2258: oCall 2130
2260: oPop 1
2262: oCall 5647
2264: oTypeSNodeType
2265: oChoice 2279
2267: oEmit 30
2269: oJumpForward 2292
2271: oEmit 36
2273: oJumpForward 2292
2275: oError 16
2277: oJumpForward 2292
2279: Choice Lookup Table
          22   2275
          21   2275
          23   2271
          19   2267
          18   2267
2290: oError 17
2292: oTypeSPop
2293: oGetGlobal 4
2295: oPushResult
2296: oTypeSPush
2297: oPop 1
2299: oJumpForward 2592
2301: oGetParam 1
2303: oPushResult
2304: oCall 2130
2306: oPop 1
2308: oGetParam 1
2310: oPushResult
2311: oCall 2595
2313: oPop 1
2315: oGetParam 1
2317: oPushResult
2318: oCall 2130
2320: oPop 1
2322: oCall 5647
2324: oTypeSNodeType
2325: oChoice 2339
2327: oEmit 31
2329: oJumpForward 2352
2331: oEmit 37
2333: oJumpForward 2352
2335: oError 16
2337: oJumpForward 2352
2339: Choice Lookup Table
          22   2335
          21   2335
          23   2331
          19   2327
          18   2327
2350: oError 17
2352: oTypeSPop
2353: oGetGlobal 4
2355: oPushResult
2356: oTypeSPush
2357: oPop 1
2359: oJumpForward 2592
2361: oGetParam 1
2363: oPushResult
2364: oCall 2130
2366: oPop 1
2368: oGetParam 1
2370: oPushResult
2371: oCall 2595
2373: oPop 1
2375: oGetParam 1
2377: oPushResult
2378: oCall 2130
2380: oPop 1
2382: oCall 5647
2384: oTypeSNodeType
2385: oChoice 2395
2387: oEmit 33
2389: oJumpForward 2406
2391: oError 16
2393: oJumpForward 2406
2395: Choice Lookup Table
          22   2391
          21   2391
          19   2387
          18   2387
2404: oError 17
2406: oTypeSPop
2407: oGetGlobal 4
2409: oPushResult
2410: oTypeSPush
2411: oPop 1
2413: oJumpForward 2592
2415: oGetParam 1
2417: oPushResult
2418: oCall 2130
2420: oPop 1
2422: oGetParam 1
2424: oPushResult
2425: oCall 2595
2427: oPop 1
2429: oGetParam 1
2431: oPushResult
2432: oCall 2130
2434: oPop 1
2436: oCall 5647
2438: oTypeSNodeType
2439: oChoice 2449
2441: oEmit 32
2443: oJumpForward 2460
2445: oError 16
2447: oJumpForward 2460
2449: Choice Lookup Table
          22   2445
          21   2445
          19   2441
          18   2441
2458: oError 17
2460: oTypeSPop
2461: oGetGlobal 4
2463: oPushResult
2464: oTypeSPush
2465: oPop 1
2467: oJumpForward 2592
2469: oGetParam 1
2471: oPushResult
2472: oCall 2130
2474: oPop 1
2476: oGetParam 1
2478: oPushResult
2479: oCall 2595
2481: oPop 1
2483: oGetParam 1
2485: oPushResult
2486: oCall 2130
2488: oPop 1
2490: oCall 5647
2492: oTypeSNodeType
2493: oChoice 2503
2495: oEmit 35
2497: oJumpForward 2514
2499: oError 16
2501: oJumpForward 2514
2503: Choice Lookup Table
          22   2499
          21   2499
          19   2495
          18   2495
2512: oError 17
2514: oTypeSPop
2515: oGetGlobal 4
2517: oPushResult
2518: oTypeSPush
2519: oPop 1
2521: oJumpForward 2592
2523: oGetParam 1
2525: oPushResult
2526: oCall 2130
2528: oPop 1
2530: oGetParam 1
2532: oPushResult
2533: oCall 2595
2535: oPop 1
2537: oGetParam 1
2539: oPushResult
2540: oCall 2130
2542: oPop 1
2544: oCall 5647
2546: oTypeSNodeType
2547: oChoice 2557
2549: oEmit 34
2551: oJumpForward 2568
2553: oError 16
2555: oJumpForward 2568
2557: Choice Lookup Table
          22   2553
          21   2553
          19   2549
          18   2549
2566: oError 17
2568: oTypeSPop
2569: oGetGlobal 4
2571: oPushResult
2572: oTypeSPush
2573: oPop 1
2575: oJumpForward 2592
2577: Choice Lookup Table
          10   2523
           9   2469
           8   2415
           7   2361
           6   2301
           5   2241
2590: oJumpForward 2594
2592: oJumpBack 2239
2594: oReturn
2595: oLocalSpace 1
2597: oGetAddrLocal 1
2599: oPushResult
2600: oSetResult 0
2602: oAssign
2603: oGetParam 1
2605: oPushResult
2606: oCall 2775
2608: oPop 1
2610: oInputChoice 2743
2612: oTypeSNodeType
2613: oChoice 2684
2615: oGetLocal 1
2617: oPushResult
2618: oSetResult 0
2620: oPushResult
2621: equal_label
2622: oPop 2
2624: oChoice 2633
2626: oGetAddrLocal 1
2628: oPushResult
2629: oLabelNew
2630: oAssign
2631: oJumpForward 2636
2633: Choice Lookup Table
           1   2626
2636: oEmit 45
2638: oGetLocal 1
2640: oPushResult
2641: oEmitLabel
2642: oPop 1
2644: oJumpForward 2691
2646: oGetParam 1
2648: oPushResult
2649: oCall 2199
2651: oPop 1
2653: oGetLocal 1
2655: oPushResult
2656: oSetResult 0
2658: oPushResult
2659: equal_label
2660: oPop 2
2662: oChoice 2671
2664: oGetAddrLocal 1
2666: oPushResult
2667: oLabelNew
2668: oAssign
2669: oJumpForward 2674
2671: Choice Lookup Table
           1   2664
2674: oEmit 45
2676: oGetLocal 1
2678: oPushResult
2679: oEmitLabel
2680: oPop 1
2682: oJumpForward 2691
2684: Choice Lookup Table
          19   2646
          20   2615
2689: oError 8
2691: oTypeSPop
2692: oEmit 48
2694: oGetFromParam 1
2696: oPushResult
2697: oEmitLabel
2698: oPop 1
2700: oGetParam 1
2702: oPushResult
2703: oSetResult 0
2705: oAssign
2706: oGetParam 1
2708: oPushResult
2709: oCall 2775
2711: oPop 1
2713: oTypeSNodeType
2714: oChoice 2727
2716: oJumpForward 2734
2718: oGetParam 1
2720: oPushResult
2721: oCall 2199
2723: oPop 1
2725: oJumpForward 2734
2727: Choice Lookup Table
          19   2718
          20   2716
2732: oError 8
2734: oTypeSPop
2735: oGetGlobal 5
2737: oPushResult
2738: oTypeSPush
2739: oPop 1
2741: oJumpForward 2748
2743: Choice Lookup Table
          52   2612
2746: oJumpForward 2750
2748: oJumpBack 2610
2750: oGetLocal 1
2752: oPushResult
2753: oSetResult 0
2755: oPushResult
2756: equal_label
2757: oPop 2
2759: oChoice 2771
2761: oEmit 48
2763: oGetLocal 1
2765: oPushResult
2766: oEmitLabel
2767: oPop 1
2769: oJumpForward 2774
2771: Choice Lookup Table
           0   2761
2774: oReturn
2775: oLocalSpace 2
2777: oGetAddrLocal 1
2779: oPushResult
2780: oSetResult 0
2782: oAssign
2783: oGetParam 1
2785: oPushResult
2786: oCall 2913
2788: oPop 1
2790: oInputChoice 2905
2792: oTypeSNodeType
2793: oChoice 2806
2795: oJumpForward 2813
2797: oGetParam 1
2799: oPushResult
2800: oCall 2199
2802: oPop 1
2804: oJumpForward 2813
2806: Choice Lookup Table
          19   2797
          20   2795
2811: oError 8
2813: oTypeSPop
2814: oGetLocal 1
2816: oPushResult
2817: oSetResult 0
2819: oPushResult
2820: equal_label
2821: oPop 2
2823: oChoice 2852
2825: oGetAddrLocal 1
2827: oPushResult
2828: oLabelNew
2829: oAssign
2830: oEmit 49
2832: oGetFromParam 1
2834: oPushResult
2835: oEmitLabel
2836: oPop 1
2838: oGetLocal 1
2840: oPushResult
2841: oEmitLabel
2842: oPop 1
2844: oGetParam 1
2846: oPushResult
2847: oGetLocal 1
2849: oAssign
2850: oJumpForward 2855
2852: Choice Lookup Table
           1   2825
2855: oGetAddrLocal 2
2857: oPushResult
2858: oSetResult 0
2860: oAssign
2861: oGetAddrLocal 2
2863: oPushResult
2864: oCall 2913
2866: oPop 1
2868: oTypeSNodeType
2869: oChoice 2882
2871: oJumpForward 2889
2873: oGetAddrLocal 2
2875: oPushResult
2876: oCall 2199
2878: oPop 1
2880: oJumpForward 2889
2882: Choice Lookup Table
          19   2873
          20   2871
2887: oError 8
2889: oEmit 49
2891: oGetLocal 2
2893: oPushResult
2894: oEmitLabel
2895: oPop 1
2897: oGetLocal 1
2899: oPushResult
2900: oEmitLabel
2901: oPop 1
2903: oJumpForward 2910
2905: Choice Lookup Table
          51   2792
2908: oJumpForward 2912
2910: oJumpBack 2790
2912: oReturn
2913: oLocalSpace 1
2915: oInputChoice 2969
2917: oGetAddrLocal 1
2919: oPushResult
2920: oSetResult 0
2922: oAssign
2923: oGetAddrLocal 1
2925: oPushResult
2926: oCall 2913
2928: oPop 1
2930: oTypeSNodeType
2931: oChoice 2960
2933: oGetParam 1
2935: oPushResult
2936: oLabelNew
2937: oAssign
2938: oEmit 45
2940: oGetFromParam 1
2942: oPushResult
2943: oEmitLabel
2944: oPop 1
2946: oEmit 48
2948: oGetLocal 1
2950: oPushResult
2951: oEmitLabel
2952: oPop 1
2954: oJumpForward 2967
2956: oEmit 29
2958: oJumpForward 2967
2960: Choice Lookup Table
          19   2956
          20   2933
2965: oError 8
2967: oJumpForward 2979
2969: Choice Lookup Table
          53   2917
2972: oGetParam 1
2974: oPushResult
2975: oCall 2980
2977: oPop 1
2979: oReturn
2980: oLocalSpace 0
2982: oGetParam 1
2984: oPushResult
2985: oCall 3031
2987: oPop 1
2989: oInputChoice 3021
2991: oCall 5673
2993: oGetParam 1
2995: oPushResult
2996: oCall 3031
2998: oPop 1
3000: oCall 5687
3002: oEmit 26
3004: oJumpForward 3028
3006: oCall 5673
3008: oGetParam 1
3010: oPushResult
3011: oCall 3031
3013: oPop 1
3015: oCall 5687
3017: oEmit 27
3019: oJumpForward 3028
3021: Choice Lookup Table
          24   3006
          23   2991
3026: oJumpForward 3030
3028: oJumpBack 2989
3030: oReturn
3031: oLocalSpace 0
3033: oGetParam 1
3035: oPushResult
3036: oCall 3082
3038: oPop 1
3040: oInputChoice 3072
3042: oCall 5673
3044: oGetParam 1
3046: oPushResult
3047: oCall 3082
3049: oPop 1
3051: oCall 5687
3053: oEmit 23
3055: oJumpForward 3079
3057: oCall 5673
3059: oGetParam 1
3061: oPushResult
3062: oCall 3082
3064: oPop 1
3066: oCall 5687
3068: oEmit 24
3070: oJumpForward 3079
3072: Choice Lookup Table
          22   3057
          21   3042
3077: oJumpForward 3081
3079: oJumpBack 3040
3081: oReturn
3082: oLocalSpace 0
3084: oInputChoice 3110
3086: oGetParam 1
3088: oPushResult
3089: oCall 3123
3091: oPop 1
3093: oCall 5687
3095: oJumpForward 3122
3097: oGetParam 1
3099: oPushResult
3100: oCall 3123
3102: oPop 1
3104: oCall 5687
3106: oEmit 28
3108: oJumpForward 3122
3110: Choice Lookup Table
          24   3097
          23   3086
3115: oGetParam 1
3117: oPushResult
3118: oCall 3123
3120: oPop 1
3122: oReturn
3123: oLocalSpace 6
3125: oInputChoice 3307
3127: oEmit 9
3129: TOKEN_VALUE
3130: oPushResult
3131: oEmitInt
3132: oPop 1
3134: oGetGlobal 3
3136: oPushResult
3137: oTypeSPush
3138: oPop 1
3140: oJumpForward 3326
3142: oGetParam 1
3144: oPushResult
3145: oCall 2230
3147: oPop 1
3149: oInput 14
3151: oJumpForward 3326
3153: oGetAddrLocal 1
3155: oPushResult
3156: oStringAllocLit
3157: oAssign
3158: oEmit 10
3160: oGetLocal 1
3162: oPushResult
3163: oEmitInt
3164: oPop 1
3166: oGetGlobal 7
3168: oPushResult
3169: oTypeSPush
3170: oPop 1
3172: oJumpForward 3326
3174: oGetAddrLocal 2
3176: oPushResult
3177: oScopeFindRequire
3178: oAssign
3179: oGetLocal 2
3181: oPushResult
3182: oNodeType
3183: oPop 1
3185: oChoice 3247
3187: oGetLocal 2
3189: oPushResult
3190: oCall 4049
3192: oPop 1
3194: oJumpForward 3266
3196: oGetAddrLocal 3
3198: oPushResult
3199: oGetLocal 2
3201: oPushResult
3202: oSetResult 6
3204: oPushResult
3205: oNodeGet
3206: oPop 2
3208: oAssign
3209: oGetLocal 3
3211: oPushResult
3212: oTypeSPush
3213: oPop 1
3215: oTypeSNodeType
3216: oChoice 3229
3218: oEmit 9
3220: oGetLocal 2
3222: oPushResult
3223: oCall 5924
3225: oPop 1
3227: oJumpForward 3236
3229: Choice Lookup Table
          19   3218
          18   3218
3234: oError 16
3236: oJumpForward 3266
3238: oGetLocal 2
3240: oPushResult
3241: oCall 3327
3243: oPop 1
3245: oJumpForward 3266
3247: Choice Lookup Table
          15   3238
          13   3238
          12   3238
           9   3196
           8   3187
3258: oError 6
3260: oGetGlobal 3
3262: oPushResult
3263: oTypeSPush
3264: oPop 1
3266: oJumpForward 3326
3268: oInput 0
3270: oGetAddrLocal 4
3272: oPushResult
3273: oScopeFindRequire
3274: oAssign
3275: oGetLocal 4
3277: oPushResult
3278: oCall 4966
3280: oPop 1
3282: oGetAddrLocal 5
3284: oPushResult
3285: oTypeSTop
3286: oAssign
3287: oTypeSPop
3288: oGetAddrLocal 6
3290: oPushResult
3291: oGetLocal 5
3293: oPushResult
3294: oCall 5789
3296: oPop 1
3298: oAssign
3299: oGetLocal 6
3301: oPushResult
3302: oTypeSPush
3303: oPop 1
3305: oJumpForward 3326
3307: Choice Lookup Table
          18   3268
           0   3174
           2   3153
          13   3142
           1   3127
3318: oError 6
3320: oGetGlobal 3
3322: oPushResult
3323: oTypeSPush
3324: oPop 1
3326: oReturn
3327: oLocalSpace 1
3329: oGetAddrLocal 1
3331: oPushResult
3332: oGetParam 1
3334: oPushResult
3335: oSetResult 6
3337: oPushResult
3338: oNodeGet
3339: oPop 2
3341: oAssign
3342: oGetLocal 1
3344: oPushResult
3345: oTypeSPush
3346: oPop 1
3348: oTypeSNodeType
3349: oChoice 3614
3351: oGetParam 1
3353: oPushResult
3354: oNodeType
3355: oPop 1
3357: oChoice 3419
3359: oEmit 0
3361: oGetParam 1
3363: oPushResult
3364: oCall 5924
3366: oPop 1
3368: oJumpForward 3427
3370: oEmit 3
3372: oGetParam 1
3374: oPushResult
3375: oCall 5924
3377: oPop 1
3379: oJumpForward 3427
3381: oGetParam 1
3383: oPushResult
3384: oSetResult 18
3386: oPushResult
3387: oNodeGetBoolean
3388: oPop 2
3390: oChoice 3405
3392: oEmit 8
3394: oGetParam 1
3396: oPushResult
3397: oCall 5924
3399: oPop 1
3401: oEmit 14
3403: oJumpForward 3417
3405: Choice Lookup Table
           1   3392
3408: oEmit 6
3410: oGetParam 1
3412: oPushResult
3413: oCall 5924
3415: oPop 1
3417: oJumpForward 3427
3419: Choice Lookup Table
          15   3381
          13   3370
          12   3359
3426: oEndChoice
3427: oJumpForward 3705
3429: oGetParam 1
3431: oPushResult
3432: oNodeType
3433: oPop 1
3435: oChoice 3497
3437: oEmit 1
3439: oGetParam 1
3441: oPushResult
3442: oCall 5924
3444: oPop 1
3446: oJumpForward 3505
3448: oEmit 4
3450: oGetParam 1
3452: oPushResult
3453: oCall 5924
3455: oPop 1
3457: oJumpForward 3505
3459: oGetParam 1
3461: oPushResult
3462: oSetResult 18
3464: oPushResult
3465: oNodeGetBoolean
3466: oPop 2
3468: oChoice 3483
3470: oEmit 8
3472: oGetParam 1
3474: oPushResult
3475: oCall 5924
3477: oPop 1
3479: oEmit 15
3481: oJumpForward 3495
3483: Choice Lookup Table
           1   3470
3486: oEmit 7
3488: oGetParam 1
3490: oPushResult
3491: oCall 5924
3493: oPop 1
3495: oJumpForward 3505
3497: Choice Lookup Table
          15   3459
          13   3448
          12   3437
3504: oEndChoice
3505: oJumpForward 3705
3507: oError 16
3509: oJumpForward 3705
3511: oGetParam 1
3513: oPushResult
3514: oNodeType
3515: oPop 1
3517: oChoice 3579
3519: oEmit 2
3521: oGetParam 1
3523: oPushResult
3524: oCall 5924
3526: oPop 1
3528: oJumpForward 3587
3530: oEmit 5
3532: oGetParam 1
3534: oPushResult
3535: oCall 5924
3537: oPop 1
3539: oJumpForward 3587
3541: oGetParam 1
3543: oPushResult
3544: oSetResult 18
3546: oPushResult
3547: oNodeGetBoolean
3548: oPop 2
3550: oChoice 3565
3552: oEmit 8
3554: oGetParam 1
3556: oPushResult
3557: oCall 5924
3559: oPop 1
3561: oEmit 16
3563: oJumpForward 3577
3565: Choice Lookup Table
           1   3552
3568: oEmit 8
3570: oGetParam 1
3572: oPushResult
3573: oCall 5924
3575: oPop 1
3577: oJumpForward 3587
3579: Choice Lookup Table
          15   3541
          13   3530
          12   3519
3586: oEndChoice
3587: oInputChoice 3609
3589: oTypeSPop
3590: oGetLocal 1
3592: oPushResult
3593: oSetResult 20
3595: oPushResult
3596: oNodeGet
3597: oPop 2
3599: oPushResult
3600: oTypeSPush
3601: oPop 1
3603: oCall 3741
3605: oCall 3706
3607: oJumpForward 3612
3609: Choice Lookup Table
          17   3589
3612: oJumpForward 3705
3614: Choice Lookup Table
          23   3511
          17   3507
          22   3507
          21   3507
          19   3429
          18   3351
3627: oGetParam 1
3629: oPushResult
3630: oNodeType
3631: oPop 1
3633: oChoice 3693
3635: oEmit 10
3637: oGetParam 1
3639: oPushResult
3640: oCall 5924
3642: oPop 1
3644: oJumpForward 3701
3646: oEmit 11
3648: oGetParam 1
3650: oPushResult
3651: oCall 5924
3653: oPop 1
3655: oJumpForward 3701
3657: oGetParam 1
3659: oPushResult
3660: oSetResult 18
3662: oPushResult
3663: oNodeGetBoolean
3664: oPop 2
3666: oChoice 3679
3668: oEmit 8
3670: oGetParam 1
3672: oPushResult
3673: oCall 5924
3675: oPop 1
3677: oJumpForward 3691
3679: Choice Lookup Table
           1   3668
3682: oEmit 12
3684: oGetParam 1
3686: oPushResult
3687: oCall 5924
3689: oPop 1
3691: oJumpForward 3701
3693: Choice Lookup Table
          15   3657
          13   3646
          12   3635
3700: oEndChoice
3701: oCall 3741
3703: oCall 3706
3705: oReturn
3706: oLocalSpace 0
3708: oTypeSNodeType
3709: oChoice 3727
3711: oEmit 14
3713: oJumpForward 3740
3715: oEmit 15
3717: oJumpForward 3740
3719: oError 16
3721: oJumpForward 3740
3723: oEmit 16
3725: oJumpForward 3740
3727: Choice Lookup Table
          23   3723
          17   3719
          22   3719
          21   3719
          19   3715
          18   3711
3740: oReturn
3741: oLocalSpace 0
3743: oInputChoice 3757
3745: oCall 3769
3747: oJumpForward 3766
3749: oCall 3912
3751: oJumpForward 3766
3753: oCall 4010
3755: oJumpForward 3766
3757: Choice Lookup Table
          17   3753
          19   3749
          15   3745
3764: oJumpForward 3768
3766: oJumpBack 3743
3768: oReturn
3769: oLocalSpace 3
3771: oTypeSNodeType
3772: oChoice 3776
3774: oJumpForward 3781
3776: Choice Lookup Table
          24   3774
3779: oError 10
3781: oTypeSNodeType
3782: oChoice 3786
3784: oJumpForward 3791
3786: Choice Lookup Table
          24   3784
3789: oError 13
3791: oGetAddrLocal 1
3793: oPushResult
3794: oTypeSTop
3795: oPushResult
3796: oSetResult 21
3798: oPushResult
3799: oNodeGet
3800: oPop 2
3802: oPushResult
3803: oCall 5873
3805: oPop 1
3807: oAssign
3808: oGetAddrLocal 2
3810: oPushResult
3811: oTypeSTop
3812: oPushResult
3813: oSetResult 20
3815: oPushResult
3816: oNodeGet
3817: oPop 2
3819: oAssign
3820: oTypeSPop
3821: oGetLocal 2
3823: oPushResult
3824: oTypeSPush
3825: oPop 1
3827: oCall 2069
3829: oCall 5673
3831: oGetLocal 1
3833: oPushResult
3834: equal_zero
3835: oPop 1
3837: oChoice 3851
3839: oEmit 9
3841: oGetLocal 1
3843: oPushResult
3844: oEmitInt
3845: oPop 1
3847: oEmit 27
3849: oJumpForward 3854
3851: Choice Lookup Table
           0   3839
3854: oGetAddrLocal 3
3856: oPushResult
3857: oGetLocal 2
3859: oPushResult
3860: oSetResult 2
3862: oPushResult
3863: oNodeGetInt
3864: oPop 2
3866: oAssign
3867: oGetLocal 3
3869: oPushResult
3870: oSetResult 1
3872: oPushResult
3873: equal
3874: oPop 2
3876: oChoice 3890
3878: oEmit 9
3880: oGetLocal 3
3882: oPushResult
3883: oEmitInt
3884: oPop 1
3886: oEmit 23
3888: oJumpForward 3893
3890: Choice Lookup Table
           0   3878
3893: oEmit 25
3895: oInputChoice 3903
3897: oJumpForward 3911
3899: oJumpForward 3909
3901: oJumpForward 3909
3903: Choice Lookup Table
          12   3901
          16   3897
3908: oEndChoice
3909: oJumpBack 3781
3911: oReturn
3912: oLocalSpace 2
3914: oTypeSNodeType
3915: oChoice 3919
3917: oJumpForward 3924
3919: Choice Lookup Table
          26   3917
3922: oError 11
3924: oTypeSTop
3925: oPushResult
3926: oSetResult 24
3928: oPushResult
3929: oNodeGet
3930: oPop 2
3932: oPushResult
3933: oScopeEnter
3934: oPop 1
3936: oInput 0
3938: oGetAddrLocal 1
3940: oPushResult
3941: oScopeFindRequire
3942: oAssign
3943: oGetLocal 1
3945: oPushResult
3946: oNodeType
3947: oPop 1
3949: oChoice 3953
3951: oJumpForward 3958
3953: Choice Lookup Table
          14   3951
3956: oError 12
3958: oScopeEnd
3959: oGetAddrLocal 2
3961: oPushResult
3962: oGetLocal 1
3964: oPushResult
3965: oSetResult 7
3967: oPushResult
3968: oNodeGetInt
3969: oPop 2
3971: oAssign
3972: oGetLocal 2
3974: oPushResult
3975: equal_zero
3976: oPop 1
3978: oChoice 3992
3980: oEmit 9
3982: oGetLocal 2
3984: oPushResult
3985: oEmitInt
3986: oPop 1
3988: oEmit 25
3990: oJumpForward 3995
3992: Choice Lookup Table
           0   3980
3995: oTypeSPop
3996: oGetLocal 1
3998: oPushResult
3999: oSetResult 6
4001: oPushResult
4002: oNodeGet
4003: oPop 2
4005: oPushResult
4006: oTypeSPush
4007: oPop 1
4009: oReturn
4010: oLocalSpace 1
4012: oTypeSNodeType
4013: oChoice 4017
4015: oJumpForward 4022
4017: Choice Lookup Table
          23   4015
4020: oError 9
4022: oEmit 16
4024: oGetAddrLocal 1
4026: oPushResult
4027: oTypeSTop
4028: oAssign
4029: oTypeSPop
4030: oGetLocal 1
4032: oPushResult
4033: oSetResult 20
4035: oPushResult
4036: oNodeGet
4037: oPop 2
4039: oPushResult
4040: oTypeSPush
4041: oPop 1
4043: oReturn
4044: oLocalSpace 0
4046: oCall 5647
4048: oReturn
4049: oLocalSpace 11
4051: oGetParam 1
4053: oPushResult
4054: oSetResult 12
4056: oPushResult
4057: oNodeGetBoolean
4058: oPop 2
4060: oChoice 4112
4062: oGetParam 1
4064: oPushResult
4065: oSetResult 14
4067: oPushResult
4068: oNodeGetBoolean
4069: oPop 2
4071: oChoice 4107
4073: oGetAddrLocal 1
4075: oPushResult
4076: oGetParam 1
4078: oPushResult
4079: oSetResult 5
4081: oPushResult
4082: oNodeGetInt
4083: oPop 2
4085: oPushResult
4086: oStringAllocLitFromIdent
4087: oPop 1
4089: oAssign
4090: oEmit 50
4092: oGetParam 1
4094: oPushResult
4095: oCall 5924
4097: oPop 1
4099: oGetLocal 1
4101: oPushResult
4102: oEmitInt
4103: oPop 1
4105: oJumpForward 4110
4107: Choice Lookup Table
           0   4073
4110: oJumpForward 4115
4112: Choice Lookup Table
           1   4062
4115: oGetParam 1
4117: oPushResult
4118: oSetResult 14
4120: oPushResult
4121: oSetResult 1
4123: oPushResult
4124: oNodeSetBoolean
4125: oPop 3
4127: oGetAddrLocal 2
4129: oPushResult
4130: oGetParam 1
4132: oPushResult
4133: oSetResult 13
4135: oPushResult
4136: oNodeGetBoolean
4137: oPop 2
4139: oAssign
4140: oGetAddrLocal 5
4142: oPushResult
4143: oGetParam 1
4145: oPushResult
4146: oNodeType
4147: oPop 1
4149: oPushResult
4150: oSetResult 8
4152: oPushResult
4153: equal_node_type
4154: oPop 2
4156: oAssign
4157: oGetLocal 5
4159: oChoice 4186
4161: oGetAddrLocal 3
4163: oPushResult
4164: oGetParam 1
4166: oPushResult
4167: oSetResult 6
4169: oPushResult
4170: oNodeGet
4171: oPop 2
4173: oAssign
4174: oGetAddrLocal 4
4176: oPushResult
4177: oGetLocal 3
4179: oPushResult
4180: oScopeAllocType
4181: oPop 1
4183: oAssign
4184: oJumpForward 4189
4186: Choice Lookup Table
           1   4161
4189: oGetAddrLocal 6
4191: oPushResult
4192: oGetParam 1
4194: oPushResult
4195: oSetResult 9
4197: oPushResult
4198: oNodeGet
4199: oPop 2
4201: oAssign
4202: oGetAddrLocal 7
4204: oPushResult
4205: oGetLocal 6
4207: oPushResult
4208: oSetResult 2
4210: oPushResult
4211: oNodeGetInt
4212: oPop 2
4214: oAssign
4215: oGetLocal 2
4217: oChoice 4239
4219: oEmit 39
4221: oGetLocal 7
4223: oPushResult
4224: oEmitInt
4225: oPop 1
4227: oJumpForward 4245
4229: oEmit 38
4231: oGetLocal 7
4233: oPushResult
4234: oEmitInt
4235: oPop 1
4237: oJumpForward 4245
4239: Choice Lookup Table
           0   4229
           1   4219
4244: oEndChoice
4245: oGetAddrLocal 8
4247: oPushResult
4248: oGetLocal 6
4250: oPushResult
4251: oSetResult 1
4253: oPushResult
4254: oNodeGetIter
4255: oPop 2
4257: oAssign
4258: oGetAddrLocal 9
4260: oPushResult
4261: oGetLocal 8
4263: oPushResult
4264: oNodeIterValue
4265: oPop 1
4267: oAssign
4268: oInputChoice 4447
4270: oGetLocal 9
4272: oPushResult
4273: oNodeNull
4274: oPop 1
4276: oChoice 4282
4278: oJumpForward 4443
4280: oJumpForward 4285
4282: Choice Lookup Table
           1   4278
4285: oGetAddrLocal 10
4287: oPushResult
4288: oGetLocal 9
4290: oPushResult
4291: oSetResult 7
4293: oPushResult
4294: oNodeGetInt
4295: oPop 2
4297: oAssign
4298: oEmit 13
4300: oGetLocal 10
4302: oPushResult
4303: oEmitInt
4304: oPop 1
4306: oGetLocal 9
4308: oPushResult
4309: oSetResult 6
4311: oPushResult
4312: oNodeGet
4313: oPop 2
4315: oPushResult
4316: oTypeSPush
4317: oPop 1
4319: oGetLocal 9
4321: oPushResult
4322: oSetResult 18
4324: oPushResult
4325: oNodeGetBoolean
4326: oPop 2
4328: oChoice 4396
4330: oCall 4930
4332: oCall 5647
4334: oEmit 19
4336: oJumpForward 4402
4338: oCall 2069
4340: oCall 4044
4342: oTypeSNodeType
4343: oChoice 4361
4345: oEmit 17
4347: oJumpForward 4394
4349: oEmit 18
4351: oJumpForward 4394
4353: oError 16
4355: oJumpForward 4394
4357: oEmit 19
4359: oJumpForward 4394
4361: Choice Lookup Table
          23   4357
          17   4353
          22   4353
          21   4353
          19   4349
          18   4345
4374: oGetAddrLocal 11
4376: oPushResult
4377: oTypeSTop
4378: oPushResult
4379: oSetResult 2
4381: oPushResult
4382: oNodeGetInt
4383: oPop 2
4385: oAssign
4386: oEmit 20
4388: oGetLocal 11
4390: oPushResult
4391: oEmitInt
4392: oPop 1
4394: oJumpForward 4402
4396: Choice Lookup Table
           0   4338
           1   4330
4401: oEndChoice
4402: oTypeSPop
4403: oGetAddrLocal 8
4405: oPushResult
4406: oNodeIterNext
4407: oPop 1
4409: oGetAddrLocal 9
4411: oPushResult
4412: oGetLocal 8
4414: oPushResult
4415: oNodeIterValue
4416: oPop 1
4418: oAssign
4419: oGetLocal 9
4421: oPushResult
4422: oNodeNull
4423: oPop 1
4425: oChoice 4433
4427: oJumpForward 4443
4429: oJumpForward 4439
4431: oJumpForward 4439
4433: Choice Lookup Table
           0   4431
           1   4427
4438: oEndChoice
4439: oInput 12
4441: oJumpBack 4270
4443: oInput 14
4445: oJumpForward 4450
4447: Choice Lookup Table
          13   4270
4450: oGetLocal 9
4452: oPushResult
4453: oNodeNull
4454: oPop 1
4456: oChoice 4462
4458: oError 15
4460: oJumpForward 4465
4462: Choice Lookup Table
           0   4458
4465: oGetLocal 5
4467: oChoice 4496
4469: oEmit 13
4471: oGetParam 1
4473: oPushResult
4474: oSetResult 17
4476: oPushResult
4477: oNodeGetInt
4478: oPop 2
4480: oPushResult
4481: oEmitInt
4482: oPop 1
4484: oEmit 11
4486: oGetLocal 4
4488: oPushResult
4489: oEmitInt
4490: oPop 1
4492: oEmit 19
4494: oJumpForward 4499
4496: Choice Lookup Table
           1   4469
4499: oGetLocal 2
4501: oChoice 4525
4503: oEmit 42
4505: oGetParam 1
4507: oPushResult
4508: oCall 5924
4510: oPop 1
4512: oJumpForward 4531
4514: oEmit 41
4516: oGetParam 1
4518: oPushResult
4519: oCall 5924
4521: oPop 1
4523: oJumpForward 4531
4525: Choice Lookup Table
           0   4514
           1   4503
4530: oEndChoice
4531: oGetLocal 5
4533: oChoice 4601
4535: oGetLocal 3
4537: oPushResult
4538: oTypeSPush
4539: oPop 1
4541: oTypeSNodeType
4542: oChoice 4578
4544: oEmit 3
4546: oGetLocal 4
4548: oPushResult
4549: oEmitInt
4550: oPop 1
4552: oJumpForward 4599
4554: oEmit 4
4556: oGetLocal 4
4558: oPushResult
4559: oEmitInt
4560: oPop 1
4562: oJumpForward 4599
4564: oError 16
4566: oJumpForward 4599
4568: oEmit 5
4570: oGetLocal 4
4572: oPushResult
4573: oEmitInt
4574: oPop 1
4576: oJumpForward 4599
4578: Choice Lookup Table
          23   4568
          17   4564
          22   4564
          21   4564
          19   4554
          18   4544
4591: oEmit 11
4593: oGetLocal 4
4595: oPushResult
4596: oEmitInt
4597: oPop 1
4599: oJumpForward 4604
4601: Choice Lookup Table
           1   4535
4604: oEmit 40
4606: oGetLocal 7
4608: oPushResult
4609: oEmitInt
4610: oPop 1
4612: oReturn
4613: oLocalSpace 0
4615: oInputChoice 4665
4617: oCall 5567
4619: oJumpForward 4690
4621: oCall 5574
4623: oJumpForward 4690
4625: oCall 5641
4627: oJumpForward 4690
4629: oCall 5644
4631: oJumpForward 4690
4633: oCall 5107
4635: oJumpForward 4690
4637: oCall 5427
4639: oJumpForward 4690
4641: oCall 5173
4643: oJumpForward 4690
4645: oCall 5347
4647: oJumpForward 4690
4649: oCall 5512
4651: oJumpForward 4690
4653: oCall 5480
4655: oJumpForward 4690
4657: oCall 5544
4659: oJumpForward 4690
4661: oCall 4691
4663: oJumpForward 4690
4665: Choice Lookup Table
           0   4661
          33   4657
          49   4653
          50   4649
          47   4645
          42   4641
          46   4637
          39   4633
          57   4629
          56   4625
          55   4621
          54   4617
4690: oReturn
4691: oLocalSpace 1
4693: oGetAddrLocal 1
4695: oPushResult
4696: oScopeFindRequire
4697: oAssign
4698: oGetLocal 1
4700: oPushResult
4701: oNodeType
4702: oPop 1
4704: oChoice 4733
4706: oGetLocal 1
4708: oPushResult
4709: oCall 4049
4711: oPop 1
4713: oJumpForward 4746
4715: oGetLocal 1
4717: oPushResult
4718: oCall 4747
4720: oPop 1
4722: oJumpForward 4746
4724: oGetLocal 1
4726: oPushResult
4727: oCall 4816
4729: oPop 1
4731: oJumpForward 4746
4733: Choice Lookup Table
           8   4724
          15   4715
          13   4715
          12   4715
           7   4706
4744: oError 0
4746: oReturn
4747: oLocalSpace 1
4749: oGetParam 1
4751: oPushResult
4752: oCall 4966
4754: oPop 1
4756: oInput 3
4758: oCall 2069
4760: oCall 5647
4762: oTypeSNodeType
4763: oChoice 4781
4765: oEmit 17
4767: oJumpForward 4814
4769: oEmit 18
4771: oJumpForward 4814
4773: oError 16
4775: oJumpForward 4814
4777: oEmit 19
4779: oJumpForward 4814
4781: Choice Lookup Table
          23   4777
          17   4773
          22   4773
          21   4773
          19   4769
          18   4765
4794: oGetAddrLocal 1
4796: oPushResult
4797: oTypeSTop
4798: oPushResult
4799: oSetResult 2
4801: oPushResult
4802: oNodeGetInt
4803: oPop 2
4805: oAssign
4806: oEmit 20
4808: oGetLocal 1
4810: oPushResult
4811: oEmitInt
4812: oPop 1
4814: oTypeSPop
4815: oReturn
4816: oLocalSpace 1
4818: oGetParam 1
4820: oPushResult
4821: oSetResult 10
4823: oPushResult
4824: oNodeGet
4825: oPop 2
4827: oPushResult
4828: oScopeCurrent
4829: oPushResult
4830: oNodeEqual
4831: oPop 2
4833: oChoice 4839
4835: oError 20
4837: oJumpForward 4842
4839: Choice Lookup Table
           0   4835
4842: oEmit 8
4844: oGetParam 1
4846: oPushResult
4847: oSetResult 17
4849: oPushResult
4850: oNodeGetInt
4851: oPop 2
4853: oPushResult
4854: oEmitInt
4855: oPop 1
4857: oGetParam 1
4859: oPushResult
4860: oSetResult 6
4862: oPushResult
4863: oNodeGet
4864: oPop 2
4866: oPushResult
4867: oTypeSPush
4868: oPop 1
4870: oInput 3
4872: oCall 2069
4874: oCall 5647
4876: oTypeSNodeType
4877: oChoice 4895
4879: oEmit 17
4881: oJumpForward 4928
4883: oEmit 18
4885: oJumpForward 4928
4887: oError 16
4889: oJumpForward 4928
4891: oEmit 19
4893: oJumpForward 4928
4895: Choice Lookup Table
          23   4891
          17   4887
          22   4887
          21   4887
          19   4883
          18   4879
4908: oGetAddrLocal 1
4910: oPushResult
4911: oTypeSTop
4912: oPushResult
4913: oSetResult 2
4915: oPushResult
4916: oNodeGetInt
4917: oPop 2
4919: oAssign
4920: oEmit 20
4922: oGetLocal 1
4924: oPushResult
4925: oEmitInt
4926: oPop 1
4928: oTypeSPop
4929: oReturn
4930: oLocalSpace 1
4932: oInput 0
4934: oGetAddrLocal 1
4936: oPushResult
4937: oScopeFindRequire
4938: oAssign
4939: oGetLocal 1
4941: oPushResult
4942: oNodeType
4943: oPop 1
4945: oChoice 4949
4947: oJumpForward 4958
4949: Choice Lookup Table
          15   4947
          13   4947
          12   4947
4956: oError 4
4958: oGetLocal 1
4960: oPushResult
4961: oCall 4966
4963: oPop 1
4965: oReturn
4966: oLocalSpace 0
4968: oGetParam 1
4970: oPushResult
4971: oNodeType
4972: oPop 1
4974: oChoice 5034
4976: oEmit 10
4978: oGetParam 1
4980: oPushResult
4981: oCall 5924
4983: oPop 1
4985: oJumpForward 5043
4987: oEmit 11
4989: oGetParam 1
4991: oPushResult
4992: oCall 5924
4994: oPop 1
4996: oJumpForward 5043
4998: oGetParam 1
5000: oPushResult
5001: oSetResult 18
5003: oPushResult
5004: oNodeGetBoolean
5005: oPop 2
5007: oChoice 5020
5009: oEmit 8
5011: oGetParam 1
5013: oPushResult
5014: oCall 5924
5016: oPop 1
5018: oJumpForward 5032
5020: Choice Lookup Table
           1   5009
5023: oEmit 12
5025: oGetParam 1
5027: oPushResult
5028: oCall 5924
5030: oPop 1
5032: oJumpForward 5043
5034: Choice Lookup Table
          15   4998
          13   4987
          12   4976
5041: oError 4
5043: oGetParam 1
5045: oPushResult
5046: oSetResult 6
5048: oPushResult
5049: oNodeGet
5050: oPop 2
5052: oPushResult
5053: oTypeSPush
5054: oPop 1
5056: oCall 3741
5058: oReturn
5059: oLocalSpace 0
5061: oGetParam 1
5063: oPushResult
5064: oCall 4966
5066: oPop 1
5068: oCall 5673
5070: oGetParam 1
5072: oPushResult
5073: oCall 3327
5075: oPop 1
5077: oTypeSPop
5078: oEmit 21
5080: oEmit 17
5082: oReturn
5083: oLocalSpace 0
5085: oGetParam 1
5087: oPushResult
5088: oCall 4966
5090: oPop 1
5092: oCall 5673
5094: oGetParam 1
5096: oPushResult
5097: oCall 3327
5099: oPop 1
5101: oTypeSPop
5102: oEmit 22
5104: oEmit 17
5106: oReturn
5107: oLocalSpace 2
5109: oGetAddrLocal 1
5111: oPushResult
5112: oSetResult 0
5114: oAssign
5115: oGetAddrLocal 1
5117: oPushResult
5118: oCall 2092
5120: oPop 1
5122: oInput 40
5124: oCall 4613
5126: oInputChoice 5161
5128: oGetAddrLocal 2
5130: oPushResult
5131: oLabelNew
5132: oAssign
5133: oEmit 45
5135: oGetLocal 2
5137: oPushResult
5138: oEmitLabel
5139: oPop 1
5141: oEmit 48
5143: oGetLocal 1
5145: oPushResult
5146: oEmitLabel
5147: oPop 1
5149: oCall 4613
5151: oEmit 48
5153: oGetLocal 2
5155: oPushResult
5156: oEmitLabel
5157: oPop 1
5159: oJumpForward 5172
5161: Choice Lookup Table
          41   5128
5164: oEmit 48
5166: oGetLocal 1
5168: oPushResult
5169: oEmitLabel
5170: oPop 1
5172: oReturn
5173: oLocalSpace 4
5175: oInput 0
5177: oGetAddrLocal 1
5179: oPushResult
5180: oScopeFindRequire
5181: oAssign
5182: oGetLocal 1
5184: oPushResult
5185: oCall 4966
5187: oPop 1
5189: oCall 5673
5191: oInput 3
5193: oCall 2069
5195: oCall 5673
5197: oEmit 17
5199: oGetAddrLocal 2
5201: oPushResult
5202: oLabelNew
5203: oAssign
5204: oGetAddrLocal 3
5206: oPushResult
5207: oLabelNew
5208: oAssign
5209: oEmit 45
5211: oGetLocal 3
5213: oPushResult
5214: oEmitLabel
5215: oPop 1
5217: oGetAddrLocal 4
5219: oPushResult
5220: oLabelNew
5221: oAssign
5222: oEmit 48
5224: oGetLocal 4
5226: oPushResult
5227: oEmitLabel
5228: oPop 1
5230: oInputChoice 5310
5232: oGetLocal 1
5234: oPushResult
5235: oCall 5059
5237: oPop 1
5239: oEmit 48
5241: oGetLocal 3
5243: oPushResult
5244: oEmitLabel
5245: oPop 1
5247: oGetLocal 1
5249: oPushResult
5250: oCall 3327
5252: oPop 1
5254: oTypeSPop
5255: oCall 2069
5257: oCall 5673
5259: oEmit 32
5261: oEmit 46
5263: oGetLocal 2
5265: oPushResult
5266: oEmitLabel
5267: oPop 1
5269: oJumpForward 5316
5271: oGetLocal 1
5273: oPushResult
5274: oCall 5083
5276: oPop 1
5278: oEmit 48
5280: oGetLocal 3
5282: oPushResult
5283: oEmitLabel
5284: oPop 1
5286: oGetLocal 1
5288: oPushResult
5289: oCall 3327
5291: oPop 1
5293: oTypeSPop
5294: oCall 2069
5296: oCall 5673
5298: oEmit 33
5300: oEmit 46
5302: oGetLocal 2
5304: oPushResult
5305: oEmitLabel
5306: oPop 1
5308: oJumpForward 5316
5310: Choice Lookup Table
          44   5271
          43   5232
5315: oEndChoice
5316: oGetLocal 4
5318: oPushResult
5319: oGetLocal 2
5321: oPushResult
5322: oLoopPush
5323: oPop 2
5325: oInput 45
5327: oCall 4613
5329: oEmit 45
5331: oGetLocal 4
5333: oPushResult
5334: oEmitLabel
5335: oPop 1
5337: oEmit 48
5339: oGetLocal 2
5341: oPushResult
5342: oEmitLabel
5343: oPop 1
5345: oLoopPop
5346: oReturn
5347: oLocalSpace 3
5349: oGetAddrLocal 1
5351: oPushResult
5352: oLabelNew
5353: oAssign
5354: oEmit 48
5356: oGetLocal 1
5358: oPushResult
5359: oEmitLabel
5360: oPop 1
5362: oGetAddrLocal 2
5364: oPushResult
5365: oLabelNew
5366: oAssign
5367: oGetLocal 1
5369: oPushResult
5370: oGetLocal 2
5372: oPushResult
5373: oLoopPush
5374: oPop 2
5376: oCall 4613
5378: oInputChoice 5409
5380: oCall 4613
5382: oJumpForward 5415
5384: oGetAddrLocal 3
5386: oPushResult
5387: oCall 2092
5389: oPop 1
5391: oEmit 49
5393: oGetLocal 3
5395: oPushResult
5396: oEmitLabel
5397: oPop 1
5399: oGetLocal 1
5401: oPushResult
5402: oEmitLabel
5403: oPop 1
5405: oJumpForward 5417
5407: oJumpForward 5415
5409: Choice Lookup Table
          48   5384
           4   5380
5414: oEndChoice
5415: oJumpBack 5378
5417: oEmit 48
5419: oGetLocal 2
5421: oPushResult
5422: oEmitLabel
5423: oPop 1
5425: oLoopPop
5426: oReturn
5427: oLocalSpace 2
5429: oGetAddrLocal 1
5431: oPushResult
5432: oLabelNew
5433: oAssign
5434: oEmit 48
5436: oGetLocal 1
5438: oPushResult
5439: oEmitLabel
5440: oPop 1
5442: oGetAddrLocal 2
5444: oPushResult
5445: oCall 2092
5447: oPop 1
5449: oGetLocal 1
5451: oPushResult
5452: oGetLocal 2
5454: oPushResult
5455: oLoopPush
5456: oPop 2
5458: oInput 45
5460: oCall 4613
5462: oEmit 45
5464: oGetLocal 1
5466: oPushResult
5467: oEmitLabel
5468: oPop 1
5470: oEmit 48
5472: oGetLocal 2
5474: oPushResult
5475: oEmitLabel
5476: oPop 1
5478: oLoopPop
5479: oReturn
5480: oLocalSpace 0
5482: oLoopContinueLabel
5483: oPushResult
5484: oSetResult 0
5486: oPushResult
5487: equal_label
5488: oPop 2
5490: oChoice 5505
5492: oError 18
5494: oJumpForward 5511
5496: oEmit 45
5498: oLoopContinueLabel
5499: oPushResult
5500: oEmitLabel
5501: oPop 1
5503: oJumpForward 5511
5505: Choice Lookup Table
           0   5496
           1   5492
5510: oEndChoice
5511: oReturn
5512: oLocalSpace 0
5514: oLoopBreakLabel
5515: oPushResult
5516: oSetResult 0
5518: oPushResult
5519: equal_label
5520: oPop 2
5522: oChoice 5537
5524: oError 18
5526: oJumpForward 5543
5528: oEmit 45
5530: oLoopBreakLabel
5531: oPushResult
5532: oEmitLabel
5533: oPop 1
5535: oJumpForward 5543
5537: Choice Lookup Table
           0   5528
           1   5524
5542: oEndChoice
5543: oReturn
5544: oLocalSpace 0
5546: oCall 4613
5548: oInputChoice 5558
5550: oCall 4613
5552: oJumpForward 5564
5554: oJumpForward 5566
5556: oJumpForward 5564
5558: Choice Lookup Table
          34   5554
           4   5550
5563: oEndChoice
5564: oJumpBack 5548
5566: oReturn
5567: oLocalSpace 0
5569: oCall 5574
5571: oEmit 55
5573: oReturn
5574: oLocalSpace 0
5576: oInputChoice 5637
5578: oCall 2069
5580: oTypeSNodeType
5581: oChoice 5603
5583: oEmit 51
5585: oJumpForward 5618
5587: oEmit 52
5589: oJumpForward 5618
5591: oEmit 53
5593: oJumpForward 5618
5595: oError 16
5597: oJumpForward 5618
5599: oEmit 54
5601: oJumpForward 5618
5603: Choice Lookup Table
          23   5599
          17   5595
          21   5595
          22   5591
          19   5587
          18   5583
5616: oError 17
5618: oTypeSPop
5619: oInputChoice 5627
5621: oJumpForward 5635
5623: oJumpForward 5633
5625: oJumpForward 5633
5627: Choice Lookup Table
          12   5625
          14   5621
5632: oEndChoice
5633: oJumpBack 5578
5635: oJumpForward 5640
5637: Choice Lookup Table
          13   5578
5640: oReturn
5641: oLocalSpace 0
5643: oReturn
5644: oLocalSpace 0
5646: oReturn
5647: oLocalSpace 1
5649: oGetAddrLocal 1
5651: oPushResult
5652: oTypeSNodeType
5653: oAssign
5654: oTypeSPop
5655: oGetLocal 1
5657: oPushResult
5658: oTypeSNodeType
5659: oPushResult
5660: equal_node_type
5661: oPop 2
5663: oChoice 5669
5665: oError 14
5667: oJumpForward 5672
5669: Choice Lookup Table
           0   5665
5672: oReturn
5673: oLocalSpace 0
5675: oTypeSNodeType
5676: oChoice 5680
5678: oJumpForward 5685
5680: Choice Lookup Table
          18   5678
5683: oError 7
5685: oTypeSPop
5686: oReturn
5687: oLocalSpace 0
5689: oTypeSNodeType
5690: oChoice 5694
5692: oJumpForward 5699
5694: Choice Lookup Table
          18   5692
5697: oError 7
5699: oReturn
5700: oLocalSpace 0
5702: oTypeSNodeType
5703: oChoice 5707
5705: oJumpForward 5712
5707: Choice Lookup Table
          19   5705
5710: oError 8
5712: oTypeSPop
5713: oReturn
5714: oLocalSpace 0
5716: oTypeSNodeType
5717: oChoice 5721
5719: oJumpForward 5726
5721: Choice Lookup Table
          19   5719
5724: oError 8
5726: oReturn
5727: oLocalSpace 1
5729: oGetAddrLocal 1
5731: oPushResult
5732: oGetParam 2
5734: oPushResult
5735: oNodeNew
5736: oPop 1
5738: oAssign
5739: oGetLocal 1
5741: oPushResult
5742: oSetResult 2
5744: oPushResult
5745: oGetParam 1
5747: oPushResult
5748: oNodeSetInt
5749: oPop 3
5751: oGetLocal 1
5753: oPushResult
5754: oTypeAdd
5755: oPop 1
5757: oGetLocal 1
5759: oReturn
5760: oReturn
5761: oLocalSpace 1
5763: oGetAddrLocal 1
5765: oPushResult
5766: oGetParam 3
5768: oPushResult
5769: oNodeNew
5770: oPop 1
5772: oAssign
5773: oGetLocal 1
5775: oPushResult
5776: oSetResult 5
5778: oPushResult
5779: oGetParam 1
5781: oPushResult
5782: oNodeSetInt
5783: oPop 3
5785: oGetLocal 1
5787: oReturn
5788: oReturn
5789: oLocalSpace 1
5791: oGetAddrLocal 1
5793: oPushResult
5794: oGetParam 1
5796: oPushResult
5797: oSetResult 19
5799: oPushResult
5800: oNodeGet
5801: oPop 2
5803: oAssign
5804: oGetLocal 1
5806: oPushResult
5807: oNodeNull
5808: oPop 1
5810: oChoice 5866
5812: oGetAddrLocal 1
5814: oPushResult
5815: oSetResult 23
5817: oPushResult
5818: oNodeNew
5819: oPop 1
5821: oAssign
5822: oGetLocal 1
5824: oPushResult
5825: oSetResult 20
5827: oPushResult
5828: oGetParam 1
5830: oPushResult
5831: oNodeSet
5832: oPop 3
5834: oGetLocal 1
5836: oPushResult
5837: oSetResult 2
5839: oPushResult
5840: oSetResult 8
5842: oPushResult
5843: oNodeSetInt
5844: oPop 3
5846: oGetLocal 1
5848: oPushResult
5849: oTypeAdd
5850: oPop 1
5852: oGetParam 1
5854: oPushResult
5855: oSetResult 19
5857: oPushResult
5858: oGetLocal 1
5860: oPushResult
5861: oNodeSet
5862: oPop 3
5864: oJumpForward 5869
5866: Choice Lookup Table
           1   5812
5869: oGetLocal 1
5871: oReturn
5872: oReturn
5873: oLocalSpace 0
5875: oGetParam 1
5877: oPushResult
5878: oNodeType
5879: oPop 1
5881: oChoice 5909
5883: oMININT
5884: oReturn
5885: oJumpForward 5923
5887: oSetResult 0
5889: oReturn
5890: oJumpForward 5923
5892: oSetResult 0
5894: oReturn
5895: oJumpForward 5923
5897: oGetParam 1
5899: oPushResult
5900: oSetResult 22
5902: oPushResult
5903: oNodeGetInt
5904: oPop 2
5906: oReturn
5907: oJumpForward 5923
5909: Choice Lookup Table
          25   5897
          21   5892
          19   5887
          18   5883
5918: oError 3
5920: oSetResult 0
5922: oReturn
5923: oReturn
5924: oLocalSpace 0
5926: oGetParam 1
5928: oPushResult
5929: oSetResult 7
5931: oPushResult
5932: oNodeGetInt
5933: oPop 2
5935: oPushResult
5936: oEmitInt
5937: oPop 1
5939: oReturn
5940: oLocalSpace 1
5942: oGetAddrGlobal 2
5944: oPushResult
5945: oSetResult 17
5947: oPushResult
5948: oSetResult 4
5950: oPushResult
5951: oCall 5727
5953: oPop 2
5955: oAssign
5956: oGetAddrGlobal 3
5958: oPushResult
5959: oSetResult 18
5961: oPushResult
5962: oSetResult 4
5964: oPushResult
5965: oCall 5727
5967: oPop 2
5969: oAssign
5970: oGetAddrGlobal 4
5972: oPushResult
5973: oSetResult 19
5975: oPushResult
5976: oSetResult 1
5978: oPushResult
5979: oCall 5727
5981: oPop 2
5983: oAssign
5984: oGetAddrGlobal 5
5986: oPushResult
5987: oSetResult 20
5989: oPushResult
5990: oSetResult 1
5992: oPushResult
5993: oCall 5727
5995: oPop 2
5997: oAssign
5998: oGetAddrGlobal 6
6000: oPushResult
6001: oSetResult 21
6003: oPushResult
6004: oSetResult 1
6006: oPushResult
6007: oCall 5727
6009: oPop 2
6011: oAssign
6012: oGetAddrGlobal 7
6014: oPushResult
6015: oSetResult 22
6017: oPushResult
6018: oSetResult 256
6020: oPushResult
6021: oCall 5727
6023: oPop 2
6025: oAssign
6026: oGetAddrLocal 1
6028: oPushResult
6029: oSetResult 10
6031: oPushResult
6032: oSetResult 5
6034: oPushResult
6035: oIdAdd_File
6036: oPushResult
6037: oCall 5761
6039: oPop 3
6041: oAssign
6042: oGetLocal 1
6044: oPushResult
6045: oSetResult 6
6047: oPushResult
6048: oGetGlobal 2
6050: oPushResult
6051: oNodeSet
6052: oPop 3
6054: oGetLocal 1
6056: oPushResult
6057: oScopeDeclare
6058: oPop 1
6060: oGetAddrLocal 1
6062: oPushResult
6063: oSetResult 10
6065: oPushResult
6066: oSetResult 5
6068: oPushResult
6069: oIdAdd_Integer
6070: oPushResult
6071: oCall 5761
6073: oPop 3
6075: oAssign
6076: oGetLocal 1
6078: oPushResult
6079: oSetResult 6
6081: oPushResult
6082: oGetGlobal 3
6084: oPushResult
6085: oNodeSet
6086: oPop 3
6088: oGetLocal 1
6090: oPushResult
6091: oScopeDeclare
6092: oPop 1
6094: oGetAddrLocal 1
6096: oPushResult
6097: oSetResult 10
6099: oPushResult
6100: oSetResult 5
6102: oPushResult
6103: oIdAdd_Boolean
6104: oPushResult
6105: oCall 5761
6107: oPop 3
6109: oAssign
6110: oGetLocal 1
6112: oPushResult
6113: oSetResult 6
6115: oPushResult
6116: oGetGlobal 4
6118: oPushResult
6119: oNodeSet
6120: oPop 3
6122: oGetLocal 1
6124: oPushResult
6125: oScopeDeclare
6126: oPop 1
6128: oGetAddrLocal 1
6130: oPushResult
6131: oSetResult 10
6133: oPushResult
6134: oSetResult 5
6136: oPushResult
6137: oIdAdd_Char
6138: oPushResult
6139: oCall 5761
6141: oPop 3
6143: oAssign
6144: oGetLocal 1
6146: oPushResult
6147: oSetResult 6
6149: oPushResult
6150: oGetGlobal 6
6152: oPushResult
6153: oNodeSet
6154: oPop 3
6156: oGetLocal 1
6158: oPushResult
6159: oScopeDeclare
6160: oPop 1
6162: oGetAddrLocal 1
6164: oPushResult
6165: oSetResult 10
6167: oPushResult
6168: oSetResult 5
6170: oPushResult
6171: oIdAdd_String
6172: oPushResult
6173: oCall 5761
6175: oPop 3
6177: oAssign
6178: oGetLocal 1
6180: oPushResult
6181: oSetResult 6
6183: oPushResult
6184: oGetGlobal 7
6186: oPushResult
6187: oNodeSet
6188: oPop 3
6190: oGetLocal 1
6192: oPushResult
6193: oScopeDeclare
6194: oPop 1
6196: oGetAddrLocal 1
6198: oPushResult
6199: oSetResult 9
6201: oPushResult
6202: oSetResult 4
6204: oPushResult
6205: oIdAdd_True
6206: oPushResult
6207: oCall 5761
6209: oPop 3
6211: oAssign
6212: oGetLocal 1
6214: oPushResult
6215: oSetResult 6
6217: oPushResult
6218: oGetGlobal 4
6220: oPushResult
6221: oNodeSet
6222: oPop 3
6224: oGetLocal 1
6226: oPushResult
6227: oSetResult 7
6229: oPushResult
6230: oSetResult 1
6232: oPushResult
6233: oNodeSetInt
6234: oPop 3
6236: oGetLocal 1
6238: oPushResult
6239: oScopeDeclare
6240: oPop 1
6242: oGetAddrLocal 1
6244: oPushResult
6245: oSetResult 9
6247: oPushResult
6248: oSetResult 4
6250: oPushResult
6251: oIdAdd_False
6252: oPushResult
6253: oCall 5761
6255: oPop 3
6257: oAssign
6258: oGetLocal 1
6260: oPushResult
6261: oSetResult 6
6263: oPushResult
6264: oGetGlobal 4
6266: oPushResult
6267: oNodeSet
6268: oPop 3
6270: oGetLocal 1
6272: oPushResult
6273: oSetResult 7
6275: oPushResult
6276: oSetResult 0
6278: oPushResult
6279: oNodeSetInt
6280: oPop 3
6282: oGetLocal 1
6284: oPushResult
6285: oScopeDeclare
6286: oPop 1
6288: oReturn
