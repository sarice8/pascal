   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tGreaterD         % double comparisions.  (equality uses EqualP, at least for now)
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nDoubleType :
2586:          decl = @newIdent( nConstDouble, id )
2600:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2611:       | nStrLitType :
2613:          decl = @newIdent( nConstStr, id )
2627:          oNodeSetString( decl, qValueStr, oValueTopString )
2638:       | * :  #eNotAllowed
2661:    ]
2661:    oValuePop
2662:    oNodeSet( decl, qType, oTypeSTop )
2673:    oTypeSPop
2674:    oScopeDeclare( decl )
2680:    ';'
2683:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2683: TypedConstDecl:
2685:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2698:    Node theType
2698:    @TypeRef( theType )
2705:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2717:    [ oNodeType( theType )
2724:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2725:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2725:          '='
      
2727:          oTypeSPush( theType )
2733:          @ConstExpr
2735:          @ConstCoerceType
      
2737:          oNodeSetInt( decl, qValue, oValueTop )
2748:          oValuePop
2749:          oTypeSPop
2750:          oScopeDeclare( decl )
2756:          ';'
      
2758:       | nShortStringType, nFileType :
2760:          #eNotImplemented
      
2762:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2764:          oScopeEnter( globalScope )
2770:          int addr = oScopeAllocType( theType )
2780:          oScopeEnd
2781:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2792:          oNodeSetInt( decl, qValue, addr )
2804:          '='
2806:          @TypedConstInit( theType, addr )
2816:          oCodePop
2817:          oScopeDeclare( decl )
2823:          ';'
2825:    ]
2852:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2852: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2854:    [ oNodeType( theType )
2861:       | nArrayType :
2862:          Node baseType = oNodeGet( theType, qBaseType )
2875:          Node indexType = oNodeGet( theType, qIndexType )
2888:          int low = @OrdinalLow( indexType )
2899:          int high = @OrdinalHigh( indexType )
2910:          int elementSize = oNodeGetInt( baseType, qSize )
      
2923:          '('
               % Loop over elements
2925:          int i = low
2931:          {
2931:             @TypedConstInit( baseType, addr )
2941:             [ equal( i, high )
2951:                | true : >
2954:                | false :
2956:             ]
2964:             ','
2966:             addr = add( addr, elementSize )
2979:             inc( i )
2985:          }
2987:          ')'
      
2989:       | nRecordType :
2991:          '('
2993:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3006:          {
3006:             [
3006:                | pIdent :
3008:                | * :  >
3015:             ]
3015:             Node field = oScopeFindRequireInScope( fieldScope )
3025:             ':'
3027:             Node fieldType = oNodeGet( field, qType )
3040:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3060:             @TypedConstInit( fieldType, fieldAddr )
3070:             [
3070:                | ';' :
3072:                | * :  >
3079:             ]
3079:          }
3081:          ')'
      
3083:       | nBooleanType, nByteType, nCharType:
3085:          .tPushAddrGlobal  oEmitInt( addr )
3093:          oTypeSPush( theType )
3099:          @ConstExpr
3101:          @ConstCoerceType
3103:          .tPushConstI  oEmitInt( oValueTop )
3110:          oValuePop
3111:          oTypeSPop
3112:          .tAssignB
      
3114:       | nIntegerType, nEnumType:
3116:          .tPushAddrGlobal  oEmitInt( addr )
3124:          oTypeSPush( theType )
3130:          @ConstExpr
3132:          @ConstCoerceType
3134:          .tPushConstI  oEmitInt( oValueTop )
3141:          oValuePop
3142:          oTypeSPop
3143:          .tAssignI
      
3145:       | nDoubleType:
3147:          #eNotImplemented
      
3149:       | nPointerType, nUniversalPointerType :
3151:          .tPushAddrGlobal  oEmitInt( addr )
3159:          oTypeSPush( theType )
3165:          @ConstExpr
3167:          @ConstCoerceType
3169:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3176:          oValuePop
3177:          oTypeSPop
3178:          .tAssignP
      
3180:       | nShortStringType, nFileType :
3182:          #eNotImplemented
3184:    ]
3213:    ;
      
      
3213: TypeDecl:
3215:    {[
3215:       | pIdent :
3217:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3230:          '='
3232:          Node theType
3232:          @TypeRef( theType )
3239:          oNodeSet( decl, qType, theType )
3251:          oScopeDeclare( decl )
3257:          ';'
3259:       | * :
3264:          >
3266:    ]};
      
3269: VarDecl( node_type varNodeType ):
3271:    {[
3271:       | pIdent :
3273:          NodeVec decls = oNodeVecNew
3278:          Node decl
3278:          {
3278:             decl = @newIdent( varNodeType, LAST_ID )
3291:             oNodeVecAppend( decls, decl )
3300:             [
3300:                | ',' :
3302:                   pIdent
3304:                | * :
3309:                   >
3311:             ]
3311:          }
3313:          ':'
3315:          Node theType
3315:          @TypeRef( theType )
      
3322:          int i = 0
3328:          {[ equal( i, oNodeVecSize( decls ) )
3342:             | false :
3343:                decl = oNodeVecElement( decls, i )
3356:                oNodeSet( decl, qType, theType )
3368:                oScopeDeclareAlloc( decl )
3374:                inc( i )
3380:             | * :
3385:               >
3387:          ]}
      
               % optional initialization
3389:          [
3389:             | '=' :
3391:                [ oNodeVecSize( decls )
3398:                   | 1 :
3399:                   | * :  #eOnlyOneVarCanBeInitialized
3406:                ]
      
                     % we need an initCode stream for this scope
3406:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3416:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3422:                boolean changedScope = false
3428:                [ equal_zero( @ScopeLevel )
3435:                   | true : oScopeEnter( initScope )
3442:                            changedScope = true
3448:                   | * :
3453:                ]
                     % generate assignment in initCode stream
3453:                @LValueVar( decl, true )
3463:                @Expr
3465:                @CoerceType
3467:                @Assign
3469:                [ changedScope
3472:                   | true : oScopeEnd
3474:                   | * :
3479:                ]
3479:                oCodePop
                   
3480:             | * :
3485:          ]
      
3485:          oNodeVecDelete( decls )
3491:          ';'
3493:       | * :
3498:          >
3500:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3503: LabelDecl:
3505:    {
3505:       Node decl
3505:       [
3505:          | pIdent :
3507:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3509:             oChangeIntLitToLabelIdent
3510:       ]
3518:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3531:       Label label = oLabelNew
3536:       oNodeSetLabel( decl, qValue, label )
3548:       oScopeDeclare( decl )
3554:       [
3554:          | ',' :
3556:          | * :
3561:             >
3563:       ]
3563:    }
3565:    ';'
3568:    ;
3568: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3568: ConstExpr:
3570:    @ConstBoolExpr
3572:    {[
3572:       | '=' :
3574:          @ConstBoolTerm
3576:          @ConstMatchTypes
3578:          [ oTypeSNodeType
3580:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3589:             | * :             oValueEqual
3595:          ]
3595:          oTypeSPop  oTypeSPush( BooleanType )
3602:       | '<>' :
3604:          @ConstBoolExpr
3606:          @ConstMatchTypes
3608:          [ oTypeSNodeType
3610:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3619:             | * :             oValueNotEqual
3625:          ]
3625:          oTypeSPop  oTypeSPush( BooleanType )
3632:       | '<' :
3634:          @ConstBoolExpr
3636:          @ConstMatchTypes
3638:          [ oTypeSNodeType
3640:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3649:             | * :             oValueLess
3655:          ]
3655:          oTypeSPop  oTypeSPush( BooleanType )
3662:       | '>' :
3664:          @ConstBoolExpr
3666:          @ConstMatchTypes
3668:          [ oTypeSNodeType
3670:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3679:             | * :             oValueGreater
3685:          ]
3685:          oTypeSPop  oTypeSPush( BooleanType )
3692:       | '<=' :
3694:          @ConstBoolExpr
3696:          @ConstMatchTypes
3698:          [ oTypeSNodeType
3700:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3709:             | * :             oValueLessEqual
3715:          ]
3715:          oTypeSPop  oTypeSPush( BooleanType )
3722:       | '>=' :
3724:          @ConstBoolExpr
3726:          @ConstMatchTypes
3728:          [ oTypeSNodeType
3730:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3739:             | * :             oValueGreaterEqual
3745:          ]
3745:          oTypeSPop  oTypeSPush( BooleanType )
3752:       | * :  >
3769:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3772: ConstExprAllowTypeName:
3774:    boolean oldAllowTypeName = flagExprAllowTypeName
3780:    flagExprAllowTypeName = true
3786:    @ConstExpr
3788:    flagExprAllowTypeName = oldAllowTypeName
3795:    ;
      
      
3795: ConstBoolExpr:
3797:    @ConstBoolTerm
3799:    {[
3799:       | pOr :
3801:          @ConstRequireBool
3803:          @ConstBoolTerm
3805:          @ConstRequireBoolPop
3807:          oValueOr
3808:       | * :  >
3815:    ]};
      
      
3818: ConstBoolTerm:
3820:    @ConstBoolFactor
3822:    {[
3822:       | pAnd :
3824:          @ConstRequireBool
3826:          @ConstBoolFactor
3828:          @ConstRequireBoolPop
3830:          oValueAnd
3831:       | * :  >
3838:    ]};
      
      
3841: ConstBoolFactor:
3843:    [
3843:       | pNot :
3845:          @ConstBoolFactor
3847:          @ConstRequireBool
3849:          oValueNot
3850:       | * :
3855:          @ConstArithExpr
3857:    ];
      
      
3858: ConstArithExpr:
3860:    @ConstTerm
3862:    {[
3862:       | '+' :
3864:          @ConstTerm
3866:          @ConstMatchTypes
3868:          [ oTypeSNodeType
3870:             | nStrLitType :   oValueStringConcat
3872:             | * :             oValueAdd
3878:          ]
3878:       | '-' :
3880:          @ConstTerm
3882:          @ConstMatchTypes
3884:          [ oTypeSNodeType
3886:             | nStrLitType :   #eNotAllowed
3889:             | * :             oValueSub
3895:          ]
3895:       | * :  >
3904:    ]};
      
      
3907: ConstTerm:
3909:    @ConstFactor
3911:    {[
3911:       | pTimes :
3913:          @ConstFactor
3915:          @ConstMatchTypes
3917:          [ oTypeSNodeType
3919:             | nStrLitType :   #eNotAllowed
3922:             | * :             oValueMult
3928:          ]
3928:       | pDivide :
3930:          @ConstFactor
3932:          @ConstMatchTypes
3934:          [ oTypeSNodeType
3936:             | nStrLitType :   #eNotAllowed
3939:             | * :             oValueDiv
3945:          ]
3945:       | * :  >
3954:    ]};
      
      
3957: ConstFactor:
3959:    [
3959:       | pPlus :
3961:          @ConstPrimary
3963:       | pMinus :
3965:          @ConstPrimary
3967:          oValueNegate
3968:       | * :
3975:          @ConstPrimary
3977:    ];
      
      
3978: ConstPrimary:
3980:    [
3980:       | pIntLit :
3982:          oValuePush( TOKEN_VALUE )
3987:          oTypeSPush( IntegerType )
3993:       | pCharLit :
3995:          oValuePush( TOKEN_VALUE )
4000:          oTypeSPush( CharType )
4006:       | pDoubleLit :
4008:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4013:          oTypeSPush( DoubleType )
4019:       | pStrLit :
4021:          oValuePushString( CURRENT_STRLIT )
4026:          oTypeSPush( StrLitType )
4032:       | '(' :
4034:          @ConstExpr
4036:          ')'
4038:       | pIdent :
4040:          Node decl = oScopeFindRequire
4045:          @ResolveUnitRef( decl )
4052:          [ oNodeType( decl )
4059:             | nBuiltInFunc :
4060:                @ConstBuiltInFunc( decl )
4067:             | nConst :
4069:                oValuePush( oNodeGetInt( decl, qValue ) )
4082:                oTypeSPush( oNodeGet( decl, qType ) )
4095:             | nConstStr :
4097:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4110:                oTypeSPush( oNodeGet( decl, qType ) )
4123:             | nEnumValue :
4125:                oValuePush( oNodeGetInt( decl, qValue ) )
4138:                oTypeSPush( oNodeGet( decl, qType ) )
4151:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4153:                oTypeSPush( oNodeGet( decl, qType ) )
4166:                [
4166:                   | '(' :
                           % Type cast
4168:                      @ConstExpr
4170:                      ')'
4172:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4174:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4179:                      [ flagExprAllowTypeName
4182:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4183:                            oValuePush( 0 )
4189:                         | * :   #eTypeNameNotAllowedHere
4196:                      ]
4196:                ]
      
4196:             | * :
4209:                #eNotConst
4211:                oValuePush( 0 )
4217:                oTypeSPush( IntegerType )
4223:          ]
4223:       | '@' :
4225:          #eNotImplemented
4227:          oValuePush( 0 )
4233:          oTypeSPush( UniversalPointerType )
4239:       | * :
4256:          #eNotConst
4258:          oValuePush( 0 )
4264:          oTypeSPush( IntegerType )
4270:    ];
      
4271: ConstRequireBoolPop:
4273:    [ oTypeSNodeType
4275:       | nBooleanType :
4276:       | * :          #eNotBoolean
4283:    ]
4283:    oTypeSPop;
      
      
4285: ConstRequireBool:
4287:    [ oTypeSNodeType
4289:       | nBooleanType :
4290:       | * :          #eNotBoolean
4297:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4298: ConstMatchTypes:
4300:    node_type nt = oTypeSNodeType
4305:    oTypeSPop
4306:    [ equal_node_type( nt, oTypeSNodeType )
4315:       | false :
               % Some implicit conversion is allowed even here
4316:          [ oTypeSNodeType
4318:             | nPointerType :
4319:                [ nt
4322:                   | nUniversalPointerType :  >>
4324:                   | * :
4329:                ]
4329:             | nUniversalPointerType :
4331:                [ nt
4334:                   | nPointerType :  >>
4336:                   | * :
4341:                ]
4341:             | nStrLitType :
4343:                [ nt
4346:                   | nCharType :
4347:                      oValueCharToString
4348:                      >>
4349:                   | * :
4354:                ]
4354:             | nCharType :
4356:                [ nt
4359:                   | nStrLitType :
4360:                      oValueSwap
4361:                      oValueCharToString
4362:                      oValueSwap
4363:                      oTypeSPop
4364:                      oTypeSPush( StrLitType )
4370:                      >>
4371:                   | * :
4376:                ]
4376:             | * :
4387:          ]
4387:          #eTypeMismatch
4389:       | * :
4394:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4395: ConstCoerceType:
4397:    node_type nt = oTypeSNodeType
4402:    oTypeSPop
4403:    [ equal_node_type( nt, oTypeSNodeType )
4412:       | false :
               % Can we implicitly convert the value to the desired type?
4413:          [ oTypeSNodeType
4415:             | nIntegerType :
4416:                [ nt
4419:                   | nByteType :  >>
4421:                   | * :
4426:                ]
4426:             | nByteType :
4428:                [ nt
4431:                   | nIntegerType :  >>
4433:                   | * :
4438:                ]
4438:             | nPointerType :
4440:                [ nt
4443:                   | nUniversalPointerType :  >>
4445:                   | * :
4450:                ]
4450:             | nUniversalPointerType :
4452:                [ nt
4455:                   | nPointerType :  >>
4457:                   | * :
4462:                ]
4462:             | nStrLitType :
4464:                [ nt
4467:                   | nCharType :
4468:                      oValueCharToString
4469:                      >>
4470:                   | * :
4475:                ]
4475:             | nShortStringType :
4477:                [ nt
4480:                   | nStrLitType :  >>
4482:                   | nCharType :
4484:                      oValueCharToString
4485:                      >>
4486:                   | * :
4493:                ]
4493:             | * :
4508:          ]
4508:          #eTypeMismatch
4510:       | * :
4515:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4516: ConstCastType:
4518:    node_type nt = oTypeSNodeType
4523:    oTypeSPop
4524:    [ equal_node_type( nt, oTypeSNodeType )
4533:       | false :
               % Can we cast the value to the desired type?
4534:          [ oTypeSNodeType
4536:             | nIntegerType, nEnumType :
4537:                [ nt
4540:                   | nByteType, nCharType, nBooleanType :  >>
4542:                   | nIntegerType, nEnumType :  >>
4545:                   | * :
4558:                ]
4558:             | nByteType, nCharType, nBooleanType :
4560:                [ nt
4563:                   | nByteType, nCharType, nBooleanType :  >>
4565:                   | nIntegerType, nEnumType :  >>
4568:                   | * :
4581:                ]
4581:             | nPointerType :
4583:                [ nt
4586:                   | nUniversalPointerType :  >>
4588:                   | * :
4593:                ]
4593:             | nUniversalPointerType :
4595:                [ nt
4598:                   | nPointerType :  >>
4600:                   | * :
4605:                ]
4605:             | nStrLitType :
4607:                [ nt
4610:                   | nCharType :
4611:                      oValueCharToString
4612:                      >>
4613:                   | * :
4618:                ]
4618:             | nShortStringType :
4620:                [ nt
4623:                   | nStrLitType :  >>
4625:                   | nCharType :
4627:                      oValueCharToString
4628:                      >>
4629:                   | * :
4636:                ]
4636:             | * :
4657:          ]
4657:          #eTypeMismatch
4659:       | * :
4664:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4665: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4667:    [ oNodeEqual( method, BuiltIn_Ord )
4677:       | true :
4678:          '('
4680:          @ConstExpr
4682:          ')'
4684:          [ oTypeSNodeType
4686:             | nIntegerType, nEnumType :
4687:             | nBooleanType, nByteType, nCharType :
4689:             | * :  #eTypeMismatch
4704:          ]
4704:          oTypeSPop
4705:          oTypeSPush( IntegerType )
4711:          ')'
4713:          >>
4714:       | * :
4719:    ]
      
         % Chr(x)
4719:    [ oNodeEqual( method, BuiltIn_Chr )
4729:       | true :
4730:          '('
4732:          @ConstExpr
4734:          ')'
4736:          [ oTypeSNodeType
4738:             | nIntegerType :
4739:             | nByteType :
4741:             | * :  #eTypeMismatch
4750:          ]
4750:          oTypeSPop
4751:          oTypeSPush( CharType )
4757:          ')'
4759:          >>
4760:       | * :
4765:    ]
      
         % Pred(x)
4765:    [ oNodeEqual( method, BuiltIn_Pred )
4775:       | true :
4776:          '('
4778:          @ConstExpr
4780:          [ oTypeSNodeType
4782:             | nEnumType :
4783:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4792:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4795:                   | * :
4800:                ]
4800:             | * :  #eTypeMismatch
4807:          ]
4807:          oValuePush( 1 )  oValueSub
4814:          ')'
4816:          >>
4817:       | * :
4822:    ]
      
         % Succ(x)
4822:    [ oNodeEqual( method, BuiltIn_Succ )
4832:       | true :
4833:          '('
4835:          @ConstExpr
4837:          [ oTypeSNodeType
4839:             | nEnumType :
4840:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4849:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4852:                   | * :
4857:                ]
4857:             | * :  #eTypeMismatch
4864:          ]
4864:          oValuePush( 1 )  oValueAdd
4871:          ')'
4873:          >>
4874:       | * :
4879:    ]
      
         % Sizeof(x)
4879:    [ oNodeEqual( method, BuiltIn_Sizeof )
4889:       | true :
4890:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4892:          @ConstExprAllowTypeName
4894:          oValuePop
4895:          Node theType = oTypeSTop
4900:          oTypeSPop
4901:          oValuePush( oNodeGetInt( theType, qSize ) )
4914:          oTypeSPush( IntegerType )
4920:          ')'
4922:          >>
4923:       | * :
4928:    ]
      
4928:    #eNotImplemented
4931:    ;
      
      
4931: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4931: Expr:
4933:    Label falseLabel = labelNull
      
4939:    @ExprAllowFlow( falseLabel )
4946:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
4954: ExprAllowTypeName:
4956:    boolean oldAllowTypeName = flagExprAllowTypeName
4962:    flagExprAllowTypeName = true
4968:    @Expr
4970:    flagExprAllowTypeName = oldAllowTypeName
4977:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4977: BooleanExprControlFlow( out Label falseLabel ):
4979:    @ExprAllowFlow( falseLabel )
4986:    [ oTypeSNodeType
4988:       | nBooleanFlowType :
4989:       | nBooleanType :
               % convert value to control flow
4991:          falseLabel = oLabelNew
4996:          .tJumpFalse  oEmitLabel( falseLabel )
5004:       | * :
5011:          #eNotBoolean
5013:    ]
5013:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5015: FlowToVal( inout Label falseLabel ):
5017:    [ oTypeSNodeType
5019:       | nBooleanFlowType :
5020:          Label doneLabel = oLabelNew
5025:          .tPushConstI  oEmitInt( 1 )
5033:          .tJump  oEmitLabel( doneLabel )
5041:          .tLabel  oEmitLabel( falseLabel )
5049:          .tPushConstI  oEmitInt( 0 )
5057:          .tLabel  oEmitLabel( doneLabel )
5065:          oTypeSPop
5066:          oTypeSPush( BooleanType )
5072:          falseLabel = labelNull
5078:       | * :
5083:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5084: ValToFlow( out Label falseLabel ):
5086:    [ oTypeSNodeType
5088:       | nBooleanType :
5089:          falseLabel = oLabelNew
5094:          .tJumpFalse  oEmitLabel( falseLabel )
5102:          oTypeSPop
5103:          oTypeSPush( BooleanFlowType )
5109:       | * :
5114:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5115: ExprAllowFlow( out Label falseLabel ):
5117:    @BoolExprAllowFlow( falseLabel )
5124:    {[
5124:       | '=' :
5126:          @FlowToVal( falseLabel )
5133:          @PromoteToIntOptional
5135:          @BoolExprAllowFlow( falseLabel )
5142:          @FlowToVal( falseLabel )
5149:          @PromoteToIntOptional
5151:          @MatchTypes
5153:          [ oTypeSNodeType
5155:             | nBooleanType, nCharType :     .tEqualB
5158:             | nIntegerType, nEnumType :     .tEqualI
5162:             | nPointerType, nUniversalPointerType :    .tEqualP
5166:             | nShortStringType, nStrLitType :
5168:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5180:             | * :                           #eNotAllowed
5201:          ]
5201:          oTypeSPop
5202:          oTypeSPush( BooleanType )
      
5208:       | '<>' :
5210:          @FlowToVal( falseLabel )
5217:          @PromoteToIntOptional
5219:          @BoolExprAllowFlow( falseLabel )
5226:          @FlowToVal( falseLabel )
5233:          @PromoteToIntOptional
5235:          @MatchTypes
5237:          [ oTypeSNodeType
5239:             | nBooleanType, nCharType :     .tNotEqualB
5242:             | nIntegerType, nEnumType :     .tNotEqualI
5246:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5250:             | nShortStringType, nStrLitType :
5252:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5264:             | * :                           #eNotAllowed
5285:          ]
5285:          oTypeSPop
5286:          oTypeSPush( BooleanType )
      
5292:       | '<' :
5294:          @FlowToVal( falseLabel )
5301:          @PromoteToIntOptional
5303:          @BoolExprAllowFlow( falseLabel )
5310:          @FlowToVal( falseLabel )
5317:          @PromoteToIntOptional
5319:          @MatchTypes
5321:          [ oTypeSNodeType
5323:             | nBooleanType, nCharType :     .tLessB
5326:             | nIntegerType, nEnumType :     .tLessI
5330:             | nPointerType, nUniversalPointerType :   .tLessP
5334:             | nShortStringType, nStrLitType :
5336:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5348:             | * :                           #eNotAllowed
5369:          ]
5369:          oTypeSPop
5370:          oTypeSPush( BooleanType )
      
5376:       | '>' :
5378:          @FlowToVal( falseLabel )
5385:          @PromoteToIntOptional
5387:          @BoolExprAllowFlow( falseLabel )
5394:          @FlowToVal( falseLabel )
5401:          @PromoteToIntOptional
5403:          @MatchTypes
5405:          [ oTypeSNodeType
5407:             | nBooleanType, nCharType :     .tGreaterB
5410:             | nIntegerType, nEnumType :     .tGreaterI
5414:             | nPointerType, nUniversalPointerType :   .tGreaterP
5418:             | nShortStringType, nStrLitType :
5420:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5432:             | * :                           #eNotAllowed
5453:          ]
5453:          oTypeSPop
5454:          oTypeSPush( BooleanType )
      
5460:       | '<=' :
5462:          @FlowToVal( falseLabel )
5469:          @PromoteToIntOptional
5471:          @BoolExprAllowFlow( falseLabel )
5478:          @FlowToVal( falseLabel )
5485:          @PromoteToIntOptional
5487:          @MatchTypes
5489:          [ oTypeSNodeType
5491:             | nBooleanType, nCharType :     .tLessEqualB
5494:             | nIntegerType, nEnumType :     .tLessEqualI
5498:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5502:             | nShortStringType, nStrLitType :
5504:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5516:             | * :                           #eNotAllowed
5537:          ]
5537:          oTypeSPop
5538:          oTypeSPush( BooleanType )
      
5544:       | '>=' :
5546:          @FlowToVal( falseLabel )
5553:          @PromoteToIntOptional
5555:          @BoolExprAllowFlow( falseLabel )
5562:          @FlowToVal( falseLabel )
5569:          @PromoteToIntOptional
5571:          @MatchTypes
5573:          [ oTypeSNodeType
5575:             | nBooleanType, nCharType :     .tGreaterEqualB
5578:             | nIntegerType, nEnumType :     .tGreaterEqualI
5582:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5586:             | nShortStringType, nStrLitType :
5588:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5600:             | * :                           #eNotAllowed
5621:          ]
5621:          oTypeSPop
5622:          oTypeSPush( BooleanType )
      
5628:       | * :
5643:          >
5645:    ]};
      
      
5648: BoolExprAllowFlow( out Label falseLabel ):
5650:    Label trueLabel = labelNull
      
5656:    @BoolTermAllowFlow( falseLabel )
5663:    {[
5663:       | pOr :
5665:          [ oTypeSNodeType
5667:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5668:                [ equal_label( trueLabel, labelNull )
5678:                   | true :  trueLabel = oLabelNew
5684:                   | * :
5689:                ]
5689:                .tJump  oEmitLabel( trueLabel )
5697:             | nBooleanType :
5699:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5706:                [ equal_label( trueLabel, labelNull )
5716:                   | true :  trueLabel = oLabelNew
5722:                   | * :
5727:                ]
5727:                .tJump  oEmitLabel( trueLabel )
5735:             | * : #eNotBoolean
5744:          ]
5744:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5745:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5753:          falseLabel = labelNull
5759:          @BoolTermAllowFlow( falseLabel )
      
5766:          [ oTypeSNodeType
5768:             | nBooleanFlowType :
5769:             | nBooleanType :
5771:                @ValToFlow( falseLabel )
5778:             | * : #eNotBoolean
5787:          ]
      
5787:          oTypeSPop
5788:          oTypeSPush( BooleanFlowType )
      
5794:       | * :
5799:          >
5801:    ]}
      
         % any short-circuit trues jump here to the end
5803:    [ equal_label( trueLabel, labelNull )
5813:       | false :
5814:          .tLabel  oEmitLabel( trueLabel )
5822:       | * :
5827:    ]
5828:    ;
      
      
5828: BoolTermAllowFlow( out Label falseLabel ):
5830:    Label overallFalseLabel = labelNull
      
5836:    @BoolFactorAllowFlow( falseLabel )
5843:    {[
5843:       | pAnd :
5845:          [ oTypeSNodeType
5847:             | nBooleanFlowType :
5848:             | nBooleanType :
5850:                @ValToFlow( falseLabel )
5857:             | * :
5864:                #eNotBoolean
5866:          ]
5866:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5867:          [ equal_label( overallFalseLabel, labelNull )
5877:             | true :
5878:                overallFalseLabel = oLabelNew
5883:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5897:                falseLabel = overallFalseLabel
5903:             | * :
5908:          ]
      
5908:          Label factorFalseLabel = labelNull
5914:          @BoolFactorAllowFlow( factorFalseLabel )
      
5921:          [ oTypeSNodeType
5923:             | nBooleanFlowType :
5924:             | nBooleanType :
5926:                @ValToFlow( factorFalseLabel )
5933:             | * : #eNotBoolean
5942:          ]
5942:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5956:       | * :
5961:          >
5963:    ]};
      
      
5966: BoolFactorAllowFlow( out Label falseLabel ):
5968:    [
5968:       | pNot :
5970:          Label factorFalseLabel = labelNull
      
5976:          @BoolFactorAllowFlow( factorFalseLabel )
5983:          [ oTypeSNodeType
5985:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5986:                falseLabel = oLabelNew
5991:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5999:                .tLabel  oEmitLabel( factorFalseLabel )
      
6007:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6009:                .tNot
      
6011:             | * : #eNotBoolean
6020:          ]
      
6020:       | * :
6025:          @ArithExprAllowFlow( falseLabel )
6032:    ];
      
      
6033: ArithExprAllowFlow( out Label falseLabel ):
6035:    boolean first = true
6041:    int tempStrOffset
      
6041:    @TermAllowFlow( falseLabel )
6048:    {[
6048:       | '+' :
6050:          [ oTypeSNodeType
6052:             | nIntegerType, nByteType :
6053:                @PromoteToIntPop
6055:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6062:                [ oTypeSNodeType
6064:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6065:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6067:                      @PointerAddition
6069:                   | * :
6076:                      @PromoteToInt
6078:                      .tAddI
6080:                ]
      
6080:             | nDoubleType :
6082:                @TermAllowFlow( falseLabel )
6089:                @PromoteToDoublePop
6091:                .tAddD
      
6093:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6095:                [ first
6098:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6099:                             tempStrOffset = @MoveIntoTempShortString
6105:                             first = false
6111:                   | * :
6116:                ]
6116:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6123:                [ oTypeSNodeType
6125:                   | nShortStringType, nStrLitType :
6126:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6128:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6136:                      oTypeSPush( ShortStringType )
6142:                   | nCharType :
6144:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6146:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6154:                      oTypeSPush( ShortStringType )
6160:                   | * :
6169:                      #eTypeMismatch
6171:                      oTypeSPop
6172:                ]
      
6172:             | nPointerType, nUniversalPointerType :
6174:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6181:                @PromoteToIntPop
6183:                @PointerAddition
      
6185:             | * :
6204:                #eNotAllowed
6206:          ]
      
6206:       | '-' :
6208:          [ oTypeSNodeType
6210:             | nIntegerType, nByteType :
6211:                @PromoteToIntPop
6213:                @TermAllowFlow( falseLabel )
6220:                @PromoteToInt
6222:                .tSubI
      
6224:             | nDoubleType :
6226:                @TermAllowFlow( falseLabel )
6233:                @PromoteToDoublePop
6235:                .tSubD
      
6237:             | nPointerType, nUniversalPointerType :
6239:                @TermAllowFlow( falseLabel )
6246:                [ oTypeSNodeType
6248:                   | nIntegerType, nByteType :
6249:                      @PromoteToIntPop
6251:                      @PointerSubInt
6253:                   | nPointerType, nUniversalPointerType :
6255:                      @MatchTypes
6257:                      @PointerSubPointer
6259:                   | * :
6270:                      #eNotAllowed
6272:                ]
      
6272:             | * :  #eNotAllowed
      
6287:          ]
6287:       | * :
6294:          >
6296:    ]};
      
      
6299: TermAllowFlow( out Label falseLabel ):
6301:    @FactorAllowFlow( falseLabel )
6308:    {[
6308:       | '*' :
6310:          [ oTypeSNodeType
6312:             | nIntegerType, nByteType :
6313:                @PromoteToIntPop
6315:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6322:                @PromoteToInt
6324:                .tMultI
      
6326:             | nDoubleType :
6328:                @FactorAllowFlow( falseLabel )
6335:                @PromoteToDoublePop
6337:                .tMultD
      
6339:             | * :
6348:                #eNotAllowed
6350:          ]
      
6350:       | '/' :
6352:          [ oTypeSNodeType
6354:             | nIntegerType, nByteType :
6355:                @PromoteToIntPop
6357:                @FactorAllowFlow( falseLabel )
6364:                @PromoteToInt
6366:                .tDivI
      
6368:             | nDoubleType :
6370:                @FactorAllowFlow( falseLabel )
6377:                @PromoteToDoublePop
6379:                .tDivD
      
6381:             | * :
6390:                #eNotAllowed
6392:          ]
      
6392:       | * :
6399:          >
6401:    ]};
      
      
6404: FactorAllowFlow( out Label falseLabel ):
6406:    [
6406:       | '+' :
6408:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6415:          [ oTypeSNodeType
6417:             | nIntegerType, nByteType :
6418:             | nDoubleType :
6420:             | * :
6429:                #eNotAllowed
6431:          ]
6431:       | '-' :
6433:          @PrimaryAllowFlow( falseLabel )
6440:          [ oTypeSNodeType
6442:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6443:                @PromoteToInt
6445:                .tNegI
6447:             | nDoubleType :
6449:                .tNegD
6451:             | * :
6460:                #eNotAllowed
6462:          ]
6462:       | * :
6469:          @PrimaryAllowFlow( falseLabel )
6476:    ];
      
      
6477: PrimaryAllowFlow( out Label falseLabel ):
6479:    [
6479:       | pIntLit :
6481:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6488:          oTypeSPush( IntegerType )
      
6494:       | pCharLit :
6496:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6503:          oTypeSPush( CharType )
      
6509:       | pDoubleLit :
6511:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6518:          oTypeSPush( DoubleType )
      
6524:       | '(' :
6526:          @ExprAllowFlow( falseLabel )
6533:          ')'
      
6535:       | pStrLit :
6537:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6546:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6554:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6560:          @LValueIndexes
               % get final value of dereferencing, if any
6562:          @FetchVar
      
6564:       | pIdent :
6566:          Node decl = oScopeFindRequire
6571:          @ResolveUnitRef( decl )
6578:          Node theType
      
6578:          [ oNodeType( decl )
6585:             | nFunc :
6586:                @Call( decl )
      
6593:             | nBuiltInFunc :
6595:                @CallBuiltInFunc( decl )
      
6602:             | nConst, nEnumValue :
6604:                theType = oNodeGet( decl, qType )
6617:                oTypeSPush( theType )
6623:                [ oTypeSNodeType
6625:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6626:                      .tPushConstI @EmitValue( decl )
6635:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6637:                      .tPushConstI @EmitValue( decl )
6646:                   | * :
6663:                      #eNotImplemented
6665:                ]
      
6665:             | nConstDouble :
6667:                theType = oNodeGet( decl, qType )
6680:                oTypeSPush( theType )
6686:                [ oTypeSNodeType
6688:                   | nDoubleType :
6689:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6704:                   | * :
6709:                      #eNotImplemented
6711:                ]
                     
6711:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6713:                int addr = oNodeGetInt( decl, qValue )
6726:                [ equal_zero( addr )
6733:                   | true :
6734:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6751:                      oNodeSetInt( decl, qValue, addr )
6763:                   | * :
6768:                ]
6768:                .tPushAddrGlobal oEmitInt( addr )
6776:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6782:                @LValueIndexes
                     % get final value of dereferencing, if any
6784:                @FetchVar
      
6786:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6788:                @VarExpr( decl )
      
6795:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6797:                oTypeSPush( oNodeGet( decl, qType ) )
6810:                [
6810:                   | '(' : 
                           % Type cast
6812:                      @Expr
6814:                      ')'
6816:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
6818:                      [ oTypeSNodeType
6820:                         | nPointerType, nUniversalPointerType :
6821:                            [
6821:                               | '^' :             % dereferenced
6823:                                  oTypeSPop
6824:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
6837:                                  @LValueIndexes
6839:                                  @FetchVar
6841:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
6843:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
6845:                                  @LValueIndexes
6847:                                  @FetchVar
6849:                               | * :               % just ptr value alone
6856:                            ]
      
6856:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
6858:                            @LValueIndexes
                                 % get final value, if no longer compound
6860:                            @FetchVar
      
6862:                         | *:
6875:                      ]
      
6875:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
6880:                      [ flagExprAllowTypeName
6883:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
6884:                            .tPushConstI  oEmitInt( 0 )
6892:                         | * :    #eTypeNameNotAllowedHere
6899:                      ]
6899:                ]
      
6899:             | * :
6924:                #eNotValue
6926:                oTypeSPush( IntegerType )
6932:          ]
      
6932:       | '@' :        % @var -- pointer to var
6934:          pIdent
      
6936:          Node decl = oScopeFindRequire
6941:          @ResolveUnitRef( decl )
6948:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
6948:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6958:          theType = oTypeSTop
6963:          oTypeSPop
6964:          Node ptrType = @PointerTypeTo( theType )
6975:          oTypeSPush( ptrType )
      
6981:       | * :
6998:          #eNotValue
7000:          oTypeSPush( IntegerType )
7006:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7007: VarExpr( Node decl ):
7009:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7022:    int uplevels = @DeclUpLevels( decl )
      
7033:    oTypeSPush( theType )
7039:    [ oTypeSNodeType
7041:       | nIntegerType, nEnumType :
7042:          [ oNodeType( decl )
7049:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7059:             | nLocalVar :
7061:                [ equal_zero( uplevels )
7068:                   | true :  .tPushLocalI  @EmitValue( decl )
7078:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7098:                ]
7098:             | nParam :
7100:                [ oNodeGetBoolean( decl, qInOut )
7110:                   | true :    % VAR param points to the var.  Auto dereference.
7111:                      [ equal_zero( uplevels )
7118:                         | true :  .tPushParamP  @EmitValue( decl )
7128:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7148:                      ]
7148:                      .tFetchI
7150:                   | * :
7155:                      [ equal_zero( uplevels )
7162:                         | true :  .tPushParamI  @EmitValue( decl )
7172:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7192:                      ]
7192:                ]
7192:          ]
      
7204:       | nBooleanType, nByteType, nCharType :
7206:          [ oNodeType( decl )
7213:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7223:             | nLocalVar :
7225:                [ equal_zero( uplevels )
7232:                   | true :  .tPushLocalB  @EmitValue( decl )
7242:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7262:                ]
7262:             | nParam :
7264:                [ oNodeGetBoolean( decl, qInOut )
7274:                   | true :    % VAR param points to the var.  Auto dereference.
7275:                      [ equal_zero( uplevels )
7282:                         | true :  .tPushParamP  @EmitValue( decl )
7292:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7312:                      ]
7312:                      .tFetchB
7314:                   | * :
7319:                      [ equal_zero( uplevels )
7326:                         | true :  .tPushParamB  @EmitValue( decl )
7336:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7356:                      ]
7356:                ]
7356:          ]
      
7368:       | nFileType :
7370:          #eNotImplemented
      
7372:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7374:          [ oNodeType( decl )
7381:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7391:             | nLocalVar :
7393:                [ equal_zero( uplevels )
7400:                   | true :  .tPushLocalP  @EmitValue( decl )
7410:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7430:                ]
7430:             | nParam :
7432:                [ oNodeGetBoolean( decl, qInOut )
7442:                   | true :    % VAR param points to the var.  Auto dereference.
7443:                      [ equal_zero( uplevels )
7450:                         | true :  .tPushParamP  @EmitValue( decl )
7460:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7480:                      ]
7480:                      .tFetchP
7482:                   | * :
7487:                      [ equal_zero( uplevels )
7494:                         | true :  .tPushParamP  @EmitValue( decl )
7504:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7524:                      ]
7524:                ]               
7524:          ]
7536:          [
7536:             | '^' :             % dereferenced
7538:                oTypeSPop
7539:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7552:                @LValueIndexes
7554:                @FetchVar
7556:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7558:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7560:                @LValueIndexes
7562:                @FetchVar
7564:             | * :               % just ptr value alone
7571:          ]
      
7571:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7573:          [ oNodeType( decl )
7580:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7590:             | nLocalVar :
7592:                [ equal_zero( uplevels )
7599:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7609:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7629:                ]
7629:             | nParam :
7631:                [ oNodeGetBoolean( decl, qInOut )
7641:                   | true :    % VAR param points to the var.  Auto dereference.
7642:                      [ equal_zero( uplevels )
7649:                         | true :  .tPushParamP  @EmitValue( decl )
7659:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7679:                      ]
7679:                   | * :
7684:                      [ equal_zero( uplevels )
7691:                         | true :  .tPushAddrParam  @EmitValue( decl )
7701:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7721:                      ]
7721:                ]
7721:          ]
               % modify addr for subscripts, field references, etc
7733:          @LValueIndexes
               % get final value
7735:          @FetchVar
7737:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7766: FetchVar:
7768:    [ oTypeSNodeType
7770:       | nIntegerType, nEnumType :  .tFetchI
7773:       | nBooleanType, nByteType, nCharType :  .tFetchB
7777:       | nFileType :   #eNotImplemented
7781:       | nPointerType :             .tFetchP
7785:       | nUniversalPointerType :    #eCantDereference
7789:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7791:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7820: LValueIndexes:
7822:    {[
7822:       | '[' :
7824:          [ oTypeSNodeType
7826:             | nArrayType :    @ArraySubscripts
7829:             | nPointerType :  @PointerArraySubscript
7833:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7837:             | * :             #eNotArray
7850:          ]
7850:       | '.' :       @RecordFieldRef
7854:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7858:       | * :         >
7869:    ]};
      
      
7872: ArraySubscripts:
7874:    [ oTypeSNodeType
7876:       | nArrayType :
7877:       | * :       #eNotArray
7884:    ]
7884:    {
7884:       [ oTypeSNodeType
7886:          | nArrayType :
7887:          | * :    #eTooManySubscripts
7894:       ]
      
            % low subscript of this dimension
7894:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7911:       Node baseType
7911:       baseType = oNodeGet( oTypeSTop, qBaseType )
7923:       oTypeSPop
7924:       oTypeSPush( baseType )
      
7930:       @Expr
7932:       @RequireIntPop
            % adjust for low subscript
7934:       [ equal_zero( low )
7941:          | false :
7942:             .tPushConstI oEmitInt( low ) .tSubI
7952:          | * :
7957:       ]
      
            % multiply by element size
7957:       int size = oNodeGetInt( baseType, qSize )
7970:       [ equal( size, 1 )
7980:          | false :
7981:             .tPushConstI oEmitInt( size ) .tMultI
7991:          | * :
7996:       ]
      
            % update start address
7996:       .tAddPI
7998:       [
7998:          | ']' :  >
8002:          | ',' :
8004:       ]
8012:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8015: PointerArraySubscript:
8017:    [ oTypeSNodeType
8019:       | nPointerType :
8020:       | * :    #eCantDereference
8027:    ]
         % replace type stack with base type
8027:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8039:    oTypeSPop
8040:    oTypeSPush( baseType )
         
8046:    @Expr
8048:    @RequireIntPop
         % multiply by element size
8050:    int size = oNodeGetInt( baseType, qSize )
8063:    [ equal( size, 1 )
8073:       | false :
8074:          .tPushConstI  oEmitInt( size )  .tMultI
8084:       | * :
8089:    ]
         % update start address
8089:    .tAddPI
8091:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8094: ShortStringArraySubscript:
8096:    [ oTypeSNodeType
8098:       | nStrLitType, nShortStringType :
8099:       | * :    #eCantDereference
8108:    ]
8108:    oTypeSPop
8109:    oTypeSPush( CharType )
8115:    @Expr
8117:    @RequireIntPop
8119:    .tAddPI
8121:    ']';
      
      
8124: RecordFieldRef:
8126:    [ oTypeSNodeType
8128:       | nRecordType :
8129:       | * :    #eNotRecord
8136:    ]
8136:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8148:    pIdent
8150:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8155:    [ oNodeType( field )
8162:       | nRecordField :
8163:       | * :   #eNotRecordField
8170:    ]
8170:    oScopeEnd
8171:    int offset = oNodeGetInt( field, qValue )
8184:    [ equal_zero( offset )
8191:       | false :
8192:          .tPushConstI oEmitInt( offset ) .tAddPI
8202:       | * :
8207:    ]
      
         % replace the type on the type stack, with the field type
8207:    oTypeSPop
8208:    oTypeSPush( oNodeGet( field, qType ) )
8222:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8222: PointerAddition:
8224:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8236:    int elementSize = oNodeGetInt( elementType, qSize )
8249:    [ equal( elementSize, 1 )
8259:       | false :
8260:          .tPushConstI  oEmitInt( elementSize )
8268:          .tMultI
8270:       | * :
8275:    ]
8275:    .tAddPI
8278:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8278: PointerSubInt:
8280:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8292:    int elementSize = oNodeGetInt( elementType, qSize )
8305:    [ equal( elementSize, 1 )
8315:       | false :
8316:          .tPushConstI  oEmitInt( elementSize )
8324:          .tMultI
8326:       | * :
8331:    ]
8331:    .tSubPI
8334:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8334: PointerSubPointer:
8336:    .tSubP
8338:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8350:    int elementSize = oNodeGetInt( elementType, qSize )
8363:    [ equal( elementSize, 1 )
8373:       | false :
8374:          .tPushConstI  oEmitInt( elementSize )
8382:          .tDivI
8384:       | * :
8389:    ]
8389:    oTypeSPop
8390:    oTypeSPush( IntegerType )
8397:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8397: PointerDeref:
8399:    [ oTypeSNodeType
8401:       | nPointerType :
8402:       | nUniversalPointerType :   #eCantDereference
8406:       | * :       #eNotPointer
8415:    ]
8415:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8417:    Node theType = oTypeSTop
8422:    oTypeSPop
8423:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8437:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8437: CoerceType:
8439:    node_type nt = oTypeSNodeType
8444:    Node given = oTypeSTop
8449:    oTypeSPop
8450:    [ equal_node_type( nt, oTypeSNodeType )
8459:       | false :
               % Can we implicitly convert the value to the desired type?
8460:          [ oTypeSNodeType
8462:             | nIntegerType :
8463:                [ nt
8466:                   | nByteType :   .tCastBtoI  >>
8470:                   | * :
8475:                ]
8475:             | nByteType :
8477:                [ nt
8480:                   | nIntegerType :   .tCastItoB  >>
8484:                   | * :
8489:                ]
8489:             | nPointerType :
8491:                [ nt
8494:                   | nUniversalPointerType :  >>
8496:                   | nStrLitType :
8498:                      [ equal_node( oTypeSTop, PCharType )
8507:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8508:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8519:                         | * :
8524:                      ]
8524:                   | * :
8531:                ]
8531:             | nUniversalPointerType :
8533:                [ nt
8536:                   | nPointerType :  >>
8538:                   | * :
8543:                ]
8543:             | nShortStringType :
8545:                [ nt
8548:                   | nStrLitType :  >>
8550:                   | nCharType :
                           % Store char as a temp ShortString.
8552:                      oTypeSPush( CharType )
8558:                      int tempOffset = @MoveIntoTempShortString
8564:                      oTypeSPop
8565:                      >>
8566:                   | * :
8573:                ]
8573:             | * :
8586:          ]
8586:          #eTypeMismatch
8588:       | * :
8593:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8594: CastType:
8596:    node_type nt = oTypeSNodeType
8601:    oTypeSPop
8602:    [ equal_node_type( nt, oTypeSNodeType )
8611:       | false :
               % Can we cast the value to the desired type?
8612:          [ oTypeSNodeType
8614:             | nIntegerType, nEnumType :
8615:                [ nt
8618:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8622:                   | nIntegerType, nEnumType :   >>
8625:                   | * :
8638:                ]
8638:             | nByteType, nCharType, nBooleanType :
8640:                [ nt
8643:                   | nByteType, nCharType, nBooleanType :   >>
8645:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8650:                   | * :
8663:                ]
8663:             | nPointerType :
8665:                [ nt
8668:                   | nUniversalPointerType :  >>
8670:                   | nStrLitType :
8672:                      [ equal_node( oTypeSTop, PCharType )
8681:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8682:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8693:                         | * :
8698:                      ]
8698:                   | * :
8705:                ]
8705:             | nUniversalPointerType :
8707:                [ nt
8710:                   | nPointerType :  >>
8712:                   | * :
8717:                ]
8717:             | nShortStringType :
8719:                [ nt
8722:                   | nStrLitType :  >>
8724:                   | nCharType :
                           % Store char as a temp ShortString.
8726:                      oTypeSPush( CharType )
8732:                      int tempOffset = @MoveIntoTempShortString
8738:                      oTypeSPop
8739:                      >>
8740:                   | * :
8747:                ]
8747:             | * :
8766:          ]
8766:          #eTypeMismatch
8768:       | * :
8773:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8774: MatchTypes:
8776:    node_type nt = oTypeSNodeType
8781:    oTypeSPop
8782:    [ equal_node_type( nt, oTypeSNodeType )
8791:       | false :
               % Some implicit conversion is allowed even here
8792:          [ oTypeSNodeType
8794:             | nPointerType :
8795:                [ nt
8798:                   | nUniversalPointerType :  >>
8800:                   | * :
8805:                ]
8805:             | nUniversalPointerType :
8807:                [ nt
8810:                   | nPointerType :  >>
8812:                   | * :
8817:                ]
8817:             | * :
8824:          ]
8824:          #eTypeMismatch
8826:       | * :
8831:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8832: RequireIntPop:
8834:    [ oTypeSNodeType
8836:       | nIntegerType :
8837:       | * :          #eNotInteger
8844:    ]
8844:    oTypeSPop;
      
8846: RequireInt:
8848:    [ oTypeSNodeType
8850:       | nIntegerType :
8851:       | * :          #eNotInteger
8858:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8859: PromoteToIntPop:
8861:    [ oTypeSNodeType
8863:       | nIntegerType :
8864:       | nByteType :        .tCastBtoI
8868:       | * :                #eNotInteger
8877:    ]
8877:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8879: PromoteToInt:
8881:    [ oTypeSNodeType
8883:       | nIntegerType :
8884:       | nByteType :        .tCastBtoI
8888:                            oTypeSPop
8889:                            oTypeSPush( IntegerType )
8895:       | * :                #eNotInteger
8904:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8905: PromoteToIntOptional:
8907:    [ oTypeSNodeType
8909:       | nByteType :        .tCastBtoI
8912:                            oTypeSPop
8913:                            oTypeSPush( IntegerType )
8919:       | * :
8924:    ];
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
8925: PromoteToDoublePop:
8927:    [ oTypeSNodeType
8929:       | nDoubleType :
8930:       | nIntegerType, nByteType :   #eNotImplemented
8934:       | * :                         #eNotDouble
8945:    ]
8945:    oTypeSPop;
      
      
8947: RequireBoolPop:
8949:    [ oTypeSNodeType
8951:       | nBooleanType :
8952:       | * :          #eNotBoolean
8959:    ]
8959:    oTypeSPop;
      
8961: RequireBool:
8963:    [ oTypeSNodeType
8965:       | nBooleanType :
8966:       | * :          #eNotBoolean
8973:    ];
      
      
8974: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8974: Statement:
8976:    [
8976:       | pWriteln :     @WritelnStmt
8980:       | pWrite :       @WriteStmt
8984:       | pReadln :      @ReadlnStmt
8988:       | pRead :        @ReadStmt
8992:       | pIf :          @IfStmt
8996:       | pWhile :       @WhileStmt
9000:       | pFor :         @ForStmt
9004:       | pRepeat :      @RepeatStmt
9008:       | pBreak :       @BreakStmt
9012:       | pContinue :    @ContinueStmt
9016:       | pBegin :       @BeginStmt
9020:       | pIdent :       @LabelOrAssignOrCallStmt
9024:       | pCase :        @CaseStmt
9028:       | pGoto :        @GotoStmt
9032:       | pIntLit :      % should be an integer label
9034:                        oChangeIntLitToLabelIdent
9035:                        @LabelOrAssignOrCallStmt
9037:       | * :            % null statement : don't accept any tokens
9070:    ];
      
      
9071: LabelOrAssignOrCallStmt:
9073:    Node decl = oScopeFindRequire
9078:    @ResolveUnitRef( decl )
9085:    [ oNodeType( decl )
9092:       | nLabel :                          @LabelDefinition( decl )
9100:                                           @Statement
9102:       | nProc :                           @Call( decl )
9111:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9113:                                           @AssignStmt( decl )
9120:       | nFunc :                           @AssignResultStmt( decl )
9129:       | * :                               #eBadStatement
9148:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9149: LabelDefinition( Node decl ):
9151:    [ oNodeGetBoolean( decl, qDefined )
9161:       | true :  #eAlreadyDefined
9164:       | * :
9169:    ]
9169:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9184:    oNodeSetBoolean( decl, qDefined, true )
9196:    ':'
9199:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9199: AssignStmt( Node decl ):
9201:    @LValueFromDecl( decl, true )
9211:    ':=' 
9213:    @Expr
9215:    @CoerceType
9217:    @Assign
9220:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9220: Assign:
9222:    [ oTypeSNodeType
9224:       | nIntegerType, nEnumType :  .tAssignI
9227:       | nBooleanType, nByteType, nCharType :  .tAssignB
9231:       | nDoubleType :  .tAssignD
9235:       | nFileType :   #eNotImplemented
9239:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9243:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9245:           int size = oNodeGetInt( oTypeSTop, qSize )
9257:           .tCopy  oEmitInt( size )    % multi-word copy
9265:    ]
9293:    oTypeSPop
9295:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9295: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9297:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9313:       | false :   #eNotCurrentFunction
9316:       | * :
9321:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9321:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9336:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9349:    ':='
9351:    @Expr
9353:    @CoerceType
9355:    [ oTypeSNodeType
9357:       | nIntegerType, nEnumType : .tAssignI
9360:       | nBooleanType, nByteType, nCharType :  .tAssignB
9364:       | nDoubleType :  .tAssignD
9368:       | nFileType :   #eNotImplemented
9372:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9376:       | nArrayType, nRecordType, nShortStringType :
9378:           int size = oNodeGetInt( oTypeSTop, qSize )
9390:           .tCopy  oEmitInt( size )    % multi-word copy
9398:    ]
9426:    oTypeSPop
9428:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9428: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9430:    pIdent
9432:    Node decl = oScopeFindRequire
9437:    @ResolveUnitRef( decl )
9444:    @LValueFromDecl( decl, writeable )
9455:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9455: LValueFromDecl( Node decl, boolean writeable ):
9457:    [ oNodeType( decl )
9464:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9465:          @LValueVar( decl, writeable )
      
9475:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9477:          oTypeSPush( oNodeGet( decl, qType ) )
9490:          '('
9492:          @LValueExpr( writeable )
9499:          ')'
9501:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9503:          [ oTypeSNodeType
9505:             | nPointerType :
9506:                [
9506:                   | '[' :
                           % dereference the pointer var first
9508:                      .tFetchP
9510:                      @PointerArraySubscript
9512:                   | * :
9517:                ]
9517:             | * :
9522:          ]
               % additional subscripts, if any
9522:          @LValueIndexes
       
9524:       | * :  #eNotVar
9539:    ]
9540:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9540: LValueCastType:
9542:    node_type nt = oTypeSNodeType
9547:    oTypeSPop
9548:    [ equal_node_type( nt, oTypeSNodeType )
9557:       | false :
               % Can we cast the value to the desired type?
9558:          [ oTypeSNodeType
9560:             | nIntegerType, nEnumType :
9561:                [ nt
9564:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9568:                   | nIntegerType, nEnumType :   >>
9571:                   | * :
9584:                ]
9584:             | nByteType, nCharType, nBooleanType :
9586:                [ nt
9589:                   | nByteType, nCharType, nBooleanType :   >>
9591:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9596:                   | * :
9609:                ]
9609:             | nPointerType :
9611:                [ nt
9614:                   | nUniversalPointerType :  >>
9616:                   | * :
9621:                ]
9621:             | nUniversalPointerType :
9623:                [ nt
9626:                   | nPointerType :  >>
9628:                   | * :
9633:                ]
9633:             | nShortStringType :
9635:                [ nt
9638:                   | nStrLitType :  >>
9640:                   | * :
9645:                ]
9645:             | * :
9664:          ]
9664:          #eTypeMismatch
9666:       | * :
9671:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9672: LValueVar( Node decl, boolean writeable ):
9674:    [ oNodeType( decl )
9681:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9691:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9702:       | nParam :
9704:          [ oNodeGetBoolean( decl, qInOut )
9714:             | true :   % VAR param points to variable.  No dereference.
9715:                        .tPushParamP @EmitValue( decl )
9724:             | * :      .tPushAddrParam @EmitValue( decl )
9738:          ]
9738:       | nTypedConst :
9740:          [ writeable
9743:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9753:             | * :      #eNotVar
9760:          ]
9760:       | * :            #eNotVar
9773:    ]
      
9773:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9786:    [ oTypeSNodeType
9788:       | nPointerType :
9789:          [
9789:             | '[' :
                     % dereference the pointer var first
9791:                .tFetchP
9793:                @PointerArraySubscript
9795:             | * :
9800:          ]
9800:       | * :
9805:    ]
         % additional subscripts, if any
9805:    @LValueIndexes
9808:    ;
      
      
9808: IncVar( Node decl ):
9810:    @LValueVar( decl, true )
9820:    @RequireIntPop
9822:    @VarExpr( decl )
9829:    oTypeSPop
9830:    .tIncI
9832:    .tAssignI;
      
9835: DecVar( Node decl ):
9837:    @LValueVar( decl, true )
9847:    @RequireIntPop
9849:    @VarExpr( decl )
9856:    oTypeSPop
9857:    .tDecI
9859:    .tAssignI;
      
      
9862: IfStmt:
9864:    Label falseLabel = labelNull
      
9870:    @BooleanExprControlFlow( falseLabel )
9877:    pThen
9879:    @Statement
9881:    [
9881:       | pElse :
9883:          Label doneLabel = oLabelNew
      
9888:          .tJump  oEmitLabel( doneLabel )
9896:          .tLabel oEmitLabel( falseLabel )
9904:          @Statement
9906:          .tLabel oEmitLabel( doneLabel )
      
9914:       | * :
9919:          .tLabel oEmitLabel( falseLabel )
9927:    ];
      
      
9928: ForStmt:
9930:    pIdent
      
9932:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9937:    @LValueVar( decl, true )
9947:    @RequireIntPop
      
9949:    ':='
      
9951:    @Expr
9953:    @RequireIntPop
9955:    .tAssignI
      
9957:    Label breakLabel = oLabelNew
      
9962:    Label checkLabel = oLabelNew
9967:    .tJump  oEmitLabel( checkLabel )
      
9975:    Label continueLabel = oLabelNew
9980:    .tLabel  oEmitLabel( continueLabel )
9988:    [
9988:       | pTo :
9990:          @IncVar( decl )
9997:          .tLabel  oEmitLabel( checkLabel )
10005:          @VarExpr( decl )  oTypeSPop
10013:          @Expr
10015:          @RequireIntPop
10017:          .tGreaterI
10019:          .tJumpTrue  oEmitLabel( breakLabel )
10027:       | pDownto :
10029:          @DecVar( decl )
10036:          .tLabel  oEmitLabel( checkLabel )
10044:          @VarExpr( decl )  oTypeSPop
10052:          @Expr
10054:          @RequireIntPop
10056:          .tLessI
10058:          .tJumpTrue  oEmitLabel( breakLabel )
10066:    ]
10074:    oLoopPush( continueLabel, breakLabel )
10083:    pDo
10085:    @Statement
10087:    .tJump  oEmitLabel( continueLabel )
10095:    .tLabel  oEmitLabel( breakLabel )
10103:    oLoopPop;
      
      
10105: RepeatStmt:
10107:    Label continueLabel = oLabelNew
10112:    .tLabel  oEmitLabel( continueLabel )
      
10120:    Label breakLabel = oLabelNew
      
10125:    oLoopPush( continueLabel, breakLabel )
10134:    @Statement
10136:    {[
10136:       | ';' :
10138:          @Statement
10140:       | pUntil :
10142:          Label falseLabel
10142:          @BooleanExprControlFlow( falseLabel )
10149:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10163:          >
10165:    ]}
10175:    .tLabel  oEmitLabel( breakLabel )
10183:    oLoopPop;
      
      
10185: WhileStmt:
10187:    Label continueLabel = oLabelNew
10192:    .tLabel  oEmitLabel( continueLabel )
      
10200:    Label breakLabel
10200:    @BooleanExprControlFlow( breakLabel )
      
10207:    oLoopPush( continueLabel, breakLabel )
10216:    pDo
10218:    @Statement
10220:    .tJump  oEmitLabel( continueLabel )
10228:    .tLabel  oEmitLabel( breakLabel )
10236:    oLoopPop;
      
      
10238: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10240:    [ equal_label( oLoopContinueLabel, labelNull )
10249:       | true :
10250:          #eNotInALoop
10252:       | false :
10254:          .tJump  oEmitLabel( oLoopContinueLabel )
10261:    ];
      
      
10270: BreakStmt:
10272:    [ equal_label( oLoopBreakLabel, labelNull )
10281:       | true :
10282:          #eNotInALoop
10284:       | false :
10286:          .tJump  oEmitLabel( oLoopBreakLabel )
10293:    ];
      
      
10302: CaseStmt:
10304:    Code tableCode = oCodeNew
10309:    Label tableLabel = oLabelNew
10314:    Label doneLabel = oLabelNew
10319:    Label otherwiseLabel = doneLabel
10325:    boolean isString = false
      
10331:    @Expr
         % Leave the expr type on the type stack throughout case statement
10333:    [ oTypeSNodeType
10335:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10344:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10354:       | nShortStringType, nStrLitType :        isString = true
10362:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10370:       | * :     #eNotAllowed
10389:    ]
10389:    pOf
      
10391:    {
10391:       [
10391:          | pOtherwise, pElse :
10393:             otherwiseLabel = oLabelNew
10398:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10406:             {[
10406:                | pEnd :  >
10410:                | * :
10415:                   @Statement
10417:                   [
10417:                      | ';' :
10419:                      | * :   pEnd  >
10428:                   ]
10428:             ]}
10430:             >
      
10432:          | pEnd :
                  % Reached end with no otherwise clause
10434:             >
      
10436:          | * :
10445:             Label caseLabel = oLabelNew
10450:             oCodePush( tableCode )
10456:             {
10456:                @ConstExpr
10458:                @ConstCoerceType
10460:                int val
10460:                [ isString
10463:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10473:                   | false :   val = oValueTop
10480:                ]
10488:                oValuePop
10489:                [
10489:                   | '..' :  @ConstExpr
10493:                             @ConstCoerceType
10495:                             int highval
10495:                             [ isString
10498:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10508:                                | false :  highval = oValueTop
10515:                             ]
10523:                             oValuePop
10524:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10544:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10563:                ]
10563:                [
10563:                   | ',' :
10565:                   | * :  >
10572:                ]
10572:             }
10574:             oCodePop
10575:             ':'
10577:             .tLabel  oEmitLabel( caseLabel )
10585:             @Statement
10587:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10595:             [
10595:                | ';' :
10597:                | * :
10602:             ]
                  
10602:       ]
         
10602:    }
      
10604:    .tLabel  oEmitLabel( tableLabel )
10612:    oEmitCode( tableCode )
10618:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10626:    .tLabel  oEmitLabel( doneLabel )
10634:    oTypeSPop
10636:    ;
      
      
10636: GotoStmt:
10638:    [
10638:       | pIdent :
10640:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10642:          oChangeIntLitToLabelIdent
10643:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10651:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10660:    oNodeSetBoolean( decl, qUsed, true )
10672:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10688:    ;
      
      
10688: BeginStmt:
10690:    @Statement
10692:    {[
10692:       | ';' :   @Statement
10696:       | pEnd :  >
10700:    ]};
      
      
10711: WritelnStmt:
10713:    @WriteStmt
10715:    .tWriteCR;
      
      
10718: WriteStmt:
10720:    [
10720:       | '(' :
10722:          {
10722:             @Expr
10724:             [ oTypeSNodeType
10726:                | nIntegerType :             .tWriteI
10729:                | nBooleanType :             .tWriteBool
10733:                | nByteType :                .tCastBtoI  .tWriteI
10739:                | nCharType :                .tWriteChar
10743:                | nDoubleType :              .tWriteD
10747:                | nShortStringType, nStrLitType :   .tWriteShortStr
10751:                | nFileType :                #eNotImplemented
10755:                | nEnumType :
                        % write name via table lookup
10757:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10771:                   .tWriteEnum
10773:                | nPointerType :
10775:                   [ equal_node( oTypeSTop, PCharType )
10784:                      | true :               .tWritePChar
10787:                      | * :                  .tWriteP
10794:                   ]
10794:                | nUniversalPointerType :    .tWriteP
10798:                | * :                        #eNotAllowed
10825:             ]
10825:             oTypeSPop
10826:             [
10826:                | ')' : >
10830:                | ',' :
10832:             ]
10840:          }
10842:       | * :
10847:    ];
      
      
10848: ReadlnStmt:
10850:    @ReadStmt
10852:    .tReadCR;
      
      
10855: ReadStmt:
10857:    [
10857:       | '(' :
10859:          {
10859:             @LValueExpr( true )
10866:             [ oTypeSNodeType
10868:                | nIntegerType :      .tReadI
10871:                | nCharType :         .tReadChar
10875:                | nShortStringType :  
10877:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
10896:                    .tReadShortStr  oEmitInt( capacity )
10904:                | * :                 #eNotAllowed
10915:             ]
10915:             oTypeSPop
10916:             [
10916:                | ')' : >
10920:                | ',' :
10922:             ]
10930:          }
10932:       | * :
10937:    ];
10938: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
10938: MoveIntoTempShortString >> int:
10940:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
10950:    [ oTypeSNodeType
10952:       | nShortStringType, nStrLitType :
10953:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
10961:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
10963:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
10978:       | nCharType :
               % temp[0] = 1
10980:          .tPushAddrLocal  oEmitInt( tempOffset )
10988:          .tPushConstI  oEmitInt( 1 )
10996:          .tAssignB
               % temp[1] = value
10998:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11013:          .tSwap
11015:          .tAssignB
11017:       | * :   #eTypeMismatch
11028:    ]
11028:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11029:    .tPushAddrLocal  oEmitInt( tempOffset )
11037:    oTypeSPush( ShortStringType )
11043:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11047: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11049:    .tAllocActuals  oEmitInt( 16 )
11057:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11069:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11081:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11090:    .tFreeActuals  oEmitInt( 16 )
11098:    oTypeSPop
11099:    oTypeSPop
11101:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11101: ShortStringAppendChar:
         % Note at the moment I don't align params
11103:    .tAllocActuals  oEmitInt( 12 )
11111:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11123:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11135:    .tCall  @EmitValue( System_ShortStringAppendChar )
11144:    .tFreeActuals  oEmitInt( 12 )
11152:    oTypeSPop
11153:    oTypeSPop
11155:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11155: ShortStringCmp:
11157:    .tAllocActualsCdecl  oEmitInt( 24 )
11165:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11177:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11189:    int tempOffset = oScopeAllocType( IntegerType )
11199:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11217:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11226:    .tPushLocalI  oEmitInt( tempOffset )
11234:    .tFreeActuals  oEmitInt( 24 )
11242:    oTypeSPop
11243:    oTypeSPush( IntegerType )
11250:    ;
11250: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11250: Call( Node method ):
11252:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11264:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11277:    Node resultType
11277:    int tempOffset
      
11277:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11294:    [ isFunc
11297:       | true :
11298:          resultType = oNodeGet( method, qType )
11311:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11321:       | * :
11326:    ]
         
      
11326:    Node paramScope = oNodeGet( method, qParams )
11339:    int actualsSize = oNodeGetInt( paramScope, qSize )
11352:    [ cdecl
11355:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11364:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11374:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11382:    [ greater( @DeclLevel( method ), 0 )
11397:       | true :
11398:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11406:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11425:          .tAssignP
11427:       | * :
11432:    ]
      
      
11432:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11445:    Node param = oNodeIterValue( paramIter )
11455:    [
11455:       | '(' :
            
11457:          {
11457:             [ oNodeNull( param )
11464:                | true : >
11467:                | * :
11472:             ]
      
11472:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11485:             .tPushAddrActual oEmitInt( offset )
11493:             oTypeSPush( oNodeGet( param, qType ) )
      
11506:             [ oNodeGetBoolean( param, qInOut )
11516:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11517:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11524:                           @MatchTypes
      
11526:                           .tAssignP
      
11528:                | false :  @Expr
11532:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11534:                           [ oTypeSNodeType
11536:                              | nIntegerType, nEnumType : .tAssignI
11539:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11543:                              | nDoubleType :  .tAssignD
11547:                              | nFileType :   #eNotImplemented
11551:                              | nPointerType, nUniversalPointerType :  .tAssignP
11555:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11557:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11569:                                  .tCopy  oEmitInt( size )    % multi-word copy
11577:                           ]
11605:             ]
11613:             oTypeSPop
      
11614:             oNodeIterNext( paramIter )
11620:             param = oNodeIterValue( paramIter )
11630:             [ oNodeNull( param )
11637:                | true :  >
11640:                | false :
11642:             ]
      
11650:             ','
11652:          }
      
11654:          ')'
      
11656:       | * :
11661:    ]
      
11661:    [ oNodeNull( param )
11668:       | false :    #eMissingParameter
11671:       | * :
11676:    ]
      
11676:    [ isFunc
11679:       | true :
               % Pass result temp as an additional VAR parameter.
11680:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11695:          .tPushAddrLocal  oEmitInt( tempOffset )
11703:          .tAssignP
11705:       | * :
11710:    ]
      
11710:    [ cdecl
11713:       | true :
11714:          .tCallCdecl  @EmitValue( method )
11723:       | false :
11725:          .tCall   @EmitValue( method )
11734:    ]
      
11742:    [ isFunc
11745:       | true :
               % push return value from temp
11746:          oTypeSPush( resultType )
      
11752:          [ oTypeSNodeType
11754:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11763:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11773:             | nFileType :  #eNotImplemented
11777:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11787:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11789:                                .tPushAddrLocal  oEmitInt( tempOffset )
11797:          ]
11823:       | * :
11828:    ]
         
11828:    .tFreeActuals  oEmitInt( actualsSize )
11837:    ;
      
      
      
      % Called on first use of an extern method
      %
11837: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
11839:    int strAddr
11839:    String externalName = oNodeGetString( method, qExternalName )
11852:    [ equal_string( externalName, stringNull )
11862:       | true :
11863:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
11884:       | false :
11886:          strAddr = oStringAllocLit( externalName )
11896:    ]
11904:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
11920:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11920: CallBuiltInFunc( Node method ):
      
         % Ord(x)
11922:    [ oNodeEqual( method, BuiltIn_Ord )
11932:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
11933:          '('
11935:          @Expr
11937:          [ oTypeSNodeType
11939:             | nIntegerType, nEnumType :
11940:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
11944:             | * :  #eTypeMismatch
11959:          ]
11959:          oTypeSPop
11960:          oTypeSPush( IntegerType )
11966:          ')'
11968:          >>
11969:       | * :
11974:    ]
      
         % Chr(x)
11974:    [ oNodeEqual( method, BuiltIn_Chr )
11984:       | true :
               % parameter is integer
               % result is char
11985:          '('
11987:          @Expr
11989:          [ oTypeSNodeType
11991:             | nIntegerType :    .tCastItoB
11994:             | nByteType :
11996:             | * :  #eTypeMismatch
12005:          ]
12005:          oTypeSPop
12006:          oTypeSPush( CharType )
12012:          ')'
12014:          >>
12015:       | * :
12020:    ]
      
         % Pred(x)
12020:    [ oNodeEqual( method, BuiltIn_Pred )
12030:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12031:          '('
12033:          @Expr
12035:          [ oTypeSNodeType
12037:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12038:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12047:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12050:                   | * :
12055:                ]
12055:             | * :  #eTypeMismatch
12062:          ]
12062:          .tDecI
12064:          ')'
12066:          >>
12067:       | * :
12072:    ]
      
         % Succ(x)
12072:    [ oNodeEqual( method, BuiltIn_Succ )
12082:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12083:          '('
12085:          @Expr
12087:          [ oTypeSNodeType
12089:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12090:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12099:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12102:                   | * :
12107:                ]
12107:             | * :  #eTypeMismatch
12114:          ]
12114:          .tIncI
12116:          ')'
12118:          >>
12119:       | * :
12124:    ]
      
         % Sizeof(x)
12124:    [ oNodeEqual( method, BuiltIn_Sizeof )
12134:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12135:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12137:          Code dummyCode = oCodeNew
12142:          oCodePush( dummyCode )
12148:          @ExprAllowTypeName
12150:          oCodePop
12151:          oCodeDiscard( dummyCode )
12157:          Node theType = oTypeSTop
12162:          oTypeSPop
12163:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12178:          oTypeSPush( IntegerType )
12184:          ')'
12186:          >>
      
12187:       | * :
12192:    ]
      
12192:    #eNotImplemented
12195:    ;
      
12195: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12195: newType( node_type nt, int size ) >> Node:
12197:   Node node = oNodeNew( nt )
12207:   oNodeSetInt( node, qSize, size )
12219:   oTypeAdd( node )
12225:   >> node
12229:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12229: TypeRef( out Node resultType ):
12231:    [
12231:       | pIdent :           % previously named type (including intrinsics)
12233:          Node decl = oScopeFindRequire
12238:          @ResolveUnitRef( decl )
12245:          [ oNodeType( decl )
12252:             | nTypeDecl :
12253:                resultType = oNodeGet( decl, qType )
12266:             | * :
12271:                #eNotType
12273:                resultType = IntegerType
12279:          ]
         
12279:       | pArray :
12281:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12283:          NodeVec dimensions = oNodeVecNew
      
12288:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12288:             Node subrange = oNodeNew( nSubrangeType )
      
12298:             @ConstExpr
12300:             oNodeSetInt( subrange, qLow, oValueTop )
12311:             oValuePop
12312:             '..'
12314:             @ConstExpr
12316:             oNodeSetInt( subrange, qHigh, oValueTop )
12327:             oValuePop
      
12328:             @ConstMatchTypes
12330:             oNodeSet( subrange, qBaseType, oTypeSTop )
12341:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12359:             oTypeSPop
12360:             oTypeAdd( subrange )
      
12366:             Node a = oNodeNew( nArrayType )
12376:             oNodeSet( a, qIndexType, subrange )
      
12388:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12397:             [
12397:                | ']' : >
12401:                | ',' :
12403:             ]
12411:          }
      
12413:          pOf
12415:          Node baseType
12415:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12422:          int dim = oNodeVecSize( dimensions )
      
12432:          {
12432:              dec(dim)
      
12438:              Node a = oNodeVecElement( dimensions, dim )
      
12451:              oNodeSet( a, qBaseType, baseType )
12463:              Node subrange = oNodeGet( a, qIndexType )
12476:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12503:              inc( width )
12509:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12535:              oTypeAdd( a )
12541:              baseType = a
      
12547:              [ equal_zero(dim)
12554:                  | true:  >
12557:                  | *:
12562:              ]
12562:          }
      
12564:          resultType = oNodeVecElement( dimensions, 0 )
12577:          oNodeVecDelete( dimensions )
      
12583:       | '^' :
12585:          Node theType
12585:          @TypeRef( theType )
12592:          resultType = @PointerTypeTo( theType )
      
12603:       | pRecord :
12605:          resultType = oNodeNew( nRecordType )
12615:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12624:          @VarDecl( nRecordField )
      
12631:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12643:          [ equal_zero( size )
12650:             | true : #eRecordEmpty
12653:             | * :
12658:          ]
      
12658:          pEnd
      
12660:          oNodeSet( resultType, qScope, oScopeCurrent )
12671:          oNodeSetInt( resultType, qSize, size )
12683:          oScopeEnd
12684:          oTypeAdd( resultType )
      
      
12690:       | '(' :
               % An enum type declaration.
12692:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12699:       | pSet :
12701:          pOf
12703:          Node theType
12703:          @TypeRef( theType )
12710:          #eNotImplemented
12712:       | * :       % this works for cases except where expr starts with an id
12727:          @ConstExpr '..' @ConstExpr
12733:          @ConstMatchTypes
12735:          #eNotImplemented
12737:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12738: EnumTypeRef( out Node resultType ):
      
12740:    resultType = oNodeNew( nEnumType )
12750:    int value = 0
12756:    int numValues = 0
12762:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12768:    Node outerScope = oScopeCurrent
12773:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12782:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12782:       pIdent
12784:       Node decl = @newIdent( nEnumValue, LAST_ID )
12797:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12810:       oNodeSet( decl, qType, resultType )
12822:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
12834:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
12847:       oNodeSetInt( decl, qNameOffset, nameOffset )
12859:       oNodeSetInt( decl2, qNameOffset, nameOffset )
12871:       [
12871:          | '=', ':=' :
12873:             oTypeSPush( IntegerType )
12879:             @ConstExpr
12881:             @ConstCoerceType
12883:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
12884:             [ equal_zero( numValues )
12891:                | false :
12892:                   [ greater( oValueTop, value )
12901:                      | false :   #eEnumValueNotAscending
12904:                      | * :
12909:                   ]
12909:                | * :
12914:             ]
12914:             [ equal( value, oValueTop )
12923:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
12924:                   oNodeSetBoolean( resultType, qHasGap, true )
12936:                | * :
12941:             ]
12941:             value = oValueTop
12946:             oValuePop
12947:          | * :
12954:       ]
12954:       oNodeSetInt( decl, qValue, value )
12966:       oNodeSetInt( decl2, qValue, value )
12978:       oScopeDeclare( decl )
      
12984:       oScopeEnter( outerScope )
12990:       oScopeDeclare( decl2 )
12996:       oScopeEnd
      
12997:       inc( value )
13003:       inc( numValues )
13009:       [
13009:          | ',' :
13011:          | * :    >
13018:       ]
13018:    }
13020:    ')'
      
13022:    oNodeSet( resultType, qScope, oScopeCurrent )
13033:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13045:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13046:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13057:    oScopeEnter( globalScope )
13063:    int size = multiply( add( numValues, 1 ), 16 )
13083:    int addr = oScopeAlloc( size, 8 )
13096:    oScopeEnd
13097:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13109:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13129:    {
13129:       Node enumValue = oNodeIterValue( it )
13139:       [ oNodeNull( enumValue )
13146:          | true :  >
13149:          | * :
13154:       ]
13154:       .tPushAddrGlobal  oEmitInt( addr )
13162:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13177:       .tAssignI
13179:       addr = add( addr, 8 )
13192:       .tPushAddrGlobal  oEmitInt( addr )
13200:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13215:       .tAssignP
13217:       addr = add( addr, 8 )
13230:       oNodeIterNext( it )
13236:    }
         % final table entry
13238:    .tPushAddrGlobal  oEmitInt( addr )
13246:    .tPushConstI  oEmitInt( 0 )
13254:    .tAssignI
13256:    addr = add( addr, 8 )
13269:    .tPushAddrGlobal  oEmitInt( addr )
13277:    .tPushConstI  oEmitInt( 0 )
13285:    .tAssignP
13287:    addr = add( addr, 8 )
13300:    oCodePop
      
13301:    oTypeAdd( resultType )
13308:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13308: PointerTypeTo( Node theType ) >> Node:
13310:    Node ptrType = oNodeGet( theType, qPointerType )
13323:    [ oNodeNull( ptrType )
13330:       | true :
13331:          ptrType = oNodeNew( nPointerType )
13341:          oNodeSet( ptrType, qBaseType, theType )
13353:          oNodeSetInt( ptrType, qSize, 8 )
13365:          oTypeAdd( ptrType )
13371:          oNodeSet( theType, qPointerType, ptrType )
13383:       | * :
13388:    ]
13388:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13392: OrdinalLow( Node theType ) >> int:
13394:    [ oNodeType( theType )
13401:       | nIntegerType :  >> oMININT
13404:       | nBooleanType :  >> 0
13409:       | nCharType :     >> 0
13414:       | nEnumType :
13416:          Node enumScope = oNodeGet( theType, qScope )
13429:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13446:          >> oNodeGetInt( first, qValue )
13456:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13468:       | * :             #eNotOrdinalType
13483:                         >> 0
13486:    ];
      
      
      % Return the high value of an ordinal type
      %
13487: OrdinalHigh( Node theType ) >> int:
13489:    [ oNodeType( theType )
13496:       | nIntegerType :  >> oMAXINT
13499:       | nBooleanType :  >> 1
13504:       | nCharType :     >> 255
13509:       | nEnumType :
13511:          Node enumScope = oNodeGet( theType, qScope )
13524:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13541:          >> oNodeGetInt( last, qValue )
13551:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13563:       | * :             #eNotOrdinalType
13578:                         >> 0
13581:    ];
      
      
      
13582: Program:
13584:    Node t
      
13584:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13589:    oScopeBegin( 0, allocGlobal )
13598:    Node rootScope = oScopeCurrent
      
13603:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13605:    .tEnter  oEmitInt( 0 )
13613:    Label mainLabel = oLabelNew
      
13618:    .tAllocActuals  oEmitInt( 0 )
13626:    .tCall  oEmitLabel( mainLabel )
13634:    .tFreeActuals  oEmitInt( 0 )
13642:    .tReturn
      
13644:    pProgram
13646:    pIdent
      
13648:    Node program = oNodeNew( nProgram )
13658:    oNodeSetInt( program, qIdent, LAST_ID )
13669:    oNodeSet( workspace, qProgram, program )
      
      
13681:    [
13681:       | '(' :
13683:          pIdent      % input, output files
      
13685:          t = @newIdent( nVar, LAST_ID )
13698:          oNodeSet( t, qType, FileType )
13710:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13716:          ','
13718:          pIdent
      
13720:          t = @newIdent( nVar, LAST_ID )
13733:          oNodeSet( t, qType, FileType )
13745:          oScopeDeclareAlloc( t )
      
13751:          ')'
13753:       | * :
13758:    ]
13758:    ';'
      
13760:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13767:    [
13767:       | pUses :  @UsesClause( program )
13776:       | * :
13781:    ]
13781:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13788:    oScopeBegin( 0, allocGlobal )
13797:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13802:    oScopeBegin( 0, allocDown )
13811:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13822:    initScope = oScopeCurrent
13827:    oNodeSet( program, qMainRoutineScope, initScope )
13839:    oScopeEnd
      
13840:    @BlockDecls( nGlobalVar )
      
      
13847:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
13853:    boolean isMain = true
13859:    @BlockStmt( mainLabel, globalScope, isMain )
      
13872:    oScopeEnd   % main routine scope
      
13873:    '.'
13875:    @CheckForUndefinedLabels
13877:    oScopeEnd   % global scope
13878:    @EndUsedUnits( program )   % used units scopes
13886:    ;
      
      
      
      
13886: Block( node_type varNodeType, Label labelForBody ):
13888:    @BlockDecls( varNodeType )
13895:    @BlockStmt( labelForBody, oScopeCurrent, false )
13907:    @CheckForUndefinedLabels
13910:    ;
      
      
13910: BlockDecls( node_type varNodeType ):
13912:    {[
13912:       | pConst :     @ConstDecl
13916:       | pType :      @TypeDecl
13920:       | pVar :       @VarDecl( varNodeType )
13929:       | pLabel :     @LabelDecl
13933:       | pProcedure : @ProcDecl
13937:       | pFunction :  @FuncDecl
13941:       | * :          >
13958:    ]}
13960:    @CheckForUndefinedMethods
13963:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
13963: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
13966:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
13966: CheckForUndefinedLabels:
13968:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
13980:    {
13980:       Node decl = oNodeIterValue( it )
13990:       [ oNodeNull( decl )
13997:          | false :
13998:          | * :  >
14005:       ]
14005:       [ oNodeType( decl )
14012:          | nLabel :
14013:             [ oNodeGetBoolean( decl, qDefined )
14023:                | false :
14024:                   [ oNodeGetBoolean( decl, qUsed )
14034:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14037:                      | * :
14042:                   ]
14042:                | * :
14047:             ]
14047:          | * :
14052:       ]
14052:       oNodeIterNext( it )
14058:    }
14061:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14061: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14063:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14071:    int patchLS
14071:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14080:    [ isMain
14083:       | true :  @InitializeUnits
14086:       | * :
14091:    ]
      
         % insert any code for initialization of this scope's variables
14091:    Code initCode = oNodeGetCode( varScope, qInitCode )
14104:    oEmitCode( initCode )
14110:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14122:    @Statement
      
14124:    [ isMain
14127:       | true :  @FinalizeUnits
14130:       | * :
14135:    ]
      
14135:    .tReturn
      
14137:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14149:    oPatch( patchLS, localSpace )
14159:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14159: GetOrCreateInitCode( Node scope ) >> Code:
14161:    Code initCode = oNodeGetCode( scope, qInitCode )
14174:    [ equal_code( initCode, codeNull )
14184:       | true :
14185:          initCode = oCodeNew
14190:          oNodeSetCode( scope, qInitCode, initCode )
14202:       | * :
14207:    ]
14207:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14211: ScopeLevel >> int:
14213:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14223: DeclLevel( Node decl ) >> int:
14225:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14243: DeclUpLevels( Node decl ) >> int:
14245:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14261: newIdent( node_type nt, int id ) >> Node:
14263:   Node t = oNodeNew( nt )
14273:   oNodeSetInt( t, qIdent, id )
14285:   >> t
14289:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14289: EmitValue( Node decl ):
14291:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14305: DeclareBuiltInFunc( int id ) >> Node:
14307:    Node decl = @newIdent( nBuiltInFunc, id )
14321:    oScopeDeclare( decl )
14327:    >> decl;
      
      
14331: installBuiltIns:
      
         % initialize some other globals too
14333:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14339:    mysystemId = oId_mysystem
      
         % install built-in types
14344:    FileType = @newType( nFileType, 4 )
14358:    IntegerType = @newType( nIntegerType, 4 )
14372:    BooleanType = @newType( nBooleanType, 1 )
14386:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14400:    CharType = @newType( nCharType, 1 )
14414:    PCharType = @PointerTypeTo( CharType )
14425:    ByteType = @newType( nByteType, 1 )
14439:    SingleType = @newType( nSingleType, 4 )
14453:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14467:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14481:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14493:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14507:    ShortStringType = @newType( nShortStringType, 256 )
14521:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14533:    Node t
      
14533:    t = @newIdent( nTypeDecl, oId_File )
14546:    oNodeSet( t, qType, FileType )
14558:    oScopeDeclare( t )
      
14564:    t = @newIdent( nTypeDecl, oId_Integer )
14577:    oNodeSet( t, qType, IntegerType )
14589:    oScopeDeclare( t )
      
14595:    t = @newIdent( nTypeDecl, oId_Boolean )
14608:    oNodeSet( t, qType, BooleanType )
14620:    oScopeDeclare( t )
      
14626:    t = @newIdent( nTypeDecl, oId_Char )
14639:    oNodeSet( t, qType, CharType )
14651:    oScopeDeclare( t )
      
14657:    t = @newIdent( nTypeDecl, oId_Byte )
14670:    oNodeSet( t, qType, ByteType )
14682:    oScopeDeclare( t )
      
14688:    t = @newIdent( nTypeDecl, oId_Single )
14701:    oNodeSet( t, qType, SingleType )
14713:    oScopeDeclare( t )
      
14719:    t = @newIdent( nTypeDecl, oId_Double )
14732:    oNodeSet( t, qType, DoubleType )
14744:    oScopeDeclare( t )
      
14750:    t = @newIdent( nTypeDecl, oId_Pointer )
14763:    oNodeSet( t, qType, UniversalPointerType )
14775:    oScopeDeclare( t )
      
14781:    t = @newIdent( nTypeDecl, oId_ShortString )
14794:    oNodeSet( t, qType, ShortStringType )
14806:    oScopeDeclare( t )
      
         % Built-in constants
      
14812:    t = @newIdent( nConst, oId_True )
14825:    oNodeSet( t, qType, BooleanType )
14837:    oNodeSetInt( t, qValue, 1 )
14849:    oScopeDeclare( t )
      
14855:    t = @newIdent( nConst, oId_False )
14868:    oNodeSet( t, qType, BooleanType )
14880:    oNodeSetInt( t, qValue, 0 )
14892:    oScopeDeclare( t )
      
14898:    t = @newIdent( nConst, oId_Nil )
14911:    oNodeSet( t, qType, UniversalPointerType )
14923:    oNodeSetInt( t, qValue, 0 )
14935:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
14941:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
14951:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
14961:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
14971:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
14981:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
14992:    ;
      
14992: end
      
14992: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13582
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 26
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 25
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3213
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3269
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 13910
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 88
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 78
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 106
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8974
1083: oInputChoice 1089
1085: oCall 8974
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 77
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 88
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 78
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 106
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8974
1177: oInputChoice 1183
1179: oCall 8974
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 77
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 72
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 75
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 74
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 72
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 75
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 74
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14223
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 11837
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14261
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 22
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 22
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 14211
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13308
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 23
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 13886
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14261
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 22
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 22
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 14211
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13308
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 12229
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13308
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 23
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 13886
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 25
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14261
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 35
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 12229
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13308
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2683
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3568
2556: oTypeSNodeType
2557: oChoice 2640
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14261
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2661
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 19
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14261
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 34
2605: oPushResult
2606: oValueTopDouble
2607: oPushResult
2608: oNodeSetDouble
2609: oPop 3
2611: oJumpForward 2661
2613: oGetAddrLocal 2
2615: oPushResult
2616: oSetResult 18
2618: oPushResult
2619: oGetLocal 1
2621: oPushResult
2622: oCall 14261
2624: oPop 2
2626: oAssign
2627: oGetLocal 2
2629: oPushResult
2630: oSetResult 33
2632: oPushResult
2633: oValueTopString
2634: oPushResult
2635: oNodeSetString
2636: oPop 3
2638: oJumpForward 2661
2640: Choice Lookup Table
          42   2613
          33   2586
          38   2559
          37   2559
          44   2559
          31   2559
          36   2559
          30   2559
          34   2559
2659: oError 18
2661: oValuePop
2662: oGetLocal 2
2664: oPushResult
2665: oSetResult 21
2667: oPushResult
2668: oTypeSTop
2669: oPushResult
2670: oNodeSet
2671: oPop 3
2673: oTypeSPop
2674: oGetLocal 2
2676: oPushResult
2677: oScopeDeclare
2678: oPop 1
2680: oInput 6
2682: oReturn
2683: oLocalSpace 3
2685: oGetAddrLocal 1
2687: oPushResult
2688: oSetResult 26
2690: oPushResult
2691: LAST_ID
2692: oPushResult
2693: oCall 14261
2695: oPop 2
2697: oAssign
2698: oGetAddrLocal 2
2700: oPushResult
2701: oCall 12229
2703: oPop 1
2705: oGetLocal 1
2707: oPushResult
2708: oSetResult 21
2710: oPushResult
2711: oGetLocal 2
2713: oPushResult
2714: oNodeSet
2715: oPop 3
2717: oGetLocal 2
2719: oPushResult
2720: oNodeType
2721: oPop 1
2723: oChoice 2827
2725: oInput 7
2727: oGetLocal 2
2729: oPushResult
2730: oTypeSPush
2731: oPop 1
2733: oCall 3568
2735: oCall 4395
2737: oGetLocal 1
2739: oPushResult
2740: oSetResult 22
2742: oPushResult
2743: oValueTop
2744: oPushResult
2745: oNodeSetInt
2746: oPop 3
2748: oValuePop
2749: oTypeSPop
2750: oGetLocal 1
2752: oPushResult
2753: oScopeDeclare
2754: oPop 1
2756: oInput 6
2758: oJumpForward 2851
2760: oError 17
2762: oJumpForward 2851
2764: oGetGlobal 2
2766: oPushResult
2767: oScopeEnter
2768: oPop 1
2770: oGetAddrLocal 3
2772: oPushResult
2773: oGetLocal 2
2775: oPushResult
2776: oScopeAllocType
2777: oPop 1
2779: oAssign
2780: oScopeEnd
2781: oGetGlobal 2
2783: oPushResult
2784: oCall 14159
2786: oPop 1
2788: oPushResult
2789: oCodePush
2790: oPop 1
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oGetLocal 3
2800: oPushResult
2801: oNodeSetInt
2802: oPop 3
2804: oInput 7
2806: oGetLocal 2
2808: oPushResult
2809: oGetLocal 3
2811: oPushResult
2812: oCall 2852
2814: oPop 2
2816: oCodePop
2817: oGetLocal 1
2819: oPushResult
2820: oScopeDeclare
2821: oPop 1
2823: oInput 6
2825: oJumpForward 2851
2827: Choice Lookup Table
          41   2764
          39   2764
          29   2760
          43   2760
          38   2725
          37   2725
          44   2725
          31   2725
          36   2725
          30   2725
          34   2725
2850: oEndChoice
2851: oReturn
2852: oLocalSpace 10
2854: oGetParam 2
2856: oPushResult
2857: oNodeType
2858: oPop 1
2860: oChoice 3186
2862: oGetAddrLocal 1
2864: oPushResult
2865: oGetParam 2
2867: oPushResult
2868: oSetResult 38
2870: oPushResult
2871: oNodeGet
2872: oPop 2
2874: oAssign
2875: oGetAddrLocal 2
2877: oPushResult
2878: oGetParam 2
2880: oPushResult
2881: oSetResult 39
2883: oPushResult
2884: oNodeGet
2885: oPop 2
2887: oAssign
2888: oGetAddrLocal 3
2890: oPushResult
2891: oGetLocal 2
2893: oPushResult
2894: oCall 13392
2896: oPop 1
2898: oAssign
2899: oGetAddrLocal 4
2901: oPushResult
2902: oGetLocal 2
2904: oPushResult
2905: oCall 13487
2907: oPop 1
2909: oAssign
2910: oGetAddrLocal 5
2912: oPushResult
2913: oGetLocal 1
2915: oPushResult
2916: oSetResult 17
2918: oPushResult
2919: oNodeGetInt
2920: oPop 2
2922: oAssign
2923: oInput 15
2925: oGetAddrLocal 6
2927: oPushResult
2928: oGetLocal 3
2930: oAssign
2931: oGetLocal 1
2933: oPushResult
2934: oGetParam 1
2936: oPushResult
2937: oCall 2852
2939: oPop 2
2941: oGetLocal 6
2943: oPushResult
2944: oGetLocal 4
2946: oPushResult
2947: equal
2948: oPop 2
2950: oChoice 2958
2952: oJumpForward 2987
2954: oJumpForward 2964
2956: oJumpForward 2964
2958: Choice Lookup Table
           0   2956
           1   2952
2963: oEndChoice
2964: oInput 14
2966: oGetAddrParam 1
2968: oPushResult
2969: oGetParam 1
2971: oPushResult
2972: oGetLocal 5
2974: oPushResult
2975: add
2976: oPop 2
2978: oAssign
2979: oGetAddrLocal 6
2981: oPushResult
2982: inc
2983: oPop 1
2985: oJumpBack 2931
2987: oInput 16
2989: oJumpForward 3212
2991: oInput 15
2993: oGetAddrLocal 7
2995: oPushResult
2996: oGetParam 2
2998: oPushResult
2999: oSetResult 42
3001: oPushResult
3002: oNodeGet
3003: oPop 2
3005: oAssign
3006: oInputChoice 3010
3008: oJumpForward 3015
3010: Choice Lookup Table
           0   3008
3013: oJumpForward 3081
3015: oGetAddrLocal 8
3017: oPushResult
3018: oGetLocal 7
3020: oPushResult
3021: oScopeFindRequireInScope
3022: oPop 1
3024: oAssign
3025: oInput 13
3027: oGetAddrLocal 9
3029: oPushResult
3030: oGetLocal 8
3032: oPushResult
3033: oSetResult 21
3035: oPushResult
3036: oNodeGet
3037: oPop 2
3039: oAssign
3040: oGetAddrLocal 10
3042: oPushResult
3043: oGetParam 1
3045: oPushResult
3046: oGetLocal 8
3048: oPushResult
3049: oSetResult 22
3051: oPushResult
3052: oNodeGetInt
3053: oPop 2
3055: oPushResult
3056: add
3057: oPop 2
3059: oAssign
3060: oGetLocal 9
3062: oPushResult
3063: oGetLocal 10
3065: oPushResult
3066: oCall 2852
3068: oPop 2
3070: oInputChoice 3074
3072: oJumpForward 3079
3074: Choice Lookup Table
           6   3072
3077: oJumpForward 3081
3079: oJumpBack 3006
3081: oInput 16
3083: oJumpForward 3212
3085: oEmit 17
3087: oGetParam 1
3089: oPushResult
3090: oEmitInt
3091: oPop 1
3093: oGetParam 2
3095: oPushResult
3096: oTypeSPush
3097: oPop 1
3099: oCall 3568
3101: oCall 4395
3103: oEmit 15
3105: oValueTop
3106: oPushResult
3107: oEmitInt
3108: oPop 1
3110: oValuePop
3111: oTypeSPop
3112: oEmit 28
3114: oJumpForward 3212
3116: oEmit 17
3118: oGetParam 1
3120: oPushResult
3121: oEmitInt
3122: oPop 1
3124: oGetParam 2
3126: oPushResult
3127: oTypeSPush
3128: oPop 1
3130: oCall 3568
3132: oCall 4395
3134: oEmit 15
3136: oValueTop
3137: oPushResult
3138: oEmitInt
3139: oPop 1
3141: oValuePop
3142: oTypeSPop
3143: oEmit 27
3145: oJumpForward 3212
3147: oError 17
3149: oJumpForward 3212
3151: oEmit 17
3153: oGetParam 1
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oGetParam 2
3161: oPushResult
3162: oTypeSPush
3163: oPop 1
3165: oCall 3568
3167: oCall 4395
3169: oEmit 15
3171: oValueTop
3172: oPushResult
3173: oEmitInt
3174: oPop 1
3176: oValuePop
3177: oTypeSPop
3178: oEmit 29
3180: oJumpForward 3212
3182: oError 17
3184: oJumpForward 3212
3186: Choice Lookup Table
          29   3182
          43   3182
          38   3151
          37   3151
          33   3147
          44   3116
          31   3116
          36   3085
          30   3085
          34   3085
          41   2991
          39   2862
3211: oEndChoice
3212: oReturn
3213: oLocalSpace 2
3215: oInputChoice 3261
3217: oGetAddrLocal 1
3219: oPushResult
3220: oSetResult 20
3222: oPushResult
3223: LAST_ID
3224: oPushResult
3225: oCall 14261
3227: oPop 2
3229: oAssign
3230: oInput 7
3232: oGetAddrLocal 2
3234: oPushResult
3235: oCall 12229
3237: oPop 1
3239: oGetLocal 1
3241: oPushResult
3242: oSetResult 21
3244: oPushResult
3245: oGetLocal 2
3247: oPushResult
3248: oNodeSet
3249: oPop 3
3251: oGetLocal 1
3253: oPushResult
3254: oScopeDeclare
3255: oPop 1
3257: oInput 6
3259: oJumpForward 3266
3261: Choice Lookup Table
           0   3217
3264: oJumpForward 3268
3266: oJumpBack 3215
3268: oReturn
3269: oLocalSpace 6
3271: oInputChoice 3495
3273: oGetAddrLocal 1
3275: oPushResult
3276: oNodeVecNew
3277: oAssign
3278: oGetAddrLocal 2
3280: oPushResult
3281: oGetParam 1
3283: oPushResult
3284: LAST_ID
3285: oPushResult
3286: oCall 14261
3288: oPop 2
3290: oAssign
3291: oGetLocal 1
3293: oPushResult
3294: oGetLocal 2
3296: oPushResult
3297: oNodeVecAppend
3298: oPop 2
3300: oInputChoice 3306
3302: oInput 0
3304: oJumpForward 3311
3306: Choice Lookup Table
          14   3302
3309: oJumpForward 3313
3311: oJumpBack 3278
3313: oInput 13
3315: oGetAddrLocal 3
3317: oPushResult
3318: oCall 12229
3320: oPop 1
3322: oGetAddrLocal 4
3324: oPushResult
3325: oSetResult 0
3327: oAssign
3328: oGetLocal 4
3330: oPushResult
3331: oGetLocal 1
3333: oPushResult
3334: oNodeVecSize
3335: oPop 1
3337: oPushResult
3338: equal
3339: oPop 2
3341: oChoice 3382
3343: oGetAddrLocal 2
3345: oPushResult
3346: oGetLocal 1
3348: oPushResult
3349: oGetLocal 4
3351: oPushResult
3352: oNodeVecElement
3353: oPop 2
3355: oAssign
3356: oGetLocal 2
3358: oPushResult
3359: oSetResult 21
3361: oPushResult
3362: oGetLocal 3
3364: oPushResult
3365: oNodeSet
3366: oPop 3
3368: oGetLocal 2
3370: oPushResult
3371: oScopeDeclareAlloc
3372: oPop 1
3374: oGetAddrLocal 4
3376: oPushResult
3377: inc
3378: oPop 1
3380: oJumpForward 3387
3382: Choice Lookup Table
           0   3343
3385: oJumpForward 3389
3387: oJumpBack 3328
3389: oInputChoice 3482
3391: oGetLocal 1
3393: oPushResult
3394: oNodeVecSize
3395: oPop 1
3397: oChoice 3401
3399: oJumpForward 3406
3401: Choice Lookup Table
           1   3399
3404: oError 23
3406: oGetAddrLocal 5
3408: oPushResult
3409: oScopeCurrent
3410: oPushResult
3411: oCall 14159
3413: oPop 1
3415: oAssign
3416: oGetLocal 5
3418: oPushResult
3419: oCodePush
3420: oPop 1
3422: oGetAddrLocal 6
3424: oPushResult
3425: oSetResult 0
3427: oAssign
3428: oCall 14211
3430: oPushResult
3431: equal_zero
3432: oPop 1
3434: oChoice 3450
3436: oGetGlobal 3
3438: oPushResult
3439: oScopeEnter
3440: oPop 1
3442: oGetAddrLocal 6
3444: oPushResult
3445: oSetResult 1
3447: oAssign
3448: oJumpForward 3453
3450: Choice Lookup Table
           1   3436
3453: oGetLocal 2
3455: oPushResult
3456: oSetResult 1
3458: oPushResult
3459: oCall 9672
3461: oPop 2
3463: oCall 4931
3465: oCall 8437
3467: oCall 9220
3469: oGetLocal 6
3471: oChoice 3476
3473: oScopeEnd
3474: oJumpForward 3479
3476: Choice Lookup Table
           1   3473
3479: oCodePop
3480: oJumpForward 3485
3482: Choice Lookup Table
           7   3391
3485: oGetLocal 1
3487: oPushResult
3488: oNodeVecDelete
3489: oPop 1
3491: oInput 6
3493: oJumpForward 3500
3495: Choice Lookup Table
           0   3273
3498: oJumpForward 3502
3500: oJumpBack 3271
3502: oReturn
3503: oLocalSpace 2
3505: oInputChoice 3512
3507: oJumpForward 3518
3509: oChangeIntLitToLabelIdent
3510: oJumpForward 3518
3512: Choice Lookup Table
           1   3509
           0   3507
3517: oEndChoice
3518: oGetAddrLocal 1
3520: oPushResult
3521: oSetResult 27
3523: oPushResult
3524: LAST_ID
3525: oPushResult
3526: oCall 14261
3528: oPop 2
3530: oAssign
3531: oGetAddrLocal 2
3533: oPushResult
3534: oLabelNew
3535: oAssign
3536: oGetLocal 1
3538: oPushResult
3539: oSetResult 22
3541: oPushResult
3542: oGetLocal 2
3544: oPushResult
3545: oNodeSetLabel
3546: oPop 3
3548: oGetLocal 1
3550: oPushResult
3551: oScopeDeclare
3552: oPop 1
3554: oInputChoice 3558
3556: oJumpForward 3563
3558: Choice Lookup Table
          14   3556
3561: oJumpForward 3565
3563: oJumpBack 3505
3565: oInput 6
3567: oReturn
3568: oLocalSpace 0
3570: oCall 3795
3572: oInputChoice 3754
3574: oCall 3818
3576: oCall 4298
3578: oTypeSNodeType
3579: oChoice 3591
3581: oValueStringCmp
3582: oSetResult 0
3584: oPushResult
3585: oValuePush
3586: oPop 1
3588: oValueEqual
3589: oJumpForward 3595
3591: Choice Lookup Table
          42   3581
3594: oValueEqual
3595: oTypeSPop
3596: oGetGlobal 7
3598: oPushResult
3599: oTypeSPush
3600: oPop 1
3602: oJumpForward 3769
3604: oCall 3795
3606: oCall 4298
3608: oTypeSNodeType
3609: oChoice 3621
3611: oValueStringCmp
3612: oSetResult 0
3614: oPushResult
3615: oValuePush
3616: oPop 1
3618: oValueNotEqual
3619: oJumpForward 3625
3621: Choice Lookup Table
          42   3611
3624: oValueNotEqual
3625: oTypeSPop
3626: oGetGlobal 7
3628: oPushResult
3629: oTypeSPush
3630: oPop 1
3632: oJumpForward 3769
3634: oCall 3795
3636: oCall 4298
3638: oTypeSNodeType
3639: oChoice 3651
3641: oValueStringCmp
3642: oSetResult 0
3644: oPushResult
3645: oValuePush
3646: oPop 1
3648: oValueLess
3649: oJumpForward 3655
3651: Choice Lookup Table
          42   3641
3654: oValueLess
3655: oTypeSPop
3656: oGetGlobal 7
3658: oPushResult
3659: oTypeSPush
3660: oPop 1
3662: oJumpForward 3769
3664: oCall 3795
3666: oCall 4298
3668: oTypeSNodeType
3669: oChoice 3681
3671: oValueStringCmp
3672: oSetResult 0
3674: oPushResult
3675: oValuePush
3676: oPop 1
3678: oValueGreater
3679: oJumpForward 3685
3681: Choice Lookup Table
          42   3671
3684: oValueGreater
3685: oTypeSPop
3686: oGetGlobal 7
3688: oPushResult
3689: oTypeSPush
3690: oPop 1
3692: oJumpForward 3769
3694: oCall 3795
3696: oCall 4298
3698: oTypeSNodeType
3699: oChoice 3711
3701: oValueStringCmp
3702: oSetResult 0
3704: oPushResult
3705: oValuePush
3706: oPop 1
3708: oValueLessEqual
3709: oJumpForward 3715
3711: Choice Lookup Table
          42   3701
3714: oValueLessEqual
3715: oTypeSPop
3716: oGetGlobal 7
3718: oPushResult
3719: oTypeSPush
3720: oPop 1
3722: oJumpForward 3769
3724: oCall 3795
3726: oCall 4298
3728: oTypeSNodeType
3729: oChoice 3741
3731: oValueStringCmp
3732: oSetResult 0
3734: oPushResult
3735: oValuePush
3736: oPop 1
3738: oValueGreaterEqual
3739: oJumpForward 3745
3741: Choice Lookup Table
          42   3731
3744: oValueGreaterEqual
3745: oTypeSPop
3746: oGetGlobal 7
3748: oPushResult
3749: oTypeSPush
3750: oPop 1
3752: oJumpForward 3769
3754: Choice Lookup Table
          12   3724
          11   3694
          10   3664
           9   3634
           8   3604
           7   3574
3767: oJumpForward 3771
3769: oJumpBack 3572
3771: oReturn
3772: oLocalSpace 1
3774: oGetAddrLocal 1
3776: oPushResult
3777: oGetGlobal 25
3779: oAssign
3780: oGetAddrGlobal 25
3782: oPushResult
3783: oSetResult 1
3785: oAssign
3786: oCall 3568
3788: oGetAddrGlobal 25
3790: oPushResult
3791: oGetLocal 1
3793: oAssign
3794: oReturn
3795: oLocalSpace 0
3797: oCall 3818
3799: oInputChoice 3810
3801: oCall 4285
3803: oCall 3818
3805: oCall 4271
3807: oValueOr
3808: oJumpForward 3815
3810: Choice Lookup Table
          58   3801
3813: oJumpForward 3817
3815: oJumpBack 3799
3817: oReturn
3818: oLocalSpace 0
3820: oCall 3841
3822: oInputChoice 3833
3824: oCall 4285
3826: oCall 3841
3828: oCall 4271
3830: oValueAnd
3831: oJumpForward 3838
3833: Choice Lookup Table
          57   3824
3836: oJumpForward 3840
3838: oJumpBack 3822
3840: oReturn
3841: oLocalSpace 0
3843: oInputChoice 3852
3845: oCall 3841
3847: oCall 4285
3849: oValueNot
3850: oJumpForward 3857
3852: Choice Lookup Table
          59   3845
3855: oCall 3858
3857: oReturn
3858: oLocalSpace 0
3860: oCall 3907
3862: oInputChoice 3897
3864: oCall 3907
3866: oCall 4298
3868: oTypeSNodeType
3869: oChoice 3874
3871: oValueStringConcat
3872: oJumpForward 3878
3874: Choice Lookup Table
          42   3871
3877: oValueAdd
3878: oJumpForward 3904
3880: oCall 3907
3882: oCall 4298
3884: oTypeSNodeType
3885: oChoice 3891
3887: oError 18
3889: oJumpForward 3895
3891: Choice Lookup Table
          42   3887
3894: oValueSub
3895: oJumpForward 3904
3897: Choice Lookup Table
          26   3880
          25   3864
3902: oJumpForward 3906
3904: oJumpBack 3862
3906: oReturn
3907: oLocalSpace 0
3909: oCall 3957
3911: oInputChoice 3947
3913: oCall 3957
3915: oCall 4298
3917: oTypeSNodeType
3918: oChoice 3924
3920: oError 18
3922: oJumpForward 3928
3924: Choice Lookup Table
          42   3920
3927: oValueMult
3928: oJumpForward 3954
3930: oCall 3957
3932: oCall 4298
3934: oTypeSNodeType
3935: oChoice 3941
3937: oError 18
3939: oJumpForward 3945
3941: Choice Lookup Table
          42   3937
3944: oValueDiv
3945: oJumpForward 3954
3947: Choice Lookup Table
          24   3930
          23   3913
3952: oJumpForward 3956
3954: oJumpBack 3911
3956: oReturn
3957: oLocalSpace 0
3959: oInputChoice 3970
3961: oCall 3978
3963: oJumpForward 3977
3965: oCall 3978
3967: oValueNegate
3968: oJumpForward 3977
3970: Choice Lookup Table
          26   3965
          25   3961
3975: oCall 3978
3977: oReturn
3978: oLocalSpace 1
3980: oInputChoice 4241
3982: TOKEN_VALUE
3983: oPushResult
3984: oValuePush
3985: oPop 1
3987: oGetGlobal 6
3989: oPushResult
3990: oTypeSPush
3991: oPop 1
3993: oJumpForward 4270
3995: TOKEN_VALUE
3996: oPushResult
3997: oValuePush
3998: oPop 1
4000: oGetGlobal 9
4002: oPushResult
4003: oTypeSPush
4004: oPop 1
4006: oJumpForward 4270
4008: TOKEN_VALUE_DOUBLE
4009: oPushResult
4010: oValuePushDouble
4011: oPop 1
4013: oGetGlobal 13
4015: oPushResult
4016: oTypeSPush
4017: oPop 1
4019: oJumpForward 4270
4021: CURRENT_STRLIT
4022: oPushResult
4023: oValuePushString
4024: oPop 1
4026: oGetGlobal 15
4028: oPushResult
4029: oTypeSPush
4030: oPop 1
4032: oJumpForward 4270
4034: oCall 3568
4036: oInput 16
4038: oJumpForward 4270
4040: oGetAddrLocal 1
4042: oPushResult
4043: oScopeFindRequire
4044: oAssign
4045: oGetAddrLocal 1
4047: oPushResult
4048: oCall 244
4050: oPop 1
4052: oGetLocal 1
4054: oPushResult
4055: oNodeType
4056: oPop 1
4058: oChoice 4198
4060: oGetLocal 1
4062: oPushResult
4063: oCall 4665
4065: oPop 1
4067: oJumpForward 4223
4069: oGetLocal 1
4071: oPushResult
4072: oSetResult 22
4074: oPushResult
4075: oNodeGetInt
4076: oPop 2
4078: oPushResult
4079: oValuePush
4080: oPop 1
4082: oGetLocal 1
4084: oPushResult
4085: oSetResult 21
4087: oPushResult
4088: oNodeGet
4089: oPop 2
4091: oPushResult
4092: oTypeSPush
4093: oPop 1
4095: oJumpForward 4223
4097: oGetLocal 1
4099: oPushResult
4100: oSetResult 33
4102: oPushResult
4103: oNodeGetString
4104: oPop 2
4106: oPushResult
4107: oValuePushString
4108: oPop 1
4110: oGetLocal 1
4112: oPushResult
4113: oSetResult 21
4115: oPushResult
4116: oNodeGet
4117: oPop 2
4119: oPushResult
4120: oTypeSPush
4121: oPop 1
4123: oJumpForward 4223
4125: oGetLocal 1
4127: oPushResult
4128: oSetResult 22
4130: oPushResult
4131: oNodeGetInt
4132: oPop 2
4134: oPushResult
4135: oValuePush
4136: oPop 1
4138: oGetLocal 1
4140: oPushResult
4141: oSetResult 21
4143: oPushResult
4144: oNodeGet
4145: oPop 2
4147: oPushResult
4148: oTypeSPush
4149: oPop 1
4151: oJumpForward 4223
4153: oGetLocal 1
4155: oPushResult
4156: oSetResult 21
4158: oPushResult
4159: oNodeGet
4160: oPop 2
4162: oPushResult
4163: oTypeSPush
4164: oPop 1
4166: oInputChoice 4176
4168: oCall 3568
4170: oInput 16
4172: oCall 4516
4174: oJumpForward 4196
4176: Choice Lookup Table
          15   4168
4179: oGetGlobal 25
4181: oChoice 4191
4183: oSetResult 0
4185: oPushResult
4186: oValuePush
4187: oPop 1
4189: oJumpForward 4196
4191: Choice Lookup Table
           1   4183
4194: oError 32
4196: oJumpForward 4223
4198: Choice Lookup Table
          20   4153
          17   4125
          18   4097
          16   4069
          14   4060
4209: oError 1
4211: oSetResult 0
4213: oPushResult
4214: oValuePush
4215: oPop 1
4217: oGetGlobal 6
4219: oPushResult
4220: oTypeSPush
4221: oPop 1
4223: oJumpForward 4270
4225: oError 17
4227: oSetResult 0
4229: oPushResult
4230: oValuePush
4231: oPop 1
4233: oGetGlobal 14
4235: oPushResult
4236: oTypeSPush
4237: oPop 1
4239: oJumpForward 4270
4241: Choice Lookup Table
          20   4225
           0   4040
          15   4034
           3   4021
           2   4008
           4   3995
           1   3982
4256: oError 1
4258: oSetResult 0
4260: oPushResult
4261: oValuePush
4262: oPop 1
4264: oGetGlobal 6
4266: oPushResult
4267: oTypeSPush
4268: oPop 1
4270: oReturn
4271: oLocalSpace 0
4273: oTypeSNodeType
4274: oChoice 4278
4276: oJumpForward 4283
4278: Choice Lookup Table
          34   4276
4281: oError 8
4283: oTypeSPop
4284: oReturn
4285: oLocalSpace 0
4287: oTypeSNodeType
4288: oChoice 4292
4290: oJumpForward 4297
4292: Choice Lookup Table
          34   4290
4295: oError 8
4297: oReturn
4298: oLocalSpace 1
4300: oGetAddrLocal 1
4302: oPushResult
4303: oTypeSNodeType
4304: oAssign
4305: oTypeSPop
4306: oGetLocal 1
4308: oPushResult
4309: oTypeSNodeType
4310: oPushResult
4311: equal_node_type
4312: oPop 2
4314: oChoice 4391
4316: oTypeSNodeType
4317: oChoice 4378
4319: oGetLocal 1
4321: oChoice 4326
4323: oReturn
4324: oJumpForward 4329
4326: Choice Lookup Table
          38   4323
4329: oJumpForward 4387
4331: oGetLocal 1
4333: oChoice 4338
4335: oReturn
4336: oJumpForward 4341
4338: Choice Lookup Table
          37   4335
4341: oJumpForward 4387
4343: oGetLocal 1
4345: oChoice 4351
4347: oValueCharToString
4348: oReturn
4349: oJumpForward 4354
4351: Choice Lookup Table
          36   4347
4354: oJumpForward 4387
4356: oGetLocal 1
4358: oChoice 4373
4360: oValueSwap
4361: oValueCharToString
4362: oValueSwap
4363: oTypeSPop
4364: oGetGlobal 15
4366: oPushResult
4367: oTypeSPush
4368: oPop 1
4370: oReturn
4371: oJumpForward 4376
4373: Choice Lookup Table
          42   4360
4376: oJumpForward 4387
4378: Choice Lookup Table
          36   4356
          42   4343
          38   4331
          37   4319
4387: oError 15
4389: oJumpForward 4394
4391: Choice Lookup Table
           0   4316
4394: oReturn
4395: oLocalSpace 1
4397: oGetAddrLocal 1
4399: oPushResult
4400: oTypeSNodeType
4401: oAssign
4402: oTypeSPop
4403: oGetLocal 1
4405: oPushResult
4406: oTypeSNodeType
4407: oPushResult
4408: equal_node_type
4409: oPop 2
4411: oChoice 4512
4413: oTypeSNodeType
4414: oChoice 4495
4416: oGetLocal 1
4418: oChoice 4423
4420: oReturn
4421: oJumpForward 4426
4423: Choice Lookup Table
          30   4420
4426: oJumpForward 4508
4428: oGetLocal 1
4430: oChoice 4435
4432: oReturn
4433: oJumpForward 4438
4435: Choice Lookup Table
          31   4432
4438: oJumpForward 4508
4440: oGetLocal 1
4442: oChoice 4447
4444: oReturn
4445: oJumpForward 4450
4447: Choice Lookup Table
          38   4444
4450: oJumpForward 4508
4452: oGetLocal 1
4454: oChoice 4459
4456: oReturn
4457: oJumpForward 4462
4459: Choice Lookup Table
          37   4456
4462: oJumpForward 4508
4464: oGetLocal 1
4466: oChoice 4472
4468: oValueCharToString
4469: oReturn
4470: oJumpForward 4475
4472: Choice Lookup Table
          36   4468
4475: oJumpForward 4508
4477: oGetLocal 1
4479: oChoice 4488
4481: oReturn
4482: oJumpForward 4493
4484: oValueCharToString
4485: oReturn
4486: oJumpForward 4493
4488: Choice Lookup Table
          36   4484
          42   4481
4493: oJumpForward 4508
4495: Choice Lookup Table
          43   4477
          42   4464
          38   4452
          37   4440
          30   4428
          31   4416
4508: oError 15
4510: oJumpForward 4515
4512: Choice Lookup Table
           0   4413
4515: oReturn
4516: oLocalSpace 1
4518: oGetAddrLocal 1
4520: oPushResult
4521: oTypeSNodeType
4522: oAssign
4523: oTypeSPop
4524: oGetLocal 1
4526: oPushResult
4527: oTypeSNodeType
4528: oPushResult
4529: equal_node_type
4530: oPop 2
4532: oChoice 4661
4534: oTypeSNodeType
4535: oChoice 4638
4537: oGetLocal 1
4539: oChoice 4547
4541: oReturn
4542: oJumpForward 4558
4544: oReturn
4545: oJumpForward 4558
4547: Choice Lookup Table
          44   4544
          31   4544
          34   4541
          36   4541
          30   4541
4558: oJumpForward 4657
4560: oGetLocal 1
4562: oChoice 4570
4564: oReturn
4565: oJumpForward 4581
4567: oReturn
4568: oJumpForward 4581
4570: Choice Lookup Table
          44   4567
          31   4567
          34   4564
          36   4564
          30   4564
4581: oJumpForward 4657
4583: oGetLocal 1
4585: oChoice 4590
4587: oReturn
4588: oJumpForward 4593
4590: Choice Lookup Table
          38   4587
4593: oJumpForward 4657
4595: oGetLocal 1
4597: oChoice 4602
4599: oReturn
4600: oJumpForward 4605
4602: Choice Lookup Table
          37   4599
4605: oJumpForward 4657
4607: oGetLocal 1
4609: oChoice 4615
4611: oValueCharToString
4612: oReturn
4613: oJumpForward 4618
4615: Choice Lookup Table
          36   4611
4618: oJumpForward 4657
4620: oGetLocal 1
4622: oChoice 4631
4624: oReturn
4625: oJumpForward 4636
4627: oValueCharToString
4628: oReturn
4629: oJumpForward 4636
4631: Choice Lookup Table
          36   4627
          42   4624
4636: oJumpForward 4657
4638: Choice Lookup Table
          43   4620
          42   4607
          38   4595
          37   4583
          34   4560
          36   4560
          30   4560
          44   4537
          31   4537
4657: oError 15
4659: oJumpForward 4664
4661: Choice Lookup Table
           0   4534
4664: oReturn
4665: oLocalSpace 1
4667: oGetParam 1
4669: oPushResult
4670: oGetGlobal 17
4672: oPushResult
4673: oNodeEqual
4674: oPop 2
4676: oChoice 4716
4678: oInput 15
4680: oCall 3568
4682: oInput 16
4684: oTypeSNodeType
4685: oChoice 4691
4687: oJumpForward 4704
4689: oJumpForward 4704
4691: Choice Lookup Table
          36   4689
          30   4689
          34   4689
          44   4687
          31   4687
4702: oError 15
4704: oTypeSPop
4705: oGetGlobal 6
4707: oPushResult
4708: oTypeSPush
4709: oPop 1
4711: oInput 16
4713: oReturn
4714: oJumpForward 4719
4716: Choice Lookup Table
           1   4678
4719: oGetParam 1
4721: oPushResult
4722: oGetGlobal 18
4724: oPushResult
4725: oNodeEqual
4726: oPop 2
4728: oChoice 4762
4730: oInput 15
4732: oCall 3568
4734: oInput 16
4736: oTypeSNodeType
4737: oChoice 4743
4739: oJumpForward 4750
4741: oJumpForward 4750
4743: Choice Lookup Table
          30   4741
          31   4739
4748: oError 15
4750: oTypeSPop
4751: oGetGlobal 9
4753: oPushResult
4754: oTypeSPush
4755: oPop 1
4757: oInput 16
4759: oReturn
4760: oJumpForward 4765
4762: Choice Lookup Table
           1   4730
4765: oGetParam 1
4767: oPushResult
4768: oGetGlobal 19
4770: oPushResult
4771: oNodeEqual
4772: oPop 2
4774: oChoice 4819
4776: oInput 15
4778: oCall 3568
4780: oTypeSNodeType
4781: oChoice 4802
4783: oTypeSTop
4784: oPushResult
4785: oSetResult 45
4787: oPushResult
4788: oNodeGetBoolean
4789: oPop 2
4791: oChoice 4797
4793: oError 29
4795: oJumpForward 4800
4797: Choice Lookup Table
           1   4793
4800: oJumpForward 4807
4802: Choice Lookup Table
          44   4783
4805: oError 15
4807: oSetResult 1
4809: oPushResult
4810: oValuePush
4811: oPop 1
4813: oValueSub
4814: oInput 16
4816: oReturn
4817: oJumpForward 4822
4819: Choice Lookup Table
           1   4776
4822: oGetParam 1
4824: oPushResult
4825: oGetGlobal 20
4827: oPushResult
4828: oNodeEqual
4829: oPop 2
4831: oChoice 4876
4833: oInput 15
4835: oCall 3568
4837: oTypeSNodeType
4838: oChoice 4859
4840: oTypeSTop
4841: oPushResult
4842: oSetResult 45
4844: oPushResult
4845: oNodeGetBoolean
4846: oPop 2
4848: oChoice 4854
4850: oError 29
4852: oJumpForward 4857
4854: Choice Lookup Table
           1   4850
4857: oJumpForward 4864
4859: Choice Lookup Table
          44   4840
4862: oError 15
4864: oSetResult 1
4866: oPushResult
4867: oValuePush
4868: oPop 1
4870: oValueAdd
4871: oInput 16
4873: oReturn
4874: oJumpForward 4879
4876: Choice Lookup Table
           1   4833
4879: oGetParam 1
4881: oPushResult
4882: oGetGlobal 21
4884: oPushResult
4885: oNodeEqual
4886: oPop 2
4888: oChoice 4925
4890: oInput 15
4892: oCall 3772
4894: oValuePop
4895: oGetAddrLocal 1
4897: oPushResult
4898: oTypeSTop
4899: oAssign
4900: oTypeSPop
4901: oGetLocal 1
4903: oPushResult
4904: oSetResult 17
4906: oPushResult
4907: oNodeGetInt
4908: oPop 2
4910: oPushResult
4911: oValuePush
4912: oPop 1
4914: oGetGlobal 6
4916: oPushResult
4917: oTypeSPush
4918: oPop 1
4920: oInput 16
4922: oReturn
4923: oJumpForward 4928
4925: Choice Lookup Table
           1   4890
4928: oError 17
4930: oReturn
4931: oLocalSpace 1
4933: oGetAddrLocal 1
4935: oPushResult
4936: oSetResult 0
4938: oAssign
4939: oGetAddrLocal 1
4941: oPushResult
4942: oCall 5115
4944: oPop 1
4946: oGetAddrLocal 1
4948: oPushResult
4949: oCall 5015
4951: oPop 1
4953: oReturn
4954: oLocalSpace 1
4956: oGetAddrLocal 1
4958: oPushResult
4959: oGetGlobal 25
4961: oAssign
4962: oGetAddrGlobal 25
4964: oPushResult
4965: oSetResult 1
4967: oAssign
4968: oCall 4931
4970: oGetAddrGlobal 25
4972: oPushResult
4973: oGetLocal 1
4975: oAssign
4976: oReturn
4977: oLocalSpace 0
4979: oGetParam 1
4981: oPushResult
4982: oCall 5115
4984: oPop 1
4986: oTypeSNodeType
4987: oChoice 5006
4989: oJumpForward 5013
4991: oGetParam 1
4993: oPushResult
4994: oLabelNew
4995: oAssign
4996: oEmit 81
4998: oGetFromParam 1
5000: oPushResult
5001: oEmitLabel
5002: oPop 1
5004: oJumpForward 5013
5006: Choice Lookup Table
          34   4991
          35   4989
5011: oError 8
5013: oTypeSPop
5014: oReturn
5015: oLocalSpace 1
5017: oTypeSNodeType
5018: oChoice 5080
5020: oGetAddrLocal 1
5022: oPushResult
5023: oLabelNew
5024: oAssign
5025: oEmit 15
5027: oSetResult 1
5029: oPushResult
5030: oEmitInt
5031: oPop 1
5033: oEmit 79
5035: oGetLocal 1
5037: oPushResult
5038: oEmitLabel
5039: oPop 1
5041: oEmit 88
5043: oGetFromParam 1
5045: oPushResult
5046: oEmitLabel
5047: oPop 1
5049: oEmit 15
5051: oSetResult 0
5053: oPushResult
5054: oEmitInt
5055: oPop 1
5057: oEmit 88
5059: oGetLocal 1
5061: oPushResult
5062: oEmitLabel
5063: oPop 1
5065: oTypeSPop
5066: oGetGlobal 7
5068: oPushResult
5069: oTypeSPush
5070: oPop 1
5072: oGetParam 1
5074: oPushResult
5075: oSetResult 0
5077: oAssign
5078: oJumpForward 5083
5080: Choice Lookup Table
          35   5020
5083: oReturn
5084: oLocalSpace 0
5086: oTypeSNodeType
5087: oChoice 5111
5089: oGetParam 1
5091: oPushResult
5092: oLabelNew
5093: oAssign
5094: oEmit 81
5096: oGetFromParam 1
5098: oPushResult
5099: oEmitLabel
5100: oPop 1
5102: oTypeSPop
5103: oGetGlobal 8
5105: oPushResult
5106: oTypeSPush
5107: oPop 1
5109: oJumpForward 5114
5111: Choice Lookup Table
          34   5089
5114: oReturn
5115: oLocalSpace 0
5117: oGetParam 1
5119: oPushResult
5120: oCall 5648
5122: oPop 1
5124: oInputChoice 5630
5126: oGetParam 1
5128: oPushResult
5129: oCall 5015
5131: oPop 1
5133: oCall 8905
5135: oGetParam 1
5137: oPushResult
5138: oCall 5648
5140: oPop 1
5142: oGetParam 1
5144: oPushResult
5145: oCall 5015
5147: oPop 1
5149: oCall 8905
5151: oCall 8774
5153: oTypeSNodeType
5154: oChoice 5182
5156: oEmit 50
5158: oJumpForward 5201
5160: oEmit 56
5162: oJumpForward 5201
5164: oEmit 62
5166: oJumpForward 5201
5168: oCall 11155
5170: oEmit 15
5172: oSetResult 0
5174: oPushResult
5175: oEmitInt
5176: oPop 1
5178: oEmit 56
5180: oJumpForward 5201
5182: Choice Lookup Table
          42   5168
          43   5168
          38   5164
          37   5164
          44   5160
          31   5160
          36   5156
          34   5156
5199: oError 18
5201: oTypeSPop
5202: oGetGlobal 7
5204: oPushResult
5205: oTypeSPush
5206: oPop 1
5208: oJumpForward 5645
5210: oGetParam 1
5212: oPushResult
5213: oCall 5015
5215: oPop 1
5217: oCall 8905
5219: oGetParam 1
5221: oPushResult
5222: oCall 5648
5224: oPop 1
5226: oGetParam 1
5228: oPushResult
5229: oCall 5015
5231: oPop 1
5233: oCall 8905
5235: oCall 8774
5237: oTypeSNodeType
5238: oChoice 5266
5240: oEmit 51
5242: oJumpForward 5285
5244: oEmit 57
5246: oJumpForward 5285
5248: oEmit 63
5250: oJumpForward 5285
5252: oCall 11155
5254: oEmit 15
5256: oSetResult 0
5258: oPushResult
5259: oEmitInt
5260: oPop 1
5262: oEmit 57
5264: oJumpForward 5285
5266: Choice Lookup Table
          42   5252
          43   5252
          38   5248
          37   5248
          44   5244
          31   5244
          36   5240
          34   5240
5283: oError 18
5285: oTypeSPop
5286: oGetGlobal 7
5288: oPushResult
5289: oTypeSPush
5290: oPop 1
5292: oJumpForward 5645
5294: oGetParam 1
5296: oPushResult
5297: oCall 5015
5299: oPop 1
5301: oCall 8905
5303: oGetParam 1
5305: oPushResult
5306: oCall 5648
5308: oPop 1
5310: oGetParam 1
5312: oPushResult
5313: oCall 5015
5315: oPop 1
5317: oCall 8905
5319: oCall 8774
5321: oTypeSNodeType
5322: oChoice 5350
5324: oEmit 53
5326: oJumpForward 5369
5328: oEmit 59
5330: oJumpForward 5369
5332: oEmit 65
5334: oJumpForward 5369
5336: oCall 11155
5338: oEmit 15
5340: oSetResult 0
5342: oPushResult
5343: oEmitInt
5344: oPop 1
5346: oEmit 59
5348: oJumpForward 5369
5350: Choice Lookup Table
          42   5336
          43   5336
          38   5332
          37   5332
          44   5328
          31   5328
          36   5324
          34   5324
5367: oError 18
5369: oTypeSPop
5370: oGetGlobal 7
5372: oPushResult
5373: oTypeSPush
5374: oPop 1
5376: oJumpForward 5645
5378: oGetParam 1
5380: oPushResult
5381: oCall 5015
5383: oPop 1
5385: oCall 8905
5387: oGetParam 1
5389: oPushResult
5390: oCall 5648
5392: oPop 1
5394: oGetParam 1
5396: oPushResult
5397: oCall 5015
5399: oPop 1
5401: oCall 8905
5403: oCall 8774
5405: oTypeSNodeType
5406: oChoice 5434
5408: oEmit 52
5410: oJumpForward 5453
5412: oEmit 58
5414: oJumpForward 5453
5416: oEmit 64
5418: oJumpForward 5453
5420: oCall 11155
5422: oEmit 15
5424: oSetResult 0
5426: oPushResult
5427: oEmitInt
5428: oPop 1
5430: oEmit 58
5432: oJumpForward 5453
5434: Choice Lookup Table
          42   5420
          43   5420
          38   5416
          37   5416
          44   5412
          31   5412
          36   5408
          34   5408
5451: oError 18
5453: oTypeSPop
5454: oGetGlobal 7
5456: oPushResult
5457: oTypeSPush
5458: oPop 1
5460: oJumpForward 5645
5462: oGetParam 1
5464: oPushResult
5465: oCall 5015
5467: oPop 1
5469: oCall 8905
5471: oGetParam 1
5473: oPushResult
5474: oCall 5648
5476: oPop 1
5478: oGetParam 1
5480: oPushResult
5481: oCall 5015
5483: oPop 1
5485: oCall 8905
5487: oCall 8774
5489: oTypeSNodeType
5490: oChoice 5518
5492: oEmit 55
5494: oJumpForward 5537
5496: oEmit 61
5498: oJumpForward 5537
5500: oEmit 67
5502: oJumpForward 5537
5504: oCall 11155
5506: oEmit 15
5508: oSetResult 0
5510: oPushResult
5511: oEmitInt
5512: oPop 1
5514: oEmit 61
5516: oJumpForward 5537
5518: Choice Lookup Table
          42   5504
          43   5504
          38   5500
          37   5500
          44   5496
          31   5496
          36   5492
          34   5492
5535: oError 18
5537: oTypeSPop
5538: oGetGlobal 7
5540: oPushResult
5541: oTypeSPush
5542: oPop 1
5544: oJumpForward 5645
5546: oGetParam 1
5548: oPushResult
5549: oCall 5015
5551: oPop 1
5553: oCall 8905
5555: oGetParam 1
5557: oPushResult
5558: oCall 5648
5560: oPop 1
5562: oGetParam 1
5564: oPushResult
5565: oCall 5015
5567: oPop 1
5569: oCall 8905
5571: oCall 8774
5573: oTypeSNodeType
5574: oChoice 5602
5576: oEmit 54
5578: oJumpForward 5621
5580: oEmit 60
5582: oJumpForward 5621
5584: oEmit 66
5586: oJumpForward 5621
5588: oCall 11155
5590: oEmit 15
5592: oSetResult 0
5594: oPushResult
5595: oEmitInt
5596: oPop 1
5598: oEmit 60
5600: oJumpForward 5621
5602: Choice Lookup Table
          42   5588
          43   5588
          38   5584
          37   5584
          44   5580
          31   5580
          36   5576
          34   5576
5619: oError 18
5621: oTypeSPop
5622: oGetGlobal 7
5624: oPushResult
5625: oTypeSPush
5626: oPop 1
5628: oJumpForward 5645
5630: Choice Lookup Table
          12   5546
          11   5462
          10   5378
           9   5294
           8   5210
           7   5126
5643: oJumpForward 5647
5645: oJumpBack 5124
5647: oReturn
5648: oLocalSpace 1
5650: oGetAddrLocal 1
5652: oPushResult
5653: oSetResult 0
5655: oAssign
5656: oGetParam 1
5658: oPushResult
5659: oCall 5828
5661: oPop 1
5663: oInputChoice 5796
5665: oTypeSNodeType
5666: oChoice 5737
5668: oGetLocal 1
5670: oPushResult
5671: oSetResult 0
5673: oPushResult
5674: equal_label
5675: oPop 2
5677: oChoice 5686
5679: oGetAddrLocal 1
5681: oPushResult
5682: oLabelNew
5683: oAssign
5684: oJumpForward 5689
5686: Choice Lookup Table
           1   5679
5689: oEmit 79
5691: oGetLocal 1
5693: oPushResult
5694: oEmitLabel
5695: oPop 1
5697: oJumpForward 5744
5699: oGetParam 1
5701: oPushResult
5702: oCall 5084
5704: oPop 1
5706: oGetLocal 1
5708: oPushResult
5709: oSetResult 0
5711: oPushResult
5712: equal_label
5713: oPop 2
5715: oChoice 5724
5717: oGetAddrLocal 1
5719: oPushResult
5720: oLabelNew
5721: oAssign
5722: oJumpForward 5727
5724: Choice Lookup Table
           1   5717
5727: oEmit 79
5729: oGetLocal 1
5731: oPushResult
5732: oEmitLabel
5733: oPop 1
5735: oJumpForward 5744
5737: Choice Lookup Table
          34   5699
          35   5668
5742: oError 8
5744: oTypeSPop
5745: oEmit 88
5747: oGetFromParam 1
5749: oPushResult
5750: oEmitLabel
5751: oPop 1
5753: oGetParam 1
5755: oPushResult
5756: oSetResult 0
5758: oAssign
5759: oGetParam 1
5761: oPushResult
5762: oCall 5828
5764: oPop 1
5766: oTypeSNodeType
5767: oChoice 5780
5769: oJumpForward 5787
5771: oGetParam 1
5773: oPushResult
5774: oCall 5084
5776: oPop 1
5778: oJumpForward 5787
5780: Choice Lookup Table
          34   5771
          35   5769
5785: oError 8
5787: oTypeSPop
5788: oGetGlobal 8
5790: oPushResult
5791: oTypeSPush
5792: oPop 1
5794: oJumpForward 5801
5796: Choice Lookup Table
          58   5665
5799: oJumpForward 5803
5801: oJumpBack 5663
5803: oGetLocal 1
5805: oPushResult
5806: oSetResult 0
5808: oPushResult
5809: equal_label
5810: oPop 2
5812: oChoice 5824
5814: oEmit 88
5816: oGetLocal 1
5818: oPushResult
5819: oEmitLabel
5820: oPop 1
5822: oJumpForward 5827
5824: Choice Lookup Table
           0   5814
5827: oReturn
5828: oLocalSpace 2
5830: oGetAddrLocal 1
5832: oPushResult
5833: oSetResult 0
5835: oAssign
5836: oGetParam 1
5838: oPushResult
5839: oCall 5966
5841: oPop 1
5843: oInputChoice 5958
5845: oTypeSNodeType
5846: oChoice 5859
5848: oJumpForward 5866
5850: oGetParam 1
5852: oPushResult
5853: oCall 5084
5855: oPop 1
5857: oJumpForward 5866
5859: Choice Lookup Table
          34   5850
          35   5848
5864: oError 8
5866: oTypeSPop
5867: oGetLocal 1
5869: oPushResult
5870: oSetResult 0
5872: oPushResult
5873: equal_label
5874: oPop 2
5876: oChoice 5905
5878: oGetAddrLocal 1
5880: oPushResult
5881: oLabelNew
5882: oAssign
5883: oEmit 89
5885: oGetFromParam 1
5887: oPushResult
5888: oEmitLabel
5889: oPop 1
5891: oGetLocal 1
5893: oPushResult
5894: oEmitLabel
5895: oPop 1
5897: oGetParam 1
5899: oPushResult
5900: oGetLocal 1
5902: oAssign
5903: oJumpForward 5908
5905: Choice Lookup Table
           1   5878
5908: oGetAddrLocal 2
5910: oPushResult
5911: oSetResult 0
5913: oAssign
5914: oGetAddrLocal 2
5916: oPushResult
5917: oCall 5966
5919: oPop 1
5921: oTypeSNodeType
5922: oChoice 5935
5924: oJumpForward 5942
5926: oGetAddrLocal 2
5928: oPushResult
5929: oCall 5084
5931: oPop 1
5933: oJumpForward 5942
5935: Choice Lookup Table
          34   5926
          35   5924
5940: oError 8
5942: oEmit 89
5944: oGetLocal 2
5946: oPushResult
5947: oEmitLabel
5948: oPop 1
5950: oGetLocal 1
5952: oPushResult
5953: oEmitLabel
5954: oPop 1
5956: oJumpForward 5963
5958: Choice Lookup Table
          57   5845
5961: oJumpForward 5965
5963: oJumpBack 5843
5965: oReturn
5966: oLocalSpace 1
5968: oInputChoice 6022
5970: oGetAddrLocal 1
5972: oPushResult
5973: oSetResult 0
5975: oAssign
5976: oGetAddrLocal 1
5978: oPushResult
5979: oCall 5966
5981: oPop 1
5983: oTypeSNodeType
5984: oChoice 6013
5986: oGetParam 1
5988: oPushResult
5989: oLabelNew
5990: oAssign
5991: oEmit 79
5993: oGetFromParam 1
5995: oPushResult
5996: oEmitLabel
5997: oPop 1
5999: oEmit 88
6001: oGetLocal 1
6003: oPushResult
6004: oEmitLabel
6005: oPop 1
6007: oJumpForward 6020
6009: oEmit 49
6011: oJumpForward 6020
6013: Choice Lookup Table
          34   6009
          35   5986
6018: oError 8
6020: oJumpForward 6032
6022: Choice Lookup Table
          59   5970
6025: oGetParam 1
6027: oPushResult
6028: oCall 6033
6030: oPop 1
6032: oReturn
6033: oLocalSpace 2
6035: oGetAddrLocal 1
6037: oPushResult
6038: oSetResult 1
6040: oAssign
6041: oGetParam 1
6043: oPushResult
6044: oCall 6299
6046: oPop 1
6048: oInputChoice 6289
6050: oTypeSNodeType
6051: oChoice 6187
6053: oCall 8859
6055: oGetParam 1
6057: oPushResult
6058: oCall 6299
6060: oPop 1
6062: oTypeSNodeType
6063: oChoice 6071
6065: oEmit 23
6067: oCall 8222
6069: oJumpForward 6080
6071: Choice Lookup Table
          38   6065
          37   6065
6076: oCall 8879
6078: oEmit 39
6080: oJumpForward 6206
6082: oGetParam 1
6084: oPushResult
6085: oCall 6299
6087: oPop 1
6089: oCall 8925
6091: oEmit 46
6093: oJumpForward 6206
6095: oGetLocal 1
6097: oChoice 6113
6099: oGetAddrLocal 2
6101: oPushResult
6102: oCall 10938
6104: oAssign
6105: oGetAddrLocal 1
6107: oPushResult
6108: oSetResult 0
6110: oAssign
6111: oJumpForward 6116
6113: Choice Lookup Table
           1   6099
6116: oGetParam 1
6118: oPushResult
6119: oCall 6299
6121: oPop 1
6123: oTypeSNodeType
6124: oChoice 6162
6126: oCall 11047
6128: oEmit 18
6130: oGetLocal 2
6132: oPushResult
6133: oEmitInt
6134: oPop 1
6136: oGetGlobal 16
6138: oPushResult
6139: oTypeSPush
6140: oPop 1
6142: oJumpForward 6172
6144: oCall 11101
6146: oEmit 18
6148: oGetLocal 2
6150: oPushResult
6151: oEmitInt
6152: oPop 1
6154: oGetGlobal 16
6156: oPushResult
6157: oTypeSPush
6158: oPop 1
6160: oJumpForward 6172
6162: Choice Lookup Table
          36   6144
          42   6126
          43   6126
6169: oError 15
6171: oTypeSPop
6172: oJumpForward 6206
6174: oGetParam 1
6176: oPushResult
6177: oCall 6299
6179: oPop 1
6181: oCall 8859
6183: oCall 8222
6185: oJumpForward 6206
6187: Choice Lookup Table
          38   6174
          37   6174
          36   6095
          42   6095
          43   6095
          33   6082
          30   6053
          31   6053
6204: oError 18
6206: oJumpForward 6296
6208: oTypeSNodeType
6209: oChoice 6274
6211: oCall 8859
6213: oGetParam 1
6215: oPushResult
6216: oCall 6299
6218: oPop 1
6220: oCall 8879
6222: oEmit 42
6224: oJumpForward 6287
6226: oGetParam 1
6228: oPushResult
6229: oCall 6299
6231: oPop 1
6233: oCall 8925
6235: oEmit 47
6237: oJumpForward 6287
6239: oGetParam 1
6241: oPushResult
6242: oCall 6299
6244: oPop 1
6246: oTypeSNodeType
6247: oChoice 6261
6249: oCall 8859
6251: oCall 8278
6253: oJumpForward 6272
6255: oCall 8774
6257: oCall 8334
6259: oJumpForward 6272
6261: Choice Lookup Table
          38   6255
          37   6255
          30   6249
          31   6249
6270: oError 18
6272: oJumpForward 6287
6274: Choice Lookup Table
          38   6239
          37   6239
          33   6226
          30   6211
          31   6211
6285: oError 18
6287: oJumpForward 6296
6289: Choice Lookup Table
          26   6208
          25   6050
6294: oJumpForward 6298
6296: oJumpBack 6048
6298: oReturn
6299: oLocalSpace 0
6301: oGetParam 1
6303: oPushResult
6304: oCall 6404
6306: oPop 1
6308: oInputChoice 6394
6310: oTypeSNodeType
6311: oChoice 6341
6313: oCall 8859
6315: oGetParam 1
6317: oPushResult
6318: oCall 6404
6320: oPop 1
6322: oCall 8879
6324: oEmit 36
6326: oJumpForward 6350
6328: oGetParam 1
6330: oPushResult
6331: oCall 6404
6333: oPop 1
6335: oCall 8925
6337: oEmit 44
6339: oJumpForward 6350
6341: Choice Lookup Table
          33   6328
          30   6313
          31   6313
6348: oError 18
6350: oJumpForward 6401
6352: oTypeSNodeType
6353: oChoice 6383
6355: oCall 8859
6357: oGetParam 1
6359: oPushResult
6360: oCall 6404
6362: oPop 1
6364: oCall 8879
6366: oEmit 37
6368: oJumpForward 6392
6370: oGetParam 1
6372: oPushResult
6373: oCall 6404
6375: oPop 1
6377: oCall 8925
6379: oEmit 45
6381: oJumpForward 6392
6383: Choice Lookup Table
          33   6370
          30   6355
          31   6355
6390: oError 18
6392: oJumpForward 6401
6394: Choice Lookup Table
          24   6352
          23   6310
6399: oJumpForward 6403
6401: oJumpBack 6308
6403: oReturn
6404: oLocalSpace 0
6406: oInputChoice 6464
6408: oGetParam 1
6410: oPushResult
6411: oCall 6477
6413: oPop 1
6415: oTypeSNodeType
6416: oChoice 6422
6418: oJumpForward 6431
6420: oJumpForward 6431
6422: Choice Lookup Table
          33   6420
          30   6418
          31   6418
6429: oError 18
6431: oJumpForward 6476
6433: oGetParam 1
6435: oPushResult
6436: oCall 6477
6438: oPop 1
6440: oTypeSNodeType
6441: oChoice 6453
6443: oCall 8879
6445: oEmit 43
6447: oJumpForward 6462
6449: oEmit 48
6451: oJumpForward 6462
6453: Choice Lookup Table
          33   6449
          30   6443
          31   6443
6460: oError 18
6462: oJumpForward 6476
6464: Choice Lookup Table
          26   6433
          25   6408
6469: oGetParam 1
6471: oPushResult
6472: oCall 6477
6474: oPop 1
6476: oReturn
6477: oLocalSpace 7
6479: oInputChoice 6983
6481: oEmit 15
6483: TOKEN_VALUE
6484: oPushResult
6485: oEmitInt
6486: oPop 1
6488: oGetGlobal 6
6490: oPushResult
6491: oTypeSPush
6492: oPop 1
6494: oJumpForward 7006
6496: oEmit 15
6498: TOKEN_VALUE
6499: oPushResult
6500: oEmitInt
6501: oPop 1
6503: oGetGlobal 9
6505: oPushResult
6506: oTypeSPush
6507: oPop 1
6509: oJumpForward 7006
6511: oEmit 16
6513: TOKEN_VALUE_DOUBLE
6514: oPushResult
6515: oEmitDouble
6516: oPop 1
6518: oGetGlobal 13
6520: oPushResult
6521: oTypeSPush
6522: oPop 1
6524: oJumpForward 7006
6526: oGetParam 1
6528: oPushResult
6529: oCall 5115
6531: oPop 1
6533: oInput 16
6535: oJumpForward 7006
6537: oGetAddrLocal 1
6539: oPushResult
6540: CURRENT_STRLIT
6541: oPushResult
6542: oStringAllocShortStringLit
6543: oPop 1
6545: oAssign
6546: oEmit 17
6548: oGetLocal 1
6550: oPushResult
6551: oEmitInt
6552: oPop 1
6554: oGetGlobal 15
6556: oPushResult
6557: oTypeSPush
6558: oPop 1
6560: oCall 7820
6562: oCall 7766
6564: oJumpForward 7006
6566: oGetAddrLocal 2
6568: oPushResult
6569: oScopeFindRequire
6570: oAssign
6571: oGetAddrLocal 2
6573: oPushResult
6574: oCall 244
6576: oPop 1
6578: oGetLocal 2
6580: oPushResult
6581: oNodeType
6582: oPop 1
6584: oChoice 6901
6586: oGetLocal 2
6588: oPushResult
6589: oCall 11250
6591: oPop 1
6593: oJumpForward 6932
6595: oGetLocal 2
6597: oPushResult
6598: oCall 11920
6600: oPop 1
6602: oJumpForward 6932
6604: oGetAddrLocal 3
6606: oPushResult
6607: oGetLocal 2
6609: oPushResult
6610: oSetResult 21
6612: oPushResult
6613: oNodeGet
6614: oPop 2
6616: oAssign
6617: oGetLocal 3
6619: oPushResult
6620: oTypeSPush
6621: oPop 1
6623: oTypeSNodeType
6624: oChoice 6648
6626: oEmit 15
6628: oGetLocal 2
6630: oPushResult
6631: oCall 14289
6633: oPop 1
6635: oJumpForward 6665
6637: oEmit 15
6639: oGetLocal 2
6641: oPushResult
6642: oCall 14289
6644: oPop 1
6646: oJumpForward 6665
6648: Choice Lookup Table
          38   6637
          37   6637
          30   6626
          36   6626
          34   6626
          44   6626
          31   6626
6663: oError 17
6665: oJumpForward 6932
6667: oGetAddrLocal 3
6669: oPushResult
6670: oGetLocal 2
6672: oPushResult
6673: oSetResult 21
6675: oPushResult
6676: oNodeGet
6677: oPop 2
6679: oAssign
6680: oGetLocal 3
6682: oPushResult
6683: oTypeSPush
6684: oPop 1
6686: oTypeSNodeType
6687: oChoice 6706
6689: oEmit 16
6691: oGetLocal 2
6693: oPushResult
6694: oSetResult 34
6696: oPushResult
6697: oNodeGetDouble
6698: oPop 2
6700: oPushResult
6701: oEmitDouble
6702: oPop 1
6704: oJumpForward 6711
6706: Choice Lookup Table
          33   6689
6709: oError 17
6711: oJumpForward 6932
6713: oGetAddrLocal 4
6715: oPushResult
6716: oGetLocal 2
6718: oPushResult
6719: oSetResult 22
6721: oPushResult
6722: oNodeGetInt
6723: oPop 2
6725: oAssign
6726: oGetLocal 4
6728: oPushResult
6729: equal_zero
6730: oPop 1
6732: oChoice 6765
6734: oGetAddrLocal 4
6736: oPushResult
6737: oGetLocal 2
6739: oPushResult
6740: oSetResult 33
6742: oPushResult
6743: oNodeGetString
6744: oPop 2
6746: oPushResult
6747: oStringAllocShortStringLit
6748: oPop 1
6750: oAssign
6751: oGetLocal 2
6753: oPushResult
6754: oSetResult 22
6756: oPushResult
6757: oGetLocal 4
6759: oPushResult
6760: oNodeSetInt
6761: oPop 3
6763: oJumpForward 6768
6765: Choice Lookup Table
           1   6734
6768: oEmit 17
6770: oGetLocal 4
6772: oPushResult
6773: oEmitInt
6774: oPop 1
6776: oGetGlobal 15
6778: oPushResult
6779: oTypeSPush
6780: oPop 1
6782: oCall 7820
6784: oCall 7766
6786: oJumpForward 6932
6788: oGetLocal 2
6790: oPushResult
6791: oCall 7007
6793: oPop 1
6795: oJumpForward 6932
6797: oGetLocal 2
6799: oPushResult
6800: oSetResult 21
6802: oPushResult
6803: oNodeGet
6804: oPop 2
6806: oPushResult
6807: oTypeSPush
6808: oPop 1
6810: oInputChoice 6877
6812: oCall 4931
6814: oInput 16
6816: oCall 8594
6818: oTypeSNodeType
6819: oChoice 6864
6821: oInputChoice 6851
6823: oTypeSPop
6824: oGetLocal 3
6826: oPushResult
6827: oSetResult 38
6829: oPushResult
6830: oNodeGet
6831: oPop 2
6833: oPushResult
6834: oTypeSPush
6835: oPop 1
6837: oCall 7820
6839: oCall 7766
6841: oJumpForward 6856
6843: oCall 8015
6845: oCall 7820
6847: oCall 7766
6849: oJumpForward 6856
6851: Choice Lookup Table
          17   6843
          19   6823
6856: oJumpForward 6875
6858: oCall 7820
6860: oCall 7766
6862: oJumpForward 6875
6864: Choice Lookup Table
          43   6858
          41   6858
          39   6858
          38   6821
          37   6821
6875: oJumpForward 6899
6877: Choice Lookup Table
          15   6812
6880: oGetGlobal 25
6882: oChoice 6894
6884: oEmit 15
6886: oSetResult 0
6888: oPushResult
6889: oEmitInt
6890: oPop 1
6892: oJumpForward 6899
6894: Choice Lookup Table
           1   6884
6897: oError 32
6899: oJumpForward 6932
6901: Choice Lookup Table
          20   6797
          26   6788
          25   6788
          23   6788
          22   6788
          18   6713
          19   6667
          17   6604
          16   6604
          14   6595
          13   6586
6924: oError 6
6926: oGetGlobal 6
6928: oPushResult
6929: oTypeSPush
6930: oPop 1
6932: oJumpForward 7006
6934: oInput 0
6936: oGetAddrLocal 5
6938: oPushResult
6939: oScopeFindRequire
6940: oAssign
6941: oGetAddrLocal 5
6943: oPushResult
6944: oCall 244
6946: oPop 1
6948: oGetLocal 5
6950: oPushResult
6951: oSetResult 0
6953: oPushResult
6954: oCall 9455
6956: oPop 2
6958: oGetAddrLocal 6
6960: oPushResult
6961: oTypeSTop
6962: oAssign
6963: oTypeSPop
6964: oGetAddrLocal 7
6966: oPushResult
6967: oGetLocal 6
6969: oPushResult
6970: oCall 13308
6972: oPop 1
6974: oAssign
6975: oGetLocal 7
6977: oPushResult
6978: oTypeSPush
6979: oPop 1
6981: oJumpForward 7006
6983: Choice Lookup Table
          20   6934
           0   6566
           3   6537
          15   6526
           2   6511
           4   6496
           1   6481
6998: oError 6
7000: oGetGlobal 6
7002: oPushResult
7003: oTypeSPush
7004: oPop 1
7006: oReturn
7007: oLocalSpace 2
7009: oGetAddrLocal 1
7011: oPushResult
7012: oGetParam 1
7014: oPushResult
7015: oSetResult 21
7017: oPushResult
7018: oNodeGet
7019: oPop 2
7021: oAssign
7022: oGetAddrLocal 2
7024: oPushResult
7025: oGetParam 1
7027: oPushResult
7028: oCall 14243
7030: oPop 1
7032: oAssign
7033: oGetLocal 1
7035: oPushResult
7036: oTypeSPush
7037: oPop 1
7039: oTypeSNodeType
7040: oChoice 7739
7042: oGetParam 1
7044: oPushResult
7045: oNodeType
7046: oPop 1
7048: oChoice 7194
7050: oEmit 0
7052: oGetParam 1
7054: oPushResult
7055: oCall 14289
7057: oPop 1
7059: oJumpForward 7204
7061: oGetLocal 2
7063: oPushResult
7064: equal_zero
7065: oPop 1
7067: oChoice 7080
7069: oEmit 3
7071: oGetParam 1
7073: oPushResult
7074: oCall 14289
7076: oPop 1
7078: oJumpForward 7098
7080: Choice Lookup Table
           1   7069
7083: oEmit 9
7085: oGetLocal 2
7087: oPushResult
7088: oEmitInt
7089: oPop 1
7091: oGetParam 1
7093: oPushResult
7094: oCall 14289
7096: oPop 1
7098: oJumpForward 7204
7100: oGetParam 1
7102: oPushResult
7103: oSetResult 35
7105: oPushResult
7106: oNodeGetBoolean
7107: oPop 2
7109: oChoice 7152
7111: oGetLocal 2
7113: oPushResult
7114: equal_zero
7115: oPop 1
7117: oChoice 7130
7119: oEmit 8
7121: oGetParam 1
7123: oPushResult
7124: oCall 14289
7126: oPop 1
7128: oJumpForward 7148
7130: Choice Lookup Table
           1   7119
7133: oEmit 14
7135: oGetLocal 2
7137: oPushResult
7138: oEmitInt
7139: oPop 1
7141: oGetParam 1
7143: oPushResult
7144: oCall 14289
7146: oPop 1
7148: oEmit 24
7150: oJumpForward 7192
7152: Choice Lookup Table
           1   7111
7155: oGetLocal 2
7157: oPushResult
7158: equal_zero
7159: oPop 1
7161: oChoice 7174
7163: oEmit 6
7165: oGetParam 1
7167: oPushResult
7168: oCall 14289
7170: oPop 1
7172: oJumpForward 7192
7174: Choice Lookup Table
           1   7163
7177: oEmit 12
7179: oGetLocal 2
7181: oPushResult
7182: oEmitInt
7183: oPop 1
7185: oGetParam 1
7187: oPushResult
7188: oCall 14289
7190: oPop 1
7192: oJumpForward 7204
7194: Choice Lookup Table
          25   7100
          23   7061
          26   7050
          22   7050
7203: oEndChoice
7204: oJumpForward 7765
7206: oGetParam 1
7208: oPushResult
7209: oNodeType
7210: oPop 1
7212: oChoice 7358
7214: oEmit 1
7216: oGetParam 1
7218: oPushResult
7219: oCall 14289
7221: oPop 1
7223: oJumpForward 7368
7225: oGetLocal 2
7227: oPushResult
7228: equal_zero
7229: oPop 1
7231: oChoice 7244
7233: oEmit 4
7235: oGetParam 1
7237: oPushResult
7238: oCall 14289
7240: oPop 1
7242: oJumpForward 7262
7244: Choice Lookup Table
           1   7233
7247: oEmit 10
7249: oGetLocal 2
7251: oPushResult
7252: oEmitInt
7253: oPop 1
7255: oGetParam 1
7257: oPushResult
7258: oCall 14289
7260: oPop 1
7262: oJumpForward 7368
7264: oGetParam 1
7266: oPushResult
7267: oSetResult 35
7269: oPushResult
7270: oNodeGetBoolean
7271: oPop 2
7273: oChoice 7316
7275: oGetLocal 2
7277: oPushResult
7278: equal_zero
7279: oPop 1
7281: oChoice 7294
7283: oEmit 8
7285: oGetParam 1
7287: oPushResult
7288: oCall 14289
7290: oPop 1
7292: oJumpForward 7312
7294: Choice Lookup Table
           1   7283
7297: oEmit 14
7299: oGetLocal 2
7301: oPushResult
7302: oEmitInt
7303: oPop 1
7305: oGetParam 1
7307: oPushResult
7308: oCall 14289
7310: oPop 1
7312: oEmit 25
7314: oJumpForward 7356
7316: Choice Lookup Table
           1   7275
7319: oGetLocal 2
7321: oPushResult
7322: equal_zero
7323: oPop 1
7325: oChoice 7338
7327: oEmit 7
7329: oGetParam 1
7331: oPushResult
7332: oCall 14289
7334: oPop 1
7336: oJumpForward 7356
7338: Choice Lookup Table
           1   7327
7341: oEmit 13
7343: oGetLocal 2
7345: oPushResult
7346: oEmitInt
7347: oPop 1
7349: oGetParam 1
7351: oPushResult
7352: oCall 14289
7354: oPop 1
7356: oJumpForward 7368
7358: Choice Lookup Table
          25   7264
          23   7225
          26   7214
          22   7214
7367: oEndChoice
7368: oJumpForward 7765
7370: oError 17
7372: oJumpForward 7765
7374: oGetParam 1
7376: oPushResult
7377: oNodeType
7378: oPop 1
7380: oChoice 7526
7382: oEmit 2
7384: oGetParam 1
7386: oPushResult
7387: oCall 14289
7389: oPop 1
7391: oJumpForward 7536
7393: oGetLocal 2
7395: oPushResult
7396: equal_zero
7397: oPop 1
7399: oChoice 7412
7401: oEmit 5
7403: oGetParam 1
7405: oPushResult
7406: oCall 14289
7408: oPop 1
7410: oJumpForward 7430
7412: Choice Lookup Table
           1   7401
7415: oEmit 11
7417: oGetLocal 2
7419: oPushResult
7420: oEmitInt
7421: oPop 1
7423: oGetParam 1
7425: oPushResult
7426: oCall 14289
7428: oPop 1
7430: oJumpForward 7536
7432: oGetParam 1
7434: oPushResult
7435: oSetResult 35
7437: oPushResult
7438: oNodeGetBoolean
7439: oPop 2
7441: oChoice 7484
7443: oGetLocal 2
7445: oPushResult
7446: equal_zero
7447: oPop 1
7449: oChoice 7462
7451: oEmit 8
7453: oGetParam 1
7455: oPushResult
7456: oCall 14289
7458: oPop 1
7460: oJumpForward 7480
7462: Choice Lookup Table
           1   7451
7465: oEmit 14
7467: oGetLocal 2
7469: oPushResult
7470: oEmitInt
7471: oPop 1
7473: oGetParam 1
7475: oPushResult
7476: oCall 14289
7478: oPop 1
7480: oEmit 26
7482: oJumpForward 7524
7484: Choice Lookup Table
           1   7443
7487: oGetLocal 2
7489: oPushResult
7490: equal_zero
7491: oPop 1
7493: oChoice 7506
7495: oEmit 8
7497: oGetParam 1
7499: oPushResult
7500: oCall 14289
7502: oPop 1
7504: oJumpForward 7524
7506: Choice Lookup Table
           1   7495
7509: oEmit 14
7511: oGetLocal 2
7513: oPushResult
7514: oEmitInt
7515: oPop 1
7517: oGetParam 1
7519: oPushResult
7520: oCall 14289
7522: oPop 1
7524: oJumpForward 7536
7526: Choice Lookup Table
          25   7432
          23   7393
          26   7382
          22   7382
7535: oEndChoice
7536: oInputChoice 7566
7538: oTypeSPop
7539: oGetLocal 1
7541: oPushResult
7542: oSetResult 38
7544: oPushResult
7545: oNodeGet
7546: oPop 2
7548: oPushResult
7549: oTypeSPush
7550: oPop 1
7552: oCall 7820
7554: oCall 7766
7556: oJumpForward 7571
7558: oCall 8015
7560: oCall 7820
7562: oCall 7766
7564: oJumpForward 7571
7566: Choice Lookup Table
          17   7558
          19   7538
7571: oJumpForward 7765
7573: oGetParam 1
7575: oPushResult
7576: oNodeType
7577: oPop 1
7579: oChoice 7723
7581: oEmit 17
7583: oGetParam 1
7585: oPushResult
7586: oCall 14289
7588: oPop 1
7590: oJumpForward 7733
7592: oGetLocal 2
7594: oPushResult
7595: equal_zero
7596: oPop 1
7598: oChoice 7611
7600: oEmit 18
7602: oGetParam 1
7604: oPushResult
7605: oCall 14289
7607: oPop 1
7609: oJumpForward 7629
7611: Choice Lookup Table
           1   7600
7614: oEmit 21
7616: oGetLocal 2
7618: oPushResult
7619: oEmitInt
7620: oPop 1
7622: oGetParam 1
7624: oPushResult
7625: oCall 14289
7627: oPop 1
7629: oJumpForward 7733
7631: oGetParam 1
7633: oPushResult
7634: oSetResult 35
7636: oPushResult
7637: oNodeGetBoolean
7638: oPop 2
7640: oChoice 7681
7642: oGetLocal 2
7644: oPushResult
7645: equal_zero
7646: oPop 1
7648: oChoice 7661
7650: oEmit 8
7652: oGetParam 1
7654: oPushResult
7655: oCall 14289
7657: oPop 1
7659: oJumpForward 7679
7661: Choice Lookup Table
           1   7650
7664: oEmit 14
7666: oGetLocal 2
7668: oPushResult
7669: oEmitInt
7670: oPop 1
7672: oGetParam 1
7674: oPushResult
7675: oCall 14289
7677: oPop 1
7679: oJumpForward 7721
7681: Choice Lookup Table
           1   7642
7684: oGetLocal 2
7686: oPushResult
7687: equal_zero
7688: oPop 1
7690: oChoice 7703
7692: oEmit 19
7694: oGetParam 1
7696: oPushResult
7697: oCall 14289
7699: oPop 1
7701: oJumpForward 7721
7703: Choice Lookup Table
           1   7692
7706: oEmit 22
7708: oGetLocal 2
7710: oPushResult
7711: oEmitInt
7712: oPop 1
7714: oGetParam 1
7716: oPushResult
7717: oCall 14289
7719: oPop 1
7721: oJumpForward 7733
7723: Choice Lookup Table
          25   7631
          23   7592
          26   7581
          22   7581
7732: oEndChoice
7733: oCall 7820
7735: oCall 7766
7737: oJumpForward 7765
7739: Choice Lookup Table
          43   7573
          41   7573
          39   7573
          33   7374
          38   7374
          37   7374
          29   7370
          36   7206
          30   7206
          34   7206
          44   7042
          31   7042
7764: oEndChoice
7765: oReturn
7766: oLocalSpace 0
7768: oTypeSNodeType
7769: oChoice 7793
7771: oEmit 24
7773: oJumpForward 7819
7775: oEmit 25
7777: oJumpForward 7819
7779: oError 17
7781: oJumpForward 7819
7783: oEmit 26
7785: oJumpForward 7819
7787: oError 30
7789: oJumpForward 7819
7791: oJumpForward 7819
7793: Choice Lookup Table
          43   7791
          42   7791
          41   7791
          39   7791
          38   7787
          37   7783
          29   7779
          36   7775
          30   7775
          34   7775
          44   7771
          31   7771
7818: oEndChoice
7819: oReturn
7820: oLocalSpace 0
7822: oInputChoice 7860
7824: oTypeSNodeType
7825: oChoice 7839
7827: oCall 7872
7829: oJumpForward 7850
7831: oCall 8015
7833: oJumpForward 7850
7835: oCall 8094
7837: oJumpForward 7850
7839: Choice Lookup Table
          43   7835
          42   7835
          37   7831
          39   7827
7848: oError 11
7850: oJumpForward 7869
7852: oCall 8124
7854: oJumpForward 7869
7856: oCall 8397
7858: oJumpForward 7869
7860: Choice Lookup Table
          19   7856
          21   7852
          17   7824
7867: oJumpForward 7871
7869: oJumpBack 7822
7871: oReturn
7872: oLocalSpace 3
7874: oTypeSNodeType
7875: oChoice 7879
7877: oJumpForward 7884
7879: Choice Lookup Table
          39   7877
7882: oError 11
7884: oTypeSNodeType
7885: oChoice 7889
7887: oJumpForward 7894
7889: Choice Lookup Table
          39   7887
7892: oError 14
7894: oGetAddrLocal 1
7896: oPushResult
7897: oTypeSTop
7898: oPushResult
7899: oSetResult 39
7901: oPushResult
7902: oNodeGet
7903: oPop 2
7905: oPushResult
7906: oCall 13392
7908: oPop 1
7910: oAssign
7911: oGetAddrLocal 2
7913: oPushResult
7914: oTypeSTop
7915: oPushResult
7916: oSetResult 38
7918: oPushResult
7919: oNodeGet
7920: oPop 2
7922: oAssign
7923: oTypeSPop
7924: oGetLocal 2
7926: oPushResult
7927: oTypeSPush
7928: oPop 1
7930: oCall 4931
7932: oCall 8832
7934: oGetLocal 1
7936: oPushResult
7937: equal_zero
7938: oPop 1
7940: oChoice 7954
7942: oEmit 15
7944: oGetLocal 1
7946: oPushResult
7947: oEmitInt
7948: oPop 1
7950: oEmit 42
7952: oJumpForward 7957
7954: Choice Lookup Table
           0   7942
7957: oGetAddrLocal 3
7959: oPushResult
7960: oGetLocal 2
7962: oPushResult
7963: oSetResult 17
7965: oPushResult
7966: oNodeGetInt
7967: oPop 2
7969: oAssign
7970: oGetLocal 3
7972: oPushResult
7973: oSetResult 1
7975: oPushResult
7976: equal
7977: oPop 2
7979: oChoice 7993
7981: oEmit 15
7983: oGetLocal 3
7985: oPushResult
7986: oEmitInt
7987: oPop 1
7989: oEmit 36
7991: oJumpForward 7996
7993: Choice Lookup Table
           0   7981
7996: oEmit 38
7998: oInputChoice 8006
8000: oJumpForward 8014
8002: oJumpForward 8012
8004: oJumpForward 8012
8006: Choice Lookup Table
          14   8004
          18   8000
8011: oEndChoice
8012: oJumpBack 7884
8014: oReturn
8015: oLocalSpace 2
8017: oTypeSNodeType
8018: oChoice 8022
8020: oJumpForward 8027
8022: Choice Lookup Table
          37   8020
8025: oError 30
8027: oGetAddrLocal 1
8029: oPushResult
8030: oTypeSTop
8031: oPushResult
8032: oSetResult 38
8034: oPushResult
8035: oNodeGet
8036: oPop 2
8038: oAssign
8039: oTypeSPop
8040: oGetLocal 1
8042: oPushResult
8043: oTypeSPush
8044: oPop 1
8046: oCall 4931
8048: oCall 8832
8050: oGetAddrLocal 2
8052: oPushResult
8053: oGetLocal 1
8055: oPushResult
8056: oSetResult 17
8058: oPushResult
8059: oNodeGetInt
8060: oPop 2
8062: oAssign
8063: oGetLocal 2
8065: oPushResult
8066: oSetResult 1
8068: oPushResult
8069: equal
8070: oPop 2
8072: oChoice 8086
8074: oEmit 15
8076: oGetLocal 2
8078: oPushResult
8079: oEmitInt
8080: oPop 1
8082: oEmit 36
8084: oJumpForward 8089
8086: Choice Lookup Table
           0   8074
8089: oEmit 38
8091: oInput 18
8093: oReturn
8094: oLocalSpace 0
8096: oTypeSNodeType
8097: oChoice 8101
8099: oJumpForward 8108
8101: Choice Lookup Table
          43   8099
          42   8099
8106: oError 30
8108: oTypeSPop
8109: oGetGlobal 9
8111: oPushResult
8112: oTypeSPush
8113: oPop 1
8115: oCall 4931
8117: oCall 8832
8119: oEmit 38
8121: oInput 18
8123: oReturn
8124: oLocalSpace 2
8126: oTypeSNodeType
8127: oChoice 8131
8129: oJumpForward 8136
8131: Choice Lookup Table
          41   8129
8134: oError 12
8136: oTypeSTop
8137: oPushResult
8138: oSetResult 42
8140: oPushResult
8141: oNodeGet
8142: oPop 2
8144: oPushResult
8145: oScopeEnter
8146: oPop 1
8148: oInput 0
8150: oGetAddrLocal 1
8152: oPushResult
8153: oScopeFindRequire
8154: oAssign
8155: oGetLocal 1
8157: oPushResult
8158: oNodeType
8159: oPop 1
8161: oChoice 8165
8163: oJumpForward 8170
8165: Choice Lookup Table
          24   8163
8168: oError 13
8170: oScopeEnd
8171: oGetAddrLocal 2
8173: oPushResult
8174: oGetLocal 1
8176: oPushResult
8177: oSetResult 22
8179: oPushResult
8180: oNodeGetInt
8181: oPop 2
8183: oAssign
8184: oGetLocal 2
8186: oPushResult
8187: equal_zero
8188: oPop 1
8190: oChoice 8204
8192: oEmit 15
8194: oGetLocal 2
8196: oPushResult
8197: oEmitInt
8198: oPop 1
8200: oEmit 38
8202: oJumpForward 8207
8204: Choice Lookup Table
           0   8192
8207: oTypeSPop
8208: oGetLocal 1
8210: oPushResult
8211: oSetResult 21
8213: oPushResult
8214: oNodeGet
8215: oPop 2
8217: oPushResult
8218: oTypeSPush
8219: oPop 1
8221: oReturn
8222: oLocalSpace 2
8224: oGetAddrLocal 1
8226: oPushResult
8227: oTypeSTop
8228: oPushResult
8229: oSetResult 38
8231: oPushResult
8232: oNodeGet
8233: oPop 2
8235: oAssign
8236: oGetAddrLocal 2
8238: oPushResult
8239: oGetLocal 1
8241: oPushResult
8242: oSetResult 17
8244: oPushResult
8245: oNodeGetInt
8246: oPop 2
8248: oAssign
8249: oGetLocal 2
8251: oPushResult
8252: oSetResult 1
8254: oPushResult
8255: equal
8256: oPop 2
8258: oChoice 8272
8260: oEmit 15
8262: oGetLocal 2
8264: oPushResult
8265: oEmitInt
8266: oPop 1
8268: oEmit 36
8270: oJumpForward 8275
8272: Choice Lookup Table
           0   8260
8275: oEmit 38
8277: oReturn
8278: oLocalSpace 2
8280: oGetAddrLocal 1
8282: oPushResult
8283: oTypeSTop
8284: oPushResult
8285: oSetResult 38
8287: oPushResult
8288: oNodeGet
8289: oPop 2
8291: oAssign
8292: oGetAddrLocal 2
8294: oPushResult
8295: oGetLocal 1
8297: oPushResult
8298: oSetResult 17
8300: oPushResult
8301: oNodeGetInt
8302: oPop 2
8304: oAssign
8305: oGetLocal 2
8307: oPushResult
8308: oSetResult 1
8310: oPushResult
8311: equal
8312: oPop 2
8314: oChoice 8328
8316: oEmit 15
8318: oGetLocal 2
8320: oPushResult
8321: oEmitInt
8322: oPop 1
8324: oEmit 36
8326: oJumpForward 8331
8328: Choice Lookup Table
           0   8316
8331: oEmit 41
8333: oReturn
8334: oLocalSpace 2
8336: oEmit 40
8338: oGetAddrLocal 1
8340: oPushResult
8341: oTypeSTop
8342: oPushResult
8343: oSetResult 38
8345: oPushResult
8346: oNodeGet
8347: oPop 2
8349: oAssign
8350: oGetAddrLocal 2
8352: oPushResult
8353: oGetLocal 1
8355: oPushResult
8356: oSetResult 17
8358: oPushResult
8359: oNodeGetInt
8360: oPop 2
8362: oAssign
8363: oGetLocal 2
8365: oPushResult
8366: oSetResult 1
8368: oPushResult
8369: equal
8370: oPop 2
8372: oChoice 8386
8374: oEmit 15
8376: oGetLocal 2
8378: oPushResult
8379: oEmitInt
8380: oPop 1
8382: oEmit 37
8384: oJumpForward 8389
8386: Choice Lookup Table
           0   8374
8389: oTypeSPop
8390: oGetGlobal 6
8392: oPushResult
8393: oTypeSPush
8394: oPop 1
8396: oReturn
8397: oLocalSpace 1
8399: oTypeSNodeType
8400: oChoice 8408
8402: oJumpForward 8415
8404: oError 30
8406: oJumpForward 8415
8408: Choice Lookup Table
          38   8404
          37   8402
8413: oError 10
8415: oEmit 26
8417: oGetAddrLocal 1
8419: oPushResult
8420: oTypeSTop
8421: oAssign
8422: oTypeSPop
8423: oGetLocal 1
8425: oPushResult
8426: oSetResult 38
8428: oPushResult
8429: oNodeGet
8430: oPop 2
8432: oPushResult
8433: oTypeSPush
8434: oPop 1
8436: oReturn
8437: oLocalSpace 3
8439: oGetAddrLocal 1
8441: oPushResult
8442: oTypeSNodeType
8443: oAssign
8444: oGetAddrLocal 2
8446: oPushResult
8447: oTypeSTop
8448: oAssign
8449: oTypeSPop
8450: oGetLocal 1
8452: oPushResult
8453: oTypeSNodeType
8454: oPushResult
8455: equal_node_type
8456: oPop 2
8458: oChoice 8590
8460: oTypeSNodeType
8461: oChoice 8575
8463: oGetLocal 1
8465: oChoice 8472
8467: oEmit 32
8469: oReturn
8470: oJumpForward 8475
8472: Choice Lookup Table
          30   8467
8475: oJumpForward 8586
8477: oGetLocal 1
8479: oChoice 8486
8481: oEmit 33
8483: oReturn
8484: oJumpForward 8489
8486: Choice Lookup Table
          31   8481
8489: oJumpForward 8586
8491: oGetLocal 1
8493: oChoice 8526
8495: oReturn
8496: oJumpForward 8531
8498: oTypeSTop
8499: oPushResult
8500: oGetGlobal 10
8502: oPushResult
8503: equal_node
8504: oPop 2
8506: oChoice 8521
8508: oEmit 15
8510: oSetResult 1
8512: oPushResult
8513: oEmitInt
8514: oPop 1
8516: oEmit 38
8518: oReturn
8519: oJumpForward 8524
8521: Choice Lookup Table
           1   8508
8524: oJumpForward 8531
8526: Choice Lookup Table
          42   8498
          38   8495
8531: oJumpForward 8586
8533: oGetLocal 1
8535: oChoice 8540
8537: oReturn
8538: oJumpForward 8543
8540: Choice Lookup Table
          37   8537
8543: oJumpForward 8586
8545: oGetLocal 1
8547: oChoice 8568
8549: oReturn
8550: oJumpForward 8573
8552: oGetGlobal 9
8554: oPushResult
8555: oTypeSPush
8556: oPop 1
8558: oGetAddrLocal 3
8560: oPushResult
8561: oCall 10938
8563: oAssign
8564: oTypeSPop
8565: oReturn
8566: oJumpForward 8573
8568: Choice Lookup Table
          36   8552
          42   8549
8573: oJumpForward 8586
8575: Choice Lookup Table
          43   8545
          38   8533
          37   8491
          30   8477
          31   8463
8586: oError 15
8588: oJumpForward 8593
8590: Choice Lookup Table
           0   8460
8593: oReturn
8594: oLocalSpace 2
8596: oGetAddrLocal 1
8598: oPushResult
8599: oTypeSNodeType
8600: oAssign
8601: oTypeSPop
8602: oGetLocal 1
8604: oPushResult
8605: oTypeSNodeType
8606: oPushResult
8607: equal_node_type
8608: oPop 2
8610: oChoice 8770
8612: oTypeSNodeType
8613: oChoice 8749
8615: oGetLocal 1
8617: oChoice 8627
8619: oEmit 32
8621: oReturn
8622: oJumpForward 8638
8624: oReturn
8625: oJumpForward 8638
8627: Choice Lookup Table
          44   8624
          31   8624
          34   8619
          36   8619
          30   8619
8638: oJumpForward 8766
8640: oGetLocal 1
8642: oChoice 8652
8644: oReturn
8645: oJumpForward 8663
8647: oEmit 33
8649: oReturn
8650: oJumpForward 8663
8652: Choice Lookup Table
          44   8647
          31   8647
          34   8644
          36   8644
          30   8644
8663: oJumpForward 8766
8665: oGetLocal 1
8667: oChoice 8700
8669: oReturn
8670: oJumpForward 8705
8672: oTypeSTop
8673: oPushResult
8674: oGetGlobal 10
8676: oPushResult
8677: equal_node
8678: oPop 2
8680: oChoice 8695
8682: oEmit 15
8684: oSetResult 1
8686: oPushResult
8687: oEmitInt
8688: oPop 1
8690: oEmit 38
8692: oReturn
8693: oJumpForward 8698
8695: Choice Lookup Table
           1   8682
8698: oJumpForward 8705
8700: Choice Lookup Table
          42   8672
          38   8669
8705: oJumpForward 8766
8707: oGetLocal 1
8709: oChoice 8714
8711: oReturn
8712: oJumpForward 8717
8714: Choice Lookup Table
          37   8711
8717: oJumpForward 8766
8719: oGetLocal 1
8721: oChoice 8742
8723: oReturn
8724: oJumpForward 8747
8726: oGetGlobal 9
8728: oPushResult
8729: oTypeSPush
8730: oPop 1
8732: oGetAddrLocal 2
8734: oPushResult
8735: oCall 10938
8737: oAssign
8738: oTypeSPop
8739: oReturn
8740: oJumpForward 8747
8742: Choice Lookup Table
          36   8726
          42   8723
8747: oJumpForward 8766
8749: Choice Lookup Table
          43   8719
          38   8707
          37   8665
          34   8640
          36   8640
          30   8640
          44   8615
          31   8615
8766: oError 15
8768: oJumpForward 8773
8770: Choice Lookup Table
           0   8612
8773: oReturn
8774: oLocalSpace 1
8776: oGetAddrLocal 1
8778: oPushResult
8779: oTypeSNodeType
8780: oAssign
8781: oTypeSPop
8782: oGetLocal 1
8784: oPushResult
8785: oTypeSNodeType
8786: oPushResult
8787: equal_node_type
8788: oPop 2
8790: oChoice 8828
8792: oTypeSNodeType
8793: oChoice 8819
8795: oGetLocal 1
8797: oChoice 8802
8799: oReturn
8800: oJumpForward 8805
8802: Choice Lookup Table
          38   8799
8805: oJumpForward 8824
8807: oGetLocal 1
8809: oChoice 8814
8811: oReturn
8812: oJumpForward 8817
8814: Choice Lookup Table
          37   8811
8817: oJumpForward 8824
8819: Choice Lookup Table
          38   8807
          37   8795
8824: oError 15
8826: oJumpForward 8831
8828: Choice Lookup Table
           0   8792
8831: oReturn
8832: oLocalSpace 0
8834: oTypeSNodeType
8835: oChoice 8839
8837: oJumpForward 8844
8839: Choice Lookup Table
          31   8837
8842: oError 7
8844: oTypeSPop
8845: oReturn
8846: oLocalSpace 0
8848: oTypeSNodeType
8849: oChoice 8853
8851: oJumpForward 8858
8853: Choice Lookup Table
          31   8851
8856: oError 7
8858: oReturn
8859: oLocalSpace 0
8861: oTypeSNodeType
8862: oChoice 8870
8864: oJumpForward 8877
8866: oEmit 32
8868: oJumpForward 8877
8870: Choice Lookup Table
          30   8866
          31   8864
8875: oError 7
8877: oTypeSPop
8878: oReturn
8879: oLocalSpace 0
8881: oTypeSNodeType
8882: oChoice 8897
8884: oJumpForward 8904
8886: oEmit 32
8888: oTypeSPop
8889: oGetGlobal 6
8891: oPushResult
8892: oTypeSPush
8893: oPop 1
8895: oJumpForward 8904
8897: Choice Lookup Table
          30   8886
          31   8884
8902: oError 7
8904: oReturn
8905: oLocalSpace 0
8907: oTypeSNodeType
8908: oChoice 8921
8910: oEmit 32
8912: oTypeSPop
8913: oGetGlobal 6
8915: oPushResult
8916: oTypeSPush
8917: oPop 1
8919: oJumpForward 8924
8921: Choice Lookup Table
          30   8910
8924: oReturn
8925: oLocalSpace 0
8927: oTypeSNodeType
8928: oChoice 8936
8930: oJumpForward 8945
8932: oError 17
8934: oJumpForward 8945
8936: Choice Lookup Table
          30   8932
          31   8932
          33   8930
8943: oError 9
8945: oTypeSPop
8946: oReturn
8947: oLocalSpace 0
8949: oTypeSNodeType
8950: oChoice 8954
8952: oJumpForward 8959
8954: Choice Lookup Table
          34   8952
8957: oError 8
8959: oTypeSPop
8960: oReturn
8961: oLocalSpace 0
8963: oTypeSNodeType
8964: oChoice 8968
8966: oJumpForward 8973
8968: Choice Lookup Table
          34   8966
8971: oError 8
8973: oReturn
8974: oLocalSpace 0
8976: oInputChoice 9039
8978: oCall 10711
8980: oJumpForward 9070
8982: oCall 10718
8984: oJumpForward 9070
8986: oCall 10848
8988: oJumpForward 9070
8990: oCall 10855
8992: oJumpForward 9070
8994: oCall 9862
8996: oJumpForward 9070
8998: oCall 10185
9000: oJumpForward 9070
9002: oCall 9928
9004: oJumpForward 9070
9006: oCall 10105
9008: oJumpForward 9070
9010: oCall 10270
9012: oJumpForward 9070
9014: oCall 10238
9016: oJumpForward 9070
9018: oCall 10688
9020: oJumpForward 9070
9022: oCall 9071
9024: oJumpForward 9070
9026: oCall 10302
9028: oJumpForward 9070
9030: oCall 10636
9032: oJumpForward 9070
9034: oChangeIntLitToLabelIdent
9035: oCall 9071
9037: oJumpForward 9070
9039: Choice Lookup Table
           1   9034
          56   9030
          54   9026
           0   9022
          36   9018
          52   9014
          53   9010
          50   9006
          45   9002
          49   8998
          42   8994
          69   8990
          68   8986
          67   8982
          66   8978
9070: oReturn
9071: oLocalSpace 1
9073: oGetAddrLocal 1
9075: oPushResult
9076: oScopeFindRequire
9077: oAssign
9078: oGetAddrLocal 1
9080: oPushResult
9081: oCall 244
9083: oPop 1
9085: oGetLocal 1
9087: oPushResult
9088: oNodeType
9089: oPop 1
9091: oChoice 9131
9093: oGetLocal 1
9095: oPushResult
9096: oCall 9149
9098: oPop 1
9100: oCall 8974
9102: oJumpForward 9148
9104: oGetLocal 1
9106: oPushResult
9107: oCall 11250
9109: oPop 1
9111: oJumpForward 9148
9113: oGetLocal 1
9115: oPushResult
9116: oCall 9199
9118: oPop 1
9120: oJumpForward 9148
9122: oGetLocal 1
9124: oPushResult
9125: oCall 9295
9127: oPop 1
9129: oJumpForward 9148
9131: Choice Lookup Table
          13   9122
          20   9113
          25   9113
          23   9113
          22   9113
          12   9104
          27   9093
9146: oError 0
9148: oReturn
9149: oLocalSpace 0
9151: oGetParam 1
9153: oPushResult
9154: oSetResult 36
9156: oPushResult
9157: oNodeGetBoolean
9158: oPop 2
9160: oChoice 9166
9162: oError 22
9164: oJumpForward 9169
9166: Choice Lookup Table
           1   9162
9169: oEmit 88
9171: oGetParam 1
9173: oPushResult
9174: oSetResult 22
9176: oPushResult
9177: oNodeGetLabel
9178: oPop 2
9180: oPushResult
9181: oEmitLabel
9182: oPop 1
9184: oGetParam 1
9186: oPushResult
9187: oSetResult 36
9189: oPushResult
9190: oSetResult 1
9192: oPushResult
9193: oNodeSetBoolean
9194: oPop 3
9196: oInput 13
9198: oReturn
9199: oLocalSpace 0
9201: oGetParam 1
9203: oPushResult
9204: oSetResult 1
9206: oPushResult
9207: oCall 9455
9209: oPop 2
9211: oInput 5
9213: oCall 4931
9215: oCall 8437
9217: oCall 9220
9219: oReturn
9220: oLocalSpace 1
9222: oTypeSNodeType
9223: oChoice 9267
9225: oEmit 27
9227: oJumpForward 9293
9229: oEmit 28
9231: oJumpForward 9293
9233: oEmit 30
9235: oJumpForward 9293
9237: oError 17
9239: oJumpForward 9293
9241: oEmit 29
9243: oJumpForward 9293
9245: oGetAddrLocal 1
9247: oPushResult
9248: oTypeSTop
9249: oPushResult
9250: oSetResult 17
9252: oPushResult
9253: oNodeGetInt
9254: oPop 2
9256: oAssign
9257: oEmit 31
9259: oGetLocal 1
9261: oPushResult
9262: oEmitInt
9263: oPop 1
9265: oJumpForward 9293
9267: Choice Lookup Table
          43   9245
          41   9245
          39   9245
          38   9241
          37   9241
          29   9237
          33   9233
          36   9229
          30   9229
          34   9229
          44   9225
          31   9225
9292: oEndChoice
9293: oTypeSPop
9294: oReturn
9295: oLocalSpace 1
9297: oGetParam 1
9299: oPushResult
9300: oSetResult 6
9302: oPushResult
9303: oNodeGet
9304: oPop 2
9306: oPushResult
9307: oScopeCurrent
9308: oPushResult
9309: oNodeEqual
9310: oPop 2
9312: oChoice 9318
9314: oError 21
9316: oJumpForward 9321
9318: Choice Lookup Table
           0   9314
9321: oEmit 8
9323: oGetParam 1
9325: oPushResult
9326: oSetResult 31
9328: oPushResult
9329: oNodeGetInt
9330: oPop 2
9332: oPushResult
9333: oEmitInt
9334: oPop 1
9336: oGetParam 1
9338: oPushResult
9339: oSetResult 21
9341: oPushResult
9342: oNodeGet
9343: oPop 2
9345: oPushResult
9346: oTypeSPush
9347: oPop 1
9349: oInput 5
9351: oCall 4931
9353: oCall 8437
9355: oTypeSNodeType
9356: oChoice 9400
9358: oEmit 27
9360: oJumpForward 9426
9362: oEmit 28
9364: oJumpForward 9426
9366: oEmit 30
9368: oJumpForward 9426
9370: oError 17
9372: oJumpForward 9426
9374: oEmit 29
9376: oJumpForward 9426
9378: oGetAddrLocal 1
9380: oPushResult
9381: oTypeSTop
9382: oPushResult
9383: oSetResult 17
9385: oPushResult
9386: oNodeGetInt
9387: oPop 2
9389: oAssign
9390: oEmit 31
9392: oGetLocal 1
9394: oPushResult
9395: oEmitInt
9396: oPop 1
9398: oJumpForward 9426
9400: Choice Lookup Table
          43   9378
          41   9378
          39   9378
          38   9374
          37   9374
          29   9370
          33   9366
          36   9362
          30   9362
          34   9362
          44   9358
          31   9358
9425: oEndChoice
9426: oTypeSPop
9427: oReturn
9428: oLocalSpace 1
9430: oInput 0
9432: oGetAddrLocal 1
9434: oPushResult
9435: oScopeFindRequire
9436: oAssign
9437: oGetAddrLocal 1
9439: oPushResult
9440: oCall 244
9442: oPop 1
9444: oGetLocal 1
9446: oPushResult
9447: oGetParam 1
9449: oPushResult
9450: oCall 9455
9452: oPop 2
9454: oReturn
9455: oLocalSpace 0
9457: oGetParam 2
9459: oPushResult
9460: oNodeType
9461: oPop 1
9463: oChoice 9526
9465: oGetParam 2
9467: oPushResult
9468: oGetParam 1
9470: oPushResult
9471: oCall 9672
9473: oPop 2
9475: oJumpForward 9539
9477: oGetParam 2
9479: oPushResult
9480: oSetResult 21
9482: oPushResult
9483: oNodeGet
9484: oPop 2
9486: oPushResult
9487: oTypeSPush
9488: oPop 1
9490: oInput 15
9492: oGetParam 1
9494: oPushResult
9495: oCall 9428
9497: oPop 1
9499: oInput 16
9501: oCall 9540
9503: oTypeSNodeType
9504: oChoice 9519
9506: oInputChoice 9514
9508: oEmit 26
9510: oCall 8015
9512: oJumpForward 9517
9514: Choice Lookup Table
          17   9508
9517: oJumpForward 9522
9519: Choice Lookup Table
          37   9506
9522: oCall 7820
9524: oJumpForward 9539
9526: Choice Lookup Table
          20   9477
          26   9465
          25   9465
          23   9465
          22   9465
9537: oError 4
9539: oReturn
9540: oLocalSpace 1
9542: oGetAddrLocal 1
9544: oPushResult
9545: oTypeSNodeType
9546: oAssign
9547: oTypeSPop
9548: oGetLocal 1
9550: oPushResult
9551: oTypeSNodeType
9552: oPushResult
9553: equal_node_type
9554: oPop 2
9556: oChoice 9668
9558: oTypeSNodeType
9559: oChoice 9647
9561: oGetLocal 1
9563: oChoice 9573
9565: oError 31
9567: oReturn
9568: oJumpForward 9584
9570: oReturn
9571: oJumpForward 9584
9573: Choice Lookup Table
          44   9570
          31   9570
          34   9565
          36   9565
          30   9565
9584: oJumpForward 9664
9586: oGetLocal 1
9588: oChoice 9598
9590: oReturn
9591: oJumpForward 9609
9593: oError 31
9595: oReturn
9596: oJumpForward 9609
9598: Choice Lookup Table
          44   9593
          31   9593
          34   9590
          36   9590
          30   9590
9609: oJumpForward 9664
9611: oGetLocal 1
9613: oChoice 9618
9615: oReturn
9616: oJumpForward 9621
9618: Choice Lookup Table
          38   9615
9621: oJumpForward 9664
9623: oGetLocal 1
9625: oChoice 9630
9627: oReturn
9628: oJumpForward 9633
9630: Choice Lookup Table
          37   9627
9633: oJumpForward 9664
9635: oGetLocal 1
9637: oChoice 9642
9639: oReturn
9640: oJumpForward 9645
9642: Choice Lookup Table
          42   9639
9645: oJumpForward 9664
9647: Choice Lookup Table
          43   9635
          38   9623
          37   9611
          34   9586
          36   9586
          30   9586
          44   9561
          31   9561
9664: oError 15
9666: oJumpForward 9671
9668: Choice Lookup Table
           0   9558
9671: oReturn
9672: oLocalSpace 0
9674: oGetParam 2
9676: oPushResult
9677: oNodeType
9678: oPop 1
9680: oChoice 9762
9682: oEmit 17
9684: oGetParam 2
9686: oPushResult
9687: oCall 14289
9689: oPop 1
9691: oJumpForward 9773
9693: oEmit 18
9695: oGetParam 2
9697: oPushResult
9698: oCall 14289
9700: oPop 1
9702: oJumpForward 9773
9704: oGetParam 2
9706: oPushResult
9707: oSetResult 35
9709: oPushResult
9710: oNodeGetBoolean
9711: oPop 2
9713: oChoice 9726
9715: oEmit 8
9717: oGetParam 2
9719: oPushResult
9720: oCall 14289
9722: oPop 1
9724: oJumpForward 9738
9726: Choice Lookup Table
           1   9715
9729: oEmit 19
9731: oGetParam 2
9733: oPushResult
9734: oCall 14289
9736: oPop 1
9738: oJumpForward 9773
9740: oGetParam 1
9742: oChoice 9755
9744: oEmit 17
9746: oGetParam 2
9748: oPushResult
9749: oCall 14289
9751: oPop 1
9753: oJumpForward 9760
9755: Choice Lookup Table
           0   9744
9758: oError 4
9760: oJumpForward 9773
9762: Choice Lookup Table
          26   9740
          25   9704
          23   9693
          22   9682
9771: oError 4
9773: oGetParam 2
9775: oPushResult
9776: oSetResult 21
9778: oPushResult
9779: oNodeGet
9780: oPop 2
9782: oPushResult
9783: oTypeSPush
9784: oPop 1
9786: oTypeSNodeType
9787: oChoice 9802
9789: oInputChoice 9797
9791: oEmit 26
9793: oCall 8015
9795: oJumpForward 9800
9797: Choice Lookup Table
          17   9791
9800: oJumpForward 9805
9802: Choice Lookup Table
          37   9789
9805: oCall 7820
9807: oReturn
9808: oLocalSpace 0
9810: oGetParam 1
9812: oPushResult
9813: oSetResult 1
9815: oPushResult
9816: oCall 9672
9818: oPop 2
9820: oCall 8832
9822: oGetParam 1
9824: oPushResult
9825: oCall 7007
9827: oPop 1
9829: oTypeSPop
9830: oEmit 34
9832: oEmit 27
9834: oReturn
9835: oLocalSpace 0
9837: oGetParam 1
9839: oPushResult
9840: oSetResult 1
9842: oPushResult
9843: oCall 9672
9845: oPop 2
9847: oCall 8832
9849: oGetParam 1
9851: oPushResult
9852: oCall 7007
9854: oPop 1
9856: oTypeSPop
9857: oEmit 35
9859: oEmit 27
9861: oReturn
9862: oLocalSpace 2
9864: oGetAddrLocal 1
9866: oPushResult
9867: oSetResult 0
9869: oAssign
9870: oGetAddrLocal 1
9872: oPushResult
9873: oCall 4977
9875: oPop 1
9877: oInput 43
9879: oCall 8974
9881: oInputChoice 9916
9883: oGetAddrLocal 2
9885: oPushResult
9886: oLabelNew
9887: oAssign
9888: oEmit 79
9890: oGetLocal 2
9892: oPushResult
9893: oEmitLabel
9894: oPop 1
9896: oEmit 88
9898: oGetLocal 1
9900: oPushResult
9901: oEmitLabel
9902: oPop 1
9904: oCall 8974
9906: oEmit 88
9908: oGetLocal 2
9910: oPushResult
9911: oEmitLabel
9912: oPop 1
9914: oJumpForward 9927
9916: Choice Lookup Table
          44   9883
9919: oEmit 88
9921: oGetLocal 1
9923: oPushResult
9924: oEmitLabel
9925: oPop 1
9927: oReturn
9928: oLocalSpace 4
9930: oInput 0
9932: oGetAddrLocal 1
9934: oPushResult
9935: oScopeFindRequire
9936: oAssign
9937: oGetLocal 1
9939: oPushResult
9940: oSetResult 1
9942: oPushResult
9943: oCall 9672
9945: oPop 2
9947: oCall 8832
9949: oInput 5
9951: oCall 4931
9953: oCall 8832
9955: oEmit 27
9957: oGetAddrLocal 2
9959: oPushResult
9960: oLabelNew
9961: oAssign
9962: oGetAddrLocal 3
9964: oPushResult
9965: oLabelNew
9966: oAssign
9967: oEmit 79
9969: oGetLocal 3
9971: oPushResult
9972: oEmitLabel
9973: oPop 1
9975: oGetAddrLocal 4
9977: oPushResult
9978: oLabelNew
9979: oAssign
9980: oEmit 88
9982: oGetLocal 4
9984: oPushResult
9985: oEmitLabel
9986: oPop 1
9988: oInputChoice 10068
9990: oGetLocal 1
9992: oPushResult
9993: oCall 9808
9995: oPop 1
9997: oEmit 88
9999: oGetLocal 3
10001: oPushResult
10002: oEmitLabel
10003: oPop 1
10005: oGetLocal 1
10007: oPushResult
10008: oCall 7007
10010: oPop 1
10012: oTypeSPop
10013: oCall 4931
10015: oCall 8832
10017: oEmit 58
10019: oEmit 80
10021: oGetLocal 2
10023: oPushResult
10024: oEmitLabel
10025: oPop 1
10027: oJumpForward 10074
10029: oGetLocal 1
10031: oPushResult
10032: oCall 9835
10034: oPop 1
10036: oEmit 88
10038: oGetLocal 3
10040: oPushResult
10041: oEmitLabel
10042: oPop 1
10044: oGetLocal 1
10046: oPushResult
10047: oCall 7007
10049: oPop 1
10051: oTypeSPop
10052: oCall 4931
10054: oCall 8832
10056: oEmit 59
10058: oEmit 80
10060: oGetLocal 2
10062: oPushResult
10063: oEmitLabel
10064: oPop 1
10066: oJumpForward 10074
10068: Choice Lookup Table
          47   10029
          46   9990
10073: oEndChoice
10074: oGetLocal 4
10076: oPushResult
10077: oGetLocal 2
10079: oPushResult
10080: oLoopPush
10081: oPop 2
10083: oInput 48
10085: oCall 8974
10087: oEmit 79
10089: oGetLocal 4
10091: oPushResult
10092: oEmitLabel
10093: oPop 1
10095: oEmit 88
10097: oGetLocal 2
10099: oPushResult
10100: oEmitLabel
10101: oPop 1
10103: oLoopPop
10104: oReturn
10105: oLocalSpace 3
10107: oGetAddrLocal 1
10109: oPushResult
10110: oLabelNew
10111: oAssign
10112: oEmit 88
10114: oGetLocal 1
10116: oPushResult
10117: oEmitLabel
10118: oPop 1
10120: oGetAddrLocal 2
10122: oPushResult
10123: oLabelNew
10124: oAssign
10125: oGetLocal 1
10127: oPushResult
10128: oGetLocal 2
10130: oPushResult
10131: oLoopPush
10132: oPop 2
10134: oCall 8974
10136: oInputChoice 10167
10138: oCall 8974
10140: oJumpForward 10173
10142: oGetAddrLocal 3
10144: oPushResult
10145: oCall 4977
10147: oPop 1
10149: oEmit 89
10151: oGetLocal 3
10153: oPushResult
10154: oEmitLabel
10155: oPop 1
10157: oGetLocal 1
10159: oPushResult
10160: oEmitLabel
10161: oPop 1
10163: oJumpForward 10175
10165: oJumpForward 10173
10167: Choice Lookup Table
          51   10142
           6   10138
10172: oEndChoice
10173: oJumpBack 10136
10175: oEmit 88
10177: oGetLocal 2
10179: oPushResult
10180: oEmitLabel
10181: oPop 1
10183: oLoopPop
10184: oReturn
10185: oLocalSpace 2
10187: oGetAddrLocal 1
10189: oPushResult
10190: oLabelNew
10191: oAssign
10192: oEmit 88
10194: oGetLocal 1
10196: oPushResult
10197: oEmitLabel
10198: oPop 1
10200: oGetAddrLocal 2
10202: oPushResult
10203: oCall 4977
10205: oPop 1
10207: oGetLocal 1
10209: oPushResult
10210: oGetLocal 2
10212: oPushResult
10213: oLoopPush
10214: oPop 2
10216: oInput 48
10218: oCall 8974
10220: oEmit 79
10222: oGetLocal 1
10224: oPushResult
10225: oEmitLabel
10226: oPop 1
10228: oEmit 88
10230: oGetLocal 2
10232: oPushResult
10233: oEmitLabel
10234: oPop 1
10236: oLoopPop
10237: oReturn
10238: oLocalSpace 0
10240: oLoopContinueLabel
10241: oPushResult
10242: oSetResult 0
10244: oPushResult
10245: equal_label
10246: oPop 2
10248: oChoice 10263
10250: oError 19
10252: oJumpForward 10269
10254: oEmit 79
10256: oLoopContinueLabel
10257: oPushResult
10258: oEmitLabel
10259: oPop 1
10261: oJumpForward 10269
10263: Choice Lookup Table
           0   10254
           1   10250
10268: oEndChoice
10269: oReturn
10270: oLocalSpace 0
10272: oLoopBreakLabel
10273: oPushResult
10274: oSetResult 0
10276: oPushResult
10277: equal_label
10278: oPop 2
10280: oChoice 10295
10282: oError 19
10284: oJumpForward 10301
10286: oEmit 79
10288: oLoopBreakLabel
10289: oPushResult
10290: oEmitLabel
10291: oPop 1
10293: oJumpForward 10301
10295: Choice Lookup Table
           0   10286
           1   10282
10300: oEndChoice
10301: oReturn
10302: oLocalSpace 8
10304: oGetAddrLocal 1
10306: oPushResult
10307: oCodeNew
10308: oAssign
10309: oGetAddrLocal 2
10311: oPushResult
10312: oLabelNew
10313: oAssign
10314: oGetAddrLocal 3
10316: oPushResult
10317: oLabelNew
10318: oAssign
10319: oGetAddrLocal 4
10321: oPushResult
10322: oGetLocal 3
10324: oAssign
10325: oGetAddrLocal 5
10327: oPushResult
10328: oSetResult 0
10330: oAssign
10331: oCall 4931
10333: oTypeSNodeType
10334: oChoice 10372
10336: oEmit 82
10338: oGetLocal 2
10340: oPushResult
10341: oEmitLabel
10342: oPop 1
10344: oJumpForward 10389
10346: oEmit 83
10348: oGetLocal 2
10350: oPushResult
10351: oEmitLabel
10352: oPop 1
10354: oJumpForward 10389
10356: oGetAddrLocal 5
10358: oPushResult
10359: oSetResult 1
10361: oAssign
10362: oEmit 84
10364: oGetLocal 2
10366: oPushResult
10367: oEmitLabel
10368: oPop 1
10370: oJumpForward 10389
10372: Choice Lookup Table
          42   10356
          43   10356
          44   10346
          31   10346
          36   10336
          30   10336
          34   10336
10387: oError 18
10389: oInput 41
10391: oInputChoice 10438
10393: oGetAddrLocal 4
10395: oPushResult
10396: oLabelNew
10397: oAssign
10398: oEmit 88
10400: oGetLocal 4
10402: oPushResult
10403: oEmitLabel
10404: oPop 1
10406: oInputChoice 10412
10408: oJumpForward 10430
10410: oJumpForward 10428
10412: Choice Lookup Table
          37   10408
10415: oCall 8974
10417: oInputChoice 10421
10419: oJumpForward 10428
10421: Choice Lookup Table
           6   10419
10424: oInput 37
10426: oJumpForward 10430
10428: oJumpBack 10406
10430: oJumpForward 10604
10432: oJumpForward 10602
10434: oJumpForward 10604
10436: oJumpForward 10602
10438: Choice Lookup Table
          37   10434
          44   10393
          55   10393
10445: oGetAddrLocal 6
10447: oPushResult
10448: oLabelNew
10449: oAssign
10450: oGetLocal 1
10452: oPushResult
10453: oCodePush
10454: oPop 1
10456: oCall 3568
10458: oCall 4395
10460: oGetLocal 5
10462: oChoice 10482
10464: oGetAddrLocal 7
10466: oPushResult
10467: oValueTopString
10468: oPushResult
10469: oStringAllocShortStringLit
10470: oPop 1
10472: oAssign
10473: oJumpForward 10488
10475: oGetAddrLocal 7
10477: oPushResult
10478: oValueTop
10479: oAssign
10480: oJumpForward 10488
10482: Choice Lookup Table
           0   10475
           1   10464
10487: oEndChoice
10488: oValuePop
10489: oInputChoice 10546
10491: oCall 3568
10493: oCall 4395
10495: oGetLocal 5
10497: oChoice 10517
10499: oGetAddrLocal 8
10501: oPushResult
10502: oValueTopString
10503: oPushResult
10504: oStringAllocShortStringLit
10505: oPop 1
10507: oAssign
10508: oJumpForward 10523
10510: oGetAddrLocal 8
10512: oPushResult
10513: oValueTop
10514: oAssign
10515: oJumpForward 10523
10517: Choice Lookup Table
           0   10510
           1   10499
10522: oEndChoice
10523: oValuePop
10524: oEmit 86
10526: oGetLocal 7
10528: oPushResult
10529: oEmitInt
10530: oPop 1
10532: oGetLocal 8
10534: oPushResult
10535: oEmitInt
10536: oPop 1
10538: oGetLocal 6
10540: oPushResult
10541: oEmitLabel
10542: oPop 1
10544: oJumpForward 10563
10546: Choice Lookup Table
          22   10491
10549: oEmit 85
10551: oGetLocal 7
10553: oPushResult
10554: oEmitInt
10555: oPop 1
10557: oGetLocal 6
10559: oPushResult
10560: oEmitLabel
10561: oPop 1
10563: oInputChoice 10567
10565: oJumpForward 10572
10567: Choice Lookup Table
          14   10565
10570: oJumpForward 10574
10572: oJumpBack 10456
10574: oCodePop
10575: oInput 13
10577: oEmit 88
10579: oGetLocal 6
10581: oPushResult
10582: oEmitLabel
10583: oPop 1
10585: oCall 8974
10587: oEmit 79
10589: oGetLocal 3
10591: oPushResult
10592: oEmitLabel
10593: oPop 1
10595: oInputChoice 10599
10597: oJumpForward 10602
10599: Choice Lookup Table
           6   10597
10602: oJumpBack 10391
10604: oEmit 88
10606: oGetLocal 2
10608: oPushResult
10609: oEmitLabel
10610: oPop 1
10612: oGetLocal 1
10614: oPushResult
10615: oEmitCode
10616: oPop 1
10618: oEmit 87
10620: oGetLocal 4
10622: oPushResult
10623: oEmitLabel
10624: oPop 1
10626: oEmit 88
10628: oGetLocal 3
10630: oPushResult
10631: oEmitLabel
10632: oPop 1
10634: oTypeSPop
10635: oReturn
10636: oLocalSpace 1
10638: oInputChoice 10645
10640: oJumpForward 10651
10642: oChangeIntLitToLabelIdent
10643: oJumpForward 10651
10645: Choice Lookup Table
           1   10642
           0   10640
10650: oEndChoice
10651: oGetAddrLocal 1
10653: oPushResult
10654: oScopeCurrent
10655: oPushResult
10656: oScopeFindRequireInScope
10657: oPop 1
10659: oAssign
10660: oGetLocal 1
10662: oPushResult
10663: oSetResult 28
10665: oPushResult
10666: oSetResult 1
10668: oPushResult
10669: oNodeSetBoolean
10670: oPop 3
10672: oEmit 79
10674: oGetLocal 1
10676: oPushResult
10677: oSetResult 22
10679: oPushResult
10680: oNodeGetLabel
10681: oPop 2
10683: oPushResult
10684: oEmitLabel
10685: oPop 1
10687: oReturn
10688: oLocalSpace 0
10690: oCall 8974
10692: oInputChoice 10702
10694: oCall 8974
10696: oJumpForward 10708
10698: oJumpForward 10710
10700: oJumpForward 10708
10702: Choice Lookup Table
          37   10698
           6   10694
10707: oEndChoice
10708: oJumpBack 10692
10710: oReturn
10711: oLocalSpace 0
10713: oCall 10718
10715: oEmit 99
10717: oReturn
10718: oLocalSpace 0
10720: oInputChoice 10844
10722: oCall 4931
10724: oTypeSNodeType
10725: oChoice 10800
10727: oEmit 91
10729: oJumpForward 10825
10731: oEmit 92
10733: oJumpForward 10825
10735: oEmit 32
10737: oEmit 91
10739: oJumpForward 10825
10741: oEmit 93
10743: oJumpForward 10825
10745: oEmit 98
10747: oJumpForward 10825
10749: oEmit 94
10751: oJumpForward 10825
10753: oError 17
10755: oJumpForward 10825
10757: oEmit 17
10759: oTypeSTop
10760: oPushResult
10761: oSetResult 44
10763: oPushResult
10764: oNodeGetInt
10765: oPop 2
10767: oPushResult
10768: oEmitInt
10769: oPop 1
10771: oEmit 97
10773: oJumpForward 10825
10775: oTypeSTop
10776: oPushResult
10777: oGetGlobal 10
10779: oPushResult
10780: equal_node
10781: oPop 2
10783: oChoice 10789
10785: oEmit 95
10787: oJumpForward 10794
10789: Choice Lookup Table
           1   10785
10792: oEmit 96
10794: oJumpForward 10825
10796: oEmit 96
10798: oJumpForward 10825
10800: Choice Lookup Table
          38   10796
          37   10775
          44   10757
          29   10753
          42   10749
          43   10749
          33   10745
          36   10741
          30   10735
          34   10731
          31   10727
10823: oError 18
10825: oTypeSPop
10826: oInputChoice 10834
10828: oJumpForward 10842
10830: oJumpForward 10840
10832: oJumpForward 10840
10834: Choice Lookup Table
          14   10832
          16   10828
10839: oEndChoice
10840: oJumpBack 10722
10842: oJumpForward 10847
10844: Choice Lookup Table
          15   10722
10847: oReturn
10848: oLocalSpace 0
10850: oCall 10855
10852: oEmit 103
10854: oReturn
10855: oLocalSpace 1
10857: oInputChoice 10934
10859: oSetResult 1
10861: oPushResult
10862: oCall 9428
10864: oPop 1
10866: oTypeSNodeType
10867: oChoice 10906
10869: oEmit 100
10871: oJumpForward 10915
10873: oEmit 101
10875: oJumpForward 10915
10877: oGetAddrLocal 1
10879: oPushResult
10880: oTypeSTop
10881: oPushResult
10882: oSetResult 17
10884: oPushResult
10885: oNodeGetInt
10886: oPop 2
10888: oPushResult
10889: oSetResult 1
10891: oPushResult
10892: subtract
10893: oPop 2
10895: oAssign
10896: oEmit 102
10898: oGetLocal 1
10900: oPushResult
10901: oEmitInt
10902: oPop 1
10904: oJumpForward 10915
10906: Choice Lookup Table
          43   10877
          36   10873
          31   10869
10913: oError 18
10915: oTypeSPop
10916: oInputChoice 10924
10918: oJumpForward 10932
10920: oJumpForward 10930
10922: oJumpForward 10930
10924: Choice Lookup Table
          14   10922
          16   10918
10929: oEndChoice
10930: oJumpBack 10859
10932: oJumpForward 10937
10934: Choice Lookup Table
          15   10859
10937: oReturn
10938: oLocalSpace 1
10940: oGetAddrLocal 1
10942: oPushResult
10943: oGetGlobal 16
10945: oPushResult
10946: oScopeAllocType
10947: oPop 1
10949: oAssign
10950: oTypeSNodeType
10951: oChoice 11019
10953: oEmit 18
10955: oGetLocal 1
10957: oPushResult
10958: oEmitInt
10959: oPop 1
10961: oEmit 23
10963: oEmit 31
10965: oGetGlobal 16
10967: oPushResult
10968: oSetResult 17
10970: oPushResult
10971: oNodeGetInt
10972: oPop 2
10974: oPushResult
10975: oEmitInt
10976: oPop 1
10978: oJumpForward 11028
10980: oEmit 18
10982: oGetLocal 1
10984: oPushResult
10985: oEmitInt
10986: oPop 1
10988: oEmit 15
10990: oSetResult 1
10992: oPushResult
10993: oEmitInt
10994: oPop 1
10996: oEmit 28
10998: oEmit 18
11000: oGetLocal 1
11002: oPushResult
11003: oSetResult 1
11005: oPushResult
11006: add
11007: oPop 2
11009: oPushResult
11010: oEmitInt
11011: oPop 1
11013: oEmit 23
11015: oEmit 28
11017: oJumpForward 11028
11019: Choice Lookup Table
          36   10980
          42   10953
          43   10953
11026: oError 15
11028: oTypeSPop
11029: oEmit 18
11031: oGetLocal 1
11033: oPushResult
11034: oEmitInt
11035: oPop 1
11037: oGetGlobal 16
11039: oPushResult
11040: oTypeSPush
11041: oPop 1
11043: oGetLocal 1
11045: oReturn
11046: oReturn
11047: oLocalSpace 0
11049: oEmit 72
11051: oSetResult 16
11053: oPushResult
11054: oEmitInt
11055: oPop 1
11057: oEmit 20
11059: oSetResult 8
11061: oPushResult
11062: oEmitInt
11063: oPop 1
11065: oEmit 23
11067: oEmit 29
11069: oEmit 20
11071: oSetResult 0
11073: oPushResult
11074: oEmitInt
11075: oPop 1
11077: oEmit 23
11079: oEmit 29
11081: oEmit 75
11083: oGetGlobal 22
11085: oPushResult
11086: oCall 14289
11088: oPop 1
11090: oEmit 74
11092: oSetResult 16
11094: oPushResult
11095: oEmitInt
11096: oPop 1
11098: oTypeSPop
11099: oTypeSPop
11100: oReturn
11101: oLocalSpace 0
11103: oEmit 72
11105: oSetResult 12
11107: oPushResult
11108: oEmitInt
11109: oPop 1
11111: oEmit 20
11113: oSetResult 8
11115: oPushResult
11116: oEmitInt
11117: oPop 1
11119: oEmit 23
11121: oEmit 28
11123: oEmit 20
11125: oSetResult 0
11127: oPushResult
11128: oEmitInt
11129: oPop 1
11131: oEmit 23
11133: oEmit 29
11135: oEmit 75
11137: oGetGlobal 23
11139: oPushResult
11140: oCall 14289
11142: oPop 1
11144: oEmit 74
11146: oSetResult 12
11148: oPushResult
11149: oEmitInt
11150: oPop 1
11152: oTypeSPop
11153: oTypeSPop
11154: oReturn
11155: oLocalSpace 1
11157: oEmit 73
11159: oSetResult 24
11161: oPushResult
11162: oEmitInt
11163: oPop 1
11165: oEmit 20
11167: oSetResult 8
11169: oPushResult
11170: oEmitInt
11171: oPop 1
11173: oEmit 23
11175: oEmit 29
11177: oEmit 20
11179: oSetResult 0
11181: oPushResult
11182: oEmitInt
11183: oPop 1
11185: oEmit 23
11187: oEmit 29
11189: oGetAddrLocal 1
11191: oPushResult
11192: oGetGlobal 6
11194: oPushResult
11195: oScopeAllocType
11196: oPop 1
11198: oAssign
11199: oEmit 20
11201: oSetResult 16
11203: oPushResult
11204: oEmitInt
11205: oPop 1
11207: oEmit 18
11209: oGetLocal 1
11211: oPushResult
11212: oEmitInt
11213: oPop 1
11215: oEmit 29
11217: oEmit 76
11219: oGetGlobal 24
11221: oPushResult
11222: oCall 14289
11224: oPop 1
11226: oEmit 3
11228: oGetLocal 1
11230: oPushResult
11231: oEmitInt
11232: oPop 1
11234: oEmit 74
11236: oSetResult 24
11238: oPushResult
11239: oEmitInt
11240: oPop 1
11242: oTypeSPop
11243: oGetGlobal 6
11245: oPushResult
11246: oTypeSPush
11247: oPop 1
11249: oReturn
11250: oLocalSpace 10
11252: oGetParam 1
11254: oPushResult
11255: oSetResult 28
11257: oPushResult
11258: oSetResult 1
11260: oPushResult
11261: oNodeSetBoolean
11262: oPop 3
11264: oGetAddrLocal 1
11266: oPushResult
11267: oGetParam 1
11269: oPushResult
11270: oSetResult 27
11272: oPushResult
11273: oNodeGetBoolean
11274: oPop 2
11276: oAssign
11277: oGetAddrLocal 4
11279: oPushResult
11280: oGetParam 1
11282: oPushResult
11283: oNodeType
11284: oPop 1
11286: oPushResult
11287: oSetResult 13
11289: oPushResult
11290: equal_node_type
11291: oPop 2
11293: oAssign
11294: oGetLocal 4
11296: oChoice 11323
11298: oGetAddrLocal 2
11300: oPushResult
11301: oGetParam 1
11303: oPushResult
11304: oSetResult 21
11306: oPushResult
11307: oNodeGet
11308: oPop 2
11310: oAssign
11311: oGetAddrLocal 3
11313: oPushResult
11314: oGetLocal 2
11316: oPushResult
11317: oScopeAllocType
11318: oPop 1
11320: oAssign
11321: oJumpForward 11326
11323: Choice Lookup Table
           1   11298
11326: oGetAddrLocal 5
11328: oPushResult
11329: oGetParam 1
11331: oPushResult
11332: oSetResult 23
11334: oPushResult
11335: oNodeGet
11336: oPop 2
11338: oAssign
11339: oGetAddrLocal 6
11341: oPushResult
11342: oGetLocal 5
11344: oPushResult
11345: oSetResult 17
11347: oPushResult
11348: oNodeGetInt
11349: oPop 2
11351: oAssign
11352: oGetLocal 1
11354: oChoice 11376
11356: oEmit 73
11358: oGetLocal 6
11360: oPushResult
11361: oEmitInt
11362: oPop 1
11364: oJumpForward 11382
11366: oEmit 72
11368: oGetLocal 6
11370: oPushResult
11371: oEmitInt
11372: oPop 1
11374: oJumpForward 11382
11376: Choice Lookup Table
           0   11366
           1   11356
11381: oEndChoice
11382: oGetParam 1
11384: oPushResult
11385: oCall 14223
11387: oPop 1
11389: oPushResult
11390: oSetResult 0
11392: oPushResult
11393: greater
11394: oPop 2
11396: oChoice 11429
11398: oEmit 20
11400: oSetResult 0
11402: oPushResult
11403: oEmitInt
11404: oPop 1
11406: oEmit 21
11408: oGetParam 1
11410: oPushResult
11411: oCall 14243
11413: oPop 1
11415: oPushResult
11416: oEmitInt
11417: oPop 1
11419: oSetResult 0
11421: oPushResult
11422: oEmitInt
11423: oPop 1
11425: oEmit 29
11427: oJumpForward 11432
11429: Choice Lookup Table
           1   11398
11432: oGetAddrLocal 7
11434: oPushResult
11435: oGetLocal 5
11437: oPushResult
11438: oSetResult 15
11440: oPushResult
11441: oNodeGetIter
11442: oPop 2
11444: oAssign
11445: oGetAddrLocal 8
11447: oPushResult
11448: oGetLocal 7
11450: oPushResult
11451: oNodeIterValue
11452: oPop 1
11454: oAssign
11455: oInputChoice 11658
11457: oGetLocal 8
11459: oPushResult
11460: oNodeNull
11461: oPop 1
11463: oChoice 11469
11465: oJumpForward 11654
11467: oJumpForward 11472
11469: Choice Lookup Table
           1   11465
11472: oGetAddrLocal 9
11474: oPushResult
11475: oGetLocal 8
11477: oPushResult
11478: oSetResult 22
11480: oPushResult
11481: oNodeGetInt
11482: oPop 2
11484: oAssign
11485: oEmit 20
11487: oGetLocal 9
11489: oPushResult
11490: oEmitInt
11491: oPop 1
11493: oGetLocal 8
11495: oPushResult
11496: oSetResult 21
11498: oPushResult
11499: oNodeGet
11500: oPop 2
11502: oPushResult
11503: oTypeSPush
11504: oPop 1
11506: oGetLocal 8
11508: oPushResult
11509: oSetResult 35
11511: oPushResult
11512: oNodeGetBoolean
11513: oPop 2
11515: oChoice 11607
11517: oSetResult 1
11519: oPushResult
11520: oCall 9428
11522: oPop 1
11524: oCall 8774
11526: oEmit 29
11528: oJumpForward 11613
11530: oCall 4931
11532: oCall 8437
11534: oTypeSNodeType
11535: oChoice 11579
11537: oEmit 27
11539: oJumpForward 11605
11541: oEmit 28
11543: oJumpForward 11605
11545: oEmit 30
11547: oJumpForward 11605
11549: oError 17
11551: oJumpForward 11605
11553: oEmit 29
11555: oJumpForward 11605
11557: oGetAddrLocal 10
11559: oPushResult
11560: oTypeSTop
11561: oPushResult
11562: oSetResult 17
11564: oPushResult
11565: oNodeGetInt
11566: oPop 2
11568: oAssign
11569: oEmit 31
11571: oGetLocal 10
11573: oPushResult
11574: oEmitInt
11575: oPop 1
11577: oJumpForward 11605
11579: Choice Lookup Table
          43   11557
          41   11557
          39   11557
          38   11553
          37   11553
          29   11549
          33   11545
          36   11541
          30   11541
          34   11541
          44   11537
          31   11537
11604: oEndChoice
11605: oJumpForward 11613
11607: Choice Lookup Table
           0   11530
           1   11517
11612: oEndChoice
11613: oTypeSPop
11614: oGetAddrLocal 7
11616: oPushResult
11617: oNodeIterNext
11618: oPop 1
11620: oGetAddrLocal 8
11622: oPushResult
11623: oGetLocal 7
11625: oPushResult
11626: oNodeIterValue
11627: oPop 1
11629: oAssign
11630: oGetLocal 8
11632: oPushResult
11633: oNodeNull
11634: oPop 1
11636: oChoice 11644
11638: oJumpForward 11654
11640: oJumpForward 11650
11642: oJumpForward 11650
11644: Choice Lookup Table
           0   11642
           1   11638
11649: oEndChoice
11650: oInput 14
11652: oJumpBack 11457
11654: oInput 16
11656: oJumpForward 11661
11658: Choice Lookup Table
          15   11457
11661: oGetLocal 8
11663: oPushResult
11664: oNodeNull
11665: oPop 1
11667: oChoice 11673
11669: oError 16
11671: oJumpForward 11676
11673: Choice Lookup Table
           0   11669
11676: oGetLocal 4
11678: oChoice 11707
11680: oEmit 20
11682: oGetParam 1
11684: oPushResult
11685: oSetResult 31
11687: oPushResult
11688: oNodeGetInt
11689: oPop 2
11691: oPushResult
11692: oEmitInt
11693: oPop 1
11695: oEmit 18
11697: oGetLocal 3
11699: oPushResult
11700: oEmitInt
11701: oPop 1
11703: oEmit 29
11705: oJumpForward 11710
11707: Choice Lookup Table
           1   11680
11710: oGetLocal 1
11712: oChoice 11736
11714: oEmit 76
11716: oGetParam 1
11718: oPushResult
11719: oCall 14289
11721: oPop 1
11723: oJumpForward 11742
11725: oEmit 75
11727: oGetParam 1
11729: oPushResult
11730: oCall 14289
11732: oPop 1
11734: oJumpForward 11742
11736: Choice Lookup Table
           0   11725
           1   11714
11741: oEndChoice
11742: oGetLocal 4
11744: oChoice 11825
11746: oGetLocal 2
11748: oPushResult
11749: oTypeSPush
11750: oPop 1
11752: oTypeSNodeType
11753: oChoice 11799
11755: oEmit 3
11757: oGetLocal 3
11759: oPushResult
11760: oEmitInt
11761: oPop 1
11763: oJumpForward 11823
11765: oEmit 4
11767: oGetLocal 3
11769: oPushResult
11770: oEmitInt
11771: oPop 1
11773: oJumpForward 11823
11775: oError 17
11777: oJumpForward 11823
11779: oEmit 5
11781: oGetLocal 3
11783: oPushResult
11784: oEmitInt
11785: oPop 1
11787: oJumpForward 11823
11789: oEmit 18
11791: oGetLocal 3
11793: oPushResult
11794: oEmitInt
11795: oPop 1
11797: oJumpForward 11823
11799: Choice Lookup Table
          43   11789
          41   11789
          39   11789
          38   11779
          37   11779
          29   11775
          36   11765
          30   11765
          34   11765
          44   11755
          31   11755
11822: oEndChoice
11823: oJumpForward 11828
11825: Choice Lookup Table
           1   11746
11828: oEmit 74
11830: oGetLocal 6
11832: oPushResult
11833: oEmitInt
11834: oPop 1
11836: oReturn
11837: oLocalSpace 2
11839: oGetAddrLocal 2
11841: oPushResult
11842: oGetParam 1
11844: oPushResult
11845: oSetResult 26
11847: oPushResult
11848: oNodeGetString
11849: oPop 2
11851: oAssign
11852: oGetLocal 2
11854: oPushResult
11855: oSetResult 0
11857: oPushResult
11858: equal_string
11859: oPop 2
11861: oChoice 11898
11863: oGetAddrLocal 1
11865: oPushResult
11866: oGetParam 1
11868: oPushResult
11869: oSetResult 4
11871: oPushResult
11872: oNodeGetInt
11873: oPop 2
11875: oPushResult
11876: ID_STRING
11877: oPop 1
11879: oPushResult
11880: oStringAllocLit
11881: oPop 1
11883: oAssign
11884: oJumpForward 11904
11886: oGetAddrLocal 1
11888: oPushResult
11889: oGetLocal 2
11891: oPushResult
11892: oStringAllocLit
11893: oPop 1
11895: oAssign
11896: oJumpForward 11904
11898: Choice Lookup Table
           0   11886
           1   11863
11903: oEndChoice
11904: oEmit 90
11906: oGetParam 1
11908: oPushResult
11909: oCall 14289
11911: oPop 1
11913: oGetLocal 1
11915: oPushResult
11916: oEmitInt
11917: oPop 1
11919: oReturn
11920: oLocalSpace 2
11922: oGetParam 1
11924: oPushResult
11925: oGetGlobal 17
11927: oPushResult
11928: oNodeEqual
11929: oPop 2
11931: oChoice 11971
11933: oInput 15
11935: oCall 4931
11937: oTypeSNodeType
11938: oChoice 11946
11940: oJumpForward 11959
11942: oEmit 32
11944: oJumpForward 11959
11946: Choice Lookup Table
          36   11942
          30   11942
          34   11942
          44   11940
          31   11940
11957: oError 15
11959: oTypeSPop
11960: oGetGlobal 6
11962: oPushResult
11963: oTypeSPush
11964: oPop 1
11966: oInput 16
11968: oReturn
11969: oJumpForward 11974
11971: Choice Lookup Table
           1   11933
11974: oGetParam 1
11976: oPushResult
11977: oGetGlobal 18
11979: oPushResult
11980: oNodeEqual
11981: oPop 2
11983: oChoice 12017
11985: oInput 15
11987: oCall 4931
11989: oTypeSNodeType
11990: oChoice 11998
11992: oEmit 33
11994: oJumpForward 12005
11996: oJumpForward 12005
11998: Choice Lookup Table
          30   11996
          31   11992
12003: oError 15
12005: oTypeSPop
12006: oGetGlobal 9
12008: oPushResult
12009: oTypeSPush
12010: oPop 1
12012: oInput 16
12014: oReturn
12015: oJumpForward 12020
12017: Choice Lookup Table
           1   11985
12020: oGetParam 1
12022: oPushResult
12023: oGetGlobal 19
12025: oPushResult
12026: oNodeEqual
12027: oPop 2
12029: oChoice 12069
12031: oInput 15
12033: oCall 4931
12035: oTypeSNodeType
12036: oChoice 12057
12038: oTypeSTop
12039: oPushResult
12040: oSetResult 45
12042: oPushResult
12043: oNodeGetBoolean
12044: oPop 2
12046: oChoice 12052
12048: oError 29
12050: oJumpForward 12055
12052: Choice Lookup Table
           1   12048
12055: oJumpForward 12062
12057: Choice Lookup Table
          44   12038
12060: oError 15
12062: oEmit 35
12064: oInput 16
12066: oReturn
12067: oJumpForward 12072
12069: Choice Lookup Table
           1   12031
12072: oGetParam 1
12074: oPushResult
12075: oGetGlobal 20
12077: oPushResult
12078: oNodeEqual
12079: oPop 2
12081: oChoice 12121
12083: oInput 15
12085: oCall 4931
12087: oTypeSNodeType
12088: oChoice 12109
12090: oTypeSTop
12091: oPushResult
12092: oSetResult 45
12094: oPushResult
12095: oNodeGetBoolean
12096: oPop 2
12098: oChoice 12104
12100: oError 29
12102: oJumpForward 12107
12104: Choice Lookup Table
           1   12100
12107: oJumpForward 12114
12109: Choice Lookup Table
          44   12090
12112: oError 15
12114: oEmit 34
12116: oInput 16
12118: oReturn
12119: oJumpForward 12124
12121: Choice Lookup Table
           1   12083
12124: oGetParam 1
12126: oPushResult
12127: oGetGlobal 21
12129: oPushResult
12130: oNodeEqual
12131: oPop 2
12133: oChoice 12189
12135: oInput 15
12137: oGetAddrLocal 1
12139: oPushResult
12140: oCodeNew
12141: oAssign
12142: oGetLocal 1
12144: oPushResult
12145: oCodePush
12146: oPop 1
12148: oCall 4954
12150: oCodePop
12151: oGetLocal 1
12153: oPushResult
12154: oCodeDiscard
12155: oPop 1
12157: oGetAddrLocal 2
12159: oPushResult
12160: oTypeSTop
12161: oAssign
12162: oTypeSPop
12163: oEmit 15
12165: oGetLocal 2
12167: oPushResult
12168: oSetResult 17
12170: oPushResult
12171: oNodeGetInt
12172: oPop 2
12174: oPushResult
12175: oEmitInt
12176: oPop 1
12178: oGetGlobal 6
12180: oPushResult
12181: oTypeSPush
12182: oPop 1
12184: oInput 16
12186: oReturn
12187: oJumpForward 12192
12189: Choice Lookup Table
           1   12135
12192: oError 17
12194: oReturn
12195: oLocalSpace 1
12197: oGetAddrLocal 1
12199: oPushResult
12200: oGetParam 2
12202: oPushResult
12203: oNodeNew
12204: oPop 1
12206: oAssign
12207: oGetLocal 1
12209: oPushResult
12210: oSetResult 17
12212: oPushResult
12213: oGetParam 1
12215: oPushResult
12216: oNodeSetInt
12217: oPop 3
12219: oGetLocal 1
12221: oPushResult
12222: oTypeAdd
12223: oPop 1
12225: oGetLocal 1
12227: oReturn
12228: oReturn
12229: oLocalSpace 12
12231: oInputChoice 12714
12233: oGetAddrLocal 1
12235: oPushResult
12236: oScopeFindRequire
12237: oAssign
12238: oGetAddrLocal 1
12240: oPushResult
12241: oCall 244
12243: oPop 1
12245: oGetLocal 1
12247: oPushResult
12248: oNodeType
12249: oPop 1
12251: oChoice 12268
12253: oGetParam 1
12255: oPushResult
12256: oGetLocal 1
12258: oPushResult
12259: oSetResult 21
12261: oPushResult
12262: oNodeGet
12263: oPop 2
12265: oAssign
12266: oJumpForward 12279
12268: Choice Lookup Table
          20   12253
12271: oError 2
12273: oGetParam 1
12275: oPushResult
12276: oGetGlobal 6
12278: oAssign
12279: oJumpForward 12737
12281: oInput 17
12283: oGetAddrLocal 2
12285: oPushResult
12286: oNodeVecNew
12287: oAssign
12288: oGetAddrLocal 3
12290: oPushResult
12291: oSetResult 40
12293: oPushResult
12294: oNodeNew
12295: oPop 1
12297: oAssign
12298: oCall 3568
12300: oGetLocal 3
12302: oPushResult
12303: oSetResult 40
12305: oPushResult
12306: oValueTop
12307: oPushResult
12308: oNodeSetInt
12309: oPop 3
12311: oValuePop
12312: oInput 22
12314: oCall 3568
12316: oGetLocal 3
12318: oPushResult
12319: oSetResult 41
12321: oPushResult
12322: oValueTop
12323: oPushResult
12324: oNodeSetInt
12325: oPop 3
12327: oValuePop
12328: oCall 4298
12330: oGetLocal 3
12332: oPushResult
12333: oSetResult 38
12335: oPushResult
12336: oTypeSTop
12337: oPushResult
12338: oNodeSet
12339: oPop 3
12341: oGetLocal 3
12343: oPushResult
12344: oSetResult 17
12346: oPushResult
12347: oTypeSTop
12348: oPushResult
12349: oSetResult 17
12351: oPushResult
12352: oNodeGetInt
12353: oPop 2
12355: oPushResult
12356: oNodeSetInt
12357: oPop 3
12359: oTypeSPop
12360: oGetLocal 3
12362: oPushResult
12363: oTypeAdd
12364: oPop 1
12366: oGetAddrLocal 4
12368: oPushResult
12369: oSetResult 39
12371: oPushResult
12372: oNodeNew
12373: oPop 1
12375: oAssign
12376: oGetLocal 4
12378: oPushResult
12379: oSetResult 39
12381: oPushResult
12382: oGetLocal 3
12384: oPushResult
12385: oNodeSet
12386: oPop 3
12388: oGetLocal 2
12390: oPushResult
12391: oGetLocal 4
12393: oPushResult
12394: oNodeVecAppend
12395: oPop 2
12397: oInputChoice 12405
12399: oJumpForward 12413
12401: oJumpForward 12411
12403: oJumpForward 12411
12405: Choice Lookup Table
          14   12403
          18   12399
12410: oEndChoice
12411: oJumpBack 12288
12413: oInput 41
12415: oGetAddrLocal 5
12417: oPushResult
12418: oCall 12229
12420: oPop 1
12422: oGetAddrLocal 6
12424: oPushResult
12425: oGetLocal 2
12427: oPushResult
12428: oNodeVecSize
12429: oPop 1
12431: oAssign
12432: oGetAddrLocal 6
12434: oPushResult
12435: dec
12436: oPop 1
12438: oGetAddrLocal 7
12440: oPushResult
12441: oGetLocal 2
12443: oPushResult
12444: oGetLocal 6
12446: oPushResult
12447: oNodeVecElement
12448: oPop 2
12450: oAssign
12451: oGetLocal 7
12453: oPushResult
12454: oSetResult 38
12456: oPushResult
12457: oGetLocal 5
12459: oPushResult
12460: oNodeSet
12461: oPop 3
12463: oGetAddrLocal 8
12465: oPushResult
12466: oGetLocal 7
12468: oPushResult
12469: oSetResult 39
12471: oPushResult
12472: oNodeGet
12473: oPop 2
12475: oAssign
12476: oGetAddrLocal 9
12478: oPushResult
12479: oGetLocal 8
12481: oPushResult
12482: oSetResult 41
12484: oPushResult
12485: oNodeGetInt
12486: oPop 2
12488: oPushResult
12489: oGetLocal 8
12491: oPushResult
12492: oSetResult 40
12494: oPushResult
12495: oNodeGetInt
12496: oPop 2
12498: oPushResult
12499: subtract
12500: oPop 2
12502: oAssign
12503: oGetAddrLocal 9
12505: oPushResult
12506: inc
12507: oPop 1
12509: oGetLocal 7
12511: oPushResult
12512: oSetResult 17
12514: oPushResult
12515: oGetLocal 9
12517: oPushResult
12518: oGetLocal 5
12520: oPushResult
12521: oSetResult 17
12523: oPushResult
12524: oNodeGetInt
12525: oPop 2
12527: oPushResult
12528: multiply
12529: oPop 2
12531: oPushResult
12532: oNodeSetInt
12533: oPop 3
12535: oGetLocal 7
12537: oPushResult
12538: oTypeAdd
12539: oPop 1
12541: oGetAddrLocal 5
12543: oPushResult
12544: oGetLocal 7
12546: oAssign
12547: oGetLocal 6
12549: oPushResult
12550: equal_zero
12551: oPop 1
12553: oChoice 12559
12555: oJumpForward 12564
12557: oJumpForward 12562
12559: Choice Lookup Table
           1   12555
12562: oJumpBack 12432
12564: oGetParam 1
12566: oPushResult
12567: oGetLocal 2
12569: oPushResult
12570: oSetResult 0
12572: oPushResult
12573: oNodeVecElement
12574: oPop 2
12576: oAssign
12577: oGetLocal 2
12579: oPushResult
12580: oNodeVecDelete
12581: oPop 1
12583: oJumpForward 12737
12585: oGetAddrLocal 10
12587: oPushResult
12588: oCall 12229
12590: oPop 1
12592: oGetParam 1
12594: oPushResult
12595: oGetLocal 10
12597: oPushResult
12598: oCall 13308
12600: oPop 1
12602: oAssign
12603: oJumpForward 12737
12605: oGetParam 1
12607: oPushResult
12608: oSetResult 41
12610: oPushResult
12611: oNodeNew
12612: oPop 1
12614: oAssign
12615: oSetResult -1
12617: oPushResult
12618: oSetResult 2
12620: oPushResult
12621: oScopeBegin
12622: oPop 2
12624: oSetResult 24
12626: oPushResult
12627: oCall 3269
12629: oPop 1
12631: oGetAddrLocal 11
12633: oPushResult
12634: oScopeCurrent
12635: oPushResult
12636: oSetResult 17
12638: oPushResult
12639: oNodeGetInt
12640: oPop 2
12642: oAssign
12643: oGetLocal 11
12645: oPushResult
12646: equal_zero
12647: oPop 1
12649: oChoice 12655
12651: oError 20
12653: oJumpForward 12658
12655: Choice Lookup Table
           1   12651
12658: oInput 37
12660: oGetFromParam 1
12662: oPushResult
12663: oSetResult 42
12665: oPushResult
12666: oScopeCurrent
12667: oPushResult
12668: oNodeSet
12669: oPop 3
12671: oGetFromParam 1
12673: oPushResult
12674: oSetResult 17
12676: oPushResult
12677: oGetLocal 11
12679: oPushResult
12680: oNodeSetInt
12681: oPop 3
12683: oScopeEnd
12684: oGetFromParam 1
12686: oPushResult
12687: oTypeAdd
12688: oPop 1
12690: oJumpForward 12737
12692: oGetParam 1
12694: oPushResult
12695: oCall 12738
12697: oPop 1
12699: oJumpForward 12737
12701: oInput 41
12703: oGetAddrLocal 12
12705: oPushResult
12706: oCall 12229
12708: oPop 1
12710: oError 17
12712: oJumpForward 12737
12714: Choice Lookup Table
          40   12701
          15   12692
          39   12605
          19   12585
          38   12281
           0   12233
12727: oCall 3568
12729: oInput 22
12731: oCall 3568
12733: oCall 4298
12735: oError 17
12737: oReturn
12738: oLocalSpace 11
12740: oGetParam 1
12742: oPushResult
12743: oSetResult 44
12745: oPushResult
12746: oNodeNew
12747: oPop 1
12749: oAssign
12750: oGetAddrLocal 1
12752: oPushResult
12753: oSetResult 0
12755: oAssign
12756: oGetAddrLocal 2
12758: oPushResult
12759: oSetResult 0
12761: oAssign
12762: oGetAddrLocal 3
12764: oPushResult
12765: oSetResult 1
12767: oAssign
12768: oGetAddrLocal 4
12770: oPushResult
12771: oScopeCurrent
12772: oAssign
12773: oSetResult -1
12775: oPushResult
12776: oSetResult 2
12778: oPushResult
12779: oScopeBegin
12780: oPop 2
12782: oInput 0
12784: oGetAddrLocal 5
12786: oPushResult
12787: oSetResult 17
12789: oPushResult
12790: LAST_ID
12791: oPushResult
12792: oCall 14261
12794: oPop 2
12796: oAssign
12797: oGetAddrLocal 6
12799: oPushResult
12800: oSetResult 17
12802: oPushResult
12803: LAST_ID
12804: oPushResult
12805: oCall 14261
12807: oPop 2
12809: oAssign
12810: oGetLocal 5
12812: oPushResult
12813: oSetResult 21
12815: oPushResult
12816: oGetFromParam 1
12818: oPushResult
12819: oNodeSet
12820: oPop 3
12822: oGetLocal 6
12824: oPushResult
12825: oSetResult 21
12827: oPushResult
12828: oGetFromParam 1
12830: oPushResult
12831: oNodeSet
12832: oPop 3
12834: oGetAddrLocal 7
12836: oPushResult
12837: LAST_ID
12838: oPushResult
12839: ID_STRING
12840: oPop 1
12842: oPushResult
12843: oStringAllocLit
12844: oPop 1
12846: oAssign
12847: oGetLocal 5
12849: oPushResult
12850: oSetResult 32
12852: oPushResult
12853: oGetLocal 7
12855: oPushResult
12856: oNodeSetInt
12857: oPop 3
12859: oGetLocal 6
12861: oPushResult
12862: oSetResult 32
12864: oPushResult
12865: oGetLocal 7
12867: oPushResult
12868: oNodeSetInt
12869: oPop 3
12871: oInputChoice 12949
12873: oGetGlobal 6
12875: oPushResult
12876: oTypeSPush
12877: oPop 1
12879: oCall 3568
12881: oCall 4395
12883: oTypeSPop
12884: oGetLocal 2
12886: oPushResult
12887: equal_zero
12888: oPop 1
12890: oChoice 12911
12892: oValueTop
12893: oPushResult
12894: oGetLocal 1
12896: oPushResult
12897: greater
12898: oPop 2
12900: oChoice 12906
12902: oError 27
12904: oJumpForward 12909
12906: Choice Lookup Table
           0   12902
12909: oJumpForward 12914
12911: Choice Lookup Table
           0   12892
12914: oGetLocal 1
12916: oPushResult
12917: oValueTop
12918: oPushResult
12919: equal
12920: oPop 2
12922: oChoice 12938
12924: oGetFromParam 1
12926: oPushResult
12927: oSetResult 45
12929: oPushResult
12930: oSetResult 1
12932: oPushResult
12933: oNodeSetBoolean
12934: oPop 3
12936: oJumpForward 12941
12938: Choice Lookup Table
           0   12924
12941: oGetAddrLocal 1
12943: oPushResult
12944: oValueTop
12945: oAssign
12946: oValuePop
12947: oJumpForward 12954
12949: Choice Lookup Table
           5   12873
           7   12873
12954: oGetLocal 5
12956: oPushResult
12957: oSetResult 22
12959: oPushResult
12960: oGetLocal 1
12962: oPushResult
12963: oNodeSetInt
12964: oPop 3
12966: oGetLocal 6
12968: oPushResult
12969: oSetResult 22
12971: oPushResult
12972: oGetLocal 1
12974: oPushResult
12975: oNodeSetInt
12976: oPop 3
12978: oGetLocal 5
12980: oPushResult
12981: oScopeDeclare
12982: oPop 1
12984: oGetLocal 4
12986: oPushResult
12987: oScopeEnter
12988: oPop 1
12990: oGetLocal 6
12992: oPushResult
12993: oScopeDeclare
12994: oPop 1
12996: oScopeEnd
12997: oGetAddrLocal 1
12999: oPushResult
13000: inc
13001: oPop 1
13003: oGetAddrLocal 2
13005: oPushResult
13006: inc
13007: oPop 1
13009: oInputChoice 13013
13011: oJumpForward 13018
13013: Choice Lookup Table
          14   13011
13016: oJumpForward 13020
13018: oJumpBack 12782
13020: oInput 16
13022: oGetFromParam 1
13024: oPushResult
13025: oSetResult 42
13027: oPushResult
13028: oScopeCurrent
13029: oPushResult
13030: oNodeSet
13031: oPop 3
13033: oGetFromParam 1
13035: oPushResult
13036: oSetResult 17
13038: oPushResult
13039: oSetResult 4
13041: oPushResult
13042: oNodeSetInt
13043: oPop 3
13045: oScopeEnd
13046: oGetGlobal 2
13048: oPushResult
13049: oCall 14159
13051: oPop 1
13053: oPushResult
13054: oCodePush
13055: oPop 1
13057: oGetGlobal 2
13059: oPushResult
13060: oScopeEnter
13061: oPop 1
13063: oGetAddrLocal 8
13065: oPushResult
13066: oGetLocal 2
13068: oPushResult
13069: oSetResult 1
13071: oPushResult
13072: add
13073: oPop 2
13075: oPushResult
13076: oSetResult 16
13078: oPushResult
13079: multiply
13080: oPop 2
13082: oAssign
13083: oGetAddrLocal 9
13085: oPushResult
13086: oGetLocal 8
13088: oPushResult
13089: oSetResult 8
13091: oPushResult
13092: oScopeAlloc
13093: oPop 2
13095: oAssign
13096: oScopeEnd
13097: oGetFromParam 1
13099: oPushResult
13100: oSetResult 44
13102: oPushResult
13103: oGetLocal 9
13105: oPushResult
13106: oNodeSetInt
13107: oPop 3
13109: oGetAddrLocal 10
13111: oPushResult
13112: oGetFromParam 1
13114: oPushResult
13115: oSetResult 42
13117: oPushResult
13118: oNodeGet
13119: oPop 2
13121: oPushResult
13122: oSetResult 15
13124: oPushResult
13125: oNodeGetIter
13126: oPop 2
13128: oAssign
13129: oGetAddrLocal 11
13131: oPushResult
13132: oGetLocal 10
13134: oPushResult
13135: oNodeIterValue
13136: oPop 1
13138: oAssign
13139: oGetLocal 11
13141: oPushResult
13142: oNodeNull
13143: oPop 1
13145: oChoice 13151
13147: oJumpForward 13238
13149: oJumpForward 13154
13151: Choice Lookup Table
           1   13147
13154: oEmit 17
13156: oGetLocal 9
13158: oPushResult
13159: oEmitInt
13160: oPop 1
13162: oEmit 15
13164: oGetLocal 11
13166: oPushResult
13167: oSetResult 22
13169: oPushResult
13170: oNodeGetInt
13171: oPop 2
13173: oPushResult
13174: oEmitInt
13175: oPop 1
13177: oEmit 27
13179: oGetAddrLocal 9
13181: oPushResult
13182: oGetLocal 9
13184: oPushResult
13185: oSetResult 8
13187: oPushResult
13188: add
13189: oPop 2
13191: oAssign
13192: oEmit 17
13194: oGetLocal 9
13196: oPushResult
13197: oEmitInt
13198: oPop 1
13200: oEmit 17
13202: oGetLocal 11
13204: oPushResult
13205: oSetResult 32
13207: oPushResult
13208: oNodeGetInt
13209: oPop 2
13211: oPushResult
13212: oEmitInt
13213: oPop 1
13215: oEmit 29
13217: oGetAddrLocal 9
13219: oPushResult
13220: oGetLocal 9
13222: oPushResult
13223: oSetResult 8
13225: oPushResult
13226: add
13227: oPop 2
13229: oAssign
13230: oGetAddrLocal 10
13232: oPushResult
13233: oNodeIterNext
13234: oPop 1
13236: oJumpBack 13129
13238: oEmit 17
13240: oGetLocal 9
13242: oPushResult
13243: oEmitInt
13244: oPop 1
13246: oEmit 15
13248: oSetResult 0
13250: oPushResult
13251: oEmitInt
13252: oPop 1
13254: oEmit 27
13256: oGetAddrLocal 9
13258: oPushResult
13259: oGetLocal 9
13261: oPushResult
13262: oSetResult 8
13264: oPushResult
13265: add
13266: oPop 2
13268: oAssign
13269: oEmit 17
13271: oGetLocal 9
13273: oPushResult
13274: oEmitInt
13275: oPop 1
13277: oEmit 15
13279: oSetResult 0
13281: oPushResult
13282: oEmitInt
13283: oPop 1
13285: oEmit 29
13287: oGetAddrLocal 9
13289: oPushResult
13290: oGetLocal 9
13292: oPushResult
13293: oSetResult 8
13295: oPushResult
13296: add
13297: oPop 2
13299: oAssign
13300: oCodePop
13301: oGetFromParam 1
13303: oPushResult
13304: oTypeAdd
13305: oPop 1
13307: oReturn
13308: oLocalSpace 1
13310: oGetAddrLocal 1
13312: oPushResult
13313: oGetParam 1
13315: oPushResult
13316: oSetResult 37
13318: oPushResult
13319: oNodeGet
13320: oPop 2
13322: oAssign
13323: oGetLocal 1
13325: oPushResult
13326: oNodeNull
13327: oPop 1
13329: oChoice 13385
13331: oGetAddrLocal 1
13333: oPushResult
13334: oSetResult 37
13336: oPushResult
13337: oNodeNew
13338: oPop 1
13340: oAssign
13341: oGetLocal 1
13343: oPushResult
13344: oSetResult 38
13346: oPushResult
13347: oGetParam 1
13349: oPushResult
13350: oNodeSet
13351: oPop 3
13353: oGetLocal 1
13355: oPushResult
13356: oSetResult 17
13358: oPushResult
13359: oSetResult 8
13361: oPushResult
13362: oNodeSetInt
13363: oPop 3
13365: oGetLocal 1
13367: oPushResult
13368: oTypeAdd
13369: oPop 1
13371: oGetParam 1
13373: oPushResult
13374: oSetResult 37
13376: oPushResult
13377: oGetLocal 1
13379: oPushResult
13380: oNodeSet
13381: oPop 3
13383: oJumpForward 13388
13385: Choice Lookup Table
           1   13331
13388: oGetLocal 1
13390: oReturn
13391: oReturn
13392: oLocalSpace 2
13394: oGetParam 1
13396: oPushResult
13397: oNodeType
13398: oPop 1
13400: oChoice 13470
13402: oMININT
13403: oReturn
13404: oJumpForward 13486
13406: oSetResult 0
13408: oReturn
13409: oJumpForward 13486
13411: oSetResult 0
13413: oReturn
13414: oJumpForward 13486
13416: oGetAddrLocal 1
13418: oPushResult
13419: oGetParam 1
13421: oPushResult
13422: oSetResult 42
13424: oPushResult
13425: oNodeGet
13426: oPop 2
13428: oAssign
13429: oGetAddrLocal 2
13431: oPushResult
13432: oGetLocal 1
13434: oPushResult
13435: oSetResult 15
13437: oPushResult
13438: oNodeGetIter
13439: oPop 2
13441: oPushResult
13442: oNodeIterValue
13443: oPop 1
13445: oAssign
13446: oGetLocal 2
13448: oPushResult
13449: oSetResult 22
13451: oPushResult
13452: oNodeGetInt
13453: oPop 2
13455: oReturn
13456: oJumpForward 13486
13458: oGetParam 1
13460: oPushResult
13461: oSetResult 40
13463: oPushResult
13464: oNodeGetInt
13465: oPop 2
13467: oReturn
13468: oJumpForward 13486
13470: Choice Lookup Table
          40   13458
          44   13416
          36   13411
          34   13406
          31   13402
13481: oError 3
13483: oSetResult 0
13485: oReturn
13486: oReturn
13487: oLocalSpace 2
13489: oGetParam 1
13491: oPushResult
13492: oNodeType
13493: oPop 1
13495: oChoice 13565
13497: oMAXINT
13498: oReturn
13499: oJumpForward 13581
13501: oSetResult 1
13503: oReturn
13504: oJumpForward 13581
13506: oSetResult 255
13508: oReturn
13509: oJumpForward 13581
13511: oGetAddrLocal 1
13513: oPushResult
13514: oGetParam 1
13516: oPushResult
13517: oSetResult 42
13519: oPushResult
13520: oNodeGet
13521: oPop 2
13523: oAssign
13524: oGetAddrLocal 2
13526: oPushResult
13527: oGetLocal 1
13529: oPushResult
13530: oSetResult 15
13532: oPushResult
13533: oNodeGetIterLast
13534: oPop 2
13536: oPushResult
13537: oNodeIterValue
13538: oPop 1
13540: oAssign
13541: oGetLocal 2
13543: oPushResult
13544: oSetResult 22
13546: oPushResult
13547: oNodeGetInt
13548: oPop 2
13550: oReturn
13551: oJumpForward 13581
13553: oGetParam 1
13555: oPushResult
13556: oSetResult 41
13558: oPushResult
13559: oNodeGetInt
13560: oPop 2
13562: oReturn
13563: oJumpForward 13581
13565: Choice Lookup Table
          40   13553
          44   13511
          36   13506
          34   13501
          31   13497
13576: oError 3
13578: oSetResult 0
13580: oReturn
13581: oReturn
13582: oLocalSpace 5
13584: oGetAddrGlobal 1
13586: oPushResult
13587: oWorkspaceNew
13588: oAssign
13589: oSetResult 0
13591: oPushResult
13592: oSetResult 0
13594: oPushResult
13595: oScopeBegin
13596: oPop 2
13598: oGetAddrLocal 2
13600: oPushResult
13601: oScopeCurrent
13602: oAssign
13603: oCall 14331
13605: oEmit 78
13607: oSetResult 0
13609: oPushResult
13610: oEmitInt
13611: oPop 1
13613: oGetAddrLocal 3
13615: oPushResult
13616: oLabelNew
13617: oAssign
13618: oEmit 72
13620: oSetResult 0
13622: oPushResult
13623: oEmitInt
13624: oPop 1
13626: oEmit 75
13628: oGetLocal 3
13630: oPushResult
13631: oEmitLabel
13632: oPop 1
13634: oEmit 74
13636: oSetResult 0
13638: oPushResult
13639: oEmitInt
13640: oPop 1
13642: oEmit 77
13644: oInput 29
13646: oInput 0
13648: oGetAddrLocal 4
13650: oPushResult
13651: oSetResult 4
13653: oPushResult
13654: oNodeNew
13655: oPop 1
13657: oAssign
13658: oGetLocal 4
13660: oPushResult
13661: oSetResult 4
13663: oPushResult
13664: LAST_ID
13665: oPushResult
13666: oNodeSetInt
13667: oPop 3
13669: oGetGlobal 1
13671: oPushResult
13672: oSetResult 2
13674: oPushResult
13675: oGetLocal 4
13677: oPushResult
13678: oNodeSet
13679: oPop 3
13681: oInputChoice 13755
13683: oInput 0
13685: oGetAddrLocal 1
13687: oPushResult
13688: oSetResult 21
13690: oPushResult
13691: LAST_ID
13692: oPushResult
13693: oCall 14261
13695: oPop 2
13697: oAssign
13698: oGetLocal 1
13700: oPushResult
13701: oSetResult 21
13703: oPushResult
13704: oGetGlobal 5
13706: oPushResult
13707: oNodeSet
13708: oPop 3
13710: oGetLocal 1
13712: oPushResult
13713: oScopeDeclareAlloc
13714: oPop 1
13716: oInput 14
13718: oInput 0
13720: oGetAddrLocal 1
13722: oPushResult
13723: oSetResult 21
13725: oPushResult
13726: LAST_ID
13727: oPushResult
13728: oCall 14261
13730: oPop 2
13732: oAssign
13733: oGetLocal 1
13735: oPushResult
13736: oSetResult 21
13738: oPushResult
13739: oGetGlobal 5
13741: oPushResult
13742: oNodeSet
13743: oPop 3
13745: oGetLocal 1
13747: oPushResult
13748: oScopeDeclareAlloc
13749: oPop 1
13751: oInput 16
13753: oJumpForward 13758
13755: Choice Lookup Table
          15   13683
13758: oInput 6
13760: oGetLocal 4
13762: oPushResult
13763: oCall 34
13765: oPop 1
13767: oInputChoice 13778
13769: oGetLocal 4
13771: oPushResult
13772: oCall 7
13774: oPop 1
13776: oJumpForward 13781
13778: Choice Lookup Table
          60   13769
13781: oGetLocal 4
13783: oPushResult
13784: oCall 287
13786: oPop 1
13788: oSetResult 0
13790: oPushResult
13791: oSetResult 0
13793: oPushResult
13794: oScopeBegin
13795: oPop 2
13797: oGetAddrGlobal 2
13799: oPushResult
13800: oScopeCurrent
13801: oAssign
13802: oSetResult 0
13804: oPushResult
13805: oSetResult 1
13807: oPushResult
13808: oScopeBegin
13809: oPop 2
13811: oScopeCurrent
13812: oPushResult
13813: oSetResult 16
13815: oPushResult
13816: oGetGlobal 2
13818: oPushResult
13819: oNodeSet
13820: oPop 3
13822: oGetAddrGlobal 3
13824: oPushResult
13825: oScopeCurrent
13826: oAssign
13827: oGetLocal 4
13829: oPushResult
13830: oSetResult 7
13832: oPushResult
13833: oGetGlobal 3
13835: oPushResult
13836: oNodeSet
13837: oPop 3
13839: oScopeEnd
13840: oSetResult 22
13842: oPushResult
13843: oCall 13910
13845: oPop 1
13847: oGetGlobal 3
13849: oPushResult
13850: oScopeEnter
13851: oPop 1
13853: oGetAddrLocal 5
13855: oPushResult
13856: oSetResult 1
13858: oAssign
13859: oGetLocal 3
13861: oPushResult
13862: oGetGlobal 2
13864: oPushResult
13865: oGetLocal 5
13867: oPushResult
13868: oCall 14061
13870: oPop 3
13872: oScopeEnd
13873: oInput 21
13875: oCall 13966
13877: oScopeEnd
13878: oGetLocal 4
13880: oPushResult
13881: oCall 349
13883: oPop 1
13885: oReturn
13886: oLocalSpace 0
13888: oGetParam 2
13890: oPushResult
13891: oCall 13910
13893: oPop 1
13895: oGetParam 1
13897: oPushResult
13898: oScopeCurrent
13899: oPushResult
13900: oSetResult 0
13902: oPushResult
13903: oCall 14061
13905: oPop 3
13907: oCall 13966
13909: oReturn
13910: oLocalSpace 0
13912: oInputChoice 13943
13914: oCall 2520
13916: oJumpForward 13958
13918: oCall 3213
13920: oJumpForward 13958
13922: oGetParam 1
13924: oPushResult
13925: oCall 3269
13927: oPop 1
13929: oJumpForward 13958
13931: oCall 3503
13933: oJumpForward 13958
13935: oCall 1743
13937: oJumpForward 13958
13939: oCall 2178
13941: oJumpForward 13958
13943: Choice Lookup Table
          31   13939
          30   13935
          35   13931
          34   13922
          33   13918
          32   13914
13956: oJumpForward 13960
13958: oJumpBack 13912
13960: oCall 13963
13962: oReturn
13963: oLocalSpace 0
13965: oReturn
13966: oLocalSpace 2
13968: oGetAddrLocal 1
13970: oPushResult
13971: oScopeCurrent
13972: oPushResult
13973: oSetResult 15
13975: oPushResult
13976: oNodeGetIter
13977: oPop 2
13979: oAssign
13980: oGetAddrLocal 2
13982: oPushResult
13983: oGetLocal 1
13985: oPushResult
13986: oNodeIterValue
13987: oPop 1
13989: oAssign
13990: oGetLocal 2
13992: oPushResult
13993: oNodeNull
13994: oPop 1
13996: oChoice 14000
13998: oJumpForward 14005
14000: Choice Lookup Table
           0   13998
14003: oJumpForward 14060
14005: oGetLocal 2
14007: oPushResult
14008: oNodeType
14009: oPop 1
14011: oChoice 14049
14013: oGetLocal 2
14015: oPushResult
14016: oSetResult 36
14018: oPushResult
14019: oNodeGetBoolean
14020: oPop 2
14022: oChoice 14044
14024: oGetLocal 2
14026: oPushResult
14027: oSetResult 28
14029: oPushResult
14030: oNodeGetBoolean
14031: oPop 2
14033: oChoice 14039
14035: oError 28
14037: oJumpForward 14042
14039: Choice Lookup Table
           1   14035
14042: oJumpForward 14047
14044: Choice Lookup Table
           0   14024
14047: oJumpForward 14052
14049: Choice Lookup Table
          27   14013
14052: oGetAddrLocal 1
14054: oPushResult
14055: oNodeIterNext
14056: oPop 1
14058: oJumpBack 13980
14060: oReturn
14061: oLocalSpace 3
14063: oEmit 88
14065: oGetParam 3
14067: oPushResult
14068: oEmitLabel
14069: oPop 1
14071: oEmit 78
14073: oGetAddrLocal 1
14075: oPushResult
14076: Here
14077: oAssign
14078: oEmit 106
14080: oGetParam 1
14082: oChoice 14088
14084: oCall 1220
14086: oJumpForward 14091
14088: Choice Lookup Table
           1   14084
14091: oGetAddrLocal 2
14093: oPushResult
14094: oGetParam 2
14096: oPushResult
14097: oSetResult 19
14099: oPushResult
14100: oNodeGetCode
14101: oPop 2
14103: oAssign
14104: oGetLocal 2
14106: oPushResult
14107: oEmitCode
14108: oPop 1
14110: oGetParam 2
14112: oPushResult
14113: oSetResult 19
14115: oPushResult
14116: oSetResult 0
14118: oPushResult
14119: oNodeSetCode
14120: oPop 3
14122: oCall 8974
14124: oGetParam 1
14126: oChoice 14132
14128: oCall 1305
14130: oJumpForward 14135
14132: Choice Lookup Table
           1   14128
14135: oEmit 77
14137: oGetAddrLocal 3
14139: oPushResult
14140: oScopeCurrent
14141: oPushResult
14142: oSetResult 17
14144: oPushResult
14145: oNodeGetInt
14146: oPop 2
14148: oAssign
14149: oGetLocal 1
14151: oPushResult
14152: oGetLocal 3
14154: oPushResult
14155: oPatch
14156: oPop 2
14158: oReturn
14159: oLocalSpace 1
14161: oGetAddrLocal 1
14163: oPushResult
14164: oGetParam 1
14166: oPushResult
14167: oSetResult 19
14169: oPushResult
14170: oNodeGetCode
14171: oPop 2
14173: oAssign
14174: oGetLocal 1
14176: oPushResult
14177: oSetResult 0
14179: oPushResult
14180: equal_code
14181: oPop 2
14183: oChoice 14204
14185: oGetAddrLocal 1
14187: oPushResult
14188: oCodeNew
14189: oAssign
14190: oGetParam 1
14192: oPushResult
14193: oSetResult 19
14195: oPushResult
14196: oGetLocal 1
14198: oPushResult
14199: oNodeSetCode
14200: oPop 3
14202: oJumpForward 14207
14204: Choice Lookup Table
           1   14185
14207: oGetLocal 1
14209: oReturn
14210: oReturn
14211: oLocalSpace 0
14213: oScopeCurrent
14214: oPushResult
14215: oSetResult 14
14217: oPushResult
14218: oNodeGetInt
14219: oPop 2
14221: oReturn
14222: oReturn
14223: oLocalSpace 0
14225: oGetParam 1
14227: oPushResult
14228: oSetResult 20
14230: oPushResult
14231: oNodeGet
14232: oPop 2
14234: oPushResult
14235: oSetResult 14
14237: oPushResult
14238: oNodeGetInt
14239: oPop 2
14241: oReturn
14242: oReturn
14243: oLocalSpace 0
14245: oCall 14211
14247: oPushResult
14248: oGetParam 1
14250: oPushResult
14251: oCall 14223
14253: oPop 1
14255: oPushResult
14256: subtract
14257: oPop 2
14259: oReturn
14260: oReturn
14261: oLocalSpace 1
14263: oGetAddrLocal 1
14265: oPushResult
14266: oGetParam 2
14268: oPushResult
14269: oNodeNew
14270: oPop 1
14272: oAssign
14273: oGetLocal 1
14275: oPushResult
14276: oSetResult 4
14278: oPushResult
14279: oGetParam 1
14281: oPushResult
14282: oNodeSetInt
14283: oPop 3
14285: oGetLocal 1
14287: oReturn
14288: oReturn
14289: oLocalSpace 0
14291: oGetParam 1
14293: oPushResult
14294: oSetResult 22
14296: oPushResult
14297: oNodeGetInt
14298: oPop 2
14300: oPushResult
14301: oEmitInt
14302: oPop 1
14304: oReturn
14305: oLocalSpace 1
14307: oGetAddrLocal 1
14309: oPushResult
14310: oSetResult 14
14312: oPushResult
14313: oGetParam 1
14315: oPushResult
14316: oCall 14261
14318: oPop 2
14320: oAssign
14321: oGetLocal 1
14323: oPushResult
14324: oScopeDeclare
14325: oPop 1
14327: oGetLocal 1
14329: oReturn
14330: oReturn
14331: oLocalSpace 1
14333: oGetAddrGlobal 25
14335: oPushResult
14336: oSetResult 0
14338: oAssign
14339: oGetAddrGlobal 4
14341: oPushResult
14342: oId_mysystem
14343: oAssign
14344: oGetAddrGlobal 5
14346: oPushResult
14347: oSetResult 29
14349: oPushResult
14350: oSetResult 4
14352: oPushResult
14353: oCall 12195
14355: oPop 2
14357: oAssign
14358: oGetAddrGlobal 6
14360: oPushResult
14361: oSetResult 31
14363: oPushResult
14364: oSetResult 4
14366: oPushResult
14367: oCall 12195
14369: oPop 2
14371: oAssign
14372: oGetAddrGlobal 7
14374: oPushResult
14375: oSetResult 34
14377: oPushResult
14378: oSetResult 1
14380: oPushResult
14381: oCall 12195
14383: oPop 2
14385: oAssign
14386: oGetAddrGlobal 8
14388: oPushResult
14389: oSetResult 35
14391: oPushResult
14392: oSetResult 1
14394: oPushResult
14395: oCall 12195
14397: oPop 2
14399: oAssign
14400: oGetAddrGlobal 9
14402: oPushResult
14403: oSetResult 36
14405: oPushResult
14406: oSetResult 1
14408: oPushResult
14409: oCall 12195
14411: oPop 2
14413: oAssign
14414: oGetAddrGlobal 10
14416: oPushResult
14417: oGetGlobal 9
14419: oPushResult
14420: oCall 13308
14422: oPop 1
14424: oAssign
14425: oGetAddrGlobal 11
14427: oPushResult
14428: oSetResult 30
14430: oPushResult
14431: oSetResult 1
14433: oPushResult
14434: oCall 12195
14436: oPop 2
14438: oAssign
14439: oGetAddrGlobal 12
14441: oPushResult
14442: oSetResult 32
14444: oPushResult
14445: oSetResult 4
14447: oPushResult
14448: oCall 12195
14450: oPop 2
14452: oAssign
14453: oGetAddrGlobal 13
14455: oPushResult
14456: oSetResult 33
14458: oPushResult
14459: oSetResult 8
14461: oPushResult
14462: oCall 12195
14464: oPop 2
14466: oAssign
14467: oGetAddrGlobal 14
14469: oPushResult
14470: oSetResult 38
14472: oPushResult
14473: oSetResult 8
14475: oPushResult
14476: oCall 12195
14478: oPop 2
14480: oAssign
14481: oGetGlobal 14
14483: oPushResult
14484: oSetResult 38
14486: oPushResult
14487: oGetGlobal 11
14489: oPushResult
14490: oNodeSet
14491: oPop 3
14493: oGetAddrGlobal 15
14495: oPushResult
14496: oSetResult 42
14498: oPushResult
14499: oSetResult 256
14501: oPushResult
14502: oCall 12195
14504: oPop 2
14506: oAssign
14507: oGetAddrGlobal 16
14509: oPushResult
14510: oSetResult 43
14512: oPushResult
14513: oSetResult 256
14515: oPushResult
14516: oCall 12195
14518: oPop 2
14520: oAssign
14521: oGetGlobal 16
14523: oPushResult
14524: oSetResult 43
14526: oPushResult
14527: oSetResult 255
14529: oPushResult
14530: oNodeSetInt
14531: oPop 3
14533: oGetAddrLocal 1
14535: oPushResult
14536: oSetResult 20
14538: oPushResult
14539: oId_File
14540: oPushResult
14541: oCall 14261
14543: oPop 2
14545: oAssign
14546: oGetLocal 1
14548: oPushResult
14549: oSetResult 21
14551: oPushResult
14552: oGetGlobal 5
14554: oPushResult
14555: oNodeSet
14556: oPop 3
14558: oGetLocal 1
14560: oPushResult
14561: oScopeDeclare
14562: oPop 1
14564: oGetAddrLocal 1
14566: oPushResult
14567: oSetResult 20
14569: oPushResult
14570: oId_Integer
14571: oPushResult
14572: oCall 14261
14574: oPop 2
14576: oAssign
14577: oGetLocal 1
14579: oPushResult
14580: oSetResult 21
14582: oPushResult
14583: oGetGlobal 6
14585: oPushResult
14586: oNodeSet
14587: oPop 3
14589: oGetLocal 1
14591: oPushResult
14592: oScopeDeclare
14593: oPop 1
14595: oGetAddrLocal 1
14597: oPushResult
14598: oSetResult 20
14600: oPushResult
14601: oId_Boolean
14602: oPushResult
14603: oCall 14261
14605: oPop 2
14607: oAssign
14608: oGetLocal 1
14610: oPushResult
14611: oSetResult 21
14613: oPushResult
14614: oGetGlobal 7
14616: oPushResult
14617: oNodeSet
14618: oPop 3
14620: oGetLocal 1
14622: oPushResult
14623: oScopeDeclare
14624: oPop 1
14626: oGetAddrLocal 1
14628: oPushResult
14629: oSetResult 20
14631: oPushResult
14632: oId_Char
14633: oPushResult
14634: oCall 14261
14636: oPop 2
14638: oAssign
14639: oGetLocal 1
14641: oPushResult
14642: oSetResult 21
14644: oPushResult
14645: oGetGlobal 9
14647: oPushResult
14648: oNodeSet
14649: oPop 3
14651: oGetLocal 1
14653: oPushResult
14654: oScopeDeclare
14655: oPop 1
14657: oGetAddrLocal 1
14659: oPushResult
14660: oSetResult 20
14662: oPushResult
14663: oId_Byte
14664: oPushResult
14665: oCall 14261
14667: oPop 2
14669: oAssign
14670: oGetLocal 1
14672: oPushResult
14673: oSetResult 21
14675: oPushResult
14676: oGetGlobal 11
14678: oPushResult
14679: oNodeSet
14680: oPop 3
14682: oGetLocal 1
14684: oPushResult
14685: oScopeDeclare
14686: oPop 1
14688: oGetAddrLocal 1
14690: oPushResult
14691: oSetResult 20
14693: oPushResult
14694: oId_Single
14695: oPushResult
14696: oCall 14261
14698: oPop 2
14700: oAssign
14701: oGetLocal 1
14703: oPushResult
14704: oSetResult 21
14706: oPushResult
14707: oGetGlobal 12
14709: oPushResult
14710: oNodeSet
14711: oPop 3
14713: oGetLocal 1
14715: oPushResult
14716: oScopeDeclare
14717: oPop 1
14719: oGetAddrLocal 1
14721: oPushResult
14722: oSetResult 20
14724: oPushResult
14725: oId_Double
14726: oPushResult
14727: oCall 14261
14729: oPop 2
14731: oAssign
14732: oGetLocal 1
14734: oPushResult
14735: oSetResult 21
14737: oPushResult
14738: oGetGlobal 13
14740: oPushResult
14741: oNodeSet
14742: oPop 3
14744: oGetLocal 1
14746: oPushResult
14747: oScopeDeclare
14748: oPop 1
14750: oGetAddrLocal 1
14752: oPushResult
14753: oSetResult 20
14755: oPushResult
14756: oId_Pointer
14757: oPushResult
14758: oCall 14261
14760: oPop 2
14762: oAssign
14763: oGetLocal 1
14765: oPushResult
14766: oSetResult 21
14768: oPushResult
14769: oGetGlobal 14
14771: oPushResult
14772: oNodeSet
14773: oPop 3
14775: oGetLocal 1
14777: oPushResult
14778: oScopeDeclare
14779: oPop 1
14781: oGetAddrLocal 1
14783: oPushResult
14784: oSetResult 20
14786: oPushResult
14787: oId_ShortString
14788: oPushResult
14789: oCall 14261
14791: oPop 2
14793: oAssign
14794: oGetLocal 1
14796: oPushResult
14797: oSetResult 21
14799: oPushResult
14800: oGetGlobal 16
14802: oPushResult
14803: oNodeSet
14804: oPop 3
14806: oGetLocal 1
14808: oPushResult
14809: oScopeDeclare
14810: oPop 1
14812: oGetAddrLocal 1
14814: oPushResult
14815: oSetResult 16
14817: oPushResult
14818: oId_True
14819: oPushResult
14820: oCall 14261
14822: oPop 2
14824: oAssign
14825: oGetLocal 1
14827: oPushResult
14828: oSetResult 21
14830: oPushResult
14831: oGetGlobal 7
14833: oPushResult
14834: oNodeSet
14835: oPop 3
14837: oGetLocal 1
14839: oPushResult
14840: oSetResult 22
14842: oPushResult
14843: oSetResult 1
14845: oPushResult
14846: oNodeSetInt
14847: oPop 3
14849: oGetLocal 1
14851: oPushResult
14852: oScopeDeclare
14853: oPop 1
14855: oGetAddrLocal 1
14857: oPushResult
14858: oSetResult 16
14860: oPushResult
14861: oId_False
14862: oPushResult
14863: oCall 14261
14865: oPop 2
14867: oAssign
14868: oGetLocal 1
14870: oPushResult
14871: oSetResult 21
14873: oPushResult
14874: oGetGlobal 7
14876: oPushResult
14877: oNodeSet
14878: oPop 3
14880: oGetLocal 1
14882: oPushResult
14883: oSetResult 22
14885: oPushResult
14886: oSetResult 0
14888: oPushResult
14889: oNodeSetInt
14890: oPop 3
14892: oGetLocal 1
14894: oPushResult
14895: oScopeDeclare
14896: oPop 1
14898: oGetAddrLocal 1
14900: oPushResult
14901: oSetResult 16
14903: oPushResult
14904: oId_Nil
14905: oPushResult
14906: oCall 14261
14908: oPop 2
14910: oAssign
14911: oGetLocal 1
14913: oPushResult
14914: oSetResult 21
14916: oPushResult
14917: oGetGlobal 14
14919: oPushResult
14920: oNodeSet
14921: oPop 3
14923: oGetLocal 1
14925: oPushResult
14926: oSetResult 22
14928: oPushResult
14929: oSetResult 0
14931: oPushResult
14932: oNodeSetInt
14933: oPop 3
14935: oGetLocal 1
14937: oPushResult
14938: oScopeDeclare
14939: oPop 1
14941: oGetAddrGlobal 17
14943: oPushResult
14944: oId_Ord
14945: oPushResult
14946: oCall 14305
14948: oPop 1
14950: oAssign
14951: oGetAddrGlobal 18
14953: oPushResult
14954: oId_Chr
14955: oPushResult
14956: oCall 14305
14958: oPop 1
14960: oAssign
14961: oGetAddrGlobal 19
14963: oPushResult
14964: oId_Pred
14965: oPushResult
14966: oCall 14305
14968: oPop 1
14970: oAssign
14971: oGetAddrGlobal 20
14973: oPushResult
14974: oId_Succ
14975: oPushResult
14976: oCall 14305
14978: oPop 1
14980: oAssign
14981: oGetAddrGlobal 21
14983: oPushResult
14984: oId_Sizeof
14985: oPushResult
14986: oCall 14305
14988: oPop 1
14990: oAssign
14991: oReturn
