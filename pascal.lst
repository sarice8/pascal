   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, kVar, LAST_ID )
 121:          oNodeSet( t, qType, FileType )
 133:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 139:          ','
 141:          pIdent
      
 143:          t = @newIdent( nVar, kVar, LAST_ID )
 159:          oNodeSet( t, qType, FileType )
 171:          oScopeDeclareAlloc( t )
      
 177:          ')'
 179:       | * :
 184:    ]
 184:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 186:    [
 186:       | pUses :  @UsesClause( program )
 195:       | * :
 200:    ]
 200:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 207:    oScopeBegin( 0, allocGlobal )
 216:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 221:    oScopeBegin( 0, allocDown )
 230:    initScope = oScopeCurrent
 235:    oNodeSet( program, qMainRoutineScope, initScope )
 247:    oScopeEnd
      
 248:    @BlockDecls( nGlobalVar )
      
      
 255:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 261:    boolean isMain = true
 267:    @BlockStmt( mainLabel, globalScope, isMain )
      
 280:    oScopeEnd   % main routine scope
      
 281:    '.'
 283:    oScopeEnd   % global scope
 284:    @EndUsedUnits( program )   % used units scopes
 292:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 292: UsesClause( Node user ):
 294:    {
 294:       pIdent
 296:       Node unit = @FindOrCompileUnit( LAST_ID )
 306:       [ equal_node( unit, Null )
 316:          | false :
 317:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % TO DO: put a declaration in the current scope, naming the unit and pointing to it.
                  %   This is to allow references to  <unit>.<identifier_in_unit>
                  %   Maybe something like nUsedUnit or nImportUnit
 329:          | * :
 334:       ]
 334:       [
 334:          | ',' :
 336:          | * :  >
 343:       ]
 343:    }   
 345:    ';'
 348:    ;
      
 348: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 350:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 363:    {
 363:       Node unit = oNodeIterValue( unitIt )
 373:       [ oNodeNull( unit )
 380:          | false :
 381:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 394:          | * :
 399:             >
 401:       ]
 401:       oNodeIterNext( unitIt )
 407:    }
 410:    ;
      
 410: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 412:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 425:    {
 425:       Node unit = oNodeIterValue( unitIt )
 435:       [ oNodeNull( unit )
 442:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 443:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 459:                | true :
 460:                | false :  #eInternalScopeMismatch
 464:             ]
 472:             oScopeEnd
 473:          | * :
 478:             >
 480:       ]
 480:       oNodeIterPrev( unitIt )
 486:    }
 489:    ;
      
      
 489: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 491:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 510:    [ equal_node( unit, Null )
 520:       | false :  >> unit
 524:       | * :
 529:    ]
      
         % If not, search for the source file on disk
 529:    boolean ok = oIncludeUnitFile( id )
 539:    [ ok
 542:       | false :  #eCantFindUnitFile  >> Null
 548:       | * :
 553:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 553:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 559:    oIncludeEnd
 560:    >> unit;
      
      
      
 564: Unit >> Node:
 566:    pUnit
 568:    pIdent
 570:    Node unit = oNodeNew( nUnit )
 580:    oNodeSetInt( unit, qIdent, LAST_ID )
 591:    Node unitImpl = oNodeNew( nUnitImpl )
 601:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 612:    oNodeSet( unit, qImpl, unitImpl )
 624:    ';'
      
         % mandatory sections
      
 626:    pInterface
 628:    [
 628:       | pUses :   @UsesClause( unit )
 637:       | * :
 642:    ]
 642:    @EnterUsedUnits( unit )
      
 649:    oScopeBegin( 0, allocGlobal )
 658:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 669:    oScopeBegin( 0, allocDown )
 678:    initScope = oScopeCurrent
 683:    oNodeSet( unit, qInitRoutineScope, initScope )
 695:    oScopeEnd
      
 696:    @UnitInterface( unit )
 703:    oScopeEnd  % interface scope
      
 704:    pImplementation
 706:    [
 706:       | pUses :   @UsesClause( unitImpl )
 715:       | * :
 720:    ]
 720:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 727:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
      
 740:    oScopeBegin( 0, allocGlobal )
 749:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 760:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 778:    @UnitImplementation( unit )
      
 785:    [
 785:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 797:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 812:    ]
 812:    [
 812:       | pFinalization :  @UnitFinalization( unit, true )
 824:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 839:    ]
 839:    pEnd  '.'
      
 843:    oScopeEnd  % impl scope
 844:    oScopeEnd  % interface scope
 845:    @EndUsedUnits( unitImpl )  % used units scopes
 852:    @EndUsedUnits( unit )
 859:    oNodeAddLast( workspace, qUnits, unit )
 871:    >> unit;
      
      
 875: UnitInterface( Node unit ):
 877:    {[
 877:       | pConst :     @ConstDecl
 881:       | pType :      @TypeDecl
 885:       | pVar :       @VarDecl( nGlobalVar )
      
 894:       | pProcedure :
 896:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 902:          [
 902:             | pExternal :
 904:                @ExternalDecl( decl )
 911:                ';'
 913:             | * :
 918:          ]
      
 918:       | pFunction :
 920:          Node decl = @FuncHeaderDecl
 926:          [
 926:             | pExternal :
 928:                @ExternalDecl( decl )
 935:                ';'
 937:             | * :
 942:          ]
      
 942:       | * :          >
 957:    ]}
 960:    ;
      
 960: UnitImplementation( Node unit ):
 962:    @BlockDecls( nGlobalVar )
 970:    ;
      
      
 970: UnitInitialization( Node unit, boolean hasStmts ):
 972:    Label label = oLabelNew
 977:    .tLabel  oEmitLabel( label )
 985:    oNodeSetLabel( unit, qInitLabel, label )
      
 997:    int patchLS
 997:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1006:    Node scope
1006:    Code initCode
      
1006:    scope = oNodeGet( unit, qPublicScope )
1019:    initCode = oNodeGetCode( scope, qInitCode )
1032:    oEmitCode( initCode )
1038:    oNodeSetCode( scope, qInitCode, codeNull )
      
1050:    scope = oNodeGet( unit, qPrivateScope )
1063:    initCode = oNodeGetCode( scope, qInitCode )
1076:    oEmitCode( initCode )
1082:    oNodeSetCode( scope, qInitCode, codeNull )
      
1094:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1107:    [ hasStmts
1110:       | true :     
1111:          @Statement
1113:          {[
1113:             | ';' :  @Statement
1117:             | * :    >
1124:          ]}
1126:       | * :
1131:    ]
      
1131:    .tReturn
      
1133:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1145:    oPatch( patchLS, localSpace )
1154:    oScopeEnd   % init routine scope, for temporaries
1156:    ;
      
      
1156: UnitFinalization( Node unit, boolean hasStmts ):
1158:    Label label = oLabelNew
1163:    .tLabel  oEmitLabel( label )
1171:    oNodeSetLabel( unit, qFinalLabel, label )
      
1183:    int patchLS
1183:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1192:    oScopeBegin( 0, allocDown )
      
1201:    [ hasStmts
1204:       | true :     
1205:          @Statement
1207:          {[
1207:             | ';' :  @Statement
1211:             | * :    >
1218:          ]}
1220:       | * :
1225:    ]
      
1225:    .tReturn
      
1227:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1239:    oPatch( patchLS, localSpace )
1248:    oScopeEnd   % final routine scope, for temporaries
1250:    ;
      
      
1250: Block( node_type varNodeType, Label labelForBody ):
1252:    @BlockDecls( varNodeType )
1259:    @BlockStmt( labelForBody, oScopeCurrent, false )
1272:    ;
      
      
1272: BlockDecls( node_type varNodeType ):
1274:    {[
1274:       | pConst :     @ConstDecl
1278:       | pType :      @TypeDecl
1282:       | pVar :       @VarDecl( varNodeType )
1291:       | pProcedure : @ProcDecl
1295:       | pFunction :  @FuncDecl
1299:       | * :          >
1314:    ]}
1316:    @CheckForUndefinedMethods
1319:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1319: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1322:    ;
      
      
1322: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1324:    NodeIter it = oNodeGetIter( workspace, qUnits )
1337:    {
1337:       Node unit = oNodeIterValue( it )
1347:       [ oNodeNull( unit )
1354:          | true :  >
1357:          | false :
1359:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1367:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1382:             .tFreeActuals  oEmitInt( 0 )
1390:             oNodeIterNext( it )
1396:       ]
1404:    };
      
      
1407: FinalizeUnits:
1409:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1422:    {
1422:       Node unit = oNodeIterValue( it )
1432:       [ oNodeNull( unit )
1439:          | true :  >
1442:          | false :
1444:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1452:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1467:             .tFreeActuals  oEmitInt( 0 )
1475:             oNodeIterPrev( it )
1481:       ]
1489:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1492: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1494:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1502:    int patchLS
1502:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1511:    [ isMain
1514:       | true :  @InitializeUnits
1517:       | * :
1522:    ]
      
         % insert any code for initialization of this scope's variables
1522:    Code initCode = oNodeGetCode( varScope, qInitCode )
1535:    oEmitCode( initCode )
1541:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1553:    @Statement
      
1555:    [ isMain
1558:       | true :  @FinalizeUnits
1561:       | * :
1566:    ]
      
1566:    .tReturn
      
1568:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1580:    oPatch( patchLS, localSpace )
1590:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1590: MethodModifiers( Node decl ):
1592:    {[
1592:       | pCdecl :
1594:          oNodeSetBoolean( decl, qCdecl, true )
1606:          ';'
      
1608:       | * : >
1615:    ]}
1618:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1618: GetOrCreateInitCode >> Code:
1620:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1632:    [ equal_code( initCode, codeNull )
1642:       | true :
1643:          initCode = oCodeNew
1648:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1659:       | * :
1664:    ]
1664:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1668: ExternalDecl( Node decl ):
1670:    [ equal_zero( @DeclLevel( decl ) )
1682:       | false :  #eExternalMethodCannotBeNested
1685:       | * :
1690:    ]
1690:    oNodeSetBoolean( decl, qExternal, true )
1702:    [
1702:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1704:          [
1704:             | pName :
1706:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1708:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1719:             | * :
1724:          ]
1724:       | * :
1729:    ]
1730:    ;
      
      
1730: ProcHeaderDecl >> Node:
1732:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1734:    boolean redeclaring = false
1740:    Node decl = oScopeFindInCurrentScope
      
1745:    [ oNodeNull( decl )
1752:       | true :
               % first declaration
1753:          decl = @newIdent( nProc, kProc, LAST_ID )
1769:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1780:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1782:          redeclaring = true
1788:          [ oNodeGetBoolean( decl, qBodyDefined )
1798:             | true : #eAlreadyDefined
1801:             | * :
1806:          ]
1806:          [ oNodeGetBoolean( decl, qExternal )
1816:             | true : #eAlreadyDefined
1819:             | * :
1824:          ]
1824:          [ oNodeType( decl )
1831:             | nProc :
1832:             | * : #eAlreadyDefined   % wrong kind
1839:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1839:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1858:          oNodeSet( decl, qParams, Null )
1870:    ]
      
1878:    int level = @ScopeLevel
1884:    boolean nested = greater( level, 0 )
1897:    inc( level )
1903:    oScopeBegin( level, allocUp )
1912:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1917:    [ nested
1920:       | true :
1921:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1936:       | * :
1941:    ]
      
1941:    @FormalArgDecl
1943:    oNodeSet( decl, qParams, paramScope )
1955:    oScopeEnd
1956:    ';'
      
1958:    [ redeclaring
1961:       | false : oScopeDeclare( decl )
1968:       | true :  % TO DO: check that qParams is consistent with qOldParams
1970:    ]
      
1978:    @MethodModifiers( decl )
1985:    >> decl;
      
      
1989: ProcDecl:
1991:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1997:    [
1997:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1999:       | pExternal : @ExternalDecl( decl )
      
2008:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2015:          Node paramScope = oNodeGet( decl, qParams )
2028:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2034:          int level = oNodeGetInt( paramScope, qLevel )
2047:          oScopeBegin( level, allocDown )
2056:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2067:          Label label = oNodeGetLabel( decl, qValue )
2080:          @Block( nLocalVar, label )
2090:          oNodeSetBoolean( decl, qBodyDefined, true )
2102:          oScopeEnd
      
2103:          oScopeEnd  % paramScope
2104:    ]
2104:    ';';
      
      
      
2107: FuncHeaderDecl >> Node:
2109:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2111:    boolean redeclaring = false
2117:    Node decl = oScopeFindInCurrentScope
      
2122:    [ oNodeNull( decl )
2129:       | true :
               % first declaration
2130:          decl = @newIdent( nFunc, kFunc, LAST_ID )
2146:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2157:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2159:          redeclaring = true
2165:          [ oNodeGetBoolean( decl, qBodyDefined )
2175:             | true : #eAlreadyDefined
2178:             | * :
2183:          ]
2183:          [ oNodeType( decl )
2190:             | nFunc :
2191:             | * : #eAlreadyDefined   % wrong kind
2198:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2198:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2217:          oNodeSet( decl, qParams, Null )
2229:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2248:          oNodeSet( decl, qType, Null )
2260:    ]
      
2268:    int level = @ScopeLevel
2274:    boolean nested = greater( level, 0 )
2287:    inc( level )
2293:    oScopeBegin( level, allocUp )
2302:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2307:    [ nested
2310:       | true :
2311:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2326:       | * :
2331:    ]
      
2331:    @FormalArgDecl
2333:    oNodeSet( decl, qParams, paramScope )
      
2345:    ':'
      
2347:    Node theType
2347:    @TypeRef( theType )
2354:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2366:    Node ptrType = @PointerTypeTo( theType )
2377:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2393:    oScopeEnd
2394:    ';'
      
2396:    [ redeclaring
2399:       | false : oScopeDeclare( decl )
2406:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2408:    ]
      
2416:    @MethodModifiers( decl )
      
2423:    >> decl;
      
      
2427: FuncDecl:
2429:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2435:    [
2435:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2437:       | pExternal : @ExternalDecl( decl )
      
2446:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2453:          Node paramScope = oNodeGet( decl, qParams )
2466:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2472:          int level = oNodeGetInt( paramScope, qLevel )
2485:          oScopeBegin( level, allocDown )
2494:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2505:          Label label = oNodeGetLabel( decl, qValue )
2518:          @Block( nLocalVar, label )
2528:          oNodeSetBoolean( decl, qBodyDefined, true )
2540:          oScopeEnd
      
2541:          oScopeEnd  % paramScope
2542:    ]
2542:    ';';
      
      
2545: FormalArgDecl:
2547:    [
2547:       | '(' :
2549:          {
2549:             NodeVec decls = oNodeVecNew
2554:             Node decl
2554:             boolean isInOut = false
      
2560:             [
2560:                | pVar : isInOut = true
2568:                | * :
2573:             ]
      
2573:             {  pIdent
      
2575:                decl = @newIdent( nParam, kVar, LAST_ID )
2591:                oNodeSetBoolean( decl, qInOut, isInOut )
2603:                oNodeVecAppend( decls, decl )
      
2612:                [
2612:                   | ':' : >
2616:                   | ',' :
2618:                ]
2626:             }
      
2628:             Node theType
2628:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2635:             Node allocType
2635:             [ isInOut
2638:                | true :   allocType = @PointerTypeTo( theType )
2650:                | * :      allocType = theType
2661:             ]
      
2661:             int i = 0
2667:             {[ equal( i, oNodeVecSize( decls ) )
2681:                | false :
2682:                   decl = oNodeVecElement( decls, i )
      
2695:                   oNodeSet( decl, qType, theType )
2707:                   oScopeDeclare( decl )
2713:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2729:                   inc( i )
2735:                | * :
2740:                   >
2742:             ]}
      
2744:             oNodeVecDelete( decls )
      
2750:             [
2750:                | ')' : >
2754:                | ';' :
2756:             ]
2764:          }
2766:       | * :
2771:    ];
      
2772: ConstDecl:
2774:    {[
2774:       | pIdent :
2776:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2792:          '='
      
2794:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2796:          int val = oValueTop
2801:          oValuePop
2802:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2814:          oNodeSet( decl, qType, IntegerType )
      
2826:          oScopeDeclare( decl )
2832:          ';'
2834:       | * :
2839:          >
2841:    ]};
      
2844: TypeDecl:
2846:    {[
2846:       | pIdent :
2848:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2864:          '='
2866:          Node theType
2866:          @TypeRef( theType )
2873:          oNodeSet( decl, qType, theType )
2885:          oScopeDeclare( decl )
2891:          ';'
2893:       | * :
2898:          >
2900:    ]};
      
2903: VarDecl( node_type varNodeType ):
2905:    {[
2905:       | pIdent :
2907:          NodeVec decls = oNodeVecNew
2912:          Node decl
2912:          {
2912:             decl = @newIdent( varNodeType, kVar, LAST_ID )
2928:             oNodeVecAppend( decls, decl )
2937:             [
2937:                | ',' :
2939:                   pIdent
2941:                | * :
2946:                   >
2948:             ]
2948:          }
2950:          ':'
2952:          Node theType
2952:          @TypeRef( theType )
      
2959:          int i = 0
2965:          {[ equal( i, oNodeVecSize( decls ) )
2979:             | false :
2980:                decl = oNodeVecElement( decls, i )
2993:                oNodeSet( decl, qType, theType )
3005:                oScopeDeclareAlloc( decl )
3011:                inc( i )
3017:             | * :
3022:               >
3024:          ]}
      
               % optional initialization
3026:          [
3026:             | '=' :
3028:                [ oNodeVecSize( decls )
3035:                   | 1 :
3036:                   | * :  #eOnlyOneVarCanBeInitialized
3043:                ]
      
                     % we need an initCode stream for this scope
3043:                Code initCode = @GetOrCreateInitCode
3049:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3055:                boolean changedScope = false
3061:                [ equal_zero( @ScopeLevel )
3068:                   | true : oScopeEnter( initScope )
3075:                            changedScope = true
3081:                   | * :
3086:                ]
                     % generate assignment in initCode stream
3086:                @LValueVar( decl )
3093:                @Expr
3095:                @MatchTypes
3097:                @Assign
3099:                [ changedScope
3102:                   | true : oScopeEnd
3104:                   | * :
3109:                ]
3109:                oCodePop
                   
3110:             | * :
3115:          ]
      
3115:          oNodeVecDelete( decls )
3121:          ';'
3123:       | * :
3128:          >
3130:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3133: TypeRef( out Node resultType ):
3135:    [
3135:       | pIdent :           % previously named type (including intrinsics)
3137:          Node decl = oScopeFindRequire
3142:          [ oNodeType( decl )
3149:            | nTypeDecl :
3150:                resultType = oNodeGet( decl, qType )
3163:            | * :
3168:                #eNotType
3170:                resultType = IntegerType
3176:          ]
         
3176:       | pArray :
3178:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3180:          NodeVec dimensions = oNodeVecNew
      
3185:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3185:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3195:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3207:             @ConstExpr
3209:             oNodeSetInt( subrange, qLow, oValueTop )
3220:             oValuePop
3221:             '..'
3223:             @ConstExpr
3225:             oNodeSetInt( subrange, qHigh, oValueTop )
3236:             oValuePop
3237:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3249:             oTypeAdd( subrange )
      
3255:             Node a = oNodeNew( nArrayType )
3265:             oNodeSet( a, qIndexType, subrange )
      
3277:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3286:             [
3286:                | ']' : >
3290:                | ',' :
3292:             ]
3300:          }
      
3302:          pOf
3304:          Node baseType
3304:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3311:          int dim = oNodeVecSize( dimensions )
      
3321:          {
3321:              dec(dim)
      
3327:              Node a = oNodeVecElement( dimensions, dim )
      
3340:              oNodeSet( a, qBaseType, baseType )
3352:              Node subrange = oNodeGet( a, qIndexType )
3365:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3392:              inc( width )
3398:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3424:              oTypeAdd( a )
3430:              baseType = a
      
3436:              [ equal_zero(dim)
3443:                  | true:  >
3446:                  | *:
3451:              ]
3451:          }
      
3453:          resultType = oNodeVecElement( dimensions, 0 )
3466:          oNodeVecDelete( dimensions )
      
3472:       | '^' :
3474:          Node theType
3474:          @TypeRef( theType )
3481:          resultType = @PointerTypeTo( theType )
      
3492:       | pRecord :
3494:          resultType = oNodeNew( nRecordType )
3504:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3513:          @VarDecl( nRecordField )
      
3520:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3532:          [ equal_zero( size )
3539:             | true : #eRecordEmpty
3542:             | * :
3547:          ]
      
3547:          pEnd
      
3549:          oNodeSet( resultType, qScope, oScopeCurrent )
3560:          oNodeSetInt( resultType, qSize, size )
3572:          oScopeEnd
3573:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3579:       | pSet :
3581:          pOf
3583:          Node theType
3583:          @TypeRef( theType )
3590:       | * :       % this works for cases except where expr starts with an id
3603:          @ConstExpr '..' @ConstExpr
3609:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3610: ConstExpr:
3612:    [
3612:       | pIntLit :
3614:          oValuePush( TOKEN_VALUE )
3619:       | pIdent :
3621:          Node decl = oScopeFindRequire
3626:          [ oNodeType( decl )
3633:             | nConst :
3634:                oValuePush( oNodeGetInt( decl, qValue ) )
3647:             | * :
3652:                #eNotConst
3654:                oValuePush( 0 )
3660:          ]
3660:       | pMinus :
3662:          @ConstExpr
3664:          oValueNegate
3665:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3676: Expr:
3678:    Label falseLabel = labelNull
      
3684:    @ExprAllowCF( falseLabel )
3691:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3699: BooleanExprControlFlow( out Label falseLabel ):
3701:    @ExprAllowCF( falseLabel )
3708:    [ oTypeSNodeType
3710:       | nBooleanCFType :
3711:       | nBooleanType :
               % convert value to control flow
3713:          falseLabel = oLabelNew
3718:          .tJumpFalse  oEmitLabel( falseLabel )
3726:       | * :
3733:          #eNotBoolean
3735:    ]
3735:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3737: CFToVal( inout Label falseLabel ):
3739:    [ oTypeSNodeType
3741:       | nBooleanCFType :
3742:          Label doneLabel = oLabelNew
3747:          .tPushConstI  oEmitInt( 1 )
3755:          .tJump  oEmitLabel( doneLabel )
3763:          .tLabel  oEmitLabel( falseLabel )
3771:          .tPushConstI  oEmitInt( 0 )
3779:          .tLabel  oEmitLabel( doneLabel )
3787:          oTypeSPop
3788:          oTypeSPush( BooleanType )
3794:          falseLabel = labelNull
3800:       | * :
3805:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3806: ValToCF( out Label falseLabel ):
3808:    [ oTypeSNodeType
3810:       | nBooleanType :
3811:          falseLabel = oLabelNew
3816:          .tJumpFalse  oEmitLabel( falseLabel )
3824:          oTypeSPop
3825:          oTypeSPush( BooleanCFType )
3831:       | * :
3836:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3837: ExprAllowCF( out Label falseLabel ):
3839:    @BoolExprAllowCF( falseLabel )
3846:    {[
3846:       | '=' :
3848:          @CFToVal( falseLabel )
3855:          @BoolExprAllowCF( falseLabel )
3862:          @CFToVal( falseLabel )
3869:          @MatchTypes
3871:          [ oTypeSNodeType
3873:             | nIntegerType, nBooleanType :  .tEqualI
3876:             | nPointerType :                .tEqualP
3880:             | nCharType, nStringType :      #eNotImplemented
3884:             | * :                           #eNotAllowed
3899:          ]
3899:          oTypeSPop
3900:          oTypeSPush( BooleanType )
      
3906:       | '<>' :
3908:          @CFToVal( falseLabel )
3915:          @BoolExprAllowCF( falseLabel )
3922:          @CFToVal( falseLabel )
3929:          @MatchTypes
3931:          [ oTypeSNodeType
3933:             | nIntegerType, nBooleanType :  .tNotEqualI
3936:             | nPointerType :                .tNotEqualP
3940:             | nCharType, nStringType :      #eNotImplemented
3944:             | * :                           #eNotAllowed
3959:          ]
3959:          oTypeSPop
3960:          oTypeSPush( BooleanType )
      
3966:       | '<' :
3968:          @CFToVal( falseLabel )
3975:          @BoolExprAllowCF( falseLabel )
3982:          @CFToVal( falseLabel )
3989:          @MatchTypes
3991:          [ oTypeSNodeType
3993:             | nIntegerType, nBooleanType :  .tLessI
3996:             | nCharType, nStringType :      #eNotImplemented
4000:             | * :                           #eNotAllowed
4013:          ]
4013:          oTypeSPop
4014:          oTypeSPush( BooleanType )
      
4020:       | '>' :
4022:          @CFToVal( falseLabel )
4029:          @BoolExprAllowCF( falseLabel )
4036:          @CFToVal( falseLabel )
4043:          @MatchTypes
4045:          [ oTypeSNodeType
4047:             | nIntegerType, nBooleanType :  .tGreaterI
4050:             | nCharType, nStringType :      #eNotImplemented
4054:             | * :                           #eNotAllowed
4067:          ]
4067:          oTypeSPop
4068:          oTypeSPush( BooleanType )
      
4074:       | '<=' :
4076:          @CFToVal( falseLabel )
4083:          @BoolExprAllowCF( falseLabel )
4090:          @CFToVal( falseLabel )
4097:          @MatchTypes
4099:          [ oTypeSNodeType
4101:             | nIntegerType, nBooleanType :  .tLessEqualI
4104:             | nCharType, nStringType :      #eNotImplemented
4108:             | * :                           #eNotAllowed
4121:          ]
4121:          oTypeSPop
4122:          oTypeSPush( BooleanType )
      
4128:       | '>=' :
4130:          @CFToVal( falseLabel )
4137:          @BoolExprAllowCF( falseLabel )
4144:          @CFToVal( falseLabel )
4151:          @MatchTypes
4153:          [ oTypeSNodeType
4155:             | nIntegerType, nBooleanType :  .tGreaterEqualI
4158:             | nCharType, nStringType :      #eNotImplemented
4162:             | * :                           #eNotAllowed
4175:          ]
4175:          oTypeSPop
4176:          oTypeSPush( BooleanType )
      
4182:       | * :
4197:          >
4199:    ]};
      
      
4202: BoolExprAllowCF( out Label falseLabel ):
4204:    Label trueLabel = labelNull
      
4210:    @BoolTermAllowCF( falseLabel )
4217:    {[
4217:       | pOr :
4219:          [ oTypeSNodeType
4221:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4222:                [ equal_label( trueLabel, labelNull )
4232:                   | true :  trueLabel = oLabelNew
4238:                   | * :
4243:                ]
4243:                .tJump  oEmitLabel( trueLabel )
4251:             | nBooleanType :
4253:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4260:                [ equal_label( trueLabel, labelNull )
4270:                   | true :  trueLabel = oLabelNew
4276:                   | * :
4281:                ]
4281:                .tJump  oEmitLabel( trueLabel )
4289:             | * : #eNotBoolean
4298:          ]
4298:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4299:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4307:          falseLabel = labelNull
4313:          @BoolTermAllowCF( falseLabel )
      
4320:          [ oTypeSNodeType
4322:             | nBooleanCFType :
4323:             | nBooleanType :
4325:                @ValToCF( falseLabel )
4332:             | * : #eNotBoolean
4341:          ]
      
4341:          oTypeSPop
4342:          oTypeSPush( BooleanCFType )
      
4348:       | * :
4353:          >
4355:    ]}
      
         % any short-circuit trues jump here to the end
4357:    [ equal_label( trueLabel, labelNull )
4367:       | false :
4368:          .tLabel  oEmitLabel( trueLabel )
4376:       | * :
4381:    ]
4382:    ;
      
      
4382: BoolTermAllowCF( out Label falseLabel ):
4384:    Label overallFalseLabel = labelNull
      
4390:    @BoolFactorAllowCF( falseLabel )
4397:    {[
4397:       | pAnd :
4399:          [ oTypeSNodeType
4401:             | nBooleanCFType :
4402:             | nBooleanType :
4404:                @ValToCF( falseLabel )
4411:             | * :
4418:                #eNotBoolean
4420:          ]
4420:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
4421:          [ equal_label( overallFalseLabel, labelNull )
4431:             | true :
4432:                overallFalseLabel = oLabelNew
4437:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
4451:                falseLabel = overallFalseLabel
4457:             | * :
4462:          ]
      
4462:          Label factorFalseLabel = labelNull
4468:          @BoolFactorAllowCF( factorFalseLabel )
      
4475:          [ oTypeSNodeType
4477:             | nBooleanCFType :
4478:             | nBooleanType :
4480:                @ValToCF( factorFalseLabel )
4487:             | * : #eNotBoolean
4496:          ]
4496:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
4510:       | * :
4515:          >
4517:    ]};
      
4520: BoolFactorAllowCF( out Label falseLabel ):
4522:    [
4522:       | pNot :
4524:          Label factorFalseLabel = labelNull
      
4530:          @BoolFactorAllowCF( factorFalseLabel )
4537:          [ oTypeSNodeType
4539:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4540:                falseLabel = oLabelNew
4545:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4553:                .tLabel  oEmitLabel( factorFalseLabel )
      
4561:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4563:                .tNot
      
4565:             | * : #eNotBoolean
4574:          ]
      
4574:       | * :
4579:          @ArithExprAllowCF( falseLabel )
4586:    ];
      
4587: ArithExprAllowCF( out Label falseLabel ):
4589:    @TermAllowCF( falseLabel )
4596:    {[
4596:       | pPlus :
4598:          @RequireIntPop
4600:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4607:          @RequireInt
4609:          .tAddI
4611:       | pMinus :
4613:          @RequireIntPop
4615:          @TermAllowCF( falseLabel )
4622:          @RequireInt
4624:          .tSubI
4626:       | * :
4633:          >
4635:    ]};
      
4638: TermAllowCF( out Label falseLabel ):
4640:    @FactorAllowCF( falseLabel )
4647:    {[
4647:       | pTimes :
4649:          @RequireIntPop
4651:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4658:          @RequireInt
4660:          .tMultI
4662:       | pDivide :
4664:          @RequireIntPop
4666:          @FactorAllowCF( falseLabel )
4673:          @RequireInt
4675:          .tDivI
4677:       | * :
4684:          >
4686:    ]};
      
4689: FactorAllowCF( out Label falseLabel ):
4691:    [
4691:       | pPlus :
4693:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4700:          @RequireInt
4702:       | pMinus :
4704:          @PrimaryAllowCF( falseLabel )
4711:          @RequireInt
4713:          .tNegI
4715:       | * :
4722:          @PrimaryAllowCF( falseLabel )
4729:    ];
      
4730: PrimaryAllowCF( out Label falseLabel ):
4732:    [
4732:       | pIntLit :
4734:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4741:          oTypeSPush( IntegerType )
      
4747:       | '(' :
4749:          @ExprAllowCF( falseLabel )
4756:          ')'
      
4758:       | pStrLit :
4760:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4769:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4777:          oTypeSPush( StringType )
      
4783:       | pIdent :
4785:          Node decl = oScopeFindRequire
4790:          Node theType
      
4790:          [ oNodeType( decl )
4797:             | nFunc :
      
4798:                @Call( decl )
      
4805:             | nConst :
4807:                theType = oNodeGet( decl, qType )
4820:                oTypeSPush( theType )
4826:                [ oTypeSNodeType
4828:                   | nIntegerType, nBooleanType :
4829:                      .tPushConstI @EmitValue( decl )
4838:                   | * :
4845:                      #eNotImplemented
4847:                ]
      
4847:             | nGlobalVar, nLocalVar, nParam :
4849:                @VarExpr( decl )
      
4856:             | * :
4869:                #eNotValue
4871:                oTypeSPush( IntegerType )
4877:          ]
      
4877:       | '@' :        % @var -- pointer to var
4879:          pIdent
      
4881:          Node decl = oScopeFindRequire
4886:          Node theType
      
4886:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
4893:          theType = oTypeSTop
4898:          oTypeSPop
4899:          Node ptrType = @PointerTypeTo( theType )
4910:          oTypeSPush( ptrType )
      
4916:       | * :
4929:          #eNotValue
4931:          oTypeSPush( IntegerType )
4937:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
4938: VarExpr( Node decl ):
4940:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
4953:    int uplevels = @DeclUpLevels( decl )
      
4964:    oTypeSPush( theType )
4970:    [ oTypeSNodeType
4972:       | nIntegerType :
4973:          [ oNodeType( decl )
4980:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
4990:             | nLocalVar :
4992:                [ equal_zero( uplevels )
4999:                   | true :  .tPushLocalI  @EmitValue( decl )
5009:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5029:                ]
5029:             | nParam :
5031:                [ oNodeGetBoolean( decl, qInOut )
5041:                   | true :    % VAR param points to the var.  Auto dereference.
5042:                      [ equal_zero( uplevels )
5049:                         | true :  .tPushParamP  @EmitValue( decl )
5059:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5079:                      ]
5079:                      .tFetchI
5081:                   | * :
5086:                      [ equal_zero( uplevels )
5093:                         | true :  .tPushParamI  @EmitValue( decl )
5103:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5123:                      ]
5123:                ]
5123:          ]
      
5133:       | nBooleanType :
5135:          [ oNodeType( decl )
5142:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5152:             | nLocalVar :
5154:                [ equal_zero( uplevels )
5161:                   | true :  .tPushLocalB  @EmitValue( decl )
5171:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5191:                ]
5191:             | nParam :
5193:                [ oNodeGetBoolean( decl, qInOut )
5203:                   | true :    % VAR param points to the var.  Auto dereference.
5204:                      [ equal_zero( uplevels )
5211:                         | true :  .tPushParamP  @EmitValue( decl )
5221:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5241:                      ]
5241:                      .tFetchB
5243:                   | * :
5248:                      [ equal_zero( uplevels )
5255:                         | true :  .tPushParamB  @EmitValue( decl )
5265:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5285:                      ]
5285:                ]
5285:          ]
      
5295:       | nCharType, nStringType, nFileType :
5297:          #eNotImplemented
      
5299:       | nPointerType :
5301:          [ oNodeType( decl )
5308:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5318:             | nLocalVar :
5320:                [ equal_zero( uplevels )
5327:                   | true :  .tPushLocalP  @EmitValue( decl )
5337:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
5357:                ]
5357:             | nParam :
5359:                [ oNodeGetBoolean( decl, qInOut )
5369:                   | true :    % VAR param points to the var.  Auto dereference.
5370:                      [ equal_zero( uplevels )
5377:                         | true :  .tPushParamP  @EmitValue( decl )
5387:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5407:                      ]
5407:                      .tFetchP
5409:                   | * :
5414:                      [ equal_zero( uplevels )
5421:                         | true :  .tPushParamP  @EmitValue( decl )
5431:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5451:                      ]
5451:                ]
5451:          ]
5461:          [
5461:             | '^' :             % dereferenced
5463:                oTypeSPop
5464:                oTypeSPush( oNodeGet( theType, qBaseType ) )
5477:                @LValueIndexes
5479:                @FetchVar
5481:             | * :               % just ptr value alone
5486:          ]
      
5486:       | * :
               % compound type
               % first, push addr of start of var
5501:          [ oNodeType( decl )
5508:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5518:             | nLocalVar :
5520:                [ equal_zero( uplevels )
5527:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5537:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5557:                ]
5557:             | nParam :
5559:                [ oNodeGetBoolean( decl, qInOut )
5569:                   | true :    % VAR param points to the var.  Auto dereference.
5570:                      [ equal_zero( uplevels )
5577:                         | true :  .tPushParamP  @EmitValue( decl )
5587:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5607:                      ]
5607:                   | * :
5612:                      [ equal_zero( uplevels )
5619:                         | true :  .tPushAddrParam  @EmitValue( decl )
5629:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5649:                      ]
5649:                ]
5649:          ]
               % modify addr for subscripts, field references, etc
5659:          @LValueIndexes
               % get final value
5661:          @FetchVar
5663:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5664: FetchVar:
5666:    [ oTypeSNodeType
5668:       | nIntegerType :   .tFetchI
5671:       | nBooleanType :   .tFetchB
5675:       | nCharType, nStringType, nFileType : #eNotImplemented
5679:       | nPointerType :   .tFetchP
5683:       | * :              % compound type; leave as addr
5698:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5699: LValueIndexes:
5701:    {[
5701:       | '[' :       @ArraySubscripts
5705:       | '.' :       @RecordFieldRef
5709:       | '^' :       @PointerDeref
5713:       | * :         >
5724:    ]};
      
5727: ArraySubscripts:
5729:    [ oTypeSNodeType
5731:       | nArrayType :
5732:       | * :       #eNotArray
5739:    ]
5739:    {
5739:       [ oTypeSNodeType
5741:          | nArrayType :
5742:          | * :    #eTooManySubscripts
5749:       ]
      
            % low subscript of this dimension
5749:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5766:       Node baseType
5766:       baseType = oNodeGet( oTypeSTop, qBaseType )
5778:       oTypeSPop
5779:       oTypeSPush( baseType )
      
5785:       @Expr
5787:       @RequireIntPop
            % adjust for low subscript
5789:       [ equal_zero( low )
5796:          | false :
5797:             .tPushConstI oEmitInt( low ) .tSubI
5807:          | * :
5812:       ]
      
            % multiply by element size
5812:       int size = oNodeGetInt( baseType, qSize )
5825:       [ equal( size, 1 )
5835:          | false :
5836:             .tPushConstI oEmitInt( size ) .tMultI
5846:          | * :
5851:       ]
      
            % update start address
5851:       .tAddPI
5853:       [
5853:          | ']' :  >
5857:          | ',' :
5859:       ]
5867:    };
      
      
5870: RecordFieldRef:
5872:    [ oTypeSNodeType
5874:       | nRecordType :
5875:       | * :    #eNotRecord
5882:    ]
5882:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
5894:    pIdent
5896:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
5901:    [ oNodeType( field )
5908:       | nRecordField :
5909:       | * :   #eNotRecordField
5916:    ]
5916:    oScopeEnd
5917:    int offset = oNodeGetInt( field, qValue )
5930:    [ equal_zero( offset )
5937:       | false :
5938:          .tPushConstI oEmitInt( offset ) .tAddPI
5948:       | * :
5953:    ]
      
         % replace the type on the type stack, with the field type
5953:    oTypeSPop
5954:    oTypeSPush( oNodeGet( field, qType ) )
5968:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
5968: PointerDeref:
5970:    [ oTypeSNodeType
5972:       | nPointerType :
5973:       | * :       #eNotPointer
5980:    ]
5980:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
5982:    Node theType = oTypeSTop
5987:    oTypeSPop
5988:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6002:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6002: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
6004:    @MatchTypes
6007:    ;
      
      
      % Called on first use of an extern method
      %
6007: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
6009:    int strAddr
6009:    String externalName = oNodeGetString( method, qExternalName )
6022:    [ equal_string( externalName, stringNull )
6032:       | true :
6033:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
6054:       | false :
6056:          strAddr = oStringAllocLit( externalName )
6066:    ]
6074:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6090:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6090: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6092:    [ oNodeGetBoolean( method, qExternal )
6102:       | true :
6103:          [ oNodeGetBoolean( method, qCalled )
6113:             | false :
                     % define the extern label on first use
6114:                @DefineExternLabel( method )
6121:             | * :
6126:          ]
6126:      | * :
6131:    ]
6131:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6143:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6156:    Node resultType
6156:    int tempOffset
      
6156:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6173:    [ isFunc
6176:       | true :
6177:          resultType = oNodeGet( method, qType )
6190:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6200:       | * :
6205:    ]
         
      
6205:    Node paramScope = oNodeGet( method, qParams )
6218:    int actualsSize = oNodeGetInt( paramScope, qSize )
6231:    [ cdecl
6234:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6243:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6253:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6261:    [ greater( @DeclLevel( method ), 0 )
6276:       | true :
6277:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6285:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6304:          .tAssignP
6306:       | * :
6311:    ]
      
      
6311:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6324:    Node param = oNodeIterValue( paramIter )
6334:    [
6334:       | '(' :
            
6336:          {
6336:             [ oNodeNull( param )
6343:                | true : >
6346:                | * :
6351:             ]
      
6351:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
6364:             .tPushAddrActual oEmitInt( offset )
6372:             oTypeSPush( oNodeGet( param, qType ) )
      
6385:             [ oNodeGetBoolean( param, qInOut )
6395:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
6396:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
6398:                           @MatchTypes
      
6400:                           .tAssignP
      
6402:                | false :  @Expr
6406:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
6408:                           [ oTypeSNodeType
6410:                              | nIntegerType :            .tAssignI
6413:                              | nBooleanType :            .tAssignB
6417:                              | nCharType, nStringType, nFileType :   #eNotImplemented
6421:                              | nPointerType :            .tAssignP
6425:                              | * :
                                       % compound types: copy value into actuals space
6440:                                  int size = oNodeGetInt( oTypeSTop, qSize )
6452:                                  .tCopy  oEmitInt( size )    % multi-word copy
6460:                           ]
6460:             ]
6468:             oTypeSPop
      
6469:             oNodeIterNext( paramIter )
6475:             param = oNodeIterValue( paramIter )
6485:             [ oNodeNull( param )
6492:                | true :  >
6495:                | false :
6497:             ]
      
6505:             ','
6507:          }
      
6509:          ')'
      
6511:       | * :
6516:    ]
      
6516:    [ oNodeNull( param )
6523:       | false :    #eMissingParameter
6526:       | * :
6531:    ]
      
6531:    [ isFunc
6534:       | true :
               % Pass result temp as an additional VAR parameter.
6535:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6550:          .tPushAddrLocal  oEmitInt( tempOffset )
6558:          .tAssignP
6560:       | * :
6565:    ]
      
6565:    [ cdecl
6568:       | true :
6569:          .tCallCdecl  @EmitValue( method )
6578:       | false :
6580:          .tCall   @EmitValue( method )
6589:    ]
      
6597:    [ isFunc
6600:       | true :
               % push return value from temp
6601:          oTypeSPush( resultType )
      
6607:          [ oTypeSNodeType
6609:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6618:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6628:             | nCharType, nStringType, nFileType : #eNotImplemented
6632:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6642:             | * :              % compound type: push address
6657:                                .tPushAddrLocal  oEmitInt( tempOffset )
6665:          ]
6665:       | * :
6670:    ]
         
6670:    .tFreeActuals  oEmitInt( actualsSize )
6679:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6679: Statement:
6681:    [
6681:       | pWriteln :     @WritelnStmt
6685:       | pWrite :       @WriteStmt
6689:       | pReadln :      @ReadlnStmt
6693:       | pRead :        @ReadStmt
6697:       | pIf :          @IfStmt
6701:       | pWhile :       @WhileStmt
6705:       | pFor :         @ForStmt
6709:       | pRepeat :      @RepeatStmt
6713:       | pBreak :       @BreakStmt
6717:       | pContinue :    @ContinueStmt
6721:       | pBegin :       @BeginStmt
6725:       | pIdent :       @AssignOrCallStmt
6729:       | * :            % null statement : don't accept any tokens
6756:    ];
      
      
6757: AssignOrCallStmt:
6759:    Node decl = oScopeFindRequire
6764:    [ oNodeType( decl )
6771:       | nProc :                           @Call( decl )
6779:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6788:       | nFunc :                           @AssignResultStmt( decl )
6797:       | * :                               #eBadStatement
6812:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6813: AssignStmt( Node decl ):
      
6815:    @LValueVar( decl )
6822:    ':=' 
6824:    @Expr
6826:    @MatchTypes
6828:    @Assign
6831:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6831: Assign:
6833:    [ oTypeSNodeType
6835:       | nIntegerType :            .tAssignI
6838:       | nBooleanType :            .tAssignB
6842:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6846:       | nPointerType :            .tAssignP
6850:       | * :
6865:           int size = oNodeGetInt( oTypeSTop, qSize )
6877:           .tCopy  oEmitInt( size )    % multi-word copy
6885:    ]
6885:    oTypeSPop
6887:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
6887: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
6889:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
6905:       | false :   #eNotCurrentFunction
6908:       | * :
6913:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
6913:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
6928:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
6941:    ':='
6943:    @Expr
6945:    @MatchTypes
6947:    [ oTypeSNodeType
6949:       | nIntegerType :            .tAssignI
6952:       | nBooleanType :            .tAssignB
6956:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6960:       | nPointerType :            .tAssignP
6964:       | * :
6979:           int size = oNodeGetInt( oTypeSTop, qSize )
6991:           .tCopy  oEmitInt( size )    % multi-word copy
6999:    ]
6999:    oTypeSPop
7001:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
7001: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
7003:    pIdent
7005:    Node decl = oScopeFindRequire
7010:    [ oNodeType( decl )
7017:       | nGlobalVar, nLocalVar, nParam :
7018:       | * :  #eNotVar
7029:    ]
7029:    @LValueVar( decl )
7037:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
7037: LValueVar( Node decl ):
7039:    [ oNodeType( decl )
7046:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
7056:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
7067:       | nParam :
7069:          [ oNodeGetBoolean( decl, qInOut )
7079:             | true :   % VAR param points to variable.  No dereference.
7080:                        .tPushParamP @EmitValue( decl )
7089:             | * :      .tPushAddrParam @EmitValue( decl )
7103:          ]
7103:       | * :            #eNotVar
7114:    ]
      
7114:    oTypeSPush( oNodeGet( decl, qType ) )
7127:    @LValueIndexes        % handle subscripts, if any
7130:    ;
      
      
7130: IncVar( Node decl ):
7132:    @LValueVar( decl )
7139:    @RequireIntPop
7141:    @VarExpr( decl )
7148:    oTypeSPop
7149:    .tIncI
7151:    .tAssignI;
      
7154: DecVar( Node decl ):
7156:    @LValueVar( decl )
7163:    @RequireIntPop
7165:    @VarExpr( decl )
7172:    oTypeSPop
7173:    .tDecI
7175:    .tAssignI;
      
      
7178: IfStmt:
7180:    Label falseLabel = labelNull
      
7186:    @BooleanExprControlFlow( falseLabel )
7193:    pThen
7195:    @Statement
7197:    [
7197:       | pElse :
7199:          Label doneLabel = oLabelNew
      
7204:          .tJump  oEmitLabel( doneLabel )
7212:          .tLabel oEmitLabel( falseLabel )
7220:          @Statement
7222:          .tLabel oEmitLabel( doneLabel )
      
7230:       | * :
7235:          .tLabel oEmitLabel( falseLabel )
7243:    ];
      
      
7244: ForStmt:
7246:    pIdent
      
7248:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
7253:    @LValueVar( decl )
7260:    @RequireIntPop
      
7262:    ':='
      
7264:    @Expr
7266:    @RequireIntPop
7268:    .tAssignI
      
7270:    Label breakLabel = oLabelNew
      
7275:    Label checkLabel = oLabelNew
7280:    .tJump  oEmitLabel( checkLabel )
      
7288:    Label continueLabel = oLabelNew
7293:    .tLabel  oEmitLabel( continueLabel )
7301:    [
7301:       | pTo :
7303:          @IncVar( decl )
7310:          .tLabel  oEmitLabel( checkLabel )
7318:          @VarExpr( decl )  oTypeSPop
7326:          @Expr
7328:          @RequireIntPop
7330:          .tGreaterI
7332:          .tJumpTrue  oEmitLabel( breakLabel )
7340:       | pDownto :
7342:          @DecVar( decl )
7349:          .tLabel  oEmitLabel( checkLabel )
7357:          @VarExpr( decl )  oTypeSPop
7365:          @Expr
7367:          @RequireIntPop
7369:          .tLessI
7371:          .tJumpTrue  oEmitLabel( breakLabel )
7379:    ]
7387:    oLoopPush( continueLabel, breakLabel )
7396:    pDo
7398:    @Statement
7400:    .tJump  oEmitLabel( continueLabel )
7408:    .tLabel  oEmitLabel( breakLabel )
7416:    oLoopPop;
      
      
7418: RepeatStmt:
7420:    Label continueLabel = oLabelNew
7425:    .tLabel  oEmitLabel( continueLabel )
      
7433:    Label breakLabel = oLabelNew
      
7438:    oLoopPush( continueLabel, breakLabel )
7447:    @Statement
7449:    {[
7449:       | ';' :
7451:          @Statement
7453:       | pUntil :
7455:          Label falseLabel
7455:          @BooleanExprControlFlow( falseLabel )
7462:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
7476:          >
7478:    ]}
7488:    .tLabel  oEmitLabel( breakLabel )
7496:    oLoopPop;
      
      
7498: WhileStmt:
7500:    Label continueLabel = oLabelNew
7505:    .tLabel  oEmitLabel( continueLabel )
      
7513:    Label breakLabel
7513:    @BooleanExprControlFlow( breakLabel )
      
7520:    oLoopPush( continueLabel, breakLabel )
7529:    pDo
7531:    @Statement
7533:    .tJump  oEmitLabel( continueLabel )
7541:    .tLabel  oEmitLabel( breakLabel )
7549:    oLoopPop;
      
      
7551: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7553:    [ equal_label( oLoopContinueLabel, labelNull )
7562:       | true :
7563:          #eNotInALoop
7565:       | false :
7567:          .tJump  oEmitLabel( oLoopContinueLabel )
7574:    ];
      
      
7583: BreakStmt:
7585:    [ equal_label( oLoopBreakLabel, labelNull )
7594:       | true :
7595:          #eNotInALoop
7597:       | false :
7599:          .tJump  oEmitLabel( oLoopBreakLabel )
7606:    ];
      
      
7615: BeginStmt:
7617:    @Statement
7619:    {[
7619:       | ';' :   @Statement
7623:       | pEnd :  >
7627:    ]};
      
      
7638: WritelnStmt:
7640:    @WriteStmt
7642:    .tWriteCR;
      
      
7645: WriteStmt:
7647:    [
7647:       | '(' :
7649:          {
7649:             @Expr
7651:             [ oTypeSNodeType
7653:                | nIntegerType :             .tWriteI
7656:                | nBooleanType :             .tWriteBool
7660:                | nStringType :              .tWriteStr
7664:                | nCharType, nFileType :     #eNotImplemented
7668:                | nPointerType :             .tWriteP
7672:                | * :                        #eNotAllowed
7689:             ]
7689:             oTypeSPop
7690:             [
7690:                | ')' : >
7694:                | ',' :
7696:             ]
7704:          }
7706:       | * :
7711:    ];
      
      
7712: ReadlnStmt:      % ***
         % TO DO
7715:    ;
      
7715: ReadStmt:
         % TO DO
7718:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7718: ScopeLevel >> int:
7720:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7730: DeclLevel( Node decl ) >> int:
7732:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7750: DeclUpLevels( Node decl ) >> int:
7752:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7768: MatchTypes:
7770:    node_type nt = oTypeSNodeType
7775:    oTypeSPop
7776:    [ equal_node_type( nt, oTypeSNodeType )
7785:       | false :
7786:          #eTypeMismatch
7788:       | * :
7793:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7794: RequireIntPop:
7796:    [ oTypeSNodeType
7798:       | nIntegerType :
7799:       | * :          #eNotInteger
7806:    ]
7806:    oTypeSPop;
      
7808: RequireInt:
7810:    [ oTypeSNodeType
7812:       | nIntegerType :
7813:       | * :          #eNotInteger
7820:    ];
      
7821: RequireBoolPop:
7823:    [ oTypeSNodeType
7825:       | nBooleanType :
7826:       | * :          #eNotBoolean
7833:    ]
7833:    oTypeSPop;
      
7835: RequireBool:
7837:    [ oTypeSNodeType
7839:       | nBooleanType :
7840:       | * :          #eNotBoolean
7847:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7848: newType( node_type nt, int size ) >> Node:
7850:   Node node = oNodeNew( nt )
7860:   oNodeSetInt( node, qSize, size )
7872:   oTypeAdd( node )
7878:   >> node
7882:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
7882: newIdent( node_type nt, kind k, int id ) >> Node:
7884:   Node t = oNodeNew( nt )
7894:   oNodeSetInt( t, qIdent, id )
7906:   >> t
7910:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
7910: PointerTypeTo( Node theType ) >> Node:
7912:    Node ptrType = oNodeGet( theType, qPointerType )
7925:    [ oNodeNull( ptrType )
7932:       | true :
7933:          ptrType = oNodeNew( nPointerType )
7943:          oNodeSet( ptrType, qBaseType, theType )
7955:          oNodeSetInt( ptrType, qSize, 8 )
7967:          oTypeAdd( ptrType )
7973:          oNodeSet( theType, qPointerType, ptrType )
7985:       | * :
7990:    ]
7990:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
7994: OrdinalLow( Node theType ) >> int:
7996:    [ oNodeType( theType )
8003:       | nIntegerType :  >> oMININT
8006:       | nBooleanType :  >> 0
8011:       | nCharType :     >> 0
8016:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
8028:       | * :             #eNotOrdinalType
8041:                         >> 0
8044:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
8045: EmitValue( Node decl ):
8047:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
8061: installBuiltIns:
      
         % install built-in types
8063:    FileType = @newType( nFileType, 4 )
8077:    IntegerType = @newType( nIntegerType, 4 )
8091:    BooleanType = @newType( nBooleanType, 1 )
8105:    BooleanCFType = @newType( nBooleanCFType, 1 )
8119:    CharType = @newType( nCharType, 1 )
8133:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8147:    Node t
      
8147:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
8163:    oNodeSet( t, qType, FileType )
8175:    oScopeDeclare( t )
      
8181:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
8197:    oNodeSet( t, qType, IntegerType )
8209:    oScopeDeclare( t )
      
8215:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
8231:    oNodeSet( t, qType, BooleanType )
8243:    oScopeDeclare( t )
      
8249:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
8265:    oNodeSet( t, qType, CharType )
8277:    oScopeDeclare( t )
      
8283:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
8299:    oNodeSet( t, qType, StringType )
8311:    oScopeDeclare( t )
      
         % Built-in constants
      
8317:    t = @newIdent( nConst, kConst, oIdAdd_True )
8333:    oNodeSet( t, qType, BooleanType )
8345:    oNodeSetInt( t, qValue, 1 )
8357:    oScopeDeclare( t )
      
8363:    t = @newIdent( nConst, kConst, oIdAdd_False )
8379:    oNodeSet( t, qType, BooleanType )
8391:    oNodeSetInt( t, qValue, 0 )
8403:    oScopeDeclare( t )
      
8410:    ;
      
8410: end
      
8410: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 6
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 8061
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 181
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 15
 110: oPushResult
 111: oSetResult 6
 113: oPushResult
 114: LAST_ID
 115: oPushResult
 116: oCall 7882
 118: oPop 3
 120: oAssign
 121: oGetLocal 1
 123: oPushResult
 124: oSetResult 21
 126: oPushResult
 127: oGetGlobal 3
 129: oPushResult
 130: oNodeSet
 131: oPop 3
 133: oGetLocal 1
 135: oPushResult
 136: oScopeDeclareAlloc
 137: oPop 1
 139: oInput 12
 141: oInput 0
 143: oGetAddrLocal 1
 145: oPushResult
 146: oSetResult 15
 148: oPushResult
 149: oSetResult 6
 151: oPushResult
 152: LAST_ID
 153: oPushResult
 154: oCall 7882
 156: oPop 3
 158: oAssign
 159: oGetLocal 1
 161: oPushResult
 162: oSetResult 21
 164: oPushResult
 165: oGetGlobal 3
 167: oPushResult
 168: oNodeSet
 169: oPop 3
 171: oGetLocal 1
 173: oPushResult
 174: oScopeDeclareAlloc
 175: oPop 1
 177: oInput 14
 179: oJumpForward 184
 181: Choice Lookup Table
          13    103
 184: oInput 4
 186: oInputChoice 197
 188: oGetLocal 4
 190: oPushResult
 191: oCall 292
 193: oPop 1
 195: oJumpForward 200
 197: Choice Lookup Table
          54    188
 200: oGetLocal 4
 202: oPushResult
 203: oCall 348
 205: oPop 1
 207: oSetResult 0
 209: oPushResult
 210: oSetResult 0
 212: oPushResult
 213: oScopeBegin
 214: oPop 2
 216: oGetAddrLocal 5
 218: oPushResult
 219: oScopeCurrent
 220: oAssign
 221: oSetResult 0
 223: oPushResult
 224: oSetResult 1
 226: oPushResult
 227: oScopeBegin
 228: oPop 2
 230: oGetAddrGlobal 2
 232: oPushResult
 233: oScopeCurrent
 234: oAssign
 235: oGetLocal 4
 237: oPushResult
 238: oSetResult 7
 240: oPushResult
 241: oGetGlobal 2
 243: oPushResult
 244: oNodeSet
 245: oPop 3
 247: oScopeEnd
 248: oSetResult 16
 250: oPushResult
 251: oCall 1272
 253: oPop 1
 255: oGetGlobal 2
 257: oPushResult
 258: oScopeEnter
 259: oPop 1
 261: oGetAddrLocal 6
 263: oPushResult
 264: oSetResult 1
 266: oAssign
 267: oGetLocal 3
 269: oPushResult
 270: oGetLocal 5
 272: oPushResult
 273: oGetLocal 6
 275: oPushResult
 276: oCall 1492
 278: oPop 3
 280: oScopeEnd
 281: oInput 19
 283: oScopeEnd
 284: oGetLocal 4
 286: oPushResult
 287: oCall 410
 289: oPop 1
 291: oReturn
 292: oLocalSpace 1
 294: oInput 0
 296: oGetAddrLocal 1
 298: oPushResult
 299: LAST_ID
 300: oPushResult
 301: oCall 489
 303: oPop 1
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oSetResult 0
 311: oPushResult
 312: equal_node
 313: oPop 2
 315: oChoice 331
 317: oGetParam 1
 319: oPushResult
 320: oSetResult 5
 322: oPushResult
 323: oGetLocal 1
 325: oPushResult
 326: oNodeAddLast
 327: oPop 3
 329: oJumpForward 334
 331: Choice Lookup Table
           0    317
 334: oInputChoice 338
 336: oJumpForward 343
 338: Choice Lookup Table
          12    336
 341: oJumpForward 345
 343: oJumpBack 294
 345: oInput 4
 347: oReturn
 348: oLocalSpace 2
 350: oGetAddrLocal 1
 352: oPushResult
 353: oGetParam 1
 355: oPushResult
 356: oSetResult 5
 358: oPushResult
 359: oNodeGetIter
 360: oPop 2
 362: oAssign
 363: oGetAddrLocal 2
 365: oPushResult
 366: oGetLocal 1
 368: oPushResult
 369: oNodeIterValue
 370: oPop 1
 372: oAssign
 373: oGetLocal 2
 375: oPushResult
 376: oNodeNull
 377: oPop 1
 379: oChoice 396
 381: oGetLocal 2
 383: oPushResult
 384: oSetResult 9
 386: oPushResult
 387: oNodeGet
 388: oPop 2
 390: oPushResult
 391: oScopeEnter
 392: oPop 1
 394: oJumpForward 401
 396: Choice Lookup Table
           0    381
 399: oJumpForward 409
 401: oGetAddrLocal 1
 403: oPushResult
 404: oNodeIterNext
 405: oPop 1
 407: oJumpBack 363
 409: oReturn
 410: oLocalSpace 2
 412: oGetAddrLocal 1
 414: oPushResult
 415: oGetParam 1
 417: oPushResult
 418: oSetResult 5
 420: oPushResult
 421: oNodeGetIterLast
 422: oPop 2
 424: oAssign
 425: oGetAddrLocal 2
 427: oPushResult
 428: oGetLocal 1
 430: oPushResult
 431: oNodeIterValue
 432: oPop 1
 434: oAssign
 435: oGetLocal 2
 437: oPushResult
 438: oNodeNull
 439: oPop 1
 441: oChoice 475
 443: oScopeCurrent
 444: oPushResult
 445: oGetLocal 2
 447: oPushResult
 448: oSetResult 9
 450: oPushResult
 451: oNodeGet
 452: oPop 2
 454: oPushResult
 455: oNodeEqual
 456: oPop 2
 458: oChoice 466
 460: oJumpForward 472
 462: oError 25
 464: oJumpForward 472
 466: Choice Lookup Table
           0    462
           1    460
 471: oEndChoice
 472: oScopeEnd
 473: oJumpForward 480
 475: Choice Lookup Table
           0    443
 478: oJumpForward 488
 480: oGetAddrLocal 1
 482: oPushResult
 483: oNodeIterPrev
 484: oPop 1
 486: oJumpBack 425
 488: oReturn
 489: oLocalSpace 2
 491: oGetAddrLocal 1
 493: oPushResult
 494: oGetGlobal 1
 496: oPushResult
 497: oSetResult 1
 499: oPushResult
 500: oSetResult 4
 502: oPushResult
 503: oGetParam 1
 505: oPushResult
 506: oNodeFind
 507: oPop 4
 509: oAssign
 510: oGetLocal 1
 512: oPushResult
 513: oSetResult 0
 515: oPushResult
 516: equal_node
 517: oPop 2
 519: oChoice 526
 521: oGetLocal 1
 523: oReturn
 524: oJumpForward 529
 526: Choice Lookup Table
           0    521
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetParam 1
 534: oPushResult
 535: oIncludeUnitFile
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oChoice 550
 543: oError 24
 545: oSetResult 0
 547: oReturn
 548: oJumpForward 553
 550: Choice Lookup Table
           0    543
 553: oGetAddrLocal 1
 555: oPushResult
 556: oCall 564
 558: oAssign
 559: oIncludeEnd
 560: oGetLocal 1
 562: oReturn
 563: oReturn
 564: oLocalSpace 2
 566: oInput 55
 568: oInput 0
 570: oGetAddrLocal 1
 572: oPushResult
 573: oSetResult 5
 575: oPushResult
 576: oNodeNew
 577: oPop 1
 579: oAssign
 580: oGetLocal 1
 582: oPushResult
 583: oSetResult 4
 585: oPushResult
 586: LAST_ID
 587: oPushResult
 588: oNodeSetInt
 589: oPop 3
 591: oGetAddrLocal 2
 593: oPushResult
 594: oSetResult 6
 596: oPushResult
 597: oNodeNew
 598: oPop 1
 600: oAssign
 601: oGetLocal 2
 603: oPushResult
 604: oSetResult 4
 606: oPushResult
 607: LAST_ID
 608: oPushResult
 609: oNodeSetInt
 610: oPop 3
 612: oGetLocal 1
 614: oPushResult
 615: oSetResult 8
 617: oPushResult
 618: oGetLocal 2
 620: oPushResult
 621: oNodeSet
 622: oPop 3
 624: oInput 4
 626: oInput 56
 628: oInputChoice 639
 630: oGetLocal 1
 632: oPushResult
 633: oCall 292
 635: oPop 1
 637: oJumpForward 642
 639: Choice Lookup Table
          54    630
 642: oGetLocal 1
 644: oPushResult
 645: oCall 348
 647: oPop 1
 649: oSetResult 0
 651: oPushResult
 652: oSetResult 0
 654: oPushResult
 655: oScopeBegin
 656: oPop 2
 658: oGetLocal 1
 660: oPushResult
 661: oSetResult 9
 663: oPushResult
 664: oScopeCurrent
 665: oPushResult
 666: oNodeSet
 667: oPop 3
 669: oSetResult 0
 671: oPushResult
 672: oSetResult 1
 674: oPushResult
 675: oScopeBegin
 676: oPop 2
 678: oGetAddrGlobal 2
 680: oPushResult
 681: oScopeCurrent
 682: oAssign
 683: oGetLocal 1
 685: oPushResult
 686: oSetResult 13
 688: oPushResult
 689: oGetGlobal 2
 691: oPushResult
 692: oNodeSet
 693: oPop 3
 695: oScopeEnd
 696: oGetLocal 1
 698: oPushResult
 699: oCall 875
 701: oPop 1
 703: oScopeEnd
 704: oInput 57
 706: oInputChoice 717
 708: oGetLocal 2
 710: oPushResult
 711: oCall 292
 713: oPop 1
 715: oJumpForward 720
 717: Choice Lookup Table
          54    708
 720: oGetLocal 2
 722: oPushResult
 723: oCall 348
 725: oPop 1
 727: oGetLocal 1
 729: oPushResult
 730: oSetResult 9
 732: oPushResult
 733: oNodeGet
 734: oPop 2
 736: oPushResult
 737: oScopeEnter
 738: oPop 1
 740: oSetResult 0
 742: oPushResult
 743: oSetResult 0
 745: oPushResult
 746: oScopeBegin
 747: oPop 2
 749: oGetLocal 1
 751: oPushResult
 752: oSetResult 10
 754: oPushResult
 755: oScopeCurrent
 756: oPushResult
 757: oNodeSet
 758: oPop 3
 760: oScopeCurrent
 761: oPushResult
 762: oSetResult 16
 764: oPushResult
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 9
 770: oPushResult
 771: oNodeGet
 772: oPop 2
 774: oPushResult
 775: oNodeSet
 776: oPop 3
 778: oGetLocal 1
 780: oPushResult
 781: oCall 960
 783: oPop 1
 785: oInputChoice 799
 787: oGetLocal 1
 789: oPushResult
 790: oSetResult 1
 792: oPushResult
 793: oCall 970
 795: oPop 2
 797: oJumpForward 812
 799: Choice Lookup Table
          58    787
 802: oGetLocal 1
 804: oPushResult
 805: oSetResult 0
 807: oPushResult
 808: oCall 970
 810: oPop 2
 812: oInputChoice 826
 814: oGetLocal 1
 816: oPushResult
 817: oSetResult 1
 819: oPushResult
 820: oCall 1156
 822: oPop 2
 824: oJumpForward 839
 826: Choice Lookup Table
          59    814
 829: oGetLocal 1
 831: oPushResult
 832: oSetResult 0
 834: oPushResult
 835: oCall 1156
 837: oPop 2
 839: oInput 34
 841: oInput 19
 843: oScopeEnd
 844: oScopeEnd
 845: oGetLocal 2
 847: oPushResult
 848: oCall 410
 850: oPop 1
 852: oGetLocal 1
 854: oPushResult
 855: oCall 410
 857: oPop 1
 859: oGetGlobal 1
 861: oPushResult
 862: oSetResult 1
 864: oPushResult
 865: oGetLocal 1
 867: oPushResult
 868: oNodeAddLast
 869: oPop 3
 871: oGetLocal 1
 873: oReturn
 874: oReturn
 875: oLocalSpace 2
 877: oInputChoice 944
 879: oCall 2772
 881: oJumpForward 957
 883: oCall 2844
 885: oJumpForward 957
 887: oSetResult 16
 889: oPushResult
 890: oCall 2903
 892: oPop 1
 894: oJumpForward 957
 896: oGetAddrLocal 1
 898: oPushResult
 899: oCall 1730
 901: oAssign
 902: oInputChoice 915
 904: oGetLocal 1
 906: oPushResult
 907: oCall 1668
 909: oPop 1
 911: oInput 4
 913: oJumpForward 918
 915: Choice Lookup Table
          65    904
 918: oJumpForward 957
 920: oGetAddrLocal 2
 922: oPushResult
 923: oCall 2107
 925: oAssign
 926: oInputChoice 939
 928: oGetLocal 2
 930: oPushResult
 931: oCall 1668
 933: oPop 1
 935: oInput 4
 937: oJumpForward 942
 939: Choice Lookup Table
          65    928
 942: oJumpForward 957
 944: Choice Lookup Table
          29    920
          28    896
          32    887
          31    883
          30    879
 955: oJumpForward 959
 957: oJumpBack 877
 959: oReturn
 960: oLocalSpace 0
 962: oSetResult 16
 964: oPushResult
 965: oCall 1272
 967: oPop 1
 969: oReturn
 970: oLocalSpace 5
 972: oGetAddrLocal 1
 974: oPushResult
 975: oLabelNew
 976: oAssign
 977: oEmit 56
 979: oGetLocal 1
 981: oPushResult
 982: oEmitLabel
 983: oPop 1
 985: oGetParam 2
 987: oPushResult
 988: oSetResult 11
 990: oPushResult
 991: oGetLocal 1
 993: oPushResult
 994: oNodeSetLabel
 995: oPop 3
 997: oEmit 52
 999: oGetAddrLocal 2
1001: oPushResult
1002: Here
1003: oAssign
1004: oEmit 64
1006: oGetAddrLocal 3
1008: oPushResult
1009: oGetParam 2
1011: oPushResult
1012: oSetResult 9
1014: oPushResult
1015: oNodeGet
1016: oPop 2
1018: oAssign
1019: oGetAddrLocal 4
1021: oPushResult
1022: oGetLocal 3
1024: oPushResult
1025: oSetResult 19
1027: oPushResult
1028: oNodeGetCode
1029: oPop 2
1031: oAssign
1032: oGetLocal 4
1034: oPushResult
1035: oEmitCode
1036: oPop 1
1038: oGetLocal 3
1040: oPushResult
1041: oSetResult 19
1043: oPushResult
1044: oSetResult 0
1046: oPushResult
1047: oNodeSetCode
1048: oPop 3
1050: oGetAddrLocal 3
1052: oPushResult
1053: oGetParam 2
1055: oPushResult
1056: oSetResult 10
1058: oPushResult
1059: oNodeGet
1060: oPop 2
1062: oAssign
1063: oGetAddrLocal 4
1065: oPushResult
1066: oGetLocal 3
1068: oPushResult
1069: oSetResult 19
1071: oPushResult
1072: oNodeGetCode
1073: oPop 2
1075: oAssign
1076: oGetLocal 4
1078: oPushResult
1079: oEmitCode
1080: oPop 1
1082: oGetLocal 3
1084: oPushResult
1085: oSetResult 19
1087: oPushResult
1088: oSetResult 0
1090: oPushResult
1091: oNodeSetCode
1092: oPop 3
1094: oGetParam 2
1096: oPushResult
1097: oSetResult 13
1099: oPushResult
1100: oNodeGet
1101: oPop 2
1103: oPushResult
1104: oScopeEnter
1105: oPop 1
1107: oGetParam 1
1109: oChoice 1128
1111: oCall 6679
1113: oInputChoice 1119
1115: oCall 6679
1117: oJumpForward 1124
1119: Choice Lookup Table
           4   1115
1122: oJumpForward 1126
1124: oJumpBack 1113
1126: oJumpForward 1131
1128: Choice Lookup Table
           1   1111
1131: oEmit 51
1133: oGetAddrLocal 5
1135: oPushResult
1136: oScopeCurrent
1137: oPushResult
1138: oSetResult 17
1140: oPushResult
1141: oNodeGetInt
1142: oPop 2
1144: oAssign
1145: oGetLocal 2
1147: oPushResult
1148: oGetLocal 5
1150: oPushResult
1151: oPatch
1152: oPop 2
1154: oScopeEnd
1155: oReturn
1156: oLocalSpace 3
1158: oGetAddrLocal 1
1160: oPushResult
1161: oLabelNew
1162: oAssign
1163: oEmit 56
1165: oGetLocal 1
1167: oPushResult
1168: oEmitLabel
1169: oPop 1
1171: oGetParam 2
1173: oPushResult
1174: oSetResult 12
1176: oPushResult
1177: oGetLocal 1
1179: oPushResult
1180: oNodeSetLabel
1181: oPop 3
1183: oEmit 52
1185: oGetAddrLocal 2
1187: oPushResult
1188: Here
1189: oAssign
1190: oEmit 64
1192: oSetResult 0
1194: oPushResult
1195: oSetResult 1
1197: oPushResult
1198: oScopeBegin
1199: oPop 2
1201: oGetParam 1
1203: oChoice 1222
1205: oCall 6679
1207: oInputChoice 1213
1209: oCall 6679
1211: oJumpForward 1218
1213: Choice Lookup Table
           4   1209
1216: oJumpForward 1220
1218: oJumpBack 1207
1220: oJumpForward 1225
1222: Choice Lookup Table
           1   1205
1225: oEmit 51
1227: oGetAddrLocal 3
1229: oPushResult
1230: oScopeCurrent
1231: oPushResult
1232: oSetResult 17
1234: oPushResult
1235: oNodeGetInt
1236: oPop 2
1238: oAssign
1239: oGetLocal 2
1241: oPushResult
1242: oGetLocal 3
1244: oPushResult
1245: oPatch
1246: oPop 2
1248: oScopeEnd
1249: oReturn
1250: oLocalSpace 0
1252: oGetParam 2
1254: oPushResult
1255: oCall 1272
1257: oPop 1
1259: oGetParam 1
1261: oPushResult
1262: oScopeCurrent
1263: oPushResult
1264: oSetResult 0
1266: oPushResult
1267: oCall 1492
1269: oPop 3
1271: oReturn
1272: oLocalSpace 0
1274: oInputChoice 1301
1276: oCall 2772
1278: oJumpForward 1314
1280: oCall 2844
1282: oJumpForward 1314
1284: oGetParam 1
1286: oPushResult
1287: oCall 2903
1289: oPop 1
1291: oJumpForward 1314
1293: oCall 1989
1295: oJumpForward 1314
1297: oCall 2427
1299: oJumpForward 1314
1301: Choice Lookup Table
          29   1297
          28   1293
          32   1284
          31   1280
          30   1276
1312: oJumpForward 1316
1314: oJumpBack 1274
1316: oCall 1319
1318: oReturn
1319: oLocalSpace 0
1321: oReturn
1322: oLocalSpace 2
1324: oGetAddrLocal 1
1326: oPushResult
1327: oGetGlobal 1
1329: oPushResult
1330: oSetResult 1
1332: oPushResult
1333: oNodeGetIter
1334: oPop 2
1336: oAssign
1337: oGetAddrLocal 2
1339: oPushResult
1340: oGetLocal 1
1342: oPushResult
1343: oNodeIterValue
1344: oPop 1
1346: oAssign
1347: oGetLocal 2
1349: oPushResult
1350: oNodeNull
1351: oPop 1
1353: oChoice 1398
1355: oJumpForward 1406
1357: oJumpForward 1404
1359: oEmit 46
1361: oSetResult 0
1363: oPushResult
1364: oEmitInt
1365: oPop 1
1367: oEmit 49
1369: oGetLocal 2
1371: oPushResult
1372: oSetResult 11
1374: oPushResult
1375: oNodeGetLabel
1376: oPop 2
1378: oPushResult
1379: oEmitLabel
1380: oPop 1
1382: oEmit 48
1384: oSetResult 0
1386: oPushResult
1387: oEmitInt
1388: oPop 1
1390: oGetAddrLocal 1
1392: oPushResult
1393: oNodeIterNext
1394: oPop 1
1396: oJumpForward 1404
1398: Choice Lookup Table
           0   1359
           1   1355
1403: oEndChoice
1404: oJumpBack 1337
1406: oReturn
1407: oLocalSpace 2
1409: oGetAddrLocal 1
1411: oPushResult
1412: oGetGlobal 1
1414: oPushResult
1415: oSetResult 1
1417: oPushResult
1418: oNodeGetIterLast
1419: oPop 2
1421: oAssign
1422: oGetAddrLocal 2
1424: oPushResult
1425: oGetLocal 1
1427: oPushResult
1428: oNodeIterValue
1429: oPop 1
1431: oAssign
1432: oGetLocal 2
1434: oPushResult
1435: oNodeNull
1436: oPop 1
1438: oChoice 1483
1440: oJumpForward 1491
1442: oJumpForward 1489
1444: oEmit 46
1446: oSetResult 0
1448: oPushResult
1449: oEmitInt
1450: oPop 1
1452: oEmit 49
1454: oGetLocal 2
1456: oPushResult
1457: oSetResult 12
1459: oPushResult
1460: oNodeGetLabel
1461: oPop 2
1463: oPushResult
1464: oEmitLabel
1465: oPop 1
1467: oEmit 48
1469: oSetResult 0
1471: oPushResult
1472: oEmitInt
1473: oPop 1
1475: oGetAddrLocal 1
1477: oPushResult
1478: oNodeIterPrev
1479: oPop 1
1481: oJumpForward 1489
1483: Choice Lookup Table
           0   1444
           1   1440
1488: oEndChoice
1489: oJumpBack 1422
1491: oReturn
1492: oLocalSpace 3
1494: oEmit 56
1496: oGetParam 3
1498: oPushResult
1499: oEmitLabel
1500: oPop 1
1502: oEmit 52
1504: oGetAddrLocal 1
1506: oPushResult
1507: Here
1508: oAssign
1509: oEmit 64
1511: oGetParam 1
1513: oChoice 1519
1515: oCall 1322
1517: oJumpForward 1522
1519: Choice Lookup Table
           1   1515
1522: oGetAddrLocal 2
1524: oPushResult
1525: oGetParam 2
1527: oPushResult
1528: oSetResult 19
1530: oPushResult
1531: oNodeGetCode
1532: oPop 2
1534: oAssign
1535: oGetLocal 2
1537: oPushResult
1538: oEmitCode
1539: oPop 1
1541: oGetParam 2
1543: oPushResult
1544: oSetResult 19
1546: oPushResult
1547: oSetResult 0
1549: oPushResult
1550: oNodeSetCode
1551: oPop 3
1553: oCall 6679
1555: oGetParam 1
1557: oChoice 1563
1559: oCall 1407
1561: oJumpForward 1566
1563: Choice Lookup Table
           1   1559
1566: oEmit 51
1568: oGetAddrLocal 3
1570: oPushResult
1571: oScopeCurrent
1572: oPushResult
1573: oSetResult 17
1575: oPushResult
1576: oNodeGetInt
1577: oPop 2
1579: oAssign
1580: oGetLocal 1
1582: oPushResult
1583: oGetLocal 3
1585: oPushResult
1586: oPatch
1587: oPop 2
1589: oReturn
1590: oLocalSpace 0
1592: oInputChoice 1610
1594: oGetParam 1
1596: oPushResult
1597: oSetResult 27
1599: oPushResult
1600: oSetResult 1
1602: oPushResult
1603: oNodeSetBoolean
1604: oPop 3
1606: oInput 4
1608: oJumpForward 1615
1610: Choice Lookup Table
          67   1594
1613: oJumpForward 1617
1615: oJumpBack 1592
1617: oReturn
1618: oLocalSpace 1
1620: oGetAddrLocal 1
1622: oPushResult
1623: oScopeCurrent
1624: oPushResult
1625: oSetResult 19
1627: oPushResult
1628: oNodeGetCode
1629: oPop 2
1631: oAssign
1632: oGetLocal 1
1634: oPushResult
1635: oSetResult 0
1637: oPushResult
1638: equal_code
1639: oPop 2
1641: oChoice 1661
1643: oGetAddrLocal 1
1645: oPushResult
1646: oCodeNew
1647: oAssign
1648: oScopeCurrent
1649: oPushResult
1650: oSetResult 19
1652: oPushResult
1653: oGetLocal 1
1655: oPushResult
1656: oNodeSetCode
1657: oPop 3
1659: oJumpForward 1664
1661: Choice Lookup Table
           1   1643
1664: oGetLocal 1
1666: oReturn
1667: oReturn
1668: oLocalSpace 0
1670: oGetParam 1
1672: oPushResult
1673: oCall 7730
1675: oPop 1
1677: oPushResult
1678: equal_zero
1679: oPop 1
1681: oChoice 1687
1683: oError 23
1685: oJumpForward 1690
1687: Choice Lookup Table
           0   1683
1690: oGetParam 1
1692: oPushResult
1693: oSetResult 25
1695: oPushResult
1696: oSetResult 1
1698: oPushResult
1699: oNodeSetBoolean
1700: oPop 3
1702: oInputChoice 1726
1704: oInputChoice 1721
1706: oInput 2
1708: oGetParam 1
1710: oPushResult
1711: oSetResult 26
1713: oPushResult
1714: CURRENT_STRLIT
1715: oPushResult
1716: oNodeSetString
1717: oPop 3
1719: oJumpForward 1724
1721: Choice Lookup Table
          66   1706
1724: oJumpForward 1729
1726: Choice Lookup Table
           2   1704
1729: oReturn
1730: oLocalSpace 6
1732: oInput 0
1734: oGetAddrLocal 1
1736: oPushResult
1737: oSetResult 0
1739: oAssign
1740: oGetAddrLocal 2
1742: oPushResult
1743: oScopeFindInCurrentScope
1744: oAssign
1745: oGetLocal 2
1747: oPushResult
1748: oNodeNull
1749: oPop 1
1751: oChoice 1872
1753: oGetAddrLocal 2
1755: oPushResult
1756: oSetResult 11
1758: oPushResult
1759: oSetResult 2
1761: oPushResult
1762: LAST_ID
1763: oPushResult
1764: oCall 7882
1766: oPop 3
1768: oAssign
1769: oGetLocal 2
1771: oPushResult
1772: oSetResult 22
1774: oPushResult
1775: oLabelNew
1776: oPushResult
1777: oNodeSetLabel
1778: oPop 3
1780: oJumpForward 1878
1782: oGetAddrLocal 1
1784: oPushResult
1785: oSetResult 1
1787: oAssign
1788: oGetLocal 2
1790: oPushResult
1791: oSetResult 24
1793: oPushResult
1794: oNodeGetBoolean
1795: oPop 2
1797: oChoice 1803
1799: oError 21
1801: oJumpForward 1806
1803: Choice Lookup Table
           1   1799
1806: oGetLocal 2
1808: oPushResult
1809: oSetResult 25
1811: oPushResult
1812: oNodeGetBoolean
1813: oPop 2
1815: oChoice 1821
1817: oError 21
1819: oJumpForward 1824
1821: Choice Lookup Table
           1   1817
1824: oGetLocal 2
1826: oPushResult
1827: oNodeType
1828: oPop 1
1830: oChoice 1834
1832: oJumpForward 1839
1834: Choice Lookup Table
          11   1832
1837: oError 21
1839: oGetLocal 2
1841: oPushResult
1842: oSetResult 29
1844: oPushResult
1845: oGetLocal 2
1847: oPushResult
1848: oSetResult 23
1850: oPushResult
1851: oNodeGet
1852: oPop 2
1854: oPushResult
1855: oNodeSet
1856: oPop 3
1858: oGetLocal 2
1860: oPushResult
1861: oSetResult 23
1863: oPushResult
1864: oSetResult 0
1866: oPushResult
1867: oNodeSet
1868: oPop 3
1870: oJumpForward 1878
1872: Choice Lookup Table
           0   1782
           1   1753
1877: oEndChoice
1878: oGetAddrLocal 3
1880: oPushResult
1881: oCall 7718
1883: oAssign
1884: oGetAddrLocal 4
1886: oPushResult
1887: oGetLocal 3
1889: oPushResult
1890: oSetResult 0
1892: oPushResult
1893: greater
1894: oPop 2
1896: oAssign
1897: oGetAddrLocal 3
1899: oPushResult
1900: inc
1901: oPop 1
1903: oGetLocal 3
1905: oPushResult
1906: oSetResult 2
1908: oPushResult
1909: oScopeBegin
1910: oPop 2
1912: oGetAddrLocal 5
1914: oPushResult
1915: oScopeCurrent
1916: oAssign
1917: oGetLocal 4
1919: oChoice 1938
1921: oGetAddrLocal 6
1923: oPushResult
1924: oGetGlobal 4
1926: oPushResult
1927: oCall 7910
1929: oPop 1
1931: oPushResult
1932: oScopeAllocType
1933: oPop 1
1935: oAssign
1936: oJumpForward 1941
1938: Choice Lookup Table
           1   1921
1941: oCall 2545
1943: oGetLocal 2
1945: oPushResult
1946: oSetResult 23
1948: oPushResult
1949: oGetLocal 5
1951: oPushResult
1952: oNodeSet
1953: oPop 3
1955: oScopeEnd
1956: oInput 4
1958: oGetLocal 1
1960: oChoice 1972
1962: oGetLocal 2
1964: oPushResult
1965: oScopeDeclare
1966: oPop 1
1968: oJumpForward 1978
1970: oJumpForward 1978
1972: Choice Lookup Table
           1   1970
           0   1962
1977: oEndChoice
1978: oGetLocal 2
1980: oPushResult
1981: oCall 1590
1983: oPop 1
1985: oGetLocal 2
1987: oReturn
1988: oReturn
1989: oLocalSpace 4
1991: oGetAddrLocal 1
1993: oPushResult
1994: oCall 1730
1996: oAssign
1997: oInputChoice 2010
1999: oJumpForward 2104
2001: oGetLocal 1
2003: oPushResult
2004: oCall 1668
2006: oPop 1
2008: oJumpForward 2104
2010: Choice Lookup Table
          65   2001
          64   1999
2015: oGetAddrLocal 2
2017: oPushResult
2018: oGetLocal 1
2020: oPushResult
2021: oSetResult 23
2023: oPushResult
2024: oNodeGet
2025: oPop 2
2027: oAssign
2028: oGetLocal 2
2030: oPushResult
2031: oScopeEnter
2032: oPop 1
2034: oGetAddrLocal 3
2036: oPushResult
2037: oGetLocal 2
2039: oPushResult
2040: oSetResult 14
2042: oPushResult
2043: oNodeGetInt
2044: oPop 2
2046: oAssign
2047: oGetLocal 3
2049: oPushResult
2050: oSetResult 1
2052: oPushResult
2053: oScopeBegin
2054: oPop 2
2056: oGetLocal 1
2058: oPushResult
2059: oSetResult 6
2061: oPushResult
2062: oScopeCurrent
2063: oPushResult
2064: oNodeSet
2065: oPop 3
2067: oGetAddrLocal 4
2069: oPushResult
2070: oGetLocal 1
2072: oPushResult
2073: oSetResult 22
2075: oPushResult
2076: oNodeGetLabel
2077: oPop 2
2079: oAssign
2080: oSetResult 17
2082: oPushResult
2083: oGetLocal 4
2085: oPushResult
2086: oCall 1250
2088: oPop 2
2090: oGetLocal 1
2092: oPushResult
2093: oSetResult 24
2095: oPushResult
2096: oSetResult 1
2098: oPushResult
2099: oNodeSetBoolean
2100: oPop 3
2102: oScopeEnd
2103: oScopeEnd
2104: oInput 4
2106: oReturn
2107: oLocalSpace 8
2109: oInput 0
2111: oGetAddrLocal 1
2113: oPushResult
2114: oSetResult 0
2116: oAssign
2117: oGetAddrLocal 2
2119: oPushResult
2120: oScopeFindInCurrentScope
2121: oAssign
2122: oGetLocal 2
2124: oPushResult
2125: oNodeNull
2126: oPop 1
2128: oChoice 2262
2130: oGetAddrLocal 2
2132: oPushResult
2133: oSetResult 12
2135: oPushResult
2136: oSetResult 3
2138: oPushResult
2139: LAST_ID
2140: oPushResult
2141: oCall 7882
2143: oPop 3
2145: oAssign
2146: oGetLocal 2
2148: oPushResult
2149: oSetResult 22
2151: oPushResult
2152: oLabelNew
2153: oPushResult
2154: oNodeSetLabel
2155: oPop 3
2157: oJumpForward 2268
2159: oGetAddrLocal 1
2161: oPushResult
2162: oSetResult 1
2164: oAssign
2165: oGetLocal 2
2167: oPushResult
2168: oSetResult 24
2170: oPushResult
2171: oNodeGetBoolean
2172: oPop 2
2174: oChoice 2180
2176: oError 21
2178: oJumpForward 2183
2180: Choice Lookup Table
           1   2176
2183: oGetLocal 2
2185: oPushResult
2186: oNodeType
2187: oPop 1
2189: oChoice 2193
2191: oJumpForward 2198
2193: Choice Lookup Table
          12   2191
2196: oError 21
2198: oGetLocal 2
2200: oPushResult
2201: oSetResult 29
2203: oPushResult
2204: oGetLocal 2
2206: oPushResult
2207: oSetResult 23
2209: oPushResult
2210: oNodeGet
2211: oPop 2
2213: oPushResult
2214: oNodeSet
2215: oPop 3
2217: oGetLocal 2
2219: oPushResult
2220: oSetResult 23
2222: oPushResult
2223: oSetResult 0
2225: oPushResult
2226: oNodeSet
2227: oPop 3
2229: oGetLocal 2
2231: oPushResult
2232: oSetResult 30
2234: oPushResult
2235: oGetLocal 2
2237: oPushResult
2238: oSetResult 21
2240: oPushResult
2241: oNodeGet
2242: oPop 2
2244: oPushResult
2245: oNodeSet
2246: oPop 3
2248: oGetLocal 2
2250: oPushResult
2251: oSetResult 21
2253: oPushResult
2254: oSetResult 0
2256: oPushResult
2257: oNodeSet
2258: oPop 3
2260: oJumpForward 2268
2262: Choice Lookup Table
           0   2159
           1   2130
2267: oEndChoice
2268: oGetAddrLocal 3
2270: oPushResult
2271: oCall 7718
2273: oAssign
2274: oGetAddrLocal 4
2276: oPushResult
2277: oGetLocal 3
2279: oPushResult
2280: oSetResult 0
2282: oPushResult
2283: greater
2284: oPop 2
2286: oAssign
2287: oGetAddrLocal 3
2289: oPushResult
2290: inc
2291: oPop 1
2293: oGetLocal 3
2295: oPushResult
2296: oSetResult 2
2298: oPushResult
2299: oScopeBegin
2300: oPop 2
2302: oGetAddrLocal 5
2304: oPushResult
2305: oScopeCurrent
2306: oAssign
2307: oGetLocal 4
2309: oChoice 2328
2311: oGetAddrLocal 6
2313: oPushResult
2314: oGetGlobal 4
2316: oPushResult
2317: oCall 7910
2319: oPop 1
2321: oPushResult
2322: oScopeAllocType
2323: oPop 1
2325: oAssign
2326: oJumpForward 2331
2328: Choice Lookup Table
           1   2311
2331: oCall 2545
2333: oGetLocal 2
2335: oPushResult
2336: oSetResult 23
2338: oPushResult
2339: oGetLocal 5
2341: oPushResult
2342: oNodeSet
2343: oPop 3
2345: oInput 11
2347: oGetAddrLocal 7
2349: oPushResult
2350: oCall 3133
2352: oPop 1
2354: oGetLocal 2
2356: oPushResult
2357: oSetResult 21
2359: oPushResult
2360: oGetLocal 7
2362: oPushResult
2363: oNodeSet
2364: oPop 3
2366: oGetAddrLocal 8
2368: oPushResult
2369: oGetLocal 7
2371: oPushResult
2372: oCall 7910
2374: oPop 1
2376: oAssign
2377: oGetLocal 2
2379: oPushResult
2380: oSetResult 31
2382: oPushResult
2383: oGetLocal 8
2385: oPushResult
2386: oScopeAllocType
2387: oPop 1
2389: oPushResult
2390: oNodeSetInt
2391: oPop 3
2393: oScopeEnd
2394: oInput 4
2396: oGetLocal 1
2398: oChoice 2410
2400: oGetLocal 2
2402: oPushResult
2403: oScopeDeclare
2404: oPop 1
2406: oJumpForward 2416
2408: oJumpForward 2416
2410: Choice Lookup Table
           1   2408
           0   2400
2415: oEndChoice
2416: oGetLocal 2
2418: oPushResult
2419: oCall 1590
2421: oPop 1
2423: oGetLocal 2
2425: oReturn
2426: oReturn
2427: oLocalSpace 4
2429: oGetAddrLocal 1
2431: oPushResult
2432: oCall 2107
2434: oAssign
2435: oInputChoice 2448
2437: oJumpForward 2542
2439: oGetLocal 1
2441: oPushResult
2442: oCall 1668
2444: oPop 1
2446: oJumpForward 2542
2448: Choice Lookup Table
          65   2439
          64   2437
2453: oGetAddrLocal 2
2455: oPushResult
2456: oGetLocal 1
2458: oPushResult
2459: oSetResult 23
2461: oPushResult
2462: oNodeGet
2463: oPop 2
2465: oAssign
2466: oGetLocal 2
2468: oPushResult
2469: oScopeEnter
2470: oPop 1
2472: oGetAddrLocal 3
2474: oPushResult
2475: oGetLocal 2
2477: oPushResult
2478: oSetResult 14
2480: oPushResult
2481: oNodeGetInt
2482: oPop 2
2484: oAssign
2485: oGetLocal 3
2487: oPushResult
2488: oSetResult 1
2490: oPushResult
2491: oScopeBegin
2492: oPop 2
2494: oGetLocal 1
2496: oPushResult
2497: oSetResult 6
2499: oPushResult
2500: oScopeCurrent
2501: oPushResult
2502: oNodeSet
2503: oPop 3
2505: oGetAddrLocal 4
2507: oPushResult
2508: oGetLocal 1
2510: oPushResult
2511: oSetResult 22
2513: oPushResult
2514: oNodeGetLabel
2515: oPop 2
2517: oAssign
2518: oSetResult 17
2520: oPushResult
2521: oGetLocal 4
2523: oPushResult
2524: oCall 1250
2526: oPop 2
2528: oGetLocal 1
2530: oPushResult
2531: oSetResult 24
2533: oPushResult
2534: oSetResult 1
2536: oPushResult
2537: oNodeSetBoolean
2538: oPop 3
2540: oScopeEnd
2541: oScopeEnd
2542: oInput 4
2544: oReturn
2545: oLocalSpace 6
2547: oInputChoice 2768
2549: oGetAddrLocal 1
2551: oPushResult
2552: oNodeVecNew
2553: oAssign
2554: oGetAddrLocal 3
2556: oPushResult
2557: oSetResult 0
2559: oAssign
2560: oInputChoice 2570
2562: oGetAddrLocal 3
2564: oPushResult
2565: oSetResult 1
2567: oAssign
2568: oJumpForward 2573
2570: Choice Lookup Table
          32   2562
2573: oInput 0
2575: oGetAddrLocal 2
2577: oPushResult
2578: oSetResult 19
2580: oPushResult
2581: oSetResult 6
2583: oPushResult
2584: LAST_ID
2585: oPushResult
2586: oCall 7882
2588: oPop 3
2590: oAssign
2591: oGetLocal 2
2593: oPushResult
2594: oSetResult 32
2596: oPushResult
2597: oGetLocal 3
2599: oPushResult
2600: oNodeSetBoolean
2601: oPop 3
2603: oGetLocal 1
2605: oPushResult
2606: oGetLocal 2
2608: oPushResult
2609: oNodeVecAppend
2610: oPop 2
2612: oInputChoice 2620
2614: oJumpForward 2628
2616: oJumpForward 2626
2618: oJumpForward 2626
2620: Choice Lookup Table
          12   2618
          11   2614
2625: oEndChoice
2626: oJumpBack 2573
2628: oGetAddrLocal 4
2630: oPushResult
2631: oCall 3133
2633: oPop 1
2635: oGetLocal 3
2637: oChoice 2652
2639: oGetAddrLocal 5
2641: oPushResult
2642: oGetLocal 4
2644: oPushResult
2645: oCall 7910
2647: oPop 1
2649: oAssign
2650: oJumpForward 2661
2652: Choice Lookup Table
           1   2639
2655: oGetAddrLocal 5
2657: oPushResult
2658: oGetLocal 4
2660: oAssign
2661: oGetAddrLocal 6
2663: oPushResult
2664: oSetResult 0
2666: oAssign
2667: oGetLocal 6
2669: oPushResult
2670: oGetLocal 1
2672: oPushResult
2673: oNodeVecSize
2674: oPop 1
2676: oPushResult
2677: equal
2678: oPop 2
2680: oChoice 2737
2682: oGetAddrLocal 2
2684: oPushResult
2685: oGetLocal 1
2687: oPushResult
2688: oGetLocal 6
2690: oPushResult
2691: oNodeVecElement
2692: oPop 2
2694: oAssign
2695: oGetLocal 2
2697: oPushResult
2698: oSetResult 21
2700: oPushResult
2701: oGetLocal 4
2703: oPushResult
2704: oNodeSet
2705: oPop 3
2707: oGetLocal 2
2709: oPushResult
2710: oScopeDeclare
2711: oPop 1
2713: oGetLocal 2
2715: oPushResult
2716: oSetResult 22
2718: oPushResult
2719: oGetLocal 5
2721: oPushResult
2722: oScopeAllocType
2723: oPop 1
2725: oPushResult
2726: oNodeSetInt
2727: oPop 3
2729: oGetAddrLocal 6
2731: oPushResult
2732: inc
2733: oPop 1
2735: oJumpForward 2742
2737: Choice Lookup Table
           0   2682
2740: oJumpForward 2744
2742: oJumpBack 2667
2744: oGetLocal 1
2746: oPushResult
2747: oNodeVecDelete
2748: oPop 1
2750: oInputChoice 2758
2752: oJumpForward 2766
2754: oJumpForward 2764
2756: oJumpForward 2764
2758: Choice Lookup Table
           4   2756
          14   2752
2763: oEndChoice
2764: oJumpBack 2549
2766: oJumpForward 2771
2768: Choice Lookup Table
          13   2549
2771: oReturn
2772: oLocalSpace 2
2774: oInputChoice 2836
2776: oGetAddrLocal 1
2778: oPushResult
2779: oSetResult 13
2781: oPushResult
2782: oSetResult 4
2784: oPushResult
2785: LAST_ID
2786: oPushResult
2787: oCall 7882
2789: oPop 3
2791: oAssign
2792: oInput 5
2794: oCall 3610
2796: oGetAddrLocal 2
2798: oPushResult
2799: oValueTop
2800: oAssign
2801: oValuePop
2802: oGetLocal 1
2804: oPushResult
2805: oSetResult 22
2807: oPushResult
2808: oGetLocal 2
2810: oPushResult
2811: oNodeSetInt
2812: oPop 3
2814: oGetLocal 1
2816: oPushResult
2817: oSetResult 21
2819: oPushResult
2820: oGetGlobal 4
2822: oPushResult
2823: oNodeSet
2824: oPop 3
2826: oGetLocal 1
2828: oPushResult
2829: oScopeDeclare
2830: oPop 1
2832: oInput 4
2834: oJumpForward 2841
2836: Choice Lookup Table
           0   2776
2839: oJumpForward 2843
2841: oJumpBack 2774
2843: oReturn
2844: oLocalSpace 2
2846: oInputChoice 2895
2848: oGetAddrLocal 1
2850: oPushResult
2851: oSetResult 14
2853: oPushResult
2854: oSetResult 5
2856: oPushResult
2857: LAST_ID
2858: oPushResult
2859: oCall 7882
2861: oPop 3
2863: oAssign
2864: oInput 5
2866: oGetAddrLocal 2
2868: oPushResult
2869: oCall 3133
2871: oPop 1
2873: oGetLocal 1
2875: oPushResult
2876: oSetResult 21
2878: oPushResult
2879: oGetLocal 2
2881: oPushResult
2882: oNodeSet
2883: oPop 3
2885: oGetLocal 1
2887: oPushResult
2888: oScopeDeclare
2889: oPop 1
2891: oInput 4
2893: oJumpForward 2900
2895: Choice Lookup Table
           0   2848
2898: oJumpForward 2902
2900: oJumpBack 2846
2902: oReturn
2903: oLocalSpace 6
2905: oInputChoice 3125
2907: oGetAddrLocal 1
2909: oPushResult
2910: oNodeVecNew
2911: oAssign
2912: oGetAddrLocal 2
2914: oPushResult
2915: oGetParam 1
2917: oPushResult
2918: oSetResult 6
2920: oPushResult
2921: LAST_ID
2922: oPushResult
2923: oCall 7882
2925: oPop 3
2927: oAssign
2928: oGetLocal 1
2930: oPushResult
2931: oGetLocal 2
2933: oPushResult
2934: oNodeVecAppend
2935: oPop 2
2937: oInputChoice 2943
2939: oInput 0
2941: oJumpForward 2948
2943: Choice Lookup Table
          12   2939
2946: oJumpForward 2950
2948: oJumpBack 2912
2950: oInput 11
2952: oGetAddrLocal 3
2954: oPushResult
2955: oCall 3133
2957: oPop 1
2959: oGetAddrLocal 4
2961: oPushResult
2962: oSetResult 0
2964: oAssign
2965: oGetLocal 4
2967: oPushResult
2968: oGetLocal 1
2970: oPushResult
2971: oNodeVecSize
2972: oPop 1
2974: oPushResult
2975: equal
2976: oPop 2
2978: oChoice 3019
2980: oGetAddrLocal 2
2982: oPushResult
2983: oGetLocal 1
2985: oPushResult
2986: oGetLocal 4
2988: oPushResult
2989: oNodeVecElement
2990: oPop 2
2992: oAssign
2993: oGetLocal 2
2995: oPushResult
2996: oSetResult 21
2998: oPushResult
2999: oGetLocal 3
3001: oPushResult
3002: oNodeSet
3003: oPop 3
3005: oGetLocal 2
3007: oPushResult
3008: oScopeDeclareAlloc
3009: oPop 1
3011: oGetAddrLocal 4
3013: oPushResult
3014: inc
3015: oPop 1
3017: oJumpForward 3024
3019: Choice Lookup Table
           0   2980
3022: oJumpForward 3026
3024: oJumpBack 2965
3026: oInputChoice 3112
3028: oGetLocal 1
3030: oPushResult
3031: oNodeVecSize
3032: oPop 1
3034: oChoice 3038
3036: oJumpForward 3043
3038: Choice Lookup Table
           1   3036
3041: oError 22
3043: oGetAddrLocal 5
3045: oPushResult
3046: oCall 1618
3048: oAssign
3049: oGetLocal 5
3051: oPushResult
3052: oCodePush
3053: oPop 1
3055: oGetAddrLocal 6
3057: oPushResult
3058: oSetResult 0
3060: oAssign
3061: oCall 7718
3063: oPushResult
3064: equal_zero
3065: oPop 1
3067: oChoice 3083
3069: oGetGlobal 2
3071: oPushResult
3072: oScopeEnter
3073: oPop 1
3075: oGetAddrLocal 6
3077: oPushResult
3078: oSetResult 1
3080: oAssign
3081: oJumpForward 3086
3083: Choice Lookup Table
           1   3069
3086: oGetLocal 2
3088: oPushResult
3089: oCall 7037
3091: oPop 1
3093: oCall 3676
3095: oCall 7768
3097: oCall 6831
3099: oGetLocal 6
3101: oChoice 3106
3103: oScopeEnd
3104: oJumpForward 3109
3106: Choice Lookup Table
           1   3103
3109: oCodePop
3110: oJumpForward 3115
3112: Choice Lookup Table
           5   3028
3115: oGetLocal 1
3117: oPushResult
3118: oNodeVecDelete
3119: oPop 1
3121: oInput 4
3123: oJumpForward 3130
3125: Choice Lookup Table
           0   2907
3128: oJumpForward 3132
3130: oJumpBack 2905
3132: oReturn
3133: oLocalSpace 12
3135: oInputChoice 3592
3137: oGetAddrLocal 1
3139: oPushResult
3140: oScopeFindRequire
3141: oAssign
3142: oGetLocal 1
3144: oPushResult
3145: oNodeType
3146: oPop 1
3148: oChoice 3165
3150: oGetParam 1
3152: oPushResult
3153: oGetLocal 1
3155: oPushResult
3156: oSetResult 21
3158: oPushResult
3159: oNodeGet
3160: oPop 2
3162: oAssign
3163: oJumpForward 3176
3165: Choice Lookup Table
          14   3150
3168: oError 2
3170: oGetParam 1
3172: oPushResult
3173: oGetGlobal 4
3175: oAssign
3176: oJumpForward 3609
3178: oInput 15
3180: oGetAddrLocal 2
3182: oPushResult
3183: oNodeVecNew
3184: oAssign
3185: oGetAddrLocal 3
3187: oPushResult
3188: oSetResult 29
3190: oPushResult
3191: oNodeNew
3192: oPop 1
3194: oAssign
3195: oGetLocal 3
3197: oPushResult
3198: oSetResult 34
3200: oPushResult
3201: oGetGlobal 4
3203: oPushResult
3204: oNodeSet
3205: oPop 3
3207: oCall 3610
3209: oGetLocal 3
3211: oPushResult
3212: oSetResult 36
3214: oPushResult
3215: oValueTop
3216: oPushResult
3217: oNodeSetInt
3218: oPop 3
3220: oValuePop
3221: oInput 20
3223: oCall 3610
3225: oGetLocal 3
3227: oPushResult
3228: oSetResult 37
3230: oPushResult
3231: oValueTop
3232: oPushResult
3233: oNodeSetInt
3234: oPop 3
3236: oValuePop
3237: oGetLocal 3
3239: oPushResult
3240: oSetResult 17
3242: oPushResult
3243: oSetResult 4
3245: oPushResult
3246: oNodeSetInt
3247: oPop 3
3249: oGetLocal 3
3251: oPushResult
3252: oTypeAdd
3253: oPop 1
3255: oGetAddrLocal 4
3257: oPushResult
3258: oSetResult 28
3260: oPushResult
3261: oNodeNew
3262: oPop 1
3264: oAssign
3265: oGetLocal 4
3267: oPushResult
3268: oSetResult 35
3270: oPushResult
3271: oGetLocal 3
3273: oPushResult
3274: oNodeSet
3275: oPop 3
3277: oGetLocal 2
3279: oPushResult
3280: oGetLocal 4
3282: oPushResult
3283: oNodeVecAppend
3284: oPop 2
3286: oInputChoice 3294
3288: oJumpForward 3302
3290: oJumpForward 3300
3292: oJumpForward 3300
3294: Choice Lookup Table
          12   3292
          16   3288
3299: oEndChoice
3300: oJumpBack 3185
3302: oInput 38
3304: oGetAddrLocal 5
3306: oPushResult
3307: oCall 3133
3309: oPop 1
3311: oGetAddrLocal 6
3313: oPushResult
3314: oGetLocal 2
3316: oPushResult
3317: oNodeVecSize
3318: oPop 1
3320: oAssign
3321: oGetAddrLocal 6
3323: oPushResult
3324: dec
3325: oPop 1
3327: oGetAddrLocal 7
3329: oPushResult
3330: oGetLocal 2
3332: oPushResult
3333: oGetLocal 6
3335: oPushResult
3336: oNodeVecElement
3337: oPop 2
3339: oAssign
3340: oGetLocal 7
3342: oPushResult
3343: oSetResult 34
3345: oPushResult
3346: oGetLocal 5
3348: oPushResult
3349: oNodeSet
3350: oPop 3
3352: oGetAddrLocal 8
3354: oPushResult
3355: oGetLocal 7
3357: oPushResult
3358: oSetResult 35
3360: oPushResult
3361: oNodeGet
3362: oPop 2
3364: oAssign
3365: oGetAddrLocal 9
3367: oPushResult
3368: oGetLocal 8
3370: oPushResult
3371: oSetResult 37
3373: oPushResult
3374: oNodeGetInt
3375: oPop 2
3377: oPushResult
3378: oGetLocal 8
3380: oPushResult
3381: oSetResult 36
3383: oPushResult
3384: oNodeGetInt
3385: oPop 2
3387: oPushResult
3388: subtract
3389: oPop 2
3391: oAssign
3392: oGetAddrLocal 9
3394: oPushResult
3395: inc
3396: oPop 1
3398: oGetLocal 7
3400: oPushResult
3401: oSetResult 17
3403: oPushResult
3404: oGetLocal 9
3406: oPushResult
3407: oGetLocal 5
3409: oPushResult
3410: oSetResult 17
3412: oPushResult
3413: oNodeGetInt
3414: oPop 2
3416: oPushResult
3417: multiply
3418: oPop 2
3420: oPushResult
3421: oNodeSetInt
3422: oPop 3
3424: oGetLocal 7
3426: oPushResult
3427: oTypeAdd
3428: oPop 1
3430: oGetAddrLocal 5
3432: oPushResult
3433: oGetLocal 7
3435: oAssign
3436: oGetLocal 6
3438: oPushResult
3439: equal_zero
3440: oPop 1
3442: oChoice 3448
3444: oJumpForward 3453
3446: oJumpForward 3451
3448: Choice Lookup Table
           1   3444
3451: oJumpBack 3321
3453: oGetParam 1
3455: oPushResult
3456: oGetLocal 2
3458: oPushResult
3459: oSetResult 0
3461: oPushResult
3462: oNodeVecElement
3463: oPop 2
3465: oAssign
3466: oGetLocal 2
3468: oPushResult
3469: oNodeVecDelete
3470: oPop 1
3472: oJumpForward 3609
3474: oGetAddrLocal 10
3476: oPushResult
3477: oCall 3133
3479: oPop 1
3481: oGetParam 1
3483: oPushResult
3484: oGetLocal 10
3486: oPushResult
3487: oCall 7910
3489: oPop 1
3491: oAssign
3492: oJumpForward 3609
3494: oGetParam 1
3496: oPushResult
3497: oSetResult 30
3499: oPushResult
3500: oNodeNew
3501: oPop 1
3503: oAssign
3504: oSetResult -1
3506: oPushResult
3507: oSetResult 2
3509: oPushResult
3510: oScopeBegin
3511: oPop 2
3513: oSetResult 18
3515: oPushResult
3516: oCall 2903
3518: oPop 1
3520: oGetAddrLocal 11
3522: oPushResult
3523: oScopeCurrent
3524: oPushResult
3525: oSetResult 17
3527: oPushResult
3528: oNodeGetInt
3529: oPop 2
3531: oAssign
3532: oGetLocal 11
3534: oPushResult
3535: equal_zero
3536: oPop 1
3538: oChoice 3544
3540: oError 19
3542: oJumpForward 3547
3544: Choice Lookup Table
           1   3540
3547: oInput 34
3549: oGetFromParam 1
3551: oPushResult
3552: oSetResult 38
3554: oPushResult
3555: oScopeCurrent
3556: oPushResult
3557: oNodeSet
3558: oPop 3
3560: oGetFromParam 1
3562: oPushResult
3563: oSetResult 17
3565: oPushResult
3566: oGetLocal 11
3568: oPushResult
3569: oNodeSetInt
3570: oPop 3
3572: oScopeEnd
3573: oGetFromParam 1
3575: oPushResult
3576: oTypeAdd
3577: oPop 1
3579: oJumpForward 3609
3581: oInput 38
3583: oGetAddrLocal 12
3585: oPushResult
3586: oCall 3133
3588: oPop 1
3590: oJumpForward 3609
3592: Choice Lookup Table
          37   3581
          36   3494
          17   3474
          35   3178
           0   3137
3603: oCall 3610
3605: oInput 20
3607: oCall 3610
3609: oReturn
3610: oLocalSpace 1
3612: oInputChoice 3667
3614: TOKEN_VALUE
3615: oPushResult
3616: oValuePush
3617: oPop 1
3619: oJumpForward 3675
3621: oGetAddrLocal 1
3623: oPushResult
3624: oScopeFindRequire
3625: oAssign
3626: oGetLocal 1
3628: oPushResult
3629: oNodeType
3630: oPop 1
3632: oChoice 3649
3634: oGetLocal 1
3636: oPushResult
3637: oSetResult 22
3639: oPushResult
3640: oNodeGetInt
3641: oPop 2
3643: oPushResult
3644: oValuePush
3645: oPop 1
3647: oJumpForward 3660
3649: Choice Lookup Table
          13   3634
3652: oError 1
3654: oSetResult 0
3656: oPushResult
3657: oValuePush
3658: oPop 1
3660: oJumpForward 3675
3662: oCall 3610
3664: oValueNegate
3665: oJumpForward 3675
3667: Choice Lookup Table
          24   3662
           0   3621
           1   3614
3674: oEndChoice
3675: oReturn
3676: oLocalSpace 1
3678: oGetAddrLocal 1
3680: oPushResult
3681: oSetResult 0
3683: oAssign
3684: oGetAddrLocal 1
3686: oPushResult
3687: oCall 3837
3689: oPop 1
3691: oGetAddrLocal 1
3693: oPushResult
3694: oCall 3737
3696: oPop 1
3698: oReturn
3699: oLocalSpace 0
3701: oGetParam 1
3703: oPushResult
3704: oCall 3837
3706: oPop 1
3708: oTypeSNodeType
3709: oChoice 3728
3711: oJumpForward 3735
3713: oGetParam 1
3715: oPushResult
3716: oLabelNew
3717: oAssign
3718: oEmit 55
3720: oGetFromParam 1
3722: oPushResult
3723: oEmitLabel
3724: oPop 1
3726: oJumpForward 3735
3728: Choice Lookup Table
          23   3713
          24   3711
3733: oError 8
3735: oTypeSPop
3736: oReturn
3737: oLocalSpace 1
3739: oTypeSNodeType
3740: oChoice 3802
3742: oGetAddrLocal 1
3744: oPushResult
3745: oLabelNew
3746: oAssign
3747: oEmit 15
3749: oSetResult 1
3751: oPushResult
3752: oEmitInt
3753: oPop 1
3755: oEmit 53
3757: oGetLocal 1
3759: oPushResult
3760: oEmitLabel
3761: oPop 1
3763: oEmit 56
3765: oGetFromParam 1
3767: oPushResult
3768: oEmitLabel
3769: oPop 1
3771: oEmit 15
3773: oSetResult 0
3775: oPushResult
3776: oEmitInt
3777: oPop 1
3779: oEmit 56
3781: oGetLocal 1
3783: oPushResult
3784: oEmitLabel
3785: oPop 1
3787: oTypeSPop
3788: oGetGlobal 5
3790: oPushResult
3791: oTypeSPush
3792: oPop 1
3794: oGetParam 1
3796: oPushResult
3797: oSetResult 0
3799: oAssign
3800: oJumpForward 3805
3802: Choice Lookup Table
          24   3742
3805: oReturn
3806: oLocalSpace 0
3808: oTypeSNodeType
3809: oChoice 3833
3811: oGetParam 1
3813: oPushResult
3814: oLabelNew
3815: oAssign
3816: oEmit 55
3818: oGetFromParam 1
3820: oPushResult
3821: oEmitLabel
3822: oPop 1
3824: oTypeSPop
3825: oGetGlobal 6
3827: oPushResult
3828: oTypeSPush
3829: oPop 1
3831: oJumpForward 3836
3833: Choice Lookup Table
          23   3811
3836: oReturn
3837: oLocalSpace 0
3839: oGetParam 1
3841: oPushResult
3842: oCall 4202
3844: oPop 1
3846: oInputChoice 4184
3848: oGetParam 1
3850: oPushResult
3851: oCall 3737
3853: oPop 1
3855: oGetParam 1
3857: oPushResult
3858: oCall 4202
3860: oPop 1
3862: oGetParam 1
3864: oPushResult
3865: oCall 3737
3867: oPop 1
3869: oCall 7768
3871: oTypeSNodeType
3872: oChoice 3886
3874: oEmit 38
3876: oJumpForward 3899
3878: oEmit 44
3880: oJumpForward 3899
3882: oError 16
3884: oJumpForward 3899
3886: Choice Lookup Table
          26   3882
          25   3882
          27   3878
          23   3874
          22   3874
3897: oError 17
3899: oTypeSPop
3900: oGetGlobal 5
3902: oPushResult
3903: oTypeSPush
3904: oPop 1
3906: oJumpForward 4199
3908: oGetParam 1
3910: oPushResult
3911: oCall 3737
3913: oPop 1
3915: oGetParam 1
3917: oPushResult
3918: oCall 4202
3920: oPop 1
3922: oGetParam 1
3924: oPushResult
3925: oCall 3737
3927: oPop 1
3929: oCall 7768
3931: oTypeSNodeType
3932: oChoice 3946
3934: oEmit 39
3936: oJumpForward 3959
3938: oEmit 45
3940: oJumpForward 3959
3942: oError 16
3944: oJumpForward 3959
3946: Choice Lookup Table
          26   3942
          25   3942
          27   3938
          23   3934
          22   3934
3957: oError 17
3959: oTypeSPop
3960: oGetGlobal 5
3962: oPushResult
3963: oTypeSPush
3964: oPop 1
3966: oJumpForward 4199
3968: oGetParam 1
3970: oPushResult
3971: oCall 3737
3973: oPop 1
3975: oGetParam 1
3977: oPushResult
3978: oCall 4202
3980: oPop 1
3982: oGetParam 1
3984: oPushResult
3985: oCall 3737
3987: oPop 1
3989: oCall 7768
3991: oTypeSNodeType
3992: oChoice 4002
3994: oEmit 41
3996: oJumpForward 4013
3998: oError 16
4000: oJumpForward 4013
4002: Choice Lookup Table
          26   3998
          25   3998
          23   3994
          22   3994
4011: oError 17
4013: oTypeSPop
4014: oGetGlobal 5
4016: oPushResult
4017: oTypeSPush
4018: oPop 1
4020: oJumpForward 4199
4022: oGetParam 1
4024: oPushResult
4025: oCall 3737
4027: oPop 1
4029: oGetParam 1
4031: oPushResult
4032: oCall 4202
4034: oPop 1
4036: oGetParam 1
4038: oPushResult
4039: oCall 3737
4041: oPop 1
4043: oCall 7768
4045: oTypeSNodeType
4046: oChoice 4056
4048: oEmit 40
4050: oJumpForward 4067
4052: oError 16
4054: oJumpForward 4067
4056: Choice Lookup Table
          26   4052
          25   4052
          23   4048
          22   4048
4065: oError 17
4067: oTypeSPop
4068: oGetGlobal 5
4070: oPushResult
4071: oTypeSPush
4072: oPop 1
4074: oJumpForward 4199
4076: oGetParam 1
4078: oPushResult
4079: oCall 3737
4081: oPop 1
4083: oGetParam 1
4085: oPushResult
4086: oCall 4202
4088: oPop 1
4090: oGetParam 1
4092: oPushResult
4093: oCall 3737
4095: oPop 1
4097: oCall 7768
4099: oTypeSNodeType
4100: oChoice 4110
4102: oEmit 43
4104: oJumpForward 4121
4106: oError 16
4108: oJumpForward 4121
4110: Choice Lookup Table
          26   4106
          25   4106
          23   4102
          22   4102
4119: oError 17
4121: oTypeSPop
4122: oGetGlobal 5
4124: oPushResult
4125: oTypeSPush
4126: oPop 1
4128: oJumpForward 4199
4130: oGetParam 1
4132: oPushResult
4133: oCall 3737
4135: oPop 1
4137: oGetParam 1
4139: oPushResult
4140: oCall 4202
4142: oPop 1
4144: oGetParam 1
4146: oPushResult
4147: oCall 3737
4149: oPop 1
4151: oCall 7768
4153: oTypeSNodeType
4154: oChoice 4164
4156: oEmit 42
4158: oJumpForward 4175
4160: oError 16
4162: oJumpForward 4175
4164: Choice Lookup Table
          26   4160
          25   4160
          23   4156
          22   4156
4173: oError 17
4175: oTypeSPop
4176: oGetGlobal 5
4178: oPushResult
4179: oTypeSPush
4180: oPop 1
4182: oJumpForward 4199
4184: Choice Lookup Table
          10   4130
           9   4076
           8   4022
           7   3968
           6   3908
           5   3848
4197: oJumpForward 4201
4199: oJumpBack 3846
4201: oReturn
4202: oLocalSpace 1
4204: oGetAddrLocal 1
4206: oPushResult
4207: oSetResult 0
4209: oAssign
4210: oGetParam 1
4212: oPushResult
4213: oCall 4382
4215: oPop 1
4217: oInputChoice 4350
4219: oTypeSNodeType
4220: oChoice 4291
4222: oGetLocal 1
4224: oPushResult
4225: oSetResult 0
4227: oPushResult
4228: equal_label
4229: oPop 2
4231: oChoice 4240
4233: oGetAddrLocal 1
4235: oPushResult
4236: oLabelNew
4237: oAssign
4238: oJumpForward 4243
4240: Choice Lookup Table
           1   4233
4243: oEmit 53
4245: oGetLocal 1
4247: oPushResult
4248: oEmitLabel
4249: oPop 1
4251: oJumpForward 4298
4253: oGetParam 1
4255: oPushResult
4256: oCall 3806
4258: oPop 1
4260: oGetLocal 1
4262: oPushResult
4263: oSetResult 0
4265: oPushResult
4266: equal_label
4267: oPop 2
4269: oChoice 4278
4271: oGetAddrLocal 1
4273: oPushResult
4274: oLabelNew
4275: oAssign
4276: oJumpForward 4281
4278: Choice Lookup Table
           1   4271
4281: oEmit 53
4283: oGetLocal 1
4285: oPushResult
4286: oEmitLabel
4287: oPop 1
4289: oJumpForward 4298
4291: Choice Lookup Table
          23   4253
          24   4222
4296: oError 8
4298: oTypeSPop
4299: oEmit 56
4301: oGetFromParam 1
4303: oPushResult
4304: oEmitLabel
4305: oPop 1
4307: oGetParam 1
4309: oPushResult
4310: oSetResult 0
4312: oAssign
4313: oGetParam 1
4315: oPushResult
4316: oCall 4382
4318: oPop 1
4320: oTypeSNodeType
4321: oChoice 4334
4323: oJumpForward 4341
4325: oGetParam 1
4327: oPushResult
4328: oCall 3806
4330: oPop 1
4332: oJumpForward 4341
4334: Choice Lookup Table
          23   4325
          24   4323
4339: oError 8
4341: oTypeSPop
4342: oGetGlobal 6
4344: oPushResult
4345: oTypeSPush
4346: oPop 1
4348: oJumpForward 4355
4350: Choice Lookup Table
          52   4219
4353: oJumpForward 4357
4355: oJumpBack 4217
4357: oGetLocal 1
4359: oPushResult
4360: oSetResult 0
4362: oPushResult
4363: equal_label
4364: oPop 2
4366: oChoice 4378
4368: oEmit 56
4370: oGetLocal 1
4372: oPushResult
4373: oEmitLabel
4374: oPop 1
4376: oJumpForward 4381
4378: Choice Lookup Table
           0   4368
4381: oReturn
4382: oLocalSpace 2
4384: oGetAddrLocal 1
4386: oPushResult
4387: oSetResult 0
4389: oAssign
4390: oGetParam 1
4392: oPushResult
4393: oCall 4520
4395: oPop 1
4397: oInputChoice 4512
4399: oTypeSNodeType
4400: oChoice 4413
4402: oJumpForward 4420
4404: oGetParam 1
4406: oPushResult
4407: oCall 3806
4409: oPop 1
4411: oJumpForward 4420
4413: Choice Lookup Table
          23   4404
          24   4402
4418: oError 8
4420: oTypeSPop
4421: oGetLocal 1
4423: oPushResult
4424: oSetResult 0
4426: oPushResult
4427: equal_label
4428: oPop 2
4430: oChoice 4459
4432: oGetAddrLocal 1
4434: oPushResult
4435: oLabelNew
4436: oAssign
4437: oEmit 57
4439: oGetFromParam 1
4441: oPushResult
4442: oEmitLabel
4443: oPop 1
4445: oGetLocal 1
4447: oPushResult
4448: oEmitLabel
4449: oPop 1
4451: oGetParam 1
4453: oPushResult
4454: oGetLocal 1
4456: oAssign
4457: oJumpForward 4462
4459: Choice Lookup Table
           1   4432
4462: oGetAddrLocal 2
4464: oPushResult
4465: oSetResult 0
4467: oAssign
4468: oGetAddrLocal 2
4470: oPushResult
4471: oCall 4520
4473: oPop 1
4475: oTypeSNodeType
4476: oChoice 4489
4478: oJumpForward 4496
4480: oGetAddrLocal 2
4482: oPushResult
4483: oCall 3806
4485: oPop 1
4487: oJumpForward 4496
4489: Choice Lookup Table
          23   4480
          24   4478
4494: oError 8
4496: oEmit 57
4498: oGetLocal 2
4500: oPushResult
4501: oEmitLabel
4502: oPop 1
4504: oGetLocal 1
4506: oPushResult
4507: oEmitLabel
4508: oPop 1
4510: oJumpForward 4517
4512: Choice Lookup Table
          51   4399
4515: oJumpForward 4519
4517: oJumpBack 4397
4519: oReturn
4520: oLocalSpace 1
4522: oInputChoice 4576
4524: oGetAddrLocal 1
4526: oPushResult
4527: oSetResult 0
4529: oAssign
4530: oGetAddrLocal 1
4532: oPushResult
4533: oCall 4520
4535: oPop 1
4537: oTypeSNodeType
4538: oChoice 4567
4540: oGetParam 1
4542: oPushResult
4543: oLabelNew
4544: oAssign
4545: oEmit 53
4547: oGetFromParam 1
4549: oPushResult
4550: oEmitLabel
4551: oPop 1
4553: oEmit 56
4555: oGetLocal 1
4557: oPushResult
4558: oEmitLabel
4559: oPop 1
4561: oJumpForward 4574
4563: oEmit 37
4565: oJumpForward 4574
4567: Choice Lookup Table
          23   4563
          24   4540
4572: oError 8
4574: oJumpForward 4586
4576: Choice Lookup Table
          53   4524
4579: oGetParam 1
4581: oPushResult
4582: oCall 4587
4584: oPop 1
4586: oReturn
4587: oLocalSpace 0
4589: oGetParam 1
4591: oPushResult
4592: oCall 4638
4594: oPop 1
4596: oInputChoice 4628
4598: oCall 7794
4600: oGetParam 1
4602: oPushResult
4603: oCall 4638
4605: oPop 1
4607: oCall 7808
4609: oEmit 34
4611: oJumpForward 4635
4613: oCall 7794
4615: oGetParam 1
4617: oPushResult
4618: oCall 4638
4620: oPop 1
4622: oCall 7808
4624: oEmit 35
4626: oJumpForward 4635
4628: Choice Lookup Table
          24   4613
          23   4598
4633: oJumpForward 4637
4635: oJumpBack 4596
4637: oReturn
4638: oLocalSpace 0
4640: oGetParam 1
4642: oPushResult
4643: oCall 4689
4645: oPop 1
4647: oInputChoice 4679
4649: oCall 7794
4651: oGetParam 1
4653: oPushResult
4654: oCall 4689
4656: oPop 1
4658: oCall 7808
4660: oEmit 31
4662: oJumpForward 4686
4664: oCall 7794
4666: oGetParam 1
4668: oPushResult
4669: oCall 4689
4671: oPop 1
4673: oCall 7808
4675: oEmit 32
4677: oJumpForward 4686
4679: Choice Lookup Table
          22   4664
          21   4649
4684: oJumpForward 4688
4686: oJumpBack 4647
4688: oReturn
4689: oLocalSpace 0
4691: oInputChoice 4717
4693: oGetParam 1
4695: oPushResult
4696: oCall 4730
4698: oPop 1
4700: oCall 7808
4702: oJumpForward 4729
4704: oGetParam 1
4706: oPushResult
4707: oCall 4730
4709: oPop 1
4711: oCall 7808
4713: oEmit 36
4715: oJumpForward 4729
4717: Choice Lookup Table
          24   4704
          23   4693
4722: oGetParam 1
4724: oPushResult
4725: oCall 4730
4727: oPop 1
4729: oReturn
4730: oLocalSpace 6
4732: oInputChoice 4918
4734: oEmit 15
4736: TOKEN_VALUE
4737: oPushResult
4738: oEmitInt
4739: oPop 1
4741: oGetGlobal 4
4743: oPushResult
4744: oTypeSPush
4745: oPop 1
4747: oJumpForward 4937
4749: oGetParam 1
4751: oPushResult
4752: oCall 3837
4754: oPop 1
4756: oInput 14
4758: oJumpForward 4937
4760: oGetAddrLocal 1
4762: oPushResult
4763: CURRENT_STRLIT
4764: oPushResult
4765: oStringAllocLit
4766: oPop 1
4768: oAssign
4769: oEmit 16
4771: oGetLocal 1
4773: oPushResult
4774: oEmitInt
4775: oPop 1
4777: oGetGlobal 8
4779: oPushResult
4780: oTypeSPush
4781: oPop 1
4783: oJumpForward 4937
4785: oGetAddrLocal 2
4787: oPushResult
4788: oScopeFindRequire
4789: oAssign
4790: oGetLocal 2
4792: oPushResult
4793: oNodeType
4794: oPop 1
4796: oChoice 4858
4798: oGetLocal 2
4800: oPushResult
4801: oCall 6090
4803: oPop 1
4805: oJumpForward 4877
4807: oGetAddrLocal 3
4809: oPushResult
4810: oGetLocal 2
4812: oPushResult
4813: oSetResult 21
4815: oPushResult
4816: oNodeGet
4817: oPop 2
4819: oAssign
4820: oGetLocal 3
4822: oPushResult
4823: oTypeSPush
4824: oPop 1
4826: oTypeSNodeType
4827: oChoice 4840
4829: oEmit 15
4831: oGetLocal 2
4833: oPushResult
4834: oCall 8045
4836: oPop 1
4838: oJumpForward 4847
4840: Choice Lookup Table
          23   4829
          22   4829
4845: oError 16
4847: oJumpForward 4877
4849: oGetLocal 2
4851: oPushResult
4852: oCall 4938
4854: oPop 1
4856: oJumpForward 4877
4858: Choice Lookup Table
          19   4849
          17   4849
          16   4849
          13   4807
          12   4798
4869: oError 6
4871: oGetGlobal 4
4873: oPushResult
4874: oTypeSPush
4875: oPop 1
4877: oJumpForward 4937
4879: oInput 0
4881: oGetAddrLocal 4
4883: oPushResult
4884: oScopeFindRequire
4885: oAssign
4886: oGetLocal 4
4888: oPushResult
4889: oCall 7037
4891: oPop 1
4893: oGetAddrLocal 5
4895: oPushResult
4896: oTypeSTop
4897: oAssign
4898: oTypeSPop
4899: oGetAddrLocal 6
4901: oPushResult
4902: oGetLocal 5
4904: oPushResult
4905: oCall 7910
4907: oPop 1
4909: oAssign
4910: oGetLocal 6
4912: oPushResult
4913: oTypeSPush
4914: oPop 1
4916: oJumpForward 4937
4918: Choice Lookup Table
          18   4879
           0   4785
           2   4760
          13   4749
           1   4734
4929: oError 6
4931: oGetGlobal 4
4933: oPushResult
4934: oTypeSPush
4935: oPop 1
4937: oReturn
4938: oLocalSpace 2
4940: oGetAddrLocal 1
4942: oPushResult
4943: oGetParam 1
4945: oPushResult
4946: oSetResult 21
4948: oPushResult
4949: oNodeGet
4950: oPop 2
4952: oAssign
4953: oGetAddrLocal 2
4955: oPushResult
4956: oGetParam 1
4958: oPushResult
4959: oCall 7750
4961: oPop 1
4963: oAssign
4964: oGetLocal 1
4966: oPushResult
4967: oTypeSPush
4968: oPop 1
4970: oTypeSNodeType
4971: oChoice 5488
4973: oGetParam 1
4975: oPushResult
4976: oNodeType
4977: oPop 1
4979: oChoice 5125
4981: oEmit 0
4983: oGetParam 1
4985: oPushResult
4986: oCall 8045
4988: oPop 1
4990: oJumpForward 5133
4992: oGetLocal 2
4994: oPushResult
4995: equal_zero
4996: oPop 1
4998: oChoice 5011
5000: oEmit 3
5002: oGetParam 1
5004: oPushResult
5005: oCall 8045
5007: oPop 1
5009: oJumpForward 5029
5011: Choice Lookup Table
           1   5000
5014: oEmit 9
5016: oGetLocal 2
5018: oPushResult
5019: oEmitInt
5020: oPop 1
5022: oGetParam 1
5024: oPushResult
5025: oCall 8045
5027: oPop 1
5029: oJumpForward 5133
5031: oGetParam 1
5033: oPushResult
5034: oSetResult 32
5036: oPushResult
5037: oNodeGetBoolean
5038: oPop 2
5040: oChoice 5083
5042: oGetLocal 2
5044: oPushResult
5045: equal_zero
5046: oPop 1
5048: oChoice 5061
5050: oEmit 8
5052: oGetParam 1
5054: oPushResult
5055: oCall 8045
5057: oPop 1
5059: oJumpForward 5079
5061: Choice Lookup Table
           1   5050
5064: oEmit 14
5066: oGetLocal 2
5068: oPushResult
5069: oEmitInt
5070: oPop 1
5072: oGetParam 1
5074: oPushResult
5075: oCall 8045
5077: oPop 1
5079: oEmit 22
5081: oJumpForward 5123
5083: Choice Lookup Table
           1   5042
5086: oGetLocal 2
5088: oPushResult
5089: equal_zero
5090: oPop 1
5092: oChoice 5105
5094: oEmit 6
5096: oGetParam 1
5098: oPushResult
5099: oCall 8045
5101: oPop 1
5103: oJumpForward 5123
5105: Choice Lookup Table
           1   5094
5108: oEmit 12
5110: oGetLocal 2
5112: oPushResult
5113: oEmitInt
5114: oPop 1
5116: oGetParam 1
5118: oPushResult
5119: oCall 8045
5121: oPop 1
5123: oJumpForward 5133
5125: Choice Lookup Table
          19   5031
          17   4992
          16   4981
5132: oEndChoice
5133: oJumpForward 5663
5135: oGetParam 1
5137: oPushResult
5138: oNodeType
5139: oPop 1
5141: oChoice 5287
5143: oEmit 1
5145: oGetParam 1
5147: oPushResult
5148: oCall 8045
5150: oPop 1
5152: oJumpForward 5295
5154: oGetLocal 2
5156: oPushResult
5157: equal_zero
5158: oPop 1
5160: oChoice 5173
5162: oEmit 4
5164: oGetParam 1
5166: oPushResult
5167: oCall 8045
5169: oPop 1
5171: oJumpForward 5191
5173: Choice Lookup Table
           1   5162
5176: oEmit 10
5178: oGetLocal 2
5180: oPushResult
5181: oEmitInt
5182: oPop 1
5184: oGetParam 1
5186: oPushResult
5187: oCall 8045
5189: oPop 1
5191: oJumpForward 5295
5193: oGetParam 1
5195: oPushResult
5196: oSetResult 32
5198: oPushResult
5199: oNodeGetBoolean
5200: oPop 2
5202: oChoice 5245
5204: oGetLocal 2
5206: oPushResult
5207: equal_zero
5208: oPop 1
5210: oChoice 5223
5212: oEmit 8
5214: oGetParam 1
5216: oPushResult
5217: oCall 8045
5219: oPop 1
5221: oJumpForward 5241
5223: Choice Lookup Table
           1   5212
5226: oEmit 14
5228: oGetLocal 2
5230: oPushResult
5231: oEmitInt
5232: oPop 1
5234: oGetParam 1
5236: oPushResult
5237: oCall 8045
5239: oPop 1
5241: oEmit 23
5243: oJumpForward 5285
5245: Choice Lookup Table
           1   5204
5248: oGetLocal 2
5250: oPushResult
5251: equal_zero
5252: oPop 1
5254: oChoice 5267
5256: oEmit 7
5258: oGetParam 1
5260: oPushResult
5261: oCall 8045
5263: oPop 1
5265: oJumpForward 5285
5267: Choice Lookup Table
           1   5256
5270: oEmit 13
5272: oGetLocal 2
5274: oPushResult
5275: oEmitInt
5276: oPop 1
5278: oGetParam 1
5280: oPushResult
5281: oCall 8045
5283: oPop 1
5285: oJumpForward 5295
5287: Choice Lookup Table
          19   5193
          17   5154
          16   5143
5294: oEndChoice
5295: oJumpForward 5663
5297: oError 16
5299: oJumpForward 5663
5301: oGetParam 1
5303: oPushResult
5304: oNodeType
5305: oPop 1
5307: oChoice 5453
5309: oEmit 2
5311: oGetParam 1
5313: oPushResult
5314: oCall 8045
5316: oPop 1
5318: oJumpForward 5461
5320: oGetLocal 2
5322: oPushResult
5323: equal_zero
5324: oPop 1
5326: oChoice 5339
5328: oEmit 5
5330: oGetParam 1
5332: oPushResult
5333: oCall 8045
5335: oPop 1
5337: oJumpForward 5357
5339: Choice Lookup Table
           1   5328
5342: oEmit 11
5344: oGetLocal 2
5346: oPushResult
5347: oEmitInt
5348: oPop 1
5350: oGetParam 1
5352: oPushResult
5353: oCall 8045
5355: oPop 1
5357: oJumpForward 5461
5359: oGetParam 1
5361: oPushResult
5362: oSetResult 32
5364: oPushResult
5365: oNodeGetBoolean
5366: oPop 2
5368: oChoice 5411
5370: oGetLocal 2
5372: oPushResult
5373: equal_zero
5374: oPop 1
5376: oChoice 5389
5378: oEmit 8
5380: oGetParam 1
5382: oPushResult
5383: oCall 8045
5385: oPop 1
5387: oJumpForward 5407
5389: Choice Lookup Table
           1   5378
5392: oEmit 14
5394: oGetLocal 2
5396: oPushResult
5397: oEmitInt
5398: oPop 1
5400: oGetParam 1
5402: oPushResult
5403: oCall 8045
5405: oPop 1
5407: oEmit 24
5409: oJumpForward 5451
5411: Choice Lookup Table
           1   5370
5414: oGetLocal 2
5416: oPushResult
5417: equal_zero
5418: oPop 1
5420: oChoice 5433
5422: oEmit 8
5424: oGetParam 1
5426: oPushResult
5427: oCall 8045
5429: oPop 1
5431: oJumpForward 5451
5433: Choice Lookup Table
           1   5422
5436: oEmit 14
5438: oGetLocal 2
5440: oPushResult
5441: oEmitInt
5442: oPop 1
5444: oGetParam 1
5446: oPushResult
5447: oCall 8045
5449: oPop 1
5451: oJumpForward 5461
5453: Choice Lookup Table
          19   5359
          17   5320
          16   5309
5460: oEndChoice
5461: oInputChoice 5483
5463: oTypeSPop
5464: oGetLocal 1
5466: oPushResult
5467: oSetResult 34
5469: oPushResult
5470: oNodeGet
5471: oPop 2
5473: oPushResult
5474: oTypeSPush
5475: oPop 1
5477: oCall 5699
5479: oCall 5664
5481: oJumpForward 5486
5483: Choice Lookup Table
          17   5463
5486: oJumpForward 5663
5488: Choice Lookup Table
          27   5301
          21   5297
          26   5297
          25   5297
          23   5135
          22   4973
5501: oGetParam 1
5503: oPushResult
5504: oNodeType
5505: oPop 1
5507: oChoice 5651
5509: oEmit 16
5511: oGetParam 1
5513: oPushResult
5514: oCall 8045
5516: oPop 1
5518: oJumpForward 5659
5520: oGetLocal 2
5522: oPushResult
5523: equal_zero
5524: oPop 1
5526: oChoice 5539
5528: oEmit 17
5530: oGetParam 1
5532: oPushResult
5533: oCall 8045
5535: oPop 1
5537: oJumpForward 5557
5539: Choice Lookup Table
           1   5528
5542: oEmit 20
5544: oGetLocal 2
5546: oPushResult
5547: oEmitInt
5548: oPop 1
5550: oGetParam 1
5552: oPushResult
5553: oCall 8045
5555: oPop 1
5557: oJumpForward 5659
5559: oGetParam 1
5561: oPushResult
5562: oSetResult 32
5564: oPushResult
5565: oNodeGetBoolean
5566: oPop 2
5568: oChoice 5609
5570: oGetLocal 2
5572: oPushResult
5573: equal_zero
5574: oPop 1
5576: oChoice 5589
5578: oEmit 8
5580: oGetParam 1
5582: oPushResult
5583: oCall 8045
5585: oPop 1
5587: oJumpForward 5607
5589: Choice Lookup Table
           1   5578
5592: oEmit 14
5594: oGetLocal 2
5596: oPushResult
5597: oEmitInt
5598: oPop 1
5600: oGetParam 1
5602: oPushResult
5603: oCall 8045
5605: oPop 1
5607: oJumpForward 5649
5609: Choice Lookup Table
           1   5570
5612: oGetLocal 2
5614: oPushResult
5615: equal_zero
5616: oPop 1
5618: oChoice 5631
5620: oEmit 18
5622: oGetParam 1
5624: oPushResult
5625: oCall 8045
5627: oPop 1
5629: oJumpForward 5649
5631: Choice Lookup Table
           1   5620
5634: oEmit 21
5636: oGetLocal 2
5638: oPushResult
5639: oEmitInt
5640: oPop 1
5642: oGetParam 1
5644: oPushResult
5645: oCall 8045
5647: oPop 1
5649: oJumpForward 5659
5651: Choice Lookup Table
          19   5559
          17   5520
          16   5509
5658: oEndChoice
5659: oCall 5699
5661: oCall 5664
5663: oReturn
5664: oLocalSpace 0
5666: oTypeSNodeType
5667: oChoice 5685
5669: oEmit 22
5671: oJumpForward 5698
5673: oEmit 23
5675: oJumpForward 5698
5677: oError 16
5679: oJumpForward 5698
5681: oEmit 24
5683: oJumpForward 5698
5685: Choice Lookup Table
          27   5681
          21   5677
          26   5677
          25   5677
          23   5673
          22   5669
5698: oReturn
5699: oLocalSpace 0
5701: oInputChoice 5715
5703: oCall 5727
5705: oJumpForward 5724
5707: oCall 5870
5709: oJumpForward 5724
5711: oCall 5968
5713: oJumpForward 5724
5715: Choice Lookup Table
          17   5711
          19   5707
          15   5703
5722: oJumpForward 5726
5724: oJumpBack 5701
5726: oReturn
5727: oLocalSpace 3
5729: oTypeSNodeType
5730: oChoice 5734
5732: oJumpForward 5739
5734: Choice Lookup Table
          28   5732
5737: oError 10
5739: oTypeSNodeType
5740: oChoice 5744
5742: oJumpForward 5749
5744: Choice Lookup Table
          28   5742
5747: oError 13
5749: oGetAddrLocal 1
5751: oPushResult
5752: oTypeSTop
5753: oPushResult
5754: oSetResult 35
5756: oPushResult
5757: oNodeGet
5758: oPop 2
5760: oPushResult
5761: oCall 7994
5763: oPop 1
5765: oAssign
5766: oGetAddrLocal 2
5768: oPushResult
5769: oTypeSTop
5770: oPushResult
5771: oSetResult 34
5773: oPushResult
5774: oNodeGet
5775: oPop 2
5777: oAssign
5778: oTypeSPop
5779: oGetLocal 2
5781: oPushResult
5782: oTypeSPush
5783: oPop 1
5785: oCall 3676
5787: oCall 7794
5789: oGetLocal 1
5791: oPushResult
5792: equal_zero
5793: oPop 1
5795: oChoice 5809
5797: oEmit 15
5799: oGetLocal 1
5801: oPushResult
5802: oEmitInt
5803: oPop 1
5805: oEmit 35
5807: oJumpForward 5812
5809: Choice Lookup Table
           0   5797
5812: oGetAddrLocal 3
5814: oPushResult
5815: oGetLocal 2
5817: oPushResult
5818: oSetResult 17
5820: oPushResult
5821: oNodeGetInt
5822: oPop 2
5824: oAssign
5825: oGetLocal 3
5827: oPushResult
5828: oSetResult 1
5830: oPushResult
5831: equal
5832: oPop 2
5834: oChoice 5848
5836: oEmit 15
5838: oGetLocal 3
5840: oPushResult
5841: oEmitInt
5842: oPop 1
5844: oEmit 31
5846: oJumpForward 5851
5848: Choice Lookup Table
           0   5836
5851: oEmit 33
5853: oInputChoice 5861
5855: oJumpForward 5869
5857: oJumpForward 5867
5859: oJumpForward 5867
5861: Choice Lookup Table
          12   5859
          16   5855
5866: oEndChoice
5867: oJumpBack 5739
5869: oReturn
5870: oLocalSpace 2
5872: oTypeSNodeType
5873: oChoice 5877
5875: oJumpForward 5882
5877: Choice Lookup Table
          30   5875
5880: oError 11
5882: oTypeSTop
5883: oPushResult
5884: oSetResult 38
5886: oPushResult
5887: oNodeGet
5888: oPop 2
5890: oPushResult
5891: oScopeEnter
5892: oPop 1
5894: oInput 0
5896: oGetAddrLocal 1
5898: oPushResult
5899: oScopeFindRequire
5900: oAssign
5901: oGetLocal 1
5903: oPushResult
5904: oNodeType
5905: oPop 1
5907: oChoice 5911
5909: oJumpForward 5916
5911: Choice Lookup Table
          18   5909
5914: oError 12
5916: oScopeEnd
5917: oGetAddrLocal 2
5919: oPushResult
5920: oGetLocal 1
5922: oPushResult
5923: oSetResult 22
5925: oPushResult
5926: oNodeGetInt
5927: oPop 2
5929: oAssign
5930: oGetLocal 2
5932: oPushResult
5933: equal_zero
5934: oPop 1
5936: oChoice 5950
5938: oEmit 15
5940: oGetLocal 2
5942: oPushResult
5943: oEmitInt
5944: oPop 1
5946: oEmit 33
5948: oJumpForward 5953
5950: Choice Lookup Table
           0   5938
5953: oTypeSPop
5954: oGetLocal 1
5956: oPushResult
5957: oSetResult 21
5959: oPushResult
5960: oNodeGet
5961: oPop 2
5963: oPushResult
5964: oTypeSPush
5965: oPop 1
5967: oReturn
5968: oLocalSpace 1
5970: oTypeSNodeType
5971: oChoice 5975
5973: oJumpForward 5980
5975: Choice Lookup Table
          27   5973
5978: oError 9
5980: oEmit 24
5982: oGetAddrLocal 1
5984: oPushResult
5985: oTypeSTop
5986: oAssign
5987: oTypeSPop
5988: oGetLocal 1
5990: oPushResult
5991: oSetResult 34
5993: oPushResult
5994: oNodeGet
5995: oPop 2
5997: oPushResult
5998: oTypeSPush
5999: oPop 1
6001: oReturn
6002: oLocalSpace 0
6004: oCall 7768
6006: oReturn
6007: oLocalSpace 2
6009: oGetAddrLocal 2
6011: oPushResult
6012: oGetParam 1
6014: oPushResult
6015: oSetResult 26
6017: oPushResult
6018: oNodeGetString
6019: oPop 2
6021: oAssign
6022: oGetLocal 2
6024: oPushResult
6025: oSetResult 0
6027: oPushResult
6028: equal_string
6029: oPop 2
6031: oChoice 6068
6033: oGetAddrLocal 1
6035: oPushResult
6036: oGetParam 1
6038: oPushResult
6039: oSetResult 4
6041: oPushResult
6042: oNodeGetInt
6043: oPop 2
6045: oPushResult
6046: ID_STRING
6047: oPop 1
6049: oPushResult
6050: oStringAllocLit
6051: oPop 1
6053: oAssign
6054: oJumpForward 6074
6056: oGetAddrLocal 1
6058: oPushResult
6059: oGetLocal 2
6061: oPushResult
6062: oStringAllocLit
6063: oPop 1
6065: oAssign
6066: oJumpForward 6074
6068: Choice Lookup Table
           0   6056
           1   6033
6073: oEndChoice
6074: oEmit 58
6076: oGetParam 1
6078: oPushResult
6079: oCall 8045
6081: oPop 1
6083: oGetLocal 1
6085: oPushResult
6086: oEmitInt
6087: oPop 1
6089: oReturn
6090: oLocalSpace 10
6092: oGetParam 1
6094: oPushResult
6095: oSetResult 25
6097: oPushResult
6098: oNodeGetBoolean
6099: oPop 2
6101: oChoice 6128
6103: oGetParam 1
6105: oPushResult
6106: oSetResult 28
6108: oPushResult
6109: oNodeGetBoolean
6110: oPop 2
6112: oChoice 6123
6114: oGetParam 1
6116: oPushResult
6117: oCall 6007
6119: oPop 1
6121: oJumpForward 6126
6123: Choice Lookup Table
           0   6114
6126: oJumpForward 6131
6128: Choice Lookup Table
           1   6103
6131: oGetParam 1
6133: oPushResult
6134: oSetResult 28
6136: oPushResult
6137: oSetResult 1
6139: oPushResult
6140: oNodeSetBoolean
6141: oPop 3
6143: oGetAddrLocal 1
6145: oPushResult
6146: oGetParam 1
6148: oPushResult
6149: oSetResult 27
6151: oPushResult
6152: oNodeGetBoolean
6153: oPop 2
6155: oAssign
6156: oGetAddrLocal 4
6158: oPushResult
6159: oGetParam 1
6161: oPushResult
6162: oNodeType
6163: oPop 1
6165: oPushResult
6166: oSetResult 12
6168: oPushResult
6169: equal_node_type
6170: oPop 2
6172: oAssign
6173: oGetLocal 4
6175: oChoice 6202
6177: oGetAddrLocal 2
6179: oPushResult
6180: oGetParam 1
6182: oPushResult
6183: oSetResult 21
6185: oPushResult
6186: oNodeGet
6187: oPop 2
6189: oAssign
6190: oGetAddrLocal 3
6192: oPushResult
6193: oGetLocal 2
6195: oPushResult
6196: oScopeAllocType
6197: oPop 1
6199: oAssign
6200: oJumpForward 6205
6202: Choice Lookup Table
           1   6177
6205: oGetAddrLocal 5
6207: oPushResult
6208: oGetParam 1
6210: oPushResult
6211: oSetResult 23
6213: oPushResult
6214: oNodeGet
6215: oPop 2
6217: oAssign
6218: oGetAddrLocal 6
6220: oPushResult
6221: oGetLocal 5
6223: oPushResult
6224: oSetResult 17
6226: oPushResult
6227: oNodeGetInt
6228: oPop 2
6230: oAssign
6231: oGetLocal 1
6233: oChoice 6255
6235: oEmit 47
6237: oGetLocal 6
6239: oPushResult
6240: oEmitInt
6241: oPop 1
6243: oJumpForward 6261
6245: oEmit 46
6247: oGetLocal 6
6249: oPushResult
6250: oEmitInt
6251: oPop 1
6253: oJumpForward 6261
6255: Choice Lookup Table
           0   6245
           1   6235
6260: oEndChoice
6261: oGetParam 1
6263: oPushResult
6264: oCall 7730
6266: oPop 1
6268: oPushResult
6269: oSetResult 0
6271: oPushResult
6272: greater
6273: oPop 2
6275: oChoice 6308
6277: oEmit 19
6279: oSetResult 0
6281: oPushResult
6282: oEmitInt
6283: oPop 1
6285: oEmit 20
6287: oGetParam 1
6289: oPushResult
6290: oCall 7750
6292: oPop 1
6294: oPushResult
6295: oEmitInt
6296: oPop 1
6298: oSetResult 0
6300: oPushResult
6301: oEmitInt
6302: oPop 1
6304: oEmit 27
6306: oJumpForward 6311
6308: Choice Lookup Table
           1   6277
6311: oGetAddrLocal 7
6313: oPushResult
6314: oGetLocal 5
6316: oPushResult
6317: oSetResult 15
6319: oPushResult
6320: oNodeGetIter
6321: oPop 2
6323: oAssign
6324: oGetAddrLocal 8
6326: oPushResult
6327: oGetLocal 7
6329: oPushResult
6330: oNodeIterValue
6331: oPop 1
6333: oAssign
6334: oInputChoice 6513
6336: oGetLocal 8
6338: oPushResult
6339: oNodeNull
6340: oPop 1
6342: oChoice 6348
6344: oJumpForward 6509
6346: oJumpForward 6351
6348: Choice Lookup Table
           1   6344
6351: oGetAddrLocal 9
6353: oPushResult
6354: oGetLocal 8
6356: oPushResult
6357: oSetResult 22
6359: oPushResult
6360: oNodeGetInt
6361: oPop 2
6363: oAssign
6364: oEmit 19
6366: oGetLocal 9
6368: oPushResult
6369: oEmitInt
6370: oPop 1
6372: oGetLocal 8
6374: oPushResult
6375: oSetResult 21
6377: oPushResult
6378: oNodeGet
6379: oPop 2
6381: oPushResult
6382: oTypeSPush
6383: oPop 1
6385: oGetLocal 8
6387: oPushResult
6388: oSetResult 32
6390: oPushResult
6391: oNodeGetBoolean
6392: oPop 2
6394: oChoice 6462
6396: oCall 7001
6398: oCall 7768
6400: oEmit 27
6402: oJumpForward 6468
6404: oCall 3676
6406: oCall 6002
6408: oTypeSNodeType
6409: oChoice 6427
6411: oEmit 25
6413: oJumpForward 6460
6415: oEmit 26
6417: oJumpForward 6460
6419: oError 16
6421: oJumpForward 6460
6423: oEmit 27
6425: oJumpForward 6460
6427: Choice Lookup Table
          27   6423
          21   6419
          26   6419
          25   6419
          23   6415
          22   6411
6440: oGetAddrLocal 10
6442: oPushResult
6443: oTypeSTop
6444: oPushResult
6445: oSetResult 17
6447: oPushResult
6448: oNodeGetInt
6449: oPop 2
6451: oAssign
6452: oEmit 28
6454: oGetLocal 10
6456: oPushResult
6457: oEmitInt
6458: oPop 1
6460: oJumpForward 6468
6462: Choice Lookup Table
           0   6404
           1   6396
6467: oEndChoice
6468: oTypeSPop
6469: oGetAddrLocal 7
6471: oPushResult
6472: oNodeIterNext
6473: oPop 1
6475: oGetAddrLocal 8
6477: oPushResult
6478: oGetLocal 7
6480: oPushResult
6481: oNodeIterValue
6482: oPop 1
6484: oAssign
6485: oGetLocal 8
6487: oPushResult
6488: oNodeNull
6489: oPop 1
6491: oChoice 6499
6493: oJumpForward 6509
6495: oJumpForward 6505
6497: oJumpForward 6505
6499: Choice Lookup Table
           0   6497
           1   6493
6504: oEndChoice
6505: oInput 12
6507: oJumpBack 6336
6509: oInput 14
6511: oJumpForward 6516
6513: Choice Lookup Table
          13   6336
6516: oGetLocal 8
6518: oPushResult
6519: oNodeNull
6520: oPop 1
6522: oChoice 6528
6524: oError 15
6526: oJumpForward 6531
6528: Choice Lookup Table
           0   6524
6531: oGetLocal 4
6533: oChoice 6562
6535: oEmit 19
6537: oGetParam 1
6539: oPushResult
6540: oSetResult 31
6542: oPushResult
6543: oNodeGetInt
6544: oPop 2
6546: oPushResult
6547: oEmitInt
6548: oPop 1
6550: oEmit 17
6552: oGetLocal 3
6554: oPushResult
6555: oEmitInt
6556: oPop 1
6558: oEmit 27
6560: oJumpForward 6565
6562: Choice Lookup Table
           1   6535
6565: oGetLocal 1
6567: oChoice 6591
6569: oEmit 50
6571: oGetParam 1
6573: oPushResult
6574: oCall 8045
6576: oPop 1
6578: oJumpForward 6597
6580: oEmit 49
6582: oGetParam 1
6584: oPushResult
6585: oCall 8045
6587: oPop 1
6589: oJumpForward 6597
6591: Choice Lookup Table
           0   6580
           1   6569
6596: oEndChoice
6597: oGetLocal 4
6599: oChoice 6667
6601: oGetLocal 2
6603: oPushResult
6604: oTypeSPush
6605: oPop 1
6607: oTypeSNodeType
6608: oChoice 6644
6610: oEmit 3
6612: oGetLocal 3
6614: oPushResult
6615: oEmitInt
6616: oPop 1
6618: oJumpForward 6665
6620: oEmit 4
6622: oGetLocal 3
6624: oPushResult
6625: oEmitInt
6626: oPop 1
6628: oJumpForward 6665
6630: oError 16
6632: oJumpForward 6665
6634: oEmit 5
6636: oGetLocal 3
6638: oPushResult
6639: oEmitInt
6640: oPop 1
6642: oJumpForward 6665
6644: Choice Lookup Table
          27   6634
          21   6630
          26   6630
          25   6630
          23   6620
          22   6610
6657: oEmit 17
6659: oGetLocal 3
6661: oPushResult
6662: oEmitInt
6663: oPop 1
6665: oJumpForward 6670
6667: Choice Lookup Table
           1   6601
6670: oEmit 48
6672: oGetLocal 6
6674: oPushResult
6675: oEmitInt
6676: oPop 1
6678: oReturn
6679: oLocalSpace 0
6681: oInputChoice 6731
6683: oCall 7638
6685: oJumpForward 6756
6687: oCall 7645
6689: oJumpForward 6756
6691: oCall 7712
6693: oJumpForward 6756
6695: oCall 7715
6697: oJumpForward 6756
6699: oCall 7178
6701: oJumpForward 6756
6703: oCall 7498
6705: oJumpForward 6756
6707: oCall 7244
6709: oJumpForward 6756
6711: oCall 7418
6713: oJumpForward 6756
6715: oCall 7583
6717: oJumpForward 6756
6719: oCall 7551
6721: oJumpForward 6756
6723: oCall 7615
6725: oJumpForward 6756
6727: oCall 6757
6729: oJumpForward 6756
6731: Choice Lookup Table
           0   6727
          33   6723
          49   6719
          50   6715
          47   6711
          42   6707
          46   6703
          39   6699
          63   6695
          62   6691
          61   6687
          60   6683
6756: oReturn
6757: oLocalSpace 1
6759: oGetAddrLocal 1
6761: oPushResult
6762: oScopeFindRequire
6763: oAssign
6764: oGetLocal 1
6766: oPushResult
6767: oNodeType
6768: oPop 1
6770: oChoice 6799
6772: oGetLocal 1
6774: oPushResult
6775: oCall 6090
6777: oPop 1
6779: oJumpForward 6812
6781: oGetLocal 1
6783: oPushResult
6784: oCall 6813
6786: oPop 1
6788: oJumpForward 6812
6790: oGetLocal 1
6792: oPushResult
6793: oCall 6887
6795: oPop 1
6797: oJumpForward 6812
6799: Choice Lookup Table
          12   6790
          19   6781
          17   6781
          16   6781
          11   6772
6810: oError 0
6812: oReturn
6813: oLocalSpace 0
6815: oGetParam 1
6817: oPushResult
6818: oCall 7037
6820: oPop 1
6822: oInput 3
6824: oCall 3676
6826: oCall 7768
6828: oCall 6831
6830: oReturn
6831: oLocalSpace 1
6833: oTypeSNodeType
6834: oChoice 6852
6836: oEmit 25
6838: oJumpForward 6885
6840: oEmit 26
6842: oJumpForward 6885
6844: oError 16
6846: oJumpForward 6885
6848: oEmit 27
6850: oJumpForward 6885
6852: Choice Lookup Table
          27   6848
          21   6844
          26   6844
          25   6844
          23   6840
          22   6836
6865: oGetAddrLocal 1
6867: oPushResult
6868: oTypeSTop
6869: oPushResult
6870: oSetResult 17
6872: oPushResult
6873: oNodeGetInt
6874: oPop 2
6876: oAssign
6877: oEmit 28
6879: oGetLocal 1
6881: oPushResult
6882: oEmitInt
6883: oPop 1
6885: oTypeSPop
6886: oReturn
6887: oLocalSpace 1
6889: oGetParam 1
6891: oPushResult
6892: oSetResult 6
6894: oPushResult
6895: oNodeGet
6896: oPop 2
6898: oPushResult
6899: oScopeCurrent
6900: oPushResult
6901: oNodeEqual
6902: oPop 2
6904: oChoice 6910
6906: oError 20
6908: oJumpForward 6913
6910: Choice Lookup Table
           0   6906
6913: oEmit 8
6915: oGetParam 1
6917: oPushResult
6918: oSetResult 31
6920: oPushResult
6921: oNodeGetInt
6922: oPop 2
6924: oPushResult
6925: oEmitInt
6926: oPop 1
6928: oGetParam 1
6930: oPushResult
6931: oSetResult 21
6933: oPushResult
6934: oNodeGet
6935: oPop 2
6937: oPushResult
6938: oTypeSPush
6939: oPop 1
6941: oInput 3
6943: oCall 3676
6945: oCall 7768
6947: oTypeSNodeType
6948: oChoice 6966
6950: oEmit 25
6952: oJumpForward 6999
6954: oEmit 26
6956: oJumpForward 6999
6958: oError 16
6960: oJumpForward 6999
6962: oEmit 27
6964: oJumpForward 6999
6966: Choice Lookup Table
          27   6962
          21   6958
          26   6958
          25   6958
          23   6954
          22   6950
6979: oGetAddrLocal 1
6981: oPushResult
6982: oTypeSTop
6983: oPushResult
6984: oSetResult 17
6986: oPushResult
6987: oNodeGetInt
6988: oPop 2
6990: oAssign
6991: oEmit 28
6993: oGetLocal 1
6995: oPushResult
6996: oEmitInt
6997: oPop 1
6999: oTypeSPop
7000: oReturn
7001: oLocalSpace 1
7003: oInput 0
7005: oGetAddrLocal 1
7007: oPushResult
7008: oScopeFindRequire
7009: oAssign
7010: oGetLocal 1
7012: oPushResult
7013: oNodeType
7014: oPop 1
7016: oChoice 7020
7018: oJumpForward 7029
7020: Choice Lookup Table
          19   7018
          17   7018
          16   7018
7027: oError 4
7029: oGetLocal 1
7031: oPushResult
7032: oCall 7037
7034: oPop 1
7036: oReturn
7037: oLocalSpace 0
7039: oGetParam 1
7041: oPushResult
7042: oNodeType
7043: oPop 1
7045: oChoice 7105
7047: oEmit 16
7049: oGetParam 1
7051: oPushResult
7052: oCall 8045
7054: oPop 1
7056: oJumpForward 7114
7058: oEmit 17
7060: oGetParam 1
7062: oPushResult
7063: oCall 8045
7065: oPop 1
7067: oJumpForward 7114
7069: oGetParam 1
7071: oPushResult
7072: oSetResult 32
7074: oPushResult
7075: oNodeGetBoolean
7076: oPop 2
7078: oChoice 7091
7080: oEmit 8
7082: oGetParam 1
7084: oPushResult
7085: oCall 8045
7087: oPop 1
7089: oJumpForward 7103
7091: Choice Lookup Table
           1   7080
7094: oEmit 18
7096: oGetParam 1
7098: oPushResult
7099: oCall 8045
7101: oPop 1
7103: oJumpForward 7114
7105: Choice Lookup Table
          19   7069
          17   7058
          16   7047
7112: oError 4
7114: oGetParam 1
7116: oPushResult
7117: oSetResult 21
7119: oPushResult
7120: oNodeGet
7121: oPop 2
7123: oPushResult
7124: oTypeSPush
7125: oPop 1
7127: oCall 5699
7129: oReturn
7130: oLocalSpace 0
7132: oGetParam 1
7134: oPushResult
7135: oCall 7037
7137: oPop 1
7139: oCall 7794
7141: oGetParam 1
7143: oPushResult
7144: oCall 4938
7146: oPop 1
7148: oTypeSPop
7149: oEmit 29
7151: oEmit 25
7153: oReturn
7154: oLocalSpace 0
7156: oGetParam 1
7158: oPushResult
7159: oCall 7037
7161: oPop 1
7163: oCall 7794
7165: oGetParam 1
7167: oPushResult
7168: oCall 4938
7170: oPop 1
7172: oTypeSPop
7173: oEmit 30
7175: oEmit 25
7177: oReturn
7178: oLocalSpace 2
7180: oGetAddrLocal 1
7182: oPushResult
7183: oSetResult 0
7185: oAssign
7186: oGetAddrLocal 1
7188: oPushResult
7189: oCall 3699
7191: oPop 1
7193: oInput 40
7195: oCall 6679
7197: oInputChoice 7232
7199: oGetAddrLocal 2
7201: oPushResult
7202: oLabelNew
7203: oAssign
7204: oEmit 53
7206: oGetLocal 2
7208: oPushResult
7209: oEmitLabel
7210: oPop 1
7212: oEmit 56
7214: oGetLocal 1
7216: oPushResult
7217: oEmitLabel
7218: oPop 1
7220: oCall 6679
7222: oEmit 56
7224: oGetLocal 2
7226: oPushResult
7227: oEmitLabel
7228: oPop 1
7230: oJumpForward 7243
7232: Choice Lookup Table
          41   7199
7235: oEmit 56
7237: oGetLocal 1
7239: oPushResult
7240: oEmitLabel
7241: oPop 1
7243: oReturn
7244: oLocalSpace 4
7246: oInput 0
7248: oGetAddrLocal 1
7250: oPushResult
7251: oScopeFindRequire
7252: oAssign
7253: oGetLocal 1
7255: oPushResult
7256: oCall 7037
7258: oPop 1
7260: oCall 7794
7262: oInput 3
7264: oCall 3676
7266: oCall 7794
7268: oEmit 25
7270: oGetAddrLocal 2
7272: oPushResult
7273: oLabelNew
7274: oAssign
7275: oGetAddrLocal 3
7277: oPushResult
7278: oLabelNew
7279: oAssign
7280: oEmit 53
7282: oGetLocal 3
7284: oPushResult
7285: oEmitLabel
7286: oPop 1
7288: oGetAddrLocal 4
7290: oPushResult
7291: oLabelNew
7292: oAssign
7293: oEmit 56
7295: oGetLocal 4
7297: oPushResult
7298: oEmitLabel
7299: oPop 1
7301: oInputChoice 7381
7303: oGetLocal 1
7305: oPushResult
7306: oCall 7130
7308: oPop 1
7310: oEmit 56
7312: oGetLocal 3
7314: oPushResult
7315: oEmitLabel
7316: oPop 1
7318: oGetLocal 1
7320: oPushResult
7321: oCall 4938
7323: oPop 1
7325: oTypeSPop
7326: oCall 3676
7328: oCall 7794
7330: oEmit 40
7332: oEmit 54
7334: oGetLocal 2
7336: oPushResult
7337: oEmitLabel
7338: oPop 1
7340: oJumpForward 7387
7342: oGetLocal 1
7344: oPushResult
7345: oCall 7154
7347: oPop 1
7349: oEmit 56
7351: oGetLocal 3
7353: oPushResult
7354: oEmitLabel
7355: oPop 1
7357: oGetLocal 1
7359: oPushResult
7360: oCall 4938
7362: oPop 1
7364: oTypeSPop
7365: oCall 3676
7367: oCall 7794
7369: oEmit 41
7371: oEmit 54
7373: oGetLocal 2
7375: oPushResult
7376: oEmitLabel
7377: oPop 1
7379: oJumpForward 7387
7381: Choice Lookup Table
          44   7342
          43   7303
7386: oEndChoice
7387: oGetLocal 4
7389: oPushResult
7390: oGetLocal 2
7392: oPushResult
7393: oLoopPush
7394: oPop 2
7396: oInput 45
7398: oCall 6679
7400: oEmit 53
7402: oGetLocal 4
7404: oPushResult
7405: oEmitLabel
7406: oPop 1
7408: oEmit 56
7410: oGetLocal 2
7412: oPushResult
7413: oEmitLabel
7414: oPop 1
7416: oLoopPop
7417: oReturn
7418: oLocalSpace 3
7420: oGetAddrLocal 1
7422: oPushResult
7423: oLabelNew
7424: oAssign
7425: oEmit 56
7427: oGetLocal 1
7429: oPushResult
7430: oEmitLabel
7431: oPop 1
7433: oGetAddrLocal 2
7435: oPushResult
7436: oLabelNew
7437: oAssign
7438: oGetLocal 1
7440: oPushResult
7441: oGetLocal 2
7443: oPushResult
7444: oLoopPush
7445: oPop 2
7447: oCall 6679
7449: oInputChoice 7480
7451: oCall 6679
7453: oJumpForward 7486
7455: oGetAddrLocal 3
7457: oPushResult
7458: oCall 3699
7460: oPop 1
7462: oEmit 57
7464: oGetLocal 3
7466: oPushResult
7467: oEmitLabel
7468: oPop 1
7470: oGetLocal 1
7472: oPushResult
7473: oEmitLabel
7474: oPop 1
7476: oJumpForward 7488
7478: oJumpForward 7486
7480: Choice Lookup Table
          48   7455
           4   7451
7485: oEndChoice
7486: oJumpBack 7449
7488: oEmit 56
7490: oGetLocal 2
7492: oPushResult
7493: oEmitLabel
7494: oPop 1
7496: oLoopPop
7497: oReturn
7498: oLocalSpace 2
7500: oGetAddrLocal 1
7502: oPushResult
7503: oLabelNew
7504: oAssign
7505: oEmit 56
7507: oGetLocal 1
7509: oPushResult
7510: oEmitLabel
7511: oPop 1
7513: oGetAddrLocal 2
7515: oPushResult
7516: oCall 3699
7518: oPop 1
7520: oGetLocal 1
7522: oPushResult
7523: oGetLocal 2
7525: oPushResult
7526: oLoopPush
7527: oPop 2
7529: oInput 45
7531: oCall 6679
7533: oEmit 53
7535: oGetLocal 1
7537: oPushResult
7538: oEmitLabel
7539: oPop 1
7541: oEmit 56
7543: oGetLocal 2
7545: oPushResult
7546: oEmitLabel
7547: oPop 1
7549: oLoopPop
7550: oReturn
7551: oLocalSpace 0
7553: oLoopContinueLabel
7554: oPushResult
7555: oSetResult 0
7557: oPushResult
7558: equal_label
7559: oPop 2
7561: oChoice 7576
7563: oError 18
7565: oJumpForward 7582
7567: oEmit 53
7569: oLoopContinueLabel
7570: oPushResult
7571: oEmitLabel
7572: oPop 1
7574: oJumpForward 7582
7576: Choice Lookup Table
           0   7567
           1   7563
7581: oEndChoice
7582: oReturn
7583: oLocalSpace 0
7585: oLoopBreakLabel
7586: oPushResult
7587: oSetResult 0
7589: oPushResult
7590: equal_label
7591: oPop 2
7593: oChoice 7608
7595: oError 18
7597: oJumpForward 7614
7599: oEmit 53
7601: oLoopBreakLabel
7602: oPushResult
7603: oEmitLabel
7604: oPop 1
7606: oJumpForward 7614
7608: Choice Lookup Table
           0   7599
           1   7595
7613: oEndChoice
7614: oReturn
7615: oLocalSpace 0
7617: oCall 6679
7619: oInputChoice 7629
7621: oCall 6679
7623: oJumpForward 7635
7625: oJumpForward 7637
7627: oJumpForward 7635
7629: Choice Lookup Table
          34   7625
           4   7621
7634: oEndChoice
7635: oJumpBack 7619
7637: oReturn
7638: oLocalSpace 0
7640: oCall 7645
7642: oEmit 63
7644: oReturn
7645: oLocalSpace 0
7647: oInputChoice 7708
7649: oCall 3676
7651: oTypeSNodeType
7652: oChoice 7674
7654: oEmit 59
7656: oJumpForward 7689
7658: oEmit 60
7660: oJumpForward 7689
7662: oEmit 61
7664: oJumpForward 7689
7666: oError 16
7668: oJumpForward 7689
7670: oEmit 62
7672: oJumpForward 7689
7674: Choice Lookup Table
          27   7670
          21   7666
          25   7666
          26   7662
          23   7658
          22   7654
7687: oError 17
7689: oTypeSPop
7690: oInputChoice 7698
7692: oJumpForward 7706
7694: oJumpForward 7704
7696: oJumpForward 7704
7698: Choice Lookup Table
          12   7696
          14   7692
7703: oEndChoice
7704: oJumpBack 7649
7706: oJumpForward 7711
7708: Choice Lookup Table
          13   7649
7711: oReturn
7712: oLocalSpace 0
7714: oReturn
7715: oLocalSpace 0
7717: oReturn
7718: oLocalSpace 0
7720: oScopeCurrent
7721: oPushResult
7722: oSetResult 14
7724: oPushResult
7725: oNodeGetInt
7726: oPop 2
7728: oReturn
7729: oReturn
7730: oLocalSpace 0
7732: oGetParam 1
7734: oPushResult
7735: oSetResult 20
7737: oPushResult
7738: oNodeGet
7739: oPop 2
7741: oPushResult
7742: oSetResult 14
7744: oPushResult
7745: oNodeGetInt
7746: oPop 2
7748: oReturn
7749: oReturn
7750: oLocalSpace 0
7752: oCall 7718
7754: oPushResult
7755: oGetParam 1
7757: oPushResult
7758: oCall 7730
7760: oPop 1
7762: oPushResult
7763: subtract
7764: oPop 2
7766: oReturn
7767: oReturn
7768: oLocalSpace 1
7770: oGetAddrLocal 1
7772: oPushResult
7773: oTypeSNodeType
7774: oAssign
7775: oTypeSPop
7776: oGetLocal 1
7778: oPushResult
7779: oTypeSNodeType
7780: oPushResult
7781: equal_node_type
7782: oPop 2
7784: oChoice 7790
7786: oError 14
7788: oJumpForward 7793
7790: Choice Lookup Table
           0   7786
7793: oReturn
7794: oLocalSpace 0
7796: oTypeSNodeType
7797: oChoice 7801
7799: oJumpForward 7806
7801: Choice Lookup Table
          22   7799
7804: oError 7
7806: oTypeSPop
7807: oReturn
7808: oLocalSpace 0
7810: oTypeSNodeType
7811: oChoice 7815
7813: oJumpForward 7820
7815: Choice Lookup Table
          22   7813
7818: oError 7
7820: oReturn
7821: oLocalSpace 0
7823: oTypeSNodeType
7824: oChoice 7828
7826: oJumpForward 7833
7828: Choice Lookup Table
          23   7826
7831: oError 8
7833: oTypeSPop
7834: oReturn
7835: oLocalSpace 0
7837: oTypeSNodeType
7838: oChoice 7842
7840: oJumpForward 7847
7842: Choice Lookup Table
          23   7840
7845: oError 8
7847: oReturn
7848: oLocalSpace 1
7850: oGetAddrLocal 1
7852: oPushResult
7853: oGetParam 2
7855: oPushResult
7856: oNodeNew
7857: oPop 1
7859: oAssign
7860: oGetLocal 1
7862: oPushResult
7863: oSetResult 17
7865: oPushResult
7866: oGetParam 1
7868: oPushResult
7869: oNodeSetInt
7870: oPop 3
7872: oGetLocal 1
7874: oPushResult
7875: oTypeAdd
7876: oPop 1
7878: oGetLocal 1
7880: oReturn
7881: oReturn
7882: oLocalSpace 1
7884: oGetAddrLocal 1
7886: oPushResult
7887: oGetParam 3
7889: oPushResult
7890: oNodeNew
7891: oPop 1
7893: oAssign
7894: oGetLocal 1
7896: oPushResult
7897: oSetResult 4
7899: oPushResult
7900: oGetParam 1
7902: oPushResult
7903: oNodeSetInt
7904: oPop 3
7906: oGetLocal 1
7908: oReturn
7909: oReturn
7910: oLocalSpace 1
7912: oGetAddrLocal 1
7914: oPushResult
7915: oGetParam 1
7917: oPushResult
7918: oSetResult 33
7920: oPushResult
7921: oNodeGet
7922: oPop 2
7924: oAssign
7925: oGetLocal 1
7927: oPushResult
7928: oNodeNull
7929: oPop 1
7931: oChoice 7987
7933: oGetAddrLocal 1
7935: oPushResult
7936: oSetResult 27
7938: oPushResult
7939: oNodeNew
7940: oPop 1
7942: oAssign
7943: oGetLocal 1
7945: oPushResult
7946: oSetResult 34
7948: oPushResult
7949: oGetParam 1
7951: oPushResult
7952: oNodeSet
7953: oPop 3
7955: oGetLocal 1
7957: oPushResult
7958: oSetResult 17
7960: oPushResult
7961: oSetResult 8
7963: oPushResult
7964: oNodeSetInt
7965: oPop 3
7967: oGetLocal 1
7969: oPushResult
7970: oTypeAdd
7971: oPop 1
7973: oGetParam 1
7975: oPushResult
7976: oSetResult 33
7978: oPushResult
7979: oGetLocal 1
7981: oPushResult
7982: oNodeSet
7983: oPop 3
7985: oJumpForward 7990
7987: Choice Lookup Table
           1   7933
7990: oGetLocal 1
7992: oReturn
7993: oReturn
7994: oLocalSpace 0
7996: oGetParam 1
7998: oPushResult
7999: oNodeType
8000: oPop 1
8002: oChoice 8030
8004: oMININT
8005: oReturn
8006: oJumpForward 8044
8008: oSetResult 0
8010: oReturn
8011: oJumpForward 8044
8013: oSetResult 0
8015: oReturn
8016: oJumpForward 8044
8018: oGetParam 1
8020: oPushResult
8021: oSetResult 36
8023: oPushResult
8024: oNodeGetInt
8025: oPop 2
8027: oReturn
8028: oJumpForward 8044
8030: Choice Lookup Table
          29   8018
          25   8013
          23   8008
          22   8004
8039: oError 3
8041: oSetResult 0
8043: oReturn
8044: oReturn
8045: oLocalSpace 0
8047: oGetParam 1
8049: oPushResult
8050: oSetResult 22
8052: oPushResult
8053: oNodeGetInt
8054: oPop 2
8056: oPushResult
8057: oEmitInt
8058: oPop 1
8060: oReturn
8061: oLocalSpace 1
8063: oGetAddrGlobal 3
8065: oPushResult
8066: oSetResult 21
8068: oPushResult
8069: oSetResult 4
8071: oPushResult
8072: oCall 7848
8074: oPop 2
8076: oAssign
8077: oGetAddrGlobal 4
8079: oPushResult
8080: oSetResult 22
8082: oPushResult
8083: oSetResult 4
8085: oPushResult
8086: oCall 7848
8088: oPop 2
8090: oAssign
8091: oGetAddrGlobal 5
8093: oPushResult
8094: oSetResult 23
8096: oPushResult
8097: oSetResult 1
8099: oPushResult
8100: oCall 7848
8102: oPop 2
8104: oAssign
8105: oGetAddrGlobal 6
8107: oPushResult
8108: oSetResult 24
8110: oPushResult
8111: oSetResult 1
8113: oPushResult
8114: oCall 7848
8116: oPop 2
8118: oAssign
8119: oGetAddrGlobal 7
8121: oPushResult
8122: oSetResult 25
8124: oPushResult
8125: oSetResult 1
8127: oPushResult
8128: oCall 7848
8130: oPop 2
8132: oAssign
8133: oGetAddrGlobal 8
8135: oPushResult
8136: oSetResult 26
8138: oPushResult
8139: oSetResult 256
8141: oPushResult
8142: oCall 7848
8144: oPop 2
8146: oAssign
8147: oGetAddrLocal 1
8149: oPushResult
8150: oSetResult 14
8152: oPushResult
8153: oSetResult 5
8155: oPushResult
8156: oIdAdd_File
8157: oPushResult
8158: oCall 7882
8160: oPop 3
8162: oAssign
8163: oGetLocal 1
8165: oPushResult
8166: oSetResult 21
8168: oPushResult
8169: oGetGlobal 3
8171: oPushResult
8172: oNodeSet
8173: oPop 3
8175: oGetLocal 1
8177: oPushResult
8178: oScopeDeclare
8179: oPop 1
8181: oGetAddrLocal 1
8183: oPushResult
8184: oSetResult 14
8186: oPushResult
8187: oSetResult 5
8189: oPushResult
8190: oIdAdd_Integer
8191: oPushResult
8192: oCall 7882
8194: oPop 3
8196: oAssign
8197: oGetLocal 1
8199: oPushResult
8200: oSetResult 21
8202: oPushResult
8203: oGetGlobal 4
8205: oPushResult
8206: oNodeSet
8207: oPop 3
8209: oGetLocal 1
8211: oPushResult
8212: oScopeDeclare
8213: oPop 1
8215: oGetAddrLocal 1
8217: oPushResult
8218: oSetResult 14
8220: oPushResult
8221: oSetResult 5
8223: oPushResult
8224: oIdAdd_Boolean
8225: oPushResult
8226: oCall 7882
8228: oPop 3
8230: oAssign
8231: oGetLocal 1
8233: oPushResult
8234: oSetResult 21
8236: oPushResult
8237: oGetGlobal 5
8239: oPushResult
8240: oNodeSet
8241: oPop 3
8243: oGetLocal 1
8245: oPushResult
8246: oScopeDeclare
8247: oPop 1
8249: oGetAddrLocal 1
8251: oPushResult
8252: oSetResult 14
8254: oPushResult
8255: oSetResult 5
8257: oPushResult
8258: oIdAdd_Char
8259: oPushResult
8260: oCall 7882
8262: oPop 3
8264: oAssign
8265: oGetLocal 1
8267: oPushResult
8268: oSetResult 21
8270: oPushResult
8271: oGetGlobal 7
8273: oPushResult
8274: oNodeSet
8275: oPop 3
8277: oGetLocal 1
8279: oPushResult
8280: oScopeDeclare
8281: oPop 1
8283: oGetAddrLocal 1
8285: oPushResult
8286: oSetResult 14
8288: oPushResult
8289: oSetResult 5
8291: oPushResult
8292: oIdAdd_String
8293: oPushResult
8294: oCall 7882
8296: oPop 3
8298: oAssign
8299: oGetLocal 1
8301: oPushResult
8302: oSetResult 21
8304: oPushResult
8305: oGetGlobal 8
8307: oPushResult
8308: oNodeSet
8309: oPop 3
8311: oGetLocal 1
8313: oPushResult
8314: oScopeDeclare
8315: oPop 1
8317: oGetAddrLocal 1
8319: oPushResult
8320: oSetResult 13
8322: oPushResult
8323: oSetResult 4
8325: oPushResult
8326: oIdAdd_True
8327: oPushResult
8328: oCall 7882
8330: oPop 3
8332: oAssign
8333: oGetLocal 1
8335: oPushResult
8336: oSetResult 21
8338: oPushResult
8339: oGetGlobal 5
8341: oPushResult
8342: oNodeSet
8343: oPop 3
8345: oGetLocal 1
8347: oPushResult
8348: oSetResult 22
8350: oPushResult
8351: oSetResult 1
8353: oPushResult
8354: oNodeSetInt
8355: oPop 3
8357: oGetLocal 1
8359: oPushResult
8360: oScopeDeclare
8361: oPop 1
8363: oGetAddrLocal 1
8365: oPushResult
8366: oSetResult 13
8368: oPushResult
8369: oSetResult 4
8371: oPushResult
8372: oIdAdd_False
8373: oPushResult
8374: oCall 7882
8376: oPop 3
8378: oAssign
8379: oGetLocal 1
8381: oPushResult
8382: oSetResult 21
8384: oPushResult
8385: oGetGlobal 5
8387: oPushResult
8388: oNodeSet
8389: oPop 3
8391: oGetLocal 1
8393: oPushResult
8394: oSetResult 22
8396: oPushResult
8397: oSetResult 0
8399: oPushResult
8400: oNodeSetInt
8401: oPop 3
8403: oGetLocal 1
8405: oPushResult
8406: oScopeDeclare
8407: oPop 1
8409: oReturn
