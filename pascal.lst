   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %
      %  *** WORKING ON : Records ***
      %    - references to records: currently pushes addr on stack. ok.
      %      Field selection '.' should lookup the ident from the record type's fields scope,
      %      add the offset if not 0,
      %      replace the current type with the field type, and continue
      %      (note, we're in fetch mode here, working with addresses on run stack
      %      just as with arrays).
      %
      %  *** WORKING ON : Procedures ***
      %    - formal args declared but not saved (see Records)
      %    - allocate args so the #'s match the stack (esp. re VAR flag)
      %    - pay attention to VAR flag
      %    - formal params are visible to body of proc, but requires special
      %      code to access non-global vars.
      %      i.e. in expressions, if var is found at SD level > 0, must take it
      %      off stack. (possibly with indirection).
      %      NOTE, VAR parameters are like pointer vars, with automatic deref ('^')
      %      Maybe this helps with the implementation.
      %    - Big choice: what is runtime environment of stack machine?
      %        Call stack with params, returns
      %        Expr stack used within a statement
      %        These can be the same if Expr stack always empty before/after an
      %        indivisible expression. (??)
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushIntVar       % push value of int var; addr follows
   2:    tPushBoolVar
   2:    tPushPtrVar
   2:    tPushAddr         % addr (of a var) follows
   2:    tFetchInt         % replace addr (on tos) of int var with contents
   2:    tFetchBool        %    "      "      "     " bool  "   "    "
   2:    tFetchPtr         %    "      "      "     " ptr   "   "    "   
   2:    tPushIntLit       % int lit follows (NOTE, used for BOOLEAN too)
   2:    tAssignInt        % assign value on tos to addr under it (pop both)
   2:    tAssignBool       %   "      "    "   "  "   "    "    "   "   "
   2:    tAssignPtr        % assign val WHOSE ADDR is on tos to addr under it (pop)
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncIntVar        % increment int var (addr follows)
   2:    tDecIntVar        % decrement int var (addr follows)
   2:    tMultiplyInt      % multiply top two integers (replacing with result)
   2:    tDivideInt
   2:    tAddInt
   2:    tSubtractInt
   2:    tNegateInt        % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualInt         % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualInt      %    NOTE, these all work for booleans too
   2:    tGreaterInt       % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessInt
   2:    tGreaterEqualInt
   2:    tLessEqualInt
   2:    tEqualPtr         % are the ptr vars whose addresses are top 2 equal?
   2:    tNotEqualPtr
   2:    tCall             % addr follows
   2:    tReturn
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tPutInt           % for writeln : write integer on tos, pop
   2:    tPutBool          %  "     "    : write TRUE/FALSE, pop
   2:    tPutStr           %  "     "    : write string whose addr is on tos, pop
   2:    tPutPtr           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tPutCR            %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qNextOffset
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qInOut
   2: 	qSize
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node )                % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
  12:    pProgram
  14:    pIdent
      
  16:    t = @newIdent( nProgram, kProgram, LAST_ID )
  32:    oScopeDeclare( t )
      
  38:    [
  38:       | '(' :
  40:          pIdent      % input, output files
      
  42:          t = @newIdent( nVar, kVar, LAST_ID )
  58:          oNodeSet( t, qType, FileType )
  70:          oScopeDeclareAlloc( t )
      
  76:          ','
  78:          pIdent
      
  80:          t = @newIdent( nVar, kVar, LAST_ID )
  96:          oNodeSet( t, qType, FileType )
 108:          oScopeDeclareAlloc( t )
      
 114:          ')'
 116:       | * :
 121:    ]
 121:    ';'
 123:    @Block( nGlobalVar )    % not including punctuation after body's 'end'
 130:    '.'
 132:    oScopeEnd
 134:    ;
      
 134: Block( node_type varNodeType ):
 136:    {[
 136:       | pConst :     @ConstDecl
 140:       | pType :      @TypeDecl
 144:       | pVar :       @VarDecl( varNodeType )
 153:       | pProcedure : @ProcDecl
 157:       | pFunction :  @FuncDecl
 161:       | * :          @Statement
 176:                      .tReturn
 178:                      >
 180:    ]};
      
 183: ProcDecl:
 185:    Node decl
      
 185:    pIdent
 187:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 203:    oScopeBegin
 204:    @FormalArgDecl
 206:    oNodeSet( decl, qParams, oScopeCurrent )
 217:    oScopeEnd
 218:    oScopeDeclare( decl )
 224:    ';'
      
 226:    oScopeBegin
 227:    @Block( nLocalVar )
 234:    oNodeSet( decl, qChildScope, oScopeCurrent )
 245:    oScopeEnd
 246:    ';';
      
 249: FuncDecl:
 251:    Node decl
 251:    Node theType
      
 251:    pIdent
 253:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 269:    oScopeBegin
 270:    @FormalArgDecl
 272:    oNodeSet( decl, qParams, oScopeCurrent )
 283:    oScopeEnd
 284:    oScopeDeclare( decl )
 290:    ':'
      
 292:    @TypeRef( theType )
 299:    oNodeSet( decl, qType, theType )
 311:    ';'
      
 313:    oScopeBegin
 314:    @Block( nLocalVar )
 321:    oNodeSet( decl, qChildScope, oScopeCurrent )
 332:    oScopeEnd
 333:    ';';
      
      
      % TO DO:
      %   This code is declaring params in the wrong order.
      %   Also ignoring var keyword.
      %   Also not using schema yet.
      %   Also should use a var instead of count stack.
      %
 336: FormalArgDecl:
 338:    [
 338:       | '(' :
 340:          {
 340:             NodeVec decls
 340:             decls = oNodeVecNew
 345:             Node decl
 345:             boolean isInOut
 345:             isInOut = false
      
 351:             [
 351:                | pVar : isInOut = true
 359:                | * :
 364:             ]
      
 364:             {  pIdent
      
 366:                decl = @newIdent( nParam, kVar, LAST_ID )
 382:                oNodeSetBoolean( decl, qInOut, isInOut )
 394:                oNodeVecAppend( decls, decl )
      
 403:                [
 403:                   | ':' : >
 407:                   | ',' :
 409:                ]
 417:             }
      
 419:             Node theType
 419:             @TypeRef( theType )
      
 426:             int i
 426:             i = 0
 432:             {[ equal( i, oNodeVecSize( decls ) )
 446:                | false :
 447:                   decl = oNodeVecElement( decls, i )
 460:                   oNodeSet( decl, qType, theType )
 472:                   oScopeDeclareAlloc( decl )
 478:                   inc( i )
 484:                | * :
 489:                   >
 491:             ]}
      
 493:             oNodeVecDelete( decls )
      
 499:             [
 499:                | ')' : >
 503:                | ';' :
 505:             ]
 513:          }
 515:       | * :
 520:    ];
      
 521: ConstDecl:
 523:    {[
 523:       | pIdent :
 525:          Node decl
 525:          decl = @newIdent( nConst, kConst, LAST_ID )
 541:          '='
      
 543:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 545:          int val
 545:          val = oValueTop
 550:          oValuePop
 551:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 563:          oNodeSet( decl, qType, IntegerType )
      
 575:          oScopeDeclare( decl )
 581:          ';'
 583:       | * :
 588:          >
 590:    ]};
      
 593: TypeDecl:
 595:    {[
 595:       | pIdent :
 597:          Node decl
 597:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 613:          '='
 615:          Node theType
 615:          @TypeRef( theType )
 622:          oNodeSet( decl, qType, theType )
 634:          oScopeDeclare( decl )
 640:          ';'
 642:       | * :
 647:          >
 649:    ]};
      
 652: VarDecl( node_type varNodeType ):
 654:    {[
 654:       | pIdent :
 656:          NodeVec decls
 656:          decls = oNodeVecNew
 661:          Node decl
 661:          {
 661:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 677:             oNodeVecAppend( decls, decl )
 686:             [
 686:                | ',' :
 688:                   pIdent
 690:                | * :
 695:                   >
 697:             ]
 697:          }
 699:          ':'
 701:          Node theType
 701:          @TypeRef( theType )
      
 708:          int i
 708:          i = 0
 714:          {[ equal( i, oNodeVecSize( decls ) )
 728:            | false :
 729:              decl = oNodeVecElement( decls, i )
 742:              oNodeSet( decl, qType, theType )
 754:              oScopeDeclareAlloc( decl )
 760:              inc( i )
 766:             | * :
 771:               >
 773:          ]}
      
 775:          oNodeVecDelete( decls )
 781:          ';'
 783:       | * :
 788:          >
 790:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
 793: TypeRef( out Node resultType ):
 795:    [
 795:       | pIdent :           % previously named type (including intrinsics)
 797:          Node decl
 797:          decl = oScopeFindRequire
 802:          [ oNodeType( decl )
 809:            | nTypeDecl :
 810:                resultType = oNodeGet( decl, qType )
 823:            | * :
 828:                #eNotType
 830:                resultType = IntegerType
 836:          ]
         
 836:       | pArray :
 838:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
 840:          NodeVec dimensions
 840:          dimensions = oNodeVecNew
      
 845:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
 845:             Node subrange
 845:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
 855:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
 867:             @ConstExpr
 869:             oNodeSetInt( subrange, qLow, oValueTop )
 880:             oValuePop
 881:             '..'
 883:             @ConstExpr
 885:             oNodeSetInt( subrange, qHigh, oValueTop )
 896:             oValuePop
 897:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
 909:             oTypeAdd( subrange )
      
 915:             Node a
 915:             a = oNodeNew( nArrayType )
 925:             oNodeSet( a, qIndexType, subrange )
      
 937:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
 946:             [
 946:                | ']' : >
 950:                | ',' :
 952:             ]
 960:          }
 962:          pOf
 964:          Node baseType
 964:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
 971:          int dim
 971:          dim = oNodeVecSize( dimensions )
 981:          {
 981:              dec(dim)
      
 987:              Node a
 987:              a = oNodeVecElement( dimensions, dim )
1000:              oNodeSet( a, qBaseType, baseType )
1012:              Node subrange
1012:              subrange = oNodeGet( a, qIndexType )
1025:              int width
1025:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1052:              inc( width )
1058:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1084:              oTypeAdd( a )
1090:              baseType = a
      
1096:              [ equal_zero(dim)
1103:                  | true:  >
1106:                  | *:
1111:              ]
1111:          }
      
1113:          resultType = oNodeVecElement( dimensions, 0 )
1126:          oNodeVecDelete( dimensions )
      
1132:       | '^' :
1134:          Node theType
1134:          @TypeRef( theType )
1141:          resultType = @PointerTypeTo( theType )
      
1152:       | pRecord :
1154:          resultType = oNodeNew( nRecordType )
1164:          oScopeBegin
      
1165:          @VarDecl( nRecordField )
      
1172:          int size
1172:          size = oNodeGetInt( oScopeCurrent, qNextOffset )
               % to do: padding
1184:          [ equal_zero( size )
1191:             | true : #eRecordEmpty
1194:             | * :
1199:          ]
      
1199:          pEnd
      
1201:          oNodeSet( resultType, qScope, oScopeCurrent )
1212:          oNodeSetInt( resultType, qSize, size )
1224:          oScopeEnd
1225:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1231:       | pSet :
1233:          pOf
1235:          Node theType
1235:          @TypeRef( theType )
1242:       | * :       % this works for cases except where expr starts with an id
1255:          @ConstExpr '..' @ConstExpr
1261:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1262: ConstExpr:
1264:    [
1264:       | pIntLit :
1266:          oValuePush( TOKEN_VALUE )
1271:       | pIdent :
1273:          Node decl
1273:          decl = oScopeFindRequire
1278:          [ oNodeType( decl )
1285:             | nConst :
1286:                oValuePush( oNodeGetInt( decl, qValue ) )
1299:             | * :
1304:                #eNotConst
1306:                oValuePush( 0 )
1312:          ]
1312:       | pMinus :
1314:          @ConstExpr
1316:          oValueNegate
1317:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1328: Expr:
1330:    @BoolExpr
1332:    {[
1332:       | '=' :
1334:          @BoolExpr
1336:          @MatchTypes
1338:          [ oTypeSNodeType
1340:             | nIntegerType, nBooleanType :  .tEqualInt
1343:             | nPointerType :                .tEqualPtr
1347:             | nCharType, nStringType :      #eNotImplemented
1351:             | * :                           #eNotAllowed
1366:          ]
1366:          oTypeSPop
1367:          oTypeSPush( BooleanType )
      
1373:       | '<>' :
1375:          @BoolExpr
1377:          @MatchTypes
1379:          [ oTypeSNodeType
1381:             | nIntegerType, nBooleanType :  .tNotEqualInt
1384:             | nPointerType :                .tNotEqualPtr
1388:             | nCharType, nStringType :      #eNotImplemented
1392:             | * :                           #eNotAllowed
1407:          ]
1407:          oTypeSPop
1408:          oTypeSPush( BooleanType )
      
1414:       | '<' :
1416:          @BoolExpr
1418:          @MatchTypes
1420:          [ oTypeSNodeType
1422:             | nIntegerType, nBooleanType :  .tLessInt
1425:             | nCharType, nStringType :      #eNotImplemented
1429:             | * :                           #eNotAllowed
1442:          ]
1442:          oTypeSPop
1443:          oTypeSPush( BooleanType )
      
1449:       | '>' :
1451:          @BoolExpr
1453:          @MatchTypes
1455:          [ oTypeSNodeType
1457:             | nIntegerType, nBooleanType :  .tGreaterInt
1460:             | nCharType, nStringType :      #eNotImplemented
1464:             | * :                           #eNotAllowed
1477:          ]
1477:          oTypeSPop
1478:          oTypeSPush( BooleanType )
      
1484:       | '<=' :
1486:          @BoolExpr
1488:          @MatchTypes
1490:          [ oTypeSNodeType
1492:             | nIntegerType, nBooleanType :  .tLessEqualInt
1495:             | nCharType, nStringType :      #eNotImplemented
1499:             | * :                           #eNotAllowed
1512:          ]
1512:          oTypeSPop
1513:          oTypeSPush( BooleanType )
      
1519:       | '>=' :
1521:          @BoolExpr
1523:          @MatchTypes
1525:          [ oTypeSNodeType
1527:             | nIntegerType, nBooleanType :  .tGreaterEqualInt
1530:             | nCharType, nStringType :      #eNotImplemented
1534:             | * :                           #eNotAllowed
1547:          ]
1547:          oTypeSPop
1548:          oTypeSPush( BooleanType )
      
1554:       | * :
1569:          >
1571:    ]};
      
1574: BoolExpr:
1576:    @BoolTerm
1578:    {[
1578:       | pOr :
1580:          @RequireBoolPop
1582:          @BoolTerm
1584:          @RequireBool
1586:          .tOr
1588:       | * :
1593:          >
1595:    ]};
      
1598: BoolTerm:
1600:    @BoolFactor
1602:    {[
1602:       | pAnd :
1604:          @RequireBoolPop
1606:          @BoolFactor
1608:          @RequireBool
1610:          .tAnd
1612:       | * :
1617:          >
1619:    ]};
      
1622: BoolFactor:
1624:    [
1624:       | pNot :
1626:          @ArithExpr
1628:          @RequireBool
1630:          .tNot
1632:       | * :
1637:          @ArithExpr
1639:    ];
      
1640: ArithExpr:
1642:    @Term
1644:    {[
1644:       | pPlus :
1646:          @RequireIntPop
1648:          @Term
1650:          @RequireInt
1652:          .tAddInt
1654:       | pMinus :
1656:          @RequireIntPop
1658:          @Term
1660:          @RequireInt
1662:          .tSubtractInt
1664:       | * :
1671:          >
1673:    ]};
      
1676: Term:
1678:    @Factor
1680:    {[
1680:       | pTimes :
1682:          @RequireIntPop
1684:          @Factor
1686:          @RequireInt
1688:          .tMultiplyInt
1690:       | pDivide :
1692:          @RequireIntPop
1694:          @Factor
1696:          @RequireInt
1698:          .tDivideInt
1700:       | * :
1707:          >
1709:    ]};
      
1712: Factor:
1714:    [
1714:       | pPlus :
1716:          @Primary
1718:          @RequireInt
1720:       | pMinus :
1722:          @Primary
1724:          @RequireInt
1726:          .tNegateInt
1728:       | * :
1735:          @Primary
1737:    ];
      
1738: Primary:
1740:    [
1740:       | pIntLit :
1742:          .tPushIntLit   oEmitInt( TOKEN_VALUE )
1749:          oTypeSPush( IntegerType )
      
1755:       | '(' :
1757:          @Expr
1759:          ')'
      
1761:       | pStrLit :
1763:          oStringAllocLit     % store, put addr on value stack
1764:          .tPushAddr  oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
1772:          oTypeSPush( StringType )
      
1778:       | pIdent :
1780:          Node decl
1780:          Node theType
1780:          decl = oScopeFindRequire
      
1785:          [ oNodeType( decl )
1792:             | nFunc :
1793:                [
1793:                   | '(' :
1795:                      {  @Expr
      
                              % TO DO: match type against param
                              % TO DO: push the expression onto the call stack e.g. iPush...
                              %  Meanwhile for now we are broken, leaving the value on the runtime value stack
1797:                         oTypeSPop
      
1798:                         [
1798:                           | ')' : >
1802:                           | ',' :
1804:                         ]
1812:                      }
1814:                   | * :
1819:                ]
1819:                .tCall  @EmitValue( decl )
1828:                oTypeSPush( oNodeGet( decl, qType ) )
      
1841:             | nConst :
1843:                theType = oNodeGet( decl, qType )
1856:                oTypeSPush( theType )
1862:                [ oTypeSNodeType
1864:                   | nIntegerType, nBooleanType :
1865:                      .tPushIntLit @EmitValue( decl )
1874:                   | * :
1881:                      #eNotImplemented
1883:                ]
      
1883:             | nGlobalVar :
1885:                theType = oNodeGet( decl, qType )
1898:                oTypeSPush( theType )
1904:                [ oTypeSNodeType
1906:                   | nIntegerType :
1907:                      .tPushIntVar @EmitValue( decl )
1916:                   | nBooleanType :
1918:                      .tPushBoolVar @EmitValue( decl )
1927:                   | nCharType, nStringType, nFileType :
1929:                      #eNotImplemented
1931:                   | nPointerType :
1933:                      .tPushPtrVar @EmitValue( decl )
1942:                      [
1942:                         | '^' :             % dereferenced
1944:                            oTypeSPop
1945:                            oTypeSPush( oNodeGet( theType, qBaseType ) )
1958:                            @LValue
1960:                            @FetchVar
1962:                         | * :               % just ptr value alone
1967:                      ]
1967:                   | * :                     % compound type
1982:                      .tPushAddr @EmitValue( decl )    % addr of start of var
1991:                      @LValue                % get final addr
1993:                      @FetchVar              % get final value
1995:                ]
      
1995:             | * :
2004:                #eNotValue
2006:                oTypeSPush( IntegerType )
2012:          ]
      
2012:       | '^' :        % ^var
2014:          pIdent
      
2016:          Node decl
2016:          Node theType
2016:          decl = oScopeFindRequire
2021:          theType = oNodeGet( decl, qType )
      
2034:          [ oNodeType( decl )
2041:             | nGlobalVar :
2042:                .tPushAddr @EmitValue( decl )
2051:                @LValue     % ptr value to expr stack
      
2053:                Node ptrType
2053:                ptrType = @PointerTypeTo( theType )
2064:                oTypeSPush( ptrType )
      
2070:             | nLocalVar, nParam : #eNotImplemented
2074:                oTypeSPush( IntegerType )
2080:             | * :
2089:                #eNotVar
2091:                oTypeSPush( IntegerType )
2097:          ]
      
2097:       | * :
2110:          #eNotValue
2112:          oTypeSPush( IntegerType )
2118:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2119: FetchVar:
2121:    [ oTypeSNodeType
2123:       | nIntegerType :   .tFetchInt
2126:       | nBooleanType :   .tFetchBool
2130:       | nCharType, nStringType, nFileType : #eNotImplemented
2134:       | nPointerType :   .tFetchPtr
2138:       | * :              % compound type; leave as addr
2153:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, etc, to get final addr on run stack, and final type
      % on type stack.
      
2154: LValue:
2156:    {[
2156:       | '[' :       @ArraySubscripts
2160:       | '.' :       @RecordFieldRef
2164:       | '^' :       @PointerDeref
2168:       | * :         >
2179:    ]};
      
2182: ArraySubscripts:
2184:    [ oTypeSNodeType
2186:       | nArrayType :
2187:       | * :       #eNotArray
2194:    ]
2194:    {
2194:       [ oTypeSNodeType
2196:          | nArrayType :
2197:          | * :    #eTooManySubscripts
2204:       ]
      
            % low subscript of this dimension
2204:       int low
2204:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2221:       Node baseType
2221:       baseType = oNodeGet( oTypeSTop, qBaseType )
2233:       oTypeSPop
2234:       oTypeSPush( baseType )
      
2240:       @Expr
2242:       @RequireIntPop
            % adjust for low subscript
2244:       [ equal_zero( low )
2251:          | false :
2252:             .tPushIntLit oEmitInt( low ) .tSubtractInt
2262:          | * :
2267:       ]
      
            % multiply by element size
2267:       int size
2267:       size = oNodeGetInt( baseType, qSize )
2280:       [ equal( size, 1 )
2290:          | false :
2291:             .tPushIntLit oEmitInt( size ) .tMultiplyInt
2301:          | * :
2306:       ]
      
            % update start address
2306:       .tAddInt
2308:       [
2308:          | ']' :  >
2312:          | ',' :
2314:       ]
2322:    };
      
      
2325: RecordFieldRef:
2327:    [ oTypeSNodeType
2329:       | nRecordType :
2330:       | * :    #eNotRecord
2337:    ]
2337:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2349:    pIdent
2351:    Node field
2351:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2356:    [ oNodeType( field )
2363:       | nRecordField :
2364:       | * :   #eNotRecordField
2371:    ]
2371:    oScopeEnd
2372:    int offset
2372:    offset = oNodeGetInt( field, qValue )
2385:    [ equal_zero( offset )
2392:       | false :
2393:          .tPushIntLit oEmitInt( offset ) .tAddInt
2403:       | * :
2408:    ]
      
         % replace the type on the type stack, with the field type
2408:    oTypeSPop
2409:    oTypeSPush( oNodeGet( field, qType ) )
2423:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2423: PointerDeref:
2425:    [ oTypeSNodeType
2427:       | nPointerType :
2428:       | * :       #eNotPointer
2435:    ]
2435:    .tFetchPtr           % now addr on stack is addr of what we're pointing to
      
2437:    Node theType
2437:    theType = oTypeSTop
2442:    oTypeSPop
2443:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2457:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
2457: Statement:
2459:    [
2459:       | pWriteln :     @WritelnStmt
2463:       | pWrite :       @WriteStmt
2467:       | pReadln :      @ReadlnStmt
2471:       | pRead :        @ReadStmt
2475:       | pIf :          @IfStmt
2479:       | pWhile :       @WhileStmt
2483:       | pFor :         @ForStmt
2487:       | pRepeat :      @RepeatStmt
2491:       | pExit :        @ExitStmt
2495:       | pCycle :       @CycleStmt
2499:       | pBegin :       @BeginStmt
2503:       | pIdent :       @AssignOrCallStmt
2507:       | * :            % null statement : don't accept any tokens
2534:    ];
      
      
2535: AssignOrCallStmt:         % *** Call doesn't work yet ***
2537:    Node decl
2537:    decl = oScopeFindRequire
2542:    [ oNodeType( decl )    % can parse without semantic info
2549:       | nProc :           %    but this is easier
2550:          [
2550:             | '(' :
2552:                {  @Expr oTypeSPop  % ignore type for now
2555:                   [
2555:                     | ')' : >
2559:                     | ',' :
2561:                   ]
2569:                }
2571:             | * :
2576:          ]
2576:          .tCall  @EmitValue( decl )
      
2585:       | nGlobalVar :
2587:          .tPushAddr @EmitValue( decl )
2596:          oTypeSPush( oNodeGet( decl, qType ) )
2609:          @LValue        % handle subscripts, if any
2611:          ':=' 
2613:          @Expr
2615:          @MatchTypes
2617:          [ oTypeSNodeType
2619:             | nIntegerType :            .tAssignInt
2622:             | nBooleanType :            .tAssignBool
2626:             | nCharType, nStringType, nFileType :   #eNotImplemented
      
                  % compound var assigns; addrs of src, dest on stack
2630:             | nPointerType :            .tAssignPtr
2634:             | * :
2649:                 int size
2649:                 size = oNodeGetInt( oTypeSTop, qSize )
2661:                 .tCopy  oEmitInt( size )    % multi-word copy
2669:          ]
2669:          oTypeSPop
      
2670:       | * :
2677:          #eBadStatement
2679:    ];
      
2680: IfStmt:
2682:    @Expr
2684:    @RequireBoolPop
2686:    pThen
2688:    .tJumpFalse
2690:    oPatchPushHere(patchIf)
2696:    .tSpace
2698:    @Statement
2700:    [
2700:       | pElse :
2702:          .tJump
2704:          oPatchPushHere(patchIf)
2710:          .tSpace
2712:          oPatchSwap(patchIf)
2718:          oPatchPopFwd(patchIf)
2724:          @Statement
2726:       | * :
2731:    ]
2731:    oPatchPopFwd(patchIf);
      
2738: ForStmt:
2740:    pIdent
      
2742:    Node decl
2742:    decl = oScopeFindRequire
2747:    [ oNodeType( decl )
2754:       | nGlobalVar :
2755:       | nLocalVar :    #eNotImplemented
2759:       | nParam :       #eNotImplemented
2763:       | * :            #eNotIntVar
2774:    ]
2774:    oTypeSPush( oNodeGet( decl, qType ) )
2787:    @RequireIntPop
2789:    .tPushAddr  @EmitValue( decl )
      
2798:    ':='
      
2800:    @Expr
2802:    @RequireIntPop
2804:    .tAssignInt
      
2806:    .tJump oPatchPushHere(patchLoop) .tSpace
2816:    oPatchPushHere(patchLoop)
2822:    oPatchSwap(patchLoop)
2828:    [
2828:       | pTo :
2830:          .tIncIntVar @EmitValue( decl )
2839:          oPatchPopFwd(patchLoop)
2845:          .tPushIntVar @EmitValue( decl )
2854:          @Expr
2856:          @RequireIntPop
2858:          .tGreaterInt
2860:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2870:          oPatchSwap(patchLoop)
2876:       | pDownto :
2878:          .tDecIntVar @EmitValue( decl )
2887:          oPatchPopFwd(patchLoop)
2893:          .tPushIntVar @EmitValue( decl )
2902:          @Expr
2904:          @RequireIntPop
2906:          .tLessInt
2908:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2918:          oPatchSwap(patchLoop)
2924:    ]
2932:    oCountPush(0)          % count 'exit' patches
2938:    pDo
2940:    @Statement
2942:    .tJump oPatchPopBack(patchLoop)
2950:    oPatchPopFwd(patchLoop)
2956:    @PatchExitsPop;
      
2959: RepeatStmt:
2961:    oPatchPushHere(patchLoop) % start of loop
2967:    oCountPush(0)          % count the 'exit' patches
2973:    @Statement
2975:    {[
2975:       | ';' :
2977:          @Statement
2979:       | pUntil :
2981:          @Expr
2983:          @RequireBoolPop
2985:          .tJumpFalse
2987:          oPatchPopBack(patchLoop)
2993:          @PatchExitsPop
2995:          >
2997:    ]};
      
3008: WhileStmt:
3010:    oPatchPushHere(patchLoop)    % start of loop
3016:    oCountPush(0)
3022:    @Expr
3024:    @RequireBoolPop
3026:    pDo
3028:    .tJumpFalse
3030:    oPatchPushHere(patchLoop)    % jump out
3036:    .tSpace
3038:    oPatchSwap(patchLoop)        % start on top
3044:    @Statement
3046:    .tJump
3048:    oPatchPopBack(patchLoop)
3054:    oPatchPopFwd(patchLoop)
3060:    @PatchExitsPop;
      
3063: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
3065:    [ oPatchAnyEntries(patchLoop)
3072:       | true :
3073:          .tJump
3075:          oPatchDup(patchLoop)  % addr of start
3081:          oPatchPopBack(patchLoop)
3087:       | * :
3092:          #eNotInALoop
3094:    ];
      
3095: ExitStmt:
3097:    [ oPatchAnyEntries(patchLoop)
3104:       | true :
3105:          .tJump
3107:          oPatchPushHere(patchExit)
3113:          .tSpace
3115:          oCountInc
3116:       | * :
3121:          #eNotInALoop
3123:    ];
      
3124: BeginStmt:
3126:    @Statement
3128:    {[
3128:       | ';' :   @Statement
3132:       | pEnd :  >
3136:    ]};
      
3147: WritelnStmt:
3149:    @WriteStmt
3151:    .tPutCR;
      
3154: WriteStmt:
3156:    [
3156:       | '(' :
3158:          {
3158:             @Expr
3160:             [ oTypeSNodeType
3162:                | nIntegerType :             .tPutInt
3165:                | nBooleanType :             .tPutBool
3169:                | nStringType :              .tPutStr
3173:                | nCharType, nFileType :     #eNotImplemented
3177:                | nPointerType :             .tPutPtr
3181:                | * :                        #eNotAllowed
3198:             ]
3198:             oTypeSPop
3199:             [
3199:                | ')' : >
3203:                | ',' :
3205:             ]
3213:          }
3215:       | * :
3220:    ];
      
      
3221: ReadlnStmt:      % ***
3224:    ;
3224: ReadStmt:
3227:    ;
      
      % -------------------------------- Utilities -------------------------------
      
3227: PatchExitsPop:
3229:    {[ oCountIsZero
3231:       | false : oPatchPopFwd(patchExit)
3238:                 oCountDec
3239:       | * :     >
3246:    ]}
3248:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
3250: MatchTypes:
3252:    node_type nt
3252:    nt = oTypeSNodeType
3257:    oTypeSPop
3258:    [ equal_node_type( nt, oTypeSNodeType )
3267:       | false :
3268:          #eTypeMismatch
3270:       | * :
3275:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
3276: RequireIntPop:
3278:    [ oTypeSNodeType
3280:       | nIntegerType :
3281:       | * :          #eNotInteger
3288:    ]
3288:    oTypeSPop;
      
3290: RequireInt:
3292:    [ oTypeSNodeType
3294:       | nIntegerType :
3295:       | * :          #eNotInteger
3302:    ];
      
3303: RequireBoolPop:
3305:    [ oTypeSNodeType
3307:       | nBooleanType :
3308:       | * :          #eNotBoolean
3315:    ]
3315:    oTypeSPop;
      
3317: RequireBool:
3319:    [ oTypeSNodeType
3321:       | nBooleanType :
3322:       | * :          #eNotBoolean
3329:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
3330: newType( node_type nt, int size ) >> Node:
3332:   Node node
3332:   node = oNodeNew( nt )
3342:   oNodeSetInt( node, qSize, size )
3354:   oTypeAdd( node )
3360:   >> node
3364:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
3364: newIdent( node_type nt, kind k, int id ) >> Node:
3366:   Node t
3366:   t = oNodeNew( nt )
3376:   oNodeSetKind( t, qKind, k )   % deprecated attribute
3388:   oNodeSetInt( t, qIdent, id )
3400:   >> t
3404:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
3404: PointerTypeTo( Node theType ) >> Node:
3406:    Node ptrType
3406:    ptrType = oNodeGet( theType, qPointerType )
3419:    [ oNodeNull( ptrType )
3426:       | true :
3427:          ptrType = oNodeNew( nPointerType )
3437:          oNodeSet( ptrType, qBaseType, theType )
3449:          oNodeSetInt( ptrType, qSize, 8 )
3461:          oTypeAdd( ptrType )
3467:          oNodeSet( theType, qPointerType, ptrType )
3479:       | * :
3484:    ]
3484:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
3488: OrdinalLow( Node theType ) >> int:
3490:    [ oNodeType( theType )
3497:       | nIntegerType :  >> -2147483648
3501:       | nBooleanType :  >> 0
3506:       | nCharType :     >> 0
3511:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
3523:       | * :             #eNotOrdinalType
3536:                         >> 0
3539:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
3540: EmitValue( Node decl ):
3542:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
3556: installBuiltIns:
      
         % install built-in types
3558:    FileType = @newType( nFileType, 4 )
3572:    IntegerType = @newType( nIntegerType, 4 )
3586:    BooleanType = @newType( nBooleanType, 1 )
3600:    CharType = @newType( nCharType, 1 )
3614:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
3628:    Node t
      
3628:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
3644:    oNodeSet( t, qType, FileType )
3656:    oScopeDeclare( t )
      
3662:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
3678:    oNodeSet( t, qType, IntegerType )
3690:    oScopeDeclare( t )
      
3696:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
3712:    oNodeSet( t, qType, BooleanType )
3724:    oScopeDeclare( t )
      
3730:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
3746:    oNodeSet( t, qType, CharType )
3758:    oScopeDeclare( t )
      
3764:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
3780:    oNodeSet( t, qType, StringType )
3792:    oScopeDeclare( t )
      
         % Built-in constants
      
3798:    t = @newIdent( nConst, kConst, oIdAdd_True )
3814:    oNodeSet( t, qType, BooleanType )
3826:    oNodeSetInt( t, qValue, 1 )
3838:    oScopeDeclare( t )
      
3844:    t = @newIdent( nConst, kConst, oIdAdd_False )
3860:    oNodeSet( t, qType, BooleanType )
3872:    oNodeSetInt( t, qValue, 0 )
3884:    oScopeDeclare( t )
      
3891:    ;
      
3891: end
      
3891: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 1
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 3556
  12: oInput 26
  14: oInput 0
  16: oGetAddrLocal 1
  18: oPushResult
  19: oSetResult 5
  21: oPushResult
  22: oSetResult 1
  24: oPushResult
  25: LAST_ID
  26: oPushResult
  27: oCall 3364
  29: oPop 3
  31: oAssign
  32: oGetLocal 1
  34: oPushResult
  35: oScopeDeclare
  36: oPop 1
  38: oInputChoice 118
  40: oInput 0
  42: oGetAddrLocal 1
  44: oPushResult
  45: oSetResult 10
  47: oPushResult
  48: oSetResult 6
  50: oPushResult
  51: LAST_ID
  52: oPushResult
  53: oCall 3364
  55: oPop 3
  57: oAssign
  58: oGetLocal 1
  60: oPushResult
  61: oSetResult 6
  63: oPushResult
  64: oGetGlobal 2
  66: oPushResult
  67: oNodeSet
  68: oPop 3
  70: oGetLocal 1
  72: oPushResult
  73: oScopeDeclareAlloc
  74: oPop 1
  76: oInput 12
  78: oInput 0
  80: oGetAddrLocal 1
  82: oPushResult
  83: oSetResult 10
  85: oPushResult
  86: oSetResult 6
  88: oPushResult
  89: LAST_ID
  90: oPushResult
  91: oCall 3364
  93: oPop 3
  95: oAssign
  96: oGetLocal 1
  98: oPushResult
  99: oSetResult 6
 101: oPushResult
 102: oGetGlobal 2
 104: oPushResult
 105: oNodeSet
 106: oPop 3
 108: oGetLocal 1
 110: oPushResult
 111: oScopeDeclareAlloc
 112: oPop 1
 114: oInput 14
 116: oJumpForward 121
 118: Choice Lookup Table
          13     40
 121: oInput 4
 123: oSetResult 11
 125: oPushResult
 126: oCall 134
 128: oPop 1
 130: oInput 18
 132: oScopeEnd
 133: oReturn
 134: oLocalSpace 0
 136: oInputChoice 163
 138: oCall 521
 140: oJumpForward 180
 142: oCall 593
 144: oJumpForward 180
 146: oGetParam 1
 148: oPushResult
 149: oCall 652
 151: oPop 1
 153: oJumpForward 180
 155: oCall 183
 157: oJumpForward 180
 159: oCall 249
 161: oJumpForward 180
 163: Choice Lookup Table
          28    159
          27    155
          31    146
          30    142
          29    138
 174: oCall 2457
 176: oEmit 31
 178: oJumpForward 182
 180: oJumpBack 136
 182: oReturn
 183: oLocalSpace 1
 185: oInput 0
 187: oGetAddrLocal 1
 189: oPushResult
 190: oSetResult 6
 192: oPushResult
 193: oSetResult 2
 195: oPushResult
 196: LAST_ID
 197: oPushResult
 198: oCall 3364
 200: oPop 3
 202: oAssign
 203: oScopeBegin
 204: oCall 336
 206: oGetLocal 1
 208: oPushResult
 209: oSetResult 9
 211: oPushResult
 212: oScopeCurrent
 213: oPushResult
 214: oNodeSet
 215: oPop 3
 217: oScopeEnd
 218: oGetLocal 1
 220: oPushResult
 221: oScopeDeclare
 222: oPop 1
 224: oInput 4
 226: oScopeBegin
 227: oSetResult 12
 229: oPushResult
 230: oCall 134
 232: oPop 1
 234: oGetLocal 1
 236: oPushResult
 237: oSetResult 10
 239: oPushResult
 240: oScopeCurrent
 241: oPushResult
 242: oNodeSet
 243: oPop 3
 245: oScopeEnd
 246: oInput 4
 248: oReturn
 249: oLocalSpace 2
 251: oInput 0
 253: oGetAddrLocal 1
 255: oPushResult
 256: oSetResult 7
 258: oPushResult
 259: oSetResult 3
 261: oPushResult
 262: LAST_ID
 263: oPushResult
 264: oCall 3364
 266: oPop 3
 268: oAssign
 269: oScopeBegin
 270: oCall 336
 272: oGetLocal 1
 274: oPushResult
 275: oSetResult 9
 277: oPushResult
 278: oScopeCurrent
 279: oPushResult
 280: oNodeSet
 281: oPop 3
 283: oScopeEnd
 284: oGetLocal 1
 286: oPushResult
 287: oScopeDeclare
 288: oPop 1
 290: oInput 11
 292: oGetAddrLocal 2
 294: oPushResult
 295: oCall 793
 297: oPop 1
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 6
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oInput 4
 313: oScopeBegin
 314: oSetResult 12
 316: oPushResult
 317: oCall 134
 319: oPop 1
 321: oGetLocal 1
 323: oPushResult
 324: oSetResult 10
 326: oPushResult
 327: oScopeCurrent
 328: oPushResult
 329: oNodeSet
 330: oPop 3
 332: oScopeEnd
 333: oInput 4
 335: oReturn
 336: oLocalSpace 5
 338: oInputChoice 517
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeVecNew
 344: oAssign
 345: oGetAddrLocal 3
 347: oPushResult
 348: oSetResult 0
 350: oAssign
 351: oInputChoice 361
 353: oGetAddrLocal 3
 355: oPushResult
 356: oSetResult 1
 358: oAssign
 359: oJumpForward 364
 361: Choice Lookup Table
          31    353
 364: oInput 0
 366: oGetAddrLocal 2
 368: oPushResult
 369: oSetResult 14
 371: oPushResult
 372: oSetResult 6
 374: oPushResult
 375: LAST_ID
 376: oPushResult
 377: oCall 3364
 379: oPop 3
 381: oAssign
 382: oGetLocal 2
 384: oPushResult
 385: oSetResult 11
 387: oPushResult
 388: oGetLocal 3
 390: oPushResult
 391: oNodeSetBoolean
 392: oPop 3
 394: oGetLocal 1
 396: oPushResult
 397: oGetLocal 2
 399: oPushResult
 400: oNodeVecAppend
 401: oPop 2
 403: oInputChoice 411
 405: oJumpForward 419
 407: oJumpForward 417
 409: oJumpForward 417
 411: Choice Lookup Table
          12    409
          11    405
 416: oEndChoice
 417: oJumpBack 364
 419: oGetAddrLocal 4
 421: oPushResult
 422: oCall 793
 424: oPop 1
 426: oGetAddrLocal 5
 428: oPushResult
 429: oSetResult 0
 431: oAssign
 432: oGetLocal 5
 434: oPushResult
 435: oGetLocal 1
 437: oPushResult
 438: oNodeVecSize
 439: oPop 1
 441: oPushResult
 442: equal
 443: oPop 2
 445: oChoice 486
 447: oGetAddrLocal 2
 449: oPushResult
 450: oGetLocal 1
 452: oPushResult
 453: oGetLocal 5
 455: oPushResult
 456: oNodeVecElement
 457: oPop 2
 459: oAssign
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 6
 465: oPushResult
 466: oGetLocal 4
 468: oPushResult
 469: oNodeSet
 470: oPop 3
 472: oGetLocal 2
 474: oPushResult
 475: oScopeDeclareAlloc
 476: oPop 1
 478: oGetAddrLocal 5
 480: oPushResult
 481: inc
 482: oPop 1
 484: oJumpForward 491
 486: Choice Lookup Table
           0    447
 489: oJumpForward 493
 491: oJumpBack 432
 493: oGetLocal 1
 495: oPushResult
 496: oNodeVecDelete
 497: oPop 1
 499: oInputChoice 507
 501: oJumpForward 515
 503: oJumpForward 513
 505: oJumpForward 513
 507: Choice Lookup Table
           4    505
          14    501
 512: oEndChoice
 513: oJumpBack 340
 515: oJumpForward 520
 517: Choice Lookup Table
          13    340
 520: oReturn
 521: oLocalSpace 2
 523: oInputChoice 585
 525: oGetAddrLocal 1
 527: oPushResult
 528: oSetResult 8
 530: oPushResult
 531: oSetResult 4
 533: oPushResult
 534: LAST_ID
 535: oPushResult
 536: oCall 3364
 538: oPop 3
 540: oAssign
 541: oInput 5
 543: oCall 1262
 545: oGetAddrLocal 2
 547: oPushResult
 548: oValueTop
 549: oAssign
 550: oValuePop
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSetInt
 561: oPop 3
 563: oGetLocal 1
 565: oPushResult
 566: oSetResult 6
 568: oPushResult
 569: oGetGlobal 3
 571: oPushResult
 572: oNodeSet
 573: oPop 3
 575: oGetLocal 1
 577: oPushResult
 578: oScopeDeclare
 579: oPop 1
 581: oInput 4
 583: oJumpForward 590
 585: Choice Lookup Table
           0    525
 588: oJumpForward 592
 590: oJumpBack 523
 592: oReturn
 593: oLocalSpace 2
 595: oInputChoice 644
 597: oGetAddrLocal 1
 599: oPushResult
 600: oSetResult 9
 602: oPushResult
 603: oSetResult 5
 605: oPushResult
 606: LAST_ID
 607: oPushResult
 608: oCall 3364
 610: oPop 3
 612: oAssign
 613: oInput 5
 615: oGetAddrLocal 2
 617: oPushResult
 618: oCall 793
 620: oPop 1
 622: oGetLocal 1
 624: oPushResult
 625: oSetResult 6
 627: oPushResult
 628: oGetLocal 2
 630: oPushResult
 631: oNodeSet
 632: oPop 3
 634: oGetLocal 1
 636: oPushResult
 637: oScopeDeclare
 638: oPop 1
 640: oInput 4
 642: oJumpForward 649
 644: Choice Lookup Table
           0    597
 647: oJumpForward 651
 649: oJumpBack 595
 651: oReturn
 652: oLocalSpace 4
 654: oInputChoice 785
 656: oGetAddrLocal 1
 658: oPushResult
 659: oNodeVecNew
 660: oAssign
 661: oGetAddrLocal 2
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oSetResult 6
 669: oPushResult
 670: LAST_ID
 671: oPushResult
 672: oCall 3364
 674: oPop 3
 676: oAssign
 677: oGetLocal 1
 679: oPushResult
 680: oGetLocal 2
 682: oPushResult
 683: oNodeVecAppend
 684: oPop 2
 686: oInputChoice 692
 688: oInput 0
 690: oJumpForward 697
 692: Choice Lookup Table
          12    688
 695: oJumpForward 699
 697: oJumpBack 661
 699: oInput 11
 701: oGetAddrLocal 3
 703: oPushResult
 704: oCall 793
 706: oPop 1
 708: oGetAddrLocal 4
 710: oPushResult
 711: oSetResult 0
 713: oAssign
 714: oGetLocal 4
 716: oPushResult
 717: oGetLocal 1
 719: oPushResult
 720: oNodeVecSize
 721: oPop 1
 723: oPushResult
 724: equal
 725: oPop 2
 727: oChoice 768
 729: oGetAddrLocal 2
 731: oPushResult
 732: oGetLocal 1
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeVecElement
 739: oPop 2
 741: oAssign
 742: oGetLocal 2
 744: oPushResult
 745: oSetResult 6
 747: oPushResult
 748: oGetLocal 3
 750: oPushResult
 751: oNodeSet
 752: oPop 3
 754: oGetLocal 2
 756: oPushResult
 757: oScopeDeclareAlloc
 758: oPop 1
 760: oGetAddrLocal 4
 762: oPushResult
 763: inc
 764: oPop 1
 766: oJumpForward 773
 768: Choice Lookup Table
           0    729
 771: oJumpForward 775
 773: oJumpBack 714
 775: oGetLocal 1
 777: oPushResult
 778: oNodeVecDelete
 779: oPop 1
 781: oInput 4
 783: oJumpForward 790
 785: Choice Lookup Table
           0    656
 788: oJumpForward 792
 790: oJumpBack 654
 792: oReturn
 793: oLocalSpace 12
 795: oInputChoice 1244
 797: oGetAddrLocal 1
 799: oPushResult
 800: oScopeFindRequire
 801: oAssign
 802: oGetLocal 1
 804: oPushResult
 805: oNodeType
 806: oPop 1
 808: oChoice 825
 810: oGetParam 1
 812: oPushResult
 813: oGetLocal 1
 815: oPushResult
 816: oSetResult 6
 818: oPushResult
 819: oNodeGet
 820: oPop 2
 822: oAssign
 823: oJumpForward 836
 825: Choice Lookup Table
           9    810
 828: oError 2
 830: oGetParam 1
 832: oPushResult
 833: oGetGlobal 3
 835: oAssign
 836: oJumpForward 1261
 838: oInput 15
 840: oGetAddrLocal 2
 842: oPushResult
 843: oNodeVecNew
 844: oAssign
 845: oGetAddrLocal 3
 847: oPushResult
 848: oSetResult 23
 850: oPushResult
 851: oNodeNew
 852: oPop 1
 854: oAssign
 855: oGetLocal 3
 857: oPushResult
 858: oSetResult 14
 860: oPushResult
 861: oGetGlobal 3
 863: oPushResult
 864: oNodeSet
 865: oPop 3
 867: oCall 1262
 869: oGetLocal 3
 871: oPushResult
 872: oSetResult 16
 874: oPushResult
 875: oValueTop
 876: oPushResult
 877: oNodeSetInt
 878: oPop 3
 880: oValuePop
 881: oInput 19
 883: oCall 1262
 885: oGetLocal 3
 887: oPushResult
 888: oSetResult 17
 890: oPushResult
 891: oValueTop
 892: oPushResult
 893: oNodeSetInt
 894: oPop 3
 896: oValuePop
 897: oGetLocal 3
 899: oPushResult
 900: oSetResult 12
 902: oPushResult
 903: oSetResult 4
 905: oPushResult
 906: oNodeSetInt
 907: oPop 3
 909: oGetLocal 3
 911: oPushResult
 912: oTypeAdd
 913: oPop 1
 915: oGetAddrLocal 4
 917: oPushResult
 918: oSetResult 22
 920: oPushResult
 921: oNodeNew
 922: oPop 1
 924: oAssign
 925: oGetLocal 4
 927: oPushResult
 928: oSetResult 15
 930: oPushResult
 931: oGetLocal 3
 933: oPushResult
 934: oNodeSet
 935: oPop 3
 937: oGetLocal 2
 939: oPushResult
 940: oGetLocal 4
 942: oPushResult
 943: oNodeVecAppend
 944: oPop 2
 946: oInputChoice 954
 948: oJumpForward 962
 950: oJumpForward 960
 952: oJumpForward 960
 954: Choice Lookup Table
          12    952
          16    948
 959: oEndChoice
 960: oJumpBack 845
 962: oInput 37
 964: oGetAddrLocal 5
 966: oPushResult
 967: oCall 793
 969: oPop 1
 971: oGetAddrLocal 6
 973: oPushResult
 974: oGetLocal 2
 976: oPushResult
 977: oNodeVecSize
 978: oPop 1
 980: oAssign
 981: oGetAddrLocal 6
 983: oPushResult
 984: dec
 985: oPop 1
 987: oGetAddrLocal 4
 989: oPushResult
 990: oGetLocal 2
 992: oPushResult
 993: oGetLocal 6
 995: oPushResult
 996: oNodeVecElement
 997: oPop 2
 999: oAssign
1000: oGetLocal 4
1002: oPushResult
1003: oSetResult 14
1005: oPushResult
1006: oGetLocal 5
1008: oPushResult
1009: oNodeSet
1010: oPop 3
1012: oGetAddrLocal 3
1014: oPushResult
1015: oGetLocal 4
1017: oPushResult
1018: oSetResult 15
1020: oPushResult
1021: oNodeGet
1022: oPop 2
1024: oAssign
1025: oGetAddrLocal 9
1027: oPushResult
1028: oGetLocal 3
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oNodeGetInt
1035: oPop 2
1037: oPushResult
1038: oGetLocal 3
1040: oPushResult
1041: oSetResult 16
1043: oPushResult
1044: oNodeGetInt
1045: oPop 2
1047: oPushResult
1048: subtract
1049: oPop 2
1051: oAssign
1052: oGetAddrLocal 9
1054: oPushResult
1055: inc
1056: oPop 1
1058: oGetLocal 4
1060: oPushResult
1061: oSetResult 12
1063: oPushResult
1064: oGetLocal 9
1066: oPushResult
1067: oGetLocal 5
1069: oPushResult
1070: oSetResult 12
1072: oPushResult
1073: oNodeGetInt
1074: oPop 2
1076: oPushResult
1077: multiply
1078: oPop 2
1080: oPushResult
1081: oNodeSetInt
1082: oPop 3
1084: oGetLocal 4
1086: oPushResult
1087: oTypeAdd
1088: oPop 1
1090: oGetAddrLocal 5
1092: oPushResult
1093: oGetLocal 4
1095: oAssign
1096: oGetLocal 6
1098: oPushResult
1099: equal_zero
1100: oPop 1
1102: oChoice 1108
1104: oJumpForward 1113
1106: oJumpForward 1111
1108: Choice Lookup Table
           1   1104
1111: oJumpBack 981
1113: oGetParam 1
1115: oPushResult
1116: oGetLocal 2
1118: oPushResult
1119: oSetResult 0
1121: oPushResult
1122: oNodeVecElement
1123: oPop 2
1125: oAssign
1126: oGetLocal 2
1128: oPushResult
1129: oNodeVecDelete
1130: oPop 1
1132: oJumpForward 1261
1134: oGetAddrLocal 10
1136: oPushResult
1137: oCall 793
1139: oPop 1
1141: oGetParam 1
1143: oPushResult
1144: oGetLocal 10
1146: oPushResult
1147: oCall 3404
1149: oPop 1
1151: oAssign
1152: oJumpForward 1261
1154: oGetParam 1
1156: oPushResult
1157: oSetResult 24
1159: oPushResult
1160: oNodeNew
1161: oPop 1
1163: oAssign
1164: oScopeBegin
1165: oSetResult 13
1167: oPushResult
1168: oCall 652
1170: oPop 1
1172: oGetAddrLocal 11
1174: oPushResult
1175: oScopeCurrent
1176: oPushResult
1177: oSetResult 3
1179: oPushResult
1180: oNodeGetInt
1181: oPop 2
1183: oAssign
1184: oGetLocal 11
1186: oPushResult
1187: equal_zero
1188: oPop 1
1190: oChoice 1196
1192: oError 18
1194: oJumpForward 1199
1196: Choice Lookup Table
           1   1192
1199: oInput 33
1201: oGetFromParam 1
1203: oPushResult
1204: oSetResult 18
1206: oPushResult
1207: oScopeCurrent
1208: oPushResult
1209: oNodeSet
1210: oPop 3
1212: oGetFromParam 1
1214: oPushResult
1215: oSetResult 12
1217: oPushResult
1218: oGetLocal 11
1220: oPushResult
1221: oNodeSetInt
1222: oPop 3
1224: oScopeEnd
1225: oGetFromParam 1
1227: oPushResult
1228: oTypeAdd
1229: oPop 1
1231: oJumpForward 1261
1233: oInput 37
1235: oGetAddrLocal 10
1237: oPushResult
1238: oCall 793
1240: oPop 1
1242: oJumpForward 1261
1244: Choice Lookup Table
          36   1233
          35   1154
          17   1134
          34    838
           0    797
1255: oCall 1262
1257: oInput 19
1259: oCall 1262
1261: oReturn
1262: oLocalSpace 1
1264: oInputChoice 1319
1266: TOKEN_VALUE
1267: oPushResult
1268: oValuePush
1269: oPop 1
1271: oJumpForward 1327
1273: oGetAddrLocal 1
1275: oPushResult
1276: oScopeFindRequire
1277: oAssign
1278: oGetLocal 1
1280: oPushResult
1281: oNodeType
1282: oPop 1
1284: oChoice 1301
1286: oGetLocal 1
1288: oPushResult
1289: oSetResult 8
1291: oPushResult
1292: oNodeGetInt
1293: oPop 2
1295: oPushResult
1296: oValuePush
1297: oPop 1
1299: oJumpForward 1312
1301: Choice Lookup Table
           8   1286
1304: oError 1
1306: oSetResult 0
1308: oPushResult
1309: oValuePush
1310: oPop 1
1312: oJumpForward 1327
1314: oCall 1262
1316: oValueNegate
1317: oJumpForward 1327
1319: Choice Lookup Table
          23   1314
           0   1273
           1   1266
1326: oEndChoice
1327: oReturn
1328: oLocalSpace 0
1330: oCall 1574
1332: oInputChoice 1556
1334: oCall 1574
1336: oCall 3250
1338: oTypeSNodeType
1339: oChoice 1353
1341: oEmit 22
1343: oJumpForward 1366
1345: oEmit 28
1347: oJumpForward 1366
1349: oError 15
1351: oJumpForward 1366
1353: Choice Lookup Table
          20   1349
          19   1349
          21   1345
          18   1341
          17   1341
1364: oError 16
1366: oTypeSPop
1367: oGetGlobal 4
1369: oPushResult
1370: oTypeSPush
1371: oPop 1
1373: oJumpForward 1571
1375: oCall 1574
1377: oCall 3250
1379: oTypeSNodeType
1380: oChoice 1394
1382: oEmit 23
1384: oJumpForward 1407
1386: oEmit 29
1388: oJumpForward 1407
1390: oError 15
1392: oJumpForward 1407
1394: Choice Lookup Table
          20   1390
          19   1390
          21   1386
          18   1382
          17   1382
1405: oError 16
1407: oTypeSPop
1408: oGetGlobal 4
1410: oPushResult
1411: oTypeSPush
1412: oPop 1
1414: oJumpForward 1571
1416: oCall 1574
1418: oCall 3250
1420: oTypeSNodeType
1421: oChoice 1431
1423: oEmit 25
1425: oJumpForward 1442
1427: oError 15
1429: oJumpForward 1442
1431: Choice Lookup Table
          20   1427
          19   1427
          18   1423
          17   1423
1440: oError 16
1442: oTypeSPop
1443: oGetGlobal 4
1445: oPushResult
1446: oTypeSPush
1447: oPop 1
1449: oJumpForward 1571
1451: oCall 1574
1453: oCall 3250
1455: oTypeSNodeType
1456: oChoice 1466
1458: oEmit 24
1460: oJumpForward 1477
1462: oError 15
1464: oJumpForward 1477
1466: Choice Lookup Table
          20   1462
          19   1462
          18   1458
          17   1458
1475: oError 16
1477: oTypeSPop
1478: oGetGlobal 4
1480: oPushResult
1481: oTypeSPush
1482: oPop 1
1484: oJumpForward 1571
1486: oCall 1574
1488: oCall 3250
1490: oTypeSNodeType
1491: oChoice 1501
1493: oEmit 27
1495: oJumpForward 1512
1497: oError 15
1499: oJumpForward 1512
1501: Choice Lookup Table
          20   1497
          19   1497
          18   1493
          17   1493
1510: oError 16
1512: oTypeSPop
1513: oGetGlobal 4
1515: oPushResult
1516: oTypeSPush
1517: oPop 1
1519: oJumpForward 1571
1521: oCall 1574
1523: oCall 3250
1525: oTypeSNodeType
1526: oChoice 1536
1528: oEmit 26
1530: oJumpForward 1547
1532: oError 15
1534: oJumpForward 1547
1536: Choice Lookup Table
          20   1532
          19   1532
          18   1528
          17   1528
1545: oError 16
1547: oTypeSPop
1548: oGetGlobal 4
1550: oPushResult
1551: oTypeSPush
1552: oPop 1
1554: oJumpForward 1571
1556: Choice Lookup Table
          10   1521
           9   1486
           8   1451
           7   1416
           6   1375
           5   1334
1569: oJumpForward 1573
1571: oJumpBack 1332
1573: oReturn
1574: oLocalSpace 0
1576: oCall 1598
1578: oInputChoice 1590
1580: oCall 3303
1582: oCall 1598
1584: oCall 3317
1586: oEmit 21
1588: oJumpForward 1595
1590: Choice Lookup Table
          52   1580
1593: oJumpForward 1597
1595: oJumpBack 1578
1597: oReturn
1598: oLocalSpace 0
1600: oCall 1622
1602: oInputChoice 1614
1604: oCall 3303
1606: oCall 1622
1608: oCall 3317
1610: oEmit 20
1612: oJumpForward 1619
1614: Choice Lookup Table
          51   1604
1617: oJumpForward 1621
1619: oJumpBack 1602
1621: oReturn
1622: oLocalSpace 0
1624: oInputChoice 1634
1626: oCall 1640
1628: oCall 3317
1630: oEmit 19
1632: oJumpForward 1639
1634: Choice Lookup Table
          53   1626
1637: oCall 1640
1639: oReturn
1640: oLocalSpace 0
1642: oCall 1676
1644: oInputChoice 1666
1646: oCall 3276
1648: oCall 1676
1650: oCall 3290
1652: oEmit 16
1654: oJumpForward 1673
1656: oCall 3276
1658: oCall 1676
1660: oCall 3290
1662: oEmit 17
1664: oJumpForward 1673
1666: Choice Lookup Table
          23   1656
          22   1646
1671: oJumpForward 1675
1673: oJumpBack 1644
1675: oReturn
1676: oLocalSpace 0
1678: oCall 1712
1680: oInputChoice 1702
1682: oCall 3276
1684: oCall 1712
1686: oCall 3290
1688: oEmit 14
1690: oJumpForward 1709
1692: oCall 3276
1694: oCall 1712
1696: oCall 3290
1698: oEmit 15
1700: oJumpForward 1709
1702: Choice Lookup Table
          21   1692
          20   1682
1707: oJumpForward 1711
1709: oJumpBack 1680
1711: oReturn
1712: oLocalSpace 0
1714: oInputChoice 1730
1716: oCall 1738
1718: oCall 3290
1720: oJumpForward 1737
1722: oCall 1738
1724: oCall 3290
1726: oEmit 18
1728: oJumpForward 1737
1730: Choice Lookup Table
          23   1722
          22   1716
1735: oCall 1738
1737: oReturn
1738: oLocalSpace 5
1740: oInputChoice 2099
1742: oEmit 7
1744: TOKEN_VALUE
1745: oPushResult
1746: oEmitInt
1747: oPop 1
1749: oGetGlobal 3
1751: oPushResult
1752: oTypeSPush
1753: oPop 1
1755: oJumpForward 2118
1757: oCall 1328
1759: oInput 14
1761: oJumpForward 2118
1763: oStringAllocLit
1764: oEmit 3
1766: oValueTop
1767: oPushResult
1768: oEmitInt
1769: oPop 1
1771: oValuePop
1772: oGetGlobal 6
1774: oPushResult
1775: oTypeSPush
1776: oPop 1
1778: oJumpForward 2118
1780: oGetAddrLocal 1
1782: oPushResult
1783: oScopeFindRequire
1784: oAssign
1785: oGetLocal 1
1787: oPushResult
1788: oNodeType
1789: oPop 1
1791: oChoice 1997
1793: oInputChoice 1816
1795: oCall 1328
1797: oTypeSPop
1798: oInputChoice 1806
1800: oJumpForward 1814
1802: oJumpForward 1812
1804: oJumpForward 1812
1806: Choice Lookup Table
          12   1804
          14   1800
1811: oEndChoice
1812: oJumpBack 1795
1814: oJumpForward 1819
1816: Choice Lookup Table
          13   1795
1819: oEmit 30
1821: oGetLocal 1
1823: oPushResult
1824: oCall 3540
1826: oPop 1
1828: oGetLocal 1
1830: oPushResult
1831: oSetResult 6
1833: oPushResult
1834: oNodeGet
1835: oPop 2
1837: oPushResult
1838: oTypeSPush
1839: oPop 1
1841: oJumpForward 2012
1843: oGetAddrLocal 2
1845: oPushResult
1846: oGetLocal 1
1848: oPushResult
1849: oSetResult 6
1851: oPushResult
1852: oNodeGet
1853: oPop 2
1855: oAssign
1856: oGetLocal 2
1858: oPushResult
1859: oTypeSPush
1860: oPop 1
1862: oTypeSNodeType
1863: oChoice 1876
1865: oEmit 7
1867: oGetLocal 1
1869: oPushResult
1870: oCall 3540
1872: oPop 1
1874: oJumpForward 1883
1876: Choice Lookup Table
          18   1865
          17   1865
1881: oError 15
1883: oJumpForward 2012
1885: oGetAddrLocal 2
1887: oPushResult
1888: oGetLocal 1
1890: oPushResult
1891: oSetResult 6
1893: oPushResult
1894: oNodeGet
1895: oPop 2
1897: oAssign
1898: oGetLocal 2
1900: oPushResult
1901: oTypeSPush
1902: oPop 1
1904: oTypeSNodeType
1905: oChoice 1969
1907: oEmit 0
1909: oGetLocal 1
1911: oPushResult
1912: oCall 3540
1914: oPop 1
1916: oJumpForward 1995
1918: oEmit 1
1920: oGetLocal 1
1922: oPushResult
1923: oCall 3540
1925: oPop 1
1927: oJumpForward 1995
1929: oError 15
1931: oJumpForward 1995
1933: oEmit 2
1935: oGetLocal 1
1937: oPushResult
1938: oCall 3540
1940: oPop 1
1942: oInputChoice 1964
1944: oTypeSPop
1945: oGetLocal 2
1947: oPushResult
1948: oSetResult 14
1950: oPushResult
1951: oNodeGet
1952: oPop 2
1954: oPushResult
1955: oTypeSPush
1956: oPop 1
1958: oCall 2154
1960: oCall 2119
1962: oJumpForward 1967
1964: Choice Lookup Table
          17   1944
1967: oJumpForward 1995
1969: Choice Lookup Table
          21   1933
          16   1929
          20   1929
          19   1929
          18   1918
          17   1907
1982: oEmit 3
1984: oGetLocal 1
1986: oPushResult
1987: oCall 3540
1989: oPop 1
1991: oCall 2154
1993: oCall 2119
1995: oJumpForward 2012
1997: Choice Lookup Table
          11   1885
           8   1843
           7   1793
2004: oError 6
2006: oGetGlobal 3
2008: oPushResult
2009: oTypeSPush
2010: oPop 1
2012: oJumpForward 2118
2014: oInput 0
2016: oGetAddrLocal 1
2018: oPushResult
2019: oScopeFindRequire
2020: oAssign
2021: oGetAddrLocal 2
2023: oPushResult
2024: oGetLocal 1
2026: oPushResult
2027: oSetResult 6
2029: oPushResult
2030: oNodeGet
2031: oPop 2
2033: oAssign
2034: oGetLocal 1
2036: oPushResult
2037: oNodeType
2038: oPop 1
2040: oChoice 2082
2042: oEmit 3
2044: oGetLocal 1
2046: oPushResult
2047: oCall 3540
2049: oPop 1
2051: oCall 2154
2053: oGetAddrLocal 5
2055: oPushResult
2056: oGetLocal 2
2058: oPushResult
2059: oCall 3404
2061: oPop 1
2063: oAssign
2064: oGetLocal 5
2066: oPushResult
2067: oTypeSPush
2068: oPop 1
2070: oJumpForward 2097
2072: oError 15
2074: oGetGlobal 3
2076: oPushResult
2077: oTypeSPush
2078: oPop 1
2080: oJumpForward 2097
2082: Choice Lookup Table
          14   2072
          12   2072
          11   2042
2089: oError 4
2091: oGetGlobal 3
2093: oPushResult
2094: oTypeSPush
2095: oPop 1
2097: oJumpForward 2118
2099: Choice Lookup Table
          17   2014
           0   1780
           2   1763
          13   1757
           1   1742
2110: oError 6
2112: oGetGlobal 3
2114: oPushResult
2115: oTypeSPush
2116: oPop 1
2118: oReturn
2119: oLocalSpace 0
2121: oTypeSNodeType
2122: oChoice 2140
2124: oEmit 4
2126: oJumpForward 2153
2128: oEmit 5
2130: oJumpForward 2153
2132: oError 15
2134: oJumpForward 2153
2136: oEmit 6
2138: oJumpForward 2153
2140: Choice Lookup Table
          21   2136
          16   2132
          20   2132
          19   2132
          18   2128
          17   2124
2153: oReturn
2154: oLocalSpace 0
2156: oInputChoice 2170
2158: oCall 2182
2160: oJumpForward 2179
2162: oCall 2325
2164: oJumpForward 2179
2166: oCall 2423
2168: oJumpForward 2179
2170: Choice Lookup Table
          17   2166
          18   2162
          15   2158
2177: oJumpForward 2181
2179: oJumpBack 2156
2181: oReturn
2182: oLocalSpace 3
2184: oTypeSNodeType
2185: oChoice 2189
2187: oJumpForward 2194
2189: Choice Lookup Table
          22   2187
2192: oError 10
2194: oTypeSNodeType
2195: oChoice 2199
2197: oJumpForward 2204
2199: Choice Lookup Table
          22   2197
2202: oError 13
2204: oGetAddrLocal 1
2206: oPushResult
2207: oTypeSTop
2208: oPushResult
2209: oSetResult 15
2211: oPushResult
2212: oNodeGet
2213: oPop 2
2215: oPushResult
2216: oCall 3488
2218: oPop 1
2220: oAssign
2221: oGetAddrLocal 2
2223: oPushResult
2224: oTypeSTop
2225: oPushResult
2226: oSetResult 14
2228: oPushResult
2229: oNodeGet
2230: oPop 2
2232: oAssign
2233: oTypeSPop
2234: oGetLocal 2
2236: oPushResult
2237: oTypeSPush
2238: oPop 1
2240: oCall 1328
2242: oCall 3276
2244: oGetLocal 1
2246: oPushResult
2247: equal_zero
2248: oPop 1
2250: oChoice 2264
2252: oEmit 7
2254: oGetLocal 1
2256: oPushResult
2257: oEmitInt
2258: oPop 1
2260: oEmit 17
2262: oJumpForward 2267
2264: Choice Lookup Table
           0   2252
2267: oGetAddrLocal 3
2269: oPushResult
2270: oGetLocal 2
2272: oPushResult
2273: oSetResult 12
2275: oPushResult
2276: oNodeGetInt
2277: oPop 2
2279: oAssign
2280: oGetLocal 3
2282: oPushResult
2283: oSetResult 1
2285: oPushResult
2286: equal
2287: oPop 2
2289: oChoice 2303
2291: oEmit 7
2293: oGetLocal 3
2295: oPushResult
2296: oEmitInt
2297: oPop 1
2299: oEmit 14
2301: oJumpForward 2306
2303: Choice Lookup Table
           0   2291
2306: oEmit 16
2308: oInputChoice 2316
2310: oJumpForward 2324
2312: oJumpForward 2322
2314: oJumpForward 2322
2316: Choice Lookup Table
          12   2314
          16   2310
2321: oEndChoice
2322: oJumpBack 2194
2324: oReturn
2325: oLocalSpace 2
2327: oTypeSNodeType
2328: oChoice 2332
2330: oJumpForward 2337
2332: Choice Lookup Table
          24   2330
2335: oError 11
2337: oTypeSTop
2338: oPushResult
2339: oSetResult 18
2341: oPushResult
2342: oNodeGet
2343: oPop 2
2345: oPushResult
2346: oScopeEnter
2347: oPop 1
2349: oInput 0
2351: oGetAddrLocal 1
2353: oPushResult
2354: oScopeFindRequire
2355: oAssign
2356: oGetLocal 1
2358: oPushResult
2359: oNodeType
2360: oPop 1
2362: oChoice 2366
2364: oJumpForward 2371
2366: Choice Lookup Table
          13   2364
2369: oError 12
2371: oScopeEnd
2372: oGetAddrLocal 2
2374: oPushResult
2375: oGetLocal 1
2377: oPushResult
2378: oSetResult 8
2380: oPushResult
2381: oNodeGetInt
2382: oPop 2
2384: oAssign
2385: oGetLocal 2
2387: oPushResult
2388: equal_zero
2389: oPop 1
2391: oChoice 2405
2393: oEmit 7
2395: oGetLocal 2
2397: oPushResult
2398: oEmitInt
2399: oPop 1
2401: oEmit 16
2403: oJumpForward 2408
2405: Choice Lookup Table
           0   2393
2408: oTypeSPop
2409: oGetLocal 1
2411: oPushResult
2412: oSetResult 6
2414: oPushResult
2415: oNodeGet
2416: oPop 2
2418: oPushResult
2419: oTypeSPush
2420: oPop 1
2422: oReturn
2423: oLocalSpace 1
2425: oTypeSNodeType
2426: oChoice 2430
2428: oJumpForward 2435
2430: Choice Lookup Table
          21   2428
2433: oError 9
2435: oEmit 6
2437: oGetAddrLocal 1
2439: oPushResult
2440: oTypeSTop
2441: oAssign
2442: oTypeSPop
2443: oGetLocal 1
2445: oPushResult
2446: oSetResult 14
2448: oPushResult
2449: oNodeGet
2450: oPop 2
2452: oPushResult
2453: oTypeSPush
2454: oPop 1
2456: oReturn
2457: oLocalSpace 0
2459: oInputChoice 2509
2461: oCall 3147
2463: oJumpForward 2534
2465: oCall 3154
2467: oJumpForward 2534
2469: oCall 3221
2471: oJumpForward 2534
2473: oCall 3224
2475: oJumpForward 2534
2477: oCall 2680
2479: oJumpForward 2534
2481: oCall 3008
2483: oJumpForward 2534
2485: oCall 2738
2487: oJumpForward 2534
2489: oCall 2959
2491: oJumpForward 2534
2493: oCall 3095
2495: oJumpForward 2534
2497: oCall 3063
2499: oJumpForward 2534
2501: oCall 3124
2503: oJumpForward 2534
2505: oCall 2535
2507: oJumpForward 2534
2509: Choice Lookup Table
           0   2505
          32   2501
          48   2497
          49   2493
          46   2489
          41   2485
          45   2481
          38   2477
          57   2473
          56   2469
          55   2465
          54   2461
2534: oReturn
2535: oLocalSpace 2
2537: oGetAddrLocal 1
2539: oPushResult
2540: oScopeFindRequire
2541: oAssign
2542: oGetLocal 1
2544: oPushResult
2545: oNodeType
2546: oPop 1
2548: oChoice 2672
2550: oInputChoice 2573
2552: oCall 1328
2554: oTypeSPop
2555: oInputChoice 2563
2557: oJumpForward 2571
2559: oJumpForward 2569
2561: oJumpForward 2569
2563: Choice Lookup Table
          12   2561
          14   2557
2568: oEndChoice
2569: oJumpBack 2552
2571: oJumpForward 2576
2573: Choice Lookup Table
          13   2552
2576: oEmit 30
2578: oGetLocal 1
2580: oPushResult
2581: oCall 3540
2583: oPop 1
2585: oJumpForward 2679
2587: oEmit 3
2589: oGetLocal 1
2591: oPushResult
2592: oCall 3540
2594: oPop 1
2596: oGetLocal 1
2598: oPushResult
2599: oSetResult 6
2601: oPushResult
2602: oNodeGet
2603: oPop 2
2605: oPushResult
2606: oTypeSPush
2607: oPop 1
2609: oCall 2154
2611: oInput 3
2613: oCall 1328
2615: oCall 3250
2617: oTypeSNodeType
2618: oChoice 2636
2620: oEmit 8
2622: oJumpForward 2669
2624: oEmit 9
2626: oJumpForward 2669
2628: oError 15
2630: oJumpForward 2669
2632: oEmit 10
2634: oJumpForward 2669
2636: Choice Lookup Table
          21   2632
          16   2628
          20   2628
          19   2628
          18   2624
          17   2620
2649: oGetAddrLocal 2
2651: oPushResult
2652: oTypeSTop
2653: oPushResult
2654: oSetResult 12
2656: oPushResult
2657: oNodeGetInt
2658: oPop 2
2660: oAssign
2661: oEmit 11
2663: oGetLocal 2
2665: oPushResult
2666: oEmitInt
2667: oPop 1
2669: oTypeSPop
2670: oJumpForward 2679
2672: Choice Lookup Table
          11   2587
           6   2550
2677: oError 0
2679: oReturn
2680: oLocalSpace 0
2682: oCall 1328
2684: oCall 3303
2686: oInput 39
2688: oEmit 34
2690: oSetResult 2
2692: oPushResult
2693: oPatchPushHere
2694: oPop 1
2696: oEmit 40
2698: oCall 2457
2700: oInputChoice 2728
2702: oEmit 32
2704: oSetResult 2
2706: oPushResult
2707: oPatchPushHere
2708: oPop 1
2710: oEmit 40
2712: oSetResult 2
2714: oPushResult
2715: oPatchSwap
2716: oPop 1
2718: oSetResult 2
2720: oPushResult
2721: oPatchPopFwd
2722: oPop 1
2724: oCall 2457
2726: oJumpForward 2731
2728: Choice Lookup Table
          40   2702
2731: oSetResult 2
2733: oPushResult
2734: oPatchPopFwd
2735: oPop 1
2737: oReturn
2738: oLocalSpace 1
2740: oInput 0
2742: oGetAddrLocal 1
2744: oPushResult
2745: oScopeFindRequire
2746: oAssign
2747: oGetLocal 1
2749: oPushResult
2750: oNodeType
2751: oPop 1
2753: oChoice 2765
2755: oJumpForward 2774
2757: oError 15
2759: oJumpForward 2774
2761: oError 15
2763: oJumpForward 2774
2765: Choice Lookup Table
          14   2761
          12   2757
          11   2755
2772: oError 5
2774: oGetLocal 1
2776: oPushResult
2777: oSetResult 6
2779: oPushResult
2780: oNodeGet
2781: oPop 2
2783: oPushResult
2784: oTypeSPush
2785: oPop 1
2787: oCall 3276
2789: oEmit 3
2791: oGetLocal 1
2793: oPushResult
2794: oCall 3540
2796: oPop 1
2798: oInput 3
2800: oCall 1328
2802: oCall 3276
2804: oEmit 8
2806: oEmit 32
2808: oSetResult 0
2810: oPushResult
2811: oPatchPushHere
2812: oPop 1
2814: oEmit 40
2816: oSetResult 0
2818: oPushResult
2819: oPatchPushHere
2820: oPop 1
2822: oSetResult 0
2824: oPushResult
2825: oPatchSwap
2826: oPop 1
2828: oInputChoice 2926
2830: oEmit 12
2832: oGetLocal 1
2834: oPushResult
2835: oCall 3540
2837: oPop 1
2839: oSetResult 0
2841: oPushResult
2842: oPatchPopFwd
2843: oPop 1
2845: oEmit 0
2847: oGetLocal 1
2849: oPushResult
2850: oCall 3540
2852: oPop 1
2854: oCall 1328
2856: oCall 3276
2858: oEmit 24
2860: oEmit 33
2862: oSetResult 0
2864: oPushResult
2865: oPatchPushHere
2866: oPop 1
2868: oEmit 40
2870: oSetResult 0
2872: oPushResult
2873: oPatchSwap
2874: oPop 1
2876: oJumpForward 2932
2878: oEmit 13
2880: oGetLocal 1
2882: oPushResult
2883: oCall 3540
2885: oPop 1
2887: oSetResult 0
2889: oPushResult
2890: oPatchPopFwd
2891: oPop 1
2893: oEmit 0
2895: oGetLocal 1
2897: oPushResult
2898: oCall 3540
2900: oPop 1
2902: oCall 1328
2904: oCall 3276
2906: oEmit 25
2908: oEmit 33
2910: oSetResult 0
2912: oPushResult
2913: oPatchPushHere
2914: oPop 1
2916: oEmit 40
2918: oSetResult 0
2920: oPushResult
2921: oPatchSwap
2922: oPop 1
2924: oJumpForward 2932
2926: Choice Lookup Table
          43   2878
          42   2830
2931: oEndChoice
2932: oSetResult 0
2934: oPushResult
2935: oCountPush
2936: oPop 1
2938: oInput 44
2940: oCall 2457
2942: oEmit 32
2944: oSetResult 0
2946: oPushResult
2947: oPatchPopBack
2948: oPop 1
2950: oSetResult 0
2952: oPushResult
2953: oPatchPopFwd
2954: oPop 1
2956: oCall 3227
2958: oReturn
2959: oLocalSpace 0
2961: oSetResult 0
2963: oPushResult
2964: oPatchPushHere
2965: oPop 1
2967: oSetResult 0
2969: oPushResult
2970: oCountPush
2971: oPop 1
2973: oCall 2457
2975: oInputChoice 2999
2977: oCall 2457
2979: oJumpForward 3005
2981: oCall 1328
2983: oCall 3303
2985: oEmit 34
2987: oSetResult 0
2989: oPushResult
2990: oPatchPopBack
2991: oPop 1
2993: oCall 3227
2995: oJumpForward 3007
2997: oJumpForward 3005
2999: Choice Lookup Table
          47   2981
           4   2977
3004: oEndChoice
3005: oJumpBack 2975
3007: oReturn
3008: oLocalSpace 0
3010: oSetResult 0
3012: oPushResult
3013: oPatchPushHere
3014: oPop 1
3016: oSetResult 0
3018: oPushResult
3019: oCountPush
3020: oPop 1
3022: oCall 1328
3024: oCall 3303
3026: oInput 44
3028: oEmit 34
3030: oSetResult 0
3032: oPushResult
3033: oPatchPushHere
3034: oPop 1
3036: oEmit 40
3038: oSetResult 0
3040: oPushResult
3041: oPatchSwap
3042: oPop 1
3044: oCall 2457
3046: oEmit 32
3048: oSetResult 0
3050: oPushResult
3051: oPatchPopBack
3052: oPop 1
3054: oSetResult 0
3056: oPushResult
3057: oPatchPopFwd
3058: oPop 1
3060: oCall 3227
3062: oReturn
3063: oLocalSpace 0
3065: oSetResult 0
3067: oPushResult
3068: oPatchAnyEntries
3069: oPop 1
3071: oChoice 3089
3073: oEmit 32
3075: oSetResult 0
3077: oPushResult
3078: oPatchDup
3079: oPop 1
3081: oSetResult 0
3083: oPushResult
3084: oPatchPopBack
3085: oPop 1
3087: oJumpForward 3094
3089: Choice Lookup Table
           1   3073
3092: oError 17
3094: oReturn
3095: oLocalSpace 0
3097: oSetResult 0
3099: oPushResult
3100: oPatchAnyEntries
3101: oPop 1
3103: oChoice 3118
3105: oEmit 32
3107: oSetResult 1
3109: oPushResult
3110: oPatchPushHere
3111: oPop 1
3113: oEmit 40
3115: oCountInc
3116: oJumpForward 3123
3118: Choice Lookup Table
           1   3105
3121: oError 17
3123: oReturn
3124: oLocalSpace 0
3126: oCall 2457
3128: oInputChoice 3138
3130: oCall 2457
3132: oJumpForward 3144
3134: oJumpForward 3146
3136: oJumpForward 3144
3138: Choice Lookup Table
          33   3134
           4   3130
3143: oEndChoice
3144: oJumpBack 3128
3146: oReturn
3147: oLocalSpace 0
3149: oCall 3154
3151: oEmit 39
3153: oReturn
3154: oLocalSpace 0
3156: oInputChoice 3217
3158: oCall 1328
3160: oTypeSNodeType
3161: oChoice 3183
3163: oEmit 35
3165: oJumpForward 3198
3167: oEmit 36
3169: oJumpForward 3198
3171: oEmit 37
3173: oJumpForward 3198
3175: oError 15
3177: oJumpForward 3198
3179: oEmit 38
3181: oJumpForward 3198
3183: Choice Lookup Table
          21   3179
          16   3175
          19   3175
          20   3171
          18   3167
          17   3163
3196: oError 16
3198: oTypeSPop
3199: oInputChoice 3207
3201: oJumpForward 3215
3203: oJumpForward 3213
3205: oJumpForward 3213
3207: Choice Lookup Table
          12   3205
          14   3201
3212: oEndChoice
3213: oJumpBack 3158
3215: oJumpForward 3220
3217: Choice Lookup Table
          13   3158
3220: oReturn
3221: oLocalSpace 0
3223: oReturn
3224: oLocalSpace 0
3226: oReturn
3227: oLocalSpace 0
3229: oCountIsZero
3230: oChoice 3241
3232: oSetResult 1
3234: oPushResult
3235: oPatchPopFwd
3236: oPop 1
3238: oCountDec
3239: oJumpForward 3246
3241: Choice Lookup Table
           0   3232
3244: oJumpForward 3248
3246: oJumpBack 3229
3248: oCountPop
3249: oReturn
3250: oLocalSpace 1
3252: oGetAddrLocal 1
3254: oPushResult
3255: oTypeSNodeType
3256: oAssign
3257: oTypeSPop
3258: oGetLocal 1
3260: oPushResult
3261: oTypeSNodeType
3262: oPushResult
3263: equal_node_type
3264: oPop 2
3266: oChoice 3272
3268: oError 14
3270: oJumpForward 3275
3272: Choice Lookup Table
           0   3268
3275: oReturn
3276: oLocalSpace 0
3278: oTypeSNodeType
3279: oChoice 3283
3281: oJumpForward 3288
3283: Choice Lookup Table
          17   3281
3286: oError 7
3288: oTypeSPop
3289: oReturn
3290: oLocalSpace 0
3292: oTypeSNodeType
3293: oChoice 3297
3295: oJumpForward 3302
3297: Choice Lookup Table
          17   3295
3300: oError 7
3302: oReturn
3303: oLocalSpace 0
3305: oTypeSNodeType
3306: oChoice 3310
3308: oJumpForward 3315
3310: Choice Lookup Table
          18   3308
3313: oError 8
3315: oTypeSPop
3316: oReturn
3317: oLocalSpace 0
3319: oTypeSNodeType
3320: oChoice 3324
3322: oJumpForward 3329
3324: Choice Lookup Table
          18   3322
3327: oError 8
3329: oReturn
3330: oLocalSpace 1
3332: oGetAddrLocal 1
3334: oPushResult
3335: oGetParam 2
3337: oPushResult
3338: oNodeNew
3339: oPop 1
3341: oAssign
3342: oGetLocal 1
3344: oPushResult
3345: oSetResult 12
3347: oPushResult
3348: oGetParam 1
3350: oPushResult
3351: oNodeSetInt
3352: oPop 3
3354: oGetLocal 1
3356: oPushResult
3357: oTypeAdd
3358: oPop 1
3360: oGetLocal 1
3362: oReturn
3363: oReturn
3364: oLocalSpace 1
3366: oGetAddrLocal 1
3368: oPushResult
3369: oGetParam 3
3371: oPushResult
3372: oNodeNew
3373: oPop 1
3375: oAssign
3376: oGetLocal 1
3378: oPushResult
3379: oSetResult 5
3381: oPushResult
3382: oGetParam 2
3384: oPushResult
3385: oNodeSetKind
3386: oPop 3
3388: oGetLocal 1
3390: oPushResult
3391: oSetResult 4
3393: oPushResult
3394: oGetParam 1
3396: oPushResult
3397: oNodeSetInt
3398: oPop 3
3400: oGetLocal 1
3402: oReturn
3403: oReturn
3404: oLocalSpace 1
3406: oGetAddrLocal 1
3408: oPushResult
3409: oGetParam 1
3411: oPushResult
3412: oSetResult 13
3414: oPushResult
3415: oNodeGet
3416: oPop 2
3418: oAssign
3419: oGetLocal 1
3421: oPushResult
3422: oNodeNull
3423: oPop 1
3425: oChoice 3481
3427: oGetAddrLocal 1
3429: oPushResult
3430: oSetResult 21
3432: oPushResult
3433: oNodeNew
3434: oPop 1
3436: oAssign
3437: oGetLocal 1
3439: oPushResult
3440: oSetResult 14
3442: oPushResult
3443: oGetParam 1
3445: oPushResult
3446: oNodeSet
3447: oPop 3
3449: oGetLocal 1
3451: oPushResult
3452: oSetResult 12
3454: oPushResult
3455: oSetResult 8
3457: oPushResult
3458: oNodeSetInt
3459: oPop 3
3461: oGetLocal 1
3463: oPushResult
3464: oTypeAdd
3465: oPop 1
3467: oGetParam 1
3469: oPushResult
3470: oSetResult 13
3472: oPushResult
3473: oGetLocal 1
3475: oPushResult
3476: oNodeSet
3477: oPop 3
3479: oJumpForward 3484
3481: Choice Lookup Table
           1   3427
3484: oGetLocal 1
3486: oReturn
3487: oReturn
3488: oLocalSpace 0
3490: oGetParam 1
3492: oPushResult
3493: oNodeType
3494: oPop 1
3496: oChoice 3525
3498: oSetResult 0
3500: oReturn
3501: oJumpForward 3539
3503: oSetResult 0
3505: oReturn
3506: oJumpForward 3539
3508: oSetResult 0
3510: oReturn
3511: oJumpForward 3539
3513: oGetParam 1
3515: oPushResult
3516: oSetResult 16
3518: oPushResult
3519: oNodeGetInt
3520: oPop 2
3522: oReturn
3523: oJumpForward 3539
3525: Choice Lookup Table
          23   3513
          19   3508
          18   3503
          17   3498
3534: oError 3
3536: oSetResult 0
3538: oReturn
3539: oReturn
3540: oLocalSpace 0
3542: oGetParam 1
3544: oPushResult
3545: oSetResult 8
3547: oPushResult
3548: oNodeGetInt
3549: oPop 2
3551: oPushResult
3552: oEmitInt
3553: oPop 1
3555: oReturn
3556: oLocalSpace 1
3558: oGetAddrGlobal 2
3560: oPushResult
3561: oSetResult 16
3563: oPushResult
3564: oSetResult 4
3566: oPushResult
3567: oCall 3330
3569: oPop 2
3571: oAssign
3572: oGetAddrGlobal 3
3574: oPushResult
3575: oSetResult 17
3577: oPushResult
3578: oSetResult 4
3580: oPushResult
3581: oCall 3330
3583: oPop 2
3585: oAssign
3586: oGetAddrGlobal 4
3588: oPushResult
3589: oSetResult 18
3591: oPushResult
3592: oSetResult 1
3594: oPushResult
3595: oCall 3330
3597: oPop 2
3599: oAssign
3600: oGetAddrGlobal 5
3602: oPushResult
3603: oSetResult 19
3605: oPushResult
3606: oSetResult 1
3608: oPushResult
3609: oCall 3330
3611: oPop 2
3613: oAssign
3614: oGetAddrGlobal 6
3616: oPushResult
3617: oSetResult 20
3619: oPushResult
3620: oSetResult 256
3622: oPushResult
3623: oCall 3330
3625: oPop 2
3627: oAssign
3628: oGetAddrLocal 1
3630: oPushResult
3631: oSetResult 9
3633: oPushResult
3634: oSetResult 5
3636: oPushResult
3637: oIdAdd_File
3638: oPushResult
3639: oCall 3364
3641: oPop 3
3643: oAssign
3644: oGetLocal 1
3646: oPushResult
3647: oSetResult 6
3649: oPushResult
3650: oGetGlobal 2
3652: oPushResult
3653: oNodeSet
3654: oPop 3
3656: oGetLocal 1
3658: oPushResult
3659: oScopeDeclare
3660: oPop 1
3662: oGetAddrLocal 1
3664: oPushResult
3665: oSetResult 9
3667: oPushResult
3668: oSetResult 5
3670: oPushResult
3671: oIdAdd_Integer
3672: oPushResult
3673: oCall 3364
3675: oPop 3
3677: oAssign
3678: oGetLocal 1
3680: oPushResult
3681: oSetResult 6
3683: oPushResult
3684: oGetGlobal 3
3686: oPushResult
3687: oNodeSet
3688: oPop 3
3690: oGetLocal 1
3692: oPushResult
3693: oScopeDeclare
3694: oPop 1
3696: oGetAddrLocal 1
3698: oPushResult
3699: oSetResult 9
3701: oPushResult
3702: oSetResult 5
3704: oPushResult
3705: oIdAdd_Boolean
3706: oPushResult
3707: oCall 3364
3709: oPop 3
3711: oAssign
3712: oGetLocal 1
3714: oPushResult
3715: oSetResult 6
3717: oPushResult
3718: oGetGlobal 4
3720: oPushResult
3721: oNodeSet
3722: oPop 3
3724: oGetLocal 1
3726: oPushResult
3727: oScopeDeclare
3728: oPop 1
3730: oGetAddrLocal 1
3732: oPushResult
3733: oSetResult 9
3735: oPushResult
3736: oSetResult 5
3738: oPushResult
3739: oIdAdd_Char
3740: oPushResult
3741: oCall 3364
3743: oPop 3
3745: oAssign
3746: oGetLocal 1
3748: oPushResult
3749: oSetResult 6
3751: oPushResult
3752: oGetGlobal 5
3754: oPushResult
3755: oNodeSet
3756: oPop 3
3758: oGetLocal 1
3760: oPushResult
3761: oScopeDeclare
3762: oPop 1
3764: oGetAddrLocal 1
3766: oPushResult
3767: oSetResult 9
3769: oPushResult
3770: oSetResult 5
3772: oPushResult
3773: oIdAdd_String
3774: oPushResult
3775: oCall 3364
3777: oPop 3
3779: oAssign
3780: oGetLocal 1
3782: oPushResult
3783: oSetResult 6
3785: oPushResult
3786: oGetGlobal 6
3788: oPushResult
3789: oNodeSet
3790: oPop 3
3792: oGetLocal 1
3794: oPushResult
3795: oScopeDeclare
3796: oPop 1
3798: oGetAddrLocal 1
3800: oPushResult
3801: oSetResult 8
3803: oPushResult
3804: oSetResult 4
3806: oPushResult
3807: oIdAdd_True
3808: oPushResult
3809: oCall 3364
3811: oPop 3
3813: oAssign
3814: oGetLocal 1
3816: oPushResult
3817: oSetResult 6
3819: oPushResult
3820: oGetGlobal 4
3822: oPushResult
3823: oNodeSet
3824: oPop 3
3826: oGetLocal 1
3828: oPushResult
3829: oSetResult 8
3831: oPushResult
3832: oSetResult 1
3834: oPushResult
3835: oNodeSetInt
3836: oPop 3
3838: oGetLocal 1
3840: oPushResult
3841: oScopeDeclare
3842: oPop 1
3844: oGetAddrLocal 1
3846: oPushResult
3847: oSetResult 8
3849: oPushResult
3850: oSetResult 4
3852: oPushResult
3853: oIdAdd_False
3854: oPushResult
3855: oCall 3364
3857: oPop 3
3859: oAssign
3860: oGetLocal 1
3862: oPushResult
3863: oSetResult 6
3865: oPushResult
3866: oGetGlobal 4
3868: oPushResult
3869: oNodeSet
3870: oPop 3
3872: oGetLocal 1
3874: oPushResult
3875: oSetResult 8
3877: oPushResult
3878: oSetResult 0
3880: oPushResult
3881: oNodeSetInt
3882: oPop 3
3884: oGetLocal 1
3886: oPushResult
3887: oScopeDeclare
3888: oPop 1
3890: oReturn
