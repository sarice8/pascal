   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nProgram
   2: 	nUnit
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qFinalRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oNodeNew( nWorkspace )
      
  14:    oScopeBegin( 0 )
  20:    globalScope = oScopeCurrent
      
  25:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  27:    .tEnter  oEmitInt( 0 )
  35:    Label mainLabel = oLabelNew
      
  40:    .tAllocActuals  oEmitInt( 0 )
  48:    .tCall  oEmitLabel( mainLabel )
  56:    .tFreeActuals  oEmitInt( 0 )
  64:    .tReturn
      
  66:    pProgram
  68:    pIdent
      
  70:    Node program = oNodeNew( nProgram )
  80:    oNodeSetInt( program, qIdent, LAST_ID )
  91:    oNodeSet( workspace, qProgram, program )
      
      
 103:    [
 103:       | '(' :
 105:          pIdent      % input, output files
      
 107:          t = @newIdent( nVar, kVar, LAST_ID )
 123:          oNodeSet( t, qType, FileType )
 135:          oScopeDeclareAlloc( t )
      
 141:          ','
 143:          pIdent
      
 145:          t = @newIdent( nVar, kVar, LAST_ID )
 161:          oNodeSet( t, qType, FileType )
 173:          oScopeDeclareAlloc( t )
      
 179:          ')'
 181:       | * :
 186:    ]
 186:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 188:    oScopeBegin( 0 )
 194:    mainRoutineScope = oScopeCurrent
 199:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 210:    oNodeSet( program, qMainRoutineScope, oScopeCurrent )
 221:    oScopeEnd
      
 222:    @BlockDecls( nGlobalVar )
      
      
 229:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 235:    @BlockStmt( mainLabel, globalScope )
      
 245:    oScopeEnd   % main routine scope
      
 246:    '.'
 248:    oScopeEnd   % global scope
 250:    ;
      
      
 250: Block( node_type varNodeType, Label labelForBody ):
 252:    @BlockDecls( varNodeType )
 259:    @BlockStmt( labelForBody, oScopeCurrent )
 269:    ;
      
      
 269: BlockDecls( node_type varNodeType ):
 271:    {[
 271:       | pConst :     @ConstDecl
 275:       | pType :      @TypeDecl
 279:       | pVar :       @VarDecl( varNodeType )
 288:       | pProcedure : @ProcDecl
 292:       | pFunction :  @FuncDecl
 296:       | * :          >
 311:    ]}
 313:    @CheckForUndefinedMethods
 316:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 316: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 319:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 319: BlockStmt( Label labelForBody, Node varScope ):
 321:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 329:    int patchLS
 329:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 338:    Code initCode = oNodeGetCode( varScope, qInitCode )
 351:    oEmitCode( initCode )
 357:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 368:    @Statement
 370:    .tReturn
      
 372:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 384:    oPatch( patchLS, localSpace )
 394:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 394: MethodModifiers( Node decl ):
 396:    {[
 396:       | pCdecl :
 398:          oNodeSetBoolean( decl, qCdecl, true )
 410:          ';'
      
 412:       | * : >
 419:    ]}
 422:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 422: GetOrCreateInitCode >> Code:
 424:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 436:    [ equal_code( initCode, codeNull )
 446:       | true :
 447:          initCode = oCodeNew
 452:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 463:       | * :
 468:    ]
 468:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 472: ExternalDecl( Node decl ):
 474:    [ equal_zero( @DeclLevel( decl ) )
 486:       | false :  #eExternalMethodCannotBeNested
 489:       | * :
 494:    ]
 494:    oNodeSetBoolean( decl, qExternal, true )
 506:    [
 506:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 508:          [
 508:             | pName :
 510:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 512:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 523:             | * :
 528:          ]
 528:       | * :
 533:    ]
 534:    ;
      
      
 534: ProcDecl:
 536:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 538:    boolean redeclaring = false
 544:    Node decl = oScopeFindInCurrentScope
      
 549:    [ oNodeNull( decl )
 556:       | true :
               % first declaration
 557:          decl = @newIdent( nProc, kProc, LAST_ID )
 573:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 584:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 586:          redeclaring = true
 592:          [ oNodeGetBoolean( decl, qBodyDefined )
 602:             | true : #eAlreadyDefined
 605:             | * :
 610:          ]
 610:          [ oNodeGetBoolean( decl, qExternal )
 620:             | true : #eAlreadyDefined
 623:             | * :
 628:          ]
 628:          [ oNodeType( decl )
 635:             | nProc :
 636:             | * : #eAlreadyDefined   % wrong kind
 643:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 643:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 662:          oNodeSet( decl, qParams, Null )
 674:    ]
      
 682:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 694:    boolean nested = greater( level, 0 )
 707:    inc( level )
 713:    oScopeBegin( level )
 719:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
 724:    [ nested
 727:       | true :
 728:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
 743:       | * :
 748:    ]
      
 748:    @FormalArgDecl
 750:    oNodeSet( decl, qParams, paramScope )
 762:    oScopeEnd
 763:    ';'
      
 765:    [ redeclaring
 768:       | false : oScopeDeclare( decl )
 775:       | true :  % TO DO: check that qParams is consistent with qOldParams
 777:    ]
      
 785:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 792:    [
 792:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 794:       | pExternal : @ExternalDecl( decl )
      
 803:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 810:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 816:          oScopeBegin( level )
 822:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 833:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 844:          Label label = oNodeGetLabel( decl, qValue )
 857:          @Block( nLocalVar, label )
 867:          oNodeSetBoolean( decl, qBodyDefined, true )
 879:          oScopeEnd
      
 880:          oScopeEnd  % paramScope
 881:    ]
 881:    ';';
      
      
 884: FuncDecl:
 886:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 888:    boolean redeclaring = false
 894:    Node decl = oScopeFindInCurrentScope
      
 899:    [ oNodeNull( decl )
 906:       | true :
               % first declaration
 907:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 923:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 934:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 936:          redeclaring = true
 942:          [ oNodeGetBoolean( decl, qBodyDefined )
 952:             | true : #eAlreadyDefined
 955:             | * :
 960:          ]
 960:          [ oNodeType( decl )
 967:             | nFunc :
 968:             | * : #eAlreadyDefined   % wrong kind
 975:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 975:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 994:          oNodeSet( decl, qParams, Null )
1006:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1025:          oNodeSet( decl, qType, Null )
1037:    ]
      
1045:    int level = oNodeGetInt( oScopeCurrent, qLevel )
1057:    boolean nested = greater( level, 0 )
1070:    inc( level )
1076:    oScopeBegin( level )
1082:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1087:    [ nested
1090:       | true :
1091:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1106:       | * :
1111:    ]
      
1111:    @FormalArgDecl
1113:    oNodeSet( decl, qParams, paramScope )
      
1125:    ':'
      
1127:    Node theType
1127:    @TypeRef( theType )
1134:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1146:    Node ptrType = @PointerTypeTo( theType )
1157:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1173:    oScopeEnd
1174:    ';'
      
1176:    [ redeclaring
1179:       | false : oScopeDeclare( decl )
1186:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1188:    ]
      
1196:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1203:    [
1203:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1205:       | pExternal : @ExternalDecl( decl )
      
1214:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1221:          oScopeEnter( paramScope )
      
1227:          oScopeBegin( level )
1233:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1244:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1255:          Label label = oNodeGetLabel( decl, qValue )
1268:          @Block( nLocalVar, label )
1278:          oNodeSetBoolean( decl, qBodyDefined, true )
1290:          oScopeEnd
      
1291:          oScopeEnd  % paramScope
1292:    ]
1292:    ';';
      
      
1295: FormalArgDecl:
1297:    [
1297:       | '(' :
1299:          {
1299:             NodeVec decls = oNodeVecNew
1304:             Node decl
1304:             boolean isInOut = false
      
1310:             [
1310:                | pVar : isInOut = true
1318:                | * :
1323:             ]
      
1323:             {  pIdent
      
1325:                decl = @newIdent( nParam, kVar, LAST_ID )
1341:                oNodeSetBoolean( decl, qInOut, isInOut )
1353:                oNodeVecAppend( decls, decl )
      
1362:                [
1362:                   | ':' : >
1366:                   | ',' :
1368:                ]
1376:             }
      
1378:             Node theType
1378:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1385:             Node allocType
1385:             [ isInOut
1388:                | true :   allocType = @PointerTypeTo( theType )
1400:                | * :      allocType = theType
1411:             ]
      
1411:             int i = 0
1417:             {[ equal( i, oNodeVecSize( decls ) )
1431:                | false :
1432:                   decl = oNodeVecElement( decls, i )
      
1445:                   oNodeSet( decl, qType, theType )
1457:                   oScopeDeclare( decl )
1463:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1479:                   inc( i )
1485:                | * :
1490:                   >
1492:             ]}
      
1494:             oNodeVecDelete( decls )
      
1500:             [
1500:                | ')' : >
1504:                | ';' :
1506:             ]
1514:          }
1516:       | * :
1521:    ];
      
1522: ConstDecl:
1524:    {[
1524:       | pIdent :
1526:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1542:          '='
      
1544:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1546:          int val = oValueTop
1551:          oValuePop
1552:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1564:          oNodeSet( decl, qType, IntegerType )
      
1576:          oScopeDeclare( decl )
1582:          ';'
1584:       | * :
1589:          >
1591:    ]};
      
1594: TypeDecl:
1596:    {[
1596:       | pIdent :
1598:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1614:          '='
1616:          Node theType
1616:          @TypeRef( theType )
1623:          oNodeSet( decl, qType, theType )
1635:          oScopeDeclare( decl )
1641:          ';'
1643:       | * :
1648:          >
1650:    ]};
      
1653: VarDecl( node_type varNodeType ):
1655:    {[
1655:       | pIdent :
1657:          NodeVec decls = oNodeVecNew
1662:          Node decl
1662:          {
1662:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1678:             oNodeVecAppend( decls, decl )
1687:             [
1687:                | ',' :
1689:                   pIdent
1691:                | * :
1696:                   >
1698:             ]
1698:          }
1700:          ':'
1702:          Node theType
1702:          @TypeRef( theType )
      
1709:          int i = 0
1715:          {[ equal( i, oNodeVecSize( decls ) )
1729:             | false :
1730:                decl = oNodeVecElement( decls, i )
1743:                oNodeSet( decl, qType, theType )
1755:                oScopeDeclareAlloc( decl )
1761:                inc( i )
1767:             | * :
1772:               >
1774:          ]}
      
               % optional initialization
1776:          [
1776:             | '=' :
1778:                [ oNodeVecSize( decls )
1785:                   | 1 :
1786:                   | * :  #eOnlyOneVarCanBeInitialized
1793:                ]
      
                     % we need an initCode stream for this scope
1793:                Code initCode = @GetOrCreateInitCode
1799:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1805:                boolean changedScope = false
1811:                [ equal_node( oScopeCurrent, globalScope )
1820:                   | true : oScopeEnter( mainRoutineScope )
1827:                            changedScope = true
1833:                   | * :
1838:                ]
                     % generate assignment in initCode stream
1838:                @LValueVar( decl )
1845:                @Expr
1847:                @MatchTypes
1849:                @Assign
1851:                [ changedScope
1854:                   | true : oScopeEnd
1856:                   | * :
1861:                ]
1861:                oCodePop
                   
1862:             | * :
1867:          ]
      
1867:          oNodeVecDelete( decls )
1873:          ';'
1875:       | * :
1880:          >
1882:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1885: TypeRef( out Node resultType ):
1887:    [
1887:       | pIdent :           % previously named type (including intrinsics)
1889:          Node decl = oScopeFindRequire
1894:          [ oNodeType( decl )
1901:            | nTypeDecl :
1902:                resultType = oNodeGet( decl, qType )
1915:            | * :
1920:                #eNotType
1922:                resultType = IntegerType
1928:          ]
         
1928:       | pArray :
1930:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1932:          NodeVec dimensions = oNodeVecNew
      
1937:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1937:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1947:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1959:             @ConstExpr
1961:             oNodeSetInt( subrange, qLow, oValueTop )
1972:             oValuePop
1973:             '..'
1975:             @ConstExpr
1977:             oNodeSetInt( subrange, qHigh, oValueTop )
1988:             oValuePop
1989:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
2001:             oTypeAdd( subrange )
      
2007:             Node a = oNodeNew( nArrayType )
2017:             oNodeSet( a, qIndexType, subrange )
      
2029:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
2038:             [
2038:                | ']' : >
2042:                | ',' :
2044:             ]
2052:          }
      
2054:          pOf
2056:          Node baseType
2056:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
2063:          int dim = oNodeVecSize( dimensions )
      
2073:          {
2073:              dec(dim)
      
2079:              Node a = oNodeVecElement( dimensions, dim )
      
2092:              oNodeSet( a, qBaseType, baseType )
2104:              Node subrange = oNodeGet( a, qIndexType )
2117:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2144:              inc( width )
2150:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2176:              oTypeAdd( a )
2182:              baseType = a
      
2188:              [ equal_zero(dim)
2195:                  | true:  >
2198:                  | *:
2203:              ]
2203:          }
      
2205:          resultType = oNodeVecElement( dimensions, 0 )
2218:          oNodeVecDelete( dimensions )
      
2224:       | '^' :
2226:          Node theType
2226:          @TypeRef( theType )
2233:          resultType = @PointerTypeTo( theType )
      
2244:       | pRecord :
2246:          resultType = oNodeNew( nRecordType )
2256:          oScopeBegin( -1 )    % level is meaningless here
      
2262:          @VarDecl( nRecordField )
      
2269:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2281:          [ equal_zero( size )
2288:             | true : #eRecordEmpty
2291:             | * :
2296:          ]
      
2296:          pEnd
      
2298:          oNodeSet( resultType, qScope, oScopeCurrent )
2309:          oNodeSetInt( resultType, qSize, size )
2321:          oScopeEnd
2322:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2328:       | pSet :
2330:          pOf
2332:          Node theType
2332:          @TypeRef( theType )
2339:       | * :       % this works for cases except where expr starts with an id
2352:          @ConstExpr '..' @ConstExpr
2358:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2359: ConstExpr:
2361:    [
2361:       | pIntLit :
2363:          oValuePush( TOKEN_VALUE )
2368:       | pIdent :
2370:          Node decl = oScopeFindRequire
2375:          [ oNodeType( decl )
2382:             | nConst :
2383:                oValuePush( oNodeGetInt( decl, qValue ) )
2396:             | * :
2401:                #eNotConst
2403:                oValuePush( 0 )
2409:          ]
2409:       | pMinus :
2411:          @ConstExpr
2413:          oValueNegate
2414:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2425: Expr:
2427:    Label falseLabel = labelNull
      
2433:    @ExprAllowCF( falseLabel )
2440:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2448: BooleanExprControlFlow( out Label falseLabel ):
2450:    @ExprAllowCF( falseLabel )
2457:    [ oTypeSNodeType
2459:       | nBooleanCFType :
2460:       | nBooleanType :
               % convert value to control flow
2462:          falseLabel = oLabelNew
2467:          .tJumpFalse  oEmitLabel( falseLabel )
2475:       | * :
2482:          #eNotBoolean
2484:    ]
2484:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2486: CFToVal( inout Label falseLabel ):
2488:    [ oTypeSNodeType
2490:       | nBooleanCFType :
2491:          Label doneLabel = oLabelNew
2496:          .tPushConstI  oEmitInt( 1 )
2504:          .tJump  oEmitLabel( doneLabel )
2512:          .tLabel  oEmitLabel( falseLabel )
2520:          .tPushConstI  oEmitInt( 0 )
2528:          .tLabel  oEmitLabel( doneLabel )
2536:          oTypeSPop
2537:          oTypeSPush( BooleanType )
2543:          falseLabel = labelNull
2549:       | * :
2554:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2555: ValToCF( out Label falseLabel ):
2557:    [ oTypeSNodeType
2559:       | nBooleanType :
2560:          falseLabel = oLabelNew
2565:          .tJumpFalse  oEmitLabel( falseLabel )
2573:          oTypeSPop
2574:          oTypeSPush( BooleanCFType )
2580:       | * :
2585:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2586: ExprAllowCF( out Label falseLabel ):
2588:    @BoolExprAllowCF( falseLabel )
2595:    {[
2595:       | '=' :
2597:          @CFToVal( falseLabel )
2604:          @BoolExprAllowCF( falseLabel )
2611:          @CFToVal( falseLabel )
2618:          @MatchTypes
2620:          [ oTypeSNodeType
2622:             | nIntegerType, nBooleanType :  .tEqualI
2625:             | nPointerType :                .tEqualP
2629:             | nCharType, nStringType :      #eNotImplemented
2633:             | * :                           #eNotAllowed
2648:          ]
2648:          oTypeSPop
2649:          oTypeSPush( BooleanType )
      
2655:       | '<>' :
2657:          @CFToVal( falseLabel )
2664:          @BoolExprAllowCF( falseLabel )
2671:          @CFToVal( falseLabel )
2678:          @MatchTypes
2680:          [ oTypeSNodeType
2682:             | nIntegerType, nBooleanType :  .tNotEqualI
2685:             | nPointerType :                .tNotEqualP
2689:             | nCharType, nStringType :      #eNotImplemented
2693:             | * :                           #eNotAllowed
2708:          ]
2708:          oTypeSPop
2709:          oTypeSPush( BooleanType )
      
2715:       | '<' :
2717:          @CFToVal( falseLabel )
2724:          @BoolExprAllowCF( falseLabel )
2731:          @CFToVal( falseLabel )
2738:          @MatchTypes
2740:          [ oTypeSNodeType
2742:             | nIntegerType, nBooleanType :  .tLessI
2745:             | nCharType, nStringType :      #eNotImplemented
2749:             | * :                           #eNotAllowed
2762:          ]
2762:          oTypeSPop
2763:          oTypeSPush( BooleanType )
      
2769:       | '>' :
2771:          @CFToVal( falseLabel )
2778:          @BoolExprAllowCF( falseLabel )
2785:          @CFToVal( falseLabel )
2792:          @MatchTypes
2794:          [ oTypeSNodeType
2796:             | nIntegerType, nBooleanType :  .tGreaterI
2799:             | nCharType, nStringType :      #eNotImplemented
2803:             | * :                           #eNotAllowed
2816:          ]
2816:          oTypeSPop
2817:          oTypeSPush( BooleanType )
      
2823:       | '<=' :
2825:          @CFToVal( falseLabel )
2832:          @BoolExprAllowCF( falseLabel )
2839:          @CFToVal( falseLabel )
2846:          @MatchTypes
2848:          [ oTypeSNodeType
2850:             | nIntegerType, nBooleanType :  .tLessEqualI
2853:             | nCharType, nStringType :      #eNotImplemented
2857:             | * :                           #eNotAllowed
2870:          ]
2870:          oTypeSPop
2871:          oTypeSPush( BooleanType )
      
2877:       | '>=' :
2879:          @CFToVal( falseLabel )
2886:          @BoolExprAllowCF( falseLabel )
2893:          @CFToVal( falseLabel )
2900:          @MatchTypes
2902:          [ oTypeSNodeType
2904:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2907:             | nCharType, nStringType :      #eNotImplemented
2911:             | * :                           #eNotAllowed
2924:          ]
2924:          oTypeSPop
2925:          oTypeSPush( BooleanType )
      
2931:       | * :
2946:          >
2948:    ]};
      
      
2951: BoolExprAllowCF( out Label falseLabel ):
2953:    Label trueLabel = labelNull
      
2959:    @BoolTermAllowCF( falseLabel )
2966:    {[
2966:       | pOr :
2968:          [ oTypeSNodeType
2970:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2971:                [ equal_label( trueLabel, labelNull )
2981:                   | true :  trueLabel = oLabelNew
2987:                   | * :
2992:                ]
2992:                .tJump  oEmitLabel( trueLabel )
3000:             | nBooleanType :
3002:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
3009:                [ equal_label( trueLabel, labelNull )
3019:                   | true :  trueLabel = oLabelNew
3025:                   | * :
3030:                ]
3030:                .tJump  oEmitLabel( trueLabel )
3038:             | * : #eNotBoolean
3047:          ]
3047:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
3048:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
3056:          falseLabel = labelNull
3062:          @BoolTermAllowCF( falseLabel )
      
3069:          [ oTypeSNodeType
3071:             | nBooleanCFType :
3072:             | nBooleanType :
3074:                @ValToCF( falseLabel )
3081:             | * : #eNotBoolean
3090:          ]
      
3090:          oTypeSPop
3091:          oTypeSPush( BooleanCFType )
      
3097:       | * :
3102:          >
3104:    ]}
      
         % any short-circuit trues jump here to the end
3106:    [ equal_label( trueLabel, labelNull )
3116:       | false :
3117:          .tLabel  oEmitLabel( trueLabel )
3125:       | * :
3130:    ]
3131:    ;
      
      
3131: BoolTermAllowCF( out Label falseLabel ):
3133:    Label overallFalseLabel = labelNull
      
3139:    @BoolFactorAllowCF( falseLabel )
3146:    {[
3146:       | pAnd :
3148:          [ oTypeSNodeType
3150:             | nBooleanCFType :
3151:             | nBooleanType :
3153:                @ValToCF( falseLabel )
3160:             | * :
3167:                #eNotBoolean
3169:          ]
3169:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3170:          [ equal_label( overallFalseLabel, labelNull )
3180:             | true :
3181:                overallFalseLabel = oLabelNew
3186:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3200:                falseLabel = overallFalseLabel
3206:             | * :
3211:          ]
      
3211:          Label factorFalseLabel = labelNull
3217:          @BoolFactorAllowCF( factorFalseLabel )
      
3224:          [ oTypeSNodeType
3226:             | nBooleanCFType :
3227:             | nBooleanType :
3229:                @ValToCF( factorFalseLabel )
3236:             | * : #eNotBoolean
3245:          ]
3245:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3259:       | * :
3264:          >
3266:    ]};
      
3269: BoolFactorAllowCF( out Label falseLabel ):
3271:    [
3271:       | pNot :
3273:          Label factorFalseLabel = labelNull
      
3279:          @BoolFactorAllowCF( factorFalseLabel )
3286:          [ oTypeSNodeType
3288:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3289:                falseLabel = oLabelNew
3294:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3302:                .tLabel  oEmitLabel( factorFalseLabel )
      
3310:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3312:                .tNot
      
3314:             | * : #eNotBoolean
3323:          ]
      
3323:       | * :
3328:          @ArithExprAllowCF( falseLabel )
3335:    ];
      
3336: ArithExprAllowCF( out Label falseLabel ):
3338:    @TermAllowCF( falseLabel )
3345:    {[
3345:       | pPlus :
3347:          @RequireIntPop
3349:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3356:          @RequireInt
3358:          .tAddI
3360:       | pMinus :
3362:          @RequireIntPop
3364:          @TermAllowCF( falseLabel )
3371:          @RequireInt
3373:          .tSubI
3375:       | * :
3382:          >
3384:    ]};
      
3387: TermAllowCF( out Label falseLabel ):
3389:    @FactorAllowCF( falseLabel )
3396:    {[
3396:       | pTimes :
3398:          @RequireIntPop
3400:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3407:          @RequireInt
3409:          .tMultI
3411:       | pDivide :
3413:          @RequireIntPop
3415:          @FactorAllowCF( falseLabel )
3422:          @RequireInt
3424:          .tDivI
3426:       | * :
3433:          >
3435:    ]};
      
3438: FactorAllowCF( out Label falseLabel ):
3440:    [
3440:       | pPlus :
3442:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3449:          @RequireInt
3451:       | pMinus :
3453:          @PrimaryAllowCF( falseLabel )
3460:          @RequireInt
3462:          .tNegI
3464:       | * :
3471:          @PrimaryAllowCF( falseLabel )
3478:    ];
      
3479: PrimaryAllowCF( out Label falseLabel ):
3481:    [
3481:       | pIntLit :
3483:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3490:          oTypeSPush( IntegerType )
      
3496:       | '(' :
3498:          @ExprAllowCF( falseLabel )
3505:          ')'
      
3507:       | pStrLit :
3509:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3518:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3526:          oTypeSPush( StringType )
      
3532:       | pIdent :
3534:          Node decl = oScopeFindRequire
3539:          Node theType
      
3539:          [ oNodeType( decl )
3546:             | nFunc :
      
3547:                @Call( decl )
      
3554:             | nConst :
3556:                theType = oNodeGet( decl, qType )
3569:                oTypeSPush( theType )
3575:                [ oTypeSNodeType
3577:                   | nIntegerType, nBooleanType :
3578:                      .tPushConstI @EmitValue( decl )
3587:                   | * :
3594:                      #eNotImplemented
3596:                ]
      
3596:             | nGlobalVar, nLocalVar, nParam :
3598:                @VarExpr( decl )
      
3605:             | * :
3618:                #eNotValue
3620:                oTypeSPush( IntegerType )
3626:          ]
      
3626:       | '@' :        % @var -- pointer to var
3628:          pIdent
      
3630:          Node decl = oScopeFindRequire
3635:          Node theType
      
3635:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3642:          theType = oTypeSTop
3647:          oTypeSPop
3648:          Node ptrType = @PointerTypeTo( theType )
3659:          oTypeSPush( ptrType )
      
3665:       | * :
3678:          #eNotValue
3680:          oTypeSPush( IntegerType )
3686:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3687: VarExpr( Node decl ):
3689:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
3702:    int uplevels = @DeclUpLevels( decl )
      
3713:    oTypeSPush( theType )
3719:    [ oTypeSNodeType
3721:       | nIntegerType :
3722:          [ oNodeType( decl )
3729:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
3739:             | nLocalVar :
3741:                [ equal_zero( uplevels )
3748:                   | true :  .tPushLocalI  @EmitValue( decl )
3758:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
3778:                ]
3778:             | nParam :
3780:                [ oNodeGetBoolean( decl, qInOut )
3790:                   | true :    % VAR param points to the var.  Auto dereference.
3791:                      [ equal_zero( uplevels )
3798:                         | true :  .tPushParamP  @EmitValue( decl )
3808:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3828:                      ]
3828:                      .tFetchI
3830:                   | * :
3835:                      [ equal_zero( uplevels )
3842:                         | true :  .tPushParamI  @EmitValue( decl )
3852:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
3872:                      ]
3872:                ]
3872:          ]
      
3882:       | nBooleanType :
3884:          [ oNodeType( decl )
3891:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
3901:             | nLocalVar :
3903:                [ equal_zero( uplevels )
3910:                   | true :  .tPushLocalB  @EmitValue( decl )
3920:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
3940:                ]
3940:             | nParam :
3942:                [ oNodeGetBoolean( decl, qInOut )
3952:                   | true :    % VAR param points to the var.  Auto dereference.
3953:                      [ equal_zero( uplevels )
3960:                         | true :  .tPushParamP  @EmitValue( decl )
3970:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3990:                      ]
3990:                      .tFetchB
3992:                   | * :
3997:                      [ equal_zero( uplevels )
4004:                         | true :  .tPushParamB  @EmitValue( decl )
4014:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
4034:                      ]
4034:                ]
4034:          ]
      
4044:       | nCharType, nStringType, nFileType :
4046:          #eNotImplemented
      
4048:       | nPointerType :
4050:          [ oNodeType( decl )
4057:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
4067:             | nLocalVar :
4069:                [ equal_zero( uplevels )
4076:                   | true :  .tPushLocalP  @EmitValue( decl )
4086:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4106:                ]
4106:             | nParam :
4108:                [ oNodeGetBoolean( decl, qInOut )
4118:                   | true :    % VAR param points to the var.  Auto dereference.
4119:                      [ equal_zero( uplevels )
4126:                         | true :  .tPushParamP  @EmitValue( decl )
4136:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4156:                      ]
4156:                      .tFetchP
4158:                   | * :
4163:                      [ equal_zero( uplevels )
4170:                         | true :  .tPushParamP  @EmitValue( decl )
4180:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4200:                      ]
4200:                ]
4200:          ]
4210:          [
4210:             | '^' :             % dereferenced
4212:                oTypeSPop
4213:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4226:                @LValueIndexes
4228:                @FetchVar
4230:             | * :               % just ptr value alone
4235:          ]
      
4235:       | * :
               % compound type
               % first, push addr of start of var
4250:          [ oNodeType( decl )
4257:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4267:             | nLocalVar :
4269:                [ equal_zero( uplevels )
4276:                   | true :  .tPushAddrLocal  @EmitValue( decl )
4286:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
4306:                ]
4306:             | nParam :
4308:                [ oNodeGetBoolean( decl, qInOut )
4318:                   | true :    % VAR param points to the var.  Auto dereference.
4319:                      [ equal_zero( uplevels )
4326:                         | true :  .tPushParamP  @EmitValue( decl )
4336:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4356:                      ]
4356:                   | * :
4361:                      [ equal_zero( uplevels )
4368:                         | true :  .tPushAddrParam  @EmitValue( decl )
4378:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
4398:                      ]
4398:                ]
4398:          ]
               % modify addr for subscripts, field references, etc
4408:          @LValueIndexes
               % get final value
4410:          @FetchVar
4412:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
4413: FetchVar:
4415:    [ oTypeSNodeType
4417:       | nIntegerType :   .tFetchI
4420:       | nBooleanType :   .tFetchB
4424:       | nCharType, nStringType, nFileType : #eNotImplemented
4428:       | nPointerType :   .tFetchP
4432:       | * :              % compound type; leave as addr
4447:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
4448: LValueIndexes:
4450:    {[
4450:       | '[' :       @ArraySubscripts
4454:       | '.' :       @RecordFieldRef
4458:       | '^' :       @PointerDeref
4462:       | * :         >
4473:    ]};
      
4476: ArraySubscripts:
4478:    [ oTypeSNodeType
4480:       | nArrayType :
4481:       | * :       #eNotArray
4488:    ]
4488:    {
4488:       [ oTypeSNodeType
4490:          | nArrayType :
4491:          | * :    #eTooManySubscripts
4498:       ]
      
            % low subscript of this dimension
4498:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
4515:       Node baseType
4515:       baseType = oNodeGet( oTypeSTop, qBaseType )
4527:       oTypeSPop
4528:       oTypeSPush( baseType )
      
4534:       @Expr
4536:       @RequireIntPop
            % adjust for low subscript
4538:       [ equal_zero( low )
4545:          | false :
4546:             .tPushConstI oEmitInt( low ) .tSubI
4556:          | * :
4561:       ]
      
            % multiply by element size
4561:       int size = oNodeGetInt( baseType, qSize )
4574:       [ equal( size, 1 )
4584:          | false :
4585:             .tPushConstI oEmitInt( size ) .tMultI
4595:          | * :
4600:       ]
      
            % update start address
4600:       .tAddPI
4602:       [
4602:          | ']' :  >
4606:          | ',' :
4608:       ]
4616:    };
      
      
4619: RecordFieldRef:
4621:    [ oTypeSNodeType
4623:       | nRecordType :
4624:       | * :    #eNotRecord
4631:    ]
4631:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4643:    pIdent
4645:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4650:    [ oNodeType( field )
4657:       | nRecordField :
4658:       | * :   #eNotRecordField
4665:    ]
4665:    oScopeEnd
4666:    int offset = oNodeGetInt( field, qValue )
4679:    [ equal_zero( offset )
4686:       | false :
4687:          .tPushConstI oEmitInt( offset ) .tAddPI
4697:       | * :
4702:    ]
      
         % replace the type on the type stack, with the field type
4702:    oTypeSPop
4703:    oTypeSPush( oNodeGet( field, qType ) )
4717:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4717: PointerDeref:
4719:    [ oTypeSNodeType
4721:       | nPointerType :
4722:       | * :       #eNotPointer
4729:    ]
4729:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4731:    Node theType = oTypeSTop
4736:    oTypeSPop
4737:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4751:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4751: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4753:    @MatchTypes
4756:    ;
      
      
      % Called on first use of an extern method
      %
4756: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4758:    int strAddr
4758:    String externalName = oNodeGetString( method, qExternalName )
4771:    [ equal_string( externalName, stringNull )
4781:       | true :
4782:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4803:       | false :
4805:          strAddr = oStringAllocLit( externalName )
4815:    ]
4823:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4839:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4839: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4841:    [ oNodeGetBoolean( method, qExternal )
4851:       | true :
4852:          [ oNodeGetBoolean( method, qCalled )
4862:             | false :
                     % define the extern label on first use
4863:                @DefineExternLabel( method )
4870:             | * :
4875:          ]
4875:      | * :
4880:    ]
4880:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4892:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4905:    Node resultType
4905:    int tempOffset
      
4905:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4922:    [ isFunc
4925:       | true :
4926:          resultType = oNodeGet( method, qType )
4939:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4949:       | * :
4954:    ]
         
      
4954:    Node paramScope = oNodeGet( method, qParams )
4967:    int actualsSize = oNodeGetInt( paramScope, qSize )
4980:    [ cdecl
4983:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4992:       | false :  .tAllocActuals  oEmitInt( actualsSize )
5002:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
5010:    [ greater( @DeclLevel( method ), 0 )
5025:       | true :
5026:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
5034:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
5053:          .tAssignP
5055:       | * :
5060:    ]
      
      
5060:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
5073:    Node param = oNodeIterValue( paramIter )
5083:    [
5083:       | '(' :
            
5085:          {
5085:             [ oNodeNull( param )
5092:                | true : >
5095:                | * :
5100:             ]
      
5100:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
5113:             .tPushAddrActual oEmitInt( offset )
5121:             oTypeSPush( oNodeGet( param, qType ) )
      
5134:             [ oNodeGetBoolean( param, qInOut )
5144:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5145:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5147:                           @MatchTypes
      
5149:                           .tAssignP
      
5151:                | false :  @Expr
5155:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5157:                           [ oTypeSNodeType
5159:                              | nIntegerType :            .tAssignI
5162:                              | nBooleanType :            .tAssignB
5166:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5170:                              | nPointerType :            .tAssignP
5174:                              | * :
                                       % compound types: copy value into actuals space
5189:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5201:                                  .tCopy  oEmitInt( size )    % multi-word copy
5209:                           ]
5209:             ]
5217:             oTypeSPop
      
5218:             oNodeIterNext( paramIter )
5224:             param = oNodeIterValue( paramIter )
5234:             [ oNodeNull( param )
5241:                | true :  >
5244:                | false :
5246:             ]
      
5254:             ','
5256:          }
      
5258:          ')'
      
5260:       | * :
5265:    ]
      
5265:    [ oNodeNull( param )
5272:       | false :    #eMissingParameter
5275:       | * :
5280:    ]
      
5280:    [ isFunc
5283:       | true :
               % Pass result temp as an additional VAR parameter.
5284:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
5299:          .tPushAddrLocal  oEmitInt( tempOffset )
5307:          .tAssignP
5309:       | * :
5314:    ]
      
5314:    [ cdecl
5317:       | true :
5318:          .tCallCdecl  @EmitValue( method )
5327:       | false :
5329:          .tCall   @EmitValue( method )
5338:    ]
      
5346:    [ isFunc
5349:       | true :
               % push return value from temp
5350:          oTypeSPush( resultType )
      
5356:          [ oTypeSNodeType
5358:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
5367:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
5377:             | nCharType, nStringType, nFileType : #eNotImplemented
5381:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
5391:             | * :              % compound type: push address
5406:                                .tPushAddrLocal  oEmitInt( tempOffset )
5414:          ]
5414:       | * :
5419:    ]
         
5419:    .tFreeActuals  oEmitInt( actualsSize )
5428:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
5428: Statement:
5430:    [
5430:       | pWriteln :     @WritelnStmt
5434:       | pWrite :       @WriteStmt
5438:       | pReadln :      @ReadlnStmt
5442:       | pRead :        @ReadStmt
5446:       | pIf :          @IfStmt
5450:       | pWhile :       @WhileStmt
5454:       | pFor :         @ForStmt
5458:       | pRepeat :      @RepeatStmt
5462:       | pBreak :       @BreakStmt
5466:       | pContinue :    @ContinueStmt
5470:       | pBegin :       @BeginStmt
5474:       | pIdent :       @AssignOrCallStmt
5478:       | * :            % null statement : don't accept any tokens
5505:    ];
      
      
5506: AssignOrCallStmt:
5508:    Node decl = oScopeFindRequire
5513:    [ oNodeType( decl )
5520:       | nProc :                           @Call( decl )
5528:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
5537:       | nFunc :                           @AssignResultStmt( decl )
5546:       | * :                               #eBadStatement
5561:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
5562: AssignStmt( Node decl ):
      
5564:    @LValueVar( decl )
5571:    ':=' 
5573:    @Expr
5575:    @MatchTypes
5577:    @Assign
5580:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
5580: Assign:
5582:    [ oTypeSNodeType
5584:       | nIntegerType :            .tAssignI
5587:       | nBooleanType :            .tAssignB
5591:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5595:       | nPointerType :            .tAssignP
5599:       | * :
5614:           int size = oNodeGetInt( oTypeSTop, qSize )
5626:           .tCopy  oEmitInt( size )    % multi-word copy
5634:    ]
5634:    oTypeSPop
5636:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5636: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5638:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5654:       | false :   #eNotCurrentFunction
5657:       | * :
5662:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5662:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5677:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5690:    ':='
5692:    @Expr
5694:    @MatchTypes
5696:    [ oTypeSNodeType
5698:       | nIntegerType :            .tAssignI
5701:       | nBooleanType :            .tAssignB
5705:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5709:       | nPointerType :            .tAssignP
5713:       | * :
5728:           int size = oNodeGetInt( oTypeSTop, qSize )
5740:           .tCopy  oEmitInt( size )    % multi-word copy
5748:    ]
5748:    oTypeSPop
5750:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5750: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5752:    pIdent
5754:    Node decl = oScopeFindRequire
5759:    [ oNodeType( decl )
5766:       | nGlobalVar, nLocalVar, nParam :
5767:       | * :  #eNotVar
5778:    ]
5778:    @LValueVar( decl )
5786:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5786: LValueVar( Node decl ):
5788:    [ oNodeType( decl )
5795:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5805:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5816:       | nParam :
5818:          [ oNodeGetBoolean( decl, qInOut )
5828:             | true :   % VAR param points to variable.  No dereference.
5829:                        .tPushParamP @EmitValue( decl )
5838:             | * :      .tPushAddrParam @EmitValue( decl )
5852:          ]
5852:       | * :            #eNotVar
5863:    ]
      
5863:    oTypeSPush( oNodeGet( decl, qType ) )
5876:    @LValueIndexes        % handle subscripts, if any
5879:    ;
      
      
5879: IncVar( Node decl ):
5881:    @LValueVar( decl )
5888:    @RequireIntPop
5890:    @VarExpr( decl )
5897:    oTypeSPop
5898:    .tIncI
5900:    .tAssignI;
      
5903: DecVar( Node decl ):
5905:    @LValueVar( decl )
5912:    @RequireIntPop
5914:    @VarExpr( decl )
5921:    oTypeSPop
5922:    .tDecI
5924:    .tAssignI;
      
      
5927: IfStmt:
5929:    Label falseLabel = labelNull
      
5935:    @BooleanExprControlFlow( falseLabel )
5942:    pThen
5944:    @Statement
5946:    [
5946:       | pElse :
5948:          Label doneLabel = oLabelNew
      
5953:          .tJump  oEmitLabel( doneLabel )
5961:          .tLabel oEmitLabel( falseLabel )
5969:          @Statement
5971:          .tLabel oEmitLabel( doneLabel )
      
5979:       | * :
5984:          .tLabel oEmitLabel( falseLabel )
5992:    ];
      
      
5993: ForStmt:
5995:    pIdent
      
5997:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
6002:    @LValueVar( decl )
6009:    @RequireIntPop
      
6011:    ':='
      
6013:    @Expr
6015:    @RequireIntPop
6017:    .tAssignI
      
6019:    Label breakLabel = oLabelNew
      
6024:    Label checkLabel = oLabelNew
6029:    .tJump  oEmitLabel( checkLabel )
      
6037:    Label continueLabel = oLabelNew
6042:    .tLabel  oEmitLabel( continueLabel )
6050:    [
6050:       | pTo :
6052:          @IncVar( decl )
6059:          .tLabel  oEmitLabel( checkLabel )
6067:          @VarExpr( decl )  oTypeSPop
6075:          @Expr
6077:          @RequireIntPop
6079:          .tGreaterI
6081:          .tJumpTrue  oEmitLabel( breakLabel )
6089:       | pDownto :
6091:          @DecVar( decl )
6098:          .tLabel  oEmitLabel( checkLabel )
6106:          @VarExpr( decl )  oTypeSPop
6114:          @Expr
6116:          @RequireIntPop
6118:          .tLessI
6120:          .tJumpTrue  oEmitLabel( breakLabel )
6128:    ]
6136:    oLoopPush( continueLabel, breakLabel )
6145:    pDo
6147:    @Statement
6149:    .tJump  oEmitLabel( continueLabel )
6157:    .tLabel  oEmitLabel( breakLabel )
6165:    oLoopPop;
      
      
6167: RepeatStmt:
6169:    Label continueLabel = oLabelNew
6174:    .tLabel  oEmitLabel( continueLabel )
      
6182:    Label breakLabel = oLabelNew
      
6187:    oLoopPush( continueLabel, breakLabel )
6196:    @Statement
6198:    {[
6198:       | ';' :
6200:          @Statement
6202:       | pUntil :
6204:          Label falseLabel
6204:          @BooleanExprControlFlow( falseLabel )
6211:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6225:          >
6227:    ]}
6237:    .tLabel  oEmitLabel( breakLabel )
6245:    oLoopPop;
      
      
6247: WhileStmt:
6249:    Label continueLabel = oLabelNew
6254:    .tLabel  oEmitLabel( continueLabel )
      
6262:    Label breakLabel
6262:    @BooleanExprControlFlow( breakLabel )
      
6269:    oLoopPush( continueLabel, breakLabel )
6278:    pDo
6280:    @Statement
6282:    .tJump  oEmitLabel( continueLabel )
6290:    .tLabel  oEmitLabel( breakLabel )
6298:    oLoopPop;
      
      
6300: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
6302:    [ equal_label( oLoopContinueLabel, labelNull )
6311:       | true :
6312:          #eNotInALoop
6314:       | false :
6316:          .tJump  oEmitLabel( oLoopContinueLabel )
6323:    ];
      
      
6332: BreakStmt:
6334:    [ equal_label( oLoopBreakLabel, labelNull )
6343:       | true :
6344:          #eNotInALoop
6346:       | false :
6348:          .tJump  oEmitLabel( oLoopBreakLabel )
6355:    ];
      
      
6364: BeginStmt:
6366:    @Statement
6368:    {[
6368:       | ';' :   @Statement
6372:       | pEnd :  >
6376:    ]};
      
      
6387: WritelnStmt:
6389:    @WriteStmt
6391:    .tWriteCR;
      
      
6394: WriteStmt:
6396:    [
6396:       | '(' :
6398:          {
6398:             @Expr
6400:             [ oTypeSNodeType
6402:                | nIntegerType :             .tWriteI
6405:                | nBooleanType :             .tWriteBool
6409:                | nStringType :              .tWriteStr
6413:                | nCharType, nFileType :     #eNotImplemented
6417:                | nPointerType :             .tWriteP
6421:                | * :                        #eNotAllowed
6438:             ]
6438:             oTypeSPop
6439:             [
6439:                | ')' : >
6443:                | ',' :
6445:             ]
6453:          }
6455:       | * :
6460:    ];
      
      
6461: ReadlnStmt:      % ***
         % TO DO
6464:    ;
      
6464: ReadStmt:
         % TO DO
6467:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Return the static scope level of the given declaration
      %
6467: DeclLevel( Node decl ) >> int:
6469:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
6487: DeclUpLevels( Node decl ) >> int:
6489:    >> subtract( oNodeGetInt( oScopeCurrent, qLevel ), @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
6511: MatchTypes:
6513:    node_type nt = oTypeSNodeType
6518:    oTypeSPop
6519:    [ equal_node_type( nt, oTypeSNodeType )
6528:       | false :
6529:          #eTypeMismatch
6531:       | * :
6536:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
6537: RequireIntPop:
6539:    [ oTypeSNodeType
6541:       | nIntegerType :
6542:       | * :          #eNotInteger
6549:    ]
6549:    oTypeSPop;
      
6551: RequireInt:
6553:    [ oTypeSNodeType
6555:       | nIntegerType :
6556:       | * :          #eNotInteger
6563:    ];
      
6564: RequireBoolPop:
6566:    [ oTypeSNodeType
6568:       | nBooleanType :
6569:       | * :          #eNotBoolean
6576:    ]
6576:    oTypeSPop;
      
6578: RequireBool:
6580:    [ oTypeSNodeType
6582:       | nBooleanType :
6583:       | * :          #eNotBoolean
6590:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
6591: newType( node_type nt, int size ) >> Node:
6593:   Node node = oNodeNew( nt )
6603:   oNodeSetInt( node, qSize, size )
6615:   oTypeAdd( node )
6621:   >> node
6625:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
6625: newIdent( node_type nt, kind k, int id ) >> Node:
6627:   Node t = oNodeNew( nt )
6637:   oNodeSetInt( t, qIdent, id )
6649:   >> t
6653:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6653: PointerTypeTo( Node theType ) >> Node:
6655:    Node ptrType = oNodeGet( theType, qPointerType )
6668:    [ oNodeNull( ptrType )
6675:       | true :
6676:          ptrType = oNodeNew( nPointerType )
6686:          oNodeSet( ptrType, qBaseType, theType )
6698:          oNodeSetInt( ptrType, qSize, 8 )
6710:          oTypeAdd( ptrType )
6716:          oNodeSet( theType, qPointerType, ptrType )
6728:       | * :
6733:    ]
6733:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6737: OrdinalLow( Node theType ) >> int:
6739:    [ oNodeType( theType )
6746:       | nIntegerType :  >> oMININT
6749:       | nBooleanType :  >> 0
6754:       | nCharType :     >> 0
6759:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6771:       | * :             #eNotOrdinalType
6784:                         >> 0
6787:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6788: EmitValue( Node decl ):
6790:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6804: installBuiltIns:
      
         % install built-in types
6806:    FileType = @newType( nFileType, 4 )
6820:    IntegerType = @newType( nIntegerType, 4 )
6834:    BooleanType = @newType( nBooleanType, 1 )
6848:    BooleanCFType = @newType( nBooleanCFType, 1 )
6862:    CharType = @newType( nCharType, 1 )
6876:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6890:    Node t
      
6890:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6906:    oNodeSet( t, qType, FileType )
6918:    oScopeDeclare( t )
      
6924:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6940:    oNodeSet( t, qType, IntegerType )
6952:    oScopeDeclare( t )
      
6958:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6974:    oNodeSet( t, qType, BooleanType )
6986:    oScopeDeclare( t )
      
6992:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
7008:    oNodeSet( t, qType, CharType )
7020:    oScopeDeclare( t )
      
7026:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
7042:    oNodeSet( t, qType, StringType )
7054:    oScopeDeclare( t )
      
         % Built-in constants
      
7060:    t = @newIdent( nConst, kConst, oIdAdd_True )
7076:    oNodeSet( t, qType, BooleanType )
7088:    oNodeSetInt( t, qValue, 1 )
7100:    oScopeDeclare( t )
      
7106:    t = @newIdent( nConst, kConst, oIdAdd_False )
7122:    oNodeSet( t, qType, BooleanType )
7134:    oNodeSetInt( t, qValue, 0 )
7146:    oScopeDeclare( t )
      
7153:    ;
      
7153: end
      
7153: 

Generated code:

   0: oGlobalSpace 10
   2: oLocalSpace 3
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oSetResult 2
   9: oPushResult
  10: oNodeNew
  11: oPop 1
  13: oAssign
  14: oSetResult 0
  16: oPushResult
  17: oScopeBegin
  18: oPop 1
  20: oGetAddrGlobal 2
  22: oPushResult
  23: oScopeCurrent
  24: oAssign
  25: oCall 6804
  27: oEmit 52
  29: oSetResult 0
  31: oPushResult
  32: oEmitInt
  33: oPop 1
  35: oGetAddrLocal 2
  37: oPushResult
  38: oLabelNew
  39: oAssign
  40: oEmit 46
  42: oSetResult 0
  44: oPushResult
  45: oEmitInt
  46: oPop 1
  48: oEmit 49
  50: oGetLocal 2
  52: oPushResult
  53: oEmitLabel
  54: oPop 1
  56: oEmit 48
  58: oSetResult 0
  60: oPushResult
  61: oEmitInt
  62: oPop 1
  64: oEmit 51
  66: oInput 27
  68: oInput 0
  70: oGetAddrLocal 3
  72: oPushResult
  73: oSetResult 3
  75: oPushResult
  76: oNodeNew
  77: oPop 1
  79: oAssign
  80: oGetLocal 3
  82: oPushResult
  83: oSetResult 3
  85: oPushResult
  86: LAST_ID
  87: oPushResult
  88: oNodeSetInt
  89: oPop 3
  91: oGetGlobal 1
  93: oPushResult
  94: oSetResult 2
  96: oPushResult
  97: oGetLocal 3
  99: oPushResult
 100: oNodeSet
 101: oPop 3
 103: oInputChoice 183
 105: oInput 0
 107: oGetAddrLocal 1
 109: oPushResult
 110: oSetResult 13
 112: oPushResult
 113: oSetResult 6
 115: oPushResult
 116: LAST_ID
 117: oPushResult
 118: oCall 6625
 120: oPop 3
 122: oAssign
 123: oGetLocal 1
 125: oPushResult
 126: oSetResult 17
 128: oPushResult
 129: oGetGlobal 4
 131: oPushResult
 132: oNodeSet
 133: oPop 3
 135: oGetLocal 1
 137: oPushResult
 138: oScopeDeclareAlloc
 139: oPop 1
 141: oInput 12
 143: oInput 0
 145: oGetAddrLocal 1
 147: oPushResult
 148: oSetResult 13
 150: oPushResult
 151: oSetResult 6
 153: oPushResult
 154: LAST_ID
 155: oPushResult
 156: oCall 6625
 158: oPop 3
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 17
 166: oPushResult
 167: oGetGlobal 4
 169: oPushResult
 170: oNodeSet
 171: oPop 3
 173: oGetLocal 1
 175: oPushResult
 176: oScopeDeclareAlloc
 177: oPop 1
 179: oInput 14
 181: oJumpForward 186
 183: Choice Lookup Table
          13    105
 186: oInput 4
 188: oSetResult 0
 190: oPushResult
 191: oScopeBegin
 192: oPop 1
 194: oGetAddrGlobal 3
 196: oPushResult
 197: oScopeCurrent
 198: oAssign
 199: oScopeCurrent
 200: oPushResult
 201: oSetResult 14
 203: oPushResult
 204: oSetResult 1
 206: oPushResult
 207: oNodeSetBoolean
 208: oPop 3
 210: oGetLocal 3
 212: oPushResult
 213: oSetResult 6
 215: oPushResult
 216: oScopeCurrent
 217: oPushResult
 218: oNodeSet
 219: oPop 3
 221: oScopeEnd
 222: oSetResult 14
 224: oPushResult
 225: oCall 269
 227: oPop 1
 229: oGetGlobal 3
 231: oPushResult
 232: oScopeEnter
 233: oPop 1
 235: oGetLocal 2
 237: oPushResult
 238: oGetGlobal 2
 240: oPushResult
 241: oCall 319
 243: oPop 2
 245: oScopeEnd
 246: oInput 19
 248: oScopeEnd
 249: oReturn
 250: oLocalSpace 0
 252: oGetParam 2
 254: oPushResult
 255: oCall 269
 257: oPop 1
 259: oGetParam 1
 261: oPushResult
 262: oScopeCurrent
 263: oPushResult
 264: oCall 319
 266: oPop 2
 268: oReturn
 269: oLocalSpace 0
 271: oInputChoice 298
 273: oCall 1522
 275: oJumpForward 311
 277: oCall 1594
 279: oJumpForward 311
 281: oGetParam 1
 283: oPushResult
 284: oCall 1653
 286: oPop 1
 288: oJumpForward 311
 290: oCall 534
 292: oJumpForward 311
 294: oCall 884
 296: oJumpForward 311
 298: Choice Lookup Table
          29    294
          28    290
          32    281
          31    277
          30    273
 309: oJumpForward 313
 311: oJumpBack 271
 313: oCall 316
 315: oReturn
 316: oLocalSpace 0
 318: oReturn
 319: oLocalSpace 3
 321: oEmit 56
 323: oGetParam 2
 325: oPushResult
 326: oEmitLabel
 327: oPop 1
 329: oEmit 52
 331: oGetAddrLocal 1
 333: oPushResult
 334: Here
 335: oAssign
 336: oEmit 64
 338: oGetAddrLocal 2
 340: oPushResult
 341: oGetParam 1
 343: oPushResult
 344: oSetResult 15
 346: oPushResult
 347: oNodeGetCode
 348: oPop 2
 350: oAssign
 351: oGetLocal 2
 353: oPushResult
 354: oEmitCode
 355: oPop 1
 357: oScopeCurrent
 358: oPushResult
 359: oSetResult 15
 361: oPushResult
 362: oSetResult 0
 364: oPushResult
 365: oNodeSetCode
 366: oPop 3
 368: oCall 5428
 370: oEmit 51
 372: oGetAddrLocal 3
 374: oPushResult
 375: oScopeCurrent
 376: oPushResult
 377: oSetResult 13
 379: oPushResult
 380: oNodeGetInt
 381: oPop 2
 383: oAssign
 384: oGetLocal 1
 386: oPushResult
 387: oGetLocal 3
 389: oPushResult
 390: oPatch
 391: oPop 2
 393: oReturn
 394: oLocalSpace 0
 396: oInputChoice 414
 398: oGetParam 1
 400: oPushResult
 401: oSetResult 23
 403: oPushResult
 404: oSetResult 1
 406: oPushResult
 407: oNodeSetBoolean
 408: oPop 3
 410: oInput 4
 412: oJumpForward 419
 414: Choice Lookup Table
          67    398
 417: oJumpForward 421
 419: oJumpBack 396
 421: oReturn
 422: oLocalSpace 1
 424: oGetAddrLocal 1
 426: oPushResult
 427: oScopeCurrent
 428: oPushResult
 429: oSetResult 15
 431: oPushResult
 432: oNodeGetCode
 433: oPop 2
 435: oAssign
 436: oGetLocal 1
 438: oPushResult
 439: oSetResult 0
 441: oPushResult
 442: equal_code
 443: oPop 2
 445: oChoice 465
 447: oGetAddrLocal 1
 449: oPushResult
 450: oCodeNew
 451: oAssign
 452: oScopeCurrent
 453: oPushResult
 454: oSetResult 15
 456: oPushResult
 457: oGetLocal 1
 459: oPushResult
 460: oNodeSetCode
 461: oPop 3
 463: oJumpForward 468
 465: Choice Lookup Table
           1    447
 468: oGetLocal 1
 470: oReturn
 471: oReturn
 472: oLocalSpace 0
 474: oGetParam 1
 476: oPushResult
 477: oCall 6467
 479: oPop 1
 481: oPushResult
 482: equal_zero
 483: oPop 1
 485: oChoice 491
 487: oError 23
 489: oJumpForward 494
 491: Choice Lookup Table
           0    487
 494: oGetParam 1
 496: oPushResult
 497: oSetResult 21
 499: oPushResult
 500: oSetResult 1
 502: oPushResult
 503: oNodeSetBoolean
 504: oPop 3
 506: oInputChoice 530
 508: oInputChoice 525
 510: oInput 2
 512: oGetParam 1
 514: oPushResult
 515: oSetResult 22
 517: oPushResult
 518: CURRENT_STRLIT
 519: oPushResult
 520: oNodeSetString
 521: oPop 3
 523: oJumpForward 528
 525: Choice Lookup Table
          66    510
 528: oJumpForward 533
 530: Choice Lookup Table
           2    508
 533: oReturn
 534: oLocalSpace 7
 536: oInput 0
 538: oGetAddrLocal 1
 540: oPushResult
 541: oSetResult 0
 543: oAssign
 544: oGetAddrLocal 2
 546: oPushResult
 547: oScopeFindInCurrentScope
 548: oAssign
 549: oGetLocal 2
 551: oPushResult
 552: oNodeNull
 553: oPop 1
 555: oChoice 676
 557: oGetAddrLocal 2
 559: oPushResult
 560: oSetResult 9
 562: oPushResult
 563: oSetResult 2
 565: oPushResult
 566: LAST_ID
 567: oPushResult
 568: oCall 6625
 570: oPop 3
 572: oAssign
 573: oGetLocal 2
 575: oPushResult
 576: oSetResult 18
 578: oPushResult
 579: oLabelNew
 580: oPushResult
 581: oNodeSetLabel
 582: oPop 3
 584: oJumpForward 682
 586: oGetAddrLocal 1
 588: oPushResult
 589: oSetResult 1
 591: oAssign
 592: oGetLocal 2
 594: oPushResult
 595: oSetResult 20
 597: oPushResult
 598: oNodeGetBoolean
 599: oPop 2
 601: oChoice 607
 603: oError 21
 605: oJumpForward 610
 607: Choice Lookup Table
           1    603
 610: oGetLocal 2
 612: oPushResult
 613: oSetResult 21
 615: oPushResult
 616: oNodeGetBoolean
 617: oPop 2
 619: oChoice 625
 621: oError 21
 623: oJumpForward 628
 625: Choice Lookup Table
           1    621
 628: oGetLocal 2
 630: oPushResult
 631: oNodeType
 632: oPop 1
 634: oChoice 638
 636: oJumpForward 643
 638: Choice Lookup Table
           9    636
 641: oError 21
 643: oGetLocal 2
 645: oPushResult
 646: oSetResult 25
 648: oPushResult
 649: oGetLocal 2
 651: oPushResult
 652: oSetResult 19
 654: oPushResult
 655: oNodeGet
 656: oPop 2
 658: oPushResult
 659: oNodeSet
 660: oPop 3
 662: oGetLocal 2
 664: oPushResult
 665: oSetResult 19
 667: oPushResult
 668: oSetResult 0
 670: oPushResult
 671: oNodeSet
 672: oPop 3
 674: oJumpForward 682
 676: Choice Lookup Table
           0    586
           1    557
 681: oEndChoice
 682: oGetAddrLocal 3
 684: oPushResult
 685: oScopeCurrent
 686: oPushResult
 687: oSetResult 11
 689: oPushResult
 690: oNodeGetInt
 691: oPop 2
 693: oAssign
 694: oGetAddrLocal 4
 696: oPushResult
 697: oGetLocal 3
 699: oPushResult
 700: oSetResult 0
 702: oPushResult
 703: greater
 704: oPop 2
 706: oAssign
 707: oGetAddrLocal 3
 709: oPushResult
 710: inc
 711: oPop 1
 713: oGetLocal 3
 715: oPushResult
 716: oScopeBegin
 717: oPop 1
 719: oGetAddrLocal 5
 721: oPushResult
 722: oScopeCurrent
 723: oAssign
 724: oGetLocal 4
 726: oChoice 745
 728: oGetAddrLocal 6
 730: oPushResult
 731: oGetGlobal 5
 733: oPushResult
 734: oCall 6653
 736: oPop 1
 738: oPushResult
 739: oScopeAllocType
 740: oPop 1
 742: oAssign
 743: oJumpForward 748
 745: Choice Lookup Table
           1    728
 748: oCall 1295
 750: oGetLocal 2
 752: oPushResult
 753: oSetResult 19
 755: oPushResult
 756: oGetLocal 5
 758: oPushResult
 759: oNodeSet
 760: oPop 3
 762: oScopeEnd
 763: oInput 4
 765: oGetLocal 1
 767: oChoice 779
 769: oGetLocal 2
 771: oPushResult
 772: oScopeDeclare
 773: oPop 1
 775: oJumpForward 785
 777: oJumpForward 785
 779: Choice Lookup Table
           1    777
           0    769
 784: oEndChoice
 785: oGetLocal 2
 787: oPushResult
 788: oCall 394
 790: oPop 1
 792: oInputChoice 805
 794: oJumpForward 881
 796: oGetLocal 2
 798: oPushResult
 799: oCall 472
 801: oPop 1
 803: oJumpForward 881
 805: Choice Lookup Table
          65    796
          64    794
 810: oGetLocal 5
 812: oPushResult
 813: oScopeEnter
 814: oPop 1
 816: oGetLocal 3
 818: oPushResult
 819: oScopeBegin
 820: oPop 1
 822: oScopeCurrent
 823: oPushResult
 824: oSetResult 14
 826: oPushResult
 827: oSetResult 1
 829: oPushResult
 830: oNodeSetBoolean
 831: oPop 3
 833: oGetLocal 2
 835: oPushResult
 836: oSetResult 5
 838: oPushResult
 839: oScopeCurrent
 840: oPushResult
 841: oNodeSet
 842: oPop 3
 844: oGetAddrLocal 7
 846: oPushResult
 847: oGetLocal 2
 849: oPushResult
 850: oSetResult 18
 852: oPushResult
 853: oNodeGetLabel
 854: oPop 2
 856: oAssign
 857: oSetResult 15
 859: oPushResult
 860: oGetLocal 7
 862: oPushResult
 863: oCall 250
 865: oPop 2
 867: oGetLocal 2
 869: oPushResult
 870: oSetResult 20
 872: oPushResult
 873: oSetResult 1
 875: oPushResult
 876: oNodeSetBoolean
 877: oPop 3
 879: oScopeEnd
 880: oScopeEnd
 881: oInput 4
 883: oReturn
 884: oLocalSpace 9
 886: oInput 0
 888: oGetAddrLocal 1
 890: oPushResult
 891: oSetResult 0
 893: oAssign
 894: oGetAddrLocal 2
 896: oPushResult
 897: oScopeFindInCurrentScope
 898: oAssign
 899: oGetLocal 2
 901: oPushResult
 902: oNodeNull
 903: oPop 1
 905: oChoice 1039
 907: oGetAddrLocal 2
 909: oPushResult
 910: oSetResult 10
 912: oPushResult
 913: oSetResult 3
 915: oPushResult
 916: LAST_ID
 917: oPushResult
 918: oCall 6625
 920: oPop 3
 922: oAssign
 923: oGetLocal 2
 925: oPushResult
 926: oSetResult 18
 928: oPushResult
 929: oLabelNew
 930: oPushResult
 931: oNodeSetLabel
 932: oPop 3
 934: oJumpForward 1045
 936: oGetAddrLocal 1
 938: oPushResult
 939: oSetResult 1
 941: oAssign
 942: oGetLocal 2
 944: oPushResult
 945: oSetResult 20
 947: oPushResult
 948: oNodeGetBoolean
 949: oPop 2
 951: oChoice 957
 953: oError 21
 955: oJumpForward 960
 957: Choice Lookup Table
           1    953
 960: oGetLocal 2
 962: oPushResult
 963: oNodeType
 964: oPop 1
 966: oChoice 970
 968: oJumpForward 975
 970: Choice Lookup Table
          10    968
 973: oError 21
 975: oGetLocal 2
 977: oPushResult
 978: oSetResult 25
 980: oPushResult
 981: oGetLocal 2
 983: oPushResult
 984: oSetResult 19
 986: oPushResult
 987: oNodeGet
 988: oPop 2
 990: oPushResult
 991: oNodeSet
 992: oPop 3
 994: oGetLocal 2
 996: oPushResult
 997: oSetResult 19
 999: oPushResult
1000: oSetResult 0
1002: oPushResult
1003: oNodeSet
1004: oPop 3
1006: oGetLocal 2
1008: oPushResult
1009: oSetResult 26
1011: oPushResult
1012: oGetLocal 2
1014: oPushResult
1015: oSetResult 17
1017: oPushResult
1018: oNodeGet
1019: oPop 2
1021: oPushResult
1022: oNodeSet
1023: oPop 3
1025: oGetLocal 2
1027: oPushResult
1028: oSetResult 17
1030: oPushResult
1031: oSetResult 0
1033: oPushResult
1034: oNodeSet
1035: oPop 3
1037: oJumpForward 1045
1039: Choice Lookup Table
           0    936
           1    907
1044: oEndChoice
1045: oGetAddrLocal 3
1047: oPushResult
1048: oScopeCurrent
1049: oPushResult
1050: oSetResult 11
1052: oPushResult
1053: oNodeGetInt
1054: oPop 2
1056: oAssign
1057: oGetAddrLocal 4
1059: oPushResult
1060: oGetLocal 3
1062: oPushResult
1063: oSetResult 0
1065: oPushResult
1066: greater
1067: oPop 2
1069: oAssign
1070: oGetAddrLocal 3
1072: oPushResult
1073: inc
1074: oPop 1
1076: oGetLocal 3
1078: oPushResult
1079: oScopeBegin
1080: oPop 1
1082: oGetAddrLocal 5
1084: oPushResult
1085: oScopeCurrent
1086: oAssign
1087: oGetLocal 4
1089: oChoice 1108
1091: oGetAddrLocal 6
1093: oPushResult
1094: oGetGlobal 5
1096: oPushResult
1097: oCall 6653
1099: oPop 1
1101: oPushResult
1102: oScopeAllocType
1103: oPop 1
1105: oAssign
1106: oJumpForward 1111
1108: Choice Lookup Table
           1   1091
1111: oCall 1295
1113: oGetLocal 2
1115: oPushResult
1116: oSetResult 19
1118: oPushResult
1119: oGetLocal 5
1121: oPushResult
1122: oNodeSet
1123: oPop 3
1125: oInput 11
1127: oGetAddrLocal 7
1129: oPushResult
1130: oCall 1885
1132: oPop 1
1134: oGetLocal 2
1136: oPushResult
1137: oSetResult 17
1139: oPushResult
1140: oGetLocal 7
1142: oPushResult
1143: oNodeSet
1144: oPop 3
1146: oGetAddrLocal 8
1148: oPushResult
1149: oGetLocal 7
1151: oPushResult
1152: oCall 6653
1154: oPop 1
1156: oAssign
1157: oGetLocal 2
1159: oPushResult
1160: oSetResult 27
1162: oPushResult
1163: oGetLocal 8
1165: oPushResult
1166: oScopeAllocType
1167: oPop 1
1169: oPushResult
1170: oNodeSetInt
1171: oPop 3
1173: oScopeEnd
1174: oInput 4
1176: oGetLocal 1
1178: oChoice 1190
1180: oGetLocal 2
1182: oPushResult
1183: oScopeDeclare
1184: oPop 1
1186: oJumpForward 1196
1188: oJumpForward 1196
1190: Choice Lookup Table
           1   1188
           0   1180
1195: oEndChoice
1196: oGetLocal 2
1198: oPushResult
1199: oCall 394
1201: oPop 1
1203: oInputChoice 1216
1205: oJumpForward 1292
1207: oGetLocal 2
1209: oPushResult
1210: oCall 472
1212: oPop 1
1214: oJumpForward 1292
1216: Choice Lookup Table
          65   1207
          64   1205
1221: oGetLocal 5
1223: oPushResult
1224: oScopeEnter
1225: oPop 1
1227: oGetLocal 3
1229: oPushResult
1230: oScopeBegin
1231: oPop 1
1233: oScopeCurrent
1234: oPushResult
1235: oSetResult 14
1237: oPushResult
1238: oSetResult 1
1240: oPushResult
1241: oNodeSetBoolean
1242: oPop 3
1244: oGetLocal 2
1246: oPushResult
1247: oSetResult 5
1249: oPushResult
1250: oScopeCurrent
1251: oPushResult
1252: oNodeSet
1253: oPop 3
1255: oGetAddrLocal 9
1257: oPushResult
1258: oGetLocal 2
1260: oPushResult
1261: oSetResult 18
1263: oPushResult
1264: oNodeGetLabel
1265: oPop 2
1267: oAssign
1268: oSetResult 15
1270: oPushResult
1271: oGetLocal 9
1273: oPushResult
1274: oCall 250
1276: oPop 2
1278: oGetLocal 2
1280: oPushResult
1281: oSetResult 20
1283: oPushResult
1284: oSetResult 1
1286: oPushResult
1287: oNodeSetBoolean
1288: oPop 3
1290: oScopeEnd
1291: oScopeEnd
1292: oInput 4
1294: oReturn
1295: oLocalSpace 6
1297: oInputChoice 1518
1299: oGetAddrLocal 1
1301: oPushResult
1302: oNodeVecNew
1303: oAssign
1304: oGetAddrLocal 3
1306: oPushResult
1307: oSetResult 0
1309: oAssign
1310: oInputChoice 1320
1312: oGetAddrLocal 3
1314: oPushResult
1315: oSetResult 1
1317: oAssign
1318: oJumpForward 1323
1320: Choice Lookup Table
          32   1312
1323: oInput 0
1325: oGetAddrLocal 2
1327: oPushResult
1328: oSetResult 17
1330: oPushResult
1331: oSetResult 6
1333: oPushResult
1334: LAST_ID
1335: oPushResult
1336: oCall 6625
1338: oPop 3
1340: oAssign
1341: oGetLocal 2
1343: oPushResult
1344: oSetResult 28
1346: oPushResult
1347: oGetLocal 3
1349: oPushResult
1350: oNodeSetBoolean
1351: oPop 3
1353: oGetLocal 1
1355: oPushResult
1356: oGetLocal 2
1358: oPushResult
1359: oNodeVecAppend
1360: oPop 2
1362: oInputChoice 1370
1364: oJumpForward 1378
1366: oJumpForward 1376
1368: oJumpForward 1376
1370: Choice Lookup Table
          12   1368
          11   1364
1375: oEndChoice
1376: oJumpBack 1323
1378: oGetAddrLocal 4
1380: oPushResult
1381: oCall 1885
1383: oPop 1
1385: oGetLocal 3
1387: oChoice 1402
1389: oGetAddrLocal 5
1391: oPushResult
1392: oGetLocal 4
1394: oPushResult
1395: oCall 6653
1397: oPop 1
1399: oAssign
1400: oJumpForward 1411
1402: Choice Lookup Table
           1   1389
1405: oGetAddrLocal 5
1407: oPushResult
1408: oGetLocal 4
1410: oAssign
1411: oGetAddrLocal 6
1413: oPushResult
1414: oSetResult 0
1416: oAssign
1417: oGetLocal 6
1419: oPushResult
1420: oGetLocal 1
1422: oPushResult
1423: oNodeVecSize
1424: oPop 1
1426: oPushResult
1427: equal
1428: oPop 2
1430: oChoice 1487
1432: oGetAddrLocal 2
1434: oPushResult
1435: oGetLocal 1
1437: oPushResult
1438: oGetLocal 6
1440: oPushResult
1441: oNodeVecElement
1442: oPop 2
1444: oAssign
1445: oGetLocal 2
1447: oPushResult
1448: oSetResult 17
1450: oPushResult
1451: oGetLocal 4
1453: oPushResult
1454: oNodeSet
1455: oPop 3
1457: oGetLocal 2
1459: oPushResult
1460: oScopeDeclare
1461: oPop 1
1463: oGetLocal 2
1465: oPushResult
1466: oSetResult 18
1468: oPushResult
1469: oGetLocal 5
1471: oPushResult
1472: oScopeAllocType
1473: oPop 1
1475: oPushResult
1476: oNodeSetInt
1477: oPop 3
1479: oGetAddrLocal 6
1481: oPushResult
1482: inc
1483: oPop 1
1485: oJumpForward 1492
1487: Choice Lookup Table
           0   1432
1490: oJumpForward 1494
1492: oJumpBack 1417
1494: oGetLocal 1
1496: oPushResult
1497: oNodeVecDelete
1498: oPop 1
1500: oInputChoice 1508
1502: oJumpForward 1516
1504: oJumpForward 1514
1506: oJumpForward 1514
1508: Choice Lookup Table
           4   1506
          14   1502
1513: oEndChoice
1514: oJumpBack 1299
1516: oJumpForward 1521
1518: Choice Lookup Table
          13   1299
1521: oReturn
1522: oLocalSpace 2
1524: oInputChoice 1586
1526: oGetAddrLocal 1
1528: oPushResult
1529: oSetResult 11
1531: oPushResult
1532: oSetResult 4
1534: oPushResult
1535: LAST_ID
1536: oPushResult
1537: oCall 6625
1539: oPop 3
1541: oAssign
1542: oInput 5
1544: oCall 2359
1546: oGetAddrLocal 2
1548: oPushResult
1549: oValueTop
1550: oAssign
1551: oValuePop
1552: oGetLocal 1
1554: oPushResult
1555: oSetResult 18
1557: oPushResult
1558: oGetLocal 2
1560: oPushResult
1561: oNodeSetInt
1562: oPop 3
1564: oGetLocal 1
1566: oPushResult
1567: oSetResult 17
1569: oPushResult
1570: oGetGlobal 5
1572: oPushResult
1573: oNodeSet
1574: oPop 3
1576: oGetLocal 1
1578: oPushResult
1579: oScopeDeclare
1580: oPop 1
1582: oInput 4
1584: oJumpForward 1591
1586: Choice Lookup Table
           0   1526
1589: oJumpForward 1593
1591: oJumpBack 1524
1593: oReturn
1594: oLocalSpace 2
1596: oInputChoice 1645
1598: oGetAddrLocal 1
1600: oPushResult
1601: oSetResult 12
1603: oPushResult
1604: oSetResult 5
1606: oPushResult
1607: LAST_ID
1608: oPushResult
1609: oCall 6625
1611: oPop 3
1613: oAssign
1614: oInput 5
1616: oGetAddrLocal 2
1618: oPushResult
1619: oCall 1885
1621: oPop 1
1623: oGetLocal 1
1625: oPushResult
1626: oSetResult 17
1628: oPushResult
1629: oGetLocal 2
1631: oPushResult
1632: oNodeSet
1633: oPop 3
1635: oGetLocal 1
1637: oPushResult
1638: oScopeDeclare
1639: oPop 1
1641: oInput 4
1643: oJumpForward 1650
1645: Choice Lookup Table
           0   1598
1648: oJumpForward 1652
1650: oJumpBack 1596
1652: oReturn
1653: oLocalSpace 6
1655: oInputChoice 1877
1657: oGetAddrLocal 1
1659: oPushResult
1660: oNodeVecNew
1661: oAssign
1662: oGetAddrLocal 2
1664: oPushResult
1665: oGetParam 1
1667: oPushResult
1668: oSetResult 6
1670: oPushResult
1671: LAST_ID
1672: oPushResult
1673: oCall 6625
1675: oPop 3
1677: oAssign
1678: oGetLocal 1
1680: oPushResult
1681: oGetLocal 2
1683: oPushResult
1684: oNodeVecAppend
1685: oPop 2
1687: oInputChoice 1693
1689: oInput 0
1691: oJumpForward 1698
1693: Choice Lookup Table
          12   1689
1696: oJumpForward 1700
1698: oJumpBack 1662
1700: oInput 11
1702: oGetAddrLocal 3
1704: oPushResult
1705: oCall 1885
1707: oPop 1
1709: oGetAddrLocal 4
1711: oPushResult
1712: oSetResult 0
1714: oAssign
1715: oGetLocal 4
1717: oPushResult
1718: oGetLocal 1
1720: oPushResult
1721: oNodeVecSize
1722: oPop 1
1724: oPushResult
1725: equal
1726: oPop 2
1728: oChoice 1769
1730: oGetAddrLocal 2
1732: oPushResult
1733: oGetLocal 1
1735: oPushResult
1736: oGetLocal 4
1738: oPushResult
1739: oNodeVecElement
1740: oPop 2
1742: oAssign
1743: oGetLocal 2
1745: oPushResult
1746: oSetResult 17
1748: oPushResult
1749: oGetLocal 3
1751: oPushResult
1752: oNodeSet
1753: oPop 3
1755: oGetLocal 2
1757: oPushResult
1758: oScopeDeclareAlloc
1759: oPop 1
1761: oGetAddrLocal 4
1763: oPushResult
1764: inc
1765: oPop 1
1767: oJumpForward 1774
1769: Choice Lookup Table
           0   1730
1772: oJumpForward 1776
1774: oJumpBack 1715
1776: oInputChoice 1864
1778: oGetLocal 1
1780: oPushResult
1781: oNodeVecSize
1782: oPop 1
1784: oChoice 1788
1786: oJumpForward 1793
1788: Choice Lookup Table
           1   1786
1791: oError 22
1793: oGetAddrLocal 5
1795: oPushResult
1796: oCall 422
1798: oAssign
1799: oGetLocal 5
1801: oPushResult
1802: oCodePush
1803: oPop 1
1805: oGetAddrLocal 6
1807: oPushResult
1808: oSetResult 0
1810: oAssign
1811: oScopeCurrent
1812: oPushResult
1813: oGetGlobal 2
1815: oPushResult
1816: equal_node
1817: oPop 2
1819: oChoice 1835
1821: oGetGlobal 3
1823: oPushResult
1824: oScopeEnter
1825: oPop 1
1827: oGetAddrLocal 6
1829: oPushResult
1830: oSetResult 1
1832: oAssign
1833: oJumpForward 1838
1835: Choice Lookup Table
           1   1821
1838: oGetLocal 2
1840: oPushResult
1841: oCall 5786
1843: oPop 1
1845: oCall 2425
1847: oCall 6511
1849: oCall 5580
1851: oGetLocal 6
1853: oChoice 1858
1855: oScopeEnd
1856: oJumpForward 1861
1858: Choice Lookup Table
           1   1855
1861: oCodePop
1862: oJumpForward 1867
1864: Choice Lookup Table
           5   1778
1867: oGetLocal 1
1869: oPushResult
1870: oNodeVecDelete
1871: oPop 1
1873: oInput 4
1875: oJumpForward 1882
1877: Choice Lookup Table
           0   1657
1880: oJumpForward 1884
1882: oJumpBack 1655
1884: oReturn
1885: oLocalSpace 12
1887: oInputChoice 2341
1889: oGetAddrLocal 1
1891: oPushResult
1892: oScopeFindRequire
1893: oAssign
1894: oGetLocal 1
1896: oPushResult
1897: oNodeType
1898: oPop 1
1900: oChoice 1917
1902: oGetParam 1
1904: oPushResult
1905: oGetLocal 1
1907: oPushResult
1908: oSetResult 17
1910: oPushResult
1911: oNodeGet
1912: oPop 2
1914: oAssign
1915: oJumpForward 1928
1917: Choice Lookup Table
          12   1902
1920: oError 2
1922: oGetParam 1
1924: oPushResult
1925: oGetGlobal 5
1927: oAssign
1928: oJumpForward 2358
1930: oInput 15
1932: oGetAddrLocal 2
1934: oPushResult
1935: oNodeVecNew
1936: oAssign
1937: oGetAddrLocal 3
1939: oPushResult
1940: oSetResult 27
1942: oPushResult
1943: oNodeNew
1944: oPop 1
1946: oAssign
1947: oGetLocal 3
1949: oPushResult
1950: oSetResult 30
1952: oPushResult
1953: oGetGlobal 5
1955: oPushResult
1956: oNodeSet
1957: oPop 3
1959: oCall 2359
1961: oGetLocal 3
1963: oPushResult
1964: oSetResult 32
1966: oPushResult
1967: oValueTop
1968: oPushResult
1969: oNodeSetInt
1970: oPop 3
1972: oValuePop
1973: oInput 20
1975: oCall 2359
1977: oGetLocal 3
1979: oPushResult
1980: oSetResult 33
1982: oPushResult
1983: oValueTop
1984: oPushResult
1985: oNodeSetInt
1986: oPop 3
1988: oValuePop
1989: oGetLocal 3
1991: oPushResult
1992: oSetResult 13
1994: oPushResult
1995: oSetResult 4
1997: oPushResult
1998: oNodeSetInt
1999: oPop 3
2001: oGetLocal 3
2003: oPushResult
2004: oTypeAdd
2005: oPop 1
2007: oGetAddrLocal 4
2009: oPushResult
2010: oSetResult 26
2012: oPushResult
2013: oNodeNew
2014: oPop 1
2016: oAssign
2017: oGetLocal 4
2019: oPushResult
2020: oSetResult 31
2022: oPushResult
2023: oGetLocal 3
2025: oPushResult
2026: oNodeSet
2027: oPop 3
2029: oGetLocal 2
2031: oPushResult
2032: oGetLocal 4
2034: oPushResult
2035: oNodeVecAppend
2036: oPop 2
2038: oInputChoice 2046
2040: oJumpForward 2054
2042: oJumpForward 2052
2044: oJumpForward 2052
2046: Choice Lookup Table
          12   2044
          16   2040
2051: oEndChoice
2052: oJumpBack 1937
2054: oInput 38
2056: oGetAddrLocal 5
2058: oPushResult
2059: oCall 1885
2061: oPop 1
2063: oGetAddrLocal 6
2065: oPushResult
2066: oGetLocal 2
2068: oPushResult
2069: oNodeVecSize
2070: oPop 1
2072: oAssign
2073: oGetAddrLocal 6
2075: oPushResult
2076: dec
2077: oPop 1
2079: oGetAddrLocal 7
2081: oPushResult
2082: oGetLocal 2
2084: oPushResult
2085: oGetLocal 6
2087: oPushResult
2088: oNodeVecElement
2089: oPop 2
2091: oAssign
2092: oGetLocal 7
2094: oPushResult
2095: oSetResult 30
2097: oPushResult
2098: oGetLocal 5
2100: oPushResult
2101: oNodeSet
2102: oPop 3
2104: oGetAddrLocal 8
2106: oPushResult
2107: oGetLocal 7
2109: oPushResult
2110: oSetResult 31
2112: oPushResult
2113: oNodeGet
2114: oPop 2
2116: oAssign
2117: oGetAddrLocal 9
2119: oPushResult
2120: oGetLocal 8
2122: oPushResult
2123: oSetResult 33
2125: oPushResult
2126: oNodeGetInt
2127: oPop 2
2129: oPushResult
2130: oGetLocal 8
2132: oPushResult
2133: oSetResult 32
2135: oPushResult
2136: oNodeGetInt
2137: oPop 2
2139: oPushResult
2140: subtract
2141: oPop 2
2143: oAssign
2144: oGetAddrLocal 9
2146: oPushResult
2147: inc
2148: oPop 1
2150: oGetLocal 7
2152: oPushResult
2153: oSetResult 13
2155: oPushResult
2156: oGetLocal 9
2158: oPushResult
2159: oGetLocal 5
2161: oPushResult
2162: oSetResult 13
2164: oPushResult
2165: oNodeGetInt
2166: oPop 2
2168: oPushResult
2169: multiply
2170: oPop 2
2172: oPushResult
2173: oNodeSetInt
2174: oPop 3
2176: oGetLocal 7
2178: oPushResult
2179: oTypeAdd
2180: oPop 1
2182: oGetAddrLocal 5
2184: oPushResult
2185: oGetLocal 7
2187: oAssign
2188: oGetLocal 6
2190: oPushResult
2191: equal_zero
2192: oPop 1
2194: oChoice 2200
2196: oJumpForward 2205
2198: oJumpForward 2203
2200: Choice Lookup Table
           1   2196
2203: oJumpBack 2073
2205: oGetParam 1
2207: oPushResult
2208: oGetLocal 2
2210: oPushResult
2211: oSetResult 0
2213: oPushResult
2214: oNodeVecElement
2215: oPop 2
2217: oAssign
2218: oGetLocal 2
2220: oPushResult
2221: oNodeVecDelete
2222: oPop 1
2224: oJumpForward 2358
2226: oGetAddrLocal 10
2228: oPushResult
2229: oCall 1885
2231: oPop 1
2233: oGetParam 1
2235: oPushResult
2236: oGetLocal 10
2238: oPushResult
2239: oCall 6653
2241: oPop 1
2243: oAssign
2244: oJumpForward 2358
2246: oGetParam 1
2248: oPushResult
2249: oSetResult 28
2251: oPushResult
2252: oNodeNew
2253: oPop 1
2255: oAssign
2256: oSetResult -1
2258: oPushResult
2259: oScopeBegin
2260: oPop 1
2262: oSetResult 16
2264: oPushResult
2265: oCall 1653
2267: oPop 1
2269: oGetAddrLocal 11
2271: oPushResult
2272: oScopeCurrent
2273: oPushResult
2274: oSetResult 13
2276: oPushResult
2277: oNodeGetInt
2278: oPop 2
2280: oAssign
2281: oGetLocal 11
2283: oPushResult
2284: equal_zero
2285: oPop 1
2287: oChoice 2293
2289: oError 19
2291: oJumpForward 2296
2293: Choice Lookup Table
           1   2289
2296: oInput 34
2298: oGetFromParam 1
2300: oPushResult
2301: oSetResult 34
2303: oPushResult
2304: oScopeCurrent
2305: oPushResult
2306: oNodeSet
2307: oPop 3
2309: oGetFromParam 1
2311: oPushResult
2312: oSetResult 13
2314: oPushResult
2315: oGetLocal 11
2317: oPushResult
2318: oNodeSetInt
2319: oPop 3
2321: oScopeEnd
2322: oGetFromParam 1
2324: oPushResult
2325: oTypeAdd
2326: oPop 1
2328: oJumpForward 2358
2330: oInput 38
2332: oGetAddrLocal 12
2334: oPushResult
2335: oCall 1885
2337: oPop 1
2339: oJumpForward 2358
2341: Choice Lookup Table
          37   2330
          36   2246
          17   2226
          35   1930
           0   1889
2352: oCall 2359
2354: oInput 20
2356: oCall 2359
2358: oReturn
2359: oLocalSpace 1
2361: oInputChoice 2416
2363: TOKEN_VALUE
2364: oPushResult
2365: oValuePush
2366: oPop 1
2368: oJumpForward 2424
2370: oGetAddrLocal 1
2372: oPushResult
2373: oScopeFindRequire
2374: oAssign
2375: oGetLocal 1
2377: oPushResult
2378: oNodeType
2379: oPop 1
2381: oChoice 2398
2383: oGetLocal 1
2385: oPushResult
2386: oSetResult 18
2388: oPushResult
2389: oNodeGetInt
2390: oPop 2
2392: oPushResult
2393: oValuePush
2394: oPop 1
2396: oJumpForward 2409
2398: Choice Lookup Table
          11   2383
2401: oError 1
2403: oSetResult 0
2405: oPushResult
2406: oValuePush
2407: oPop 1
2409: oJumpForward 2424
2411: oCall 2359
2413: oValueNegate
2414: oJumpForward 2424
2416: Choice Lookup Table
          24   2411
           0   2370
           1   2363
2423: oEndChoice
2424: oReturn
2425: oLocalSpace 1
2427: oGetAddrLocal 1
2429: oPushResult
2430: oSetResult 0
2432: oAssign
2433: oGetAddrLocal 1
2435: oPushResult
2436: oCall 2586
2438: oPop 1
2440: oGetAddrLocal 1
2442: oPushResult
2443: oCall 2486
2445: oPop 1
2447: oReturn
2448: oLocalSpace 0
2450: oGetParam 1
2452: oPushResult
2453: oCall 2586
2455: oPop 1
2457: oTypeSNodeType
2458: oChoice 2477
2460: oJumpForward 2484
2462: oGetParam 1
2464: oPushResult
2465: oLabelNew
2466: oAssign
2467: oEmit 55
2469: oGetFromParam 1
2471: oPushResult
2472: oEmitLabel
2473: oPop 1
2475: oJumpForward 2484
2477: Choice Lookup Table
          21   2462
          22   2460
2482: oError 8
2484: oTypeSPop
2485: oReturn
2486: oLocalSpace 1
2488: oTypeSNodeType
2489: oChoice 2551
2491: oGetAddrLocal 1
2493: oPushResult
2494: oLabelNew
2495: oAssign
2496: oEmit 15
2498: oSetResult 1
2500: oPushResult
2501: oEmitInt
2502: oPop 1
2504: oEmit 53
2506: oGetLocal 1
2508: oPushResult
2509: oEmitLabel
2510: oPop 1
2512: oEmit 56
2514: oGetFromParam 1
2516: oPushResult
2517: oEmitLabel
2518: oPop 1
2520: oEmit 15
2522: oSetResult 0
2524: oPushResult
2525: oEmitInt
2526: oPop 1
2528: oEmit 56
2530: oGetLocal 1
2532: oPushResult
2533: oEmitLabel
2534: oPop 1
2536: oTypeSPop
2537: oGetGlobal 6
2539: oPushResult
2540: oTypeSPush
2541: oPop 1
2543: oGetParam 1
2545: oPushResult
2546: oSetResult 0
2548: oAssign
2549: oJumpForward 2554
2551: Choice Lookup Table
          22   2491
2554: oReturn
2555: oLocalSpace 0
2557: oTypeSNodeType
2558: oChoice 2582
2560: oGetParam 1
2562: oPushResult
2563: oLabelNew
2564: oAssign
2565: oEmit 55
2567: oGetFromParam 1
2569: oPushResult
2570: oEmitLabel
2571: oPop 1
2573: oTypeSPop
2574: oGetGlobal 7
2576: oPushResult
2577: oTypeSPush
2578: oPop 1
2580: oJumpForward 2585
2582: Choice Lookup Table
          21   2560
2585: oReturn
2586: oLocalSpace 0
2588: oGetParam 1
2590: oPushResult
2591: oCall 2951
2593: oPop 1
2595: oInputChoice 2933
2597: oGetParam 1
2599: oPushResult
2600: oCall 2486
2602: oPop 1
2604: oGetParam 1
2606: oPushResult
2607: oCall 2951
2609: oPop 1
2611: oGetParam 1
2613: oPushResult
2614: oCall 2486
2616: oPop 1
2618: oCall 6511
2620: oTypeSNodeType
2621: oChoice 2635
2623: oEmit 38
2625: oJumpForward 2648
2627: oEmit 44
2629: oJumpForward 2648
2631: oError 16
2633: oJumpForward 2648
2635: Choice Lookup Table
          24   2631
          23   2631
          25   2627
          21   2623
          20   2623
2646: oError 17
2648: oTypeSPop
2649: oGetGlobal 6
2651: oPushResult
2652: oTypeSPush
2653: oPop 1
2655: oJumpForward 2948
2657: oGetParam 1
2659: oPushResult
2660: oCall 2486
2662: oPop 1
2664: oGetParam 1
2666: oPushResult
2667: oCall 2951
2669: oPop 1
2671: oGetParam 1
2673: oPushResult
2674: oCall 2486
2676: oPop 1
2678: oCall 6511
2680: oTypeSNodeType
2681: oChoice 2695
2683: oEmit 39
2685: oJumpForward 2708
2687: oEmit 45
2689: oJumpForward 2708
2691: oError 16
2693: oJumpForward 2708
2695: Choice Lookup Table
          24   2691
          23   2691
          25   2687
          21   2683
          20   2683
2706: oError 17
2708: oTypeSPop
2709: oGetGlobal 6
2711: oPushResult
2712: oTypeSPush
2713: oPop 1
2715: oJumpForward 2948
2717: oGetParam 1
2719: oPushResult
2720: oCall 2486
2722: oPop 1
2724: oGetParam 1
2726: oPushResult
2727: oCall 2951
2729: oPop 1
2731: oGetParam 1
2733: oPushResult
2734: oCall 2486
2736: oPop 1
2738: oCall 6511
2740: oTypeSNodeType
2741: oChoice 2751
2743: oEmit 41
2745: oJumpForward 2762
2747: oError 16
2749: oJumpForward 2762
2751: Choice Lookup Table
          24   2747
          23   2747
          21   2743
          20   2743
2760: oError 17
2762: oTypeSPop
2763: oGetGlobal 6
2765: oPushResult
2766: oTypeSPush
2767: oPop 1
2769: oJumpForward 2948
2771: oGetParam 1
2773: oPushResult
2774: oCall 2486
2776: oPop 1
2778: oGetParam 1
2780: oPushResult
2781: oCall 2951
2783: oPop 1
2785: oGetParam 1
2787: oPushResult
2788: oCall 2486
2790: oPop 1
2792: oCall 6511
2794: oTypeSNodeType
2795: oChoice 2805
2797: oEmit 40
2799: oJumpForward 2816
2801: oError 16
2803: oJumpForward 2816
2805: Choice Lookup Table
          24   2801
          23   2801
          21   2797
          20   2797
2814: oError 17
2816: oTypeSPop
2817: oGetGlobal 6
2819: oPushResult
2820: oTypeSPush
2821: oPop 1
2823: oJumpForward 2948
2825: oGetParam 1
2827: oPushResult
2828: oCall 2486
2830: oPop 1
2832: oGetParam 1
2834: oPushResult
2835: oCall 2951
2837: oPop 1
2839: oGetParam 1
2841: oPushResult
2842: oCall 2486
2844: oPop 1
2846: oCall 6511
2848: oTypeSNodeType
2849: oChoice 2859
2851: oEmit 43
2853: oJumpForward 2870
2855: oError 16
2857: oJumpForward 2870
2859: Choice Lookup Table
          24   2855
          23   2855
          21   2851
          20   2851
2868: oError 17
2870: oTypeSPop
2871: oGetGlobal 6
2873: oPushResult
2874: oTypeSPush
2875: oPop 1
2877: oJumpForward 2948
2879: oGetParam 1
2881: oPushResult
2882: oCall 2486
2884: oPop 1
2886: oGetParam 1
2888: oPushResult
2889: oCall 2951
2891: oPop 1
2893: oGetParam 1
2895: oPushResult
2896: oCall 2486
2898: oPop 1
2900: oCall 6511
2902: oTypeSNodeType
2903: oChoice 2913
2905: oEmit 42
2907: oJumpForward 2924
2909: oError 16
2911: oJumpForward 2924
2913: Choice Lookup Table
          24   2909
          23   2909
          21   2905
          20   2905
2922: oError 17
2924: oTypeSPop
2925: oGetGlobal 6
2927: oPushResult
2928: oTypeSPush
2929: oPop 1
2931: oJumpForward 2948
2933: Choice Lookup Table
          10   2879
           9   2825
           8   2771
           7   2717
           6   2657
           5   2597
2946: oJumpForward 2950
2948: oJumpBack 2595
2950: oReturn
2951: oLocalSpace 1
2953: oGetAddrLocal 1
2955: oPushResult
2956: oSetResult 0
2958: oAssign
2959: oGetParam 1
2961: oPushResult
2962: oCall 3131
2964: oPop 1
2966: oInputChoice 3099
2968: oTypeSNodeType
2969: oChoice 3040
2971: oGetLocal 1
2973: oPushResult
2974: oSetResult 0
2976: oPushResult
2977: equal_label
2978: oPop 2
2980: oChoice 2989
2982: oGetAddrLocal 1
2984: oPushResult
2985: oLabelNew
2986: oAssign
2987: oJumpForward 2992
2989: Choice Lookup Table
           1   2982
2992: oEmit 53
2994: oGetLocal 1
2996: oPushResult
2997: oEmitLabel
2998: oPop 1
3000: oJumpForward 3047
3002: oGetParam 1
3004: oPushResult
3005: oCall 2555
3007: oPop 1
3009: oGetLocal 1
3011: oPushResult
3012: oSetResult 0
3014: oPushResult
3015: equal_label
3016: oPop 2
3018: oChoice 3027
3020: oGetAddrLocal 1
3022: oPushResult
3023: oLabelNew
3024: oAssign
3025: oJumpForward 3030
3027: Choice Lookup Table
           1   3020
3030: oEmit 53
3032: oGetLocal 1
3034: oPushResult
3035: oEmitLabel
3036: oPop 1
3038: oJumpForward 3047
3040: Choice Lookup Table
          21   3002
          22   2971
3045: oError 8
3047: oTypeSPop
3048: oEmit 56
3050: oGetFromParam 1
3052: oPushResult
3053: oEmitLabel
3054: oPop 1
3056: oGetParam 1
3058: oPushResult
3059: oSetResult 0
3061: oAssign
3062: oGetParam 1
3064: oPushResult
3065: oCall 3131
3067: oPop 1
3069: oTypeSNodeType
3070: oChoice 3083
3072: oJumpForward 3090
3074: oGetParam 1
3076: oPushResult
3077: oCall 2555
3079: oPop 1
3081: oJumpForward 3090
3083: Choice Lookup Table
          21   3074
          22   3072
3088: oError 8
3090: oTypeSPop
3091: oGetGlobal 7
3093: oPushResult
3094: oTypeSPush
3095: oPop 1
3097: oJumpForward 3104
3099: Choice Lookup Table
          52   2968
3102: oJumpForward 3106
3104: oJumpBack 2966
3106: oGetLocal 1
3108: oPushResult
3109: oSetResult 0
3111: oPushResult
3112: equal_label
3113: oPop 2
3115: oChoice 3127
3117: oEmit 56
3119: oGetLocal 1
3121: oPushResult
3122: oEmitLabel
3123: oPop 1
3125: oJumpForward 3130
3127: Choice Lookup Table
           0   3117
3130: oReturn
3131: oLocalSpace 2
3133: oGetAddrLocal 1
3135: oPushResult
3136: oSetResult 0
3138: oAssign
3139: oGetParam 1
3141: oPushResult
3142: oCall 3269
3144: oPop 1
3146: oInputChoice 3261
3148: oTypeSNodeType
3149: oChoice 3162
3151: oJumpForward 3169
3153: oGetParam 1
3155: oPushResult
3156: oCall 2555
3158: oPop 1
3160: oJumpForward 3169
3162: Choice Lookup Table
          21   3153
          22   3151
3167: oError 8
3169: oTypeSPop
3170: oGetLocal 1
3172: oPushResult
3173: oSetResult 0
3175: oPushResult
3176: equal_label
3177: oPop 2
3179: oChoice 3208
3181: oGetAddrLocal 1
3183: oPushResult
3184: oLabelNew
3185: oAssign
3186: oEmit 57
3188: oGetFromParam 1
3190: oPushResult
3191: oEmitLabel
3192: oPop 1
3194: oGetLocal 1
3196: oPushResult
3197: oEmitLabel
3198: oPop 1
3200: oGetParam 1
3202: oPushResult
3203: oGetLocal 1
3205: oAssign
3206: oJumpForward 3211
3208: Choice Lookup Table
           1   3181
3211: oGetAddrLocal 2
3213: oPushResult
3214: oSetResult 0
3216: oAssign
3217: oGetAddrLocal 2
3219: oPushResult
3220: oCall 3269
3222: oPop 1
3224: oTypeSNodeType
3225: oChoice 3238
3227: oJumpForward 3245
3229: oGetAddrLocal 2
3231: oPushResult
3232: oCall 2555
3234: oPop 1
3236: oJumpForward 3245
3238: Choice Lookup Table
          21   3229
          22   3227
3243: oError 8
3245: oEmit 57
3247: oGetLocal 2
3249: oPushResult
3250: oEmitLabel
3251: oPop 1
3253: oGetLocal 1
3255: oPushResult
3256: oEmitLabel
3257: oPop 1
3259: oJumpForward 3266
3261: Choice Lookup Table
          51   3148
3264: oJumpForward 3268
3266: oJumpBack 3146
3268: oReturn
3269: oLocalSpace 1
3271: oInputChoice 3325
3273: oGetAddrLocal 1
3275: oPushResult
3276: oSetResult 0
3278: oAssign
3279: oGetAddrLocal 1
3281: oPushResult
3282: oCall 3269
3284: oPop 1
3286: oTypeSNodeType
3287: oChoice 3316
3289: oGetParam 1
3291: oPushResult
3292: oLabelNew
3293: oAssign
3294: oEmit 53
3296: oGetFromParam 1
3298: oPushResult
3299: oEmitLabel
3300: oPop 1
3302: oEmit 56
3304: oGetLocal 1
3306: oPushResult
3307: oEmitLabel
3308: oPop 1
3310: oJumpForward 3323
3312: oEmit 37
3314: oJumpForward 3323
3316: Choice Lookup Table
          21   3312
          22   3289
3321: oError 8
3323: oJumpForward 3335
3325: Choice Lookup Table
          53   3273
3328: oGetParam 1
3330: oPushResult
3331: oCall 3336
3333: oPop 1
3335: oReturn
3336: oLocalSpace 0
3338: oGetParam 1
3340: oPushResult
3341: oCall 3387
3343: oPop 1
3345: oInputChoice 3377
3347: oCall 6537
3349: oGetParam 1
3351: oPushResult
3352: oCall 3387
3354: oPop 1
3356: oCall 6551
3358: oEmit 34
3360: oJumpForward 3384
3362: oCall 6537
3364: oGetParam 1
3366: oPushResult
3367: oCall 3387
3369: oPop 1
3371: oCall 6551
3373: oEmit 35
3375: oJumpForward 3384
3377: Choice Lookup Table
          24   3362
          23   3347
3382: oJumpForward 3386
3384: oJumpBack 3345
3386: oReturn
3387: oLocalSpace 0
3389: oGetParam 1
3391: oPushResult
3392: oCall 3438
3394: oPop 1
3396: oInputChoice 3428
3398: oCall 6537
3400: oGetParam 1
3402: oPushResult
3403: oCall 3438
3405: oPop 1
3407: oCall 6551
3409: oEmit 31
3411: oJumpForward 3435
3413: oCall 6537
3415: oGetParam 1
3417: oPushResult
3418: oCall 3438
3420: oPop 1
3422: oCall 6551
3424: oEmit 32
3426: oJumpForward 3435
3428: Choice Lookup Table
          22   3413
          21   3398
3433: oJumpForward 3437
3435: oJumpBack 3396
3437: oReturn
3438: oLocalSpace 0
3440: oInputChoice 3466
3442: oGetParam 1
3444: oPushResult
3445: oCall 3479
3447: oPop 1
3449: oCall 6551
3451: oJumpForward 3478
3453: oGetParam 1
3455: oPushResult
3456: oCall 3479
3458: oPop 1
3460: oCall 6551
3462: oEmit 36
3464: oJumpForward 3478
3466: Choice Lookup Table
          24   3453
          23   3442
3471: oGetParam 1
3473: oPushResult
3474: oCall 3479
3476: oPop 1
3478: oReturn
3479: oLocalSpace 6
3481: oInputChoice 3667
3483: oEmit 15
3485: TOKEN_VALUE
3486: oPushResult
3487: oEmitInt
3488: oPop 1
3490: oGetGlobal 5
3492: oPushResult
3493: oTypeSPush
3494: oPop 1
3496: oJumpForward 3686
3498: oGetParam 1
3500: oPushResult
3501: oCall 2586
3503: oPop 1
3505: oInput 14
3507: oJumpForward 3686
3509: oGetAddrLocal 1
3511: oPushResult
3512: CURRENT_STRLIT
3513: oPushResult
3514: oStringAllocLit
3515: oPop 1
3517: oAssign
3518: oEmit 16
3520: oGetLocal 1
3522: oPushResult
3523: oEmitInt
3524: oPop 1
3526: oGetGlobal 9
3528: oPushResult
3529: oTypeSPush
3530: oPop 1
3532: oJumpForward 3686
3534: oGetAddrLocal 2
3536: oPushResult
3537: oScopeFindRequire
3538: oAssign
3539: oGetLocal 2
3541: oPushResult
3542: oNodeType
3543: oPop 1
3545: oChoice 3607
3547: oGetLocal 2
3549: oPushResult
3550: oCall 4839
3552: oPop 1
3554: oJumpForward 3626
3556: oGetAddrLocal 3
3558: oPushResult
3559: oGetLocal 2
3561: oPushResult
3562: oSetResult 17
3564: oPushResult
3565: oNodeGet
3566: oPop 2
3568: oAssign
3569: oGetLocal 3
3571: oPushResult
3572: oTypeSPush
3573: oPop 1
3575: oTypeSNodeType
3576: oChoice 3589
3578: oEmit 15
3580: oGetLocal 2
3582: oPushResult
3583: oCall 6788
3585: oPop 1
3587: oJumpForward 3596
3589: Choice Lookup Table
          21   3578
          20   3578
3594: oError 16
3596: oJumpForward 3626
3598: oGetLocal 2
3600: oPushResult
3601: oCall 3687
3603: oPop 1
3605: oJumpForward 3626
3607: Choice Lookup Table
          17   3598
          15   3598
          14   3598
          11   3556
          10   3547
3618: oError 6
3620: oGetGlobal 5
3622: oPushResult
3623: oTypeSPush
3624: oPop 1
3626: oJumpForward 3686
3628: oInput 0
3630: oGetAddrLocal 4
3632: oPushResult
3633: oScopeFindRequire
3634: oAssign
3635: oGetLocal 4
3637: oPushResult
3638: oCall 5786
3640: oPop 1
3642: oGetAddrLocal 5
3644: oPushResult
3645: oTypeSTop
3646: oAssign
3647: oTypeSPop
3648: oGetAddrLocal 6
3650: oPushResult
3651: oGetLocal 5
3653: oPushResult
3654: oCall 6653
3656: oPop 1
3658: oAssign
3659: oGetLocal 6
3661: oPushResult
3662: oTypeSPush
3663: oPop 1
3665: oJumpForward 3686
3667: Choice Lookup Table
          18   3628
           0   3534
           2   3509
          13   3498
           1   3483
3678: oError 6
3680: oGetGlobal 5
3682: oPushResult
3683: oTypeSPush
3684: oPop 1
3686: oReturn
3687: oLocalSpace 2
3689: oGetAddrLocal 1
3691: oPushResult
3692: oGetParam 1
3694: oPushResult
3695: oSetResult 17
3697: oPushResult
3698: oNodeGet
3699: oPop 2
3701: oAssign
3702: oGetAddrLocal 2
3704: oPushResult
3705: oGetParam 1
3707: oPushResult
3708: oCall 6487
3710: oPop 1
3712: oAssign
3713: oGetLocal 1
3715: oPushResult
3716: oTypeSPush
3717: oPop 1
3719: oTypeSNodeType
3720: oChoice 4237
3722: oGetParam 1
3724: oPushResult
3725: oNodeType
3726: oPop 1
3728: oChoice 3874
3730: oEmit 0
3732: oGetParam 1
3734: oPushResult
3735: oCall 6788
3737: oPop 1
3739: oJumpForward 3882
3741: oGetLocal 2
3743: oPushResult
3744: equal_zero
3745: oPop 1
3747: oChoice 3760
3749: oEmit 3
3751: oGetParam 1
3753: oPushResult
3754: oCall 6788
3756: oPop 1
3758: oJumpForward 3778
3760: Choice Lookup Table
           1   3749
3763: oEmit 9
3765: oGetLocal 2
3767: oPushResult
3768: oEmitInt
3769: oPop 1
3771: oGetParam 1
3773: oPushResult
3774: oCall 6788
3776: oPop 1
3778: oJumpForward 3882
3780: oGetParam 1
3782: oPushResult
3783: oSetResult 28
3785: oPushResult
3786: oNodeGetBoolean
3787: oPop 2
3789: oChoice 3832
3791: oGetLocal 2
3793: oPushResult
3794: equal_zero
3795: oPop 1
3797: oChoice 3810
3799: oEmit 8
3801: oGetParam 1
3803: oPushResult
3804: oCall 6788
3806: oPop 1
3808: oJumpForward 3828
3810: Choice Lookup Table
           1   3799
3813: oEmit 14
3815: oGetLocal 2
3817: oPushResult
3818: oEmitInt
3819: oPop 1
3821: oGetParam 1
3823: oPushResult
3824: oCall 6788
3826: oPop 1
3828: oEmit 22
3830: oJumpForward 3872
3832: Choice Lookup Table
           1   3791
3835: oGetLocal 2
3837: oPushResult
3838: equal_zero
3839: oPop 1
3841: oChoice 3854
3843: oEmit 6
3845: oGetParam 1
3847: oPushResult
3848: oCall 6788
3850: oPop 1
3852: oJumpForward 3872
3854: Choice Lookup Table
           1   3843
3857: oEmit 12
3859: oGetLocal 2
3861: oPushResult
3862: oEmitInt
3863: oPop 1
3865: oGetParam 1
3867: oPushResult
3868: oCall 6788
3870: oPop 1
3872: oJumpForward 3882
3874: Choice Lookup Table
          17   3780
          15   3741
          14   3730
3881: oEndChoice
3882: oJumpForward 4412
3884: oGetParam 1
3886: oPushResult
3887: oNodeType
3888: oPop 1
3890: oChoice 4036
3892: oEmit 1
3894: oGetParam 1
3896: oPushResult
3897: oCall 6788
3899: oPop 1
3901: oJumpForward 4044
3903: oGetLocal 2
3905: oPushResult
3906: equal_zero
3907: oPop 1
3909: oChoice 3922
3911: oEmit 4
3913: oGetParam 1
3915: oPushResult
3916: oCall 6788
3918: oPop 1
3920: oJumpForward 3940
3922: Choice Lookup Table
           1   3911
3925: oEmit 10
3927: oGetLocal 2
3929: oPushResult
3930: oEmitInt
3931: oPop 1
3933: oGetParam 1
3935: oPushResult
3936: oCall 6788
3938: oPop 1
3940: oJumpForward 4044
3942: oGetParam 1
3944: oPushResult
3945: oSetResult 28
3947: oPushResult
3948: oNodeGetBoolean
3949: oPop 2
3951: oChoice 3994
3953: oGetLocal 2
3955: oPushResult
3956: equal_zero
3957: oPop 1
3959: oChoice 3972
3961: oEmit 8
3963: oGetParam 1
3965: oPushResult
3966: oCall 6788
3968: oPop 1
3970: oJumpForward 3990
3972: Choice Lookup Table
           1   3961
3975: oEmit 14
3977: oGetLocal 2
3979: oPushResult
3980: oEmitInt
3981: oPop 1
3983: oGetParam 1
3985: oPushResult
3986: oCall 6788
3988: oPop 1
3990: oEmit 23
3992: oJumpForward 4034
3994: Choice Lookup Table
           1   3953
3997: oGetLocal 2
3999: oPushResult
4000: equal_zero
4001: oPop 1
4003: oChoice 4016
4005: oEmit 7
4007: oGetParam 1
4009: oPushResult
4010: oCall 6788
4012: oPop 1
4014: oJumpForward 4034
4016: Choice Lookup Table
           1   4005
4019: oEmit 13
4021: oGetLocal 2
4023: oPushResult
4024: oEmitInt
4025: oPop 1
4027: oGetParam 1
4029: oPushResult
4030: oCall 6788
4032: oPop 1
4034: oJumpForward 4044
4036: Choice Lookup Table
          17   3942
          15   3903
          14   3892
4043: oEndChoice
4044: oJumpForward 4412
4046: oError 16
4048: oJumpForward 4412
4050: oGetParam 1
4052: oPushResult
4053: oNodeType
4054: oPop 1
4056: oChoice 4202
4058: oEmit 2
4060: oGetParam 1
4062: oPushResult
4063: oCall 6788
4065: oPop 1
4067: oJumpForward 4210
4069: oGetLocal 2
4071: oPushResult
4072: equal_zero
4073: oPop 1
4075: oChoice 4088
4077: oEmit 5
4079: oGetParam 1
4081: oPushResult
4082: oCall 6788
4084: oPop 1
4086: oJumpForward 4106
4088: Choice Lookup Table
           1   4077
4091: oEmit 11
4093: oGetLocal 2
4095: oPushResult
4096: oEmitInt
4097: oPop 1
4099: oGetParam 1
4101: oPushResult
4102: oCall 6788
4104: oPop 1
4106: oJumpForward 4210
4108: oGetParam 1
4110: oPushResult
4111: oSetResult 28
4113: oPushResult
4114: oNodeGetBoolean
4115: oPop 2
4117: oChoice 4160
4119: oGetLocal 2
4121: oPushResult
4122: equal_zero
4123: oPop 1
4125: oChoice 4138
4127: oEmit 8
4129: oGetParam 1
4131: oPushResult
4132: oCall 6788
4134: oPop 1
4136: oJumpForward 4156
4138: Choice Lookup Table
           1   4127
4141: oEmit 14
4143: oGetLocal 2
4145: oPushResult
4146: oEmitInt
4147: oPop 1
4149: oGetParam 1
4151: oPushResult
4152: oCall 6788
4154: oPop 1
4156: oEmit 24
4158: oJumpForward 4200
4160: Choice Lookup Table
           1   4119
4163: oGetLocal 2
4165: oPushResult
4166: equal_zero
4167: oPop 1
4169: oChoice 4182
4171: oEmit 8
4173: oGetParam 1
4175: oPushResult
4176: oCall 6788
4178: oPop 1
4180: oJumpForward 4200
4182: Choice Lookup Table
           1   4171
4185: oEmit 14
4187: oGetLocal 2
4189: oPushResult
4190: oEmitInt
4191: oPop 1
4193: oGetParam 1
4195: oPushResult
4196: oCall 6788
4198: oPop 1
4200: oJumpForward 4210
4202: Choice Lookup Table
          17   4108
          15   4069
          14   4058
4209: oEndChoice
4210: oInputChoice 4232
4212: oTypeSPop
4213: oGetLocal 1
4215: oPushResult
4216: oSetResult 30
4218: oPushResult
4219: oNodeGet
4220: oPop 2
4222: oPushResult
4223: oTypeSPush
4224: oPop 1
4226: oCall 4448
4228: oCall 4413
4230: oJumpForward 4235
4232: Choice Lookup Table
          17   4212
4235: oJumpForward 4412
4237: Choice Lookup Table
          25   4050
          19   4046
          24   4046
          23   4046
          21   3884
          20   3722
4250: oGetParam 1
4252: oPushResult
4253: oNodeType
4254: oPop 1
4256: oChoice 4400
4258: oEmit 16
4260: oGetParam 1
4262: oPushResult
4263: oCall 6788
4265: oPop 1
4267: oJumpForward 4408
4269: oGetLocal 2
4271: oPushResult
4272: equal_zero
4273: oPop 1
4275: oChoice 4288
4277: oEmit 17
4279: oGetParam 1
4281: oPushResult
4282: oCall 6788
4284: oPop 1
4286: oJumpForward 4306
4288: Choice Lookup Table
           1   4277
4291: oEmit 20
4293: oGetLocal 2
4295: oPushResult
4296: oEmitInt
4297: oPop 1
4299: oGetParam 1
4301: oPushResult
4302: oCall 6788
4304: oPop 1
4306: oJumpForward 4408
4308: oGetParam 1
4310: oPushResult
4311: oSetResult 28
4313: oPushResult
4314: oNodeGetBoolean
4315: oPop 2
4317: oChoice 4358
4319: oGetLocal 2
4321: oPushResult
4322: equal_zero
4323: oPop 1
4325: oChoice 4338
4327: oEmit 8
4329: oGetParam 1
4331: oPushResult
4332: oCall 6788
4334: oPop 1
4336: oJumpForward 4356
4338: Choice Lookup Table
           1   4327
4341: oEmit 14
4343: oGetLocal 2
4345: oPushResult
4346: oEmitInt
4347: oPop 1
4349: oGetParam 1
4351: oPushResult
4352: oCall 6788
4354: oPop 1
4356: oJumpForward 4398
4358: Choice Lookup Table
           1   4319
4361: oGetLocal 2
4363: oPushResult
4364: equal_zero
4365: oPop 1
4367: oChoice 4380
4369: oEmit 18
4371: oGetParam 1
4373: oPushResult
4374: oCall 6788
4376: oPop 1
4378: oJumpForward 4398
4380: Choice Lookup Table
           1   4369
4383: oEmit 21
4385: oGetLocal 2
4387: oPushResult
4388: oEmitInt
4389: oPop 1
4391: oGetParam 1
4393: oPushResult
4394: oCall 6788
4396: oPop 1
4398: oJumpForward 4408
4400: Choice Lookup Table
          17   4308
          15   4269
          14   4258
4407: oEndChoice
4408: oCall 4448
4410: oCall 4413
4412: oReturn
4413: oLocalSpace 0
4415: oTypeSNodeType
4416: oChoice 4434
4418: oEmit 22
4420: oJumpForward 4447
4422: oEmit 23
4424: oJumpForward 4447
4426: oError 16
4428: oJumpForward 4447
4430: oEmit 24
4432: oJumpForward 4447
4434: Choice Lookup Table
          25   4430
          19   4426
          24   4426
          23   4426
          21   4422
          20   4418
4447: oReturn
4448: oLocalSpace 0
4450: oInputChoice 4464
4452: oCall 4476
4454: oJumpForward 4473
4456: oCall 4619
4458: oJumpForward 4473
4460: oCall 4717
4462: oJumpForward 4473
4464: Choice Lookup Table
          17   4460
          19   4456
          15   4452
4471: oJumpForward 4475
4473: oJumpBack 4450
4475: oReturn
4476: oLocalSpace 3
4478: oTypeSNodeType
4479: oChoice 4483
4481: oJumpForward 4488
4483: Choice Lookup Table
          26   4481
4486: oError 10
4488: oTypeSNodeType
4489: oChoice 4493
4491: oJumpForward 4498
4493: Choice Lookup Table
          26   4491
4496: oError 13
4498: oGetAddrLocal 1
4500: oPushResult
4501: oTypeSTop
4502: oPushResult
4503: oSetResult 31
4505: oPushResult
4506: oNodeGet
4507: oPop 2
4509: oPushResult
4510: oCall 6737
4512: oPop 1
4514: oAssign
4515: oGetAddrLocal 2
4517: oPushResult
4518: oTypeSTop
4519: oPushResult
4520: oSetResult 30
4522: oPushResult
4523: oNodeGet
4524: oPop 2
4526: oAssign
4527: oTypeSPop
4528: oGetLocal 2
4530: oPushResult
4531: oTypeSPush
4532: oPop 1
4534: oCall 2425
4536: oCall 6537
4538: oGetLocal 1
4540: oPushResult
4541: equal_zero
4542: oPop 1
4544: oChoice 4558
4546: oEmit 15
4548: oGetLocal 1
4550: oPushResult
4551: oEmitInt
4552: oPop 1
4554: oEmit 35
4556: oJumpForward 4561
4558: Choice Lookup Table
           0   4546
4561: oGetAddrLocal 3
4563: oPushResult
4564: oGetLocal 2
4566: oPushResult
4567: oSetResult 13
4569: oPushResult
4570: oNodeGetInt
4571: oPop 2
4573: oAssign
4574: oGetLocal 3
4576: oPushResult
4577: oSetResult 1
4579: oPushResult
4580: equal
4581: oPop 2
4583: oChoice 4597
4585: oEmit 15
4587: oGetLocal 3
4589: oPushResult
4590: oEmitInt
4591: oPop 1
4593: oEmit 31
4595: oJumpForward 4600
4597: Choice Lookup Table
           0   4585
4600: oEmit 33
4602: oInputChoice 4610
4604: oJumpForward 4618
4606: oJumpForward 4616
4608: oJumpForward 4616
4610: Choice Lookup Table
          12   4608
          16   4604
4615: oEndChoice
4616: oJumpBack 4488
4618: oReturn
4619: oLocalSpace 2
4621: oTypeSNodeType
4622: oChoice 4626
4624: oJumpForward 4631
4626: Choice Lookup Table
          28   4624
4629: oError 11
4631: oTypeSTop
4632: oPushResult
4633: oSetResult 34
4635: oPushResult
4636: oNodeGet
4637: oPop 2
4639: oPushResult
4640: oScopeEnter
4641: oPop 1
4643: oInput 0
4645: oGetAddrLocal 1
4647: oPushResult
4648: oScopeFindRequire
4649: oAssign
4650: oGetLocal 1
4652: oPushResult
4653: oNodeType
4654: oPop 1
4656: oChoice 4660
4658: oJumpForward 4665
4660: Choice Lookup Table
          16   4658
4663: oError 12
4665: oScopeEnd
4666: oGetAddrLocal 2
4668: oPushResult
4669: oGetLocal 1
4671: oPushResult
4672: oSetResult 18
4674: oPushResult
4675: oNodeGetInt
4676: oPop 2
4678: oAssign
4679: oGetLocal 2
4681: oPushResult
4682: equal_zero
4683: oPop 1
4685: oChoice 4699
4687: oEmit 15
4689: oGetLocal 2
4691: oPushResult
4692: oEmitInt
4693: oPop 1
4695: oEmit 33
4697: oJumpForward 4702
4699: Choice Lookup Table
           0   4687
4702: oTypeSPop
4703: oGetLocal 1
4705: oPushResult
4706: oSetResult 17
4708: oPushResult
4709: oNodeGet
4710: oPop 2
4712: oPushResult
4713: oTypeSPush
4714: oPop 1
4716: oReturn
4717: oLocalSpace 1
4719: oTypeSNodeType
4720: oChoice 4724
4722: oJumpForward 4729
4724: Choice Lookup Table
          25   4722
4727: oError 9
4729: oEmit 24
4731: oGetAddrLocal 1
4733: oPushResult
4734: oTypeSTop
4735: oAssign
4736: oTypeSPop
4737: oGetLocal 1
4739: oPushResult
4740: oSetResult 30
4742: oPushResult
4743: oNodeGet
4744: oPop 2
4746: oPushResult
4747: oTypeSPush
4748: oPop 1
4750: oReturn
4751: oLocalSpace 0
4753: oCall 6511
4755: oReturn
4756: oLocalSpace 2
4758: oGetAddrLocal 2
4760: oPushResult
4761: oGetParam 1
4763: oPushResult
4764: oSetResult 22
4766: oPushResult
4767: oNodeGetString
4768: oPop 2
4770: oAssign
4771: oGetLocal 2
4773: oPushResult
4774: oSetResult 0
4776: oPushResult
4777: equal_string
4778: oPop 2
4780: oChoice 4817
4782: oGetAddrLocal 1
4784: oPushResult
4785: oGetParam 1
4787: oPushResult
4788: oSetResult 3
4790: oPushResult
4791: oNodeGetInt
4792: oPop 2
4794: oPushResult
4795: ID_STRING
4796: oPop 1
4798: oPushResult
4799: oStringAllocLit
4800: oPop 1
4802: oAssign
4803: oJumpForward 4823
4805: oGetAddrLocal 1
4807: oPushResult
4808: oGetLocal 2
4810: oPushResult
4811: oStringAllocLit
4812: oPop 1
4814: oAssign
4815: oJumpForward 4823
4817: Choice Lookup Table
           0   4805
           1   4782
4822: oEndChoice
4823: oEmit 58
4825: oGetParam 1
4827: oPushResult
4828: oCall 6788
4830: oPop 1
4832: oGetLocal 1
4834: oPushResult
4835: oEmitInt
4836: oPop 1
4838: oReturn
4839: oLocalSpace 10
4841: oGetParam 1
4843: oPushResult
4844: oSetResult 21
4846: oPushResult
4847: oNodeGetBoolean
4848: oPop 2
4850: oChoice 4877
4852: oGetParam 1
4854: oPushResult
4855: oSetResult 24
4857: oPushResult
4858: oNodeGetBoolean
4859: oPop 2
4861: oChoice 4872
4863: oGetParam 1
4865: oPushResult
4866: oCall 4756
4868: oPop 1
4870: oJumpForward 4875
4872: Choice Lookup Table
           0   4863
4875: oJumpForward 4880
4877: Choice Lookup Table
           1   4852
4880: oGetParam 1
4882: oPushResult
4883: oSetResult 24
4885: oPushResult
4886: oSetResult 1
4888: oPushResult
4889: oNodeSetBoolean
4890: oPop 3
4892: oGetAddrLocal 1
4894: oPushResult
4895: oGetParam 1
4897: oPushResult
4898: oSetResult 23
4900: oPushResult
4901: oNodeGetBoolean
4902: oPop 2
4904: oAssign
4905: oGetAddrLocal 4
4907: oPushResult
4908: oGetParam 1
4910: oPushResult
4911: oNodeType
4912: oPop 1
4914: oPushResult
4915: oSetResult 10
4917: oPushResult
4918: equal_node_type
4919: oPop 2
4921: oAssign
4922: oGetLocal 4
4924: oChoice 4951
4926: oGetAddrLocal 2
4928: oPushResult
4929: oGetParam 1
4931: oPushResult
4932: oSetResult 17
4934: oPushResult
4935: oNodeGet
4936: oPop 2
4938: oAssign
4939: oGetAddrLocal 3
4941: oPushResult
4942: oGetLocal 2
4944: oPushResult
4945: oScopeAllocType
4946: oPop 1
4948: oAssign
4949: oJumpForward 4954
4951: Choice Lookup Table
           1   4926
4954: oGetAddrLocal 5
4956: oPushResult
4957: oGetParam 1
4959: oPushResult
4960: oSetResult 19
4962: oPushResult
4963: oNodeGet
4964: oPop 2
4966: oAssign
4967: oGetAddrLocal 6
4969: oPushResult
4970: oGetLocal 5
4972: oPushResult
4973: oSetResult 13
4975: oPushResult
4976: oNodeGetInt
4977: oPop 2
4979: oAssign
4980: oGetLocal 1
4982: oChoice 5004
4984: oEmit 47
4986: oGetLocal 6
4988: oPushResult
4989: oEmitInt
4990: oPop 1
4992: oJumpForward 5010
4994: oEmit 46
4996: oGetLocal 6
4998: oPushResult
4999: oEmitInt
5000: oPop 1
5002: oJumpForward 5010
5004: Choice Lookup Table
           0   4994
           1   4984
5009: oEndChoice
5010: oGetParam 1
5012: oPushResult
5013: oCall 6467
5015: oPop 1
5017: oPushResult
5018: oSetResult 0
5020: oPushResult
5021: greater
5022: oPop 2
5024: oChoice 5057
5026: oEmit 19
5028: oSetResult 0
5030: oPushResult
5031: oEmitInt
5032: oPop 1
5034: oEmit 20
5036: oGetParam 1
5038: oPushResult
5039: oCall 6487
5041: oPop 1
5043: oPushResult
5044: oEmitInt
5045: oPop 1
5047: oSetResult 0
5049: oPushResult
5050: oEmitInt
5051: oPop 1
5053: oEmit 27
5055: oJumpForward 5060
5057: Choice Lookup Table
           1   5026
5060: oGetAddrLocal 7
5062: oPushResult
5063: oGetLocal 5
5065: oPushResult
5066: oSetResult 12
5068: oPushResult
5069: oNodeGetIter
5070: oPop 2
5072: oAssign
5073: oGetAddrLocal 8
5075: oPushResult
5076: oGetLocal 7
5078: oPushResult
5079: oNodeIterValue
5080: oPop 1
5082: oAssign
5083: oInputChoice 5262
5085: oGetLocal 8
5087: oPushResult
5088: oNodeNull
5089: oPop 1
5091: oChoice 5097
5093: oJumpForward 5258
5095: oJumpForward 5100
5097: Choice Lookup Table
           1   5093
5100: oGetAddrLocal 9
5102: oPushResult
5103: oGetLocal 8
5105: oPushResult
5106: oSetResult 18
5108: oPushResult
5109: oNodeGetInt
5110: oPop 2
5112: oAssign
5113: oEmit 19
5115: oGetLocal 9
5117: oPushResult
5118: oEmitInt
5119: oPop 1
5121: oGetLocal 8
5123: oPushResult
5124: oSetResult 17
5126: oPushResult
5127: oNodeGet
5128: oPop 2
5130: oPushResult
5131: oTypeSPush
5132: oPop 1
5134: oGetLocal 8
5136: oPushResult
5137: oSetResult 28
5139: oPushResult
5140: oNodeGetBoolean
5141: oPop 2
5143: oChoice 5211
5145: oCall 5750
5147: oCall 6511
5149: oEmit 27
5151: oJumpForward 5217
5153: oCall 2425
5155: oCall 4751
5157: oTypeSNodeType
5158: oChoice 5176
5160: oEmit 25
5162: oJumpForward 5209
5164: oEmit 26
5166: oJumpForward 5209
5168: oError 16
5170: oJumpForward 5209
5172: oEmit 27
5174: oJumpForward 5209
5176: Choice Lookup Table
          25   5172
          19   5168
          24   5168
          23   5168
          21   5164
          20   5160
5189: oGetAddrLocal 10
5191: oPushResult
5192: oTypeSTop
5193: oPushResult
5194: oSetResult 13
5196: oPushResult
5197: oNodeGetInt
5198: oPop 2
5200: oAssign
5201: oEmit 28
5203: oGetLocal 10
5205: oPushResult
5206: oEmitInt
5207: oPop 1
5209: oJumpForward 5217
5211: Choice Lookup Table
           0   5153
           1   5145
5216: oEndChoice
5217: oTypeSPop
5218: oGetAddrLocal 7
5220: oPushResult
5221: oNodeIterNext
5222: oPop 1
5224: oGetAddrLocal 8
5226: oPushResult
5227: oGetLocal 7
5229: oPushResult
5230: oNodeIterValue
5231: oPop 1
5233: oAssign
5234: oGetLocal 8
5236: oPushResult
5237: oNodeNull
5238: oPop 1
5240: oChoice 5248
5242: oJumpForward 5258
5244: oJumpForward 5254
5246: oJumpForward 5254
5248: Choice Lookup Table
           0   5246
           1   5242
5253: oEndChoice
5254: oInput 12
5256: oJumpBack 5085
5258: oInput 14
5260: oJumpForward 5265
5262: Choice Lookup Table
          13   5085
5265: oGetLocal 8
5267: oPushResult
5268: oNodeNull
5269: oPop 1
5271: oChoice 5277
5273: oError 15
5275: oJumpForward 5280
5277: Choice Lookup Table
           0   5273
5280: oGetLocal 4
5282: oChoice 5311
5284: oEmit 19
5286: oGetParam 1
5288: oPushResult
5289: oSetResult 27
5291: oPushResult
5292: oNodeGetInt
5293: oPop 2
5295: oPushResult
5296: oEmitInt
5297: oPop 1
5299: oEmit 17
5301: oGetLocal 3
5303: oPushResult
5304: oEmitInt
5305: oPop 1
5307: oEmit 27
5309: oJumpForward 5314
5311: Choice Lookup Table
           1   5284
5314: oGetLocal 1
5316: oChoice 5340
5318: oEmit 50
5320: oGetParam 1
5322: oPushResult
5323: oCall 6788
5325: oPop 1
5327: oJumpForward 5346
5329: oEmit 49
5331: oGetParam 1
5333: oPushResult
5334: oCall 6788
5336: oPop 1
5338: oJumpForward 5346
5340: Choice Lookup Table
           0   5329
           1   5318
5345: oEndChoice
5346: oGetLocal 4
5348: oChoice 5416
5350: oGetLocal 2
5352: oPushResult
5353: oTypeSPush
5354: oPop 1
5356: oTypeSNodeType
5357: oChoice 5393
5359: oEmit 3
5361: oGetLocal 3
5363: oPushResult
5364: oEmitInt
5365: oPop 1
5367: oJumpForward 5414
5369: oEmit 4
5371: oGetLocal 3
5373: oPushResult
5374: oEmitInt
5375: oPop 1
5377: oJumpForward 5414
5379: oError 16
5381: oJumpForward 5414
5383: oEmit 5
5385: oGetLocal 3
5387: oPushResult
5388: oEmitInt
5389: oPop 1
5391: oJumpForward 5414
5393: Choice Lookup Table
          25   5383
          19   5379
          24   5379
          23   5379
          21   5369
          20   5359
5406: oEmit 17
5408: oGetLocal 3
5410: oPushResult
5411: oEmitInt
5412: oPop 1
5414: oJumpForward 5419
5416: Choice Lookup Table
           1   5350
5419: oEmit 48
5421: oGetLocal 6
5423: oPushResult
5424: oEmitInt
5425: oPop 1
5427: oReturn
5428: oLocalSpace 0
5430: oInputChoice 5480
5432: oCall 6387
5434: oJumpForward 5505
5436: oCall 6394
5438: oJumpForward 5505
5440: oCall 6461
5442: oJumpForward 5505
5444: oCall 6464
5446: oJumpForward 5505
5448: oCall 5927
5450: oJumpForward 5505
5452: oCall 6247
5454: oJumpForward 5505
5456: oCall 5993
5458: oJumpForward 5505
5460: oCall 6167
5462: oJumpForward 5505
5464: oCall 6332
5466: oJumpForward 5505
5468: oCall 6300
5470: oJumpForward 5505
5472: oCall 6364
5474: oJumpForward 5505
5476: oCall 5506
5478: oJumpForward 5505
5480: Choice Lookup Table
           0   5476
          33   5472
          49   5468
          50   5464
          47   5460
          42   5456
          46   5452
          39   5448
          63   5444
          62   5440
          61   5436
          60   5432
5505: oReturn
5506: oLocalSpace 1
5508: oGetAddrLocal 1
5510: oPushResult
5511: oScopeFindRequire
5512: oAssign
5513: oGetLocal 1
5515: oPushResult
5516: oNodeType
5517: oPop 1
5519: oChoice 5548
5521: oGetLocal 1
5523: oPushResult
5524: oCall 4839
5526: oPop 1
5528: oJumpForward 5561
5530: oGetLocal 1
5532: oPushResult
5533: oCall 5562
5535: oPop 1
5537: oJumpForward 5561
5539: oGetLocal 1
5541: oPushResult
5542: oCall 5636
5544: oPop 1
5546: oJumpForward 5561
5548: Choice Lookup Table
          10   5539
          17   5530
          15   5530
          14   5530
           9   5521
5559: oError 0
5561: oReturn
5562: oLocalSpace 0
5564: oGetParam 1
5566: oPushResult
5567: oCall 5786
5569: oPop 1
5571: oInput 3
5573: oCall 2425
5575: oCall 6511
5577: oCall 5580
5579: oReturn
5580: oLocalSpace 1
5582: oTypeSNodeType
5583: oChoice 5601
5585: oEmit 25
5587: oJumpForward 5634
5589: oEmit 26
5591: oJumpForward 5634
5593: oError 16
5595: oJumpForward 5634
5597: oEmit 27
5599: oJumpForward 5634
5601: Choice Lookup Table
          25   5597
          19   5593
          24   5593
          23   5593
          21   5589
          20   5585
5614: oGetAddrLocal 1
5616: oPushResult
5617: oTypeSTop
5618: oPushResult
5619: oSetResult 13
5621: oPushResult
5622: oNodeGetInt
5623: oPop 2
5625: oAssign
5626: oEmit 28
5628: oGetLocal 1
5630: oPushResult
5631: oEmitInt
5632: oPop 1
5634: oTypeSPop
5635: oReturn
5636: oLocalSpace 1
5638: oGetParam 1
5640: oPushResult
5641: oSetResult 5
5643: oPushResult
5644: oNodeGet
5645: oPop 2
5647: oPushResult
5648: oScopeCurrent
5649: oPushResult
5650: oNodeEqual
5651: oPop 2
5653: oChoice 5659
5655: oError 20
5657: oJumpForward 5662
5659: Choice Lookup Table
           0   5655
5662: oEmit 8
5664: oGetParam 1
5666: oPushResult
5667: oSetResult 27
5669: oPushResult
5670: oNodeGetInt
5671: oPop 2
5673: oPushResult
5674: oEmitInt
5675: oPop 1
5677: oGetParam 1
5679: oPushResult
5680: oSetResult 17
5682: oPushResult
5683: oNodeGet
5684: oPop 2
5686: oPushResult
5687: oTypeSPush
5688: oPop 1
5690: oInput 3
5692: oCall 2425
5694: oCall 6511
5696: oTypeSNodeType
5697: oChoice 5715
5699: oEmit 25
5701: oJumpForward 5748
5703: oEmit 26
5705: oJumpForward 5748
5707: oError 16
5709: oJumpForward 5748
5711: oEmit 27
5713: oJumpForward 5748
5715: Choice Lookup Table
          25   5711
          19   5707
          24   5707
          23   5707
          21   5703
          20   5699
5728: oGetAddrLocal 1
5730: oPushResult
5731: oTypeSTop
5732: oPushResult
5733: oSetResult 13
5735: oPushResult
5736: oNodeGetInt
5737: oPop 2
5739: oAssign
5740: oEmit 28
5742: oGetLocal 1
5744: oPushResult
5745: oEmitInt
5746: oPop 1
5748: oTypeSPop
5749: oReturn
5750: oLocalSpace 1
5752: oInput 0
5754: oGetAddrLocal 1
5756: oPushResult
5757: oScopeFindRequire
5758: oAssign
5759: oGetLocal 1
5761: oPushResult
5762: oNodeType
5763: oPop 1
5765: oChoice 5769
5767: oJumpForward 5778
5769: Choice Lookup Table
          17   5767
          15   5767
          14   5767
5776: oError 4
5778: oGetLocal 1
5780: oPushResult
5781: oCall 5786
5783: oPop 1
5785: oReturn
5786: oLocalSpace 0
5788: oGetParam 1
5790: oPushResult
5791: oNodeType
5792: oPop 1
5794: oChoice 5854
5796: oEmit 16
5798: oGetParam 1
5800: oPushResult
5801: oCall 6788
5803: oPop 1
5805: oJumpForward 5863
5807: oEmit 17
5809: oGetParam 1
5811: oPushResult
5812: oCall 6788
5814: oPop 1
5816: oJumpForward 5863
5818: oGetParam 1
5820: oPushResult
5821: oSetResult 28
5823: oPushResult
5824: oNodeGetBoolean
5825: oPop 2
5827: oChoice 5840
5829: oEmit 8
5831: oGetParam 1
5833: oPushResult
5834: oCall 6788
5836: oPop 1
5838: oJumpForward 5852
5840: Choice Lookup Table
           1   5829
5843: oEmit 18
5845: oGetParam 1
5847: oPushResult
5848: oCall 6788
5850: oPop 1
5852: oJumpForward 5863
5854: Choice Lookup Table
          17   5818
          15   5807
          14   5796
5861: oError 4
5863: oGetParam 1
5865: oPushResult
5866: oSetResult 17
5868: oPushResult
5869: oNodeGet
5870: oPop 2
5872: oPushResult
5873: oTypeSPush
5874: oPop 1
5876: oCall 4448
5878: oReturn
5879: oLocalSpace 0
5881: oGetParam 1
5883: oPushResult
5884: oCall 5786
5886: oPop 1
5888: oCall 6537
5890: oGetParam 1
5892: oPushResult
5893: oCall 3687
5895: oPop 1
5897: oTypeSPop
5898: oEmit 29
5900: oEmit 25
5902: oReturn
5903: oLocalSpace 0
5905: oGetParam 1
5907: oPushResult
5908: oCall 5786
5910: oPop 1
5912: oCall 6537
5914: oGetParam 1
5916: oPushResult
5917: oCall 3687
5919: oPop 1
5921: oTypeSPop
5922: oEmit 30
5924: oEmit 25
5926: oReturn
5927: oLocalSpace 2
5929: oGetAddrLocal 1
5931: oPushResult
5932: oSetResult 0
5934: oAssign
5935: oGetAddrLocal 1
5937: oPushResult
5938: oCall 2448
5940: oPop 1
5942: oInput 40
5944: oCall 5428
5946: oInputChoice 5981
5948: oGetAddrLocal 2
5950: oPushResult
5951: oLabelNew
5952: oAssign
5953: oEmit 53
5955: oGetLocal 2
5957: oPushResult
5958: oEmitLabel
5959: oPop 1
5961: oEmit 56
5963: oGetLocal 1
5965: oPushResult
5966: oEmitLabel
5967: oPop 1
5969: oCall 5428
5971: oEmit 56
5973: oGetLocal 2
5975: oPushResult
5976: oEmitLabel
5977: oPop 1
5979: oJumpForward 5992
5981: Choice Lookup Table
          41   5948
5984: oEmit 56
5986: oGetLocal 1
5988: oPushResult
5989: oEmitLabel
5990: oPop 1
5992: oReturn
5993: oLocalSpace 4
5995: oInput 0
5997: oGetAddrLocal 1
5999: oPushResult
6000: oScopeFindRequire
6001: oAssign
6002: oGetLocal 1
6004: oPushResult
6005: oCall 5786
6007: oPop 1
6009: oCall 6537
6011: oInput 3
6013: oCall 2425
6015: oCall 6537
6017: oEmit 25
6019: oGetAddrLocal 2
6021: oPushResult
6022: oLabelNew
6023: oAssign
6024: oGetAddrLocal 3
6026: oPushResult
6027: oLabelNew
6028: oAssign
6029: oEmit 53
6031: oGetLocal 3
6033: oPushResult
6034: oEmitLabel
6035: oPop 1
6037: oGetAddrLocal 4
6039: oPushResult
6040: oLabelNew
6041: oAssign
6042: oEmit 56
6044: oGetLocal 4
6046: oPushResult
6047: oEmitLabel
6048: oPop 1
6050: oInputChoice 6130
6052: oGetLocal 1
6054: oPushResult
6055: oCall 5879
6057: oPop 1
6059: oEmit 56
6061: oGetLocal 3
6063: oPushResult
6064: oEmitLabel
6065: oPop 1
6067: oGetLocal 1
6069: oPushResult
6070: oCall 3687
6072: oPop 1
6074: oTypeSPop
6075: oCall 2425
6077: oCall 6537
6079: oEmit 40
6081: oEmit 54
6083: oGetLocal 2
6085: oPushResult
6086: oEmitLabel
6087: oPop 1
6089: oJumpForward 6136
6091: oGetLocal 1
6093: oPushResult
6094: oCall 5903
6096: oPop 1
6098: oEmit 56
6100: oGetLocal 3
6102: oPushResult
6103: oEmitLabel
6104: oPop 1
6106: oGetLocal 1
6108: oPushResult
6109: oCall 3687
6111: oPop 1
6113: oTypeSPop
6114: oCall 2425
6116: oCall 6537
6118: oEmit 41
6120: oEmit 54
6122: oGetLocal 2
6124: oPushResult
6125: oEmitLabel
6126: oPop 1
6128: oJumpForward 6136
6130: Choice Lookup Table
          44   6091
          43   6052
6135: oEndChoice
6136: oGetLocal 4
6138: oPushResult
6139: oGetLocal 2
6141: oPushResult
6142: oLoopPush
6143: oPop 2
6145: oInput 45
6147: oCall 5428
6149: oEmit 53
6151: oGetLocal 4
6153: oPushResult
6154: oEmitLabel
6155: oPop 1
6157: oEmit 56
6159: oGetLocal 2
6161: oPushResult
6162: oEmitLabel
6163: oPop 1
6165: oLoopPop
6166: oReturn
6167: oLocalSpace 3
6169: oGetAddrLocal 1
6171: oPushResult
6172: oLabelNew
6173: oAssign
6174: oEmit 56
6176: oGetLocal 1
6178: oPushResult
6179: oEmitLabel
6180: oPop 1
6182: oGetAddrLocal 2
6184: oPushResult
6185: oLabelNew
6186: oAssign
6187: oGetLocal 1
6189: oPushResult
6190: oGetLocal 2
6192: oPushResult
6193: oLoopPush
6194: oPop 2
6196: oCall 5428
6198: oInputChoice 6229
6200: oCall 5428
6202: oJumpForward 6235
6204: oGetAddrLocal 3
6206: oPushResult
6207: oCall 2448
6209: oPop 1
6211: oEmit 57
6213: oGetLocal 3
6215: oPushResult
6216: oEmitLabel
6217: oPop 1
6219: oGetLocal 1
6221: oPushResult
6222: oEmitLabel
6223: oPop 1
6225: oJumpForward 6237
6227: oJumpForward 6235
6229: Choice Lookup Table
          48   6204
           4   6200
6234: oEndChoice
6235: oJumpBack 6198
6237: oEmit 56
6239: oGetLocal 2
6241: oPushResult
6242: oEmitLabel
6243: oPop 1
6245: oLoopPop
6246: oReturn
6247: oLocalSpace 2
6249: oGetAddrLocal 1
6251: oPushResult
6252: oLabelNew
6253: oAssign
6254: oEmit 56
6256: oGetLocal 1
6258: oPushResult
6259: oEmitLabel
6260: oPop 1
6262: oGetAddrLocal 2
6264: oPushResult
6265: oCall 2448
6267: oPop 1
6269: oGetLocal 1
6271: oPushResult
6272: oGetLocal 2
6274: oPushResult
6275: oLoopPush
6276: oPop 2
6278: oInput 45
6280: oCall 5428
6282: oEmit 53
6284: oGetLocal 1
6286: oPushResult
6287: oEmitLabel
6288: oPop 1
6290: oEmit 56
6292: oGetLocal 2
6294: oPushResult
6295: oEmitLabel
6296: oPop 1
6298: oLoopPop
6299: oReturn
6300: oLocalSpace 0
6302: oLoopContinueLabel
6303: oPushResult
6304: oSetResult 0
6306: oPushResult
6307: equal_label
6308: oPop 2
6310: oChoice 6325
6312: oError 18
6314: oJumpForward 6331
6316: oEmit 53
6318: oLoopContinueLabel
6319: oPushResult
6320: oEmitLabel
6321: oPop 1
6323: oJumpForward 6331
6325: Choice Lookup Table
           0   6316
           1   6312
6330: oEndChoice
6331: oReturn
6332: oLocalSpace 0
6334: oLoopBreakLabel
6335: oPushResult
6336: oSetResult 0
6338: oPushResult
6339: equal_label
6340: oPop 2
6342: oChoice 6357
6344: oError 18
6346: oJumpForward 6363
6348: oEmit 53
6350: oLoopBreakLabel
6351: oPushResult
6352: oEmitLabel
6353: oPop 1
6355: oJumpForward 6363
6357: Choice Lookup Table
           0   6348
           1   6344
6362: oEndChoice
6363: oReturn
6364: oLocalSpace 0
6366: oCall 5428
6368: oInputChoice 6378
6370: oCall 5428
6372: oJumpForward 6384
6374: oJumpForward 6386
6376: oJumpForward 6384
6378: Choice Lookup Table
          34   6374
           4   6370
6383: oEndChoice
6384: oJumpBack 6368
6386: oReturn
6387: oLocalSpace 0
6389: oCall 6394
6391: oEmit 63
6393: oReturn
6394: oLocalSpace 0
6396: oInputChoice 6457
6398: oCall 2425
6400: oTypeSNodeType
6401: oChoice 6423
6403: oEmit 59
6405: oJumpForward 6438
6407: oEmit 60
6409: oJumpForward 6438
6411: oEmit 61
6413: oJumpForward 6438
6415: oError 16
6417: oJumpForward 6438
6419: oEmit 62
6421: oJumpForward 6438
6423: Choice Lookup Table
          25   6419
          19   6415
          23   6415
          24   6411
          21   6407
          20   6403
6436: oError 17
6438: oTypeSPop
6439: oInputChoice 6447
6441: oJumpForward 6455
6443: oJumpForward 6453
6445: oJumpForward 6453
6447: Choice Lookup Table
          12   6445
          14   6441
6452: oEndChoice
6453: oJumpBack 6398
6455: oJumpForward 6460
6457: Choice Lookup Table
          13   6398
6460: oReturn
6461: oLocalSpace 0
6463: oReturn
6464: oLocalSpace 0
6466: oReturn
6467: oLocalSpace 0
6469: oGetParam 1
6471: oPushResult
6472: oSetResult 16
6474: oPushResult
6475: oNodeGet
6476: oPop 2
6478: oPushResult
6479: oSetResult 11
6481: oPushResult
6482: oNodeGetInt
6483: oPop 2
6485: oReturn
6486: oReturn
6487: oLocalSpace 0
6489: oScopeCurrent
6490: oPushResult
6491: oSetResult 11
6493: oPushResult
6494: oNodeGetInt
6495: oPop 2
6497: oPushResult
6498: oGetParam 1
6500: oPushResult
6501: oCall 6467
6503: oPop 1
6505: oPushResult
6506: subtract
6507: oPop 2
6509: oReturn
6510: oReturn
6511: oLocalSpace 1
6513: oGetAddrLocal 1
6515: oPushResult
6516: oTypeSNodeType
6517: oAssign
6518: oTypeSPop
6519: oGetLocal 1
6521: oPushResult
6522: oTypeSNodeType
6523: oPushResult
6524: equal_node_type
6525: oPop 2
6527: oChoice 6533
6529: oError 14
6531: oJumpForward 6536
6533: Choice Lookup Table
           0   6529
6536: oReturn
6537: oLocalSpace 0
6539: oTypeSNodeType
6540: oChoice 6544
6542: oJumpForward 6549
6544: Choice Lookup Table
          20   6542
6547: oError 7
6549: oTypeSPop
6550: oReturn
6551: oLocalSpace 0
6553: oTypeSNodeType
6554: oChoice 6558
6556: oJumpForward 6563
6558: Choice Lookup Table
          20   6556
6561: oError 7
6563: oReturn
6564: oLocalSpace 0
6566: oTypeSNodeType
6567: oChoice 6571
6569: oJumpForward 6576
6571: Choice Lookup Table
          21   6569
6574: oError 8
6576: oTypeSPop
6577: oReturn
6578: oLocalSpace 0
6580: oTypeSNodeType
6581: oChoice 6585
6583: oJumpForward 6590
6585: Choice Lookup Table
          21   6583
6588: oError 8
6590: oReturn
6591: oLocalSpace 1
6593: oGetAddrLocal 1
6595: oPushResult
6596: oGetParam 2
6598: oPushResult
6599: oNodeNew
6600: oPop 1
6602: oAssign
6603: oGetLocal 1
6605: oPushResult
6606: oSetResult 13
6608: oPushResult
6609: oGetParam 1
6611: oPushResult
6612: oNodeSetInt
6613: oPop 3
6615: oGetLocal 1
6617: oPushResult
6618: oTypeAdd
6619: oPop 1
6621: oGetLocal 1
6623: oReturn
6624: oReturn
6625: oLocalSpace 1
6627: oGetAddrLocal 1
6629: oPushResult
6630: oGetParam 3
6632: oPushResult
6633: oNodeNew
6634: oPop 1
6636: oAssign
6637: oGetLocal 1
6639: oPushResult
6640: oSetResult 3
6642: oPushResult
6643: oGetParam 1
6645: oPushResult
6646: oNodeSetInt
6647: oPop 3
6649: oGetLocal 1
6651: oReturn
6652: oReturn
6653: oLocalSpace 1
6655: oGetAddrLocal 1
6657: oPushResult
6658: oGetParam 1
6660: oPushResult
6661: oSetResult 29
6663: oPushResult
6664: oNodeGet
6665: oPop 2
6667: oAssign
6668: oGetLocal 1
6670: oPushResult
6671: oNodeNull
6672: oPop 1
6674: oChoice 6730
6676: oGetAddrLocal 1
6678: oPushResult
6679: oSetResult 25
6681: oPushResult
6682: oNodeNew
6683: oPop 1
6685: oAssign
6686: oGetLocal 1
6688: oPushResult
6689: oSetResult 30
6691: oPushResult
6692: oGetParam 1
6694: oPushResult
6695: oNodeSet
6696: oPop 3
6698: oGetLocal 1
6700: oPushResult
6701: oSetResult 13
6703: oPushResult
6704: oSetResult 8
6706: oPushResult
6707: oNodeSetInt
6708: oPop 3
6710: oGetLocal 1
6712: oPushResult
6713: oTypeAdd
6714: oPop 1
6716: oGetParam 1
6718: oPushResult
6719: oSetResult 29
6721: oPushResult
6722: oGetLocal 1
6724: oPushResult
6725: oNodeSet
6726: oPop 3
6728: oJumpForward 6733
6730: Choice Lookup Table
           1   6676
6733: oGetLocal 1
6735: oReturn
6736: oReturn
6737: oLocalSpace 0
6739: oGetParam 1
6741: oPushResult
6742: oNodeType
6743: oPop 1
6745: oChoice 6773
6747: oMININT
6748: oReturn
6749: oJumpForward 6787
6751: oSetResult 0
6753: oReturn
6754: oJumpForward 6787
6756: oSetResult 0
6758: oReturn
6759: oJumpForward 6787
6761: oGetParam 1
6763: oPushResult
6764: oSetResult 32
6766: oPushResult
6767: oNodeGetInt
6768: oPop 2
6770: oReturn
6771: oJumpForward 6787
6773: Choice Lookup Table
          27   6761
          23   6756
          21   6751
          20   6747
6782: oError 3
6784: oSetResult 0
6786: oReturn
6787: oReturn
6788: oLocalSpace 0
6790: oGetParam 1
6792: oPushResult
6793: oSetResult 18
6795: oPushResult
6796: oNodeGetInt
6797: oPop 2
6799: oPushResult
6800: oEmitInt
6801: oPop 1
6803: oReturn
6804: oLocalSpace 1
6806: oGetAddrGlobal 4
6808: oPushResult
6809: oSetResult 19
6811: oPushResult
6812: oSetResult 4
6814: oPushResult
6815: oCall 6591
6817: oPop 2
6819: oAssign
6820: oGetAddrGlobal 5
6822: oPushResult
6823: oSetResult 20
6825: oPushResult
6826: oSetResult 4
6828: oPushResult
6829: oCall 6591
6831: oPop 2
6833: oAssign
6834: oGetAddrGlobal 6
6836: oPushResult
6837: oSetResult 21
6839: oPushResult
6840: oSetResult 1
6842: oPushResult
6843: oCall 6591
6845: oPop 2
6847: oAssign
6848: oGetAddrGlobal 7
6850: oPushResult
6851: oSetResult 22
6853: oPushResult
6854: oSetResult 1
6856: oPushResult
6857: oCall 6591
6859: oPop 2
6861: oAssign
6862: oGetAddrGlobal 8
6864: oPushResult
6865: oSetResult 23
6867: oPushResult
6868: oSetResult 1
6870: oPushResult
6871: oCall 6591
6873: oPop 2
6875: oAssign
6876: oGetAddrGlobal 9
6878: oPushResult
6879: oSetResult 24
6881: oPushResult
6882: oSetResult 256
6884: oPushResult
6885: oCall 6591
6887: oPop 2
6889: oAssign
6890: oGetAddrLocal 1
6892: oPushResult
6893: oSetResult 12
6895: oPushResult
6896: oSetResult 5
6898: oPushResult
6899: oIdAdd_File
6900: oPushResult
6901: oCall 6625
6903: oPop 3
6905: oAssign
6906: oGetLocal 1
6908: oPushResult
6909: oSetResult 17
6911: oPushResult
6912: oGetGlobal 4
6914: oPushResult
6915: oNodeSet
6916: oPop 3
6918: oGetLocal 1
6920: oPushResult
6921: oScopeDeclare
6922: oPop 1
6924: oGetAddrLocal 1
6926: oPushResult
6927: oSetResult 12
6929: oPushResult
6930: oSetResult 5
6932: oPushResult
6933: oIdAdd_Integer
6934: oPushResult
6935: oCall 6625
6937: oPop 3
6939: oAssign
6940: oGetLocal 1
6942: oPushResult
6943: oSetResult 17
6945: oPushResult
6946: oGetGlobal 5
6948: oPushResult
6949: oNodeSet
6950: oPop 3
6952: oGetLocal 1
6954: oPushResult
6955: oScopeDeclare
6956: oPop 1
6958: oGetAddrLocal 1
6960: oPushResult
6961: oSetResult 12
6963: oPushResult
6964: oSetResult 5
6966: oPushResult
6967: oIdAdd_Boolean
6968: oPushResult
6969: oCall 6625
6971: oPop 3
6973: oAssign
6974: oGetLocal 1
6976: oPushResult
6977: oSetResult 17
6979: oPushResult
6980: oGetGlobal 6
6982: oPushResult
6983: oNodeSet
6984: oPop 3
6986: oGetLocal 1
6988: oPushResult
6989: oScopeDeclare
6990: oPop 1
6992: oGetAddrLocal 1
6994: oPushResult
6995: oSetResult 12
6997: oPushResult
6998: oSetResult 5
7000: oPushResult
7001: oIdAdd_Char
7002: oPushResult
7003: oCall 6625
7005: oPop 3
7007: oAssign
7008: oGetLocal 1
7010: oPushResult
7011: oSetResult 17
7013: oPushResult
7014: oGetGlobal 8
7016: oPushResult
7017: oNodeSet
7018: oPop 3
7020: oGetLocal 1
7022: oPushResult
7023: oScopeDeclare
7024: oPop 1
7026: oGetAddrLocal 1
7028: oPushResult
7029: oSetResult 12
7031: oPushResult
7032: oSetResult 5
7034: oPushResult
7035: oIdAdd_String
7036: oPushResult
7037: oCall 6625
7039: oPop 3
7041: oAssign
7042: oGetLocal 1
7044: oPushResult
7045: oSetResult 17
7047: oPushResult
7048: oGetGlobal 9
7050: oPushResult
7051: oNodeSet
7052: oPop 3
7054: oGetLocal 1
7056: oPushResult
7057: oScopeDeclare
7058: oPop 1
7060: oGetAddrLocal 1
7062: oPushResult
7063: oSetResult 11
7065: oPushResult
7066: oSetResult 4
7068: oPushResult
7069: oIdAdd_True
7070: oPushResult
7071: oCall 6625
7073: oPop 3
7075: oAssign
7076: oGetLocal 1
7078: oPushResult
7079: oSetResult 17
7081: oPushResult
7082: oGetGlobal 6
7084: oPushResult
7085: oNodeSet
7086: oPop 3
7088: oGetLocal 1
7090: oPushResult
7091: oSetResult 18
7093: oPushResult
7094: oSetResult 1
7096: oPushResult
7097: oNodeSetInt
7098: oPop 3
7100: oGetLocal 1
7102: oPushResult
7103: oScopeDeclare
7104: oPop 1
7106: oGetAddrLocal 1
7108: oPushResult
7109: oSetResult 11
7111: oPushResult
7112: oSetResult 4
7114: oPushResult
7115: oIdAdd_False
7116: oPushResult
7117: oCall 6625
7119: oPop 3
7121: oAssign
7122: oGetLocal 1
7124: oPushResult
7125: oSetResult 17
7127: oPushResult
7128: oGetGlobal 6
7130: oPushResult
7131: oNodeSet
7132: oPop 3
7134: oGetLocal 1
7136: oPushResult
7137: oSetResult 18
7139: oPushResult
7140: oSetResult 0
7142: oPushResult
7143: oNodeSetInt
7144: oPop 3
7146: oGetLocal 1
7148: oPushResult
7149: oScopeDeclare
7150: oPop 1
7152: oReturn
