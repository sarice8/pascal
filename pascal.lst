   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstP       % <ptr> - push constant ptr value
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncGlobalI       % <ptr> - increment int value pointed to by ptr
   2:    tDecGlobalI       % <ptr> - decrement int value pointed to by ptr
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddI  
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % addr follows
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, out int addr );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by jumping to the main program statement
  12:    int patchJumpMain
  12:    .tJump 
  14:    patchJumpMain = Here
  19:    .tSpace
      
  21:    pProgram
  23:    pIdent
      
  25:    t = @newIdent( nProgram, kProgram, LAST_ID )
  41:    oScopeDeclare( t )
      
  47:    [
  47:       | '(' :
  49:          pIdent      % input, output files
      
  51:          t = @newIdent( nVar, kVar, LAST_ID )
  67:          oNodeSet( t, qType, FileType )
  79:          oScopeDeclareAlloc( t )
      
  85:          ','
  87:          pIdent
      
  89:          t = @newIdent( nVar, kVar, LAST_ID )
 105:          oNodeSet( t, qType, FileType )
 117:          oScopeDeclareAlloc( t )
      
 123:          ')'
 125:       | * :
 130:    ]
 130:    ';'
      
 132:    int addr
 132:    @Block( nGlobalVar, addr )    % not including punctuation after body's 'end'
 142:    oPatch( patchJumpMain, addr )
      
 151:    '.'
 153:    oScopeEnd
 155:    ;
      
      
      % Returns the addr of the block's statements.
      % This might differ from the Here on entry to this rule,
      % due to method declarations in the block.
      %
 155: Block( node_type varNodeType, out int addr ):
 157:    {[
 157:       | pConst :     @ConstDecl
 161:       | pType :      @TypeDecl
 165:       | pVar :       @VarDecl( varNodeType )
 174:       | pProcedure : @ProcDecl
 178:       | pFunction :  @FuncDecl
 182:       | * :          >
 197:    ]}
 199:    addr = Here
      
         % proc/func body begins with tEnter
 204:    int patchLS
 204:    [ equal_node_type( varNodeType, nLocalVar )
 214:       | true :       .tEnter  patchLS = Here  .tSpace
 224:       | * :
 229:    ]
      
 229:    @Statement
 231:    .tReturn
      
 233:    [ equal_node_type( varNodeType, nLocalVar )
 243:       | true :
 244:          int localSpace
 244:          localSpace = oNodeGetInt( oScopeCurrent, qSize )
 256:          oPatch( patchLS, localSpace )
 265:       | * :
 270:    ];
      
      
 271: ProcDecl:
 273:    Node decl
      
 273:    pIdent
 275:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 291:    oScopeBegin
 292:    Node paramScope
 292:    paramScope = oScopeCurrent
      
 297:    @FormalArgDecl
 299:    oNodeSet( decl, qParams, paramScope )
 311:    oScopeEnd
      
 312:    oScopeDeclare( decl )
 318:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 320:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 326:    oScopeBegin
 327:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
      
 338:    int addr
 338:    @Block( nLocalVar, addr )
 348:    oNodeSet( decl, qChildScope, oScopeCurrent )
 359:    oNodeSetInt( decl, qValue, addr )
 371:    oNodeSetBoolean( decl, qAddrDefined, true )
 383:    oScopeEnd
      
 384:    oScopeEnd  % paramScope
 385:    ';';
      
 388: FuncDecl:
 390:    Node decl
 390:    Node theType
      
 390:    pIdent
 392:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 408:    oScopeBegin
 409:    Node paramScope
 409:    paramScope = oScopeCurrent
      
 414:    @FormalArgDecl
 416:    oNodeSet( decl, qParams, paramScope )
 428:    oScopeEnd
      
 429:    oScopeDeclare( decl )
 435:    ':'
      
 437:    @TypeRef( theType )
 444:    oNodeSet( decl, qType, theType )
 456:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 458:    oScopeEnter( paramScope )
      
 464:    oScopeBegin
 465:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
      
 476:    int addr
 476:    @Block( nLocalVar, addr )
 486:    oNodeSet( decl, qChildScope, oScopeCurrent )
 497:    oNodeSetInt( decl, qValue, addr )
 509:    oNodeSetBoolean( decl, qAddrDefined, true )
 521:    oScopeEnd
      
 522:    oScopeEnd  % paramScope
 523:    ';';
      
      
 526: FormalArgDecl:
 528:    [
 528:       | '(' :
 530:          {
 530:             NodeVec decls
 530:             decls = oNodeVecNew
 535:             Node decl
 535:             boolean isInOut
 535:             isInOut = false
      
 541:             [
 541:                | pVar : isInOut = true
 549:                | * :
 554:             ]
      
 554:             {  pIdent
      
 556:                decl = @newIdent( nParam, kVar, LAST_ID )
 572:                oNodeSetBoolean( decl, qInOut, isInOut )
 584:                oNodeVecAppend( decls, decl )
      
 593:                [
 593:                   | ':' : >
 597:                   | ',' :
 599:                ]
 607:             }
      
 609:             Node theType
 609:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 616:             Node allocType
 616:             [ isInOut
 619:                | true :   allocType = @PointerTypeTo( theType )
 631:                | * :      allocType = theType
 642:             ]
      
 642:             int i
 642:             i = 0
 648:             {[ equal( i, oNodeVecSize( decls ) )
 662:                | false :
 663:                   decl = oNodeVecElement( decls, i )
      
 676:                   oNodeSet( decl, qType, theType )
 688:                   oScopeDeclare( decl )
 694:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 710:                   inc( i )
 716:                | * :
 721:                   >
 723:             ]}
      
 725:             oNodeVecDelete( decls )
      
 731:             [
 731:                | ')' : >
 735:                | ';' :
 737:             ]
 745:          }
 747:       | * :
 752:    ];
      
 753: ConstDecl:
 755:    {[
 755:       | pIdent :
 757:          Node decl
 757:          decl = @newIdent( nConst, kConst, LAST_ID )
 773:          '='
      
 775:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 777:          int val
 777:          val = oValueTop
 782:          oValuePop
 783:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 795:          oNodeSet( decl, qType, IntegerType )
      
 807:          oScopeDeclare( decl )
 813:          ';'
 815:       | * :
 820:          >
 822:    ]};
      
 825: TypeDecl:
 827:    {[
 827:       | pIdent :
 829:          Node decl
 829:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 845:          '='
 847:          Node theType
 847:          @TypeRef( theType )
 854:          oNodeSet( decl, qType, theType )
 866:          oScopeDeclare( decl )
 872:          ';'
 874:       | * :
 879:          >
 881:    ]};
      
 884: VarDecl( node_type varNodeType ):
 886:    {[
 886:       | pIdent :
 888:          NodeVec decls
 888:          decls = oNodeVecNew
 893:          Node decl
 893:          {
 893:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 909:             oNodeVecAppend( decls, decl )
 918:             [
 918:                | ',' :
 920:                   pIdent
 922:                | * :
 927:                   >
 929:             ]
 929:          }
 931:          ':'
 933:          Node theType
 933:          @TypeRef( theType )
      
 940:          int i
 940:          i = 0
 946:          {[ equal( i, oNodeVecSize( decls ) )
 960:            | false :
 961:              decl = oNodeVecElement( decls, i )
 974:              oNodeSet( decl, qType, theType )
 986:              oScopeDeclareAlloc( decl )
 992:              inc( i )
 998:             | * :
1003:               >
1005:          ]}
      
1007:          oNodeVecDelete( decls )
1013:          ';'
1015:       | * :
1020:          >
1022:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1025: TypeRef( out Node resultType ):
1027:    [
1027:       | pIdent :           % previously named type (including intrinsics)
1029:          Node decl
1029:          decl = oScopeFindRequire
1034:          [ oNodeType( decl )
1041:            | nTypeDecl :
1042:                resultType = oNodeGet( decl, qType )
1055:            | * :
1060:                #eNotType
1062:                resultType = IntegerType
1068:          ]
         
1068:       | pArray :
1070:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1072:          NodeVec dimensions
1072:          dimensions = oNodeVecNew
      
1077:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1077:             Node subrange
1077:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1087:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1099:             @ConstExpr
1101:             oNodeSetInt( subrange, qLow, oValueTop )
1112:             oValuePop
1113:             '..'
1115:             @ConstExpr
1117:             oNodeSetInt( subrange, qHigh, oValueTop )
1128:             oValuePop
1129:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1141:             oTypeAdd( subrange )
      
1147:             Node a
1147:             a = oNodeNew( nArrayType )
1157:             oNodeSet( a, qIndexType, subrange )
      
1169:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1178:             [
1178:                | ']' : >
1182:                | ',' :
1184:             ]
1192:          }
1194:          pOf
1196:          Node baseType
1196:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1203:          int dim
1203:          dim = oNodeVecSize( dimensions )
1213:          {
1213:              dec(dim)
      
1219:              Node a
1219:              a = oNodeVecElement( dimensions, dim )
1232:              oNodeSet( a, qBaseType, baseType )
1244:              Node subrange
1244:              subrange = oNodeGet( a, qIndexType )
1257:              int width
1257:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1284:              inc( width )
1290:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1316:              oTypeAdd( a )
1322:              baseType = a
      
1328:              [ equal_zero(dim)
1335:                  | true:  >
1338:                  | *:
1343:              ]
1343:          }
      
1345:          resultType = oNodeVecElement( dimensions, 0 )
1358:          oNodeVecDelete( dimensions )
      
1364:       | '^' :
1366:          Node theType
1366:          @TypeRef( theType )
1373:          resultType = @PointerTypeTo( theType )
      
1384:       | pRecord :
1386:          resultType = oNodeNew( nRecordType )
1396:          oScopeBegin
      
1397:          @VarDecl( nRecordField )
      
1404:          int size
1404:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1416:          [ equal_zero( size )
1423:             | true : #eRecordEmpty
1426:             | * :
1431:          ]
      
1431:          pEnd
      
1433:          oNodeSet( resultType, qScope, oScopeCurrent )
1444:          oNodeSetInt( resultType, qSize, size )
1456:          oScopeEnd
1457:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1463:       | pSet :
1465:          pOf
1467:          Node theType
1467:          @TypeRef( theType )
1474:       | * :       % this works for cases except where expr starts with an id
1487:          @ConstExpr '..' @ConstExpr
1493:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1494: ConstExpr:
1496:    [
1496:       | pIntLit :
1498:          oValuePush( TOKEN_VALUE )
1503:       | pIdent :
1505:          Node decl
1505:          decl = oScopeFindRequire
1510:          [ oNodeType( decl )
1517:             | nConst :
1518:                oValuePush( oNodeGetInt( decl, qValue ) )
1531:             | * :
1536:                #eNotConst
1538:                oValuePush( 0 )
1544:          ]
1544:       | pMinus :
1546:          @ConstExpr
1548:          oValueNegate
1549:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1560: Expr:
1562:    @BoolExpr
1564:    {[
1564:       | '=' :
1566:          @BoolExpr
1568:          @MatchTypes
1570:          [ oTypeSNodeType
1572:             | nIntegerType, nBooleanType :  .tEqualI
1575:             | nPointerType :                .tEqualP
1579:             | nCharType, nStringType :      #eNotImplemented
1583:             | * :                           #eNotAllowed
1598:          ]
1598:          oTypeSPop
1599:          oTypeSPush( BooleanType )
      
1605:       | '<>' :
1607:          @BoolExpr
1609:          @MatchTypes
1611:          [ oTypeSNodeType
1613:             | nIntegerType, nBooleanType :  .tNotEqualI
1616:             | nPointerType :                .tNotEqualP
1620:             | nCharType, nStringType :      #eNotImplemented
1624:             | * :                           #eNotAllowed
1639:          ]
1639:          oTypeSPop
1640:          oTypeSPush( BooleanType )
      
1646:       | '<' :
1648:          @BoolExpr
1650:          @MatchTypes
1652:          [ oTypeSNodeType
1654:             | nIntegerType, nBooleanType :  .tLessI
1657:             | nCharType, nStringType :      #eNotImplemented
1661:             | * :                           #eNotAllowed
1674:          ]
1674:          oTypeSPop
1675:          oTypeSPush( BooleanType )
      
1681:       | '>' :
1683:          @BoolExpr
1685:          @MatchTypes
1687:          [ oTypeSNodeType
1689:             | nIntegerType, nBooleanType :  .tGreaterI
1692:             | nCharType, nStringType :      #eNotImplemented
1696:             | * :                           #eNotAllowed
1709:          ]
1709:          oTypeSPop
1710:          oTypeSPush( BooleanType )
      
1716:       | '<=' :
1718:          @BoolExpr
1720:          @MatchTypes
1722:          [ oTypeSNodeType
1724:             | nIntegerType, nBooleanType :  .tLessEqualI
1727:             | nCharType, nStringType :      #eNotImplemented
1731:             | * :                           #eNotAllowed
1744:          ]
1744:          oTypeSPop
1745:          oTypeSPush( BooleanType )
      
1751:       | '>=' :
1753:          @BoolExpr
1755:          @MatchTypes
1757:          [ oTypeSNodeType
1759:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1762:             | nCharType, nStringType :      #eNotImplemented
1766:             | * :                           #eNotAllowed
1779:          ]
1779:          oTypeSPop
1780:          oTypeSPush( BooleanType )
      
1786:       | * :
1801:          >
1803:    ]};
      
1806: BoolExpr:
1808:    @BoolTerm
1810:    {[
1810:       | pOr :
1812:          @RequireBoolPop
1814:          @BoolTerm
1816:          @RequireBool
1818:          .tOr
1820:       | * :
1825:          >
1827:    ]};
      
1830: BoolTerm:
1832:    @BoolFactor
1834:    {[
1834:       | pAnd :
1836:          @RequireBoolPop
1838:          @BoolFactor
1840:          @RequireBool
1842:          .tAnd
1844:       | * :
1849:          >
1851:    ]};
      
1854: BoolFactor:
1856:    [
1856:       | pNot :
1858:          @ArithExpr
1860:          @RequireBool
1862:          .tNot
1864:       | * :
1869:          @ArithExpr
1871:    ];
      
1872: ArithExpr:
1874:    @Term
1876:    {[
1876:       | pPlus :
1878:          @RequireIntPop
1880:          @Term
1882:          @RequireInt
1884:          .tAddI
1886:       | pMinus :
1888:          @RequireIntPop
1890:          @Term
1892:          @RequireInt
1894:          .tSubI
1896:       | * :
1903:          >
1905:    ]};
      
1908: Term:
1910:    @Factor
1912:    {[
1912:       | pTimes :
1914:          @RequireIntPop
1916:          @Factor
1918:          @RequireInt
1920:          .tMultI
1922:       | pDivide :
1924:          @RequireIntPop
1926:          @Factor
1928:          @RequireInt
1930:          .tDivI
1932:       | * :
1939:          >
1941:    ]};
      
1944: Factor:
1946:    [
1946:       | pPlus :
1948:          @Primary
1950:          @RequireInt
1952:       | pMinus :
1954:          @Primary
1956:          @RequireInt
1958:          .tNegI
1960:       | * :
1967:          @Primary
1969:    ];
      
1970: Primary:
1972:    [
1972:       | pIntLit :
1974:          .tPushConstI  oEmitInt( TOKEN_VALUE )
1981:          oTypeSPush( IntegerType )
      
1987:       | '(' :
1989:          @Expr
1991:          ')'
      
1993:       | pStrLit :
1995:          oStringAllocLit     % store, put addr on value stack
1996:          .tPushConstP oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2004:          oTypeSPush( StringType )
      
2010:       | pIdent :
2012:          Node decl
2012:          Node theType
2012:          decl = oScopeFindRequire
      
2017:          [ oNodeType( decl )
2024:             | nFunc :
      
2025:                @Call( decl )
      
2032:             | nConst :
2034:                theType = oNodeGet( decl, qType )
2047:                oTypeSPush( theType )
2053:                [ oTypeSNodeType
2055:                   | nIntegerType, nBooleanType :
2056:                      .tPushConstI @EmitValue( decl )
2065:                   | * :
2072:                      #eNotImplemented
2074:                ]
      
2074:             | nGlobalVar, nLocalVar, nParam :
2076:                @VarExpr( decl )
      
2083:             | * :
2096:                #eNotValue
2098:                oTypeSPush( IntegerType )
2104:          ]
      
2104:       | '^' :        % ^var
2106:          pIdent
      
2108:          Node decl
2108:          Node theType
2108:          decl = oScopeFindRequire
      
2113:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2120:          theType = oTypeSTop
2125:          oTypeSPop
2126:          Node ptrType
2126:          ptrType = @PointerTypeTo( theType )
2137:          oTypeSPush( ptrType )
      
2143:       | * :
2156:          #eNotValue
2158:          oTypeSPush( IntegerType )
2164:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2165: VarExpr( Node decl ):
2167:    Node theType
2167:    theType = oNodeGet( decl, qType )
2180:    oTypeSPush( theType )
2186:    [ oTypeSNodeType
2188:       | nIntegerType :
2189:          [ oNodeType( decl )
2196:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2206:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2217:             | nParam :
2219:                [ oNodeGetBoolean( decl, qInOut )
2229:                   | true :    % VAR param points to the var.  Auto dereference.
2230:                               .tPushParamP @EmitValue( decl )
2239:                               .tFetchI
2241:                   | * :       .tPushParamI @EmitValue( decl )
2255:                ]
2255:          ]
      
2265:       | nBooleanType :
2267:          [ oNodeType( decl )
2274:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2284:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2295:             | nParam :
2297:                [ oNodeGetBoolean( decl, qInOut )
2307:                   | true :    % VAR param points to the var.  Auto derefernce.
2308:                               .tPushParamP @EmitValue( decl )
2317:                               .tFetchB
2319:                   | * :       .tPushParamB @EmitValue( decl )
2333:                ]
2333:          ]
      
2343:       | nCharType, nStringType, nFileType :
2345:          #eNotImplemented
      
2347:       | nPointerType :
2349:          [ oNodeType( decl )
2356:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2366:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2377:             | nParam :
2379:                [ oNodeGetBoolean( decl, qInOut )
2389:                   | true :    % VAR param points to the var.  Auto derefernce.
2390:                               .tPushParamP @EmitValue( decl )
2399:                               .tFetchP
2401:                   | * :       .tPushParamP @EmitValue( decl )
2415:                ]
2415:          ]
2425:          [
2425:             | '^' :             % dereferenced
2427:                oTypeSPop
2428:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2441:                @LValueIndexes
2443:                @FetchVar
2445:             | * :               % just ptr value alone
2450:          ]
      
2450:       | * :
               % compound type
               % first, push addr of start of var
2465:          [ oNodeType( decl )
2472:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2482:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2493:             | nParam :
2495:                [ oNodeGetBoolean( decl, qInOut )
2505:                   | true :    % VAR param points to the var.  Auto derefernce.
2506:                               .tPushParamP @EmitValue( decl )
2515:                   | * :       .tPushAddrParam @EmitValue( decl )
2529:                ]
2529:          ]
               % modify addr for subscripts, field references, etc
2539:          @LValueIndexes
               % get final value
2541:          @FetchVar
2543:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2544: FetchVar:
2546:    [ oTypeSNodeType
2548:       | nIntegerType :   .tFetchI
2551:       | nBooleanType :   .tFetchB
2555:       | nCharType, nStringType, nFileType : #eNotImplemented
2559:       | nPointerType :   .tFetchP
2563:       | * :              % compound type; leave as addr
2578:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
2579: LValueIndexes:
2581:    {[
2581:       | '[' :       @ArraySubscripts
2585:       | '.' :       @RecordFieldRef
2589:       | '^' :       @PointerDeref
2593:       | * :         >
2604:    ]};
      
2607: ArraySubscripts:
2609:    [ oTypeSNodeType
2611:       | nArrayType :
2612:       | * :       #eNotArray
2619:    ]
2619:    {
2619:       [ oTypeSNodeType
2621:          | nArrayType :
2622:          | * :    #eTooManySubscripts
2629:       ]
      
            % low subscript of this dimension
2629:       int low
2629:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2646:       Node baseType
2646:       baseType = oNodeGet( oTypeSTop, qBaseType )
2658:       oTypeSPop
2659:       oTypeSPush( baseType )
      
2665:       @Expr
2667:       @RequireIntPop
            % adjust for low subscript
2669:       [ equal_zero( low )
2676:          | false :
2677:             .tPushConstI oEmitInt( low ) .tSubI
2687:          | * :
2692:       ]
      
            % multiply by element size
2692:       int size
2692:       size = oNodeGetInt( baseType, qSize )
2705:       [ equal( size, 1 )
2715:          | false :
2716:             .tPushConstI oEmitInt( size ) .tMultI
2726:          | * :
2731:       ]
      
            % update start address
2731:       .tAddI
2733:       [
2733:          | ']' :  >
2737:          | ',' :
2739:       ]
2747:    };
      
      
2750: RecordFieldRef:
2752:    [ oTypeSNodeType
2754:       | nRecordType :
2755:       | * :    #eNotRecord
2762:    ]
2762:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2774:    pIdent
2776:    Node field
2776:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2781:    [ oNodeType( field )
2788:       | nRecordField :
2789:       | * :   #eNotRecordField
2796:    ]
2796:    oScopeEnd
2797:    int offset
2797:    offset = oNodeGetInt( field, qValue )
2810:    [ equal_zero( offset )
2817:       | false :
2818:          .tPushConstI oEmitInt( offset ) .tAddI
2828:       | * :
2833:    ]
      
         % replace the type on the type stack, with the field type
2833:    oTypeSPop
2834:    oTypeSPush( oNodeGet( field, qType ) )
2848:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2848: PointerDeref:
2850:    [ oTypeSNodeType
2852:       | nPointerType :
2853:       | * :       #eNotPointer
2860:    ]
2860:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2862:    Node theType
2862:    theType = oTypeSTop
2867:    oTypeSPop
2868:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2882:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2882: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2884:    @MatchTypes
2887:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2887: Call( Node method ):
      
2889:    Node paramScope
2889:    paramScope = oNodeGet( method, qParams )
2902:    int actualsSize
2902:    actualsSize = oNodeGetInt( paramScope, qSize )
2915:    .tAllocActuals  oEmitInt( actualsSize )
      
2923:    Node param
2923:    param = oNodeGet( paramScope, qDecls )
2936:    [
2936:       | '(' :
            
2938:          {
2938:             [ oNodeNull( param )
2945:                | true : >
2948:                | * :
2953:             ]
      
2953:             int offset
2953:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
2966:             .tPushAddrActual oEmitInt( offset )
2974:             oTypeSPush( oNodeGet( param, qType ) )
      
2987:             [ oNodeGetBoolean( param, qInOut )
2997:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
2998:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3000:                           @MatchTypes
      
3002:                           .tAssignP
      
3004:                | false :  @Expr
3008:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3010:                           [ oTypeSNodeType
3012:                              | nIntegerType :            .tAssignI
3015:                              | nBooleanType :            .tAssignB
3019:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3023:                              | nPointerType :            .tAssignP
3027:                              | * :
                                       % compound types: copy value into actuals space
3042:                                  int size
3042:                                  size = oNodeGetInt( oTypeSTop, qSize )
3054:                                  .tCopy  oEmitInt( size )    % multi-word copy
3062:                           ]
3062:             ]
3070:             oTypeSPop
      
3071:             oNodeNext( param )
3077:             [ oNodeNull( param )
3084:                | true :  >
3087:                | false :
3089:             ]
      
3097:             ','
3099:          }
      
3101:          ')'
      
3103:       | * :
3108:          [ oNodeNull( param )
3115:             | false :    #eMissingParameter
3118:             | * :
3123:          ]
3123:    ]
      
3123:    .tCall   @EmitValue( method )
      
3132:    [ oNodeType( method )
3139:       | nFunc :
               % TO DO: push return value from actuals space
3140:          oTypeSPush( oNodeGet( method, qType ) )
3153:       | * :
3158:    ]
         
3158:    .tFreeActuals  oEmitInt( actualsSize )
3167:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3167: Statement:
3169:    [
3169:       | pWriteln :     @WritelnStmt
3173:       | pWrite :       @WriteStmt
3177:       | pReadln :      @ReadlnStmt
3181:       | pRead :        @ReadStmt
3185:       | pIf :          @IfStmt
3189:       | pWhile :       @WhileStmt
3193:       | pFor :         @ForStmt
3197:       | pRepeat :      @RepeatStmt
3201:       | pExit :        @ExitStmt
3205:       | pCycle :       @CycleStmt
3209:       | pBegin :       @BeginStmt
3213:       | pIdent :       @AssignOrCallStmt
3217:       | * :            % null statement : don't accept any tokens
3244:    ];
      
      
3245: AssignOrCallStmt:
3247:    Node decl
3247:    decl = oScopeFindRequire
3252:    [ oNodeType( decl )
3259:       | nProc :                           @Call( decl )
3267:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3276:       | * :                               #eBadStatement
3289:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3290: AssignStmt( Node decl ):
      
3292:    @LValueVar( decl )
      
3299:    ':=' 
3301:    @Expr
3303:    @MatchTypes
3305:    [ oTypeSNodeType
3307:       | nIntegerType :            .tAssignI
3310:       | nBooleanType :            .tAssignB
3314:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3318:       | nPointerType :            .tAssignP
3322:       | * :
3337:           int size
3337:           size = oNodeGetInt( oTypeSTop, qSize )
3349:           .tCopy  oEmitInt( size )    % multi-word copy
3357:    ]
3357:    oTypeSPop
3359:    ;
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
3359: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
3361:    pIdent
3363:    Node decl
3363:    decl = oScopeFindRequire
3368:    [ oNodeType( decl )
3375:       | nGlobalVar, nLocalVar, nParam :
3376:       | * :  #eNotVar
3387:    ]
3387:    @LValueVar( decl )
3395:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that stars with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
3395: LValueVar( Node decl ):
3397:    [ oNodeType( decl )
3404:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3414:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3425:       | nParam :
3427:          [ oNodeGetBoolean( decl, qInOut )
3437:             | true :   % VAR param points to variable.  No dereference.
3438:                        .tPushParamP @EmitValue( decl )
3447:             | * :      .tPushAddrParam @EmitValue( decl )
3461:          ]
3461:       | * :            #eNotVar
3472:    ]
      
3472:    oTypeSPush( oNodeGet( decl, qType ) )
3485:    @LValueIndexes        % handle subscripts, if any
3488:    ;
      
      
3488: IfStmt:
3490:    @Expr
3492:    @RequireBoolPop
3494:    pThen
3496:    .tJumpFalse
3498:    oPatchPushHere(patchIf)
3504:    .tSpace
3506:    @Statement
3508:    [
3508:       | pElse :
3510:          .tJump
3512:          oPatchPushHere(patchIf)
3518:          .tSpace
3520:          oPatchSwap(patchIf)
3526:          oPatchPopFwd(patchIf)
3532:          @Statement
3534:       | * :
3539:    ]
3539:    oPatchPopFwd(patchIf);
      
3546: ForStmt:
3548:    pIdent
      
3550:    Node decl
3550:    decl = oScopeFindRequire
3555:    [ oNodeType( decl )
3562:       | nGlobalVar :
3563:       | nLocalVar :    #eNotImplemented
3567:       | nParam :       #eNotImplemented
3571:       | * :            #eNotIntVar
3582:    ]
3582:    oTypeSPush( oNodeGet( decl, qType ) )
3595:    @RequireIntPop
3597:    .tPushConstP  @EmitValue( decl )
      
3606:    ':='
      
3608:    @Expr
3610:    @RequireIntPop
3612:    .tAssignI
      
3614:    .tJump oPatchPushHere(patchLoop) .tSpace
3624:    oPatchPushHere(patchLoop)
3630:    oPatchSwap(patchLoop)
3636:    [
3636:       | pTo :
3638:          .tIncGlobalI @EmitValue( decl )
3647:          oPatchPopFwd(patchLoop)
3653:          .tPushGlobalI @EmitValue( decl )
3662:          @Expr
3664:          @RequireIntPop
3666:          .tGreaterI
3668:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3678:          oPatchSwap(patchLoop)
3684:       | pDownto :
3686:          .tDecGlobalI @EmitValue( decl )
3695:          oPatchPopFwd(patchLoop)
3701:          .tPushGlobalI @EmitValue( decl )
3710:          @Expr
3712:          @RequireIntPop
3714:          .tLessI
3716:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3726:          oPatchSwap(patchLoop)
3732:    ]
3740:    oCountPush(0)          % count 'exit' patches
3746:    pDo
3748:    @Statement
3750:    .tJump oPatchPopBack(patchLoop)
3758:    oPatchPopFwd(patchLoop)
3764:    @PatchExitsPop;
      
3767: RepeatStmt:
3769:    oPatchPushHere(patchLoop) % start of loop
3775:    oCountPush(0)          % count the 'exit' patches
3781:    @Statement
3783:    {[
3783:       | ';' :
3785:          @Statement
3787:       | pUntil :
3789:          @Expr
3791:          @RequireBoolPop
3793:          .tJumpFalse
3795:          oPatchPopBack(patchLoop)
3801:          @PatchExitsPop
3803:          >
3805:    ]};
      
3816: WhileStmt:
3818:    oPatchPushHere(patchLoop)    % start of loop
3824:    oCountPush(0)
3830:    @Expr
3832:    @RequireBoolPop
3834:    pDo
3836:    .tJumpFalse
3838:    oPatchPushHere(patchLoop)    % jump out
3844:    .tSpace
3846:    oPatchSwap(patchLoop)        % start on top
3852:    @Statement
3854:    .tJump
3856:    oPatchPopBack(patchLoop)
3862:    oPatchPopFwd(patchLoop)
3868:    @PatchExitsPop;
      
3871: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
3873:    [ oPatchAnyEntries(patchLoop)
3880:       | true :
3881:          .tJump
3883:          oPatchDup(patchLoop)  % addr of start
3889:          oPatchPopBack(patchLoop)
3895:       | * :
3900:          #eNotInALoop
3902:    ];
      
3903: ExitStmt:
3905:    [ oPatchAnyEntries(patchLoop)
3912:       | true :
3913:          .tJump
3915:          oPatchPushHere(patchExit)
3921:          .tSpace
3923:          oCountInc
3924:       | * :
3929:          #eNotInALoop
3931:    ];
      
3932: BeginStmt:
3934:    @Statement
3936:    {[
3936:       | ';' :   @Statement
3940:       | pEnd :  >
3944:    ]};
      
3955: WritelnStmt:
3957:    @WriteStmt
3959:    .tWriteCR;
      
3962: WriteStmt:
3964:    [
3964:       | '(' :
3966:          {
3966:             @Expr
3968:             [ oTypeSNodeType
3970:                | nIntegerType :             .tWriteI
3973:                | nBooleanType :             .tWriteBool
3977:                | nStringType :              .tWriteStr
3981:                | nCharType, nFileType :     #eNotImplemented
3985:                | nPointerType :             .tWriteP
3989:                | * :                        #eNotAllowed
4006:             ]
4006:             oTypeSPop
4007:             [
4007:                | ')' : >
4011:                | ',' :
4013:             ]
4021:          }
4023:       | * :
4028:    ];
      
      
4029: ReadlnStmt:      % ***
4032:    ;
4032: ReadStmt:
4035:    ;
      
      % -------------------------------- Utilities -------------------------------
      
4035: PatchExitsPop:
4037:    {[ oCountIsZero
4039:       | false : oPatchPopFwd(patchExit)
4046:                 oCountDec
4047:       | * :     >
4054:    ]}
4056:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4058: MatchTypes:
4060:    node_type nt
4060:    nt = oTypeSNodeType
4065:    oTypeSPop
4066:    [ equal_node_type( nt, oTypeSNodeType )
4075:       | false :
4076:          #eTypeMismatch
4078:       | * :
4083:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
4084: RequireIntPop:
4086:    [ oTypeSNodeType
4088:       | nIntegerType :
4089:       | * :          #eNotInteger
4096:    ]
4096:    oTypeSPop;
      
4098: RequireInt:
4100:    [ oTypeSNodeType
4102:       | nIntegerType :
4103:       | * :          #eNotInteger
4110:    ];
      
4111: RequireBoolPop:
4113:    [ oTypeSNodeType
4115:       | nBooleanType :
4116:       | * :          #eNotBoolean
4123:    ]
4123:    oTypeSPop;
      
4125: RequireBool:
4127:    [ oTypeSNodeType
4129:       | nBooleanType :
4130:       | * :          #eNotBoolean
4137:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
4138: newType( node_type nt, int size ) >> Node:
4140:   Node node
4140:   node = oNodeNew( nt )
4150:   oNodeSetInt( node, qSize, size )
4162:   oTypeAdd( node )
4168:   >> node
4172:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
4172: newIdent( node_type nt, kind k, int id ) >> Node:
4174:   Node t
4174:   t = oNodeNew( nt )
4184:   oNodeSetKind( t, qKind, k )   % deprecated attribute
4196:   oNodeSetInt( t, qIdent, id )
4208:   >> t
4212:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
4212: PointerTypeTo( Node theType ) >> Node:
4214:    Node ptrType
4214:    ptrType = oNodeGet( theType, qPointerType )
4227:    [ oNodeNull( ptrType )
4234:       | true :
4235:          ptrType = oNodeNew( nPointerType )
4245:          oNodeSet( ptrType, qBaseType, theType )
4257:          oNodeSetInt( ptrType, qSize, 8 )
4269:          oTypeAdd( ptrType )
4275:          oNodeSet( theType, qPointerType, ptrType )
4287:       | * :
4292:    ]
4292:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4296: OrdinalLow( Node theType ) >> int:
4298:    [ oNodeType( theType )
4305:       | nIntegerType :  >> -2147483648
4309:       | nBooleanType :  >> 0
4314:       | nCharType :     >> 0
4319:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4331:       | * :             #eNotOrdinalType
4344:                         >> 0
4347:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4348: EmitValue( Node decl ):
4350:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4364: installBuiltIns:
      
         % install built-in types
4366:    FileType = @newType( nFileType, 4 )
4380:    IntegerType = @newType( nIntegerType, 4 )
4394:    BooleanType = @newType( nBooleanType, 1 )
4408:    CharType = @newType( nCharType, 1 )
4422:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4436:    Node t
      
4436:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4452:    oNodeSet( t, qType, FileType )
4464:    oScopeDeclare( t )
      
4470:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4486:    oNodeSet( t, qType, IntegerType )
4498:    oScopeDeclare( t )
      
4504:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4520:    oNodeSet( t, qType, BooleanType )
4532:    oScopeDeclare( t )
      
4538:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4554:    oNodeSet( t, qType, CharType )
4566:    oScopeDeclare( t )
      
4572:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4588:    oNodeSet( t, qType, StringType )
4600:    oScopeDeclare( t )
      
         % Built-in constants
      
4606:    t = @newIdent( nConst, kConst, oIdAdd_True )
4622:    oNodeSet( t, qType, BooleanType )
4634:    oNodeSetInt( t, qValue, 1 )
4646:    oScopeDeclare( t )
      
4652:    t = @newIdent( nConst, kConst, oIdAdd_False )
4668:    oNodeSet( t, qType, BooleanType )
4680:    oNodeSetInt( t, qValue, 0 )
4692:    oScopeDeclare( t )
      
4699:    ;
      
4699: end
      
4699: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4364
  12: oEmit 45
  14: oGetAddrLocal 2
  16: oPushResult
  17: Here
  18: oAssign
  19: oEmit 53
  21: oInput 26
  23: oInput 0
  25: oGetAddrLocal 1
  27: oPushResult
  28: oSetResult 5
  30: oPushResult
  31: oSetResult 1
  33: oPushResult
  34: LAST_ID
  35: oPushResult
  36: oCall 4172
  38: oPop 3
  40: oAssign
  41: oGetLocal 1
  43: oPushResult
  44: oScopeDeclare
  45: oPop 1
  47: oInputChoice 127
  49: oInput 0
  51: oGetAddrLocal 1
  53: oPushResult
  54: oSetResult 11
  56: oPushResult
  57: oSetResult 6
  59: oPushResult
  60: LAST_ID
  61: oPushResult
  62: oCall 4172
  64: oPop 3
  66: oAssign
  67: oGetLocal 1
  69: oPushResult
  70: oSetResult 6
  72: oPushResult
  73: oGetGlobal 2
  75: oPushResult
  76: oNodeSet
  77: oPop 3
  79: oGetLocal 1
  81: oPushResult
  82: oScopeDeclareAlloc
  83: oPop 1
  85: oInput 12
  87: oInput 0
  89: oGetAddrLocal 1
  91: oPushResult
  92: oSetResult 11
  94: oPushResult
  95: oSetResult 6
  97: oPushResult
  98: LAST_ID
  99: oPushResult
 100: oCall 4172
 102: oPop 3
 104: oAssign
 105: oGetLocal 1
 107: oPushResult
 108: oSetResult 6
 110: oPushResult
 111: oGetGlobal 2
 113: oPushResult
 114: oNodeSet
 115: oPop 3
 117: oGetLocal 1
 119: oPushResult
 120: oScopeDeclareAlloc
 121: oPop 1
 123: oInput 14
 125: oJumpForward 130
 127: Choice Lookup Table
          13     49
 130: oInput 4
 132: oSetResult 12
 134: oPushResult
 135: oGetAddrLocal 3
 137: oPushResult
 138: oCall 155
 140: oPop 2
 142: oGetLocal 2
 144: oPushResult
 145: oGetLocal 3
 147: oPushResult
 148: oPatch
 149: oPop 2
 151: oInput 18
 153: oScopeEnd
 154: oReturn
 155: oLocalSpace 2
 157: oInputChoice 184
 159: oCall 753
 161: oJumpForward 197
 163: oCall 825
 165: oJumpForward 197
 167: oGetParam 2
 169: oPushResult
 170: oCall 884
 172: oPop 1
 174: oJumpForward 197
 176: oCall 271
 178: oJumpForward 197
 180: oCall 388
 182: oJumpForward 197
 184: Choice Lookup Table
          28    180
          27    176
          31    167
          30    163
          29    159
 195: oJumpForward 199
 197: oJumpBack 157
 199: oGetParam 1
 201: oPushResult
 202: Here
 203: oAssign
 204: oGetParam 2
 206: oPushResult
 207: oSetResult 13
 209: oPushResult
 210: equal_node_type
 211: oPop 2
 213: oChoice 226
 215: oEmit 44
 217: oGetAddrLocal 1
 219: oPushResult
 220: Here
 221: oAssign
 222: oEmit 53
 224: oJumpForward 229
 226: Choice Lookup Table
           1    215
 229: oCall 3167
 231: oEmit 43
 233: oGetParam 2
 235: oPushResult
 236: oSetResult 13
 238: oPushResult
 239: equal_node_type
 240: oPop 2
 242: oChoice 267
 244: oGetAddrLocal 2
 246: oPushResult
 247: oScopeCurrent
 248: oPushResult
 249: oSetResult 2
 251: oPushResult
 252: oNodeGetInt
 253: oPop 2
 255: oAssign
 256: oGetLocal 1
 258: oPushResult
 259: oGetLocal 2
 261: oPushResult
 262: oPatch
 263: oPop 2
 265: oJumpForward 270
 267: Choice Lookup Table
           1    244
 270: oReturn
 271: oLocalSpace 3
 273: oInput 0
 275: oGetAddrLocal 1
 277: oPushResult
 278: oSetResult 7
 280: oPushResult
 281: oSetResult 2
 283: oPushResult
 284: LAST_ID
 285: oPushResult
 286: oCall 4172
 288: oPop 3
 290: oAssign
 291: oScopeBegin
 292: oGetAddrLocal 2
 294: oPushResult
 295: oScopeCurrent
 296: oAssign
 297: oCall 526
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 9
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oScopeEnd
 312: oGetLocal 1
 314: oPushResult
 315: oScopeDeclare
 316: oPop 1
 318: oInput 4
 320: oGetLocal 2
 322: oPushResult
 323: oScopeEnter
 324: oPop 1
 326: oScopeBegin
 327: oScopeCurrent
 328: oPushResult
 329: oSetResult 3
 331: oPushResult
 332: oSetResult 1
 334: oPushResult
 335: oNodeSetBoolean
 336: oPop 3
 338: oSetResult 13
 340: oPushResult
 341: oGetAddrLocal 3
 343: oPushResult
 344: oCall 155
 346: oPop 2
 348: oGetLocal 1
 350: oPushResult
 351: oSetResult 10
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oNodeSet
 357: oPop 3
 359: oGetLocal 1
 361: oPushResult
 362: oSetResult 8
 364: oPushResult
 365: oGetLocal 3
 367: oPushResult
 368: oNodeSetInt
 369: oPop 3
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 11
 376: oPushResult
 377: oSetResult 1
 379: oPushResult
 380: oNodeSetBoolean
 381: oPop 3
 383: oScopeEnd
 384: oScopeEnd
 385: oInput 4
 387: oReturn
 388: oLocalSpace 4
 390: oInput 0
 392: oGetAddrLocal 1
 394: oPushResult
 395: oSetResult 8
 397: oPushResult
 398: oSetResult 3
 400: oPushResult
 401: LAST_ID
 402: oPushResult
 403: oCall 4172
 405: oPop 3
 407: oAssign
 408: oScopeBegin
 409: oGetAddrLocal 3
 411: oPushResult
 412: oScopeCurrent
 413: oAssign
 414: oCall 526
 416: oGetLocal 1
 418: oPushResult
 419: oSetResult 9
 421: oPushResult
 422: oGetLocal 3
 424: oPushResult
 425: oNodeSet
 426: oPop 3
 428: oScopeEnd
 429: oGetLocal 1
 431: oPushResult
 432: oScopeDeclare
 433: oPop 1
 435: oInput 11
 437: oGetAddrLocal 2
 439: oPushResult
 440: oCall 1025
 442: oPop 1
 444: oGetLocal 1
 446: oPushResult
 447: oSetResult 6
 449: oPushResult
 450: oGetLocal 2
 452: oPushResult
 453: oNodeSet
 454: oPop 3
 456: oInput 4
 458: oGetLocal 3
 460: oPushResult
 461: oScopeEnter
 462: oPop 1
 464: oScopeBegin
 465: oScopeCurrent
 466: oPushResult
 467: oSetResult 3
 469: oPushResult
 470: oSetResult 1
 472: oPushResult
 473: oNodeSetBoolean
 474: oPop 3
 476: oSetResult 13
 478: oPushResult
 479: oGetAddrLocal 4
 481: oPushResult
 482: oCall 155
 484: oPop 2
 486: oGetLocal 1
 488: oPushResult
 489: oSetResult 10
 491: oPushResult
 492: oScopeCurrent
 493: oPushResult
 494: oNodeSet
 495: oPop 3
 497: oGetLocal 1
 499: oPushResult
 500: oSetResult 8
 502: oPushResult
 503: oGetLocal 4
 505: oPushResult
 506: oNodeSetInt
 507: oPop 3
 509: oGetLocal 1
 511: oPushResult
 512: oSetResult 11
 514: oPushResult
 515: oSetResult 1
 517: oPushResult
 518: oNodeSetBoolean
 519: oPop 3
 521: oScopeEnd
 522: oScopeEnd
 523: oInput 4
 525: oReturn
 526: oLocalSpace 6
 528: oInputChoice 749
 530: oGetAddrLocal 1
 532: oPushResult
 533: oNodeVecNew
 534: oAssign
 535: oGetAddrLocal 3
 537: oPushResult
 538: oSetResult 0
 540: oAssign
 541: oInputChoice 551
 543: oGetAddrLocal 3
 545: oPushResult
 546: oSetResult 1
 548: oAssign
 549: oJumpForward 554
 551: Choice Lookup Table
          31    543
 554: oInput 0
 556: oGetAddrLocal 2
 558: oPushResult
 559: oSetResult 15
 561: oPushResult
 562: oSetResult 6
 564: oPushResult
 565: LAST_ID
 566: oPushResult
 567: oCall 4172
 569: oPop 3
 571: oAssign
 572: oGetLocal 2
 574: oPushResult
 575: oSetResult 12
 577: oPushResult
 578: oGetLocal 3
 580: oPushResult
 581: oNodeSetBoolean
 582: oPop 3
 584: oGetLocal 1
 586: oPushResult
 587: oGetLocal 2
 589: oPushResult
 590: oNodeVecAppend
 591: oPop 2
 593: oInputChoice 601
 595: oJumpForward 609
 597: oJumpForward 607
 599: oJumpForward 607
 601: Choice Lookup Table
          12    599
          11    595
 606: oEndChoice
 607: oJumpBack 554
 609: oGetAddrLocal 4
 611: oPushResult
 612: oCall 1025
 614: oPop 1
 616: oGetLocal 3
 618: oChoice 633
 620: oGetAddrLocal 5
 622: oPushResult
 623: oGetLocal 4
 625: oPushResult
 626: oCall 4212
 628: oPop 1
 630: oAssign
 631: oJumpForward 642
 633: Choice Lookup Table
           1    620
 636: oGetAddrLocal 5
 638: oPushResult
 639: oGetLocal 4
 641: oAssign
 642: oGetAddrLocal 6
 644: oPushResult
 645: oSetResult 0
 647: oAssign
 648: oGetLocal 6
 650: oPushResult
 651: oGetLocal 1
 653: oPushResult
 654: oNodeVecSize
 655: oPop 1
 657: oPushResult
 658: equal
 659: oPop 2
 661: oChoice 718
 663: oGetAddrLocal 2
 665: oPushResult
 666: oGetLocal 1
 668: oPushResult
 669: oGetLocal 6
 671: oPushResult
 672: oNodeVecElement
 673: oPop 2
 675: oAssign
 676: oGetLocal 2
 678: oPushResult
 679: oSetResult 6
 681: oPushResult
 682: oGetLocal 4
 684: oPushResult
 685: oNodeSet
 686: oPop 3
 688: oGetLocal 2
 690: oPushResult
 691: oScopeDeclare
 692: oPop 1
 694: oGetLocal 2
 696: oPushResult
 697: oSetResult 8
 699: oPushResult
 700: oGetLocal 5
 702: oPushResult
 703: oScopeAllocType
 704: oPop 1
 706: oPushResult
 707: oNodeSetInt
 708: oPop 3
 710: oGetAddrLocal 6
 712: oPushResult
 713: inc
 714: oPop 1
 716: oJumpForward 723
 718: Choice Lookup Table
           0    663
 721: oJumpForward 725
 723: oJumpBack 648
 725: oGetLocal 1
 727: oPushResult
 728: oNodeVecDelete
 729: oPop 1
 731: oInputChoice 739
 733: oJumpForward 747
 735: oJumpForward 745
 737: oJumpForward 745
 739: Choice Lookup Table
           4    737
          14    733
 744: oEndChoice
 745: oJumpBack 530
 747: oJumpForward 752
 749: Choice Lookup Table
          13    530
 752: oReturn
 753: oLocalSpace 2
 755: oInputChoice 817
 757: oGetAddrLocal 1
 759: oPushResult
 760: oSetResult 9
 762: oPushResult
 763: oSetResult 4
 765: oPushResult
 766: LAST_ID
 767: oPushResult
 768: oCall 4172
 770: oPop 3
 772: oAssign
 773: oInput 5
 775: oCall 1494
 777: oGetAddrLocal 2
 779: oPushResult
 780: oValueTop
 781: oAssign
 782: oValuePop
 783: oGetLocal 1
 785: oPushResult
 786: oSetResult 8
 788: oPushResult
 789: oGetLocal 2
 791: oPushResult
 792: oNodeSetInt
 793: oPop 3
 795: oGetLocal 1
 797: oPushResult
 798: oSetResult 6
 800: oPushResult
 801: oGetGlobal 3
 803: oPushResult
 804: oNodeSet
 805: oPop 3
 807: oGetLocal 1
 809: oPushResult
 810: oScopeDeclare
 811: oPop 1
 813: oInput 4
 815: oJumpForward 822
 817: Choice Lookup Table
           0    757
 820: oJumpForward 824
 822: oJumpBack 755
 824: oReturn
 825: oLocalSpace 2
 827: oInputChoice 876
 829: oGetAddrLocal 1
 831: oPushResult
 832: oSetResult 10
 834: oPushResult
 835: oSetResult 5
 837: oPushResult
 838: LAST_ID
 839: oPushResult
 840: oCall 4172
 842: oPop 3
 844: oAssign
 845: oInput 5
 847: oGetAddrLocal 2
 849: oPushResult
 850: oCall 1025
 852: oPop 1
 854: oGetLocal 1
 856: oPushResult
 857: oSetResult 6
 859: oPushResult
 860: oGetLocal 2
 862: oPushResult
 863: oNodeSet
 864: oPop 3
 866: oGetLocal 1
 868: oPushResult
 869: oScopeDeclare
 870: oPop 1
 872: oInput 4
 874: oJumpForward 881
 876: Choice Lookup Table
           0    829
 879: oJumpForward 883
 881: oJumpBack 827
 883: oReturn
 884: oLocalSpace 4
 886: oInputChoice 1017
 888: oGetAddrLocal 1
 890: oPushResult
 891: oNodeVecNew
 892: oAssign
 893: oGetAddrLocal 2
 895: oPushResult
 896: oGetParam 1
 898: oPushResult
 899: oSetResult 6
 901: oPushResult
 902: LAST_ID
 903: oPushResult
 904: oCall 4172
 906: oPop 3
 908: oAssign
 909: oGetLocal 1
 911: oPushResult
 912: oGetLocal 2
 914: oPushResult
 915: oNodeVecAppend
 916: oPop 2
 918: oInputChoice 924
 920: oInput 0
 922: oJumpForward 929
 924: Choice Lookup Table
          12    920
 927: oJumpForward 931
 929: oJumpBack 893
 931: oInput 11
 933: oGetAddrLocal 3
 935: oPushResult
 936: oCall 1025
 938: oPop 1
 940: oGetAddrLocal 4
 942: oPushResult
 943: oSetResult 0
 945: oAssign
 946: oGetLocal 4
 948: oPushResult
 949: oGetLocal 1
 951: oPushResult
 952: oNodeVecSize
 953: oPop 1
 955: oPushResult
 956: equal
 957: oPop 2
 959: oChoice 1000
 961: oGetAddrLocal 2
 963: oPushResult
 964: oGetLocal 1
 966: oPushResult
 967: oGetLocal 4
 969: oPushResult
 970: oNodeVecElement
 971: oPop 2
 973: oAssign
 974: oGetLocal 2
 976: oPushResult
 977: oSetResult 6
 979: oPushResult
 980: oGetLocal 3
 982: oPushResult
 983: oNodeSet
 984: oPop 3
 986: oGetLocal 2
 988: oPushResult
 989: oScopeDeclareAlloc
 990: oPop 1
 992: oGetAddrLocal 4
 994: oPushResult
 995: inc
 996: oPop 1
 998: oJumpForward 1005
1000: Choice Lookup Table
           0    961
1003: oJumpForward 1007
1005: oJumpBack 946
1007: oGetLocal 1
1009: oPushResult
1010: oNodeVecDelete
1011: oPop 1
1013: oInput 4
1015: oJumpForward 1022
1017: Choice Lookup Table
           0    888
1020: oJumpForward 1024
1022: oJumpBack 886
1024: oReturn
1025: oLocalSpace 12
1027: oInputChoice 1476
1029: oGetAddrLocal 1
1031: oPushResult
1032: oScopeFindRequire
1033: oAssign
1034: oGetLocal 1
1036: oPushResult
1037: oNodeType
1038: oPop 1
1040: oChoice 1057
1042: oGetParam 1
1044: oPushResult
1045: oGetLocal 1
1047: oPushResult
1048: oSetResult 6
1050: oPushResult
1051: oNodeGet
1052: oPop 2
1054: oAssign
1055: oJumpForward 1068
1057: Choice Lookup Table
          10   1042
1060: oError 2
1062: oGetParam 1
1064: oPushResult
1065: oGetGlobal 3
1067: oAssign
1068: oJumpForward 1493
1070: oInput 15
1072: oGetAddrLocal 2
1074: oPushResult
1075: oNodeVecNew
1076: oAssign
1077: oGetAddrLocal 3
1079: oPushResult
1080: oSetResult 24
1082: oPushResult
1083: oNodeNew
1084: oPop 1
1086: oAssign
1087: oGetLocal 3
1089: oPushResult
1090: oSetResult 14
1092: oPushResult
1093: oGetGlobal 3
1095: oPushResult
1096: oNodeSet
1097: oPop 3
1099: oCall 1494
1101: oGetLocal 3
1103: oPushResult
1104: oSetResult 16
1106: oPushResult
1107: oValueTop
1108: oPushResult
1109: oNodeSetInt
1110: oPop 3
1112: oValuePop
1113: oInput 19
1115: oCall 1494
1117: oGetLocal 3
1119: oPushResult
1120: oSetResult 17
1122: oPushResult
1123: oValueTop
1124: oPushResult
1125: oNodeSetInt
1126: oPop 3
1128: oValuePop
1129: oGetLocal 3
1131: oPushResult
1132: oSetResult 2
1134: oPushResult
1135: oSetResult 4
1137: oPushResult
1138: oNodeSetInt
1139: oPop 3
1141: oGetLocal 3
1143: oPushResult
1144: oTypeAdd
1145: oPop 1
1147: oGetAddrLocal 4
1149: oPushResult
1150: oSetResult 23
1152: oPushResult
1153: oNodeNew
1154: oPop 1
1156: oAssign
1157: oGetLocal 4
1159: oPushResult
1160: oSetResult 15
1162: oPushResult
1163: oGetLocal 3
1165: oPushResult
1166: oNodeSet
1167: oPop 3
1169: oGetLocal 2
1171: oPushResult
1172: oGetLocal 4
1174: oPushResult
1175: oNodeVecAppend
1176: oPop 2
1178: oInputChoice 1186
1180: oJumpForward 1194
1182: oJumpForward 1192
1184: oJumpForward 1192
1186: Choice Lookup Table
          12   1184
          16   1180
1191: oEndChoice
1192: oJumpBack 1077
1194: oInput 37
1196: oGetAddrLocal 5
1198: oPushResult
1199: oCall 1025
1201: oPop 1
1203: oGetAddrLocal 6
1205: oPushResult
1206: oGetLocal 2
1208: oPushResult
1209: oNodeVecSize
1210: oPop 1
1212: oAssign
1213: oGetAddrLocal 6
1215: oPushResult
1216: dec
1217: oPop 1
1219: oGetAddrLocal 4
1221: oPushResult
1222: oGetLocal 2
1224: oPushResult
1225: oGetLocal 6
1227: oPushResult
1228: oNodeVecElement
1229: oPop 2
1231: oAssign
1232: oGetLocal 4
1234: oPushResult
1235: oSetResult 14
1237: oPushResult
1238: oGetLocal 5
1240: oPushResult
1241: oNodeSet
1242: oPop 3
1244: oGetAddrLocal 3
1246: oPushResult
1247: oGetLocal 4
1249: oPushResult
1250: oSetResult 15
1252: oPushResult
1253: oNodeGet
1254: oPop 2
1256: oAssign
1257: oGetAddrLocal 9
1259: oPushResult
1260: oGetLocal 3
1262: oPushResult
1263: oSetResult 17
1265: oPushResult
1266: oNodeGetInt
1267: oPop 2
1269: oPushResult
1270: oGetLocal 3
1272: oPushResult
1273: oSetResult 16
1275: oPushResult
1276: oNodeGetInt
1277: oPop 2
1279: oPushResult
1280: subtract
1281: oPop 2
1283: oAssign
1284: oGetAddrLocal 9
1286: oPushResult
1287: inc
1288: oPop 1
1290: oGetLocal 4
1292: oPushResult
1293: oSetResult 2
1295: oPushResult
1296: oGetLocal 9
1298: oPushResult
1299: oGetLocal 5
1301: oPushResult
1302: oSetResult 2
1304: oPushResult
1305: oNodeGetInt
1306: oPop 2
1308: oPushResult
1309: multiply
1310: oPop 2
1312: oPushResult
1313: oNodeSetInt
1314: oPop 3
1316: oGetLocal 4
1318: oPushResult
1319: oTypeAdd
1320: oPop 1
1322: oGetAddrLocal 5
1324: oPushResult
1325: oGetLocal 4
1327: oAssign
1328: oGetLocal 6
1330: oPushResult
1331: equal_zero
1332: oPop 1
1334: oChoice 1340
1336: oJumpForward 1345
1338: oJumpForward 1343
1340: Choice Lookup Table
           1   1336
1343: oJumpBack 1213
1345: oGetParam 1
1347: oPushResult
1348: oGetLocal 2
1350: oPushResult
1351: oSetResult 0
1353: oPushResult
1354: oNodeVecElement
1355: oPop 2
1357: oAssign
1358: oGetLocal 2
1360: oPushResult
1361: oNodeVecDelete
1362: oPop 1
1364: oJumpForward 1493
1366: oGetAddrLocal 10
1368: oPushResult
1369: oCall 1025
1371: oPop 1
1373: oGetParam 1
1375: oPushResult
1376: oGetLocal 10
1378: oPushResult
1379: oCall 4212
1381: oPop 1
1383: oAssign
1384: oJumpForward 1493
1386: oGetParam 1
1388: oPushResult
1389: oSetResult 25
1391: oPushResult
1392: oNodeNew
1393: oPop 1
1395: oAssign
1396: oScopeBegin
1397: oSetResult 14
1399: oPushResult
1400: oCall 884
1402: oPop 1
1404: oGetAddrLocal 11
1406: oPushResult
1407: oScopeCurrent
1408: oPushResult
1409: oSetResult 2
1411: oPushResult
1412: oNodeGetInt
1413: oPop 2
1415: oAssign
1416: oGetLocal 11
1418: oPushResult
1419: equal_zero
1420: oPop 1
1422: oChoice 1428
1424: oError 19
1426: oJumpForward 1431
1428: Choice Lookup Table
           1   1424
1431: oInput 33
1433: oGetFromParam 1
1435: oPushResult
1436: oSetResult 18
1438: oPushResult
1439: oScopeCurrent
1440: oPushResult
1441: oNodeSet
1442: oPop 3
1444: oGetFromParam 1
1446: oPushResult
1447: oSetResult 2
1449: oPushResult
1450: oGetLocal 11
1452: oPushResult
1453: oNodeSetInt
1454: oPop 3
1456: oScopeEnd
1457: oGetFromParam 1
1459: oPushResult
1460: oTypeAdd
1461: oPop 1
1463: oJumpForward 1493
1465: oInput 37
1467: oGetAddrLocal 10
1469: oPushResult
1470: oCall 1025
1472: oPop 1
1474: oJumpForward 1493
1476: Choice Lookup Table
          36   1465
          35   1386
          17   1366
          34   1070
           0   1029
1487: oCall 1494
1489: oInput 19
1491: oCall 1494
1493: oReturn
1494: oLocalSpace 1
1496: oInputChoice 1551
1498: TOKEN_VALUE
1499: oPushResult
1500: oValuePush
1501: oPop 1
1503: oJumpForward 1559
1505: oGetAddrLocal 1
1507: oPushResult
1508: oScopeFindRequire
1509: oAssign
1510: oGetLocal 1
1512: oPushResult
1513: oNodeType
1514: oPop 1
1516: oChoice 1533
1518: oGetLocal 1
1520: oPushResult
1521: oSetResult 8
1523: oPushResult
1524: oNodeGetInt
1525: oPop 2
1527: oPushResult
1528: oValuePush
1529: oPop 1
1531: oJumpForward 1544
1533: Choice Lookup Table
           9   1518
1536: oError 1
1538: oSetResult 0
1540: oPushResult
1541: oValuePush
1542: oPop 1
1544: oJumpForward 1559
1546: oCall 1494
1548: oValueNegate
1549: oJumpForward 1559
1551: Choice Lookup Table
          23   1546
           0   1505
           1   1498
1558: oEndChoice
1559: oReturn
1560: oLocalSpace 0
1562: oCall 1806
1564: oInputChoice 1788
1566: oCall 1806
1568: oCall 4058
1570: oTypeSNodeType
1571: oChoice 1585
1573: oEmit 32
1575: oJumpForward 1598
1577: oEmit 38
1579: oJumpForward 1598
1581: oError 16
1583: oJumpForward 1598
1585: Choice Lookup Table
          21   1581
          20   1581
          22   1577
          19   1573
          18   1573
1596: oError 17
1598: oTypeSPop
1599: oGetGlobal 4
1601: oPushResult
1602: oTypeSPush
1603: oPop 1
1605: oJumpForward 1803
1607: oCall 1806
1609: oCall 4058
1611: oTypeSNodeType
1612: oChoice 1626
1614: oEmit 33
1616: oJumpForward 1639
1618: oEmit 39
1620: oJumpForward 1639
1622: oError 16
1624: oJumpForward 1639
1626: Choice Lookup Table
          21   1622
          20   1622
          22   1618
          19   1614
          18   1614
1637: oError 17
1639: oTypeSPop
1640: oGetGlobal 4
1642: oPushResult
1643: oTypeSPush
1644: oPop 1
1646: oJumpForward 1803
1648: oCall 1806
1650: oCall 4058
1652: oTypeSNodeType
1653: oChoice 1663
1655: oEmit 35
1657: oJumpForward 1674
1659: oError 16
1661: oJumpForward 1674
1663: Choice Lookup Table
          21   1659
          20   1659
          19   1655
          18   1655
1672: oError 17
1674: oTypeSPop
1675: oGetGlobal 4
1677: oPushResult
1678: oTypeSPush
1679: oPop 1
1681: oJumpForward 1803
1683: oCall 1806
1685: oCall 4058
1687: oTypeSNodeType
1688: oChoice 1698
1690: oEmit 34
1692: oJumpForward 1709
1694: oError 16
1696: oJumpForward 1709
1698: Choice Lookup Table
          21   1694
          20   1694
          19   1690
          18   1690
1707: oError 17
1709: oTypeSPop
1710: oGetGlobal 4
1712: oPushResult
1713: oTypeSPush
1714: oPop 1
1716: oJumpForward 1803
1718: oCall 1806
1720: oCall 4058
1722: oTypeSNodeType
1723: oChoice 1733
1725: oEmit 37
1727: oJumpForward 1744
1729: oError 16
1731: oJumpForward 1744
1733: Choice Lookup Table
          21   1729
          20   1729
          19   1725
          18   1725
1742: oError 17
1744: oTypeSPop
1745: oGetGlobal 4
1747: oPushResult
1748: oTypeSPush
1749: oPop 1
1751: oJumpForward 1803
1753: oCall 1806
1755: oCall 4058
1757: oTypeSNodeType
1758: oChoice 1768
1760: oEmit 36
1762: oJumpForward 1779
1764: oError 16
1766: oJumpForward 1779
1768: Choice Lookup Table
          21   1764
          20   1764
          19   1760
          18   1760
1777: oError 17
1779: oTypeSPop
1780: oGetGlobal 4
1782: oPushResult
1783: oTypeSPush
1784: oPop 1
1786: oJumpForward 1803
1788: Choice Lookup Table
          10   1753
           9   1718
           8   1683
           7   1648
           6   1607
           5   1566
1801: oJumpForward 1805
1803: oJumpBack 1564
1805: oReturn
1806: oLocalSpace 0
1808: oCall 1830
1810: oInputChoice 1822
1812: oCall 4111
1814: oCall 1830
1816: oCall 4125
1818: oEmit 31
1820: oJumpForward 1827
1822: Choice Lookup Table
          52   1812
1825: oJumpForward 1829
1827: oJumpBack 1810
1829: oReturn
1830: oLocalSpace 0
1832: oCall 1854
1834: oInputChoice 1846
1836: oCall 4111
1838: oCall 1854
1840: oCall 4125
1842: oEmit 30
1844: oJumpForward 1851
1846: Choice Lookup Table
          51   1836
1849: oJumpForward 1853
1851: oJumpBack 1834
1853: oReturn
1854: oLocalSpace 0
1856: oInputChoice 1866
1858: oCall 1872
1860: oCall 4125
1862: oEmit 29
1864: oJumpForward 1871
1866: Choice Lookup Table
          53   1858
1869: oCall 1872
1871: oReturn
1872: oLocalSpace 0
1874: oCall 1908
1876: oInputChoice 1898
1878: oCall 4084
1880: oCall 1908
1882: oCall 4098
1884: oEmit 26
1886: oJumpForward 1905
1888: oCall 4084
1890: oCall 1908
1892: oCall 4098
1894: oEmit 27
1896: oJumpForward 1905
1898: Choice Lookup Table
          23   1888
          22   1878
1903: oJumpForward 1907
1905: oJumpBack 1876
1907: oReturn
1908: oLocalSpace 0
1910: oCall 1944
1912: oInputChoice 1934
1914: oCall 4084
1916: oCall 1944
1918: oCall 4098
1920: oEmit 24
1922: oJumpForward 1941
1924: oCall 4084
1926: oCall 1944
1928: oCall 4098
1930: oEmit 25
1932: oJumpForward 1941
1934: Choice Lookup Table
          21   1924
          20   1914
1939: oJumpForward 1943
1941: oJumpBack 1912
1943: oReturn
1944: oLocalSpace 0
1946: oInputChoice 1962
1948: oCall 1970
1950: oCall 4098
1952: oJumpForward 1969
1954: oCall 1970
1956: oCall 4098
1958: oEmit 28
1960: oJumpForward 1969
1962: Choice Lookup Table
          23   1954
          22   1948
1967: oCall 1970
1969: oReturn
1970: oLocalSpace 5
1972: oInputChoice 2145
1974: oEmit 9
1976: TOKEN_VALUE
1977: oPushResult
1978: oEmitInt
1979: oPop 1
1981: oGetGlobal 3
1983: oPushResult
1984: oTypeSPush
1985: oPop 1
1987: oJumpForward 2164
1989: oCall 1560
1991: oInput 14
1993: oJumpForward 2164
1995: oStringAllocLit
1996: oEmit 10
1998: oValueTop
1999: oPushResult
2000: oEmitInt
2001: oPop 1
2003: oValuePop
2004: oGetGlobal 6
2006: oPushResult
2007: oTypeSPush
2008: oPop 1
2010: oJumpForward 2164
2012: oGetAddrLocal 1
2014: oPushResult
2015: oScopeFindRequire
2016: oAssign
2017: oGetLocal 1
2019: oPushResult
2020: oNodeType
2021: oPop 1
2023: oChoice 2085
2025: oGetLocal 1
2027: oPushResult
2028: oCall 2887
2030: oPop 1
2032: oJumpForward 2104
2034: oGetAddrLocal 2
2036: oPushResult
2037: oGetLocal 1
2039: oPushResult
2040: oSetResult 6
2042: oPushResult
2043: oNodeGet
2044: oPop 2
2046: oAssign
2047: oGetLocal 2
2049: oPushResult
2050: oTypeSPush
2051: oPop 1
2053: oTypeSNodeType
2054: oChoice 2067
2056: oEmit 9
2058: oGetLocal 1
2060: oPushResult
2061: oCall 4348
2063: oPop 1
2065: oJumpForward 2074
2067: Choice Lookup Table
          19   2056
          18   2056
2072: oError 16
2074: oJumpForward 2104
2076: oGetLocal 1
2078: oPushResult
2079: oCall 2165
2081: oPop 1
2083: oJumpForward 2104
2085: Choice Lookup Table
          15   2076
          13   2076
          12   2076
           9   2034
           8   2025
2096: oError 6
2098: oGetGlobal 3
2100: oPushResult
2101: oTypeSPush
2102: oPop 1
2104: oJumpForward 2164
2106: oInput 0
2108: oGetAddrLocal 1
2110: oPushResult
2111: oScopeFindRequire
2112: oAssign
2113: oGetLocal 1
2115: oPushResult
2116: oCall 3395
2118: oPop 1
2120: oGetAddrLocal 2
2122: oPushResult
2123: oTypeSTop
2124: oAssign
2125: oTypeSPop
2126: oGetAddrLocal 5
2128: oPushResult
2129: oGetLocal 2
2131: oPushResult
2132: oCall 4212
2134: oPop 1
2136: oAssign
2137: oGetLocal 5
2139: oPushResult
2140: oTypeSPush
2141: oPop 1
2143: oJumpForward 2164
2145: Choice Lookup Table
          17   2106
           0   2012
           2   1995
          13   1989
           1   1974
2156: oError 6
2158: oGetGlobal 3
2160: oPushResult
2161: oTypeSPush
2162: oPop 1
2164: oReturn
2165: oLocalSpace 1
2167: oGetAddrLocal 1
2169: oPushResult
2170: oGetParam 1
2172: oPushResult
2173: oSetResult 6
2175: oPushResult
2176: oNodeGet
2177: oPop 2
2179: oAssign
2180: oGetLocal 1
2182: oPushResult
2183: oTypeSPush
2184: oPop 1
2186: oTypeSNodeType
2187: oChoice 2452
2189: oGetParam 1
2191: oPushResult
2192: oNodeType
2193: oPop 1
2195: oChoice 2257
2197: oEmit 0
2199: oGetParam 1
2201: oPushResult
2202: oCall 4348
2204: oPop 1
2206: oJumpForward 2265
2208: oEmit 3
2210: oGetParam 1
2212: oPushResult
2213: oCall 4348
2215: oPop 1
2217: oJumpForward 2265
2219: oGetParam 1
2221: oPushResult
2222: oSetResult 12
2224: oPushResult
2225: oNodeGetBoolean
2226: oPop 2
2228: oChoice 2243
2230: oEmit 8
2232: oGetParam 1
2234: oPushResult
2235: oCall 4348
2237: oPop 1
2239: oEmit 15
2241: oJumpForward 2255
2243: Choice Lookup Table
           1   2230
2246: oEmit 6
2248: oGetParam 1
2250: oPushResult
2251: oCall 4348
2253: oPop 1
2255: oJumpForward 2265
2257: Choice Lookup Table
          15   2219
          13   2208
          12   2197
2264: oEndChoice
2265: oJumpForward 2543
2267: oGetParam 1
2269: oPushResult
2270: oNodeType
2271: oPop 1
2273: oChoice 2335
2275: oEmit 1
2277: oGetParam 1
2279: oPushResult
2280: oCall 4348
2282: oPop 1
2284: oJumpForward 2343
2286: oEmit 4
2288: oGetParam 1
2290: oPushResult
2291: oCall 4348
2293: oPop 1
2295: oJumpForward 2343
2297: oGetParam 1
2299: oPushResult
2300: oSetResult 12
2302: oPushResult
2303: oNodeGetBoolean
2304: oPop 2
2306: oChoice 2321
2308: oEmit 8
2310: oGetParam 1
2312: oPushResult
2313: oCall 4348
2315: oPop 1
2317: oEmit 16
2319: oJumpForward 2333
2321: Choice Lookup Table
           1   2308
2324: oEmit 7
2326: oGetParam 1
2328: oPushResult
2329: oCall 4348
2331: oPop 1
2333: oJumpForward 2343
2335: Choice Lookup Table
          15   2297
          13   2286
          12   2275
2342: oEndChoice
2343: oJumpForward 2543
2345: oError 16
2347: oJumpForward 2543
2349: oGetParam 1
2351: oPushResult
2352: oNodeType
2353: oPop 1
2355: oChoice 2417
2357: oEmit 2
2359: oGetParam 1
2361: oPushResult
2362: oCall 4348
2364: oPop 1
2366: oJumpForward 2425
2368: oEmit 5
2370: oGetParam 1
2372: oPushResult
2373: oCall 4348
2375: oPop 1
2377: oJumpForward 2425
2379: oGetParam 1
2381: oPushResult
2382: oSetResult 12
2384: oPushResult
2385: oNodeGetBoolean
2386: oPop 2
2388: oChoice 2403
2390: oEmit 8
2392: oGetParam 1
2394: oPushResult
2395: oCall 4348
2397: oPop 1
2399: oEmit 17
2401: oJumpForward 2415
2403: Choice Lookup Table
           1   2390
2406: oEmit 8
2408: oGetParam 1
2410: oPushResult
2411: oCall 4348
2413: oPop 1
2415: oJumpForward 2425
2417: Choice Lookup Table
          15   2379
          13   2368
          12   2357
2424: oEndChoice
2425: oInputChoice 2447
2427: oTypeSPop
2428: oGetLocal 1
2430: oPushResult
2431: oSetResult 14
2433: oPushResult
2434: oNodeGet
2435: oPop 2
2437: oPushResult
2438: oTypeSPush
2439: oPop 1
2441: oCall 2579
2443: oCall 2544
2445: oJumpForward 2450
2447: Choice Lookup Table
          17   2427
2450: oJumpForward 2543
2452: Choice Lookup Table
          22   2349
          17   2345
          21   2345
          20   2345
          19   2267
          18   2189
2465: oGetParam 1
2467: oPushResult
2468: oNodeType
2469: oPop 1
2471: oChoice 2531
2473: oEmit 11
2475: oGetParam 1
2477: oPushResult
2478: oCall 4348
2480: oPop 1
2482: oJumpForward 2539
2484: oEmit 12
2486: oGetParam 1
2488: oPushResult
2489: oCall 4348
2491: oPop 1
2493: oJumpForward 2539
2495: oGetParam 1
2497: oPushResult
2498: oSetResult 12
2500: oPushResult
2501: oNodeGetBoolean
2502: oPop 2
2504: oChoice 2517
2506: oEmit 8
2508: oGetParam 1
2510: oPushResult
2511: oCall 4348
2513: oPop 1
2515: oJumpForward 2529
2517: Choice Lookup Table
           1   2506
2520: oEmit 13
2522: oGetParam 1
2524: oPushResult
2525: oCall 4348
2527: oPop 1
2529: oJumpForward 2539
2531: Choice Lookup Table
          15   2495
          13   2484
          12   2473
2538: oEndChoice
2539: oCall 2579
2541: oCall 2544
2543: oReturn
2544: oLocalSpace 0
2546: oTypeSNodeType
2547: oChoice 2565
2549: oEmit 15
2551: oJumpForward 2578
2553: oEmit 16
2555: oJumpForward 2578
2557: oError 16
2559: oJumpForward 2578
2561: oEmit 17
2563: oJumpForward 2578
2565: Choice Lookup Table
          22   2561
          17   2557
          21   2557
          20   2557
          19   2553
          18   2549
2578: oReturn
2579: oLocalSpace 0
2581: oInputChoice 2595
2583: oCall 2607
2585: oJumpForward 2604
2587: oCall 2750
2589: oJumpForward 2604
2591: oCall 2848
2593: oJumpForward 2604
2595: Choice Lookup Table
          17   2591
          18   2587
          15   2583
2602: oJumpForward 2606
2604: oJumpBack 2581
2606: oReturn
2607: oLocalSpace 3
2609: oTypeSNodeType
2610: oChoice 2614
2612: oJumpForward 2619
2614: Choice Lookup Table
          23   2612
2617: oError 10
2619: oTypeSNodeType
2620: oChoice 2624
2622: oJumpForward 2629
2624: Choice Lookup Table
          23   2622
2627: oError 13
2629: oGetAddrLocal 1
2631: oPushResult
2632: oTypeSTop
2633: oPushResult
2634: oSetResult 15
2636: oPushResult
2637: oNodeGet
2638: oPop 2
2640: oPushResult
2641: oCall 4296
2643: oPop 1
2645: oAssign
2646: oGetAddrLocal 2
2648: oPushResult
2649: oTypeSTop
2650: oPushResult
2651: oSetResult 14
2653: oPushResult
2654: oNodeGet
2655: oPop 2
2657: oAssign
2658: oTypeSPop
2659: oGetLocal 2
2661: oPushResult
2662: oTypeSPush
2663: oPop 1
2665: oCall 1560
2667: oCall 4084
2669: oGetLocal 1
2671: oPushResult
2672: equal_zero
2673: oPop 1
2675: oChoice 2689
2677: oEmit 9
2679: oGetLocal 1
2681: oPushResult
2682: oEmitInt
2683: oPop 1
2685: oEmit 27
2687: oJumpForward 2692
2689: Choice Lookup Table
           0   2677
2692: oGetAddrLocal 3
2694: oPushResult
2695: oGetLocal 2
2697: oPushResult
2698: oSetResult 2
2700: oPushResult
2701: oNodeGetInt
2702: oPop 2
2704: oAssign
2705: oGetLocal 3
2707: oPushResult
2708: oSetResult 1
2710: oPushResult
2711: equal
2712: oPop 2
2714: oChoice 2728
2716: oEmit 9
2718: oGetLocal 3
2720: oPushResult
2721: oEmitInt
2722: oPop 1
2724: oEmit 24
2726: oJumpForward 2731
2728: Choice Lookup Table
           0   2716
2731: oEmit 26
2733: oInputChoice 2741
2735: oJumpForward 2749
2737: oJumpForward 2747
2739: oJumpForward 2747
2741: Choice Lookup Table
          12   2739
          16   2735
2746: oEndChoice
2747: oJumpBack 2619
2749: oReturn
2750: oLocalSpace 2
2752: oTypeSNodeType
2753: oChoice 2757
2755: oJumpForward 2762
2757: Choice Lookup Table
          25   2755
2760: oError 11
2762: oTypeSTop
2763: oPushResult
2764: oSetResult 18
2766: oPushResult
2767: oNodeGet
2768: oPop 2
2770: oPushResult
2771: oScopeEnter
2772: oPop 1
2774: oInput 0
2776: oGetAddrLocal 1
2778: oPushResult
2779: oScopeFindRequire
2780: oAssign
2781: oGetLocal 1
2783: oPushResult
2784: oNodeType
2785: oPop 1
2787: oChoice 2791
2789: oJumpForward 2796
2791: Choice Lookup Table
          14   2789
2794: oError 12
2796: oScopeEnd
2797: oGetAddrLocal 2
2799: oPushResult
2800: oGetLocal 1
2802: oPushResult
2803: oSetResult 8
2805: oPushResult
2806: oNodeGetInt
2807: oPop 2
2809: oAssign
2810: oGetLocal 2
2812: oPushResult
2813: equal_zero
2814: oPop 1
2816: oChoice 2830
2818: oEmit 9
2820: oGetLocal 2
2822: oPushResult
2823: oEmitInt
2824: oPop 1
2826: oEmit 26
2828: oJumpForward 2833
2830: Choice Lookup Table
           0   2818
2833: oTypeSPop
2834: oGetLocal 1
2836: oPushResult
2837: oSetResult 6
2839: oPushResult
2840: oNodeGet
2841: oPop 2
2843: oPushResult
2844: oTypeSPush
2845: oPop 1
2847: oReturn
2848: oLocalSpace 1
2850: oTypeSNodeType
2851: oChoice 2855
2853: oJumpForward 2860
2855: Choice Lookup Table
          22   2853
2858: oError 9
2860: oEmit 17
2862: oGetAddrLocal 1
2864: oPushResult
2865: oTypeSTop
2866: oAssign
2867: oTypeSPop
2868: oGetLocal 1
2870: oPushResult
2871: oSetResult 14
2873: oPushResult
2874: oNodeGet
2875: oPop 2
2877: oPushResult
2878: oTypeSPush
2879: oPop 1
2881: oReturn
2882: oLocalSpace 0
2884: oCall 4058
2886: oReturn
2887: oLocalSpace 5
2889: oGetAddrLocal 1
2891: oPushResult
2892: oGetParam 1
2894: oPushResult
2895: oSetResult 9
2897: oPushResult
2898: oNodeGet
2899: oPop 2
2901: oAssign
2902: oGetAddrLocal 2
2904: oPushResult
2905: oGetLocal 1
2907: oPushResult
2908: oSetResult 2
2910: oPushResult
2911: oNodeGetInt
2912: oPop 2
2914: oAssign
2915: oEmit 40
2917: oGetLocal 2
2919: oPushResult
2920: oEmitInt
2921: oPop 1
2923: oGetAddrLocal 3
2925: oPushResult
2926: oGetLocal 1
2928: oPushResult
2929: oSetResult 1
2931: oPushResult
2932: oNodeGet
2933: oPop 2
2935: oAssign
2936: oInputChoice 3105
2938: oGetLocal 3
2940: oPushResult
2941: oNodeNull
2942: oPop 1
2944: oChoice 2950
2946: oJumpForward 3101
2948: oJumpForward 2953
2950: Choice Lookup Table
           1   2946
2953: oGetAddrLocal 4
2955: oPushResult
2956: oGetLocal 3
2958: oPushResult
2959: oSetResult 8
2961: oPushResult
2962: oNodeGetInt
2963: oPop 2
2965: oAssign
2966: oEmit 14
2968: oGetLocal 4
2970: oPushResult
2971: oEmitInt
2972: oPop 1
2974: oGetLocal 3
2976: oPushResult
2977: oSetResult 6
2979: oPushResult
2980: oNodeGet
2981: oPop 2
2983: oPushResult
2984: oTypeSPush
2985: oPop 1
2987: oGetLocal 3
2989: oPushResult
2990: oSetResult 12
2992: oPushResult
2993: oNodeGetBoolean
2994: oPop 2
2996: oChoice 3064
2998: oCall 3359
3000: oCall 4058
3002: oEmit 20
3004: oJumpForward 3070
3006: oCall 1560
3008: oCall 2882
3010: oTypeSNodeType
3011: oChoice 3029
3013: oEmit 18
3015: oJumpForward 3062
3017: oEmit 19
3019: oJumpForward 3062
3021: oError 16
3023: oJumpForward 3062
3025: oEmit 20
3027: oJumpForward 3062
3029: Choice Lookup Table
          22   3025
          17   3021
          21   3021
          20   3021
          19   3017
          18   3013
3042: oGetAddrLocal 5
3044: oPushResult
3045: oTypeSTop
3046: oPushResult
3047: oSetResult 2
3049: oPushResult
3050: oNodeGetInt
3051: oPop 2
3053: oAssign
3054: oEmit 21
3056: oGetLocal 5
3058: oPushResult
3059: oEmitInt
3060: oPop 1
3062: oJumpForward 3070
3064: Choice Lookup Table
           0   3006
           1   2998
3069: oEndChoice
3070: oTypeSPop
3071: oGetAddrLocal 3
3073: oPushResult
3074: oNodeNext
3075: oPop 1
3077: oGetLocal 3
3079: oPushResult
3080: oNodeNull
3081: oPop 1
3083: oChoice 3091
3085: oJumpForward 3101
3087: oJumpForward 3097
3089: oJumpForward 3097
3091: Choice Lookup Table
           0   3089
           1   3085
3096: oEndChoice
3097: oInput 12
3099: oJumpBack 2938
3101: oInput 14
3103: oJumpForward 3123
3105: Choice Lookup Table
          13   2938
3108: oGetLocal 3
3110: oPushResult
3111: oNodeNull
3112: oPop 1
3114: oChoice 3120
3116: oError 15
3118: oJumpForward 3123
3120: Choice Lookup Table
           0   3116
3123: oEmit 42
3125: oGetParam 1
3127: oPushResult
3128: oCall 4348
3130: oPop 1
3132: oGetParam 1
3134: oPushResult
3135: oNodeType
3136: oPop 1
3138: oChoice 3155
3140: oGetParam 1
3142: oPushResult
3143: oSetResult 6
3145: oPushResult
3146: oNodeGet
3147: oPop 2
3149: oPushResult
3150: oTypeSPush
3151: oPop 1
3153: oJumpForward 3158
3155: Choice Lookup Table
           8   3140
3158: oEmit 41
3160: oGetLocal 2
3162: oPushResult
3163: oEmitInt
3164: oPop 1
3166: oReturn
3167: oLocalSpace 0
3169: oInputChoice 3219
3171: oCall 3955
3173: oJumpForward 3244
3175: oCall 3962
3177: oJumpForward 3244
3179: oCall 4029
3181: oJumpForward 3244
3183: oCall 4032
3185: oJumpForward 3244
3187: oCall 3488
3189: oJumpForward 3244
3191: oCall 3816
3193: oJumpForward 3244
3195: oCall 3546
3197: oJumpForward 3244
3199: oCall 3767
3201: oJumpForward 3244
3203: oCall 3903
3205: oJumpForward 3244
3207: oCall 3871
3209: oJumpForward 3244
3211: oCall 3932
3213: oJumpForward 3244
3215: oCall 3245
3217: oJumpForward 3244
3219: Choice Lookup Table
           0   3215
          32   3211
          48   3207
          49   3203
          46   3199
          41   3195
          45   3191
          38   3187
          57   3183
          56   3179
          55   3175
          54   3171
3244: oReturn
3245: oLocalSpace 1
3247: oGetAddrLocal 1
3249: oPushResult
3250: oScopeFindRequire
3251: oAssign
3252: oGetLocal 1
3254: oPushResult
3255: oNodeType
3256: oPop 1
3258: oChoice 3278
3260: oGetLocal 1
3262: oPushResult
3263: oCall 2887
3265: oPop 1
3267: oJumpForward 3289
3269: oGetLocal 1
3271: oPushResult
3272: oCall 3290
3274: oPop 1
3276: oJumpForward 3289
3278: Choice Lookup Table
          15   3269
          13   3269
          12   3269
           7   3260
3287: oError 0
3289: oReturn
3290: oLocalSpace 1
3292: oGetParam 1
3294: oPushResult
3295: oCall 3395
3297: oPop 1
3299: oInput 3
3301: oCall 1560
3303: oCall 4058
3305: oTypeSNodeType
3306: oChoice 3324
3308: oEmit 18
3310: oJumpForward 3357
3312: oEmit 19
3314: oJumpForward 3357
3316: oError 16
3318: oJumpForward 3357
3320: oEmit 20
3322: oJumpForward 3357
3324: Choice Lookup Table
          22   3320
          17   3316
          21   3316
          20   3316
          19   3312
          18   3308
3337: oGetAddrLocal 1
3339: oPushResult
3340: oTypeSTop
3341: oPushResult
3342: oSetResult 2
3344: oPushResult
3345: oNodeGetInt
3346: oPop 2
3348: oAssign
3349: oEmit 21
3351: oGetLocal 1
3353: oPushResult
3354: oEmitInt
3355: oPop 1
3357: oTypeSPop
3358: oReturn
3359: oLocalSpace 1
3361: oInput 0
3363: oGetAddrLocal 1
3365: oPushResult
3366: oScopeFindRequire
3367: oAssign
3368: oGetLocal 1
3370: oPushResult
3371: oNodeType
3372: oPop 1
3374: oChoice 3378
3376: oJumpForward 3387
3378: Choice Lookup Table
          15   3376
          13   3376
          12   3376
3385: oError 4
3387: oGetLocal 1
3389: oPushResult
3390: oCall 3395
3392: oPop 1
3394: oReturn
3395: oLocalSpace 0
3397: oGetParam 1
3399: oPushResult
3400: oNodeType
3401: oPop 1
3403: oChoice 3463
3405: oEmit 11
3407: oGetParam 1
3409: oPushResult
3410: oCall 4348
3412: oPop 1
3414: oJumpForward 3472
3416: oEmit 12
3418: oGetParam 1
3420: oPushResult
3421: oCall 4348
3423: oPop 1
3425: oJumpForward 3472
3427: oGetParam 1
3429: oPushResult
3430: oSetResult 12
3432: oPushResult
3433: oNodeGetBoolean
3434: oPop 2
3436: oChoice 3449
3438: oEmit 8
3440: oGetParam 1
3442: oPushResult
3443: oCall 4348
3445: oPop 1
3447: oJumpForward 3461
3449: Choice Lookup Table
           1   3438
3452: oEmit 13
3454: oGetParam 1
3456: oPushResult
3457: oCall 4348
3459: oPop 1
3461: oJumpForward 3472
3463: Choice Lookup Table
          15   3427
          13   3416
          12   3405
3470: oError 4
3472: oGetParam 1
3474: oPushResult
3475: oSetResult 6
3477: oPushResult
3478: oNodeGet
3479: oPop 2
3481: oPushResult
3482: oTypeSPush
3483: oPop 1
3485: oCall 2579
3487: oReturn
3488: oLocalSpace 0
3490: oCall 1560
3492: oCall 4111
3494: oInput 39
3496: oEmit 47
3498: oSetResult 2
3500: oPushResult
3501: oPatchPushHere
3502: oPop 1
3504: oEmit 53
3506: oCall 3167
3508: oInputChoice 3536
3510: oEmit 45
3512: oSetResult 2
3514: oPushResult
3515: oPatchPushHere
3516: oPop 1
3518: oEmit 53
3520: oSetResult 2
3522: oPushResult
3523: oPatchSwap
3524: oPop 1
3526: oSetResult 2
3528: oPushResult
3529: oPatchPopFwd
3530: oPop 1
3532: oCall 3167
3534: oJumpForward 3539
3536: Choice Lookup Table
          40   3510
3539: oSetResult 2
3541: oPushResult
3542: oPatchPopFwd
3543: oPop 1
3545: oReturn
3546: oLocalSpace 1
3548: oInput 0
3550: oGetAddrLocal 1
3552: oPushResult
3553: oScopeFindRequire
3554: oAssign
3555: oGetLocal 1
3557: oPushResult
3558: oNodeType
3559: oPop 1
3561: oChoice 3573
3563: oJumpForward 3582
3565: oError 16
3567: oJumpForward 3582
3569: oError 16
3571: oJumpForward 3582
3573: Choice Lookup Table
          15   3569
          13   3565
          12   3563
3580: oError 5
3582: oGetLocal 1
3584: oPushResult
3585: oSetResult 6
3587: oPushResult
3588: oNodeGet
3589: oPop 2
3591: oPushResult
3592: oTypeSPush
3593: oPop 1
3595: oCall 4084
3597: oEmit 10
3599: oGetLocal 1
3601: oPushResult
3602: oCall 4348
3604: oPop 1
3606: oInput 3
3608: oCall 1560
3610: oCall 4084
3612: oEmit 18
3614: oEmit 45
3616: oSetResult 0
3618: oPushResult
3619: oPatchPushHere
3620: oPop 1
3622: oEmit 53
3624: oSetResult 0
3626: oPushResult
3627: oPatchPushHere
3628: oPop 1
3630: oSetResult 0
3632: oPushResult
3633: oPatchSwap
3634: oPop 1
3636: oInputChoice 3734
3638: oEmit 22
3640: oGetLocal 1
3642: oPushResult
3643: oCall 4348
3645: oPop 1
3647: oSetResult 0
3649: oPushResult
3650: oPatchPopFwd
3651: oPop 1
3653: oEmit 0
3655: oGetLocal 1
3657: oPushResult
3658: oCall 4348
3660: oPop 1
3662: oCall 1560
3664: oCall 4084
3666: oEmit 34
3668: oEmit 46
3670: oSetResult 0
3672: oPushResult
3673: oPatchPushHere
3674: oPop 1
3676: oEmit 53
3678: oSetResult 0
3680: oPushResult
3681: oPatchSwap
3682: oPop 1
3684: oJumpForward 3740
3686: oEmit 23
3688: oGetLocal 1
3690: oPushResult
3691: oCall 4348
3693: oPop 1
3695: oSetResult 0
3697: oPushResult
3698: oPatchPopFwd
3699: oPop 1
3701: oEmit 0
3703: oGetLocal 1
3705: oPushResult
3706: oCall 4348
3708: oPop 1
3710: oCall 1560
3712: oCall 4084
3714: oEmit 35
3716: oEmit 46
3718: oSetResult 0
3720: oPushResult
3721: oPatchPushHere
3722: oPop 1
3724: oEmit 53
3726: oSetResult 0
3728: oPushResult
3729: oPatchSwap
3730: oPop 1
3732: oJumpForward 3740
3734: Choice Lookup Table
          43   3686
          42   3638
3739: oEndChoice
3740: oSetResult 0
3742: oPushResult
3743: oCountPush
3744: oPop 1
3746: oInput 44
3748: oCall 3167
3750: oEmit 45
3752: oSetResult 0
3754: oPushResult
3755: oPatchPopBack
3756: oPop 1
3758: oSetResult 0
3760: oPushResult
3761: oPatchPopFwd
3762: oPop 1
3764: oCall 4035
3766: oReturn
3767: oLocalSpace 0
3769: oSetResult 0
3771: oPushResult
3772: oPatchPushHere
3773: oPop 1
3775: oSetResult 0
3777: oPushResult
3778: oCountPush
3779: oPop 1
3781: oCall 3167
3783: oInputChoice 3807
3785: oCall 3167
3787: oJumpForward 3813
3789: oCall 1560
3791: oCall 4111
3793: oEmit 47
3795: oSetResult 0
3797: oPushResult
3798: oPatchPopBack
3799: oPop 1
3801: oCall 4035
3803: oJumpForward 3815
3805: oJumpForward 3813
3807: Choice Lookup Table
          47   3789
           4   3785
3812: oEndChoice
3813: oJumpBack 3783
3815: oReturn
3816: oLocalSpace 0
3818: oSetResult 0
3820: oPushResult
3821: oPatchPushHere
3822: oPop 1
3824: oSetResult 0
3826: oPushResult
3827: oCountPush
3828: oPop 1
3830: oCall 1560
3832: oCall 4111
3834: oInput 44
3836: oEmit 47
3838: oSetResult 0
3840: oPushResult
3841: oPatchPushHere
3842: oPop 1
3844: oEmit 53
3846: oSetResult 0
3848: oPushResult
3849: oPatchSwap
3850: oPop 1
3852: oCall 3167
3854: oEmit 45
3856: oSetResult 0
3858: oPushResult
3859: oPatchPopBack
3860: oPop 1
3862: oSetResult 0
3864: oPushResult
3865: oPatchPopFwd
3866: oPop 1
3868: oCall 4035
3870: oReturn
3871: oLocalSpace 0
3873: oSetResult 0
3875: oPushResult
3876: oPatchAnyEntries
3877: oPop 1
3879: oChoice 3897
3881: oEmit 45
3883: oSetResult 0
3885: oPushResult
3886: oPatchDup
3887: oPop 1
3889: oSetResult 0
3891: oPushResult
3892: oPatchPopBack
3893: oPop 1
3895: oJumpForward 3902
3897: Choice Lookup Table
           1   3881
3900: oError 18
3902: oReturn
3903: oLocalSpace 0
3905: oSetResult 0
3907: oPushResult
3908: oPatchAnyEntries
3909: oPop 1
3911: oChoice 3926
3913: oEmit 45
3915: oSetResult 1
3917: oPushResult
3918: oPatchPushHere
3919: oPop 1
3921: oEmit 53
3923: oCountInc
3924: oJumpForward 3931
3926: Choice Lookup Table
           1   3913
3929: oError 18
3931: oReturn
3932: oLocalSpace 0
3934: oCall 3167
3936: oInputChoice 3946
3938: oCall 3167
3940: oJumpForward 3952
3942: oJumpForward 3954
3944: oJumpForward 3952
3946: Choice Lookup Table
          33   3942
           4   3938
3951: oEndChoice
3952: oJumpBack 3936
3954: oReturn
3955: oLocalSpace 0
3957: oCall 3962
3959: oEmit 52
3961: oReturn
3962: oLocalSpace 0
3964: oInputChoice 4025
3966: oCall 1560
3968: oTypeSNodeType
3969: oChoice 3991
3971: oEmit 48
3973: oJumpForward 4006
3975: oEmit 49
3977: oJumpForward 4006
3979: oEmit 50
3981: oJumpForward 4006
3983: oError 16
3985: oJumpForward 4006
3987: oEmit 51
3989: oJumpForward 4006
3991: Choice Lookup Table
          22   3987
          17   3983
          20   3983
          21   3979
          19   3975
          18   3971
4004: oError 17
4006: oTypeSPop
4007: oInputChoice 4015
4009: oJumpForward 4023
4011: oJumpForward 4021
4013: oJumpForward 4021
4015: Choice Lookup Table
          12   4013
          14   4009
4020: oEndChoice
4021: oJumpBack 3966
4023: oJumpForward 4028
4025: Choice Lookup Table
          13   3966
4028: oReturn
4029: oLocalSpace 0
4031: oReturn
4032: oLocalSpace 0
4034: oReturn
4035: oLocalSpace 0
4037: oCountIsZero
4038: oChoice 4049
4040: oSetResult 1
4042: oPushResult
4043: oPatchPopFwd
4044: oPop 1
4046: oCountDec
4047: oJumpForward 4054
4049: Choice Lookup Table
           0   4040
4052: oJumpForward 4056
4054: oJumpBack 4037
4056: oCountPop
4057: oReturn
4058: oLocalSpace 1
4060: oGetAddrLocal 1
4062: oPushResult
4063: oTypeSNodeType
4064: oAssign
4065: oTypeSPop
4066: oGetLocal 1
4068: oPushResult
4069: oTypeSNodeType
4070: oPushResult
4071: equal_node_type
4072: oPop 2
4074: oChoice 4080
4076: oError 14
4078: oJumpForward 4083
4080: Choice Lookup Table
           0   4076
4083: oReturn
4084: oLocalSpace 0
4086: oTypeSNodeType
4087: oChoice 4091
4089: oJumpForward 4096
4091: Choice Lookup Table
          18   4089
4094: oError 7
4096: oTypeSPop
4097: oReturn
4098: oLocalSpace 0
4100: oTypeSNodeType
4101: oChoice 4105
4103: oJumpForward 4110
4105: Choice Lookup Table
          18   4103
4108: oError 7
4110: oReturn
4111: oLocalSpace 0
4113: oTypeSNodeType
4114: oChoice 4118
4116: oJumpForward 4123
4118: Choice Lookup Table
          19   4116
4121: oError 8
4123: oTypeSPop
4124: oReturn
4125: oLocalSpace 0
4127: oTypeSNodeType
4128: oChoice 4132
4130: oJumpForward 4137
4132: Choice Lookup Table
          19   4130
4135: oError 8
4137: oReturn
4138: oLocalSpace 1
4140: oGetAddrLocal 1
4142: oPushResult
4143: oGetParam 2
4145: oPushResult
4146: oNodeNew
4147: oPop 1
4149: oAssign
4150: oGetLocal 1
4152: oPushResult
4153: oSetResult 2
4155: oPushResult
4156: oGetParam 1
4158: oPushResult
4159: oNodeSetInt
4160: oPop 3
4162: oGetLocal 1
4164: oPushResult
4165: oTypeAdd
4166: oPop 1
4168: oGetLocal 1
4170: oReturn
4171: oReturn
4172: oLocalSpace 1
4174: oGetAddrLocal 1
4176: oPushResult
4177: oGetParam 3
4179: oPushResult
4180: oNodeNew
4181: oPop 1
4183: oAssign
4184: oGetLocal 1
4186: oPushResult
4187: oSetResult 5
4189: oPushResult
4190: oGetParam 2
4192: oPushResult
4193: oNodeSetKind
4194: oPop 3
4196: oGetLocal 1
4198: oPushResult
4199: oSetResult 4
4201: oPushResult
4202: oGetParam 1
4204: oPushResult
4205: oNodeSetInt
4206: oPop 3
4208: oGetLocal 1
4210: oReturn
4211: oReturn
4212: oLocalSpace 1
4214: oGetAddrLocal 1
4216: oPushResult
4217: oGetParam 1
4219: oPushResult
4220: oSetResult 13
4222: oPushResult
4223: oNodeGet
4224: oPop 2
4226: oAssign
4227: oGetLocal 1
4229: oPushResult
4230: oNodeNull
4231: oPop 1
4233: oChoice 4289
4235: oGetAddrLocal 1
4237: oPushResult
4238: oSetResult 22
4240: oPushResult
4241: oNodeNew
4242: oPop 1
4244: oAssign
4245: oGetLocal 1
4247: oPushResult
4248: oSetResult 14
4250: oPushResult
4251: oGetParam 1
4253: oPushResult
4254: oNodeSet
4255: oPop 3
4257: oGetLocal 1
4259: oPushResult
4260: oSetResult 2
4262: oPushResult
4263: oSetResult 8
4265: oPushResult
4266: oNodeSetInt
4267: oPop 3
4269: oGetLocal 1
4271: oPushResult
4272: oTypeAdd
4273: oPop 1
4275: oGetParam 1
4277: oPushResult
4278: oSetResult 13
4280: oPushResult
4281: oGetLocal 1
4283: oPushResult
4284: oNodeSet
4285: oPop 3
4287: oJumpForward 4292
4289: Choice Lookup Table
           1   4235
4292: oGetLocal 1
4294: oReturn
4295: oReturn
4296: oLocalSpace 0
4298: oGetParam 1
4300: oPushResult
4301: oNodeType
4302: oPop 1
4304: oChoice 4333
4306: oSetResult 0
4308: oReturn
4309: oJumpForward 4347
4311: oSetResult 0
4313: oReturn
4314: oJumpForward 4347
4316: oSetResult 0
4318: oReturn
4319: oJumpForward 4347
4321: oGetParam 1
4323: oPushResult
4324: oSetResult 16
4326: oPushResult
4327: oNodeGetInt
4328: oPop 2
4330: oReturn
4331: oJumpForward 4347
4333: Choice Lookup Table
          24   4321
          20   4316
          19   4311
          18   4306
4342: oError 3
4344: oSetResult 0
4346: oReturn
4347: oReturn
4348: oLocalSpace 0
4350: oGetParam 1
4352: oPushResult
4353: oSetResult 8
4355: oPushResult
4356: oNodeGetInt
4357: oPop 2
4359: oPushResult
4360: oEmitInt
4361: oPop 1
4363: oReturn
4364: oLocalSpace 1
4366: oGetAddrGlobal 2
4368: oPushResult
4369: oSetResult 17
4371: oPushResult
4372: oSetResult 4
4374: oPushResult
4375: oCall 4138
4377: oPop 2
4379: oAssign
4380: oGetAddrGlobal 3
4382: oPushResult
4383: oSetResult 18
4385: oPushResult
4386: oSetResult 4
4388: oPushResult
4389: oCall 4138
4391: oPop 2
4393: oAssign
4394: oGetAddrGlobal 4
4396: oPushResult
4397: oSetResult 19
4399: oPushResult
4400: oSetResult 1
4402: oPushResult
4403: oCall 4138
4405: oPop 2
4407: oAssign
4408: oGetAddrGlobal 5
4410: oPushResult
4411: oSetResult 20
4413: oPushResult
4414: oSetResult 1
4416: oPushResult
4417: oCall 4138
4419: oPop 2
4421: oAssign
4422: oGetAddrGlobal 6
4424: oPushResult
4425: oSetResult 21
4427: oPushResult
4428: oSetResult 256
4430: oPushResult
4431: oCall 4138
4433: oPop 2
4435: oAssign
4436: oGetAddrLocal 1
4438: oPushResult
4439: oSetResult 10
4441: oPushResult
4442: oSetResult 5
4444: oPushResult
4445: oIdAdd_File
4446: oPushResult
4447: oCall 4172
4449: oPop 3
4451: oAssign
4452: oGetLocal 1
4454: oPushResult
4455: oSetResult 6
4457: oPushResult
4458: oGetGlobal 2
4460: oPushResult
4461: oNodeSet
4462: oPop 3
4464: oGetLocal 1
4466: oPushResult
4467: oScopeDeclare
4468: oPop 1
4470: oGetAddrLocal 1
4472: oPushResult
4473: oSetResult 10
4475: oPushResult
4476: oSetResult 5
4478: oPushResult
4479: oIdAdd_Integer
4480: oPushResult
4481: oCall 4172
4483: oPop 3
4485: oAssign
4486: oGetLocal 1
4488: oPushResult
4489: oSetResult 6
4491: oPushResult
4492: oGetGlobal 3
4494: oPushResult
4495: oNodeSet
4496: oPop 3
4498: oGetLocal 1
4500: oPushResult
4501: oScopeDeclare
4502: oPop 1
4504: oGetAddrLocal 1
4506: oPushResult
4507: oSetResult 10
4509: oPushResult
4510: oSetResult 5
4512: oPushResult
4513: oIdAdd_Boolean
4514: oPushResult
4515: oCall 4172
4517: oPop 3
4519: oAssign
4520: oGetLocal 1
4522: oPushResult
4523: oSetResult 6
4525: oPushResult
4526: oGetGlobal 4
4528: oPushResult
4529: oNodeSet
4530: oPop 3
4532: oGetLocal 1
4534: oPushResult
4535: oScopeDeclare
4536: oPop 1
4538: oGetAddrLocal 1
4540: oPushResult
4541: oSetResult 10
4543: oPushResult
4544: oSetResult 5
4546: oPushResult
4547: oIdAdd_Char
4548: oPushResult
4549: oCall 4172
4551: oPop 3
4553: oAssign
4554: oGetLocal 1
4556: oPushResult
4557: oSetResult 6
4559: oPushResult
4560: oGetGlobal 5
4562: oPushResult
4563: oNodeSet
4564: oPop 3
4566: oGetLocal 1
4568: oPushResult
4569: oScopeDeclare
4570: oPop 1
4572: oGetAddrLocal 1
4574: oPushResult
4575: oSetResult 10
4577: oPushResult
4578: oSetResult 5
4580: oPushResult
4581: oIdAdd_String
4582: oPushResult
4583: oCall 4172
4585: oPop 3
4587: oAssign
4588: oGetLocal 1
4590: oPushResult
4591: oSetResult 6
4593: oPushResult
4594: oGetGlobal 6
4596: oPushResult
4597: oNodeSet
4598: oPop 3
4600: oGetLocal 1
4602: oPushResult
4603: oScopeDeclare
4604: oPop 1
4606: oGetAddrLocal 1
4608: oPushResult
4609: oSetResult 9
4611: oPushResult
4612: oSetResult 4
4614: oPushResult
4615: oIdAdd_True
4616: oPushResult
4617: oCall 4172
4619: oPop 3
4621: oAssign
4622: oGetLocal 1
4624: oPushResult
4625: oSetResult 6
4627: oPushResult
4628: oGetGlobal 4
4630: oPushResult
4631: oNodeSet
4632: oPop 3
4634: oGetLocal 1
4636: oPushResult
4637: oSetResult 8
4639: oPushResult
4640: oSetResult 1
4642: oPushResult
4643: oNodeSetInt
4644: oPop 3
4646: oGetLocal 1
4648: oPushResult
4649: oScopeDeclare
4650: oPop 1
4652: oGetAddrLocal 1
4654: oPushResult
4655: oSetResult 9
4657: oPushResult
4658: oSetResult 4
4660: oPushResult
4661: oIdAdd_False
4662: oPushResult
4663: oCall 4172
4665: oPop 3
4667: oAssign
4668: oGetLocal 1
4670: oPushResult
4671: oSetResult 6
4673: oPushResult
4674: oGetGlobal 4
4676: oPushResult
4677: oNodeSet
4678: oPop 3
4680: oGetLocal 1
4682: oPushResult
4683: oSetResult 8
4685: oPushResult
4686: oSetResult 0
4688: oPushResult
4689: oNodeSetInt
4690: oPop 3
4692: oGetLocal 1
4694: oPushResult
4695: oScopeDeclare
4696: oPop 1
4698: oReturn
