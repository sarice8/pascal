   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]}
 241:    @CheckForUndefinedMethods
 244:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 244: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 247:    ;
      
      
      
 247: BlockStmt( Label labelForBody ):
 249:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 257:    int patchLS
 257:    .tEnter  patchLS = Here  .tSpace
      
 266:    @Statement
 268:    .tReturn
      
 270:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 282:    oPatch( patchLS, localSpace )
 292:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 292: MethodModifiers( Node decl ):
 294:    {[
 294:       | pCdecl :
 296:          oNodeSetBoolean( decl, qCdecl, true )
 308:          ';'
      
 310:       | * : >
 317:    ]}
 320:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 320: ExternalDecl( Node decl ):
 322:    oNodeSetBoolean( decl, qExternal, true )
 334:    [
 334:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 336:          [
 336:             | pName :
 338:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 340:             | * :
 345:          ]
 345:       | * :
 350:    ]
 351:    ;
      
      
 351: ProcDecl:
 353:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 355:    boolean redeclaring = false
 361:    Node decl = oScopeFindInCurrentScope
      
 366:    [ oNodeNull( decl )
 373:       | true :
               % first declaration
 374:          decl = @newIdent( nProc, kProc, LAST_ID )
 390:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 401:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 403:          redeclaring = true
 409:          [ oNodeGetBoolean( decl, qBodyDefined )
 419:             | true : #eAlreadyDefined
 422:             | * :
 427:          ]
 427:          [ oNodeGetBoolean( decl, qExternal )
 437:             | true : #eAlreadyDefined
 440:             | * :
 445:          ]
 445:          [ oNodeType( decl )
 452:             | nProc :
 453:             | * : #eAlreadyDefined   % wrong kind
 460:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 460:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 479:          oNodeSet( decl, qParams, Null )
 491:    ]
      
 499:    oScopeBegin
 500:    Node paramScope = oScopeCurrent
      
 505:    @FormalArgDecl
 507:    oNodeSet( decl, qParams, paramScope )
 519:    oScopeEnd
 520:    ';'
      
 522:    [ redeclaring
 525:       | false : oScopeDeclare( decl )
 532:       | true :  % TO DO: check that qParams is consistent with qOldParams
 534:    ]
      
 542:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 549:    [
 549:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 551:       | pExternal : @ExternalDecl( decl )
      
 560:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 567:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 573:          oScopeBegin
 574:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 585:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 596:          Label label = oNodeGetLabel( decl, qValue )
 609:          @Block( nLocalVar, label )
 619:          oNodeSetBoolean( decl, qBodyDefined, true )
 631:          oScopeEnd
      
 632:          oScopeEnd  % paramScope
 633:    ]
 633:    ';';
      
      
 636: FuncDecl:
 638:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 640:    boolean redeclaring = false
 646:    Node decl = oScopeFindInCurrentScope
      
 651:    [ oNodeNull( decl )
 658:       | true :
               % first declaration
 659:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 675:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 686:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 688:          redeclaring = true
 694:          [ oNodeGetBoolean( decl, qBodyDefined )
 704:             | true : #eAlreadyDefined
 707:             | * :
 712:          ]
 712:          [ oNodeType( decl )
 719:             | nFunc :
 720:             | * : #eAlreadyDefined   % wrong kind
 727:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 727:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 746:          oNodeSet( decl, qParams, Null )
 758:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 777:          oNodeSet( decl, qType, Null )
 789:    ]
      
 797:    oScopeBegin
 798:    Node paramScope = oScopeCurrent
      
 803:    @FormalArgDecl
 805:    oNodeSet( decl, qParams, paramScope )
      
 817:    ':'
      
 819:    Node theType
 819:    @TypeRef( theType )
 826:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 838:    Node ptrType = @PointerTypeTo( theType )
 849:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 865:    oScopeEnd
 866:    ';'
      
 868:    [ redeclaring
 871:       | false : oScopeDeclare( decl )
 878:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 880:    ]
      
 888:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 895:    [
 895:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 897:       | pExternal : @ExternalDecl( decl )
      
 906:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 913:          oScopeEnter( paramScope )
      
 919:          oScopeBegin
 920:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 931:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 942:          Label label = oNodeGetLabel( decl, qValue )
 955:          @Block( nLocalVar, label )
 965:          oNodeSetBoolean( decl, qBodyDefined, true )
 977:          oScopeEnd
      
 978:          oScopeEnd  % paramScope
 979:    ]
 979:    ';';
      
      
 982: FormalArgDecl:
 984:    [
 984:       | '(' :
 986:          {
 986:             NodeVec decls = oNodeVecNew
 991:             Node decl
 991:             boolean isInOut = false
      
 997:             [
 997:                | pVar : isInOut = true
1005:                | * :
1010:             ]
      
1010:             {  pIdent
      
1012:                decl = @newIdent( nParam, kVar, LAST_ID )
1028:                oNodeSetBoolean( decl, qInOut, isInOut )
1040:                oNodeVecAppend( decls, decl )
      
1049:                [
1049:                   | ':' : >
1053:                   | ',' :
1055:                ]
1063:             }
      
1065:             Node theType
1065:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1072:             Node allocType
1072:             [ isInOut
1075:                | true :   allocType = @PointerTypeTo( theType )
1087:                | * :      allocType = theType
1098:             ]
      
1098:             int i = 0
1104:             {[ equal( i, oNodeVecSize( decls ) )
1118:                | false :
1119:                   decl = oNodeVecElement( decls, i )
      
1132:                   oNodeSet( decl, qType, theType )
1144:                   oScopeDeclare( decl )
1150:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1166:                   inc( i )
1172:                | * :
1177:                   >
1179:             ]}
      
1181:             oNodeVecDelete( decls )
      
1187:             [
1187:                | ')' : >
1191:                | ';' :
1193:             ]
1201:          }
1203:       | * :
1208:    ];
      
1209: ConstDecl:
1211:    {[
1211:       | pIdent :
1213:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1229:          '='
      
1231:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1233:          int val = oValueTop
1238:          oValuePop
1239:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1251:          oNodeSet( decl, qType, IntegerType )
      
1263:          oScopeDeclare( decl )
1269:          ';'
1271:       | * :
1276:          >
1278:    ]};
      
1281: TypeDecl:
1283:    {[
1283:       | pIdent :
1285:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1301:          '='
1303:          Node theType
1303:          @TypeRef( theType )
1310:          oNodeSet( decl, qType, theType )
1322:          oScopeDeclare( decl )
1328:          ';'
1330:       | * :
1335:          >
1337:    ]};
      
1340: VarDecl( node_type varNodeType ):
1342:    {[
1342:       | pIdent :
1344:          NodeVec decls = oNodeVecNew
1349:          Node decl
1349:          {
1349:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1365:             oNodeVecAppend( decls, decl )
1374:             [
1374:                | ',' :
1376:                   pIdent
1378:                | * :
1383:                   >
1385:             ]
1385:          }
1387:          ':'
1389:          Node theType
1389:          @TypeRef( theType )
      
1396:          int i = 0
1402:          {[ equal( i, oNodeVecSize( decls ) )
1416:            | false :
1417:              decl = oNodeVecElement( decls, i )
1430:              oNodeSet( decl, qType, theType )
1442:              oScopeDeclareAlloc( decl )
1448:              inc( i )
1454:             | * :
1459:               >
1461:          ]}
      
1463:          oNodeVecDelete( decls )
1469:          ';'
1471:       | * :
1476:          >
1478:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1481: TypeRef( out Node resultType ):
1483:    [
1483:       | pIdent :           % previously named type (including intrinsics)
1485:          Node decl = oScopeFindRequire
1490:          [ oNodeType( decl )
1497:            | nTypeDecl :
1498:                resultType = oNodeGet( decl, qType )
1511:            | * :
1516:                #eNotType
1518:                resultType = IntegerType
1524:          ]
         
1524:       | pArray :
1526:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1528:          NodeVec dimensions = oNodeVecNew
      
1533:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1533:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1543:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1555:             @ConstExpr
1557:             oNodeSetInt( subrange, qLow, oValueTop )
1568:             oValuePop
1569:             '..'
1571:             @ConstExpr
1573:             oNodeSetInt( subrange, qHigh, oValueTop )
1584:             oValuePop
1585:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1597:             oTypeAdd( subrange )
      
1603:             Node a = oNodeNew( nArrayType )
1613:             oNodeSet( a, qIndexType, subrange )
      
1625:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1634:             [
1634:                | ']' : >
1638:                | ',' :
1640:             ]
1648:          }
      
1650:          pOf
1652:          Node baseType
1652:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1659:          int dim = oNodeVecSize( dimensions )
      
1669:          {
1669:              dec(dim)
      
1675:              Node a = oNodeVecElement( dimensions, dim )
      
1688:              oNodeSet( a, qBaseType, baseType )
1700:              Node subrange = oNodeGet( a, qIndexType )
1713:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1740:              inc( width )
1746:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1772:              oTypeAdd( a )
1778:              baseType = a
      
1784:              [ equal_zero(dim)
1791:                  | true:  >
1794:                  | *:
1799:              ]
1799:          }
      
1801:          resultType = oNodeVecElement( dimensions, 0 )
1814:          oNodeVecDelete( dimensions )
      
1820:       | '^' :
1822:          Node theType
1822:          @TypeRef( theType )
1829:          resultType = @PointerTypeTo( theType )
      
1840:       | pRecord :
1842:          resultType = oNodeNew( nRecordType )
1852:          oScopeBegin
      
1853:          @VarDecl( nRecordField )
      
1860:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1872:          [ equal_zero( size )
1879:             | true : #eRecordEmpty
1882:             | * :
1887:          ]
      
1887:          pEnd
      
1889:          oNodeSet( resultType, qScope, oScopeCurrent )
1900:          oNodeSetInt( resultType, qSize, size )
1912:          oScopeEnd
1913:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1919:       | pSet :
1921:          pOf
1923:          Node theType
1923:          @TypeRef( theType )
1930:       | * :       % this works for cases except where expr starts with an id
1943:          @ConstExpr '..' @ConstExpr
1949:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1950: ConstExpr:
1952:    [
1952:       | pIntLit :
1954:          oValuePush( TOKEN_VALUE )
1959:       | pIdent :
1961:          Node decl = oScopeFindRequire
1966:          [ oNodeType( decl )
1973:             | nConst :
1974:                oValuePush( oNodeGetInt( decl, qValue ) )
1987:             | * :
1992:                #eNotConst
1994:                oValuePush( 0 )
2000:          ]
2000:       | pMinus :
2002:          @ConstExpr
2004:          oValueNegate
2005:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2016: Expr:
2018:    Label falseLabel = labelNull
      
2024:    @ExprAllowCF( falseLabel )
2031:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2039: BooleanExprControlFlow( out Label falseLabel ):
2041:    @ExprAllowCF( falseLabel )
2048:    [ oTypeSNodeType
2050:       | nBooleanCFType :
2051:       | nBooleanType :
               % convert value to control flow
2053:          falseLabel = oLabelNew
2058:          .tJumpFalse  oEmitLabel( falseLabel )
2066:       | * :
2073:          #eNotBoolean
2075:    ]
2075:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2077: CFToVal( inout Label falseLabel ):
2079:    [ oTypeSNodeType
2081:       | nBooleanCFType :
2082:          Label doneLabel = oLabelNew
2087:          .tPushConstI  oEmitInt( 1 )
2095:          .tJump  oEmitLabel( doneLabel )
2103:          .tLabel  oEmitLabel( falseLabel )
2111:          .tPushConstI  oEmitInt( 0 )
2119:          .tLabel  oEmitLabel( doneLabel )
2127:          oTypeSPop
2128:          oTypeSPush( BooleanType )
2134:          falseLabel = labelNull
2140:       | * :
2145:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2146: ValToCF( out Label falseLabel ):
2148:    [ oTypeSNodeType
2150:       | nBooleanType :
2151:          falseLabel = oLabelNew
2156:          .tJumpFalse  oEmitLabel( falseLabel )
2164:          oTypeSPop
2165:          oTypeSPush( BooleanCFType )
2171:       | * :
2176:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2177: ExprAllowCF( out Label falseLabel ):
2179:    @BoolExprAllowCF( falseLabel )
2186:    {[
2186:       | '=' :
2188:          @CFToVal( falseLabel )
2195:          @BoolExprAllowCF( falseLabel )
2202:          @CFToVal( falseLabel )
2209:          @MatchTypes
2211:          [ oTypeSNodeType
2213:             | nIntegerType, nBooleanType :  .tEqualI
2216:             | nPointerType :                .tEqualP
2220:             | nCharType, nStringType :      #eNotImplemented
2224:             | * :                           #eNotAllowed
2239:          ]
2239:          oTypeSPop
2240:          oTypeSPush( BooleanType )
      
2246:       | '<>' :
2248:          @CFToVal( falseLabel )
2255:          @BoolExprAllowCF( falseLabel )
2262:          @CFToVal( falseLabel )
2269:          @MatchTypes
2271:          [ oTypeSNodeType
2273:             | nIntegerType, nBooleanType :  .tNotEqualI
2276:             | nPointerType :                .tNotEqualP
2280:             | nCharType, nStringType :      #eNotImplemented
2284:             | * :                           #eNotAllowed
2299:          ]
2299:          oTypeSPop
2300:          oTypeSPush( BooleanType )
      
2306:       | '<' :
2308:          @CFToVal( falseLabel )
2315:          @BoolExprAllowCF( falseLabel )
2322:          @CFToVal( falseLabel )
2329:          @MatchTypes
2331:          [ oTypeSNodeType
2333:             | nIntegerType, nBooleanType :  .tLessI
2336:             | nCharType, nStringType :      #eNotImplemented
2340:             | * :                           #eNotAllowed
2353:          ]
2353:          oTypeSPop
2354:          oTypeSPush( BooleanType )
      
2360:       | '>' :
2362:          @CFToVal( falseLabel )
2369:          @BoolExprAllowCF( falseLabel )
2376:          @CFToVal( falseLabel )
2383:          @MatchTypes
2385:          [ oTypeSNodeType
2387:             | nIntegerType, nBooleanType :  .tGreaterI
2390:             | nCharType, nStringType :      #eNotImplemented
2394:             | * :                           #eNotAllowed
2407:          ]
2407:          oTypeSPop
2408:          oTypeSPush( BooleanType )
      
2414:       | '<=' :
2416:          @CFToVal( falseLabel )
2423:          @BoolExprAllowCF( falseLabel )
2430:          @CFToVal( falseLabel )
2437:          @MatchTypes
2439:          [ oTypeSNodeType
2441:             | nIntegerType, nBooleanType :  .tLessEqualI
2444:             | nCharType, nStringType :      #eNotImplemented
2448:             | * :                           #eNotAllowed
2461:          ]
2461:          oTypeSPop
2462:          oTypeSPush( BooleanType )
      
2468:       | '>=' :
2470:          @CFToVal( falseLabel )
2477:          @BoolExprAllowCF( falseLabel )
2484:          @CFToVal( falseLabel )
2491:          @MatchTypes
2493:          [ oTypeSNodeType
2495:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2498:             | nCharType, nStringType :      #eNotImplemented
2502:             | * :                           #eNotAllowed
2515:          ]
2515:          oTypeSPop
2516:          oTypeSPush( BooleanType )
      
2522:       | * :
2537:          >
2539:    ]};
      
      
2542: BoolExprAllowCF( out Label falseLabel ):
2544:    Label trueLabel = labelNull
      
2550:    @BoolTermAllowCF( falseLabel )
2557:    {[
2557:       | pOr :
2559:          [ oTypeSNodeType
2561:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2562:                [ equal_label( trueLabel, labelNull )
2572:                   | true :  trueLabel = oLabelNew
2578:                   | * :
2583:                ]
2583:                .tJump  oEmitLabel( trueLabel )
2591:             | nBooleanType :
2593:                @ValToCF( falseLabel )
                     % We might be true here. If so, jump ahead to done
2600:                [ equal_label( trueLabel, labelNull )
2610:                   | true :  trueLabel = oLabelNew
2616:                   | * :
2621:                ]
2621:                .tJumpTrue  oEmitLabel( trueLabel )
2629:             | * : #eNotBoolean
2638:          ]
2638:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2639:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2647:          falseLabel = labelNull
2653:          @BoolTermAllowCF( falseLabel )
      
2660:          [ oTypeSNodeType
2662:             | nBooleanCFType :
2663:             | nBooleanType :
2665:                @ValToCF( falseLabel )
2672:             | * : #eNotBoolean
2681:          ]
      
2681:          oTypeSPop
2682:          oTypeSPush( BooleanCFType )
      
2688:       | * :
2693:          >
2695:    ]}
      
         % any short-circuit trues jump here to the end
2697:    [ equal_label( trueLabel, labelNull )
2707:       | false :
2708:          .tLabel  oEmitLabel( trueLabel )
2716:       | * :
2721:    ]
2722:    ;
      
      
2722: BoolTermAllowCF( out Label falseLabel ):
2724:    Label overallFalseLabel = labelNull
      
2730:    @BoolFactorAllowCF( falseLabel )
2737:    {[
2737:       | pAnd :
2739:          [ oTypeSNodeType
2741:             | nBooleanCFType :
2742:             | nBooleanType :
2744:                @ValToCF( falseLabel )
2751:             | * :
2758:                #eNotBoolean
2760:          ]
2760:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2761:          [ equal_label( overallFalseLabel, labelNull )
2771:             | true :
2772:                overallFalseLabel = oLabelNew
2777:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2791:                falseLabel = overallFalseLabel
2797:             | * :
2802:          ]
      
2802:          Label factorFalseLabel = labelNull
2808:          @BoolFactorAllowCF( factorFalseLabel )
      
2815:          [ oTypeSNodeType
2817:             | nBooleanCFType :
2818:             | nBooleanType :
2820:                @ValToCF( factorFalseLabel )
2827:             | * : #eNotBoolean
2836:          ]
2836:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2850:       | * :
2855:          >
2857:    ]};
      
2860: BoolFactorAllowCF( out Label falseLabel ):
2862:    [
2862:       | pNot :
2864:          Label factorFalseLabel = labelNull
      
2870:          @BoolFactorAllowCF( factorFalseLabel )
2877:          [ oTypeSNodeType
2879:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2880:                falseLabel = oLabelNew
2885:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2893:                .tLabel  oEmitLabel( factorFalseLabel )
      
2901:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2903:                .tNot
      
2905:             | * : #eNotBoolean
2914:          ]
      
2914:       | * :
2919:          @ArithExprAllowCF( falseLabel )
2926:    ];
      
2927: ArithExprAllowCF( out Label falseLabel ):
2929:    @TermAllowCF( falseLabel )
2936:    {[
2936:       | pPlus :
2938:          @RequireIntPop
2940:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2947:          @RequireInt
2949:          .tAddI
2951:       | pMinus :
2953:          @RequireIntPop
2955:          @TermAllowCF( falseLabel )
2962:          @RequireInt
2964:          .tSubI
2966:       | * :
2973:          >
2975:    ]};
      
2978: TermAllowCF( out Label falseLabel ):
2980:    @FactorAllowCF( falseLabel )
2987:    {[
2987:       | pTimes :
2989:          @RequireIntPop
2991:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2998:          @RequireInt
3000:          .tMultI
3002:       | pDivide :
3004:          @RequireIntPop
3006:          @FactorAllowCF( falseLabel )
3013:          @RequireInt
3015:          .tDivI
3017:       | * :
3024:          >
3026:    ]};
      
3029: FactorAllowCF( out Label falseLabel ):
3031:    [
3031:       | pPlus :
3033:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3040:          @RequireInt
3042:       | pMinus :
3044:          @PrimaryAllowCF( falseLabel )
3051:          @RequireInt
3053:          .tNegI
3055:       | * :
3062:          @PrimaryAllowCF( falseLabel )
3069:    ];
      
3070: PrimaryAllowCF( out Label falseLabel ):
3072:    [
3072:       | pIntLit :
3074:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3081:          oTypeSPush( IntegerType )
      
3087:       | '(' :
3089:          @ExprAllowCF( falseLabel )
3096:          ')'
      
3098:       | pStrLit :
3100:          int addr = oStringAllocLit     % store in global data
3105:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3113:          oTypeSPush( StringType )
      
3119:       | pIdent :
3121:          Node decl = oScopeFindRequire
3126:          Node theType
      
3126:          [ oNodeType( decl )
3133:             | nFunc :
      
3134:                @Call( decl )
      
3141:             | nConst :
3143:                theType = oNodeGet( decl, qType )
3156:                oTypeSPush( theType )
3162:                [ oTypeSNodeType
3164:                   | nIntegerType, nBooleanType :
3165:                      .tPushConstI @EmitValue( decl )
3174:                   | * :
3181:                      #eNotImplemented
3183:                ]
      
3183:             | nGlobalVar, nLocalVar, nParam :
3185:                @VarExpr( decl )
      
3192:             | * :
3205:                #eNotValue
3207:                oTypeSPush( IntegerType )
3213:          ]
      
3213:       | '@' :        % @var -- pointer to var
3215:          pIdent
      
3217:          Node decl = oScopeFindRequire
3222:          Node theType
      
3222:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3229:          theType = oTypeSTop
3234:          oTypeSPop
3235:          Node ptrType = @PointerTypeTo( theType )
3246:          oTypeSPush( ptrType )
      
3252:       | * :
3265:          #eNotValue
3267:          oTypeSPush( IntegerType )
3273:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3274: VarExpr( Node decl ):
3276:    Node theType = oNodeGet( decl, qType )
3289:    oTypeSPush( theType )
3295:    [ oTypeSNodeType
3297:       | nIntegerType :
3298:          [ oNodeType( decl )
3305:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3315:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3326:             | nParam :
3328:                [ oNodeGetBoolean( decl, qInOut )
3338:                   | true :    % VAR param points to the var.  Auto dereference.
3339:                               .tPushParamP @EmitValue( decl )
3348:                               .tFetchI
3350:                   | * :       .tPushParamI @EmitValue( decl )
3364:                ]
3364:          ]
      
3374:       | nBooleanType :
3376:          [ oNodeType( decl )
3383:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3393:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3404:             | nParam :
3406:                [ oNodeGetBoolean( decl, qInOut )
3416:                   | true :    % VAR param points to the var.  Auto derefernce.
3417:                               .tPushParamP @EmitValue( decl )
3426:                               .tFetchB
3428:                   | * :       .tPushParamB @EmitValue( decl )
3442:                ]
3442:          ]
      
3452:       | nCharType, nStringType, nFileType :
3454:          #eNotImplemented
      
3456:       | nPointerType :
3458:          [ oNodeType( decl )
3465:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3475:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3486:             | nParam :
3488:                [ oNodeGetBoolean( decl, qInOut )
3498:                   | true :    % VAR param points to the var.  Auto derefernce.
3499:                               .tPushParamP @EmitValue( decl )
3508:                               .tFetchP
3510:                   | * :       .tPushParamP @EmitValue( decl )
3524:                ]
3524:          ]
3534:          [
3534:             | '^' :             % dereferenced
3536:                oTypeSPop
3537:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3550:                @LValueIndexes
3552:                @FetchVar
3554:             | * :               % just ptr value alone
3559:          ]
      
3559:       | * :
               % compound type
               % first, push addr of start of var
3574:          [ oNodeType( decl )
3581:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3591:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3602:             | nParam :
3604:                [ oNodeGetBoolean( decl, qInOut )
3614:                   | true :    % VAR param points to the var.  Auto derefernce.
3615:                               .tPushParamP @EmitValue( decl )
3624:                   | * :       .tPushAddrParam @EmitValue( decl )
3638:                ]
3638:          ]
               % modify addr for subscripts, field references, etc
3648:          @LValueIndexes
               % get final value
3650:          @FetchVar
3652:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3653: FetchVar:
3655:    [ oTypeSNodeType
3657:       | nIntegerType :   .tFetchI
3660:       | nBooleanType :   .tFetchB
3664:       | nCharType, nStringType, nFileType : #eNotImplemented
3668:       | nPointerType :   .tFetchP
3672:       | * :              % compound type; leave as addr
3687:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3688: LValueIndexes:
3690:    {[
3690:       | '[' :       @ArraySubscripts
3694:       | '.' :       @RecordFieldRef
3698:       | '^' :       @PointerDeref
3702:       | * :         >
3713:    ]};
      
3716: ArraySubscripts:
3718:    [ oTypeSNodeType
3720:       | nArrayType :
3721:       | * :       #eNotArray
3728:    ]
3728:    {
3728:       [ oTypeSNodeType
3730:          | nArrayType :
3731:          | * :    #eTooManySubscripts
3738:       ]
      
            % low subscript of this dimension
3738:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3755:       Node baseType
3755:       baseType = oNodeGet( oTypeSTop, qBaseType )
3767:       oTypeSPop
3768:       oTypeSPush( baseType )
      
3774:       @Expr
3776:       @RequireIntPop
            % adjust for low subscript
3778:       [ equal_zero( low )
3785:          | false :
3786:             .tPushConstI oEmitInt( low ) .tSubI
3796:          | * :
3801:       ]
      
            % multiply by element size
3801:       int size = oNodeGetInt( baseType, qSize )
3814:       [ equal( size, 1 )
3824:          | false :
3825:             .tPushConstI oEmitInt( size ) .tMultI
3835:          | * :
3840:       ]
      
            % update start address
3840:       .tAddPI
3842:       [
3842:          | ']' :  >
3846:          | ',' :
3848:       ]
3856:    };
      
      
3859: RecordFieldRef:
3861:    [ oTypeSNodeType
3863:       | nRecordType :
3864:       | * :    #eNotRecord
3871:    ]
3871:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3883:    pIdent
3885:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3890:    [ oNodeType( field )
3897:       | nRecordField :
3898:       | * :   #eNotRecordField
3905:    ]
3905:    oScopeEnd
3906:    int offset = oNodeGetInt( field, qValue )
3919:    [ equal_zero( offset )
3926:       | false :
3927:          .tPushConstI oEmitInt( offset ) .tAddPI
3937:       | * :
3942:    ]
      
         % replace the type on the type stack, with the field type
3942:    oTypeSPop
3943:    oTypeSPush( oNodeGet( field, qType ) )
3957:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3957: PointerDeref:
3959:    [ oTypeSNodeType
3961:       | nPointerType :
3962:       | * :       #eNotPointer
3969:    ]
3969:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3971:    Node theType = oTypeSTop
3976:    oTypeSPop
3977:    oTypeSPush( oNodeGet( theType, qBaseType ) )
3991:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
3991: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
3993:    @MatchTypes
3996:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
3996: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
3998:    [ oNodeGetBoolean( method, qExternal )
4008:       | true :
4009:          [ oNodeGetBoolean( method, qCalled )
4019:             | false :
                     % define the label as extern
4020:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4037:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4052:             | * :
4057:          ]
4057:      | * :
4062:    ]
4062:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4074:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4087:    Node resultType
4087:    int tempOffset
      
4087:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4104:    [ isFunc
4107:       | true :
4108:          resultType = oNodeGet( method, qType )
4121:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4131:       | * :
4136:    ]
         
      
4136:    Node paramScope = oNodeGet( method, qParams )
4149:    int actualsSize = oNodeGetInt( paramScope, qSize )
4162:    [ cdecl
4165:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4174:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4184:    ]
      
4192:    Node param = oNodeGet( paramScope, qDecls )
4205:    [
4205:       | '(' :
            
4207:          {
4207:             [ oNodeNull( param )
4214:                | true : >
4217:                | * :
4222:             ]
      
4222:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4235:             .tPushAddrActual oEmitInt( offset )
4243:             oTypeSPush( oNodeGet( param, qType ) )
      
4256:             [ oNodeGetBoolean( param, qInOut )
4266:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4267:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4269:                           @MatchTypes
      
4271:                           .tAssignP
      
4273:                | false :  @Expr
4277:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4279:                           [ oTypeSNodeType
4281:                              | nIntegerType :            .tAssignI
4284:                              | nBooleanType :            .tAssignB
4288:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4292:                              | nPointerType :            .tAssignP
4296:                              | * :
                                       % compound types: copy value into actuals space
4311:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4323:                                  .tCopy  oEmitInt( size )    % multi-word copy
4331:                           ]
4331:             ]
4339:             oTypeSPop
      
4340:             oNodeNext( param )
4346:             [ oNodeNull( param )
4353:                | true :  >
4356:                | false :
4358:             ]
      
4366:             ','
4368:          }
      
4370:          ')'
      
4372:       | * :
4377:    ]
      
4377:    [ oNodeNull( param )
4384:       | false :    #eMissingParameter
4387:       | * :
4392:    ]
      
4392:    [ isFunc
4395:       | true :
               % Pass result temp as an additional VAR parameter.
4396:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4411:          .tPushAddrLocal  oEmitInt( tempOffset )
4419:          .tAssignP
4421:       | * :
4426:    ]
      
4426:    [ cdecl
4429:       | true :
4430:          .tCallCdecl  @EmitValue( method )
4439:       | false :
4441:          .tCall   @EmitValue( method )
4450:    ]
      
4458:    [ isFunc
4461:       | true :
               % push return value from temp
4462:          oTypeSPush( resultType )
4468:          .tPushAddrLocal  oEmitInt( tempOffset )
4476:          @FetchVar
4478:       | * :
4483:    ]
         
4483:    .tFreeActuals  oEmitInt( actualsSize )
4492:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4492: Statement:
4494:    [
4494:       | pWriteln :     @WritelnStmt
4498:       | pWrite :       @WriteStmt
4502:       | pReadln :      @ReadlnStmt
4506:       | pRead :        @ReadStmt
4510:       | pIf :          @IfStmt
4514:       | pWhile :       @WhileStmt
4518:       | pFor :         @ForStmt
4522:       | pRepeat :      @RepeatStmt
4526:       | pBreak :       @BreakStmt
4530:       | pContinue :    @ContinueStmt
4534:       | pBegin :       @BeginStmt
4538:       | pIdent :       @AssignOrCallStmt
4542:       | * :            % null statement : don't accept any tokens
4569:    ];
      
      
4570: AssignOrCallStmt:
4572:    Node decl = oScopeFindRequire
4577:    [ oNodeType( decl )
4584:       | nProc :                           @Call( decl )
4592:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4601:       | nFunc :                           @AssignResultStmt( decl )
4610:       | * :                               #eBadStatement
4625:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4626: AssignStmt( Node decl ):
      
4628:    @LValueVar( decl )
      
4635:    ':=' 
4637:    @Expr
4639:    @MatchTypes
4641:    [ oTypeSNodeType
4643:       | nIntegerType :            .tAssignI
4646:       | nBooleanType :            .tAssignB
4650:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4654:       | nPointerType :            .tAssignP
4658:       | * :
4673:           int size = oNodeGetInt( oTypeSTop, qSize )
4685:           .tCopy  oEmitInt( size )    % multi-word copy
4693:    ]
4693:    oTypeSPop
4695:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4695: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4697:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4713:       | false :   #eNotCurrentFunction
4716:       | * :
4721:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4721:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4736:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4749:    ':='
4751:    @Expr
4753:    @MatchTypes
4755:    [ oTypeSNodeType
4757:       | nIntegerType :            .tAssignI
4760:       | nBooleanType :            .tAssignB
4764:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4768:       | nPointerType :            .tAssignP
4772:       | * :
4787:           int size = oNodeGetInt( oTypeSTop, qSize )
4799:           .tCopy  oEmitInt( size )    % multi-word copy
4807:    ]
4807:    oTypeSPop
4809:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4809: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4811:    pIdent
4813:    Node decl = oScopeFindRequire
4818:    [ oNodeType( decl )
4825:       | nGlobalVar, nLocalVar, nParam :
4826:       | * :  #eNotVar
4837:    ]
4837:    @LValueVar( decl )
4845:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4845: LValueVar( Node decl ):
4847:    [ oNodeType( decl )
4854:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4864:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4875:       | nParam :
4877:          [ oNodeGetBoolean( decl, qInOut )
4887:             | true :   % VAR param points to variable.  No dereference.
4888:                        .tPushParamP @EmitValue( decl )
4897:             | * :      .tPushAddrParam @EmitValue( decl )
4911:          ]
4911:       | * :            #eNotVar
4922:    ]
      
4922:    oTypeSPush( oNodeGet( decl, qType ) )
4935:    @LValueIndexes        % handle subscripts, if any
4938:    ;
      
      
4938: IncVar( Node decl ):
4940:    @LValueVar( decl )
4947:    @RequireIntPop
4949:    @VarExpr( decl )
4956:    oTypeSPop
4957:    .tIncI
4959:    .tAssignI;
      
4962: DecVar( Node decl ):
4964:    @LValueVar( decl )
4971:    @RequireIntPop
4973:    @VarExpr( decl )
4980:    oTypeSPop
4981:    .tDecI
4983:    .tAssignI;
      
      
4986: IfStmt:
4988:    Label falseLabel = labelNull
      
4994:    @BooleanExprControlFlow( falseLabel )
5001:    pThen
5003:    @Statement
5005:    [
5005:       | pElse :
5007:          Label doneLabel = oLabelNew
      
5012:          .tJump  oEmitLabel( doneLabel )
5020:          .tLabel oEmitLabel( falseLabel )
5028:          @Statement
5030:          .tLabel oEmitLabel( doneLabel )
      
5038:       | * :
5043:          .tLabel oEmitLabel( falseLabel )
5051:    ];
      
      
5052: ForStmt:
5054:    pIdent
      
5056:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5061:    @LValueVar( decl )
5068:    @RequireIntPop
      
5070:    ':='
      
5072:    @Expr
5074:    @RequireIntPop
5076:    .tAssignI
      
5078:    Label breakLabel = oLabelNew
      
5083:    Label checkLabel = oLabelNew
5088:    .tJump  oEmitLabel( checkLabel )
      
5096:    Label continueLabel = oLabelNew
5101:    .tLabel  oEmitLabel( continueLabel )
5109:    [
5109:       | pTo :
5111:          @IncVar( decl )
5118:          .tLabel  oEmitLabel( checkLabel )
5126:          @VarExpr( decl )  oTypeSPop
5134:          @Expr
5136:          @RequireIntPop
5138:          .tGreaterI
5140:          .tJumpTrue  oEmitLabel( breakLabel )
5148:       | pDownto :
5150:          @DecVar( decl )
5157:          .tLabel  oEmitLabel( checkLabel )
5165:          @VarExpr( decl )  oTypeSPop
5173:          @Expr
5175:          @RequireIntPop
5177:          .tLessI
5179:          .tJumpTrue  oEmitLabel( breakLabel )
5187:    ]
5195:    oLoopPush( continueLabel, breakLabel )
5204:    pDo
5206:    @Statement
5208:    .tJump  oEmitLabel( continueLabel )
5216:    .tLabel  oEmitLabel( breakLabel )
5224:    oLoopPop;
      
      
5226: RepeatStmt:
5228:    Label continueLabel = oLabelNew
5233:    .tLabel  oEmitLabel( continueLabel )
      
5241:    Label breakLabel = oLabelNew
      
5246:    oLoopPush( continueLabel, breakLabel )
5255:    @Statement
5257:    {[
5257:       | ';' :
5259:          @Statement
5261:       | pUntil :
5263:          Label falseLabel
5263:          @BooleanExprControlFlow( falseLabel )
5270:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5284:          >
5286:    ]}
5296:    .tLabel  oEmitLabel( breakLabel )
5304:    oLoopPop;
      
      
5306: WhileStmt:
5308:    Label continueLabel = oLabelNew
5313:    .tLabel  oEmitLabel( continueLabel )
      
5321:    Label breakLabel
5321:    @BooleanExprControlFlow( breakLabel )
      
5328:    oLoopPush( continueLabel, breakLabel )
5337:    pDo
5339:    @Statement
5341:    .tJump  oEmitLabel( continueLabel )
5349:    .tLabel  oEmitLabel( breakLabel )
5357:    oLoopPop;
      
      
5359: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5361:    [ equal_label( oLoopContinueLabel, labelNull )
5370:       | true :
5371:          #eNotInALoop
5373:       | false :
5375:          .tJump  oEmitLabel( oLoopContinueLabel )
5382:    ];
      
      
5391: BreakStmt:
5393:    [ equal_label( oLoopBreakLabel, labelNull )
5402:       | true :
5403:          #eNotInALoop
5405:       | false :
5407:          .tJump  oEmitLabel( oLoopBreakLabel )
5414:    ];
      
      
5423: BeginStmt:
5425:    @Statement
5427:    {[
5427:       | ';' :   @Statement
5431:       | pEnd :  >
5435:    ]};
      
      
5446: WritelnStmt:
5448:    @WriteStmt
5450:    .tWriteCR;
      
      
5453: WriteStmt:
5455:    [
5455:       | '(' :
5457:          {
5457:             @Expr
5459:             [ oTypeSNodeType
5461:                | nIntegerType :             .tWriteI
5464:                | nBooleanType :             .tWriteBool
5468:                | nStringType :              .tWriteStr
5472:                | nCharType, nFileType :     #eNotImplemented
5476:                | nPointerType :             .tWriteP
5480:                | * :                        #eNotAllowed
5497:             ]
5497:             oTypeSPop
5498:             [
5498:                | ')' : >
5502:                | ',' :
5504:             ]
5512:          }
5514:       | * :
5519:    ];
      
      
5520: ReadlnStmt:      % ***
         % TO DO
5523:    ;
      
5523: ReadStmt:
         % TO DO
5526:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5526: MatchTypes:
5528:    node_type nt = oTypeSNodeType
5533:    oTypeSPop
5534:    [ equal_node_type( nt, oTypeSNodeType )
5543:       | false :
5544:          #eTypeMismatch
5546:       | * :
5551:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5552: RequireIntPop:
5554:    [ oTypeSNodeType
5556:       | nIntegerType :
5557:       | * :          #eNotInteger
5564:    ]
5564:    oTypeSPop;
      
5566: RequireInt:
5568:    [ oTypeSNodeType
5570:       | nIntegerType :
5571:       | * :          #eNotInteger
5578:    ];
      
5579: RequireBoolPop:
5581:    [ oTypeSNodeType
5583:       | nBooleanType :
5584:       | * :          #eNotBoolean
5591:    ]
5591:    oTypeSPop;
      
5593: RequireBool:
5595:    [ oTypeSNodeType
5597:       | nBooleanType :
5598:       | * :          #eNotBoolean
5605:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5606: newType( node_type nt, int size ) >> Node:
5608:   Node node = oNodeNew( nt )
5618:   oNodeSetInt( node, qSize, size )
5630:   oTypeAdd( node )
5636:   >> node
5640:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5640: newIdent( node_type nt, kind k, int id ) >> Node:
5642:   Node t = oNodeNew( nt )
5652:   oNodeSetInt( t, qIdent, id )
5664:   >> t
5668:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5668: PointerTypeTo( Node theType ) >> Node:
5670:    Node ptrType = oNodeGet( theType, qPointerType )
5683:    [ oNodeNull( ptrType )
5690:       | true :
5691:          ptrType = oNodeNew( nPointerType )
5701:          oNodeSet( ptrType, qBaseType, theType )
5713:          oNodeSetInt( ptrType, qSize, 8 )
5725:          oTypeAdd( ptrType )
5731:          oNodeSet( theType, qPointerType, ptrType )
5743:       | * :
5748:    ]
5748:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5752: OrdinalLow( Node theType ) >> int:
5754:    [ oNodeType( theType )
5761:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5764:       | nBooleanType :  >> 0
5769:       | nCharType :     >> 0
5774:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5786:       | * :             #eNotOrdinalType
5799:                         >> 0
5802:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5803: EmitValue( Node decl ):
5805:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5819: installBuiltIns:
      
         % install built-in types
5821:    FileType = @newType( nFileType, 4 )
5835:    IntegerType = @newType( nIntegerType, 4 )
5849:    BooleanType = @newType( nBooleanType, 1 )
5863:    BooleanCFType = @newType( nBooleanCFType, 1 )
5877:    CharType = @newType( nCharType, 1 )
5891:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5905:    Node t
      
5905:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
5921:    oNodeSet( t, qType, FileType )
5933:    oScopeDeclare( t )
      
5939:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
5955:    oNodeSet( t, qType, IntegerType )
5967:    oScopeDeclare( t )
      
5973:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
5989:    oNodeSet( t, qType, BooleanType )
6001:    oScopeDeclare( t )
      
6007:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6023:    oNodeSet( t, qType, CharType )
6035:    oScopeDeclare( t )
      
6041:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6057:    oNodeSet( t, qType, StringType )
6069:    oScopeDeclare( t )
      
         % Built-in constants
      
6075:    t = @newIdent( nConst, kConst, oIdAdd_True )
6091:    oNodeSet( t, qType, BooleanType )
6103:    oNodeSetInt( t, qValue, 1 )
6115:    oScopeDeclare( t )
      
6121:    t = @newIdent( nConst, kConst, oIdAdd_False )
6137:    oNodeSet( t, qType, BooleanType )
6149:    oNodeSetInt( t, qValue, 0 )
6161:    oScopeDeclare( t )
      
6168:    ;
      
6168: end
      
6168: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5819
  12: oGetAddrLocal 2
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 41
  19: oGetLocal 2
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 43
  27: oInput 27
  29: oInput 0
  31: oGetAddrLocal 3
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 5640
  44: oPop 3
  46: oAssign
  47: oGetLocal 3
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 1
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 5640
  70: oPop 3
  72: oAssign
  73: oGetLocal 1
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 1
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 1
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 5640
 108: oPop 3
 110: oAssign
 111: oGetLocal 1
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 1
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 3
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 2
 170: oPushResult
 171: oCall 247
 173: oPop 1
 175: oScopeEnd
 176: oInput 19
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 247
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 1209
 203: oJumpForward 239
 205: oCall 1281
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 1340
 214: oPop 1
 216: oJumpForward 239
 218: oCall 351
 220: oJumpForward 239
 222: oCall 636
 224: oJumpForward 239
 226: Choice Lookup Table
          29    222
          28    218
          32    209
          31    205
          30    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oCall 244
 243: oReturn
 244: oLocalSpace 0
 246: oReturn
 247: oLocalSpace 2
 249: oEmit 48
 251: oGetParam 1
 253: oPushResult
 254: oEmitLabel
 255: oPop 1
 257: oEmit 44
 259: oGetAddrLocal 1
 261: oPushResult
 262: Here
 263: oAssign
 264: oEmit 56
 266: oCall 4492
 268: oEmit 43
 270: oGetAddrLocal 2
 272: oPushResult
 273: oScopeCurrent
 274: oPushResult
 275: oSetResult 2
 277: oPushResult
 278: oNodeGetInt
 279: oPop 2
 281: oAssign
 282: oGetLocal 1
 284: oPushResult
 285: oGetLocal 2
 287: oPushResult
 288: oPatch
 289: oPop 2
 291: oReturn
 292: oLocalSpace 0
 294: oInputChoice 312
 296: oGetParam 1
 298: oPushResult
 299: oSetResult 12
 301: oPushResult
 302: oSetResult 1
 304: oPushResult
 305: oNodeSetBoolean
 306: oPop 3
 308: oInput 4
 310: oJumpForward 317
 312: Choice Lookup Table
          62    296
 315: oJumpForward 319
 317: oJumpBack 294
 319: oReturn
 320: oLocalSpace 0
 322: oGetParam 1
 324: oPushResult
 325: oSetResult 11
 327: oPushResult
 328: oSetResult 1
 330: oPushResult
 331: oNodeSetBoolean
 332: oPop 3
 334: oInputChoice 347
 336: oInputChoice 342
 338: oInput 2
 340: oJumpForward 345
 342: Choice Lookup Table
          61    338
 345: oJumpForward 350
 347: Choice Lookup Table
           2    336
 350: oReturn
 351: oLocalSpace 4
 353: oInput 0
 355: oGetAddrLocal 1
 357: oPushResult
 358: oSetResult 0
 360: oAssign
 361: oGetAddrLocal 2
 363: oPushResult
 364: oScopeFindInCurrentScope
 365: oAssign
 366: oGetLocal 2
 368: oPushResult
 369: oNodeNull
 370: oPop 1
 372: oChoice 493
 374: oGetAddrLocal 2
 376: oPushResult
 377: oSetResult 7
 379: oPushResult
 380: oSetResult 2
 382: oPushResult
 383: LAST_ID
 384: oPushResult
 385: oCall 5640
 387: oPop 3
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oSetResult 6
 395: oPushResult
 396: oLabelNew
 397: oPushResult
 398: oNodeSetLabel
 399: oPop 3
 401: oJumpForward 499
 403: oGetAddrLocal 1
 405: oPushResult
 406: oSetResult 1
 408: oAssign
 409: oGetLocal 2
 411: oPushResult
 412: oSetResult 10
 414: oPushResult
 415: oNodeGetBoolean
 416: oPop 2
 418: oChoice 424
 420: oError 21
 422: oJumpForward 427
 424: Choice Lookup Table
           1    420
 427: oGetLocal 2
 429: oPushResult
 430: oSetResult 11
 432: oPushResult
 433: oNodeGetBoolean
 434: oPop 2
 436: oChoice 442
 438: oError 21
 440: oJumpForward 445
 442: Choice Lookup Table
           1    438
 445: oGetLocal 2
 447: oPushResult
 448: oNodeType
 449: oPop 1
 451: oChoice 455
 453: oJumpForward 460
 455: Choice Lookup Table
           7    453
 458: oError 21
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 14
 465: oPushResult
 466: oGetLocal 2
 468: oPushResult
 469: oSetResult 8
 471: oPushResult
 472: oNodeGet
 473: oPop 2
 475: oPushResult
 476: oNodeSet
 477: oPop 3
 479: oGetLocal 2
 481: oPushResult
 482: oSetResult 8
 484: oPushResult
 485: oSetResult 0
 487: oPushResult
 488: oNodeSet
 489: oPop 3
 491: oJumpForward 499
 493: Choice Lookup Table
           0    403
           1    374
 498: oEndChoice
 499: oScopeBegin
 500: oGetAddrLocal 3
 502: oPushResult
 503: oScopeCurrent
 504: oAssign
 505: oCall 982
 507: oGetLocal 2
 509: oPushResult
 510: oSetResult 8
 512: oPushResult
 513: oGetLocal 3
 515: oPushResult
 516: oNodeSet
 517: oPop 3
 519: oScopeEnd
 520: oInput 4
 522: oGetLocal 1
 524: oChoice 536
 526: oGetLocal 2
 528: oPushResult
 529: oScopeDeclare
 530: oPop 1
 532: oJumpForward 542
 534: oJumpForward 542
 536: Choice Lookup Table
           1    534
           0    526
 541: oEndChoice
 542: oGetLocal 2
 544: oPushResult
 545: oCall 292
 547: oPop 1
 549: oInputChoice 562
 551: oJumpForward 633
 553: oGetLocal 2
 555: oPushResult
 556: oCall 320
 558: oPop 1
 560: oJumpForward 633
 562: Choice Lookup Table
          60    553
          59    551
 567: oGetLocal 3
 569: oPushResult
 570: oScopeEnter
 571: oPop 1
 573: oScopeBegin
 574: oScopeCurrent
 575: oPushResult
 576: oSetResult 3
 578: oPushResult
 579: oSetResult 1
 581: oPushResult
 582: oNodeSetBoolean
 583: oPop 3
 585: oGetLocal 2
 587: oPushResult
 588: oSetResult 9
 590: oPushResult
 591: oScopeCurrent
 592: oPushResult
 593: oNodeSet
 594: oPop 3
 596: oGetAddrLocal 4
 598: oPushResult
 599: oGetLocal 2
 601: oPushResult
 602: oSetResult 6
 604: oPushResult
 605: oNodeGetLabel
 606: oPop 2
 608: oAssign
 609: oSetResult 13
 611: oPushResult
 612: oGetLocal 4
 614: oPushResult
 615: oCall 180
 617: oPop 2
 619: oGetLocal 2
 621: oPushResult
 622: oSetResult 10
 624: oPushResult
 625: oSetResult 1
 627: oPushResult
 628: oNodeSetBoolean
 629: oPop 3
 631: oScopeEnd
 632: oScopeEnd
 633: oInput 4
 635: oReturn
 636: oLocalSpace 6
 638: oInput 0
 640: oGetAddrLocal 1
 642: oPushResult
 643: oSetResult 0
 645: oAssign
 646: oGetAddrLocal 2
 648: oPushResult
 649: oScopeFindInCurrentScope
 650: oAssign
 651: oGetLocal 2
 653: oPushResult
 654: oNodeNull
 655: oPop 1
 657: oChoice 791
 659: oGetAddrLocal 2
 661: oPushResult
 662: oSetResult 8
 664: oPushResult
 665: oSetResult 3
 667: oPushResult
 668: LAST_ID
 669: oPushResult
 670: oCall 5640
 672: oPop 3
 674: oAssign
 675: oGetLocal 2
 677: oPushResult
 678: oSetResult 6
 680: oPushResult
 681: oLabelNew
 682: oPushResult
 683: oNodeSetLabel
 684: oPop 3
 686: oJumpForward 797
 688: oGetAddrLocal 1
 690: oPushResult
 691: oSetResult 1
 693: oAssign
 694: oGetLocal 2
 696: oPushResult
 697: oSetResult 10
 699: oPushResult
 700: oNodeGetBoolean
 701: oPop 2
 703: oChoice 709
 705: oError 21
 707: oJumpForward 712
 709: Choice Lookup Table
           1    705
 712: oGetLocal 2
 714: oPushResult
 715: oNodeType
 716: oPop 1
 718: oChoice 722
 720: oJumpForward 727
 722: Choice Lookup Table
           8    720
 725: oError 21
 727: oGetLocal 2
 729: oPushResult
 730: oSetResult 14
 732: oPushResult
 733: oGetLocal 2
 735: oPushResult
 736: oSetResult 8
 738: oPushResult
 739: oNodeGet
 740: oPop 2
 742: oPushResult
 743: oNodeSet
 744: oPop 3
 746: oGetLocal 2
 748: oPushResult
 749: oSetResult 8
 751: oPushResult
 752: oSetResult 0
 754: oPushResult
 755: oNodeSet
 756: oPop 3
 758: oGetLocal 2
 760: oPushResult
 761: oSetResult 15
 763: oPushResult
 764: oGetLocal 2
 766: oPushResult
 767: oSetResult 5
 769: oPushResult
 770: oNodeGet
 771: oPop 2
 773: oPushResult
 774: oNodeSet
 775: oPop 3
 777: oGetLocal 2
 779: oPushResult
 780: oSetResult 5
 782: oPushResult
 783: oSetResult 0
 785: oPushResult
 786: oNodeSet
 787: oPop 3
 789: oJumpForward 797
 791: Choice Lookup Table
           0    688
           1    659
 796: oEndChoice
 797: oScopeBegin
 798: oGetAddrLocal 3
 800: oPushResult
 801: oScopeCurrent
 802: oAssign
 803: oCall 982
 805: oGetLocal 2
 807: oPushResult
 808: oSetResult 8
 810: oPushResult
 811: oGetLocal 3
 813: oPushResult
 814: oNodeSet
 815: oPop 3
 817: oInput 11
 819: oGetAddrLocal 4
 821: oPushResult
 822: oCall 1481
 824: oPop 1
 826: oGetLocal 2
 828: oPushResult
 829: oSetResult 5
 831: oPushResult
 832: oGetLocal 4
 834: oPushResult
 835: oNodeSet
 836: oPop 3
 838: oGetAddrLocal 5
 840: oPushResult
 841: oGetLocal 4
 843: oPushResult
 844: oCall 5668
 846: oPop 1
 848: oAssign
 849: oGetLocal 2
 851: oPushResult
 852: oSetResult 16
 854: oPushResult
 855: oGetLocal 5
 857: oPushResult
 858: oScopeAllocType
 859: oPop 1
 861: oPushResult
 862: oNodeSetInt
 863: oPop 3
 865: oScopeEnd
 866: oInput 4
 868: oGetLocal 1
 870: oChoice 882
 872: oGetLocal 2
 874: oPushResult
 875: oScopeDeclare
 876: oPop 1
 878: oJumpForward 888
 880: oJumpForward 888
 882: Choice Lookup Table
           1    880
           0    872
 887: oEndChoice
 888: oGetLocal 2
 890: oPushResult
 891: oCall 292
 893: oPop 1
 895: oInputChoice 908
 897: oJumpForward 979
 899: oGetLocal 2
 901: oPushResult
 902: oCall 320
 904: oPop 1
 906: oJumpForward 979
 908: Choice Lookup Table
          60    899
          59    897
 913: oGetLocal 3
 915: oPushResult
 916: oScopeEnter
 917: oPop 1
 919: oScopeBegin
 920: oScopeCurrent
 921: oPushResult
 922: oSetResult 3
 924: oPushResult
 925: oSetResult 1
 927: oPushResult
 928: oNodeSetBoolean
 929: oPop 3
 931: oGetLocal 2
 933: oPushResult
 934: oSetResult 9
 936: oPushResult
 937: oScopeCurrent
 938: oPushResult
 939: oNodeSet
 940: oPop 3
 942: oGetAddrLocal 6
 944: oPushResult
 945: oGetLocal 2
 947: oPushResult
 948: oSetResult 6
 950: oPushResult
 951: oNodeGetLabel
 952: oPop 2
 954: oAssign
 955: oSetResult 13
 957: oPushResult
 958: oGetLocal 6
 960: oPushResult
 961: oCall 180
 963: oPop 2
 965: oGetLocal 2
 967: oPushResult
 968: oSetResult 10
 970: oPushResult
 971: oSetResult 1
 973: oPushResult
 974: oNodeSetBoolean
 975: oPop 3
 977: oScopeEnd
 978: oScopeEnd
 979: oInput 4
 981: oReturn
 982: oLocalSpace 6
 984: oInputChoice 1205
 986: oGetAddrLocal 1
 988: oPushResult
 989: oNodeVecNew
 990: oAssign
 991: oGetAddrLocal 3
 993: oPushResult
 994: oSetResult 0
 996: oAssign
 997: oInputChoice 1007
 999: oGetAddrLocal 3
1001: oPushResult
1002: oSetResult 1
1004: oAssign
1005: oJumpForward 1010
1007: Choice Lookup Table
          32    999
1010: oInput 0
1012: oGetAddrLocal 2
1014: oPushResult
1015: oSetResult 15
1017: oPushResult
1018: oSetResult 6
1020: oPushResult
1021: LAST_ID
1022: oPushResult
1023: oCall 5640
1025: oPop 3
1027: oAssign
1028: oGetLocal 2
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oGetLocal 3
1036: oPushResult
1037: oNodeSetBoolean
1038: oPop 3
1040: oGetLocal 1
1042: oPushResult
1043: oGetLocal 2
1045: oPushResult
1046: oNodeVecAppend
1047: oPop 2
1049: oInputChoice 1057
1051: oJumpForward 1065
1053: oJumpForward 1063
1055: oJumpForward 1063
1057: Choice Lookup Table
          12   1055
          11   1051
1062: oEndChoice
1063: oJumpBack 1010
1065: oGetAddrLocal 4
1067: oPushResult
1068: oCall 1481
1070: oPop 1
1072: oGetLocal 3
1074: oChoice 1089
1076: oGetAddrLocal 5
1078: oPushResult
1079: oGetLocal 4
1081: oPushResult
1082: oCall 5668
1084: oPop 1
1086: oAssign
1087: oJumpForward 1098
1089: Choice Lookup Table
           1   1076
1092: oGetAddrLocal 5
1094: oPushResult
1095: oGetLocal 4
1097: oAssign
1098: oGetAddrLocal 6
1100: oPushResult
1101: oSetResult 0
1103: oAssign
1104: oGetLocal 6
1106: oPushResult
1107: oGetLocal 1
1109: oPushResult
1110: oNodeVecSize
1111: oPop 1
1113: oPushResult
1114: equal
1115: oPop 2
1117: oChoice 1174
1119: oGetAddrLocal 2
1121: oPushResult
1122: oGetLocal 1
1124: oPushResult
1125: oGetLocal 6
1127: oPushResult
1128: oNodeVecElement
1129: oPop 2
1131: oAssign
1132: oGetLocal 2
1134: oPushResult
1135: oSetResult 5
1137: oPushResult
1138: oGetLocal 4
1140: oPushResult
1141: oNodeSet
1142: oPop 3
1144: oGetLocal 2
1146: oPushResult
1147: oScopeDeclare
1148: oPop 1
1150: oGetLocal 2
1152: oPushResult
1153: oSetResult 6
1155: oPushResult
1156: oGetLocal 5
1158: oPushResult
1159: oScopeAllocType
1160: oPop 1
1162: oPushResult
1163: oNodeSetInt
1164: oPop 3
1166: oGetAddrLocal 6
1168: oPushResult
1169: inc
1170: oPop 1
1172: oJumpForward 1179
1174: Choice Lookup Table
           0   1119
1177: oJumpForward 1181
1179: oJumpBack 1104
1181: oGetLocal 1
1183: oPushResult
1184: oNodeVecDelete
1185: oPop 1
1187: oInputChoice 1195
1189: oJumpForward 1203
1191: oJumpForward 1201
1193: oJumpForward 1201
1195: Choice Lookup Table
           4   1193
          14   1189
1200: oEndChoice
1201: oJumpBack 986
1203: oJumpForward 1208
1205: Choice Lookup Table
          13    986
1208: oReturn
1209: oLocalSpace 2
1211: oInputChoice 1273
1213: oGetAddrLocal 1
1215: oPushResult
1216: oSetResult 9
1218: oPushResult
1219: oSetResult 4
1221: oPushResult
1222: LAST_ID
1223: oPushResult
1224: oCall 5640
1226: oPop 3
1228: oAssign
1229: oInput 5
1231: oCall 1950
1233: oGetAddrLocal 2
1235: oPushResult
1236: oValueTop
1237: oAssign
1238: oValuePop
1239: oGetLocal 1
1241: oPushResult
1242: oSetResult 6
1244: oPushResult
1245: oGetLocal 2
1247: oPushResult
1248: oNodeSetInt
1249: oPop 3
1251: oGetLocal 1
1253: oPushResult
1254: oSetResult 5
1256: oPushResult
1257: oGetGlobal 3
1259: oPushResult
1260: oNodeSet
1261: oPop 3
1263: oGetLocal 1
1265: oPushResult
1266: oScopeDeclare
1267: oPop 1
1269: oInput 4
1271: oJumpForward 1278
1273: Choice Lookup Table
           0   1213
1276: oJumpForward 1280
1278: oJumpBack 1211
1280: oReturn
1281: oLocalSpace 2
1283: oInputChoice 1332
1285: oGetAddrLocal 1
1287: oPushResult
1288: oSetResult 10
1290: oPushResult
1291: oSetResult 5
1293: oPushResult
1294: LAST_ID
1295: oPushResult
1296: oCall 5640
1298: oPop 3
1300: oAssign
1301: oInput 5
1303: oGetAddrLocal 2
1305: oPushResult
1306: oCall 1481
1308: oPop 1
1310: oGetLocal 1
1312: oPushResult
1313: oSetResult 5
1315: oPushResult
1316: oGetLocal 2
1318: oPushResult
1319: oNodeSet
1320: oPop 3
1322: oGetLocal 1
1324: oPushResult
1325: oScopeDeclare
1326: oPop 1
1328: oInput 4
1330: oJumpForward 1337
1332: Choice Lookup Table
           0   1285
1335: oJumpForward 1339
1337: oJumpBack 1283
1339: oReturn
1340: oLocalSpace 4
1342: oInputChoice 1473
1344: oGetAddrLocal 1
1346: oPushResult
1347: oNodeVecNew
1348: oAssign
1349: oGetAddrLocal 2
1351: oPushResult
1352: oGetParam 1
1354: oPushResult
1355: oSetResult 6
1357: oPushResult
1358: LAST_ID
1359: oPushResult
1360: oCall 5640
1362: oPop 3
1364: oAssign
1365: oGetLocal 1
1367: oPushResult
1368: oGetLocal 2
1370: oPushResult
1371: oNodeVecAppend
1372: oPop 2
1374: oInputChoice 1380
1376: oInput 0
1378: oJumpForward 1385
1380: Choice Lookup Table
          12   1376
1383: oJumpForward 1387
1385: oJumpBack 1349
1387: oInput 11
1389: oGetAddrLocal 3
1391: oPushResult
1392: oCall 1481
1394: oPop 1
1396: oGetAddrLocal 4
1398: oPushResult
1399: oSetResult 0
1401: oAssign
1402: oGetLocal 4
1404: oPushResult
1405: oGetLocal 1
1407: oPushResult
1408: oNodeVecSize
1409: oPop 1
1411: oPushResult
1412: equal
1413: oPop 2
1415: oChoice 1456
1417: oGetAddrLocal 2
1419: oPushResult
1420: oGetLocal 1
1422: oPushResult
1423: oGetLocal 4
1425: oPushResult
1426: oNodeVecElement
1427: oPop 2
1429: oAssign
1430: oGetLocal 2
1432: oPushResult
1433: oSetResult 5
1435: oPushResult
1436: oGetLocal 3
1438: oPushResult
1439: oNodeSet
1440: oPop 3
1442: oGetLocal 2
1444: oPushResult
1445: oScopeDeclareAlloc
1446: oPop 1
1448: oGetAddrLocal 4
1450: oPushResult
1451: inc
1452: oPop 1
1454: oJumpForward 1461
1456: Choice Lookup Table
           0   1417
1459: oJumpForward 1463
1461: oJumpBack 1402
1463: oGetLocal 1
1465: oPushResult
1466: oNodeVecDelete
1467: oPop 1
1469: oInput 4
1471: oJumpForward 1478
1473: Choice Lookup Table
           0   1344
1476: oJumpForward 1480
1478: oJumpBack 1342
1480: oReturn
1481: oLocalSpace 12
1483: oInputChoice 1932
1485: oGetAddrLocal 1
1487: oPushResult
1488: oScopeFindRequire
1489: oAssign
1490: oGetLocal 1
1492: oPushResult
1493: oNodeType
1494: oPop 1
1496: oChoice 1513
1498: oGetParam 1
1500: oPushResult
1501: oGetLocal 1
1503: oPushResult
1504: oSetResult 5
1506: oPushResult
1507: oNodeGet
1508: oPop 2
1510: oAssign
1511: oJumpForward 1524
1513: Choice Lookup Table
          10   1498
1516: oError 2
1518: oGetParam 1
1520: oPushResult
1521: oGetGlobal 3
1523: oAssign
1524: oJumpForward 1949
1526: oInput 15
1528: oGetAddrLocal 2
1530: oPushResult
1531: oNodeVecNew
1532: oAssign
1533: oGetAddrLocal 3
1535: oPushResult
1536: oSetResult 25
1538: oPushResult
1539: oNodeNew
1540: oPop 1
1542: oAssign
1543: oGetLocal 3
1545: oPushResult
1546: oSetResult 19
1548: oPushResult
1549: oGetGlobal 3
1551: oPushResult
1552: oNodeSet
1553: oPop 3
1555: oCall 1950
1557: oGetLocal 3
1559: oPushResult
1560: oSetResult 21
1562: oPushResult
1563: oValueTop
1564: oPushResult
1565: oNodeSetInt
1566: oPop 3
1568: oValuePop
1569: oInput 20
1571: oCall 1950
1573: oGetLocal 3
1575: oPushResult
1576: oSetResult 22
1578: oPushResult
1579: oValueTop
1580: oPushResult
1581: oNodeSetInt
1582: oPop 3
1584: oValuePop
1585: oGetLocal 3
1587: oPushResult
1588: oSetResult 2
1590: oPushResult
1591: oSetResult 4
1593: oPushResult
1594: oNodeSetInt
1595: oPop 3
1597: oGetLocal 3
1599: oPushResult
1600: oTypeAdd
1601: oPop 1
1603: oGetAddrLocal 4
1605: oPushResult
1606: oSetResult 24
1608: oPushResult
1609: oNodeNew
1610: oPop 1
1612: oAssign
1613: oGetLocal 4
1615: oPushResult
1616: oSetResult 20
1618: oPushResult
1619: oGetLocal 3
1621: oPushResult
1622: oNodeSet
1623: oPop 3
1625: oGetLocal 2
1627: oPushResult
1628: oGetLocal 4
1630: oPushResult
1631: oNodeVecAppend
1632: oPop 2
1634: oInputChoice 1642
1636: oJumpForward 1650
1638: oJumpForward 1648
1640: oJumpForward 1648
1642: Choice Lookup Table
          12   1640
          16   1636
1647: oEndChoice
1648: oJumpBack 1533
1650: oInput 38
1652: oGetAddrLocal 5
1654: oPushResult
1655: oCall 1481
1657: oPop 1
1659: oGetAddrLocal 6
1661: oPushResult
1662: oGetLocal 2
1664: oPushResult
1665: oNodeVecSize
1666: oPop 1
1668: oAssign
1669: oGetAddrLocal 6
1671: oPushResult
1672: dec
1673: oPop 1
1675: oGetAddrLocal 7
1677: oPushResult
1678: oGetLocal 2
1680: oPushResult
1681: oGetLocal 6
1683: oPushResult
1684: oNodeVecElement
1685: oPop 2
1687: oAssign
1688: oGetLocal 7
1690: oPushResult
1691: oSetResult 19
1693: oPushResult
1694: oGetLocal 5
1696: oPushResult
1697: oNodeSet
1698: oPop 3
1700: oGetAddrLocal 8
1702: oPushResult
1703: oGetLocal 7
1705: oPushResult
1706: oSetResult 20
1708: oPushResult
1709: oNodeGet
1710: oPop 2
1712: oAssign
1713: oGetAddrLocal 9
1715: oPushResult
1716: oGetLocal 8
1718: oPushResult
1719: oSetResult 22
1721: oPushResult
1722: oNodeGetInt
1723: oPop 2
1725: oPushResult
1726: oGetLocal 8
1728: oPushResult
1729: oSetResult 21
1731: oPushResult
1732: oNodeGetInt
1733: oPop 2
1735: oPushResult
1736: subtract
1737: oPop 2
1739: oAssign
1740: oGetAddrLocal 9
1742: oPushResult
1743: inc
1744: oPop 1
1746: oGetLocal 7
1748: oPushResult
1749: oSetResult 2
1751: oPushResult
1752: oGetLocal 9
1754: oPushResult
1755: oGetLocal 5
1757: oPushResult
1758: oSetResult 2
1760: oPushResult
1761: oNodeGetInt
1762: oPop 2
1764: oPushResult
1765: multiply
1766: oPop 2
1768: oPushResult
1769: oNodeSetInt
1770: oPop 3
1772: oGetLocal 7
1774: oPushResult
1775: oTypeAdd
1776: oPop 1
1778: oGetAddrLocal 5
1780: oPushResult
1781: oGetLocal 7
1783: oAssign
1784: oGetLocal 6
1786: oPushResult
1787: equal_zero
1788: oPop 1
1790: oChoice 1796
1792: oJumpForward 1801
1794: oJumpForward 1799
1796: Choice Lookup Table
           1   1792
1799: oJumpBack 1669
1801: oGetParam 1
1803: oPushResult
1804: oGetLocal 2
1806: oPushResult
1807: oSetResult 0
1809: oPushResult
1810: oNodeVecElement
1811: oPop 2
1813: oAssign
1814: oGetLocal 2
1816: oPushResult
1817: oNodeVecDelete
1818: oPop 1
1820: oJumpForward 1949
1822: oGetAddrLocal 10
1824: oPushResult
1825: oCall 1481
1827: oPop 1
1829: oGetParam 1
1831: oPushResult
1832: oGetLocal 10
1834: oPushResult
1835: oCall 5668
1837: oPop 1
1839: oAssign
1840: oJumpForward 1949
1842: oGetParam 1
1844: oPushResult
1845: oSetResult 26
1847: oPushResult
1848: oNodeNew
1849: oPop 1
1851: oAssign
1852: oScopeBegin
1853: oSetResult 14
1855: oPushResult
1856: oCall 1340
1858: oPop 1
1860: oGetAddrLocal 11
1862: oPushResult
1863: oScopeCurrent
1864: oPushResult
1865: oSetResult 2
1867: oPushResult
1868: oNodeGetInt
1869: oPop 2
1871: oAssign
1872: oGetLocal 11
1874: oPushResult
1875: equal_zero
1876: oPop 1
1878: oChoice 1884
1880: oError 19
1882: oJumpForward 1887
1884: Choice Lookup Table
           1   1880
1887: oInput 34
1889: oGetFromParam 1
1891: oPushResult
1892: oSetResult 23
1894: oPushResult
1895: oScopeCurrent
1896: oPushResult
1897: oNodeSet
1898: oPop 3
1900: oGetFromParam 1
1902: oPushResult
1903: oSetResult 2
1905: oPushResult
1906: oGetLocal 11
1908: oPushResult
1909: oNodeSetInt
1910: oPop 3
1912: oScopeEnd
1913: oGetFromParam 1
1915: oPushResult
1916: oTypeAdd
1917: oPop 1
1919: oJumpForward 1949
1921: oInput 38
1923: oGetAddrLocal 12
1925: oPushResult
1926: oCall 1481
1928: oPop 1
1930: oJumpForward 1949
1932: Choice Lookup Table
          37   1921
          36   1842
          17   1822
          35   1526
           0   1485
1943: oCall 1950
1945: oInput 20
1947: oCall 1950
1949: oReturn
1950: oLocalSpace 1
1952: oInputChoice 2007
1954: TOKEN_VALUE
1955: oPushResult
1956: oValuePush
1957: oPop 1
1959: oJumpForward 2015
1961: oGetAddrLocal 1
1963: oPushResult
1964: oScopeFindRequire
1965: oAssign
1966: oGetLocal 1
1968: oPushResult
1969: oNodeType
1970: oPop 1
1972: oChoice 1989
1974: oGetLocal 1
1976: oPushResult
1977: oSetResult 6
1979: oPushResult
1980: oNodeGetInt
1981: oPop 2
1983: oPushResult
1984: oValuePush
1985: oPop 1
1987: oJumpForward 2000
1989: Choice Lookup Table
           9   1974
1992: oError 1
1994: oSetResult 0
1996: oPushResult
1997: oValuePush
1998: oPop 1
2000: oJumpForward 2015
2002: oCall 1950
2004: oValueNegate
2005: oJumpForward 2015
2007: Choice Lookup Table
          24   2002
           0   1961
           1   1954
2014: oEndChoice
2015: oReturn
2016: oLocalSpace 1
2018: oGetAddrLocal 1
2020: oPushResult
2021: oSetResult 0
2023: oAssign
2024: oGetAddrLocal 1
2026: oPushResult
2027: oCall 2177
2029: oPop 1
2031: oGetAddrLocal 1
2033: oPushResult
2034: oCall 2077
2036: oPop 1
2038: oReturn
2039: oLocalSpace 0
2041: oGetParam 1
2043: oPushResult
2044: oCall 2177
2046: oPop 1
2048: oTypeSNodeType
2049: oChoice 2068
2051: oJumpForward 2075
2053: oGetParam 1
2055: oPushResult
2056: oLabelNew
2057: oAssign
2058: oEmit 47
2060: oGetFromParam 1
2062: oPushResult
2063: oEmitLabel
2064: oPop 1
2066: oJumpForward 2075
2068: Choice Lookup Table
          19   2053
          20   2051
2073: oError 8
2075: oTypeSPop
2076: oReturn
2077: oLocalSpace 1
2079: oTypeSNodeType
2080: oChoice 2142
2082: oGetAddrLocal 1
2084: oPushResult
2085: oLabelNew
2086: oAssign
2087: oEmit 9
2089: oSetResult 1
2091: oPushResult
2092: oEmitInt
2093: oPop 1
2095: oEmit 45
2097: oGetLocal 1
2099: oPushResult
2100: oEmitLabel
2101: oPop 1
2103: oEmit 48
2105: oGetFromParam 1
2107: oPushResult
2108: oEmitLabel
2109: oPop 1
2111: oEmit 9
2113: oSetResult 0
2115: oPushResult
2116: oEmitInt
2117: oPop 1
2119: oEmit 48
2121: oGetLocal 1
2123: oPushResult
2124: oEmitLabel
2125: oPop 1
2127: oTypeSPop
2128: oGetGlobal 4
2130: oPushResult
2131: oTypeSPush
2132: oPop 1
2134: oGetParam 1
2136: oPushResult
2137: oSetResult 0
2139: oAssign
2140: oJumpForward 2145
2142: Choice Lookup Table
          20   2082
2145: oReturn
2146: oLocalSpace 0
2148: oTypeSNodeType
2149: oChoice 2173
2151: oGetParam 1
2153: oPushResult
2154: oLabelNew
2155: oAssign
2156: oEmit 47
2158: oGetFromParam 1
2160: oPushResult
2161: oEmitLabel
2162: oPop 1
2164: oTypeSPop
2165: oGetGlobal 5
2167: oPushResult
2168: oTypeSPush
2169: oPop 1
2171: oJumpForward 2176
2173: Choice Lookup Table
          19   2151
2176: oReturn
2177: oLocalSpace 0
2179: oGetParam 1
2181: oPushResult
2182: oCall 2542
2184: oPop 1
2186: oInputChoice 2524
2188: oGetParam 1
2190: oPushResult
2191: oCall 2077
2193: oPop 1
2195: oGetParam 1
2197: oPushResult
2198: oCall 2542
2200: oPop 1
2202: oGetParam 1
2204: oPushResult
2205: oCall 2077
2207: oPop 1
2209: oCall 5526
2211: oTypeSNodeType
2212: oChoice 2226
2214: oEmit 30
2216: oJumpForward 2239
2218: oEmit 36
2220: oJumpForward 2239
2222: oError 16
2224: oJumpForward 2239
2226: Choice Lookup Table
          22   2222
          21   2222
          23   2218
          19   2214
          18   2214
2237: oError 17
2239: oTypeSPop
2240: oGetGlobal 4
2242: oPushResult
2243: oTypeSPush
2244: oPop 1
2246: oJumpForward 2539
2248: oGetParam 1
2250: oPushResult
2251: oCall 2077
2253: oPop 1
2255: oGetParam 1
2257: oPushResult
2258: oCall 2542
2260: oPop 1
2262: oGetParam 1
2264: oPushResult
2265: oCall 2077
2267: oPop 1
2269: oCall 5526
2271: oTypeSNodeType
2272: oChoice 2286
2274: oEmit 31
2276: oJumpForward 2299
2278: oEmit 37
2280: oJumpForward 2299
2282: oError 16
2284: oJumpForward 2299
2286: Choice Lookup Table
          22   2282
          21   2282
          23   2278
          19   2274
          18   2274
2297: oError 17
2299: oTypeSPop
2300: oGetGlobal 4
2302: oPushResult
2303: oTypeSPush
2304: oPop 1
2306: oJumpForward 2539
2308: oGetParam 1
2310: oPushResult
2311: oCall 2077
2313: oPop 1
2315: oGetParam 1
2317: oPushResult
2318: oCall 2542
2320: oPop 1
2322: oGetParam 1
2324: oPushResult
2325: oCall 2077
2327: oPop 1
2329: oCall 5526
2331: oTypeSNodeType
2332: oChoice 2342
2334: oEmit 33
2336: oJumpForward 2353
2338: oError 16
2340: oJumpForward 2353
2342: Choice Lookup Table
          22   2338
          21   2338
          19   2334
          18   2334
2351: oError 17
2353: oTypeSPop
2354: oGetGlobal 4
2356: oPushResult
2357: oTypeSPush
2358: oPop 1
2360: oJumpForward 2539
2362: oGetParam 1
2364: oPushResult
2365: oCall 2077
2367: oPop 1
2369: oGetParam 1
2371: oPushResult
2372: oCall 2542
2374: oPop 1
2376: oGetParam 1
2378: oPushResult
2379: oCall 2077
2381: oPop 1
2383: oCall 5526
2385: oTypeSNodeType
2386: oChoice 2396
2388: oEmit 32
2390: oJumpForward 2407
2392: oError 16
2394: oJumpForward 2407
2396: Choice Lookup Table
          22   2392
          21   2392
          19   2388
          18   2388
2405: oError 17
2407: oTypeSPop
2408: oGetGlobal 4
2410: oPushResult
2411: oTypeSPush
2412: oPop 1
2414: oJumpForward 2539
2416: oGetParam 1
2418: oPushResult
2419: oCall 2077
2421: oPop 1
2423: oGetParam 1
2425: oPushResult
2426: oCall 2542
2428: oPop 1
2430: oGetParam 1
2432: oPushResult
2433: oCall 2077
2435: oPop 1
2437: oCall 5526
2439: oTypeSNodeType
2440: oChoice 2450
2442: oEmit 35
2444: oJumpForward 2461
2446: oError 16
2448: oJumpForward 2461
2450: Choice Lookup Table
          22   2446
          21   2446
          19   2442
          18   2442
2459: oError 17
2461: oTypeSPop
2462: oGetGlobal 4
2464: oPushResult
2465: oTypeSPush
2466: oPop 1
2468: oJumpForward 2539
2470: oGetParam 1
2472: oPushResult
2473: oCall 2077
2475: oPop 1
2477: oGetParam 1
2479: oPushResult
2480: oCall 2542
2482: oPop 1
2484: oGetParam 1
2486: oPushResult
2487: oCall 2077
2489: oPop 1
2491: oCall 5526
2493: oTypeSNodeType
2494: oChoice 2504
2496: oEmit 34
2498: oJumpForward 2515
2500: oError 16
2502: oJumpForward 2515
2504: Choice Lookup Table
          22   2500
          21   2500
          19   2496
          18   2496
2513: oError 17
2515: oTypeSPop
2516: oGetGlobal 4
2518: oPushResult
2519: oTypeSPush
2520: oPop 1
2522: oJumpForward 2539
2524: Choice Lookup Table
          10   2470
           9   2416
           8   2362
           7   2308
           6   2248
           5   2188
2537: oJumpForward 2541
2539: oJumpBack 2186
2541: oReturn
2542: oLocalSpace 1
2544: oGetAddrLocal 1
2546: oPushResult
2547: oSetResult 0
2549: oAssign
2550: oGetParam 1
2552: oPushResult
2553: oCall 2722
2555: oPop 1
2557: oInputChoice 2690
2559: oTypeSNodeType
2560: oChoice 2631
2562: oGetLocal 1
2564: oPushResult
2565: oSetResult 0
2567: oPushResult
2568: equal_label
2569: oPop 2
2571: oChoice 2580
2573: oGetAddrLocal 1
2575: oPushResult
2576: oLabelNew
2577: oAssign
2578: oJumpForward 2583
2580: Choice Lookup Table
           1   2573
2583: oEmit 45
2585: oGetLocal 1
2587: oPushResult
2588: oEmitLabel
2589: oPop 1
2591: oJumpForward 2638
2593: oGetParam 1
2595: oPushResult
2596: oCall 2146
2598: oPop 1
2600: oGetLocal 1
2602: oPushResult
2603: oSetResult 0
2605: oPushResult
2606: equal_label
2607: oPop 2
2609: oChoice 2618
2611: oGetAddrLocal 1
2613: oPushResult
2614: oLabelNew
2615: oAssign
2616: oJumpForward 2621
2618: Choice Lookup Table
           1   2611
2621: oEmit 46
2623: oGetLocal 1
2625: oPushResult
2626: oEmitLabel
2627: oPop 1
2629: oJumpForward 2638
2631: Choice Lookup Table
          19   2593
          20   2562
2636: oError 8
2638: oTypeSPop
2639: oEmit 48
2641: oGetFromParam 1
2643: oPushResult
2644: oEmitLabel
2645: oPop 1
2647: oGetParam 1
2649: oPushResult
2650: oSetResult 0
2652: oAssign
2653: oGetParam 1
2655: oPushResult
2656: oCall 2722
2658: oPop 1
2660: oTypeSNodeType
2661: oChoice 2674
2663: oJumpForward 2681
2665: oGetParam 1
2667: oPushResult
2668: oCall 2146
2670: oPop 1
2672: oJumpForward 2681
2674: Choice Lookup Table
          19   2665
          20   2663
2679: oError 8
2681: oTypeSPop
2682: oGetGlobal 5
2684: oPushResult
2685: oTypeSPush
2686: oPop 1
2688: oJumpForward 2695
2690: Choice Lookup Table
          53   2559
2693: oJumpForward 2697
2695: oJumpBack 2557
2697: oGetLocal 1
2699: oPushResult
2700: oSetResult 0
2702: oPushResult
2703: equal_label
2704: oPop 2
2706: oChoice 2718
2708: oEmit 48
2710: oGetLocal 1
2712: oPushResult
2713: oEmitLabel
2714: oPop 1
2716: oJumpForward 2721
2718: Choice Lookup Table
           0   2708
2721: oReturn
2722: oLocalSpace 2
2724: oGetAddrLocal 1
2726: oPushResult
2727: oSetResult 0
2729: oAssign
2730: oGetParam 1
2732: oPushResult
2733: oCall 2860
2735: oPop 1
2737: oInputChoice 2852
2739: oTypeSNodeType
2740: oChoice 2753
2742: oJumpForward 2760
2744: oGetParam 1
2746: oPushResult
2747: oCall 2146
2749: oPop 1
2751: oJumpForward 2760
2753: Choice Lookup Table
          19   2744
          20   2742
2758: oError 8
2760: oTypeSPop
2761: oGetLocal 1
2763: oPushResult
2764: oSetResult 0
2766: oPushResult
2767: equal_label
2768: oPop 2
2770: oChoice 2799
2772: oGetAddrLocal 1
2774: oPushResult
2775: oLabelNew
2776: oAssign
2777: oEmit 49
2779: oGetFromParam 1
2781: oPushResult
2782: oEmitLabel
2783: oPop 1
2785: oGetLocal 1
2787: oPushResult
2788: oEmitLabel
2789: oPop 1
2791: oGetParam 1
2793: oPushResult
2794: oGetLocal 1
2796: oAssign
2797: oJumpForward 2802
2799: Choice Lookup Table
           1   2772
2802: oGetAddrLocal 2
2804: oPushResult
2805: oSetResult 0
2807: oAssign
2808: oGetAddrLocal 2
2810: oPushResult
2811: oCall 2860
2813: oPop 1
2815: oTypeSNodeType
2816: oChoice 2829
2818: oJumpForward 2836
2820: oGetAddrLocal 2
2822: oPushResult
2823: oCall 2146
2825: oPop 1
2827: oJumpForward 2836
2829: Choice Lookup Table
          19   2820
          20   2818
2834: oError 8
2836: oEmit 49
2838: oGetLocal 2
2840: oPushResult
2841: oEmitLabel
2842: oPop 1
2844: oGetLocal 1
2846: oPushResult
2847: oEmitLabel
2848: oPop 1
2850: oJumpForward 2857
2852: Choice Lookup Table
          52   2739
2855: oJumpForward 2859
2857: oJumpBack 2737
2859: oReturn
2860: oLocalSpace 1
2862: oInputChoice 2916
2864: oGetAddrLocal 1
2866: oPushResult
2867: oSetResult 0
2869: oAssign
2870: oGetAddrLocal 1
2872: oPushResult
2873: oCall 2860
2875: oPop 1
2877: oTypeSNodeType
2878: oChoice 2907
2880: oGetParam 1
2882: oPushResult
2883: oLabelNew
2884: oAssign
2885: oEmit 45
2887: oGetFromParam 1
2889: oPushResult
2890: oEmitLabel
2891: oPop 1
2893: oEmit 48
2895: oGetLocal 1
2897: oPushResult
2898: oEmitLabel
2899: oPop 1
2901: oJumpForward 2914
2903: oEmit 29
2905: oJumpForward 2914
2907: Choice Lookup Table
          19   2903
          20   2880
2912: oError 8
2914: oJumpForward 2926
2916: Choice Lookup Table
          54   2864
2919: oGetParam 1
2921: oPushResult
2922: oCall 2927
2924: oPop 1
2926: oReturn
2927: oLocalSpace 0
2929: oGetParam 1
2931: oPushResult
2932: oCall 2978
2934: oPop 1
2936: oInputChoice 2968
2938: oCall 5552
2940: oGetParam 1
2942: oPushResult
2943: oCall 2978
2945: oPop 1
2947: oCall 5566
2949: oEmit 26
2951: oJumpForward 2975
2953: oCall 5552
2955: oGetParam 1
2957: oPushResult
2958: oCall 2978
2960: oPop 1
2962: oCall 5566
2964: oEmit 27
2966: oJumpForward 2975
2968: Choice Lookup Table
          24   2953
          23   2938
2973: oJumpForward 2977
2975: oJumpBack 2936
2977: oReturn
2978: oLocalSpace 0
2980: oGetParam 1
2982: oPushResult
2983: oCall 3029
2985: oPop 1
2987: oInputChoice 3019
2989: oCall 5552
2991: oGetParam 1
2993: oPushResult
2994: oCall 3029
2996: oPop 1
2998: oCall 5566
3000: oEmit 23
3002: oJumpForward 3026
3004: oCall 5552
3006: oGetParam 1
3008: oPushResult
3009: oCall 3029
3011: oPop 1
3013: oCall 5566
3015: oEmit 24
3017: oJumpForward 3026
3019: Choice Lookup Table
          22   3004
          21   2989
3024: oJumpForward 3028
3026: oJumpBack 2987
3028: oReturn
3029: oLocalSpace 0
3031: oInputChoice 3057
3033: oGetParam 1
3035: oPushResult
3036: oCall 3070
3038: oPop 1
3040: oCall 5566
3042: oJumpForward 3069
3044: oGetParam 1
3046: oPushResult
3047: oCall 3070
3049: oPop 1
3051: oCall 5566
3053: oEmit 28
3055: oJumpForward 3069
3057: Choice Lookup Table
          24   3044
          23   3033
3062: oGetParam 1
3064: oPushResult
3065: oCall 3070
3067: oPop 1
3069: oReturn
3070: oLocalSpace 6
3072: oInputChoice 3254
3074: oEmit 9
3076: TOKEN_VALUE
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oGetGlobal 3
3083: oPushResult
3084: oTypeSPush
3085: oPop 1
3087: oJumpForward 3273
3089: oGetParam 1
3091: oPushResult
3092: oCall 2177
3094: oPop 1
3096: oInput 14
3098: oJumpForward 3273
3100: oGetAddrLocal 1
3102: oPushResult
3103: oStringAllocLit
3104: oAssign
3105: oEmit 10
3107: oGetLocal 1
3109: oPushResult
3110: oEmitInt
3111: oPop 1
3113: oGetGlobal 7
3115: oPushResult
3116: oTypeSPush
3117: oPop 1
3119: oJumpForward 3273
3121: oGetAddrLocal 2
3123: oPushResult
3124: oScopeFindRequire
3125: oAssign
3126: oGetLocal 2
3128: oPushResult
3129: oNodeType
3130: oPop 1
3132: oChoice 3194
3134: oGetLocal 2
3136: oPushResult
3137: oCall 3996
3139: oPop 1
3141: oJumpForward 3213
3143: oGetAddrLocal 3
3145: oPushResult
3146: oGetLocal 2
3148: oPushResult
3149: oSetResult 5
3151: oPushResult
3152: oNodeGet
3153: oPop 2
3155: oAssign
3156: oGetLocal 3
3158: oPushResult
3159: oTypeSPush
3160: oPop 1
3162: oTypeSNodeType
3163: oChoice 3176
3165: oEmit 9
3167: oGetLocal 2
3169: oPushResult
3170: oCall 5803
3172: oPop 1
3174: oJumpForward 3183
3176: Choice Lookup Table
          19   3165
          18   3165
3181: oError 16
3183: oJumpForward 3213
3185: oGetLocal 2
3187: oPushResult
3188: oCall 3274
3190: oPop 1
3192: oJumpForward 3213
3194: Choice Lookup Table
          15   3185
          13   3185
          12   3185
           9   3143
           8   3134
3205: oError 6
3207: oGetGlobal 3
3209: oPushResult
3210: oTypeSPush
3211: oPop 1
3213: oJumpForward 3273
3215: oInput 0
3217: oGetAddrLocal 4
3219: oPushResult
3220: oScopeFindRequire
3221: oAssign
3222: oGetLocal 4
3224: oPushResult
3225: oCall 4845
3227: oPop 1
3229: oGetAddrLocal 5
3231: oPushResult
3232: oTypeSTop
3233: oAssign
3234: oTypeSPop
3235: oGetAddrLocal 6
3237: oPushResult
3238: oGetLocal 5
3240: oPushResult
3241: oCall 5668
3243: oPop 1
3245: oAssign
3246: oGetLocal 6
3248: oPushResult
3249: oTypeSPush
3250: oPop 1
3252: oJumpForward 3273
3254: Choice Lookup Table
          18   3215
           0   3121
           2   3100
          13   3089
           1   3074
3265: oError 6
3267: oGetGlobal 3
3269: oPushResult
3270: oTypeSPush
3271: oPop 1
3273: oReturn
3274: oLocalSpace 1
3276: oGetAddrLocal 1
3278: oPushResult
3279: oGetParam 1
3281: oPushResult
3282: oSetResult 5
3284: oPushResult
3285: oNodeGet
3286: oPop 2
3288: oAssign
3289: oGetLocal 1
3291: oPushResult
3292: oTypeSPush
3293: oPop 1
3295: oTypeSNodeType
3296: oChoice 3561
3298: oGetParam 1
3300: oPushResult
3301: oNodeType
3302: oPop 1
3304: oChoice 3366
3306: oEmit 0
3308: oGetParam 1
3310: oPushResult
3311: oCall 5803
3313: oPop 1
3315: oJumpForward 3374
3317: oEmit 3
3319: oGetParam 1
3321: oPushResult
3322: oCall 5803
3324: oPop 1
3326: oJumpForward 3374
3328: oGetParam 1
3330: oPushResult
3331: oSetResult 17
3333: oPushResult
3334: oNodeGetBoolean
3335: oPop 2
3337: oChoice 3352
3339: oEmit 8
3341: oGetParam 1
3343: oPushResult
3344: oCall 5803
3346: oPop 1
3348: oEmit 14
3350: oJumpForward 3364
3352: Choice Lookup Table
           1   3339
3355: oEmit 6
3357: oGetParam 1
3359: oPushResult
3360: oCall 5803
3362: oPop 1
3364: oJumpForward 3374
3366: Choice Lookup Table
          15   3328
          13   3317
          12   3306
3373: oEndChoice
3374: oJumpForward 3652
3376: oGetParam 1
3378: oPushResult
3379: oNodeType
3380: oPop 1
3382: oChoice 3444
3384: oEmit 1
3386: oGetParam 1
3388: oPushResult
3389: oCall 5803
3391: oPop 1
3393: oJumpForward 3452
3395: oEmit 4
3397: oGetParam 1
3399: oPushResult
3400: oCall 5803
3402: oPop 1
3404: oJumpForward 3452
3406: oGetParam 1
3408: oPushResult
3409: oSetResult 17
3411: oPushResult
3412: oNodeGetBoolean
3413: oPop 2
3415: oChoice 3430
3417: oEmit 8
3419: oGetParam 1
3421: oPushResult
3422: oCall 5803
3424: oPop 1
3426: oEmit 15
3428: oJumpForward 3442
3430: Choice Lookup Table
           1   3417
3433: oEmit 7
3435: oGetParam 1
3437: oPushResult
3438: oCall 5803
3440: oPop 1
3442: oJumpForward 3452
3444: Choice Lookup Table
          15   3406
          13   3395
          12   3384
3451: oEndChoice
3452: oJumpForward 3652
3454: oError 16
3456: oJumpForward 3652
3458: oGetParam 1
3460: oPushResult
3461: oNodeType
3462: oPop 1
3464: oChoice 3526
3466: oEmit 2
3468: oGetParam 1
3470: oPushResult
3471: oCall 5803
3473: oPop 1
3475: oJumpForward 3534
3477: oEmit 5
3479: oGetParam 1
3481: oPushResult
3482: oCall 5803
3484: oPop 1
3486: oJumpForward 3534
3488: oGetParam 1
3490: oPushResult
3491: oSetResult 17
3493: oPushResult
3494: oNodeGetBoolean
3495: oPop 2
3497: oChoice 3512
3499: oEmit 8
3501: oGetParam 1
3503: oPushResult
3504: oCall 5803
3506: oPop 1
3508: oEmit 16
3510: oJumpForward 3524
3512: Choice Lookup Table
           1   3499
3515: oEmit 8
3517: oGetParam 1
3519: oPushResult
3520: oCall 5803
3522: oPop 1
3524: oJumpForward 3534
3526: Choice Lookup Table
          15   3488
          13   3477
          12   3466
3533: oEndChoice
3534: oInputChoice 3556
3536: oTypeSPop
3537: oGetLocal 1
3539: oPushResult
3540: oSetResult 19
3542: oPushResult
3543: oNodeGet
3544: oPop 2
3546: oPushResult
3547: oTypeSPush
3548: oPop 1
3550: oCall 3688
3552: oCall 3653
3554: oJumpForward 3559
3556: Choice Lookup Table
          17   3536
3559: oJumpForward 3652
3561: Choice Lookup Table
          23   3458
          17   3454
          22   3454
          21   3454
          19   3376
          18   3298
3574: oGetParam 1
3576: oPushResult
3577: oNodeType
3578: oPop 1
3580: oChoice 3640
3582: oEmit 10
3584: oGetParam 1
3586: oPushResult
3587: oCall 5803
3589: oPop 1
3591: oJumpForward 3648
3593: oEmit 11
3595: oGetParam 1
3597: oPushResult
3598: oCall 5803
3600: oPop 1
3602: oJumpForward 3648
3604: oGetParam 1
3606: oPushResult
3607: oSetResult 17
3609: oPushResult
3610: oNodeGetBoolean
3611: oPop 2
3613: oChoice 3626
3615: oEmit 8
3617: oGetParam 1
3619: oPushResult
3620: oCall 5803
3622: oPop 1
3624: oJumpForward 3638
3626: Choice Lookup Table
           1   3615
3629: oEmit 12
3631: oGetParam 1
3633: oPushResult
3634: oCall 5803
3636: oPop 1
3638: oJumpForward 3648
3640: Choice Lookup Table
          15   3604
          13   3593
          12   3582
3647: oEndChoice
3648: oCall 3688
3650: oCall 3653
3652: oReturn
3653: oLocalSpace 0
3655: oTypeSNodeType
3656: oChoice 3674
3658: oEmit 14
3660: oJumpForward 3687
3662: oEmit 15
3664: oJumpForward 3687
3666: oError 16
3668: oJumpForward 3687
3670: oEmit 16
3672: oJumpForward 3687
3674: Choice Lookup Table
          23   3670
          17   3666
          22   3666
          21   3666
          19   3662
          18   3658
3687: oReturn
3688: oLocalSpace 0
3690: oInputChoice 3704
3692: oCall 3716
3694: oJumpForward 3713
3696: oCall 3859
3698: oJumpForward 3713
3700: oCall 3957
3702: oJumpForward 3713
3704: Choice Lookup Table
          17   3700
          19   3696
          15   3692
3711: oJumpForward 3715
3713: oJumpBack 3690
3715: oReturn
3716: oLocalSpace 3
3718: oTypeSNodeType
3719: oChoice 3723
3721: oJumpForward 3728
3723: Choice Lookup Table
          24   3721
3726: oError 10
3728: oTypeSNodeType
3729: oChoice 3733
3731: oJumpForward 3738
3733: Choice Lookup Table
          24   3731
3736: oError 13
3738: oGetAddrLocal 1
3740: oPushResult
3741: oTypeSTop
3742: oPushResult
3743: oSetResult 20
3745: oPushResult
3746: oNodeGet
3747: oPop 2
3749: oPushResult
3750: oCall 5752
3752: oPop 1
3754: oAssign
3755: oGetAddrLocal 2
3757: oPushResult
3758: oTypeSTop
3759: oPushResult
3760: oSetResult 19
3762: oPushResult
3763: oNodeGet
3764: oPop 2
3766: oAssign
3767: oTypeSPop
3768: oGetLocal 2
3770: oPushResult
3771: oTypeSPush
3772: oPop 1
3774: oCall 2016
3776: oCall 5552
3778: oGetLocal 1
3780: oPushResult
3781: equal_zero
3782: oPop 1
3784: oChoice 3798
3786: oEmit 9
3788: oGetLocal 1
3790: oPushResult
3791: oEmitInt
3792: oPop 1
3794: oEmit 27
3796: oJumpForward 3801
3798: Choice Lookup Table
           0   3786
3801: oGetAddrLocal 3
3803: oPushResult
3804: oGetLocal 2
3806: oPushResult
3807: oSetResult 2
3809: oPushResult
3810: oNodeGetInt
3811: oPop 2
3813: oAssign
3814: oGetLocal 3
3816: oPushResult
3817: oSetResult 1
3819: oPushResult
3820: equal
3821: oPop 2
3823: oChoice 3837
3825: oEmit 9
3827: oGetLocal 3
3829: oPushResult
3830: oEmitInt
3831: oPop 1
3833: oEmit 23
3835: oJumpForward 3840
3837: Choice Lookup Table
           0   3825
3840: oEmit 25
3842: oInputChoice 3850
3844: oJumpForward 3858
3846: oJumpForward 3856
3848: oJumpForward 3856
3850: Choice Lookup Table
          12   3848
          16   3844
3855: oEndChoice
3856: oJumpBack 3728
3858: oReturn
3859: oLocalSpace 2
3861: oTypeSNodeType
3862: oChoice 3866
3864: oJumpForward 3871
3866: Choice Lookup Table
          26   3864
3869: oError 11
3871: oTypeSTop
3872: oPushResult
3873: oSetResult 23
3875: oPushResult
3876: oNodeGet
3877: oPop 2
3879: oPushResult
3880: oScopeEnter
3881: oPop 1
3883: oInput 0
3885: oGetAddrLocal 1
3887: oPushResult
3888: oScopeFindRequire
3889: oAssign
3890: oGetLocal 1
3892: oPushResult
3893: oNodeType
3894: oPop 1
3896: oChoice 3900
3898: oJumpForward 3905
3900: Choice Lookup Table
          14   3898
3903: oError 12
3905: oScopeEnd
3906: oGetAddrLocal 2
3908: oPushResult
3909: oGetLocal 1
3911: oPushResult
3912: oSetResult 6
3914: oPushResult
3915: oNodeGetInt
3916: oPop 2
3918: oAssign
3919: oGetLocal 2
3921: oPushResult
3922: equal_zero
3923: oPop 1
3925: oChoice 3939
3927: oEmit 9
3929: oGetLocal 2
3931: oPushResult
3932: oEmitInt
3933: oPop 1
3935: oEmit 25
3937: oJumpForward 3942
3939: Choice Lookup Table
           0   3927
3942: oTypeSPop
3943: oGetLocal 1
3945: oPushResult
3946: oSetResult 5
3948: oPushResult
3949: oNodeGet
3950: oPop 2
3952: oPushResult
3953: oTypeSPush
3954: oPop 1
3956: oReturn
3957: oLocalSpace 1
3959: oTypeSNodeType
3960: oChoice 3964
3962: oJumpForward 3969
3964: Choice Lookup Table
          23   3962
3967: oError 9
3969: oEmit 16
3971: oGetAddrLocal 1
3973: oPushResult
3974: oTypeSTop
3975: oAssign
3976: oTypeSPop
3977: oGetLocal 1
3979: oPushResult
3980: oSetResult 19
3982: oPushResult
3983: oNodeGet
3984: oPop 2
3986: oPushResult
3987: oTypeSPush
3988: oPop 1
3990: oReturn
3991: oLocalSpace 0
3993: oCall 5526
3995: oReturn
3996: oLocalSpace 10
3998: oGetParam 1
4000: oPushResult
4001: oSetResult 11
4003: oPushResult
4004: oNodeGetBoolean
4005: oPop 2
4007: oChoice 4059
4009: oGetParam 1
4011: oPushResult
4012: oSetResult 13
4014: oPushResult
4015: oNodeGetBoolean
4016: oPop 2
4018: oChoice 4054
4020: oGetAddrLocal 1
4022: oPushResult
4023: oGetParam 1
4025: oPushResult
4026: oSetResult 4
4028: oPushResult
4029: oNodeGetInt
4030: oPop 2
4032: oPushResult
4033: oStringAllocLitFromIdent
4034: oPop 1
4036: oAssign
4037: oEmit 50
4039: oGetParam 1
4041: oPushResult
4042: oCall 5803
4044: oPop 1
4046: oGetLocal 1
4048: oPushResult
4049: oEmitInt
4050: oPop 1
4052: oJumpForward 4057
4054: Choice Lookup Table
           0   4020
4057: oJumpForward 4062
4059: Choice Lookup Table
           1   4009
4062: oGetParam 1
4064: oPushResult
4065: oSetResult 13
4067: oPushResult
4068: oSetResult 1
4070: oPushResult
4071: oNodeSetBoolean
4072: oPop 3
4074: oGetAddrLocal 2
4076: oPushResult
4077: oGetParam 1
4079: oPushResult
4080: oSetResult 12
4082: oPushResult
4083: oNodeGetBoolean
4084: oPop 2
4086: oAssign
4087: oGetAddrLocal 5
4089: oPushResult
4090: oGetParam 1
4092: oPushResult
4093: oNodeType
4094: oPop 1
4096: oPushResult
4097: oSetResult 8
4099: oPushResult
4100: equal_node_type
4101: oPop 2
4103: oAssign
4104: oGetLocal 5
4106: oChoice 4133
4108: oGetAddrLocal 3
4110: oPushResult
4111: oGetParam 1
4113: oPushResult
4114: oSetResult 5
4116: oPushResult
4117: oNodeGet
4118: oPop 2
4120: oAssign
4121: oGetAddrLocal 4
4123: oPushResult
4124: oGetLocal 3
4126: oPushResult
4127: oScopeAllocType
4128: oPop 1
4130: oAssign
4131: oJumpForward 4136
4133: Choice Lookup Table
           1   4108
4136: oGetAddrLocal 6
4138: oPushResult
4139: oGetParam 1
4141: oPushResult
4142: oSetResult 8
4144: oPushResult
4145: oNodeGet
4146: oPop 2
4148: oAssign
4149: oGetAddrLocal 7
4151: oPushResult
4152: oGetLocal 6
4154: oPushResult
4155: oSetResult 2
4157: oPushResult
4158: oNodeGetInt
4159: oPop 2
4161: oAssign
4162: oGetLocal 2
4164: oChoice 4186
4166: oEmit 39
4168: oGetLocal 7
4170: oPushResult
4171: oEmitInt
4172: oPop 1
4174: oJumpForward 4192
4176: oEmit 38
4178: oGetLocal 7
4180: oPushResult
4181: oEmitInt
4182: oPop 1
4184: oJumpForward 4192
4186: Choice Lookup Table
           0   4176
           1   4166
4191: oEndChoice
4192: oGetAddrLocal 8
4194: oPushResult
4195: oGetLocal 6
4197: oPushResult
4198: oSetResult 1
4200: oPushResult
4201: oNodeGet
4202: oPop 2
4204: oAssign
4205: oInputChoice 4374
4207: oGetLocal 8
4209: oPushResult
4210: oNodeNull
4211: oPop 1
4213: oChoice 4219
4215: oJumpForward 4370
4217: oJumpForward 4222
4219: Choice Lookup Table
           1   4215
4222: oGetAddrLocal 9
4224: oPushResult
4225: oGetLocal 8
4227: oPushResult
4228: oSetResult 6
4230: oPushResult
4231: oNodeGetInt
4232: oPop 2
4234: oAssign
4235: oEmit 13
4237: oGetLocal 9
4239: oPushResult
4240: oEmitInt
4241: oPop 1
4243: oGetLocal 8
4245: oPushResult
4246: oSetResult 5
4248: oPushResult
4249: oNodeGet
4250: oPop 2
4252: oPushResult
4253: oTypeSPush
4254: oPop 1
4256: oGetLocal 8
4258: oPushResult
4259: oSetResult 17
4261: oPushResult
4262: oNodeGetBoolean
4263: oPop 2
4265: oChoice 4333
4267: oCall 4809
4269: oCall 5526
4271: oEmit 19
4273: oJumpForward 4339
4275: oCall 2016
4277: oCall 3991
4279: oTypeSNodeType
4280: oChoice 4298
4282: oEmit 17
4284: oJumpForward 4331
4286: oEmit 18
4288: oJumpForward 4331
4290: oError 16
4292: oJumpForward 4331
4294: oEmit 19
4296: oJumpForward 4331
4298: Choice Lookup Table
          23   4294
          17   4290
          22   4290
          21   4290
          19   4286
          18   4282
4311: oGetAddrLocal 10
4313: oPushResult
4314: oTypeSTop
4315: oPushResult
4316: oSetResult 2
4318: oPushResult
4319: oNodeGetInt
4320: oPop 2
4322: oAssign
4323: oEmit 20
4325: oGetLocal 10
4327: oPushResult
4328: oEmitInt
4329: oPop 1
4331: oJumpForward 4339
4333: Choice Lookup Table
           0   4275
           1   4267
4338: oEndChoice
4339: oTypeSPop
4340: oGetAddrLocal 8
4342: oPushResult
4343: oNodeNext
4344: oPop 1
4346: oGetLocal 8
4348: oPushResult
4349: oNodeNull
4350: oPop 1
4352: oChoice 4360
4354: oJumpForward 4370
4356: oJumpForward 4366
4358: oJumpForward 4366
4360: Choice Lookup Table
           0   4358
           1   4354
4365: oEndChoice
4366: oInput 12
4368: oJumpBack 4207
4370: oInput 14
4372: oJumpForward 4377
4374: Choice Lookup Table
          13   4207
4377: oGetLocal 8
4379: oPushResult
4380: oNodeNull
4381: oPop 1
4383: oChoice 4389
4385: oError 15
4387: oJumpForward 4392
4389: Choice Lookup Table
           0   4385
4392: oGetLocal 5
4394: oChoice 4423
4396: oEmit 13
4398: oGetParam 1
4400: oPushResult
4401: oSetResult 16
4403: oPushResult
4404: oNodeGetInt
4405: oPop 2
4407: oPushResult
4408: oEmitInt
4409: oPop 1
4411: oEmit 11
4413: oGetLocal 4
4415: oPushResult
4416: oEmitInt
4417: oPop 1
4419: oEmit 19
4421: oJumpForward 4426
4423: Choice Lookup Table
           1   4396
4426: oGetLocal 2
4428: oChoice 4452
4430: oEmit 42
4432: oGetParam 1
4434: oPushResult
4435: oCall 5803
4437: oPop 1
4439: oJumpForward 4458
4441: oEmit 41
4443: oGetParam 1
4445: oPushResult
4446: oCall 5803
4448: oPop 1
4450: oJumpForward 4458
4452: Choice Lookup Table
           0   4441
           1   4430
4457: oEndChoice
4458: oGetLocal 5
4460: oChoice 4480
4462: oGetLocal 3
4464: oPushResult
4465: oTypeSPush
4466: oPop 1
4468: oEmit 11
4470: oGetLocal 4
4472: oPushResult
4473: oEmitInt
4474: oPop 1
4476: oCall 3653
4478: oJumpForward 4483
4480: Choice Lookup Table
           1   4462
4483: oEmit 40
4485: oGetLocal 7
4487: oPushResult
4488: oEmitInt
4489: oPop 1
4491: oReturn
4492: oLocalSpace 0
4494: oInputChoice 4544
4496: oCall 5446
4498: oJumpForward 4569
4500: oCall 5453
4502: oJumpForward 4569
4504: oCall 5520
4506: oJumpForward 4569
4508: oCall 5523
4510: oJumpForward 4569
4512: oCall 4986
4514: oJumpForward 4569
4516: oCall 5306
4518: oJumpForward 4569
4520: oCall 5052
4522: oJumpForward 4569
4524: oCall 5226
4526: oJumpForward 4569
4528: oCall 5391
4530: oJumpForward 4569
4532: oCall 5359
4534: oJumpForward 4569
4536: oCall 5423
4538: oJumpForward 4569
4540: oCall 4570
4542: oJumpForward 4569
4544: Choice Lookup Table
           0   4540
          33   4536
          49   4532
          50   4528
          47   4524
          42   4520
          46   4516
          39   4512
          58   4508
          57   4504
          56   4500
          55   4496
4569: oReturn
4570: oLocalSpace 1
4572: oGetAddrLocal 1
4574: oPushResult
4575: oScopeFindRequire
4576: oAssign
4577: oGetLocal 1
4579: oPushResult
4580: oNodeType
4581: oPop 1
4583: oChoice 4612
4585: oGetLocal 1
4587: oPushResult
4588: oCall 3996
4590: oPop 1
4592: oJumpForward 4625
4594: oGetLocal 1
4596: oPushResult
4597: oCall 4626
4599: oPop 1
4601: oJumpForward 4625
4603: oGetLocal 1
4605: oPushResult
4606: oCall 4695
4608: oPop 1
4610: oJumpForward 4625
4612: Choice Lookup Table
           8   4603
          15   4594
          13   4594
          12   4594
           7   4585
4623: oError 0
4625: oReturn
4626: oLocalSpace 1
4628: oGetParam 1
4630: oPushResult
4631: oCall 4845
4633: oPop 1
4635: oInput 3
4637: oCall 2016
4639: oCall 5526
4641: oTypeSNodeType
4642: oChoice 4660
4644: oEmit 17
4646: oJumpForward 4693
4648: oEmit 18
4650: oJumpForward 4693
4652: oError 16
4654: oJumpForward 4693
4656: oEmit 19
4658: oJumpForward 4693
4660: Choice Lookup Table
          23   4656
          17   4652
          22   4652
          21   4652
          19   4648
          18   4644
4673: oGetAddrLocal 1
4675: oPushResult
4676: oTypeSTop
4677: oPushResult
4678: oSetResult 2
4680: oPushResult
4681: oNodeGetInt
4682: oPop 2
4684: oAssign
4685: oEmit 20
4687: oGetLocal 1
4689: oPushResult
4690: oEmitInt
4691: oPop 1
4693: oTypeSPop
4694: oReturn
4695: oLocalSpace 1
4697: oGetParam 1
4699: oPushResult
4700: oSetResult 9
4702: oPushResult
4703: oNodeGet
4704: oPop 2
4706: oPushResult
4707: oScopeCurrent
4708: oPushResult
4709: oNodeEqual
4710: oPop 2
4712: oChoice 4718
4714: oError 20
4716: oJumpForward 4721
4718: Choice Lookup Table
           0   4714
4721: oEmit 8
4723: oGetParam 1
4725: oPushResult
4726: oSetResult 16
4728: oPushResult
4729: oNodeGetInt
4730: oPop 2
4732: oPushResult
4733: oEmitInt
4734: oPop 1
4736: oGetParam 1
4738: oPushResult
4739: oSetResult 5
4741: oPushResult
4742: oNodeGet
4743: oPop 2
4745: oPushResult
4746: oTypeSPush
4747: oPop 1
4749: oInput 3
4751: oCall 2016
4753: oCall 5526
4755: oTypeSNodeType
4756: oChoice 4774
4758: oEmit 17
4760: oJumpForward 4807
4762: oEmit 18
4764: oJumpForward 4807
4766: oError 16
4768: oJumpForward 4807
4770: oEmit 19
4772: oJumpForward 4807
4774: Choice Lookup Table
          23   4770
          17   4766
          22   4766
          21   4766
          19   4762
          18   4758
4787: oGetAddrLocal 1
4789: oPushResult
4790: oTypeSTop
4791: oPushResult
4792: oSetResult 2
4794: oPushResult
4795: oNodeGetInt
4796: oPop 2
4798: oAssign
4799: oEmit 20
4801: oGetLocal 1
4803: oPushResult
4804: oEmitInt
4805: oPop 1
4807: oTypeSPop
4808: oReturn
4809: oLocalSpace 1
4811: oInput 0
4813: oGetAddrLocal 1
4815: oPushResult
4816: oScopeFindRequire
4817: oAssign
4818: oGetLocal 1
4820: oPushResult
4821: oNodeType
4822: oPop 1
4824: oChoice 4828
4826: oJumpForward 4837
4828: Choice Lookup Table
          15   4826
          13   4826
          12   4826
4835: oError 4
4837: oGetLocal 1
4839: oPushResult
4840: oCall 4845
4842: oPop 1
4844: oReturn
4845: oLocalSpace 0
4847: oGetParam 1
4849: oPushResult
4850: oNodeType
4851: oPop 1
4853: oChoice 4913
4855: oEmit 10
4857: oGetParam 1
4859: oPushResult
4860: oCall 5803
4862: oPop 1
4864: oJumpForward 4922
4866: oEmit 11
4868: oGetParam 1
4870: oPushResult
4871: oCall 5803
4873: oPop 1
4875: oJumpForward 4922
4877: oGetParam 1
4879: oPushResult
4880: oSetResult 17
4882: oPushResult
4883: oNodeGetBoolean
4884: oPop 2
4886: oChoice 4899
4888: oEmit 8
4890: oGetParam 1
4892: oPushResult
4893: oCall 5803
4895: oPop 1
4897: oJumpForward 4911
4899: Choice Lookup Table
           1   4888
4902: oEmit 12
4904: oGetParam 1
4906: oPushResult
4907: oCall 5803
4909: oPop 1
4911: oJumpForward 4922
4913: Choice Lookup Table
          15   4877
          13   4866
          12   4855
4920: oError 4
4922: oGetParam 1
4924: oPushResult
4925: oSetResult 5
4927: oPushResult
4928: oNodeGet
4929: oPop 2
4931: oPushResult
4932: oTypeSPush
4933: oPop 1
4935: oCall 3688
4937: oReturn
4938: oLocalSpace 0
4940: oGetParam 1
4942: oPushResult
4943: oCall 4845
4945: oPop 1
4947: oCall 5552
4949: oGetParam 1
4951: oPushResult
4952: oCall 3274
4954: oPop 1
4956: oTypeSPop
4957: oEmit 21
4959: oEmit 17
4961: oReturn
4962: oLocalSpace 0
4964: oGetParam 1
4966: oPushResult
4967: oCall 4845
4969: oPop 1
4971: oCall 5552
4973: oGetParam 1
4975: oPushResult
4976: oCall 3274
4978: oPop 1
4980: oTypeSPop
4981: oEmit 22
4983: oEmit 17
4985: oReturn
4986: oLocalSpace 2
4988: oGetAddrLocal 1
4990: oPushResult
4991: oSetResult 0
4993: oAssign
4994: oGetAddrLocal 1
4996: oPushResult
4997: oCall 2039
4999: oPop 1
5001: oInput 40
5003: oCall 4492
5005: oInputChoice 5040
5007: oGetAddrLocal 2
5009: oPushResult
5010: oLabelNew
5011: oAssign
5012: oEmit 45
5014: oGetLocal 2
5016: oPushResult
5017: oEmitLabel
5018: oPop 1
5020: oEmit 48
5022: oGetLocal 1
5024: oPushResult
5025: oEmitLabel
5026: oPop 1
5028: oCall 4492
5030: oEmit 48
5032: oGetLocal 2
5034: oPushResult
5035: oEmitLabel
5036: oPop 1
5038: oJumpForward 5051
5040: Choice Lookup Table
          41   5007
5043: oEmit 48
5045: oGetLocal 1
5047: oPushResult
5048: oEmitLabel
5049: oPop 1
5051: oReturn
5052: oLocalSpace 4
5054: oInput 0
5056: oGetAddrLocal 1
5058: oPushResult
5059: oScopeFindRequire
5060: oAssign
5061: oGetLocal 1
5063: oPushResult
5064: oCall 4845
5066: oPop 1
5068: oCall 5552
5070: oInput 3
5072: oCall 2016
5074: oCall 5552
5076: oEmit 17
5078: oGetAddrLocal 2
5080: oPushResult
5081: oLabelNew
5082: oAssign
5083: oGetAddrLocal 3
5085: oPushResult
5086: oLabelNew
5087: oAssign
5088: oEmit 45
5090: oGetLocal 3
5092: oPushResult
5093: oEmitLabel
5094: oPop 1
5096: oGetAddrLocal 4
5098: oPushResult
5099: oLabelNew
5100: oAssign
5101: oEmit 48
5103: oGetLocal 4
5105: oPushResult
5106: oEmitLabel
5107: oPop 1
5109: oInputChoice 5189
5111: oGetLocal 1
5113: oPushResult
5114: oCall 4938
5116: oPop 1
5118: oEmit 48
5120: oGetLocal 3
5122: oPushResult
5123: oEmitLabel
5124: oPop 1
5126: oGetLocal 1
5128: oPushResult
5129: oCall 3274
5131: oPop 1
5133: oTypeSPop
5134: oCall 2016
5136: oCall 5552
5138: oEmit 32
5140: oEmit 46
5142: oGetLocal 2
5144: oPushResult
5145: oEmitLabel
5146: oPop 1
5148: oJumpForward 5195
5150: oGetLocal 1
5152: oPushResult
5153: oCall 4962
5155: oPop 1
5157: oEmit 48
5159: oGetLocal 3
5161: oPushResult
5162: oEmitLabel
5163: oPop 1
5165: oGetLocal 1
5167: oPushResult
5168: oCall 3274
5170: oPop 1
5172: oTypeSPop
5173: oCall 2016
5175: oCall 5552
5177: oEmit 33
5179: oEmit 46
5181: oGetLocal 2
5183: oPushResult
5184: oEmitLabel
5185: oPop 1
5187: oJumpForward 5195
5189: Choice Lookup Table
          44   5150
          43   5111
5194: oEndChoice
5195: oGetLocal 4
5197: oPushResult
5198: oGetLocal 2
5200: oPushResult
5201: oLoopPush
5202: oPop 2
5204: oInput 45
5206: oCall 4492
5208: oEmit 45
5210: oGetLocal 4
5212: oPushResult
5213: oEmitLabel
5214: oPop 1
5216: oEmit 48
5218: oGetLocal 2
5220: oPushResult
5221: oEmitLabel
5222: oPop 1
5224: oLoopPop
5225: oReturn
5226: oLocalSpace 3
5228: oGetAddrLocal 1
5230: oPushResult
5231: oLabelNew
5232: oAssign
5233: oEmit 48
5235: oGetLocal 1
5237: oPushResult
5238: oEmitLabel
5239: oPop 1
5241: oGetAddrLocal 2
5243: oPushResult
5244: oLabelNew
5245: oAssign
5246: oGetLocal 1
5248: oPushResult
5249: oGetLocal 2
5251: oPushResult
5252: oLoopPush
5253: oPop 2
5255: oCall 4492
5257: oInputChoice 5288
5259: oCall 4492
5261: oJumpForward 5294
5263: oGetAddrLocal 3
5265: oPushResult
5266: oCall 2039
5268: oPop 1
5270: oEmit 49
5272: oGetLocal 3
5274: oPushResult
5275: oEmitLabel
5276: oPop 1
5278: oGetLocal 1
5280: oPushResult
5281: oEmitLabel
5282: oPop 1
5284: oJumpForward 5296
5286: oJumpForward 5294
5288: Choice Lookup Table
          48   5263
           4   5259
5293: oEndChoice
5294: oJumpBack 5257
5296: oEmit 48
5298: oGetLocal 2
5300: oPushResult
5301: oEmitLabel
5302: oPop 1
5304: oLoopPop
5305: oReturn
5306: oLocalSpace 2
5308: oGetAddrLocal 1
5310: oPushResult
5311: oLabelNew
5312: oAssign
5313: oEmit 48
5315: oGetLocal 1
5317: oPushResult
5318: oEmitLabel
5319: oPop 1
5321: oGetAddrLocal 2
5323: oPushResult
5324: oCall 2039
5326: oPop 1
5328: oGetLocal 1
5330: oPushResult
5331: oGetLocal 2
5333: oPushResult
5334: oLoopPush
5335: oPop 2
5337: oInput 45
5339: oCall 4492
5341: oEmit 45
5343: oGetLocal 1
5345: oPushResult
5346: oEmitLabel
5347: oPop 1
5349: oEmit 48
5351: oGetLocal 2
5353: oPushResult
5354: oEmitLabel
5355: oPop 1
5357: oLoopPop
5358: oReturn
5359: oLocalSpace 0
5361: oLoopContinueLabel
5362: oPushResult
5363: oSetResult 0
5365: oPushResult
5366: equal_label
5367: oPop 2
5369: oChoice 5384
5371: oError 18
5373: oJumpForward 5390
5375: oEmit 45
5377: oLoopContinueLabel
5378: oPushResult
5379: oEmitLabel
5380: oPop 1
5382: oJumpForward 5390
5384: Choice Lookup Table
           0   5375
           1   5371
5389: oEndChoice
5390: oReturn
5391: oLocalSpace 0
5393: oLoopBreakLabel
5394: oPushResult
5395: oSetResult 0
5397: oPushResult
5398: equal_label
5399: oPop 2
5401: oChoice 5416
5403: oError 18
5405: oJumpForward 5422
5407: oEmit 45
5409: oLoopBreakLabel
5410: oPushResult
5411: oEmitLabel
5412: oPop 1
5414: oJumpForward 5422
5416: Choice Lookup Table
           0   5407
           1   5403
5421: oEndChoice
5422: oReturn
5423: oLocalSpace 0
5425: oCall 4492
5427: oInputChoice 5437
5429: oCall 4492
5431: oJumpForward 5443
5433: oJumpForward 5445
5435: oJumpForward 5443
5437: Choice Lookup Table
          34   5433
           4   5429
5442: oEndChoice
5443: oJumpBack 5427
5445: oReturn
5446: oLocalSpace 0
5448: oCall 5453
5450: oEmit 55
5452: oReturn
5453: oLocalSpace 0
5455: oInputChoice 5516
5457: oCall 2016
5459: oTypeSNodeType
5460: oChoice 5482
5462: oEmit 51
5464: oJumpForward 5497
5466: oEmit 52
5468: oJumpForward 5497
5470: oEmit 53
5472: oJumpForward 5497
5474: oError 16
5476: oJumpForward 5497
5478: oEmit 54
5480: oJumpForward 5497
5482: Choice Lookup Table
          23   5478
          17   5474
          21   5474
          22   5470
          19   5466
          18   5462
5495: oError 17
5497: oTypeSPop
5498: oInputChoice 5506
5500: oJumpForward 5514
5502: oJumpForward 5512
5504: oJumpForward 5512
5506: Choice Lookup Table
          12   5504
          14   5500
5511: oEndChoice
5512: oJumpBack 5457
5514: oJumpForward 5519
5516: Choice Lookup Table
          13   5457
5519: oReturn
5520: oLocalSpace 0
5522: oReturn
5523: oLocalSpace 0
5525: oReturn
5526: oLocalSpace 1
5528: oGetAddrLocal 1
5530: oPushResult
5531: oTypeSNodeType
5532: oAssign
5533: oTypeSPop
5534: oGetLocal 1
5536: oPushResult
5537: oTypeSNodeType
5538: oPushResult
5539: equal_node_type
5540: oPop 2
5542: oChoice 5548
5544: oError 14
5546: oJumpForward 5551
5548: Choice Lookup Table
           0   5544
5551: oReturn
5552: oLocalSpace 0
5554: oTypeSNodeType
5555: oChoice 5559
5557: oJumpForward 5564
5559: Choice Lookup Table
          18   5557
5562: oError 7
5564: oTypeSPop
5565: oReturn
5566: oLocalSpace 0
5568: oTypeSNodeType
5569: oChoice 5573
5571: oJumpForward 5578
5573: Choice Lookup Table
          18   5571
5576: oError 7
5578: oReturn
5579: oLocalSpace 0
5581: oTypeSNodeType
5582: oChoice 5586
5584: oJumpForward 5591
5586: Choice Lookup Table
          19   5584
5589: oError 8
5591: oTypeSPop
5592: oReturn
5593: oLocalSpace 0
5595: oTypeSNodeType
5596: oChoice 5600
5598: oJumpForward 5605
5600: Choice Lookup Table
          19   5598
5603: oError 8
5605: oReturn
5606: oLocalSpace 1
5608: oGetAddrLocal 1
5610: oPushResult
5611: oGetParam 2
5613: oPushResult
5614: oNodeNew
5615: oPop 1
5617: oAssign
5618: oGetLocal 1
5620: oPushResult
5621: oSetResult 2
5623: oPushResult
5624: oGetParam 1
5626: oPushResult
5627: oNodeSetInt
5628: oPop 3
5630: oGetLocal 1
5632: oPushResult
5633: oTypeAdd
5634: oPop 1
5636: oGetLocal 1
5638: oReturn
5639: oReturn
5640: oLocalSpace 1
5642: oGetAddrLocal 1
5644: oPushResult
5645: oGetParam 3
5647: oPushResult
5648: oNodeNew
5649: oPop 1
5651: oAssign
5652: oGetLocal 1
5654: oPushResult
5655: oSetResult 4
5657: oPushResult
5658: oGetParam 1
5660: oPushResult
5661: oNodeSetInt
5662: oPop 3
5664: oGetLocal 1
5666: oReturn
5667: oReturn
5668: oLocalSpace 1
5670: oGetAddrLocal 1
5672: oPushResult
5673: oGetParam 1
5675: oPushResult
5676: oSetResult 18
5678: oPushResult
5679: oNodeGet
5680: oPop 2
5682: oAssign
5683: oGetLocal 1
5685: oPushResult
5686: oNodeNull
5687: oPop 1
5689: oChoice 5745
5691: oGetAddrLocal 1
5693: oPushResult
5694: oSetResult 23
5696: oPushResult
5697: oNodeNew
5698: oPop 1
5700: oAssign
5701: oGetLocal 1
5703: oPushResult
5704: oSetResult 19
5706: oPushResult
5707: oGetParam 1
5709: oPushResult
5710: oNodeSet
5711: oPop 3
5713: oGetLocal 1
5715: oPushResult
5716: oSetResult 2
5718: oPushResult
5719: oSetResult 8
5721: oPushResult
5722: oNodeSetInt
5723: oPop 3
5725: oGetLocal 1
5727: oPushResult
5728: oTypeAdd
5729: oPop 1
5731: oGetParam 1
5733: oPushResult
5734: oSetResult 18
5736: oPushResult
5737: oGetLocal 1
5739: oPushResult
5740: oNodeSet
5741: oPop 3
5743: oJumpForward 5748
5745: Choice Lookup Table
           1   5691
5748: oGetLocal 1
5750: oReturn
5751: oReturn
5752: oLocalSpace 0
5754: oGetParam 1
5756: oPushResult
5757: oNodeType
5758: oPop 1
5760: oChoice 5788
5762: oMININT
5763: oReturn
5764: oJumpForward 5802
5766: oSetResult 0
5768: oReturn
5769: oJumpForward 5802
5771: oSetResult 0
5773: oReturn
5774: oJumpForward 5802
5776: oGetParam 1
5778: oPushResult
5779: oSetResult 21
5781: oPushResult
5782: oNodeGetInt
5783: oPop 2
5785: oReturn
5786: oJumpForward 5802
5788: Choice Lookup Table
          25   5776
          21   5771
          19   5766
          18   5762
5797: oError 3
5799: oSetResult 0
5801: oReturn
5802: oReturn
5803: oLocalSpace 0
5805: oGetParam 1
5807: oPushResult
5808: oSetResult 6
5810: oPushResult
5811: oNodeGetInt
5812: oPop 2
5814: oPushResult
5815: oEmitInt
5816: oPop 1
5818: oReturn
5819: oLocalSpace 1
5821: oGetAddrGlobal 2
5823: oPushResult
5824: oSetResult 17
5826: oPushResult
5827: oSetResult 4
5829: oPushResult
5830: oCall 5606
5832: oPop 2
5834: oAssign
5835: oGetAddrGlobal 3
5837: oPushResult
5838: oSetResult 18
5840: oPushResult
5841: oSetResult 4
5843: oPushResult
5844: oCall 5606
5846: oPop 2
5848: oAssign
5849: oGetAddrGlobal 4
5851: oPushResult
5852: oSetResult 19
5854: oPushResult
5855: oSetResult 1
5857: oPushResult
5858: oCall 5606
5860: oPop 2
5862: oAssign
5863: oGetAddrGlobal 5
5865: oPushResult
5866: oSetResult 20
5868: oPushResult
5869: oSetResult 1
5871: oPushResult
5872: oCall 5606
5874: oPop 2
5876: oAssign
5877: oGetAddrGlobal 6
5879: oPushResult
5880: oSetResult 21
5882: oPushResult
5883: oSetResult 1
5885: oPushResult
5886: oCall 5606
5888: oPop 2
5890: oAssign
5891: oGetAddrGlobal 7
5893: oPushResult
5894: oSetResult 22
5896: oPushResult
5897: oSetResult 256
5899: oPushResult
5900: oCall 5606
5902: oPop 2
5904: oAssign
5905: oGetAddrLocal 1
5907: oPushResult
5908: oSetResult 10
5910: oPushResult
5911: oSetResult 5
5913: oPushResult
5914: oIdAdd_File
5915: oPushResult
5916: oCall 5640
5918: oPop 3
5920: oAssign
5921: oGetLocal 1
5923: oPushResult
5924: oSetResult 5
5926: oPushResult
5927: oGetGlobal 2
5929: oPushResult
5930: oNodeSet
5931: oPop 3
5933: oGetLocal 1
5935: oPushResult
5936: oScopeDeclare
5937: oPop 1
5939: oGetAddrLocal 1
5941: oPushResult
5942: oSetResult 10
5944: oPushResult
5945: oSetResult 5
5947: oPushResult
5948: oIdAdd_Integer
5949: oPushResult
5950: oCall 5640
5952: oPop 3
5954: oAssign
5955: oGetLocal 1
5957: oPushResult
5958: oSetResult 5
5960: oPushResult
5961: oGetGlobal 3
5963: oPushResult
5964: oNodeSet
5965: oPop 3
5967: oGetLocal 1
5969: oPushResult
5970: oScopeDeclare
5971: oPop 1
5973: oGetAddrLocal 1
5975: oPushResult
5976: oSetResult 10
5978: oPushResult
5979: oSetResult 5
5981: oPushResult
5982: oIdAdd_Boolean
5983: oPushResult
5984: oCall 5640
5986: oPop 3
5988: oAssign
5989: oGetLocal 1
5991: oPushResult
5992: oSetResult 5
5994: oPushResult
5995: oGetGlobal 4
5997: oPushResult
5998: oNodeSet
5999: oPop 3
6001: oGetLocal 1
6003: oPushResult
6004: oScopeDeclare
6005: oPop 1
6007: oGetAddrLocal 1
6009: oPushResult
6010: oSetResult 10
6012: oPushResult
6013: oSetResult 5
6015: oPushResult
6016: oIdAdd_Char
6017: oPushResult
6018: oCall 5640
6020: oPop 3
6022: oAssign
6023: oGetLocal 1
6025: oPushResult
6026: oSetResult 5
6028: oPushResult
6029: oGetGlobal 6
6031: oPushResult
6032: oNodeSet
6033: oPop 3
6035: oGetLocal 1
6037: oPushResult
6038: oScopeDeclare
6039: oPop 1
6041: oGetAddrLocal 1
6043: oPushResult
6044: oSetResult 10
6046: oPushResult
6047: oSetResult 5
6049: oPushResult
6050: oIdAdd_String
6051: oPushResult
6052: oCall 5640
6054: oPop 3
6056: oAssign
6057: oGetLocal 1
6059: oPushResult
6060: oSetResult 5
6062: oPushResult
6063: oGetGlobal 7
6065: oPushResult
6066: oNodeSet
6067: oPop 3
6069: oGetLocal 1
6071: oPushResult
6072: oScopeDeclare
6073: oPop 1
6075: oGetAddrLocal 1
6077: oPushResult
6078: oSetResult 9
6080: oPushResult
6081: oSetResult 4
6083: oPushResult
6084: oIdAdd_True
6085: oPushResult
6086: oCall 5640
6088: oPop 3
6090: oAssign
6091: oGetLocal 1
6093: oPushResult
6094: oSetResult 5
6096: oPushResult
6097: oGetGlobal 4
6099: oPushResult
6100: oNodeSet
6101: oPop 3
6103: oGetLocal 1
6105: oPushResult
6106: oSetResult 6
6108: oPushResult
6109: oSetResult 1
6111: oPushResult
6112: oNodeSetInt
6113: oPop 3
6115: oGetLocal 1
6117: oPushResult
6118: oScopeDeclare
6119: oPop 1
6121: oGetAddrLocal 1
6123: oPushResult
6124: oSetResult 9
6126: oPushResult
6127: oSetResult 4
6129: oPushResult
6130: oIdAdd_False
6131: oPushResult
6132: oCall 5640
6134: oPop 3
6136: oAssign
6137: oGetLocal 1
6139: oPushResult
6140: oSetResult 5
6142: oPushResult
6143: oGetGlobal 4
6145: oPushResult
6146: oNodeSet
6147: oPop 3
6149: oGetLocal 1
6151: oPushResult
6152: oSetResult 6
6154: oPushResult
6155: oSetResult 0
6157: oPushResult
6158: oNodeSetInt
6159: oPop 3
6161: oGetLocal 1
6163: oPushResult
6164: oScopeDeclare
6165: oPop 1
6167: oReturn
