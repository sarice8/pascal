   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_mysystem >> int
   2:     oIdAdd_ShortStringAppendShortString >> int
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_Pointer >> int
   2:     oIdAdd_ShortString >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
   2: int     id_ShortStringAppendShortString
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
 370: FindSelectSystemDecls( Node unit ):
 372:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
 389:       | true :
 390:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, id_ShortStringAppendShortString )
      
 408:       | * :
 413:    ]
 414:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 414: Uses( int id, Node user ):
 416:    Node unit = @FindOrCompileUnit( id )
 427:    [ equal_node( unit, Null )
 437:       | false :
 438:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 450:          Node unitRef = oNodeNew( nUnitRef )
 460:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 479:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 498:          oScopeDeclare( unitRef )
 504:       | * :
 509:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 510: ResolveUnitRef( inout Node decl ):
 512:    [ oNodeType( decl )
 519:       | nUnitRef :
 520:          Node scope = oNodeGet( decl, qPublicScope )
 533:          '.'
 535:          pIdent
 537:          decl = oScopeFindRequireInScope( scope )
 547:       | * :
 552:    ];
      
      
 553: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 555:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 568:    {
 568:       Node unit = oNodeIterValue( unitIt )
 578:       [ oNodeNull( unit )
 585:          | false :
 586:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 599:          | * :
 604:             >
 606:       ]
 606:       oNodeIterNext( unitIt )
 612:    }
 615:    ;
      
 615: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 617:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 630:    {
 630:       Node unit = oNodeIterValue( unitIt )
 640:       [ oNodeNull( unit )
 647:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 648:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 664:                | true :
 665:                | false :  #eInternalScopeMismatch
 669:             ]
 677:             oScopeEnd
 678:          | * :
 683:             >
 685:       ]
 685:       oNodeIterPrev( unitIt )
 691:    }
 694:    ;
      
      
 694: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 696:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 715:    [ equal_node( unit, Null )
 725:       | false :  >> unit
 729:       | * :
 734:    ]
      
         % If not, search for the source file on disk
 734:    boolean ok = oIncludeUnitFile( id )
 744:    [ ok
 747:       | false :  #eCantFindUnitFile  >> Null
 753:       | * :
 758:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 758:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 764:    oIncludeEnd
 765:    >> unit;
      
      
      
 769: Unit >> Node:
 771:    pUnit
 773:    pIdent
 775:    Node unit = oNodeNew( nUnit )
 785:    oNodeSetInt( unit, qIdent, LAST_ID )
 796:    Node unitImpl = oNodeNew( nUnitImpl )
 806:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 817:    oNodeSet( unit, qImpl, unitImpl )
 829:    ';'
      
         % mandatory sections
      
 831:    pInterface
 833:    @UsesMySystem( unit )
 840:    [
 840:       | pUses :   @UsesClause( unit )
 849:       | * :
 854:    ]
 854:    @EnterUsedUnits( unit )
      
 861:    oScopeBegin( 0, allocGlobal )
 870:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 881:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 886:    oScopeBegin( 0, allocDown )
 895:    initScope = oScopeCurrent
 900:    oNodeSet( unit, qInitRoutineScope, initScope )
 912:    oScopeEnd
      
 913:    @UnitInterface( unit )
 920:    oScopeEnd  % interface scope
      
 921:    pImplementation
 923:    @UsesMySystem( unitImpl )
 930:    [
 930:       | pUses :   @UsesClause( unitImpl )
 939:       | * :
 944:    ]
 944:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 951:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 964:    oScopeBegin( 0, allocGlobal )
 973:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 984:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
1002:    globalScope = oScopeCurrent
1007:    @UnitImplementation( unit )
      
1014:    [
1014:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
1026:       | * :                @UnitInitialization( unit, false )  % implicit init routine
1041:    ]
1041:    [
1041:       | pFinalization :  @UnitFinalization( unit, true )
1053:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1068:    ]
1068:    pEnd  '.'
      
1072:    oScopeEnd  % impl scope
1073:    oScopeEnd  % interface scope
1074:    @EndUsedUnits( unitImpl )  % used units scopes
1081:    @EndUsedUnits( unit )
1088:    oNodeAddLast( workspace, qUnits, unit )
1100:    >> unit;
      
      
1104: UnitInterface( Node unit ):
1106:    {[
1106:       | pConst :     @ConstDecl
1110:       | pType :      @TypeDecl
1114:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1123:       | pProcedure :
1125:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1131:          [
1131:             | pExternal :
1133:                @ExternalDecl( decl )
1140:                ';'
1142:             | * :
1147:          ]
      
1147:       | pFunction :
1149:          Node decl = @FuncHeaderDecl
1155:          [
1155:             | pExternal :
1157:                @ExternalDecl( decl )
1164:                ';'
1166:             | * :
1171:          ]
      
1171:       | * :          >
1186:    ]}
1188:    @FindSelectSystemDecls( unit )
1196:    ;
      
1196: UnitImplementation( Node unit ):
1198:    @BlockDecls( nGlobalVar )
1206:    ;
      
      
1206: UnitInitialization( Node unit, boolean hasStmts ):
1208:    Label label = oLabelNew
1213:    .tLabel  oEmitLabel( label )
1221:    oNodeSetLabel( unit, qInitLabel, label )
      
1233:    int patchLS
1233:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1242:    Node scope
1242:    Code initCode
      
1242:    scope = oNodeGet( unit, qPublicScope )
1255:    initCode = oNodeGetCode( scope, qInitCode )
1268:    oEmitCode( initCode )
1274:    oNodeSetCode( scope, qInitCode, codeNull )
      
1286:    scope = oNodeGet( unit, qPrivateScope )
1299:    initCode = oNodeGetCode( scope, qInitCode )
1312:    oEmitCode( initCode )
1318:    oNodeSetCode( scope, qInitCode, codeNull )
      
1330:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1343:    [ hasStmts
1346:       | true :     
1347:          @Statement
1349:          {[
1349:             | ';' :  @Statement
1353:             | * :    >
1360:          ]}
1362:       | * :
1367:    ]
      
1367:    .tReturn
      
1369:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1381:    oPatch( patchLS, localSpace )
1390:    oScopeEnd   % init routine scope, for temporaries
1392:    ;
      
      
1392: UnitFinalization( Node unit, boolean hasStmts ):
1394:    Label label = oLabelNew
1399:    .tLabel  oEmitLabel( label )
1407:    oNodeSetLabel( unit, qFinalLabel, label )
      
1419:    int patchLS
1419:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1428:    oScopeBegin( 0, allocDown )
      
1437:    [ hasStmts
1440:       | true :     
1441:          @Statement
1443:          {[
1443:             | ';' :  @Statement
1447:             | * :    >
1454:          ]}
1456:       | * :
1461:    ]
      
1461:    .tReturn
      
1463:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1475:    oPatch( patchLS, localSpace )
1484:    oScopeEnd   % final routine scope, for temporaries
1486:    ;
      
      
1486: Block( node_type varNodeType, Label labelForBody ):
1488:    @BlockDecls( varNodeType )
1495:    @BlockStmt( labelForBody, oScopeCurrent, false )
1507:    @CheckForUndefinedLabels
1510:    ;
      
      
1510: BlockDecls( node_type varNodeType ):
1512:    {[
1512:       | pConst :     @ConstDecl
1516:       | pType :      @TypeDecl
1520:       | pVar :       @VarDecl( varNodeType )
1529:       | pLabel :     @LabelDecl
1533:       | pProcedure : @ProcDecl
1537:       | pFunction :  @FuncDecl
1541:       | * :          >
1558:    ]}
1560:    @CheckForUndefinedMethods
1563:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1563: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1566:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1566: CheckForUndefinedLabels:
1568:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1580:    {
1580:       Node decl = oNodeIterValue( it )
1590:       [ oNodeNull( decl )
1597:          | false :
1598:          | * :  >
1605:       ]
1605:       [ oNodeType( decl )
1612:          | nLabel :
1613:             [ oNodeGetBoolean( decl, qDefined )
1623:                | false :
1624:                   [ oNodeGetBoolean( decl, qUsed )
1634:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1637:                      | * :
1642:                   ]
1642:                | * :
1647:             ]
1647:          | * :
1652:       ]
1652:       oNodeIterNext( it )
1658:    }
1661:    ;
      
      
1661: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1663:    NodeIter it = oNodeGetIter( workspace, qUnits )
1676:    {
1676:       Node unit = oNodeIterValue( it )
1686:       [ oNodeNull( unit )
1693:          | true :  >
1696:          | false :
1698:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1706:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1721:             .tFreeActuals  oEmitInt( 0 )
1729:             oNodeIterNext( it )
1735:       ]
1743:    };
      
      
1746: FinalizeUnits:
1748:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1761:    {
1761:       Node unit = oNodeIterValue( it )
1771:       [ oNodeNull( unit )
1778:          | true :  >
1781:          | false :
1783:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1791:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1806:             .tFreeActuals  oEmitInt( 0 )
1814:             oNodeIterPrev( it )
1820:       ]
1828:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1831: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1833:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1841:    int patchLS
1841:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1850:    [ isMain
1853:       | true :  @InitializeUnits
1856:       | * :
1861:    ]
      
         % insert any code for initialization of this scope's variables
1861:    Code initCode = oNodeGetCode( varScope, qInitCode )
1874:    oEmitCode( initCode )
1880:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1892:    @Statement
      
1894:    [ isMain
1897:       | true :  @FinalizeUnits
1900:       | * :
1905:    ]
      
1905:    .tReturn
      
1907:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1919:    oPatch( patchLS, localSpace )
1929:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1929: MethodModifiers( Node decl ):
1931:    {[
1931:       | pCdecl :
1933:          oNodeSetBoolean( decl, qCdecl, true )
1945:          ';'
      
1947:       | * : >
1954:    ]}
1957:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1957: GetOrCreateInitCode( Node scope ) >> Code:
1959:    Code initCode = oNodeGetCode( scope, qInitCode )
1972:    [ equal_code( initCode, codeNull )
1982:       | true :
1983:          initCode = oCodeNew
1988:          oNodeSetCode( scope, qInitCode, initCode )
2000:       | * :
2005:    ]
2005:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
2009: ExternalDecl( Node decl ):
2011:    [ equal_zero( @DeclLevel( decl ) )
2023:       | false :  #eExternalMethodCannotBeNested
2026:       | * :
2031:    ]
2031:    oNodeSetBoolean( decl, qExternal, true )
2043:    [
2043:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
2045:          [
2045:             | pName :
2047:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
2049:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2060:             | * :
2065:          ]
2065:       | * :
2070:    ]
2071:    ;
      
      
2071: ProcHeaderDecl >> Node:
2073:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2075:    boolean redeclaring = false
2081:    Node decl = oScopeFindInCurrentScope
      
2086:    [ oNodeNull( decl )
2093:       | true :
               % first declaration
2094:          decl = @newIdent( nProc, LAST_ID )
2107:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2118:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2120:          redeclaring = true
2126:          [ oNodeGetBoolean( decl, qBodyDefined )
2136:             | true : #eAlreadyDefined
2139:             | * :
2144:          ]
2144:          [ oNodeGetBoolean( decl, qExternal )
2154:             | true : #eAlreadyDefined
2157:             | * :
2162:          ]
2162:          [ oNodeType( decl )
2169:             | nProc :
2170:             | * : #eAlreadyDefined   % wrong kind
2177:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2177:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2196:          oNodeSet( decl, qParams, Null )
2208:    ]
      
2216:    int level = @ScopeLevel
2222:    boolean nested = greater( level, 0 )
2235:    inc( level )
2241:    oScopeBegin( level, allocUp )
2250:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2255:    [ nested
2258:       | true :
2259:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2274:       | * :
2279:    ]
      
2279:    @FormalArgDecl
2281:    oNodeSet( decl, qParams, paramScope )
2293:    oScopeEnd
2294:    ';'
      
2296:    [ redeclaring
2299:       | false : oScopeDeclare( decl )
2306:       | true :  % TO DO: check that qParams is consistent with qOldParams
2308:    ]
      
2316:    @MethodModifiers( decl )
2323:    >> decl;
      
      
2327: ProcDecl:
2329:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2335:    [
2335:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2337:       | pExternal : @ExternalDecl( decl )
      
2346:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2353:          Node paramScope = oNodeGet( decl, qParams )
2366:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2372:          int level = oNodeGetInt( paramScope, qLevel )
2385:          oScopeBegin( level, allocDown )
2394:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2405:          Label label = oNodeGetLabel( decl, qValue )
2418:          @Block( nLocalVar, label )
2428:          oNodeSetBoolean( decl, qBodyDefined, true )
2440:          oScopeEnd
      
2441:          oScopeEnd  % paramScope
2442:    ]
2442:    ';';
      
      
      
2445: FuncHeaderDecl >> Node:
2447:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2449:    boolean redeclaring = false
2455:    Node decl = oScopeFindInCurrentScope
      
2460:    [ oNodeNull( decl )
2467:       | true :
               % first declaration
2468:          decl = @newIdent( nFunc, LAST_ID )
2481:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2492:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2494:          redeclaring = true
2500:          [ oNodeGetBoolean( decl, qBodyDefined )
2510:             | true : #eAlreadyDefined
2513:             | * :
2518:          ]
2518:          [ oNodeType( decl )
2525:             | nFunc :
2526:             | * : #eAlreadyDefined   % wrong kind
2533:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2533:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2552:          oNodeSet( decl, qParams, Null )
2564:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2583:          oNodeSet( decl, qType, Null )
2595:    ]
      
2603:    int level = @ScopeLevel
2609:    boolean nested = greater( level, 0 )
2622:    inc( level )
2628:    oScopeBegin( level, allocUp )
2637:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2642:    [ nested
2645:       | true :
2646:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2661:       | * :
2666:    ]
      
2666:    @FormalArgDecl
2668:    oNodeSet( decl, qParams, paramScope )
      
2680:    ':'
      
2682:    Node theType
2682:    @TypeRef( theType )
2689:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2701:    Node ptrType = @PointerTypeTo( theType )
2712:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2728:    oScopeEnd
2729:    ';'
      
2731:    [ redeclaring
2734:       | false : oScopeDeclare( decl )
2741:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2743:    ]
      
2751:    @MethodModifiers( decl )
      
2758:    >> decl;
      
      
2762: FuncDecl:
2764:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2770:    [
2770:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2772:       | pExternal : @ExternalDecl( decl )
      
2781:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2788:          Node paramScope = oNodeGet( decl, qParams )
2801:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2807:          int level = oNodeGetInt( paramScope, qLevel )
2820:          oScopeBegin( level, allocDown )
2829:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2840:          Label label = oNodeGetLabel( decl, qValue )
2853:          @Block( nLocalVar, label )
2863:          oNodeSetBoolean( decl, qBodyDefined, true )
2875:          oScopeEnd
      
2876:          oScopeEnd  % paramScope
2877:    ]
2877:    ';';
      
      
2880: FormalArgDecl:
2882:    [
2882:       | '(' :
2884:          {
2884:             NodeVec decls = oNodeVecNew
2889:             Node decl
2889:             boolean isInOut = false
      
2895:             [
2895:                | pVar : isInOut = true
2903:                | * :
2908:             ]
      
2908:             {  pIdent
      
2910:                decl = @newIdent( nParam, LAST_ID )
2923:                oNodeSetBoolean( decl, qInOut, isInOut )
2935:                oNodeVecAppend( decls, decl )
      
2944:                [
2944:                   | ':' : >
2948:                   | ',' :
2950:                ]
2958:             }
      
2960:             Node theType
2960:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2967:             Node allocType
2967:             [ isInOut
2970:                | true :   allocType = @PointerTypeTo( theType )
2982:                | * :      allocType = theType
2993:             ]
      
2993:             int i = 0
2999:             {[ equal( i, oNodeVecSize( decls ) )
3013:                | false :
3014:                   decl = oNodeVecElement( decls, i )
      
3027:                   oNodeSet( decl, qType, theType )
3039:                   oScopeDeclare( decl )
3045:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3061:                   inc( i )
3067:                | * :
3072:                   >
3074:             ]}
      
3076:             oNodeVecDelete( decls )
      
3082:             [
3082:                | ')' : >
3086:                | ';' :
3088:             ]
3096:          }
3098:       | * :
3103:    ];
      
      
3104: ConstDecl:
3106:    {[
3106:       | pIdent :
3108:          [
3108:             | ':' :
3110:                @TypedConstDecl
3112:             | * :
3117:                @UntypedConstDecl
3119:          ]
3119:       | * :
3124:          >
3126:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3129: UntypedConstDecl:
3131:    Node decl = @newIdent( nConst, LAST_ID )
3144:    '='
      
3146:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3148:    int val = oValueTop
3153:    oValuePop
3154:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3166:    oNodeSet( decl, qType, IntegerType )
      
3178:    oScopeDeclare( decl )
3184:    ';'
3187:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3187: TypedConstDecl:
3189:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3202:    Node theType
3202:    @TypeRef( theType )
3209:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3221:    [ oNodeType( theType )
3228:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3229:          '='
      
3231:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3233:          int val = oValueTop
3238:          oValuePop
3239:          oNodeSetInt( decl, qValue, val )
3251:          oScopeDeclare( decl )
3257:          ';'
      
3259:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3261:          #eNotImplemented
      
3263:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3265:          oScopeEnter( globalScope )
3271:          int addr = oScopeAllocType( theType )
3281:          oScopeEnd
3282:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3293:          oNodeSetInt( decl, qValue, addr )
3305:          '='
3307:          @TypedConstInit( theType, addr )
3317:          oCodePop
3318:          oScopeDeclare( decl )
3324:          ';'
3326:    ]
3353:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3353: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3355:    [ oNodeType( theType )
3362:       | nArrayType :
3363:          Node baseType = oNodeGet( theType, qBaseType )
3376:          Node indexType = oNodeGet( theType, qIndexType )
3389:          int low = @OrdinalLow( indexType )
3400:          int high = @OrdinalHigh( indexType )
3411:          int elementSize = oNodeGetInt( baseType, qSize )
      
3424:          '('
               % Loop over elements
3426:          int i = low
3432:          {
3432:             @TypedConstInit( baseType, addr )
3442:             [ equal( i, high )
3452:                | true : >
3455:                | false :
3457:             ]
3465:             ','
3467:             addr = add( addr, elementSize )
3480:             inc( i )
3486:          }
3488:          ')'
      
3490:       | nRecordType :
3492:          '('
3494:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3507:          {
3507:             [
3507:                | pIdent :
3509:                | * :  >
3516:             ]
3516:             Node field = oScopeFindRequireInScope( fieldScope )
3526:             ':'
3528:             Node fieldType = oNodeGet( field, qType )
3541:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3561:             @TypedConstInit( fieldType, fieldAddr )
3571:             [
3571:                | ';' :
3573:                | * :  >
3580:             ]
3580:          }
3582:          ')'
      
3584:       | nBooleanType, nByteType, nCharType:
3586:          .tPushAddrGlobal  oEmitInt( addr )
3594:          @ConstExpr
3596:          .tPushConstI  oEmitInt( oValueTop )
3603:          oValuePop
3604:          .tAssignB
      
3606:       | nIntegerType, nEnumType:
3608:          .tPushAddrGlobal  oEmitInt( addr )
3616:          @ConstExpr
3618:          .tPushConstI  oEmitInt( oValueTop )
3625:          oValuePop
3626:          .tAssignI
      
3628:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3630:          #eNotImplemented
3632:    ]
3659:    ;
      
      
3659: TypeDecl:
3661:    {[
3661:       | pIdent :
3663:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3676:          '='
3678:          Node theType
3678:          @TypeRef( theType )
3685:          oNodeSet( decl, qType, theType )
3697:          oScopeDeclare( decl )
3703:          ';'
3705:       | * :
3710:          >
3712:    ]};
      
3715: VarDecl( node_type varNodeType ):
3717:    {[
3717:       | pIdent :
3719:          NodeVec decls = oNodeVecNew
3724:          Node decl
3724:          {
3724:             decl = @newIdent( varNodeType, LAST_ID )
3737:             oNodeVecAppend( decls, decl )
3746:             [
3746:                | ',' :
3748:                   pIdent
3750:                | * :
3755:                   >
3757:             ]
3757:          }
3759:          ':'
3761:          Node theType
3761:          @TypeRef( theType )
      
3768:          int i = 0
3774:          {[ equal( i, oNodeVecSize( decls ) )
3788:             | false :
3789:                decl = oNodeVecElement( decls, i )
3802:                oNodeSet( decl, qType, theType )
3814:                oScopeDeclareAlloc( decl )
3820:                inc( i )
3826:             | * :
3831:               >
3833:          ]}
      
               % optional initialization
3835:          [
3835:             | '=' :
3837:                [ oNodeVecSize( decls )
3844:                   | 1 :
3845:                   | * :  #eOnlyOneVarCanBeInitialized
3852:                ]
      
                     % we need an initCode stream for this scope
3852:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3862:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3868:                boolean changedScope = false
3874:                [ equal_zero( @ScopeLevel )
3881:                   | true : oScopeEnter( initScope )
3888:                            changedScope = true
3894:                   | * :
3899:                ]
                     % generate assignment in initCode stream
3899:                @LValueVar( decl, true )
3909:                @Expr
3911:                @CoerceType
3913:                @Assign
3915:                [ changedScope
3918:                   | true : oScopeEnd
3920:                   | * :
3925:                ]
3925:                oCodePop
                   
3926:             | * :
3931:          ]
      
3931:          oNodeVecDelete( decls )
3937:          ';'
3939:       | * :
3944:          >
3946:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3949: LabelDecl:
3951:    {
3951:       Node decl
3951:       [
3951:          | pIdent :
3953:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3955:             oChangeIntLitToLabelIdent
3956:       ]
3964:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3977:       Label label = oLabelNew
3982:       oNodeSetLabel( decl, qValue, label )
3994:       oScopeDeclare( decl )
4000:       [
4000:          | ',' :
4002:          | * :
4007:             >
4009:       ]
4009:    }
4011:    ';'
4014:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
4014: TypeRef( out Node resultType ):
4016:    [
4016:       | pIdent :           % previously named type (including intrinsics)
4018:          Node decl = oScopeFindRequire
4023:          @ResolveUnitRef( decl )
4030:          [ oNodeType( decl )
4037:             | nTypeDecl :
4038:                resultType = oNodeGet( decl, qType )
4051:             | * :
4056:                #eNotType
4058:                resultType = IntegerType
4064:          ]
         
4064:       | pArray :
4066:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4068:          NodeVec dimensions = oNodeVecNew
      
4073:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4073:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4083:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4095:             @ConstExpr
4097:             oNodeSetInt( subrange, qLow, oValueTop )
4108:             oValuePop
4109:             '..'
4111:             @ConstExpr
4113:             oNodeSetInt( subrange, qHigh, oValueTop )
4124:             oValuePop
4125:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4137:             oTypeAdd( subrange )
      
4143:             Node a = oNodeNew( nArrayType )
4153:             oNodeSet( a, qIndexType, subrange )
      
4165:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4174:             [
4174:                | ']' : >
4178:                | ',' :
4180:             ]
4188:          }
      
4190:          pOf
4192:          Node baseType
4192:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4199:          int dim = oNodeVecSize( dimensions )
      
4209:          {
4209:              dec(dim)
      
4215:              Node a = oNodeVecElement( dimensions, dim )
      
4228:              oNodeSet( a, qBaseType, baseType )
4240:              Node subrange = oNodeGet( a, qIndexType )
4253:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4280:              inc( width )
4286:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4312:              oTypeAdd( a )
4318:              baseType = a
      
4324:              [ equal_zero(dim)
4331:                  | true:  >
4334:                  | *:
4339:              ]
4339:          }
      
4341:          resultType = oNodeVecElement( dimensions, 0 )
4354:          oNodeVecDelete( dimensions )
      
4360:       | '^' :
4362:          Node theType
4362:          @TypeRef( theType )
4369:          resultType = @PointerTypeTo( theType )
      
4380:       | pRecord :
4382:          resultType = oNodeNew( nRecordType )
4392:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4401:          @VarDecl( nRecordField )
      
4408:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4420:          [ equal_zero( size )
4427:             | true : #eRecordEmpty
4430:             | * :
4435:          ]
      
4435:          pEnd
      
4437:          oNodeSet( resultType, qScope, oScopeCurrent )
4448:          oNodeSetInt( resultType, qSize, size )
4460:          oScopeEnd
4461:          oTypeAdd( resultType )
      
      
4467:       | '(' :
               % An enum type declaration.
4469:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4476:       | pSet :
4478:          pOf
4480:          Node theType
4480:          @TypeRef( theType )
4487:       | * :       % this works for cases except where expr starts with an id
4502:          @ConstExpr '..' @ConstExpr
4508:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4509: EnumTypeRef( out Node resultType ):
      
4511:    resultType = oNodeNew( nEnumType )
4521:    int value = 0
4527:    int numValues = 0
4533:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4539:    Node outerScope = oScopeCurrent
4544:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4553:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4553:       pIdent
4555:       Node decl = @newIdent( nEnumValue, LAST_ID )
4568:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4581:       oNodeSet( decl, qType, resultType )
4593:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4605:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4618:       oNodeSetInt( decl, qNameOffset, nameOffset )
4630:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4642:       [
4642:          | '=', ':=' :
4644:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4646:             [ equal_zero( numValues )
4653:                | false :
4654:                   [ greater( oValueTop, value )
4663:                      | false :   #eEnumValueNotAscending
4666:                      | * :
4671:                   ]
4671:                | * :
4676:             ]
4676:             [ equal( value, oValueTop )
4685:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4686:                   oNodeSetBoolean( resultType, qHasGap, true )
4698:                | * :
4703:             ]
4703:             value = oValueTop
4708:             oValuePop
4709:          | * :
4716:       ]
4716:       oNodeSetInt( decl, qValue, value )
4728:       oNodeSetInt( decl2, qValue, value )
4740:       oScopeDeclare( decl )
      
4746:       oScopeEnter( outerScope )
4752:       oScopeDeclare( decl2 )
4758:       oScopeEnd
      
4759:       inc( value )
4765:       inc( numValues )
4771:       [
4771:          | ',' :
4773:          | * :    >
4780:       ]
4780:    }
4782:    ')'
      
4784:    oNodeSet( resultType, qScope, oScopeCurrent )
4795:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4807:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4808:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4819:    oScopeEnter( globalScope )
4825:    int size = multiply( add( numValues, 1 ), 16 )
4845:    int addr = oScopeAlloc( size, 8 )
4858:    oScopeEnd
4859:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4871:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4891:    {
4891:       Node enumValue = oNodeIterValue( it )
4901:       [ oNodeNull( enumValue )
4908:          | true :  >
4911:          | * :
4916:       ]
4916:       .tPushAddrGlobal  oEmitInt( addr )
4924:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4939:       .tAssignI
4941:       addr = add( addr, 8 )
4954:       .tPushAddrGlobal  oEmitInt( addr )
4962:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4977:       .tAssignP
4979:       addr = add( addr, 8 )
4992:       oNodeIterNext( it )
4998:    }
         % final table entry
5000:    .tPushAddrGlobal  oEmitInt( addr )
5008:    .tPushConstI  oEmitInt( 0 )
5016:    .tAssignI
5018:    addr = add( addr, 8 )
5031:    .tPushAddrGlobal  oEmitInt( addr )
5039:    .tPushConstI  oEmitInt( 0 )
5047:    .tAssignP
5049:    addr = add( addr, 8 )
5062:    oCodePop
      
5063:    oTypeAdd( resultType )
5070:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
5070: ConstExpr:
5072:    [
5072:       | pIntLit :
5074:          oValuePush( TOKEN_VALUE )
5079:       | pIdent :
5081:          Node decl = oScopeFindRequire
5086:          @ResolveUnitRef( decl )
5093:          [ oNodeType( decl )
5100:             | nConst :
5101:                oValuePush( oNodeGetInt( decl, qValue ) )
5114:             | * :
5119:                #eNotConst
5121:                oValuePush( 0 )
5127:          ]
5127:       | pMinus :
5129:          @ConstExpr
5131:          oValueNegate
5132:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5143: Expr:
5145:    Label falseLabel = labelNull
      
5151:    @ExprAllowCF( falseLabel )
5158:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5166: BooleanExprControlFlow( out Label falseLabel ):
5168:    @ExprAllowCF( falseLabel )
5175:    [ oTypeSNodeType
5177:       | nBooleanCFType :
5178:       | nBooleanType :
               % convert value to control flow
5180:          falseLabel = oLabelNew
5185:          .tJumpFalse  oEmitLabel( falseLabel )
5193:       | * :
5200:          #eNotBoolean
5202:    ]
5202:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5204: CFToVal( inout Label falseLabel ):
5206:    [ oTypeSNodeType
5208:       | nBooleanCFType :
5209:          Label doneLabel = oLabelNew
5214:          .tPushConstI  oEmitInt( 1 )
5222:          .tJump  oEmitLabel( doneLabel )
5230:          .tLabel  oEmitLabel( falseLabel )
5238:          .tPushConstI  oEmitInt( 0 )
5246:          .tLabel  oEmitLabel( doneLabel )
5254:          oTypeSPop
5255:          oTypeSPush( BooleanType )
5261:          falseLabel = labelNull
5267:       | * :
5272:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5273: ValToCF( out Label falseLabel ):
5275:    [ oTypeSNodeType
5277:       | nBooleanType :
5278:          falseLabel = oLabelNew
5283:          .tJumpFalse  oEmitLabel( falseLabel )
5291:          oTypeSPop
5292:          oTypeSPush( BooleanCFType )
5298:       | * :
5303:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5304: ExprAllowCF( out Label falseLabel ):
5306:    @BoolExprAllowCF( falseLabel )
5313:    {[
5313:       | '=' :
5315:          @CFToVal( falseLabel )
5322:          @PromoteToIntOptional
5324:          @BoolExprAllowCF( falseLabel )
5331:          @CFToVal( falseLabel )
5338:          @PromoteToIntOptional
5340:          @MatchTypes
5342:          [ oTypeSNodeType
5344:             | nBooleanType, nCharType :     .tEqualB
5347:             | nIntegerType, nEnumType :     .tEqualI
5351:             | nPointerType, nUniversalPointerType :    .tEqualP
5355:             | nShortStringType, nStrLitType :            #eNotImplemented
5359:             | * :                           #eNotAllowed
5380:          ]
5380:          oTypeSPop
5381:          oTypeSPush( BooleanType )
      
5387:       | '<>' :
5389:          @CFToVal( falseLabel )
5396:          @PromoteToIntOptional
5398:          @BoolExprAllowCF( falseLabel )
5405:          @CFToVal( falseLabel )
5412:          @PromoteToIntOptional
5414:          @MatchTypes
5416:          [ oTypeSNodeType
5418:             | nBooleanType, nCharType :     .tNotEqualB
5421:             | nIntegerType, nEnumType :     .tNotEqualI
5425:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5429:             | nShortStringType, nStrLitType :            #eNotImplemented
5433:             | * :                           #eNotAllowed
5454:          ]
5454:          oTypeSPop
5455:          oTypeSPush( BooleanType )
      
5461:       | '<' :
5463:          @CFToVal( falseLabel )
5470:          @PromoteToIntOptional
5472:          @BoolExprAllowCF( falseLabel )
5479:          @CFToVal( falseLabel )
5486:          @PromoteToIntOptional
5488:          @MatchTypes
5490:          [ oTypeSNodeType
5492:             | nBooleanType, nCharType :     .tLessB
5495:             | nIntegerType, nEnumType :     .tLessI
5499:             | nPointerType, nUniversalPointerType :   .tLessP
5503:             | nShortStringType, nStrLitType :            #eNotImplemented
5507:             | * :                           #eNotAllowed
5528:          ]
5528:          oTypeSPop
5529:          oTypeSPush( BooleanType )
      
5535:       | '>' :
5537:          @CFToVal( falseLabel )
5544:          @PromoteToIntOptional
5546:          @BoolExprAllowCF( falseLabel )
5553:          @CFToVal( falseLabel )
5560:          @PromoteToIntOptional
5562:          @MatchTypes
5564:          [ oTypeSNodeType
5566:             | nBooleanType, nCharType :     .tGreaterB
5569:             | nIntegerType, nEnumType :     .tGreaterI
5573:             | nPointerType, nUniversalPointerType :   .tGreaterP
5577:             | nShortStringType, nStrLitType :            #eNotImplemented
5581:             | * :                           #eNotAllowed
5602:          ]
5602:          oTypeSPop
5603:          oTypeSPush( BooleanType )
      
5609:       | '<=' :
5611:          @CFToVal( falseLabel )
5618:          @PromoteToIntOptional
5620:          @BoolExprAllowCF( falseLabel )
5627:          @CFToVal( falseLabel )
5634:          @PromoteToIntOptional
5636:          @MatchTypes
5638:          [ oTypeSNodeType
5640:             | nBooleanType, nCharType :     .tLessEqualB
5643:             | nIntegerType, nEnumType :     .tLessEqualI
5647:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5651:             | nShortStringType, nStrLitType :            #eNotImplemented
5655:             | * :                           #eNotAllowed
5676:          ]
5676:          oTypeSPop
5677:          oTypeSPush( BooleanType )
      
5683:       | '>=' :
5685:          @CFToVal( falseLabel )
5692:          @PromoteToIntOptional
5694:          @BoolExprAllowCF( falseLabel )
5701:          @CFToVal( falseLabel )
5708:          @PromoteToIntOptional
5710:          @MatchTypes
5712:          [ oTypeSNodeType
5714:             | nBooleanType, nCharType :     .tGreaterEqualB
5717:             | nIntegerType, nEnumType :     .tGreaterEqualI
5721:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5725:             | nShortStringType, nStrLitType :            #eNotImplemented
5729:             | * :                           #eNotAllowed
5750:          ]
5750:          oTypeSPop
5751:          oTypeSPush( BooleanType )
      
5757:       | * :
5772:          >
5774:    ]};
      
      
5777: BoolExprAllowCF( out Label falseLabel ):
5779:    Label trueLabel = labelNull
      
5785:    @BoolTermAllowCF( falseLabel )
5792:    {[
5792:       | pOr :
5794:          [ oTypeSNodeType
5796:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5797:                [ equal_label( trueLabel, labelNull )
5807:                   | true :  trueLabel = oLabelNew
5813:                   | * :
5818:                ]
5818:                .tJump  oEmitLabel( trueLabel )
5826:             | nBooleanType :
5828:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5835:                [ equal_label( trueLabel, labelNull )
5845:                   | true :  trueLabel = oLabelNew
5851:                   | * :
5856:                ]
5856:                .tJump  oEmitLabel( trueLabel )
5864:             | * : #eNotBoolean
5873:          ]
5873:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5874:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5882:          falseLabel = labelNull
5888:          @BoolTermAllowCF( falseLabel )
      
5895:          [ oTypeSNodeType
5897:             | nBooleanCFType :
5898:             | nBooleanType :
5900:                @ValToCF( falseLabel )
5907:             | * : #eNotBoolean
5916:          ]
      
5916:          oTypeSPop
5917:          oTypeSPush( BooleanCFType )
      
5923:       | * :
5928:          >
5930:    ]}
      
         % any short-circuit trues jump here to the end
5932:    [ equal_label( trueLabel, labelNull )
5942:       | false :
5943:          .tLabel  oEmitLabel( trueLabel )
5951:       | * :
5956:    ]
5957:    ;
      
      
5957: BoolTermAllowCF( out Label falseLabel ):
5959:    Label overallFalseLabel = labelNull
      
5965:    @BoolFactorAllowCF( falseLabel )
5972:    {[
5972:       | pAnd :
5974:          [ oTypeSNodeType
5976:             | nBooleanCFType :
5977:             | nBooleanType :
5979:                @ValToCF( falseLabel )
5986:             | * :
5993:                #eNotBoolean
5995:          ]
5995:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5996:          [ equal_label( overallFalseLabel, labelNull )
6006:             | true :
6007:                overallFalseLabel = oLabelNew
6012:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6026:                falseLabel = overallFalseLabel
6032:             | * :
6037:          ]
      
6037:          Label factorFalseLabel = labelNull
6043:          @BoolFactorAllowCF( factorFalseLabel )
      
6050:          [ oTypeSNodeType
6052:             | nBooleanCFType :
6053:             | nBooleanType :
6055:                @ValToCF( factorFalseLabel )
6062:             | * : #eNotBoolean
6071:          ]
6071:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6085:       | * :
6090:          >
6092:    ]};
      
6095: BoolFactorAllowCF( out Label falseLabel ):
6097:    [
6097:       | pNot :
6099:          Label factorFalseLabel = labelNull
      
6105:          @BoolFactorAllowCF( factorFalseLabel )
6112:          [ oTypeSNodeType
6114:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
6115:                falseLabel = oLabelNew
6120:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6128:                .tLabel  oEmitLabel( factorFalseLabel )
      
6136:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6138:                .tNot
      
6140:             | * : #eNotBoolean
6149:          ]
      
6149:       | * :
6154:          @ArithExprAllowCF( falseLabel )
6161:    ];
      
6162: ArithExprAllowCF( out Label falseLabel ):
6164:    boolean first = true
6170:    int tempStrOffset
      
6170:    @TermAllowCF( falseLabel )
6177:    {[
6177:       | '+' :
6179:          [ oTypeSNodeType
6181:             | nIntegerType, nByteType :
6182:                @PromoteToIntPop
6184:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6191:                @PromoteToInt
6193:                .tAddI
      
6195:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6197:                [ first
6200:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6201:                             tempStrOffset = @MoveIntoTempShortString
6207:                             first = false
6213:                   | * :
6218:                ]
6218:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6225:                [ oTypeSNodeType
6227:                   | nShortStringType, nStrLitType :
6228:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6230:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6238:                      oTypeSPush( ShortStringType )
6244:                   | nCharType :
6246:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6248:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6256:                      oTypeSPush( ShortStringType )
6262:                   | * :
6271:                      #eTypeMismatch
6273:                      oTypeSPop
6274:                ]
      
6274:             | nPointerType, nUniversalPointerType :
6276:                Node elementType = oNodeGet( oTypeSTop, qBaseType )
6288:                int elementSize = oNodeGetInt( elementType, qSize )
6301:                @TermAllowCF( falseLabel )  % actually not allowing CF
6308:                @PromoteToIntPop
6310:                [ equal( elementSize, 1 )
6320:                   | false :
6321:                      .tPushConstI  oEmitInt( elementSize )
6329:                      .tMultI
6331:                   | * :
6336:                ]
6336:                .tAddPI
6338:             | * :
6355:                #eNotAllowed
6357:          ]
      
6357:       | '-' :
               % TO DO: pointer arithmetic, as above
      
6359:          @PromoteToIntPop
6361:          @TermAllowCF( falseLabel )
6368:          @PromoteToInt
6370:          .tSubI
6372:       | * :
6379:          >
6381:    ]};
      
6384: TermAllowCF( out Label falseLabel ):
6386:    @FactorAllowCF( falseLabel )
6393:    {[
6393:       | pTimes :
6395:          @PromoteToIntPop
6397:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6404:          @PromoteToInt
6406:          .tMultI
6408:       | pDivide :
6410:          @PromoteToIntPop
6412:          @FactorAllowCF( falseLabel )
6419:          @PromoteToInt
6421:          .tDivI
6423:       | * :
6430:          >
6432:    ]};
      
6435: FactorAllowCF( out Label falseLabel ):
6437:    [
6437:       | pPlus :
6439:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6446:          @PromoteToInt
6448:       | pMinus :
6450:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6457:          @PromoteToInt
6459:          .tNegI
6461:       | * :
6468:          @PrimaryAllowCF( falseLabel )
6475:    ];
      
6476: PrimaryAllowCF( out Label falseLabel ):
6478:    [
6478:       | pIntLit :
6480:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6487:          oTypeSPush( IntegerType )
      
6493:       | pCharLit :
6495:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6502:          oTypeSPush( CharType )
      
6508:       | '(' :
6510:          @ExprAllowCF( falseLabel )
6517:          ')'
      
6519:       | pStrLit :
6521:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6530:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6538:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6544:          @LValueIndexes
               % get final value of dereferencing, if any
6546:          @FetchVar
      
6548:       | pIdent :
6550:          Node decl = oScopeFindRequire
6555:          @ResolveUnitRef( decl )
6562:          Node theType
      
6562:          [ oNodeType( decl )
6569:             | nFunc :
6570:                @Call( decl )
      
6577:             | nBuiltInFunc :
6579:                @CallBuiltInFunc( decl )
      
6586:             | nConst, nEnumValue :
6588:                theType = oNodeGet( decl, qType )
6601:                oTypeSPush( theType )
6607:                [ oTypeSNodeType
6609:                   | nIntegerType, nEnumType, nBooleanType :
6610:                      .tPushConstI @EmitValue( decl )
6619:                   | * :
6628:                      #eNotImplemented
6630:                ]
      
6630:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6632:                @VarExpr( decl )
      
6639:             | * :
6658:                #eNotValue
6660:                oTypeSPush( IntegerType )
6666:          ]
      
6666:       | '@' :        % @var -- pointer to var
6668:          pIdent
      
6670:          Node decl = oScopeFindRequire
6675:          @ResolveUnitRef( decl )
6682:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6682:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6692:          theType = oTypeSTop
6697:          oTypeSPop
6698:          Node ptrType = @PointerTypeTo( theType )
6709:          oTypeSPush( ptrType )
      
6715:       | * :
6730:          #eNotValue
6732:          oTypeSPush( IntegerType )
6738:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6739: VarExpr( Node decl ):
6741:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6754:    int uplevels = @DeclUpLevels( decl )
      
6765:    oTypeSPush( theType )
6771:    [ oTypeSNodeType
6773:       | nIntegerType, nEnumType :
6774:          [ oNodeType( decl )
6781:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6791:             | nLocalVar :
6793:                [ equal_zero( uplevels )
6800:                   | true :  .tPushLocalI  @EmitValue( decl )
6810:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6830:                ]
6830:             | nParam :
6832:                [ oNodeGetBoolean( decl, qInOut )
6842:                   | true :    % VAR param points to the var.  Auto dereference.
6843:                      [ equal_zero( uplevels )
6850:                         | true :  .tPushParamP  @EmitValue( decl )
6860:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6880:                      ]
6880:                      .tFetchI
6882:                   | * :
6887:                      [ equal_zero( uplevels )
6894:                         | true :  .tPushParamI  @EmitValue( decl )
6904:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6924:                      ]
6924:                ]
6924:          ]
      
6936:       | nBooleanType, nByteType, nCharType :
6938:          [ oNodeType( decl )
6945:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6955:             | nLocalVar :
6957:                [ equal_zero( uplevels )
6964:                   | true :  .tPushLocalB  @EmitValue( decl )
6974:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6994:                ]
6994:             | nParam :
6996:                [ oNodeGetBoolean( decl, qInOut )
7006:                   | true :    % VAR param points to the var.  Auto dereference.
7007:                      [ equal_zero( uplevels )
7014:                         | true :  .tPushParamP  @EmitValue( decl )
7024:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7044:                      ]
7044:                      .tFetchB
7046:                   | * :
7051:                      [ equal_zero( uplevels )
7058:                         | true :  .tPushParamB  @EmitValue( decl )
7068:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7088:                      ]
7088:                ]
7088:          ]
      
7100:       | nFileType :
7102:          #eNotImplemented
      
7104:       | nPointerType, nUniversalPointerType :
7106:          [ oNodeType( decl )
7113:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7123:             | nLocalVar :
7125:                [ equal_zero( uplevels )
7132:                   | true :  .tPushLocalP  @EmitValue( decl )
7142:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7162:                ]
7162:             | nParam :
7164:                [ oNodeGetBoolean( decl, qInOut )
7174:                   | true :    % VAR param points to the var.  Auto dereference.
7175:                      [ equal_zero( uplevels )
7182:                         | true :  .tPushParamP  @EmitValue( decl )
7192:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7212:                      ]
7212:                      .tFetchP
7214:                   | * :
7219:                      [ equal_zero( uplevels )
7226:                         | true :  .tPushParamP  @EmitValue( decl )
7236:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7256:                      ]
7256:                ]               
7256:          ]
7268:          [
7268:             | '^' :             % dereferenced
7270:                oTypeSPop
7271:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7284:                @LValueIndexes
7286:                @FetchVar
7288:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7290:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7292:                @LValueIndexes
7294:                @FetchVar
7296:             | * :               % just ptr value alone
7303:          ]
      
7303:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7305:          [ oNodeType( decl )
7312:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7322:             | nLocalVar :
7324:                [ equal_zero( uplevels )
7331:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7341:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7361:                ]
7361:             | nParam :
7363:                [ oNodeGetBoolean( decl, qInOut )
7373:                   | true :    % VAR param points to the var.  Auto dereference.
7374:                      [ equal_zero( uplevels )
7381:                         | true :  .tPushParamP  @EmitValue( decl )
7391:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7411:                      ]
7411:                   | * :
7416:                      [ equal_zero( uplevels )
7423:                         | true :  .tPushAddrParam  @EmitValue( decl )
7433:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7453:                      ]
7453:                ]
7453:          ]
               % modify addr for subscripts, field references, etc
7465:          @LValueIndexes
               % get final value
7467:          @FetchVar
7469:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7496: FetchVar:
7498:    [ oTypeSNodeType
7500:       | nIntegerType, nEnumType :  .tFetchI
7503:       | nBooleanType, nByteType, nCharType :  .tFetchB
7507:       | nFileType :   #eNotImplemented
7511:       | nPointerType :             .tFetchP
7515:       | nUniversalPointerType :    #eCantDereference
7519:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7521:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7550: LValueIndexes:
7552:    {[
7552:       | '[' :
7554:          [ oTypeSNodeType
7556:             | nArrayType :    @ArraySubscripts
7559:             | nPointerType :  @PointerArraySubscript
7563:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7567:             | * :             #eNotArray
7580:          ]
7580:       | '.' :       @RecordFieldRef
7584:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7588:       | * :         >
7599:    ]};
      
7602: ArraySubscripts:
7604:    [ oTypeSNodeType
7606:       | nArrayType :
7607:       | * :       #eNotArray
7614:    ]
7614:    {
7614:       [ oTypeSNodeType
7616:          | nArrayType :
7617:          | * :    #eTooManySubscripts
7624:       ]
      
            % low subscript of this dimension
7624:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7641:       Node baseType
7641:       baseType = oNodeGet( oTypeSTop, qBaseType )
7653:       oTypeSPop
7654:       oTypeSPush( baseType )
      
7660:       @Expr
7662:       @RequireIntPop
            % adjust for low subscript
7664:       [ equal_zero( low )
7671:          | false :
7672:             .tPushConstI oEmitInt( low ) .tSubI
7682:          | * :
7687:       ]
      
            % multiply by element size
7687:       int size = oNodeGetInt( baseType, qSize )
7700:       [ equal( size, 1 )
7710:          | false :
7711:             .tPushConstI oEmitInt( size ) .tMultI
7721:          | * :
7726:       ]
      
            % update start address
7726:       .tAddPI
7728:       [
7728:          | ']' :  >
7732:          | ',' :
7734:       ]
7742:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7745: PointerArraySubscript:
7747:    [ oTypeSNodeType
7749:       | nPointerType :
7750:       | * :    #eCantDereference
7757:    ]
         % replace type stack with base type
7757:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7769:    oTypeSPop
7770:    oTypeSPush( baseType )
         
7776:    @Expr
7778:    @RequireIntPop
         % multiply by element size
7780:    int size = oNodeGetInt( baseType, qSize )
7793:    [ equal( size, 1 )
7803:       | false :
7804:          .tPushConstI  oEmitInt( size )  .tMultI
7814:       | * :
7819:    ]
         % update start address
7819:    .tAddPI
7821:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7824: ShortStringArraySubscript:
7826:    [ oTypeSNodeType
7828:       | nStrLitType, nShortStringType :
7829:       | * :    #eCantDereference
7838:    ]
7838:    oTypeSPop
7839:    oTypeSPush( CharType )
7845:    @Expr
7847:    @RequireIntPop
7849:    .tAddPI
7851:    ']';
      
      
7854: RecordFieldRef:
7856:    [ oTypeSNodeType
7858:       | nRecordType :
7859:       | * :    #eNotRecord
7866:    ]
7866:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7878:    pIdent
7880:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7885:    [ oNodeType( field )
7892:       | nRecordField :
7893:       | * :   #eNotRecordField
7900:    ]
7900:    oScopeEnd
7901:    int offset = oNodeGetInt( field, qValue )
7914:    [ equal_zero( offset )
7921:       | false :
7922:          .tPushConstI oEmitInt( offset ) .tAddPI
7932:       | * :
7937:    ]
      
         % replace the type on the type stack, with the field type
7937:    oTypeSPop
7938:    oTypeSPush( oNodeGet( field, qType ) )
7952:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7952: PointerDeref:
7954:    [ oTypeSNodeType
7956:       | nPointerType :
7957:       | nUniversalPointerType :   #eCantDereference
7961:       | * :       #eNotPointer
7970:    ]
7970:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7972:    Node theType = oTypeSTop
7977:    oTypeSPop
7978:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7992:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7992: CoerceType:
7994:    node_type nt = oTypeSNodeType
7999:    oTypeSPop
8000:    [ equal_node_type( nt, oTypeSNodeType )
8009:       | false :
               % Can we implicitly convert the value to the desired type?
8010:          [ oTypeSNodeType
8012:             | nIntegerType :
8013:                [ nt
8016:                   | nByteType :   .tCastBtoI  >>
8020:                   | * :
8025:                ]
8025:             | nByteType :
8027:                [ nt
8030:                   | nIntegerType :   .tCastItoB  >>
8034:                   | * :
8039:                ]
8039:             | nPointerType :
8041:                [ nt
8044:                   | nUniversalPointerType :  >>
8046:                   | nStrLitType :
8048:                      [ equal_node( oTypeSTop, PCharType )
8057:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8058:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8069:                         | * :
8074:                      ]
8074:                   | * :
8081:                ]
8081:             | nUniversalPointerType :
8083:                [ nt
8086:                   | nPointerType :  >>
8088:                   | * :
8093:                ]
8093:             | nShortStringType :
8095:                [ nt
8098:                   | nStrLitType :  >>
8100:                   | * :
8105:                ]
8105:             | * :
8118:          ]
8118:          #eTypeMismatch
8120:       | * :
8125:    ];
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
8126: MoveIntoTempShortString >> int:
8128:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
8138:    [ oTypeSNodeType
8140:       | nShortStringType, nStrLitType :
8141:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
8149:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
8151:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
8166:       | nCharType :
               % temp[0] = 1
8168:          .tPushAddrLocal  oEmitInt( tempOffset )
8176:          .tPushConstI  oEmitInt( 1 )
8184:          .tAssignB
               % temp[1] = value
8186:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
8201:          .tSwap
8203:          .tAssignB
8205:       | * :   #eTypeMismatch
8216:    ]
8216:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
8217:    .tPushAddrLocal  oEmitInt( tempOffset )
8225:    oTypeSPush( ShortStringType )
8231:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8235: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
8237:    .tAllocActuals  oEmitInt( 16 )
8245:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
8257:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8269:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
8278:    .tFreeActuals  oEmitInt( 16 )
8286:    oTypeSPop
8287:    oTypeSPop
8289:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8289: ShortStringAppendChar:
8291:    #eNotImplemented
8293:    oTypeSPop
8294:    oTypeSPop
8296:    ;
      
      
      
      % Called on first use of an extern method
      %
8296: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
8298:    int strAddr
8298:    String externalName = oNodeGetString( method, qExternalName )
8311:    [ equal_string( externalName, stringNull )
8321:       | true :
8322:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
8343:       | false :
8345:          strAddr = oStringAllocLit( externalName )
8355:    ]
8363:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
8379:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8379: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
8381:    [ oNodeGetBoolean( method, qExternal )
8391:       | true :
8392:          [ oNodeGetBoolean( method, qUsed )
8402:             | false :
                     % define the extern label on first use
8403:                @DefineExternLabel( method )
8410:             | * :
8415:          ]
8415:      | * :
8420:    ]
8420:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
8432:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
8445:    Node resultType
8445:    int tempOffset
      
8445:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
8462:    [ isFunc
8465:       | true :
8466:          resultType = oNodeGet( method, qType )
8479:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
8489:       | * :
8494:    ]
         
      
8494:    Node paramScope = oNodeGet( method, qParams )
8507:    int actualsSize = oNodeGetInt( paramScope, qSize )
8520:    [ cdecl
8523:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
8532:       | false :  .tAllocActuals  oEmitInt( actualsSize )
8542:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
8550:    [ greater( @DeclLevel( method ), 0 )
8565:       | true :
8566:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
8574:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
8593:          .tAssignP
8595:       | * :
8600:    ]
      
      
8600:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
8613:    Node param = oNodeIterValue( paramIter )
8623:    [
8623:       | '(' :
            
8625:          {
8625:             [ oNodeNull( param )
8632:                | true : >
8635:                | * :
8640:             ]
      
8640:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
8653:             .tPushAddrActual oEmitInt( offset )
8661:             oTypeSPush( oNodeGet( param, qType ) )
      
8674:             [ oNodeGetBoolean( param, qInOut )
8684:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
8685:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
8692:                           @MatchTypes
      
8694:                           .tAssignP
      
8696:                | false :  @Expr
8700:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
8702:                           [ oTypeSNodeType
8704:                              | nIntegerType, nEnumType : .tAssignI
8707:                              | nBooleanType, nByteType, nCharType :  .tAssignB
8711:                              | nFileType :   #eNotImplemented
8715:                              | nPointerType, nUniversalPointerType :  .tAssignP
8719:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
8721:                                  int size = oNodeGetInt( oTypeSTop, qSize )
8733:                                  .tCopy  oEmitInt( size )    % multi-word copy
8741:                           ]
8767:             ]
8775:             oTypeSPop
      
8776:             oNodeIterNext( paramIter )
8782:             param = oNodeIterValue( paramIter )
8792:             [ oNodeNull( param )
8799:                | true :  >
8802:                | false :
8804:             ]
      
8812:             ','
8814:          }
      
8816:          ')'
      
8818:       | * :
8823:    ]
      
8823:    [ oNodeNull( param )
8830:       | false :    #eMissingParameter
8833:       | * :
8838:    ]
      
8838:    [ isFunc
8841:       | true :
               % Pass result temp as an additional VAR parameter.
8842:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
8857:          .tPushAddrLocal  oEmitInt( tempOffset )
8865:          .tAssignP
8867:       | * :
8872:    ]
      
8872:    [ cdecl
8875:       | true :
8876:          .tCallCdecl  @EmitValue( method )
8885:       | false :
8887:          .tCall   @EmitValue( method )
8896:    ]
      
8904:    [ isFunc
8907:       | true :
               % push return value from temp
8908:          oTypeSPush( resultType )
      
8914:          [ oTypeSNodeType
8916:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8925:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8935:             | nFileType :  #eNotImplemented
8939:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8949:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
8951:                                .tPushAddrLocal  oEmitInt( tempOffset )
8959:          ]
8985:       | * :
8990:    ]
         
8990:    .tFreeActuals  oEmitInt( actualsSize )
8999:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8999: CallBuiltInFunc( Node method ):
      
         % Ord(x)
9001:    [ oNodeEqual( method, BuiltIn_Ord )
9011:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
9012:          '('
9014:          @Expr
9016:          [ oTypeSNodeType
9018:             | nIntegerType, nEnumType :
9019:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
9023:             | * :  #eTypeMismatch
9038:          ]
9038:          oTypeSPop
9039:          oTypeSPush( IntegerType )
9045:          ')'
9047:          >>
9048:       | * :
9053:    ]
      
         % Chr(x)
9053:    [ oNodeEqual( method, BuiltIn_Chr )
9063:       | true :
               % parameter is integer
               % result is char
9064:          '('
9066:          @Expr
9068:          [ oTypeSNodeType
9070:             | nIntegerType :    .tCastItoB
9073:             | nByteType :
9075:             | * :  #eTypeMismatch
9084:          ]
9084:          oTypeSPop
9085:          oTypeSPush( CharType )
9091:          ')'
9093:          >>
9094:       | * :
9099:    ]
      
         % Pred(x)
9099:    [ oNodeEqual( method, BuiltIn_Pred )
9109:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9110:          '('
9112:          @Expr
9114:          [ oTypeSNodeType
9116:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9117:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9126:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9129:                   | * :
9134:                ]
9134:             | * :  #eTypeMismatch
9141:          ]
9141:          .tDecI
9143:          ')'
9145:          >>
9146:       | * :
9151:    ]
      
         % Succ(x)
9151:    [ oNodeEqual( method, BuiltIn_Succ )
9161:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9162:          '('
9164:          @Expr
9166:          [ oTypeSNodeType
9168:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9169:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9178:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9181:                   | * :
9186:                ]
9186:             | * :  #eTypeMismatch
9193:          ]
9193:          .tIncI
9195:          ')'
9197:          >>
9198:       | * :
9203:    ]
      
9203:    #eNotImplemented
9206:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
9206: Statement:
9208:    [
9208:       | pWriteln :     @WritelnStmt
9212:       | pWrite :       @WriteStmt
9216:       | pReadln :      @ReadlnStmt
9220:       | pRead :        @ReadStmt
9224:       | pIf :          @IfStmt
9228:       | pWhile :       @WhileStmt
9232:       | pFor :         @ForStmt
9236:       | pRepeat :      @RepeatStmt
9240:       | pBreak :       @BreakStmt
9244:       | pContinue :    @ContinueStmt
9248:       | pBegin :       @BeginStmt
9252:       | pIdent :       @LabelOrAssignOrCallStmt
9256:       | pGoto :        @GotoStmt
9260:       | pIntLit :      % should be an integer label
9262:                        oChangeIntLitToLabelIdent
9263:                        @LabelOrAssignOrCallStmt
9265:       | * :            % null statement : don't accept any tokens
9296:    ];
      
      
9297: LabelOrAssignOrCallStmt:
9299:    Node decl = oScopeFindRequire
9304:    @ResolveUnitRef( decl )
9311:    [ oNodeType( decl )
9318:       | nLabel :                          @LabelDefinition( decl )
9326:                                           @Statement
9328:       | nProc :                           @Call( decl )
9337:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
9346:       | nFunc :                           @AssignResultStmt( decl )
9355:       | * :                               #eBadStatement
9372:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9373: LabelDefinition( Node decl ):
9375:    [ oNodeGetBoolean( decl, qDefined )
9385:       | true :  #eAlreadyDefined
9388:       | * :
9393:    ]
9393:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9408:    oNodeSetBoolean( decl, qDefined, true )
9420:    ':'
9423:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9423: AssignStmt( Node decl ):
      
9425:    @LValueVar( decl, true )
9435:    ':=' 
9437:    @Expr
9439:    @CoerceType
9441:    @Assign
9444:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9444: Assign:
9446:    [ oTypeSNodeType
9448:       | nIntegerType, nEnumType :  .tAssignI
9451:       | nBooleanType, nByteType, nCharType :  .tAssignB
9455:       | nFileType :   #eNotImplemented
9459:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9463:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9465:           int size = oNodeGetInt( oTypeSTop, qSize )
9477:           .tCopy  oEmitInt( size )    % multi-word copy
9485:    ]
9511:    oTypeSPop
9513:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9513: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9515:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9531:       | false :   #eNotCurrentFunction
9534:       | * :
9539:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9539:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9554:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9567:    ':='
9569:    @Expr
9571:    @CoerceType
9573:    [ oTypeSNodeType
9575:       | nIntegerType, nEnumType : .tAssignI
9578:       | nBooleanType, nByteType, nCharType :  .tAssignB
9582:       | nFileType :   #eNotImplemented
9586:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9590:       | nArrayType, nRecordType, nShortStringType :
9592:           int size = oNodeGetInt( oTypeSTop, qSize )
9604:           .tCopy  oEmitInt( size )    % multi-word copy
9612:    ]
9638:    oTypeSPop
9640:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9640: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
9642:    pIdent
9644:    Node decl = oScopeFindRequire
9649:    @ResolveUnitRef( decl )
9656:    [ oNodeType( decl )
9663:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9664:       | * :  #eNotVar
9677:    ]
9677:    @LValueVar( decl, writeable )
9688:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9688: LValueVar( Node decl, boolean writeable ):
9690:    [ oNodeType( decl )
9697:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9707:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9718:       | nParam :
9720:          [ oNodeGetBoolean( decl, qInOut )
9730:             | true :   % VAR param points to variable.  No dereference.
9731:                        .tPushParamP @EmitValue( decl )
9740:             | * :      .tPushAddrParam @EmitValue( decl )
9754:          ]
9754:       | nTypedConst :
9756:          [ writeable
9759:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9769:             | * :      #eNotVar
9776:          ]
9776:       | * :            #eNotVar
9789:    ]
      
9789:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9802:    [ oTypeSNodeType
9804:       | nPointerType :
9805:          [
9805:             | '[' :
                     % dereference the pointer var first
9807:                .tFetchP
9809:                @PointerArraySubscript
9811:             | * :
9816:          ]
9816:       | * :
9821:    ]
         % additional subscripts, if any
9821:    @LValueIndexes
9824:    ;
      
      
9824: IncVar( Node decl ):
9826:    @LValueVar( decl, true )
9836:    @RequireIntPop
9838:    @VarExpr( decl )
9845:    oTypeSPop
9846:    .tIncI
9848:    .tAssignI;
      
9851: DecVar( Node decl ):
9853:    @LValueVar( decl, true )
9863:    @RequireIntPop
9865:    @VarExpr( decl )
9872:    oTypeSPop
9873:    .tDecI
9875:    .tAssignI;
      
      
9878: IfStmt:
9880:    Label falseLabel = labelNull
      
9886:    @BooleanExprControlFlow( falseLabel )
9893:    pThen
9895:    @Statement
9897:    [
9897:       | pElse :
9899:          Label doneLabel = oLabelNew
      
9904:          .tJump  oEmitLabel( doneLabel )
9912:          .tLabel oEmitLabel( falseLabel )
9920:          @Statement
9922:          .tLabel oEmitLabel( doneLabel )
      
9930:       | * :
9935:          .tLabel oEmitLabel( falseLabel )
9943:    ];
      
      
9944: ForStmt:
9946:    pIdent
      
9948:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9953:    @LValueVar( decl, true )
9963:    @RequireIntPop
      
9965:    ':='
      
9967:    @Expr
9969:    @RequireIntPop
9971:    .tAssignI
      
9973:    Label breakLabel = oLabelNew
      
9978:    Label checkLabel = oLabelNew
9983:    .tJump  oEmitLabel( checkLabel )
      
9991:    Label continueLabel = oLabelNew
9996:    .tLabel  oEmitLabel( continueLabel )
10004:    [
10004:       | pTo :
10006:          @IncVar( decl )
10013:          .tLabel  oEmitLabel( checkLabel )
10021:          @VarExpr( decl )  oTypeSPop
10029:          @Expr
10031:          @RequireIntPop
10033:          .tGreaterI
10035:          .tJumpTrue  oEmitLabel( breakLabel )
10043:       | pDownto :
10045:          @DecVar( decl )
10052:          .tLabel  oEmitLabel( checkLabel )
10060:          @VarExpr( decl )  oTypeSPop
10068:          @Expr
10070:          @RequireIntPop
10072:          .tLessI
10074:          .tJumpTrue  oEmitLabel( breakLabel )
10082:    ]
10090:    oLoopPush( continueLabel, breakLabel )
10099:    pDo
10101:    @Statement
10103:    .tJump  oEmitLabel( continueLabel )
10111:    .tLabel  oEmitLabel( breakLabel )
10119:    oLoopPop;
      
      
10121: RepeatStmt:
10123:    Label continueLabel = oLabelNew
10128:    .tLabel  oEmitLabel( continueLabel )
      
10136:    Label breakLabel = oLabelNew
      
10141:    oLoopPush( continueLabel, breakLabel )
10150:    @Statement
10152:    {[
10152:       | ';' :
10154:          @Statement
10156:       | pUntil :
10158:          Label falseLabel
10158:          @BooleanExprControlFlow( falseLabel )
10165:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10179:          >
10181:    ]}
10191:    .tLabel  oEmitLabel( breakLabel )
10199:    oLoopPop;
      
      
10201: WhileStmt:
10203:    Label continueLabel = oLabelNew
10208:    .tLabel  oEmitLabel( continueLabel )
      
10216:    Label breakLabel
10216:    @BooleanExprControlFlow( breakLabel )
      
10223:    oLoopPush( continueLabel, breakLabel )
10232:    pDo
10234:    @Statement
10236:    .tJump  oEmitLabel( continueLabel )
10244:    .tLabel  oEmitLabel( breakLabel )
10252:    oLoopPop;
      
      
10254: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10256:    [ equal_label( oLoopContinueLabel, labelNull )
10265:       | true :
10266:          #eNotInALoop
10268:       | false :
10270:          .tJump  oEmitLabel( oLoopContinueLabel )
10277:    ];
      
      
10286: BreakStmt:
10288:    [ equal_label( oLoopBreakLabel, labelNull )
10297:       | true :
10298:          #eNotInALoop
10300:       | false :
10302:          .tJump  oEmitLabel( oLoopBreakLabel )
10309:    ];
      
      
10318: GotoStmt:
10320:    [
10320:       | pIdent :
10322:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10324:          oChangeIntLitToLabelIdent
10325:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10333:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10342:    oNodeSetBoolean( decl, qUsed, true )
10354:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10370:    ;
      
      
10370: BeginStmt:
10372:    @Statement
10374:    {[
10374:       | ';' :   @Statement
10378:       | pEnd :  >
10382:    ]};
      
      
10393: WritelnStmt:
10395:    @WriteStmt
10397:    .tWriteCR;
      
      
10400: WriteStmt:
10402:    [
10402:       | '(' :
10404:          {
10404:             @Expr
10406:             [ oTypeSNodeType
10408:                | nIntegerType :             .tWriteI
10411:                | nBooleanType :             .tWriteBool
10415:                | nByteType :                .tCastBtoI  .tWriteI
10421:                | nCharType :                .tWriteChar
10425:                | nShortStringType, nStrLitType :   .tWriteShortStr
10429:                | nFileType :                #eNotImplemented
10433:                | nEnumType :
                        % write name via table lookup
10435:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10449:                   .tWriteEnum
10451:                | nPointerType :
10453:                   [ equal_node( oTypeSTop, PCharType )
10462:                      | true :               .tWritePChar
10465:                      | * :                  .tWriteP
10472:                   ]
10472:                | nUniversalPointerType :    .tWriteP
10476:                | * :                        #eNotAllowed
10501:             ]
10501:             oTypeSPop
10502:             [
10502:                | ')' : >
10506:                | ',' :
10508:             ]
10516:          }
10518:       | * :
10523:    ];
      
      
10524: ReadlnStmt:      % ***
         % TO DO
10527:    ;
      
10527: ReadStmt:
         % TO DO
10530:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
10530: ScopeLevel >> int:
10532:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
10542: DeclLevel( Node decl ) >> int:
10544:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
10562: DeclUpLevels( Node decl ) >> int:
10564:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
10580: MatchTypes:
10582:    node_type nt = oTypeSNodeType
10587:    oTypeSPop
10588:    [ equal_node_type( nt, oTypeSNodeType )
10597:       | false :
               % Some implicit conversion is allowed even here
10598:          [ oTypeSNodeType
10600:             | nPointerType :
10601:                [ nt
10604:                   | nUniversalPointerType :  >>
10606:                   | * :
10611:                ]
10611:             | nUniversalPointerType :
10613:                [ nt
10616:                   | nPointerType :  >>
10618:                   | * :
10623:                ]
10623:             | * :
10630:          ]
10630:          #eTypeMismatch
10632:       | * :
10637:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
10638: RequireIntPop:
10640:    [ oTypeSNodeType
10642:       | nIntegerType :
10643:       | * :          #eNotInteger
10650:    ]
10650:    oTypeSPop;
      
10652: RequireInt:
10654:    [ oTypeSNodeType
10656:       | nIntegerType :
10657:       | * :          #eNotInteger
10664:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
10665: PromoteToIntPop:
10667:    [ oTypeSNodeType
10669:       | nIntegerType :
10670:       | nByteType :        .tCastBtoI
10674:       | * :                #eNotInteger
10683:    ]
10683:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
10685: PromoteToInt:
10687:    [ oTypeSNodeType
10689:       | nIntegerType :
10690:       | nByteType :        .tCastBtoI
10694:                            oTypeSPop
10695:                            oTypeSPush( IntegerType )
10701:       | * :                #eNotInteger
10710:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
10711: PromoteToIntOptional:
10713:    [ oTypeSNodeType
10715:       | nByteType :        .tCastBtoI
10718:                            oTypeSPop
10719:                            oTypeSPush( IntegerType )
10725:       | * :
10730:    ];
      
      
      
      
10731: RequireBoolPop:
10733:    [ oTypeSNodeType
10735:       | nBooleanType :
10736:       | * :          #eNotBoolean
10743:    ]
10743:    oTypeSPop;
      
10745: RequireBool:
10747:    [ oTypeSNodeType
10749:       | nBooleanType :
10750:       | * :          #eNotBoolean
10757:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10758: newType( node_type nt, int size ) >> Node:
10760:   Node node = oNodeNew( nt )
10770:   oNodeSetInt( node, qSize, size )
10782:   oTypeAdd( node )
10788:   >> node
10792:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
10792: newIdent( node_type nt, int id ) >> Node:
10794:   Node t = oNodeNew( nt )
10804:   oNodeSetInt( t, qIdent, id )
10816:   >> t
10820:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
10820: PointerTypeTo( Node theType ) >> Node:
10822:    Node ptrType = oNodeGet( theType, qPointerType )
10835:    [ oNodeNull( ptrType )
10842:       | true :
10843:          ptrType = oNodeNew( nPointerType )
10853:          oNodeSet( ptrType, qBaseType, theType )
10865:          oNodeSetInt( ptrType, qSize, 8 )
10877:          oTypeAdd( ptrType )
10883:          oNodeSet( theType, qPointerType, ptrType )
10895:       | * :
10900:    ]
10900:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
10904: OrdinalLow( Node theType ) >> int:
10906:    [ oNodeType( theType )
10913:       | nIntegerType :  >> oMININT
10916:       | nBooleanType :  >> 0
10921:       | nCharType :     >> 0
10926:       | nEnumType :
10928:          Node enumScope = oNodeGet( theType, qScope )
10941:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
10958:          >> oNodeGetInt( first, qValue )
10968:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
10980:       | * :             #eNotOrdinalType
10995:                         >> 0
10998:    ];
      
      
      % Return the high value of an ordinal type
      %
10999: OrdinalHigh( Node theType ) >> int:
11001:    [ oNodeType( theType )
11008:       | nIntegerType :  >> oMAXINT
11011:       | nBooleanType :  >> 1
11016:       | nCharType :     >> 255
11021:       | nEnumType :
11023:          Node enumScope = oNodeGet( theType, qScope )
11036:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
11053:          >> oNodeGetInt( last, qValue )
11063:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
11075:       | * :             #eNotOrdinalType
11090:                         >> 0
11093:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
11094: EmitValue( Node decl ):
11096:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
11110: DeclareBuiltInFunc( int id ) >> Node:
11112:    Node decl = @newIdent( nBuiltInFunc, id )
11126:    oScopeDeclare( decl )
11132:    >> decl;
      
      
11136: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
11138:    mysystemId = oIdAdd_mysystem
      
         % Some names we'll want to look up in mysystem unit
11143:    id_ShortStringAppendShortString = oIdAdd_ShortStringAppendShortString
      
         % install built-in types
11148:    FileType = @newType( nFileType, 4 )
11162:    IntegerType = @newType( nIntegerType, 4 )
11176:    BooleanType = @newType( nBooleanType, 1 )
11190:    BooleanCFType = @newType( nBooleanCFType, 1 )
11204:    CharType = @newType( nCharType, 1 )
11218:    PCharType = @PointerTypeTo( CharType )
11229:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
11243:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
11257:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
11269:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
11283:    ShortStringType = @newType( nShortStringType, 256 )
11297:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
11309:    Node t
      
11309:    t = @newIdent( nTypeDecl, oIdAdd_File )
11322:    oNodeSet( t, qType, FileType )
11334:    oScopeDeclare( t )
      
11340:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
11353:    oNodeSet( t, qType, IntegerType )
11365:    oScopeDeclare( t )
      
11371:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
11384:    oNodeSet( t, qType, BooleanType )
11396:    oScopeDeclare( t )
      
11402:    t = @newIdent( nTypeDecl, oIdAdd_Char )
11415:    oNodeSet( t, qType, CharType )
11427:    oScopeDeclare( t )
      
11433:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
11446:    oNodeSet( t, qType, ByteType )
11458:    oScopeDeclare( t )
      
11464:    t = @newIdent( nTypeDecl, oIdAdd_Pointer )
11477:    oNodeSet( t, qType, UniversalPointerType )
11489:    oScopeDeclare( t )
      
11495:    t = @newIdent( nTypeDecl, oIdAdd_ShortString )
11508:    oNodeSet( t, qType, ShortStringType )
11520:    oScopeDeclare( t )
      
         % Built-in constants
      
11526:    t = @newIdent( nConst, oIdAdd_True )
11539:    oNodeSet( t, qType, BooleanType )
11551:    oNodeSetInt( t, qValue, 1 )
11563:    oScopeDeclare( t )
      
11569:    t = @newIdent( nConst, oIdAdd_False )
11582:    oNodeSet( t, qType, BooleanType )
11594:    oNodeSetInt( t, qValue, 0 )
11606:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
11612:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
11622:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
11632:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
11642:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
11653:    ;
      
11653: end
      
11653: 

Generated code:

   0: oGlobalSpace 21
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 11136
  25: oEmit 65
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 59
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 62
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 61
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 64
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 10792
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 6
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 10792
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 6
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          57    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 553
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1510
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1831
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1566
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 615
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 414
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 414
 367: oPop 2
 369: oReturn
 370: oLocalSpace 0
 372: oGetParam 1
 374: oPushResult
 375: oSetResult 4
 377: oPushResult
 378: oNodeGetInt
 379: oPop 2
 381: oPushResult
 382: oGetGlobal 4
 384: oPushResult
 385: equal
 386: oPop 2
 388: oChoice 410
 390: oGetAddrGlobal 20
 392: oPushResult
 393: oScopeCurrent
 394: oPushResult
 395: oSetResult 15
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oGetGlobal 5
 403: oPushResult
 404: oNodeFind
 405: oPop 4
 407: oAssign
 408: oJumpForward 413
 410: Choice Lookup Table
           1    390
 413: oReturn
 414: oLocalSpace 2
 416: oGetAddrLocal 1
 418: oPushResult
 419: oGetParam 2
 421: oPushResult
 422: oCall 694
 424: oPop 1
 426: oAssign
 427: oGetLocal 1
 429: oPushResult
 430: oSetResult 0
 432: oPushResult
 433: equal_node
 434: oPop 2
 436: oChoice 506
 438: oGetParam 1
 440: oPushResult
 441: oSetResult 5
 443: oPushResult
 444: oGetLocal 1
 446: oPushResult
 447: oNodeAddLast
 448: oPop 3
 450: oGetAddrLocal 2
 452: oPushResult
 453: oSetResult 10
 455: oPushResult
 456: oNodeNew
 457: oPop 1
 459: oAssign
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 4
 465: oPushResult
 466: oGetLocal 1
 468: oPushResult
 469: oSetResult 4
 471: oPushResult
 472: oNodeGetInt
 473: oPop 2
 475: oPushResult
 476: oNodeSetInt
 477: oPop 3
 479: oGetLocal 2
 481: oPushResult
 482: oSetResult 9
 484: oPushResult
 485: oGetLocal 1
 487: oPushResult
 488: oSetResult 9
 490: oPushResult
 491: oNodeGet
 492: oPop 2
 494: oPushResult
 495: oNodeSet
 496: oPop 3
 498: oGetLocal 2
 500: oPushResult
 501: oScopeDeclare
 502: oPop 1
 504: oJumpForward 509
 506: Choice Lookup Table
           0    438
 509: oReturn
 510: oLocalSpace 1
 512: oGetFromParam 1
 514: oPushResult
 515: oNodeType
 516: oPop 1
 518: oChoice 549
 520: oGetAddrLocal 1
 522: oPushResult
 523: oGetFromParam 1
 525: oPushResult
 526: oSetResult 9
 528: oPushResult
 529: oNodeGet
 530: oPop 2
 532: oAssign
 533: oInput 20
 535: oInput 0
 537: oGetParam 1
 539: oPushResult
 540: oGetLocal 1
 542: oPushResult
 543: oScopeFindRequireInScope
 544: oPop 1
 546: oAssign
 547: oJumpForward 552
 549: Choice Lookup Table
          10    520
 552: oReturn
 553: oLocalSpace 2
 555: oGetAddrLocal 1
 557: oPushResult
 558: oGetParam 1
 560: oPushResult
 561: oSetResult 5
 563: oPushResult
 564: oNodeGetIter
 565: oPop 2
 567: oAssign
 568: oGetAddrLocal 2
 570: oPushResult
 571: oGetLocal 1
 573: oPushResult
 574: oNodeIterValue
 575: oPop 1
 577: oAssign
 578: oGetLocal 2
 580: oPushResult
 581: oNodeNull
 582: oPop 1
 584: oChoice 601
 586: oGetLocal 2
 588: oPushResult
 589: oSetResult 9
 591: oPushResult
 592: oNodeGet
 593: oPop 2
 595: oPushResult
 596: oScopeEnter
 597: oPop 1
 599: oJumpForward 606
 601: Choice Lookup Table
           0    586
 604: oJumpForward 614
 606: oGetAddrLocal 1
 608: oPushResult
 609: oNodeIterNext
 610: oPop 1
 612: oJumpBack 568
 614: oReturn
 615: oLocalSpace 2
 617: oGetAddrLocal 1
 619: oPushResult
 620: oGetParam 1
 622: oPushResult
 623: oSetResult 5
 625: oPushResult
 626: oNodeGetIterLast
 627: oPop 2
 629: oAssign
 630: oGetAddrLocal 2
 632: oPushResult
 633: oGetLocal 1
 635: oPushResult
 636: oNodeIterValue
 637: oPop 1
 639: oAssign
 640: oGetLocal 2
 642: oPushResult
 643: oNodeNull
 644: oPop 1
 646: oChoice 680
 648: oScopeCurrent
 649: oPushResult
 650: oGetLocal 2
 652: oPushResult
 653: oSetResult 9
 655: oPushResult
 656: oNodeGet
 657: oPop 2
 659: oPushResult
 660: oNodeEqual
 661: oPop 2
 663: oChoice 671
 665: oJumpForward 677
 667: oError 25
 669: oJumpForward 677
 671: Choice Lookup Table
           0    667
           1    665
 676: oEndChoice
 677: oScopeEnd
 678: oJumpForward 685
 680: Choice Lookup Table
           0    648
 683: oJumpForward 693
 685: oGetAddrLocal 1
 687: oPushResult
 688: oNodeIterPrev
 689: oPop 1
 691: oJumpBack 630
 693: oReturn
 694: oLocalSpace 2
 696: oGetAddrLocal 1
 698: oPushResult
 699: oGetGlobal 1
 701: oPushResult
 702: oSetResult 1
 704: oPushResult
 705: oSetResult 4
 707: oPushResult
 708: oGetParam 1
 710: oPushResult
 711: oNodeFind
 712: oPop 4
 714: oAssign
 715: oGetLocal 1
 717: oPushResult
 718: oSetResult 0
 720: oPushResult
 721: equal_node
 722: oPop 2
 724: oChoice 731
 726: oGetLocal 1
 728: oReturn
 729: oJumpForward 734
 731: Choice Lookup Table
           0    726
 734: oGetAddrLocal 2
 736: oPushResult
 737: oGetParam 1
 739: oPushResult
 740: oIncludeUnitFile
 741: oPop 1
 743: oAssign
 744: oGetLocal 2
 746: oChoice 755
 748: oError 24
 750: oSetResult 0
 752: oReturn
 753: oJumpForward 758
 755: Choice Lookup Table
           0    748
 758: oGetAddrLocal 1
 760: oPushResult
 761: oCall 769
 763: oAssign
 764: oIncludeEnd
 765: oGetLocal 1
 767: oReturn
 768: oReturn
 769: oLocalSpace 2
 771: oInput 58
 773: oInput 0
 775: oGetAddrLocal 1
 777: oPushResult
 778: oSetResult 5
 780: oPushResult
 781: oNodeNew
 782: oPop 1
 784: oAssign
 785: oGetLocal 1
 787: oPushResult
 788: oSetResult 4
 790: oPushResult
 791: LAST_ID
 792: oPushResult
 793: oNodeSetInt
 794: oPop 3
 796: oGetAddrLocal 2
 798: oPushResult
 799: oSetResult 6
 801: oPushResult
 802: oNodeNew
 803: oPop 1
 805: oAssign
 806: oGetLocal 2
 808: oPushResult
 809: oSetResult 4
 811: oPushResult
 812: LAST_ID
 813: oPushResult
 814: oNodeSetInt
 815: oPop 3
 817: oGetLocal 1
 819: oPushResult
 820: oSetResult 8
 822: oPushResult
 823: oGetLocal 2
 825: oPushResult
 826: oNodeSet
 827: oPop 3
 829: oInput 5
 831: oInput 59
 833: oGetLocal 1
 835: oPushResult
 836: oCall 333
 838: oPop 1
 840: oInputChoice 851
 842: oGetLocal 1
 844: oPushResult
 845: oCall 306
 847: oPop 1
 849: oJumpForward 854
 851: Choice Lookup Table
          57    842
 854: oGetLocal 1
 856: oPushResult
 857: oCall 553
 859: oPop 1
 861: oSetResult 0
 863: oPushResult
 864: oSetResult 0
 866: oPushResult
 867: oScopeBegin
 868: oPop 2
 870: oGetLocal 1
 872: oPushResult
 873: oSetResult 9
 875: oPushResult
 876: oScopeCurrent
 877: oPushResult
 878: oNodeSet
 879: oPop 3
 881: oGetAddrGlobal 2
 883: oPushResult
 884: oScopeCurrent
 885: oAssign
 886: oSetResult 0
 888: oPushResult
 889: oSetResult 1
 891: oPushResult
 892: oScopeBegin
 893: oPop 2
 895: oGetAddrGlobal 3
 897: oPushResult
 898: oScopeCurrent
 899: oAssign
 900: oGetLocal 1
 902: oPushResult
 903: oSetResult 13
 905: oPushResult
 906: oGetGlobal 3
 908: oPushResult
 909: oNodeSet
 910: oPop 3
 912: oScopeEnd
 913: oGetLocal 1
 915: oPushResult
 916: oCall 1104
 918: oPop 1
 920: oScopeEnd
 921: oInput 60
 923: oGetLocal 2
 925: oPushResult
 926: oCall 333
 928: oPop 1
 930: oInputChoice 941
 932: oGetLocal 2
 934: oPushResult
 935: oCall 306
 937: oPop 1
 939: oJumpForward 944
 941: Choice Lookup Table
          57    932
 944: oGetLocal 2
 946: oPushResult
 947: oCall 553
 949: oPop 1
 951: oGetLocal 1
 953: oPushResult
 954: oSetResult 9
 956: oPushResult
 957: oNodeGet
 958: oPop 2
 960: oPushResult
 961: oScopeEnter
 962: oPop 1
 964: oSetResult 0
 966: oPushResult
 967: oSetResult 0
 969: oPushResult
 970: oScopeBegin
 971: oPop 2
 973: oGetLocal 1
 975: oPushResult
 976: oSetResult 10
 978: oPushResult
 979: oScopeCurrent
 980: oPushResult
 981: oNodeSet
 982: oPop 3
 984: oScopeCurrent
 985: oPushResult
 986: oSetResult 16
 988: oPushResult
 989: oGetLocal 1
 991: oPushResult
 992: oSetResult 9
 994: oPushResult
 995: oNodeGet
 996: oPop 2
 998: oPushResult
 999: oNodeSet
1000: oPop 3
1002: oGetAddrGlobal 2
1004: oPushResult
1005: oScopeCurrent
1006: oAssign
1007: oGetLocal 1
1009: oPushResult
1010: oCall 1196
1012: oPop 1
1014: oInputChoice 1028
1016: oGetLocal 1
1018: oPushResult
1019: oSetResult 1
1021: oPushResult
1022: oCall 1206
1024: oPop 2
1026: oJumpForward 1041
1028: Choice Lookup Table
          61   1016
1031: oGetLocal 1
1033: oPushResult
1034: oSetResult 0
1036: oPushResult
1037: oCall 1206
1039: oPop 2
1041: oInputChoice 1055
1043: oGetLocal 1
1045: oPushResult
1046: oSetResult 1
1048: oPushResult
1049: oCall 1392
1051: oPop 2
1053: oJumpForward 1068
1055: Choice Lookup Table
          62   1043
1058: oGetLocal 1
1060: oPushResult
1061: oSetResult 0
1063: oPushResult
1064: oCall 1392
1066: oPop 2
1068: oInput 36
1070: oInput 20
1072: oScopeEnd
1073: oScopeEnd
1074: oGetLocal 2
1076: oPushResult
1077: oCall 615
1079: oPop 1
1081: oGetLocal 1
1083: oPushResult
1084: oCall 615
1086: oPop 1
1088: oGetGlobal 1
1090: oPushResult
1091: oSetResult 1
1093: oPushResult
1094: oGetLocal 1
1096: oPushResult
1097: oNodeAddLast
1098: oPop 3
1100: oGetLocal 1
1102: oReturn
1103: oReturn
1104: oLocalSpace 2
1106: oInputChoice 1173
1108: oCall 3104
1110: oJumpForward 1186
1112: oCall 3659
1114: oJumpForward 1186
1116: oSetResult 20
1118: oPushResult
1119: oCall 3715
1121: oPop 1
1123: oJumpForward 1186
1125: oGetAddrLocal 1
1127: oPushResult
1128: oCall 2071
1130: oAssign
1131: oInputChoice 1144
1133: oGetLocal 1
1135: oPushResult
1136: oCall 2009
1138: oPop 1
1140: oInput 5
1142: oJumpForward 1147
1144: Choice Lookup Table
          68   1133
1147: oJumpForward 1186
1149: oGetAddrLocal 2
1151: oPushResult
1152: oCall 2445
1154: oAssign
1155: oInputChoice 1168
1157: oGetLocal 2
1159: oPushResult
1160: oCall 2009
1162: oPop 1
1164: oInput 5
1166: oJumpForward 1171
1168: Choice Lookup Table
          68   1157
1171: oJumpForward 1186
1173: Choice Lookup Table
          30   1149
          29   1125
          33   1116
          32   1112
          31   1108
1184: oJumpForward 1188
1186: oJumpBack 1106
1188: oGetParam 1
1190: oPushResult
1191: oCall 370
1193: oPop 1
1195: oReturn
1196: oLocalSpace 0
1198: oSetResult 20
1200: oPushResult
1201: oCall 1510
1203: oPop 1
1205: oReturn
1206: oLocalSpace 5
1208: oGetAddrLocal 1
1210: oPushResult
1211: oLabelNew
1212: oAssign
1213: oEmit 69
1215: oGetLocal 1
1217: oPushResult
1218: oEmitLabel
1219: oPop 1
1221: oGetParam 2
1223: oPushResult
1224: oSetResult 11
1226: oPushResult
1227: oGetLocal 1
1229: oPushResult
1230: oNodeSetLabel
1231: oPop 3
1233: oEmit 65
1235: oGetAddrLocal 2
1237: oPushResult
1238: Here
1239: oAssign
1240: oEmit 80
1242: oGetAddrLocal 3
1244: oPushResult
1245: oGetParam 2
1247: oPushResult
1248: oSetResult 9
1250: oPushResult
1251: oNodeGet
1252: oPop 2
1254: oAssign
1255: oGetAddrLocal 4
1257: oPushResult
1258: oGetLocal 3
1260: oPushResult
1261: oSetResult 19
1263: oPushResult
1264: oNodeGetCode
1265: oPop 2
1267: oAssign
1268: oGetLocal 4
1270: oPushResult
1271: oEmitCode
1272: oPop 1
1274: oGetLocal 3
1276: oPushResult
1277: oSetResult 19
1279: oPushResult
1280: oSetResult 0
1282: oPushResult
1283: oNodeSetCode
1284: oPop 3
1286: oGetAddrLocal 3
1288: oPushResult
1289: oGetParam 2
1291: oPushResult
1292: oSetResult 10
1294: oPushResult
1295: oNodeGet
1296: oPop 2
1298: oAssign
1299: oGetAddrLocal 4
1301: oPushResult
1302: oGetLocal 3
1304: oPushResult
1305: oSetResult 19
1307: oPushResult
1308: oNodeGetCode
1309: oPop 2
1311: oAssign
1312: oGetLocal 4
1314: oPushResult
1315: oEmitCode
1316: oPop 1
1318: oGetLocal 3
1320: oPushResult
1321: oSetResult 19
1323: oPushResult
1324: oSetResult 0
1326: oPushResult
1327: oNodeSetCode
1328: oPop 3
1330: oGetParam 2
1332: oPushResult
1333: oSetResult 13
1335: oPushResult
1336: oNodeGet
1337: oPop 2
1339: oPushResult
1340: oScopeEnter
1341: oPop 1
1343: oGetParam 1
1345: oChoice 1364
1347: oCall 9206
1349: oInputChoice 1355
1351: oCall 9206
1353: oJumpForward 1360
1355: Choice Lookup Table
           5   1351
1358: oJumpForward 1362
1360: oJumpBack 1349
1362: oJumpForward 1367
1364: Choice Lookup Table
           1   1347
1367: oEmit 64
1369: oGetAddrLocal 5
1371: oPushResult
1372: oScopeCurrent
1373: oPushResult
1374: oSetResult 17
1376: oPushResult
1377: oNodeGetInt
1378: oPop 2
1380: oAssign
1381: oGetLocal 2
1383: oPushResult
1384: oGetLocal 5
1386: oPushResult
1387: oPatch
1388: oPop 2
1390: oScopeEnd
1391: oReturn
1392: oLocalSpace 3
1394: oGetAddrLocal 1
1396: oPushResult
1397: oLabelNew
1398: oAssign
1399: oEmit 69
1401: oGetLocal 1
1403: oPushResult
1404: oEmitLabel
1405: oPop 1
1407: oGetParam 2
1409: oPushResult
1410: oSetResult 12
1412: oPushResult
1413: oGetLocal 1
1415: oPushResult
1416: oNodeSetLabel
1417: oPop 3
1419: oEmit 65
1421: oGetAddrLocal 2
1423: oPushResult
1424: Here
1425: oAssign
1426: oEmit 80
1428: oSetResult 0
1430: oPushResult
1431: oSetResult 1
1433: oPushResult
1434: oScopeBegin
1435: oPop 2
1437: oGetParam 1
1439: oChoice 1458
1441: oCall 9206
1443: oInputChoice 1449
1445: oCall 9206
1447: oJumpForward 1454
1449: Choice Lookup Table
           5   1445
1452: oJumpForward 1456
1454: oJumpBack 1443
1456: oJumpForward 1461
1458: Choice Lookup Table
           1   1441
1461: oEmit 64
1463: oGetAddrLocal 3
1465: oPushResult
1466: oScopeCurrent
1467: oPushResult
1468: oSetResult 17
1470: oPushResult
1471: oNodeGetInt
1472: oPop 2
1474: oAssign
1475: oGetLocal 2
1477: oPushResult
1478: oGetLocal 3
1480: oPushResult
1481: oPatch
1482: oPop 2
1484: oScopeEnd
1485: oReturn
1486: oLocalSpace 0
1488: oGetParam 2
1490: oPushResult
1491: oCall 1510
1493: oPop 1
1495: oGetParam 1
1497: oPushResult
1498: oScopeCurrent
1499: oPushResult
1500: oSetResult 0
1502: oPushResult
1503: oCall 1831
1505: oPop 3
1507: oCall 1566
1509: oReturn
1510: oLocalSpace 0
1512: oInputChoice 1543
1514: oCall 3104
1516: oJumpForward 1558
1518: oCall 3659
1520: oJumpForward 1558
1522: oGetParam 1
1524: oPushResult
1525: oCall 3715
1527: oPop 1
1529: oJumpForward 1558
1531: oCall 3949
1533: oJumpForward 1558
1535: oCall 2327
1537: oJumpForward 1558
1539: oCall 2762
1541: oJumpForward 1558
1543: Choice Lookup Table
          30   1539
          29   1535
          34   1531
          33   1522
          32   1518
          31   1514
1556: oJumpForward 1560
1558: oJumpBack 1512
1560: oCall 1563
1562: oReturn
1563: oLocalSpace 0
1565: oReturn
1566: oLocalSpace 2
1568: oGetAddrLocal 1
1570: oPushResult
1571: oScopeCurrent
1572: oPushResult
1573: oSetResult 15
1575: oPushResult
1576: oNodeGetIter
1577: oPop 2
1579: oAssign
1580: oGetAddrLocal 2
1582: oPushResult
1583: oGetLocal 1
1585: oPushResult
1586: oNodeIterValue
1587: oPop 1
1589: oAssign
1590: oGetLocal 2
1592: oPushResult
1593: oNodeNull
1594: oPop 1
1596: oChoice 1600
1598: oJumpForward 1605
1600: Choice Lookup Table
           0   1598
1603: oJumpForward 1660
1605: oGetLocal 2
1607: oPushResult
1608: oNodeType
1609: oPop 1
1611: oChoice 1649
1613: oGetLocal 2
1615: oPushResult
1616: oSetResult 34
1618: oPushResult
1619: oNodeGetBoolean
1620: oPop 2
1622: oChoice 1644
1624: oGetLocal 2
1626: oPushResult
1627: oSetResult 28
1629: oPushResult
1630: oNodeGetBoolean
1631: oPop 2
1633: oChoice 1639
1635: oError 27
1637: oJumpForward 1642
1639: Choice Lookup Table
           1   1635
1642: oJumpForward 1647
1644: Choice Lookup Table
           0   1624
1647: oJumpForward 1652
1649: Choice Lookup Table
          25   1613
1652: oGetAddrLocal 1
1654: oPushResult
1655: oNodeIterNext
1656: oPop 1
1658: oJumpBack 1580
1660: oReturn
1661: oLocalSpace 2
1663: oGetAddrLocal 1
1665: oPushResult
1666: oGetGlobal 1
1668: oPushResult
1669: oSetResult 1
1671: oPushResult
1672: oNodeGetIter
1673: oPop 2
1675: oAssign
1676: oGetAddrLocal 2
1678: oPushResult
1679: oGetLocal 1
1681: oPushResult
1682: oNodeIterValue
1683: oPop 1
1685: oAssign
1686: oGetLocal 2
1688: oPushResult
1689: oNodeNull
1690: oPop 1
1692: oChoice 1737
1694: oJumpForward 1745
1696: oJumpForward 1743
1698: oEmit 59
1700: oSetResult 0
1702: oPushResult
1703: oEmitInt
1704: oPop 1
1706: oEmit 62
1708: oGetLocal 2
1710: oPushResult
1711: oSetResult 11
1713: oPushResult
1714: oNodeGetLabel
1715: oPop 2
1717: oPushResult
1718: oEmitLabel
1719: oPop 1
1721: oEmit 61
1723: oSetResult 0
1725: oPushResult
1726: oEmitInt
1727: oPop 1
1729: oGetAddrLocal 1
1731: oPushResult
1732: oNodeIterNext
1733: oPop 1
1735: oJumpForward 1743
1737: Choice Lookup Table
           0   1698
           1   1694
1742: oEndChoice
1743: oJumpBack 1676
1745: oReturn
1746: oLocalSpace 2
1748: oGetAddrLocal 1
1750: oPushResult
1751: oGetGlobal 1
1753: oPushResult
1754: oSetResult 1
1756: oPushResult
1757: oNodeGetIterLast
1758: oPop 2
1760: oAssign
1761: oGetAddrLocal 2
1763: oPushResult
1764: oGetLocal 1
1766: oPushResult
1767: oNodeIterValue
1768: oPop 1
1770: oAssign
1771: oGetLocal 2
1773: oPushResult
1774: oNodeNull
1775: oPop 1
1777: oChoice 1822
1779: oJumpForward 1830
1781: oJumpForward 1828
1783: oEmit 59
1785: oSetResult 0
1787: oPushResult
1788: oEmitInt
1789: oPop 1
1791: oEmit 62
1793: oGetLocal 2
1795: oPushResult
1796: oSetResult 12
1798: oPushResult
1799: oNodeGetLabel
1800: oPop 2
1802: oPushResult
1803: oEmitLabel
1804: oPop 1
1806: oEmit 61
1808: oSetResult 0
1810: oPushResult
1811: oEmitInt
1812: oPop 1
1814: oGetAddrLocal 1
1816: oPushResult
1817: oNodeIterPrev
1818: oPop 1
1820: oJumpForward 1828
1822: Choice Lookup Table
           0   1783
           1   1779
1827: oEndChoice
1828: oJumpBack 1761
1830: oReturn
1831: oLocalSpace 3
1833: oEmit 69
1835: oGetParam 3
1837: oPushResult
1838: oEmitLabel
1839: oPop 1
1841: oEmit 65
1843: oGetAddrLocal 1
1845: oPushResult
1846: Here
1847: oAssign
1848: oEmit 80
1850: oGetParam 1
1852: oChoice 1858
1854: oCall 1661
1856: oJumpForward 1861
1858: Choice Lookup Table
           1   1854
1861: oGetAddrLocal 2
1863: oPushResult
1864: oGetParam 2
1866: oPushResult
1867: oSetResult 19
1869: oPushResult
1870: oNodeGetCode
1871: oPop 2
1873: oAssign
1874: oGetLocal 2
1876: oPushResult
1877: oEmitCode
1878: oPop 1
1880: oGetParam 2
1882: oPushResult
1883: oSetResult 19
1885: oPushResult
1886: oSetResult 0
1888: oPushResult
1889: oNodeSetCode
1890: oPop 3
1892: oCall 9206
1894: oGetParam 1
1896: oChoice 1902
1898: oCall 1746
1900: oJumpForward 1905
1902: Choice Lookup Table
           1   1898
1905: oEmit 64
1907: oGetAddrLocal 3
1909: oPushResult
1910: oScopeCurrent
1911: oPushResult
1912: oSetResult 17
1914: oPushResult
1915: oNodeGetInt
1916: oPop 2
1918: oAssign
1919: oGetLocal 1
1921: oPushResult
1922: oGetLocal 3
1924: oPushResult
1925: oPatch
1926: oPop 2
1928: oReturn
1929: oLocalSpace 0
1931: oInputChoice 1949
1933: oGetParam 1
1935: oPushResult
1936: oSetResult 27
1938: oPushResult
1939: oSetResult 1
1941: oPushResult
1942: oNodeSetBoolean
1943: oPop 3
1945: oInput 5
1947: oJumpForward 1954
1949: Choice Lookup Table
          70   1933
1952: oJumpForward 1956
1954: oJumpBack 1931
1956: oReturn
1957: oLocalSpace 1
1959: oGetAddrLocal 1
1961: oPushResult
1962: oGetParam 1
1964: oPushResult
1965: oSetResult 19
1967: oPushResult
1968: oNodeGetCode
1969: oPop 2
1971: oAssign
1972: oGetLocal 1
1974: oPushResult
1975: oSetResult 0
1977: oPushResult
1978: equal_code
1979: oPop 2
1981: oChoice 2002
1983: oGetAddrLocal 1
1985: oPushResult
1986: oCodeNew
1987: oAssign
1988: oGetParam 1
1990: oPushResult
1991: oSetResult 19
1993: oPushResult
1994: oGetLocal 1
1996: oPushResult
1997: oNodeSetCode
1998: oPop 3
2000: oJumpForward 2005
2002: Choice Lookup Table
           1   1983
2005: oGetLocal 1
2007: oReturn
2008: oReturn
2009: oLocalSpace 0
2011: oGetParam 1
2013: oPushResult
2014: oCall 10542
2016: oPop 1
2018: oPushResult
2019: equal_zero
2020: oPop 1
2022: oChoice 2028
2024: oError 23
2026: oJumpForward 2031
2028: Choice Lookup Table
           0   2024
2031: oGetParam 1
2033: oPushResult
2034: oSetResult 25
2036: oPushResult
2037: oSetResult 1
2039: oPushResult
2040: oNodeSetBoolean
2041: oPop 3
2043: oInputChoice 2067
2045: oInputChoice 2062
2047: oInput 2
2049: oGetParam 1
2051: oPushResult
2052: oSetResult 26
2054: oPushResult
2055: CURRENT_STRLIT
2056: oPushResult
2057: oNodeSetString
2058: oPop 3
2060: oJumpForward 2065
2062: Choice Lookup Table
          69   2047
2065: oJumpForward 2070
2067: Choice Lookup Table
           2   2045
2070: oReturn
2071: oLocalSpace 6
2073: oInput 0
2075: oGetAddrLocal 1
2077: oPushResult
2078: oSetResult 0
2080: oAssign
2081: oGetAddrLocal 2
2083: oPushResult
2084: oScopeFindInCurrentScope
2085: oAssign
2086: oGetLocal 2
2088: oPushResult
2089: oNodeNull
2090: oPop 1
2092: oChoice 2210
2094: oGetAddrLocal 2
2096: oPushResult
2097: oSetResult 12
2099: oPushResult
2100: LAST_ID
2101: oPushResult
2102: oCall 10792
2104: oPop 2
2106: oAssign
2107: oGetLocal 2
2109: oPushResult
2110: oSetResult 22
2112: oPushResult
2113: oLabelNew
2114: oPushResult
2115: oNodeSetLabel
2116: oPop 3
2118: oJumpForward 2216
2120: oGetAddrLocal 1
2122: oPushResult
2123: oSetResult 1
2125: oAssign
2126: oGetLocal 2
2128: oPushResult
2129: oSetResult 24
2131: oPushResult
2132: oNodeGetBoolean
2133: oPop 2
2135: oChoice 2141
2137: oError 21
2139: oJumpForward 2144
2141: Choice Lookup Table
           1   2137
2144: oGetLocal 2
2146: oPushResult
2147: oSetResult 25
2149: oPushResult
2150: oNodeGetBoolean
2151: oPop 2
2153: oChoice 2159
2155: oError 21
2157: oJumpForward 2162
2159: Choice Lookup Table
           1   2155
2162: oGetLocal 2
2164: oPushResult
2165: oNodeType
2166: oPop 1
2168: oChoice 2172
2170: oJumpForward 2177
2172: Choice Lookup Table
          12   2170
2175: oError 21
2177: oGetLocal 2
2179: oPushResult
2180: oSetResult 29
2182: oPushResult
2183: oGetLocal 2
2185: oPushResult
2186: oSetResult 23
2188: oPushResult
2189: oNodeGet
2190: oPop 2
2192: oPushResult
2193: oNodeSet
2194: oPop 3
2196: oGetLocal 2
2198: oPushResult
2199: oSetResult 23
2201: oPushResult
2202: oSetResult 0
2204: oPushResult
2205: oNodeSet
2206: oPop 3
2208: oJumpForward 2216
2210: Choice Lookup Table
           0   2120
           1   2094
2215: oEndChoice
2216: oGetAddrLocal 3
2218: oPushResult
2219: oCall 10530
2221: oAssign
2222: oGetAddrLocal 4
2224: oPushResult
2225: oGetLocal 3
2227: oPushResult
2228: oSetResult 0
2230: oPushResult
2231: greater
2232: oPop 2
2234: oAssign
2235: oGetAddrLocal 3
2237: oPushResult
2238: inc
2239: oPop 1
2241: oGetLocal 3
2243: oPushResult
2244: oSetResult 2
2246: oPushResult
2247: oScopeBegin
2248: oPop 2
2250: oGetAddrLocal 5
2252: oPushResult
2253: oScopeCurrent
2254: oAssign
2255: oGetLocal 4
2257: oChoice 2276
2259: oGetAddrLocal 6
2261: oPushResult
2262: oGetGlobal 7
2264: oPushResult
2265: oCall 10820
2267: oPop 1
2269: oPushResult
2270: oScopeAllocType
2271: oPop 1
2273: oAssign
2274: oJumpForward 2279
2276: Choice Lookup Table
           1   2259
2279: oCall 2880
2281: oGetLocal 2
2283: oPushResult
2284: oSetResult 23
2286: oPushResult
2287: oGetLocal 5
2289: oPushResult
2290: oNodeSet
2291: oPop 3
2293: oScopeEnd
2294: oInput 5
2296: oGetLocal 1
2298: oChoice 2310
2300: oGetLocal 2
2302: oPushResult
2303: oScopeDeclare
2304: oPop 1
2306: oJumpForward 2316
2308: oJumpForward 2316
2310: Choice Lookup Table
           1   2308
           0   2300
2315: oEndChoice
2316: oGetLocal 2
2318: oPushResult
2319: oCall 1929
2321: oPop 1
2323: oGetLocal 2
2325: oReturn
2326: oReturn
2327: oLocalSpace 4
2329: oGetAddrLocal 1
2331: oPushResult
2332: oCall 2071
2334: oAssign
2335: oInputChoice 2348
2337: oJumpForward 2442
2339: oGetLocal 1
2341: oPushResult
2342: oCall 2009
2344: oPop 1
2346: oJumpForward 2442
2348: Choice Lookup Table
          68   2339
          67   2337
2353: oGetAddrLocal 2
2355: oPushResult
2356: oGetLocal 1
2358: oPushResult
2359: oSetResult 23
2361: oPushResult
2362: oNodeGet
2363: oPop 2
2365: oAssign
2366: oGetLocal 2
2368: oPushResult
2369: oScopeEnter
2370: oPop 1
2372: oGetAddrLocal 3
2374: oPushResult
2375: oGetLocal 2
2377: oPushResult
2378: oSetResult 14
2380: oPushResult
2381: oNodeGetInt
2382: oPop 2
2384: oAssign
2385: oGetLocal 3
2387: oPushResult
2388: oSetResult 1
2390: oPushResult
2391: oScopeBegin
2392: oPop 2
2394: oGetLocal 1
2396: oPushResult
2397: oSetResult 6
2399: oPushResult
2400: oScopeCurrent
2401: oPushResult
2402: oNodeSet
2403: oPop 3
2405: oGetAddrLocal 4
2407: oPushResult
2408: oGetLocal 1
2410: oPushResult
2411: oSetResult 22
2413: oPushResult
2414: oNodeGetLabel
2415: oPop 2
2417: oAssign
2418: oSetResult 21
2420: oPushResult
2421: oGetLocal 4
2423: oPushResult
2424: oCall 1486
2426: oPop 2
2428: oGetLocal 1
2430: oPushResult
2431: oSetResult 24
2433: oPushResult
2434: oSetResult 1
2436: oPushResult
2437: oNodeSetBoolean
2438: oPop 3
2440: oScopeEnd
2441: oScopeEnd
2442: oInput 5
2444: oReturn
2445: oLocalSpace 8
2447: oInput 0
2449: oGetAddrLocal 1
2451: oPushResult
2452: oSetResult 0
2454: oAssign
2455: oGetAddrLocal 2
2457: oPushResult
2458: oScopeFindInCurrentScope
2459: oAssign
2460: oGetLocal 2
2462: oPushResult
2463: oNodeNull
2464: oPop 1
2466: oChoice 2597
2468: oGetAddrLocal 2
2470: oPushResult
2471: oSetResult 13
2473: oPushResult
2474: LAST_ID
2475: oPushResult
2476: oCall 10792
2478: oPop 2
2480: oAssign
2481: oGetLocal 2
2483: oPushResult
2484: oSetResult 22
2486: oPushResult
2487: oLabelNew
2488: oPushResult
2489: oNodeSetLabel
2490: oPop 3
2492: oJumpForward 2603
2494: oGetAddrLocal 1
2496: oPushResult
2497: oSetResult 1
2499: oAssign
2500: oGetLocal 2
2502: oPushResult
2503: oSetResult 24
2505: oPushResult
2506: oNodeGetBoolean
2507: oPop 2
2509: oChoice 2515
2511: oError 21
2513: oJumpForward 2518
2515: Choice Lookup Table
           1   2511
2518: oGetLocal 2
2520: oPushResult
2521: oNodeType
2522: oPop 1
2524: oChoice 2528
2526: oJumpForward 2533
2528: Choice Lookup Table
          13   2526
2531: oError 21
2533: oGetLocal 2
2535: oPushResult
2536: oSetResult 29
2538: oPushResult
2539: oGetLocal 2
2541: oPushResult
2542: oSetResult 23
2544: oPushResult
2545: oNodeGet
2546: oPop 2
2548: oPushResult
2549: oNodeSet
2550: oPop 3
2552: oGetLocal 2
2554: oPushResult
2555: oSetResult 23
2557: oPushResult
2558: oSetResult 0
2560: oPushResult
2561: oNodeSet
2562: oPop 3
2564: oGetLocal 2
2566: oPushResult
2567: oSetResult 30
2569: oPushResult
2570: oGetLocal 2
2572: oPushResult
2573: oSetResult 21
2575: oPushResult
2576: oNodeGet
2577: oPop 2
2579: oPushResult
2580: oNodeSet
2581: oPop 3
2583: oGetLocal 2
2585: oPushResult
2586: oSetResult 21
2588: oPushResult
2589: oSetResult 0
2591: oPushResult
2592: oNodeSet
2593: oPop 3
2595: oJumpForward 2603
2597: Choice Lookup Table
           0   2494
           1   2468
2602: oEndChoice
2603: oGetAddrLocal 3
2605: oPushResult
2606: oCall 10530
2608: oAssign
2609: oGetAddrLocal 4
2611: oPushResult
2612: oGetLocal 3
2614: oPushResult
2615: oSetResult 0
2617: oPushResult
2618: greater
2619: oPop 2
2621: oAssign
2622: oGetAddrLocal 3
2624: oPushResult
2625: inc
2626: oPop 1
2628: oGetLocal 3
2630: oPushResult
2631: oSetResult 2
2633: oPushResult
2634: oScopeBegin
2635: oPop 2
2637: oGetAddrLocal 5
2639: oPushResult
2640: oScopeCurrent
2641: oAssign
2642: oGetLocal 4
2644: oChoice 2663
2646: oGetAddrLocal 6
2648: oPushResult
2649: oGetGlobal 7
2651: oPushResult
2652: oCall 10820
2654: oPop 1
2656: oPushResult
2657: oScopeAllocType
2658: oPop 1
2660: oAssign
2661: oJumpForward 2666
2663: Choice Lookup Table
           1   2646
2666: oCall 2880
2668: oGetLocal 2
2670: oPushResult
2671: oSetResult 23
2673: oPushResult
2674: oGetLocal 5
2676: oPushResult
2677: oNodeSet
2678: oPop 3
2680: oInput 12
2682: oGetAddrLocal 7
2684: oPushResult
2685: oCall 4014
2687: oPop 1
2689: oGetLocal 2
2691: oPushResult
2692: oSetResult 21
2694: oPushResult
2695: oGetLocal 7
2697: oPushResult
2698: oNodeSet
2699: oPop 3
2701: oGetAddrLocal 8
2703: oPushResult
2704: oGetLocal 7
2706: oPushResult
2707: oCall 10820
2709: oPop 1
2711: oAssign
2712: oGetLocal 2
2714: oPushResult
2715: oSetResult 31
2717: oPushResult
2718: oGetLocal 8
2720: oPushResult
2721: oScopeAllocType
2722: oPop 1
2724: oPushResult
2725: oNodeSetInt
2726: oPop 3
2728: oScopeEnd
2729: oInput 5
2731: oGetLocal 1
2733: oChoice 2745
2735: oGetLocal 2
2737: oPushResult
2738: oScopeDeclare
2739: oPop 1
2741: oJumpForward 2751
2743: oJumpForward 2751
2745: Choice Lookup Table
           1   2743
           0   2735
2750: oEndChoice
2751: oGetLocal 2
2753: oPushResult
2754: oCall 1929
2756: oPop 1
2758: oGetLocal 2
2760: oReturn
2761: oReturn
2762: oLocalSpace 4
2764: oGetAddrLocal 1
2766: oPushResult
2767: oCall 2445
2769: oAssign
2770: oInputChoice 2783
2772: oJumpForward 2877
2774: oGetLocal 1
2776: oPushResult
2777: oCall 2009
2779: oPop 1
2781: oJumpForward 2877
2783: Choice Lookup Table
          68   2774
          67   2772
2788: oGetAddrLocal 2
2790: oPushResult
2791: oGetLocal 1
2793: oPushResult
2794: oSetResult 23
2796: oPushResult
2797: oNodeGet
2798: oPop 2
2800: oAssign
2801: oGetLocal 2
2803: oPushResult
2804: oScopeEnter
2805: oPop 1
2807: oGetAddrLocal 3
2809: oPushResult
2810: oGetLocal 2
2812: oPushResult
2813: oSetResult 14
2815: oPushResult
2816: oNodeGetInt
2817: oPop 2
2819: oAssign
2820: oGetLocal 3
2822: oPushResult
2823: oSetResult 1
2825: oPushResult
2826: oScopeBegin
2827: oPop 2
2829: oGetLocal 1
2831: oPushResult
2832: oSetResult 6
2834: oPushResult
2835: oScopeCurrent
2836: oPushResult
2837: oNodeSet
2838: oPop 3
2840: oGetAddrLocal 4
2842: oPushResult
2843: oGetLocal 1
2845: oPushResult
2846: oSetResult 22
2848: oPushResult
2849: oNodeGetLabel
2850: oPop 2
2852: oAssign
2853: oSetResult 21
2855: oPushResult
2856: oGetLocal 4
2858: oPushResult
2859: oCall 1486
2861: oPop 2
2863: oGetLocal 1
2865: oPushResult
2866: oSetResult 24
2868: oPushResult
2869: oSetResult 1
2871: oPushResult
2872: oNodeSetBoolean
2873: oPop 3
2875: oScopeEnd
2876: oScopeEnd
2877: oInput 5
2879: oReturn
2880: oLocalSpace 6
2882: oInputChoice 3100
2884: oGetAddrLocal 1
2886: oPushResult
2887: oNodeVecNew
2888: oAssign
2889: oGetAddrLocal 3
2891: oPushResult
2892: oSetResult 0
2894: oAssign
2895: oInputChoice 2905
2897: oGetAddrLocal 3
2899: oPushResult
2900: oSetResult 1
2902: oAssign
2903: oJumpForward 2908
2905: Choice Lookup Table
          33   2897
2908: oInput 0
2910: oGetAddrLocal 2
2912: oPushResult
2913: oSetResult 23
2915: oPushResult
2916: LAST_ID
2917: oPushResult
2918: oCall 10792
2920: oPop 2
2922: oAssign
2923: oGetLocal 2
2925: oPushResult
2926: oSetResult 33
2928: oPushResult
2929: oGetLocal 3
2931: oPushResult
2932: oNodeSetBoolean
2933: oPop 3
2935: oGetLocal 1
2937: oPushResult
2938: oGetLocal 2
2940: oPushResult
2941: oNodeVecAppend
2942: oPop 2
2944: oInputChoice 2952
2946: oJumpForward 2960
2948: oJumpForward 2958
2950: oJumpForward 2958
2952: Choice Lookup Table
          13   2950
          12   2946
2957: oEndChoice
2958: oJumpBack 2908
2960: oGetAddrLocal 4
2962: oPushResult
2963: oCall 4014
2965: oPop 1
2967: oGetLocal 3
2969: oChoice 2984
2971: oGetAddrLocal 5
2973: oPushResult
2974: oGetLocal 4
2976: oPushResult
2977: oCall 10820
2979: oPop 1
2981: oAssign
2982: oJumpForward 2993
2984: Choice Lookup Table
           1   2971
2987: oGetAddrLocal 5
2989: oPushResult
2990: oGetLocal 4
2992: oAssign
2993: oGetAddrLocal 6
2995: oPushResult
2996: oSetResult 0
2998: oAssign
2999: oGetLocal 6
3001: oPushResult
3002: oGetLocal 1
3004: oPushResult
3005: oNodeVecSize
3006: oPop 1
3008: oPushResult
3009: equal
3010: oPop 2
3012: oChoice 3069
3014: oGetAddrLocal 2
3016: oPushResult
3017: oGetLocal 1
3019: oPushResult
3020: oGetLocal 6
3022: oPushResult
3023: oNodeVecElement
3024: oPop 2
3026: oAssign
3027: oGetLocal 2
3029: oPushResult
3030: oSetResult 21
3032: oPushResult
3033: oGetLocal 4
3035: oPushResult
3036: oNodeSet
3037: oPop 3
3039: oGetLocal 2
3041: oPushResult
3042: oScopeDeclare
3043: oPop 1
3045: oGetLocal 2
3047: oPushResult
3048: oSetResult 22
3050: oPushResult
3051: oGetLocal 5
3053: oPushResult
3054: oScopeAllocType
3055: oPop 1
3057: oPushResult
3058: oNodeSetInt
3059: oPop 3
3061: oGetAddrLocal 6
3063: oPushResult
3064: inc
3065: oPop 1
3067: oJumpForward 3074
3069: Choice Lookup Table
           0   3014
3072: oJumpForward 3076
3074: oJumpBack 2999
3076: oGetLocal 1
3078: oPushResult
3079: oNodeVecDelete
3080: oPop 1
3082: oInputChoice 3090
3084: oJumpForward 3098
3086: oJumpForward 3096
3088: oJumpForward 3096
3090: Choice Lookup Table
           5   3088
          15   3084
3095: oEndChoice
3096: oJumpBack 2884
3098: oJumpForward 3103
3100: Choice Lookup Table
          14   2884
3103: oReturn
3104: oLocalSpace 0
3106: oInputChoice 3121
3108: oInputChoice 3114
3110: oCall 3187
3112: oJumpForward 3119
3114: Choice Lookup Table
          12   3110
3117: oCall 3129
3119: oJumpForward 3126
3121: Choice Lookup Table
           0   3108
3124: oJumpForward 3128
3126: oJumpBack 3106
3128: oReturn
3129: oLocalSpace 2
3131: oGetAddrLocal 1
3133: oPushResult
3134: oSetResult 16
3136: oPushResult
3137: LAST_ID
3138: oPushResult
3139: oCall 10792
3141: oPop 2
3143: oAssign
3144: oInput 6
3146: oCall 5070
3148: oGetAddrLocal 2
3150: oPushResult
3151: oValueTop
3152: oAssign
3153: oValuePop
3154: oGetLocal 1
3156: oPushResult
3157: oSetResult 22
3159: oPushResult
3160: oGetLocal 2
3162: oPushResult
3163: oNodeSetInt
3164: oPop 3
3166: oGetLocal 1
3168: oPushResult
3169: oSetResult 21
3171: oPushResult
3172: oGetGlobal 7
3174: oPushResult
3175: oNodeSet
3176: oPop 3
3178: oGetLocal 1
3180: oPushResult
3181: oScopeDeclare
3182: oPop 1
3184: oInput 5
3186: oReturn
3187: oLocalSpace 4
3189: oGetAddrLocal 1
3191: oPushResult
3192: oSetResult 24
3194: oPushResult
3195: LAST_ID
3196: oPushResult
3197: oCall 10792
3199: oPop 2
3201: oAssign
3202: oGetAddrLocal 2
3204: oPushResult
3205: oCall 4014
3207: oPop 1
3209: oGetLocal 1
3211: oPushResult
3212: oSetResult 21
3214: oPushResult
3215: oGetLocal 2
3217: oPushResult
3218: oNodeSet
3219: oPop 3
3221: oGetLocal 2
3223: oPushResult
3224: oNodeType
3225: oPop 1
3227: oChoice 3328
3229: oInput 6
3231: oCall 5070
3233: oGetAddrLocal 3
3235: oPushResult
3236: oValueTop
3237: oAssign
3238: oValuePop
3239: oGetLocal 1
3241: oPushResult
3242: oSetResult 22
3244: oPushResult
3245: oGetLocal 3
3247: oPushResult
3248: oNodeSetInt
3249: oPop 3
3251: oGetLocal 1
3253: oPushResult
3254: oScopeDeclare
3255: oPop 1
3257: oInput 5
3259: oJumpForward 3352
3261: oError 16
3263: oJumpForward 3352
3265: oGetGlobal 2
3267: oPushResult
3268: oScopeEnter
3269: oPop 1
3271: oGetAddrLocal 4
3273: oPushResult
3274: oGetLocal 2
3276: oPushResult
3277: oScopeAllocType
3278: oPop 1
3280: oAssign
3281: oScopeEnd
3282: oGetGlobal 2
3284: oPushResult
3285: oCall 1957
3287: oPop 1
3289: oPushResult
3290: oCodePush
3291: oPop 1
3293: oGetLocal 1
3295: oPushResult
3296: oSetResult 22
3298: oPushResult
3299: oGetLocal 4
3301: oPushResult
3302: oNodeSetInt
3303: oPop 3
3305: oInput 6
3307: oGetLocal 2
3309: oPushResult
3310: oGetLocal 4
3312: oPushResult
3313: oCall 3353
3315: oPop 2
3317: oCodePop
3318: oGetLocal 1
3320: oPushResult
3321: oScopeDeclare
3322: oPop 1
3324: oInput 5
3326: oJumpForward 3352
3328: Choice Lookup Table
          37   3265
          35   3265
          34   3261
          33   3261
          27   3261
          39   3261
          40   3229
          28   3229
          32   3229
          29   3229
          30   3229
3351: oEndChoice
3352: oReturn
3353: oLocalSpace 10
3355: oGetParam 2
3357: oPushResult
3358: oNodeType
3359: oPop 1
3361: oChoice 3634
3363: oGetAddrLocal 1
3365: oPushResult
3366: oGetParam 2
3368: oPushResult
3369: oSetResult 36
3371: oPushResult
3372: oNodeGet
3373: oPop 2
3375: oAssign
3376: oGetAddrLocal 2
3378: oPushResult
3379: oGetParam 2
3381: oPushResult
3382: oSetResult 37
3384: oPushResult
3385: oNodeGet
3386: oPop 2
3388: oAssign
3389: oGetAddrLocal 3
3391: oPushResult
3392: oGetLocal 2
3394: oPushResult
3395: oCall 10904
3397: oPop 1
3399: oAssign
3400: oGetAddrLocal 4
3402: oPushResult
3403: oGetLocal 2
3405: oPushResult
3406: oCall 10999
3408: oPop 1
3410: oAssign
3411: oGetAddrLocal 5
3413: oPushResult
3414: oGetLocal 1
3416: oPushResult
3417: oSetResult 17
3419: oPushResult
3420: oNodeGetInt
3421: oPop 2
3423: oAssign
3424: oInput 14
3426: oGetAddrLocal 6
3428: oPushResult
3429: oGetLocal 3
3431: oAssign
3432: oGetLocal 1
3434: oPushResult
3435: oGetParam 1
3437: oPushResult
3438: oCall 3353
3440: oPop 2
3442: oGetLocal 6
3444: oPushResult
3445: oGetLocal 4
3447: oPushResult
3448: equal
3449: oPop 2
3451: oChoice 3459
3453: oJumpForward 3488
3455: oJumpForward 3465
3457: oJumpForward 3465
3459: Choice Lookup Table
           0   3457
           1   3453
3464: oEndChoice
3465: oInput 13
3467: oGetAddrParam 1
3469: oPushResult
3470: oGetParam 1
3472: oPushResult
3473: oGetLocal 5
3475: oPushResult
3476: add
3477: oPop 2
3479: oAssign
3480: oGetAddrLocal 6
3482: oPushResult
3483: inc
3484: oPop 1
3486: oJumpBack 3432
3488: oInput 15
3490: oJumpForward 3658
3492: oInput 14
3494: oGetAddrLocal 7
3496: oPushResult
3497: oGetParam 2
3499: oPushResult
3500: oSetResult 40
3502: oPushResult
3503: oNodeGet
3504: oPop 2
3506: oAssign
3507: oInputChoice 3511
3509: oJumpForward 3516
3511: Choice Lookup Table
           0   3509
3514: oJumpForward 3582
3516: oGetAddrLocal 8
3518: oPushResult
3519: oGetLocal 7
3521: oPushResult
3522: oScopeFindRequireInScope
3523: oPop 1
3525: oAssign
3526: oInput 12
3528: oGetAddrLocal 9
3530: oPushResult
3531: oGetLocal 8
3533: oPushResult
3534: oSetResult 21
3536: oPushResult
3537: oNodeGet
3538: oPop 2
3540: oAssign
3541: oGetAddrLocal 10
3543: oPushResult
3544: oGetParam 1
3546: oPushResult
3547: oGetLocal 8
3549: oPushResult
3550: oSetResult 22
3552: oPushResult
3553: oNodeGetInt
3554: oPop 2
3556: oPushResult
3557: add
3558: oPop 2
3560: oAssign
3561: oGetLocal 9
3563: oPushResult
3564: oGetLocal 10
3566: oPushResult
3567: oCall 3353
3569: oPop 2
3571: oInputChoice 3575
3573: oJumpForward 3580
3575: Choice Lookup Table
           5   3573
3578: oJumpForward 3582
3580: oJumpBack 3507
3582: oInput 15
3584: oJumpForward 3658
3586: oEmit 16
3588: oGetParam 1
3590: oPushResult
3591: oEmitInt
3592: oPop 1
3594: oCall 5070
3596: oEmit 15
3598: oValueTop
3599: oPushResult
3600: oEmitInt
3601: oPop 1
3603: oValuePop
3604: oEmit 27
3606: oJumpForward 3658
3608: oEmit 16
3610: oGetParam 1
3612: oPushResult
3613: oEmitInt
3614: oPop 1
3616: oCall 5070
3618: oEmit 15
3620: oValueTop
3621: oPushResult
3622: oEmitInt
3623: oPop 1
3625: oValuePop
3626: oEmit 26
3628: oJumpForward 3658
3630: oError 16
3632: oJumpForward 3658
3634: Choice Lookup Table
          34   3630
          33   3630
          27   3630
          39   3630
          40   3608
          28   3608
          32   3586
          29   3586
          30   3586
          37   3492
          35   3363
3657: oEndChoice
3658: oReturn
3659: oLocalSpace 2
3661: oInputChoice 3707
3663: oGetAddrLocal 1
3665: oPushResult
3666: oSetResult 18
3668: oPushResult
3669: LAST_ID
3670: oPushResult
3671: oCall 10792
3673: oPop 2
3675: oAssign
3676: oInput 6
3678: oGetAddrLocal 2
3680: oPushResult
3681: oCall 4014
3683: oPop 1
3685: oGetLocal 1
3687: oPushResult
3688: oSetResult 21
3690: oPushResult
3691: oGetLocal 2
3693: oPushResult
3694: oNodeSet
3695: oPop 3
3697: oGetLocal 1
3699: oPushResult
3700: oScopeDeclare
3701: oPop 1
3703: oInput 5
3705: oJumpForward 3712
3707: Choice Lookup Table
           0   3663
3710: oJumpForward 3714
3712: oJumpBack 3661
3714: oReturn
3715: oLocalSpace 6
3717: oInputChoice 3941
3719: oGetAddrLocal 1
3721: oPushResult
3722: oNodeVecNew
3723: oAssign
3724: oGetAddrLocal 2
3726: oPushResult
3727: oGetParam 1
3729: oPushResult
3730: LAST_ID
3731: oPushResult
3732: oCall 10792
3734: oPop 2
3736: oAssign
3737: oGetLocal 1
3739: oPushResult
3740: oGetLocal 2
3742: oPushResult
3743: oNodeVecAppend
3744: oPop 2
3746: oInputChoice 3752
3748: oInput 0
3750: oJumpForward 3757
3752: Choice Lookup Table
          13   3748
3755: oJumpForward 3759
3757: oJumpBack 3724
3759: oInput 12
3761: oGetAddrLocal 3
3763: oPushResult
3764: oCall 4014
3766: oPop 1
3768: oGetAddrLocal 4
3770: oPushResult
3771: oSetResult 0
3773: oAssign
3774: oGetLocal 4
3776: oPushResult
3777: oGetLocal 1
3779: oPushResult
3780: oNodeVecSize
3781: oPop 1
3783: oPushResult
3784: equal
3785: oPop 2
3787: oChoice 3828
3789: oGetAddrLocal 2
3791: oPushResult
3792: oGetLocal 1
3794: oPushResult
3795: oGetLocal 4
3797: oPushResult
3798: oNodeVecElement
3799: oPop 2
3801: oAssign
3802: oGetLocal 2
3804: oPushResult
3805: oSetResult 21
3807: oPushResult
3808: oGetLocal 3
3810: oPushResult
3811: oNodeSet
3812: oPop 3
3814: oGetLocal 2
3816: oPushResult
3817: oScopeDeclareAlloc
3818: oPop 1
3820: oGetAddrLocal 4
3822: oPushResult
3823: inc
3824: oPop 1
3826: oJumpForward 3833
3828: Choice Lookup Table
           0   3789
3831: oJumpForward 3835
3833: oJumpBack 3774
3835: oInputChoice 3928
3837: oGetLocal 1
3839: oPushResult
3840: oNodeVecSize
3841: oPop 1
3843: oChoice 3847
3845: oJumpForward 3852
3847: Choice Lookup Table
           1   3845
3850: oError 22
3852: oGetAddrLocal 5
3854: oPushResult
3855: oScopeCurrent
3856: oPushResult
3857: oCall 1957
3859: oPop 1
3861: oAssign
3862: oGetLocal 5
3864: oPushResult
3865: oCodePush
3866: oPop 1
3868: oGetAddrLocal 6
3870: oPushResult
3871: oSetResult 0
3873: oAssign
3874: oCall 10530
3876: oPushResult
3877: equal_zero
3878: oPop 1
3880: oChoice 3896
3882: oGetGlobal 3
3884: oPushResult
3885: oScopeEnter
3886: oPop 1
3888: oGetAddrLocal 6
3890: oPushResult
3891: oSetResult 1
3893: oAssign
3894: oJumpForward 3899
3896: Choice Lookup Table
           1   3882
3899: oGetLocal 2
3901: oPushResult
3902: oSetResult 1
3904: oPushResult
3905: oCall 9688
3907: oPop 2
3909: oCall 5143
3911: oCall 7992
3913: oCall 9444
3915: oGetLocal 6
3917: oChoice 3922
3919: oScopeEnd
3920: oJumpForward 3925
3922: Choice Lookup Table
           1   3919
3925: oCodePop
3926: oJumpForward 3931
3928: Choice Lookup Table
           6   3837
3931: oGetLocal 1
3933: oPushResult
3934: oNodeVecDelete
3935: oPop 1
3937: oInput 5
3939: oJumpForward 3946
3941: Choice Lookup Table
           0   3719
3944: oJumpForward 3948
3946: oJumpBack 3717
3948: oReturn
3949: oLocalSpace 2
3951: oInputChoice 3958
3953: oJumpForward 3964
3955: oChangeIntLitToLabelIdent
3956: oJumpForward 3964
3958: Choice Lookup Table
           1   3955
           0   3953
3963: oEndChoice
3964: oGetAddrLocal 1
3966: oPushResult
3967: oSetResult 25
3969: oPushResult
3970: LAST_ID
3971: oPushResult
3972: oCall 10792
3974: oPop 2
3976: oAssign
3977: oGetAddrLocal 2
3979: oPushResult
3980: oLabelNew
3981: oAssign
3982: oGetLocal 1
3984: oPushResult
3985: oSetResult 22
3987: oPushResult
3988: oGetLocal 2
3990: oPushResult
3991: oNodeSetLabel
3992: oPop 3
3994: oGetLocal 1
3996: oPushResult
3997: oScopeDeclare
3998: oPop 1
4000: oInputChoice 4004
4002: oJumpForward 4009
4004: Choice Lookup Table
          13   4002
4007: oJumpForward 4011
4009: oJumpBack 3951
4011: oInput 5
4013: oReturn
4014: oLocalSpace 12
4016: oInputChoice 4489
4018: oGetAddrLocal 1
4020: oPushResult
4021: oScopeFindRequire
4022: oAssign
4023: oGetAddrLocal 1
4025: oPushResult
4026: oCall 510
4028: oPop 1
4030: oGetLocal 1
4032: oPushResult
4033: oNodeType
4034: oPop 1
4036: oChoice 4053
4038: oGetParam 1
4040: oPushResult
4041: oGetLocal 1
4043: oPushResult
4044: oSetResult 21
4046: oPushResult
4047: oNodeGet
4048: oPop 2
4050: oAssign
4051: oJumpForward 4064
4053: Choice Lookup Table
          18   4038
4056: oError 2
4058: oGetParam 1
4060: oPushResult
4061: oGetGlobal 7
4063: oAssign
4064: oJumpForward 4508
4066: oInput 16
4068: oGetAddrLocal 2
4070: oPushResult
4071: oNodeVecNew
4072: oAssign
4073: oGetAddrLocal 3
4075: oPushResult
4076: oSetResult 36
4078: oPushResult
4079: oNodeNew
4080: oPop 1
4082: oAssign
4083: oGetLocal 3
4085: oPushResult
4086: oSetResult 36
4088: oPushResult
4089: oGetGlobal 7
4091: oPushResult
4092: oNodeSet
4093: oPop 3
4095: oCall 5070
4097: oGetLocal 3
4099: oPushResult
4100: oSetResult 38
4102: oPushResult
4103: oValueTop
4104: oPushResult
4105: oNodeSetInt
4106: oPop 3
4108: oValuePop
4109: oInput 21
4111: oCall 5070
4113: oGetLocal 3
4115: oPushResult
4116: oSetResult 39
4118: oPushResult
4119: oValueTop
4120: oPushResult
4121: oNodeSetInt
4122: oPop 3
4124: oValuePop
4125: oGetLocal 3
4127: oPushResult
4128: oSetResult 17
4130: oPushResult
4131: oSetResult 4
4133: oPushResult
4134: oNodeSetInt
4135: oPop 3
4137: oGetLocal 3
4139: oPushResult
4140: oTypeAdd
4141: oPop 1
4143: oGetAddrLocal 4
4145: oPushResult
4146: oSetResult 35
4148: oPushResult
4149: oNodeNew
4150: oPop 1
4152: oAssign
4153: oGetLocal 4
4155: oPushResult
4156: oSetResult 37
4158: oPushResult
4159: oGetLocal 3
4161: oPushResult
4162: oNodeSet
4163: oPop 3
4165: oGetLocal 2
4167: oPushResult
4168: oGetLocal 4
4170: oPushResult
4171: oNodeVecAppend
4172: oPop 2
4174: oInputChoice 4182
4176: oJumpForward 4190
4178: oJumpForward 4188
4180: oJumpForward 4188
4182: Choice Lookup Table
          13   4180
          17   4176
4187: oEndChoice
4188: oJumpBack 4073
4190: oInput 40
4192: oGetAddrLocal 5
4194: oPushResult
4195: oCall 4014
4197: oPop 1
4199: oGetAddrLocal 6
4201: oPushResult
4202: oGetLocal 2
4204: oPushResult
4205: oNodeVecSize
4206: oPop 1
4208: oAssign
4209: oGetAddrLocal 6
4211: oPushResult
4212: dec
4213: oPop 1
4215: oGetAddrLocal 7
4217: oPushResult
4218: oGetLocal 2
4220: oPushResult
4221: oGetLocal 6
4223: oPushResult
4224: oNodeVecElement
4225: oPop 2
4227: oAssign
4228: oGetLocal 7
4230: oPushResult
4231: oSetResult 36
4233: oPushResult
4234: oGetLocal 5
4236: oPushResult
4237: oNodeSet
4238: oPop 3
4240: oGetAddrLocal 8
4242: oPushResult
4243: oGetLocal 7
4245: oPushResult
4246: oSetResult 37
4248: oPushResult
4249: oNodeGet
4250: oPop 2
4252: oAssign
4253: oGetAddrLocal 9
4255: oPushResult
4256: oGetLocal 8
4258: oPushResult
4259: oSetResult 39
4261: oPushResult
4262: oNodeGetInt
4263: oPop 2
4265: oPushResult
4266: oGetLocal 8
4268: oPushResult
4269: oSetResult 38
4271: oPushResult
4272: oNodeGetInt
4273: oPop 2
4275: oPushResult
4276: subtract
4277: oPop 2
4279: oAssign
4280: oGetAddrLocal 9
4282: oPushResult
4283: inc
4284: oPop 1
4286: oGetLocal 7
4288: oPushResult
4289: oSetResult 17
4291: oPushResult
4292: oGetLocal 9
4294: oPushResult
4295: oGetLocal 5
4297: oPushResult
4298: oSetResult 17
4300: oPushResult
4301: oNodeGetInt
4302: oPop 2
4304: oPushResult
4305: multiply
4306: oPop 2
4308: oPushResult
4309: oNodeSetInt
4310: oPop 3
4312: oGetLocal 7
4314: oPushResult
4315: oTypeAdd
4316: oPop 1
4318: oGetAddrLocal 5
4320: oPushResult
4321: oGetLocal 7
4323: oAssign
4324: oGetLocal 6
4326: oPushResult
4327: equal_zero
4328: oPop 1
4330: oChoice 4336
4332: oJumpForward 4341
4334: oJumpForward 4339
4336: Choice Lookup Table
           1   4332
4339: oJumpBack 4209
4341: oGetParam 1
4343: oPushResult
4344: oGetLocal 2
4346: oPushResult
4347: oSetResult 0
4349: oPushResult
4350: oNodeVecElement
4351: oPop 2
4353: oAssign
4354: oGetLocal 2
4356: oPushResult
4357: oNodeVecDelete
4358: oPop 1
4360: oJumpForward 4508
4362: oGetAddrLocal 10
4364: oPushResult
4365: oCall 4014
4367: oPop 1
4369: oGetParam 1
4371: oPushResult
4372: oGetLocal 10
4374: oPushResult
4375: oCall 10820
4377: oPop 1
4379: oAssign
4380: oJumpForward 4508
4382: oGetParam 1
4384: oPushResult
4385: oSetResult 37
4387: oPushResult
4388: oNodeNew
4389: oPop 1
4391: oAssign
4392: oSetResult -1
4394: oPushResult
4395: oSetResult 2
4397: oPushResult
4398: oScopeBegin
4399: oPop 2
4401: oSetResult 22
4403: oPushResult
4404: oCall 3715
4406: oPop 1
4408: oGetAddrLocal 11
4410: oPushResult
4411: oScopeCurrent
4412: oPushResult
4413: oSetResult 17
4415: oPushResult
4416: oNodeGetInt
4417: oPop 2
4419: oAssign
4420: oGetLocal 11
4422: oPushResult
4423: equal_zero
4424: oPop 1
4426: oChoice 4432
4428: oError 19
4430: oJumpForward 4435
4432: Choice Lookup Table
           1   4428
4435: oInput 36
4437: oGetFromParam 1
4439: oPushResult
4440: oSetResult 40
4442: oPushResult
4443: oScopeCurrent
4444: oPushResult
4445: oNodeSet
4446: oPop 3
4448: oGetFromParam 1
4450: oPushResult
4451: oSetResult 17
4453: oPushResult
4454: oGetLocal 11
4456: oPushResult
4457: oNodeSetInt
4458: oPop 3
4460: oScopeEnd
4461: oGetFromParam 1
4463: oPushResult
4464: oTypeAdd
4465: oPop 1
4467: oJumpForward 4508
4469: oGetParam 1
4471: oPushResult
4472: oCall 4509
4474: oPop 1
4476: oJumpForward 4508
4478: oInput 40
4480: oGetAddrLocal 12
4482: oPushResult
4483: oCall 4014
4485: oPop 1
4487: oJumpForward 4508
4489: Choice Lookup Table
          39   4478
          14   4469
          38   4382
          18   4362
          37   4066
           0   4018
4502: oCall 5070
4504: oInput 21
4506: oCall 5070
4508: oReturn
4509: oLocalSpace 11
4511: oGetParam 1
4513: oPushResult
4514: oSetResult 40
4516: oPushResult
4517: oNodeNew
4518: oPop 1
4520: oAssign
4521: oGetAddrLocal 1
4523: oPushResult
4524: oSetResult 0
4526: oAssign
4527: oGetAddrLocal 2
4529: oPushResult
4530: oSetResult 0
4532: oAssign
4533: oGetAddrLocal 3
4535: oPushResult
4536: oSetResult 1
4538: oAssign
4539: oGetAddrLocal 4
4541: oPushResult
4542: oScopeCurrent
4543: oAssign
4544: oSetResult -1
4546: oPushResult
4547: oSetResult 2
4549: oPushResult
4550: oScopeBegin
4551: oPop 2
4553: oInput 0
4555: oGetAddrLocal 5
4557: oPushResult
4558: oSetResult 17
4560: oPushResult
4561: LAST_ID
4562: oPushResult
4563: oCall 10792
4565: oPop 2
4567: oAssign
4568: oGetAddrLocal 6
4570: oPushResult
4571: oSetResult 17
4573: oPushResult
4574: LAST_ID
4575: oPushResult
4576: oCall 10792
4578: oPop 2
4580: oAssign
4581: oGetLocal 5
4583: oPushResult
4584: oSetResult 21
4586: oPushResult
4587: oGetFromParam 1
4589: oPushResult
4590: oNodeSet
4591: oPop 3
4593: oGetLocal 6
4595: oPushResult
4596: oSetResult 21
4598: oPushResult
4599: oGetFromParam 1
4601: oPushResult
4602: oNodeSet
4603: oPop 3
4605: oGetAddrLocal 7
4607: oPushResult
4608: LAST_ID
4609: oPushResult
4610: ID_STRING
4611: oPop 1
4613: oPushResult
4614: oStringAllocLit
4615: oPop 1
4617: oAssign
4618: oGetLocal 5
4620: oPushResult
4621: oSetResult 32
4623: oPushResult
4624: oGetLocal 7
4626: oPushResult
4627: oNodeSetInt
4628: oPop 3
4630: oGetLocal 6
4632: oPushResult
4633: oSetResult 32
4635: oPushResult
4636: oGetLocal 7
4638: oPushResult
4639: oNodeSetInt
4640: oPop 3
4642: oInputChoice 4711
4644: oCall 5070
4646: oGetLocal 2
4648: oPushResult
4649: equal_zero
4650: oPop 1
4652: oChoice 4673
4654: oValueTop
4655: oPushResult
4656: oGetLocal 1
4658: oPushResult
4659: greater
4660: oPop 2
4662: oChoice 4668
4664: oError 26
4666: oJumpForward 4671
4668: Choice Lookup Table
           0   4664
4671: oJumpForward 4676
4673: Choice Lookup Table
           0   4654
4676: oGetLocal 1
4678: oPushResult
4679: oValueTop
4680: oPushResult
4681: equal
4682: oPop 2
4684: oChoice 4700
4686: oGetFromParam 1
4688: oPushResult
4689: oSetResult 43
4691: oPushResult
4692: oSetResult 1
4694: oPushResult
4695: oNodeSetBoolean
4696: oPop 3
4698: oJumpForward 4703
4700: Choice Lookup Table
           0   4686
4703: oGetAddrLocal 1
4705: oPushResult
4706: oValueTop
4707: oAssign
4708: oValuePop
4709: oJumpForward 4716
4711: Choice Lookup Table
           4   4644
           6   4644
4716: oGetLocal 5
4718: oPushResult
4719: oSetResult 22
4721: oPushResult
4722: oGetLocal 1
4724: oPushResult
4725: oNodeSetInt
4726: oPop 3
4728: oGetLocal 6
4730: oPushResult
4731: oSetResult 22
4733: oPushResult
4734: oGetLocal 1
4736: oPushResult
4737: oNodeSetInt
4738: oPop 3
4740: oGetLocal 5
4742: oPushResult
4743: oScopeDeclare
4744: oPop 1
4746: oGetLocal 4
4748: oPushResult
4749: oScopeEnter
4750: oPop 1
4752: oGetLocal 6
4754: oPushResult
4755: oScopeDeclare
4756: oPop 1
4758: oScopeEnd
4759: oGetAddrLocal 1
4761: oPushResult
4762: inc
4763: oPop 1
4765: oGetAddrLocal 2
4767: oPushResult
4768: inc
4769: oPop 1
4771: oInputChoice 4775
4773: oJumpForward 4780
4775: Choice Lookup Table
          13   4773
4778: oJumpForward 4782
4780: oJumpBack 4553
4782: oInput 15
4784: oGetFromParam 1
4786: oPushResult
4787: oSetResult 40
4789: oPushResult
4790: oScopeCurrent
4791: oPushResult
4792: oNodeSet
4793: oPop 3
4795: oGetFromParam 1
4797: oPushResult
4798: oSetResult 17
4800: oPushResult
4801: oSetResult 4
4803: oPushResult
4804: oNodeSetInt
4805: oPop 3
4807: oScopeEnd
4808: oGetGlobal 2
4810: oPushResult
4811: oCall 1957
4813: oPop 1
4815: oPushResult
4816: oCodePush
4817: oPop 1
4819: oGetGlobal 2
4821: oPushResult
4822: oScopeEnter
4823: oPop 1
4825: oGetAddrLocal 8
4827: oPushResult
4828: oGetLocal 2
4830: oPushResult
4831: oSetResult 1
4833: oPushResult
4834: add
4835: oPop 2
4837: oPushResult
4838: oSetResult 16
4840: oPushResult
4841: multiply
4842: oPop 2
4844: oAssign
4845: oGetAddrLocal 9
4847: oPushResult
4848: oGetLocal 8
4850: oPushResult
4851: oSetResult 8
4853: oPushResult
4854: oScopeAlloc
4855: oPop 2
4857: oAssign
4858: oScopeEnd
4859: oGetFromParam 1
4861: oPushResult
4862: oSetResult 42
4864: oPushResult
4865: oGetLocal 9
4867: oPushResult
4868: oNodeSetInt
4869: oPop 3
4871: oGetAddrLocal 10
4873: oPushResult
4874: oGetFromParam 1
4876: oPushResult
4877: oSetResult 40
4879: oPushResult
4880: oNodeGet
4881: oPop 2
4883: oPushResult
4884: oSetResult 15
4886: oPushResult
4887: oNodeGetIter
4888: oPop 2
4890: oAssign
4891: oGetAddrLocal 11
4893: oPushResult
4894: oGetLocal 10
4896: oPushResult
4897: oNodeIterValue
4898: oPop 1
4900: oAssign
4901: oGetLocal 11
4903: oPushResult
4904: oNodeNull
4905: oPop 1
4907: oChoice 4913
4909: oJumpForward 5000
4911: oJumpForward 4916
4913: Choice Lookup Table
           1   4909
4916: oEmit 16
4918: oGetLocal 9
4920: oPushResult
4921: oEmitInt
4922: oPop 1
4924: oEmit 15
4926: oGetLocal 11
4928: oPushResult
4929: oSetResult 22
4931: oPushResult
4932: oNodeGetInt
4933: oPop 2
4935: oPushResult
4936: oEmitInt
4937: oPop 1
4939: oEmit 26
4941: oGetAddrLocal 9
4943: oPushResult
4944: oGetLocal 9
4946: oPushResult
4947: oSetResult 8
4949: oPushResult
4950: add
4951: oPop 2
4953: oAssign
4954: oEmit 16
4956: oGetLocal 9
4958: oPushResult
4959: oEmitInt
4960: oPop 1
4962: oEmit 16
4964: oGetLocal 11
4966: oPushResult
4967: oSetResult 32
4969: oPushResult
4970: oNodeGetInt
4971: oPop 2
4973: oPushResult
4974: oEmitInt
4975: oPop 1
4977: oEmit 28
4979: oGetAddrLocal 9
4981: oPushResult
4982: oGetLocal 9
4984: oPushResult
4985: oSetResult 8
4987: oPushResult
4988: add
4989: oPop 2
4991: oAssign
4992: oGetAddrLocal 10
4994: oPushResult
4995: oNodeIterNext
4996: oPop 1
4998: oJumpBack 4891
5000: oEmit 16
5002: oGetLocal 9
5004: oPushResult
5005: oEmitInt
5006: oPop 1
5008: oEmit 15
5010: oSetResult 0
5012: oPushResult
5013: oEmitInt
5014: oPop 1
5016: oEmit 26
5018: oGetAddrLocal 9
5020: oPushResult
5021: oGetLocal 9
5023: oPushResult
5024: oSetResult 8
5026: oPushResult
5027: add
5028: oPop 2
5030: oAssign
5031: oEmit 16
5033: oGetLocal 9
5035: oPushResult
5036: oEmitInt
5037: oPop 1
5039: oEmit 15
5041: oSetResult 0
5043: oPushResult
5044: oEmitInt
5045: oPop 1
5047: oEmit 28
5049: oGetAddrLocal 9
5051: oPushResult
5052: oGetLocal 9
5054: oPushResult
5055: oSetResult 8
5057: oPushResult
5058: add
5059: oPop 2
5061: oAssign
5062: oCodePop
5063: oGetFromParam 1
5065: oPushResult
5066: oTypeAdd
5067: oPop 1
5069: oReturn
5070: oLocalSpace 1
5072: oInputChoice 5134
5074: TOKEN_VALUE
5075: oPushResult
5076: oValuePush
5077: oPop 1
5079: oJumpForward 5142
5081: oGetAddrLocal 1
5083: oPushResult
5084: oScopeFindRequire
5085: oAssign
5086: oGetAddrLocal 1
5088: oPushResult
5089: oCall 510
5091: oPop 1
5093: oGetLocal 1
5095: oPushResult
5096: oNodeType
5097: oPop 1
5099: oChoice 5116
5101: oGetLocal 1
5103: oPushResult
5104: oSetResult 22
5106: oPushResult
5107: oNodeGetInt
5108: oPop 2
5110: oPushResult
5111: oValuePush
5112: oPop 1
5114: oJumpForward 5127
5116: Choice Lookup Table
          16   5101
5119: oError 1
5121: oSetResult 0
5123: oPushResult
5124: oValuePush
5125: oPop 1
5127: oJumpForward 5142
5129: oCall 5070
5131: oValueNegate
5132: oJumpForward 5142
5134: Choice Lookup Table
          25   5129
           0   5081
           1   5074
5141: oEndChoice
5142: oReturn
5143: oLocalSpace 1
5145: oGetAddrLocal 1
5147: oPushResult
5148: oSetResult 0
5150: oAssign
5151: oGetAddrLocal 1
5153: oPushResult
5154: oCall 5304
5156: oPop 1
5158: oGetAddrLocal 1
5160: oPushResult
5161: oCall 5204
5163: oPop 1
5165: oReturn
5166: oLocalSpace 0
5168: oGetParam 1
5170: oPushResult
5171: oCall 5304
5173: oPop 1
5175: oTypeSNodeType
5176: oChoice 5195
5178: oJumpForward 5202
5180: oGetParam 1
5182: oPushResult
5183: oLabelNew
5184: oAssign
5185: oEmit 68
5187: oGetFromParam 1
5189: oPushResult
5190: oEmitLabel
5191: oPop 1
5193: oJumpForward 5202
5195: Choice Lookup Table
          30   5180
          31   5178
5200: oError 8
5202: oTypeSPop
5203: oReturn
5204: oLocalSpace 1
5206: oTypeSNodeType
5207: oChoice 5269
5209: oGetAddrLocal 1
5211: oPushResult
5212: oLabelNew
5213: oAssign
5214: oEmit 15
5216: oSetResult 1
5218: oPushResult
5219: oEmitInt
5220: oPop 1
5222: oEmit 66
5224: oGetLocal 1
5226: oPushResult
5227: oEmitLabel
5228: oPop 1
5230: oEmit 69
5232: oGetFromParam 1
5234: oPushResult
5235: oEmitLabel
5236: oPop 1
5238: oEmit 15
5240: oSetResult 0
5242: oPushResult
5243: oEmitInt
5244: oPop 1
5246: oEmit 69
5248: oGetLocal 1
5250: oPushResult
5251: oEmitLabel
5252: oPop 1
5254: oTypeSPop
5255: oGetGlobal 8
5257: oPushResult
5258: oTypeSPush
5259: oPop 1
5261: oGetParam 1
5263: oPushResult
5264: oSetResult 0
5266: oAssign
5267: oJumpForward 5272
5269: Choice Lookup Table
          31   5209
5272: oReturn
5273: oLocalSpace 0
5275: oTypeSNodeType
5276: oChoice 5300
5278: oGetParam 1
5280: oPushResult
5281: oLabelNew
5282: oAssign
5283: oEmit 68
5285: oGetFromParam 1
5287: oPushResult
5288: oEmitLabel
5289: oPop 1
5291: oTypeSPop
5292: oGetGlobal 9
5294: oPushResult
5295: oTypeSPush
5296: oPop 1
5298: oJumpForward 5303
5300: Choice Lookup Table
          30   5278
5303: oReturn
5304: oLocalSpace 0
5306: oGetParam 1
5308: oPushResult
5309: oCall 5777
5311: oPop 1
5313: oInputChoice 5759
5315: oGetParam 1
5317: oPushResult
5318: oCall 5204
5320: oPop 1
5322: oCall 10711
5324: oGetParam 1
5326: oPushResult
5327: oCall 5777
5329: oPop 1
5331: oGetParam 1
5333: oPushResult
5334: oCall 5204
5336: oPop 1
5338: oCall 10711
5340: oCall 10580
5342: oTypeSNodeType
5343: oChoice 5361
5345: oEmit 41
5347: oJumpForward 5380
5349: oEmit 47
5351: oJumpForward 5380
5353: oEmit 53
5355: oJumpForward 5380
5357: oError 16
5359: oJumpForward 5380
5361: Choice Lookup Table
          38   5357
          39   5357
          34   5353
          33   5353
          40   5349
          28   5349
          32   5345
          30   5345
5378: oError 17
5380: oTypeSPop
5381: oGetGlobal 8
5383: oPushResult
5384: oTypeSPush
5385: oPop 1
5387: oJumpForward 5774
5389: oGetParam 1
5391: oPushResult
5392: oCall 5204
5394: oPop 1
5396: oCall 10711
5398: oGetParam 1
5400: oPushResult
5401: oCall 5777
5403: oPop 1
5405: oGetParam 1
5407: oPushResult
5408: oCall 5204
5410: oPop 1
5412: oCall 10711
5414: oCall 10580
5416: oTypeSNodeType
5417: oChoice 5435
5419: oEmit 42
5421: oJumpForward 5454
5423: oEmit 48
5425: oJumpForward 5454
5427: oEmit 54
5429: oJumpForward 5454
5431: oError 16
5433: oJumpForward 5454
5435: Choice Lookup Table
          38   5431
          39   5431
          34   5427
          33   5427
          40   5423
          28   5423
          32   5419
          30   5419
5452: oError 17
5454: oTypeSPop
5455: oGetGlobal 8
5457: oPushResult
5458: oTypeSPush
5459: oPop 1
5461: oJumpForward 5774
5463: oGetParam 1
5465: oPushResult
5466: oCall 5204
5468: oPop 1
5470: oCall 10711
5472: oGetParam 1
5474: oPushResult
5475: oCall 5777
5477: oPop 1
5479: oGetParam 1
5481: oPushResult
5482: oCall 5204
5484: oPop 1
5486: oCall 10711
5488: oCall 10580
5490: oTypeSNodeType
5491: oChoice 5509
5493: oEmit 44
5495: oJumpForward 5528
5497: oEmit 50
5499: oJumpForward 5528
5501: oEmit 56
5503: oJumpForward 5528
5505: oError 16
5507: oJumpForward 5528
5509: Choice Lookup Table
          38   5505
          39   5505
          34   5501
          33   5501
          40   5497
          28   5497
          32   5493
          30   5493
5526: oError 17
5528: oTypeSPop
5529: oGetGlobal 8
5531: oPushResult
5532: oTypeSPush
5533: oPop 1
5535: oJumpForward 5774
5537: oGetParam 1
5539: oPushResult
5540: oCall 5204
5542: oPop 1
5544: oCall 10711
5546: oGetParam 1
5548: oPushResult
5549: oCall 5777
5551: oPop 1
5553: oGetParam 1
5555: oPushResult
5556: oCall 5204
5558: oPop 1
5560: oCall 10711
5562: oCall 10580
5564: oTypeSNodeType
5565: oChoice 5583
5567: oEmit 43
5569: oJumpForward 5602
5571: oEmit 49
5573: oJumpForward 5602
5575: oEmit 55
5577: oJumpForward 5602
5579: oError 16
5581: oJumpForward 5602
5583: Choice Lookup Table
          38   5579
          39   5579
          34   5575
          33   5575
          40   5571
          28   5571
          32   5567
          30   5567
5600: oError 17
5602: oTypeSPop
5603: oGetGlobal 8
5605: oPushResult
5606: oTypeSPush
5607: oPop 1
5609: oJumpForward 5774
5611: oGetParam 1
5613: oPushResult
5614: oCall 5204
5616: oPop 1
5618: oCall 10711
5620: oGetParam 1
5622: oPushResult
5623: oCall 5777
5625: oPop 1
5627: oGetParam 1
5629: oPushResult
5630: oCall 5204
5632: oPop 1
5634: oCall 10711
5636: oCall 10580
5638: oTypeSNodeType
5639: oChoice 5657
5641: oEmit 46
5643: oJumpForward 5676
5645: oEmit 52
5647: oJumpForward 5676
5649: oEmit 58
5651: oJumpForward 5676
5653: oError 16
5655: oJumpForward 5676
5657: Choice Lookup Table
          38   5653
          39   5653
          34   5649
          33   5649
          40   5645
          28   5645
          32   5641
          30   5641
5674: oError 17
5676: oTypeSPop
5677: oGetGlobal 8
5679: oPushResult
5680: oTypeSPush
5681: oPop 1
5683: oJumpForward 5774
5685: oGetParam 1
5687: oPushResult
5688: oCall 5204
5690: oPop 1
5692: oCall 10711
5694: oGetParam 1
5696: oPushResult
5697: oCall 5777
5699: oPop 1
5701: oGetParam 1
5703: oPushResult
5704: oCall 5204
5706: oPop 1
5708: oCall 10711
5710: oCall 10580
5712: oTypeSNodeType
5713: oChoice 5731
5715: oEmit 45
5717: oJumpForward 5750
5719: oEmit 51
5721: oJumpForward 5750
5723: oEmit 57
5725: oJumpForward 5750
5727: oError 16
5729: oJumpForward 5750
5731: Choice Lookup Table
          38   5727
          39   5727
          34   5723
          33   5723
          40   5719
          28   5719
          32   5715
          30   5715
5748: oError 17
5750: oTypeSPop
5751: oGetGlobal 8
5753: oPushResult
5754: oTypeSPush
5755: oPop 1
5757: oJumpForward 5774
5759: Choice Lookup Table
          11   5685
          10   5611
           9   5537
           8   5463
           7   5389
           6   5315
5772: oJumpForward 5776
5774: oJumpBack 5313
5776: oReturn
5777: oLocalSpace 1
5779: oGetAddrLocal 1
5781: oPushResult
5782: oSetResult 0
5784: oAssign
5785: oGetParam 1
5787: oPushResult
5788: oCall 5957
5790: oPop 1
5792: oInputChoice 5925
5794: oTypeSNodeType
5795: oChoice 5866
5797: oGetLocal 1
5799: oPushResult
5800: oSetResult 0
5802: oPushResult
5803: equal_label
5804: oPop 2
5806: oChoice 5815
5808: oGetAddrLocal 1
5810: oPushResult
5811: oLabelNew
5812: oAssign
5813: oJumpForward 5818
5815: Choice Lookup Table
           1   5808
5818: oEmit 66
5820: oGetLocal 1
5822: oPushResult
5823: oEmitLabel
5824: oPop 1
5826: oJumpForward 5873
5828: oGetParam 1
5830: oPushResult
5831: oCall 5273
5833: oPop 1
5835: oGetLocal 1
5837: oPushResult
5838: oSetResult 0
5840: oPushResult
5841: equal_label
5842: oPop 2
5844: oChoice 5853
5846: oGetAddrLocal 1
5848: oPushResult
5849: oLabelNew
5850: oAssign
5851: oJumpForward 5856
5853: Choice Lookup Table
           1   5846
5856: oEmit 66
5858: oGetLocal 1
5860: oPushResult
5861: oEmitLabel
5862: oPop 1
5864: oJumpForward 5873
5866: Choice Lookup Table
          30   5828
          31   5797
5871: oError 8
5873: oTypeSPop
5874: oEmit 69
5876: oGetFromParam 1
5878: oPushResult
5879: oEmitLabel
5880: oPop 1
5882: oGetParam 1
5884: oPushResult
5885: oSetResult 0
5887: oAssign
5888: oGetParam 1
5890: oPushResult
5891: oCall 5957
5893: oPop 1
5895: oTypeSNodeType
5896: oChoice 5909
5898: oJumpForward 5916
5900: oGetParam 1
5902: oPushResult
5903: oCall 5273
5905: oPop 1
5907: oJumpForward 5916
5909: Choice Lookup Table
          30   5900
          31   5898
5914: oError 8
5916: oTypeSPop
5917: oGetGlobal 9
5919: oPushResult
5920: oTypeSPush
5921: oPop 1
5923: oJumpForward 5930
5925: Choice Lookup Table
          55   5794
5928: oJumpForward 5932
5930: oJumpBack 5792
5932: oGetLocal 1
5934: oPushResult
5935: oSetResult 0
5937: oPushResult
5938: equal_label
5939: oPop 2
5941: oChoice 5953
5943: oEmit 69
5945: oGetLocal 1
5947: oPushResult
5948: oEmitLabel
5949: oPop 1
5951: oJumpForward 5956
5953: Choice Lookup Table
           0   5943
5956: oReturn
5957: oLocalSpace 2
5959: oGetAddrLocal 1
5961: oPushResult
5962: oSetResult 0
5964: oAssign
5965: oGetParam 1
5967: oPushResult
5968: oCall 6095
5970: oPop 1
5972: oInputChoice 6087
5974: oTypeSNodeType
5975: oChoice 5988
5977: oJumpForward 5995
5979: oGetParam 1
5981: oPushResult
5982: oCall 5273
5984: oPop 1
5986: oJumpForward 5995
5988: Choice Lookup Table
          30   5979
          31   5977
5993: oError 8
5995: oTypeSPop
5996: oGetLocal 1
5998: oPushResult
5999: oSetResult 0
6001: oPushResult
6002: equal_label
6003: oPop 2
6005: oChoice 6034
6007: oGetAddrLocal 1
6009: oPushResult
6010: oLabelNew
6011: oAssign
6012: oEmit 70
6014: oGetFromParam 1
6016: oPushResult
6017: oEmitLabel
6018: oPop 1
6020: oGetLocal 1
6022: oPushResult
6023: oEmitLabel
6024: oPop 1
6026: oGetParam 1
6028: oPushResult
6029: oGetLocal 1
6031: oAssign
6032: oJumpForward 6037
6034: Choice Lookup Table
           1   6007
6037: oGetAddrLocal 2
6039: oPushResult
6040: oSetResult 0
6042: oAssign
6043: oGetAddrLocal 2
6045: oPushResult
6046: oCall 6095
6048: oPop 1
6050: oTypeSNodeType
6051: oChoice 6064
6053: oJumpForward 6071
6055: oGetAddrLocal 2
6057: oPushResult
6058: oCall 5273
6060: oPop 1
6062: oJumpForward 6071
6064: Choice Lookup Table
          30   6055
          31   6053
6069: oError 8
6071: oEmit 70
6073: oGetLocal 2
6075: oPushResult
6076: oEmitLabel
6077: oPop 1
6079: oGetLocal 1
6081: oPushResult
6082: oEmitLabel
6083: oPop 1
6085: oJumpForward 6092
6087: Choice Lookup Table
          54   5974
6090: oJumpForward 6094
6092: oJumpBack 5972
6094: oReturn
6095: oLocalSpace 1
6097: oInputChoice 6151
6099: oGetAddrLocal 1
6101: oPushResult
6102: oSetResult 0
6104: oAssign
6105: oGetAddrLocal 1
6107: oPushResult
6108: oCall 6095
6110: oPop 1
6112: oTypeSNodeType
6113: oChoice 6142
6115: oGetParam 1
6117: oPushResult
6118: oLabelNew
6119: oAssign
6120: oEmit 66
6122: oGetFromParam 1
6124: oPushResult
6125: oEmitLabel
6126: oPop 1
6128: oEmit 69
6130: oGetLocal 1
6132: oPushResult
6133: oEmitLabel
6134: oPop 1
6136: oJumpForward 6149
6138: oEmit 40
6140: oJumpForward 6149
6142: Choice Lookup Table
          30   6138
          31   6115
6147: oError 8
6149: oJumpForward 6161
6151: Choice Lookup Table
          56   6099
6154: oGetParam 1
6156: oPushResult
6157: oCall 6162
6159: oPop 1
6161: oReturn
6162: oLocalSpace 4
6164: oGetAddrLocal 1
6166: oPushResult
6167: oSetResult 1
6169: oAssign
6170: oGetParam 1
6172: oPushResult
6173: oCall 6384
6175: oPop 1
6177: oInputChoice 6374
6179: oTypeSNodeType
6180: oChoice 6340
6182: oCall 10665
6184: oGetParam 1
6186: oPushResult
6187: oCall 6384
6189: oPop 1
6191: oCall 10685
6193: oEmit 37
6195: oJumpForward 6357
6197: oGetLocal 1
6199: oChoice 6215
6201: oGetAddrLocal 2
6203: oPushResult
6204: oCall 8126
6206: oAssign
6207: oGetAddrLocal 1
6209: oPushResult
6210: oSetResult 0
6212: oAssign
6213: oJumpForward 6218
6215: Choice Lookup Table
           1   6201
6218: oGetParam 1
6220: oPushResult
6221: oCall 6384
6223: oPop 1
6225: oTypeSNodeType
6226: oChoice 6264
6228: oCall 8235
6230: oEmit 17
6232: oGetLocal 2
6234: oPushResult
6235: oEmitInt
6236: oPop 1
6238: oGetGlobal 15
6240: oPushResult
6241: oTypeSPush
6242: oPop 1
6244: oJumpForward 6274
6246: oCall 8289
6248: oEmit 17
6250: oGetLocal 2
6252: oPushResult
6253: oEmitInt
6254: oPop 1
6256: oGetGlobal 15
6258: oPushResult
6259: oTypeSPush
6260: oPop 1
6262: oJumpForward 6274
6264: Choice Lookup Table
          32   6246
          38   6228
          39   6228
6271: oError 14
6273: oTypeSPop
6274: oJumpForward 6357
6276: oGetAddrLocal 3
6278: oPushResult
6279: oTypeSTop
6280: oPushResult
6281: oSetResult 36
6283: oPushResult
6284: oNodeGet
6285: oPop 2
6287: oAssign
6288: oGetAddrLocal 4
6290: oPushResult
6291: oGetLocal 3
6293: oPushResult
6294: oSetResult 17
6296: oPushResult
6297: oNodeGetInt
6298: oPop 2
6300: oAssign
6301: oGetParam 1
6303: oPushResult
6304: oCall 6384
6306: oPop 1
6308: oCall 10665
6310: oGetLocal 4
6312: oPushResult
6313: oSetResult 1
6315: oPushResult
6316: equal
6317: oPop 2
6319: oChoice 6333
6321: oEmit 15
6323: oGetLocal 4
6325: oPushResult
6326: oEmitInt
6327: oPop 1
6329: oEmit 34
6331: oJumpForward 6336
6333: Choice Lookup Table
           0   6321
6336: oEmit 36
6338: oJumpForward 6357
6340: Choice Lookup Table
          34   6276
          33   6276
          32   6197
          38   6197
          39   6197
          29   6182
          28   6182
6355: oError 17
6357: oJumpForward 6381
6359: oCall 10665
6361: oGetParam 1
6363: oPushResult
6364: oCall 6384
6366: oPop 1
6368: oCall 10685
6370: oEmit 38
6372: oJumpForward 6381
6374: Choice Lookup Table
          25   6359
          24   6179
6379: oJumpForward 6383
6381: oJumpBack 6177
6383: oReturn
6384: oLocalSpace 0
6386: oGetParam 1
6388: oPushResult
6389: oCall 6435
6391: oPop 1
6393: oInputChoice 6425
6395: oCall 10665
6397: oGetParam 1
6399: oPushResult
6400: oCall 6435
6402: oPop 1
6404: oCall 10685
6406: oEmit 34
6408: oJumpForward 6432
6410: oCall 10665
6412: oGetParam 1
6414: oPushResult
6415: oCall 6435
6417: oPop 1
6419: oCall 10685
6421: oEmit 35
6423: oJumpForward 6432
6425: Choice Lookup Table
          23   6410
          22   6395
6430: oJumpForward 6434
6432: oJumpBack 6393
6434: oReturn
6435: oLocalSpace 0
6437: oInputChoice 6463
6439: oGetParam 1
6441: oPushResult
6442: oCall 6476
6444: oPop 1
6446: oCall 10685
6448: oJumpForward 6475
6450: oGetParam 1
6452: oPushResult
6453: oCall 6476
6455: oPop 1
6457: oCall 10685
6459: oEmit 39
6461: oJumpForward 6475
6463: Choice Lookup Table
          25   6450
          24   6439
6468: oGetParam 1
6470: oPushResult
6471: oCall 6476
6473: oPop 1
6475: oReturn
6476: oLocalSpace 6
6478: oInputChoice 6717
6480: oEmit 15
6482: TOKEN_VALUE
6483: oPushResult
6484: oEmitInt
6485: oPop 1
6487: oGetGlobal 7
6489: oPushResult
6490: oTypeSPush
6491: oPop 1
6493: oJumpForward 6738
6495: oEmit 15
6497: TOKEN_VALUE
6498: oPushResult
6499: oEmitInt
6500: oPop 1
6502: oGetGlobal 10
6504: oPushResult
6505: oTypeSPush
6506: oPop 1
6508: oJumpForward 6738
6510: oGetParam 1
6512: oPushResult
6513: oCall 5304
6515: oPop 1
6517: oInput 15
6519: oJumpForward 6738
6521: oGetAddrLocal 1
6523: oPushResult
6524: CURRENT_STRLIT
6525: oPushResult
6526: oStringAllocShortStringLit
6527: oPop 1
6529: oAssign
6530: oEmit 16
6532: oGetLocal 1
6534: oPushResult
6535: oEmitInt
6536: oPop 1
6538: oGetGlobal 14
6540: oPushResult
6541: oTypeSPush
6542: oPop 1
6544: oCall 7550
6546: oCall 7496
6548: oJumpForward 6738
6550: oGetAddrLocal 2
6552: oPushResult
6553: oScopeFindRequire
6554: oAssign
6555: oGetAddrLocal 2
6557: oPushResult
6558: oCall 510
6560: oPop 1
6562: oGetLocal 2
6564: oPushResult
6565: oNodeType
6566: oPop 1
6568: oChoice 6641
6570: oGetLocal 2
6572: oPushResult
6573: oCall 8379
6575: oPop 1
6577: oJumpForward 6666
6579: oGetLocal 2
6581: oPushResult
6582: oCall 8999
6584: oPop 1
6586: oJumpForward 6666
6588: oGetAddrLocal 3
6590: oPushResult
6591: oGetLocal 2
6593: oPushResult
6594: oSetResult 21
6596: oPushResult
6597: oNodeGet
6598: oPop 2
6600: oAssign
6601: oGetLocal 3
6603: oPushResult
6604: oTypeSPush
6605: oPop 1
6607: oTypeSNodeType
6608: oChoice 6621
6610: oEmit 15
6612: oGetLocal 2
6614: oPushResult
6615: oCall 11094
6617: oPop 1
6619: oJumpForward 6630
6621: Choice Lookup Table
          30   6610
          40   6610
          28   6610
6628: oError 16
6630: oJumpForward 6666
6632: oGetLocal 2
6634: oPushResult
6635: oCall 6739
6637: oPop 1
6639: oJumpForward 6666
6641: Choice Lookup Table
          24   6632
          23   6632
          21   6632
          20   6632
          17   6588
          16   6588
          14   6579
          13   6570
6658: oError 6
6660: oGetGlobal 7
6662: oPushResult
6663: oTypeSPush
6664: oPop 1
6666: oJumpForward 6738
6668: oInput 0
6670: oGetAddrLocal 4
6672: oPushResult
6673: oScopeFindRequire
6674: oAssign
6675: oGetAddrLocal 4
6677: oPushResult
6678: oCall 510
6680: oPop 1
6682: oGetLocal 4
6684: oPushResult
6685: oSetResult 0
6687: oPushResult
6688: oCall 9688
6690: oPop 2
6692: oGetAddrLocal 5
6694: oPushResult
6695: oTypeSTop
6696: oAssign
6697: oTypeSPop
6698: oGetAddrLocal 6
6700: oPushResult
6701: oGetLocal 5
6703: oPushResult
6704: oCall 10820
6706: oPop 1
6708: oAssign
6709: oGetLocal 6
6711: oPushResult
6712: oTypeSPush
6713: oPop 1
6715: oJumpForward 6738
6717: Choice Lookup Table
          19   6668
           0   6550
           2   6521
          14   6510
           3   6495
           1   6480
6730: oError 6
6732: oGetGlobal 7
6734: oPushResult
6735: oTypeSPush
6736: oPop 1
6738: oReturn
6739: oLocalSpace 2
6741: oGetAddrLocal 1
6743: oPushResult
6744: oGetParam 1
6746: oPushResult
6747: oSetResult 21
6749: oPushResult
6750: oNodeGet
6751: oPop 2
6753: oAssign
6754: oGetAddrLocal 2
6756: oPushResult
6757: oGetParam 1
6759: oPushResult
6760: oCall 10562
6762: oPop 1
6764: oAssign
6765: oGetLocal 1
6767: oPushResult
6768: oTypeSPush
6769: oPop 1
6771: oTypeSNodeType
6772: oChoice 7471
6774: oGetParam 1
6776: oPushResult
6777: oNodeType
6778: oPop 1
6780: oChoice 6926
6782: oEmit 0
6784: oGetParam 1
6786: oPushResult
6787: oCall 11094
6789: oPop 1
6791: oJumpForward 6936
6793: oGetLocal 2
6795: oPushResult
6796: equal_zero
6797: oPop 1
6799: oChoice 6812
6801: oEmit 3
6803: oGetParam 1
6805: oPushResult
6806: oCall 11094
6808: oPop 1
6810: oJumpForward 6830
6812: Choice Lookup Table
           1   6801
6815: oEmit 9
6817: oGetLocal 2
6819: oPushResult
6820: oEmitInt
6821: oPop 1
6823: oGetParam 1
6825: oPushResult
6826: oCall 11094
6828: oPop 1
6830: oJumpForward 6936
6832: oGetParam 1
6834: oPushResult
6835: oSetResult 33
6837: oPushResult
6838: oNodeGetBoolean
6839: oPop 2
6841: oChoice 6884
6843: oGetLocal 2
6845: oPushResult
6846: equal_zero
6847: oPop 1
6849: oChoice 6862
6851: oEmit 8
6853: oGetParam 1
6855: oPushResult
6856: oCall 11094
6858: oPop 1
6860: oJumpForward 6880
6862: Choice Lookup Table
           1   6851
6865: oEmit 14
6867: oGetLocal 2
6869: oPushResult
6870: oEmitInt
6871: oPop 1
6873: oGetParam 1
6875: oPushResult
6876: oCall 11094
6878: oPop 1
6880: oEmit 23
6882: oJumpForward 6924
6884: Choice Lookup Table
           1   6843
6887: oGetLocal 2
6889: oPushResult
6890: equal_zero
6891: oPop 1
6893: oChoice 6906
6895: oEmit 6
6897: oGetParam 1
6899: oPushResult
6900: oCall 11094
6902: oPop 1
6904: oJumpForward 6924
6906: Choice Lookup Table
           1   6895
6909: oEmit 12
6911: oGetLocal 2
6913: oPushResult
6914: oEmitInt
6915: oPop 1
6917: oGetParam 1
6919: oPushResult
6920: oCall 11094
6922: oPop 1
6924: oJumpForward 6936
6926: Choice Lookup Table
          23   6832
          21   6793
          24   6782
          20   6782
6935: oEndChoice
6936: oJumpForward 7495
6938: oGetParam 1
6940: oPushResult
6941: oNodeType
6942: oPop 1
6944: oChoice 7090
6946: oEmit 1
6948: oGetParam 1
6950: oPushResult
6951: oCall 11094
6953: oPop 1
6955: oJumpForward 7100
6957: oGetLocal 2
6959: oPushResult
6960: equal_zero
6961: oPop 1
6963: oChoice 6976
6965: oEmit 4
6967: oGetParam 1
6969: oPushResult
6970: oCall 11094
6972: oPop 1
6974: oJumpForward 6994
6976: Choice Lookup Table
           1   6965
6979: oEmit 10
6981: oGetLocal 2
6983: oPushResult
6984: oEmitInt
6985: oPop 1
6987: oGetParam 1
6989: oPushResult
6990: oCall 11094
6992: oPop 1
6994: oJumpForward 7100
6996: oGetParam 1
6998: oPushResult
6999: oSetResult 33
7001: oPushResult
7002: oNodeGetBoolean
7003: oPop 2
7005: oChoice 7048
7007: oGetLocal 2
7009: oPushResult
7010: equal_zero
7011: oPop 1
7013: oChoice 7026
7015: oEmit 8
7017: oGetParam 1
7019: oPushResult
7020: oCall 11094
7022: oPop 1
7024: oJumpForward 7044
7026: Choice Lookup Table
           1   7015
7029: oEmit 14
7031: oGetLocal 2
7033: oPushResult
7034: oEmitInt
7035: oPop 1
7037: oGetParam 1
7039: oPushResult
7040: oCall 11094
7042: oPop 1
7044: oEmit 24
7046: oJumpForward 7088
7048: Choice Lookup Table
           1   7007
7051: oGetLocal 2
7053: oPushResult
7054: equal_zero
7055: oPop 1
7057: oChoice 7070
7059: oEmit 7
7061: oGetParam 1
7063: oPushResult
7064: oCall 11094
7066: oPop 1
7068: oJumpForward 7088
7070: Choice Lookup Table
           1   7059
7073: oEmit 13
7075: oGetLocal 2
7077: oPushResult
7078: oEmitInt
7079: oPop 1
7081: oGetParam 1
7083: oPushResult
7084: oCall 11094
7086: oPop 1
7088: oJumpForward 7100
7090: Choice Lookup Table
          23   6996
          21   6957
          24   6946
          20   6946
7099: oEndChoice
7100: oJumpForward 7495
7102: oError 16
7104: oJumpForward 7495
7106: oGetParam 1
7108: oPushResult
7109: oNodeType
7110: oPop 1
7112: oChoice 7258
7114: oEmit 2
7116: oGetParam 1
7118: oPushResult
7119: oCall 11094
7121: oPop 1
7123: oJumpForward 7268
7125: oGetLocal 2
7127: oPushResult
7128: equal_zero
7129: oPop 1
7131: oChoice 7144
7133: oEmit 5
7135: oGetParam 1
7137: oPushResult
7138: oCall 11094
7140: oPop 1
7142: oJumpForward 7162
7144: Choice Lookup Table
           1   7133
7147: oEmit 11
7149: oGetLocal 2
7151: oPushResult
7152: oEmitInt
7153: oPop 1
7155: oGetParam 1
7157: oPushResult
7158: oCall 11094
7160: oPop 1
7162: oJumpForward 7268
7164: oGetParam 1
7166: oPushResult
7167: oSetResult 33
7169: oPushResult
7170: oNodeGetBoolean
7171: oPop 2
7173: oChoice 7216
7175: oGetLocal 2
7177: oPushResult
7178: equal_zero
7179: oPop 1
7181: oChoice 7194
7183: oEmit 8
7185: oGetParam 1
7187: oPushResult
7188: oCall 11094
7190: oPop 1
7192: oJumpForward 7212
7194: Choice Lookup Table
           1   7183
7197: oEmit 14
7199: oGetLocal 2
7201: oPushResult
7202: oEmitInt
7203: oPop 1
7205: oGetParam 1
7207: oPushResult
7208: oCall 11094
7210: oPop 1
7212: oEmit 25
7214: oJumpForward 7256
7216: Choice Lookup Table
           1   7175
7219: oGetLocal 2
7221: oPushResult
7222: equal_zero
7223: oPop 1
7225: oChoice 7238
7227: oEmit 8
7229: oGetParam 1
7231: oPushResult
7232: oCall 11094
7234: oPop 1
7236: oJumpForward 7256
7238: Choice Lookup Table
           1   7227
7241: oEmit 14
7243: oGetLocal 2
7245: oPushResult
7246: oEmitInt
7247: oPop 1
7249: oGetParam 1
7251: oPushResult
7252: oCall 11094
7254: oPop 1
7256: oJumpForward 7268
7258: Choice Lookup Table
          23   7164
          21   7125
          24   7114
          20   7114
7267: oEndChoice
7268: oInputChoice 7298
7270: oTypeSPop
7271: oGetLocal 1
7273: oPushResult
7274: oSetResult 36
7276: oPushResult
7277: oNodeGet
7278: oPop 2
7280: oPushResult
7281: oTypeSPush
7282: oPop 1
7284: oCall 7550
7286: oCall 7496
7288: oJumpForward 7303
7290: oCall 7745
7292: oCall 7550
7294: oCall 7496
7296: oJumpForward 7303
7298: Choice Lookup Table
          16   7290
          18   7270
7303: oJumpForward 7495
7305: oGetParam 1
7307: oPushResult
7308: oNodeType
7309: oPop 1
7311: oChoice 7455
7313: oEmit 16
7315: oGetParam 1
7317: oPushResult
7318: oCall 11094
7320: oPop 1
7322: oJumpForward 7465
7324: oGetLocal 2
7326: oPushResult
7327: equal_zero
7328: oPop 1
7330: oChoice 7343
7332: oEmit 17
7334: oGetParam 1
7336: oPushResult
7337: oCall 11094
7339: oPop 1
7341: oJumpForward 7361
7343: Choice Lookup Table
           1   7332
7346: oEmit 20
7348: oGetLocal 2
7350: oPushResult
7351: oEmitInt
7352: oPop 1
7354: oGetParam 1
7356: oPushResult
7357: oCall 11094
7359: oPop 1
7361: oJumpForward 7465
7363: oGetParam 1
7365: oPushResult
7366: oSetResult 33
7368: oPushResult
7369: oNodeGetBoolean
7370: oPop 2
7372: oChoice 7413
7374: oGetLocal 2
7376: oPushResult
7377: equal_zero
7378: oPop 1
7380: oChoice 7393
7382: oEmit 8
7384: oGetParam 1
7386: oPushResult
7387: oCall 11094
7389: oPop 1
7391: oJumpForward 7411
7393: Choice Lookup Table
           1   7382
7396: oEmit 14
7398: oGetLocal 2
7400: oPushResult
7401: oEmitInt
7402: oPop 1
7404: oGetParam 1
7406: oPushResult
7407: oCall 11094
7409: oPop 1
7411: oJumpForward 7453
7413: Choice Lookup Table
           1   7374
7416: oGetLocal 2
7418: oPushResult
7419: equal_zero
7420: oPop 1
7422: oChoice 7435
7424: oEmit 18
7426: oGetParam 1
7428: oPushResult
7429: oCall 11094
7431: oPop 1
7433: oJumpForward 7453
7435: Choice Lookup Table
           1   7424
7438: oEmit 21
7440: oGetLocal 2
7442: oPushResult
7443: oEmitInt
7444: oPop 1
7446: oGetParam 1
7448: oPushResult
7449: oCall 11094
7451: oPop 1
7453: oJumpForward 7465
7455: Choice Lookup Table
          23   7363
          21   7324
          24   7313
          20   7313
7464: oEndChoice
7465: oCall 7550
7467: oCall 7496
7469: oJumpForward 7495
7471: Choice Lookup Table
          39   7305
          37   7305
          35   7305
          34   7106
          33   7106
          27   7102
          32   6938
          29   6938
          30   6938
          40   6774
          28   6774
7494: oEndChoice
7495: oReturn
7496: oLocalSpace 0
7498: oTypeSNodeType
7499: oChoice 7523
7501: oEmit 23
7503: oJumpForward 7549
7505: oEmit 24
7507: oJumpForward 7549
7509: oError 16
7511: oJumpForward 7549
7513: oEmit 25
7515: oJumpForward 7549
7517: oError 29
7519: oJumpForward 7549
7521: oJumpForward 7549
7523: Choice Lookup Table
          39   7521
          38   7521
          37   7521
          35   7521
          34   7517
          33   7513
          27   7509
          32   7505
          29   7505
          30   7505
          40   7501
          28   7501
7548: oEndChoice
7549: oReturn
7550: oLocalSpace 0
7552: oInputChoice 7590
7554: oTypeSNodeType
7555: oChoice 7569
7557: oCall 7602
7559: oJumpForward 7580
7561: oCall 7745
7563: oJumpForward 7580
7565: oCall 7824
7567: oJumpForward 7580
7569: Choice Lookup Table
          39   7565
          38   7565
          33   7561
          35   7557
7578: oError 10
7580: oJumpForward 7599
7582: oCall 7854
7584: oJumpForward 7599
7586: oCall 7952
7588: oJumpForward 7599
7590: Choice Lookup Table
          18   7586
          20   7582
          16   7554
7597: oJumpForward 7601
7599: oJumpBack 7552
7601: oReturn
7602: oLocalSpace 3
7604: oTypeSNodeType
7605: oChoice 7609
7607: oJumpForward 7614
7609: Choice Lookup Table
          35   7607
7612: oError 10
7614: oTypeSNodeType
7615: oChoice 7619
7617: oJumpForward 7624
7619: Choice Lookup Table
          35   7617
7622: oError 13
7624: oGetAddrLocal 1
7626: oPushResult
7627: oTypeSTop
7628: oPushResult
7629: oSetResult 37
7631: oPushResult
7632: oNodeGet
7633: oPop 2
7635: oPushResult
7636: oCall 10904
7638: oPop 1
7640: oAssign
7641: oGetAddrLocal 2
7643: oPushResult
7644: oTypeSTop
7645: oPushResult
7646: oSetResult 36
7648: oPushResult
7649: oNodeGet
7650: oPop 2
7652: oAssign
7653: oTypeSPop
7654: oGetLocal 2
7656: oPushResult
7657: oTypeSPush
7658: oPop 1
7660: oCall 5143
7662: oCall 10638
7664: oGetLocal 1
7666: oPushResult
7667: equal_zero
7668: oPop 1
7670: oChoice 7684
7672: oEmit 15
7674: oGetLocal 1
7676: oPushResult
7677: oEmitInt
7678: oPop 1
7680: oEmit 38
7682: oJumpForward 7687
7684: Choice Lookup Table
           0   7672
7687: oGetAddrLocal 3
7689: oPushResult
7690: oGetLocal 2
7692: oPushResult
7693: oSetResult 17
7695: oPushResult
7696: oNodeGetInt
7697: oPop 2
7699: oAssign
7700: oGetLocal 3
7702: oPushResult
7703: oSetResult 1
7705: oPushResult
7706: equal
7707: oPop 2
7709: oChoice 7723
7711: oEmit 15
7713: oGetLocal 3
7715: oPushResult
7716: oEmitInt
7717: oPop 1
7719: oEmit 34
7721: oJumpForward 7726
7723: Choice Lookup Table
           0   7711
7726: oEmit 36
7728: oInputChoice 7736
7730: oJumpForward 7744
7732: oJumpForward 7742
7734: oJumpForward 7742
7736: Choice Lookup Table
          13   7734
          17   7730
7741: oEndChoice
7742: oJumpBack 7614
7744: oReturn
7745: oLocalSpace 2
7747: oTypeSNodeType
7748: oChoice 7752
7750: oJumpForward 7757
7752: Choice Lookup Table
          33   7750
7755: oError 29
7757: oGetAddrLocal 1
7759: oPushResult
7760: oTypeSTop
7761: oPushResult
7762: oSetResult 36
7764: oPushResult
7765: oNodeGet
7766: oPop 2
7768: oAssign
7769: oTypeSPop
7770: oGetLocal 1
7772: oPushResult
7773: oTypeSPush
7774: oPop 1
7776: oCall 5143
7778: oCall 10638
7780: oGetAddrLocal 2
7782: oPushResult
7783: oGetLocal 1
7785: oPushResult
7786: oSetResult 17
7788: oPushResult
7789: oNodeGetInt
7790: oPop 2
7792: oAssign
7793: oGetLocal 2
7795: oPushResult
7796: oSetResult 1
7798: oPushResult
7799: equal
7800: oPop 2
7802: oChoice 7816
7804: oEmit 15
7806: oGetLocal 2
7808: oPushResult
7809: oEmitInt
7810: oPop 1
7812: oEmit 34
7814: oJumpForward 7819
7816: Choice Lookup Table
           0   7804
7819: oEmit 36
7821: oInput 17
7823: oReturn
7824: oLocalSpace 0
7826: oTypeSNodeType
7827: oChoice 7831
7829: oJumpForward 7838
7831: Choice Lookup Table
          39   7829
          38   7829
7836: oError 29
7838: oTypeSPop
7839: oGetGlobal 10
7841: oPushResult
7842: oTypeSPush
7843: oPop 1
7845: oCall 5143
7847: oCall 10638
7849: oEmit 36
7851: oInput 17
7853: oReturn
7854: oLocalSpace 2
7856: oTypeSNodeType
7857: oChoice 7861
7859: oJumpForward 7866
7861: Choice Lookup Table
          37   7859
7864: oError 11
7866: oTypeSTop
7867: oPushResult
7868: oSetResult 40
7870: oPushResult
7871: oNodeGet
7872: oPop 2
7874: oPushResult
7875: oScopeEnter
7876: oPop 1
7878: oInput 0
7880: oGetAddrLocal 1
7882: oPushResult
7883: oScopeFindRequire
7884: oAssign
7885: oGetLocal 1
7887: oPushResult
7888: oNodeType
7889: oPop 1
7891: oChoice 7895
7893: oJumpForward 7900
7895: Choice Lookup Table
          22   7893
7898: oError 12
7900: oScopeEnd
7901: oGetAddrLocal 2
7903: oPushResult
7904: oGetLocal 1
7906: oPushResult
7907: oSetResult 22
7909: oPushResult
7910: oNodeGetInt
7911: oPop 2
7913: oAssign
7914: oGetLocal 2
7916: oPushResult
7917: equal_zero
7918: oPop 1
7920: oChoice 7934
7922: oEmit 15
7924: oGetLocal 2
7926: oPushResult
7927: oEmitInt
7928: oPop 1
7930: oEmit 36
7932: oJumpForward 7937
7934: Choice Lookup Table
           0   7922
7937: oTypeSPop
7938: oGetLocal 1
7940: oPushResult
7941: oSetResult 21
7943: oPushResult
7944: oNodeGet
7945: oPop 2
7947: oPushResult
7948: oTypeSPush
7949: oPop 1
7951: oReturn
7952: oLocalSpace 1
7954: oTypeSNodeType
7955: oChoice 7963
7957: oJumpForward 7970
7959: oError 29
7961: oJumpForward 7970
7963: Choice Lookup Table
          34   7959
          33   7957
7968: oError 9
7970: oEmit 25
7972: oGetAddrLocal 1
7974: oPushResult
7975: oTypeSTop
7976: oAssign
7977: oTypeSPop
7978: oGetLocal 1
7980: oPushResult
7981: oSetResult 36
7983: oPushResult
7984: oNodeGet
7985: oPop 2
7987: oPushResult
7988: oTypeSPush
7989: oPop 1
7991: oReturn
7992: oLocalSpace 1
7994: oGetAddrLocal 1
7996: oPushResult
7997: oTypeSNodeType
7998: oAssign
7999: oTypeSPop
8000: oGetLocal 1
8002: oPushResult
8003: oTypeSNodeType
8004: oPushResult
8005: equal_node_type
8006: oPop 2
8008: oChoice 8122
8010: oTypeSNodeType
8011: oChoice 8107
8013: oGetLocal 1
8015: oChoice 8022
8017: oEmit 30
8019: oReturn
8020: oJumpForward 8025
8022: Choice Lookup Table
          29   8017
8025: oJumpForward 8118
8027: oGetLocal 1
8029: oChoice 8036
8031: oEmit 31
8033: oReturn
8034: oJumpForward 8039
8036: Choice Lookup Table
          28   8031
8039: oJumpForward 8118
8041: oGetLocal 1
8043: oChoice 8076
8045: oReturn
8046: oJumpForward 8081
8048: oTypeSTop
8049: oPushResult
8050: oGetGlobal 11
8052: oPushResult
8053: equal_node
8054: oPop 2
8056: oChoice 8071
8058: oEmit 15
8060: oSetResult 1
8062: oPushResult
8063: oEmitInt
8064: oPop 1
8066: oEmit 36
8068: oReturn
8069: oJumpForward 8074
8071: Choice Lookup Table
           1   8058
8074: oJumpForward 8081
8076: Choice Lookup Table
          38   8048
          34   8045
8081: oJumpForward 8118
8083: oGetLocal 1
8085: oChoice 8090
8087: oReturn
8088: oJumpForward 8093
8090: Choice Lookup Table
          33   8087
8093: oJumpForward 8118
8095: oGetLocal 1
8097: oChoice 8102
8099: oReturn
8100: oJumpForward 8105
8102: Choice Lookup Table
          38   8099
8105: oJumpForward 8118
8107: Choice Lookup Table
          39   8095
          34   8083
          33   8041
          29   8027
          28   8013
8118: oError 14
8120: oJumpForward 8125
8122: Choice Lookup Table
           0   8010
8125: oReturn
8126: oLocalSpace 1
8128: oGetAddrLocal 1
8130: oPushResult
8131: oGetGlobal 15
8133: oPushResult
8134: oScopeAllocType
8135: oPop 1
8137: oAssign
8138: oTypeSNodeType
8139: oChoice 8207
8141: oEmit 17
8143: oGetLocal 1
8145: oPushResult
8146: oEmitInt
8147: oPop 1
8149: oEmit 22
8151: oEmit 29
8153: oGetGlobal 15
8155: oPushResult
8156: oSetResult 17
8158: oPushResult
8159: oNodeGetInt
8160: oPop 2
8162: oPushResult
8163: oEmitInt
8164: oPop 1
8166: oJumpForward 8216
8168: oEmit 17
8170: oGetLocal 1
8172: oPushResult
8173: oEmitInt
8174: oPop 1
8176: oEmit 15
8178: oSetResult 1
8180: oPushResult
8181: oEmitInt
8182: oPop 1
8184: oEmit 27
8186: oEmit 17
8188: oGetLocal 1
8190: oPushResult
8191: oSetResult 1
8193: oPushResult
8194: add
8195: oPop 2
8197: oPushResult
8198: oEmitInt
8199: oPop 1
8201: oEmit 22
8203: oEmit 27
8205: oJumpForward 8216
8207: Choice Lookup Table
          32   8168
          38   8141
          39   8141
8214: oError 14
8216: oTypeSPop
8217: oEmit 17
8219: oGetLocal 1
8221: oPushResult
8222: oEmitInt
8223: oPop 1
8225: oGetGlobal 15
8227: oPushResult
8228: oTypeSPush
8229: oPop 1
8231: oGetLocal 1
8233: oReturn
8234: oReturn
8235: oLocalSpace 0
8237: oEmit 59
8239: oSetResult 16
8241: oPushResult
8242: oEmitInt
8243: oPop 1
8245: oEmit 19
8247: oSetResult 8
8249: oPushResult
8250: oEmitInt
8251: oPop 1
8253: oEmit 22
8255: oEmit 28
8257: oEmit 19
8259: oSetResult 0
8261: oPushResult
8262: oEmitInt
8263: oPop 1
8265: oEmit 22
8267: oEmit 28
8269: oEmit 62
8271: oGetGlobal 20
8273: oPushResult
8274: oCall 11094
8276: oPop 1
8278: oEmit 61
8280: oSetResult 16
8282: oPushResult
8283: oEmitInt
8284: oPop 1
8286: oTypeSPop
8287: oTypeSPop
8288: oReturn
8289: oLocalSpace 0
8291: oError 16
8293: oTypeSPop
8294: oTypeSPop
8295: oReturn
8296: oLocalSpace 2
8298: oGetAddrLocal 2
8300: oPushResult
8301: oGetParam 1
8303: oPushResult
8304: oSetResult 26
8306: oPushResult
8307: oNodeGetString
8308: oPop 2
8310: oAssign
8311: oGetLocal 2
8313: oPushResult
8314: oSetResult 0
8316: oPushResult
8317: equal_string
8318: oPop 2
8320: oChoice 8357
8322: oGetAddrLocal 1
8324: oPushResult
8325: oGetParam 1
8327: oPushResult
8328: oSetResult 4
8330: oPushResult
8331: oNodeGetInt
8332: oPop 2
8334: oPushResult
8335: ID_STRING
8336: oPop 1
8338: oPushResult
8339: oStringAllocLit
8340: oPop 1
8342: oAssign
8343: oJumpForward 8363
8345: oGetAddrLocal 1
8347: oPushResult
8348: oGetLocal 2
8350: oPushResult
8351: oStringAllocLit
8352: oPop 1
8354: oAssign
8355: oJumpForward 8363
8357: Choice Lookup Table
           0   8345
           1   8322
8362: oEndChoice
8363: oEmit 71
8365: oGetParam 1
8367: oPushResult
8368: oCall 11094
8370: oPop 1
8372: oGetLocal 1
8374: oPushResult
8375: oEmitInt
8376: oPop 1
8378: oReturn
8379: oLocalSpace 10
8381: oGetParam 1
8383: oPushResult
8384: oSetResult 25
8386: oPushResult
8387: oNodeGetBoolean
8388: oPop 2
8390: oChoice 8417
8392: oGetParam 1
8394: oPushResult
8395: oSetResult 28
8397: oPushResult
8398: oNodeGetBoolean
8399: oPop 2
8401: oChoice 8412
8403: oGetParam 1
8405: oPushResult
8406: oCall 8296
8408: oPop 1
8410: oJumpForward 8415
8412: Choice Lookup Table
           0   8403
8415: oJumpForward 8420
8417: Choice Lookup Table
           1   8392
8420: oGetParam 1
8422: oPushResult
8423: oSetResult 28
8425: oPushResult
8426: oSetResult 1
8428: oPushResult
8429: oNodeSetBoolean
8430: oPop 3
8432: oGetAddrLocal 1
8434: oPushResult
8435: oGetParam 1
8437: oPushResult
8438: oSetResult 27
8440: oPushResult
8441: oNodeGetBoolean
8442: oPop 2
8444: oAssign
8445: oGetAddrLocal 4
8447: oPushResult
8448: oGetParam 1
8450: oPushResult
8451: oNodeType
8452: oPop 1
8454: oPushResult
8455: oSetResult 13
8457: oPushResult
8458: equal_node_type
8459: oPop 2
8461: oAssign
8462: oGetLocal 4
8464: oChoice 8491
8466: oGetAddrLocal 2
8468: oPushResult
8469: oGetParam 1
8471: oPushResult
8472: oSetResult 21
8474: oPushResult
8475: oNodeGet
8476: oPop 2
8478: oAssign
8479: oGetAddrLocal 3
8481: oPushResult
8482: oGetLocal 2
8484: oPushResult
8485: oScopeAllocType
8486: oPop 1
8488: oAssign
8489: oJumpForward 8494
8491: Choice Lookup Table
           1   8466
8494: oGetAddrLocal 5
8496: oPushResult
8497: oGetParam 1
8499: oPushResult
8500: oSetResult 23
8502: oPushResult
8503: oNodeGet
8504: oPop 2
8506: oAssign
8507: oGetAddrLocal 6
8509: oPushResult
8510: oGetLocal 5
8512: oPushResult
8513: oSetResult 17
8515: oPushResult
8516: oNodeGetInt
8517: oPop 2
8519: oAssign
8520: oGetLocal 1
8522: oChoice 8544
8524: oEmit 60
8526: oGetLocal 6
8528: oPushResult
8529: oEmitInt
8530: oPop 1
8532: oJumpForward 8550
8534: oEmit 59
8536: oGetLocal 6
8538: oPushResult
8539: oEmitInt
8540: oPop 1
8542: oJumpForward 8550
8544: Choice Lookup Table
           0   8534
           1   8524
8549: oEndChoice
8550: oGetParam 1
8552: oPushResult
8553: oCall 10542
8555: oPop 1
8557: oPushResult
8558: oSetResult 0
8560: oPushResult
8561: greater
8562: oPop 2
8564: oChoice 8597
8566: oEmit 19
8568: oSetResult 0
8570: oPushResult
8571: oEmitInt
8572: oPop 1
8574: oEmit 20
8576: oGetParam 1
8578: oPushResult
8579: oCall 10562
8581: oPop 1
8583: oPushResult
8584: oEmitInt
8585: oPop 1
8587: oSetResult 0
8589: oPushResult
8590: oEmitInt
8591: oPop 1
8593: oEmit 28
8595: oJumpForward 8600
8597: Choice Lookup Table
           1   8566
8600: oGetAddrLocal 7
8602: oPushResult
8603: oGetLocal 5
8605: oPushResult
8606: oSetResult 15
8608: oPushResult
8609: oNodeGetIter
8610: oPop 2
8612: oAssign
8613: oGetAddrLocal 8
8615: oPushResult
8616: oGetLocal 7
8618: oPushResult
8619: oNodeIterValue
8620: oPop 1
8622: oAssign
8623: oInputChoice 8820
8625: oGetLocal 8
8627: oPushResult
8628: oNodeNull
8629: oPop 1
8631: oChoice 8637
8633: oJumpForward 8816
8635: oJumpForward 8640
8637: Choice Lookup Table
           1   8633
8640: oGetAddrLocal 9
8642: oPushResult
8643: oGetLocal 8
8645: oPushResult
8646: oSetResult 22
8648: oPushResult
8649: oNodeGetInt
8650: oPop 2
8652: oAssign
8653: oEmit 19
8655: oGetLocal 9
8657: oPushResult
8658: oEmitInt
8659: oPop 1
8661: oGetLocal 8
8663: oPushResult
8664: oSetResult 21
8666: oPushResult
8667: oNodeGet
8668: oPop 2
8670: oPushResult
8671: oTypeSPush
8672: oPop 1
8674: oGetLocal 8
8676: oPushResult
8677: oSetResult 33
8679: oPushResult
8680: oNodeGetBoolean
8681: oPop 2
8683: oChoice 8769
8685: oSetResult 1
8687: oPushResult
8688: oCall 9640
8690: oPop 1
8692: oCall 10580
8694: oEmit 28
8696: oJumpForward 8775
8698: oCall 5143
8700: oCall 7992
8702: oTypeSNodeType
8703: oChoice 8743
8705: oEmit 26
8707: oJumpForward 8767
8709: oEmit 27
8711: oJumpForward 8767
8713: oError 16
8715: oJumpForward 8767
8717: oEmit 28
8719: oJumpForward 8767
8721: oGetAddrLocal 10
8723: oPushResult
8724: oTypeSTop
8725: oPushResult
8726: oSetResult 17
8728: oPushResult
8729: oNodeGetInt
8730: oPop 2
8732: oAssign
8733: oEmit 29
8735: oGetLocal 10
8737: oPushResult
8738: oEmitInt
8739: oPop 1
8741: oJumpForward 8767
8743: Choice Lookup Table
          39   8721
          37   8721
          35   8721
          34   8717
          33   8717
          27   8713
          32   8709
          29   8709
          30   8709
          40   8705
          28   8705
8766: oEndChoice
8767: oJumpForward 8775
8769: Choice Lookup Table
           0   8698
           1   8685
8774: oEndChoice
8775: oTypeSPop
8776: oGetAddrLocal 7
8778: oPushResult
8779: oNodeIterNext
8780: oPop 1
8782: oGetAddrLocal 8
8784: oPushResult
8785: oGetLocal 7
8787: oPushResult
8788: oNodeIterValue
8789: oPop 1
8791: oAssign
8792: oGetLocal 8
8794: oPushResult
8795: oNodeNull
8796: oPop 1
8798: oChoice 8806
8800: oJumpForward 8816
8802: oJumpForward 8812
8804: oJumpForward 8812
8806: Choice Lookup Table
           0   8804
           1   8800
8811: oEndChoice
8812: oInput 13
8814: oJumpBack 8625
8816: oInput 15
8818: oJumpForward 8823
8820: Choice Lookup Table
          14   8625
8823: oGetLocal 8
8825: oPushResult
8826: oNodeNull
8827: oPop 1
8829: oChoice 8835
8831: oError 15
8833: oJumpForward 8838
8835: Choice Lookup Table
           0   8831
8838: oGetLocal 4
8840: oChoice 8869
8842: oEmit 19
8844: oGetParam 1
8846: oPushResult
8847: oSetResult 31
8849: oPushResult
8850: oNodeGetInt
8851: oPop 2
8853: oPushResult
8854: oEmitInt
8855: oPop 1
8857: oEmit 17
8859: oGetLocal 3
8861: oPushResult
8862: oEmitInt
8863: oPop 1
8865: oEmit 28
8867: oJumpForward 8872
8869: Choice Lookup Table
           1   8842
8872: oGetLocal 1
8874: oChoice 8898
8876: oEmit 63
8878: oGetParam 1
8880: oPushResult
8881: oCall 11094
8883: oPop 1
8885: oJumpForward 8904
8887: oEmit 62
8889: oGetParam 1
8891: oPushResult
8892: oCall 11094
8894: oPop 1
8896: oJumpForward 8904
8898: Choice Lookup Table
           0   8887
           1   8876
8903: oEndChoice
8904: oGetLocal 4
8906: oChoice 8987
8908: oGetLocal 2
8910: oPushResult
8911: oTypeSPush
8912: oPop 1
8914: oTypeSNodeType
8915: oChoice 8961
8917: oEmit 3
8919: oGetLocal 3
8921: oPushResult
8922: oEmitInt
8923: oPop 1
8925: oJumpForward 8985
8927: oEmit 4
8929: oGetLocal 3
8931: oPushResult
8932: oEmitInt
8933: oPop 1
8935: oJumpForward 8985
8937: oError 16
8939: oJumpForward 8985
8941: oEmit 5
8943: oGetLocal 3
8945: oPushResult
8946: oEmitInt
8947: oPop 1
8949: oJumpForward 8985
8951: oEmit 17
8953: oGetLocal 3
8955: oPushResult
8956: oEmitInt
8957: oPop 1
8959: oJumpForward 8985
8961: Choice Lookup Table
          39   8951
          37   8951
          35   8951
          34   8941
          33   8941
          27   8937
          32   8927
          29   8927
          30   8927
          40   8917
          28   8917
8984: oEndChoice
8985: oJumpForward 8990
8987: Choice Lookup Table
           1   8908
8990: oEmit 61
8992: oGetLocal 6
8994: oPushResult
8995: oEmitInt
8996: oPop 1
8998: oReturn
8999: oLocalSpace 0
9001: oGetParam 1
9003: oPushResult
9004: oGetGlobal 16
9006: oPushResult
9007: oNodeEqual
9008: oPop 2
9010: oChoice 9050
9012: oInput 14
9014: oCall 5143
9016: oTypeSNodeType
9017: oChoice 9025
9019: oJumpForward 9038
9021: oEmit 30
9023: oJumpForward 9038
9025: Choice Lookup Table
          32   9021
          29   9021
          30   9021
          40   9019
          28   9019
9036: oError 14
9038: oTypeSPop
9039: oGetGlobal 7
9041: oPushResult
9042: oTypeSPush
9043: oPop 1
9045: oInput 15
9047: oReturn
9048: oJumpForward 9053
9050: Choice Lookup Table
           1   9012
9053: oGetParam 1
9055: oPushResult
9056: oGetGlobal 17
9058: oPushResult
9059: oNodeEqual
9060: oPop 2
9062: oChoice 9096
9064: oInput 14
9066: oCall 5143
9068: oTypeSNodeType
9069: oChoice 9077
9071: oEmit 31
9073: oJumpForward 9084
9075: oJumpForward 9084
9077: Choice Lookup Table
          29   9075
          28   9071
9082: oError 14
9084: oTypeSPop
9085: oGetGlobal 10
9087: oPushResult
9088: oTypeSPush
9089: oPop 1
9091: oInput 15
9093: oReturn
9094: oJumpForward 9099
9096: Choice Lookup Table
           1   9064
9099: oGetParam 1
9101: oPushResult
9102: oGetGlobal 18
9104: oPushResult
9105: oNodeEqual
9106: oPop 2
9108: oChoice 9148
9110: oInput 14
9112: oCall 5143
9114: oTypeSNodeType
9115: oChoice 9136
9117: oTypeSTop
9118: oPushResult
9119: oSetResult 43
9121: oPushResult
9122: oNodeGetBoolean
9123: oPop 2
9125: oChoice 9131
9127: oError 28
9129: oJumpForward 9134
9131: Choice Lookup Table
           1   9127
9134: oJumpForward 9141
9136: Choice Lookup Table
          40   9117
9139: oError 14
9141: oEmit 33
9143: oInput 15
9145: oReturn
9146: oJumpForward 9151
9148: Choice Lookup Table
           1   9110
9151: oGetParam 1
9153: oPushResult
9154: oGetGlobal 19
9156: oPushResult
9157: oNodeEqual
9158: oPop 2
9160: oChoice 9200
9162: oInput 14
9164: oCall 5143
9166: oTypeSNodeType
9167: oChoice 9188
9169: oTypeSTop
9170: oPushResult
9171: oSetResult 43
9173: oPushResult
9174: oNodeGetBoolean
9175: oPop 2
9177: oChoice 9183
9179: oError 28
9181: oJumpForward 9186
9183: Choice Lookup Table
           1   9179
9186: oJumpForward 9193
9188: Choice Lookup Table
          40   9169
9191: oError 14
9193: oEmit 32
9195: oInput 15
9197: oReturn
9198: oJumpForward 9203
9200: Choice Lookup Table
           1   9162
9203: oError 16
9205: oReturn
9206: oLocalSpace 0
9208: oInputChoice 9267
9210: oCall 10393
9212: oJumpForward 9296
9214: oCall 10400
9216: oJumpForward 9296
9218: oCall 10524
9220: oJumpForward 9296
9222: oCall 10527
9224: oJumpForward 9296
9226: oCall 9878
9228: oJumpForward 9296
9230: oCall 10201
9232: oJumpForward 9296
9234: oCall 9944
9236: oJumpForward 9296
9238: oCall 10121
9240: oJumpForward 9296
9242: oCall 10286
9244: oJumpForward 9296
9246: oCall 10254
9248: oJumpForward 9296
9250: oCall 10370
9252: oJumpForward 9296
9254: oCall 9297
9256: oJumpForward 9296
9258: oCall 10318
9260: oJumpForward 9296
9262: oChangeIntLitToLabelIdent
9263: oCall 9297
9265: oJumpForward 9296
9267: Choice Lookup Table
           1   9262
          53   9258
           0   9254
          35   9250
          51   9246
          52   9242
          49   9238
          44   9234
          48   9230
          41   9226
          66   9222
          65   9218
          64   9214
          63   9210
9296: oReturn
9297: oLocalSpace 1
9299: oGetAddrLocal 1
9301: oPushResult
9302: oScopeFindRequire
9303: oAssign
9304: oGetAddrLocal 1
9306: oPushResult
9307: oCall 510
9309: oPop 1
9311: oGetLocal 1
9313: oPushResult
9314: oNodeType
9315: oPop 1
9317: oChoice 9357
9319: oGetLocal 1
9321: oPushResult
9322: oCall 9373
9324: oPop 1
9326: oCall 9206
9328: oJumpForward 9372
9330: oGetLocal 1
9332: oPushResult
9333: oCall 8379
9335: oPop 1
9337: oJumpForward 9372
9339: oGetLocal 1
9341: oPushResult
9342: oCall 9423
9344: oPop 1
9346: oJumpForward 9372
9348: oGetLocal 1
9350: oPushResult
9351: oCall 9513
9353: oPop 1
9355: oJumpForward 9372
9357: Choice Lookup Table
          13   9348
          23   9339
          21   9339
          20   9339
          12   9330
          25   9319
9370: oError 0
9372: oReturn
9373: oLocalSpace 0
9375: oGetParam 1
9377: oPushResult
9378: oSetResult 34
9380: oPushResult
9381: oNodeGetBoolean
9382: oPop 2
9384: oChoice 9390
9386: oError 21
9388: oJumpForward 9393
9390: Choice Lookup Table
           1   9386
9393: oEmit 69
9395: oGetParam 1
9397: oPushResult
9398: oSetResult 22
9400: oPushResult
9401: oNodeGetLabel
9402: oPop 2
9404: oPushResult
9405: oEmitLabel
9406: oPop 1
9408: oGetParam 1
9410: oPushResult
9411: oSetResult 34
9413: oPushResult
9414: oSetResult 1
9416: oPushResult
9417: oNodeSetBoolean
9418: oPop 3
9420: oInput 12
9422: oReturn
9423: oLocalSpace 0
9425: oGetParam 1
9427: oPushResult
9428: oSetResult 1
9430: oPushResult
9431: oCall 9688
9433: oPop 2
9435: oInput 4
9437: oCall 5143
9439: oCall 7992
9441: oCall 9444
9443: oReturn
9444: oLocalSpace 1
9446: oTypeSNodeType
9447: oChoice 9487
9449: oEmit 26
9451: oJumpForward 9511
9453: oEmit 27
9455: oJumpForward 9511
9457: oError 16
9459: oJumpForward 9511
9461: oEmit 28
9463: oJumpForward 9511
9465: oGetAddrLocal 1
9467: oPushResult
9468: oTypeSTop
9469: oPushResult
9470: oSetResult 17
9472: oPushResult
9473: oNodeGetInt
9474: oPop 2
9476: oAssign
9477: oEmit 29
9479: oGetLocal 1
9481: oPushResult
9482: oEmitInt
9483: oPop 1
9485: oJumpForward 9511
9487: Choice Lookup Table
          39   9465
          37   9465
          35   9465
          34   9461
          33   9461
          27   9457
          32   9453
          29   9453
          30   9453
          40   9449
          28   9449
9510: oEndChoice
9511: oTypeSPop
9512: oReturn
9513: oLocalSpace 1
9515: oGetParam 1
9517: oPushResult
9518: oSetResult 6
9520: oPushResult
9521: oNodeGet
9522: oPop 2
9524: oPushResult
9525: oScopeCurrent
9526: oPushResult
9527: oNodeEqual
9528: oPop 2
9530: oChoice 9536
9532: oError 20
9534: oJumpForward 9539
9536: Choice Lookup Table
           0   9532
9539: oEmit 8
9541: oGetParam 1
9543: oPushResult
9544: oSetResult 31
9546: oPushResult
9547: oNodeGetInt
9548: oPop 2
9550: oPushResult
9551: oEmitInt
9552: oPop 1
9554: oGetParam 1
9556: oPushResult
9557: oSetResult 21
9559: oPushResult
9560: oNodeGet
9561: oPop 2
9563: oPushResult
9564: oTypeSPush
9565: oPop 1
9567: oInput 4
9569: oCall 5143
9571: oCall 7992
9573: oTypeSNodeType
9574: oChoice 9614
9576: oEmit 26
9578: oJumpForward 9638
9580: oEmit 27
9582: oJumpForward 9638
9584: oError 16
9586: oJumpForward 9638
9588: oEmit 28
9590: oJumpForward 9638
9592: oGetAddrLocal 1
9594: oPushResult
9595: oTypeSTop
9596: oPushResult
9597: oSetResult 17
9599: oPushResult
9600: oNodeGetInt
9601: oPop 2
9603: oAssign
9604: oEmit 29
9606: oGetLocal 1
9608: oPushResult
9609: oEmitInt
9610: oPop 1
9612: oJumpForward 9638
9614: Choice Lookup Table
          39   9592
          37   9592
          35   9592
          34   9588
          33   9588
          27   9584
          32   9580
          29   9580
          30   9580
          40   9576
          28   9576
9637: oEndChoice
9638: oTypeSPop
9639: oReturn
9640: oLocalSpace 1
9642: oInput 0
9644: oGetAddrLocal 1
9646: oPushResult
9647: oScopeFindRequire
9648: oAssign
9649: oGetAddrLocal 1
9651: oPushResult
9652: oCall 510
9654: oPop 1
9656: oGetLocal 1
9658: oPushResult
9659: oNodeType
9660: oPop 1
9662: oChoice 9666
9664: oJumpForward 9677
9666: Choice Lookup Table
          24   9664
          23   9664
          21   9664
          20   9664
9675: oError 4
9677: oGetLocal 1
9679: oPushResult
9680: oGetParam 1
9682: oPushResult
9683: oCall 9688
9685: oPop 2
9687: oReturn
9688: oLocalSpace 0
9690: oGetParam 2
9692: oPushResult
9693: oNodeType
9694: oPop 1
9696: oChoice 9778
9698: oEmit 16
9700: oGetParam 2
9702: oPushResult
9703: oCall 11094
9705: oPop 1
9707: oJumpForward 9789
9709: oEmit 17
9711: oGetParam 2
9713: oPushResult
9714: oCall 11094
9716: oPop 1
9718: oJumpForward 9789
9720: oGetParam 2
9722: oPushResult
9723: oSetResult 33
9725: oPushResult
9726: oNodeGetBoolean
9727: oPop 2
9729: oChoice 9742
9731: oEmit 8
9733: oGetParam 2
9735: oPushResult
9736: oCall 11094
9738: oPop 1
9740: oJumpForward 9754
9742: Choice Lookup Table
           1   9731
9745: oEmit 18
9747: oGetParam 2
9749: oPushResult
9750: oCall 11094
9752: oPop 1
9754: oJumpForward 9789
9756: oGetParam 1
9758: oChoice 9771
9760: oEmit 16
9762: oGetParam 2
9764: oPushResult
9765: oCall 11094
9767: oPop 1
9769: oJumpForward 9776
9771: Choice Lookup Table
           0   9760
9774: oError 4
9776: oJumpForward 9789
9778: Choice Lookup Table
          24   9756
          23   9720
          21   9709
          20   9698
9787: oError 4
9789: oGetParam 2
9791: oPushResult
9792: oSetResult 21
9794: oPushResult
9795: oNodeGet
9796: oPop 2
9798: oPushResult
9799: oTypeSPush
9800: oPop 1
9802: oTypeSNodeType
9803: oChoice 9818
9805: oInputChoice 9813
9807: oEmit 25
9809: oCall 7745
9811: oJumpForward 9816
9813: Choice Lookup Table
          16   9807
9816: oJumpForward 9821
9818: Choice Lookup Table
          33   9805
9821: oCall 7550
9823: oReturn
9824: oLocalSpace 0
9826: oGetParam 1
9828: oPushResult
9829: oSetResult 1
9831: oPushResult
9832: oCall 9688
9834: oPop 2
9836: oCall 10638
9838: oGetParam 1
9840: oPushResult
9841: oCall 6739
9843: oPop 1
9845: oTypeSPop
9846: oEmit 32
9848: oEmit 26
9850: oReturn
9851: oLocalSpace 0
9853: oGetParam 1
9855: oPushResult
9856: oSetResult 1
9858: oPushResult
9859: oCall 9688
9861: oPop 2
9863: oCall 10638
9865: oGetParam 1
9867: oPushResult
9868: oCall 6739
9870: oPop 1
9872: oTypeSPop
9873: oEmit 33
9875: oEmit 26
9877: oReturn
9878: oLocalSpace 2
9880: oGetAddrLocal 1
9882: oPushResult
9883: oSetResult 0
9885: oAssign
9886: oGetAddrLocal 1
9888: oPushResult
9889: oCall 5166
9891: oPop 1
9893: oInput 42
9895: oCall 9206
9897: oInputChoice 9932
9899: oGetAddrLocal 2
9901: oPushResult
9902: oLabelNew
9903: oAssign
9904: oEmit 66
9906: oGetLocal 2
9908: oPushResult
9909: oEmitLabel
9910: oPop 1
9912: oEmit 69
9914: oGetLocal 1
9916: oPushResult
9917: oEmitLabel
9918: oPop 1
9920: oCall 9206
9922: oEmit 69
9924: oGetLocal 2
9926: oPushResult
9927: oEmitLabel
9928: oPop 1
9930: oJumpForward 9943
9932: Choice Lookup Table
          43   9899
9935: oEmit 69
9937: oGetLocal 1
9939: oPushResult
9940: oEmitLabel
9941: oPop 1
9943: oReturn
9944: oLocalSpace 4
9946: oInput 0
9948: oGetAddrLocal 1
9950: oPushResult
9951: oScopeFindRequire
9952: oAssign
9953: oGetLocal 1
9955: oPushResult
9956: oSetResult 1
9958: oPushResult
9959: oCall 9688
9961: oPop 2
9963: oCall 10638
9965: oInput 4
9967: oCall 5143
9969: oCall 10638
9971: oEmit 26
9973: oGetAddrLocal 2
9975: oPushResult
9976: oLabelNew
9977: oAssign
9978: oGetAddrLocal 3
9980: oPushResult
9981: oLabelNew
9982: oAssign
9983: oEmit 66
9985: oGetLocal 3
9987: oPushResult
9988: oEmitLabel
9989: oPop 1
9991: oGetAddrLocal 4
9993: oPushResult
9994: oLabelNew
9995: oAssign
9996: oEmit 69
9998: oGetLocal 4
10000: oPushResult
10001: oEmitLabel
10002: oPop 1
10004: oInputChoice 10084
10006: oGetLocal 1
10008: oPushResult
10009: oCall 9824
10011: oPop 1
10013: oEmit 69
10015: oGetLocal 3
10017: oPushResult
10018: oEmitLabel
10019: oPop 1
10021: oGetLocal 1
10023: oPushResult
10024: oCall 6739
10026: oPop 1
10028: oTypeSPop
10029: oCall 5143
10031: oCall 10638
10033: oEmit 49
10035: oEmit 67
10037: oGetLocal 2
10039: oPushResult
10040: oEmitLabel
10041: oPop 1
10043: oJumpForward 10090
10045: oGetLocal 1
10047: oPushResult
10048: oCall 9851
10050: oPop 1
10052: oEmit 69
10054: oGetLocal 3
10056: oPushResult
10057: oEmitLabel
10058: oPop 1
10060: oGetLocal 1
10062: oPushResult
10063: oCall 6739
10065: oPop 1
10067: oTypeSPop
10068: oCall 5143
10070: oCall 10638
10072: oEmit 50
10074: oEmit 67
10076: oGetLocal 2
10078: oPushResult
10079: oEmitLabel
10080: oPop 1
10082: oJumpForward 10090
10084: Choice Lookup Table
          46   10045
          45   10006
10089: oEndChoice
10090: oGetLocal 4
10092: oPushResult
10093: oGetLocal 2
10095: oPushResult
10096: oLoopPush
10097: oPop 2
10099: oInput 47
10101: oCall 9206
10103: oEmit 66
10105: oGetLocal 4
10107: oPushResult
10108: oEmitLabel
10109: oPop 1
10111: oEmit 69
10113: oGetLocal 2
10115: oPushResult
10116: oEmitLabel
10117: oPop 1
10119: oLoopPop
10120: oReturn
10121: oLocalSpace 3
10123: oGetAddrLocal 1
10125: oPushResult
10126: oLabelNew
10127: oAssign
10128: oEmit 69
10130: oGetLocal 1
10132: oPushResult
10133: oEmitLabel
10134: oPop 1
10136: oGetAddrLocal 2
10138: oPushResult
10139: oLabelNew
10140: oAssign
10141: oGetLocal 1
10143: oPushResult
10144: oGetLocal 2
10146: oPushResult
10147: oLoopPush
10148: oPop 2
10150: oCall 9206
10152: oInputChoice 10183
10154: oCall 9206
10156: oJumpForward 10189
10158: oGetAddrLocal 3
10160: oPushResult
10161: oCall 5166
10163: oPop 1
10165: oEmit 70
10167: oGetLocal 3
10169: oPushResult
10170: oEmitLabel
10171: oPop 1
10173: oGetLocal 1
10175: oPushResult
10176: oEmitLabel
10177: oPop 1
10179: oJumpForward 10191
10181: oJumpForward 10189
10183: Choice Lookup Table
          50   10158
           5   10154
10188: oEndChoice
10189: oJumpBack 10152
10191: oEmit 69
10193: oGetLocal 2
10195: oPushResult
10196: oEmitLabel
10197: oPop 1
10199: oLoopPop
10200: oReturn
10201: oLocalSpace 2
10203: oGetAddrLocal 1
10205: oPushResult
10206: oLabelNew
10207: oAssign
10208: oEmit 69
10210: oGetLocal 1
10212: oPushResult
10213: oEmitLabel
10214: oPop 1
10216: oGetAddrLocal 2
10218: oPushResult
10219: oCall 5166
10221: oPop 1
10223: oGetLocal 1
10225: oPushResult
10226: oGetLocal 2
10228: oPushResult
10229: oLoopPush
10230: oPop 2
10232: oInput 47
10234: oCall 9206
10236: oEmit 66
10238: oGetLocal 1
10240: oPushResult
10241: oEmitLabel
10242: oPop 1
10244: oEmit 69
10246: oGetLocal 2
10248: oPushResult
10249: oEmitLabel
10250: oPop 1
10252: oLoopPop
10253: oReturn
10254: oLocalSpace 0
10256: oLoopContinueLabel
10257: oPushResult
10258: oSetResult 0
10260: oPushResult
10261: equal_label
10262: oPop 2
10264: oChoice 10279
10266: oError 18
10268: oJumpForward 10285
10270: oEmit 66
10272: oLoopContinueLabel
10273: oPushResult
10274: oEmitLabel
10275: oPop 1
10277: oJumpForward 10285
10279: Choice Lookup Table
           0   10270
           1   10266
10284: oEndChoice
10285: oReturn
10286: oLocalSpace 0
10288: oLoopBreakLabel
10289: oPushResult
10290: oSetResult 0
10292: oPushResult
10293: equal_label
10294: oPop 2
10296: oChoice 10311
10298: oError 18
10300: oJumpForward 10317
10302: oEmit 66
10304: oLoopBreakLabel
10305: oPushResult
10306: oEmitLabel
10307: oPop 1
10309: oJumpForward 10317
10311: Choice Lookup Table
           0   10302
           1   10298
10316: oEndChoice
10317: oReturn
10318: oLocalSpace 1
10320: oInputChoice 10327
10322: oJumpForward 10333
10324: oChangeIntLitToLabelIdent
10325: oJumpForward 10333
10327: Choice Lookup Table
           1   10324
           0   10322
10332: oEndChoice
10333: oGetAddrLocal 1
10335: oPushResult
10336: oScopeCurrent
10337: oPushResult
10338: oScopeFindRequireInScope
10339: oPop 1
10341: oAssign
10342: oGetLocal 1
10344: oPushResult
10345: oSetResult 28
10347: oPushResult
10348: oSetResult 1
10350: oPushResult
10351: oNodeSetBoolean
10352: oPop 3
10354: oEmit 66
10356: oGetLocal 1
10358: oPushResult
10359: oSetResult 22
10361: oPushResult
10362: oNodeGetLabel
10363: oPop 2
10365: oPushResult
10366: oEmitLabel
10367: oPop 1
10369: oReturn
10370: oLocalSpace 0
10372: oCall 9206
10374: oInputChoice 10384
10376: oCall 9206
10378: oJumpForward 10390
10380: oJumpForward 10392
10382: oJumpForward 10390
10384: Choice Lookup Table
          36   10380
           5   10376
10389: oEndChoice
10390: oJumpBack 10374
10392: oReturn
10393: oLocalSpace 0
10395: oCall 10400
10397: oEmit 79
10399: oReturn
10400: oLocalSpace 0
10402: oInputChoice 10520
10404: oCall 5143
10406: oTypeSNodeType
10407: oChoice 10478
10409: oEmit 72
10411: oJumpForward 10501
10413: oEmit 73
10415: oJumpForward 10501
10417: oEmit 30
10419: oEmit 72
10421: oJumpForward 10501
10423: oEmit 74
10425: oJumpForward 10501
10427: oEmit 75
10429: oJumpForward 10501
10431: oError 16
10433: oJumpForward 10501
10435: oEmit 16
10437: oTypeSTop
10438: oPushResult
10439: oSetResult 42
10441: oPushResult
10442: oNodeGetInt
10443: oPop 2
10445: oPushResult
10446: oEmitInt
10447: oPop 1
10449: oEmit 78
10451: oJumpForward 10501
10453: oTypeSTop
10454: oPushResult
10455: oGetGlobal 11
10457: oPushResult
10458: equal_node
10459: oPop 2
10461: oChoice 10467
10463: oEmit 76
10465: oJumpForward 10472
10467: Choice Lookup Table
           1   10463
10470: oEmit 77
10472: oJumpForward 10501
10474: oEmit 77
10476: oJumpForward 10501
10478: Choice Lookup Table
          34   10474
          33   10453
          40   10435
          27   10431
          38   10427
          39   10427
          32   10423
          29   10417
          30   10413
          28   10409
10499: oError 17
10501: oTypeSPop
10502: oInputChoice 10510
10504: oJumpForward 10518
10506: oJumpForward 10516
10508: oJumpForward 10516
10510: Choice Lookup Table
          13   10508
          15   10504
10515: oEndChoice
10516: oJumpBack 10404
10518: oJumpForward 10523
10520: Choice Lookup Table
          14   10404
10523: oReturn
10524: oLocalSpace 0
10526: oReturn
10527: oLocalSpace 0
10529: oReturn
10530: oLocalSpace 0
10532: oScopeCurrent
10533: oPushResult
10534: oSetResult 14
10536: oPushResult
10537: oNodeGetInt
10538: oPop 2
10540: oReturn
10541: oReturn
10542: oLocalSpace 0
10544: oGetParam 1
10546: oPushResult
10547: oSetResult 20
10549: oPushResult
10550: oNodeGet
10551: oPop 2
10553: oPushResult
10554: oSetResult 14
10556: oPushResult
10557: oNodeGetInt
10558: oPop 2
10560: oReturn
10561: oReturn
10562: oLocalSpace 0
10564: oCall 10530
10566: oPushResult
10567: oGetParam 1
10569: oPushResult
10570: oCall 10542
10572: oPop 1
10574: oPushResult
10575: subtract
10576: oPop 2
10578: oReturn
10579: oReturn
10580: oLocalSpace 1
10582: oGetAddrLocal 1
10584: oPushResult
10585: oTypeSNodeType
10586: oAssign
10587: oTypeSPop
10588: oGetLocal 1
10590: oPushResult
10591: oTypeSNodeType
10592: oPushResult
10593: equal_node_type
10594: oPop 2
10596: oChoice 10634
10598: oTypeSNodeType
10599: oChoice 10625
10601: oGetLocal 1
10603: oChoice 10608
10605: oReturn
10606: oJumpForward 10611
10608: Choice Lookup Table
          34   10605
10611: oJumpForward 10630
10613: oGetLocal 1
10615: oChoice 10620
10617: oReturn
10618: oJumpForward 10623
10620: Choice Lookup Table
          33   10617
10623: oJumpForward 10630
10625: Choice Lookup Table
          34   10613
          33   10601
10630: oError 14
10632: oJumpForward 10637
10634: Choice Lookup Table
           0   10598
10637: oReturn
10638: oLocalSpace 0
10640: oTypeSNodeType
10641: oChoice 10645
10643: oJumpForward 10650
10645: Choice Lookup Table
          28   10643
10648: oError 7
10650: oTypeSPop
10651: oReturn
10652: oLocalSpace 0
10654: oTypeSNodeType
10655: oChoice 10659
10657: oJumpForward 10664
10659: Choice Lookup Table
          28   10657
10662: oError 7
10664: oReturn
10665: oLocalSpace 0
10667: oTypeSNodeType
10668: oChoice 10676
10670: oJumpForward 10683
10672: oEmit 30
10674: oJumpForward 10683
10676: Choice Lookup Table
          29   10672
          28   10670
10681: oError 7
10683: oTypeSPop
10684: oReturn
10685: oLocalSpace 0
10687: oTypeSNodeType
10688: oChoice 10703
10690: oJumpForward 10710
10692: oEmit 30
10694: oTypeSPop
10695: oGetGlobal 7
10697: oPushResult
10698: oTypeSPush
10699: oPop 1
10701: oJumpForward 10710
10703: Choice Lookup Table
          29   10692
          28   10690
10708: oError 7
10710: oReturn
10711: oLocalSpace 0
10713: oTypeSNodeType
10714: oChoice 10727
10716: oEmit 30
10718: oTypeSPop
10719: oGetGlobal 7
10721: oPushResult
10722: oTypeSPush
10723: oPop 1
10725: oJumpForward 10730
10727: Choice Lookup Table
          29   10716
10730: oReturn
10731: oLocalSpace 0
10733: oTypeSNodeType
10734: oChoice 10738
10736: oJumpForward 10743
10738: Choice Lookup Table
          30   10736
10741: oError 8
10743: oTypeSPop
10744: oReturn
10745: oLocalSpace 0
10747: oTypeSNodeType
10748: oChoice 10752
10750: oJumpForward 10757
10752: Choice Lookup Table
          30   10750
10755: oError 8
10757: oReturn
10758: oLocalSpace 1
10760: oGetAddrLocal 1
10762: oPushResult
10763: oGetParam 2
10765: oPushResult
10766: oNodeNew
10767: oPop 1
10769: oAssign
10770: oGetLocal 1
10772: oPushResult
10773: oSetResult 17
10775: oPushResult
10776: oGetParam 1
10778: oPushResult
10779: oNodeSetInt
10780: oPop 3
10782: oGetLocal 1
10784: oPushResult
10785: oTypeAdd
10786: oPop 1
10788: oGetLocal 1
10790: oReturn
10791: oReturn
10792: oLocalSpace 1
10794: oGetAddrLocal 1
10796: oPushResult
10797: oGetParam 2
10799: oPushResult
10800: oNodeNew
10801: oPop 1
10803: oAssign
10804: oGetLocal 1
10806: oPushResult
10807: oSetResult 4
10809: oPushResult
10810: oGetParam 1
10812: oPushResult
10813: oNodeSetInt
10814: oPop 3
10816: oGetLocal 1
10818: oReturn
10819: oReturn
10820: oLocalSpace 1
10822: oGetAddrLocal 1
10824: oPushResult
10825: oGetParam 1
10827: oPushResult
10828: oSetResult 35
10830: oPushResult
10831: oNodeGet
10832: oPop 2
10834: oAssign
10835: oGetLocal 1
10837: oPushResult
10838: oNodeNull
10839: oPop 1
10841: oChoice 10897
10843: oGetAddrLocal 1
10845: oPushResult
10846: oSetResult 33
10848: oPushResult
10849: oNodeNew
10850: oPop 1
10852: oAssign
10853: oGetLocal 1
10855: oPushResult
10856: oSetResult 36
10858: oPushResult
10859: oGetParam 1
10861: oPushResult
10862: oNodeSet
10863: oPop 3
10865: oGetLocal 1
10867: oPushResult
10868: oSetResult 17
10870: oPushResult
10871: oSetResult 8
10873: oPushResult
10874: oNodeSetInt
10875: oPop 3
10877: oGetLocal 1
10879: oPushResult
10880: oTypeAdd
10881: oPop 1
10883: oGetParam 1
10885: oPushResult
10886: oSetResult 35
10888: oPushResult
10889: oGetLocal 1
10891: oPushResult
10892: oNodeSet
10893: oPop 3
10895: oJumpForward 10900
10897: Choice Lookup Table
           1   10843
10900: oGetLocal 1
10902: oReturn
10903: oReturn
10904: oLocalSpace 2
10906: oGetParam 1
10908: oPushResult
10909: oNodeType
10910: oPop 1
10912: oChoice 10982
10914: oMININT
10915: oReturn
10916: oJumpForward 10998
10918: oSetResult 0
10920: oReturn
10921: oJumpForward 10998
10923: oSetResult 0
10925: oReturn
10926: oJumpForward 10998
10928: oGetAddrLocal 1
10930: oPushResult
10931: oGetParam 1
10933: oPushResult
10934: oSetResult 40
10936: oPushResult
10937: oNodeGet
10938: oPop 2
10940: oAssign
10941: oGetAddrLocal 2
10943: oPushResult
10944: oGetLocal 1
10946: oPushResult
10947: oSetResult 15
10949: oPushResult
10950: oNodeGetIter
10951: oPop 2
10953: oPushResult
10954: oNodeIterValue
10955: oPop 1
10957: oAssign
10958: oGetLocal 2
10960: oPushResult
10961: oSetResult 22
10963: oPushResult
10964: oNodeGetInt
10965: oPop 2
10967: oReturn
10968: oJumpForward 10998
10970: oGetParam 1
10972: oPushResult
10973: oSetResult 38
10975: oPushResult
10976: oNodeGetInt
10977: oPop 2
10979: oReturn
10980: oJumpForward 10998
10982: Choice Lookup Table
          36   10970
          40   10928
          32   10923
          30   10918
          28   10914
10993: oError 3
10995: oSetResult 0
10997: oReturn
10998: oReturn
10999: oLocalSpace 2
11001: oGetParam 1
11003: oPushResult
11004: oNodeType
11005: oPop 1
11007: oChoice 11077
11009: oMAXINT
11010: oReturn
11011: oJumpForward 11093
11013: oSetResult 1
11015: oReturn
11016: oJumpForward 11093
11018: oSetResult 255
11020: oReturn
11021: oJumpForward 11093
11023: oGetAddrLocal 1
11025: oPushResult
11026: oGetParam 1
11028: oPushResult
11029: oSetResult 40
11031: oPushResult
11032: oNodeGet
11033: oPop 2
11035: oAssign
11036: oGetAddrLocal 2
11038: oPushResult
11039: oGetLocal 1
11041: oPushResult
11042: oSetResult 15
11044: oPushResult
11045: oNodeGetIterLast
11046: oPop 2
11048: oPushResult
11049: oNodeIterValue
11050: oPop 1
11052: oAssign
11053: oGetLocal 2
11055: oPushResult
11056: oSetResult 22
11058: oPushResult
11059: oNodeGetInt
11060: oPop 2
11062: oReturn
11063: oJumpForward 11093
11065: oGetParam 1
11067: oPushResult
11068: oSetResult 39
11070: oPushResult
11071: oNodeGetInt
11072: oPop 2
11074: oReturn
11075: oJumpForward 11093
11077: Choice Lookup Table
          36   11065
          40   11023
          32   11018
          30   11013
          28   11009
11088: oError 3
11090: oSetResult 0
11092: oReturn
11093: oReturn
11094: oLocalSpace 0
11096: oGetParam 1
11098: oPushResult
11099: oSetResult 22
11101: oPushResult
11102: oNodeGetInt
11103: oPop 2
11105: oPushResult
11106: oEmitInt
11107: oPop 1
11109: oReturn
11110: oLocalSpace 1
11112: oGetAddrLocal 1
11114: oPushResult
11115: oSetResult 14
11117: oPushResult
11118: oGetParam 1
11120: oPushResult
11121: oCall 10792
11123: oPop 2
11125: oAssign
11126: oGetLocal 1
11128: oPushResult
11129: oScopeDeclare
11130: oPop 1
11132: oGetLocal 1
11134: oReturn
11135: oReturn
11136: oLocalSpace 1
11138: oGetAddrGlobal 4
11140: oPushResult
11141: oIdAdd_mysystem
11142: oAssign
11143: oGetAddrGlobal 5
11145: oPushResult
11146: oIdAdd_ShortStringAppendShortString
11147: oAssign
11148: oGetAddrGlobal 6
11150: oPushResult
11151: oSetResult 27
11153: oPushResult
11154: oSetResult 4
11156: oPushResult
11157: oCall 10758
11159: oPop 2
11161: oAssign
11162: oGetAddrGlobal 7
11164: oPushResult
11165: oSetResult 28
11167: oPushResult
11168: oSetResult 4
11170: oPushResult
11171: oCall 10758
11173: oPop 2
11175: oAssign
11176: oGetAddrGlobal 8
11178: oPushResult
11179: oSetResult 30
11181: oPushResult
11182: oSetResult 1
11184: oPushResult
11185: oCall 10758
11187: oPop 2
11189: oAssign
11190: oGetAddrGlobal 9
11192: oPushResult
11193: oSetResult 31
11195: oPushResult
11196: oSetResult 1
11198: oPushResult
11199: oCall 10758
11201: oPop 2
11203: oAssign
11204: oGetAddrGlobal 10
11206: oPushResult
11207: oSetResult 32
11209: oPushResult
11210: oSetResult 1
11212: oPushResult
11213: oCall 10758
11215: oPop 2
11217: oAssign
11218: oGetAddrGlobal 11
11220: oPushResult
11221: oGetGlobal 10
11223: oPushResult
11224: oCall 10820
11226: oPop 1
11228: oAssign
11229: oGetAddrGlobal 12
11231: oPushResult
11232: oSetResult 29
11234: oPushResult
11235: oSetResult 1
11237: oPushResult
11238: oCall 10758
11240: oPop 2
11242: oAssign
11243: oGetAddrGlobal 13
11245: oPushResult
11246: oSetResult 34
11248: oPushResult
11249: oSetResult 8
11251: oPushResult
11252: oCall 10758
11254: oPop 2
11256: oAssign
11257: oGetGlobal 13
11259: oPushResult
11260: oSetResult 36
11262: oPushResult
11263: oGetGlobal 12
11265: oPushResult
11266: oNodeSet
11267: oPop 3
11269: oGetAddrGlobal 14
11271: oPushResult
11272: oSetResult 38
11274: oPushResult
11275: oSetResult 256
11277: oPushResult
11278: oCall 10758
11280: oPop 2
11282: oAssign
11283: oGetAddrGlobal 15
11285: oPushResult
11286: oSetResult 39
11288: oPushResult
11289: oSetResult 256
11291: oPushResult
11292: oCall 10758
11294: oPop 2
11296: oAssign
11297: oGetGlobal 15
11299: oPushResult
11300: oSetResult 41
11302: oPushResult
11303: oSetResult 255
11305: oPushResult
11306: oNodeSetInt
11307: oPop 3
11309: oGetAddrLocal 1
11311: oPushResult
11312: oSetResult 18
11314: oPushResult
11315: oIdAdd_File
11316: oPushResult
11317: oCall 10792
11319: oPop 2
11321: oAssign
11322: oGetLocal 1
11324: oPushResult
11325: oSetResult 21
11327: oPushResult
11328: oGetGlobal 6
11330: oPushResult
11331: oNodeSet
11332: oPop 3
11334: oGetLocal 1
11336: oPushResult
11337: oScopeDeclare
11338: oPop 1
11340: oGetAddrLocal 1
11342: oPushResult
11343: oSetResult 18
11345: oPushResult
11346: oIdAdd_Integer
11347: oPushResult
11348: oCall 10792
11350: oPop 2
11352: oAssign
11353: oGetLocal 1
11355: oPushResult
11356: oSetResult 21
11358: oPushResult
11359: oGetGlobal 7
11361: oPushResult
11362: oNodeSet
11363: oPop 3
11365: oGetLocal 1
11367: oPushResult
11368: oScopeDeclare
11369: oPop 1
11371: oGetAddrLocal 1
11373: oPushResult
11374: oSetResult 18
11376: oPushResult
11377: oIdAdd_Boolean
11378: oPushResult
11379: oCall 10792
11381: oPop 2
11383: oAssign
11384: oGetLocal 1
11386: oPushResult
11387: oSetResult 21
11389: oPushResult
11390: oGetGlobal 8
11392: oPushResult
11393: oNodeSet
11394: oPop 3
11396: oGetLocal 1
11398: oPushResult
11399: oScopeDeclare
11400: oPop 1
11402: oGetAddrLocal 1
11404: oPushResult
11405: oSetResult 18
11407: oPushResult
11408: oIdAdd_Char
11409: oPushResult
11410: oCall 10792
11412: oPop 2
11414: oAssign
11415: oGetLocal 1
11417: oPushResult
11418: oSetResult 21
11420: oPushResult
11421: oGetGlobal 10
11423: oPushResult
11424: oNodeSet
11425: oPop 3
11427: oGetLocal 1
11429: oPushResult
11430: oScopeDeclare
11431: oPop 1
11433: oGetAddrLocal 1
11435: oPushResult
11436: oSetResult 18
11438: oPushResult
11439: oIdAdd_Byte
11440: oPushResult
11441: oCall 10792
11443: oPop 2
11445: oAssign
11446: oGetLocal 1
11448: oPushResult
11449: oSetResult 21
11451: oPushResult
11452: oGetGlobal 12
11454: oPushResult
11455: oNodeSet
11456: oPop 3
11458: oGetLocal 1
11460: oPushResult
11461: oScopeDeclare
11462: oPop 1
11464: oGetAddrLocal 1
11466: oPushResult
11467: oSetResult 18
11469: oPushResult
11470: oIdAdd_Pointer
11471: oPushResult
11472: oCall 10792
11474: oPop 2
11476: oAssign
11477: oGetLocal 1
11479: oPushResult
11480: oSetResult 21
11482: oPushResult
11483: oGetGlobal 13
11485: oPushResult
11486: oNodeSet
11487: oPop 3
11489: oGetLocal 1
11491: oPushResult
11492: oScopeDeclare
11493: oPop 1
11495: oGetAddrLocal 1
11497: oPushResult
11498: oSetResult 18
11500: oPushResult
11501: oIdAdd_ShortString
11502: oPushResult
11503: oCall 10792
11505: oPop 2
11507: oAssign
11508: oGetLocal 1
11510: oPushResult
11511: oSetResult 21
11513: oPushResult
11514: oGetGlobal 15
11516: oPushResult
11517: oNodeSet
11518: oPop 3
11520: oGetLocal 1
11522: oPushResult
11523: oScopeDeclare
11524: oPop 1
11526: oGetAddrLocal 1
11528: oPushResult
11529: oSetResult 16
11531: oPushResult
11532: oIdAdd_True
11533: oPushResult
11534: oCall 10792
11536: oPop 2
11538: oAssign
11539: oGetLocal 1
11541: oPushResult
11542: oSetResult 21
11544: oPushResult
11545: oGetGlobal 8
11547: oPushResult
11548: oNodeSet
11549: oPop 3
11551: oGetLocal 1
11553: oPushResult
11554: oSetResult 22
11556: oPushResult
11557: oSetResult 1
11559: oPushResult
11560: oNodeSetInt
11561: oPop 3
11563: oGetLocal 1
11565: oPushResult
11566: oScopeDeclare
11567: oPop 1
11569: oGetAddrLocal 1
11571: oPushResult
11572: oSetResult 16
11574: oPushResult
11575: oIdAdd_False
11576: oPushResult
11577: oCall 10792
11579: oPop 2
11581: oAssign
11582: oGetLocal 1
11584: oPushResult
11585: oSetResult 21
11587: oPushResult
11588: oGetGlobal 8
11590: oPushResult
11591: oNodeSet
11592: oPop 3
11594: oGetLocal 1
11596: oPushResult
11597: oSetResult 22
11599: oPushResult
11600: oSetResult 0
11602: oPushResult
11603: oNodeSetInt
11604: oPop 3
11606: oGetLocal 1
11608: oPushResult
11609: oScopeDeclare
11610: oPop 1
11612: oGetAddrGlobal 16
11614: oPushResult
11615: oIdAdd_Ord
11616: oPushResult
11617: oCall 11110
11619: oPop 1
11621: oAssign
11622: oGetAddrGlobal 17
11624: oPushResult
11625: oIdAdd_Chr
11626: oPushResult
11627: oCall 11110
11629: oPop 1
11631: oAssign
11632: oGetAddrGlobal 18
11634: oPushResult
11635: oIdAdd_Pred
11636: oPushResult
11637: oCall 11110
11639: oPop 1
11641: oAssign
11642: oGetAddrGlobal 19
11644: oPushResult
11645: oIdAdd_Succ
11646: oPushResult
11647: oCall 11110
11649: oPop 1
11651: oAssign
11652: oReturn
