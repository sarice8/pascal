   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 162:    oScopeBegin
 163:    mainRoutineScope = oScopeCurrent
 168:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 179:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
 190:    oScopeEnd
      
 191:    @BlockDecls( nGlobalVar )
      
      
 198:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 204:    @BlockStmt( mainLabel, globalScope )
      
 214:    oScopeEnd   % main routine scope
      
 215:    '.'
 217:    oScopeEnd   % global scope
 219:    ;
      
      
 219: Block( node_type varNodeType, Label labelForBody ):
 221:    @BlockDecls( varNodeType )
 228:    @BlockStmt( labelForBody, oScopeCurrent )
 238:    ;
      
      
 238: BlockDecls( node_type varNodeType ):
 240:    {[
 240:       | pConst :     @ConstDecl
 244:       | pType :      @TypeDecl
 248:       | pVar :       @VarDecl( varNodeType )
 257:       | pProcedure : @ProcDecl
 261:       | pFunction :  @FuncDecl
 265:       | * :          >
 280:    ]}
 282:    @CheckForUndefinedMethods
 285:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 285: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 288:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 288: BlockStmt( Label labelForBody, Node varScope ):
 290:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 298:    int patchLS
 298:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 307:    Code initCode = oNodeGetCode( varScope, qInitCode )
 320:    oEmitCode( initCode )
 326:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 337:    @Statement
 339:    .tReturn
      
 341:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 353:    oPatch( patchLS, localSpace )
 363:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 363: MethodModifiers( Node decl ):
 365:    {[
 365:       | pCdecl :
 367:          oNodeSetBoolean( decl, qCdecl, true )
 379:          ';'
      
 381:       | * : >
 388:    ]}
 391:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 391: GetOrCreateInitCode >> Code:
 393:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 405:    [ equal_code( initCode, codeNull )
 415:       | true :
 416:          initCode = oCodeNew
 421:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 432:       | * :
 437:    ]
 437:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 441: ExternalDecl( Node decl ):
 443:    oNodeSetBoolean( decl, qExternal, true )
 455:    [
 455:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 457:          [
 457:             | pName :
 459:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 461:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 472:             | * :
 477:          ]
 477:       | * :
 482:    ]
 483:    ;
      
      
 483: ProcDecl:
 485:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 487:    boolean redeclaring = false
 493:    Node decl = oScopeFindInCurrentScope
      
 498:    [ oNodeNull( decl )
 505:       | true :
               % first declaration
 506:          decl = @newIdent( nProc, kProc, LAST_ID )
 522:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 533:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 535:          redeclaring = true
 541:          [ oNodeGetBoolean( decl, qBodyDefined )
 551:             | true : #eAlreadyDefined
 554:             | * :
 559:          ]
 559:          [ oNodeGetBoolean( decl, qExternal )
 569:             | true : #eAlreadyDefined
 572:             | * :
 577:          ]
 577:          [ oNodeType( decl )
 584:             | nProc :
 585:             | * : #eAlreadyDefined   % wrong kind
 592:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 592:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 611:          oNodeSet( decl, qParams, Null )
 623:    ]
      
 631:    oScopeBegin
 632:    Node paramScope = oScopeCurrent
      
 637:    @FormalArgDecl
 639:    oNodeSet( decl, qParams, paramScope )
 651:    oScopeEnd
 652:    ';'
      
 654:    [ redeclaring
 657:       | false : oScopeDeclare( decl )
 664:       | true :  % TO DO: check that qParams is consistent with qOldParams
 666:    ]
      
 674:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 681:    [
 681:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 683:       | pExternal : @ExternalDecl( decl )
      
 692:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 699:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 705:          oScopeBegin
 706:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 717:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 728:          Label label = oNodeGetLabel( decl, qValue )
 741:          @Block( nLocalVar, label )
 751:          oNodeSetBoolean( decl, qBodyDefined, true )
 763:          oScopeEnd
      
 764:          oScopeEnd  % paramScope
 765:    ]
 765:    ';';
      
      
 768: FuncDecl:
 770:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 772:    boolean redeclaring = false
 778:    Node decl = oScopeFindInCurrentScope
      
 783:    [ oNodeNull( decl )
 790:       | true :
               % first declaration
 791:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 807:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 818:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 820:          redeclaring = true
 826:          [ oNodeGetBoolean( decl, qBodyDefined )
 836:             | true : #eAlreadyDefined
 839:             | * :
 844:          ]
 844:          [ oNodeType( decl )
 851:             | nFunc :
 852:             | * : #eAlreadyDefined   % wrong kind
 859:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 859:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 878:          oNodeSet( decl, qParams, Null )
 890:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 909:          oNodeSet( decl, qType, Null )
 921:    ]
      
 929:    oScopeBegin
 930:    Node paramScope = oScopeCurrent
      
 935:    @FormalArgDecl
 937:    oNodeSet( decl, qParams, paramScope )
      
 949:    ':'
      
 951:    Node theType
 951:    @TypeRef( theType )
 958:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 970:    Node ptrType = @PointerTypeTo( theType )
 981:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 997:    oScopeEnd
 998:    ';'
      
1000:    [ redeclaring
1003:       | false : oScopeDeclare( decl )
1010:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1012:    ]
      
1020:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1027:    [
1027:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1029:       | pExternal : @ExternalDecl( decl )
      
1038:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1045:          oScopeEnter( paramScope )
      
1051:          oScopeBegin
1052:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1063:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1074:          Label label = oNodeGetLabel( decl, qValue )
1087:          @Block( nLocalVar, label )
1097:          oNodeSetBoolean( decl, qBodyDefined, true )
1109:          oScopeEnd
      
1110:          oScopeEnd  % paramScope
1111:    ]
1111:    ';';
      
      
1114: FormalArgDecl:
1116:    [
1116:       | '(' :
1118:          {
1118:             NodeVec decls = oNodeVecNew
1123:             Node decl
1123:             boolean isInOut = false
      
1129:             [
1129:                | pVar : isInOut = true
1137:                | * :
1142:             ]
      
1142:             {  pIdent
      
1144:                decl = @newIdent( nParam, kVar, LAST_ID )
1160:                oNodeSetBoolean( decl, qInOut, isInOut )
1172:                oNodeVecAppend( decls, decl )
      
1181:                [
1181:                   | ':' : >
1185:                   | ',' :
1187:                ]
1195:             }
      
1197:             Node theType
1197:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1204:             Node allocType
1204:             [ isInOut
1207:                | true :   allocType = @PointerTypeTo( theType )
1219:                | * :      allocType = theType
1230:             ]
      
1230:             int i = 0
1236:             {[ equal( i, oNodeVecSize( decls ) )
1250:                | false :
1251:                   decl = oNodeVecElement( decls, i )
      
1264:                   oNodeSet( decl, qType, theType )
1276:                   oScopeDeclare( decl )
1282:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1298:                   inc( i )
1304:                | * :
1309:                   >
1311:             ]}
      
1313:             oNodeVecDelete( decls )
      
1319:             [
1319:                | ')' : >
1323:                | ';' :
1325:             ]
1333:          }
1335:       | * :
1340:    ];
      
1341: ConstDecl:
1343:    {[
1343:       | pIdent :
1345:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1361:          '='
      
1363:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1365:          int val = oValueTop
1370:          oValuePop
1371:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1383:          oNodeSet( decl, qType, IntegerType )
      
1395:          oScopeDeclare( decl )
1401:          ';'
1403:       | * :
1408:          >
1410:    ]};
      
1413: TypeDecl:
1415:    {[
1415:       | pIdent :
1417:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1433:          '='
1435:          Node theType
1435:          @TypeRef( theType )
1442:          oNodeSet( decl, qType, theType )
1454:          oScopeDeclare( decl )
1460:          ';'
1462:       | * :
1467:          >
1469:    ]};
      
1472: VarDecl( node_type varNodeType ):
1474:    {[
1474:       | pIdent :
1476:          NodeVec decls = oNodeVecNew
1481:          Node decl
1481:          {
1481:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1497:             oNodeVecAppend( decls, decl )
1506:             [
1506:                | ',' :
1508:                   pIdent
1510:                | * :
1515:                   >
1517:             ]
1517:          }
1519:          ':'
1521:          Node theType
1521:          @TypeRef( theType )
      
1528:          int i = 0
1534:          {[ equal( i, oNodeVecSize( decls ) )
1548:             | false :
1549:                decl = oNodeVecElement( decls, i )
1562:                oNodeSet( decl, qType, theType )
1574:                oScopeDeclareAlloc( decl )
1580:                inc( i )
1586:             | * :
1591:               >
1593:          ]}
      
               % optional initialization
1595:          [
1595:             | '=' :
1597:                [ oNodeVecSize( decls )
1604:                   | 1 :
1605:                   | * :  #eOnlyOneVarCanBeInitialized
1612:                ]
      
                     % we need an initCode stream for this scope
1612:                Code initCode = @GetOrCreateInitCode
1618:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1624:                boolean changedScope = false
1630:                [ equal_node( oScopeCurrent, globalScope )
1639:                   | true : oScopeEnter( mainRoutineScope )
1646:                            changedScope = true
1652:                   | * :
1657:                ]
                     % generate assignment in initCode stream
1657:                @LValueVar( decl )
1664:                @Expr
1666:                @MatchTypes
1668:                @Assign
1670:                [ changedScope
1673:                   | true : oScopeEnd
1675:                   | * :
1680:                ]
1680:                oCodePop
                   
1681:             | * :
1686:          ]
      
1686:          oNodeVecDelete( decls )
1692:          ';'
1694:       | * :
1699:          >
1701:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1704: TypeRef( out Node resultType ):
1706:    [
1706:       | pIdent :           % previously named type (including intrinsics)
1708:          Node decl = oScopeFindRequire
1713:          [ oNodeType( decl )
1720:            | nTypeDecl :
1721:                resultType = oNodeGet( decl, qType )
1734:            | * :
1739:                #eNotType
1741:                resultType = IntegerType
1747:          ]
         
1747:       | pArray :
1749:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1751:          NodeVec dimensions = oNodeVecNew
      
1756:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1756:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1766:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1778:             @ConstExpr
1780:             oNodeSetInt( subrange, qLow, oValueTop )
1791:             oValuePop
1792:             '..'
1794:             @ConstExpr
1796:             oNodeSetInt( subrange, qHigh, oValueTop )
1807:             oValuePop
1808:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1820:             oTypeAdd( subrange )
      
1826:             Node a = oNodeNew( nArrayType )
1836:             oNodeSet( a, qIndexType, subrange )
      
1848:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1857:             [
1857:                | ']' : >
1861:                | ',' :
1863:             ]
1871:          }
      
1873:          pOf
1875:          Node baseType
1875:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1882:          int dim = oNodeVecSize( dimensions )
      
1892:          {
1892:              dec(dim)
      
1898:              Node a = oNodeVecElement( dimensions, dim )
      
1911:              oNodeSet( a, qBaseType, baseType )
1923:              Node subrange = oNodeGet( a, qIndexType )
1936:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1963:              inc( width )
1969:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1995:              oTypeAdd( a )
2001:              baseType = a
      
2007:              [ equal_zero(dim)
2014:                  | true:  >
2017:                  | *:
2022:              ]
2022:          }
      
2024:          resultType = oNodeVecElement( dimensions, 0 )
2037:          oNodeVecDelete( dimensions )
      
2043:       | '^' :
2045:          Node theType
2045:          @TypeRef( theType )
2052:          resultType = @PointerTypeTo( theType )
      
2063:       | pRecord :
2065:          resultType = oNodeNew( nRecordType )
2075:          oScopeBegin
      
2076:          @VarDecl( nRecordField )
      
2083:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2095:          [ equal_zero( size )
2102:             | true : #eRecordEmpty
2105:             | * :
2110:          ]
      
2110:          pEnd
      
2112:          oNodeSet( resultType, qScope, oScopeCurrent )
2123:          oNodeSetInt( resultType, qSize, size )
2135:          oScopeEnd
2136:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2142:       | pSet :
2144:          pOf
2146:          Node theType
2146:          @TypeRef( theType )
2153:       | * :       % this works for cases except where expr starts with an id
2166:          @ConstExpr '..' @ConstExpr
2172:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2173: ConstExpr:
2175:    [
2175:       | pIntLit :
2177:          oValuePush( TOKEN_VALUE )
2182:       | pIdent :
2184:          Node decl = oScopeFindRequire
2189:          [ oNodeType( decl )
2196:             | nConst :
2197:                oValuePush( oNodeGetInt( decl, qValue ) )
2210:             | * :
2215:                #eNotConst
2217:                oValuePush( 0 )
2223:          ]
2223:       | pMinus :
2225:          @ConstExpr
2227:          oValueNegate
2228:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2239: Expr:
2241:    Label falseLabel = labelNull
      
2247:    @ExprAllowCF( falseLabel )
2254:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2262: BooleanExprControlFlow( out Label falseLabel ):
2264:    @ExprAllowCF( falseLabel )
2271:    [ oTypeSNodeType
2273:       | nBooleanCFType :
2274:       | nBooleanType :
               % convert value to control flow
2276:          falseLabel = oLabelNew
2281:          .tJumpFalse  oEmitLabel( falseLabel )
2289:       | * :
2296:          #eNotBoolean
2298:    ]
2298:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2300: CFToVal( inout Label falseLabel ):
2302:    [ oTypeSNodeType
2304:       | nBooleanCFType :
2305:          Label doneLabel = oLabelNew
2310:          .tPushConstI  oEmitInt( 1 )
2318:          .tJump  oEmitLabel( doneLabel )
2326:          .tLabel  oEmitLabel( falseLabel )
2334:          .tPushConstI  oEmitInt( 0 )
2342:          .tLabel  oEmitLabel( doneLabel )
2350:          oTypeSPop
2351:          oTypeSPush( BooleanType )
2357:          falseLabel = labelNull
2363:       | * :
2368:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2369: ValToCF( out Label falseLabel ):
2371:    [ oTypeSNodeType
2373:       | nBooleanType :
2374:          falseLabel = oLabelNew
2379:          .tJumpFalse  oEmitLabel( falseLabel )
2387:          oTypeSPop
2388:          oTypeSPush( BooleanCFType )
2394:       | * :
2399:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2400: ExprAllowCF( out Label falseLabel ):
2402:    @BoolExprAllowCF( falseLabel )
2409:    {[
2409:       | '=' :
2411:          @CFToVal( falseLabel )
2418:          @BoolExprAllowCF( falseLabel )
2425:          @CFToVal( falseLabel )
2432:          @MatchTypes
2434:          [ oTypeSNodeType
2436:             | nIntegerType, nBooleanType :  .tEqualI
2439:             | nPointerType :                .tEqualP
2443:             | nCharType, nStringType :      #eNotImplemented
2447:             | * :                           #eNotAllowed
2462:          ]
2462:          oTypeSPop
2463:          oTypeSPush( BooleanType )
      
2469:       | '<>' :
2471:          @CFToVal( falseLabel )
2478:          @BoolExprAllowCF( falseLabel )
2485:          @CFToVal( falseLabel )
2492:          @MatchTypes
2494:          [ oTypeSNodeType
2496:             | nIntegerType, nBooleanType :  .tNotEqualI
2499:             | nPointerType :                .tNotEqualP
2503:             | nCharType, nStringType :      #eNotImplemented
2507:             | * :                           #eNotAllowed
2522:          ]
2522:          oTypeSPop
2523:          oTypeSPush( BooleanType )
      
2529:       | '<' :
2531:          @CFToVal( falseLabel )
2538:          @BoolExprAllowCF( falseLabel )
2545:          @CFToVal( falseLabel )
2552:          @MatchTypes
2554:          [ oTypeSNodeType
2556:             | nIntegerType, nBooleanType :  .tLessI
2559:             | nCharType, nStringType :      #eNotImplemented
2563:             | * :                           #eNotAllowed
2576:          ]
2576:          oTypeSPop
2577:          oTypeSPush( BooleanType )
      
2583:       | '>' :
2585:          @CFToVal( falseLabel )
2592:          @BoolExprAllowCF( falseLabel )
2599:          @CFToVal( falseLabel )
2606:          @MatchTypes
2608:          [ oTypeSNodeType
2610:             | nIntegerType, nBooleanType :  .tGreaterI
2613:             | nCharType, nStringType :      #eNotImplemented
2617:             | * :                           #eNotAllowed
2630:          ]
2630:          oTypeSPop
2631:          oTypeSPush( BooleanType )
      
2637:       | '<=' :
2639:          @CFToVal( falseLabel )
2646:          @BoolExprAllowCF( falseLabel )
2653:          @CFToVal( falseLabel )
2660:          @MatchTypes
2662:          [ oTypeSNodeType
2664:             | nIntegerType, nBooleanType :  .tLessEqualI
2667:             | nCharType, nStringType :      #eNotImplemented
2671:             | * :                           #eNotAllowed
2684:          ]
2684:          oTypeSPop
2685:          oTypeSPush( BooleanType )
      
2691:       | '>=' :
2693:          @CFToVal( falseLabel )
2700:          @BoolExprAllowCF( falseLabel )
2707:          @CFToVal( falseLabel )
2714:          @MatchTypes
2716:          [ oTypeSNodeType
2718:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2721:             | nCharType, nStringType :      #eNotImplemented
2725:             | * :                           #eNotAllowed
2738:          ]
2738:          oTypeSPop
2739:          oTypeSPush( BooleanType )
      
2745:       | * :
2760:          >
2762:    ]};
      
      
2765: BoolExprAllowCF( out Label falseLabel ):
2767:    Label trueLabel = labelNull
      
2773:    @BoolTermAllowCF( falseLabel )
2780:    {[
2780:       | pOr :
2782:          [ oTypeSNodeType
2784:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2785:                [ equal_label( trueLabel, labelNull )
2795:                   | true :  trueLabel = oLabelNew
2801:                   | * :
2806:                ]
2806:                .tJump  oEmitLabel( trueLabel )
2814:             | nBooleanType :
2816:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2823:                [ equal_label( trueLabel, labelNull )
2833:                   | true :  trueLabel = oLabelNew
2839:                   | * :
2844:                ]
2844:                .tJump  oEmitLabel( trueLabel )
2852:             | * : #eNotBoolean
2861:          ]
2861:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2862:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2870:          falseLabel = labelNull
2876:          @BoolTermAllowCF( falseLabel )
      
2883:          [ oTypeSNodeType
2885:             | nBooleanCFType :
2886:             | nBooleanType :
2888:                @ValToCF( falseLabel )
2895:             | * : #eNotBoolean
2904:          ]
      
2904:          oTypeSPop
2905:          oTypeSPush( BooleanCFType )
      
2911:       | * :
2916:          >
2918:    ]}
      
         % any short-circuit trues jump here to the end
2920:    [ equal_label( trueLabel, labelNull )
2930:       | false :
2931:          .tLabel  oEmitLabel( trueLabel )
2939:       | * :
2944:    ]
2945:    ;
      
      
2945: BoolTermAllowCF( out Label falseLabel ):
2947:    Label overallFalseLabel = labelNull
      
2953:    @BoolFactorAllowCF( falseLabel )
2960:    {[
2960:       | pAnd :
2962:          [ oTypeSNodeType
2964:             | nBooleanCFType :
2965:             | nBooleanType :
2967:                @ValToCF( falseLabel )
2974:             | * :
2981:                #eNotBoolean
2983:          ]
2983:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2984:          [ equal_label( overallFalseLabel, labelNull )
2994:             | true :
2995:                overallFalseLabel = oLabelNew
3000:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3014:                falseLabel = overallFalseLabel
3020:             | * :
3025:          ]
      
3025:          Label factorFalseLabel = labelNull
3031:          @BoolFactorAllowCF( factorFalseLabel )
      
3038:          [ oTypeSNodeType
3040:             | nBooleanCFType :
3041:             | nBooleanType :
3043:                @ValToCF( factorFalseLabel )
3050:             | * : #eNotBoolean
3059:          ]
3059:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3073:       | * :
3078:          >
3080:    ]};
      
3083: BoolFactorAllowCF( out Label falseLabel ):
3085:    [
3085:       | pNot :
3087:          Label factorFalseLabel = labelNull
      
3093:          @BoolFactorAllowCF( factorFalseLabel )
3100:          [ oTypeSNodeType
3102:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3103:                falseLabel = oLabelNew
3108:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3116:                .tLabel  oEmitLabel( factorFalseLabel )
      
3124:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3126:                .tNot
      
3128:             | * : #eNotBoolean
3137:          ]
      
3137:       | * :
3142:          @ArithExprAllowCF( falseLabel )
3149:    ];
      
3150: ArithExprAllowCF( out Label falseLabel ):
3152:    @TermAllowCF( falseLabel )
3159:    {[
3159:       | pPlus :
3161:          @RequireIntPop
3163:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3170:          @RequireInt
3172:          .tAddI
3174:       | pMinus :
3176:          @RequireIntPop
3178:          @TermAllowCF( falseLabel )
3185:          @RequireInt
3187:          .tSubI
3189:       | * :
3196:          >
3198:    ]};
      
3201: TermAllowCF( out Label falseLabel ):
3203:    @FactorAllowCF( falseLabel )
3210:    {[
3210:       | pTimes :
3212:          @RequireIntPop
3214:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3221:          @RequireInt
3223:          .tMultI
3225:       | pDivide :
3227:          @RequireIntPop
3229:          @FactorAllowCF( falseLabel )
3236:          @RequireInt
3238:          .tDivI
3240:       | * :
3247:          >
3249:    ]};
      
3252: FactorAllowCF( out Label falseLabel ):
3254:    [
3254:       | pPlus :
3256:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3263:          @RequireInt
3265:       | pMinus :
3267:          @PrimaryAllowCF( falseLabel )
3274:          @RequireInt
3276:          .tNegI
3278:       | * :
3285:          @PrimaryAllowCF( falseLabel )
3292:    ];
      
3293: PrimaryAllowCF( out Label falseLabel ):
3295:    [
3295:       | pIntLit :
3297:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3304:          oTypeSPush( IntegerType )
      
3310:       | '(' :
3312:          @ExprAllowCF( falseLabel )
3319:          ')'
      
3321:       | pStrLit :
3323:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3332:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3340:          oTypeSPush( StringType )
      
3346:       | pIdent :
3348:          Node decl = oScopeFindRequire
3353:          Node theType
      
3353:          [ oNodeType( decl )
3360:             | nFunc :
      
3361:                @Call( decl )
      
3368:             | nConst :
3370:                theType = oNodeGet( decl, qType )
3383:                oTypeSPush( theType )
3389:                [ oTypeSNodeType
3391:                   | nIntegerType, nBooleanType :
3392:                      .tPushConstI @EmitValue( decl )
3401:                   | * :
3408:                      #eNotImplemented
3410:                ]
      
3410:             | nGlobalVar, nLocalVar, nParam :
3412:                @VarExpr( decl )
      
3419:             | * :
3432:                #eNotValue
3434:                oTypeSPush( IntegerType )
3440:          ]
      
3440:       | '@' :        % @var -- pointer to var
3442:          pIdent
      
3444:          Node decl = oScopeFindRequire
3449:          Node theType
      
3449:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3456:          theType = oTypeSTop
3461:          oTypeSPop
3462:          Node ptrType = @PointerTypeTo( theType )
3473:          oTypeSPush( ptrType )
      
3479:       | * :
3492:          #eNotValue
3494:          oTypeSPush( IntegerType )
3500:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3501: VarExpr( Node decl ):
3503:    Node theType = oNodeGet( decl, qType )
3516:    oTypeSPush( theType )
3522:    [ oTypeSNodeType
3524:       | nIntegerType :
3525:          [ oNodeType( decl )
3532:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3542:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3553:             | nParam :
3555:                [ oNodeGetBoolean( decl, qInOut )
3565:                   | true :    % VAR param points to the var.  Auto dereference.
3566:                               .tPushParamP @EmitValue( decl )
3575:                               .tFetchI
3577:                   | * :       .tPushParamI @EmitValue( decl )
3591:                ]
3591:          ]
      
3601:       | nBooleanType :
3603:          [ oNodeType( decl )
3610:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3620:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3631:             | nParam :
3633:                [ oNodeGetBoolean( decl, qInOut )
3643:                   | true :    % VAR param points to the var.  Auto derefernce.
3644:                               .tPushParamP @EmitValue( decl )
3653:                               .tFetchB
3655:                   | * :       .tPushParamB @EmitValue( decl )
3669:                ]
3669:          ]
      
3679:       | nCharType, nStringType, nFileType :
3681:          #eNotImplemented
      
3683:       | nPointerType :
3685:          [ oNodeType( decl )
3692:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3702:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3713:             | nParam :
3715:                [ oNodeGetBoolean( decl, qInOut )
3725:                   | true :    % VAR param points to the var.  Auto derefernce.
3726:                               .tPushParamP @EmitValue( decl )
3735:                               .tFetchP
3737:                   | * :       .tPushParamP @EmitValue( decl )
3751:                ]
3751:          ]
3761:          [
3761:             | '^' :             % dereferenced
3763:                oTypeSPop
3764:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3777:                @LValueIndexes
3779:                @FetchVar
3781:             | * :               % just ptr value alone
3786:          ]
      
3786:       | * :
               % compound type
               % first, push addr of start of var
3801:          [ oNodeType( decl )
3808:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3818:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3829:             | nParam :
3831:                [ oNodeGetBoolean( decl, qInOut )
3841:                   | true :    % VAR param points to the var.  Auto derefernce.
3842:                               .tPushParamP @EmitValue( decl )
3851:                   | * :       .tPushAddrParam @EmitValue( decl )
3865:                ]
3865:          ]
               % modify addr for subscripts, field references, etc
3875:          @LValueIndexes
               % get final value
3877:          @FetchVar
3879:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3880: FetchVar:
3882:    [ oTypeSNodeType
3884:       | nIntegerType :   .tFetchI
3887:       | nBooleanType :   .tFetchB
3891:       | nCharType, nStringType, nFileType : #eNotImplemented
3895:       | nPointerType :   .tFetchP
3899:       | * :              % compound type; leave as addr
3914:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3915: LValueIndexes:
3917:    {[
3917:       | '[' :       @ArraySubscripts
3921:       | '.' :       @RecordFieldRef
3925:       | '^' :       @PointerDeref
3929:       | * :         >
3940:    ]};
      
3943: ArraySubscripts:
3945:    [ oTypeSNodeType
3947:       | nArrayType :
3948:       | * :       #eNotArray
3955:    ]
3955:    {
3955:       [ oTypeSNodeType
3957:          | nArrayType :
3958:          | * :    #eTooManySubscripts
3965:       ]
      
            % low subscript of this dimension
3965:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3982:       Node baseType
3982:       baseType = oNodeGet( oTypeSTop, qBaseType )
3994:       oTypeSPop
3995:       oTypeSPush( baseType )
      
4001:       @Expr
4003:       @RequireIntPop
            % adjust for low subscript
4005:       [ equal_zero( low )
4012:          | false :
4013:             .tPushConstI oEmitInt( low ) .tSubI
4023:          | * :
4028:       ]
      
            % multiply by element size
4028:       int size = oNodeGetInt( baseType, qSize )
4041:       [ equal( size, 1 )
4051:          | false :
4052:             .tPushConstI oEmitInt( size ) .tMultI
4062:          | * :
4067:       ]
      
            % update start address
4067:       .tAddPI
4069:       [
4069:          | ']' :  >
4073:          | ',' :
4075:       ]
4083:    };
      
      
4086: RecordFieldRef:
4088:    [ oTypeSNodeType
4090:       | nRecordType :
4091:       | * :    #eNotRecord
4098:    ]
4098:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4110:    pIdent
4112:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4117:    [ oNodeType( field )
4124:       | nRecordField :
4125:       | * :   #eNotRecordField
4132:    ]
4132:    oScopeEnd
4133:    int offset = oNodeGetInt( field, qValue )
4146:    [ equal_zero( offset )
4153:       | false :
4154:          .tPushConstI oEmitInt( offset ) .tAddPI
4164:       | * :
4169:    ]
      
         % replace the type on the type stack, with the field type
4169:    oTypeSPop
4170:    oTypeSPush( oNodeGet( field, qType ) )
4184:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4184: PointerDeref:
4186:    [ oTypeSNodeType
4188:       | nPointerType :
4189:       | * :       #eNotPointer
4196:    ]
4196:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4198:    Node theType = oTypeSTop
4203:    oTypeSPop
4204:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4218:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4218: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4220:    @MatchTypes
4223:    ;
      
      
      % Called on first use of an extern method
      %
4223: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4225:    int strAddr
4225:    String externalName = oNodeGetString( method, qExternalName )
4238:    [ equal_string( externalName, stringNull )
4248:       | true :
4249:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4270:       | false :
4272:          strAddr = oStringAllocLit( externalName )
4282:    ]
4290:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4306:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4306: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4308:    [ oNodeGetBoolean( method, qExternal )
4318:       | true :
4319:          [ oNodeGetBoolean( method, qCalled )
4329:             | false :
                     % define the extern label on first use
4330:                @DefineExternLabel( method )
4337:             | * :
4342:          ]
4342:      | * :
4347:    ]
4347:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4359:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4372:    Node resultType
4372:    int tempOffset
      
4372:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4389:    [ isFunc
4392:       | true :
4393:          resultType = oNodeGet( method, qType )
4406:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4416:       | * :
4421:    ]
         
      
4421:    Node paramScope = oNodeGet( method, qParams )
4434:    int actualsSize = oNodeGetInt( paramScope, qSize )
4447:    [ cdecl
4450:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4459:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4469:    ]
      
4477:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4490:    Node param = oNodeIterValue( paramIter )
4500:    [
4500:       | '(' :
            
4502:          {
4502:             [ oNodeNull( param )
4509:                | true : >
4512:                | * :
4517:             ]
      
4517:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4530:             .tPushAddrActual oEmitInt( offset )
4538:             oTypeSPush( oNodeGet( param, qType ) )
      
4551:             [ oNodeGetBoolean( param, qInOut )
4561:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4562:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4564:                           @MatchTypes
      
4566:                           .tAssignP
      
4568:                | false :  @Expr
4572:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4574:                           [ oTypeSNodeType
4576:                              | nIntegerType :            .tAssignI
4579:                              | nBooleanType :            .tAssignB
4583:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4587:                              | nPointerType :            .tAssignP
4591:                              | * :
                                       % compound types: copy value into actuals space
4606:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4618:                                  .tCopy  oEmitInt( size )    % multi-word copy
4626:                           ]
4626:             ]
4634:             oTypeSPop
      
4635:             oNodeIterNext( paramIter )
4641:             param = oNodeIterValue( paramIter )
4651:             [ oNodeNull( param )
4658:                | true :  >
4661:                | false :
4663:             ]
      
4671:             ','
4673:          }
      
4675:          ')'
      
4677:       | * :
4682:    ]
      
4682:    [ oNodeNull( param )
4689:       | false :    #eMissingParameter
4692:       | * :
4697:    ]
      
4697:    [ isFunc
4700:       | true :
               % Pass result temp as an additional VAR parameter.
4701:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4716:          .tPushAddrLocal  oEmitInt( tempOffset )
4724:          .tAssignP
4726:       | * :
4731:    ]
      
4731:    [ cdecl
4734:       | true :
4735:          .tCallCdecl  @EmitValue( method )
4744:       | false :
4746:          .tCall   @EmitValue( method )
4755:    ]
      
4763:    [ isFunc
4766:       | true :
               % push return value from temp
4767:          oTypeSPush( resultType )
      
4773:          [ oTypeSNodeType
4775:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4784:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4794:             | nCharType, nStringType, nFileType : #eNotImplemented
4798:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4808:             | * :              % compound type: push address
4823:                                .tPushAddrLocal  oEmitInt( tempOffset )
4831:          ]
4831:       | * :
4836:    ]
         
4836:    .tFreeActuals  oEmitInt( actualsSize )
4845:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4845: Statement:
4847:    [
4847:       | pWriteln :     @WritelnStmt
4851:       | pWrite :       @WriteStmt
4855:       | pReadln :      @ReadlnStmt
4859:       | pRead :        @ReadStmt
4863:       | pIf :          @IfStmt
4867:       | pWhile :       @WhileStmt
4871:       | pFor :         @ForStmt
4875:       | pRepeat :      @RepeatStmt
4879:       | pBreak :       @BreakStmt
4883:       | pContinue :    @ContinueStmt
4887:       | pBegin :       @BeginStmt
4891:       | pIdent :       @AssignOrCallStmt
4895:       | * :            % null statement : don't accept any tokens
4922:    ];
      
      
4923: AssignOrCallStmt:
4925:    Node decl = oScopeFindRequire
4930:    [ oNodeType( decl )
4937:       | nProc :                           @Call( decl )
4945:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4954:       | nFunc :                           @AssignResultStmt( decl )
4963:       | * :                               #eBadStatement
4978:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4979: AssignStmt( Node decl ):
      
4981:    @LValueVar( decl )
4988:    ':=' 
4990:    @Expr
4992:    @MatchTypes
4994:    @Assign
4997:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
4997: Assign:
4999:    [ oTypeSNodeType
5001:       | nIntegerType :            .tAssignI
5004:       | nBooleanType :            .tAssignB
5008:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5012:       | nPointerType :            .tAssignP
5016:       | * :
5031:           int size = oNodeGetInt( oTypeSTop, qSize )
5043:           .tCopy  oEmitInt( size )    % multi-word copy
5051:    ]
5051:    oTypeSPop
5053:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5053: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5055:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5071:       | false :   #eNotCurrentFunction
5074:       | * :
5079:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5079:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5094:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5107:    ':='
5109:    @Expr
5111:    @MatchTypes
5113:    [ oTypeSNodeType
5115:       | nIntegerType :            .tAssignI
5118:       | nBooleanType :            .tAssignB
5122:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5126:       | nPointerType :            .tAssignP
5130:       | * :
5145:           int size = oNodeGetInt( oTypeSTop, qSize )
5157:           .tCopy  oEmitInt( size )    % multi-word copy
5165:    ]
5165:    oTypeSPop
5167:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5167: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5169:    pIdent
5171:    Node decl = oScopeFindRequire
5176:    [ oNodeType( decl )
5183:       | nGlobalVar, nLocalVar, nParam :
5184:       | * :  #eNotVar
5195:    ]
5195:    @LValueVar( decl )
5203:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5203: LValueVar( Node decl ):
5205:    [ oNodeType( decl )
5212:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5222:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5233:       | nParam :
5235:          [ oNodeGetBoolean( decl, qInOut )
5245:             | true :   % VAR param points to variable.  No dereference.
5246:                        .tPushParamP @EmitValue( decl )
5255:             | * :      .tPushAddrParam @EmitValue( decl )
5269:          ]
5269:       | * :            #eNotVar
5280:    ]
      
5280:    oTypeSPush( oNodeGet( decl, qType ) )
5293:    @LValueIndexes        % handle subscripts, if any
5296:    ;
      
      
5296: IncVar( Node decl ):
5298:    @LValueVar( decl )
5305:    @RequireIntPop
5307:    @VarExpr( decl )
5314:    oTypeSPop
5315:    .tIncI
5317:    .tAssignI;
      
5320: DecVar( Node decl ):
5322:    @LValueVar( decl )
5329:    @RequireIntPop
5331:    @VarExpr( decl )
5338:    oTypeSPop
5339:    .tDecI
5341:    .tAssignI;
      
      
5344: IfStmt:
5346:    Label falseLabel = labelNull
      
5352:    @BooleanExprControlFlow( falseLabel )
5359:    pThen
5361:    @Statement
5363:    [
5363:       | pElse :
5365:          Label doneLabel = oLabelNew
      
5370:          .tJump  oEmitLabel( doneLabel )
5378:          .tLabel oEmitLabel( falseLabel )
5386:          @Statement
5388:          .tLabel oEmitLabel( doneLabel )
      
5396:       | * :
5401:          .tLabel oEmitLabel( falseLabel )
5409:    ];
      
      
5410: ForStmt:
5412:    pIdent
      
5414:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5419:    @LValueVar( decl )
5426:    @RequireIntPop
      
5428:    ':='
      
5430:    @Expr
5432:    @RequireIntPop
5434:    .tAssignI
      
5436:    Label breakLabel = oLabelNew
      
5441:    Label checkLabel = oLabelNew
5446:    .tJump  oEmitLabel( checkLabel )
      
5454:    Label continueLabel = oLabelNew
5459:    .tLabel  oEmitLabel( continueLabel )
5467:    [
5467:       | pTo :
5469:          @IncVar( decl )
5476:          .tLabel  oEmitLabel( checkLabel )
5484:          @VarExpr( decl )  oTypeSPop
5492:          @Expr
5494:          @RequireIntPop
5496:          .tGreaterI
5498:          .tJumpTrue  oEmitLabel( breakLabel )
5506:       | pDownto :
5508:          @DecVar( decl )
5515:          .tLabel  oEmitLabel( checkLabel )
5523:          @VarExpr( decl )  oTypeSPop
5531:          @Expr
5533:          @RequireIntPop
5535:          .tLessI
5537:          .tJumpTrue  oEmitLabel( breakLabel )
5545:    ]
5553:    oLoopPush( continueLabel, breakLabel )
5562:    pDo
5564:    @Statement
5566:    .tJump  oEmitLabel( continueLabel )
5574:    .tLabel  oEmitLabel( breakLabel )
5582:    oLoopPop;
      
      
5584: RepeatStmt:
5586:    Label continueLabel = oLabelNew
5591:    .tLabel  oEmitLabel( continueLabel )
      
5599:    Label breakLabel = oLabelNew
      
5604:    oLoopPush( continueLabel, breakLabel )
5613:    @Statement
5615:    {[
5615:       | ';' :
5617:          @Statement
5619:       | pUntil :
5621:          Label falseLabel
5621:          @BooleanExprControlFlow( falseLabel )
5628:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5642:          >
5644:    ]}
5654:    .tLabel  oEmitLabel( breakLabel )
5662:    oLoopPop;
      
      
5664: WhileStmt:
5666:    Label continueLabel = oLabelNew
5671:    .tLabel  oEmitLabel( continueLabel )
      
5679:    Label breakLabel
5679:    @BooleanExprControlFlow( breakLabel )
      
5686:    oLoopPush( continueLabel, breakLabel )
5695:    pDo
5697:    @Statement
5699:    .tJump  oEmitLabel( continueLabel )
5707:    .tLabel  oEmitLabel( breakLabel )
5715:    oLoopPop;
      
      
5717: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5719:    [ equal_label( oLoopContinueLabel, labelNull )
5728:       | true :
5729:          #eNotInALoop
5731:       | false :
5733:          .tJump  oEmitLabel( oLoopContinueLabel )
5740:    ];
      
      
5749: BreakStmt:
5751:    [ equal_label( oLoopBreakLabel, labelNull )
5760:       | true :
5761:          #eNotInALoop
5763:       | false :
5765:          .tJump  oEmitLabel( oLoopBreakLabel )
5772:    ];
      
      
5781: BeginStmt:
5783:    @Statement
5785:    {[
5785:       | ';' :   @Statement
5789:       | pEnd :  >
5793:    ]};
      
      
5804: WritelnStmt:
5806:    @WriteStmt
5808:    .tWriteCR;
      
      
5811: WriteStmt:
5813:    [
5813:       | '(' :
5815:          {
5815:             @Expr
5817:             [ oTypeSNodeType
5819:                | nIntegerType :             .tWriteI
5822:                | nBooleanType :             .tWriteBool
5826:                | nStringType :              .tWriteStr
5830:                | nCharType, nFileType :     #eNotImplemented
5834:                | nPointerType :             .tWriteP
5838:                | * :                        #eNotAllowed
5855:             ]
5855:             oTypeSPop
5856:             [
5856:                | ')' : >
5860:                | ',' :
5862:             ]
5870:          }
5872:       | * :
5877:    ];
      
      
5878: ReadlnStmt:      % ***
         % TO DO
5881:    ;
      
5881: ReadStmt:
         % TO DO
5884:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5884: MatchTypes:
5886:    node_type nt = oTypeSNodeType
5891:    oTypeSPop
5892:    [ equal_node_type( nt, oTypeSNodeType )
5901:       | false :
5902:          #eTypeMismatch
5904:       | * :
5909:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5910: RequireIntPop:
5912:    [ oTypeSNodeType
5914:       | nIntegerType :
5915:       | * :          #eNotInteger
5922:    ]
5922:    oTypeSPop;
      
5924: RequireInt:
5926:    [ oTypeSNodeType
5928:       | nIntegerType :
5929:       | * :          #eNotInteger
5936:    ];
      
5937: RequireBoolPop:
5939:    [ oTypeSNodeType
5941:       | nBooleanType :
5942:       | * :          #eNotBoolean
5949:    ]
5949:    oTypeSPop;
      
5951: RequireBool:
5953:    [ oTypeSNodeType
5955:       | nBooleanType :
5956:       | * :          #eNotBoolean
5963:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5964: newType( node_type nt, int size ) >> Node:
5966:   Node node = oNodeNew( nt )
5976:   oNodeSetInt( node, qSize, size )
5988:   oTypeAdd( node )
5994:   >> node
5998:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5998: newIdent( node_type nt, kind k, int id ) >> Node:
6000:   Node t = oNodeNew( nt )
6010:   oNodeSetInt( t, qIdent, id )
6022:   >> t
6026:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6026: PointerTypeTo( Node theType ) >> Node:
6028:    Node ptrType = oNodeGet( theType, qPointerType )
6041:    [ oNodeNull( ptrType )
6048:       | true :
6049:          ptrType = oNodeNew( nPointerType )
6059:          oNodeSet( ptrType, qBaseType, theType )
6071:          oNodeSetInt( ptrType, qSize, 8 )
6083:          oTypeAdd( ptrType )
6089:          oNodeSet( theType, qPointerType, ptrType )
6101:       | * :
6106:    ]
6106:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6110: OrdinalLow( Node theType ) >> int:
6112:    [ oNodeType( theType )
6119:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
6122:       | nBooleanType :  >> 0
6127:       | nCharType :     >> 0
6132:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6144:       | * :             #eNotOrdinalType
6157:                         >> 0
6160:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6161: EmitValue( Node decl ):
6163:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6177: installBuiltIns:
      
         % install built-in types
6179:    FileType = @newType( nFileType, 4 )
6193:    IntegerType = @newType( nIntegerType, 4 )
6207:    BooleanType = @newType( nBooleanType, 1 )
6221:    BooleanCFType = @newType( nBooleanCFType, 1 )
6235:    CharType = @newType( nCharType, 1 )
6249:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6263:    Node t
      
6263:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6279:    oNodeSet( t, qType, FileType )
6291:    oScopeDeclare( t )
      
6297:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6313:    oNodeSet( t, qType, IntegerType )
6325:    oScopeDeclare( t )
      
6331:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6347:    oNodeSet( t, qType, BooleanType )
6359:    oScopeDeclare( t )
      
6365:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6381:    oNodeSet( t, qType, CharType )
6393:    oScopeDeclare( t )
      
6399:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6415:    oNodeSet( t, qType, StringType )
6427:    oScopeDeclare( t )
      
         % Built-in constants
      
6433:    t = @newIdent( nConst, kConst, oIdAdd_True )
6449:    oNodeSet( t, qType, BooleanType )
6461:    oNodeSetInt( t, qValue, 1 )
6473:    oScopeDeclare( t )
      
6479:    t = @newIdent( nConst, kConst, oIdAdd_False )
6495:    oNodeSet( t, qType, BooleanType )
6507:    oNodeSetInt( t, qValue, 0 )
6519:    oScopeDeclare( t )
      
6526:    ;
      
6526: end
      
6526: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 6177
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5998
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5998
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 6
 102: oPushResult
 103: oGetGlobal 3
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5998
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 6
 140: oPushResult
 141: oGetGlobal 3
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oScopeBegin
 163: oGetAddrGlobal 2
 165: oPushResult
 166: oScopeCurrent
 167: oAssign
 168: oScopeCurrent
 169: oPushResult
 170: oSetResult 3
 172: oPushResult
 173: oSetResult 1
 175: oPushResult
 176: oNodeSetBoolean
 177: oPop 3
 179: oGetLocal 3
 181: oPushResult
 182: oSetResult 8
 184: oPushResult
 185: oScopeCurrent
 186: oPushResult
 187: oNodeSet
 188: oPop 3
 190: oScopeEnd
 191: oSetResult 12
 193: oPushResult
 194: oCall 238
 196: oPop 1
 198: oGetGlobal 2
 200: oPushResult
 201: oScopeEnter
 202: oPop 1
 204: oGetLocal 2
 206: oPushResult
 207: oGetGlobal 1
 209: oPushResult
 210: oCall 288
 212: oPop 2
 214: oScopeEnd
 215: oInput 19
 217: oScopeEnd
 218: oReturn
 219: oLocalSpace 0
 221: oGetParam 2
 223: oPushResult
 224: oCall 238
 226: oPop 1
 228: oGetParam 1
 230: oPushResult
 231: oScopeCurrent
 232: oPushResult
 233: oCall 288
 235: oPop 2
 237: oReturn
 238: oLocalSpace 0
 240: oInputChoice 267
 242: oCall 1341
 244: oJumpForward 280
 246: oCall 1413
 248: oJumpForward 280
 250: oGetParam 1
 252: oPushResult
 253: oCall 1472
 255: oPop 1
 257: oJumpForward 280
 259: oCall 483
 261: oJumpForward 280
 263: oCall 768
 265: oJumpForward 280
 267: Choice Lookup Table
          29    263
          28    259
          32    250
          31    246
          30    242
 278: oJumpForward 282
 280: oJumpBack 240
 282: oCall 285
 284: oReturn
 285: oLocalSpace 0
 287: oReturn
 288: oLocalSpace 3
 290: oEmit 48
 292: oGetParam 2
 294: oPushResult
 295: oEmitLabel
 296: oPop 1
 298: oEmit 44
 300: oGetAddrLocal 1
 302: oPushResult
 303: Here
 304: oAssign
 305: oEmit 56
 307: oGetAddrLocal 2
 309: oPushResult
 310: oGetParam 1
 312: oPushResult
 313: oSetResult 4
 315: oPushResult
 316: oNodeGetCode
 317: oPop 2
 319: oAssign
 320: oGetLocal 2
 322: oPushResult
 323: oEmitCode
 324: oPop 1
 326: oScopeCurrent
 327: oPushResult
 328: oSetResult 4
 330: oPushResult
 331: oSetResult 0
 333: oPushResult
 334: oNodeSetCode
 335: oPop 3
 337: oCall 4845
 339: oEmit 43
 341: oGetAddrLocal 3
 343: oPushResult
 344: oScopeCurrent
 345: oPushResult
 346: oSetResult 2
 348: oPushResult
 349: oNodeGetInt
 350: oPop 2
 352: oAssign
 353: oGetLocal 1
 355: oPushResult
 356: oGetLocal 3
 358: oPushResult
 359: oPatch
 360: oPop 2
 362: oReturn
 363: oLocalSpace 0
 365: oInputChoice 383
 367: oGetParam 1
 369: oPushResult
 370: oSetResult 14
 372: oPushResult
 373: oSetResult 1
 375: oPushResult
 376: oNodeSetBoolean
 377: oPop 3
 379: oInput 4
 381: oJumpForward 388
 383: Choice Lookup Table
          61    367
 386: oJumpForward 390
 388: oJumpBack 365
 390: oReturn
 391: oLocalSpace 1
 393: oGetAddrLocal 1
 395: oPushResult
 396: oScopeCurrent
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oNodeGetCode
 402: oPop 2
 404: oAssign
 405: oGetLocal 1
 407: oPushResult
 408: oSetResult 0
 410: oPushResult
 411: equal_code
 412: oPop 2
 414: oChoice 434
 416: oGetAddrLocal 1
 418: oPushResult
 419: oCodeNew
 420: oAssign
 421: oScopeCurrent
 422: oPushResult
 423: oSetResult 4
 425: oPushResult
 426: oGetLocal 1
 428: oPushResult
 429: oNodeSetCode
 430: oPop 3
 432: oJumpForward 437
 434: Choice Lookup Table
           1    416
 437: oGetLocal 1
 439: oReturn
 440: oReturn
 441: oLocalSpace 0
 443: oGetParam 1
 445: oPushResult
 446: oSetResult 12
 448: oPushResult
 449: oSetResult 1
 451: oPushResult
 452: oNodeSetBoolean
 453: oPop 3
 455: oInputChoice 479
 457: oInputChoice 474
 459: oInput 2
 461: oGetParam 1
 463: oPushResult
 464: oSetResult 13
 466: oPushResult
 467: CURRENT_STRLIT
 468: oPushResult
 469: oNodeSetString
 470: oPop 3
 472: oJumpForward 477
 474: Choice Lookup Table
          60    459
 477: oJumpForward 482
 479: Choice Lookup Table
           2    457
 482: oReturn
 483: oLocalSpace 4
 485: oInput 0
 487: oGetAddrLocal 1
 489: oPushResult
 490: oSetResult 0
 492: oAssign
 493: oGetAddrLocal 2
 495: oPushResult
 496: oScopeFindInCurrentScope
 497: oAssign
 498: oGetLocal 2
 500: oPushResult
 501: oNodeNull
 502: oPop 1
 504: oChoice 625
 506: oGetAddrLocal 2
 508: oPushResult
 509: oSetResult 7
 511: oPushResult
 512: oSetResult 2
 514: oPushResult
 515: LAST_ID
 516: oPushResult
 517: oCall 5998
 519: oPop 3
 521: oAssign
 522: oGetLocal 2
 524: oPushResult
 525: oSetResult 7
 527: oPushResult
 528: oLabelNew
 529: oPushResult
 530: oNodeSetLabel
 531: oPop 3
 533: oJumpForward 631
 535: oGetAddrLocal 1
 537: oPushResult
 538: oSetResult 1
 540: oAssign
 541: oGetLocal 2
 543: oPushResult
 544: oSetResult 11
 546: oPushResult
 547: oNodeGetBoolean
 548: oPop 2
 550: oChoice 556
 552: oError 21
 554: oJumpForward 559
 556: Choice Lookup Table
           1    552
 559: oGetLocal 2
 561: oPushResult
 562: oSetResult 12
 564: oPushResult
 565: oNodeGetBoolean
 566: oPop 2
 568: oChoice 574
 570: oError 21
 572: oJumpForward 577
 574: Choice Lookup Table
           1    570
 577: oGetLocal 2
 579: oPushResult
 580: oNodeType
 581: oPop 1
 583: oChoice 587
 585: oJumpForward 592
 587: Choice Lookup Table
           7    585
 590: oError 21
 592: oGetLocal 2
 594: oPushResult
 595: oSetResult 16
 597: oPushResult
 598: oGetLocal 2
 600: oPushResult
 601: oSetResult 9
 603: oPushResult
 604: oNodeGet
 605: oPop 2
 607: oPushResult
 608: oNodeSet
 609: oPop 3
 611: oGetLocal 2
 613: oPushResult
 614: oSetResult 9
 616: oPushResult
 617: oSetResult 0
 619: oPushResult
 620: oNodeSet
 621: oPop 3
 623: oJumpForward 631
 625: Choice Lookup Table
           0    535
           1    506
 630: oEndChoice
 631: oScopeBegin
 632: oGetAddrLocal 3
 634: oPushResult
 635: oScopeCurrent
 636: oAssign
 637: oCall 1114
 639: oGetLocal 2
 641: oPushResult
 642: oSetResult 9
 644: oPushResult
 645: oGetLocal 3
 647: oPushResult
 648: oNodeSet
 649: oPop 3
 651: oScopeEnd
 652: oInput 4
 654: oGetLocal 1
 656: oChoice 668
 658: oGetLocal 2
 660: oPushResult
 661: oScopeDeclare
 662: oPop 1
 664: oJumpForward 674
 666: oJumpForward 674
 668: Choice Lookup Table
           1    666
           0    658
 673: oEndChoice
 674: oGetLocal 2
 676: oPushResult
 677: oCall 363
 679: oPop 1
 681: oInputChoice 694
 683: oJumpForward 765
 685: oGetLocal 2
 687: oPushResult
 688: oCall 441
 690: oPop 1
 692: oJumpForward 765
 694: Choice Lookup Table
          59    685
          58    683
 699: oGetLocal 3
 701: oPushResult
 702: oScopeEnter
 703: oPop 1
 705: oScopeBegin
 706: oScopeCurrent
 707: oPushResult
 708: oSetResult 3
 710: oPushResult
 711: oSetResult 1
 713: oPushResult
 714: oNodeSetBoolean
 715: oPop 3
 717: oGetLocal 2
 719: oPushResult
 720: oSetResult 10
 722: oPushResult
 723: oScopeCurrent
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oGetAddrLocal 4
 730: oPushResult
 731: oGetLocal 2
 733: oPushResult
 734: oSetResult 7
 736: oPushResult
 737: oNodeGetLabel
 738: oPop 2
 740: oAssign
 741: oSetResult 13
 743: oPushResult
 744: oGetLocal 4
 746: oPushResult
 747: oCall 219
 749: oPop 2
 751: oGetLocal 2
 753: oPushResult
 754: oSetResult 11
 756: oPushResult
 757: oSetResult 1
 759: oPushResult
 760: oNodeSetBoolean
 761: oPop 3
 763: oScopeEnd
 764: oScopeEnd
 765: oInput 4
 767: oReturn
 768: oLocalSpace 6
 770: oInput 0
 772: oGetAddrLocal 1
 774: oPushResult
 775: oSetResult 0
 777: oAssign
 778: oGetAddrLocal 2
 780: oPushResult
 781: oScopeFindInCurrentScope
 782: oAssign
 783: oGetLocal 2
 785: oPushResult
 786: oNodeNull
 787: oPop 1
 789: oChoice 923
 791: oGetAddrLocal 2
 793: oPushResult
 794: oSetResult 8
 796: oPushResult
 797: oSetResult 3
 799: oPushResult
 800: LAST_ID
 801: oPushResult
 802: oCall 5998
 804: oPop 3
 806: oAssign
 807: oGetLocal 2
 809: oPushResult
 810: oSetResult 7
 812: oPushResult
 813: oLabelNew
 814: oPushResult
 815: oNodeSetLabel
 816: oPop 3
 818: oJumpForward 929
 820: oGetAddrLocal 1
 822: oPushResult
 823: oSetResult 1
 825: oAssign
 826: oGetLocal 2
 828: oPushResult
 829: oSetResult 11
 831: oPushResult
 832: oNodeGetBoolean
 833: oPop 2
 835: oChoice 841
 837: oError 21
 839: oJumpForward 844
 841: Choice Lookup Table
           1    837
 844: oGetLocal 2
 846: oPushResult
 847: oNodeType
 848: oPop 1
 850: oChoice 854
 852: oJumpForward 859
 854: Choice Lookup Table
           8    852
 857: oError 21
 859: oGetLocal 2
 861: oPushResult
 862: oSetResult 16
 864: oPushResult
 865: oGetLocal 2
 867: oPushResult
 868: oSetResult 9
 870: oPushResult
 871: oNodeGet
 872: oPop 2
 874: oPushResult
 875: oNodeSet
 876: oPop 3
 878: oGetLocal 2
 880: oPushResult
 881: oSetResult 9
 883: oPushResult
 884: oSetResult 0
 886: oPushResult
 887: oNodeSet
 888: oPop 3
 890: oGetLocal 2
 892: oPushResult
 893: oSetResult 17
 895: oPushResult
 896: oGetLocal 2
 898: oPushResult
 899: oSetResult 6
 901: oPushResult
 902: oNodeGet
 903: oPop 2
 905: oPushResult
 906: oNodeSet
 907: oPop 3
 909: oGetLocal 2
 911: oPushResult
 912: oSetResult 6
 914: oPushResult
 915: oSetResult 0
 917: oPushResult
 918: oNodeSet
 919: oPop 3
 921: oJumpForward 929
 923: Choice Lookup Table
           0    820
           1    791
 928: oEndChoice
 929: oScopeBegin
 930: oGetAddrLocal 3
 932: oPushResult
 933: oScopeCurrent
 934: oAssign
 935: oCall 1114
 937: oGetLocal 2
 939: oPushResult
 940: oSetResult 9
 942: oPushResult
 943: oGetLocal 3
 945: oPushResult
 946: oNodeSet
 947: oPop 3
 949: oInput 11
 951: oGetAddrLocal 4
 953: oPushResult
 954: oCall 1704
 956: oPop 1
 958: oGetLocal 2
 960: oPushResult
 961: oSetResult 6
 963: oPushResult
 964: oGetLocal 4
 966: oPushResult
 967: oNodeSet
 968: oPop 3
 970: oGetAddrLocal 5
 972: oPushResult
 973: oGetLocal 4
 975: oPushResult
 976: oCall 6026
 978: oPop 1
 980: oAssign
 981: oGetLocal 2
 983: oPushResult
 984: oSetResult 18
 986: oPushResult
 987: oGetLocal 5
 989: oPushResult
 990: oScopeAllocType
 991: oPop 1
 993: oPushResult
 994: oNodeSetInt
 995: oPop 3
 997: oScopeEnd
 998: oInput 4
1000: oGetLocal 1
1002: oChoice 1014
1004: oGetLocal 2
1006: oPushResult
1007: oScopeDeclare
1008: oPop 1
1010: oJumpForward 1020
1012: oJumpForward 1020
1014: Choice Lookup Table
           1   1012
           0   1004
1019: oEndChoice
1020: oGetLocal 2
1022: oPushResult
1023: oCall 363
1025: oPop 1
1027: oInputChoice 1040
1029: oJumpForward 1111
1031: oGetLocal 2
1033: oPushResult
1034: oCall 441
1036: oPop 1
1038: oJumpForward 1111
1040: Choice Lookup Table
          59   1031
          58   1029
1045: oGetLocal 3
1047: oPushResult
1048: oScopeEnter
1049: oPop 1
1051: oScopeBegin
1052: oScopeCurrent
1053: oPushResult
1054: oSetResult 3
1056: oPushResult
1057: oSetResult 1
1059: oPushResult
1060: oNodeSetBoolean
1061: oPop 3
1063: oGetLocal 2
1065: oPushResult
1066: oSetResult 10
1068: oPushResult
1069: oScopeCurrent
1070: oPushResult
1071: oNodeSet
1072: oPop 3
1074: oGetAddrLocal 6
1076: oPushResult
1077: oGetLocal 2
1079: oPushResult
1080: oSetResult 7
1082: oPushResult
1083: oNodeGetLabel
1084: oPop 2
1086: oAssign
1087: oSetResult 13
1089: oPushResult
1090: oGetLocal 6
1092: oPushResult
1093: oCall 219
1095: oPop 2
1097: oGetLocal 2
1099: oPushResult
1100: oSetResult 11
1102: oPushResult
1103: oSetResult 1
1105: oPushResult
1106: oNodeSetBoolean
1107: oPop 3
1109: oScopeEnd
1110: oScopeEnd
1111: oInput 4
1113: oReturn
1114: oLocalSpace 6
1116: oInputChoice 1337
1118: oGetAddrLocal 1
1120: oPushResult
1121: oNodeVecNew
1122: oAssign
1123: oGetAddrLocal 3
1125: oPushResult
1126: oSetResult 0
1128: oAssign
1129: oInputChoice 1139
1131: oGetAddrLocal 3
1133: oPushResult
1134: oSetResult 1
1136: oAssign
1137: oJumpForward 1142
1139: Choice Lookup Table
          32   1131
1142: oInput 0
1144: oGetAddrLocal 2
1146: oPushResult
1147: oSetResult 15
1149: oPushResult
1150: oSetResult 6
1152: oPushResult
1153: LAST_ID
1154: oPushResult
1155: oCall 5998
1157: oPop 3
1159: oAssign
1160: oGetLocal 2
1162: oPushResult
1163: oSetResult 19
1165: oPushResult
1166: oGetLocal 3
1168: oPushResult
1169: oNodeSetBoolean
1170: oPop 3
1172: oGetLocal 1
1174: oPushResult
1175: oGetLocal 2
1177: oPushResult
1178: oNodeVecAppend
1179: oPop 2
1181: oInputChoice 1189
1183: oJumpForward 1197
1185: oJumpForward 1195
1187: oJumpForward 1195
1189: Choice Lookup Table
          12   1187
          11   1183
1194: oEndChoice
1195: oJumpBack 1142
1197: oGetAddrLocal 4
1199: oPushResult
1200: oCall 1704
1202: oPop 1
1204: oGetLocal 3
1206: oChoice 1221
1208: oGetAddrLocal 5
1210: oPushResult
1211: oGetLocal 4
1213: oPushResult
1214: oCall 6026
1216: oPop 1
1218: oAssign
1219: oJumpForward 1230
1221: Choice Lookup Table
           1   1208
1224: oGetAddrLocal 5
1226: oPushResult
1227: oGetLocal 4
1229: oAssign
1230: oGetAddrLocal 6
1232: oPushResult
1233: oSetResult 0
1235: oAssign
1236: oGetLocal 6
1238: oPushResult
1239: oGetLocal 1
1241: oPushResult
1242: oNodeVecSize
1243: oPop 1
1245: oPushResult
1246: equal
1247: oPop 2
1249: oChoice 1306
1251: oGetAddrLocal 2
1253: oPushResult
1254: oGetLocal 1
1256: oPushResult
1257: oGetLocal 6
1259: oPushResult
1260: oNodeVecElement
1261: oPop 2
1263: oAssign
1264: oGetLocal 2
1266: oPushResult
1267: oSetResult 6
1269: oPushResult
1270: oGetLocal 4
1272: oPushResult
1273: oNodeSet
1274: oPop 3
1276: oGetLocal 2
1278: oPushResult
1279: oScopeDeclare
1280: oPop 1
1282: oGetLocal 2
1284: oPushResult
1285: oSetResult 7
1287: oPushResult
1288: oGetLocal 5
1290: oPushResult
1291: oScopeAllocType
1292: oPop 1
1294: oPushResult
1295: oNodeSetInt
1296: oPop 3
1298: oGetAddrLocal 6
1300: oPushResult
1301: inc
1302: oPop 1
1304: oJumpForward 1311
1306: Choice Lookup Table
           0   1251
1309: oJumpForward 1313
1311: oJumpBack 1236
1313: oGetLocal 1
1315: oPushResult
1316: oNodeVecDelete
1317: oPop 1
1319: oInputChoice 1327
1321: oJumpForward 1335
1323: oJumpForward 1333
1325: oJumpForward 1333
1327: Choice Lookup Table
           4   1325
          14   1321
1332: oEndChoice
1333: oJumpBack 1118
1335: oJumpForward 1340
1337: Choice Lookup Table
          13   1118
1340: oReturn
1341: oLocalSpace 2
1343: oInputChoice 1405
1345: oGetAddrLocal 1
1347: oPushResult
1348: oSetResult 9
1350: oPushResult
1351: oSetResult 4
1353: oPushResult
1354: LAST_ID
1355: oPushResult
1356: oCall 5998
1358: oPop 3
1360: oAssign
1361: oInput 5
1363: oCall 2173
1365: oGetAddrLocal 2
1367: oPushResult
1368: oValueTop
1369: oAssign
1370: oValuePop
1371: oGetLocal 1
1373: oPushResult
1374: oSetResult 7
1376: oPushResult
1377: oGetLocal 2
1379: oPushResult
1380: oNodeSetInt
1381: oPop 3
1383: oGetLocal 1
1385: oPushResult
1386: oSetResult 6
1388: oPushResult
1389: oGetGlobal 4
1391: oPushResult
1392: oNodeSet
1393: oPop 3
1395: oGetLocal 1
1397: oPushResult
1398: oScopeDeclare
1399: oPop 1
1401: oInput 4
1403: oJumpForward 1410
1405: Choice Lookup Table
           0   1345
1408: oJumpForward 1412
1410: oJumpBack 1343
1412: oReturn
1413: oLocalSpace 2
1415: oInputChoice 1464
1417: oGetAddrLocal 1
1419: oPushResult
1420: oSetResult 10
1422: oPushResult
1423: oSetResult 5
1425: oPushResult
1426: LAST_ID
1427: oPushResult
1428: oCall 5998
1430: oPop 3
1432: oAssign
1433: oInput 5
1435: oGetAddrLocal 2
1437: oPushResult
1438: oCall 1704
1440: oPop 1
1442: oGetLocal 1
1444: oPushResult
1445: oSetResult 6
1447: oPushResult
1448: oGetLocal 2
1450: oPushResult
1451: oNodeSet
1452: oPop 3
1454: oGetLocal 1
1456: oPushResult
1457: oScopeDeclare
1458: oPop 1
1460: oInput 4
1462: oJumpForward 1469
1464: Choice Lookup Table
           0   1417
1467: oJumpForward 1471
1469: oJumpBack 1415
1471: oReturn
1472: oLocalSpace 6
1474: oInputChoice 1696
1476: oGetAddrLocal 1
1478: oPushResult
1479: oNodeVecNew
1480: oAssign
1481: oGetAddrLocal 2
1483: oPushResult
1484: oGetParam 1
1486: oPushResult
1487: oSetResult 6
1489: oPushResult
1490: LAST_ID
1491: oPushResult
1492: oCall 5998
1494: oPop 3
1496: oAssign
1497: oGetLocal 1
1499: oPushResult
1500: oGetLocal 2
1502: oPushResult
1503: oNodeVecAppend
1504: oPop 2
1506: oInputChoice 1512
1508: oInput 0
1510: oJumpForward 1517
1512: Choice Lookup Table
          12   1508
1515: oJumpForward 1519
1517: oJumpBack 1481
1519: oInput 11
1521: oGetAddrLocal 3
1523: oPushResult
1524: oCall 1704
1526: oPop 1
1528: oGetAddrLocal 4
1530: oPushResult
1531: oSetResult 0
1533: oAssign
1534: oGetLocal 4
1536: oPushResult
1537: oGetLocal 1
1539: oPushResult
1540: oNodeVecSize
1541: oPop 1
1543: oPushResult
1544: equal
1545: oPop 2
1547: oChoice 1588
1549: oGetAddrLocal 2
1551: oPushResult
1552: oGetLocal 1
1554: oPushResult
1555: oGetLocal 4
1557: oPushResult
1558: oNodeVecElement
1559: oPop 2
1561: oAssign
1562: oGetLocal 2
1564: oPushResult
1565: oSetResult 6
1567: oPushResult
1568: oGetLocal 3
1570: oPushResult
1571: oNodeSet
1572: oPop 3
1574: oGetLocal 2
1576: oPushResult
1577: oScopeDeclareAlloc
1578: oPop 1
1580: oGetAddrLocal 4
1582: oPushResult
1583: inc
1584: oPop 1
1586: oJumpForward 1593
1588: Choice Lookup Table
           0   1549
1591: oJumpForward 1595
1593: oJumpBack 1534
1595: oInputChoice 1683
1597: oGetLocal 1
1599: oPushResult
1600: oNodeVecSize
1601: oPop 1
1603: oChoice 1607
1605: oJumpForward 1612
1607: Choice Lookup Table
           1   1605
1610: oError 22
1612: oGetAddrLocal 5
1614: oPushResult
1615: oCall 391
1617: oAssign
1618: oGetLocal 5
1620: oPushResult
1621: oCodePush
1622: oPop 1
1624: oGetAddrLocal 6
1626: oPushResult
1627: oSetResult 0
1629: oAssign
1630: oScopeCurrent
1631: oPushResult
1632: oGetGlobal 1
1634: oPushResult
1635: equal_node
1636: oPop 2
1638: oChoice 1654
1640: oGetGlobal 2
1642: oPushResult
1643: oScopeEnter
1644: oPop 1
1646: oGetAddrLocal 6
1648: oPushResult
1649: oSetResult 1
1651: oAssign
1652: oJumpForward 1657
1654: Choice Lookup Table
           1   1640
1657: oGetLocal 2
1659: oPushResult
1660: oCall 5203
1662: oPop 1
1664: oCall 2239
1666: oCall 5884
1668: oCall 4997
1670: oGetLocal 6
1672: oChoice 1677
1674: oScopeEnd
1675: oJumpForward 1680
1677: Choice Lookup Table
           1   1674
1680: oCodePop
1681: oJumpForward 1686
1683: Choice Lookup Table
           5   1597
1686: oGetLocal 1
1688: oPushResult
1689: oNodeVecDelete
1690: oPop 1
1692: oInput 4
1694: oJumpForward 1701
1696: Choice Lookup Table
           0   1476
1699: oJumpForward 1703
1701: oJumpBack 1474
1703: oReturn
1704: oLocalSpace 12
1706: oInputChoice 2155
1708: oGetAddrLocal 1
1710: oPushResult
1711: oScopeFindRequire
1712: oAssign
1713: oGetLocal 1
1715: oPushResult
1716: oNodeType
1717: oPop 1
1719: oChoice 1736
1721: oGetParam 1
1723: oPushResult
1724: oGetLocal 1
1726: oPushResult
1727: oSetResult 6
1729: oPushResult
1730: oNodeGet
1731: oPop 2
1733: oAssign
1734: oJumpForward 1747
1736: Choice Lookup Table
          10   1721
1739: oError 2
1741: oGetParam 1
1743: oPushResult
1744: oGetGlobal 4
1746: oAssign
1747: oJumpForward 2172
1749: oInput 15
1751: oGetAddrLocal 2
1753: oPushResult
1754: oNodeVecNew
1755: oAssign
1756: oGetAddrLocal 3
1758: oPushResult
1759: oSetResult 25
1761: oPushResult
1762: oNodeNew
1763: oPop 1
1765: oAssign
1766: oGetLocal 3
1768: oPushResult
1769: oSetResult 21
1771: oPushResult
1772: oGetGlobal 4
1774: oPushResult
1775: oNodeSet
1776: oPop 3
1778: oCall 2173
1780: oGetLocal 3
1782: oPushResult
1783: oSetResult 23
1785: oPushResult
1786: oValueTop
1787: oPushResult
1788: oNodeSetInt
1789: oPop 3
1791: oValuePop
1792: oInput 20
1794: oCall 2173
1796: oGetLocal 3
1798: oPushResult
1799: oSetResult 24
1801: oPushResult
1802: oValueTop
1803: oPushResult
1804: oNodeSetInt
1805: oPop 3
1807: oValuePop
1808: oGetLocal 3
1810: oPushResult
1811: oSetResult 2
1813: oPushResult
1814: oSetResult 4
1816: oPushResult
1817: oNodeSetInt
1818: oPop 3
1820: oGetLocal 3
1822: oPushResult
1823: oTypeAdd
1824: oPop 1
1826: oGetAddrLocal 4
1828: oPushResult
1829: oSetResult 24
1831: oPushResult
1832: oNodeNew
1833: oPop 1
1835: oAssign
1836: oGetLocal 4
1838: oPushResult
1839: oSetResult 22
1841: oPushResult
1842: oGetLocal 3
1844: oPushResult
1845: oNodeSet
1846: oPop 3
1848: oGetLocal 2
1850: oPushResult
1851: oGetLocal 4
1853: oPushResult
1854: oNodeVecAppend
1855: oPop 2
1857: oInputChoice 1865
1859: oJumpForward 1873
1861: oJumpForward 1871
1863: oJumpForward 1871
1865: Choice Lookup Table
          12   1863
          16   1859
1870: oEndChoice
1871: oJumpBack 1756
1873: oInput 38
1875: oGetAddrLocal 5
1877: oPushResult
1878: oCall 1704
1880: oPop 1
1882: oGetAddrLocal 6
1884: oPushResult
1885: oGetLocal 2
1887: oPushResult
1888: oNodeVecSize
1889: oPop 1
1891: oAssign
1892: oGetAddrLocal 6
1894: oPushResult
1895: dec
1896: oPop 1
1898: oGetAddrLocal 7
1900: oPushResult
1901: oGetLocal 2
1903: oPushResult
1904: oGetLocal 6
1906: oPushResult
1907: oNodeVecElement
1908: oPop 2
1910: oAssign
1911: oGetLocal 7
1913: oPushResult
1914: oSetResult 21
1916: oPushResult
1917: oGetLocal 5
1919: oPushResult
1920: oNodeSet
1921: oPop 3
1923: oGetAddrLocal 8
1925: oPushResult
1926: oGetLocal 7
1928: oPushResult
1929: oSetResult 22
1931: oPushResult
1932: oNodeGet
1933: oPop 2
1935: oAssign
1936: oGetAddrLocal 9
1938: oPushResult
1939: oGetLocal 8
1941: oPushResult
1942: oSetResult 24
1944: oPushResult
1945: oNodeGetInt
1946: oPop 2
1948: oPushResult
1949: oGetLocal 8
1951: oPushResult
1952: oSetResult 23
1954: oPushResult
1955: oNodeGetInt
1956: oPop 2
1958: oPushResult
1959: subtract
1960: oPop 2
1962: oAssign
1963: oGetAddrLocal 9
1965: oPushResult
1966: inc
1967: oPop 1
1969: oGetLocal 7
1971: oPushResult
1972: oSetResult 2
1974: oPushResult
1975: oGetLocal 9
1977: oPushResult
1978: oGetLocal 5
1980: oPushResult
1981: oSetResult 2
1983: oPushResult
1984: oNodeGetInt
1985: oPop 2
1987: oPushResult
1988: multiply
1989: oPop 2
1991: oPushResult
1992: oNodeSetInt
1993: oPop 3
1995: oGetLocal 7
1997: oPushResult
1998: oTypeAdd
1999: oPop 1
2001: oGetAddrLocal 5
2003: oPushResult
2004: oGetLocal 7
2006: oAssign
2007: oGetLocal 6
2009: oPushResult
2010: equal_zero
2011: oPop 1
2013: oChoice 2019
2015: oJumpForward 2024
2017: oJumpForward 2022
2019: Choice Lookup Table
           1   2015
2022: oJumpBack 1892
2024: oGetParam 1
2026: oPushResult
2027: oGetLocal 2
2029: oPushResult
2030: oSetResult 0
2032: oPushResult
2033: oNodeVecElement
2034: oPop 2
2036: oAssign
2037: oGetLocal 2
2039: oPushResult
2040: oNodeVecDelete
2041: oPop 1
2043: oJumpForward 2172
2045: oGetAddrLocal 10
2047: oPushResult
2048: oCall 1704
2050: oPop 1
2052: oGetParam 1
2054: oPushResult
2055: oGetLocal 10
2057: oPushResult
2058: oCall 6026
2060: oPop 1
2062: oAssign
2063: oJumpForward 2172
2065: oGetParam 1
2067: oPushResult
2068: oSetResult 26
2070: oPushResult
2071: oNodeNew
2072: oPop 1
2074: oAssign
2075: oScopeBegin
2076: oSetResult 14
2078: oPushResult
2079: oCall 1472
2081: oPop 1
2083: oGetAddrLocal 11
2085: oPushResult
2086: oScopeCurrent
2087: oPushResult
2088: oSetResult 2
2090: oPushResult
2091: oNodeGetInt
2092: oPop 2
2094: oAssign
2095: oGetLocal 11
2097: oPushResult
2098: equal_zero
2099: oPop 1
2101: oChoice 2107
2103: oError 19
2105: oJumpForward 2110
2107: Choice Lookup Table
           1   2103
2110: oInput 34
2112: oGetFromParam 1
2114: oPushResult
2115: oSetResult 25
2117: oPushResult
2118: oScopeCurrent
2119: oPushResult
2120: oNodeSet
2121: oPop 3
2123: oGetFromParam 1
2125: oPushResult
2126: oSetResult 2
2128: oPushResult
2129: oGetLocal 11
2131: oPushResult
2132: oNodeSetInt
2133: oPop 3
2135: oScopeEnd
2136: oGetFromParam 1
2138: oPushResult
2139: oTypeAdd
2140: oPop 1
2142: oJumpForward 2172
2144: oInput 38
2146: oGetAddrLocal 12
2148: oPushResult
2149: oCall 1704
2151: oPop 1
2153: oJumpForward 2172
2155: Choice Lookup Table
          37   2144
          36   2065
          17   2045
          35   1749
           0   1708
2166: oCall 2173
2168: oInput 20
2170: oCall 2173
2172: oReturn
2173: oLocalSpace 1
2175: oInputChoice 2230
2177: TOKEN_VALUE
2178: oPushResult
2179: oValuePush
2180: oPop 1
2182: oJumpForward 2238
2184: oGetAddrLocal 1
2186: oPushResult
2187: oScopeFindRequire
2188: oAssign
2189: oGetLocal 1
2191: oPushResult
2192: oNodeType
2193: oPop 1
2195: oChoice 2212
2197: oGetLocal 1
2199: oPushResult
2200: oSetResult 7
2202: oPushResult
2203: oNodeGetInt
2204: oPop 2
2206: oPushResult
2207: oValuePush
2208: oPop 1
2210: oJumpForward 2223
2212: Choice Lookup Table
           9   2197
2215: oError 1
2217: oSetResult 0
2219: oPushResult
2220: oValuePush
2221: oPop 1
2223: oJumpForward 2238
2225: oCall 2173
2227: oValueNegate
2228: oJumpForward 2238
2230: Choice Lookup Table
          24   2225
           0   2184
           1   2177
2237: oEndChoice
2238: oReturn
2239: oLocalSpace 1
2241: oGetAddrLocal 1
2243: oPushResult
2244: oSetResult 0
2246: oAssign
2247: oGetAddrLocal 1
2249: oPushResult
2250: oCall 2400
2252: oPop 1
2254: oGetAddrLocal 1
2256: oPushResult
2257: oCall 2300
2259: oPop 1
2261: oReturn
2262: oLocalSpace 0
2264: oGetParam 1
2266: oPushResult
2267: oCall 2400
2269: oPop 1
2271: oTypeSNodeType
2272: oChoice 2291
2274: oJumpForward 2298
2276: oGetParam 1
2278: oPushResult
2279: oLabelNew
2280: oAssign
2281: oEmit 47
2283: oGetFromParam 1
2285: oPushResult
2286: oEmitLabel
2287: oPop 1
2289: oJumpForward 2298
2291: Choice Lookup Table
          19   2276
          20   2274
2296: oError 8
2298: oTypeSPop
2299: oReturn
2300: oLocalSpace 1
2302: oTypeSNodeType
2303: oChoice 2365
2305: oGetAddrLocal 1
2307: oPushResult
2308: oLabelNew
2309: oAssign
2310: oEmit 9
2312: oSetResult 1
2314: oPushResult
2315: oEmitInt
2316: oPop 1
2318: oEmit 45
2320: oGetLocal 1
2322: oPushResult
2323: oEmitLabel
2324: oPop 1
2326: oEmit 48
2328: oGetFromParam 1
2330: oPushResult
2331: oEmitLabel
2332: oPop 1
2334: oEmit 9
2336: oSetResult 0
2338: oPushResult
2339: oEmitInt
2340: oPop 1
2342: oEmit 48
2344: oGetLocal 1
2346: oPushResult
2347: oEmitLabel
2348: oPop 1
2350: oTypeSPop
2351: oGetGlobal 5
2353: oPushResult
2354: oTypeSPush
2355: oPop 1
2357: oGetParam 1
2359: oPushResult
2360: oSetResult 0
2362: oAssign
2363: oJumpForward 2368
2365: Choice Lookup Table
          20   2305
2368: oReturn
2369: oLocalSpace 0
2371: oTypeSNodeType
2372: oChoice 2396
2374: oGetParam 1
2376: oPushResult
2377: oLabelNew
2378: oAssign
2379: oEmit 47
2381: oGetFromParam 1
2383: oPushResult
2384: oEmitLabel
2385: oPop 1
2387: oTypeSPop
2388: oGetGlobal 6
2390: oPushResult
2391: oTypeSPush
2392: oPop 1
2394: oJumpForward 2399
2396: Choice Lookup Table
          19   2374
2399: oReturn
2400: oLocalSpace 0
2402: oGetParam 1
2404: oPushResult
2405: oCall 2765
2407: oPop 1
2409: oInputChoice 2747
2411: oGetParam 1
2413: oPushResult
2414: oCall 2300
2416: oPop 1
2418: oGetParam 1
2420: oPushResult
2421: oCall 2765
2423: oPop 1
2425: oGetParam 1
2427: oPushResult
2428: oCall 2300
2430: oPop 1
2432: oCall 5884
2434: oTypeSNodeType
2435: oChoice 2449
2437: oEmit 30
2439: oJumpForward 2462
2441: oEmit 36
2443: oJumpForward 2462
2445: oError 16
2447: oJumpForward 2462
2449: Choice Lookup Table
          22   2445
          21   2445
          23   2441
          19   2437
          18   2437
2460: oError 17
2462: oTypeSPop
2463: oGetGlobal 5
2465: oPushResult
2466: oTypeSPush
2467: oPop 1
2469: oJumpForward 2762
2471: oGetParam 1
2473: oPushResult
2474: oCall 2300
2476: oPop 1
2478: oGetParam 1
2480: oPushResult
2481: oCall 2765
2483: oPop 1
2485: oGetParam 1
2487: oPushResult
2488: oCall 2300
2490: oPop 1
2492: oCall 5884
2494: oTypeSNodeType
2495: oChoice 2509
2497: oEmit 31
2499: oJumpForward 2522
2501: oEmit 37
2503: oJumpForward 2522
2505: oError 16
2507: oJumpForward 2522
2509: Choice Lookup Table
          22   2505
          21   2505
          23   2501
          19   2497
          18   2497
2520: oError 17
2522: oTypeSPop
2523: oGetGlobal 5
2525: oPushResult
2526: oTypeSPush
2527: oPop 1
2529: oJumpForward 2762
2531: oGetParam 1
2533: oPushResult
2534: oCall 2300
2536: oPop 1
2538: oGetParam 1
2540: oPushResult
2541: oCall 2765
2543: oPop 1
2545: oGetParam 1
2547: oPushResult
2548: oCall 2300
2550: oPop 1
2552: oCall 5884
2554: oTypeSNodeType
2555: oChoice 2565
2557: oEmit 33
2559: oJumpForward 2576
2561: oError 16
2563: oJumpForward 2576
2565: Choice Lookup Table
          22   2561
          21   2561
          19   2557
          18   2557
2574: oError 17
2576: oTypeSPop
2577: oGetGlobal 5
2579: oPushResult
2580: oTypeSPush
2581: oPop 1
2583: oJumpForward 2762
2585: oGetParam 1
2587: oPushResult
2588: oCall 2300
2590: oPop 1
2592: oGetParam 1
2594: oPushResult
2595: oCall 2765
2597: oPop 1
2599: oGetParam 1
2601: oPushResult
2602: oCall 2300
2604: oPop 1
2606: oCall 5884
2608: oTypeSNodeType
2609: oChoice 2619
2611: oEmit 32
2613: oJumpForward 2630
2615: oError 16
2617: oJumpForward 2630
2619: Choice Lookup Table
          22   2615
          21   2615
          19   2611
          18   2611
2628: oError 17
2630: oTypeSPop
2631: oGetGlobal 5
2633: oPushResult
2634: oTypeSPush
2635: oPop 1
2637: oJumpForward 2762
2639: oGetParam 1
2641: oPushResult
2642: oCall 2300
2644: oPop 1
2646: oGetParam 1
2648: oPushResult
2649: oCall 2765
2651: oPop 1
2653: oGetParam 1
2655: oPushResult
2656: oCall 2300
2658: oPop 1
2660: oCall 5884
2662: oTypeSNodeType
2663: oChoice 2673
2665: oEmit 35
2667: oJumpForward 2684
2669: oError 16
2671: oJumpForward 2684
2673: Choice Lookup Table
          22   2669
          21   2669
          19   2665
          18   2665
2682: oError 17
2684: oTypeSPop
2685: oGetGlobal 5
2687: oPushResult
2688: oTypeSPush
2689: oPop 1
2691: oJumpForward 2762
2693: oGetParam 1
2695: oPushResult
2696: oCall 2300
2698: oPop 1
2700: oGetParam 1
2702: oPushResult
2703: oCall 2765
2705: oPop 1
2707: oGetParam 1
2709: oPushResult
2710: oCall 2300
2712: oPop 1
2714: oCall 5884
2716: oTypeSNodeType
2717: oChoice 2727
2719: oEmit 34
2721: oJumpForward 2738
2723: oError 16
2725: oJumpForward 2738
2727: Choice Lookup Table
          22   2723
          21   2723
          19   2719
          18   2719
2736: oError 17
2738: oTypeSPop
2739: oGetGlobal 5
2741: oPushResult
2742: oTypeSPush
2743: oPop 1
2745: oJumpForward 2762
2747: Choice Lookup Table
          10   2693
           9   2639
           8   2585
           7   2531
           6   2471
           5   2411
2760: oJumpForward 2764
2762: oJumpBack 2409
2764: oReturn
2765: oLocalSpace 1
2767: oGetAddrLocal 1
2769: oPushResult
2770: oSetResult 0
2772: oAssign
2773: oGetParam 1
2775: oPushResult
2776: oCall 2945
2778: oPop 1
2780: oInputChoice 2913
2782: oTypeSNodeType
2783: oChoice 2854
2785: oGetLocal 1
2787: oPushResult
2788: oSetResult 0
2790: oPushResult
2791: equal_label
2792: oPop 2
2794: oChoice 2803
2796: oGetAddrLocal 1
2798: oPushResult
2799: oLabelNew
2800: oAssign
2801: oJumpForward 2806
2803: Choice Lookup Table
           1   2796
2806: oEmit 45
2808: oGetLocal 1
2810: oPushResult
2811: oEmitLabel
2812: oPop 1
2814: oJumpForward 2861
2816: oGetParam 1
2818: oPushResult
2819: oCall 2369
2821: oPop 1
2823: oGetLocal 1
2825: oPushResult
2826: oSetResult 0
2828: oPushResult
2829: equal_label
2830: oPop 2
2832: oChoice 2841
2834: oGetAddrLocal 1
2836: oPushResult
2837: oLabelNew
2838: oAssign
2839: oJumpForward 2844
2841: Choice Lookup Table
           1   2834
2844: oEmit 45
2846: oGetLocal 1
2848: oPushResult
2849: oEmitLabel
2850: oPop 1
2852: oJumpForward 2861
2854: Choice Lookup Table
          19   2816
          20   2785
2859: oError 8
2861: oTypeSPop
2862: oEmit 48
2864: oGetFromParam 1
2866: oPushResult
2867: oEmitLabel
2868: oPop 1
2870: oGetParam 1
2872: oPushResult
2873: oSetResult 0
2875: oAssign
2876: oGetParam 1
2878: oPushResult
2879: oCall 2945
2881: oPop 1
2883: oTypeSNodeType
2884: oChoice 2897
2886: oJumpForward 2904
2888: oGetParam 1
2890: oPushResult
2891: oCall 2369
2893: oPop 1
2895: oJumpForward 2904
2897: Choice Lookup Table
          19   2888
          20   2886
2902: oError 8
2904: oTypeSPop
2905: oGetGlobal 6
2907: oPushResult
2908: oTypeSPush
2909: oPop 1
2911: oJumpForward 2918
2913: Choice Lookup Table
          52   2782
2916: oJumpForward 2920
2918: oJumpBack 2780
2920: oGetLocal 1
2922: oPushResult
2923: oSetResult 0
2925: oPushResult
2926: equal_label
2927: oPop 2
2929: oChoice 2941
2931: oEmit 48
2933: oGetLocal 1
2935: oPushResult
2936: oEmitLabel
2937: oPop 1
2939: oJumpForward 2944
2941: Choice Lookup Table
           0   2931
2944: oReturn
2945: oLocalSpace 2
2947: oGetAddrLocal 1
2949: oPushResult
2950: oSetResult 0
2952: oAssign
2953: oGetParam 1
2955: oPushResult
2956: oCall 3083
2958: oPop 1
2960: oInputChoice 3075
2962: oTypeSNodeType
2963: oChoice 2976
2965: oJumpForward 2983
2967: oGetParam 1
2969: oPushResult
2970: oCall 2369
2972: oPop 1
2974: oJumpForward 2983
2976: Choice Lookup Table
          19   2967
          20   2965
2981: oError 8
2983: oTypeSPop
2984: oGetLocal 1
2986: oPushResult
2987: oSetResult 0
2989: oPushResult
2990: equal_label
2991: oPop 2
2993: oChoice 3022
2995: oGetAddrLocal 1
2997: oPushResult
2998: oLabelNew
2999: oAssign
3000: oEmit 49
3002: oGetFromParam 1
3004: oPushResult
3005: oEmitLabel
3006: oPop 1
3008: oGetLocal 1
3010: oPushResult
3011: oEmitLabel
3012: oPop 1
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 1
3019: oAssign
3020: oJumpForward 3025
3022: Choice Lookup Table
           1   2995
3025: oGetAddrLocal 2
3027: oPushResult
3028: oSetResult 0
3030: oAssign
3031: oGetAddrLocal 2
3033: oPushResult
3034: oCall 3083
3036: oPop 1
3038: oTypeSNodeType
3039: oChoice 3052
3041: oJumpForward 3059
3043: oGetAddrLocal 2
3045: oPushResult
3046: oCall 2369
3048: oPop 1
3050: oJumpForward 3059
3052: Choice Lookup Table
          19   3043
          20   3041
3057: oError 8
3059: oEmit 49
3061: oGetLocal 2
3063: oPushResult
3064: oEmitLabel
3065: oPop 1
3067: oGetLocal 1
3069: oPushResult
3070: oEmitLabel
3071: oPop 1
3073: oJumpForward 3080
3075: Choice Lookup Table
          51   2962
3078: oJumpForward 3082
3080: oJumpBack 2960
3082: oReturn
3083: oLocalSpace 1
3085: oInputChoice 3139
3087: oGetAddrLocal 1
3089: oPushResult
3090: oSetResult 0
3092: oAssign
3093: oGetAddrLocal 1
3095: oPushResult
3096: oCall 3083
3098: oPop 1
3100: oTypeSNodeType
3101: oChoice 3130
3103: oGetParam 1
3105: oPushResult
3106: oLabelNew
3107: oAssign
3108: oEmit 45
3110: oGetFromParam 1
3112: oPushResult
3113: oEmitLabel
3114: oPop 1
3116: oEmit 48
3118: oGetLocal 1
3120: oPushResult
3121: oEmitLabel
3122: oPop 1
3124: oJumpForward 3137
3126: oEmit 29
3128: oJumpForward 3137
3130: Choice Lookup Table
          19   3126
          20   3103
3135: oError 8
3137: oJumpForward 3149
3139: Choice Lookup Table
          53   3087
3142: oGetParam 1
3144: oPushResult
3145: oCall 3150
3147: oPop 1
3149: oReturn
3150: oLocalSpace 0
3152: oGetParam 1
3154: oPushResult
3155: oCall 3201
3157: oPop 1
3159: oInputChoice 3191
3161: oCall 5910
3163: oGetParam 1
3165: oPushResult
3166: oCall 3201
3168: oPop 1
3170: oCall 5924
3172: oEmit 26
3174: oJumpForward 3198
3176: oCall 5910
3178: oGetParam 1
3180: oPushResult
3181: oCall 3201
3183: oPop 1
3185: oCall 5924
3187: oEmit 27
3189: oJumpForward 3198
3191: Choice Lookup Table
          24   3176
          23   3161
3196: oJumpForward 3200
3198: oJumpBack 3159
3200: oReturn
3201: oLocalSpace 0
3203: oGetParam 1
3205: oPushResult
3206: oCall 3252
3208: oPop 1
3210: oInputChoice 3242
3212: oCall 5910
3214: oGetParam 1
3216: oPushResult
3217: oCall 3252
3219: oPop 1
3221: oCall 5924
3223: oEmit 23
3225: oJumpForward 3249
3227: oCall 5910
3229: oGetParam 1
3231: oPushResult
3232: oCall 3252
3234: oPop 1
3236: oCall 5924
3238: oEmit 24
3240: oJumpForward 3249
3242: Choice Lookup Table
          22   3227
          21   3212
3247: oJumpForward 3251
3249: oJumpBack 3210
3251: oReturn
3252: oLocalSpace 0
3254: oInputChoice 3280
3256: oGetParam 1
3258: oPushResult
3259: oCall 3293
3261: oPop 1
3263: oCall 5924
3265: oJumpForward 3292
3267: oGetParam 1
3269: oPushResult
3270: oCall 3293
3272: oPop 1
3274: oCall 5924
3276: oEmit 28
3278: oJumpForward 3292
3280: Choice Lookup Table
          24   3267
          23   3256
3285: oGetParam 1
3287: oPushResult
3288: oCall 3293
3290: oPop 1
3292: oReturn
3293: oLocalSpace 6
3295: oInputChoice 3481
3297: oEmit 9
3299: TOKEN_VALUE
3300: oPushResult
3301: oEmitInt
3302: oPop 1
3304: oGetGlobal 4
3306: oPushResult
3307: oTypeSPush
3308: oPop 1
3310: oJumpForward 3500
3312: oGetParam 1
3314: oPushResult
3315: oCall 2400
3317: oPop 1
3319: oInput 14
3321: oJumpForward 3500
3323: oGetAddrLocal 1
3325: oPushResult
3326: CURRENT_STRLIT
3327: oPushResult
3328: oStringAllocLit
3329: oPop 1
3331: oAssign
3332: oEmit 10
3334: oGetLocal 1
3336: oPushResult
3337: oEmitInt
3338: oPop 1
3340: oGetGlobal 8
3342: oPushResult
3343: oTypeSPush
3344: oPop 1
3346: oJumpForward 3500
3348: oGetAddrLocal 2
3350: oPushResult
3351: oScopeFindRequire
3352: oAssign
3353: oGetLocal 2
3355: oPushResult
3356: oNodeType
3357: oPop 1
3359: oChoice 3421
3361: oGetLocal 2
3363: oPushResult
3364: oCall 4306
3366: oPop 1
3368: oJumpForward 3440
3370: oGetAddrLocal 3
3372: oPushResult
3373: oGetLocal 2
3375: oPushResult
3376: oSetResult 6
3378: oPushResult
3379: oNodeGet
3380: oPop 2
3382: oAssign
3383: oGetLocal 3
3385: oPushResult
3386: oTypeSPush
3387: oPop 1
3389: oTypeSNodeType
3390: oChoice 3403
3392: oEmit 9
3394: oGetLocal 2
3396: oPushResult
3397: oCall 6161
3399: oPop 1
3401: oJumpForward 3410
3403: Choice Lookup Table
          19   3392
          18   3392
3408: oError 16
3410: oJumpForward 3440
3412: oGetLocal 2
3414: oPushResult
3415: oCall 3501
3417: oPop 1
3419: oJumpForward 3440
3421: Choice Lookup Table
          15   3412
          13   3412
          12   3412
           9   3370
           8   3361
3432: oError 6
3434: oGetGlobal 4
3436: oPushResult
3437: oTypeSPush
3438: oPop 1
3440: oJumpForward 3500
3442: oInput 0
3444: oGetAddrLocal 4
3446: oPushResult
3447: oScopeFindRequire
3448: oAssign
3449: oGetLocal 4
3451: oPushResult
3452: oCall 5203
3454: oPop 1
3456: oGetAddrLocal 5
3458: oPushResult
3459: oTypeSTop
3460: oAssign
3461: oTypeSPop
3462: oGetAddrLocal 6
3464: oPushResult
3465: oGetLocal 5
3467: oPushResult
3468: oCall 6026
3470: oPop 1
3472: oAssign
3473: oGetLocal 6
3475: oPushResult
3476: oTypeSPush
3477: oPop 1
3479: oJumpForward 3500
3481: Choice Lookup Table
          18   3442
           0   3348
           2   3323
          13   3312
           1   3297
3492: oError 6
3494: oGetGlobal 4
3496: oPushResult
3497: oTypeSPush
3498: oPop 1
3500: oReturn
3501: oLocalSpace 1
3503: oGetAddrLocal 1
3505: oPushResult
3506: oGetParam 1
3508: oPushResult
3509: oSetResult 6
3511: oPushResult
3512: oNodeGet
3513: oPop 2
3515: oAssign
3516: oGetLocal 1
3518: oPushResult
3519: oTypeSPush
3520: oPop 1
3522: oTypeSNodeType
3523: oChoice 3788
3525: oGetParam 1
3527: oPushResult
3528: oNodeType
3529: oPop 1
3531: oChoice 3593
3533: oEmit 0
3535: oGetParam 1
3537: oPushResult
3538: oCall 6161
3540: oPop 1
3542: oJumpForward 3601
3544: oEmit 3
3546: oGetParam 1
3548: oPushResult
3549: oCall 6161
3551: oPop 1
3553: oJumpForward 3601
3555: oGetParam 1
3557: oPushResult
3558: oSetResult 19
3560: oPushResult
3561: oNodeGetBoolean
3562: oPop 2
3564: oChoice 3579
3566: oEmit 8
3568: oGetParam 1
3570: oPushResult
3571: oCall 6161
3573: oPop 1
3575: oEmit 14
3577: oJumpForward 3591
3579: Choice Lookup Table
           1   3566
3582: oEmit 6
3584: oGetParam 1
3586: oPushResult
3587: oCall 6161
3589: oPop 1
3591: oJumpForward 3601
3593: Choice Lookup Table
          15   3555
          13   3544
          12   3533
3600: oEndChoice
3601: oJumpForward 3879
3603: oGetParam 1
3605: oPushResult
3606: oNodeType
3607: oPop 1
3609: oChoice 3671
3611: oEmit 1
3613: oGetParam 1
3615: oPushResult
3616: oCall 6161
3618: oPop 1
3620: oJumpForward 3679
3622: oEmit 4
3624: oGetParam 1
3626: oPushResult
3627: oCall 6161
3629: oPop 1
3631: oJumpForward 3679
3633: oGetParam 1
3635: oPushResult
3636: oSetResult 19
3638: oPushResult
3639: oNodeGetBoolean
3640: oPop 2
3642: oChoice 3657
3644: oEmit 8
3646: oGetParam 1
3648: oPushResult
3649: oCall 6161
3651: oPop 1
3653: oEmit 15
3655: oJumpForward 3669
3657: Choice Lookup Table
           1   3644
3660: oEmit 7
3662: oGetParam 1
3664: oPushResult
3665: oCall 6161
3667: oPop 1
3669: oJumpForward 3679
3671: Choice Lookup Table
          15   3633
          13   3622
          12   3611
3678: oEndChoice
3679: oJumpForward 3879
3681: oError 16
3683: oJumpForward 3879
3685: oGetParam 1
3687: oPushResult
3688: oNodeType
3689: oPop 1
3691: oChoice 3753
3693: oEmit 2
3695: oGetParam 1
3697: oPushResult
3698: oCall 6161
3700: oPop 1
3702: oJumpForward 3761
3704: oEmit 5
3706: oGetParam 1
3708: oPushResult
3709: oCall 6161
3711: oPop 1
3713: oJumpForward 3761
3715: oGetParam 1
3717: oPushResult
3718: oSetResult 19
3720: oPushResult
3721: oNodeGetBoolean
3722: oPop 2
3724: oChoice 3739
3726: oEmit 8
3728: oGetParam 1
3730: oPushResult
3731: oCall 6161
3733: oPop 1
3735: oEmit 16
3737: oJumpForward 3751
3739: Choice Lookup Table
           1   3726
3742: oEmit 8
3744: oGetParam 1
3746: oPushResult
3747: oCall 6161
3749: oPop 1
3751: oJumpForward 3761
3753: Choice Lookup Table
          15   3715
          13   3704
          12   3693
3760: oEndChoice
3761: oInputChoice 3783
3763: oTypeSPop
3764: oGetLocal 1
3766: oPushResult
3767: oSetResult 21
3769: oPushResult
3770: oNodeGet
3771: oPop 2
3773: oPushResult
3774: oTypeSPush
3775: oPop 1
3777: oCall 3915
3779: oCall 3880
3781: oJumpForward 3786
3783: Choice Lookup Table
          17   3763
3786: oJumpForward 3879
3788: Choice Lookup Table
          23   3685
          17   3681
          22   3681
          21   3681
          19   3603
          18   3525
3801: oGetParam 1
3803: oPushResult
3804: oNodeType
3805: oPop 1
3807: oChoice 3867
3809: oEmit 10
3811: oGetParam 1
3813: oPushResult
3814: oCall 6161
3816: oPop 1
3818: oJumpForward 3875
3820: oEmit 11
3822: oGetParam 1
3824: oPushResult
3825: oCall 6161
3827: oPop 1
3829: oJumpForward 3875
3831: oGetParam 1
3833: oPushResult
3834: oSetResult 19
3836: oPushResult
3837: oNodeGetBoolean
3838: oPop 2
3840: oChoice 3853
3842: oEmit 8
3844: oGetParam 1
3846: oPushResult
3847: oCall 6161
3849: oPop 1
3851: oJumpForward 3865
3853: Choice Lookup Table
           1   3842
3856: oEmit 12
3858: oGetParam 1
3860: oPushResult
3861: oCall 6161
3863: oPop 1
3865: oJumpForward 3875
3867: Choice Lookup Table
          15   3831
          13   3820
          12   3809
3874: oEndChoice
3875: oCall 3915
3877: oCall 3880
3879: oReturn
3880: oLocalSpace 0
3882: oTypeSNodeType
3883: oChoice 3901
3885: oEmit 14
3887: oJumpForward 3914
3889: oEmit 15
3891: oJumpForward 3914
3893: oError 16
3895: oJumpForward 3914
3897: oEmit 16
3899: oJumpForward 3914
3901: Choice Lookup Table
          23   3897
          17   3893
          22   3893
          21   3893
          19   3889
          18   3885
3914: oReturn
3915: oLocalSpace 0
3917: oInputChoice 3931
3919: oCall 3943
3921: oJumpForward 3940
3923: oCall 4086
3925: oJumpForward 3940
3927: oCall 4184
3929: oJumpForward 3940
3931: Choice Lookup Table
          17   3927
          19   3923
          15   3919
3938: oJumpForward 3942
3940: oJumpBack 3917
3942: oReturn
3943: oLocalSpace 3
3945: oTypeSNodeType
3946: oChoice 3950
3948: oJumpForward 3955
3950: Choice Lookup Table
          24   3948
3953: oError 10
3955: oTypeSNodeType
3956: oChoice 3960
3958: oJumpForward 3965
3960: Choice Lookup Table
          24   3958
3963: oError 13
3965: oGetAddrLocal 1
3967: oPushResult
3968: oTypeSTop
3969: oPushResult
3970: oSetResult 22
3972: oPushResult
3973: oNodeGet
3974: oPop 2
3976: oPushResult
3977: oCall 6110
3979: oPop 1
3981: oAssign
3982: oGetAddrLocal 2
3984: oPushResult
3985: oTypeSTop
3986: oPushResult
3987: oSetResult 21
3989: oPushResult
3990: oNodeGet
3991: oPop 2
3993: oAssign
3994: oTypeSPop
3995: oGetLocal 2
3997: oPushResult
3998: oTypeSPush
3999: oPop 1
4001: oCall 2239
4003: oCall 5910
4005: oGetLocal 1
4007: oPushResult
4008: equal_zero
4009: oPop 1
4011: oChoice 4025
4013: oEmit 9
4015: oGetLocal 1
4017: oPushResult
4018: oEmitInt
4019: oPop 1
4021: oEmit 27
4023: oJumpForward 4028
4025: Choice Lookup Table
           0   4013
4028: oGetAddrLocal 3
4030: oPushResult
4031: oGetLocal 2
4033: oPushResult
4034: oSetResult 2
4036: oPushResult
4037: oNodeGetInt
4038: oPop 2
4040: oAssign
4041: oGetLocal 3
4043: oPushResult
4044: oSetResult 1
4046: oPushResult
4047: equal
4048: oPop 2
4050: oChoice 4064
4052: oEmit 9
4054: oGetLocal 3
4056: oPushResult
4057: oEmitInt
4058: oPop 1
4060: oEmit 23
4062: oJumpForward 4067
4064: Choice Lookup Table
           0   4052
4067: oEmit 25
4069: oInputChoice 4077
4071: oJumpForward 4085
4073: oJumpForward 4083
4075: oJumpForward 4083
4077: Choice Lookup Table
          12   4075
          16   4071
4082: oEndChoice
4083: oJumpBack 3955
4085: oReturn
4086: oLocalSpace 2
4088: oTypeSNodeType
4089: oChoice 4093
4091: oJumpForward 4098
4093: Choice Lookup Table
          26   4091
4096: oError 11
4098: oTypeSTop
4099: oPushResult
4100: oSetResult 25
4102: oPushResult
4103: oNodeGet
4104: oPop 2
4106: oPushResult
4107: oScopeEnter
4108: oPop 1
4110: oInput 0
4112: oGetAddrLocal 1
4114: oPushResult
4115: oScopeFindRequire
4116: oAssign
4117: oGetLocal 1
4119: oPushResult
4120: oNodeType
4121: oPop 1
4123: oChoice 4127
4125: oJumpForward 4132
4127: Choice Lookup Table
          14   4125
4130: oError 12
4132: oScopeEnd
4133: oGetAddrLocal 2
4135: oPushResult
4136: oGetLocal 1
4138: oPushResult
4139: oSetResult 7
4141: oPushResult
4142: oNodeGetInt
4143: oPop 2
4145: oAssign
4146: oGetLocal 2
4148: oPushResult
4149: equal_zero
4150: oPop 1
4152: oChoice 4166
4154: oEmit 9
4156: oGetLocal 2
4158: oPushResult
4159: oEmitInt
4160: oPop 1
4162: oEmit 25
4164: oJumpForward 4169
4166: Choice Lookup Table
           0   4154
4169: oTypeSPop
4170: oGetLocal 1
4172: oPushResult
4173: oSetResult 6
4175: oPushResult
4176: oNodeGet
4177: oPop 2
4179: oPushResult
4180: oTypeSPush
4181: oPop 1
4183: oReturn
4184: oLocalSpace 1
4186: oTypeSNodeType
4187: oChoice 4191
4189: oJumpForward 4196
4191: Choice Lookup Table
          23   4189
4194: oError 9
4196: oEmit 16
4198: oGetAddrLocal 1
4200: oPushResult
4201: oTypeSTop
4202: oAssign
4203: oTypeSPop
4204: oGetLocal 1
4206: oPushResult
4207: oSetResult 21
4209: oPushResult
4210: oNodeGet
4211: oPop 2
4213: oPushResult
4214: oTypeSPush
4215: oPop 1
4217: oReturn
4218: oLocalSpace 0
4220: oCall 5884
4222: oReturn
4223: oLocalSpace 2
4225: oGetAddrLocal 2
4227: oPushResult
4228: oGetParam 1
4230: oPushResult
4231: oSetResult 13
4233: oPushResult
4234: oNodeGetString
4235: oPop 2
4237: oAssign
4238: oGetLocal 2
4240: oPushResult
4241: oSetResult 0
4243: oPushResult
4244: equal_string
4245: oPop 2
4247: oChoice 4284
4249: oGetAddrLocal 1
4251: oPushResult
4252: oGetParam 1
4254: oPushResult
4255: oSetResult 5
4257: oPushResult
4258: oNodeGetInt
4259: oPop 2
4261: oPushResult
4262: ID_STRING
4263: oPop 1
4265: oPushResult
4266: oStringAllocLit
4267: oPop 1
4269: oAssign
4270: oJumpForward 4290
4272: oGetAddrLocal 1
4274: oPushResult
4275: oGetLocal 2
4277: oPushResult
4278: oStringAllocLit
4279: oPop 1
4281: oAssign
4282: oJumpForward 4290
4284: Choice Lookup Table
           0   4272
           1   4249
4289: oEndChoice
4290: oEmit 50
4292: oGetParam 1
4294: oPushResult
4295: oCall 6161
4297: oPop 1
4299: oGetLocal 1
4301: oPushResult
4302: oEmitInt
4303: oPop 1
4305: oReturn
4306: oLocalSpace 10
4308: oGetParam 1
4310: oPushResult
4311: oSetResult 12
4313: oPushResult
4314: oNodeGetBoolean
4315: oPop 2
4317: oChoice 4344
4319: oGetParam 1
4321: oPushResult
4322: oSetResult 15
4324: oPushResult
4325: oNodeGetBoolean
4326: oPop 2
4328: oChoice 4339
4330: oGetParam 1
4332: oPushResult
4333: oCall 4223
4335: oPop 1
4337: oJumpForward 4342
4339: Choice Lookup Table
           0   4330
4342: oJumpForward 4347
4344: Choice Lookup Table
           1   4319
4347: oGetParam 1
4349: oPushResult
4350: oSetResult 15
4352: oPushResult
4353: oSetResult 1
4355: oPushResult
4356: oNodeSetBoolean
4357: oPop 3
4359: oGetAddrLocal 1
4361: oPushResult
4362: oGetParam 1
4364: oPushResult
4365: oSetResult 14
4367: oPushResult
4368: oNodeGetBoolean
4369: oPop 2
4371: oAssign
4372: oGetAddrLocal 4
4374: oPushResult
4375: oGetParam 1
4377: oPushResult
4378: oNodeType
4379: oPop 1
4381: oPushResult
4382: oSetResult 8
4384: oPushResult
4385: equal_node_type
4386: oPop 2
4388: oAssign
4389: oGetLocal 4
4391: oChoice 4418
4393: oGetAddrLocal 2
4395: oPushResult
4396: oGetParam 1
4398: oPushResult
4399: oSetResult 6
4401: oPushResult
4402: oNodeGet
4403: oPop 2
4405: oAssign
4406: oGetAddrLocal 3
4408: oPushResult
4409: oGetLocal 2
4411: oPushResult
4412: oScopeAllocType
4413: oPop 1
4415: oAssign
4416: oJumpForward 4421
4418: Choice Lookup Table
           1   4393
4421: oGetAddrLocal 5
4423: oPushResult
4424: oGetParam 1
4426: oPushResult
4427: oSetResult 9
4429: oPushResult
4430: oNodeGet
4431: oPop 2
4433: oAssign
4434: oGetAddrLocal 6
4436: oPushResult
4437: oGetLocal 5
4439: oPushResult
4440: oSetResult 2
4442: oPushResult
4443: oNodeGetInt
4444: oPop 2
4446: oAssign
4447: oGetLocal 1
4449: oChoice 4471
4451: oEmit 39
4453: oGetLocal 6
4455: oPushResult
4456: oEmitInt
4457: oPop 1
4459: oJumpForward 4477
4461: oEmit 38
4463: oGetLocal 6
4465: oPushResult
4466: oEmitInt
4467: oPop 1
4469: oJumpForward 4477
4471: Choice Lookup Table
           0   4461
           1   4451
4476: oEndChoice
4477: oGetAddrLocal 7
4479: oPushResult
4480: oGetLocal 5
4482: oPushResult
4483: oSetResult 1
4485: oPushResult
4486: oNodeGetIter
4487: oPop 2
4489: oAssign
4490: oGetAddrLocal 8
4492: oPushResult
4493: oGetLocal 7
4495: oPushResult
4496: oNodeIterValue
4497: oPop 1
4499: oAssign
4500: oInputChoice 4679
4502: oGetLocal 8
4504: oPushResult
4505: oNodeNull
4506: oPop 1
4508: oChoice 4514
4510: oJumpForward 4675
4512: oJumpForward 4517
4514: Choice Lookup Table
           1   4510
4517: oGetAddrLocal 9
4519: oPushResult
4520: oGetLocal 8
4522: oPushResult
4523: oSetResult 7
4525: oPushResult
4526: oNodeGetInt
4527: oPop 2
4529: oAssign
4530: oEmit 13
4532: oGetLocal 9
4534: oPushResult
4535: oEmitInt
4536: oPop 1
4538: oGetLocal 8
4540: oPushResult
4541: oSetResult 6
4543: oPushResult
4544: oNodeGet
4545: oPop 2
4547: oPushResult
4548: oTypeSPush
4549: oPop 1
4551: oGetLocal 8
4553: oPushResult
4554: oSetResult 19
4556: oPushResult
4557: oNodeGetBoolean
4558: oPop 2
4560: oChoice 4628
4562: oCall 5167
4564: oCall 5884
4566: oEmit 19
4568: oJumpForward 4634
4570: oCall 2239
4572: oCall 4218
4574: oTypeSNodeType
4575: oChoice 4593
4577: oEmit 17
4579: oJumpForward 4626
4581: oEmit 18
4583: oJumpForward 4626
4585: oError 16
4587: oJumpForward 4626
4589: oEmit 19
4591: oJumpForward 4626
4593: Choice Lookup Table
          23   4589
          17   4585
          22   4585
          21   4585
          19   4581
          18   4577
4606: oGetAddrLocal 10
4608: oPushResult
4609: oTypeSTop
4610: oPushResult
4611: oSetResult 2
4613: oPushResult
4614: oNodeGetInt
4615: oPop 2
4617: oAssign
4618: oEmit 20
4620: oGetLocal 10
4622: oPushResult
4623: oEmitInt
4624: oPop 1
4626: oJumpForward 4634
4628: Choice Lookup Table
           0   4570
           1   4562
4633: oEndChoice
4634: oTypeSPop
4635: oGetAddrLocal 7
4637: oPushResult
4638: oNodeIterNext
4639: oPop 1
4641: oGetAddrLocal 8
4643: oPushResult
4644: oGetLocal 7
4646: oPushResult
4647: oNodeIterValue
4648: oPop 1
4650: oAssign
4651: oGetLocal 8
4653: oPushResult
4654: oNodeNull
4655: oPop 1
4657: oChoice 4665
4659: oJumpForward 4675
4661: oJumpForward 4671
4663: oJumpForward 4671
4665: Choice Lookup Table
           0   4663
           1   4659
4670: oEndChoice
4671: oInput 12
4673: oJumpBack 4502
4675: oInput 14
4677: oJumpForward 4682
4679: Choice Lookup Table
          13   4502
4682: oGetLocal 8
4684: oPushResult
4685: oNodeNull
4686: oPop 1
4688: oChoice 4694
4690: oError 15
4692: oJumpForward 4697
4694: Choice Lookup Table
           0   4690
4697: oGetLocal 4
4699: oChoice 4728
4701: oEmit 13
4703: oGetParam 1
4705: oPushResult
4706: oSetResult 18
4708: oPushResult
4709: oNodeGetInt
4710: oPop 2
4712: oPushResult
4713: oEmitInt
4714: oPop 1
4716: oEmit 11
4718: oGetLocal 3
4720: oPushResult
4721: oEmitInt
4722: oPop 1
4724: oEmit 19
4726: oJumpForward 4731
4728: Choice Lookup Table
           1   4701
4731: oGetLocal 1
4733: oChoice 4757
4735: oEmit 42
4737: oGetParam 1
4739: oPushResult
4740: oCall 6161
4742: oPop 1
4744: oJumpForward 4763
4746: oEmit 41
4748: oGetParam 1
4750: oPushResult
4751: oCall 6161
4753: oPop 1
4755: oJumpForward 4763
4757: Choice Lookup Table
           0   4746
           1   4735
4762: oEndChoice
4763: oGetLocal 4
4765: oChoice 4833
4767: oGetLocal 2
4769: oPushResult
4770: oTypeSPush
4771: oPop 1
4773: oTypeSNodeType
4774: oChoice 4810
4776: oEmit 3
4778: oGetLocal 3
4780: oPushResult
4781: oEmitInt
4782: oPop 1
4784: oJumpForward 4831
4786: oEmit 4
4788: oGetLocal 3
4790: oPushResult
4791: oEmitInt
4792: oPop 1
4794: oJumpForward 4831
4796: oError 16
4798: oJumpForward 4831
4800: oEmit 5
4802: oGetLocal 3
4804: oPushResult
4805: oEmitInt
4806: oPop 1
4808: oJumpForward 4831
4810: Choice Lookup Table
          23   4800
          17   4796
          22   4796
          21   4796
          19   4786
          18   4776
4823: oEmit 11
4825: oGetLocal 3
4827: oPushResult
4828: oEmitInt
4829: oPop 1
4831: oJumpForward 4836
4833: Choice Lookup Table
           1   4767
4836: oEmit 40
4838: oGetLocal 6
4840: oPushResult
4841: oEmitInt
4842: oPop 1
4844: oReturn
4845: oLocalSpace 0
4847: oInputChoice 4897
4849: oCall 5804
4851: oJumpForward 4922
4853: oCall 5811
4855: oJumpForward 4922
4857: oCall 5878
4859: oJumpForward 4922
4861: oCall 5881
4863: oJumpForward 4922
4865: oCall 5344
4867: oJumpForward 4922
4869: oCall 5664
4871: oJumpForward 4922
4873: oCall 5410
4875: oJumpForward 4922
4877: oCall 5584
4879: oJumpForward 4922
4881: oCall 5749
4883: oJumpForward 4922
4885: oCall 5717
4887: oJumpForward 4922
4889: oCall 5781
4891: oJumpForward 4922
4893: oCall 4923
4895: oJumpForward 4922
4897: Choice Lookup Table
           0   4893
          33   4889
          49   4885
          50   4881
          47   4877
          42   4873
          46   4869
          39   4865
          57   4861
          56   4857
          55   4853
          54   4849
4922: oReturn
4923: oLocalSpace 1
4925: oGetAddrLocal 1
4927: oPushResult
4928: oScopeFindRequire
4929: oAssign
4930: oGetLocal 1
4932: oPushResult
4933: oNodeType
4934: oPop 1
4936: oChoice 4965
4938: oGetLocal 1
4940: oPushResult
4941: oCall 4306
4943: oPop 1
4945: oJumpForward 4978
4947: oGetLocal 1
4949: oPushResult
4950: oCall 4979
4952: oPop 1
4954: oJumpForward 4978
4956: oGetLocal 1
4958: oPushResult
4959: oCall 5053
4961: oPop 1
4963: oJumpForward 4978
4965: Choice Lookup Table
           8   4956
          15   4947
          13   4947
          12   4947
           7   4938
4976: oError 0
4978: oReturn
4979: oLocalSpace 0
4981: oGetParam 1
4983: oPushResult
4984: oCall 5203
4986: oPop 1
4988: oInput 3
4990: oCall 2239
4992: oCall 5884
4994: oCall 4997
4996: oReturn
4997: oLocalSpace 1
4999: oTypeSNodeType
5000: oChoice 5018
5002: oEmit 17
5004: oJumpForward 5051
5006: oEmit 18
5008: oJumpForward 5051
5010: oError 16
5012: oJumpForward 5051
5014: oEmit 19
5016: oJumpForward 5051
5018: Choice Lookup Table
          23   5014
          17   5010
          22   5010
          21   5010
          19   5006
          18   5002
5031: oGetAddrLocal 1
5033: oPushResult
5034: oTypeSTop
5035: oPushResult
5036: oSetResult 2
5038: oPushResult
5039: oNodeGetInt
5040: oPop 2
5042: oAssign
5043: oEmit 20
5045: oGetLocal 1
5047: oPushResult
5048: oEmitInt
5049: oPop 1
5051: oTypeSPop
5052: oReturn
5053: oLocalSpace 1
5055: oGetParam 1
5057: oPushResult
5058: oSetResult 10
5060: oPushResult
5061: oNodeGet
5062: oPop 2
5064: oPushResult
5065: oScopeCurrent
5066: oPushResult
5067: oNodeEqual
5068: oPop 2
5070: oChoice 5076
5072: oError 20
5074: oJumpForward 5079
5076: Choice Lookup Table
           0   5072
5079: oEmit 8
5081: oGetParam 1
5083: oPushResult
5084: oSetResult 18
5086: oPushResult
5087: oNodeGetInt
5088: oPop 2
5090: oPushResult
5091: oEmitInt
5092: oPop 1
5094: oGetParam 1
5096: oPushResult
5097: oSetResult 6
5099: oPushResult
5100: oNodeGet
5101: oPop 2
5103: oPushResult
5104: oTypeSPush
5105: oPop 1
5107: oInput 3
5109: oCall 2239
5111: oCall 5884
5113: oTypeSNodeType
5114: oChoice 5132
5116: oEmit 17
5118: oJumpForward 5165
5120: oEmit 18
5122: oJumpForward 5165
5124: oError 16
5126: oJumpForward 5165
5128: oEmit 19
5130: oJumpForward 5165
5132: Choice Lookup Table
          23   5128
          17   5124
          22   5124
          21   5124
          19   5120
          18   5116
5145: oGetAddrLocal 1
5147: oPushResult
5148: oTypeSTop
5149: oPushResult
5150: oSetResult 2
5152: oPushResult
5153: oNodeGetInt
5154: oPop 2
5156: oAssign
5157: oEmit 20
5159: oGetLocal 1
5161: oPushResult
5162: oEmitInt
5163: oPop 1
5165: oTypeSPop
5166: oReturn
5167: oLocalSpace 1
5169: oInput 0
5171: oGetAddrLocal 1
5173: oPushResult
5174: oScopeFindRequire
5175: oAssign
5176: oGetLocal 1
5178: oPushResult
5179: oNodeType
5180: oPop 1
5182: oChoice 5186
5184: oJumpForward 5195
5186: Choice Lookup Table
          15   5184
          13   5184
          12   5184
5193: oError 4
5195: oGetLocal 1
5197: oPushResult
5198: oCall 5203
5200: oPop 1
5202: oReturn
5203: oLocalSpace 0
5205: oGetParam 1
5207: oPushResult
5208: oNodeType
5209: oPop 1
5211: oChoice 5271
5213: oEmit 10
5215: oGetParam 1
5217: oPushResult
5218: oCall 6161
5220: oPop 1
5222: oJumpForward 5280
5224: oEmit 11
5226: oGetParam 1
5228: oPushResult
5229: oCall 6161
5231: oPop 1
5233: oJumpForward 5280
5235: oGetParam 1
5237: oPushResult
5238: oSetResult 19
5240: oPushResult
5241: oNodeGetBoolean
5242: oPop 2
5244: oChoice 5257
5246: oEmit 8
5248: oGetParam 1
5250: oPushResult
5251: oCall 6161
5253: oPop 1
5255: oJumpForward 5269
5257: Choice Lookup Table
           1   5246
5260: oEmit 12
5262: oGetParam 1
5264: oPushResult
5265: oCall 6161
5267: oPop 1
5269: oJumpForward 5280
5271: Choice Lookup Table
          15   5235
          13   5224
          12   5213
5278: oError 4
5280: oGetParam 1
5282: oPushResult
5283: oSetResult 6
5285: oPushResult
5286: oNodeGet
5287: oPop 2
5289: oPushResult
5290: oTypeSPush
5291: oPop 1
5293: oCall 3915
5295: oReturn
5296: oLocalSpace 0
5298: oGetParam 1
5300: oPushResult
5301: oCall 5203
5303: oPop 1
5305: oCall 5910
5307: oGetParam 1
5309: oPushResult
5310: oCall 3501
5312: oPop 1
5314: oTypeSPop
5315: oEmit 21
5317: oEmit 17
5319: oReturn
5320: oLocalSpace 0
5322: oGetParam 1
5324: oPushResult
5325: oCall 5203
5327: oPop 1
5329: oCall 5910
5331: oGetParam 1
5333: oPushResult
5334: oCall 3501
5336: oPop 1
5338: oTypeSPop
5339: oEmit 22
5341: oEmit 17
5343: oReturn
5344: oLocalSpace 2
5346: oGetAddrLocal 1
5348: oPushResult
5349: oSetResult 0
5351: oAssign
5352: oGetAddrLocal 1
5354: oPushResult
5355: oCall 2262
5357: oPop 1
5359: oInput 40
5361: oCall 4845
5363: oInputChoice 5398
5365: oGetAddrLocal 2
5367: oPushResult
5368: oLabelNew
5369: oAssign
5370: oEmit 45
5372: oGetLocal 2
5374: oPushResult
5375: oEmitLabel
5376: oPop 1
5378: oEmit 48
5380: oGetLocal 1
5382: oPushResult
5383: oEmitLabel
5384: oPop 1
5386: oCall 4845
5388: oEmit 48
5390: oGetLocal 2
5392: oPushResult
5393: oEmitLabel
5394: oPop 1
5396: oJumpForward 5409
5398: Choice Lookup Table
          41   5365
5401: oEmit 48
5403: oGetLocal 1
5405: oPushResult
5406: oEmitLabel
5407: oPop 1
5409: oReturn
5410: oLocalSpace 4
5412: oInput 0
5414: oGetAddrLocal 1
5416: oPushResult
5417: oScopeFindRequire
5418: oAssign
5419: oGetLocal 1
5421: oPushResult
5422: oCall 5203
5424: oPop 1
5426: oCall 5910
5428: oInput 3
5430: oCall 2239
5432: oCall 5910
5434: oEmit 17
5436: oGetAddrLocal 2
5438: oPushResult
5439: oLabelNew
5440: oAssign
5441: oGetAddrLocal 3
5443: oPushResult
5444: oLabelNew
5445: oAssign
5446: oEmit 45
5448: oGetLocal 3
5450: oPushResult
5451: oEmitLabel
5452: oPop 1
5454: oGetAddrLocal 4
5456: oPushResult
5457: oLabelNew
5458: oAssign
5459: oEmit 48
5461: oGetLocal 4
5463: oPushResult
5464: oEmitLabel
5465: oPop 1
5467: oInputChoice 5547
5469: oGetLocal 1
5471: oPushResult
5472: oCall 5296
5474: oPop 1
5476: oEmit 48
5478: oGetLocal 3
5480: oPushResult
5481: oEmitLabel
5482: oPop 1
5484: oGetLocal 1
5486: oPushResult
5487: oCall 3501
5489: oPop 1
5491: oTypeSPop
5492: oCall 2239
5494: oCall 5910
5496: oEmit 32
5498: oEmit 46
5500: oGetLocal 2
5502: oPushResult
5503: oEmitLabel
5504: oPop 1
5506: oJumpForward 5553
5508: oGetLocal 1
5510: oPushResult
5511: oCall 5320
5513: oPop 1
5515: oEmit 48
5517: oGetLocal 3
5519: oPushResult
5520: oEmitLabel
5521: oPop 1
5523: oGetLocal 1
5525: oPushResult
5526: oCall 3501
5528: oPop 1
5530: oTypeSPop
5531: oCall 2239
5533: oCall 5910
5535: oEmit 33
5537: oEmit 46
5539: oGetLocal 2
5541: oPushResult
5542: oEmitLabel
5543: oPop 1
5545: oJumpForward 5553
5547: Choice Lookup Table
          44   5508
          43   5469
5552: oEndChoice
5553: oGetLocal 4
5555: oPushResult
5556: oGetLocal 2
5558: oPushResult
5559: oLoopPush
5560: oPop 2
5562: oInput 45
5564: oCall 4845
5566: oEmit 45
5568: oGetLocal 4
5570: oPushResult
5571: oEmitLabel
5572: oPop 1
5574: oEmit 48
5576: oGetLocal 2
5578: oPushResult
5579: oEmitLabel
5580: oPop 1
5582: oLoopPop
5583: oReturn
5584: oLocalSpace 3
5586: oGetAddrLocal 1
5588: oPushResult
5589: oLabelNew
5590: oAssign
5591: oEmit 48
5593: oGetLocal 1
5595: oPushResult
5596: oEmitLabel
5597: oPop 1
5599: oGetAddrLocal 2
5601: oPushResult
5602: oLabelNew
5603: oAssign
5604: oGetLocal 1
5606: oPushResult
5607: oGetLocal 2
5609: oPushResult
5610: oLoopPush
5611: oPop 2
5613: oCall 4845
5615: oInputChoice 5646
5617: oCall 4845
5619: oJumpForward 5652
5621: oGetAddrLocal 3
5623: oPushResult
5624: oCall 2262
5626: oPop 1
5628: oEmit 49
5630: oGetLocal 3
5632: oPushResult
5633: oEmitLabel
5634: oPop 1
5636: oGetLocal 1
5638: oPushResult
5639: oEmitLabel
5640: oPop 1
5642: oJumpForward 5654
5644: oJumpForward 5652
5646: Choice Lookup Table
          48   5621
           4   5617
5651: oEndChoice
5652: oJumpBack 5615
5654: oEmit 48
5656: oGetLocal 2
5658: oPushResult
5659: oEmitLabel
5660: oPop 1
5662: oLoopPop
5663: oReturn
5664: oLocalSpace 2
5666: oGetAddrLocal 1
5668: oPushResult
5669: oLabelNew
5670: oAssign
5671: oEmit 48
5673: oGetLocal 1
5675: oPushResult
5676: oEmitLabel
5677: oPop 1
5679: oGetAddrLocal 2
5681: oPushResult
5682: oCall 2262
5684: oPop 1
5686: oGetLocal 1
5688: oPushResult
5689: oGetLocal 2
5691: oPushResult
5692: oLoopPush
5693: oPop 2
5695: oInput 45
5697: oCall 4845
5699: oEmit 45
5701: oGetLocal 1
5703: oPushResult
5704: oEmitLabel
5705: oPop 1
5707: oEmit 48
5709: oGetLocal 2
5711: oPushResult
5712: oEmitLabel
5713: oPop 1
5715: oLoopPop
5716: oReturn
5717: oLocalSpace 0
5719: oLoopContinueLabel
5720: oPushResult
5721: oSetResult 0
5723: oPushResult
5724: equal_label
5725: oPop 2
5727: oChoice 5742
5729: oError 18
5731: oJumpForward 5748
5733: oEmit 45
5735: oLoopContinueLabel
5736: oPushResult
5737: oEmitLabel
5738: oPop 1
5740: oJumpForward 5748
5742: Choice Lookup Table
           0   5733
           1   5729
5747: oEndChoice
5748: oReturn
5749: oLocalSpace 0
5751: oLoopBreakLabel
5752: oPushResult
5753: oSetResult 0
5755: oPushResult
5756: equal_label
5757: oPop 2
5759: oChoice 5774
5761: oError 18
5763: oJumpForward 5780
5765: oEmit 45
5767: oLoopBreakLabel
5768: oPushResult
5769: oEmitLabel
5770: oPop 1
5772: oJumpForward 5780
5774: Choice Lookup Table
           0   5765
           1   5761
5779: oEndChoice
5780: oReturn
5781: oLocalSpace 0
5783: oCall 4845
5785: oInputChoice 5795
5787: oCall 4845
5789: oJumpForward 5801
5791: oJumpForward 5803
5793: oJumpForward 5801
5795: Choice Lookup Table
          34   5791
           4   5787
5800: oEndChoice
5801: oJumpBack 5785
5803: oReturn
5804: oLocalSpace 0
5806: oCall 5811
5808: oEmit 55
5810: oReturn
5811: oLocalSpace 0
5813: oInputChoice 5874
5815: oCall 2239
5817: oTypeSNodeType
5818: oChoice 5840
5820: oEmit 51
5822: oJumpForward 5855
5824: oEmit 52
5826: oJumpForward 5855
5828: oEmit 53
5830: oJumpForward 5855
5832: oError 16
5834: oJumpForward 5855
5836: oEmit 54
5838: oJumpForward 5855
5840: Choice Lookup Table
          23   5836
          17   5832
          21   5832
          22   5828
          19   5824
          18   5820
5853: oError 17
5855: oTypeSPop
5856: oInputChoice 5864
5858: oJumpForward 5872
5860: oJumpForward 5870
5862: oJumpForward 5870
5864: Choice Lookup Table
          12   5862
          14   5858
5869: oEndChoice
5870: oJumpBack 5815
5872: oJumpForward 5877
5874: Choice Lookup Table
          13   5815
5877: oReturn
5878: oLocalSpace 0
5880: oReturn
5881: oLocalSpace 0
5883: oReturn
5884: oLocalSpace 1
5886: oGetAddrLocal 1
5888: oPushResult
5889: oTypeSNodeType
5890: oAssign
5891: oTypeSPop
5892: oGetLocal 1
5894: oPushResult
5895: oTypeSNodeType
5896: oPushResult
5897: equal_node_type
5898: oPop 2
5900: oChoice 5906
5902: oError 14
5904: oJumpForward 5909
5906: Choice Lookup Table
           0   5902
5909: oReturn
5910: oLocalSpace 0
5912: oTypeSNodeType
5913: oChoice 5917
5915: oJumpForward 5922
5917: Choice Lookup Table
          18   5915
5920: oError 7
5922: oTypeSPop
5923: oReturn
5924: oLocalSpace 0
5926: oTypeSNodeType
5927: oChoice 5931
5929: oJumpForward 5936
5931: Choice Lookup Table
          18   5929
5934: oError 7
5936: oReturn
5937: oLocalSpace 0
5939: oTypeSNodeType
5940: oChoice 5944
5942: oJumpForward 5949
5944: Choice Lookup Table
          19   5942
5947: oError 8
5949: oTypeSPop
5950: oReturn
5951: oLocalSpace 0
5953: oTypeSNodeType
5954: oChoice 5958
5956: oJumpForward 5963
5958: Choice Lookup Table
          19   5956
5961: oError 8
5963: oReturn
5964: oLocalSpace 1
5966: oGetAddrLocal 1
5968: oPushResult
5969: oGetParam 2
5971: oPushResult
5972: oNodeNew
5973: oPop 1
5975: oAssign
5976: oGetLocal 1
5978: oPushResult
5979: oSetResult 2
5981: oPushResult
5982: oGetParam 1
5984: oPushResult
5985: oNodeSetInt
5986: oPop 3
5988: oGetLocal 1
5990: oPushResult
5991: oTypeAdd
5992: oPop 1
5994: oGetLocal 1
5996: oReturn
5997: oReturn
5998: oLocalSpace 1
6000: oGetAddrLocal 1
6002: oPushResult
6003: oGetParam 3
6005: oPushResult
6006: oNodeNew
6007: oPop 1
6009: oAssign
6010: oGetLocal 1
6012: oPushResult
6013: oSetResult 5
6015: oPushResult
6016: oGetParam 1
6018: oPushResult
6019: oNodeSetInt
6020: oPop 3
6022: oGetLocal 1
6024: oReturn
6025: oReturn
6026: oLocalSpace 1
6028: oGetAddrLocal 1
6030: oPushResult
6031: oGetParam 1
6033: oPushResult
6034: oSetResult 20
6036: oPushResult
6037: oNodeGet
6038: oPop 2
6040: oAssign
6041: oGetLocal 1
6043: oPushResult
6044: oNodeNull
6045: oPop 1
6047: oChoice 6103
6049: oGetAddrLocal 1
6051: oPushResult
6052: oSetResult 23
6054: oPushResult
6055: oNodeNew
6056: oPop 1
6058: oAssign
6059: oGetLocal 1
6061: oPushResult
6062: oSetResult 21
6064: oPushResult
6065: oGetParam 1
6067: oPushResult
6068: oNodeSet
6069: oPop 3
6071: oGetLocal 1
6073: oPushResult
6074: oSetResult 2
6076: oPushResult
6077: oSetResult 8
6079: oPushResult
6080: oNodeSetInt
6081: oPop 3
6083: oGetLocal 1
6085: oPushResult
6086: oTypeAdd
6087: oPop 1
6089: oGetParam 1
6091: oPushResult
6092: oSetResult 20
6094: oPushResult
6095: oGetLocal 1
6097: oPushResult
6098: oNodeSet
6099: oPop 3
6101: oJumpForward 6106
6103: Choice Lookup Table
           1   6049
6106: oGetLocal 1
6108: oReturn
6109: oReturn
6110: oLocalSpace 0
6112: oGetParam 1
6114: oPushResult
6115: oNodeType
6116: oPop 1
6118: oChoice 6146
6120: oMININT
6121: oReturn
6122: oJumpForward 6160
6124: oSetResult 0
6126: oReturn
6127: oJumpForward 6160
6129: oSetResult 0
6131: oReturn
6132: oJumpForward 6160
6134: oGetParam 1
6136: oPushResult
6137: oSetResult 23
6139: oPushResult
6140: oNodeGetInt
6141: oPop 2
6143: oReturn
6144: oJumpForward 6160
6146: Choice Lookup Table
          25   6134
          21   6129
          19   6124
          18   6120
6155: oError 3
6157: oSetResult 0
6159: oReturn
6160: oReturn
6161: oLocalSpace 0
6163: oGetParam 1
6165: oPushResult
6166: oSetResult 7
6168: oPushResult
6169: oNodeGetInt
6170: oPop 2
6172: oPushResult
6173: oEmitInt
6174: oPop 1
6176: oReturn
6177: oLocalSpace 1
6179: oGetAddrGlobal 3
6181: oPushResult
6182: oSetResult 17
6184: oPushResult
6185: oSetResult 4
6187: oPushResult
6188: oCall 5964
6190: oPop 2
6192: oAssign
6193: oGetAddrGlobal 4
6195: oPushResult
6196: oSetResult 18
6198: oPushResult
6199: oSetResult 4
6201: oPushResult
6202: oCall 5964
6204: oPop 2
6206: oAssign
6207: oGetAddrGlobal 5
6209: oPushResult
6210: oSetResult 19
6212: oPushResult
6213: oSetResult 1
6215: oPushResult
6216: oCall 5964
6218: oPop 2
6220: oAssign
6221: oGetAddrGlobal 6
6223: oPushResult
6224: oSetResult 20
6226: oPushResult
6227: oSetResult 1
6229: oPushResult
6230: oCall 5964
6232: oPop 2
6234: oAssign
6235: oGetAddrGlobal 7
6237: oPushResult
6238: oSetResult 21
6240: oPushResult
6241: oSetResult 1
6243: oPushResult
6244: oCall 5964
6246: oPop 2
6248: oAssign
6249: oGetAddrGlobal 8
6251: oPushResult
6252: oSetResult 22
6254: oPushResult
6255: oSetResult 256
6257: oPushResult
6258: oCall 5964
6260: oPop 2
6262: oAssign
6263: oGetAddrLocal 1
6265: oPushResult
6266: oSetResult 10
6268: oPushResult
6269: oSetResult 5
6271: oPushResult
6272: oIdAdd_File
6273: oPushResult
6274: oCall 5998
6276: oPop 3
6278: oAssign
6279: oGetLocal 1
6281: oPushResult
6282: oSetResult 6
6284: oPushResult
6285: oGetGlobal 3
6287: oPushResult
6288: oNodeSet
6289: oPop 3
6291: oGetLocal 1
6293: oPushResult
6294: oScopeDeclare
6295: oPop 1
6297: oGetAddrLocal 1
6299: oPushResult
6300: oSetResult 10
6302: oPushResult
6303: oSetResult 5
6305: oPushResult
6306: oIdAdd_Integer
6307: oPushResult
6308: oCall 5998
6310: oPop 3
6312: oAssign
6313: oGetLocal 1
6315: oPushResult
6316: oSetResult 6
6318: oPushResult
6319: oGetGlobal 4
6321: oPushResult
6322: oNodeSet
6323: oPop 3
6325: oGetLocal 1
6327: oPushResult
6328: oScopeDeclare
6329: oPop 1
6331: oGetAddrLocal 1
6333: oPushResult
6334: oSetResult 10
6336: oPushResult
6337: oSetResult 5
6339: oPushResult
6340: oIdAdd_Boolean
6341: oPushResult
6342: oCall 5998
6344: oPop 3
6346: oAssign
6347: oGetLocal 1
6349: oPushResult
6350: oSetResult 6
6352: oPushResult
6353: oGetGlobal 5
6355: oPushResult
6356: oNodeSet
6357: oPop 3
6359: oGetLocal 1
6361: oPushResult
6362: oScopeDeclare
6363: oPop 1
6365: oGetAddrLocal 1
6367: oPushResult
6368: oSetResult 10
6370: oPushResult
6371: oSetResult 5
6373: oPushResult
6374: oIdAdd_Char
6375: oPushResult
6376: oCall 5998
6378: oPop 3
6380: oAssign
6381: oGetLocal 1
6383: oPushResult
6384: oSetResult 6
6386: oPushResult
6387: oGetGlobal 7
6389: oPushResult
6390: oNodeSet
6391: oPop 3
6393: oGetLocal 1
6395: oPushResult
6396: oScopeDeclare
6397: oPop 1
6399: oGetAddrLocal 1
6401: oPushResult
6402: oSetResult 10
6404: oPushResult
6405: oSetResult 5
6407: oPushResult
6408: oIdAdd_String
6409: oPushResult
6410: oCall 5998
6412: oPop 3
6414: oAssign
6415: oGetLocal 1
6417: oPushResult
6418: oSetResult 6
6420: oPushResult
6421: oGetGlobal 8
6423: oPushResult
6424: oNodeSet
6425: oPop 3
6427: oGetLocal 1
6429: oPushResult
6430: oScopeDeclare
6431: oPop 1
6433: oGetAddrLocal 1
6435: oPushResult
6436: oSetResult 9
6438: oPushResult
6439: oSetResult 4
6441: oPushResult
6442: oIdAdd_True
6443: oPushResult
6444: oCall 5998
6446: oPop 3
6448: oAssign
6449: oGetLocal 1
6451: oPushResult
6452: oSetResult 6
6454: oPushResult
6455: oGetGlobal 5
6457: oPushResult
6458: oNodeSet
6459: oPop 3
6461: oGetLocal 1
6463: oPushResult
6464: oSetResult 7
6466: oPushResult
6467: oSetResult 1
6469: oPushResult
6470: oNodeSetInt
6471: oPop 3
6473: oGetLocal 1
6475: oPushResult
6476: oScopeDeclare
6477: oPop 1
6479: oGetAddrLocal 1
6481: oPushResult
6482: oSetResult 9
6484: oPushResult
6485: oSetResult 4
6487: oPushResult
6488: oIdAdd_False
6489: oPushResult
6490: oCall 5998
6492: oPop 3
6494: oAssign
6495: oGetLocal 1
6497: oPushResult
6498: oSetResult 6
6500: oPushResult
6501: oGetGlobal 5
6503: oPushResult
6504: oNodeSet
6505: oPop 3
6507: oGetLocal 1
6509: oPushResult
6510: oSetResult 7
6512: oPushResult
6513: oSetResult 0
6515: oPushResult
6516: oNodeSetInt
6517: oPop 3
6519: oGetLocal 1
6521: oPushResult
6522: oScopeDeclare
6523: oPop 1
6525: oReturn
