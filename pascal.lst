   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, kVar, LAST_ID )
 121:          oNodeSet( t, qType, FileType )
 133:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 139:          ','
 141:          pIdent
      
 143:          t = @newIdent( nVar, kVar, LAST_ID )
 159:          oNodeSet( t, qType, FileType )
 171:          oScopeDeclareAlloc( t )
      
 177:          ')'
 179:       | * :
 184:    ]
 184:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 186:    [
 186:       | pUses :  @UsesClause( program )
 195:       | * :
 200:    ]
 200:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 207:    oScopeBegin( 0, allocGlobal )
 216:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 221:    oScopeBegin( 0, allocDown )
 230:    initScope = oScopeCurrent
 235:    oNodeSet( program, qMainRoutineScope, initScope )
 247:    oScopeEnd
      
 248:    @BlockDecls( nGlobalVar )
      
      
 255:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 261:    boolean isMain = true
 267:    @BlockStmt( mainLabel, globalScope, isMain )
      
 280:    oScopeEnd   % main routine scope
      
 281:    '.'
 283:    oScopeEnd   % global scope
 284:    @EndUsedUnits( program )   % used units scopes
 292:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded)
      % and make the public portions of the named units visible to this program.
 292: UsesClause( Node user ):
 294:    {
 294:       pIdent
 296:       Node unit = @FindOrCompileUnit( LAST_ID )
 306:       [ equal_node( unit, Null )
 316:          | false :
 317:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % TO DO: put a declaration in the current scope, naming the unit and pointing to it.
                  %   This is to allow references to  <unit>.<identifier_in_unit>
                  %   Maybe something like nUsedUnit or nImportUnit
 329:          | * :
 334:       ]
 334:       [
 334:          | ',' :
 336:          | * :  >
 343:       ]
 343:    }   
 345:    ';'
 348:    ;
      
 348: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
 350:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 363:    {
 363:       Node unit = oNodeIterValue( unitIt )
 373:       [ oNodeNull( unit )
 380:          | false :
 381:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 394:          | * :
 399:             >
 401:       ]
 401:       oNodeIterNext( unitIt )
 407:    }
 410:    ;
      
 410: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 412:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 425:    {
 425:       Node unit = oNodeIterValue( unitIt )
 435:       [ oNodeNull( unit )
 442:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 443:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 459:                | true :
 460:                | false :  #eInternalScopeMismatch
 464:             ]
 472:             oScopeEnd
 473:          | * :
 478:             >
 480:       ]
 480:       oNodeIterNext( unitIt )
 486:    }
 489:    ;
      
      
 489: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 491:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 510:    [ equal_node( unit, Null )
 520:       | false :  >> unit
 524:       | * :
 529:    ]
      
         % If not, search for the source file on disk
 529:    boolean ok = oIncludeUnitFile( id )
 539:    [ ok
 542:       | false :  #eCantFindUnitFile  >> Null
 548:       | * :
 553:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 553:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 559:    oIncludeEnd
 560:    >> unit;
      
      
      
 564: Unit >> Node:
 566:    pUnit
 568:    pIdent
 570:    Node unit = oNodeNew( nUnit )
 580:    oNodeSetInt( unit, qIdent, LAST_ID )
 591:    oNodeAddLast( workspace, qUnits, unit )
 603:    ';'
 605:    [
 605:       | pUses :   @UsesClause( unit )
 614:       | * :
 619:    ]
 619:    @EnterUsedUnits( unit )
      
         % mandatory sections
      
         % NOTE, despite syntax diagrams, method headers in the interface may have 'external' clause.
         % Confirmed this looking at some units shipped with fpc.
 626:    pInterface
 628:    oScopeBegin( 0, allocGlobal )
 637:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 648:    oScopeBegin( 0, allocDown )
 657:    initScope = oScopeCurrent
 662:    oNodeSet( unit, qInitRoutineScope, initScope )
 674:    oScopeEnd
      
 675:    @UnitInterface( unit )
      
 682:    pImplementation
 684:    oScopeBegin( 0, allocGlobal )
 693:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 704:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 722:    @UnitImplementation( unit )
      
 729:    [
 729:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 741:       | * :                @UnitInitialization( unit, false )  % still need an implicit init routine
 756:    ]
 756:    [
 756:       | pFinalization :  @UnitFinalization( unit, true )
 768:       | * :              @UnitFinalization( unit, false )   % have an implicit final routine, may be handy later
 783:    ]
 783:    pEnd  '.'
 787:    oScopeEnd  % impl scope
 788:    oScopeEnd  % interface scope
 789:    @EndUsedUnits( unit )  % used units scopes
 796:    >> unit;
      
      
 800: UnitInterface( Node unit ):
 802:    {[
 802:       | pConst :     @ConstDecl
 806:       | pType :      @TypeDecl
 810:       | pVar :       @VarDecl( nGlobalVar )
      
 819:       | pProcedure :
 821:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 827:          [
 827:             | pExternal :
 829:                @ExternalDecl( decl )
 836:                ';'
 838:             | * :
 843:          ]
      
 843:       | pFunction :
 845:          Node decl = @FuncHeaderDecl
 851:          [
 851:             | pExternal :
 853:                @ExternalDecl( decl )
 860:                ';'
 862:             | * :
 867:          ]
      
 867:       | * :          >
 882:    ]}
 885:    ;
      
 885: UnitImplementation( Node unit ):
 887:    @BlockDecls( nGlobalVar )
 895:    ;
      
      
 895: UnitInitialization( Node unit, boolean hasStmts ):
 897:    Label label = oLabelNew
 902:    .tLabel  oEmitLabel( label )
 910:    oNodeSetLabel( unit, qInitLabel, label )
      
 922:    int patchLS
 922:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 931:    Node scope
 931:    Code initCode
      
 931:    scope = oNodeGet( unit, qPublicScope )
 944:    initCode = oNodeGetCode( scope, qInitCode )
 957:    oEmitCode( initCode )
 963:    oNodeSetCode( scope, qInitCode, codeNull )
      
 975:    scope = oNodeGet( unit, qPrivateScope )
 988:    initCode = oNodeGetCode( scope, qInitCode )
1001:    oEmitCode( initCode )
1007:    oNodeSetCode( scope, qInitCode, codeNull )
      
1019:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1032:    [ hasStmts
1035:       | true :     
1036:          @Statement
1038:          {[
1038:             | ';' :  @Statement
1042:             | * :    >
1049:          ]}
1051:       | * :
1056:    ]
      
1056:    .tReturn
      
1058:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1070:    oPatch( patchLS, localSpace )
1079:    oScopeEnd   % init routine scope, for temporaries
1081:    ;
      
      
1081: UnitFinalization( Node unit, boolean hasStmts ):
1083:    Label label = oLabelNew
1088:    .tLabel  oEmitLabel( label )
1096:    oNodeSetLabel( unit, qFinalLabel, label )
      
1108:    int patchLS
1108:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1117:    oScopeBegin( 0, allocDown )
      
1126:    [ hasStmts
1129:       | true :     
1130:          @Statement
1132:          {[
1132:             | ';' :  @Statement
1136:             | * :    >
1143:          ]}
1145:       | * :
1150:    ]
      
1150:    .tReturn
      
1152:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1164:    oPatch( patchLS, localSpace )
1173:    oScopeEnd   % final routine scope, for temporaries
1175:    ;
      
      
1175: Block( node_type varNodeType, Label labelForBody ):
1177:    @BlockDecls( varNodeType )
1184:    @BlockStmt( labelForBody, oScopeCurrent, false )
1197:    ;
      
      
1197: BlockDecls( node_type varNodeType ):
1199:    {[
1199:       | pConst :     @ConstDecl
1203:       | pType :      @TypeDecl
1207:       | pVar :       @VarDecl( varNodeType )
1216:       | pProcedure : @ProcDecl
1220:       | pFunction :  @FuncDecl
1224:       | * :          >
1239:    ]}
1241:    @CheckForUndefinedMethods
1244:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1244: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1247:    ;
      
      
1247: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1249:    NodeIter it = oNodeGetIter( workspace, qUnits )
1262:    {
1262:       Node unit = oNodeIterValue( it )
1272:       [ oNodeNull( unit )
1279:          | true :  >
1282:          | false :
1284:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1292:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1307:             .tFreeActuals  oEmitInt( 0 )
1315:             oNodeIterNext( it )
1321:       ]
1329:    };
      
      
1332: FinalizeUnits:
1334:    NodeIter it = oNodeGetIter( workspace, qUnits )
1347:    {
1347:       Node unit = oNodeIterValue( it )
1357:       [ oNodeNull( unit )
1364:          | true :  >
1367:          | false :
1369:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1377:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1392:             .tFreeActuals  oEmitInt( 0 )
1400:             oNodeIterNext( it )
1406:       ]
1414:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1417: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1419:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1427:    int patchLS
1427:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1436:    [ isMain
1439:       | true :  @InitializeUnits
1442:       | * :
1447:    ]
      
         % insert any code for initialization of this scope's variables
1447:    Code initCode = oNodeGetCode( varScope, qInitCode )
1460:    oEmitCode( initCode )
1466:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1478:    @Statement
      
1480:    [ isMain
1483:       | true :  @FinalizeUnits
1486:       | * :
1491:    ]
      
1491:    .tReturn
      
1493:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1505:    oPatch( patchLS, localSpace )
1515:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1515: MethodModifiers( Node decl ):
1517:    {[
1517:       | pCdecl :
1519:          oNodeSetBoolean( decl, qCdecl, true )
1531:          ';'
      
1533:       | * : >
1540:    ]}
1543:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1543: GetOrCreateInitCode >> Code:
1545:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1557:    [ equal_code( initCode, codeNull )
1567:       | true :
1568:          initCode = oCodeNew
1573:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1584:       | * :
1589:    ]
1589:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1593: ExternalDecl( Node decl ):
1595:    [ equal_zero( @DeclLevel( decl ) )
1607:       | false :  #eExternalMethodCannotBeNested
1610:       | * :
1615:    ]
1615:    oNodeSetBoolean( decl, qExternal, true )
1627:    [
1627:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1629:          [
1629:             | pName :
1631:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1633:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1644:             | * :
1649:          ]
1649:       | * :
1654:    ]
1655:    ;
      
      
1655: ProcHeaderDecl >> Node:
1657:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1659:    boolean redeclaring = false
1665:    Node decl = oScopeFindInCurrentScope
      
1670:    [ oNodeNull( decl )
1677:       | true :
               % first declaration
1678:          decl = @newIdent( nProc, kProc, LAST_ID )
1694:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1705:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1707:          redeclaring = true
1713:          [ oNodeGetBoolean( decl, qBodyDefined )
1723:             | true : #eAlreadyDefined
1726:             | * :
1731:          ]
1731:          [ oNodeGetBoolean( decl, qExternal )
1741:             | true : #eAlreadyDefined
1744:             | * :
1749:          ]
1749:          [ oNodeType( decl )
1756:             | nProc :
1757:             | * : #eAlreadyDefined   % wrong kind
1764:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1764:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1783:          oNodeSet( decl, qParams, Null )
1795:    ]
      
1803:    int level = @ScopeLevel
1809:    boolean nested = greater( level, 0 )
1822:    inc( level )
1828:    oScopeBegin( level, allocUp )
1837:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1842:    [ nested
1845:       | true :
1846:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1861:       | * :
1866:    ]
      
1866:    @FormalArgDecl
1868:    oNodeSet( decl, qParams, paramScope )
1880:    oScopeEnd
1881:    ';'
      
1883:    [ redeclaring
1886:       | false : oScopeDeclare( decl )
1893:       | true :  % TO DO: check that qParams is consistent with qOldParams
1895:    ]
      
1903:    @MethodModifiers( decl )
1910:    >> decl;
      
      
1914: ProcDecl:
1916:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1922:    [
1922:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1924:       | pExternal : @ExternalDecl( decl )
      
1933:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1940:          Node paramScope = oNodeGet( decl, qParams )
1953:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1959:          int level = oNodeGetInt( paramScope, qLevel )
1972:          oScopeBegin( level, allocDown )
1981:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1992:          Label label = oNodeGetLabel( decl, qValue )
2005:          @Block( nLocalVar, label )
2015:          oNodeSetBoolean( decl, qBodyDefined, true )
2027:          oScopeEnd
      
2028:          oScopeEnd  % paramScope
2029:    ]
2029:    ';';
      
      
      
2032: FuncHeaderDecl >> Node:
2034:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2036:    boolean redeclaring = false
2042:    Node decl = oScopeFindInCurrentScope
      
2047:    [ oNodeNull( decl )
2054:       | true :
               % first declaration
2055:          decl = @newIdent( nFunc, kFunc, LAST_ID )
2071:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2082:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2084:          redeclaring = true
2090:          [ oNodeGetBoolean( decl, qBodyDefined )
2100:             | true : #eAlreadyDefined
2103:             | * :
2108:          ]
2108:          [ oNodeType( decl )
2115:             | nFunc :
2116:             | * : #eAlreadyDefined   % wrong kind
2123:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2123:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2142:          oNodeSet( decl, qParams, Null )
2154:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2173:          oNodeSet( decl, qType, Null )
2185:    ]
      
2193:    int level = @ScopeLevel
2199:    boolean nested = greater( level, 0 )
2212:    inc( level )
2218:    oScopeBegin( level, allocUp )
2227:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2232:    [ nested
2235:       | true :
2236:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2251:       | * :
2256:    ]
      
2256:    @FormalArgDecl
2258:    oNodeSet( decl, qParams, paramScope )
      
2270:    ':'
      
2272:    Node theType
2272:    @TypeRef( theType )
2279:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2291:    Node ptrType = @PointerTypeTo( theType )
2302:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2318:    oScopeEnd
2319:    ';'
      
2321:    [ redeclaring
2324:       | false : oScopeDeclare( decl )
2331:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2333:    ]
      
2341:    @MethodModifiers( decl )
      
2348:    >> decl;
      
      
2352: FuncDecl:
2354:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2360:    [
2360:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2362:       | pExternal : @ExternalDecl( decl )
      
2371:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2378:          Node paramScope = oNodeGet( decl, qParams )
2391:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2397:          int level = oNodeGetInt( paramScope, qLevel )
2410:          oScopeBegin( level, allocDown )
2419:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2430:          Label label = oNodeGetLabel( decl, qValue )
2443:          @Block( nLocalVar, label )
2453:          oNodeSetBoolean( decl, qBodyDefined, true )
2465:          oScopeEnd
      
2466:          oScopeEnd  % paramScope
2467:    ]
2467:    ';';
      
      
2470: FormalArgDecl:
2472:    [
2472:       | '(' :
2474:          {
2474:             NodeVec decls = oNodeVecNew
2479:             Node decl
2479:             boolean isInOut = false
      
2485:             [
2485:                | pVar : isInOut = true
2493:                | * :
2498:             ]
      
2498:             {  pIdent
      
2500:                decl = @newIdent( nParam, kVar, LAST_ID )
2516:                oNodeSetBoolean( decl, qInOut, isInOut )
2528:                oNodeVecAppend( decls, decl )
      
2537:                [
2537:                   | ':' : >
2541:                   | ',' :
2543:                ]
2551:             }
      
2553:             Node theType
2553:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2560:             Node allocType
2560:             [ isInOut
2563:                | true :   allocType = @PointerTypeTo( theType )
2575:                | * :      allocType = theType
2586:             ]
      
2586:             int i = 0
2592:             {[ equal( i, oNodeVecSize( decls ) )
2606:                | false :
2607:                   decl = oNodeVecElement( decls, i )
      
2620:                   oNodeSet( decl, qType, theType )
2632:                   oScopeDeclare( decl )
2638:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2654:                   inc( i )
2660:                | * :
2665:                   >
2667:             ]}
      
2669:             oNodeVecDelete( decls )
      
2675:             [
2675:                | ')' : >
2679:                | ';' :
2681:             ]
2689:          }
2691:       | * :
2696:    ];
      
2697: ConstDecl:
2699:    {[
2699:       | pIdent :
2701:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2717:          '='
      
2719:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2721:          int val = oValueTop
2726:          oValuePop
2727:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2739:          oNodeSet( decl, qType, IntegerType )
      
2751:          oScopeDeclare( decl )
2757:          ';'
2759:       | * :
2764:          >
2766:    ]};
      
2769: TypeDecl:
2771:    {[
2771:       | pIdent :
2773:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2789:          '='
2791:          Node theType
2791:          @TypeRef( theType )
2798:          oNodeSet( decl, qType, theType )
2810:          oScopeDeclare( decl )
2816:          ';'
2818:       | * :
2823:          >
2825:    ]};
      
2828: VarDecl( node_type varNodeType ):
2830:    {[
2830:       | pIdent :
2832:          NodeVec decls = oNodeVecNew
2837:          Node decl
2837:          {
2837:             decl = @newIdent( varNodeType, kVar, LAST_ID )
2853:             oNodeVecAppend( decls, decl )
2862:             [
2862:                | ',' :
2864:                   pIdent
2866:                | * :
2871:                   >
2873:             ]
2873:          }
2875:          ':'
2877:          Node theType
2877:          @TypeRef( theType )
      
2884:          int i = 0
2890:          {[ equal( i, oNodeVecSize( decls ) )
2904:             | false :
2905:                decl = oNodeVecElement( decls, i )
2918:                oNodeSet( decl, qType, theType )
2930:                oScopeDeclareAlloc( decl )
2936:                inc( i )
2942:             | * :
2947:               >
2949:          ]}
      
               % optional initialization
2951:          [
2951:             | '=' :
2953:                [ oNodeVecSize( decls )
2960:                   | 1 :
2961:                   | * :  #eOnlyOneVarCanBeInitialized
2968:                ]
      
                     % we need an initCode stream for this scope
2968:                Code initCode = @GetOrCreateInitCode
2974:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
2980:                boolean changedScope = false
2986:                [ equal_zero( @ScopeLevel )
2993:                   | true : oScopeEnter( initScope )
3000:                            changedScope = true
3006:                   | * :
3011:                ]
                     % generate assignment in initCode stream
3011:                @LValueVar( decl )
3018:                @Expr
3020:                @MatchTypes
3022:                @Assign
3024:                [ changedScope
3027:                   | true : oScopeEnd
3029:                   | * :
3034:                ]
3034:                oCodePop
                   
3035:             | * :
3040:          ]
      
3040:          oNodeVecDelete( decls )
3046:          ';'
3048:       | * :
3053:          >
3055:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3058: TypeRef( out Node resultType ):
3060:    [
3060:       | pIdent :           % previously named type (including intrinsics)
3062:          Node decl = oScopeFindRequire
3067:          [ oNodeType( decl )
3074:            | nTypeDecl :
3075:                resultType = oNodeGet( decl, qType )
3088:            | * :
3093:                #eNotType
3095:                resultType = IntegerType
3101:          ]
         
3101:       | pArray :
3103:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3105:          NodeVec dimensions = oNodeVecNew
      
3110:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3110:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3120:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3132:             @ConstExpr
3134:             oNodeSetInt( subrange, qLow, oValueTop )
3145:             oValuePop
3146:             '..'
3148:             @ConstExpr
3150:             oNodeSetInt( subrange, qHigh, oValueTop )
3161:             oValuePop
3162:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3174:             oTypeAdd( subrange )
      
3180:             Node a = oNodeNew( nArrayType )
3190:             oNodeSet( a, qIndexType, subrange )
      
3202:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3211:             [
3211:                | ']' : >
3215:                | ',' :
3217:             ]
3225:          }
      
3227:          pOf
3229:          Node baseType
3229:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3236:          int dim = oNodeVecSize( dimensions )
      
3246:          {
3246:              dec(dim)
      
3252:              Node a = oNodeVecElement( dimensions, dim )
      
3265:              oNodeSet( a, qBaseType, baseType )
3277:              Node subrange = oNodeGet( a, qIndexType )
3290:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3317:              inc( width )
3323:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3349:              oTypeAdd( a )
3355:              baseType = a
      
3361:              [ equal_zero(dim)
3368:                  | true:  >
3371:                  | *:
3376:              ]
3376:          }
      
3378:          resultType = oNodeVecElement( dimensions, 0 )
3391:          oNodeVecDelete( dimensions )
      
3397:       | '^' :
3399:          Node theType
3399:          @TypeRef( theType )
3406:          resultType = @PointerTypeTo( theType )
      
3417:       | pRecord :
3419:          resultType = oNodeNew( nRecordType )
3429:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3438:          @VarDecl( nRecordField )
      
3445:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3457:          [ equal_zero( size )
3464:             | true : #eRecordEmpty
3467:             | * :
3472:          ]
      
3472:          pEnd
      
3474:          oNodeSet( resultType, qScope, oScopeCurrent )
3485:          oNodeSetInt( resultType, qSize, size )
3497:          oScopeEnd
3498:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3504:       | pSet :
3506:          pOf
3508:          Node theType
3508:          @TypeRef( theType )
3515:       | * :       % this works for cases except where expr starts with an id
3528:          @ConstExpr '..' @ConstExpr
3534:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3535: ConstExpr:
3537:    [
3537:       | pIntLit :
3539:          oValuePush( TOKEN_VALUE )
3544:       | pIdent :
3546:          Node decl = oScopeFindRequire
3551:          [ oNodeType( decl )
3558:             | nConst :
3559:                oValuePush( oNodeGetInt( decl, qValue ) )
3572:             | * :
3577:                #eNotConst
3579:                oValuePush( 0 )
3585:          ]
3585:       | pMinus :
3587:          @ConstExpr
3589:          oValueNegate
3590:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3601: Expr:
3603:    Label falseLabel = labelNull
      
3609:    @ExprAllowCF( falseLabel )
3616:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3624: BooleanExprControlFlow( out Label falseLabel ):
3626:    @ExprAllowCF( falseLabel )
3633:    [ oTypeSNodeType
3635:       | nBooleanCFType :
3636:       | nBooleanType :
               % convert value to control flow
3638:          falseLabel = oLabelNew
3643:          .tJumpFalse  oEmitLabel( falseLabel )
3651:       | * :
3658:          #eNotBoolean
3660:    ]
3660:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3662: CFToVal( inout Label falseLabel ):
3664:    [ oTypeSNodeType
3666:       | nBooleanCFType :
3667:          Label doneLabel = oLabelNew
3672:          .tPushConstI  oEmitInt( 1 )
3680:          .tJump  oEmitLabel( doneLabel )
3688:          .tLabel  oEmitLabel( falseLabel )
3696:          .tPushConstI  oEmitInt( 0 )
3704:          .tLabel  oEmitLabel( doneLabel )
3712:          oTypeSPop
3713:          oTypeSPush( BooleanType )
3719:          falseLabel = labelNull
3725:       | * :
3730:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3731: ValToCF( out Label falseLabel ):
3733:    [ oTypeSNodeType
3735:       | nBooleanType :
3736:          falseLabel = oLabelNew
3741:          .tJumpFalse  oEmitLabel( falseLabel )
3749:          oTypeSPop
3750:          oTypeSPush( BooleanCFType )
3756:       | * :
3761:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3762: ExprAllowCF( out Label falseLabel ):
3764:    @BoolExprAllowCF( falseLabel )
3771:    {[
3771:       | '=' :
3773:          @CFToVal( falseLabel )
3780:          @BoolExprAllowCF( falseLabel )
3787:          @CFToVal( falseLabel )
3794:          @MatchTypes
3796:          [ oTypeSNodeType
3798:             | nIntegerType, nBooleanType :  .tEqualI
3801:             | nPointerType :                .tEqualP
3805:             | nCharType, nStringType :      #eNotImplemented
3809:             | * :                           #eNotAllowed
3824:          ]
3824:          oTypeSPop
3825:          oTypeSPush( BooleanType )
      
3831:       | '<>' :
3833:          @CFToVal( falseLabel )
3840:          @BoolExprAllowCF( falseLabel )
3847:          @CFToVal( falseLabel )
3854:          @MatchTypes
3856:          [ oTypeSNodeType
3858:             | nIntegerType, nBooleanType :  .tNotEqualI
3861:             | nPointerType :                .tNotEqualP
3865:             | nCharType, nStringType :      #eNotImplemented
3869:             | * :                           #eNotAllowed
3884:          ]
3884:          oTypeSPop
3885:          oTypeSPush( BooleanType )
      
3891:       | '<' :
3893:          @CFToVal( falseLabel )
3900:          @BoolExprAllowCF( falseLabel )
3907:          @CFToVal( falseLabel )
3914:          @MatchTypes
3916:          [ oTypeSNodeType
3918:             | nIntegerType, nBooleanType :  .tLessI
3921:             | nCharType, nStringType :      #eNotImplemented
3925:             | * :                           #eNotAllowed
3938:          ]
3938:          oTypeSPop
3939:          oTypeSPush( BooleanType )
      
3945:       | '>' :
3947:          @CFToVal( falseLabel )
3954:          @BoolExprAllowCF( falseLabel )
3961:          @CFToVal( falseLabel )
3968:          @MatchTypes
3970:          [ oTypeSNodeType
3972:             | nIntegerType, nBooleanType :  .tGreaterI
3975:             | nCharType, nStringType :      #eNotImplemented
3979:             | * :                           #eNotAllowed
3992:          ]
3992:          oTypeSPop
3993:          oTypeSPush( BooleanType )
      
3999:       | '<=' :
4001:          @CFToVal( falseLabel )
4008:          @BoolExprAllowCF( falseLabel )
4015:          @CFToVal( falseLabel )
4022:          @MatchTypes
4024:          [ oTypeSNodeType
4026:             | nIntegerType, nBooleanType :  .tLessEqualI
4029:             | nCharType, nStringType :      #eNotImplemented
4033:             | * :                           #eNotAllowed
4046:          ]
4046:          oTypeSPop
4047:          oTypeSPush( BooleanType )
      
4053:       | '>=' :
4055:          @CFToVal( falseLabel )
4062:          @BoolExprAllowCF( falseLabel )
4069:          @CFToVal( falseLabel )
4076:          @MatchTypes
4078:          [ oTypeSNodeType
4080:             | nIntegerType, nBooleanType :  .tGreaterEqualI
4083:             | nCharType, nStringType :      #eNotImplemented
4087:             | * :                           #eNotAllowed
4100:          ]
4100:          oTypeSPop
4101:          oTypeSPush( BooleanType )
      
4107:       | * :
4122:          >
4124:    ]};
      
      
4127: BoolExprAllowCF( out Label falseLabel ):
4129:    Label trueLabel = labelNull
      
4135:    @BoolTermAllowCF( falseLabel )
4142:    {[
4142:       | pOr :
4144:          [ oTypeSNodeType
4146:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4147:                [ equal_label( trueLabel, labelNull )
4157:                   | true :  trueLabel = oLabelNew
4163:                   | * :
4168:                ]
4168:                .tJump  oEmitLabel( trueLabel )
4176:             | nBooleanType :
4178:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4185:                [ equal_label( trueLabel, labelNull )
4195:                   | true :  trueLabel = oLabelNew
4201:                   | * :
4206:                ]
4206:                .tJump  oEmitLabel( trueLabel )
4214:             | * : #eNotBoolean
4223:          ]
4223:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4224:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4232:          falseLabel = labelNull
4238:          @BoolTermAllowCF( falseLabel )
      
4245:          [ oTypeSNodeType
4247:             | nBooleanCFType :
4248:             | nBooleanType :
4250:                @ValToCF( falseLabel )
4257:             | * : #eNotBoolean
4266:          ]
      
4266:          oTypeSPop
4267:          oTypeSPush( BooleanCFType )
      
4273:       | * :
4278:          >
4280:    ]}
      
         % any short-circuit trues jump here to the end
4282:    [ equal_label( trueLabel, labelNull )
4292:       | false :
4293:          .tLabel  oEmitLabel( trueLabel )
4301:       | * :
4306:    ]
4307:    ;
      
      
4307: BoolTermAllowCF( out Label falseLabel ):
4309:    Label overallFalseLabel = labelNull
      
4315:    @BoolFactorAllowCF( falseLabel )
4322:    {[
4322:       | pAnd :
4324:          [ oTypeSNodeType
4326:             | nBooleanCFType :
4327:             | nBooleanType :
4329:                @ValToCF( falseLabel )
4336:             | * :
4343:                #eNotBoolean
4345:          ]
4345:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
4346:          [ equal_label( overallFalseLabel, labelNull )
4356:             | true :
4357:                overallFalseLabel = oLabelNew
4362:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
4376:                falseLabel = overallFalseLabel
4382:             | * :
4387:          ]
      
4387:          Label factorFalseLabel = labelNull
4393:          @BoolFactorAllowCF( factorFalseLabel )
      
4400:          [ oTypeSNodeType
4402:             | nBooleanCFType :
4403:             | nBooleanType :
4405:                @ValToCF( factorFalseLabel )
4412:             | * : #eNotBoolean
4421:          ]
4421:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
4435:       | * :
4440:          >
4442:    ]};
      
4445: BoolFactorAllowCF( out Label falseLabel ):
4447:    [
4447:       | pNot :
4449:          Label factorFalseLabel = labelNull
      
4455:          @BoolFactorAllowCF( factorFalseLabel )
4462:          [ oTypeSNodeType
4464:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4465:                falseLabel = oLabelNew
4470:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4478:                .tLabel  oEmitLabel( factorFalseLabel )
      
4486:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4488:                .tNot
      
4490:             | * : #eNotBoolean
4499:          ]
      
4499:       | * :
4504:          @ArithExprAllowCF( falseLabel )
4511:    ];
      
4512: ArithExprAllowCF( out Label falseLabel ):
4514:    @TermAllowCF( falseLabel )
4521:    {[
4521:       | pPlus :
4523:          @RequireIntPop
4525:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4532:          @RequireInt
4534:          .tAddI
4536:       | pMinus :
4538:          @RequireIntPop
4540:          @TermAllowCF( falseLabel )
4547:          @RequireInt
4549:          .tSubI
4551:       | * :
4558:          >
4560:    ]};
      
4563: TermAllowCF( out Label falseLabel ):
4565:    @FactorAllowCF( falseLabel )
4572:    {[
4572:       | pTimes :
4574:          @RequireIntPop
4576:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4583:          @RequireInt
4585:          .tMultI
4587:       | pDivide :
4589:          @RequireIntPop
4591:          @FactorAllowCF( falseLabel )
4598:          @RequireInt
4600:          .tDivI
4602:       | * :
4609:          >
4611:    ]};
      
4614: FactorAllowCF( out Label falseLabel ):
4616:    [
4616:       | pPlus :
4618:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4625:          @RequireInt
4627:       | pMinus :
4629:          @PrimaryAllowCF( falseLabel )
4636:          @RequireInt
4638:          .tNegI
4640:       | * :
4647:          @PrimaryAllowCF( falseLabel )
4654:    ];
      
4655: PrimaryAllowCF( out Label falseLabel ):
4657:    [
4657:       | pIntLit :
4659:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4666:          oTypeSPush( IntegerType )
      
4672:       | '(' :
4674:          @ExprAllowCF( falseLabel )
4681:          ')'
      
4683:       | pStrLit :
4685:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4694:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4702:          oTypeSPush( StringType )
      
4708:       | pIdent :
4710:          Node decl = oScopeFindRequire
4715:          Node theType
      
4715:          [ oNodeType( decl )
4722:             | nFunc :
      
4723:                @Call( decl )
      
4730:             | nConst :
4732:                theType = oNodeGet( decl, qType )
4745:                oTypeSPush( theType )
4751:                [ oTypeSNodeType
4753:                   | nIntegerType, nBooleanType :
4754:                      .tPushConstI @EmitValue( decl )
4763:                   | * :
4770:                      #eNotImplemented
4772:                ]
      
4772:             | nGlobalVar, nLocalVar, nParam :
4774:                @VarExpr( decl )
      
4781:             | * :
4794:                #eNotValue
4796:                oTypeSPush( IntegerType )
4802:          ]
      
4802:       | '@' :        % @var -- pointer to var
4804:          pIdent
      
4806:          Node decl = oScopeFindRequire
4811:          Node theType
      
4811:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
4818:          theType = oTypeSTop
4823:          oTypeSPop
4824:          Node ptrType = @PointerTypeTo( theType )
4835:          oTypeSPush( ptrType )
      
4841:       | * :
4854:          #eNotValue
4856:          oTypeSPush( IntegerType )
4862:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
4863: VarExpr( Node decl ):
4865:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
4878:    int uplevels = @DeclUpLevels( decl )
      
4889:    oTypeSPush( theType )
4895:    [ oTypeSNodeType
4897:       | nIntegerType :
4898:          [ oNodeType( decl )
4905:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
4915:             | nLocalVar :
4917:                [ equal_zero( uplevels )
4924:                   | true :  .tPushLocalI  @EmitValue( decl )
4934:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
4954:                ]
4954:             | nParam :
4956:                [ oNodeGetBoolean( decl, qInOut )
4966:                   | true :    % VAR param points to the var.  Auto dereference.
4967:                      [ equal_zero( uplevels )
4974:                         | true :  .tPushParamP  @EmitValue( decl )
4984:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5004:                      ]
5004:                      .tFetchI
5006:                   | * :
5011:                      [ equal_zero( uplevels )
5018:                         | true :  .tPushParamI  @EmitValue( decl )
5028:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5048:                      ]
5048:                ]
5048:          ]
      
5058:       | nBooleanType :
5060:          [ oNodeType( decl )
5067:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5077:             | nLocalVar :
5079:                [ equal_zero( uplevels )
5086:                   | true :  .tPushLocalB  @EmitValue( decl )
5096:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5116:                ]
5116:             | nParam :
5118:                [ oNodeGetBoolean( decl, qInOut )
5128:                   | true :    % VAR param points to the var.  Auto dereference.
5129:                      [ equal_zero( uplevels )
5136:                         | true :  .tPushParamP  @EmitValue( decl )
5146:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5166:                      ]
5166:                      .tFetchB
5168:                   | * :
5173:                      [ equal_zero( uplevels )
5180:                         | true :  .tPushParamB  @EmitValue( decl )
5190:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5210:                      ]
5210:                ]
5210:          ]
      
5220:       | nCharType, nStringType, nFileType :
5222:          #eNotImplemented
      
5224:       | nPointerType :
5226:          [ oNodeType( decl )
5233:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5243:             | nLocalVar :
5245:                [ equal_zero( uplevels )
5252:                   | true :  .tPushLocalP  @EmitValue( decl )
5262:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
5282:                ]
5282:             | nParam :
5284:                [ oNodeGetBoolean( decl, qInOut )
5294:                   | true :    % VAR param points to the var.  Auto dereference.
5295:                      [ equal_zero( uplevels )
5302:                         | true :  .tPushParamP  @EmitValue( decl )
5312:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5332:                      ]
5332:                      .tFetchP
5334:                   | * :
5339:                      [ equal_zero( uplevels )
5346:                         | true :  .tPushParamP  @EmitValue( decl )
5356:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5376:                      ]
5376:                ]
5376:          ]
5386:          [
5386:             | '^' :             % dereferenced
5388:                oTypeSPop
5389:                oTypeSPush( oNodeGet( theType, qBaseType ) )
5402:                @LValueIndexes
5404:                @FetchVar
5406:             | * :               % just ptr value alone
5411:          ]
      
5411:       | * :
               % compound type
               % first, push addr of start of var
5426:          [ oNodeType( decl )
5433:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5443:             | nLocalVar :
5445:                [ equal_zero( uplevels )
5452:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5462:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5482:                ]
5482:             | nParam :
5484:                [ oNodeGetBoolean( decl, qInOut )
5494:                   | true :    % VAR param points to the var.  Auto dereference.
5495:                      [ equal_zero( uplevels )
5502:                         | true :  .tPushParamP  @EmitValue( decl )
5512:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5532:                      ]
5532:                   | * :
5537:                      [ equal_zero( uplevels )
5544:                         | true :  .tPushAddrParam  @EmitValue( decl )
5554:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5574:                      ]
5574:                ]
5574:          ]
               % modify addr for subscripts, field references, etc
5584:          @LValueIndexes
               % get final value
5586:          @FetchVar
5588:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5589: FetchVar:
5591:    [ oTypeSNodeType
5593:       | nIntegerType :   .tFetchI
5596:       | nBooleanType :   .tFetchB
5600:       | nCharType, nStringType, nFileType : #eNotImplemented
5604:       | nPointerType :   .tFetchP
5608:       | * :              % compound type; leave as addr
5623:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5624: LValueIndexes:
5626:    {[
5626:       | '[' :       @ArraySubscripts
5630:       | '.' :       @RecordFieldRef
5634:       | '^' :       @PointerDeref
5638:       | * :         >
5649:    ]};
      
5652: ArraySubscripts:
5654:    [ oTypeSNodeType
5656:       | nArrayType :
5657:       | * :       #eNotArray
5664:    ]
5664:    {
5664:       [ oTypeSNodeType
5666:          | nArrayType :
5667:          | * :    #eTooManySubscripts
5674:       ]
      
            % low subscript of this dimension
5674:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5691:       Node baseType
5691:       baseType = oNodeGet( oTypeSTop, qBaseType )
5703:       oTypeSPop
5704:       oTypeSPush( baseType )
      
5710:       @Expr
5712:       @RequireIntPop
            % adjust for low subscript
5714:       [ equal_zero( low )
5721:          | false :
5722:             .tPushConstI oEmitInt( low ) .tSubI
5732:          | * :
5737:       ]
      
            % multiply by element size
5737:       int size = oNodeGetInt( baseType, qSize )
5750:       [ equal( size, 1 )
5760:          | false :
5761:             .tPushConstI oEmitInt( size ) .tMultI
5771:          | * :
5776:       ]
      
            % update start address
5776:       .tAddPI
5778:       [
5778:          | ']' :  >
5782:          | ',' :
5784:       ]
5792:    };
      
      
5795: RecordFieldRef:
5797:    [ oTypeSNodeType
5799:       | nRecordType :
5800:       | * :    #eNotRecord
5807:    ]
5807:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
5819:    pIdent
5821:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
5826:    [ oNodeType( field )
5833:       | nRecordField :
5834:       | * :   #eNotRecordField
5841:    ]
5841:    oScopeEnd
5842:    int offset = oNodeGetInt( field, qValue )
5855:    [ equal_zero( offset )
5862:       | false :
5863:          .tPushConstI oEmitInt( offset ) .tAddPI
5873:       | * :
5878:    ]
      
         % replace the type on the type stack, with the field type
5878:    oTypeSPop
5879:    oTypeSPush( oNodeGet( field, qType ) )
5893:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
5893: PointerDeref:
5895:    [ oTypeSNodeType
5897:       | nPointerType :
5898:       | * :       #eNotPointer
5905:    ]
5905:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
5907:    Node theType = oTypeSTop
5912:    oTypeSPop
5913:    oTypeSPush( oNodeGet( theType, qBaseType ) )
5927:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
5927: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
5929:    @MatchTypes
5932:    ;
      
      
      % Called on first use of an extern method
      %
5932: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
5934:    int strAddr
5934:    String externalName = oNodeGetString( method, qExternalName )
5947:    [ equal_string( externalName, stringNull )
5957:       | true :
5958:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
5979:       | false :
5981:          strAddr = oStringAllocLit( externalName )
5991:    ]
5999:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6015:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6015: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6017:    [ oNodeGetBoolean( method, qExternal )
6027:       | true :
6028:          [ oNodeGetBoolean( method, qCalled )
6038:             | false :
                     % define the extern label on first use
6039:                @DefineExternLabel( method )
6046:             | * :
6051:          ]
6051:      | * :
6056:    ]
6056:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6068:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6081:    Node resultType
6081:    int tempOffset
      
6081:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6098:    [ isFunc
6101:       | true :
6102:          resultType = oNodeGet( method, qType )
6115:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6125:       | * :
6130:    ]
         
      
6130:    Node paramScope = oNodeGet( method, qParams )
6143:    int actualsSize = oNodeGetInt( paramScope, qSize )
6156:    [ cdecl
6159:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6168:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6178:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6186:    [ greater( @DeclLevel( method ), 0 )
6201:       | true :
6202:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6210:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6229:          .tAssignP
6231:       | * :
6236:    ]
      
      
6236:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6249:    Node param = oNodeIterValue( paramIter )
6259:    [
6259:       | '(' :
            
6261:          {
6261:             [ oNodeNull( param )
6268:                | true : >
6271:                | * :
6276:             ]
      
6276:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
6289:             .tPushAddrActual oEmitInt( offset )
6297:             oTypeSPush( oNodeGet( param, qType ) )
      
6310:             [ oNodeGetBoolean( param, qInOut )
6320:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
6321:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
6323:                           @MatchTypes
      
6325:                           .tAssignP
      
6327:                | false :  @Expr
6331:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
6333:                           [ oTypeSNodeType
6335:                              | nIntegerType :            .tAssignI
6338:                              | nBooleanType :            .tAssignB
6342:                              | nCharType, nStringType, nFileType :   #eNotImplemented
6346:                              | nPointerType :            .tAssignP
6350:                              | * :
                                       % compound types: copy value into actuals space
6365:                                  int size = oNodeGetInt( oTypeSTop, qSize )
6377:                                  .tCopy  oEmitInt( size )    % multi-word copy
6385:                           ]
6385:             ]
6393:             oTypeSPop
      
6394:             oNodeIterNext( paramIter )
6400:             param = oNodeIterValue( paramIter )
6410:             [ oNodeNull( param )
6417:                | true :  >
6420:                | false :
6422:             ]
      
6430:             ','
6432:          }
      
6434:          ')'
      
6436:       | * :
6441:    ]
      
6441:    [ oNodeNull( param )
6448:       | false :    #eMissingParameter
6451:       | * :
6456:    ]
      
6456:    [ isFunc
6459:       | true :
               % Pass result temp as an additional VAR parameter.
6460:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6475:          .tPushAddrLocal  oEmitInt( tempOffset )
6483:          .tAssignP
6485:       | * :
6490:    ]
      
6490:    [ cdecl
6493:       | true :
6494:          .tCallCdecl  @EmitValue( method )
6503:       | false :
6505:          .tCall   @EmitValue( method )
6514:    ]
      
6522:    [ isFunc
6525:       | true :
               % push return value from temp
6526:          oTypeSPush( resultType )
      
6532:          [ oTypeSNodeType
6534:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6543:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6553:             | nCharType, nStringType, nFileType : #eNotImplemented
6557:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6567:             | * :              % compound type: push address
6582:                                .tPushAddrLocal  oEmitInt( tempOffset )
6590:          ]
6590:       | * :
6595:    ]
         
6595:    .tFreeActuals  oEmitInt( actualsSize )
6604:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6604: Statement:
6606:    [
6606:       | pWriteln :     @WritelnStmt
6610:       | pWrite :       @WriteStmt
6614:       | pReadln :      @ReadlnStmt
6618:       | pRead :        @ReadStmt
6622:       | pIf :          @IfStmt
6626:       | pWhile :       @WhileStmt
6630:       | pFor :         @ForStmt
6634:       | pRepeat :      @RepeatStmt
6638:       | pBreak :       @BreakStmt
6642:       | pContinue :    @ContinueStmt
6646:       | pBegin :       @BeginStmt
6650:       | pIdent :       @AssignOrCallStmt
6654:       | * :            % null statement : don't accept any tokens
6681:    ];
      
      
6682: AssignOrCallStmt:
6684:    Node decl = oScopeFindRequire
6689:    [ oNodeType( decl )
6696:       | nProc :                           @Call( decl )
6704:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6713:       | nFunc :                           @AssignResultStmt( decl )
6722:       | * :                               #eBadStatement
6737:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6738: AssignStmt( Node decl ):
      
6740:    @LValueVar( decl )
6747:    ':=' 
6749:    @Expr
6751:    @MatchTypes
6753:    @Assign
6756:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6756: Assign:
6758:    [ oTypeSNodeType
6760:       | nIntegerType :            .tAssignI
6763:       | nBooleanType :            .tAssignB
6767:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6771:       | nPointerType :            .tAssignP
6775:       | * :
6790:           int size = oNodeGetInt( oTypeSTop, qSize )
6802:           .tCopy  oEmitInt( size )    % multi-word copy
6810:    ]
6810:    oTypeSPop
6812:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
6812: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
6814:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
6830:       | false :   #eNotCurrentFunction
6833:       | * :
6838:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
6838:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
6853:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
6866:    ':='
6868:    @Expr
6870:    @MatchTypes
6872:    [ oTypeSNodeType
6874:       | nIntegerType :            .tAssignI
6877:       | nBooleanType :            .tAssignB
6881:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6885:       | nPointerType :            .tAssignP
6889:       | * :
6904:           int size = oNodeGetInt( oTypeSTop, qSize )
6916:           .tCopy  oEmitInt( size )    % multi-word copy
6924:    ]
6924:    oTypeSPop
6926:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
6926: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
6928:    pIdent
6930:    Node decl = oScopeFindRequire
6935:    [ oNodeType( decl )
6942:       | nGlobalVar, nLocalVar, nParam :
6943:       | * :  #eNotVar
6954:    ]
6954:    @LValueVar( decl )
6962:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
6962: LValueVar( Node decl ):
6964:    [ oNodeType( decl )
6971:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6981:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
6992:       | nParam :
6994:          [ oNodeGetBoolean( decl, qInOut )
7004:             | true :   % VAR param points to variable.  No dereference.
7005:                        .tPushParamP @EmitValue( decl )
7014:             | * :      .tPushAddrParam @EmitValue( decl )
7028:          ]
7028:       | * :            #eNotVar
7039:    ]
      
7039:    oTypeSPush( oNodeGet( decl, qType ) )
7052:    @LValueIndexes        % handle subscripts, if any
7055:    ;
      
      
7055: IncVar( Node decl ):
7057:    @LValueVar( decl )
7064:    @RequireIntPop
7066:    @VarExpr( decl )
7073:    oTypeSPop
7074:    .tIncI
7076:    .tAssignI;
      
7079: DecVar( Node decl ):
7081:    @LValueVar( decl )
7088:    @RequireIntPop
7090:    @VarExpr( decl )
7097:    oTypeSPop
7098:    .tDecI
7100:    .tAssignI;
      
      
7103: IfStmt:
7105:    Label falseLabel = labelNull
      
7111:    @BooleanExprControlFlow( falseLabel )
7118:    pThen
7120:    @Statement
7122:    [
7122:       | pElse :
7124:          Label doneLabel = oLabelNew
      
7129:          .tJump  oEmitLabel( doneLabel )
7137:          .tLabel oEmitLabel( falseLabel )
7145:          @Statement
7147:          .tLabel oEmitLabel( doneLabel )
      
7155:       | * :
7160:          .tLabel oEmitLabel( falseLabel )
7168:    ];
      
      
7169: ForStmt:
7171:    pIdent
      
7173:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
7178:    @LValueVar( decl )
7185:    @RequireIntPop
      
7187:    ':='
      
7189:    @Expr
7191:    @RequireIntPop
7193:    .tAssignI
      
7195:    Label breakLabel = oLabelNew
      
7200:    Label checkLabel = oLabelNew
7205:    .tJump  oEmitLabel( checkLabel )
      
7213:    Label continueLabel = oLabelNew
7218:    .tLabel  oEmitLabel( continueLabel )
7226:    [
7226:       | pTo :
7228:          @IncVar( decl )
7235:          .tLabel  oEmitLabel( checkLabel )
7243:          @VarExpr( decl )  oTypeSPop
7251:          @Expr
7253:          @RequireIntPop
7255:          .tGreaterI
7257:          .tJumpTrue  oEmitLabel( breakLabel )
7265:       | pDownto :
7267:          @DecVar( decl )
7274:          .tLabel  oEmitLabel( checkLabel )
7282:          @VarExpr( decl )  oTypeSPop
7290:          @Expr
7292:          @RequireIntPop
7294:          .tLessI
7296:          .tJumpTrue  oEmitLabel( breakLabel )
7304:    ]
7312:    oLoopPush( continueLabel, breakLabel )
7321:    pDo
7323:    @Statement
7325:    .tJump  oEmitLabel( continueLabel )
7333:    .tLabel  oEmitLabel( breakLabel )
7341:    oLoopPop;
      
      
7343: RepeatStmt:
7345:    Label continueLabel = oLabelNew
7350:    .tLabel  oEmitLabel( continueLabel )
      
7358:    Label breakLabel = oLabelNew
      
7363:    oLoopPush( continueLabel, breakLabel )
7372:    @Statement
7374:    {[
7374:       | ';' :
7376:          @Statement
7378:       | pUntil :
7380:          Label falseLabel
7380:          @BooleanExprControlFlow( falseLabel )
7387:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
7401:          >
7403:    ]}
7413:    .tLabel  oEmitLabel( breakLabel )
7421:    oLoopPop;
      
      
7423: WhileStmt:
7425:    Label continueLabel = oLabelNew
7430:    .tLabel  oEmitLabel( continueLabel )
      
7438:    Label breakLabel
7438:    @BooleanExprControlFlow( breakLabel )
      
7445:    oLoopPush( continueLabel, breakLabel )
7454:    pDo
7456:    @Statement
7458:    .tJump  oEmitLabel( continueLabel )
7466:    .tLabel  oEmitLabel( breakLabel )
7474:    oLoopPop;
      
      
7476: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7478:    [ equal_label( oLoopContinueLabel, labelNull )
7487:       | true :
7488:          #eNotInALoop
7490:       | false :
7492:          .tJump  oEmitLabel( oLoopContinueLabel )
7499:    ];
      
      
7508: BreakStmt:
7510:    [ equal_label( oLoopBreakLabel, labelNull )
7519:       | true :
7520:          #eNotInALoop
7522:       | false :
7524:          .tJump  oEmitLabel( oLoopBreakLabel )
7531:    ];
      
      
7540: BeginStmt:
7542:    @Statement
7544:    {[
7544:       | ';' :   @Statement
7548:       | pEnd :  >
7552:    ]};
      
      
7563: WritelnStmt:
7565:    @WriteStmt
7567:    .tWriteCR;
      
      
7570: WriteStmt:
7572:    [
7572:       | '(' :
7574:          {
7574:             @Expr
7576:             [ oTypeSNodeType
7578:                | nIntegerType :             .tWriteI
7581:                | nBooleanType :             .tWriteBool
7585:                | nStringType :              .tWriteStr
7589:                | nCharType, nFileType :     #eNotImplemented
7593:                | nPointerType :             .tWriteP
7597:                | * :                        #eNotAllowed
7614:             ]
7614:             oTypeSPop
7615:             [
7615:                | ')' : >
7619:                | ',' :
7621:             ]
7629:          }
7631:       | * :
7636:    ];
      
      
7637: ReadlnStmt:      % ***
         % TO DO
7640:    ;
      
7640: ReadStmt:
         % TO DO
7643:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7643: ScopeLevel >> int:
7645:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7655: DeclLevel( Node decl ) >> int:
7657:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7675: DeclUpLevels( Node decl ) >> int:
7677:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7693: MatchTypes:
7695:    node_type nt = oTypeSNodeType
7700:    oTypeSPop
7701:    [ equal_node_type( nt, oTypeSNodeType )
7710:       | false :
7711:          #eTypeMismatch
7713:       | * :
7718:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7719: RequireIntPop:
7721:    [ oTypeSNodeType
7723:       | nIntegerType :
7724:       | * :          #eNotInteger
7731:    ]
7731:    oTypeSPop;
      
7733: RequireInt:
7735:    [ oTypeSNodeType
7737:       | nIntegerType :
7738:       | * :          #eNotInteger
7745:    ];
      
7746: RequireBoolPop:
7748:    [ oTypeSNodeType
7750:       | nBooleanType :
7751:       | * :          #eNotBoolean
7758:    ]
7758:    oTypeSPop;
      
7760: RequireBool:
7762:    [ oTypeSNodeType
7764:       | nBooleanType :
7765:       | * :          #eNotBoolean
7772:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7773: newType( node_type nt, int size ) >> Node:
7775:   Node node = oNodeNew( nt )
7785:   oNodeSetInt( node, qSize, size )
7797:   oTypeAdd( node )
7803:   >> node
7807:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
7807: newIdent( node_type nt, kind k, int id ) >> Node:
7809:   Node t = oNodeNew( nt )
7819:   oNodeSetInt( t, qIdent, id )
7831:   >> t
7835:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
7835: PointerTypeTo( Node theType ) >> Node:
7837:    Node ptrType = oNodeGet( theType, qPointerType )
7850:    [ oNodeNull( ptrType )
7857:       | true :
7858:          ptrType = oNodeNew( nPointerType )
7868:          oNodeSet( ptrType, qBaseType, theType )
7880:          oNodeSetInt( ptrType, qSize, 8 )
7892:          oTypeAdd( ptrType )
7898:          oNodeSet( theType, qPointerType, ptrType )
7910:       | * :
7915:    ]
7915:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
7919: OrdinalLow( Node theType ) >> int:
7921:    [ oNodeType( theType )
7928:       | nIntegerType :  >> oMININT
7931:       | nBooleanType :  >> 0
7936:       | nCharType :     >> 0
7941:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
7953:       | * :             #eNotOrdinalType
7966:                         >> 0
7969:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
7970: EmitValue( Node decl ):
7972:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
7986: installBuiltIns:
      
         % install built-in types
7988:    FileType = @newType( nFileType, 4 )
8002:    IntegerType = @newType( nIntegerType, 4 )
8016:    BooleanType = @newType( nBooleanType, 1 )
8030:    BooleanCFType = @newType( nBooleanCFType, 1 )
8044:    CharType = @newType( nCharType, 1 )
8058:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8072:    Node t
      
8072:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
8088:    oNodeSet( t, qType, FileType )
8100:    oScopeDeclare( t )
      
8106:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
8122:    oNodeSet( t, qType, IntegerType )
8134:    oScopeDeclare( t )
      
8140:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
8156:    oNodeSet( t, qType, BooleanType )
8168:    oScopeDeclare( t )
      
8174:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
8190:    oNodeSet( t, qType, CharType )
8202:    oScopeDeclare( t )
      
8208:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
8224:    oNodeSet( t, qType, StringType )
8236:    oScopeDeclare( t )
      
         % Built-in constants
      
8242:    t = @newIdent( nConst, kConst, oIdAdd_True )
8258:    oNodeSet( t, qType, BooleanType )
8270:    oNodeSetInt( t, qValue, 1 )
8282:    oScopeDeclare( t )
      
8288:    t = @newIdent( nConst, kConst, oIdAdd_False )
8304:    oNodeSet( t, qType, BooleanType )
8316:    oNodeSetInt( t, qValue, 0 )
8328:    oScopeDeclare( t )
      
8335:    ;
      
8335: end
      
8335: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 6
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 7986
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 181
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 14
 110: oPushResult
 111: oSetResult 6
 113: oPushResult
 114: LAST_ID
 115: oPushResult
 116: oCall 7807
 118: oPop 3
 120: oAssign
 121: oGetLocal 1
 123: oPushResult
 124: oSetResult 20
 126: oPushResult
 127: oGetGlobal 3
 129: oPushResult
 130: oNodeSet
 131: oPop 3
 133: oGetLocal 1
 135: oPushResult
 136: oScopeDeclareAlloc
 137: oPop 1
 139: oInput 12
 141: oInput 0
 143: oGetAddrLocal 1
 145: oPushResult
 146: oSetResult 14
 148: oPushResult
 149: oSetResult 6
 151: oPushResult
 152: LAST_ID
 153: oPushResult
 154: oCall 7807
 156: oPop 3
 158: oAssign
 159: oGetLocal 1
 161: oPushResult
 162: oSetResult 20
 164: oPushResult
 165: oGetGlobal 3
 167: oPushResult
 168: oNodeSet
 169: oPop 3
 171: oGetLocal 1
 173: oPushResult
 174: oScopeDeclareAlloc
 175: oPop 1
 177: oInput 14
 179: oJumpForward 184
 181: Choice Lookup Table
          13    103
 184: oInput 4
 186: oInputChoice 197
 188: oGetLocal 4
 190: oPushResult
 191: oCall 292
 193: oPop 1
 195: oJumpForward 200
 197: Choice Lookup Table
          54    188
 200: oGetLocal 4
 202: oPushResult
 203: oCall 348
 205: oPop 1
 207: oSetResult 0
 209: oPushResult
 210: oSetResult 0
 212: oPushResult
 213: oScopeBegin
 214: oPop 2
 216: oGetAddrLocal 5
 218: oPushResult
 219: oScopeCurrent
 220: oAssign
 221: oSetResult 0
 223: oPushResult
 224: oSetResult 1
 226: oPushResult
 227: oScopeBegin
 228: oPop 2
 230: oGetAddrGlobal 2
 232: oPushResult
 233: oScopeCurrent
 234: oAssign
 235: oGetLocal 4
 237: oPushResult
 238: oSetResult 7
 240: oPushResult
 241: oGetGlobal 2
 243: oPushResult
 244: oNodeSet
 245: oPop 3
 247: oScopeEnd
 248: oSetResult 15
 250: oPushResult
 251: oCall 1197
 253: oPop 1
 255: oGetGlobal 2
 257: oPushResult
 258: oScopeEnter
 259: oPop 1
 261: oGetAddrLocal 6
 263: oPushResult
 264: oSetResult 1
 266: oAssign
 267: oGetLocal 3
 269: oPushResult
 270: oGetLocal 5
 272: oPushResult
 273: oGetLocal 6
 275: oPushResult
 276: oCall 1417
 278: oPop 3
 280: oScopeEnd
 281: oInput 19
 283: oScopeEnd
 284: oGetLocal 4
 286: oPushResult
 287: oCall 410
 289: oPop 1
 291: oReturn
 292: oLocalSpace 1
 294: oInput 0
 296: oGetAddrLocal 1
 298: oPushResult
 299: LAST_ID
 300: oPushResult
 301: oCall 489
 303: oPop 1
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oSetResult 0
 311: oPushResult
 312: equal_node
 313: oPop 2
 315: oChoice 331
 317: oGetParam 1
 319: oPushResult
 320: oSetResult 5
 322: oPushResult
 323: oGetLocal 1
 325: oPushResult
 326: oNodeAddLast
 327: oPop 3
 329: oJumpForward 334
 331: Choice Lookup Table
           0    317
 334: oInputChoice 338
 336: oJumpForward 343
 338: Choice Lookup Table
          12    336
 341: oJumpForward 345
 343: oJumpBack 294
 345: oInput 4
 347: oReturn
 348: oLocalSpace 2
 350: oGetAddrLocal 1
 352: oPushResult
 353: oGetParam 1
 355: oPushResult
 356: oSetResult 5
 358: oPushResult
 359: oNodeGetIter
 360: oPop 2
 362: oAssign
 363: oGetAddrLocal 2
 365: oPushResult
 366: oGetLocal 1
 368: oPushResult
 369: oNodeIterValue
 370: oPop 1
 372: oAssign
 373: oGetLocal 2
 375: oPushResult
 376: oNodeNull
 377: oPop 1
 379: oChoice 396
 381: oGetLocal 2
 383: oPushResult
 384: oSetResult 8
 386: oPushResult
 387: oNodeGet
 388: oPop 2
 390: oPushResult
 391: oScopeEnter
 392: oPop 1
 394: oJumpForward 401
 396: Choice Lookup Table
           0    381
 399: oJumpForward 409
 401: oGetAddrLocal 1
 403: oPushResult
 404: oNodeIterNext
 405: oPop 1
 407: oJumpBack 363
 409: oReturn
 410: oLocalSpace 2
 412: oGetAddrLocal 1
 414: oPushResult
 415: oGetParam 1
 417: oPushResult
 418: oSetResult 5
 420: oPushResult
 421: oNodeGetIter
 422: oPop 2
 424: oAssign
 425: oGetAddrLocal 2
 427: oPushResult
 428: oGetLocal 1
 430: oPushResult
 431: oNodeIterValue
 432: oPop 1
 434: oAssign
 435: oGetLocal 2
 437: oPushResult
 438: oNodeNull
 439: oPop 1
 441: oChoice 475
 443: oScopeCurrent
 444: oPushResult
 445: oGetLocal 2
 447: oPushResult
 448: oSetResult 8
 450: oPushResult
 451: oNodeGet
 452: oPop 2
 454: oPushResult
 455: oNodeEqual
 456: oPop 2
 458: oChoice 466
 460: oJumpForward 472
 462: oError 25
 464: oJumpForward 472
 466: Choice Lookup Table
           0    462
           1    460
 471: oEndChoice
 472: oScopeEnd
 473: oJumpForward 480
 475: Choice Lookup Table
           0    443
 478: oJumpForward 488
 480: oGetAddrLocal 1
 482: oPushResult
 483: oNodeIterNext
 484: oPop 1
 486: oJumpBack 425
 488: oReturn
 489: oLocalSpace 2
 491: oGetAddrLocal 1
 493: oPushResult
 494: oGetGlobal 1
 496: oPushResult
 497: oSetResult 1
 499: oPushResult
 500: oSetResult 4
 502: oPushResult
 503: oGetParam 1
 505: oPushResult
 506: oNodeFind
 507: oPop 4
 509: oAssign
 510: oGetLocal 1
 512: oPushResult
 513: oSetResult 0
 515: oPushResult
 516: equal_node
 517: oPop 2
 519: oChoice 526
 521: oGetLocal 1
 523: oReturn
 524: oJumpForward 529
 526: Choice Lookup Table
           0    521
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetParam 1
 534: oPushResult
 535: oIncludeUnitFile
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oChoice 550
 543: oError 24
 545: oSetResult 0
 547: oReturn
 548: oJumpForward 553
 550: Choice Lookup Table
           0    543
 553: oGetAddrLocal 1
 555: oPushResult
 556: oCall 564
 558: oAssign
 559: oIncludeEnd
 560: oGetLocal 1
 562: oReturn
 563: oReturn
 564: oLocalSpace 1
 566: oInput 55
 568: oInput 0
 570: oGetAddrLocal 1
 572: oPushResult
 573: oSetResult 5
 575: oPushResult
 576: oNodeNew
 577: oPop 1
 579: oAssign
 580: oGetLocal 1
 582: oPushResult
 583: oSetResult 4
 585: oPushResult
 586: LAST_ID
 587: oPushResult
 588: oNodeSetInt
 589: oPop 3
 591: oGetGlobal 1
 593: oPushResult
 594: oSetResult 1
 596: oPushResult
 597: oGetLocal 1
 599: oPushResult
 600: oNodeAddLast
 601: oPop 3
 603: oInput 4
 605: oInputChoice 616
 607: oGetLocal 1
 609: oPushResult
 610: oCall 292
 612: oPop 1
 614: oJumpForward 619
 616: Choice Lookup Table
          54    607
 619: oGetLocal 1
 621: oPushResult
 622: oCall 348
 624: oPop 1
 626: oInput 56
 628: oSetResult 0
 630: oPushResult
 631: oSetResult 0
 633: oPushResult
 634: oScopeBegin
 635: oPop 2
 637: oGetLocal 1
 639: oPushResult
 640: oSetResult 8
 642: oPushResult
 643: oScopeCurrent
 644: oPushResult
 645: oNodeSet
 646: oPop 3
 648: oSetResult 0
 650: oPushResult
 651: oSetResult 1
 653: oPushResult
 654: oScopeBegin
 655: oPop 2
 657: oGetAddrGlobal 2
 659: oPushResult
 660: oScopeCurrent
 661: oAssign
 662: oGetLocal 1
 664: oPushResult
 665: oSetResult 12
 667: oPushResult
 668: oGetGlobal 2
 670: oPushResult
 671: oNodeSet
 672: oPop 3
 674: oScopeEnd
 675: oGetLocal 1
 677: oPushResult
 678: oCall 800
 680: oPop 1
 682: oInput 57
 684: oSetResult 0
 686: oPushResult
 687: oSetResult 0
 689: oPushResult
 690: oScopeBegin
 691: oPop 2
 693: oGetLocal 1
 695: oPushResult
 696: oSetResult 9
 698: oPushResult
 699: oScopeCurrent
 700: oPushResult
 701: oNodeSet
 702: oPop 3
 704: oScopeCurrent
 705: oPushResult
 706: oSetResult 15
 708: oPushResult
 709: oGetLocal 1
 711: oPushResult
 712: oSetResult 8
 714: oPushResult
 715: oNodeGet
 716: oPop 2
 718: oPushResult
 719: oNodeSet
 720: oPop 3
 722: oGetLocal 1
 724: oPushResult
 725: oCall 885
 727: oPop 1
 729: oInputChoice 743
 731: oGetLocal 1
 733: oPushResult
 734: oSetResult 1
 736: oPushResult
 737: oCall 895
 739: oPop 2
 741: oJumpForward 756
 743: Choice Lookup Table
          58    731
 746: oGetLocal 1
 748: oPushResult
 749: oSetResult 0
 751: oPushResult
 752: oCall 895
 754: oPop 2
 756: oInputChoice 770
 758: oGetLocal 1
 760: oPushResult
 761: oSetResult 1
 763: oPushResult
 764: oCall 1081
 766: oPop 2
 768: oJumpForward 783
 770: Choice Lookup Table
          59    758
 773: oGetLocal 1
 775: oPushResult
 776: oSetResult 0
 778: oPushResult
 779: oCall 1081
 781: oPop 2
 783: oInput 34
 785: oInput 19
 787: oScopeEnd
 788: oScopeEnd
 789: oGetLocal 1
 791: oPushResult
 792: oCall 410
 794: oPop 1
 796: oGetLocal 1
 798: oReturn
 799: oReturn
 800: oLocalSpace 2
 802: oInputChoice 869
 804: oCall 2697
 806: oJumpForward 882
 808: oCall 2769
 810: oJumpForward 882
 812: oSetResult 15
 814: oPushResult
 815: oCall 2828
 817: oPop 1
 819: oJumpForward 882
 821: oGetAddrLocal 1
 823: oPushResult
 824: oCall 1655
 826: oAssign
 827: oInputChoice 840
 829: oGetLocal 1
 831: oPushResult
 832: oCall 1593
 834: oPop 1
 836: oInput 4
 838: oJumpForward 843
 840: Choice Lookup Table
          65    829
 843: oJumpForward 882
 845: oGetAddrLocal 2
 847: oPushResult
 848: oCall 2032
 850: oAssign
 851: oInputChoice 864
 853: oGetLocal 2
 855: oPushResult
 856: oCall 1593
 858: oPop 1
 860: oInput 4
 862: oJumpForward 867
 864: Choice Lookup Table
          65    853
 867: oJumpForward 882
 869: Choice Lookup Table
          29    845
          28    821
          32    812
          31    808
          30    804
 880: oJumpForward 884
 882: oJumpBack 802
 884: oReturn
 885: oLocalSpace 0
 887: oSetResult 15
 889: oPushResult
 890: oCall 1197
 892: oPop 1
 894: oReturn
 895: oLocalSpace 5
 897: oGetAddrLocal 1
 899: oPushResult
 900: oLabelNew
 901: oAssign
 902: oEmit 56
 904: oGetLocal 1
 906: oPushResult
 907: oEmitLabel
 908: oPop 1
 910: oGetParam 2
 912: oPushResult
 913: oSetResult 10
 915: oPushResult
 916: oGetLocal 1
 918: oPushResult
 919: oNodeSetLabel
 920: oPop 3
 922: oEmit 52
 924: oGetAddrLocal 2
 926: oPushResult
 927: Here
 928: oAssign
 929: oEmit 64
 931: oGetAddrLocal 3
 933: oPushResult
 934: oGetParam 2
 936: oPushResult
 937: oSetResult 8
 939: oPushResult
 940: oNodeGet
 941: oPop 2
 943: oAssign
 944: oGetAddrLocal 4
 946: oPushResult
 947: oGetLocal 3
 949: oPushResult
 950: oSetResult 18
 952: oPushResult
 953: oNodeGetCode
 954: oPop 2
 956: oAssign
 957: oGetLocal 4
 959: oPushResult
 960: oEmitCode
 961: oPop 1
 963: oGetLocal 3
 965: oPushResult
 966: oSetResult 18
 968: oPushResult
 969: oSetResult 0
 971: oPushResult
 972: oNodeSetCode
 973: oPop 3
 975: oGetAddrLocal 3
 977: oPushResult
 978: oGetParam 2
 980: oPushResult
 981: oSetResult 9
 983: oPushResult
 984: oNodeGet
 985: oPop 2
 987: oAssign
 988: oGetAddrLocal 4
 990: oPushResult
 991: oGetLocal 3
 993: oPushResult
 994: oSetResult 18
 996: oPushResult
 997: oNodeGetCode
 998: oPop 2
1000: oAssign
1001: oGetLocal 4
1003: oPushResult
1004: oEmitCode
1005: oPop 1
1007: oGetLocal 3
1009: oPushResult
1010: oSetResult 18
1012: oPushResult
1013: oSetResult 0
1015: oPushResult
1016: oNodeSetCode
1017: oPop 3
1019: oGetParam 2
1021: oPushResult
1022: oSetResult 12
1024: oPushResult
1025: oNodeGet
1026: oPop 2
1028: oPushResult
1029: oScopeEnter
1030: oPop 1
1032: oGetParam 1
1034: oChoice 1053
1036: oCall 6604
1038: oInputChoice 1044
1040: oCall 6604
1042: oJumpForward 1049
1044: Choice Lookup Table
           4   1040
1047: oJumpForward 1051
1049: oJumpBack 1038
1051: oJumpForward 1056
1053: Choice Lookup Table
           1   1036
1056: oEmit 51
1058: oGetAddrLocal 5
1060: oPushResult
1061: oScopeCurrent
1062: oPushResult
1063: oSetResult 16
1065: oPushResult
1066: oNodeGetInt
1067: oPop 2
1069: oAssign
1070: oGetLocal 2
1072: oPushResult
1073: oGetLocal 5
1075: oPushResult
1076: oPatch
1077: oPop 2
1079: oScopeEnd
1080: oReturn
1081: oLocalSpace 3
1083: oGetAddrLocal 1
1085: oPushResult
1086: oLabelNew
1087: oAssign
1088: oEmit 56
1090: oGetLocal 1
1092: oPushResult
1093: oEmitLabel
1094: oPop 1
1096: oGetParam 2
1098: oPushResult
1099: oSetResult 11
1101: oPushResult
1102: oGetLocal 1
1104: oPushResult
1105: oNodeSetLabel
1106: oPop 3
1108: oEmit 52
1110: oGetAddrLocal 2
1112: oPushResult
1113: Here
1114: oAssign
1115: oEmit 64
1117: oSetResult 0
1119: oPushResult
1120: oSetResult 1
1122: oPushResult
1123: oScopeBegin
1124: oPop 2
1126: oGetParam 1
1128: oChoice 1147
1130: oCall 6604
1132: oInputChoice 1138
1134: oCall 6604
1136: oJumpForward 1143
1138: Choice Lookup Table
           4   1134
1141: oJumpForward 1145
1143: oJumpBack 1132
1145: oJumpForward 1150
1147: Choice Lookup Table
           1   1130
1150: oEmit 51
1152: oGetAddrLocal 3
1154: oPushResult
1155: oScopeCurrent
1156: oPushResult
1157: oSetResult 16
1159: oPushResult
1160: oNodeGetInt
1161: oPop 2
1163: oAssign
1164: oGetLocal 2
1166: oPushResult
1167: oGetLocal 3
1169: oPushResult
1170: oPatch
1171: oPop 2
1173: oScopeEnd
1174: oReturn
1175: oLocalSpace 0
1177: oGetParam 2
1179: oPushResult
1180: oCall 1197
1182: oPop 1
1184: oGetParam 1
1186: oPushResult
1187: oScopeCurrent
1188: oPushResult
1189: oSetResult 0
1191: oPushResult
1192: oCall 1417
1194: oPop 3
1196: oReturn
1197: oLocalSpace 0
1199: oInputChoice 1226
1201: oCall 2697
1203: oJumpForward 1239
1205: oCall 2769
1207: oJumpForward 1239
1209: oGetParam 1
1211: oPushResult
1212: oCall 2828
1214: oPop 1
1216: oJumpForward 1239
1218: oCall 1914
1220: oJumpForward 1239
1222: oCall 2352
1224: oJumpForward 1239
1226: Choice Lookup Table
          29   1222
          28   1218
          32   1209
          31   1205
          30   1201
1237: oJumpForward 1241
1239: oJumpBack 1199
1241: oCall 1244
1243: oReturn
1244: oLocalSpace 0
1246: oReturn
1247: oLocalSpace 2
1249: oGetAddrLocal 1
1251: oPushResult
1252: oGetGlobal 1
1254: oPushResult
1255: oSetResult 1
1257: oPushResult
1258: oNodeGetIter
1259: oPop 2
1261: oAssign
1262: oGetAddrLocal 2
1264: oPushResult
1265: oGetLocal 1
1267: oPushResult
1268: oNodeIterValue
1269: oPop 1
1271: oAssign
1272: oGetLocal 2
1274: oPushResult
1275: oNodeNull
1276: oPop 1
1278: oChoice 1323
1280: oJumpForward 1331
1282: oJumpForward 1329
1284: oEmit 46
1286: oSetResult 0
1288: oPushResult
1289: oEmitInt
1290: oPop 1
1292: oEmit 49
1294: oGetLocal 2
1296: oPushResult
1297: oSetResult 10
1299: oPushResult
1300: oNodeGetLabel
1301: oPop 2
1303: oPushResult
1304: oEmitLabel
1305: oPop 1
1307: oEmit 48
1309: oSetResult 0
1311: oPushResult
1312: oEmitInt
1313: oPop 1
1315: oGetAddrLocal 1
1317: oPushResult
1318: oNodeIterNext
1319: oPop 1
1321: oJumpForward 1329
1323: Choice Lookup Table
           0   1284
           1   1280
1328: oEndChoice
1329: oJumpBack 1262
1331: oReturn
1332: oLocalSpace 2
1334: oGetAddrLocal 1
1336: oPushResult
1337: oGetGlobal 1
1339: oPushResult
1340: oSetResult 1
1342: oPushResult
1343: oNodeGetIter
1344: oPop 2
1346: oAssign
1347: oGetAddrLocal 2
1349: oPushResult
1350: oGetLocal 1
1352: oPushResult
1353: oNodeIterValue
1354: oPop 1
1356: oAssign
1357: oGetLocal 2
1359: oPushResult
1360: oNodeNull
1361: oPop 1
1363: oChoice 1408
1365: oJumpForward 1416
1367: oJumpForward 1414
1369: oEmit 46
1371: oSetResult 0
1373: oPushResult
1374: oEmitInt
1375: oPop 1
1377: oEmit 49
1379: oGetLocal 2
1381: oPushResult
1382: oSetResult 11
1384: oPushResult
1385: oNodeGetLabel
1386: oPop 2
1388: oPushResult
1389: oEmitLabel
1390: oPop 1
1392: oEmit 48
1394: oSetResult 0
1396: oPushResult
1397: oEmitInt
1398: oPop 1
1400: oGetAddrLocal 1
1402: oPushResult
1403: oNodeIterNext
1404: oPop 1
1406: oJumpForward 1414
1408: Choice Lookup Table
           0   1369
           1   1365
1413: oEndChoice
1414: oJumpBack 1347
1416: oReturn
1417: oLocalSpace 3
1419: oEmit 56
1421: oGetParam 3
1423: oPushResult
1424: oEmitLabel
1425: oPop 1
1427: oEmit 52
1429: oGetAddrLocal 1
1431: oPushResult
1432: Here
1433: oAssign
1434: oEmit 64
1436: oGetParam 1
1438: oChoice 1444
1440: oCall 1247
1442: oJumpForward 1447
1444: Choice Lookup Table
           1   1440
1447: oGetAddrLocal 2
1449: oPushResult
1450: oGetParam 2
1452: oPushResult
1453: oSetResult 18
1455: oPushResult
1456: oNodeGetCode
1457: oPop 2
1459: oAssign
1460: oGetLocal 2
1462: oPushResult
1463: oEmitCode
1464: oPop 1
1466: oGetParam 2
1468: oPushResult
1469: oSetResult 18
1471: oPushResult
1472: oSetResult 0
1474: oPushResult
1475: oNodeSetCode
1476: oPop 3
1478: oCall 6604
1480: oGetParam 1
1482: oChoice 1488
1484: oCall 1332
1486: oJumpForward 1491
1488: Choice Lookup Table
           1   1484
1491: oEmit 51
1493: oGetAddrLocal 3
1495: oPushResult
1496: oScopeCurrent
1497: oPushResult
1498: oSetResult 16
1500: oPushResult
1501: oNodeGetInt
1502: oPop 2
1504: oAssign
1505: oGetLocal 1
1507: oPushResult
1508: oGetLocal 3
1510: oPushResult
1511: oPatch
1512: oPop 2
1514: oReturn
1515: oLocalSpace 0
1517: oInputChoice 1535
1519: oGetParam 1
1521: oPushResult
1522: oSetResult 26
1524: oPushResult
1525: oSetResult 1
1527: oPushResult
1528: oNodeSetBoolean
1529: oPop 3
1531: oInput 4
1533: oJumpForward 1540
1535: Choice Lookup Table
          67   1519
1538: oJumpForward 1542
1540: oJumpBack 1517
1542: oReturn
1543: oLocalSpace 1
1545: oGetAddrLocal 1
1547: oPushResult
1548: oScopeCurrent
1549: oPushResult
1550: oSetResult 18
1552: oPushResult
1553: oNodeGetCode
1554: oPop 2
1556: oAssign
1557: oGetLocal 1
1559: oPushResult
1560: oSetResult 0
1562: oPushResult
1563: equal_code
1564: oPop 2
1566: oChoice 1586
1568: oGetAddrLocal 1
1570: oPushResult
1571: oCodeNew
1572: oAssign
1573: oScopeCurrent
1574: oPushResult
1575: oSetResult 18
1577: oPushResult
1578: oGetLocal 1
1580: oPushResult
1581: oNodeSetCode
1582: oPop 3
1584: oJumpForward 1589
1586: Choice Lookup Table
           1   1568
1589: oGetLocal 1
1591: oReturn
1592: oReturn
1593: oLocalSpace 0
1595: oGetParam 1
1597: oPushResult
1598: oCall 7655
1600: oPop 1
1602: oPushResult
1603: equal_zero
1604: oPop 1
1606: oChoice 1612
1608: oError 23
1610: oJumpForward 1615
1612: Choice Lookup Table
           0   1608
1615: oGetParam 1
1617: oPushResult
1618: oSetResult 24
1620: oPushResult
1621: oSetResult 1
1623: oPushResult
1624: oNodeSetBoolean
1625: oPop 3
1627: oInputChoice 1651
1629: oInputChoice 1646
1631: oInput 2
1633: oGetParam 1
1635: oPushResult
1636: oSetResult 25
1638: oPushResult
1639: CURRENT_STRLIT
1640: oPushResult
1641: oNodeSetString
1642: oPop 3
1644: oJumpForward 1649
1646: Choice Lookup Table
          66   1631
1649: oJumpForward 1654
1651: Choice Lookup Table
           2   1629
1654: oReturn
1655: oLocalSpace 6
1657: oInput 0
1659: oGetAddrLocal 1
1661: oPushResult
1662: oSetResult 0
1664: oAssign
1665: oGetAddrLocal 2
1667: oPushResult
1668: oScopeFindInCurrentScope
1669: oAssign
1670: oGetLocal 2
1672: oPushResult
1673: oNodeNull
1674: oPop 1
1676: oChoice 1797
1678: oGetAddrLocal 2
1680: oPushResult
1681: oSetResult 10
1683: oPushResult
1684: oSetResult 2
1686: oPushResult
1687: LAST_ID
1688: oPushResult
1689: oCall 7807
1691: oPop 3
1693: oAssign
1694: oGetLocal 2
1696: oPushResult
1697: oSetResult 21
1699: oPushResult
1700: oLabelNew
1701: oPushResult
1702: oNodeSetLabel
1703: oPop 3
1705: oJumpForward 1803
1707: oGetAddrLocal 1
1709: oPushResult
1710: oSetResult 1
1712: oAssign
1713: oGetLocal 2
1715: oPushResult
1716: oSetResult 23
1718: oPushResult
1719: oNodeGetBoolean
1720: oPop 2
1722: oChoice 1728
1724: oError 21
1726: oJumpForward 1731
1728: Choice Lookup Table
           1   1724
1731: oGetLocal 2
1733: oPushResult
1734: oSetResult 24
1736: oPushResult
1737: oNodeGetBoolean
1738: oPop 2
1740: oChoice 1746
1742: oError 21
1744: oJumpForward 1749
1746: Choice Lookup Table
           1   1742
1749: oGetLocal 2
1751: oPushResult
1752: oNodeType
1753: oPop 1
1755: oChoice 1759
1757: oJumpForward 1764
1759: Choice Lookup Table
          10   1757
1762: oError 21
1764: oGetLocal 2
1766: oPushResult
1767: oSetResult 28
1769: oPushResult
1770: oGetLocal 2
1772: oPushResult
1773: oSetResult 22
1775: oPushResult
1776: oNodeGet
1777: oPop 2
1779: oPushResult
1780: oNodeSet
1781: oPop 3
1783: oGetLocal 2
1785: oPushResult
1786: oSetResult 22
1788: oPushResult
1789: oSetResult 0
1791: oPushResult
1792: oNodeSet
1793: oPop 3
1795: oJumpForward 1803
1797: Choice Lookup Table
           0   1707
           1   1678
1802: oEndChoice
1803: oGetAddrLocal 3
1805: oPushResult
1806: oCall 7643
1808: oAssign
1809: oGetAddrLocal 4
1811: oPushResult
1812: oGetLocal 3
1814: oPushResult
1815: oSetResult 0
1817: oPushResult
1818: greater
1819: oPop 2
1821: oAssign
1822: oGetAddrLocal 3
1824: oPushResult
1825: inc
1826: oPop 1
1828: oGetLocal 3
1830: oPushResult
1831: oSetResult 2
1833: oPushResult
1834: oScopeBegin
1835: oPop 2
1837: oGetAddrLocal 5
1839: oPushResult
1840: oScopeCurrent
1841: oAssign
1842: oGetLocal 4
1844: oChoice 1863
1846: oGetAddrLocal 6
1848: oPushResult
1849: oGetGlobal 4
1851: oPushResult
1852: oCall 7835
1854: oPop 1
1856: oPushResult
1857: oScopeAllocType
1858: oPop 1
1860: oAssign
1861: oJumpForward 1866
1863: Choice Lookup Table
           1   1846
1866: oCall 2470
1868: oGetLocal 2
1870: oPushResult
1871: oSetResult 22
1873: oPushResult
1874: oGetLocal 5
1876: oPushResult
1877: oNodeSet
1878: oPop 3
1880: oScopeEnd
1881: oInput 4
1883: oGetLocal 1
1885: oChoice 1897
1887: oGetLocal 2
1889: oPushResult
1890: oScopeDeclare
1891: oPop 1
1893: oJumpForward 1903
1895: oJumpForward 1903
1897: Choice Lookup Table
           1   1895
           0   1887
1902: oEndChoice
1903: oGetLocal 2
1905: oPushResult
1906: oCall 1515
1908: oPop 1
1910: oGetLocal 2
1912: oReturn
1913: oReturn
1914: oLocalSpace 4
1916: oGetAddrLocal 1
1918: oPushResult
1919: oCall 1655
1921: oAssign
1922: oInputChoice 1935
1924: oJumpForward 2029
1926: oGetLocal 1
1928: oPushResult
1929: oCall 1593
1931: oPop 1
1933: oJumpForward 2029
1935: Choice Lookup Table
          65   1926
          64   1924
1940: oGetAddrLocal 2
1942: oPushResult
1943: oGetLocal 1
1945: oPushResult
1946: oSetResult 22
1948: oPushResult
1949: oNodeGet
1950: oPop 2
1952: oAssign
1953: oGetLocal 2
1955: oPushResult
1956: oScopeEnter
1957: oPop 1
1959: oGetAddrLocal 3
1961: oPushResult
1962: oGetLocal 2
1964: oPushResult
1965: oSetResult 13
1967: oPushResult
1968: oNodeGetInt
1969: oPop 2
1971: oAssign
1972: oGetLocal 3
1974: oPushResult
1975: oSetResult 1
1977: oPushResult
1978: oScopeBegin
1979: oPop 2
1981: oGetLocal 1
1983: oPushResult
1984: oSetResult 6
1986: oPushResult
1987: oScopeCurrent
1988: oPushResult
1989: oNodeSet
1990: oPop 3
1992: oGetAddrLocal 4
1994: oPushResult
1995: oGetLocal 1
1997: oPushResult
1998: oSetResult 21
2000: oPushResult
2001: oNodeGetLabel
2002: oPop 2
2004: oAssign
2005: oSetResult 16
2007: oPushResult
2008: oGetLocal 4
2010: oPushResult
2011: oCall 1175
2013: oPop 2
2015: oGetLocal 1
2017: oPushResult
2018: oSetResult 23
2020: oPushResult
2021: oSetResult 1
2023: oPushResult
2024: oNodeSetBoolean
2025: oPop 3
2027: oScopeEnd
2028: oScopeEnd
2029: oInput 4
2031: oReturn
2032: oLocalSpace 8
2034: oInput 0
2036: oGetAddrLocal 1
2038: oPushResult
2039: oSetResult 0
2041: oAssign
2042: oGetAddrLocal 2
2044: oPushResult
2045: oScopeFindInCurrentScope
2046: oAssign
2047: oGetLocal 2
2049: oPushResult
2050: oNodeNull
2051: oPop 1
2053: oChoice 2187
2055: oGetAddrLocal 2
2057: oPushResult
2058: oSetResult 11
2060: oPushResult
2061: oSetResult 3
2063: oPushResult
2064: LAST_ID
2065: oPushResult
2066: oCall 7807
2068: oPop 3
2070: oAssign
2071: oGetLocal 2
2073: oPushResult
2074: oSetResult 21
2076: oPushResult
2077: oLabelNew
2078: oPushResult
2079: oNodeSetLabel
2080: oPop 3
2082: oJumpForward 2193
2084: oGetAddrLocal 1
2086: oPushResult
2087: oSetResult 1
2089: oAssign
2090: oGetLocal 2
2092: oPushResult
2093: oSetResult 23
2095: oPushResult
2096: oNodeGetBoolean
2097: oPop 2
2099: oChoice 2105
2101: oError 21
2103: oJumpForward 2108
2105: Choice Lookup Table
           1   2101
2108: oGetLocal 2
2110: oPushResult
2111: oNodeType
2112: oPop 1
2114: oChoice 2118
2116: oJumpForward 2123
2118: Choice Lookup Table
          11   2116
2121: oError 21
2123: oGetLocal 2
2125: oPushResult
2126: oSetResult 28
2128: oPushResult
2129: oGetLocal 2
2131: oPushResult
2132: oSetResult 22
2134: oPushResult
2135: oNodeGet
2136: oPop 2
2138: oPushResult
2139: oNodeSet
2140: oPop 3
2142: oGetLocal 2
2144: oPushResult
2145: oSetResult 22
2147: oPushResult
2148: oSetResult 0
2150: oPushResult
2151: oNodeSet
2152: oPop 3
2154: oGetLocal 2
2156: oPushResult
2157: oSetResult 29
2159: oPushResult
2160: oGetLocal 2
2162: oPushResult
2163: oSetResult 20
2165: oPushResult
2166: oNodeGet
2167: oPop 2
2169: oPushResult
2170: oNodeSet
2171: oPop 3
2173: oGetLocal 2
2175: oPushResult
2176: oSetResult 20
2178: oPushResult
2179: oSetResult 0
2181: oPushResult
2182: oNodeSet
2183: oPop 3
2185: oJumpForward 2193
2187: Choice Lookup Table
           0   2084
           1   2055
2192: oEndChoice
2193: oGetAddrLocal 3
2195: oPushResult
2196: oCall 7643
2198: oAssign
2199: oGetAddrLocal 4
2201: oPushResult
2202: oGetLocal 3
2204: oPushResult
2205: oSetResult 0
2207: oPushResult
2208: greater
2209: oPop 2
2211: oAssign
2212: oGetAddrLocal 3
2214: oPushResult
2215: inc
2216: oPop 1
2218: oGetLocal 3
2220: oPushResult
2221: oSetResult 2
2223: oPushResult
2224: oScopeBegin
2225: oPop 2
2227: oGetAddrLocal 5
2229: oPushResult
2230: oScopeCurrent
2231: oAssign
2232: oGetLocal 4
2234: oChoice 2253
2236: oGetAddrLocal 6
2238: oPushResult
2239: oGetGlobal 4
2241: oPushResult
2242: oCall 7835
2244: oPop 1
2246: oPushResult
2247: oScopeAllocType
2248: oPop 1
2250: oAssign
2251: oJumpForward 2256
2253: Choice Lookup Table
           1   2236
2256: oCall 2470
2258: oGetLocal 2
2260: oPushResult
2261: oSetResult 22
2263: oPushResult
2264: oGetLocal 5
2266: oPushResult
2267: oNodeSet
2268: oPop 3
2270: oInput 11
2272: oGetAddrLocal 7
2274: oPushResult
2275: oCall 3058
2277: oPop 1
2279: oGetLocal 2
2281: oPushResult
2282: oSetResult 20
2284: oPushResult
2285: oGetLocal 7
2287: oPushResult
2288: oNodeSet
2289: oPop 3
2291: oGetAddrLocal 8
2293: oPushResult
2294: oGetLocal 7
2296: oPushResult
2297: oCall 7835
2299: oPop 1
2301: oAssign
2302: oGetLocal 2
2304: oPushResult
2305: oSetResult 30
2307: oPushResult
2308: oGetLocal 8
2310: oPushResult
2311: oScopeAllocType
2312: oPop 1
2314: oPushResult
2315: oNodeSetInt
2316: oPop 3
2318: oScopeEnd
2319: oInput 4
2321: oGetLocal 1
2323: oChoice 2335
2325: oGetLocal 2
2327: oPushResult
2328: oScopeDeclare
2329: oPop 1
2331: oJumpForward 2341
2333: oJumpForward 2341
2335: Choice Lookup Table
           1   2333
           0   2325
2340: oEndChoice
2341: oGetLocal 2
2343: oPushResult
2344: oCall 1515
2346: oPop 1
2348: oGetLocal 2
2350: oReturn
2351: oReturn
2352: oLocalSpace 4
2354: oGetAddrLocal 1
2356: oPushResult
2357: oCall 2032
2359: oAssign
2360: oInputChoice 2373
2362: oJumpForward 2467
2364: oGetLocal 1
2366: oPushResult
2367: oCall 1593
2369: oPop 1
2371: oJumpForward 2467
2373: Choice Lookup Table
          65   2364
          64   2362
2378: oGetAddrLocal 2
2380: oPushResult
2381: oGetLocal 1
2383: oPushResult
2384: oSetResult 22
2386: oPushResult
2387: oNodeGet
2388: oPop 2
2390: oAssign
2391: oGetLocal 2
2393: oPushResult
2394: oScopeEnter
2395: oPop 1
2397: oGetAddrLocal 3
2399: oPushResult
2400: oGetLocal 2
2402: oPushResult
2403: oSetResult 13
2405: oPushResult
2406: oNodeGetInt
2407: oPop 2
2409: oAssign
2410: oGetLocal 3
2412: oPushResult
2413: oSetResult 1
2415: oPushResult
2416: oScopeBegin
2417: oPop 2
2419: oGetLocal 1
2421: oPushResult
2422: oSetResult 6
2424: oPushResult
2425: oScopeCurrent
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oGetAddrLocal 4
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oSetResult 21
2438: oPushResult
2439: oNodeGetLabel
2440: oPop 2
2442: oAssign
2443: oSetResult 16
2445: oPushResult
2446: oGetLocal 4
2448: oPushResult
2449: oCall 1175
2451: oPop 2
2453: oGetLocal 1
2455: oPushResult
2456: oSetResult 23
2458: oPushResult
2459: oSetResult 1
2461: oPushResult
2462: oNodeSetBoolean
2463: oPop 3
2465: oScopeEnd
2466: oScopeEnd
2467: oInput 4
2469: oReturn
2470: oLocalSpace 6
2472: oInputChoice 2693
2474: oGetAddrLocal 1
2476: oPushResult
2477: oNodeVecNew
2478: oAssign
2479: oGetAddrLocal 3
2481: oPushResult
2482: oSetResult 0
2484: oAssign
2485: oInputChoice 2495
2487: oGetAddrLocal 3
2489: oPushResult
2490: oSetResult 1
2492: oAssign
2493: oJumpForward 2498
2495: Choice Lookup Table
          32   2487
2498: oInput 0
2500: oGetAddrLocal 2
2502: oPushResult
2503: oSetResult 18
2505: oPushResult
2506: oSetResult 6
2508: oPushResult
2509: LAST_ID
2510: oPushResult
2511: oCall 7807
2513: oPop 3
2515: oAssign
2516: oGetLocal 2
2518: oPushResult
2519: oSetResult 31
2521: oPushResult
2522: oGetLocal 3
2524: oPushResult
2525: oNodeSetBoolean
2526: oPop 3
2528: oGetLocal 1
2530: oPushResult
2531: oGetLocal 2
2533: oPushResult
2534: oNodeVecAppend
2535: oPop 2
2537: oInputChoice 2545
2539: oJumpForward 2553
2541: oJumpForward 2551
2543: oJumpForward 2551
2545: Choice Lookup Table
          12   2543
          11   2539
2550: oEndChoice
2551: oJumpBack 2498
2553: oGetAddrLocal 4
2555: oPushResult
2556: oCall 3058
2558: oPop 1
2560: oGetLocal 3
2562: oChoice 2577
2564: oGetAddrLocal 5
2566: oPushResult
2567: oGetLocal 4
2569: oPushResult
2570: oCall 7835
2572: oPop 1
2574: oAssign
2575: oJumpForward 2586
2577: Choice Lookup Table
           1   2564
2580: oGetAddrLocal 5
2582: oPushResult
2583: oGetLocal 4
2585: oAssign
2586: oGetAddrLocal 6
2588: oPushResult
2589: oSetResult 0
2591: oAssign
2592: oGetLocal 6
2594: oPushResult
2595: oGetLocal 1
2597: oPushResult
2598: oNodeVecSize
2599: oPop 1
2601: oPushResult
2602: equal
2603: oPop 2
2605: oChoice 2662
2607: oGetAddrLocal 2
2609: oPushResult
2610: oGetLocal 1
2612: oPushResult
2613: oGetLocal 6
2615: oPushResult
2616: oNodeVecElement
2617: oPop 2
2619: oAssign
2620: oGetLocal 2
2622: oPushResult
2623: oSetResult 20
2625: oPushResult
2626: oGetLocal 4
2628: oPushResult
2629: oNodeSet
2630: oPop 3
2632: oGetLocal 2
2634: oPushResult
2635: oScopeDeclare
2636: oPop 1
2638: oGetLocal 2
2640: oPushResult
2641: oSetResult 21
2643: oPushResult
2644: oGetLocal 5
2646: oPushResult
2647: oScopeAllocType
2648: oPop 1
2650: oPushResult
2651: oNodeSetInt
2652: oPop 3
2654: oGetAddrLocal 6
2656: oPushResult
2657: inc
2658: oPop 1
2660: oJumpForward 2667
2662: Choice Lookup Table
           0   2607
2665: oJumpForward 2669
2667: oJumpBack 2592
2669: oGetLocal 1
2671: oPushResult
2672: oNodeVecDelete
2673: oPop 1
2675: oInputChoice 2683
2677: oJumpForward 2691
2679: oJumpForward 2689
2681: oJumpForward 2689
2683: Choice Lookup Table
           4   2681
          14   2677
2688: oEndChoice
2689: oJumpBack 2474
2691: oJumpForward 2696
2693: Choice Lookup Table
          13   2474
2696: oReturn
2697: oLocalSpace 2
2699: oInputChoice 2761
2701: oGetAddrLocal 1
2703: oPushResult
2704: oSetResult 12
2706: oPushResult
2707: oSetResult 4
2709: oPushResult
2710: LAST_ID
2711: oPushResult
2712: oCall 7807
2714: oPop 3
2716: oAssign
2717: oInput 5
2719: oCall 3535
2721: oGetAddrLocal 2
2723: oPushResult
2724: oValueTop
2725: oAssign
2726: oValuePop
2727: oGetLocal 1
2729: oPushResult
2730: oSetResult 21
2732: oPushResult
2733: oGetLocal 2
2735: oPushResult
2736: oNodeSetInt
2737: oPop 3
2739: oGetLocal 1
2741: oPushResult
2742: oSetResult 20
2744: oPushResult
2745: oGetGlobal 4
2747: oPushResult
2748: oNodeSet
2749: oPop 3
2751: oGetLocal 1
2753: oPushResult
2754: oScopeDeclare
2755: oPop 1
2757: oInput 4
2759: oJumpForward 2766
2761: Choice Lookup Table
           0   2701
2764: oJumpForward 2768
2766: oJumpBack 2699
2768: oReturn
2769: oLocalSpace 2
2771: oInputChoice 2820
2773: oGetAddrLocal 1
2775: oPushResult
2776: oSetResult 13
2778: oPushResult
2779: oSetResult 5
2781: oPushResult
2782: LAST_ID
2783: oPushResult
2784: oCall 7807
2786: oPop 3
2788: oAssign
2789: oInput 5
2791: oGetAddrLocal 2
2793: oPushResult
2794: oCall 3058
2796: oPop 1
2798: oGetLocal 1
2800: oPushResult
2801: oSetResult 20
2803: oPushResult
2804: oGetLocal 2
2806: oPushResult
2807: oNodeSet
2808: oPop 3
2810: oGetLocal 1
2812: oPushResult
2813: oScopeDeclare
2814: oPop 1
2816: oInput 4
2818: oJumpForward 2825
2820: Choice Lookup Table
           0   2773
2823: oJumpForward 2827
2825: oJumpBack 2771
2827: oReturn
2828: oLocalSpace 6
2830: oInputChoice 3050
2832: oGetAddrLocal 1
2834: oPushResult
2835: oNodeVecNew
2836: oAssign
2837: oGetAddrLocal 2
2839: oPushResult
2840: oGetParam 1
2842: oPushResult
2843: oSetResult 6
2845: oPushResult
2846: LAST_ID
2847: oPushResult
2848: oCall 7807
2850: oPop 3
2852: oAssign
2853: oGetLocal 1
2855: oPushResult
2856: oGetLocal 2
2858: oPushResult
2859: oNodeVecAppend
2860: oPop 2
2862: oInputChoice 2868
2864: oInput 0
2866: oJumpForward 2873
2868: Choice Lookup Table
          12   2864
2871: oJumpForward 2875
2873: oJumpBack 2837
2875: oInput 11
2877: oGetAddrLocal 3
2879: oPushResult
2880: oCall 3058
2882: oPop 1
2884: oGetAddrLocal 4
2886: oPushResult
2887: oSetResult 0
2889: oAssign
2890: oGetLocal 4
2892: oPushResult
2893: oGetLocal 1
2895: oPushResult
2896: oNodeVecSize
2897: oPop 1
2899: oPushResult
2900: equal
2901: oPop 2
2903: oChoice 2944
2905: oGetAddrLocal 2
2907: oPushResult
2908: oGetLocal 1
2910: oPushResult
2911: oGetLocal 4
2913: oPushResult
2914: oNodeVecElement
2915: oPop 2
2917: oAssign
2918: oGetLocal 2
2920: oPushResult
2921: oSetResult 20
2923: oPushResult
2924: oGetLocal 3
2926: oPushResult
2927: oNodeSet
2928: oPop 3
2930: oGetLocal 2
2932: oPushResult
2933: oScopeDeclareAlloc
2934: oPop 1
2936: oGetAddrLocal 4
2938: oPushResult
2939: inc
2940: oPop 1
2942: oJumpForward 2949
2944: Choice Lookup Table
           0   2905
2947: oJumpForward 2951
2949: oJumpBack 2890
2951: oInputChoice 3037
2953: oGetLocal 1
2955: oPushResult
2956: oNodeVecSize
2957: oPop 1
2959: oChoice 2963
2961: oJumpForward 2968
2963: Choice Lookup Table
           1   2961
2966: oError 22
2968: oGetAddrLocal 5
2970: oPushResult
2971: oCall 1543
2973: oAssign
2974: oGetLocal 5
2976: oPushResult
2977: oCodePush
2978: oPop 1
2980: oGetAddrLocal 6
2982: oPushResult
2983: oSetResult 0
2985: oAssign
2986: oCall 7643
2988: oPushResult
2989: equal_zero
2990: oPop 1
2992: oChoice 3008
2994: oGetGlobal 2
2996: oPushResult
2997: oScopeEnter
2998: oPop 1
3000: oGetAddrLocal 6
3002: oPushResult
3003: oSetResult 1
3005: oAssign
3006: oJumpForward 3011
3008: Choice Lookup Table
           1   2994
3011: oGetLocal 2
3013: oPushResult
3014: oCall 6962
3016: oPop 1
3018: oCall 3601
3020: oCall 7693
3022: oCall 6756
3024: oGetLocal 6
3026: oChoice 3031
3028: oScopeEnd
3029: oJumpForward 3034
3031: Choice Lookup Table
           1   3028
3034: oCodePop
3035: oJumpForward 3040
3037: Choice Lookup Table
           5   2953
3040: oGetLocal 1
3042: oPushResult
3043: oNodeVecDelete
3044: oPop 1
3046: oInput 4
3048: oJumpForward 3055
3050: Choice Lookup Table
           0   2832
3053: oJumpForward 3057
3055: oJumpBack 2830
3057: oReturn
3058: oLocalSpace 12
3060: oInputChoice 3517
3062: oGetAddrLocal 1
3064: oPushResult
3065: oScopeFindRequire
3066: oAssign
3067: oGetLocal 1
3069: oPushResult
3070: oNodeType
3071: oPop 1
3073: oChoice 3090
3075: oGetParam 1
3077: oPushResult
3078: oGetLocal 1
3080: oPushResult
3081: oSetResult 20
3083: oPushResult
3084: oNodeGet
3085: oPop 2
3087: oAssign
3088: oJumpForward 3101
3090: Choice Lookup Table
          13   3075
3093: oError 2
3095: oGetParam 1
3097: oPushResult
3098: oGetGlobal 4
3100: oAssign
3101: oJumpForward 3534
3103: oInput 15
3105: oGetAddrLocal 2
3107: oPushResult
3108: oNodeVecNew
3109: oAssign
3110: oGetAddrLocal 3
3112: oPushResult
3113: oSetResult 28
3115: oPushResult
3116: oNodeNew
3117: oPop 1
3119: oAssign
3120: oGetLocal 3
3122: oPushResult
3123: oSetResult 33
3125: oPushResult
3126: oGetGlobal 4
3128: oPushResult
3129: oNodeSet
3130: oPop 3
3132: oCall 3535
3134: oGetLocal 3
3136: oPushResult
3137: oSetResult 35
3139: oPushResult
3140: oValueTop
3141: oPushResult
3142: oNodeSetInt
3143: oPop 3
3145: oValuePop
3146: oInput 20
3148: oCall 3535
3150: oGetLocal 3
3152: oPushResult
3153: oSetResult 36
3155: oPushResult
3156: oValueTop
3157: oPushResult
3158: oNodeSetInt
3159: oPop 3
3161: oValuePop
3162: oGetLocal 3
3164: oPushResult
3165: oSetResult 16
3167: oPushResult
3168: oSetResult 4
3170: oPushResult
3171: oNodeSetInt
3172: oPop 3
3174: oGetLocal 3
3176: oPushResult
3177: oTypeAdd
3178: oPop 1
3180: oGetAddrLocal 4
3182: oPushResult
3183: oSetResult 27
3185: oPushResult
3186: oNodeNew
3187: oPop 1
3189: oAssign
3190: oGetLocal 4
3192: oPushResult
3193: oSetResult 34
3195: oPushResult
3196: oGetLocal 3
3198: oPushResult
3199: oNodeSet
3200: oPop 3
3202: oGetLocal 2
3204: oPushResult
3205: oGetLocal 4
3207: oPushResult
3208: oNodeVecAppend
3209: oPop 2
3211: oInputChoice 3219
3213: oJumpForward 3227
3215: oJumpForward 3225
3217: oJumpForward 3225
3219: Choice Lookup Table
          12   3217
          16   3213
3224: oEndChoice
3225: oJumpBack 3110
3227: oInput 38
3229: oGetAddrLocal 5
3231: oPushResult
3232: oCall 3058
3234: oPop 1
3236: oGetAddrLocal 6
3238: oPushResult
3239: oGetLocal 2
3241: oPushResult
3242: oNodeVecSize
3243: oPop 1
3245: oAssign
3246: oGetAddrLocal 6
3248: oPushResult
3249: dec
3250: oPop 1
3252: oGetAddrLocal 7
3254: oPushResult
3255: oGetLocal 2
3257: oPushResult
3258: oGetLocal 6
3260: oPushResult
3261: oNodeVecElement
3262: oPop 2
3264: oAssign
3265: oGetLocal 7
3267: oPushResult
3268: oSetResult 33
3270: oPushResult
3271: oGetLocal 5
3273: oPushResult
3274: oNodeSet
3275: oPop 3
3277: oGetAddrLocal 8
3279: oPushResult
3280: oGetLocal 7
3282: oPushResult
3283: oSetResult 34
3285: oPushResult
3286: oNodeGet
3287: oPop 2
3289: oAssign
3290: oGetAddrLocal 9
3292: oPushResult
3293: oGetLocal 8
3295: oPushResult
3296: oSetResult 36
3298: oPushResult
3299: oNodeGetInt
3300: oPop 2
3302: oPushResult
3303: oGetLocal 8
3305: oPushResult
3306: oSetResult 35
3308: oPushResult
3309: oNodeGetInt
3310: oPop 2
3312: oPushResult
3313: subtract
3314: oPop 2
3316: oAssign
3317: oGetAddrLocal 9
3319: oPushResult
3320: inc
3321: oPop 1
3323: oGetLocal 7
3325: oPushResult
3326: oSetResult 16
3328: oPushResult
3329: oGetLocal 9
3331: oPushResult
3332: oGetLocal 5
3334: oPushResult
3335: oSetResult 16
3337: oPushResult
3338: oNodeGetInt
3339: oPop 2
3341: oPushResult
3342: multiply
3343: oPop 2
3345: oPushResult
3346: oNodeSetInt
3347: oPop 3
3349: oGetLocal 7
3351: oPushResult
3352: oTypeAdd
3353: oPop 1
3355: oGetAddrLocal 5
3357: oPushResult
3358: oGetLocal 7
3360: oAssign
3361: oGetLocal 6
3363: oPushResult
3364: equal_zero
3365: oPop 1
3367: oChoice 3373
3369: oJumpForward 3378
3371: oJumpForward 3376
3373: Choice Lookup Table
           1   3369
3376: oJumpBack 3246
3378: oGetParam 1
3380: oPushResult
3381: oGetLocal 2
3383: oPushResult
3384: oSetResult 0
3386: oPushResult
3387: oNodeVecElement
3388: oPop 2
3390: oAssign
3391: oGetLocal 2
3393: oPushResult
3394: oNodeVecDelete
3395: oPop 1
3397: oJumpForward 3534
3399: oGetAddrLocal 10
3401: oPushResult
3402: oCall 3058
3404: oPop 1
3406: oGetParam 1
3408: oPushResult
3409: oGetLocal 10
3411: oPushResult
3412: oCall 7835
3414: oPop 1
3416: oAssign
3417: oJumpForward 3534
3419: oGetParam 1
3421: oPushResult
3422: oSetResult 29
3424: oPushResult
3425: oNodeNew
3426: oPop 1
3428: oAssign
3429: oSetResult -1
3431: oPushResult
3432: oSetResult 2
3434: oPushResult
3435: oScopeBegin
3436: oPop 2
3438: oSetResult 17
3440: oPushResult
3441: oCall 2828
3443: oPop 1
3445: oGetAddrLocal 11
3447: oPushResult
3448: oScopeCurrent
3449: oPushResult
3450: oSetResult 16
3452: oPushResult
3453: oNodeGetInt
3454: oPop 2
3456: oAssign
3457: oGetLocal 11
3459: oPushResult
3460: equal_zero
3461: oPop 1
3463: oChoice 3469
3465: oError 19
3467: oJumpForward 3472
3469: Choice Lookup Table
           1   3465
3472: oInput 34
3474: oGetFromParam 1
3476: oPushResult
3477: oSetResult 37
3479: oPushResult
3480: oScopeCurrent
3481: oPushResult
3482: oNodeSet
3483: oPop 3
3485: oGetFromParam 1
3487: oPushResult
3488: oSetResult 16
3490: oPushResult
3491: oGetLocal 11
3493: oPushResult
3494: oNodeSetInt
3495: oPop 3
3497: oScopeEnd
3498: oGetFromParam 1
3500: oPushResult
3501: oTypeAdd
3502: oPop 1
3504: oJumpForward 3534
3506: oInput 38
3508: oGetAddrLocal 12
3510: oPushResult
3511: oCall 3058
3513: oPop 1
3515: oJumpForward 3534
3517: Choice Lookup Table
          37   3506
          36   3419
          17   3399
          35   3103
           0   3062
3528: oCall 3535
3530: oInput 20
3532: oCall 3535
3534: oReturn
3535: oLocalSpace 1
3537: oInputChoice 3592
3539: TOKEN_VALUE
3540: oPushResult
3541: oValuePush
3542: oPop 1
3544: oJumpForward 3600
3546: oGetAddrLocal 1
3548: oPushResult
3549: oScopeFindRequire
3550: oAssign
3551: oGetLocal 1
3553: oPushResult
3554: oNodeType
3555: oPop 1
3557: oChoice 3574
3559: oGetLocal 1
3561: oPushResult
3562: oSetResult 21
3564: oPushResult
3565: oNodeGetInt
3566: oPop 2
3568: oPushResult
3569: oValuePush
3570: oPop 1
3572: oJumpForward 3585
3574: Choice Lookup Table
          12   3559
3577: oError 1
3579: oSetResult 0
3581: oPushResult
3582: oValuePush
3583: oPop 1
3585: oJumpForward 3600
3587: oCall 3535
3589: oValueNegate
3590: oJumpForward 3600
3592: Choice Lookup Table
          24   3587
           0   3546
           1   3539
3599: oEndChoice
3600: oReturn
3601: oLocalSpace 1
3603: oGetAddrLocal 1
3605: oPushResult
3606: oSetResult 0
3608: oAssign
3609: oGetAddrLocal 1
3611: oPushResult
3612: oCall 3762
3614: oPop 1
3616: oGetAddrLocal 1
3618: oPushResult
3619: oCall 3662
3621: oPop 1
3623: oReturn
3624: oLocalSpace 0
3626: oGetParam 1
3628: oPushResult
3629: oCall 3762
3631: oPop 1
3633: oTypeSNodeType
3634: oChoice 3653
3636: oJumpForward 3660
3638: oGetParam 1
3640: oPushResult
3641: oLabelNew
3642: oAssign
3643: oEmit 55
3645: oGetFromParam 1
3647: oPushResult
3648: oEmitLabel
3649: oPop 1
3651: oJumpForward 3660
3653: Choice Lookup Table
          22   3638
          23   3636
3658: oError 8
3660: oTypeSPop
3661: oReturn
3662: oLocalSpace 1
3664: oTypeSNodeType
3665: oChoice 3727
3667: oGetAddrLocal 1
3669: oPushResult
3670: oLabelNew
3671: oAssign
3672: oEmit 15
3674: oSetResult 1
3676: oPushResult
3677: oEmitInt
3678: oPop 1
3680: oEmit 53
3682: oGetLocal 1
3684: oPushResult
3685: oEmitLabel
3686: oPop 1
3688: oEmit 56
3690: oGetFromParam 1
3692: oPushResult
3693: oEmitLabel
3694: oPop 1
3696: oEmit 15
3698: oSetResult 0
3700: oPushResult
3701: oEmitInt
3702: oPop 1
3704: oEmit 56
3706: oGetLocal 1
3708: oPushResult
3709: oEmitLabel
3710: oPop 1
3712: oTypeSPop
3713: oGetGlobal 5
3715: oPushResult
3716: oTypeSPush
3717: oPop 1
3719: oGetParam 1
3721: oPushResult
3722: oSetResult 0
3724: oAssign
3725: oJumpForward 3730
3727: Choice Lookup Table
          23   3667
3730: oReturn
3731: oLocalSpace 0
3733: oTypeSNodeType
3734: oChoice 3758
3736: oGetParam 1
3738: oPushResult
3739: oLabelNew
3740: oAssign
3741: oEmit 55
3743: oGetFromParam 1
3745: oPushResult
3746: oEmitLabel
3747: oPop 1
3749: oTypeSPop
3750: oGetGlobal 6
3752: oPushResult
3753: oTypeSPush
3754: oPop 1
3756: oJumpForward 3761
3758: Choice Lookup Table
          22   3736
3761: oReturn
3762: oLocalSpace 0
3764: oGetParam 1
3766: oPushResult
3767: oCall 4127
3769: oPop 1
3771: oInputChoice 4109
3773: oGetParam 1
3775: oPushResult
3776: oCall 3662
3778: oPop 1
3780: oGetParam 1
3782: oPushResult
3783: oCall 4127
3785: oPop 1
3787: oGetParam 1
3789: oPushResult
3790: oCall 3662
3792: oPop 1
3794: oCall 7693
3796: oTypeSNodeType
3797: oChoice 3811
3799: oEmit 38
3801: oJumpForward 3824
3803: oEmit 44
3805: oJumpForward 3824
3807: oError 16
3809: oJumpForward 3824
3811: Choice Lookup Table
          25   3807
          24   3807
          26   3803
          22   3799
          21   3799
3822: oError 17
3824: oTypeSPop
3825: oGetGlobal 5
3827: oPushResult
3828: oTypeSPush
3829: oPop 1
3831: oJumpForward 4124
3833: oGetParam 1
3835: oPushResult
3836: oCall 3662
3838: oPop 1
3840: oGetParam 1
3842: oPushResult
3843: oCall 4127
3845: oPop 1
3847: oGetParam 1
3849: oPushResult
3850: oCall 3662
3852: oPop 1
3854: oCall 7693
3856: oTypeSNodeType
3857: oChoice 3871
3859: oEmit 39
3861: oJumpForward 3884
3863: oEmit 45
3865: oJumpForward 3884
3867: oError 16
3869: oJumpForward 3884
3871: Choice Lookup Table
          25   3867
          24   3867
          26   3863
          22   3859
          21   3859
3882: oError 17
3884: oTypeSPop
3885: oGetGlobal 5
3887: oPushResult
3888: oTypeSPush
3889: oPop 1
3891: oJumpForward 4124
3893: oGetParam 1
3895: oPushResult
3896: oCall 3662
3898: oPop 1
3900: oGetParam 1
3902: oPushResult
3903: oCall 4127
3905: oPop 1
3907: oGetParam 1
3909: oPushResult
3910: oCall 3662
3912: oPop 1
3914: oCall 7693
3916: oTypeSNodeType
3917: oChoice 3927
3919: oEmit 41
3921: oJumpForward 3938
3923: oError 16
3925: oJumpForward 3938
3927: Choice Lookup Table
          25   3923
          24   3923
          22   3919
          21   3919
3936: oError 17
3938: oTypeSPop
3939: oGetGlobal 5
3941: oPushResult
3942: oTypeSPush
3943: oPop 1
3945: oJumpForward 4124
3947: oGetParam 1
3949: oPushResult
3950: oCall 3662
3952: oPop 1
3954: oGetParam 1
3956: oPushResult
3957: oCall 4127
3959: oPop 1
3961: oGetParam 1
3963: oPushResult
3964: oCall 3662
3966: oPop 1
3968: oCall 7693
3970: oTypeSNodeType
3971: oChoice 3981
3973: oEmit 40
3975: oJumpForward 3992
3977: oError 16
3979: oJumpForward 3992
3981: Choice Lookup Table
          25   3977
          24   3977
          22   3973
          21   3973
3990: oError 17
3992: oTypeSPop
3993: oGetGlobal 5
3995: oPushResult
3996: oTypeSPush
3997: oPop 1
3999: oJumpForward 4124
4001: oGetParam 1
4003: oPushResult
4004: oCall 3662
4006: oPop 1
4008: oGetParam 1
4010: oPushResult
4011: oCall 4127
4013: oPop 1
4015: oGetParam 1
4017: oPushResult
4018: oCall 3662
4020: oPop 1
4022: oCall 7693
4024: oTypeSNodeType
4025: oChoice 4035
4027: oEmit 43
4029: oJumpForward 4046
4031: oError 16
4033: oJumpForward 4046
4035: Choice Lookup Table
          25   4031
          24   4031
          22   4027
          21   4027
4044: oError 17
4046: oTypeSPop
4047: oGetGlobal 5
4049: oPushResult
4050: oTypeSPush
4051: oPop 1
4053: oJumpForward 4124
4055: oGetParam 1
4057: oPushResult
4058: oCall 3662
4060: oPop 1
4062: oGetParam 1
4064: oPushResult
4065: oCall 4127
4067: oPop 1
4069: oGetParam 1
4071: oPushResult
4072: oCall 3662
4074: oPop 1
4076: oCall 7693
4078: oTypeSNodeType
4079: oChoice 4089
4081: oEmit 42
4083: oJumpForward 4100
4085: oError 16
4087: oJumpForward 4100
4089: Choice Lookup Table
          25   4085
          24   4085
          22   4081
          21   4081
4098: oError 17
4100: oTypeSPop
4101: oGetGlobal 5
4103: oPushResult
4104: oTypeSPush
4105: oPop 1
4107: oJumpForward 4124
4109: Choice Lookup Table
          10   4055
           9   4001
           8   3947
           7   3893
           6   3833
           5   3773
4122: oJumpForward 4126
4124: oJumpBack 3771
4126: oReturn
4127: oLocalSpace 1
4129: oGetAddrLocal 1
4131: oPushResult
4132: oSetResult 0
4134: oAssign
4135: oGetParam 1
4137: oPushResult
4138: oCall 4307
4140: oPop 1
4142: oInputChoice 4275
4144: oTypeSNodeType
4145: oChoice 4216
4147: oGetLocal 1
4149: oPushResult
4150: oSetResult 0
4152: oPushResult
4153: equal_label
4154: oPop 2
4156: oChoice 4165
4158: oGetAddrLocal 1
4160: oPushResult
4161: oLabelNew
4162: oAssign
4163: oJumpForward 4168
4165: Choice Lookup Table
           1   4158
4168: oEmit 53
4170: oGetLocal 1
4172: oPushResult
4173: oEmitLabel
4174: oPop 1
4176: oJumpForward 4223
4178: oGetParam 1
4180: oPushResult
4181: oCall 3731
4183: oPop 1
4185: oGetLocal 1
4187: oPushResult
4188: oSetResult 0
4190: oPushResult
4191: equal_label
4192: oPop 2
4194: oChoice 4203
4196: oGetAddrLocal 1
4198: oPushResult
4199: oLabelNew
4200: oAssign
4201: oJumpForward 4206
4203: Choice Lookup Table
           1   4196
4206: oEmit 53
4208: oGetLocal 1
4210: oPushResult
4211: oEmitLabel
4212: oPop 1
4214: oJumpForward 4223
4216: Choice Lookup Table
          22   4178
          23   4147
4221: oError 8
4223: oTypeSPop
4224: oEmit 56
4226: oGetFromParam 1
4228: oPushResult
4229: oEmitLabel
4230: oPop 1
4232: oGetParam 1
4234: oPushResult
4235: oSetResult 0
4237: oAssign
4238: oGetParam 1
4240: oPushResult
4241: oCall 4307
4243: oPop 1
4245: oTypeSNodeType
4246: oChoice 4259
4248: oJumpForward 4266
4250: oGetParam 1
4252: oPushResult
4253: oCall 3731
4255: oPop 1
4257: oJumpForward 4266
4259: Choice Lookup Table
          22   4250
          23   4248
4264: oError 8
4266: oTypeSPop
4267: oGetGlobal 6
4269: oPushResult
4270: oTypeSPush
4271: oPop 1
4273: oJumpForward 4280
4275: Choice Lookup Table
          52   4144
4278: oJumpForward 4282
4280: oJumpBack 4142
4282: oGetLocal 1
4284: oPushResult
4285: oSetResult 0
4287: oPushResult
4288: equal_label
4289: oPop 2
4291: oChoice 4303
4293: oEmit 56
4295: oGetLocal 1
4297: oPushResult
4298: oEmitLabel
4299: oPop 1
4301: oJumpForward 4306
4303: Choice Lookup Table
           0   4293
4306: oReturn
4307: oLocalSpace 2
4309: oGetAddrLocal 1
4311: oPushResult
4312: oSetResult 0
4314: oAssign
4315: oGetParam 1
4317: oPushResult
4318: oCall 4445
4320: oPop 1
4322: oInputChoice 4437
4324: oTypeSNodeType
4325: oChoice 4338
4327: oJumpForward 4345
4329: oGetParam 1
4331: oPushResult
4332: oCall 3731
4334: oPop 1
4336: oJumpForward 4345
4338: Choice Lookup Table
          22   4329
          23   4327
4343: oError 8
4345: oTypeSPop
4346: oGetLocal 1
4348: oPushResult
4349: oSetResult 0
4351: oPushResult
4352: equal_label
4353: oPop 2
4355: oChoice 4384
4357: oGetAddrLocal 1
4359: oPushResult
4360: oLabelNew
4361: oAssign
4362: oEmit 57
4364: oGetFromParam 1
4366: oPushResult
4367: oEmitLabel
4368: oPop 1
4370: oGetLocal 1
4372: oPushResult
4373: oEmitLabel
4374: oPop 1
4376: oGetParam 1
4378: oPushResult
4379: oGetLocal 1
4381: oAssign
4382: oJumpForward 4387
4384: Choice Lookup Table
           1   4357
4387: oGetAddrLocal 2
4389: oPushResult
4390: oSetResult 0
4392: oAssign
4393: oGetAddrLocal 2
4395: oPushResult
4396: oCall 4445
4398: oPop 1
4400: oTypeSNodeType
4401: oChoice 4414
4403: oJumpForward 4421
4405: oGetAddrLocal 2
4407: oPushResult
4408: oCall 3731
4410: oPop 1
4412: oJumpForward 4421
4414: Choice Lookup Table
          22   4405
          23   4403
4419: oError 8
4421: oEmit 57
4423: oGetLocal 2
4425: oPushResult
4426: oEmitLabel
4427: oPop 1
4429: oGetLocal 1
4431: oPushResult
4432: oEmitLabel
4433: oPop 1
4435: oJumpForward 4442
4437: Choice Lookup Table
          51   4324
4440: oJumpForward 4444
4442: oJumpBack 4322
4444: oReturn
4445: oLocalSpace 1
4447: oInputChoice 4501
4449: oGetAddrLocal 1
4451: oPushResult
4452: oSetResult 0
4454: oAssign
4455: oGetAddrLocal 1
4457: oPushResult
4458: oCall 4445
4460: oPop 1
4462: oTypeSNodeType
4463: oChoice 4492
4465: oGetParam 1
4467: oPushResult
4468: oLabelNew
4469: oAssign
4470: oEmit 53
4472: oGetFromParam 1
4474: oPushResult
4475: oEmitLabel
4476: oPop 1
4478: oEmit 56
4480: oGetLocal 1
4482: oPushResult
4483: oEmitLabel
4484: oPop 1
4486: oJumpForward 4499
4488: oEmit 37
4490: oJumpForward 4499
4492: Choice Lookup Table
          22   4488
          23   4465
4497: oError 8
4499: oJumpForward 4511
4501: Choice Lookup Table
          53   4449
4504: oGetParam 1
4506: oPushResult
4507: oCall 4512
4509: oPop 1
4511: oReturn
4512: oLocalSpace 0
4514: oGetParam 1
4516: oPushResult
4517: oCall 4563
4519: oPop 1
4521: oInputChoice 4553
4523: oCall 7719
4525: oGetParam 1
4527: oPushResult
4528: oCall 4563
4530: oPop 1
4532: oCall 7733
4534: oEmit 34
4536: oJumpForward 4560
4538: oCall 7719
4540: oGetParam 1
4542: oPushResult
4543: oCall 4563
4545: oPop 1
4547: oCall 7733
4549: oEmit 35
4551: oJumpForward 4560
4553: Choice Lookup Table
          24   4538
          23   4523
4558: oJumpForward 4562
4560: oJumpBack 4521
4562: oReturn
4563: oLocalSpace 0
4565: oGetParam 1
4567: oPushResult
4568: oCall 4614
4570: oPop 1
4572: oInputChoice 4604
4574: oCall 7719
4576: oGetParam 1
4578: oPushResult
4579: oCall 4614
4581: oPop 1
4583: oCall 7733
4585: oEmit 31
4587: oJumpForward 4611
4589: oCall 7719
4591: oGetParam 1
4593: oPushResult
4594: oCall 4614
4596: oPop 1
4598: oCall 7733
4600: oEmit 32
4602: oJumpForward 4611
4604: Choice Lookup Table
          22   4589
          21   4574
4609: oJumpForward 4613
4611: oJumpBack 4572
4613: oReturn
4614: oLocalSpace 0
4616: oInputChoice 4642
4618: oGetParam 1
4620: oPushResult
4621: oCall 4655
4623: oPop 1
4625: oCall 7733
4627: oJumpForward 4654
4629: oGetParam 1
4631: oPushResult
4632: oCall 4655
4634: oPop 1
4636: oCall 7733
4638: oEmit 36
4640: oJumpForward 4654
4642: Choice Lookup Table
          24   4629
          23   4618
4647: oGetParam 1
4649: oPushResult
4650: oCall 4655
4652: oPop 1
4654: oReturn
4655: oLocalSpace 6
4657: oInputChoice 4843
4659: oEmit 15
4661: TOKEN_VALUE
4662: oPushResult
4663: oEmitInt
4664: oPop 1
4666: oGetGlobal 4
4668: oPushResult
4669: oTypeSPush
4670: oPop 1
4672: oJumpForward 4862
4674: oGetParam 1
4676: oPushResult
4677: oCall 3762
4679: oPop 1
4681: oInput 14
4683: oJumpForward 4862
4685: oGetAddrLocal 1
4687: oPushResult
4688: CURRENT_STRLIT
4689: oPushResult
4690: oStringAllocLit
4691: oPop 1
4693: oAssign
4694: oEmit 16
4696: oGetLocal 1
4698: oPushResult
4699: oEmitInt
4700: oPop 1
4702: oGetGlobal 8
4704: oPushResult
4705: oTypeSPush
4706: oPop 1
4708: oJumpForward 4862
4710: oGetAddrLocal 2
4712: oPushResult
4713: oScopeFindRequire
4714: oAssign
4715: oGetLocal 2
4717: oPushResult
4718: oNodeType
4719: oPop 1
4721: oChoice 4783
4723: oGetLocal 2
4725: oPushResult
4726: oCall 6015
4728: oPop 1
4730: oJumpForward 4802
4732: oGetAddrLocal 3
4734: oPushResult
4735: oGetLocal 2
4737: oPushResult
4738: oSetResult 20
4740: oPushResult
4741: oNodeGet
4742: oPop 2
4744: oAssign
4745: oGetLocal 3
4747: oPushResult
4748: oTypeSPush
4749: oPop 1
4751: oTypeSNodeType
4752: oChoice 4765
4754: oEmit 15
4756: oGetLocal 2
4758: oPushResult
4759: oCall 7970
4761: oPop 1
4763: oJumpForward 4772
4765: Choice Lookup Table
          22   4754
          21   4754
4770: oError 16
4772: oJumpForward 4802
4774: oGetLocal 2
4776: oPushResult
4777: oCall 4863
4779: oPop 1
4781: oJumpForward 4802
4783: Choice Lookup Table
          18   4774
          16   4774
          15   4774
          12   4732
          11   4723
4794: oError 6
4796: oGetGlobal 4
4798: oPushResult
4799: oTypeSPush
4800: oPop 1
4802: oJumpForward 4862
4804: oInput 0
4806: oGetAddrLocal 4
4808: oPushResult
4809: oScopeFindRequire
4810: oAssign
4811: oGetLocal 4
4813: oPushResult
4814: oCall 6962
4816: oPop 1
4818: oGetAddrLocal 5
4820: oPushResult
4821: oTypeSTop
4822: oAssign
4823: oTypeSPop
4824: oGetAddrLocal 6
4826: oPushResult
4827: oGetLocal 5
4829: oPushResult
4830: oCall 7835
4832: oPop 1
4834: oAssign
4835: oGetLocal 6
4837: oPushResult
4838: oTypeSPush
4839: oPop 1
4841: oJumpForward 4862
4843: Choice Lookup Table
          18   4804
           0   4710
           2   4685
          13   4674
           1   4659
4854: oError 6
4856: oGetGlobal 4
4858: oPushResult
4859: oTypeSPush
4860: oPop 1
4862: oReturn
4863: oLocalSpace 2
4865: oGetAddrLocal 1
4867: oPushResult
4868: oGetParam 1
4870: oPushResult
4871: oSetResult 20
4873: oPushResult
4874: oNodeGet
4875: oPop 2
4877: oAssign
4878: oGetAddrLocal 2
4880: oPushResult
4881: oGetParam 1
4883: oPushResult
4884: oCall 7675
4886: oPop 1
4888: oAssign
4889: oGetLocal 1
4891: oPushResult
4892: oTypeSPush
4893: oPop 1
4895: oTypeSNodeType
4896: oChoice 5413
4898: oGetParam 1
4900: oPushResult
4901: oNodeType
4902: oPop 1
4904: oChoice 5050
4906: oEmit 0
4908: oGetParam 1
4910: oPushResult
4911: oCall 7970
4913: oPop 1
4915: oJumpForward 5058
4917: oGetLocal 2
4919: oPushResult
4920: equal_zero
4921: oPop 1
4923: oChoice 4936
4925: oEmit 3
4927: oGetParam 1
4929: oPushResult
4930: oCall 7970
4932: oPop 1
4934: oJumpForward 4954
4936: Choice Lookup Table
           1   4925
4939: oEmit 9
4941: oGetLocal 2
4943: oPushResult
4944: oEmitInt
4945: oPop 1
4947: oGetParam 1
4949: oPushResult
4950: oCall 7970
4952: oPop 1
4954: oJumpForward 5058
4956: oGetParam 1
4958: oPushResult
4959: oSetResult 31
4961: oPushResult
4962: oNodeGetBoolean
4963: oPop 2
4965: oChoice 5008
4967: oGetLocal 2
4969: oPushResult
4970: equal_zero
4971: oPop 1
4973: oChoice 4986
4975: oEmit 8
4977: oGetParam 1
4979: oPushResult
4980: oCall 7970
4982: oPop 1
4984: oJumpForward 5004
4986: Choice Lookup Table
           1   4975
4989: oEmit 14
4991: oGetLocal 2
4993: oPushResult
4994: oEmitInt
4995: oPop 1
4997: oGetParam 1
4999: oPushResult
5000: oCall 7970
5002: oPop 1
5004: oEmit 22
5006: oJumpForward 5048
5008: Choice Lookup Table
           1   4967
5011: oGetLocal 2
5013: oPushResult
5014: equal_zero
5015: oPop 1
5017: oChoice 5030
5019: oEmit 6
5021: oGetParam 1
5023: oPushResult
5024: oCall 7970
5026: oPop 1
5028: oJumpForward 5048
5030: Choice Lookup Table
           1   5019
5033: oEmit 12
5035: oGetLocal 2
5037: oPushResult
5038: oEmitInt
5039: oPop 1
5041: oGetParam 1
5043: oPushResult
5044: oCall 7970
5046: oPop 1
5048: oJumpForward 5058
5050: Choice Lookup Table
          18   4956
          16   4917
          15   4906
5057: oEndChoice
5058: oJumpForward 5588
5060: oGetParam 1
5062: oPushResult
5063: oNodeType
5064: oPop 1
5066: oChoice 5212
5068: oEmit 1
5070: oGetParam 1
5072: oPushResult
5073: oCall 7970
5075: oPop 1
5077: oJumpForward 5220
5079: oGetLocal 2
5081: oPushResult
5082: equal_zero
5083: oPop 1
5085: oChoice 5098
5087: oEmit 4
5089: oGetParam 1
5091: oPushResult
5092: oCall 7970
5094: oPop 1
5096: oJumpForward 5116
5098: Choice Lookup Table
           1   5087
5101: oEmit 10
5103: oGetLocal 2
5105: oPushResult
5106: oEmitInt
5107: oPop 1
5109: oGetParam 1
5111: oPushResult
5112: oCall 7970
5114: oPop 1
5116: oJumpForward 5220
5118: oGetParam 1
5120: oPushResult
5121: oSetResult 31
5123: oPushResult
5124: oNodeGetBoolean
5125: oPop 2
5127: oChoice 5170
5129: oGetLocal 2
5131: oPushResult
5132: equal_zero
5133: oPop 1
5135: oChoice 5148
5137: oEmit 8
5139: oGetParam 1
5141: oPushResult
5142: oCall 7970
5144: oPop 1
5146: oJumpForward 5166
5148: Choice Lookup Table
           1   5137
5151: oEmit 14
5153: oGetLocal 2
5155: oPushResult
5156: oEmitInt
5157: oPop 1
5159: oGetParam 1
5161: oPushResult
5162: oCall 7970
5164: oPop 1
5166: oEmit 23
5168: oJumpForward 5210
5170: Choice Lookup Table
           1   5129
5173: oGetLocal 2
5175: oPushResult
5176: equal_zero
5177: oPop 1
5179: oChoice 5192
5181: oEmit 7
5183: oGetParam 1
5185: oPushResult
5186: oCall 7970
5188: oPop 1
5190: oJumpForward 5210
5192: Choice Lookup Table
           1   5181
5195: oEmit 13
5197: oGetLocal 2
5199: oPushResult
5200: oEmitInt
5201: oPop 1
5203: oGetParam 1
5205: oPushResult
5206: oCall 7970
5208: oPop 1
5210: oJumpForward 5220
5212: Choice Lookup Table
          18   5118
          16   5079
          15   5068
5219: oEndChoice
5220: oJumpForward 5588
5222: oError 16
5224: oJumpForward 5588
5226: oGetParam 1
5228: oPushResult
5229: oNodeType
5230: oPop 1
5232: oChoice 5378
5234: oEmit 2
5236: oGetParam 1
5238: oPushResult
5239: oCall 7970
5241: oPop 1
5243: oJumpForward 5386
5245: oGetLocal 2
5247: oPushResult
5248: equal_zero
5249: oPop 1
5251: oChoice 5264
5253: oEmit 5
5255: oGetParam 1
5257: oPushResult
5258: oCall 7970
5260: oPop 1
5262: oJumpForward 5282
5264: Choice Lookup Table
           1   5253
5267: oEmit 11
5269: oGetLocal 2
5271: oPushResult
5272: oEmitInt
5273: oPop 1
5275: oGetParam 1
5277: oPushResult
5278: oCall 7970
5280: oPop 1
5282: oJumpForward 5386
5284: oGetParam 1
5286: oPushResult
5287: oSetResult 31
5289: oPushResult
5290: oNodeGetBoolean
5291: oPop 2
5293: oChoice 5336
5295: oGetLocal 2
5297: oPushResult
5298: equal_zero
5299: oPop 1
5301: oChoice 5314
5303: oEmit 8
5305: oGetParam 1
5307: oPushResult
5308: oCall 7970
5310: oPop 1
5312: oJumpForward 5332
5314: Choice Lookup Table
           1   5303
5317: oEmit 14
5319: oGetLocal 2
5321: oPushResult
5322: oEmitInt
5323: oPop 1
5325: oGetParam 1
5327: oPushResult
5328: oCall 7970
5330: oPop 1
5332: oEmit 24
5334: oJumpForward 5376
5336: Choice Lookup Table
           1   5295
5339: oGetLocal 2
5341: oPushResult
5342: equal_zero
5343: oPop 1
5345: oChoice 5358
5347: oEmit 8
5349: oGetParam 1
5351: oPushResult
5352: oCall 7970
5354: oPop 1
5356: oJumpForward 5376
5358: Choice Lookup Table
           1   5347
5361: oEmit 14
5363: oGetLocal 2
5365: oPushResult
5366: oEmitInt
5367: oPop 1
5369: oGetParam 1
5371: oPushResult
5372: oCall 7970
5374: oPop 1
5376: oJumpForward 5386
5378: Choice Lookup Table
          18   5284
          16   5245
          15   5234
5385: oEndChoice
5386: oInputChoice 5408
5388: oTypeSPop
5389: oGetLocal 1
5391: oPushResult
5392: oSetResult 33
5394: oPushResult
5395: oNodeGet
5396: oPop 2
5398: oPushResult
5399: oTypeSPush
5400: oPop 1
5402: oCall 5624
5404: oCall 5589
5406: oJumpForward 5411
5408: Choice Lookup Table
          17   5388
5411: oJumpForward 5588
5413: Choice Lookup Table
          26   5226
          20   5222
          25   5222
          24   5222
          22   5060
          21   4898
5426: oGetParam 1
5428: oPushResult
5429: oNodeType
5430: oPop 1
5432: oChoice 5576
5434: oEmit 16
5436: oGetParam 1
5438: oPushResult
5439: oCall 7970
5441: oPop 1
5443: oJumpForward 5584
5445: oGetLocal 2
5447: oPushResult
5448: equal_zero
5449: oPop 1
5451: oChoice 5464
5453: oEmit 17
5455: oGetParam 1
5457: oPushResult
5458: oCall 7970
5460: oPop 1
5462: oJumpForward 5482
5464: Choice Lookup Table
           1   5453
5467: oEmit 20
5469: oGetLocal 2
5471: oPushResult
5472: oEmitInt
5473: oPop 1
5475: oGetParam 1
5477: oPushResult
5478: oCall 7970
5480: oPop 1
5482: oJumpForward 5584
5484: oGetParam 1
5486: oPushResult
5487: oSetResult 31
5489: oPushResult
5490: oNodeGetBoolean
5491: oPop 2
5493: oChoice 5534
5495: oGetLocal 2
5497: oPushResult
5498: equal_zero
5499: oPop 1
5501: oChoice 5514
5503: oEmit 8
5505: oGetParam 1
5507: oPushResult
5508: oCall 7970
5510: oPop 1
5512: oJumpForward 5532
5514: Choice Lookup Table
           1   5503
5517: oEmit 14
5519: oGetLocal 2
5521: oPushResult
5522: oEmitInt
5523: oPop 1
5525: oGetParam 1
5527: oPushResult
5528: oCall 7970
5530: oPop 1
5532: oJumpForward 5574
5534: Choice Lookup Table
           1   5495
5537: oGetLocal 2
5539: oPushResult
5540: equal_zero
5541: oPop 1
5543: oChoice 5556
5545: oEmit 18
5547: oGetParam 1
5549: oPushResult
5550: oCall 7970
5552: oPop 1
5554: oJumpForward 5574
5556: Choice Lookup Table
           1   5545
5559: oEmit 21
5561: oGetLocal 2
5563: oPushResult
5564: oEmitInt
5565: oPop 1
5567: oGetParam 1
5569: oPushResult
5570: oCall 7970
5572: oPop 1
5574: oJumpForward 5584
5576: Choice Lookup Table
          18   5484
          16   5445
          15   5434
5583: oEndChoice
5584: oCall 5624
5586: oCall 5589
5588: oReturn
5589: oLocalSpace 0
5591: oTypeSNodeType
5592: oChoice 5610
5594: oEmit 22
5596: oJumpForward 5623
5598: oEmit 23
5600: oJumpForward 5623
5602: oError 16
5604: oJumpForward 5623
5606: oEmit 24
5608: oJumpForward 5623
5610: Choice Lookup Table
          26   5606
          20   5602
          25   5602
          24   5602
          22   5598
          21   5594
5623: oReturn
5624: oLocalSpace 0
5626: oInputChoice 5640
5628: oCall 5652
5630: oJumpForward 5649
5632: oCall 5795
5634: oJumpForward 5649
5636: oCall 5893
5638: oJumpForward 5649
5640: Choice Lookup Table
          17   5636
          19   5632
          15   5628
5647: oJumpForward 5651
5649: oJumpBack 5626
5651: oReturn
5652: oLocalSpace 3
5654: oTypeSNodeType
5655: oChoice 5659
5657: oJumpForward 5664
5659: Choice Lookup Table
          27   5657
5662: oError 10
5664: oTypeSNodeType
5665: oChoice 5669
5667: oJumpForward 5674
5669: Choice Lookup Table
          27   5667
5672: oError 13
5674: oGetAddrLocal 1
5676: oPushResult
5677: oTypeSTop
5678: oPushResult
5679: oSetResult 34
5681: oPushResult
5682: oNodeGet
5683: oPop 2
5685: oPushResult
5686: oCall 7919
5688: oPop 1
5690: oAssign
5691: oGetAddrLocal 2
5693: oPushResult
5694: oTypeSTop
5695: oPushResult
5696: oSetResult 33
5698: oPushResult
5699: oNodeGet
5700: oPop 2
5702: oAssign
5703: oTypeSPop
5704: oGetLocal 2
5706: oPushResult
5707: oTypeSPush
5708: oPop 1
5710: oCall 3601
5712: oCall 7719
5714: oGetLocal 1
5716: oPushResult
5717: equal_zero
5718: oPop 1
5720: oChoice 5734
5722: oEmit 15
5724: oGetLocal 1
5726: oPushResult
5727: oEmitInt
5728: oPop 1
5730: oEmit 35
5732: oJumpForward 5737
5734: Choice Lookup Table
           0   5722
5737: oGetAddrLocal 3
5739: oPushResult
5740: oGetLocal 2
5742: oPushResult
5743: oSetResult 16
5745: oPushResult
5746: oNodeGetInt
5747: oPop 2
5749: oAssign
5750: oGetLocal 3
5752: oPushResult
5753: oSetResult 1
5755: oPushResult
5756: equal
5757: oPop 2
5759: oChoice 5773
5761: oEmit 15
5763: oGetLocal 3
5765: oPushResult
5766: oEmitInt
5767: oPop 1
5769: oEmit 31
5771: oJumpForward 5776
5773: Choice Lookup Table
           0   5761
5776: oEmit 33
5778: oInputChoice 5786
5780: oJumpForward 5794
5782: oJumpForward 5792
5784: oJumpForward 5792
5786: Choice Lookup Table
          12   5784
          16   5780
5791: oEndChoice
5792: oJumpBack 5664
5794: oReturn
5795: oLocalSpace 2
5797: oTypeSNodeType
5798: oChoice 5802
5800: oJumpForward 5807
5802: Choice Lookup Table
          29   5800
5805: oError 11
5807: oTypeSTop
5808: oPushResult
5809: oSetResult 37
5811: oPushResult
5812: oNodeGet
5813: oPop 2
5815: oPushResult
5816: oScopeEnter
5817: oPop 1
5819: oInput 0
5821: oGetAddrLocal 1
5823: oPushResult
5824: oScopeFindRequire
5825: oAssign
5826: oGetLocal 1
5828: oPushResult
5829: oNodeType
5830: oPop 1
5832: oChoice 5836
5834: oJumpForward 5841
5836: Choice Lookup Table
          17   5834
5839: oError 12
5841: oScopeEnd
5842: oGetAddrLocal 2
5844: oPushResult
5845: oGetLocal 1
5847: oPushResult
5848: oSetResult 21
5850: oPushResult
5851: oNodeGetInt
5852: oPop 2
5854: oAssign
5855: oGetLocal 2
5857: oPushResult
5858: equal_zero
5859: oPop 1
5861: oChoice 5875
5863: oEmit 15
5865: oGetLocal 2
5867: oPushResult
5868: oEmitInt
5869: oPop 1
5871: oEmit 33
5873: oJumpForward 5878
5875: Choice Lookup Table
           0   5863
5878: oTypeSPop
5879: oGetLocal 1
5881: oPushResult
5882: oSetResult 20
5884: oPushResult
5885: oNodeGet
5886: oPop 2
5888: oPushResult
5889: oTypeSPush
5890: oPop 1
5892: oReturn
5893: oLocalSpace 1
5895: oTypeSNodeType
5896: oChoice 5900
5898: oJumpForward 5905
5900: Choice Lookup Table
          26   5898
5903: oError 9
5905: oEmit 24
5907: oGetAddrLocal 1
5909: oPushResult
5910: oTypeSTop
5911: oAssign
5912: oTypeSPop
5913: oGetLocal 1
5915: oPushResult
5916: oSetResult 33
5918: oPushResult
5919: oNodeGet
5920: oPop 2
5922: oPushResult
5923: oTypeSPush
5924: oPop 1
5926: oReturn
5927: oLocalSpace 0
5929: oCall 7693
5931: oReturn
5932: oLocalSpace 2
5934: oGetAddrLocal 2
5936: oPushResult
5937: oGetParam 1
5939: oPushResult
5940: oSetResult 25
5942: oPushResult
5943: oNodeGetString
5944: oPop 2
5946: oAssign
5947: oGetLocal 2
5949: oPushResult
5950: oSetResult 0
5952: oPushResult
5953: equal_string
5954: oPop 2
5956: oChoice 5993
5958: oGetAddrLocal 1
5960: oPushResult
5961: oGetParam 1
5963: oPushResult
5964: oSetResult 4
5966: oPushResult
5967: oNodeGetInt
5968: oPop 2
5970: oPushResult
5971: ID_STRING
5972: oPop 1
5974: oPushResult
5975: oStringAllocLit
5976: oPop 1
5978: oAssign
5979: oJumpForward 5999
5981: oGetAddrLocal 1
5983: oPushResult
5984: oGetLocal 2
5986: oPushResult
5987: oStringAllocLit
5988: oPop 1
5990: oAssign
5991: oJumpForward 5999
5993: Choice Lookup Table
           0   5981
           1   5958
5998: oEndChoice
5999: oEmit 58
6001: oGetParam 1
6003: oPushResult
6004: oCall 7970
6006: oPop 1
6008: oGetLocal 1
6010: oPushResult
6011: oEmitInt
6012: oPop 1
6014: oReturn
6015: oLocalSpace 10
6017: oGetParam 1
6019: oPushResult
6020: oSetResult 24
6022: oPushResult
6023: oNodeGetBoolean
6024: oPop 2
6026: oChoice 6053
6028: oGetParam 1
6030: oPushResult
6031: oSetResult 27
6033: oPushResult
6034: oNodeGetBoolean
6035: oPop 2
6037: oChoice 6048
6039: oGetParam 1
6041: oPushResult
6042: oCall 5932
6044: oPop 1
6046: oJumpForward 6051
6048: Choice Lookup Table
           0   6039
6051: oJumpForward 6056
6053: Choice Lookup Table
           1   6028
6056: oGetParam 1
6058: oPushResult
6059: oSetResult 27
6061: oPushResult
6062: oSetResult 1
6064: oPushResult
6065: oNodeSetBoolean
6066: oPop 3
6068: oGetAddrLocal 1
6070: oPushResult
6071: oGetParam 1
6073: oPushResult
6074: oSetResult 26
6076: oPushResult
6077: oNodeGetBoolean
6078: oPop 2
6080: oAssign
6081: oGetAddrLocal 4
6083: oPushResult
6084: oGetParam 1
6086: oPushResult
6087: oNodeType
6088: oPop 1
6090: oPushResult
6091: oSetResult 11
6093: oPushResult
6094: equal_node_type
6095: oPop 2
6097: oAssign
6098: oGetLocal 4
6100: oChoice 6127
6102: oGetAddrLocal 2
6104: oPushResult
6105: oGetParam 1
6107: oPushResult
6108: oSetResult 20
6110: oPushResult
6111: oNodeGet
6112: oPop 2
6114: oAssign
6115: oGetAddrLocal 3
6117: oPushResult
6118: oGetLocal 2
6120: oPushResult
6121: oScopeAllocType
6122: oPop 1
6124: oAssign
6125: oJumpForward 6130
6127: Choice Lookup Table
           1   6102
6130: oGetAddrLocal 5
6132: oPushResult
6133: oGetParam 1
6135: oPushResult
6136: oSetResult 22
6138: oPushResult
6139: oNodeGet
6140: oPop 2
6142: oAssign
6143: oGetAddrLocal 6
6145: oPushResult
6146: oGetLocal 5
6148: oPushResult
6149: oSetResult 16
6151: oPushResult
6152: oNodeGetInt
6153: oPop 2
6155: oAssign
6156: oGetLocal 1
6158: oChoice 6180
6160: oEmit 47
6162: oGetLocal 6
6164: oPushResult
6165: oEmitInt
6166: oPop 1
6168: oJumpForward 6186
6170: oEmit 46
6172: oGetLocal 6
6174: oPushResult
6175: oEmitInt
6176: oPop 1
6178: oJumpForward 6186
6180: Choice Lookup Table
           0   6170
           1   6160
6185: oEndChoice
6186: oGetParam 1
6188: oPushResult
6189: oCall 7655
6191: oPop 1
6193: oPushResult
6194: oSetResult 0
6196: oPushResult
6197: greater
6198: oPop 2
6200: oChoice 6233
6202: oEmit 19
6204: oSetResult 0
6206: oPushResult
6207: oEmitInt
6208: oPop 1
6210: oEmit 20
6212: oGetParam 1
6214: oPushResult
6215: oCall 7675
6217: oPop 1
6219: oPushResult
6220: oEmitInt
6221: oPop 1
6223: oSetResult 0
6225: oPushResult
6226: oEmitInt
6227: oPop 1
6229: oEmit 27
6231: oJumpForward 6236
6233: Choice Lookup Table
           1   6202
6236: oGetAddrLocal 7
6238: oPushResult
6239: oGetLocal 5
6241: oPushResult
6242: oSetResult 14
6244: oPushResult
6245: oNodeGetIter
6246: oPop 2
6248: oAssign
6249: oGetAddrLocal 8
6251: oPushResult
6252: oGetLocal 7
6254: oPushResult
6255: oNodeIterValue
6256: oPop 1
6258: oAssign
6259: oInputChoice 6438
6261: oGetLocal 8
6263: oPushResult
6264: oNodeNull
6265: oPop 1
6267: oChoice 6273
6269: oJumpForward 6434
6271: oJumpForward 6276
6273: Choice Lookup Table
           1   6269
6276: oGetAddrLocal 9
6278: oPushResult
6279: oGetLocal 8
6281: oPushResult
6282: oSetResult 21
6284: oPushResult
6285: oNodeGetInt
6286: oPop 2
6288: oAssign
6289: oEmit 19
6291: oGetLocal 9
6293: oPushResult
6294: oEmitInt
6295: oPop 1
6297: oGetLocal 8
6299: oPushResult
6300: oSetResult 20
6302: oPushResult
6303: oNodeGet
6304: oPop 2
6306: oPushResult
6307: oTypeSPush
6308: oPop 1
6310: oGetLocal 8
6312: oPushResult
6313: oSetResult 31
6315: oPushResult
6316: oNodeGetBoolean
6317: oPop 2
6319: oChoice 6387
6321: oCall 6926
6323: oCall 7693
6325: oEmit 27
6327: oJumpForward 6393
6329: oCall 3601
6331: oCall 5927
6333: oTypeSNodeType
6334: oChoice 6352
6336: oEmit 25
6338: oJumpForward 6385
6340: oEmit 26
6342: oJumpForward 6385
6344: oError 16
6346: oJumpForward 6385
6348: oEmit 27
6350: oJumpForward 6385
6352: Choice Lookup Table
          26   6348
          20   6344
          25   6344
          24   6344
          22   6340
          21   6336
6365: oGetAddrLocal 10
6367: oPushResult
6368: oTypeSTop
6369: oPushResult
6370: oSetResult 16
6372: oPushResult
6373: oNodeGetInt
6374: oPop 2
6376: oAssign
6377: oEmit 28
6379: oGetLocal 10
6381: oPushResult
6382: oEmitInt
6383: oPop 1
6385: oJumpForward 6393
6387: Choice Lookup Table
           0   6329
           1   6321
6392: oEndChoice
6393: oTypeSPop
6394: oGetAddrLocal 7
6396: oPushResult
6397: oNodeIterNext
6398: oPop 1
6400: oGetAddrLocal 8
6402: oPushResult
6403: oGetLocal 7
6405: oPushResult
6406: oNodeIterValue
6407: oPop 1
6409: oAssign
6410: oGetLocal 8
6412: oPushResult
6413: oNodeNull
6414: oPop 1
6416: oChoice 6424
6418: oJumpForward 6434
6420: oJumpForward 6430
6422: oJumpForward 6430
6424: Choice Lookup Table
           0   6422
           1   6418
6429: oEndChoice
6430: oInput 12
6432: oJumpBack 6261
6434: oInput 14
6436: oJumpForward 6441
6438: Choice Lookup Table
          13   6261
6441: oGetLocal 8
6443: oPushResult
6444: oNodeNull
6445: oPop 1
6447: oChoice 6453
6449: oError 15
6451: oJumpForward 6456
6453: Choice Lookup Table
           0   6449
6456: oGetLocal 4
6458: oChoice 6487
6460: oEmit 19
6462: oGetParam 1
6464: oPushResult
6465: oSetResult 30
6467: oPushResult
6468: oNodeGetInt
6469: oPop 2
6471: oPushResult
6472: oEmitInt
6473: oPop 1
6475: oEmit 17
6477: oGetLocal 3
6479: oPushResult
6480: oEmitInt
6481: oPop 1
6483: oEmit 27
6485: oJumpForward 6490
6487: Choice Lookup Table
           1   6460
6490: oGetLocal 1
6492: oChoice 6516
6494: oEmit 50
6496: oGetParam 1
6498: oPushResult
6499: oCall 7970
6501: oPop 1
6503: oJumpForward 6522
6505: oEmit 49
6507: oGetParam 1
6509: oPushResult
6510: oCall 7970
6512: oPop 1
6514: oJumpForward 6522
6516: Choice Lookup Table
           0   6505
           1   6494
6521: oEndChoice
6522: oGetLocal 4
6524: oChoice 6592
6526: oGetLocal 2
6528: oPushResult
6529: oTypeSPush
6530: oPop 1
6532: oTypeSNodeType
6533: oChoice 6569
6535: oEmit 3
6537: oGetLocal 3
6539: oPushResult
6540: oEmitInt
6541: oPop 1
6543: oJumpForward 6590
6545: oEmit 4
6547: oGetLocal 3
6549: oPushResult
6550: oEmitInt
6551: oPop 1
6553: oJumpForward 6590
6555: oError 16
6557: oJumpForward 6590
6559: oEmit 5
6561: oGetLocal 3
6563: oPushResult
6564: oEmitInt
6565: oPop 1
6567: oJumpForward 6590
6569: Choice Lookup Table
          26   6559
          20   6555
          25   6555
          24   6555
          22   6545
          21   6535
6582: oEmit 17
6584: oGetLocal 3
6586: oPushResult
6587: oEmitInt
6588: oPop 1
6590: oJumpForward 6595
6592: Choice Lookup Table
           1   6526
6595: oEmit 48
6597: oGetLocal 6
6599: oPushResult
6600: oEmitInt
6601: oPop 1
6603: oReturn
6604: oLocalSpace 0
6606: oInputChoice 6656
6608: oCall 7563
6610: oJumpForward 6681
6612: oCall 7570
6614: oJumpForward 6681
6616: oCall 7637
6618: oJumpForward 6681
6620: oCall 7640
6622: oJumpForward 6681
6624: oCall 7103
6626: oJumpForward 6681
6628: oCall 7423
6630: oJumpForward 6681
6632: oCall 7169
6634: oJumpForward 6681
6636: oCall 7343
6638: oJumpForward 6681
6640: oCall 7508
6642: oJumpForward 6681
6644: oCall 7476
6646: oJumpForward 6681
6648: oCall 7540
6650: oJumpForward 6681
6652: oCall 6682
6654: oJumpForward 6681
6656: Choice Lookup Table
           0   6652
          33   6648
          49   6644
          50   6640
          47   6636
          42   6632
          46   6628
          39   6624
          63   6620
          62   6616
          61   6612
          60   6608
6681: oReturn
6682: oLocalSpace 1
6684: oGetAddrLocal 1
6686: oPushResult
6687: oScopeFindRequire
6688: oAssign
6689: oGetLocal 1
6691: oPushResult
6692: oNodeType
6693: oPop 1
6695: oChoice 6724
6697: oGetLocal 1
6699: oPushResult
6700: oCall 6015
6702: oPop 1
6704: oJumpForward 6737
6706: oGetLocal 1
6708: oPushResult
6709: oCall 6738
6711: oPop 1
6713: oJumpForward 6737
6715: oGetLocal 1
6717: oPushResult
6718: oCall 6812
6720: oPop 1
6722: oJumpForward 6737
6724: Choice Lookup Table
          11   6715
          18   6706
          16   6706
          15   6706
          10   6697
6735: oError 0
6737: oReturn
6738: oLocalSpace 0
6740: oGetParam 1
6742: oPushResult
6743: oCall 6962
6745: oPop 1
6747: oInput 3
6749: oCall 3601
6751: oCall 7693
6753: oCall 6756
6755: oReturn
6756: oLocalSpace 1
6758: oTypeSNodeType
6759: oChoice 6777
6761: oEmit 25
6763: oJumpForward 6810
6765: oEmit 26
6767: oJumpForward 6810
6769: oError 16
6771: oJumpForward 6810
6773: oEmit 27
6775: oJumpForward 6810
6777: Choice Lookup Table
          26   6773
          20   6769
          25   6769
          24   6769
          22   6765
          21   6761
6790: oGetAddrLocal 1
6792: oPushResult
6793: oTypeSTop
6794: oPushResult
6795: oSetResult 16
6797: oPushResult
6798: oNodeGetInt
6799: oPop 2
6801: oAssign
6802: oEmit 28
6804: oGetLocal 1
6806: oPushResult
6807: oEmitInt
6808: oPop 1
6810: oTypeSPop
6811: oReturn
6812: oLocalSpace 1
6814: oGetParam 1
6816: oPushResult
6817: oSetResult 6
6819: oPushResult
6820: oNodeGet
6821: oPop 2
6823: oPushResult
6824: oScopeCurrent
6825: oPushResult
6826: oNodeEqual
6827: oPop 2
6829: oChoice 6835
6831: oError 20
6833: oJumpForward 6838
6835: Choice Lookup Table
           0   6831
6838: oEmit 8
6840: oGetParam 1
6842: oPushResult
6843: oSetResult 30
6845: oPushResult
6846: oNodeGetInt
6847: oPop 2
6849: oPushResult
6850: oEmitInt
6851: oPop 1
6853: oGetParam 1
6855: oPushResult
6856: oSetResult 20
6858: oPushResult
6859: oNodeGet
6860: oPop 2
6862: oPushResult
6863: oTypeSPush
6864: oPop 1
6866: oInput 3
6868: oCall 3601
6870: oCall 7693
6872: oTypeSNodeType
6873: oChoice 6891
6875: oEmit 25
6877: oJumpForward 6924
6879: oEmit 26
6881: oJumpForward 6924
6883: oError 16
6885: oJumpForward 6924
6887: oEmit 27
6889: oJumpForward 6924
6891: Choice Lookup Table
          26   6887
          20   6883
          25   6883
          24   6883
          22   6879
          21   6875
6904: oGetAddrLocal 1
6906: oPushResult
6907: oTypeSTop
6908: oPushResult
6909: oSetResult 16
6911: oPushResult
6912: oNodeGetInt
6913: oPop 2
6915: oAssign
6916: oEmit 28
6918: oGetLocal 1
6920: oPushResult
6921: oEmitInt
6922: oPop 1
6924: oTypeSPop
6925: oReturn
6926: oLocalSpace 1
6928: oInput 0
6930: oGetAddrLocal 1
6932: oPushResult
6933: oScopeFindRequire
6934: oAssign
6935: oGetLocal 1
6937: oPushResult
6938: oNodeType
6939: oPop 1
6941: oChoice 6945
6943: oJumpForward 6954
6945: Choice Lookup Table
          18   6943
          16   6943
          15   6943
6952: oError 4
6954: oGetLocal 1
6956: oPushResult
6957: oCall 6962
6959: oPop 1
6961: oReturn
6962: oLocalSpace 0
6964: oGetParam 1
6966: oPushResult
6967: oNodeType
6968: oPop 1
6970: oChoice 7030
6972: oEmit 16
6974: oGetParam 1
6976: oPushResult
6977: oCall 7970
6979: oPop 1
6981: oJumpForward 7039
6983: oEmit 17
6985: oGetParam 1
6987: oPushResult
6988: oCall 7970
6990: oPop 1
6992: oJumpForward 7039
6994: oGetParam 1
6996: oPushResult
6997: oSetResult 31
6999: oPushResult
7000: oNodeGetBoolean
7001: oPop 2
7003: oChoice 7016
7005: oEmit 8
7007: oGetParam 1
7009: oPushResult
7010: oCall 7970
7012: oPop 1
7014: oJumpForward 7028
7016: Choice Lookup Table
           1   7005
7019: oEmit 18
7021: oGetParam 1
7023: oPushResult
7024: oCall 7970
7026: oPop 1
7028: oJumpForward 7039
7030: Choice Lookup Table
          18   6994
          16   6983
          15   6972
7037: oError 4
7039: oGetParam 1
7041: oPushResult
7042: oSetResult 20
7044: oPushResult
7045: oNodeGet
7046: oPop 2
7048: oPushResult
7049: oTypeSPush
7050: oPop 1
7052: oCall 5624
7054: oReturn
7055: oLocalSpace 0
7057: oGetParam 1
7059: oPushResult
7060: oCall 6962
7062: oPop 1
7064: oCall 7719
7066: oGetParam 1
7068: oPushResult
7069: oCall 4863
7071: oPop 1
7073: oTypeSPop
7074: oEmit 29
7076: oEmit 25
7078: oReturn
7079: oLocalSpace 0
7081: oGetParam 1
7083: oPushResult
7084: oCall 6962
7086: oPop 1
7088: oCall 7719
7090: oGetParam 1
7092: oPushResult
7093: oCall 4863
7095: oPop 1
7097: oTypeSPop
7098: oEmit 30
7100: oEmit 25
7102: oReturn
7103: oLocalSpace 2
7105: oGetAddrLocal 1
7107: oPushResult
7108: oSetResult 0
7110: oAssign
7111: oGetAddrLocal 1
7113: oPushResult
7114: oCall 3624
7116: oPop 1
7118: oInput 40
7120: oCall 6604
7122: oInputChoice 7157
7124: oGetAddrLocal 2
7126: oPushResult
7127: oLabelNew
7128: oAssign
7129: oEmit 53
7131: oGetLocal 2
7133: oPushResult
7134: oEmitLabel
7135: oPop 1
7137: oEmit 56
7139: oGetLocal 1
7141: oPushResult
7142: oEmitLabel
7143: oPop 1
7145: oCall 6604
7147: oEmit 56
7149: oGetLocal 2
7151: oPushResult
7152: oEmitLabel
7153: oPop 1
7155: oJumpForward 7168
7157: Choice Lookup Table
          41   7124
7160: oEmit 56
7162: oGetLocal 1
7164: oPushResult
7165: oEmitLabel
7166: oPop 1
7168: oReturn
7169: oLocalSpace 4
7171: oInput 0
7173: oGetAddrLocal 1
7175: oPushResult
7176: oScopeFindRequire
7177: oAssign
7178: oGetLocal 1
7180: oPushResult
7181: oCall 6962
7183: oPop 1
7185: oCall 7719
7187: oInput 3
7189: oCall 3601
7191: oCall 7719
7193: oEmit 25
7195: oGetAddrLocal 2
7197: oPushResult
7198: oLabelNew
7199: oAssign
7200: oGetAddrLocal 3
7202: oPushResult
7203: oLabelNew
7204: oAssign
7205: oEmit 53
7207: oGetLocal 3
7209: oPushResult
7210: oEmitLabel
7211: oPop 1
7213: oGetAddrLocal 4
7215: oPushResult
7216: oLabelNew
7217: oAssign
7218: oEmit 56
7220: oGetLocal 4
7222: oPushResult
7223: oEmitLabel
7224: oPop 1
7226: oInputChoice 7306
7228: oGetLocal 1
7230: oPushResult
7231: oCall 7055
7233: oPop 1
7235: oEmit 56
7237: oGetLocal 3
7239: oPushResult
7240: oEmitLabel
7241: oPop 1
7243: oGetLocal 1
7245: oPushResult
7246: oCall 4863
7248: oPop 1
7250: oTypeSPop
7251: oCall 3601
7253: oCall 7719
7255: oEmit 40
7257: oEmit 54
7259: oGetLocal 2
7261: oPushResult
7262: oEmitLabel
7263: oPop 1
7265: oJumpForward 7312
7267: oGetLocal 1
7269: oPushResult
7270: oCall 7079
7272: oPop 1
7274: oEmit 56
7276: oGetLocal 3
7278: oPushResult
7279: oEmitLabel
7280: oPop 1
7282: oGetLocal 1
7284: oPushResult
7285: oCall 4863
7287: oPop 1
7289: oTypeSPop
7290: oCall 3601
7292: oCall 7719
7294: oEmit 41
7296: oEmit 54
7298: oGetLocal 2
7300: oPushResult
7301: oEmitLabel
7302: oPop 1
7304: oJumpForward 7312
7306: Choice Lookup Table
          44   7267
          43   7228
7311: oEndChoice
7312: oGetLocal 4
7314: oPushResult
7315: oGetLocal 2
7317: oPushResult
7318: oLoopPush
7319: oPop 2
7321: oInput 45
7323: oCall 6604
7325: oEmit 53
7327: oGetLocal 4
7329: oPushResult
7330: oEmitLabel
7331: oPop 1
7333: oEmit 56
7335: oGetLocal 2
7337: oPushResult
7338: oEmitLabel
7339: oPop 1
7341: oLoopPop
7342: oReturn
7343: oLocalSpace 3
7345: oGetAddrLocal 1
7347: oPushResult
7348: oLabelNew
7349: oAssign
7350: oEmit 56
7352: oGetLocal 1
7354: oPushResult
7355: oEmitLabel
7356: oPop 1
7358: oGetAddrLocal 2
7360: oPushResult
7361: oLabelNew
7362: oAssign
7363: oGetLocal 1
7365: oPushResult
7366: oGetLocal 2
7368: oPushResult
7369: oLoopPush
7370: oPop 2
7372: oCall 6604
7374: oInputChoice 7405
7376: oCall 6604
7378: oJumpForward 7411
7380: oGetAddrLocal 3
7382: oPushResult
7383: oCall 3624
7385: oPop 1
7387: oEmit 57
7389: oGetLocal 3
7391: oPushResult
7392: oEmitLabel
7393: oPop 1
7395: oGetLocal 1
7397: oPushResult
7398: oEmitLabel
7399: oPop 1
7401: oJumpForward 7413
7403: oJumpForward 7411
7405: Choice Lookup Table
          48   7380
           4   7376
7410: oEndChoice
7411: oJumpBack 7374
7413: oEmit 56
7415: oGetLocal 2
7417: oPushResult
7418: oEmitLabel
7419: oPop 1
7421: oLoopPop
7422: oReturn
7423: oLocalSpace 2
7425: oGetAddrLocal 1
7427: oPushResult
7428: oLabelNew
7429: oAssign
7430: oEmit 56
7432: oGetLocal 1
7434: oPushResult
7435: oEmitLabel
7436: oPop 1
7438: oGetAddrLocal 2
7440: oPushResult
7441: oCall 3624
7443: oPop 1
7445: oGetLocal 1
7447: oPushResult
7448: oGetLocal 2
7450: oPushResult
7451: oLoopPush
7452: oPop 2
7454: oInput 45
7456: oCall 6604
7458: oEmit 53
7460: oGetLocal 1
7462: oPushResult
7463: oEmitLabel
7464: oPop 1
7466: oEmit 56
7468: oGetLocal 2
7470: oPushResult
7471: oEmitLabel
7472: oPop 1
7474: oLoopPop
7475: oReturn
7476: oLocalSpace 0
7478: oLoopContinueLabel
7479: oPushResult
7480: oSetResult 0
7482: oPushResult
7483: equal_label
7484: oPop 2
7486: oChoice 7501
7488: oError 18
7490: oJumpForward 7507
7492: oEmit 53
7494: oLoopContinueLabel
7495: oPushResult
7496: oEmitLabel
7497: oPop 1
7499: oJumpForward 7507
7501: Choice Lookup Table
           0   7492
           1   7488
7506: oEndChoice
7507: oReturn
7508: oLocalSpace 0
7510: oLoopBreakLabel
7511: oPushResult
7512: oSetResult 0
7514: oPushResult
7515: equal_label
7516: oPop 2
7518: oChoice 7533
7520: oError 18
7522: oJumpForward 7539
7524: oEmit 53
7526: oLoopBreakLabel
7527: oPushResult
7528: oEmitLabel
7529: oPop 1
7531: oJumpForward 7539
7533: Choice Lookup Table
           0   7524
           1   7520
7538: oEndChoice
7539: oReturn
7540: oLocalSpace 0
7542: oCall 6604
7544: oInputChoice 7554
7546: oCall 6604
7548: oJumpForward 7560
7550: oJumpForward 7562
7552: oJumpForward 7560
7554: Choice Lookup Table
          34   7550
           4   7546
7559: oEndChoice
7560: oJumpBack 7544
7562: oReturn
7563: oLocalSpace 0
7565: oCall 7570
7567: oEmit 63
7569: oReturn
7570: oLocalSpace 0
7572: oInputChoice 7633
7574: oCall 3601
7576: oTypeSNodeType
7577: oChoice 7599
7579: oEmit 59
7581: oJumpForward 7614
7583: oEmit 60
7585: oJumpForward 7614
7587: oEmit 61
7589: oJumpForward 7614
7591: oError 16
7593: oJumpForward 7614
7595: oEmit 62
7597: oJumpForward 7614
7599: Choice Lookup Table
          26   7595
          20   7591
          24   7591
          25   7587
          22   7583
          21   7579
7612: oError 17
7614: oTypeSPop
7615: oInputChoice 7623
7617: oJumpForward 7631
7619: oJumpForward 7629
7621: oJumpForward 7629
7623: Choice Lookup Table
          12   7621
          14   7617
7628: oEndChoice
7629: oJumpBack 7574
7631: oJumpForward 7636
7633: Choice Lookup Table
          13   7574
7636: oReturn
7637: oLocalSpace 0
7639: oReturn
7640: oLocalSpace 0
7642: oReturn
7643: oLocalSpace 0
7645: oScopeCurrent
7646: oPushResult
7647: oSetResult 13
7649: oPushResult
7650: oNodeGetInt
7651: oPop 2
7653: oReturn
7654: oReturn
7655: oLocalSpace 0
7657: oGetParam 1
7659: oPushResult
7660: oSetResult 19
7662: oPushResult
7663: oNodeGet
7664: oPop 2
7666: oPushResult
7667: oSetResult 13
7669: oPushResult
7670: oNodeGetInt
7671: oPop 2
7673: oReturn
7674: oReturn
7675: oLocalSpace 0
7677: oCall 7643
7679: oPushResult
7680: oGetParam 1
7682: oPushResult
7683: oCall 7655
7685: oPop 1
7687: oPushResult
7688: subtract
7689: oPop 2
7691: oReturn
7692: oReturn
7693: oLocalSpace 1
7695: oGetAddrLocal 1
7697: oPushResult
7698: oTypeSNodeType
7699: oAssign
7700: oTypeSPop
7701: oGetLocal 1
7703: oPushResult
7704: oTypeSNodeType
7705: oPushResult
7706: equal_node_type
7707: oPop 2
7709: oChoice 7715
7711: oError 14
7713: oJumpForward 7718
7715: Choice Lookup Table
           0   7711
7718: oReturn
7719: oLocalSpace 0
7721: oTypeSNodeType
7722: oChoice 7726
7724: oJumpForward 7731
7726: Choice Lookup Table
          21   7724
7729: oError 7
7731: oTypeSPop
7732: oReturn
7733: oLocalSpace 0
7735: oTypeSNodeType
7736: oChoice 7740
7738: oJumpForward 7745
7740: Choice Lookup Table
          21   7738
7743: oError 7
7745: oReturn
7746: oLocalSpace 0
7748: oTypeSNodeType
7749: oChoice 7753
7751: oJumpForward 7758
7753: Choice Lookup Table
          22   7751
7756: oError 8
7758: oTypeSPop
7759: oReturn
7760: oLocalSpace 0
7762: oTypeSNodeType
7763: oChoice 7767
7765: oJumpForward 7772
7767: Choice Lookup Table
          22   7765
7770: oError 8
7772: oReturn
7773: oLocalSpace 1
7775: oGetAddrLocal 1
7777: oPushResult
7778: oGetParam 2
7780: oPushResult
7781: oNodeNew
7782: oPop 1
7784: oAssign
7785: oGetLocal 1
7787: oPushResult
7788: oSetResult 16
7790: oPushResult
7791: oGetParam 1
7793: oPushResult
7794: oNodeSetInt
7795: oPop 3
7797: oGetLocal 1
7799: oPushResult
7800: oTypeAdd
7801: oPop 1
7803: oGetLocal 1
7805: oReturn
7806: oReturn
7807: oLocalSpace 1
7809: oGetAddrLocal 1
7811: oPushResult
7812: oGetParam 3
7814: oPushResult
7815: oNodeNew
7816: oPop 1
7818: oAssign
7819: oGetLocal 1
7821: oPushResult
7822: oSetResult 4
7824: oPushResult
7825: oGetParam 1
7827: oPushResult
7828: oNodeSetInt
7829: oPop 3
7831: oGetLocal 1
7833: oReturn
7834: oReturn
7835: oLocalSpace 1
7837: oGetAddrLocal 1
7839: oPushResult
7840: oGetParam 1
7842: oPushResult
7843: oSetResult 32
7845: oPushResult
7846: oNodeGet
7847: oPop 2
7849: oAssign
7850: oGetLocal 1
7852: oPushResult
7853: oNodeNull
7854: oPop 1
7856: oChoice 7912
7858: oGetAddrLocal 1
7860: oPushResult
7861: oSetResult 26
7863: oPushResult
7864: oNodeNew
7865: oPop 1
7867: oAssign
7868: oGetLocal 1
7870: oPushResult
7871: oSetResult 33
7873: oPushResult
7874: oGetParam 1
7876: oPushResult
7877: oNodeSet
7878: oPop 3
7880: oGetLocal 1
7882: oPushResult
7883: oSetResult 16
7885: oPushResult
7886: oSetResult 8
7888: oPushResult
7889: oNodeSetInt
7890: oPop 3
7892: oGetLocal 1
7894: oPushResult
7895: oTypeAdd
7896: oPop 1
7898: oGetParam 1
7900: oPushResult
7901: oSetResult 32
7903: oPushResult
7904: oGetLocal 1
7906: oPushResult
7907: oNodeSet
7908: oPop 3
7910: oJumpForward 7915
7912: Choice Lookup Table
           1   7858
7915: oGetLocal 1
7917: oReturn
7918: oReturn
7919: oLocalSpace 0
7921: oGetParam 1
7923: oPushResult
7924: oNodeType
7925: oPop 1
7927: oChoice 7955
7929: oMININT
7930: oReturn
7931: oJumpForward 7969
7933: oSetResult 0
7935: oReturn
7936: oJumpForward 7969
7938: oSetResult 0
7940: oReturn
7941: oJumpForward 7969
7943: oGetParam 1
7945: oPushResult
7946: oSetResult 35
7948: oPushResult
7949: oNodeGetInt
7950: oPop 2
7952: oReturn
7953: oJumpForward 7969
7955: Choice Lookup Table
          28   7943
          24   7938
          22   7933
          21   7929
7964: oError 3
7966: oSetResult 0
7968: oReturn
7969: oReturn
7970: oLocalSpace 0
7972: oGetParam 1
7974: oPushResult
7975: oSetResult 21
7977: oPushResult
7978: oNodeGetInt
7979: oPop 2
7981: oPushResult
7982: oEmitInt
7983: oPop 1
7985: oReturn
7986: oLocalSpace 1
7988: oGetAddrGlobal 3
7990: oPushResult
7991: oSetResult 20
7993: oPushResult
7994: oSetResult 4
7996: oPushResult
7997: oCall 7773
7999: oPop 2
8001: oAssign
8002: oGetAddrGlobal 4
8004: oPushResult
8005: oSetResult 21
8007: oPushResult
8008: oSetResult 4
8010: oPushResult
8011: oCall 7773
8013: oPop 2
8015: oAssign
8016: oGetAddrGlobal 5
8018: oPushResult
8019: oSetResult 22
8021: oPushResult
8022: oSetResult 1
8024: oPushResult
8025: oCall 7773
8027: oPop 2
8029: oAssign
8030: oGetAddrGlobal 6
8032: oPushResult
8033: oSetResult 23
8035: oPushResult
8036: oSetResult 1
8038: oPushResult
8039: oCall 7773
8041: oPop 2
8043: oAssign
8044: oGetAddrGlobal 7
8046: oPushResult
8047: oSetResult 24
8049: oPushResult
8050: oSetResult 1
8052: oPushResult
8053: oCall 7773
8055: oPop 2
8057: oAssign
8058: oGetAddrGlobal 8
8060: oPushResult
8061: oSetResult 25
8063: oPushResult
8064: oSetResult 256
8066: oPushResult
8067: oCall 7773
8069: oPop 2
8071: oAssign
8072: oGetAddrLocal 1
8074: oPushResult
8075: oSetResult 13
8077: oPushResult
8078: oSetResult 5
8080: oPushResult
8081: oIdAdd_File
8082: oPushResult
8083: oCall 7807
8085: oPop 3
8087: oAssign
8088: oGetLocal 1
8090: oPushResult
8091: oSetResult 20
8093: oPushResult
8094: oGetGlobal 3
8096: oPushResult
8097: oNodeSet
8098: oPop 3
8100: oGetLocal 1
8102: oPushResult
8103: oScopeDeclare
8104: oPop 1
8106: oGetAddrLocal 1
8108: oPushResult
8109: oSetResult 13
8111: oPushResult
8112: oSetResult 5
8114: oPushResult
8115: oIdAdd_Integer
8116: oPushResult
8117: oCall 7807
8119: oPop 3
8121: oAssign
8122: oGetLocal 1
8124: oPushResult
8125: oSetResult 20
8127: oPushResult
8128: oGetGlobal 4
8130: oPushResult
8131: oNodeSet
8132: oPop 3
8134: oGetLocal 1
8136: oPushResult
8137: oScopeDeclare
8138: oPop 1
8140: oGetAddrLocal 1
8142: oPushResult
8143: oSetResult 13
8145: oPushResult
8146: oSetResult 5
8148: oPushResult
8149: oIdAdd_Boolean
8150: oPushResult
8151: oCall 7807
8153: oPop 3
8155: oAssign
8156: oGetLocal 1
8158: oPushResult
8159: oSetResult 20
8161: oPushResult
8162: oGetGlobal 5
8164: oPushResult
8165: oNodeSet
8166: oPop 3
8168: oGetLocal 1
8170: oPushResult
8171: oScopeDeclare
8172: oPop 1
8174: oGetAddrLocal 1
8176: oPushResult
8177: oSetResult 13
8179: oPushResult
8180: oSetResult 5
8182: oPushResult
8183: oIdAdd_Char
8184: oPushResult
8185: oCall 7807
8187: oPop 3
8189: oAssign
8190: oGetLocal 1
8192: oPushResult
8193: oSetResult 20
8195: oPushResult
8196: oGetGlobal 7
8198: oPushResult
8199: oNodeSet
8200: oPop 3
8202: oGetLocal 1
8204: oPushResult
8205: oScopeDeclare
8206: oPop 1
8208: oGetAddrLocal 1
8210: oPushResult
8211: oSetResult 13
8213: oPushResult
8214: oSetResult 5
8216: oPushResult
8217: oIdAdd_String
8218: oPushResult
8219: oCall 7807
8221: oPop 3
8223: oAssign
8224: oGetLocal 1
8226: oPushResult
8227: oSetResult 20
8229: oPushResult
8230: oGetGlobal 8
8232: oPushResult
8233: oNodeSet
8234: oPop 3
8236: oGetLocal 1
8238: oPushResult
8239: oScopeDeclare
8240: oPop 1
8242: oGetAddrLocal 1
8244: oPushResult
8245: oSetResult 12
8247: oPushResult
8248: oSetResult 4
8250: oPushResult
8251: oIdAdd_True
8252: oPushResult
8253: oCall 7807
8255: oPop 3
8257: oAssign
8258: oGetLocal 1
8260: oPushResult
8261: oSetResult 20
8263: oPushResult
8264: oGetGlobal 5
8266: oPushResult
8267: oNodeSet
8268: oPop 3
8270: oGetLocal 1
8272: oPushResult
8273: oSetResult 21
8275: oPushResult
8276: oSetResult 1
8278: oPushResult
8279: oNodeSetInt
8280: oPop 3
8282: oGetLocal 1
8284: oPushResult
8285: oScopeDeclare
8286: oPop 1
8288: oGetAddrLocal 1
8290: oPushResult
8291: oSetResult 12
8293: oPushResult
8294: oSetResult 4
8296: oPushResult
8297: oIdAdd_False
8298: oPushResult
8299: oCall 7807
8301: oPop 3
8303: oAssign
8304: oGetLocal 1
8306: oPushResult
8307: oSetResult 20
8309: oPushResult
8310: oGetGlobal 5
8312: oPushResult
8313: oNodeSet
8314: oPop 3
8316: oGetLocal 1
8318: oPushResult
8319: oSetResult 21
8321: oPushResult
8322: oSetResult 0
8324: oPushResult
8325: oNodeSetInt
8326: oPop 3
8328: oGetLocal 1
8330: oPushResult
8331: oScopeDeclare
8332: oPop 1
8334: oReturn
