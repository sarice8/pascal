   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qParentScope
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin( 0 )
  10:    globalScope = oScopeCurrent
      
  15:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  17:    .tEnter  oEmitInt( 0 )
  25:    Label mainLabel = oLabelNew
      
  30:    .tAllocActuals  oEmitInt( 0 )
  38:    .tCall  oEmitLabel( mainLabel )
  46:    .tFreeActuals  oEmitInt( 0 )
  54:    .tReturn
      
  56:    pProgram
  58:    pIdent
      
  60:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  76:    oScopeDeclare( progDecl )
      
  82:    [
  82:       | '(' :
  84:          pIdent      % input, output files
      
  86:          t = @newIdent( nVar, kVar, LAST_ID )
 102:          oNodeSet( t, qType, FileType )
 114:          oScopeDeclareAlloc( t )
      
 120:          ','
 122:          pIdent
      
 124:          t = @newIdent( nVar, kVar, LAST_ID )
 140:          oNodeSet( t, qType, FileType )
 152:          oScopeDeclareAlloc( t )
      
 158:          ')'
 160:       | * :
 165:    ]
 165:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 167:    oScopeBegin( 0 )
 173:    mainRoutineScope = oScopeCurrent
 178:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 189:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
 200:    oScopeEnd
      
 201:    @BlockDecls( nGlobalVar )
      
      
 208:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 214:    @BlockStmt( mainLabel, globalScope )
      
 224:    oScopeEnd   % main routine scope
      
 225:    '.'
 227:    oScopeEnd   % global scope
 229:    ;
      
      
 229: Block( node_type varNodeType, Label labelForBody ):
 231:    @BlockDecls( varNodeType )
 238:    @BlockStmt( labelForBody, oScopeCurrent )
 248:    ;
      
      
 248: BlockDecls( node_type varNodeType ):
 250:    {[
 250:       | pConst :     @ConstDecl
 254:       | pType :      @TypeDecl
 258:       | pVar :       @VarDecl( varNodeType )
 267:       | pProcedure : @ProcDecl
 271:       | pFunction :  @FuncDecl
 275:       | * :          >
 290:    ]}
 292:    @CheckForUndefinedMethods
 295:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 295: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 298:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 298: BlockStmt( Label labelForBody, Node varScope ):
 300:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 308:    int patchLS
 308:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 317:    Code initCode = oNodeGetCode( varScope, qInitCode )
 330:    oEmitCode( initCode )
 336:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 347:    @Statement
 349:    .tReturn
      
 351:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 363:    oPatch( patchLS, localSpace )
 373:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 373: MethodModifiers( Node decl ):
 375:    {[
 375:       | pCdecl :
 377:          oNodeSetBoolean( decl, qCdecl, true )
 389:          ';'
      
 391:       | * : >
 398:    ]}
 401:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 401: GetOrCreateInitCode >> Code:
 403:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 415:    [ equal_code( initCode, codeNull )
 425:       | true :
 426:          initCode = oCodeNew
 431:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 442:       | * :
 447:    ]
 447:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 451: ExternalDecl( Node decl ):
 453:    [ equal_zero( @DeclLevel( decl ) )
 465:       | false :  #eExternalMethodCannotBeNested
 468:       | * :
 473:    ]
 473:    oNodeSetBoolean( decl, qExternal, true )
 485:    [
 485:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 487:          [
 487:             | pName :
 489:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 491:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 502:             | * :
 507:          ]
 507:       | * :
 512:    ]
 513:    ;
      
      
 513: ProcDecl:
 515:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 517:    boolean redeclaring = false
 523:    Node decl = oScopeFindInCurrentScope
      
 528:    [ oNodeNull( decl )
 535:       | true :
               % first declaration
 536:          decl = @newIdent( nProc, kProc, LAST_ID )
 552:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 563:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 565:          redeclaring = true
 571:          [ oNodeGetBoolean( decl, qBodyDefined )
 581:             | true : #eAlreadyDefined
 584:             | * :
 589:          ]
 589:          [ oNodeGetBoolean( decl, qExternal )
 599:             | true : #eAlreadyDefined
 602:             | * :
 607:          ]
 607:          [ oNodeType( decl )
 614:             | nProc :
 615:             | * : #eAlreadyDefined   % wrong kind
 622:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 622:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 641:          oNodeSet( decl, qParams, Null )
 653:    ]
      
 661:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 673:    boolean nested = greater( level, 0 )
 686:    inc( level )
 692:    oScopeBegin( level )
 698:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
 703:    [ nested
 706:       | true :
 707:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
 722:       | * :
 727:    ]
      
 727:    @FormalArgDecl
 729:    oNodeSet( decl, qParams, paramScope )
 741:    oScopeEnd
 742:    ';'
      
 744:    [ redeclaring
 747:       | false : oScopeDeclare( decl )
 754:       | true :  % TO DO: check that qParams is consistent with qOldParams
 756:    ]
      
 764:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 771:    [
 771:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 773:       | pExternal : @ExternalDecl( decl )
      
 782:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 789:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 795:          oScopeBegin( level )
 801:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 812:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 823:          Label label = oNodeGetLabel( decl, qValue )
 836:          @Block( nLocalVar, label )
 846:          oNodeSetBoolean( decl, qBodyDefined, true )
 858:          oScopeEnd
      
 859:          oScopeEnd  % paramScope
 860:    ]
 860:    ';';
      
      
 863: FuncDecl:
 865:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 867:    boolean redeclaring = false
 873:    Node decl = oScopeFindInCurrentScope
      
 878:    [ oNodeNull( decl )
 885:       | true :
               % first declaration
 886:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 902:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 913:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 915:          redeclaring = true
 921:          [ oNodeGetBoolean( decl, qBodyDefined )
 931:             | true : #eAlreadyDefined
 934:             | * :
 939:          ]
 939:          [ oNodeType( decl )
 946:             | nFunc :
 947:             | * : #eAlreadyDefined   % wrong kind
 954:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 954:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 973:          oNodeSet( decl, qParams, Null )
 985:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1004:          oNodeSet( decl, qType, Null )
1016:    ]
      
1024:    int level = oNodeGetInt( oScopeCurrent, qLevel )
1036:    boolean nested = greater( level, 0 )
1049:    inc( level )
1055:    oScopeBegin( level )
1061:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1066:    [ nested
1069:       | true :
1070:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1085:       | * :
1090:    ]
      
1090:    @FormalArgDecl
1092:    oNodeSet( decl, qParams, paramScope )
      
1104:    ':'
      
1106:    Node theType
1106:    @TypeRef( theType )
1113:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1125:    Node ptrType = @PointerTypeTo( theType )
1136:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1152:    oScopeEnd
1153:    ';'
      
1155:    [ redeclaring
1158:       | false : oScopeDeclare( decl )
1165:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1167:    ]
      
1175:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1182:    [
1182:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1184:       | pExternal : @ExternalDecl( decl )
      
1193:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1200:          oScopeEnter( paramScope )
      
1206:          oScopeBegin( level )
1212:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1223:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1234:          Label label = oNodeGetLabel( decl, qValue )
1247:          @Block( nLocalVar, label )
1257:          oNodeSetBoolean( decl, qBodyDefined, true )
1269:          oScopeEnd
      
1270:          oScopeEnd  % paramScope
1271:    ]
1271:    ';';
      
      
1274: FormalArgDecl:
1276:    [
1276:       | '(' :
1278:          {
1278:             NodeVec decls = oNodeVecNew
1283:             Node decl
1283:             boolean isInOut = false
      
1289:             [
1289:                | pVar : isInOut = true
1297:                | * :
1302:             ]
      
1302:             {  pIdent
      
1304:                decl = @newIdent( nParam, kVar, LAST_ID )
1320:                oNodeSetBoolean( decl, qInOut, isInOut )
1332:                oNodeVecAppend( decls, decl )
      
1341:                [
1341:                   | ':' : >
1345:                   | ',' :
1347:                ]
1355:             }
      
1357:             Node theType
1357:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1364:             Node allocType
1364:             [ isInOut
1367:                | true :   allocType = @PointerTypeTo( theType )
1379:                | * :      allocType = theType
1390:             ]
      
1390:             int i = 0
1396:             {[ equal( i, oNodeVecSize( decls ) )
1410:                | false :
1411:                   decl = oNodeVecElement( decls, i )
      
1424:                   oNodeSet( decl, qType, theType )
1436:                   oScopeDeclare( decl )
1442:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1458:                   inc( i )
1464:                | * :
1469:                   >
1471:             ]}
      
1473:             oNodeVecDelete( decls )
      
1479:             [
1479:                | ')' : >
1483:                | ';' :
1485:             ]
1493:          }
1495:       | * :
1500:    ];
      
1501: ConstDecl:
1503:    {[
1503:       | pIdent :
1505:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1521:          '='
      
1523:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1525:          int val = oValueTop
1530:          oValuePop
1531:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1543:          oNodeSet( decl, qType, IntegerType )
      
1555:          oScopeDeclare( decl )
1561:          ';'
1563:       | * :
1568:          >
1570:    ]};
      
1573: TypeDecl:
1575:    {[
1575:       | pIdent :
1577:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1593:          '='
1595:          Node theType
1595:          @TypeRef( theType )
1602:          oNodeSet( decl, qType, theType )
1614:          oScopeDeclare( decl )
1620:          ';'
1622:       | * :
1627:          >
1629:    ]};
      
1632: VarDecl( node_type varNodeType ):
1634:    {[
1634:       | pIdent :
1636:          NodeVec decls = oNodeVecNew
1641:          Node decl
1641:          {
1641:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1657:             oNodeVecAppend( decls, decl )
1666:             [
1666:                | ',' :
1668:                   pIdent
1670:                | * :
1675:                   >
1677:             ]
1677:          }
1679:          ':'
1681:          Node theType
1681:          @TypeRef( theType )
      
1688:          int i = 0
1694:          {[ equal( i, oNodeVecSize( decls ) )
1708:             | false :
1709:                decl = oNodeVecElement( decls, i )
1722:                oNodeSet( decl, qType, theType )
1734:                oScopeDeclareAlloc( decl )
1740:                inc( i )
1746:             | * :
1751:               >
1753:          ]}
      
               % optional initialization
1755:          [
1755:             | '=' :
1757:                [ oNodeVecSize( decls )
1764:                   | 1 :
1765:                   | * :  #eOnlyOneVarCanBeInitialized
1772:                ]
      
                     % we need an initCode stream for this scope
1772:                Code initCode = @GetOrCreateInitCode
1778:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1784:                boolean changedScope = false
1790:                [ equal_node( oScopeCurrent, globalScope )
1799:                   | true : oScopeEnter( mainRoutineScope )
1806:                            changedScope = true
1812:                   | * :
1817:                ]
                     % generate assignment in initCode stream
1817:                @LValueVar( decl )
1824:                @Expr
1826:                @MatchTypes
1828:                @Assign
1830:                [ changedScope
1833:                   | true : oScopeEnd
1835:                   | * :
1840:                ]
1840:                oCodePop
                   
1841:             | * :
1846:          ]
      
1846:          oNodeVecDelete( decls )
1852:          ';'
1854:       | * :
1859:          >
1861:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1864: TypeRef( out Node resultType ):
1866:    [
1866:       | pIdent :           % previously named type (including intrinsics)
1868:          Node decl = oScopeFindRequire
1873:          [ oNodeType( decl )
1880:            | nTypeDecl :
1881:                resultType = oNodeGet( decl, qType )
1894:            | * :
1899:                #eNotType
1901:                resultType = IntegerType
1907:          ]
         
1907:       | pArray :
1909:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1911:          NodeVec dimensions = oNodeVecNew
      
1916:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1916:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1926:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1938:             @ConstExpr
1940:             oNodeSetInt( subrange, qLow, oValueTop )
1951:             oValuePop
1952:             '..'
1954:             @ConstExpr
1956:             oNodeSetInt( subrange, qHigh, oValueTop )
1967:             oValuePop
1968:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1980:             oTypeAdd( subrange )
      
1986:             Node a = oNodeNew( nArrayType )
1996:             oNodeSet( a, qIndexType, subrange )
      
2008:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
2017:             [
2017:                | ']' : >
2021:                | ',' :
2023:             ]
2031:          }
      
2033:          pOf
2035:          Node baseType
2035:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
2042:          int dim = oNodeVecSize( dimensions )
      
2052:          {
2052:              dec(dim)
      
2058:              Node a = oNodeVecElement( dimensions, dim )
      
2071:              oNodeSet( a, qBaseType, baseType )
2083:              Node subrange = oNodeGet( a, qIndexType )
2096:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2123:              inc( width )
2129:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2155:              oTypeAdd( a )
2161:              baseType = a
      
2167:              [ equal_zero(dim)
2174:                  | true:  >
2177:                  | *:
2182:              ]
2182:          }
      
2184:          resultType = oNodeVecElement( dimensions, 0 )
2197:          oNodeVecDelete( dimensions )
      
2203:       | '^' :
2205:          Node theType
2205:          @TypeRef( theType )
2212:          resultType = @PointerTypeTo( theType )
      
2223:       | pRecord :
2225:          resultType = oNodeNew( nRecordType )
2235:          oScopeBegin( -1 )    % level is meaningless here
      
2241:          @VarDecl( nRecordField )
      
2248:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2260:          [ equal_zero( size )
2267:             | true : #eRecordEmpty
2270:             | * :
2275:          ]
      
2275:          pEnd
      
2277:          oNodeSet( resultType, qScope, oScopeCurrent )
2288:          oNodeSetInt( resultType, qSize, size )
2300:          oScopeEnd
2301:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2307:       | pSet :
2309:          pOf
2311:          Node theType
2311:          @TypeRef( theType )
2318:       | * :       % this works for cases except where expr starts with an id
2331:          @ConstExpr '..' @ConstExpr
2337:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2338: ConstExpr:
2340:    [
2340:       | pIntLit :
2342:          oValuePush( TOKEN_VALUE )
2347:       | pIdent :
2349:          Node decl = oScopeFindRequire
2354:          [ oNodeType( decl )
2361:             | nConst :
2362:                oValuePush( oNodeGetInt( decl, qValue ) )
2375:             | * :
2380:                #eNotConst
2382:                oValuePush( 0 )
2388:          ]
2388:       | pMinus :
2390:          @ConstExpr
2392:          oValueNegate
2393:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2404: Expr:
2406:    Label falseLabel = labelNull
      
2412:    @ExprAllowCF( falseLabel )
2419:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2427: BooleanExprControlFlow( out Label falseLabel ):
2429:    @ExprAllowCF( falseLabel )
2436:    [ oTypeSNodeType
2438:       | nBooleanCFType :
2439:       | nBooleanType :
               % convert value to control flow
2441:          falseLabel = oLabelNew
2446:          .tJumpFalse  oEmitLabel( falseLabel )
2454:       | * :
2461:          #eNotBoolean
2463:    ]
2463:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2465: CFToVal( inout Label falseLabel ):
2467:    [ oTypeSNodeType
2469:       | nBooleanCFType :
2470:          Label doneLabel = oLabelNew
2475:          .tPushConstI  oEmitInt( 1 )
2483:          .tJump  oEmitLabel( doneLabel )
2491:          .tLabel  oEmitLabel( falseLabel )
2499:          .tPushConstI  oEmitInt( 0 )
2507:          .tLabel  oEmitLabel( doneLabel )
2515:          oTypeSPop
2516:          oTypeSPush( BooleanType )
2522:          falseLabel = labelNull
2528:       | * :
2533:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2534: ValToCF( out Label falseLabel ):
2536:    [ oTypeSNodeType
2538:       | nBooleanType :
2539:          falseLabel = oLabelNew
2544:          .tJumpFalse  oEmitLabel( falseLabel )
2552:          oTypeSPop
2553:          oTypeSPush( BooleanCFType )
2559:       | * :
2564:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2565: ExprAllowCF( out Label falseLabel ):
2567:    @BoolExprAllowCF( falseLabel )
2574:    {[
2574:       | '=' :
2576:          @CFToVal( falseLabel )
2583:          @BoolExprAllowCF( falseLabel )
2590:          @CFToVal( falseLabel )
2597:          @MatchTypes
2599:          [ oTypeSNodeType
2601:             | nIntegerType, nBooleanType :  .tEqualI
2604:             | nPointerType :                .tEqualP
2608:             | nCharType, nStringType :      #eNotImplemented
2612:             | * :                           #eNotAllowed
2627:          ]
2627:          oTypeSPop
2628:          oTypeSPush( BooleanType )
      
2634:       | '<>' :
2636:          @CFToVal( falseLabel )
2643:          @BoolExprAllowCF( falseLabel )
2650:          @CFToVal( falseLabel )
2657:          @MatchTypes
2659:          [ oTypeSNodeType
2661:             | nIntegerType, nBooleanType :  .tNotEqualI
2664:             | nPointerType :                .tNotEqualP
2668:             | nCharType, nStringType :      #eNotImplemented
2672:             | * :                           #eNotAllowed
2687:          ]
2687:          oTypeSPop
2688:          oTypeSPush( BooleanType )
      
2694:       | '<' :
2696:          @CFToVal( falseLabel )
2703:          @BoolExprAllowCF( falseLabel )
2710:          @CFToVal( falseLabel )
2717:          @MatchTypes
2719:          [ oTypeSNodeType
2721:             | nIntegerType, nBooleanType :  .tLessI
2724:             | nCharType, nStringType :      #eNotImplemented
2728:             | * :                           #eNotAllowed
2741:          ]
2741:          oTypeSPop
2742:          oTypeSPush( BooleanType )
      
2748:       | '>' :
2750:          @CFToVal( falseLabel )
2757:          @BoolExprAllowCF( falseLabel )
2764:          @CFToVal( falseLabel )
2771:          @MatchTypes
2773:          [ oTypeSNodeType
2775:             | nIntegerType, nBooleanType :  .tGreaterI
2778:             | nCharType, nStringType :      #eNotImplemented
2782:             | * :                           #eNotAllowed
2795:          ]
2795:          oTypeSPop
2796:          oTypeSPush( BooleanType )
      
2802:       | '<=' :
2804:          @CFToVal( falseLabel )
2811:          @BoolExprAllowCF( falseLabel )
2818:          @CFToVal( falseLabel )
2825:          @MatchTypes
2827:          [ oTypeSNodeType
2829:             | nIntegerType, nBooleanType :  .tLessEqualI
2832:             | nCharType, nStringType :      #eNotImplemented
2836:             | * :                           #eNotAllowed
2849:          ]
2849:          oTypeSPop
2850:          oTypeSPush( BooleanType )
      
2856:       | '>=' :
2858:          @CFToVal( falseLabel )
2865:          @BoolExprAllowCF( falseLabel )
2872:          @CFToVal( falseLabel )
2879:          @MatchTypes
2881:          [ oTypeSNodeType
2883:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2886:             | nCharType, nStringType :      #eNotImplemented
2890:             | * :                           #eNotAllowed
2903:          ]
2903:          oTypeSPop
2904:          oTypeSPush( BooleanType )
      
2910:       | * :
2925:          >
2927:    ]};
      
      
2930: BoolExprAllowCF( out Label falseLabel ):
2932:    Label trueLabel = labelNull
      
2938:    @BoolTermAllowCF( falseLabel )
2945:    {[
2945:       | pOr :
2947:          [ oTypeSNodeType
2949:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2950:                [ equal_label( trueLabel, labelNull )
2960:                   | true :  trueLabel = oLabelNew
2966:                   | * :
2971:                ]
2971:                .tJump  oEmitLabel( trueLabel )
2979:             | nBooleanType :
2981:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2988:                [ equal_label( trueLabel, labelNull )
2998:                   | true :  trueLabel = oLabelNew
3004:                   | * :
3009:                ]
3009:                .tJump  oEmitLabel( trueLabel )
3017:             | * : #eNotBoolean
3026:          ]
3026:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
3027:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
3035:          falseLabel = labelNull
3041:          @BoolTermAllowCF( falseLabel )
      
3048:          [ oTypeSNodeType
3050:             | nBooleanCFType :
3051:             | nBooleanType :
3053:                @ValToCF( falseLabel )
3060:             | * : #eNotBoolean
3069:          ]
      
3069:          oTypeSPop
3070:          oTypeSPush( BooleanCFType )
      
3076:       | * :
3081:          >
3083:    ]}
      
         % any short-circuit trues jump here to the end
3085:    [ equal_label( trueLabel, labelNull )
3095:       | false :
3096:          .tLabel  oEmitLabel( trueLabel )
3104:       | * :
3109:    ]
3110:    ;
      
      
3110: BoolTermAllowCF( out Label falseLabel ):
3112:    Label overallFalseLabel = labelNull
      
3118:    @BoolFactorAllowCF( falseLabel )
3125:    {[
3125:       | pAnd :
3127:          [ oTypeSNodeType
3129:             | nBooleanCFType :
3130:             | nBooleanType :
3132:                @ValToCF( falseLabel )
3139:             | * :
3146:                #eNotBoolean
3148:          ]
3148:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3149:          [ equal_label( overallFalseLabel, labelNull )
3159:             | true :
3160:                overallFalseLabel = oLabelNew
3165:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3179:                falseLabel = overallFalseLabel
3185:             | * :
3190:          ]
      
3190:          Label factorFalseLabel = labelNull
3196:          @BoolFactorAllowCF( factorFalseLabel )
      
3203:          [ oTypeSNodeType
3205:             | nBooleanCFType :
3206:             | nBooleanType :
3208:                @ValToCF( factorFalseLabel )
3215:             | * : #eNotBoolean
3224:          ]
3224:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3238:       | * :
3243:          >
3245:    ]};
      
3248: BoolFactorAllowCF( out Label falseLabel ):
3250:    [
3250:       | pNot :
3252:          Label factorFalseLabel = labelNull
      
3258:          @BoolFactorAllowCF( factorFalseLabel )
3265:          [ oTypeSNodeType
3267:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3268:                falseLabel = oLabelNew
3273:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3281:                .tLabel  oEmitLabel( factorFalseLabel )
      
3289:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3291:                .tNot
      
3293:             | * : #eNotBoolean
3302:          ]
      
3302:       | * :
3307:          @ArithExprAllowCF( falseLabel )
3314:    ];
      
3315: ArithExprAllowCF( out Label falseLabel ):
3317:    @TermAllowCF( falseLabel )
3324:    {[
3324:       | pPlus :
3326:          @RequireIntPop
3328:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3335:          @RequireInt
3337:          .tAddI
3339:       | pMinus :
3341:          @RequireIntPop
3343:          @TermAllowCF( falseLabel )
3350:          @RequireInt
3352:          .tSubI
3354:       | * :
3361:          >
3363:    ]};
      
3366: TermAllowCF( out Label falseLabel ):
3368:    @FactorAllowCF( falseLabel )
3375:    {[
3375:       | pTimes :
3377:          @RequireIntPop
3379:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3386:          @RequireInt
3388:          .tMultI
3390:       | pDivide :
3392:          @RequireIntPop
3394:          @FactorAllowCF( falseLabel )
3401:          @RequireInt
3403:          .tDivI
3405:       | * :
3412:          >
3414:    ]};
      
3417: FactorAllowCF( out Label falseLabel ):
3419:    [
3419:       | pPlus :
3421:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3428:          @RequireInt
3430:       | pMinus :
3432:          @PrimaryAllowCF( falseLabel )
3439:          @RequireInt
3441:          .tNegI
3443:       | * :
3450:          @PrimaryAllowCF( falseLabel )
3457:    ];
      
3458: PrimaryAllowCF( out Label falseLabel ):
3460:    [
3460:       | pIntLit :
3462:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3469:          oTypeSPush( IntegerType )
      
3475:       | '(' :
3477:          @ExprAllowCF( falseLabel )
3484:          ')'
      
3486:       | pStrLit :
3488:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3497:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3505:          oTypeSPush( StringType )
      
3511:       | pIdent :
3513:          Node decl = oScopeFindRequire
3518:          Node theType
      
3518:          [ oNodeType( decl )
3525:             | nFunc :
      
3526:                @Call( decl )
      
3533:             | nConst :
3535:                theType = oNodeGet( decl, qType )
3548:                oTypeSPush( theType )
3554:                [ oTypeSNodeType
3556:                   | nIntegerType, nBooleanType :
3557:                      .tPushConstI @EmitValue( decl )
3566:                   | * :
3573:                      #eNotImplemented
3575:                ]
      
3575:             | nGlobalVar, nLocalVar, nParam :
3577:                @VarExpr( decl )
      
3584:             | * :
3597:                #eNotValue
3599:                oTypeSPush( IntegerType )
3605:          ]
      
3605:       | '@' :        % @var -- pointer to var
3607:          pIdent
      
3609:          Node decl = oScopeFindRequire
3614:          Node theType
      
3614:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3621:          theType = oTypeSTop
3626:          oTypeSPop
3627:          Node ptrType = @PointerTypeTo( theType )
3638:          oTypeSPush( ptrType )
      
3644:       | * :
3657:          #eNotValue
3659:          oTypeSPush( IntegerType )
3665:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3666: VarExpr( Node decl ):
3668:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
3681:    int uplevels = @DeclUpLevels( decl )
      
3692:    oTypeSPush( theType )
3698:    [ oTypeSNodeType
3700:       | nIntegerType :
3701:          [ oNodeType( decl )
3708:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
3718:             | nLocalVar :
3720:                [ equal_zero( uplevels )
3727:                   | true :  .tPushLocalI  @EmitValue( decl )
3737:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
3757:                ]
3757:             | nParam :
3759:                [ oNodeGetBoolean( decl, qInOut )
3769:                   | true :    % VAR param points to the var.  Auto dereference.
3770:                      [ equal_zero( uplevels )
3777:                         | true :  .tPushParamP  @EmitValue( decl )
3787:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3807:                      ]
3807:                      .tFetchI
3809:                   | * :
3814:                      [ equal_zero( uplevels )
3821:                         | true :  .tPushParamI  @EmitValue( decl )
3831:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
3851:                      ]
3851:                ]
3851:          ]
      
3861:       | nBooleanType :
3863:          [ oNodeType( decl )
3870:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
3880:             | nLocalVar :
3882:                [ equal_zero( uplevels )
3889:                   | true :  .tPushLocalB  @EmitValue( decl )
3899:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
3919:                ]
3919:             | nParam :
3921:                [ oNodeGetBoolean( decl, qInOut )
3931:                   | true :    % VAR param points to the var.  Auto dereference.
3932:                      [ equal_zero( uplevels )
3939:                         | true :  .tPushParamP  @EmitValue( decl )
3949:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3969:                      ]
3969:                      .tFetchB
3971:                   | * :
3976:                      [ equal_zero( uplevels )
3983:                         | true :  .tPushParamB  @EmitValue( decl )
3993:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
4013:                      ]
4013:                ]
4013:          ]
      
4023:       | nCharType, nStringType, nFileType :
4025:          #eNotImplemented
      
4027:       | nPointerType :
4029:          [ oNodeType( decl )
4036:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
4046:             | nLocalVar :
4048:                [ equal_zero( uplevels )
4055:                   | true :  .tPushLocalP  @EmitValue( decl )
4065:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4085:                ]
4085:             | nParam :
4087:                [ oNodeGetBoolean( decl, qInOut )
4097:                   | true :    % VAR param points to the var.  Auto dereference.
4098:                      [ equal_zero( uplevels )
4105:                         | true :  .tPushParamP  @EmitValue( decl )
4115:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4135:                      ]
4135:                      .tFetchP
4137:                   | * :
4142:                      [ equal_zero( uplevels )
4149:                         | true :  .tPushParamP  @EmitValue( decl )
4159:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4179:                      ]
4179:                ]
4179:          ]
4189:          [
4189:             | '^' :             % dereferenced
4191:                oTypeSPop
4192:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4205:                @LValueIndexes
4207:                @FetchVar
4209:             | * :               % just ptr value alone
4214:          ]
      
4214:       | * :
               % compound type
               % first, push addr of start of var
4229:          [ oNodeType( decl )
4236:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4246:             | nLocalVar :
4248:                [ equal_zero( uplevels )
4255:                   | true :  .tPushAddrLocal  @EmitValue( decl )
4265:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
4285:                ]
4285:             | nParam :
4287:                [ oNodeGetBoolean( decl, qInOut )
4297:                   | true :    % VAR param points to the var.  Auto dereference.
4298:                      [ equal_zero( uplevels )
4305:                         | true :  .tPushParamP  @EmitValue( decl )
4315:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4335:                      ]
4335:                   | * :
4340:                      [ equal_zero( uplevels )
4347:                         | true :  .tPushAddrParam  @EmitValue( decl )
4357:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
4377:                      ]
4377:                ]
4377:          ]
               % modify addr for subscripts, field references, etc
4387:          @LValueIndexes
               % get final value
4389:          @FetchVar
4391:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
4392: FetchVar:
4394:    [ oTypeSNodeType
4396:       | nIntegerType :   .tFetchI
4399:       | nBooleanType :   .tFetchB
4403:       | nCharType, nStringType, nFileType : #eNotImplemented
4407:       | nPointerType :   .tFetchP
4411:       | * :              % compound type; leave as addr
4426:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
4427: LValueIndexes:
4429:    {[
4429:       | '[' :       @ArraySubscripts
4433:       | '.' :       @RecordFieldRef
4437:       | '^' :       @PointerDeref
4441:       | * :         >
4452:    ]};
      
4455: ArraySubscripts:
4457:    [ oTypeSNodeType
4459:       | nArrayType :
4460:       | * :       #eNotArray
4467:    ]
4467:    {
4467:       [ oTypeSNodeType
4469:          | nArrayType :
4470:          | * :    #eTooManySubscripts
4477:       ]
      
            % low subscript of this dimension
4477:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
4494:       Node baseType
4494:       baseType = oNodeGet( oTypeSTop, qBaseType )
4506:       oTypeSPop
4507:       oTypeSPush( baseType )
      
4513:       @Expr
4515:       @RequireIntPop
            % adjust for low subscript
4517:       [ equal_zero( low )
4524:          | false :
4525:             .tPushConstI oEmitInt( low ) .tSubI
4535:          | * :
4540:       ]
      
            % multiply by element size
4540:       int size = oNodeGetInt( baseType, qSize )
4553:       [ equal( size, 1 )
4563:          | false :
4564:             .tPushConstI oEmitInt( size ) .tMultI
4574:          | * :
4579:       ]
      
            % update start address
4579:       .tAddPI
4581:       [
4581:          | ']' :  >
4585:          | ',' :
4587:       ]
4595:    };
      
      
4598: RecordFieldRef:
4600:    [ oTypeSNodeType
4602:       | nRecordType :
4603:       | * :    #eNotRecord
4610:    ]
4610:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4622:    pIdent
4624:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4629:    [ oNodeType( field )
4636:       | nRecordField :
4637:       | * :   #eNotRecordField
4644:    ]
4644:    oScopeEnd
4645:    int offset = oNodeGetInt( field, qValue )
4658:    [ equal_zero( offset )
4665:       | false :
4666:          .tPushConstI oEmitInt( offset ) .tAddPI
4676:       | * :
4681:    ]
      
         % replace the type on the type stack, with the field type
4681:    oTypeSPop
4682:    oTypeSPush( oNodeGet( field, qType ) )
4696:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4696: PointerDeref:
4698:    [ oTypeSNodeType
4700:       | nPointerType :
4701:       | * :       #eNotPointer
4708:    ]
4708:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4710:    Node theType = oTypeSTop
4715:    oTypeSPop
4716:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4730:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4730: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4732:    @MatchTypes
4735:    ;
      
      
      % Called on first use of an extern method
      %
4735: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4737:    int strAddr
4737:    String externalName = oNodeGetString( method, qExternalName )
4750:    [ equal_string( externalName, stringNull )
4760:       | true :
4761:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4782:       | false :
4784:          strAddr = oStringAllocLit( externalName )
4794:    ]
4802:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4818:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4818: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4820:    [ oNodeGetBoolean( method, qExternal )
4830:       | true :
4831:          [ oNodeGetBoolean( method, qCalled )
4841:             | false :
                     % define the extern label on first use
4842:                @DefineExternLabel( method )
4849:             | * :
4854:          ]
4854:      | * :
4859:    ]
4859:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4871:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4884:    Node resultType
4884:    int tempOffset
      
4884:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4901:    [ isFunc
4904:       | true :
4905:          resultType = oNodeGet( method, qType )
4918:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4928:       | * :
4933:    ]
         
      
4933:    Node paramScope = oNodeGet( method, qParams )
4946:    int actualsSize = oNodeGetInt( paramScope, qSize )
4959:    [ cdecl
4962:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4971:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4981:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
4989:    [ greater( @DeclLevel( method ), 0 )
5004:       | true :
5005:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
5013:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
5032:          .tAssignP
5034:       | * :
5039:    ]
      
      
5039:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
5052:    Node param = oNodeIterValue( paramIter )
5062:    [
5062:       | '(' :
            
5064:          {
5064:             [ oNodeNull( param )
5071:                | true : >
5074:                | * :
5079:             ]
      
5079:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
5092:             .tPushAddrActual oEmitInt( offset )
5100:             oTypeSPush( oNodeGet( param, qType ) )
      
5113:             [ oNodeGetBoolean( param, qInOut )
5123:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5124:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5126:                           @MatchTypes
      
5128:                           .tAssignP
      
5130:                | false :  @Expr
5134:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5136:                           [ oTypeSNodeType
5138:                              | nIntegerType :            .tAssignI
5141:                              | nBooleanType :            .tAssignB
5145:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5149:                              | nPointerType :            .tAssignP
5153:                              | * :
                                       % compound types: copy value into actuals space
5168:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5180:                                  .tCopy  oEmitInt( size )    % multi-word copy
5188:                           ]
5188:             ]
5196:             oTypeSPop
      
5197:             oNodeIterNext( paramIter )
5203:             param = oNodeIterValue( paramIter )
5213:             [ oNodeNull( param )
5220:                | true :  >
5223:                | false :
5225:             ]
      
5233:             ','
5235:          }
      
5237:          ')'
      
5239:       | * :
5244:    ]
      
5244:    [ oNodeNull( param )
5251:       | false :    #eMissingParameter
5254:       | * :
5259:    ]
      
5259:    [ isFunc
5262:       | true :
               % Pass result temp as an additional VAR parameter.
5263:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
5278:          .tPushAddrLocal  oEmitInt( tempOffset )
5286:          .tAssignP
5288:       | * :
5293:    ]
      
5293:    [ cdecl
5296:       | true :
5297:          .tCallCdecl  @EmitValue( method )
5306:       | false :
5308:          .tCall   @EmitValue( method )
5317:    ]
      
5325:    [ isFunc
5328:       | true :
               % push return value from temp
5329:          oTypeSPush( resultType )
      
5335:          [ oTypeSNodeType
5337:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
5346:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
5356:             | nCharType, nStringType, nFileType : #eNotImplemented
5360:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
5370:             | * :              % compound type: push address
5385:                                .tPushAddrLocal  oEmitInt( tempOffset )
5393:          ]
5393:       | * :
5398:    ]
         
5398:    .tFreeActuals  oEmitInt( actualsSize )
5407:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
5407: Statement:
5409:    [
5409:       | pWriteln :     @WritelnStmt
5413:       | pWrite :       @WriteStmt
5417:       | pReadln :      @ReadlnStmt
5421:       | pRead :        @ReadStmt
5425:       | pIf :          @IfStmt
5429:       | pWhile :       @WhileStmt
5433:       | pFor :         @ForStmt
5437:       | pRepeat :      @RepeatStmt
5441:       | pBreak :       @BreakStmt
5445:       | pContinue :    @ContinueStmt
5449:       | pBegin :       @BeginStmt
5453:       | pIdent :       @AssignOrCallStmt
5457:       | * :            % null statement : don't accept any tokens
5484:    ];
      
      
5485: AssignOrCallStmt:
5487:    Node decl = oScopeFindRequire
5492:    [ oNodeType( decl )
5499:       | nProc :                           @Call( decl )
5507:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
5516:       | nFunc :                           @AssignResultStmt( decl )
5525:       | * :                               #eBadStatement
5540:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
5541: AssignStmt( Node decl ):
      
5543:    @LValueVar( decl )
5550:    ':=' 
5552:    @Expr
5554:    @MatchTypes
5556:    @Assign
5559:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
5559: Assign:
5561:    [ oTypeSNodeType
5563:       | nIntegerType :            .tAssignI
5566:       | nBooleanType :            .tAssignB
5570:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5574:       | nPointerType :            .tAssignP
5578:       | * :
5593:           int size = oNodeGetInt( oTypeSTop, qSize )
5605:           .tCopy  oEmitInt( size )    % multi-word copy
5613:    ]
5613:    oTypeSPop
5615:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5615: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5617:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5633:       | false :   #eNotCurrentFunction
5636:       | * :
5641:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5641:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5656:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5669:    ':='
5671:    @Expr
5673:    @MatchTypes
5675:    [ oTypeSNodeType
5677:       | nIntegerType :            .tAssignI
5680:       | nBooleanType :            .tAssignB
5684:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5688:       | nPointerType :            .tAssignP
5692:       | * :
5707:           int size = oNodeGetInt( oTypeSTop, qSize )
5719:           .tCopy  oEmitInt( size )    % multi-word copy
5727:    ]
5727:    oTypeSPop
5729:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5729: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5731:    pIdent
5733:    Node decl = oScopeFindRequire
5738:    [ oNodeType( decl )
5745:       | nGlobalVar, nLocalVar, nParam :
5746:       | * :  #eNotVar
5757:    ]
5757:    @LValueVar( decl )
5765:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5765: LValueVar( Node decl ):
5767:    [ oNodeType( decl )
5774:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5784:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5795:       | nParam :
5797:          [ oNodeGetBoolean( decl, qInOut )
5807:             | true :   % VAR param points to variable.  No dereference.
5808:                        .tPushParamP @EmitValue( decl )
5817:             | * :      .tPushAddrParam @EmitValue( decl )
5831:          ]
5831:       | * :            #eNotVar
5842:    ]
      
5842:    oTypeSPush( oNodeGet( decl, qType ) )
5855:    @LValueIndexes        % handle subscripts, if any
5858:    ;
      
      
5858: IncVar( Node decl ):
5860:    @LValueVar( decl )
5867:    @RequireIntPop
5869:    @VarExpr( decl )
5876:    oTypeSPop
5877:    .tIncI
5879:    .tAssignI;
      
5882: DecVar( Node decl ):
5884:    @LValueVar( decl )
5891:    @RequireIntPop
5893:    @VarExpr( decl )
5900:    oTypeSPop
5901:    .tDecI
5903:    .tAssignI;
      
      
5906: IfStmt:
5908:    Label falseLabel = labelNull
      
5914:    @BooleanExprControlFlow( falseLabel )
5921:    pThen
5923:    @Statement
5925:    [
5925:       | pElse :
5927:          Label doneLabel = oLabelNew
      
5932:          .tJump  oEmitLabel( doneLabel )
5940:          .tLabel oEmitLabel( falseLabel )
5948:          @Statement
5950:          .tLabel oEmitLabel( doneLabel )
      
5958:       | * :
5963:          .tLabel oEmitLabel( falseLabel )
5971:    ];
      
      
5972: ForStmt:
5974:    pIdent
      
5976:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5981:    @LValueVar( decl )
5988:    @RequireIntPop
      
5990:    ':='
      
5992:    @Expr
5994:    @RequireIntPop
5996:    .tAssignI
      
5998:    Label breakLabel = oLabelNew
      
6003:    Label checkLabel = oLabelNew
6008:    .tJump  oEmitLabel( checkLabel )
      
6016:    Label continueLabel = oLabelNew
6021:    .tLabel  oEmitLabel( continueLabel )
6029:    [
6029:       | pTo :
6031:          @IncVar( decl )
6038:          .tLabel  oEmitLabel( checkLabel )
6046:          @VarExpr( decl )  oTypeSPop
6054:          @Expr
6056:          @RequireIntPop
6058:          .tGreaterI
6060:          .tJumpTrue  oEmitLabel( breakLabel )
6068:       | pDownto :
6070:          @DecVar( decl )
6077:          .tLabel  oEmitLabel( checkLabel )
6085:          @VarExpr( decl )  oTypeSPop
6093:          @Expr
6095:          @RequireIntPop
6097:          .tLessI
6099:          .tJumpTrue  oEmitLabel( breakLabel )
6107:    ]
6115:    oLoopPush( continueLabel, breakLabel )
6124:    pDo
6126:    @Statement
6128:    .tJump  oEmitLabel( continueLabel )
6136:    .tLabel  oEmitLabel( breakLabel )
6144:    oLoopPop;
      
      
6146: RepeatStmt:
6148:    Label continueLabel = oLabelNew
6153:    .tLabel  oEmitLabel( continueLabel )
      
6161:    Label breakLabel = oLabelNew
      
6166:    oLoopPush( continueLabel, breakLabel )
6175:    @Statement
6177:    {[
6177:       | ';' :
6179:          @Statement
6181:       | pUntil :
6183:          Label falseLabel
6183:          @BooleanExprControlFlow( falseLabel )
6190:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6204:          >
6206:    ]}
6216:    .tLabel  oEmitLabel( breakLabel )
6224:    oLoopPop;
      
      
6226: WhileStmt:
6228:    Label continueLabel = oLabelNew
6233:    .tLabel  oEmitLabel( continueLabel )
      
6241:    Label breakLabel
6241:    @BooleanExprControlFlow( breakLabel )
      
6248:    oLoopPush( continueLabel, breakLabel )
6257:    pDo
6259:    @Statement
6261:    .tJump  oEmitLabel( continueLabel )
6269:    .tLabel  oEmitLabel( breakLabel )
6277:    oLoopPop;
      
      
6279: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
6281:    [ equal_label( oLoopContinueLabel, labelNull )
6290:       | true :
6291:          #eNotInALoop
6293:       | false :
6295:          .tJump  oEmitLabel( oLoopContinueLabel )
6302:    ];
      
      
6311: BreakStmt:
6313:    [ equal_label( oLoopBreakLabel, labelNull )
6322:       | true :
6323:          #eNotInALoop
6325:       | false :
6327:          .tJump  oEmitLabel( oLoopBreakLabel )
6334:    ];
      
      
6343: BeginStmt:
6345:    @Statement
6347:    {[
6347:       | ';' :   @Statement
6351:       | pEnd :  >
6355:    ]};
      
      
6366: WritelnStmt:
6368:    @WriteStmt
6370:    .tWriteCR;
      
      
6373: WriteStmt:
6375:    [
6375:       | '(' :
6377:          {
6377:             @Expr
6379:             [ oTypeSNodeType
6381:                | nIntegerType :             .tWriteI
6384:                | nBooleanType :             .tWriteBool
6388:                | nStringType :              .tWriteStr
6392:                | nCharType, nFileType :     #eNotImplemented
6396:                | nPointerType :             .tWriteP
6400:                | * :                        #eNotAllowed
6417:             ]
6417:             oTypeSPop
6418:             [
6418:                | ')' : >
6422:                | ',' :
6424:             ]
6432:          }
6434:       | * :
6439:    ];
      
      
6440: ReadlnStmt:      % ***
         % TO DO
6443:    ;
      
6443: ReadStmt:
         % TO DO
6446:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Return the static scope level of the given declaration
      %
6446: DeclLevel( Node decl ) >> int:
6448:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
6466: DeclUpLevels( Node decl ) >> int:
6468:    >> subtract( oNodeGetInt( oScopeCurrent, qLevel ), @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
6490: MatchTypes:
6492:    node_type nt = oTypeSNodeType
6497:    oTypeSPop
6498:    [ equal_node_type( nt, oTypeSNodeType )
6507:       | false :
6508:          #eTypeMismatch
6510:       | * :
6515:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
6516: RequireIntPop:
6518:    [ oTypeSNodeType
6520:       | nIntegerType :
6521:       | * :          #eNotInteger
6528:    ]
6528:    oTypeSPop;
      
6530: RequireInt:
6532:    [ oTypeSNodeType
6534:       | nIntegerType :
6535:       | * :          #eNotInteger
6542:    ];
      
6543: RequireBoolPop:
6545:    [ oTypeSNodeType
6547:       | nBooleanType :
6548:       | * :          #eNotBoolean
6555:    ]
6555:    oTypeSPop;
      
6557: RequireBool:
6559:    [ oTypeSNodeType
6561:       | nBooleanType :
6562:       | * :          #eNotBoolean
6569:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
6570: newType( node_type nt, int size ) >> Node:
6572:   Node node = oNodeNew( nt )
6582:   oNodeSetInt( node, qSize, size )
6594:   oTypeAdd( node )
6600:   >> node
6604:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
6604: newIdent( node_type nt, kind k, int id ) >> Node:
6606:   Node t = oNodeNew( nt )
6616:   oNodeSetInt( t, qIdent, id )
6628:   >> t
6632:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6632: PointerTypeTo( Node theType ) >> Node:
6634:    Node ptrType = oNodeGet( theType, qPointerType )
6647:    [ oNodeNull( ptrType )
6654:       | true :
6655:          ptrType = oNodeNew( nPointerType )
6665:          oNodeSet( ptrType, qBaseType, theType )
6677:          oNodeSetInt( ptrType, qSize, 8 )
6689:          oTypeAdd( ptrType )
6695:          oNodeSet( theType, qPointerType, ptrType )
6707:       | * :
6712:    ]
6712:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6716: OrdinalLow( Node theType ) >> int:
6718:    [ oNodeType( theType )
6725:       | nIntegerType :  >> oMININT
6728:       | nBooleanType :  >> 0
6733:       | nCharType :     >> 0
6738:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6750:       | * :             #eNotOrdinalType
6763:                         >> 0
6766:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6767: EmitValue( Node decl ):
6769:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6783: installBuiltIns:
      
         % install built-in types
6785:    FileType = @newType( nFileType, 4 )
6799:    IntegerType = @newType( nIntegerType, 4 )
6813:    BooleanType = @newType( nBooleanType, 1 )
6827:    BooleanCFType = @newType( nBooleanCFType, 1 )
6841:    CharType = @newType( nCharType, 1 )
6855:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6869:    Node t
      
6869:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6885:    oNodeSet( t, qType, FileType )
6897:    oScopeDeclare( t )
      
6903:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6919:    oNodeSet( t, qType, IntegerType )
6931:    oScopeDeclare( t )
      
6937:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6953:    oNodeSet( t, qType, BooleanType )
6965:    oScopeDeclare( t )
      
6971:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6987:    oNodeSet( t, qType, CharType )
6999:    oScopeDeclare( t )
      
7005:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
7021:    oNodeSet( t, qType, StringType )
7033:    oScopeDeclare( t )
      
         % Built-in constants
      
7039:    t = @newIdent( nConst, kConst, oIdAdd_True )
7055:    oNodeSet( t, qType, BooleanType )
7067:    oNodeSetInt( t, qValue, 1 )
7079:    oScopeDeclare( t )
      
7085:    t = @newIdent( nConst, kConst, oIdAdd_False )
7101:    oNodeSet( t, qType, BooleanType )
7113:    oNodeSetInt( t, qValue, 0 )
7125:    oScopeDeclare( t )
      
7132:    ;
      
7132: end
      
7132: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 3
   4: oSetResult 0
   6: oPushResult
   7: oScopeBegin
   8: oPop 1
  10: oGetAddrGlobal 1
  12: oPushResult
  13: oScopeCurrent
  14: oAssign
  15: oCall 6783
  17: oEmit 52
  19: oSetResult 0
  21: oPushResult
  22: oEmitInt
  23: oPop 1
  25: oGetAddrLocal 2
  27: oPushResult
  28: oLabelNew
  29: oAssign
  30: oEmit 46
  32: oSetResult 0
  34: oPushResult
  35: oEmitInt
  36: oPop 1
  38: oEmit 49
  40: oGetLocal 2
  42: oPushResult
  43: oEmitLabel
  44: oPop 1
  46: oEmit 48
  48: oSetResult 0
  50: oPushResult
  51: oEmitInt
  52: oPop 1
  54: oEmit 51
  56: oInput 27
  58: oInput 0
  60: oGetAddrLocal 3
  62: oPushResult
  63: oSetResult 5
  65: oPushResult
  66: oSetResult 1
  68: oPushResult
  69: LAST_ID
  70: oPushResult
  71: oCall 6604
  73: oPop 3
  75: oAssign
  76: oGetLocal 3
  78: oPushResult
  79: oScopeDeclare
  80: oPop 1
  82: oInputChoice 162
  84: oInput 0
  86: oGetAddrLocal 1
  88: oPushResult
  89: oSetResult 11
  91: oPushResult
  92: oSetResult 6
  94: oPushResult
  95: LAST_ID
  96: oPushResult
  97: oCall 6604
  99: oPop 3
 101: oAssign
 102: oGetLocal 1
 104: oPushResult
 105: oSetResult 8
 107: oPushResult
 108: oGetGlobal 3
 110: oPushResult
 111: oNodeSet
 112: oPop 3
 114: oGetLocal 1
 116: oPushResult
 117: oScopeDeclareAlloc
 118: oPop 1
 120: oInput 12
 122: oInput 0
 124: oGetAddrLocal 1
 126: oPushResult
 127: oSetResult 11
 129: oPushResult
 130: oSetResult 6
 132: oPushResult
 133: LAST_ID
 134: oPushResult
 135: oCall 6604
 137: oPop 3
 139: oAssign
 140: oGetLocal 1
 142: oPushResult
 143: oSetResult 8
 145: oPushResult
 146: oGetGlobal 3
 148: oPushResult
 149: oNodeSet
 150: oPop 3
 152: oGetLocal 1
 154: oPushResult
 155: oScopeDeclareAlloc
 156: oPop 1
 158: oInput 14
 160: oJumpForward 165
 162: Choice Lookup Table
          13     84
 165: oInput 4
 167: oSetResult 0
 169: oPushResult
 170: oScopeBegin
 171: oPop 1
 173: oGetAddrGlobal 2
 175: oPushResult
 176: oScopeCurrent
 177: oAssign
 178: oScopeCurrent
 179: oPushResult
 180: oSetResult 4
 182: oPushResult
 183: oSetResult 1
 185: oPushResult
 186: oNodeSetBoolean
 187: oPop 3
 189: oGetLocal 3
 191: oPushResult
 192: oSetResult 10
 194: oPushResult
 195: oScopeCurrent
 196: oPushResult
 197: oNodeSet
 198: oPop 3
 200: oScopeEnd
 201: oSetResult 12
 203: oPushResult
 204: oCall 248
 206: oPop 1
 208: oGetGlobal 2
 210: oPushResult
 211: oScopeEnter
 212: oPop 1
 214: oGetLocal 2
 216: oPushResult
 217: oGetGlobal 1
 219: oPushResult
 220: oCall 298
 222: oPop 2
 224: oScopeEnd
 225: oInput 19
 227: oScopeEnd
 228: oReturn
 229: oLocalSpace 0
 231: oGetParam 2
 233: oPushResult
 234: oCall 248
 236: oPop 1
 238: oGetParam 1
 240: oPushResult
 241: oScopeCurrent
 242: oPushResult
 243: oCall 298
 245: oPop 2
 247: oReturn
 248: oLocalSpace 0
 250: oInputChoice 277
 252: oCall 1501
 254: oJumpForward 290
 256: oCall 1573
 258: oJumpForward 290
 260: oGetParam 1
 262: oPushResult
 263: oCall 1632
 265: oPop 1
 267: oJumpForward 290
 269: oCall 513
 271: oJumpForward 290
 273: oCall 863
 275: oJumpForward 290
 277: Choice Lookup Table
          29    273
          28    269
          32    260
          31    256
          30    252
 288: oJumpForward 292
 290: oJumpBack 250
 292: oCall 295
 294: oReturn
 295: oLocalSpace 0
 297: oReturn
 298: oLocalSpace 3
 300: oEmit 56
 302: oGetParam 2
 304: oPushResult
 305: oEmitLabel
 306: oPop 1
 308: oEmit 52
 310: oGetAddrLocal 1
 312: oPushResult
 313: Here
 314: oAssign
 315: oEmit 64
 317: oGetAddrLocal 2
 319: oPushResult
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 5
 325: oPushResult
 326: oNodeGetCode
 327: oPop 2
 329: oAssign
 330: oGetLocal 2
 332: oPushResult
 333: oEmitCode
 334: oPop 1
 336: oScopeCurrent
 337: oPushResult
 338: oSetResult 5
 340: oPushResult
 341: oSetResult 0
 343: oPushResult
 344: oNodeSetCode
 345: oPop 3
 347: oCall 5407
 349: oEmit 51
 351: oGetAddrLocal 3
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oSetResult 3
 358: oPushResult
 359: oNodeGetInt
 360: oPop 2
 362: oAssign
 363: oGetLocal 1
 365: oPushResult
 366: oGetLocal 3
 368: oPushResult
 369: oPatch
 370: oPop 2
 372: oReturn
 373: oLocalSpace 0
 375: oInputChoice 393
 377: oGetParam 1
 379: oPushResult
 380: oSetResult 16
 382: oPushResult
 383: oSetResult 1
 385: oPushResult
 386: oNodeSetBoolean
 387: oPop 3
 389: oInput 4
 391: oJumpForward 398
 393: Choice Lookup Table
          61    377
 396: oJumpForward 400
 398: oJumpBack 375
 400: oReturn
 401: oLocalSpace 1
 403: oGetAddrLocal 1
 405: oPushResult
 406: oScopeCurrent
 407: oPushResult
 408: oSetResult 5
 410: oPushResult
 411: oNodeGetCode
 412: oPop 2
 414: oAssign
 415: oGetLocal 1
 417: oPushResult
 418: oSetResult 0
 420: oPushResult
 421: equal_code
 422: oPop 2
 424: oChoice 444
 426: oGetAddrLocal 1
 428: oPushResult
 429: oCodeNew
 430: oAssign
 431: oScopeCurrent
 432: oPushResult
 433: oSetResult 5
 435: oPushResult
 436: oGetLocal 1
 438: oPushResult
 439: oNodeSetCode
 440: oPop 3
 442: oJumpForward 447
 444: Choice Lookup Table
           1    426
 447: oGetLocal 1
 449: oReturn
 450: oReturn
 451: oLocalSpace 0
 453: oGetParam 1
 455: oPushResult
 456: oCall 6446
 458: oPop 1
 460: oPushResult
 461: equal_zero
 462: oPop 1
 464: oChoice 470
 466: oError 23
 468: oJumpForward 473
 470: Choice Lookup Table
           0    466
 473: oGetParam 1
 475: oPushResult
 476: oSetResult 14
 478: oPushResult
 479: oSetResult 1
 481: oPushResult
 482: oNodeSetBoolean
 483: oPop 3
 485: oInputChoice 509
 487: oInputChoice 504
 489: oInput 2
 491: oGetParam 1
 493: oPushResult
 494: oSetResult 15
 496: oPushResult
 497: CURRENT_STRLIT
 498: oPushResult
 499: oNodeSetString
 500: oPop 3
 502: oJumpForward 507
 504: Choice Lookup Table
          60    489
 507: oJumpForward 512
 509: Choice Lookup Table
           2    487
 512: oReturn
 513: oLocalSpace 7
 515: oInput 0
 517: oGetAddrLocal 1
 519: oPushResult
 520: oSetResult 0
 522: oAssign
 523: oGetAddrLocal 2
 525: oPushResult
 526: oScopeFindInCurrentScope
 527: oAssign
 528: oGetLocal 2
 530: oPushResult
 531: oNodeNull
 532: oPop 1
 534: oChoice 655
 536: oGetAddrLocal 2
 538: oPushResult
 539: oSetResult 7
 541: oPushResult
 542: oSetResult 2
 544: oPushResult
 545: LAST_ID
 546: oPushResult
 547: oCall 6604
 549: oPop 3
 551: oAssign
 552: oGetLocal 2
 554: oPushResult
 555: oSetResult 9
 557: oPushResult
 558: oLabelNew
 559: oPushResult
 560: oNodeSetLabel
 561: oPop 3
 563: oJumpForward 661
 565: oGetAddrLocal 1
 567: oPushResult
 568: oSetResult 1
 570: oAssign
 571: oGetLocal 2
 573: oPushResult
 574: oSetResult 13
 576: oPushResult
 577: oNodeGetBoolean
 578: oPop 2
 580: oChoice 586
 582: oError 21
 584: oJumpForward 589
 586: Choice Lookup Table
           1    582
 589: oGetLocal 2
 591: oPushResult
 592: oSetResult 14
 594: oPushResult
 595: oNodeGetBoolean
 596: oPop 2
 598: oChoice 604
 600: oError 21
 602: oJumpForward 607
 604: Choice Lookup Table
           1    600
 607: oGetLocal 2
 609: oPushResult
 610: oNodeType
 611: oPop 1
 613: oChoice 617
 615: oJumpForward 622
 617: Choice Lookup Table
           7    615
 620: oError 21
 622: oGetLocal 2
 624: oPushResult
 625: oSetResult 18
 627: oPushResult
 628: oGetLocal 2
 630: oPushResult
 631: oSetResult 11
 633: oPushResult
 634: oNodeGet
 635: oPop 2
 637: oPushResult
 638: oNodeSet
 639: oPop 3
 641: oGetLocal 2
 643: oPushResult
 644: oSetResult 11
 646: oPushResult
 647: oSetResult 0
 649: oPushResult
 650: oNodeSet
 651: oPop 3
 653: oJumpForward 661
 655: Choice Lookup Table
           0    565
           1    536
 660: oEndChoice
 661: oGetAddrLocal 3
 663: oPushResult
 664: oScopeCurrent
 665: oPushResult
 666: oSetResult 1
 668: oPushResult
 669: oNodeGetInt
 670: oPop 2
 672: oAssign
 673: oGetAddrLocal 4
 675: oPushResult
 676: oGetLocal 3
 678: oPushResult
 679: oSetResult 0
 681: oPushResult
 682: greater
 683: oPop 2
 685: oAssign
 686: oGetAddrLocal 3
 688: oPushResult
 689: inc
 690: oPop 1
 692: oGetLocal 3
 694: oPushResult
 695: oScopeBegin
 696: oPop 1
 698: oGetAddrLocal 5
 700: oPushResult
 701: oScopeCurrent
 702: oAssign
 703: oGetLocal 4
 705: oChoice 724
 707: oGetAddrLocal 6
 709: oPushResult
 710: oGetGlobal 4
 712: oPushResult
 713: oCall 6632
 715: oPop 1
 717: oPushResult
 718: oScopeAllocType
 719: oPop 1
 721: oAssign
 722: oJumpForward 727
 724: Choice Lookup Table
           1    707
 727: oCall 1274
 729: oGetLocal 2
 731: oPushResult
 732: oSetResult 11
 734: oPushResult
 735: oGetLocal 5
 737: oPushResult
 738: oNodeSet
 739: oPop 3
 741: oScopeEnd
 742: oInput 4
 744: oGetLocal 1
 746: oChoice 758
 748: oGetLocal 2
 750: oPushResult
 751: oScopeDeclare
 752: oPop 1
 754: oJumpForward 764
 756: oJumpForward 764
 758: Choice Lookup Table
           1    756
           0    748
 763: oEndChoice
 764: oGetLocal 2
 766: oPushResult
 767: oCall 373
 769: oPop 1
 771: oInputChoice 784
 773: oJumpForward 860
 775: oGetLocal 2
 777: oPushResult
 778: oCall 451
 780: oPop 1
 782: oJumpForward 860
 784: Choice Lookup Table
          59    775
          58    773
 789: oGetLocal 5
 791: oPushResult
 792: oScopeEnter
 793: oPop 1
 795: oGetLocal 3
 797: oPushResult
 798: oScopeBegin
 799: oPop 1
 801: oScopeCurrent
 802: oPushResult
 803: oSetResult 4
 805: oPushResult
 806: oSetResult 1
 808: oPushResult
 809: oNodeSetBoolean
 810: oPop 3
 812: oGetLocal 2
 814: oPushResult
 815: oSetResult 12
 817: oPushResult
 818: oScopeCurrent
 819: oPushResult
 820: oNodeSet
 821: oPop 3
 823: oGetAddrLocal 7
 825: oPushResult
 826: oGetLocal 2
 828: oPushResult
 829: oSetResult 9
 831: oPushResult
 832: oNodeGetLabel
 833: oPop 2
 835: oAssign
 836: oSetResult 13
 838: oPushResult
 839: oGetLocal 7
 841: oPushResult
 842: oCall 229
 844: oPop 2
 846: oGetLocal 2
 848: oPushResult
 849: oSetResult 13
 851: oPushResult
 852: oSetResult 1
 854: oPushResult
 855: oNodeSetBoolean
 856: oPop 3
 858: oScopeEnd
 859: oScopeEnd
 860: oInput 4
 862: oReturn
 863: oLocalSpace 9
 865: oInput 0
 867: oGetAddrLocal 1
 869: oPushResult
 870: oSetResult 0
 872: oAssign
 873: oGetAddrLocal 2
 875: oPushResult
 876: oScopeFindInCurrentScope
 877: oAssign
 878: oGetLocal 2
 880: oPushResult
 881: oNodeNull
 882: oPop 1
 884: oChoice 1018
 886: oGetAddrLocal 2
 888: oPushResult
 889: oSetResult 8
 891: oPushResult
 892: oSetResult 3
 894: oPushResult
 895: LAST_ID
 896: oPushResult
 897: oCall 6604
 899: oPop 3
 901: oAssign
 902: oGetLocal 2
 904: oPushResult
 905: oSetResult 9
 907: oPushResult
 908: oLabelNew
 909: oPushResult
 910: oNodeSetLabel
 911: oPop 3
 913: oJumpForward 1024
 915: oGetAddrLocal 1
 917: oPushResult
 918: oSetResult 1
 920: oAssign
 921: oGetLocal 2
 923: oPushResult
 924: oSetResult 13
 926: oPushResult
 927: oNodeGetBoolean
 928: oPop 2
 930: oChoice 936
 932: oError 21
 934: oJumpForward 939
 936: Choice Lookup Table
           1    932
 939: oGetLocal 2
 941: oPushResult
 942: oNodeType
 943: oPop 1
 945: oChoice 949
 947: oJumpForward 954
 949: Choice Lookup Table
           8    947
 952: oError 21
 954: oGetLocal 2
 956: oPushResult
 957: oSetResult 18
 959: oPushResult
 960: oGetLocal 2
 962: oPushResult
 963: oSetResult 11
 965: oPushResult
 966: oNodeGet
 967: oPop 2
 969: oPushResult
 970: oNodeSet
 971: oPop 3
 973: oGetLocal 2
 975: oPushResult
 976: oSetResult 11
 978: oPushResult
 979: oSetResult 0
 981: oPushResult
 982: oNodeSet
 983: oPop 3
 985: oGetLocal 2
 987: oPushResult
 988: oSetResult 19
 990: oPushResult
 991: oGetLocal 2
 993: oPushResult
 994: oSetResult 8
 996: oPushResult
 997: oNodeGet
 998: oPop 2
1000: oPushResult
1001: oNodeSet
1002: oPop 3
1004: oGetLocal 2
1006: oPushResult
1007: oSetResult 8
1009: oPushResult
1010: oSetResult 0
1012: oPushResult
1013: oNodeSet
1014: oPop 3
1016: oJumpForward 1024
1018: Choice Lookup Table
           0    915
           1    886
1023: oEndChoice
1024: oGetAddrLocal 3
1026: oPushResult
1027: oScopeCurrent
1028: oPushResult
1029: oSetResult 1
1031: oPushResult
1032: oNodeGetInt
1033: oPop 2
1035: oAssign
1036: oGetAddrLocal 4
1038: oPushResult
1039: oGetLocal 3
1041: oPushResult
1042: oSetResult 0
1044: oPushResult
1045: greater
1046: oPop 2
1048: oAssign
1049: oGetAddrLocal 3
1051: oPushResult
1052: inc
1053: oPop 1
1055: oGetLocal 3
1057: oPushResult
1058: oScopeBegin
1059: oPop 1
1061: oGetAddrLocal 5
1063: oPushResult
1064: oScopeCurrent
1065: oAssign
1066: oGetLocal 4
1068: oChoice 1087
1070: oGetAddrLocal 6
1072: oPushResult
1073: oGetGlobal 4
1075: oPushResult
1076: oCall 6632
1078: oPop 1
1080: oPushResult
1081: oScopeAllocType
1082: oPop 1
1084: oAssign
1085: oJumpForward 1090
1087: Choice Lookup Table
           1   1070
1090: oCall 1274
1092: oGetLocal 2
1094: oPushResult
1095: oSetResult 11
1097: oPushResult
1098: oGetLocal 5
1100: oPushResult
1101: oNodeSet
1102: oPop 3
1104: oInput 11
1106: oGetAddrLocal 7
1108: oPushResult
1109: oCall 1864
1111: oPop 1
1113: oGetLocal 2
1115: oPushResult
1116: oSetResult 8
1118: oPushResult
1119: oGetLocal 7
1121: oPushResult
1122: oNodeSet
1123: oPop 3
1125: oGetAddrLocal 8
1127: oPushResult
1128: oGetLocal 7
1130: oPushResult
1131: oCall 6632
1133: oPop 1
1135: oAssign
1136: oGetLocal 2
1138: oPushResult
1139: oSetResult 20
1141: oPushResult
1142: oGetLocal 8
1144: oPushResult
1145: oScopeAllocType
1146: oPop 1
1148: oPushResult
1149: oNodeSetInt
1150: oPop 3
1152: oScopeEnd
1153: oInput 4
1155: oGetLocal 1
1157: oChoice 1169
1159: oGetLocal 2
1161: oPushResult
1162: oScopeDeclare
1163: oPop 1
1165: oJumpForward 1175
1167: oJumpForward 1175
1169: Choice Lookup Table
           1   1167
           0   1159
1174: oEndChoice
1175: oGetLocal 2
1177: oPushResult
1178: oCall 373
1180: oPop 1
1182: oInputChoice 1195
1184: oJumpForward 1271
1186: oGetLocal 2
1188: oPushResult
1189: oCall 451
1191: oPop 1
1193: oJumpForward 1271
1195: Choice Lookup Table
          59   1186
          58   1184
1200: oGetLocal 5
1202: oPushResult
1203: oScopeEnter
1204: oPop 1
1206: oGetLocal 3
1208: oPushResult
1209: oScopeBegin
1210: oPop 1
1212: oScopeCurrent
1213: oPushResult
1214: oSetResult 4
1216: oPushResult
1217: oSetResult 1
1219: oPushResult
1220: oNodeSetBoolean
1221: oPop 3
1223: oGetLocal 2
1225: oPushResult
1226: oSetResult 12
1228: oPushResult
1229: oScopeCurrent
1230: oPushResult
1231: oNodeSet
1232: oPop 3
1234: oGetAddrLocal 9
1236: oPushResult
1237: oGetLocal 2
1239: oPushResult
1240: oSetResult 9
1242: oPushResult
1243: oNodeGetLabel
1244: oPop 2
1246: oAssign
1247: oSetResult 13
1249: oPushResult
1250: oGetLocal 9
1252: oPushResult
1253: oCall 229
1255: oPop 2
1257: oGetLocal 2
1259: oPushResult
1260: oSetResult 13
1262: oPushResult
1263: oSetResult 1
1265: oPushResult
1266: oNodeSetBoolean
1267: oPop 3
1269: oScopeEnd
1270: oScopeEnd
1271: oInput 4
1273: oReturn
1274: oLocalSpace 6
1276: oInputChoice 1497
1278: oGetAddrLocal 1
1280: oPushResult
1281: oNodeVecNew
1282: oAssign
1283: oGetAddrLocal 3
1285: oPushResult
1286: oSetResult 0
1288: oAssign
1289: oInputChoice 1299
1291: oGetAddrLocal 3
1293: oPushResult
1294: oSetResult 1
1296: oAssign
1297: oJumpForward 1302
1299: Choice Lookup Table
          32   1291
1302: oInput 0
1304: oGetAddrLocal 2
1306: oPushResult
1307: oSetResult 15
1309: oPushResult
1310: oSetResult 6
1312: oPushResult
1313: LAST_ID
1314: oPushResult
1315: oCall 6604
1317: oPop 3
1319: oAssign
1320: oGetLocal 2
1322: oPushResult
1323: oSetResult 21
1325: oPushResult
1326: oGetLocal 3
1328: oPushResult
1329: oNodeSetBoolean
1330: oPop 3
1332: oGetLocal 1
1334: oPushResult
1335: oGetLocal 2
1337: oPushResult
1338: oNodeVecAppend
1339: oPop 2
1341: oInputChoice 1349
1343: oJumpForward 1357
1345: oJumpForward 1355
1347: oJumpForward 1355
1349: Choice Lookup Table
          12   1347
          11   1343
1354: oEndChoice
1355: oJumpBack 1302
1357: oGetAddrLocal 4
1359: oPushResult
1360: oCall 1864
1362: oPop 1
1364: oGetLocal 3
1366: oChoice 1381
1368: oGetAddrLocal 5
1370: oPushResult
1371: oGetLocal 4
1373: oPushResult
1374: oCall 6632
1376: oPop 1
1378: oAssign
1379: oJumpForward 1390
1381: Choice Lookup Table
           1   1368
1384: oGetAddrLocal 5
1386: oPushResult
1387: oGetLocal 4
1389: oAssign
1390: oGetAddrLocal 6
1392: oPushResult
1393: oSetResult 0
1395: oAssign
1396: oGetLocal 6
1398: oPushResult
1399: oGetLocal 1
1401: oPushResult
1402: oNodeVecSize
1403: oPop 1
1405: oPushResult
1406: equal
1407: oPop 2
1409: oChoice 1466
1411: oGetAddrLocal 2
1413: oPushResult
1414: oGetLocal 1
1416: oPushResult
1417: oGetLocal 6
1419: oPushResult
1420: oNodeVecElement
1421: oPop 2
1423: oAssign
1424: oGetLocal 2
1426: oPushResult
1427: oSetResult 8
1429: oPushResult
1430: oGetLocal 4
1432: oPushResult
1433: oNodeSet
1434: oPop 3
1436: oGetLocal 2
1438: oPushResult
1439: oScopeDeclare
1440: oPop 1
1442: oGetLocal 2
1444: oPushResult
1445: oSetResult 9
1447: oPushResult
1448: oGetLocal 5
1450: oPushResult
1451: oScopeAllocType
1452: oPop 1
1454: oPushResult
1455: oNodeSetInt
1456: oPop 3
1458: oGetAddrLocal 6
1460: oPushResult
1461: inc
1462: oPop 1
1464: oJumpForward 1471
1466: Choice Lookup Table
           0   1411
1469: oJumpForward 1473
1471: oJumpBack 1396
1473: oGetLocal 1
1475: oPushResult
1476: oNodeVecDelete
1477: oPop 1
1479: oInputChoice 1487
1481: oJumpForward 1495
1483: oJumpForward 1493
1485: oJumpForward 1493
1487: Choice Lookup Table
           4   1485
          14   1481
1492: oEndChoice
1493: oJumpBack 1278
1495: oJumpForward 1500
1497: Choice Lookup Table
          13   1278
1500: oReturn
1501: oLocalSpace 2
1503: oInputChoice 1565
1505: oGetAddrLocal 1
1507: oPushResult
1508: oSetResult 9
1510: oPushResult
1511: oSetResult 4
1513: oPushResult
1514: LAST_ID
1515: oPushResult
1516: oCall 6604
1518: oPop 3
1520: oAssign
1521: oInput 5
1523: oCall 2338
1525: oGetAddrLocal 2
1527: oPushResult
1528: oValueTop
1529: oAssign
1530: oValuePop
1531: oGetLocal 1
1533: oPushResult
1534: oSetResult 9
1536: oPushResult
1537: oGetLocal 2
1539: oPushResult
1540: oNodeSetInt
1541: oPop 3
1543: oGetLocal 1
1545: oPushResult
1546: oSetResult 8
1548: oPushResult
1549: oGetGlobal 4
1551: oPushResult
1552: oNodeSet
1553: oPop 3
1555: oGetLocal 1
1557: oPushResult
1558: oScopeDeclare
1559: oPop 1
1561: oInput 4
1563: oJumpForward 1570
1565: Choice Lookup Table
           0   1505
1568: oJumpForward 1572
1570: oJumpBack 1503
1572: oReturn
1573: oLocalSpace 2
1575: oInputChoice 1624
1577: oGetAddrLocal 1
1579: oPushResult
1580: oSetResult 10
1582: oPushResult
1583: oSetResult 5
1585: oPushResult
1586: LAST_ID
1587: oPushResult
1588: oCall 6604
1590: oPop 3
1592: oAssign
1593: oInput 5
1595: oGetAddrLocal 2
1597: oPushResult
1598: oCall 1864
1600: oPop 1
1602: oGetLocal 1
1604: oPushResult
1605: oSetResult 8
1607: oPushResult
1608: oGetLocal 2
1610: oPushResult
1611: oNodeSet
1612: oPop 3
1614: oGetLocal 1
1616: oPushResult
1617: oScopeDeclare
1618: oPop 1
1620: oInput 4
1622: oJumpForward 1629
1624: Choice Lookup Table
           0   1577
1627: oJumpForward 1631
1629: oJumpBack 1575
1631: oReturn
1632: oLocalSpace 6
1634: oInputChoice 1856
1636: oGetAddrLocal 1
1638: oPushResult
1639: oNodeVecNew
1640: oAssign
1641: oGetAddrLocal 2
1643: oPushResult
1644: oGetParam 1
1646: oPushResult
1647: oSetResult 6
1649: oPushResult
1650: LAST_ID
1651: oPushResult
1652: oCall 6604
1654: oPop 3
1656: oAssign
1657: oGetLocal 1
1659: oPushResult
1660: oGetLocal 2
1662: oPushResult
1663: oNodeVecAppend
1664: oPop 2
1666: oInputChoice 1672
1668: oInput 0
1670: oJumpForward 1677
1672: Choice Lookup Table
          12   1668
1675: oJumpForward 1679
1677: oJumpBack 1641
1679: oInput 11
1681: oGetAddrLocal 3
1683: oPushResult
1684: oCall 1864
1686: oPop 1
1688: oGetAddrLocal 4
1690: oPushResult
1691: oSetResult 0
1693: oAssign
1694: oGetLocal 4
1696: oPushResult
1697: oGetLocal 1
1699: oPushResult
1700: oNodeVecSize
1701: oPop 1
1703: oPushResult
1704: equal
1705: oPop 2
1707: oChoice 1748
1709: oGetAddrLocal 2
1711: oPushResult
1712: oGetLocal 1
1714: oPushResult
1715: oGetLocal 4
1717: oPushResult
1718: oNodeVecElement
1719: oPop 2
1721: oAssign
1722: oGetLocal 2
1724: oPushResult
1725: oSetResult 8
1727: oPushResult
1728: oGetLocal 3
1730: oPushResult
1731: oNodeSet
1732: oPop 3
1734: oGetLocal 2
1736: oPushResult
1737: oScopeDeclareAlloc
1738: oPop 1
1740: oGetAddrLocal 4
1742: oPushResult
1743: inc
1744: oPop 1
1746: oJumpForward 1753
1748: Choice Lookup Table
           0   1709
1751: oJumpForward 1755
1753: oJumpBack 1694
1755: oInputChoice 1843
1757: oGetLocal 1
1759: oPushResult
1760: oNodeVecSize
1761: oPop 1
1763: oChoice 1767
1765: oJumpForward 1772
1767: Choice Lookup Table
           1   1765
1770: oError 22
1772: oGetAddrLocal 5
1774: oPushResult
1775: oCall 401
1777: oAssign
1778: oGetLocal 5
1780: oPushResult
1781: oCodePush
1782: oPop 1
1784: oGetAddrLocal 6
1786: oPushResult
1787: oSetResult 0
1789: oAssign
1790: oScopeCurrent
1791: oPushResult
1792: oGetGlobal 1
1794: oPushResult
1795: equal_node
1796: oPop 2
1798: oChoice 1814
1800: oGetGlobal 2
1802: oPushResult
1803: oScopeEnter
1804: oPop 1
1806: oGetAddrLocal 6
1808: oPushResult
1809: oSetResult 1
1811: oAssign
1812: oJumpForward 1817
1814: Choice Lookup Table
           1   1800
1817: oGetLocal 2
1819: oPushResult
1820: oCall 5765
1822: oPop 1
1824: oCall 2404
1826: oCall 6490
1828: oCall 5559
1830: oGetLocal 6
1832: oChoice 1837
1834: oScopeEnd
1835: oJumpForward 1840
1837: Choice Lookup Table
           1   1834
1840: oCodePop
1841: oJumpForward 1846
1843: Choice Lookup Table
           5   1757
1846: oGetLocal 1
1848: oPushResult
1849: oNodeVecDelete
1850: oPop 1
1852: oInput 4
1854: oJumpForward 1861
1856: Choice Lookup Table
           0   1636
1859: oJumpForward 1863
1861: oJumpBack 1634
1863: oReturn
1864: oLocalSpace 12
1866: oInputChoice 2320
1868: oGetAddrLocal 1
1870: oPushResult
1871: oScopeFindRequire
1872: oAssign
1873: oGetLocal 1
1875: oPushResult
1876: oNodeType
1877: oPop 1
1879: oChoice 1896
1881: oGetParam 1
1883: oPushResult
1884: oGetLocal 1
1886: oPushResult
1887: oSetResult 8
1889: oPushResult
1890: oNodeGet
1891: oPop 2
1893: oAssign
1894: oJumpForward 1907
1896: Choice Lookup Table
          10   1881
1899: oError 2
1901: oGetParam 1
1903: oPushResult
1904: oGetGlobal 4
1906: oAssign
1907: oJumpForward 2337
1909: oInput 15
1911: oGetAddrLocal 2
1913: oPushResult
1914: oNodeVecNew
1915: oAssign
1916: oGetAddrLocal 3
1918: oPushResult
1919: oSetResult 25
1921: oPushResult
1922: oNodeNew
1923: oPop 1
1925: oAssign
1926: oGetLocal 3
1928: oPushResult
1929: oSetResult 23
1931: oPushResult
1932: oGetGlobal 4
1934: oPushResult
1935: oNodeSet
1936: oPop 3
1938: oCall 2338
1940: oGetLocal 3
1942: oPushResult
1943: oSetResult 25
1945: oPushResult
1946: oValueTop
1947: oPushResult
1948: oNodeSetInt
1949: oPop 3
1951: oValuePop
1952: oInput 20
1954: oCall 2338
1956: oGetLocal 3
1958: oPushResult
1959: oSetResult 26
1961: oPushResult
1962: oValueTop
1963: oPushResult
1964: oNodeSetInt
1965: oPop 3
1967: oValuePop
1968: oGetLocal 3
1970: oPushResult
1971: oSetResult 3
1973: oPushResult
1974: oSetResult 4
1976: oPushResult
1977: oNodeSetInt
1978: oPop 3
1980: oGetLocal 3
1982: oPushResult
1983: oTypeAdd
1984: oPop 1
1986: oGetAddrLocal 4
1988: oPushResult
1989: oSetResult 24
1991: oPushResult
1992: oNodeNew
1993: oPop 1
1995: oAssign
1996: oGetLocal 4
1998: oPushResult
1999: oSetResult 24
2001: oPushResult
2002: oGetLocal 3
2004: oPushResult
2005: oNodeSet
2006: oPop 3
2008: oGetLocal 2
2010: oPushResult
2011: oGetLocal 4
2013: oPushResult
2014: oNodeVecAppend
2015: oPop 2
2017: oInputChoice 2025
2019: oJumpForward 2033
2021: oJumpForward 2031
2023: oJumpForward 2031
2025: Choice Lookup Table
          12   2023
          16   2019
2030: oEndChoice
2031: oJumpBack 1916
2033: oInput 38
2035: oGetAddrLocal 5
2037: oPushResult
2038: oCall 1864
2040: oPop 1
2042: oGetAddrLocal 6
2044: oPushResult
2045: oGetLocal 2
2047: oPushResult
2048: oNodeVecSize
2049: oPop 1
2051: oAssign
2052: oGetAddrLocal 6
2054: oPushResult
2055: dec
2056: oPop 1
2058: oGetAddrLocal 7
2060: oPushResult
2061: oGetLocal 2
2063: oPushResult
2064: oGetLocal 6
2066: oPushResult
2067: oNodeVecElement
2068: oPop 2
2070: oAssign
2071: oGetLocal 7
2073: oPushResult
2074: oSetResult 23
2076: oPushResult
2077: oGetLocal 5
2079: oPushResult
2080: oNodeSet
2081: oPop 3
2083: oGetAddrLocal 8
2085: oPushResult
2086: oGetLocal 7
2088: oPushResult
2089: oSetResult 24
2091: oPushResult
2092: oNodeGet
2093: oPop 2
2095: oAssign
2096: oGetAddrLocal 9
2098: oPushResult
2099: oGetLocal 8
2101: oPushResult
2102: oSetResult 26
2104: oPushResult
2105: oNodeGetInt
2106: oPop 2
2108: oPushResult
2109: oGetLocal 8
2111: oPushResult
2112: oSetResult 25
2114: oPushResult
2115: oNodeGetInt
2116: oPop 2
2118: oPushResult
2119: subtract
2120: oPop 2
2122: oAssign
2123: oGetAddrLocal 9
2125: oPushResult
2126: inc
2127: oPop 1
2129: oGetLocal 7
2131: oPushResult
2132: oSetResult 3
2134: oPushResult
2135: oGetLocal 9
2137: oPushResult
2138: oGetLocal 5
2140: oPushResult
2141: oSetResult 3
2143: oPushResult
2144: oNodeGetInt
2145: oPop 2
2147: oPushResult
2148: multiply
2149: oPop 2
2151: oPushResult
2152: oNodeSetInt
2153: oPop 3
2155: oGetLocal 7
2157: oPushResult
2158: oTypeAdd
2159: oPop 1
2161: oGetAddrLocal 5
2163: oPushResult
2164: oGetLocal 7
2166: oAssign
2167: oGetLocal 6
2169: oPushResult
2170: equal_zero
2171: oPop 1
2173: oChoice 2179
2175: oJumpForward 2184
2177: oJumpForward 2182
2179: Choice Lookup Table
           1   2175
2182: oJumpBack 2052
2184: oGetParam 1
2186: oPushResult
2187: oGetLocal 2
2189: oPushResult
2190: oSetResult 0
2192: oPushResult
2193: oNodeVecElement
2194: oPop 2
2196: oAssign
2197: oGetLocal 2
2199: oPushResult
2200: oNodeVecDelete
2201: oPop 1
2203: oJumpForward 2337
2205: oGetAddrLocal 10
2207: oPushResult
2208: oCall 1864
2210: oPop 1
2212: oGetParam 1
2214: oPushResult
2215: oGetLocal 10
2217: oPushResult
2218: oCall 6632
2220: oPop 1
2222: oAssign
2223: oJumpForward 2337
2225: oGetParam 1
2227: oPushResult
2228: oSetResult 26
2230: oPushResult
2231: oNodeNew
2232: oPop 1
2234: oAssign
2235: oSetResult -1
2237: oPushResult
2238: oScopeBegin
2239: oPop 1
2241: oSetResult 14
2243: oPushResult
2244: oCall 1632
2246: oPop 1
2248: oGetAddrLocal 11
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oSetResult 3
2255: oPushResult
2256: oNodeGetInt
2257: oPop 2
2259: oAssign
2260: oGetLocal 11
2262: oPushResult
2263: equal_zero
2264: oPop 1
2266: oChoice 2272
2268: oError 19
2270: oJumpForward 2275
2272: Choice Lookup Table
           1   2268
2275: oInput 34
2277: oGetFromParam 1
2279: oPushResult
2280: oSetResult 27
2282: oPushResult
2283: oScopeCurrent
2284: oPushResult
2285: oNodeSet
2286: oPop 3
2288: oGetFromParam 1
2290: oPushResult
2291: oSetResult 3
2293: oPushResult
2294: oGetLocal 11
2296: oPushResult
2297: oNodeSetInt
2298: oPop 3
2300: oScopeEnd
2301: oGetFromParam 1
2303: oPushResult
2304: oTypeAdd
2305: oPop 1
2307: oJumpForward 2337
2309: oInput 38
2311: oGetAddrLocal 12
2313: oPushResult
2314: oCall 1864
2316: oPop 1
2318: oJumpForward 2337
2320: Choice Lookup Table
          37   2309
          36   2225
          17   2205
          35   1909
           0   1868
2331: oCall 2338
2333: oInput 20
2335: oCall 2338
2337: oReturn
2338: oLocalSpace 1
2340: oInputChoice 2395
2342: TOKEN_VALUE
2343: oPushResult
2344: oValuePush
2345: oPop 1
2347: oJumpForward 2403
2349: oGetAddrLocal 1
2351: oPushResult
2352: oScopeFindRequire
2353: oAssign
2354: oGetLocal 1
2356: oPushResult
2357: oNodeType
2358: oPop 1
2360: oChoice 2377
2362: oGetLocal 1
2364: oPushResult
2365: oSetResult 9
2367: oPushResult
2368: oNodeGetInt
2369: oPop 2
2371: oPushResult
2372: oValuePush
2373: oPop 1
2375: oJumpForward 2388
2377: Choice Lookup Table
           9   2362
2380: oError 1
2382: oSetResult 0
2384: oPushResult
2385: oValuePush
2386: oPop 1
2388: oJumpForward 2403
2390: oCall 2338
2392: oValueNegate
2393: oJumpForward 2403
2395: Choice Lookup Table
          24   2390
           0   2349
           1   2342
2402: oEndChoice
2403: oReturn
2404: oLocalSpace 1
2406: oGetAddrLocal 1
2408: oPushResult
2409: oSetResult 0
2411: oAssign
2412: oGetAddrLocal 1
2414: oPushResult
2415: oCall 2565
2417: oPop 1
2419: oGetAddrLocal 1
2421: oPushResult
2422: oCall 2465
2424: oPop 1
2426: oReturn
2427: oLocalSpace 0
2429: oGetParam 1
2431: oPushResult
2432: oCall 2565
2434: oPop 1
2436: oTypeSNodeType
2437: oChoice 2456
2439: oJumpForward 2463
2441: oGetParam 1
2443: oPushResult
2444: oLabelNew
2445: oAssign
2446: oEmit 55
2448: oGetFromParam 1
2450: oPushResult
2451: oEmitLabel
2452: oPop 1
2454: oJumpForward 2463
2456: Choice Lookup Table
          19   2441
          20   2439
2461: oError 8
2463: oTypeSPop
2464: oReturn
2465: oLocalSpace 1
2467: oTypeSNodeType
2468: oChoice 2530
2470: oGetAddrLocal 1
2472: oPushResult
2473: oLabelNew
2474: oAssign
2475: oEmit 15
2477: oSetResult 1
2479: oPushResult
2480: oEmitInt
2481: oPop 1
2483: oEmit 53
2485: oGetLocal 1
2487: oPushResult
2488: oEmitLabel
2489: oPop 1
2491: oEmit 56
2493: oGetFromParam 1
2495: oPushResult
2496: oEmitLabel
2497: oPop 1
2499: oEmit 15
2501: oSetResult 0
2503: oPushResult
2504: oEmitInt
2505: oPop 1
2507: oEmit 56
2509: oGetLocal 1
2511: oPushResult
2512: oEmitLabel
2513: oPop 1
2515: oTypeSPop
2516: oGetGlobal 5
2518: oPushResult
2519: oTypeSPush
2520: oPop 1
2522: oGetParam 1
2524: oPushResult
2525: oSetResult 0
2527: oAssign
2528: oJumpForward 2533
2530: Choice Lookup Table
          20   2470
2533: oReturn
2534: oLocalSpace 0
2536: oTypeSNodeType
2537: oChoice 2561
2539: oGetParam 1
2541: oPushResult
2542: oLabelNew
2543: oAssign
2544: oEmit 55
2546: oGetFromParam 1
2548: oPushResult
2549: oEmitLabel
2550: oPop 1
2552: oTypeSPop
2553: oGetGlobal 6
2555: oPushResult
2556: oTypeSPush
2557: oPop 1
2559: oJumpForward 2564
2561: Choice Lookup Table
          19   2539
2564: oReturn
2565: oLocalSpace 0
2567: oGetParam 1
2569: oPushResult
2570: oCall 2930
2572: oPop 1
2574: oInputChoice 2912
2576: oGetParam 1
2578: oPushResult
2579: oCall 2465
2581: oPop 1
2583: oGetParam 1
2585: oPushResult
2586: oCall 2930
2588: oPop 1
2590: oGetParam 1
2592: oPushResult
2593: oCall 2465
2595: oPop 1
2597: oCall 6490
2599: oTypeSNodeType
2600: oChoice 2614
2602: oEmit 38
2604: oJumpForward 2627
2606: oEmit 44
2608: oJumpForward 2627
2610: oError 16
2612: oJumpForward 2627
2614: Choice Lookup Table
          22   2610
          21   2610
          23   2606
          19   2602
          18   2602
2625: oError 17
2627: oTypeSPop
2628: oGetGlobal 5
2630: oPushResult
2631: oTypeSPush
2632: oPop 1
2634: oJumpForward 2927
2636: oGetParam 1
2638: oPushResult
2639: oCall 2465
2641: oPop 1
2643: oGetParam 1
2645: oPushResult
2646: oCall 2930
2648: oPop 1
2650: oGetParam 1
2652: oPushResult
2653: oCall 2465
2655: oPop 1
2657: oCall 6490
2659: oTypeSNodeType
2660: oChoice 2674
2662: oEmit 39
2664: oJumpForward 2687
2666: oEmit 45
2668: oJumpForward 2687
2670: oError 16
2672: oJumpForward 2687
2674: Choice Lookup Table
          22   2670
          21   2670
          23   2666
          19   2662
          18   2662
2685: oError 17
2687: oTypeSPop
2688: oGetGlobal 5
2690: oPushResult
2691: oTypeSPush
2692: oPop 1
2694: oJumpForward 2927
2696: oGetParam 1
2698: oPushResult
2699: oCall 2465
2701: oPop 1
2703: oGetParam 1
2705: oPushResult
2706: oCall 2930
2708: oPop 1
2710: oGetParam 1
2712: oPushResult
2713: oCall 2465
2715: oPop 1
2717: oCall 6490
2719: oTypeSNodeType
2720: oChoice 2730
2722: oEmit 41
2724: oJumpForward 2741
2726: oError 16
2728: oJumpForward 2741
2730: Choice Lookup Table
          22   2726
          21   2726
          19   2722
          18   2722
2739: oError 17
2741: oTypeSPop
2742: oGetGlobal 5
2744: oPushResult
2745: oTypeSPush
2746: oPop 1
2748: oJumpForward 2927
2750: oGetParam 1
2752: oPushResult
2753: oCall 2465
2755: oPop 1
2757: oGetParam 1
2759: oPushResult
2760: oCall 2930
2762: oPop 1
2764: oGetParam 1
2766: oPushResult
2767: oCall 2465
2769: oPop 1
2771: oCall 6490
2773: oTypeSNodeType
2774: oChoice 2784
2776: oEmit 40
2778: oJumpForward 2795
2780: oError 16
2782: oJumpForward 2795
2784: Choice Lookup Table
          22   2780
          21   2780
          19   2776
          18   2776
2793: oError 17
2795: oTypeSPop
2796: oGetGlobal 5
2798: oPushResult
2799: oTypeSPush
2800: oPop 1
2802: oJumpForward 2927
2804: oGetParam 1
2806: oPushResult
2807: oCall 2465
2809: oPop 1
2811: oGetParam 1
2813: oPushResult
2814: oCall 2930
2816: oPop 1
2818: oGetParam 1
2820: oPushResult
2821: oCall 2465
2823: oPop 1
2825: oCall 6490
2827: oTypeSNodeType
2828: oChoice 2838
2830: oEmit 43
2832: oJumpForward 2849
2834: oError 16
2836: oJumpForward 2849
2838: Choice Lookup Table
          22   2834
          21   2834
          19   2830
          18   2830
2847: oError 17
2849: oTypeSPop
2850: oGetGlobal 5
2852: oPushResult
2853: oTypeSPush
2854: oPop 1
2856: oJumpForward 2927
2858: oGetParam 1
2860: oPushResult
2861: oCall 2465
2863: oPop 1
2865: oGetParam 1
2867: oPushResult
2868: oCall 2930
2870: oPop 1
2872: oGetParam 1
2874: oPushResult
2875: oCall 2465
2877: oPop 1
2879: oCall 6490
2881: oTypeSNodeType
2882: oChoice 2892
2884: oEmit 42
2886: oJumpForward 2903
2888: oError 16
2890: oJumpForward 2903
2892: Choice Lookup Table
          22   2888
          21   2888
          19   2884
          18   2884
2901: oError 17
2903: oTypeSPop
2904: oGetGlobal 5
2906: oPushResult
2907: oTypeSPush
2908: oPop 1
2910: oJumpForward 2927
2912: Choice Lookup Table
          10   2858
           9   2804
           8   2750
           7   2696
           6   2636
           5   2576
2925: oJumpForward 2929
2927: oJumpBack 2574
2929: oReturn
2930: oLocalSpace 1
2932: oGetAddrLocal 1
2934: oPushResult
2935: oSetResult 0
2937: oAssign
2938: oGetParam 1
2940: oPushResult
2941: oCall 3110
2943: oPop 1
2945: oInputChoice 3078
2947: oTypeSNodeType
2948: oChoice 3019
2950: oGetLocal 1
2952: oPushResult
2953: oSetResult 0
2955: oPushResult
2956: equal_label
2957: oPop 2
2959: oChoice 2968
2961: oGetAddrLocal 1
2963: oPushResult
2964: oLabelNew
2965: oAssign
2966: oJumpForward 2971
2968: Choice Lookup Table
           1   2961
2971: oEmit 53
2973: oGetLocal 1
2975: oPushResult
2976: oEmitLabel
2977: oPop 1
2979: oJumpForward 3026
2981: oGetParam 1
2983: oPushResult
2984: oCall 2534
2986: oPop 1
2988: oGetLocal 1
2990: oPushResult
2991: oSetResult 0
2993: oPushResult
2994: equal_label
2995: oPop 2
2997: oChoice 3006
2999: oGetAddrLocal 1
3001: oPushResult
3002: oLabelNew
3003: oAssign
3004: oJumpForward 3009
3006: Choice Lookup Table
           1   2999
3009: oEmit 53
3011: oGetLocal 1
3013: oPushResult
3014: oEmitLabel
3015: oPop 1
3017: oJumpForward 3026
3019: Choice Lookup Table
          19   2981
          20   2950
3024: oError 8
3026: oTypeSPop
3027: oEmit 56
3029: oGetFromParam 1
3031: oPushResult
3032: oEmitLabel
3033: oPop 1
3035: oGetParam 1
3037: oPushResult
3038: oSetResult 0
3040: oAssign
3041: oGetParam 1
3043: oPushResult
3044: oCall 3110
3046: oPop 1
3048: oTypeSNodeType
3049: oChoice 3062
3051: oJumpForward 3069
3053: oGetParam 1
3055: oPushResult
3056: oCall 2534
3058: oPop 1
3060: oJumpForward 3069
3062: Choice Lookup Table
          19   3053
          20   3051
3067: oError 8
3069: oTypeSPop
3070: oGetGlobal 6
3072: oPushResult
3073: oTypeSPush
3074: oPop 1
3076: oJumpForward 3083
3078: Choice Lookup Table
          52   2947
3081: oJumpForward 3085
3083: oJumpBack 2945
3085: oGetLocal 1
3087: oPushResult
3088: oSetResult 0
3090: oPushResult
3091: equal_label
3092: oPop 2
3094: oChoice 3106
3096: oEmit 56
3098: oGetLocal 1
3100: oPushResult
3101: oEmitLabel
3102: oPop 1
3104: oJumpForward 3109
3106: Choice Lookup Table
           0   3096
3109: oReturn
3110: oLocalSpace 2
3112: oGetAddrLocal 1
3114: oPushResult
3115: oSetResult 0
3117: oAssign
3118: oGetParam 1
3120: oPushResult
3121: oCall 3248
3123: oPop 1
3125: oInputChoice 3240
3127: oTypeSNodeType
3128: oChoice 3141
3130: oJumpForward 3148
3132: oGetParam 1
3134: oPushResult
3135: oCall 2534
3137: oPop 1
3139: oJumpForward 3148
3141: Choice Lookup Table
          19   3132
          20   3130
3146: oError 8
3148: oTypeSPop
3149: oGetLocal 1
3151: oPushResult
3152: oSetResult 0
3154: oPushResult
3155: equal_label
3156: oPop 2
3158: oChoice 3187
3160: oGetAddrLocal 1
3162: oPushResult
3163: oLabelNew
3164: oAssign
3165: oEmit 57
3167: oGetFromParam 1
3169: oPushResult
3170: oEmitLabel
3171: oPop 1
3173: oGetLocal 1
3175: oPushResult
3176: oEmitLabel
3177: oPop 1
3179: oGetParam 1
3181: oPushResult
3182: oGetLocal 1
3184: oAssign
3185: oJumpForward 3190
3187: Choice Lookup Table
           1   3160
3190: oGetAddrLocal 2
3192: oPushResult
3193: oSetResult 0
3195: oAssign
3196: oGetAddrLocal 2
3198: oPushResult
3199: oCall 3248
3201: oPop 1
3203: oTypeSNodeType
3204: oChoice 3217
3206: oJumpForward 3224
3208: oGetAddrLocal 2
3210: oPushResult
3211: oCall 2534
3213: oPop 1
3215: oJumpForward 3224
3217: Choice Lookup Table
          19   3208
          20   3206
3222: oError 8
3224: oEmit 57
3226: oGetLocal 2
3228: oPushResult
3229: oEmitLabel
3230: oPop 1
3232: oGetLocal 1
3234: oPushResult
3235: oEmitLabel
3236: oPop 1
3238: oJumpForward 3245
3240: Choice Lookup Table
          51   3127
3243: oJumpForward 3247
3245: oJumpBack 3125
3247: oReturn
3248: oLocalSpace 1
3250: oInputChoice 3304
3252: oGetAddrLocal 1
3254: oPushResult
3255: oSetResult 0
3257: oAssign
3258: oGetAddrLocal 1
3260: oPushResult
3261: oCall 3248
3263: oPop 1
3265: oTypeSNodeType
3266: oChoice 3295
3268: oGetParam 1
3270: oPushResult
3271: oLabelNew
3272: oAssign
3273: oEmit 53
3275: oGetFromParam 1
3277: oPushResult
3278: oEmitLabel
3279: oPop 1
3281: oEmit 56
3283: oGetLocal 1
3285: oPushResult
3286: oEmitLabel
3287: oPop 1
3289: oJumpForward 3302
3291: oEmit 37
3293: oJumpForward 3302
3295: Choice Lookup Table
          19   3291
          20   3268
3300: oError 8
3302: oJumpForward 3314
3304: Choice Lookup Table
          53   3252
3307: oGetParam 1
3309: oPushResult
3310: oCall 3315
3312: oPop 1
3314: oReturn
3315: oLocalSpace 0
3317: oGetParam 1
3319: oPushResult
3320: oCall 3366
3322: oPop 1
3324: oInputChoice 3356
3326: oCall 6516
3328: oGetParam 1
3330: oPushResult
3331: oCall 3366
3333: oPop 1
3335: oCall 6530
3337: oEmit 34
3339: oJumpForward 3363
3341: oCall 6516
3343: oGetParam 1
3345: oPushResult
3346: oCall 3366
3348: oPop 1
3350: oCall 6530
3352: oEmit 35
3354: oJumpForward 3363
3356: Choice Lookup Table
          24   3341
          23   3326
3361: oJumpForward 3365
3363: oJumpBack 3324
3365: oReturn
3366: oLocalSpace 0
3368: oGetParam 1
3370: oPushResult
3371: oCall 3417
3373: oPop 1
3375: oInputChoice 3407
3377: oCall 6516
3379: oGetParam 1
3381: oPushResult
3382: oCall 3417
3384: oPop 1
3386: oCall 6530
3388: oEmit 31
3390: oJumpForward 3414
3392: oCall 6516
3394: oGetParam 1
3396: oPushResult
3397: oCall 3417
3399: oPop 1
3401: oCall 6530
3403: oEmit 32
3405: oJumpForward 3414
3407: Choice Lookup Table
          22   3392
          21   3377
3412: oJumpForward 3416
3414: oJumpBack 3375
3416: oReturn
3417: oLocalSpace 0
3419: oInputChoice 3445
3421: oGetParam 1
3423: oPushResult
3424: oCall 3458
3426: oPop 1
3428: oCall 6530
3430: oJumpForward 3457
3432: oGetParam 1
3434: oPushResult
3435: oCall 3458
3437: oPop 1
3439: oCall 6530
3441: oEmit 36
3443: oJumpForward 3457
3445: Choice Lookup Table
          24   3432
          23   3421
3450: oGetParam 1
3452: oPushResult
3453: oCall 3458
3455: oPop 1
3457: oReturn
3458: oLocalSpace 6
3460: oInputChoice 3646
3462: oEmit 15
3464: TOKEN_VALUE
3465: oPushResult
3466: oEmitInt
3467: oPop 1
3469: oGetGlobal 4
3471: oPushResult
3472: oTypeSPush
3473: oPop 1
3475: oJumpForward 3665
3477: oGetParam 1
3479: oPushResult
3480: oCall 2565
3482: oPop 1
3484: oInput 14
3486: oJumpForward 3665
3488: oGetAddrLocal 1
3490: oPushResult
3491: CURRENT_STRLIT
3492: oPushResult
3493: oStringAllocLit
3494: oPop 1
3496: oAssign
3497: oEmit 16
3499: oGetLocal 1
3501: oPushResult
3502: oEmitInt
3503: oPop 1
3505: oGetGlobal 8
3507: oPushResult
3508: oTypeSPush
3509: oPop 1
3511: oJumpForward 3665
3513: oGetAddrLocal 2
3515: oPushResult
3516: oScopeFindRequire
3517: oAssign
3518: oGetLocal 2
3520: oPushResult
3521: oNodeType
3522: oPop 1
3524: oChoice 3586
3526: oGetLocal 2
3528: oPushResult
3529: oCall 4818
3531: oPop 1
3533: oJumpForward 3605
3535: oGetAddrLocal 3
3537: oPushResult
3538: oGetLocal 2
3540: oPushResult
3541: oSetResult 8
3543: oPushResult
3544: oNodeGet
3545: oPop 2
3547: oAssign
3548: oGetLocal 3
3550: oPushResult
3551: oTypeSPush
3552: oPop 1
3554: oTypeSNodeType
3555: oChoice 3568
3557: oEmit 15
3559: oGetLocal 2
3561: oPushResult
3562: oCall 6767
3564: oPop 1
3566: oJumpForward 3575
3568: Choice Lookup Table
          19   3557
          18   3557
3573: oError 16
3575: oJumpForward 3605
3577: oGetLocal 2
3579: oPushResult
3580: oCall 3666
3582: oPop 1
3584: oJumpForward 3605
3586: Choice Lookup Table
          15   3577
          13   3577
          12   3577
           9   3535
           8   3526
3597: oError 6
3599: oGetGlobal 4
3601: oPushResult
3602: oTypeSPush
3603: oPop 1
3605: oJumpForward 3665
3607: oInput 0
3609: oGetAddrLocal 4
3611: oPushResult
3612: oScopeFindRequire
3613: oAssign
3614: oGetLocal 4
3616: oPushResult
3617: oCall 5765
3619: oPop 1
3621: oGetAddrLocal 5
3623: oPushResult
3624: oTypeSTop
3625: oAssign
3626: oTypeSPop
3627: oGetAddrLocal 6
3629: oPushResult
3630: oGetLocal 5
3632: oPushResult
3633: oCall 6632
3635: oPop 1
3637: oAssign
3638: oGetLocal 6
3640: oPushResult
3641: oTypeSPush
3642: oPop 1
3644: oJumpForward 3665
3646: Choice Lookup Table
          18   3607
           0   3513
           2   3488
          13   3477
           1   3462
3657: oError 6
3659: oGetGlobal 4
3661: oPushResult
3662: oTypeSPush
3663: oPop 1
3665: oReturn
3666: oLocalSpace 2
3668: oGetAddrLocal 1
3670: oPushResult
3671: oGetParam 1
3673: oPushResult
3674: oSetResult 8
3676: oPushResult
3677: oNodeGet
3678: oPop 2
3680: oAssign
3681: oGetAddrLocal 2
3683: oPushResult
3684: oGetParam 1
3686: oPushResult
3687: oCall 6466
3689: oPop 1
3691: oAssign
3692: oGetLocal 1
3694: oPushResult
3695: oTypeSPush
3696: oPop 1
3698: oTypeSNodeType
3699: oChoice 4216
3701: oGetParam 1
3703: oPushResult
3704: oNodeType
3705: oPop 1
3707: oChoice 3853
3709: oEmit 0
3711: oGetParam 1
3713: oPushResult
3714: oCall 6767
3716: oPop 1
3718: oJumpForward 3861
3720: oGetLocal 2
3722: oPushResult
3723: equal_zero
3724: oPop 1
3726: oChoice 3739
3728: oEmit 3
3730: oGetParam 1
3732: oPushResult
3733: oCall 6767
3735: oPop 1
3737: oJumpForward 3757
3739: Choice Lookup Table
           1   3728
3742: oEmit 9
3744: oGetLocal 2
3746: oPushResult
3747: oEmitInt
3748: oPop 1
3750: oGetParam 1
3752: oPushResult
3753: oCall 6767
3755: oPop 1
3757: oJumpForward 3861
3759: oGetParam 1
3761: oPushResult
3762: oSetResult 21
3764: oPushResult
3765: oNodeGetBoolean
3766: oPop 2
3768: oChoice 3811
3770: oGetLocal 2
3772: oPushResult
3773: equal_zero
3774: oPop 1
3776: oChoice 3789
3778: oEmit 8
3780: oGetParam 1
3782: oPushResult
3783: oCall 6767
3785: oPop 1
3787: oJumpForward 3807
3789: Choice Lookup Table
           1   3778
3792: oEmit 14
3794: oGetLocal 2
3796: oPushResult
3797: oEmitInt
3798: oPop 1
3800: oGetParam 1
3802: oPushResult
3803: oCall 6767
3805: oPop 1
3807: oEmit 22
3809: oJumpForward 3851
3811: Choice Lookup Table
           1   3770
3814: oGetLocal 2
3816: oPushResult
3817: equal_zero
3818: oPop 1
3820: oChoice 3833
3822: oEmit 6
3824: oGetParam 1
3826: oPushResult
3827: oCall 6767
3829: oPop 1
3831: oJumpForward 3851
3833: Choice Lookup Table
           1   3822
3836: oEmit 12
3838: oGetLocal 2
3840: oPushResult
3841: oEmitInt
3842: oPop 1
3844: oGetParam 1
3846: oPushResult
3847: oCall 6767
3849: oPop 1
3851: oJumpForward 3861
3853: Choice Lookup Table
          15   3759
          13   3720
          12   3709
3860: oEndChoice
3861: oJumpForward 4391
3863: oGetParam 1
3865: oPushResult
3866: oNodeType
3867: oPop 1
3869: oChoice 4015
3871: oEmit 1
3873: oGetParam 1
3875: oPushResult
3876: oCall 6767
3878: oPop 1
3880: oJumpForward 4023
3882: oGetLocal 2
3884: oPushResult
3885: equal_zero
3886: oPop 1
3888: oChoice 3901
3890: oEmit 4
3892: oGetParam 1
3894: oPushResult
3895: oCall 6767
3897: oPop 1
3899: oJumpForward 3919
3901: Choice Lookup Table
           1   3890
3904: oEmit 10
3906: oGetLocal 2
3908: oPushResult
3909: oEmitInt
3910: oPop 1
3912: oGetParam 1
3914: oPushResult
3915: oCall 6767
3917: oPop 1
3919: oJumpForward 4023
3921: oGetParam 1
3923: oPushResult
3924: oSetResult 21
3926: oPushResult
3927: oNodeGetBoolean
3928: oPop 2
3930: oChoice 3973
3932: oGetLocal 2
3934: oPushResult
3935: equal_zero
3936: oPop 1
3938: oChoice 3951
3940: oEmit 8
3942: oGetParam 1
3944: oPushResult
3945: oCall 6767
3947: oPop 1
3949: oJumpForward 3969
3951: Choice Lookup Table
           1   3940
3954: oEmit 14
3956: oGetLocal 2
3958: oPushResult
3959: oEmitInt
3960: oPop 1
3962: oGetParam 1
3964: oPushResult
3965: oCall 6767
3967: oPop 1
3969: oEmit 23
3971: oJumpForward 4013
3973: Choice Lookup Table
           1   3932
3976: oGetLocal 2
3978: oPushResult
3979: equal_zero
3980: oPop 1
3982: oChoice 3995
3984: oEmit 7
3986: oGetParam 1
3988: oPushResult
3989: oCall 6767
3991: oPop 1
3993: oJumpForward 4013
3995: Choice Lookup Table
           1   3984
3998: oEmit 13
4000: oGetLocal 2
4002: oPushResult
4003: oEmitInt
4004: oPop 1
4006: oGetParam 1
4008: oPushResult
4009: oCall 6767
4011: oPop 1
4013: oJumpForward 4023
4015: Choice Lookup Table
          15   3921
          13   3882
          12   3871
4022: oEndChoice
4023: oJumpForward 4391
4025: oError 16
4027: oJumpForward 4391
4029: oGetParam 1
4031: oPushResult
4032: oNodeType
4033: oPop 1
4035: oChoice 4181
4037: oEmit 2
4039: oGetParam 1
4041: oPushResult
4042: oCall 6767
4044: oPop 1
4046: oJumpForward 4189
4048: oGetLocal 2
4050: oPushResult
4051: equal_zero
4052: oPop 1
4054: oChoice 4067
4056: oEmit 5
4058: oGetParam 1
4060: oPushResult
4061: oCall 6767
4063: oPop 1
4065: oJumpForward 4085
4067: Choice Lookup Table
           1   4056
4070: oEmit 11
4072: oGetLocal 2
4074: oPushResult
4075: oEmitInt
4076: oPop 1
4078: oGetParam 1
4080: oPushResult
4081: oCall 6767
4083: oPop 1
4085: oJumpForward 4189
4087: oGetParam 1
4089: oPushResult
4090: oSetResult 21
4092: oPushResult
4093: oNodeGetBoolean
4094: oPop 2
4096: oChoice 4139
4098: oGetLocal 2
4100: oPushResult
4101: equal_zero
4102: oPop 1
4104: oChoice 4117
4106: oEmit 8
4108: oGetParam 1
4110: oPushResult
4111: oCall 6767
4113: oPop 1
4115: oJumpForward 4135
4117: Choice Lookup Table
           1   4106
4120: oEmit 14
4122: oGetLocal 2
4124: oPushResult
4125: oEmitInt
4126: oPop 1
4128: oGetParam 1
4130: oPushResult
4131: oCall 6767
4133: oPop 1
4135: oEmit 24
4137: oJumpForward 4179
4139: Choice Lookup Table
           1   4098
4142: oGetLocal 2
4144: oPushResult
4145: equal_zero
4146: oPop 1
4148: oChoice 4161
4150: oEmit 8
4152: oGetParam 1
4154: oPushResult
4155: oCall 6767
4157: oPop 1
4159: oJumpForward 4179
4161: Choice Lookup Table
           1   4150
4164: oEmit 14
4166: oGetLocal 2
4168: oPushResult
4169: oEmitInt
4170: oPop 1
4172: oGetParam 1
4174: oPushResult
4175: oCall 6767
4177: oPop 1
4179: oJumpForward 4189
4181: Choice Lookup Table
          15   4087
          13   4048
          12   4037
4188: oEndChoice
4189: oInputChoice 4211
4191: oTypeSPop
4192: oGetLocal 1
4194: oPushResult
4195: oSetResult 23
4197: oPushResult
4198: oNodeGet
4199: oPop 2
4201: oPushResult
4202: oTypeSPush
4203: oPop 1
4205: oCall 4427
4207: oCall 4392
4209: oJumpForward 4214
4211: Choice Lookup Table
          17   4191
4214: oJumpForward 4391
4216: Choice Lookup Table
          23   4029
          17   4025
          22   4025
          21   4025
          19   3863
          18   3701
4229: oGetParam 1
4231: oPushResult
4232: oNodeType
4233: oPop 1
4235: oChoice 4379
4237: oEmit 16
4239: oGetParam 1
4241: oPushResult
4242: oCall 6767
4244: oPop 1
4246: oJumpForward 4387
4248: oGetLocal 2
4250: oPushResult
4251: equal_zero
4252: oPop 1
4254: oChoice 4267
4256: oEmit 17
4258: oGetParam 1
4260: oPushResult
4261: oCall 6767
4263: oPop 1
4265: oJumpForward 4285
4267: Choice Lookup Table
           1   4256
4270: oEmit 20
4272: oGetLocal 2
4274: oPushResult
4275: oEmitInt
4276: oPop 1
4278: oGetParam 1
4280: oPushResult
4281: oCall 6767
4283: oPop 1
4285: oJumpForward 4387
4287: oGetParam 1
4289: oPushResult
4290: oSetResult 21
4292: oPushResult
4293: oNodeGetBoolean
4294: oPop 2
4296: oChoice 4337
4298: oGetLocal 2
4300: oPushResult
4301: equal_zero
4302: oPop 1
4304: oChoice 4317
4306: oEmit 8
4308: oGetParam 1
4310: oPushResult
4311: oCall 6767
4313: oPop 1
4315: oJumpForward 4335
4317: Choice Lookup Table
           1   4306
4320: oEmit 14
4322: oGetLocal 2
4324: oPushResult
4325: oEmitInt
4326: oPop 1
4328: oGetParam 1
4330: oPushResult
4331: oCall 6767
4333: oPop 1
4335: oJumpForward 4377
4337: Choice Lookup Table
           1   4298
4340: oGetLocal 2
4342: oPushResult
4343: equal_zero
4344: oPop 1
4346: oChoice 4359
4348: oEmit 18
4350: oGetParam 1
4352: oPushResult
4353: oCall 6767
4355: oPop 1
4357: oJumpForward 4377
4359: Choice Lookup Table
           1   4348
4362: oEmit 21
4364: oGetLocal 2
4366: oPushResult
4367: oEmitInt
4368: oPop 1
4370: oGetParam 1
4372: oPushResult
4373: oCall 6767
4375: oPop 1
4377: oJumpForward 4387
4379: Choice Lookup Table
          15   4287
          13   4248
          12   4237
4386: oEndChoice
4387: oCall 4427
4389: oCall 4392
4391: oReturn
4392: oLocalSpace 0
4394: oTypeSNodeType
4395: oChoice 4413
4397: oEmit 22
4399: oJumpForward 4426
4401: oEmit 23
4403: oJumpForward 4426
4405: oError 16
4407: oJumpForward 4426
4409: oEmit 24
4411: oJumpForward 4426
4413: Choice Lookup Table
          23   4409
          17   4405
          22   4405
          21   4405
          19   4401
          18   4397
4426: oReturn
4427: oLocalSpace 0
4429: oInputChoice 4443
4431: oCall 4455
4433: oJumpForward 4452
4435: oCall 4598
4437: oJumpForward 4452
4439: oCall 4696
4441: oJumpForward 4452
4443: Choice Lookup Table
          17   4439
          19   4435
          15   4431
4450: oJumpForward 4454
4452: oJumpBack 4429
4454: oReturn
4455: oLocalSpace 3
4457: oTypeSNodeType
4458: oChoice 4462
4460: oJumpForward 4467
4462: Choice Lookup Table
          24   4460
4465: oError 10
4467: oTypeSNodeType
4468: oChoice 4472
4470: oJumpForward 4477
4472: Choice Lookup Table
          24   4470
4475: oError 13
4477: oGetAddrLocal 1
4479: oPushResult
4480: oTypeSTop
4481: oPushResult
4482: oSetResult 24
4484: oPushResult
4485: oNodeGet
4486: oPop 2
4488: oPushResult
4489: oCall 6716
4491: oPop 1
4493: oAssign
4494: oGetAddrLocal 2
4496: oPushResult
4497: oTypeSTop
4498: oPushResult
4499: oSetResult 23
4501: oPushResult
4502: oNodeGet
4503: oPop 2
4505: oAssign
4506: oTypeSPop
4507: oGetLocal 2
4509: oPushResult
4510: oTypeSPush
4511: oPop 1
4513: oCall 2404
4515: oCall 6516
4517: oGetLocal 1
4519: oPushResult
4520: equal_zero
4521: oPop 1
4523: oChoice 4537
4525: oEmit 15
4527: oGetLocal 1
4529: oPushResult
4530: oEmitInt
4531: oPop 1
4533: oEmit 35
4535: oJumpForward 4540
4537: Choice Lookup Table
           0   4525
4540: oGetAddrLocal 3
4542: oPushResult
4543: oGetLocal 2
4545: oPushResult
4546: oSetResult 3
4548: oPushResult
4549: oNodeGetInt
4550: oPop 2
4552: oAssign
4553: oGetLocal 3
4555: oPushResult
4556: oSetResult 1
4558: oPushResult
4559: equal
4560: oPop 2
4562: oChoice 4576
4564: oEmit 15
4566: oGetLocal 3
4568: oPushResult
4569: oEmitInt
4570: oPop 1
4572: oEmit 31
4574: oJumpForward 4579
4576: Choice Lookup Table
           0   4564
4579: oEmit 33
4581: oInputChoice 4589
4583: oJumpForward 4597
4585: oJumpForward 4595
4587: oJumpForward 4595
4589: Choice Lookup Table
          12   4587
          16   4583
4594: oEndChoice
4595: oJumpBack 4467
4597: oReturn
4598: oLocalSpace 2
4600: oTypeSNodeType
4601: oChoice 4605
4603: oJumpForward 4610
4605: Choice Lookup Table
          26   4603
4608: oError 11
4610: oTypeSTop
4611: oPushResult
4612: oSetResult 27
4614: oPushResult
4615: oNodeGet
4616: oPop 2
4618: oPushResult
4619: oScopeEnter
4620: oPop 1
4622: oInput 0
4624: oGetAddrLocal 1
4626: oPushResult
4627: oScopeFindRequire
4628: oAssign
4629: oGetLocal 1
4631: oPushResult
4632: oNodeType
4633: oPop 1
4635: oChoice 4639
4637: oJumpForward 4644
4639: Choice Lookup Table
          14   4637
4642: oError 12
4644: oScopeEnd
4645: oGetAddrLocal 2
4647: oPushResult
4648: oGetLocal 1
4650: oPushResult
4651: oSetResult 9
4653: oPushResult
4654: oNodeGetInt
4655: oPop 2
4657: oAssign
4658: oGetLocal 2
4660: oPushResult
4661: equal_zero
4662: oPop 1
4664: oChoice 4678
4666: oEmit 15
4668: oGetLocal 2
4670: oPushResult
4671: oEmitInt
4672: oPop 1
4674: oEmit 33
4676: oJumpForward 4681
4678: Choice Lookup Table
           0   4666
4681: oTypeSPop
4682: oGetLocal 1
4684: oPushResult
4685: oSetResult 8
4687: oPushResult
4688: oNodeGet
4689: oPop 2
4691: oPushResult
4692: oTypeSPush
4693: oPop 1
4695: oReturn
4696: oLocalSpace 1
4698: oTypeSNodeType
4699: oChoice 4703
4701: oJumpForward 4708
4703: Choice Lookup Table
          23   4701
4706: oError 9
4708: oEmit 24
4710: oGetAddrLocal 1
4712: oPushResult
4713: oTypeSTop
4714: oAssign
4715: oTypeSPop
4716: oGetLocal 1
4718: oPushResult
4719: oSetResult 23
4721: oPushResult
4722: oNodeGet
4723: oPop 2
4725: oPushResult
4726: oTypeSPush
4727: oPop 1
4729: oReturn
4730: oLocalSpace 0
4732: oCall 6490
4734: oReturn
4735: oLocalSpace 2
4737: oGetAddrLocal 2
4739: oPushResult
4740: oGetParam 1
4742: oPushResult
4743: oSetResult 15
4745: oPushResult
4746: oNodeGetString
4747: oPop 2
4749: oAssign
4750: oGetLocal 2
4752: oPushResult
4753: oSetResult 0
4755: oPushResult
4756: equal_string
4757: oPop 2
4759: oChoice 4796
4761: oGetAddrLocal 1
4763: oPushResult
4764: oGetParam 1
4766: oPushResult
4767: oSetResult 7
4769: oPushResult
4770: oNodeGetInt
4771: oPop 2
4773: oPushResult
4774: ID_STRING
4775: oPop 1
4777: oPushResult
4778: oStringAllocLit
4779: oPop 1
4781: oAssign
4782: oJumpForward 4802
4784: oGetAddrLocal 1
4786: oPushResult
4787: oGetLocal 2
4789: oPushResult
4790: oStringAllocLit
4791: oPop 1
4793: oAssign
4794: oJumpForward 4802
4796: Choice Lookup Table
           0   4784
           1   4761
4801: oEndChoice
4802: oEmit 58
4804: oGetParam 1
4806: oPushResult
4807: oCall 6767
4809: oPop 1
4811: oGetLocal 1
4813: oPushResult
4814: oEmitInt
4815: oPop 1
4817: oReturn
4818: oLocalSpace 10
4820: oGetParam 1
4822: oPushResult
4823: oSetResult 14
4825: oPushResult
4826: oNodeGetBoolean
4827: oPop 2
4829: oChoice 4856
4831: oGetParam 1
4833: oPushResult
4834: oSetResult 17
4836: oPushResult
4837: oNodeGetBoolean
4838: oPop 2
4840: oChoice 4851
4842: oGetParam 1
4844: oPushResult
4845: oCall 4735
4847: oPop 1
4849: oJumpForward 4854
4851: Choice Lookup Table
           0   4842
4854: oJumpForward 4859
4856: Choice Lookup Table
           1   4831
4859: oGetParam 1
4861: oPushResult
4862: oSetResult 17
4864: oPushResult
4865: oSetResult 1
4867: oPushResult
4868: oNodeSetBoolean
4869: oPop 3
4871: oGetAddrLocal 1
4873: oPushResult
4874: oGetParam 1
4876: oPushResult
4877: oSetResult 16
4879: oPushResult
4880: oNodeGetBoolean
4881: oPop 2
4883: oAssign
4884: oGetAddrLocal 4
4886: oPushResult
4887: oGetParam 1
4889: oPushResult
4890: oNodeType
4891: oPop 1
4893: oPushResult
4894: oSetResult 8
4896: oPushResult
4897: equal_node_type
4898: oPop 2
4900: oAssign
4901: oGetLocal 4
4903: oChoice 4930
4905: oGetAddrLocal 2
4907: oPushResult
4908: oGetParam 1
4910: oPushResult
4911: oSetResult 8
4913: oPushResult
4914: oNodeGet
4915: oPop 2
4917: oAssign
4918: oGetAddrLocal 3
4920: oPushResult
4921: oGetLocal 2
4923: oPushResult
4924: oScopeAllocType
4925: oPop 1
4927: oAssign
4928: oJumpForward 4933
4930: Choice Lookup Table
           1   4905
4933: oGetAddrLocal 5
4935: oPushResult
4936: oGetParam 1
4938: oPushResult
4939: oSetResult 11
4941: oPushResult
4942: oNodeGet
4943: oPop 2
4945: oAssign
4946: oGetAddrLocal 6
4948: oPushResult
4949: oGetLocal 5
4951: oPushResult
4952: oSetResult 3
4954: oPushResult
4955: oNodeGetInt
4956: oPop 2
4958: oAssign
4959: oGetLocal 1
4961: oChoice 4983
4963: oEmit 47
4965: oGetLocal 6
4967: oPushResult
4968: oEmitInt
4969: oPop 1
4971: oJumpForward 4989
4973: oEmit 46
4975: oGetLocal 6
4977: oPushResult
4978: oEmitInt
4979: oPop 1
4981: oJumpForward 4989
4983: Choice Lookup Table
           0   4973
           1   4963
4988: oEndChoice
4989: oGetParam 1
4991: oPushResult
4992: oCall 6446
4994: oPop 1
4996: oPushResult
4997: oSetResult 0
4999: oPushResult
5000: greater
5001: oPop 2
5003: oChoice 5036
5005: oEmit 19
5007: oSetResult 0
5009: oPushResult
5010: oEmitInt
5011: oPop 1
5013: oEmit 20
5015: oGetParam 1
5017: oPushResult
5018: oCall 6466
5020: oPop 1
5022: oPushResult
5023: oEmitInt
5024: oPop 1
5026: oSetResult 0
5028: oPushResult
5029: oEmitInt
5030: oPop 1
5032: oEmit 27
5034: oJumpForward 5039
5036: Choice Lookup Table
           1   5005
5039: oGetAddrLocal 7
5041: oPushResult
5042: oGetLocal 5
5044: oPushResult
5045: oSetResult 2
5047: oPushResult
5048: oNodeGetIter
5049: oPop 2
5051: oAssign
5052: oGetAddrLocal 8
5054: oPushResult
5055: oGetLocal 7
5057: oPushResult
5058: oNodeIterValue
5059: oPop 1
5061: oAssign
5062: oInputChoice 5241
5064: oGetLocal 8
5066: oPushResult
5067: oNodeNull
5068: oPop 1
5070: oChoice 5076
5072: oJumpForward 5237
5074: oJumpForward 5079
5076: Choice Lookup Table
           1   5072
5079: oGetAddrLocal 9
5081: oPushResult
5082: oGetLocal 8
5084: oPushResult
5085: oSetResult 9
5087: oPushResult
5088: oNodeGetInt
5089: oPop 2
5091: oAssign
5092: oEmit 19
5094: oGetLocal 9
5096: oPushResult
5097: oEmitInt
5098: oPop 1
5100: oGetLocal 8
5102: oPushResult
5103: oSetResult 8
5105: oPushResult
5106: oNodeGet
5107: oPop 2
5109: oPushResult
5110: oTypeSPush
5111: oPop 1
5113: oGetLocal 8
5115: oPushResult
5116: oSetResult 21
5118: oPushResult
5119: oNodeGetBoolean
5120: oPop 2
5122: oChoice 5190
5124: oCall 5729
5126: oCall 6490
5128: oEmit 27
5130: oJumpForward 5196
5132: oCall 2404
5134: oCall 4730
5136: oTypeSNodeType
5137: oChoice 5155
5139: oEmit 25
5141: oJumpForward 5188
5143: oEmit 26
5145: oJumpForward 5188
5147: oError 16
5149: oJumpForward 5188
5151: oEmit 27
5153: oJumpForward 5188
5155: Choice Lookup Table
          23   5151
          17   5147
          22   5147
          21   5147
          19   5143
          18   5139
5168: oGetAddrLocal 10
5170: oPushResult
5171: oTypeSTop
5172: oPushResult
5173: oSetResult 3
5175: oPushResult
5176: oNodeGetInt
5177: oPop 2
5179: oAssign
5180: oEmit 28
5182: oGetLocal 10
5184: oPushResult
5185: oEmitInt
5186: oPop 1
5188: oJumpForward 5196
5190: Choice Lookup Table
           0   5132
           1   5124
5195: oEndChoice
5196: oTypeSPop
5197: oGetAddrLocal 7
5199: oPushResult
5200: oNodeIterNext
5201: oPop 1
5203: oGetAddrLocal 8
5205: oPushResult
5206: oGetLocal 7
5208: oPushResult
5209: oNodeIterValue
5210: oPop 1
5212: oAssign
5213: oGetLocal 8
5215: oPushResult
5216: oNodeNull
5217: oPop 1
5219: oChoice 5227
5221: oJumpForward 5237
5223: oJumpForward 5233
5225: oJumpForward 5233
5227: Choice Lookup Table
           0   5225
           1   5221
5232: oEndChoice
5233: oInput 12
5235: oJumpBack 5064
5237: oInput 14
5239: oJumpForward 5244
5241: Choice Lookup Table
          13   5064
5244: oGetLocal 8
5246: oPushResult
5247: oNodeNull
5248: oPop 1
5250: oChoice 5256
5252: oError 15
5254: oJumpForward 5259
5256: Choice Lookup Table
           0   5252
5259: oGetLocal 4
5261: oChoice 5290
5263: oEmit 19
5265: oGetParam 1
5267: oPushResult
5268: oSetResult 20
5270: oPushResult
5271: oNodeGetInt
5272: oPop 2
5274: oPushResult
5275: oEmitInt
5276: oPop 1
5278: oEmit 17
5280: oGetLocal 3
5282: oPushResult
5283: oEmitInt
5284: oPop 1
5286: oEmit 27
5288: oJumpForward 5293
5290: Choice Lookup Table
           1   5263
5293: oGetLocal 1
5295: oChoice 5319
5297: oEmit 50
5299: oGetParam 1
5301: oPushResult
5302: oCall 6767
5304: oPop 1
5306: oJumpForward 5325
5308: oEmit 49
5310: oGetParam 1
5312: oPushResult
5313: oCall 6767
5315: oPop 1
5317: oJumpForward 5325
5319: Choice Lookup Table
           0   5308
           1   5297
5324: oEndChoice
5325: oGetLocal 4
5327: oChoice 5395
5329: oGetLocal 2
5331: oPushResult
5332: oTypeSPush
5333: oPop 1
5335: oTypeSNodeType
5336: oChoice 5372
5338: oEmit 3
5340: oGetLocal 3
5342: oPushResult
5343: oEmitInt
5344: oPop 1
5346: oJumpForward 5393
5348: oEmit 4
5350: oGetLocal 3
5352: oPushResult
5353: oEmitInt
5354: oPop 1
5356: oJumpForward 5393
5358: oError 16
5360: oJumpForward 5393
5362: oEmit 5
5364: oGetLocal 3
5366: oPushResult
5367: oEmitInt
5368: oPop 1
5370: oJumpForward 5393
5372: Choice Lookup Table
          23   5362
          17   5358
          22   5358
          21   5358
          19   5348
          18   5338
5385: oEmit 17
5387: oGetLocal 3
5389: oPushResult
5390: oEmitInt
5391: oPop 1
5393: oJumpForward 5398
5395: Choice Lookup Table
           1   5329
5398: oEmit 48
5400: oGetLocal 6
5402: oPushResult
5403: oEmitInt
5404: oPop 1
5406: oReturn
5407: oLocalSpace 0
5409: oInputChoice 5459
5411: oCall 6366
5413: oJumpForward 5484
5415: oCall 6373
5417: oJumpForward 5484
5419: oCall 6440
5421: oJumpForward 5484
5423: oCall 6443
5425: oJumpForward 5484
5427: oCall 5906
5429: oJumpForward 5484
5431: oCall 6226
5433: oJumpForward 5484
5435: oCall 5972
5437: oJumpForward 5484
5439: oCall 6146
5441: oJumpForward 5484
5443: oCall 6311
5445: oJumpForward 5484
5447: oCall 6279
5449: oJumpForward 5484
5451: oCall 6343
5453: oJumpForward 5484
5455: oCall 5485
5457: oJumpForward 5484
5459: Choice Lookup Table
           0   5455
          33   5451
          49   5447
          50   5443
          47   5439
          42   5435
          46   5431
          39   5427
          57   5423
          56   5419
          55   5415
          54   5411
5484: oReturn
5485: oLocalSpace 1
5487: oGetAddrLocal 1
5489: oPushResult
5490: oScopeFindRequire
5491: oAssign
5492: oGetLocal 1
5494: oPushResult
5495: oNodeType
5496: oPop 1
5498: oChoice 5527
5500: oGetLocal 1
5502: oPushResult
5503: oCall 4818
5505: oPop 1
5507: oJumpForward 5540
5509: oGetLocal 1
5511: oPushResult
5512: oCall 5541
5514: oPop 1
5516: oJumpForward 5540
5518: oGetLocal 1
5520: oPushResult
5521: oCall 5615
5523: oPop 1
5525: oJumpForward 5540
5527: Choice Lookup Table
           8   5518
          15   5509
          13   5509
          12   5509
           7   5500
5538: oError 0
5540: oReturn
5541: oLocalSpace 0
5543: oGetParam 1
5545: oPushResult
5546: oCall 5765
5548: oPop 1
5550: oInput 3
5552: oCall 2404
5554: oCall 6490
5556: oCall 5559
5558: oReturn
5559: oLocalSpace 1
5561: oTypeSNodeType
5562: oChoice 5580
5564: oEmit 25
5566: oJumpForward 5613
5568: oEmit 26
5570: oJumpForward 5613
5572: oError 16
5574: oJumpForward 5613
5576: oEmit 27
5578: oJumpForward 5613
5580: Choice Lookup Table
          23   5576
          17   5572
          22   5572
          21   5572
          19   5568
          18   5564
5593: oGetAddrLocal 1
5595: oPushResult
5596: oTypeSTop
5597: oPushResult
5598: oSetResult 3
5600: oPushResult
5601: oNodeGetInt
5602: oPop 2
5604: oAssign
5605: oEmit 28
5607: oGetLocal 1
5609: oPushResult
5610: oEmitInt
5611: oPop 1
5613: oTypeSPop
5614: oReturn
5615: oLocalSpace 1
5617: oGetParam 1
5619: oPushResult
5620: oSetResult 12
5622: oPushResult
5623: oNodeGet
5624: oPop 2
5626: oPushResult
5627: oScopeCurrent
5628: oPushResult
5629: oNodeEqual
5630: oPop 2
5632: oChoice 5638
5634: oError 20
5636: oJumpForward 5641
5638: Choice Lookup Table
           0   5634
5641: oEmit 8
5643: oGetParam 1
5645: oPushResult
5646: oSetResult 20
5648: oPushResult
5649: oNodeGetInt
5650: oPop 2
5652: oPushResult
5653: oEmitInt
5654: oPop 1
5656: oGetParam 1
5658: oPushResult
5659: oSetResult 8
5661: oPushResult
5662: oNodeGet
5663: oPop 2
5665: oPushResult
5666: oTypeSPush
5667: oPop 1
5669: oInput 3
5671: oCall 2404
5673: oCall 6490
5675: oTypeSNodeType
5676: oChoice 5694
5678: oEmit 25
5680: oJumpForward 5727
5682: oEmit 26
5684: oJumpForward 5727
5686: oError 16
5688: oJumpForward 5727
5690: oEmit 27
5692: oJumpForward 5727
5694: Choice Lookup Table
          23   5690
          17   5686
          22   5686
          21   5686
          19   5682
          18   5678
5707: oGetAddrLocal 1
5709: oPushResult
5710: oTypeSTop
5711: oPushResult
5712: oSetResult 3
5714: oPushResult
5715: oNodeGetInt
5716: oPop 2
5718: oAssign
5719: oEmit 28
5721: oGetLocal 1
5723: oPushResult
5724: oEmitInt
5725: oPop 1
5727: oTypeSPop
5728: oReturn
5729: oLocalSpace 1
5731: oInput 0
5733: oGetAddrLocal 1
5735: oPushResult
5736: oScopeFindRequire
5737: oAssign
5738: oGetLocal 1
5740: oPushResult
5741: oNodeType
5742: oPop 1
5744: oChoice 5748
5746: oJumpForward 5757
5748: Choice Lookup Table
          15   5746
          13   5746
          12   5746
5755: oError 4
5757: oGetLocal 1
5759: oPushResult
5760: oCall 5765
5762: oPop 1
5764: oReturn
5765: oLocalSpace 0
5767: oGetParam 1
5769: oPushResult
5770: oNodeType
5771: oPop 1
5773: oChoice 5833
5775: oEmit 16
5777: oGetParam 1
5779: oPushResult
5780: oCall 6767
5782: oPop 1
5784: oJumpForward 5842
5786: oEmit 17
5788: oGetParam 1
5790: oPushResult
5791: oCall 6767
5793: oPop 1
5795: oJumpForward 5842
5797: oGetParam 1
5799: oPushResult
5800: oSetResult 21
5802: oPushResult
5803: oNodeGetBoolean
5804: oPop 2
5806: oChoice 5819
5808: oEmit 8
5810: oGetParam 1
5812: oPushResult
5813: oCall 6767
5815: oPop 1
5817: oJumpForward 5831
5819: Choice Lookup Table
           1   5808
5822: oEmit 18
5824: oGetParam 1
5826: oPushResult
5827: oCall 6767
5829: oPop 1
5831: oJumpForward 5842
5833: Choice Lookup Table
          15   5797
          13   5786
          12   5775
5840: oError 4
5842: oGetParam 1
5844: oPushResult
5845: oSetResult 8
5847: oPushResult
5848: oNodeGet
5849: oPop 2
5851: oPushResult
5852: oTypeSPush
5853: oPop 1
5855: oCall 4427
5857: oReturn
5858: oLocalSpace 0
5860: oGetParam 1
5862: oPushResult
5863: oCall 5765
5865: oPop 1
5867: oCall 6516
5869: oGetParam 1
5871: oPushResult
5872: oCall 3666
5874: oPop 1
5876: oTypeSPop
5877: oEmit 29
5879: oEmit 25
5881: oReturn
5882: oLocalSpace 0
5884: oGetParam 1
5886: oPushResult
5887: oCall 5765
5889: oPop 1
5891: oCall 6516
5893: oGetParam 1
5895: oPushResult
5896: oCall 3666
5898: oPop 1
5900: oTypeSPop
5901: oEmit 30
5903: oEmit 25
5905: oReturn
5906: oLocalSpace 2
5908: oGetAddrLocal 1
5910: oPushResult
5911: oSetResult 0
5913: oAssign
5914: oGetAddrLocal 1
5916: oPushResult
5917: oCall 2427
5919: oPop 1
5921: oInput 40
5923: oCall 5407
5925: oInputChoice 5960
5927: oGetAddrLocal 2
5929: oPushResult
5930: oLabelNew
5931: oAssign
5932: oEmit 53
5934: oGetLocal 2
5936: oPushResult
5937: oEmitLabel
5938: oPop 1
5940: oEmit 56
5942: oGetLocal 1
5944: oPushResult
5945: oEmitLabel
5946: oPop 1
5948: oCall 5407
5950: oEmit 56
5952: oGetLocal 2
5954: oPushResult
5955: oEmitLabel
5956: oPop 1
5958: oJumpForward 5971
5960: Choice Lookup Table
          41   5927
5963: oEmit 56
5965: oGetLocal 1
5967: oPushResult
5968: oEmitLabel
5969: oPop 1
5971: oReturn
5972: oLocalSpace 4
5974: oInput 0
5976: oGetAddrLocal 1
5978: oPushResult
5979: oScopeFindRequire
5980: oAssign
5981: oGetLocal 1
5983: oPushResult
5984: oCall 5765
5986: oPop 1
5988: oCall 6516
5990: oInput 3
5992: oCall 2404
5994: oCall 6516
5996: oEmit 25
5998: oGetAddrLocal 2
6000: oPushResult
6001: oLabelNew
6002: oAssign
6003: oGetAddrLocal 3
6005: oPushResult
6006: oLabelNew
6007: oAssign
6008: oEmit 53
6010: oGetLocal 3
6012: oPushResult
6013: oEmitLabel
6014: oPop 1
6016: oGetAddrLocal 4
6018: oPushResult
6019: oLabelNew
6020: oAssign
6021: oEmit 56
6023: oGetLocal 4
6025: oPushResult
6026: oEmitLabel
6027: oPop 1
6029: oInputChoice 6109
6031: oGetLocal 1
6033: oPushResult
6034: oCall 5858
6036: oPop 1
6038: oEmit 56
6040: oGetLocal 3
6042: oPushResult
6043: oEmitLabel
6044: oPop 1
6046: oGetLocal 1
6048: oPushResult
6049: oCall 3666
6051: oPop 1
6053: oTypeSPop
6054: oCall 2404
6056: oCall 6516
6058: oEmit 40
6060: oEmit 54
6062: oGetLocal 2
6064: oPushResult
6065: oEmitLabel
6066: oPop 1
6068: oJumpForward 6115
6070: oGetLocal 1
6072: oPushResult
6073: oCall 5882
6075: oPop 1
6077: oEmit 56
6079: oGetLocal 3
6081: oPushResult
6082: oEmitLabel
6083: oPop 1
6085: oGetLocal 1
6087: oPushResult
6088: oCall 3666
6090: oPop 1
6092: oTypeSPop
6093: oCall 2404
6095: oCall 6516
6097: oEmit 41
6099: oEmit 54
6101: oGetLocal 2
6103: oPushResult
6104: oEmitLabel
6105: oPop 1
6107: oJumpForward 6115
6109: Choice Lookup Table
          44   6070
          43   6031
6114: oEndChoice
6115: oGetLocal 4
6117: oPushResult
6118: oGetLocal 2
6120: oPushResult
6121: oLoopPush
6122: oPop 2
6124: oInput 45
6126: oCall 5407
6128: oEmit 53
6130: oGetLocal 4
6132: oPushResult
6133: oEmitLabel
6134: oPop 1
6136: oEmit 56
6138: oGetLocal 2
6140: oPushResult
6141: oEmitLabel
6142: oPop 1
6144: oLoopPop
6145: oReturn
6146: oLocalSpace 3
6148: oGetAddrLocal 1
6150: oPushResult
6151: oLabelNew
6152: oAssign
6153: oEmit 56
6155: oGetLocal 1
6157: oPushResult
6158: oEmitLabel
6159: oPop 1
6161: oGetAddrLocal 2
6163: oPushResult
6164: oLabelNew
6165: oAssign
6166: oGetLocal 1
6168: oPushResult
6169: oGetLocal 2
6171: oPushResult
6172: oLoopPush
6173: oPop 2
6175: oCall 5407
6177: oInputChoice 6208
6179: oCall 5407
6181: oJumpForward 6214
6183: oGetAddrLocal 3
6185: oPushResult
6186: oCall 2427
6188: oPop 1
6190: oEmit 57
6192: oGetLocal 3
6194: oPushResult
6195: oEmitLabel
6196: oPop 1
6198: oGetLocal 1
6200: oPushResult
6201: oEmitLabel
6202: oPop 1
6204: oJumpForward 6216
6206: oJumpForward 6214
6208: Choice Lookup Table
          48   6183
           4   6179
6213: oEndChoice
6214: oJumpBack 6177
6216: oEmit 56
6218: oGetLocal 2
6220: oPushResult
6221: oEmitLabel
6222: oPop 1
6224: oLoopPop
6225: oReturn
6226: oLocalSpace 2
6228: oGetAddrLocal 1
6230: oPushResult
6231: oLabelNew
6232: oAssign
6233: oEmit 56
6235: oGetLocal 1
6237: oPushResult
6238: oEmitLabel
6239: oPop 1
6241: oGetAddrLocal 2
6243: oPushResult
6244: oCall 2427
6246: oPop 1
6248: oGetLocal 1
6250: oPushResult
6251: oGetLocal 2
6253: oPushResult
6254: oLoopPush
6255: oPop 2
6257: oInput 45
6259: oCall 5407
6261: oEmit 53
6263: oGetLocal 1
6265: oPushResult
6266: oEmitLabel
6267: oPop 1
6269: oEmit 56
6271: oGetLocal 2
6273: oPushResult
6274: oEmitLabel
6275: oPop 1
6277: oLoopPop
6278: oReturn
6279: oLocalSpace 0
6281: oLoopContinueLabel
6282: oPushResult
6283: oSetResult 0
6285: oPushResult
6286: equal_label
6287: oPop 2
6289: oChoice 6304
6291: oError 18
6293: oJumpForward 6310
6295: oEmit 53
6297: oLoopContinueLabel
6298: oPushResult
6299: oEmitLabel
6300: oPop 1
6302: oJumpForward 6310
6304: Choice Lookup Table
           0   6295
           1   6291
6309: oEndChoice
6310: oReturn
6311: oLocalSpace 0
6313: oLoopBreakLabel
6314: oPushResult
6315: oSetResult 0
6317: oPushResult
6318: equal_label
6319: oPop 2
6321: oChoice 6336
6323: oError 18
6325: oJumpForward 6342
6327: oEmit 53
6329: oLoopBreakLabel
6330: oPushResult
6331: oEmitLabel
6332: oPop 1
6334: oJumpForward 6342
6336: Choice Lookup Table
           0   6327
           1   6323
6341: oEndChoice
6342: oReturn
6343: oLocalSpace 0
6345: oCall 5407
6347: oInputChoice 6357
6349: oCall 5407
6351: oJumpForward 6363
6353: oJumpForward 6365
6355: oJumpForward 6363
6357: Choice Lookup Table
          34   6353
           4   6349
6362: oEndChoice
6363: oJumpBack 6347
6365: oReturn
6366: oLocalSpace 0
6368: oCall 6373
6370: oEmit 63
6372: oReturn
6373: oLocalSpace 0
6375: oInputChoice 6436
6377: oCall 2404
6379: oTypeSNodeType
6380: oChoice 6402
6382: oEmit 59
6384: oJumpForward 6417
6386: oEmit 60
6388: oJumpForward 6417
6390: oEmit 61
6392: oJumpForward 6417
6394: oError 16
6396: oJumpForward 6417
6398: oEmit 62
6400: oJumpForward 6417
6402: Choice Lookup Table
          23   6398
          17   6394
          21   6394
          22   6390
          19   6386
          18   6382
6415: oError 17
6417: oTypeSPop
6418: oInputChoice 6426
6420: oJumpForward 6434
6422: oJumpForward 6432
6424: oJumpForward 6432
6426: Choice Lookup Table
          12   6424
          14   6420
6431: oEndChoice
6432: oJumpBack 6377
6434: oJumpForward 6439
6436: Choice Lookup Table
          13   6377
6439: oReturn
6440: oLocalSpace 0
6442: oReturn
6443: oLocalSpace 0
6445: oReturn
6446: oLocalSpace 0
6448: oGetParam 1
6450: oPushResult
6451: oSetResult 6
6453: oPushResult
6454: oNodeGet
6455: oPop 2
6457: oPushResult
6458: oSetResult 1
6460: oPushResult
6461: oNodeGetInt
6462: oPop 2
6464: oReturn
6465: oReturn
6466: oLocalSpace 0
6468: oScopeCurrent
6469: oPushResult
6470: oSetResult 1
6472: oPushResult
6473: oNodeGetInt
6474: oPop 2
6476: oPushResult
6477: oGetParam 1
6479: oPushResult
6480: oCall 6446
6482: oPop 1
6484: oPushResult
6485: subtract
6486: oPop 2
6488: oReturn
6489: oReturn
6490: oLocalSpace 1
6492: oGetAddrLocal 1
6494: oPushResult
6495: oTypeSNodeType
6496: oAssign
6497: oTypeSPop
6498: oGetLocal 1
6500: oPushResult
6501: oTypeSNodeType
6502: oPushResult
6503: equal_node_type
6504: oPop 2
6506: oChoice 6512
6508: oError 14
6510: oJumpForward 6515
6512: Choice Lookup Table
           0   6508
6515: oReturn
6516: oLocalSpace 0
6518: oTypeSNodeType
6519: oChoice 6523
6521: oJumpForward 6528
6523: Choice Lookup Table
          18   6521
6526: oError 7
6528: oTypeSPop
6529: oReturn
6530: oLocalSpace 0
6532: oTypeSNodeType
6533: oChoice 6537
6535: oJumpForward 6542
6537: Choice Lookup Table
          18   6535
6540: oError 7
6542: oReturn
6543: oLocalSpace 0
6545: oTypeSNodeType
6546: oChoice 6550
6548: oJumpForward 6555
6550: Choice Lookup Table
          19   6548
6553: oError 8
6555: oTypeSPop
6556: oReturn
6557: oLocalSpace 0
6559: oTypeSNodeType
6560: oChoice 6564
6562: oJumpForward 6569
6564: Choice Lookup Table
          19   6562
6567: oError 8
6569: oReturn
6570: oLocalSpace 1
6572: oGetAddrLocal 1
6574: oPushResult
6575: oGetParam 2
6577: oPushResult
6578: oNodeNew
6579: oPop 1
6581: oAssign
6582: oGetLocal 1
6584: oPushResult
6585: oSetResult 3
6587: oPushResult
6588: oGetParam 1
6590: oPushResult
6591: oNodeSetInt
6592: oPop 3
6594: oGetLocal 1
6596: oPushResult
6597: oTypeAdd
6598: oPop 1
6600: oGetLocal 1
6602: oReturn
6603: oReturn
6604: oLocalSpace 1
6606: oGetAddrLocal 1
6608: oPushResult
6609: oGetParam 3
6611: oPushResult
6612: oNodeNew
6613: oPop 1
6615: oAssign
6616: oGetLocal 1
6618: oPushResult
6619: oSetResult 7
6621: oPushResult
6622: oGetParam 1
6624: oPushResult
6625: oNodeSetInt
6626: oPop 3
6628: oGetLocal 1
6630: oReturn
6631: oReturn
6632: oLocalSpace 1
6634: oGetAddrLocal 1
6636: oPushResult
6637: oGetParam 1
6639: oPushResult
6640: oSetResult 22
6642: oPushResult
6643: oNodeGet
6644: oPop 2
6646: oAssign
6647: oGetLocal 1
6649: oPushResult
6650: oNodeNull
6651: oPop 1
6653: oChoice 6709
6655: oGetAddrLocal 1
6657: oPushResult
6658: oSetResult 23
6660: oPushResult
6661: oNodeNew
6662: oPop 1
6664: oAssign
6665: oGetLocal 1
6667: oPushResult
6668: oSetResult 23
6670: oPushResult
6671: oGetParam 1
6673: oPushResult
6674: oNodeSet
6675: oPop 3
6677: oGetLocal 1
6679: oPushResult
6680: oSetResult 3
6682: oPushResult
6683: oSetResult 8
6685: oPushResult
6686: oNodeSetInt
6687: oPop 3
6689: oGetLocal 1
6691: oPushResult
6692: oTypeAdd
6693: oPop 1
6695: oGetParam 1
6697: oPushResult
6698: oSetResult 22
6700: oPushResult
6701: oGetLocal 1
6703: oPushResult
6704: oNodeSet
6705: oPop 3
6707: oJumpForward 6712
6709: Choice Lookup Table
           1   6655
6712: oGetLocal 1
6714: oReturn
6715: oReturn
6716: oLocalSpace 0
6718: oGetParam 1
6720: oPushResult
6721: oNodeType
6722: oPop 1
6724: oChoice 6752
6726: oMININT
6727: oReturn
6728: oJumpForward 6766
6730: oSetResult 0
6732: oReturn
6733: oJumpForward 6766
6735: oSetResult 0
6737: oReturn
6738: oJumpForward 6766
6740: oGetParam 1
6742: oPushResult
6743: oSetResult 25
6745: oPushResult
6746: oNodeGetInt
6747: oPop 2
6749: oReturn
6750: oJumpForward 6766
6752: Choice Lookup Table
          25   6740
          21   6735
          19   6730
          18   6726
6761: oError 3
6763: oSetResult 0
6765: oReturn
6766: oReturn
6767: oLocalSpace 0
6769: oGetParam 1
6771: oPushResult
6772: oSetResult 9
6774: oPushResult
6775: oNodeGetInt
6776: oPop 2
6778: oPushResult
6779: oEmitInt
6780: oPop 1
6782: oReturn
6783: oLocalSpace 1
6785: oGetAddrGlobal 3
6787: oPushResult
6788: oSetResult 17
6790: oPushResult
6791: oSetResult 4
6793: oPushResult
6794: oCall 6570
6796: oPop 2
6798: oAssign
6799: oGetAddrGlobal 4
6801: oPushResult
6802: oSetResult 18
6804: oPushResult
6805: oSetResult 4
6807: oPushResult
6808: oCall 6570
6810: oPop 2
6812: oAssign
6813: oGetAddrGlobal 5
6815: oPushResult
6816: oSetResult 19
6818: oPushResult
6819: oSetResult 1
6821: oPushResult
6822: oCall 6570
6824: oPop 2
6826: oAssign
6827: oGetAddrGlobal 6
6829: oPushResult
6830: oSetResult 20
6832: oPushResult
6833: oSetResult 1
6835: oPushResult
6836: oCall 6570
6838: oPop 2
6840: oAssign
6841: oGetAddrGlobal 7
6843: oPushResult
6844: oSetResult 21
6846: oPushResult
6847: oSetResult 1
6849: oPushResult
6850: oCall 6570
6852: oPop 2
6854: oAssign
6855: oGetAddrGlobal 8
6857: oPushResult
6858: oSetResult 22
6860: oPushResult
6861: oSetResult 256
6863: oPushResult
6864: oCall 6570
6866: oPop 2
6868: oAssign
6869: oGetAddrLocal 1
6871: oPushResult
6872: oSetResult 10
6874: oPushResult
6875: oSetResult 5
6877: oPushResult
6878: oIdAdd_File
6879: oPushResult
6880: oCall 6604
6882: oPop 3
6884: oAssign
6885: oGetLocal 1
6887: oPushResult
6888: oSetResult 8
6890: oPushResult
6891: oGetGlobal 3
6893: oPushResult
6894: oNodeSet
6895: oPop 3
6897: oGetLocal 1
6899: oPushResult
6900: oScopeDeclare
6901: oPop 1
6903: oGetAddrLocal 1
6905: oPushResult
6906: oSetResult 10
6908: oPushResult
6909: oSetResult 5
6911: oPushResult
6912: oIdAdd_Integer
6913: oPushResult
6914: oCall 6604
6916: oPop 3
6918: oAssign
6919: oGetLocal 1
6921: oPushResult
6922: oSetResult 8
6924: oPushResult
6925: oGetGlobal 4
6927: oPushResult
6928: oNodeSet
6929: oPop 3
6931: oGetLocal 1
6933: oPushResult
6934: oScopeDeclare
6935: oPop 1
6937: oGetAddrLocal 1
6939: oPushResult
6940: oSetResult 10
6942: oPushResult
6943: oSetResult 5
6945: oPushResult
6946: oIdAdd_Boolean
6947: oPushResult
6948: oCall 6604
6950: oPop 3
6952: oAssign
6953: oGetLocal 1
6955: oPushResult
6956: oSetResult 8
6958: oPushResult
6959: oGetGlobal 5
6961: oPushResult
6962: oNodeSet
6963: oPop 3
6965: oGetLocal 1
6967: oPushResult
6968: oScopeDeclare
6969: oPop 1
6971: oGetAddrLocal 1
6973: oPushResult
6974: oSetResult 10
6976: oPushResult
6977: oSetResult 5
6979: oPushResult
6980: oIdAdd_Char
6981: oPushResult
6982: oCall 6604
6984: oPop 3
6986: oAssign
6987: oGetLocal 1
6989: oPushResult
6990: oSetResult 8
6992: oPushResult
6993: oGetGlobal 7
6995: oPushResult
6996: oNodeSet
6997: oPop 3
6999: oGetLocal 1
7001: oPushResult
7002: oScopeDeclare
7003: oPop 1
7005: oGetAddrLocal 1
7007: oPushResult
7008: oSetResult 10
7010: oPushResult
7011: oSetResult 5
7013: oPushResult
7014: oIdAdd_String
7015: oPushResult
7016: oCall 6604
7018: oPop 3
7020: oAssign
7021: oGetLocal 1
7023: oPushResult
7024: oSetResult 8
7026: oPushResult
7027: oGetGlobal 8
7029: oPushResult
7030: oNodeSet
7031: oPop 3
7033: oGetLocal 1
7035: oPushResult
7036: oScopeDeclare
7037: oPop 1
7039: oGetAddrLocal 1
7041: oPushResult
7042: oSetResult 9
7044: oPushResult
7045: oSetResult 4
7047: oPushResult
7048: oIdAdd_True
7049: oPushResult
7050: oCall 6604
7052: oPop 3
7054: oAssign
7055: oGetLocal 1
7057: oPushResult
7058: oSetResult 8
7060: oPushResult
7061: oGetGlobal 5
7063: oPushResult
7064: oNodeSet
7065: oPop 3
7067: oGetLocal 1
7069: oPushResult
7070: oSetResult 9
7072: oPushResult
7073: oSetResult 1
7075: oPushResult
7076: oNodeSetInt
7077: oPop 3
7079: oGetLocal 1
7081: oPushResult
7082: oScopeDeclare
7083: oPop 1
7085: oGetAddrLocal 1
7087: oPushResult
7088: oSetResult 9
7090: oPushResult
7091: oSetResult 4
7093: oPushResult
7094: oIdAdd_False
7095: oPushResult
7096: oCall 6604
7098: oPop 3
7100: oAssign
7101: oGetLocal 1
7103: oPushResult
7104: oSetResult 8
7106: oPushResult
7107: oGetGlobal 5
7109: oPushResult
7110: oNodeSet
7111: oPop 3
7113: oGetLocal 1
7115: oPushResult
7116: oSetResult 9
7118: oPushResult
7119: oSetResult 0
7121: oPushResult
7122: oNodeSetInt
7123: oPop 3
7125: oGetLocal 1
7127: oPushResult
7128: oScopeDeclare
7129: oPop 1
7131: oReturn
