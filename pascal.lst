   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tGreaterD         % double comparisions.  (equality uses EqualP, at least for now)
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nStrLitType :
2586:          decl = @newIdent( nConstStr, id )
2600:          oNodeSetString( decl, qValueStr, oValueTopString )
2611:       | * :  #eNotAllowed
2632:    ]
2632:    oValuePop
2633:    oNodeSet( decl, qType, oTypeSTop )
2644:    oTypeSPop
2645:    oScopeDeclare( decl )
2651:    ';'
2654:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2654: TypedConstDecl:
2656:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2669:    Node theType
2669:    @TypeRef( theType )
2676:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2688:    [ oNodeType( theType )
2695:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2696:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2696:          '='
      
2698:          oTypeSPush( theType )
2704:          @ConstExpr
2706:          @ConstCoerceType
      
2708:          oNodeSetInt( decl, qValue, oValueTop )
2719:          oValuePop
2720:          oTypeSPop
2721:          oScopeDeclare( decl )
2727:          ';'
      
2729:       | nShortStringType, nFileType :
2731:          #eNotImplemented
      
2733:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2735:          oScopeEnter( globalScope )
2741:          int addr = oScopeAllocType( theType )
2751:          oScopeEnd
2752:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2763:          oNodeSetInt( decl, qValue, addr )
2775:          '='
2777:          @TypedConstInit( theType, addr )
2787:          oCodePop
2788:          oScopeDeclare( decl )
2794:          ';'
2796:    ]
2823:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2823: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2825:    [ oNodeType( theType )
2832:       | nArrayType :
2833:          Node baseType = oNodeGet( theType, qBaseType )
2846:          Node indexType = oNodeGet( theType, qIndexType )
2859:          int low = @OrdinalLow( indexType )
2870:          int high = @OrdinalHigh( indexType )
2881:          int elementSize = oNodeGetInt( baseType, qSize )
      
2894:          '('
               % Loop over elements
2896:          int i = low
2902:          {
2902:             @TypedConstInit( baseType, addr )
2912:             [ equal( i, high )
2922:                | true : >
2925:                | false :
2927:             ]
2935:             ','
2937:             addr = add( addr, elementSize )
2950:             inc( i )
2956:          }
2958:          ')'
      
2960:       | nRecordType :
2962:          '('
2964:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2977:          {
2977:             [
2977:                | pIdent :
2979:                | * :  >
2986:             ]
2986:             Node field = oScopeFindRequireInScope( fieldScope )
2996:             ':'
2998:             Node fieldType = oNodeGet( field, qType )
3011:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3031:             @TypedConstInit( fieldType, fieldAddr )
3041:             [
3041:                | ';' :
3043:                | * :  >
3050:             ]
3050:          }
3052:          ')'
      
3054:       | nBooleanType, nByteType, nCharType:
3056:          .tPushAddrGlobal  oEmitInt( addr )
3064:          oTypeSPush( theType )
3070:          @ConstExpr
3072:          @ConstCoerceType
3074:          .tPushConstI  oEmitInt( oValueTop )
3081:          oValuePop
3082:          oTypeSPop
3083:          .tAssignB
      
3085:       | nIntegerType, nEnumType:
3087:          .tPushAddrGlobal  oEmitInt( addr )
3095:          oTypeSPush( theType )
3101:          @ConstExpr
3103:          @ConstCoerceType
3105:          .tPushConstI  oEmitInt( oValueTop )
3112:          oValuePop
3113:          oTypeSPop
3114:          .tAssignI
      
3116:       | nDoubleType:
3118:          #eNotImplemented
      
3120:       | nPointerType, nUniversalPointerType :
3122:          .tPushAddrGlobal  oEmitInt( addr )
3130:          oTypeSPush( theType )
3136:          @ConstExpr
3138:          @ConstCoerceType
3140:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3147:          oValuePop
3148:          oTypeSPop
3149:          .tAssignP
      
3151:       | nShortStringType, nFileType :
3153:          #eNotImplemented
3155:    ]
3184:    ;
      
      
3184: TypeDecl:
3186:    {[
3186:       | pIdent :
3188:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3201:          '='
3203:          Node theType
3203:          @TypeRef( theType )
3210:          oNodeSet( decl, qType, theType )
3222:          oScopeDeclare( decl )
3228:          ';'
3230:       | * :
3235:          >
3237:    ]};
      
3240: VarDecl( node_type varNodeType ):
3242:    {[
3242:       | pIdent :
3244:          NodeVec decls = oNodeVecNew
3249:          Node decl
3249:          {
3249:             decl = @newIdent( varNodeType, LAST_ID )
3262:             oNodeVecAppend( decls, decl )
3271:             [
3271:                | ',' :
3273:                   pIdent
3275:                | * :
3280:                   >
3282:             ]
3282:          }
3284:          ':'
3286:          Node theType
3286:          @TypeRef( theType )
      
3293:          int i = 0
3299:          {[ equal( i, oNodeVecSize( decls ) )
3313:             | false :
3314:                decl = oNodeVecElement( decls, i )
3327:                oNodeSet( decl, qType, theType )
3339:                oScopeDeclareAlloc( decl )
3345:                inc( i )
3351:             | * :
3356:               >
3358:          ]}
      
               % optional initialization
3360:          [
3360:             | '=' :
3362:                [ oNodeVecSize( decls )
3369:                   | 1 :
3370:                   | * :  #eOnlyOneVarCanBeInitialized
3377:                ]
      
                     % we need an initCode stream for this scope
3377:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3387:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3393:                boolean changedScope = false
3399:                [ equal_zero( @ScopeLevel )
3406:                   | true : oScopeEnter( initScope )
3413:                            changedScope = true
3419:                   | * :
3424:                ]
                     % generate assignment in initCode stream
3424:                @LValueVar( decl, true )
3434:                @Expr
3436:                @CoerceType
3438:                @Assign
3440:                [ changedScope
3443:                   | true : oScopeEnd
3445:                   | * :
3450:                ]
3450:                oCodePop
                   
3451:             | * :
3456:          ]
      
3456:          oNodeVecDelete( decls )
3462:          ';'
3464:       | * :
3469:          >
3471:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3474: LabelDecl:
3476:    {
3476:       Node decl
3476:       [
3476:          | pIdent :
3478:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3480:             oChangeIntLitToLabelIdent
3481:       ]
3489:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3502:       Label label = oLabelNew
3507:       oNodeSetLabel( decl, qValue, label )
3519:       oScopeDeclare( decl )
3525:       [
3525:          | ',' :
3527:          | * :
3532:             >
3534:       ]
3534:    }
3536:    ';'
3539:    ;
3539: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3539: ConstExpr:
3541:    @ConstBoolExpr
3543:    {[
3543:       | '=' :
3545:          @ConstBoolTerm
3547:          @ConstMatchTypes
3549:          [ oTypeSNodeType
3551:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3560:             | * :             oValueEqual
3566:          ]
3566:          oTypeSPop  oTypeSPush( BooleanType )
3573:       | '<>' :
3575:          @ConstBoolExpr
3577:          @ConstMatchTypes
3579:          [ oTypeSNodeType
3581:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3590:             | * :             oValueNotEqual
3596:          ]
3596:          oTypeSPop  oTypeSPush( BooleanType )
3603:       | '<' :
3605:          @ConstBoolExpr
3607:          @ConstMatchTypes
3609:          [ oTypeSNodeType
3611:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3620:             | * :             oValueLess
3626:          ]
3626:          oTypeSPop  oTypeSPush( BooleanType )
3633:       | '>' :
3635:          @ConstBoolExpr
3637:          @ConstMatchTypes
3639:          [ oTypeSNodeType
3641:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3650:             | * :             oValueGreater
3656:          ]
3656:          oTypeSPop  oTypeSPush( BooleanType )
3663:       | '<=' :
3665:          @ConstBoolExpr
3667:          @ConstMatchTypes
3669:          [ oTypeSNodeType
3671:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3680:             | * :             oValueLessEqual
3686:          ]
3686:          oTypeSPop  oTypeSPush( BooleanType )
3693:       | '>=' :
3695:          @ConstBoolExpr
3697:          @ConstMatchTypes
3699:          [ oTypeSNodeType
3701:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3710:             | * :             oValueGreaterEqual
3716:          ]
3716:          oTypeSPop  oTypeSPush( BooleanType )
3723:       | * :  >
3740:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3743: ConstExprAllowTypeName:
3745:    boolean oldAllowTypeName = flagExprAllowTypeName
3751:    flagExprAllowTypeName = true
3757:    @ConstExpr
3759:    flagExprAllowTypeName = oldAllowTypeName
3766:    ;
      
      
3766: ConstBoolExpr:
3768:    @ConstBoolTerm
3770:    {[
3770:       | pOr :
3772:          @ConstRequireBool
3774:          @ConstBoolTerm
3776:          @ConstRequireBoolPop
3778:          oValueOr
3779:       | * :  >
3786:    ]};
      
      
3789: ConstBoolTerm:
3791:    @ConstBoolFactor
3793:    {[
3793:       | pAnd :
3795:          @ConstRequireBool
3797:          @ConstBoolFactor
3799:          @ConstRequireBoolPop
3801:          oValueAnd
3802:       | * :  >
3809:    ]};
      
      
3812: ConstBoolFactor:
3814:    [
3814:       | pNot :
3816:          @ConstBoolFactor
3818:          @ConstRequireBool
3820:          oValueNot
3821:       | * :
3826:          @ConstArithExpr
3828:    ];
      
      
3829: ConstArithExpr:
3831:    @ConstTerm
3833:    {[
3833:       | '+' :
3835:          @ConstTerm
3837:          @ConstMatchTypes
3839:          [ oTypeSNodeType
3841:             | nStrLitType :   oValueStringConcat
3843:             | * :             oValueAdd
3849:          ]
3849:       | '-' :
3851:          @ConstTerm
3853:          @ConstMatchTypes
3855:          [ oTypeSNodeType
3857:             | nStrLitType :   #eNotAllowed
3860:             | * :             oValueSub
3866:          ]
3866:       | * :  >
3875:    ]};
      
      
3878: ConstTerm:
3880:    @ConstFactor
3882:    {[
3882:       | pTimes :
3884:          @ConstFactor
3886:          @ConstMatchTypes
3888:          [ oTypeSNodeType
3890:             | nStrLitType :   #eNotAllowed
3893:             | * :             oValueMult
3899:          ]
3899:       | pDivide :
3901:          @ConstFactor
3903:          @ConstMatchTypes
3905:          [ oTypeSNodeType
3907:             | nStrLitType :   #eNotAllowed
3910:             | * :             oValueDiv
3916:          ]
3916:       | * :  >
3925:    ]};
      
      
3928: ConstFactor:
3930:    [
3930:       | pPlus :
3932:          @ConstPrimary
3934:       | pMinus :
3936:          @ConstPrimary
3938:          oValueNegate
3939:       | * :
3946:          @ConstPrimary
3948:    ];
      
      
3949: ConstPrimary:
3951:    [
3951:       | pIntLit :
3953:          oValuePush( TOKEN_VALUE )
3958:          oTypeSPush( IntegerType )
3964:       | pCharLit :
3966:          oValuePush( TOKEN_VALUE )
3971:          oTypeSPush( CharType )
3977:       | pStrLit :
3979:          oValuePushString( CURRENT_STRLIT )
3984:          oTypeSPush( StrLitType )
3990:       | '(' :
3992:          @ConstExpr
3994:          ')'
3996:       | pIdent :
3998:          Node decl = oScopeFindRequire
4003:          @ResolveUnitRef( decl )
4010:          [ oNodeType( decl )
4017:             | nBuiltInFunc :
4018:                @ConstBuiltInFunc( decl )
4025:             | nConst :
4027:                oValuePush( oNodeGetInt( decl, qValue ) )
4040:                oTypeSPush( oNodeGet( decl, qType ) )
4053:             | nConstStr :
4055:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4068:                oTypeSPush( oNodeGet( decl, qType ) )
4081:             | nEnumValue :
4083:                oValuePush( oNodeGetInt( decl, qValue ) )
4096:                oTypeSPush( oNodeGet( decl, qType ) )
4109:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4111:                oTypeSPush( oNodeGet( decl, qType ) )
4124:                [
4124:                   | '(' :
                           % Type cast
4126:                      @ConstExpr
4128:                      ')'
4130:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4132:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4137:                      [ flagExprAllowTypeName
4140:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4141:                            oValuePush( 0 )
4147:                         | * :   #eTypeNameNotAllowedHere
4154:                      ]
4154:                ]
      
4154:             | * :
4167:                #eNotConst
4169:                oValuePush( 0 )
4175:                oTypeSPush( IntegerType )
4181:          ]
4181:       | '@' :
4183:          #eNotImplemented
4185:          oValuePush( 0 )
4191:          oTypeSPush( UniversalPointerType )
4197:       | * :
4212:          #eNotConst
4214:          oValuePush( 0 )
4220:          oTypeSPush( IntegerType )
4226:    ];
      
4227: ConstRequireBoolPop:
4229:    [ oTypeSNodeType
4231:       | nBooleanType :
4232:       | * :          #eNotBoolean
4239:    ]
4239:    oTypeSPop;
      
      
4241: ConstRequireBool:
4243:    [ oTypeSNodeType
4245:       | nBooleanType :
4246:       | * :          #eNotBoolean
4253:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4254: ConstMatchTypes:
4256:    node_type nt = oTypeSNodeType
4261:    oTypeSPop
4262:    [ equal_node_type( nt, oTypeSNodeType )
4271:       | false :
               % Some implicit conversion is allowed even here
4272:          [ oTypeSNodeType
4274:             | nPointerType :
4275:                [ nt
4278:                   | nUniversalPointerType :  >>
4280:                   | * :
4285:                ]
4285:             | nUniversalPointerType :
4287:                [ nt
4290:                   | nPointerType :  >>
4292:                   | * :
4297:                ]
4297:             | nStrLitType :
4299:                [ nt
4302:                   | nCharType :
4303:                      oValueCharToString
4304:                      >>
4305:                   | * :
4310:                ]
4310:             | nCharType :
4312:                [ nt
4315:                   | nStrLitType :
4316:                      oValueSwap
4317:                      oValueCharToString
4318:                      oValueSwap
4319:                      oTypeSPop
4320:                      oTypeSPush( StrLitType )
4326:                      >>
4327:                   | * :
4332:                ]
4332:             | * :
4343:          ]
4343:          #eTypeMismatch
4345:       | * :
4350:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4351: ConstCoerceType:
4353:    node_type nt = oTypeSNodeType
4358:    oTypeSPop
4359:    [ equal_node_type( nt, oTypeSNodeType )
4368:       | false :
               % Can we implicitly convert the value to the desired type?
4369:          [ oTypeSNodeType
4371:             | nIntegerType :
4372:                [ nt
4375:                   | nByteType :  >>
4377:                   | * :
4382:                ]
4382:             | nByteType :
4384:                [ nt
4387:                   | nIntegerType :  >>
4389:                   | * :
4394:                ]
4394:             | nPointerType :
4396:                [ nt
4399:                   | nUniversalPointerType :  >>
4401:                   | * :
4406:                ]
4406:             | nUniversalPointerType :
4408:                [ nt
4411:                   | nPointerType :  >>
4413:                   | * :
4418:                ]
4418:             | nStrLitType :
4420:                [ nt
4423:                   | nCharType :
4424:                      oValueCharToString
4425:                      >>
4426:                   | * :
4431:                ]
4431:             | nShortStringType :
4433:                [ nt
4436:                   | nStrLitType :  >>
4438:                   | nCharType :
4440:                      oValueCharToString
4441:                      >>
4442:                   | * :
4449:                ]
4449:             | * :
4464:          ]
4464:          #eTypeMismatch
4466:       | * :
4471:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4472: ConstCastType:
4474:    node_type nt = oTypeSNodeType
4479:    oTypeSPop
4480:    [ equal_node_type( nt, oTypeSNodeType )
4489:       | false :
               % Can we cast the value to the desired type?
4490:          [ oTypeSNodeType
4492:             | nIntegerType, nEnumType :
4493:                [ nt
4496:                   | nByteType, nCharType, nBooleanType :  >>
4498:                   | nIntegerType, nEnumType :  >>
4501:                   | * :
4514:                ]
4514:             | nByteType, nCharType, nBooleanType :
4516:                [ nt
4519:                   | nByteType, nCharType, nBooleanType :  >>
4521:                   | nIntegerType, nEnumType :  >>
4524:                   | * :
4537:                ]
4537:             | nPointerType :
4539:                [ nt
4542:                   | nUniversalPointerType :  >>
4544:                   | * :
4549:                ]
4549:             | nUniversalPointerType :
4551:                [ nt
4554:                   | nPointerType :  >>
4556:                   | * :
4561:                ]
4561:             | nStrLitType :
4563:                [ nt
4566:                   | nCharType :
4567:                      oValueCharToString
4568:                      >>
4569:                   | * :
4574:                ]
4574:             | nShortStringType :
4576:                [ nt
4579:                   | nStrLitType :  >>
4581:                   | nCharType :
4583:                      oValueCharToString
4584:                      >>
4585:                   | * :
4592:                ]
4592:             | * :
4613:          ]
4613:          #eTypeMismatch
4615:       | * :
4620:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4621: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4623:    [ oNodeEqual( method, BuiltIn_Ord )
4633:       | true :
4634:          '('
4636:          @ConstExpr
4638:          ')'
4640:          [ oTypeSNodeType
4642:             | nIntegerType, nEnumType :
4643:             | nBooleanType, nByteType, nCharType :
4645:             | * :  #eTypeMismatch
4660:          ]
4660:          oTypeSPop
4661:          oTypeSPush( IntegerType )
4667:          ')'
4669:          >>
4670:       | * :
4675:    ]
      
         % Chr(x)
4675:    [ oNodeEqual( method, BuiltIn_Chr )
4685:       | true :
4686:          '('
4688:          @ConstExpr
4690:          ')'
4692:          [ oTypeSNodeType
4694:             | nIntegerType :
4695:             | nByteType :
4697:             | * :  #eTypeMismatch
4706:          ]
4706:          oTypeSPop
4707:          oTypeSPush( CharType )
4713:          ')'
4715:          >>
4716:       | * :
4721:    ]
      
         % Pred(x)
4721:    [ oNodeEqual( method, BuiltIn_Pred )
4731:       | true :
4732:          '('
4734:          @ConstExpr
4736:          [ oTypeSNodeType
4738:             | nEnumType :
4739:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4748:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4751:                   | * :
4756:                ]
4756:             | * :  #eTypeMismatch
4763:          ]
4763:          oValuePush( 1 )  oValueSub
4770:          ')'
4772:          >>
4773:       | * :
4778:    ]
      
         % Succ(x)
4778:    [ oNodeEqual( method, BuiltIn_Succ )
4788:       | true :
4789:          '('
4791:          @ConstExpr
4793:          [ oTypeSNodeType
4795:             | nEnumType :
4796:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4805:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4808:                   | * :
4813:                ]
4813:             | * :  #eTypeMismatch
4820:          ]
4820:          oValuePush( 1 )  oValueAdd
4827:          ')'
4829:          >>
4830:       | * :
4835:    ]
      
         % Sizeof(x)
4835:    [ oNodeEqual( method, BuiltIn_Sizeof )
4845:       | true :
4846:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4848:          @ConstExprAllowTypeName
4850:          oValuePop
4851:          Node theType = oTypeSTop
4856:          oTypeSPop
4857:          oValuePush( oNodeGetInt( theType, qSize ) )
4870:          oTypeSPush( IntegerType )
4876:          ')'
4878:          >>
4879:       | * :
4884:    ]
      
4884:    #eNotImplemented
4887:    ;
      
      
4887: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4887: Expr:
4889:    Label falseLabel = labelNull
      
4895:    @ExprAllowFlow( falseLabel )
4902:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
4910: ExprAllowTypeName:
4912:    boolean oldAllowTypeName = flagExprAllowTypeName
4918:    flagExprAllowTypeName = true
4924:    @Expr
4926:    flagExprAllowTypeName = oldAllowTypeName
4933:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4933: BooleanExprControlFlow( out Label falseLabel ):
4935:    @ExprAllowFlow( falseLabel )
4942:    [ oTypeSNodeType
4944:       | nBooleanFlowType :
4945:       | nBooleanType :
               % convert value to control flow
4947:          falseLabel = oLabelNew
4952:          .tJumpFalse  oEmitLabel( falseLabel )
4960:       | * :
4967:          #eNotBoolean
4969:    ]
4969:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4971: FlowToVal( inout Label falseLabel ):
4973:    [ oTypeSNodeType
4975:       | nBooleanFlowType :
4976:          Label doneLabel = oLabelNew
4981:          .tPushConstI  oEmitInt( 1 )
4989:          .tJump  oEmitLabel( doneLabel )
4997:          .tLabel  oEmitLabel( falseLabel )
5005:          .tPushConstI  oEmitInt( 0 )
5013:          .tLabel  oEmitLabel( doneLabel )
5021:          oTypeSPop
5022:          oTypeSPush( BooleanType )
5028:          falseLabel = labelNull
5034:       | * :
5039:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5040: ValToFlow( out Label falseLabel ):
5042:    [ oTypeSNodeType
5044:       | nBooleanType :
5045:          falseLabel = oLabelNew
5050:          .tJumpFalse  oEmitLabel( falseLabel )
5058:          oTypeSPop
5059:          oTypeSPush( BooleanFlowType )
5065:       | * :
5070:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5071: ExprAllowFlow( out Label falseLabel ):
5073:    @BoolExprAllowFlow( falseLabel )
5080:    {[
5080:       | '=' :
5082:          @FlowToVal( falseLabel )
5089:          @PromoteToIntOptional
5091:          @BoolExprAllowFlow( falseLabel )
5098:          @FlowToVal( falseLabel )
5105:          @PromoteToIntOptional
5107:          @MatchTypes
5109:          [ oTypeSNodeType
5111:             | nBooleanType, nCharType :     .tEqualB
5114:             | nIntegerType, nEnumType :     .tEqualI
5118:             | nPointerType, nUniversalPointerType :    .tEqualP
5122:             | nShortStringType, nStrLitType :
5124:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5136:             | * :                           #eNotAllowed
5157:          ]
5157:          oTypeSPop
5158:          oTypeSPush( BooleanType )
      
5164:       | '<>' :
5166:          @FlowToVal( falseLabel )
5173:          @PromoteToIntOptional
5175:          @BoolExprAllowFlow( falseLabel )
5182:          @FlowToVal( falseLabel )
5189:          @PromoteToIntOptional
5191:          @MatchTypes
5193:          [ oTypeSNodeType
5195:             | nBooleanType, nCharType :     .tNotEqualB
5198:             | nIntegerType, nEnumType :     .tNotEqualI
5202:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5206:             | nShortStringType, nStrLitType :
5208:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5220:             | * :                           #eNotAllowed
5241:          ]
5241:          oTypeSPop
5242:          oTypeSPush( BooleanType )
      
5248:       | '<' :
5250:          @FlowToVal( falseLabel )
5257:          @PromoteToIntOptional
5259:          @BoolExprAllowFlow( falseLabel )
5266:          @FlowToVal( falseLabel )
5273:          @PromoteToIntOptional
5275:          @MatchTypes
5277:          [ oTypeSNodeType
5279:             | nBooleanType, nCharType :     .tLessB
5282:             | nIntegerType, nEnumType :     .tLessI
5286:             | nPointerType, nUniversalPointerType :   .tLessP
5290:             | nShortStringType, nStrLitType :
5292:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5304:             | * :                           #eNotAllowed
5325:          ]
5325:          oTypeSPop
5326:          oTypeSPush( BooleanType )
      
5332:       | '>' :
5334:          @FlowToVal( falseLabel )
5341:          @PromoteToIntOptional
5343:          @BoolExprAllowFlow( falseLabel )
5350:          @FlowToVal( falseLabel )
5357:          @PromoteToIntOptional
5359:          @MatchTypes
5361:          [ oTypeSNodeType
5363:             | nBooleanType, nCharType :     .tGreaterB
5366:             | nIntegerType, nEnumType :     .tGreaterI
5370:             | nPointerType, nUniversalPointerType :   .tGreaterP
5374:             | nShortStringType, nStrLitType :
5376:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5388:             | * :                           #eNotAllowed
5409:          ]
5409:          oTypeSPop
5410:          oTypeSPush( BooleanType )
      
5416:       | '<=' :
5418:          @FlowToVal( falseLabel )
5425:          @PromoteToIntOptional
5427:          @BoolExprAllowFlow( falseLabel )
5434:          @FlowToVal( falseLabel )
5441:          @PromoteToIntOptional
5443:          @MatchTypes
5445:          [ oTypeSNodeType
5447:             | nBooleanType, nCharType :     .tLessEqualB
5450:             | nIntegerType, nEnumType :     .tLessEqualI
5454:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5458:             | nShortStringType, nStrLitType :
5460:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5472:             | * :                           #eNotAllowed
5493:          ]
5493:          oTypeSPop
5494:          oTypeSPush( BooleanType )
      
5500:       | '>=' :
5502:          @FlowToVal( falseLabel )
5509:          @PromoteToIntOptional
5511:          @BoolExprAllowFlow( falseLabel )
5518:          @FlowToVal( falseLabel )
5525:          @PromoteToIntOptional
5527:          @MatchTypes
5529:          [ oTypeSNodeType
5531:             | nBooleanType, nCharType :     .tGreaterEqualB
5534:             | nIntegerType, nEnumType :     .tGreaterEqualI
5538:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5542:             | nShortStringType, nStrLitType :
5544:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5556:             | * :                           #eNotAllowed
5577:          ]
5577:          oTypeSPop
5578:          oTypeSPush( BooleanType )
      
5584:       | * :
5599:          >
5601:    ]};
      
      
5604: BoolExprAllowFlow( out Label falseLabel ):
5606:    Label trueLabel = labelNull
      
5612:    @BoolTermAllowFlow( falseLabel )
5619:    {[
5619:       | pOr :
5621:          [ oTypeSNodeType
5623:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5624:                [ equal_label( trueLabel, labelNull )
5634:                   | true :  trueLabel = oLabelNew
5640:                   | * :
5645:                ]
5645:                .tJump  oEmitLabel( trueLabel )
5653:             | nBooleanType :
5655:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5662:                [ equal_label( trueLabel, labelNull )
5672:                   | true :  trueLabel = oLabelNew
5678:                   | * :
5683:                ]
5683:                .tJump  oEmitLabel( trueLabel )
5691:             | * : #eNotBoolean
5700:          ]
5700:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5701:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5709:          falseLabel = labelNull
5715:          @BoolTermAllowFlow( falseLabel )
      
5722:          [ oTypeSNodeType
5724:             | nBooleanFlowType :
5725:             | nBooleanType :
5727:                @ValToFlow( falseLabel )
5734:             | * : #eNotBoolean
5743:          ]
      
5743:          oTypeSPop
5744:          oTypeSPush( BooleanFlowType )
      
5750:       | * :
5755:          >
5757:    ]}
      
         % any short-circuit trues jump here to the end
5759:    [ equal_label( trueLabel, labelNull )
5769:       | false :
5770:          .tLabel  oEmitLabel( trueLabel )
5778:       | * :
5783:    ]
5784:    ;
      
      
5784: BoolTermAllowFlow( out Label falseLabel ):
5786:    Label overallFalseLabel = labelNull
      
5792:    @BoolFactorAllowFlow( falseLabel )
5799:    {[
5799:       | pAnd :
5801:          [ oTypeSNodeType
5803:             | nBooleanFlowType :
5804:             | nBooleanType :
5806:                @ValToFlow( falseLabel )
5813:             | * :
5820:                #eNotBoolean
5822:          ]
5822:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5823:          [ equal_label( overallFalseLabel, labelNull )
5833:             | true :
5834:                overallFalseLabel = oLabelNew
5839:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5853:                falseLabel = overallFalseLabel
5859:             | * :
5864:          ]
      
5864:          Label factorFalseLabel = labelNull
5870:          @BoolFactorAllowFlow( factorFalseLabel )
      
5877:          [ oTypeSNodeType
5879:             | nBooleanFlowType :
5880:             | nBooleanType :
5882:                @ValToFlow( factorFalseLabel )
5889:             | * : #eNotBoolean
5898:          ]
5898:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5912:       | * :
5917:          >
5919:    ]};
      
      
5922: BoolFactorAllowFlow( out Label falseLabel ):
5924:    [
5924:       | pNot :
5926:          Label factorFalseLabel = labelNull
      
5932:          @BoolFactorAllowFlow( factorFalseLabel )
5939:          [ oTypeSNodeType
5941:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5942:                falseLabel = oLabelNew
5947:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5955:                .tLabel  oEmitLabel( factorFalseLabel )
      
5963:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5965:                .tNot
      
5967:             | * : #eNotBoolean
5976:          ]
      
5976:       | * :
5981:          @ArithExprAllowFlow( falseLabel )
5988:    ];
      
      
5989: ArithExprAllowFlow( out Label falseLabel ):
5991:    boolean first = true
5997:    int tempStrOffset
      
5997:    @TermAllowFlow( falseLabel )
6004:    {[
6004:       | '+' :
6006:          [ oTypeSNodeType
6008:             | nIntegerType, nByteType :
6009:                @PromoteToIntPop
6011:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6018:                [ oTypeSNodeType
6020:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6021:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6023:                      @PointerAddition
6025:                   | * :
6032:                      @PromoteToInt
6034:                      .tAddI
6036:                ]
      
6036:             | nDoubleType :
6038:                @TermAllowFlow( falseLabel )
6045:                @PromoteToDoublePop
6047:                .tAddD
      
6049:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6051:                [ first
6054:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6055:                             tempStrOffset = @MoveIntoTempShortString
6061:                             first = false
6067:                   | * :
6072:                ]
6072:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6079:                [ oTypeSNodeType
6081:                   | nShortStringType, nStrLitType :
6082:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6084:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6092:                      oTypeSPush( ShortStringType )
6098:                   | nCharType :
6100:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6102:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6110:                      oTypeSPush( ShortStringType )
6116:                   | * :
6125:                      #eTypeMismatch
6127:                      oTypeSPop
6128:                ]
      
6128:             | nPointerType, nUniversalPointerType :
6130:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6137:                @PromoteToIntPop
6139:                @PointerAddition
      
6141:             | * :
6160:                #eNotAllowed
6162:          ]
      
6162:       | '-' :
6164:          [ oTypeSNodeType
6166:             | nIntegerType, nByteType :
6167:                @PromoteToIntPop
6169:                @TermAllowFlow( falseLabel )
6176:                @PromoteToInt
6178:                .tSubI
      
6180:             | nDoubleType :
6182:                @TermAllowFlow( falseLabel )
6189:                @PromoteToDoublePop
6191:                .tSubD
      
6193:             | nPointerType, nUniversalPointerType :
6195:                @TermAllowFlow( falseLabel )
6202:                [ oTypeSNodeType
6204:                   | nIntegerType, nByteType :
6205:                      @PromoteToIntPop
6207:                      @PointerSubInt
6209:                   | nPointerType, nUniversalPointerType :
6211:                      @MatchTypes
6213:                      @PointerSubPointer
6215:                   | * :
6226:                      #eNotAllowed
6228:                ]
      
6228:             | * :  #eNotAllowed
      
6243:          ]
6243:       | * :
6250:          >
6252:    ]};
      
      
6255: TermAllowFlow( out Label falseLabel ):
6257:    @FactorAllowFlow( falseLabel )
6264:    {[
6264:       | '*' :
6266:          [ oTypeSNodeType
6268:             | nIntegerType, nByteType :
6269:                @PromoteToIntPop
6271:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6278:                @PromoteToInt
6280:                .tMultI
      
6282:             | nDoubleType :
6284:                @FactorAllowFlow( falseLabel )
6291:                @PromoteToDoublePop
6293:                .tMultD
      
6295:             | * :
6304:                #eNotAllowed
6306:          ]
      
6306:       | '/' :
6308:          [ oTypeSNodeType
6310:             | nIntegerType, nByteType :
6311:                @PromoteToIntPop
6313:                @FactorAllowFlow( falseLabel )
6320:                @PromoteToInt
6322:                .tDivI
      
6324:             | nDoubleType :
6326:                @FactorAllowFlow( falseLabel )
6333:                @PromoteToDoublePop
6335:                .tDivD
      
6337:             | * :
6346:                #eNotAllowed
6348:          ]
      
6348:       | * :
6355:          >
6357:    ]};
      
      
6360: FactorAllowFlow( out Label falseLabel ):
6362:    [
6362:       | '+' :
6364:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6371:          [ oTypeSNodeType
6373:             | nIntegerType, nByteType :
6374:             | nDoubleType :
6376:             | * :
6385:                #eNotAllowed
6387:          ]
6387:       | '-' :
6389:          @PrimaryAllowFlow( falseLabel )
6396:          [ oTypeSNodeType
6398:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6399:                @PromoteToInt
6401:                .tNegI
6403:             | nDoubleType :
6405:                .tNegD
6407:             | * :
6416:                #eNotAllowed
6418:          ]
6418:       | * :
6425:          @PrimaryAllowFlow( falseLabel )
6432:    ];
      
      
6433: PrimaryAllowFlow( out Label falseLabel ):
6435:    [
6435:       | pIntLit :
6437:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6444:          oTypeSPush( IntegerType )
      
6450:       | pCharLit :
6452:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6459:          oTypeSPush( CharType )
      
6465:       | pDoubleLit :
6467:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6474:          oTypeSPush( DoubleType )
      
6480:       | '(' :
6482:          @ExprAllowFlow( falseLabel )
6489:          ')'
      
6491:       | pStrLit :
6493:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6502:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6510:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6516:          @LValueIndexes
               % get final value of dereferencing, if any
6518:          @FetchVar
      
6520:       | pIdent :
6522:          Node decl = oScopeFindRequire
6527:          @ResolveUnitRef( decl )
6534:          Node theType
      
6534:          [ oNodeType( decl )
6541:             | nFunc :
6542:                @Call( decl )
      
6549:             | nBuiltInFunc :
6551:                @CallBuiltInFunc( decl )
      
6558:             | nConst, nEnumValue :
6560:                theType = oNodeGet( decl, qType )
6573:                oTypeSPush( theType )
6579:                [ oTypeSNodeType
6581:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6582:                      .tPushConstI @EmitValue( decl )
6591:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6593:                      .tPushConstI @EmitValue( decl )
6602:                   | * :
6619:                      #eNotImplemented
6621:                ]
      
6621:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6623:                int addr = oNodeGetInt( decl, qValue )
6636:                [ equal_zero( addr )
6643:                   | true :
6644:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6661:                      oNodeSetInt( decl, qValue, addr )
6673:                   | * :
6678:                ]
6678:                .tPushAddrGlobal oEmitInt( addr )
6686:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6692:                @LValueIndexes
                     % get final value of dereferencing, if any
6694:                @FetchVar
      
6696:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6698:                @VarExpr( decl )
      
6705:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6707:                oTypeSPush( oNodeGet( decl, qType ) )
6720:                [
6720:                   | '(' : 
                           % Type cast
6722:                      @Expr
6724:                      ')'
6726:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
6728:                      [ oTypeSNodeType
6730:                         | nPointerType, nUniversalPointerType :
6731:                            [
6731:                               | '^' :             % dereferenced
6733:                                  oTypeSPop
6734:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
6747:                                  @LValueIndexes
6749:                                  @FetchVar
6751:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
6753:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
6755:                                  @LValueIndexes
6757:                                  @FetchVar
6759:                               | * :               % just ptr value alone
6766:                            ]
      
6766:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
6768:                            @LValueIndexes
                                 % get final value, if no longer compound
6770:                            @FetchVar
      
6772:                         | *:
6785:                      ]
      
6785:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
6790:                      [ flagExprAllowTypeName
6793:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
6794:                            .tPushConstI  oEmitInt( 0 )
6802:                         | * :    #eTypeNameNotAllowedHere
6809:                      ]
6809:                ]
      
6809:             | * :
6832:                #eNotValue
6834:                oTypeSPush( IntegerType )
6840:          ]
      
6840:       | '@' :        % @var -- pointer to var
6842:          pIdent
      
6844:          Node decl = oScopeFindRequire
6849:          @ResolveUnitRef( decl )
6856:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
6856:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6866:          theType = oTypeSTop
6871:          oTypeSPop
6872:          Node ptrType = @PointerTypeTo( theType )
6883:          oTypeSPush( ptrType )
      
6889:       | * :
6906:          #eNotValue
6908:          oTypeSPush( IntegerType )
6914:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6915: VarExpr( Node decl ):
6917:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6930:    int uplevels = @DeclUpLevels( decl )
      
6941:    oTypeSPush( theType )
6947:    [ oTypeSNodeType
6949:       | nIntegerType, nEnumType :
6950:          [ oNodeType( decl )
6957:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6967:             | nLocalVar :
6969:                [ equal_zero( uplevels )
6976:                   | true :  .tPushLocalI  @EmitValue( decl )
6986:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7006:                ]
7006:             | nParam :
7008:                [ oNodeGetBoolean( decl, qInOut )
7018:                   | true :    % VAR param points to the var.  Auto dereference.
7019:                      [ equal_zero( uplevels )
7026:                         | true :  .tPushParamP  @EmitValue( decl )
7036:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7056:                      ]
7056:                      .tFetchI
7058:                   | * :
7063:                      [ equal_zero( uplevels )
7070:                         | true :  .tPushParamI  @EmitValue( decl )
7080:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7100:                      ]
7100:                ]
7100:          ]
      
7112:       | nBooleanType, nByteType, nCharType :
7114:          [ oNodeType( decl )
7121:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7131:             | nLocalVar :
7133:                [ equal_zero( uplevels )
7140:                   | true :  .tPushLocalB  @EmitValue( decl )
7150:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7170:                ]
7170:             | nParam :
7172:                [ oNodeGetBoolean( decl, qInOut )
7182:                   | true :    % VAR param points to the var.  Auto dereference.
7183:                      [ equal_zero( uplevels )
7190:                         | true :  .tPushParamP  @EmitValue( decl )
7200:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7220:                      ]
7220:                      .tFetchB
7222:                   | * :
7227:                      [ equal_zero( uplevels )
7234:                         | true :  .tPushParamB  @EmitValue( decl )
7244:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7264:                      ]
7264:                ]
7264:          ]
      
7276:       | nFileType :
7278:          #eNotImplemented
      
7280:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7282:          [ oNodeType( decl )
7289:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7299:             | nLocalVar :
7301:                [ equal_zero( uplevels )
7308:                   | true :  .tPushLocalP  @EmitValue( decl )
7318:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7338:                ]
7338:             | nParam :
7340:                [ oNodeGetBoolean( decl, qInOut )
7350:                   | true :    % VAR param points to the var.  Auto dereference.
7351:                      [ equal_zero( uplevels )
7358:                         | true :  .tPushParamP  @EmitValue( decl )
7368:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7388:                      ]
7388:                      .tFetchP
7390:                   | * :
7395:                      [ equal_zero( uplevels )
7402:                         | true :  .tPushParamP  @EmitValue( decl )
7412:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7432:                      ]
7432:                ]               
7432:          ]
7444:          [
7444:             | '^' :             % dereferenced
7446:                oTypeSPop
7447:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7460:                @LValueIndexes
7462:                @FetchVar
7464:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7466:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7468:                @LValueIndexes
7470:                @FetchVar
7472:             | * :               % just ptr value alone
7479:          ]
      
7479:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7481:          [ oNodeType( decl )
7488:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7498:             | nLocalVar :
7500:                [ equal_zero( uplevels )
7507:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7517:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7537:                ]
7537:             | nParam :
7539:                [ oNodeGetBoolean( decl, qInOut )
7549:                   | true :    % VAR param points to the var.  Auto dereference.
7550:                      [ equal_zero( uplevels )
7557:                         | true :  .tPushParamP  @EmitValue( decl )
7567:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7587:                      ]
7587:                   | * :
7592:                      [ equal_zero( uplevels )
7599:                         | true :  .tPushAddrParam  @EmitValue( decl )
7609:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7629:                      ]
7629:                ]
7629:          ]
               % modify addr for subscripts, field references, etc
7641:          @LValueIndexes
               % get final value
7643:          @FetchVar
7645:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7674: FetchVar:
7676:    [ oTypeSNodeType
7678:       | nIntegerType, nEnumType :  .tFetchI
7681:       | nBooleanType, nByteType, nCharType :  .tFetchB
7685:       | nFileType :   #eNotImplemented
7689:       | nPointerType :             .tFetchP
7693:       | nUniversalPointerType :    #eCantDereference
7697:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7699:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7728: LValueIndexes:
7730:    {[
7730:       | '[' :
7732:          [ oTypeSNodeType
7734:             | nArrayType :    @ArraySubscripts
7737:             | nPointerType :  @PointerArraySubscript
7741:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7745:             | * :             #eNotArray
7758:          ]
7758:       | '.' :       @RecordFieldRef
7762:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7766:       | * :         >
7777:    ]};
      
      
7780: ArraySubscripts:
7782:    [ oTypeSNodeType
7784:       | nArrayType :
7785:       | * :       #eNotArray
7792:    ]
7792:    {
7792:       [ oTypeSNodeType
7794:          | nArrayType :
7795:          | * :    #eTooManySubscripts
7802:       ]
      
            % low subscript of this dimension
7802:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7819:       Node baseType
7819:       baseType = oNodeGet( oTypeSTop, qBaseType )
7831:       oTypeSPop
7832:       oTypeSPush( baseType )
      
7838:       @Expr
7840:       @RequireIntPop
            % adjust for low subscript
7842:       [ equal_zero( low )
7849:          | false :
7850:             .tPushConstI oEmitInt( low ) .tSubI
7860:          | * :
7865:       ]
      
            % multiply by element size
7865:       int size = oNodeGetInt( baseType, qSize )
7878:       [ equal( size, 1 )
7888:          | false :
7889:             .tPushConstI oEmitInt( size ) .tMultI
7899:          | * :
7904:       ]
      
            % update start address
7904:       .tAddPI
7906:       [
7906:          | ']' :  >
7910:          | ',' :
7912:       ]
7920:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7923: PointerArraySubscript:
7925:    [ oTypeSNodeType
7927:       | nPointerType :
7928:       | * :    #eCantDereference
7935:    ]
         % replace type stack with base type
7935:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7947:    oTypeSPop
7948:    oTypeSPush( baseType )
         
7954:    @Expr
7956:    @RequireIntPop
         % multiply by element size
7958:    int size = oNodeGetInt( baseType, qSize )
7971:    [ equal( size, 1 )
7981:       | false :
7982:          .tPushConstI  oEmitInt( size )  .tMultI
7992:       | * :
7997:    ]
         % update start address
7997:    .tAddPI
7999:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8002: ShortStringArraySubscript:
8004:    [ oTypeSNodeType
8006:       | nStrLitType, nShortStringType :
8007:       | * :    #eCantDereference
8016:    ]
8016:    oTypeSPop
8017:    oTypeSPush( CharType )
8023:    @Expr
8025:    @RequireIntPop
8027:    .tAddPI
8029:    ']';
      
      
8032: RecordFieldRef:
8034:    [ oTypeSNodeType
8036:       | nRecordType :
8037:       | * :    #eNotRecord
8044:    ]
8044:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8056:    pIdent
8058:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8063:    [ oNodeType( field )
8070:       | nRecordField :
8071:       | * :   #eNotRecordField
8078:    ]
8078:    oScopeEnd
8079:    int offset = oNodeGetInt( field, qValue )
8092:    [ equal_zero( offset )
8099:       | false :
8100:          .tPushConstI oEmitInt( offset ) .tAddPI
8110:       | * :
8115:    ]
      
         % replace the type on the type stack, with the field type
8115:    oTypeSPop
8116:    oTypeSPush( oNodeGet( field, qType ) )
8130:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8130: PointerAddition:
8132:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8144:    int elementSize = oNodeGetInt( elementType, qSize )
8157:    [ equal( elementSize, 1 )
8167:       | false :
8168:          .tPushConstI  oEmitInt( elementSize )
8176:          .tMultI
8178:       | * :
8183:    ]
8183:    .tAddPI
8186:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8186: PointerSubInt:
8188:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8200:    int elementSize = oNodeGetInt( elementType, qSize )
8213:    [ equal( elementSize, 1 )
8223:       | false :
8224:          .tPushConstI  oEmitInt( elementSize )
8232:          .tMultI
8234:       | * :
8239:    ]
8239:    .tSubPI
8242:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8242: PointerSubPointer:
8244:    .tSubP
8246:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8258:    int elementSize = oNodeGetInt( elementType, qSize )
8271:    [ equal( elementSize, 1 )
8281:       | false :
8282:          .tPushConstI  oEmitInt( elementSize )
8290:          .tDivI
8292:       | * :
8297:    ]
8297:    oTypeSPop
8298:    oTypeSPush( IntegerType )
8305:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8305: PointerDeref:
8307:    [ oTypeSNodeType
8309:       | nPointerType :
8310:       | nUniversalPointerType :   #eCantDereference
8314:       | * :       #eNotPointer
8323:    ]
8323:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8325:    Node theType = oTypeSTop
8330:    oTypeSPop
8331:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8345:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8345: CoerceType:
8347:    node_type nt = oTypeSNodeType
8352:    Node given = oTypeSTop
8357:    oTypeSPop
8358:    [ equal_node_type( nt, oTypeSNodeType )
8367:       | false :
               % Can we implicitly convert the value to the desired type?
8368:          [ oTypeSNodeType
8370:             | nIntegerType :
8371:                [ nt
8374:                   | nByteType :   .tCastBtoI  >>
8378:                   | * :
8383:                ]
8383:             | nByteType :
8385:                [ nt
8388:                   | nIntegerType :   .tCastItoB  >>
8392:                   | * :
8397:                ]
8397:             | nPointerType :
8399:                [ nt
8402:                   | nUniversalPointerType :  >>
8404:                   | nStrLitType :
8406:                      [ equal_node( oTypeSTop, PCharType )
8415:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8416:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8427:                         | * :
8432:                      ]
8432:                   | * :
8439:                ]
8439:             | nUniversalPointerType :
8441:                [ nt
8444:                   | nPointerType :  >>
8446:                   | * :
8451:                ]
8451:             | nShortStringType :
8453:                [ nt
8456:                   | nStrLitType :  >>
8458:                   | nCharType :
                           % Store char as a temp ShortString.
8460:                      oTypeSPush( CharType )
8466:                      int tempOffset = @MoveIntoTempShortString
8472:                      oTypeSPop
8473:                      >>
8474:                   | * :
8481:                ]
8481:             | * :
8494:          ]
8494:          #eTypeMismatch
8496:       | * :
8501:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8502: CastType:
8504:    node_type nt = oTypeSNodeType
8509:    oTypeSPop
8510:    [ equal_node_type( nt, oTypeSNodeType )
8519:       | false :
               % Can we cast the value to the desired type?
8520:          [ oTypeSNodeType
8522:             | nIntegerType, nEnumType :
8523:                [ nt
8526:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8530:                   | nIntegerType, nEnumType :   >>
8533:                   | * :
8546:                ]
8546:             | nByteType, nCharType, nBooleanType :
8548:                [ nt
8551:                   | nByteType, nCharType, nBooleanType :   >>
8553:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8558:                   | * :
8571:                ]
8571:             | nPointerType :
8573:                [ nt
8576:                   | nUniversalPointerType :  >>
8578:                   | nStrLitType :
8580:                      [ equal_node( oTypeSTop, PCharType )
8589:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8590:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8601:                         | * :
8606:                      ]
8606:                   | * :
8613:                ]
8613:             | nUniversalPointerType :
8615:                [ nt
8618:                   | nPointerType :  >>
8620:                   | * :
8625:                ]
8625:             | nShortStringType :
8627:                [ nt
8630:                   | nStrLitType :  >>
8632:                   | nCharType :
                           % Store char as a temp ShortString.
8634:                      oTypeSPush( CharType )
8640:                      int tempOffset = @MoveIntoTempShortString
8646:                      oTypeSPop
8647:                      >>
8648:                   | * :
8655:                ]
8655:             | * :
8674:          ]
8674:          #eTypeMismatch
8676:       | * :
8681:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8682: MatchTypes:
8684:    node_type nt = oTypeSNodeType
8689:    oTypeSPop
8690:    [ equal_node_type( nt, oTypeSNodeType )
8699:       | false :
               % Some implicit conversion is allowed even here
8700:          [ oTypeSNodeType
8702:             | nPointerType :
8703:                [ nt
8706:                   | nUniversalPointerType :  >>
8708:                   | * :
8713:                ]
8713:             | nUniversalPointerType :
8715:                [ nt
8718:                   | nPointerType :  >>
8720:                   | * :
8725:                ]
8725:             | * :
8732:          ]
8732:          #eTypeMismatch
8734:       | * :
8739:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8740: RequireIntPop:
8742:    [ oTypeSNodeType
8744:       | nIntegerType :
8745:       | * :          #eNotInteger
8752:    ]
8752:    oTypeSPop;
      
8754: RequireInt:
8756:    [ oTypeSNodeType
8758:       | nIntegerType :
8759:       | * :          #eNotInteger
8766:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8767: PromoteToIntPop:
8769:    [ oTypeSNodeType
8771:       | nIntegerType :
8772:       | nByteType :        .tCastBtoI
8776:       | * :                #eNotInteger
8785:    ]
8785:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8787: PromoteToInt:
8789:    [ oTypeSNodeType
8791:       | nIntegerType :
8792:       | nByteType :        .tCastBtoI
8796:                            oTypeSPop
8797:                            oTypeSPush( IntegerType )
8803:       | * :                #eNotInteger
8812:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8813: PromoteToIntOptional:
8815:    [ oTypeSNodeType
8817:       | nByteType :        .tCastBtoI
8820:                            oTypeSPop
8821:                            oTypeSPush( IntegerType )
8827:       | * :
8832:    ];
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
8833: PromoteToDoublePop:
8835:    [ oTypeSNodeType
8837:       | nDoubleType :
8838:       | nIntegerType, nByteType :   #eNotImplemented
8842:       | * :                         #eNotDouble
8853:    ]
8853:    oTypeSPop;
      
      
8855: RequireBoolPop:
8857:    [ oTypeSNodeType
8859:       | nBooleanType :
8860:       | * :          #eNotBoolean
8867:    ]
8867:    oTypeSPop;
      
8869: RequireBool:
8871:    [ oTypeSNodeType
8873:       | nBooleanType :
8874:       | * :          #eNotBoolean
8881:    ];
      
      
8882: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8882: Statement:
8884:    [
8884:       | pWriteln :     @WritelnStmt
8888:       | pWrite :       @WriteStmt
8892:       | pReadln :      @ReadlnStmt
8896:       | pRead :        @ReadStmt
8900:       | pIf :          @IfStmt
8904:       | pWhile :       @WhileStmt
8908:       | pFor :         @ForStmt
8912:       | pRepeat :      @RepeatStmt
8916:       | pBreak :       @BreakStmt
8920:       | pContinue :    @ContinueStmt
8924:       | pBegin :       @BeginStmt
8928:       | pIdent :       @LabelOrAssignOrCallStmt
8932:       | pCase :        @CaseStmt
8936:       | pGoto :        @GotoStmt
8940:       | pIntLit :      % should be an integer label
8942:                        oChangeIntLitToLabelIdent
8943:                        @LabelOrAssignOrCallStmt
8945:       | * :            % null statement : don't accept any tokens
8978:    ];
      
      
8979: LabelOrAssignOrCallStmt:
8981:    Node decl = oScopeFindRequire
8986:    @ResolveUnitRef( decl )
8993:    [ oNodeType( decl )
9000:       | nLabel :                          @LabelDefinition( decl )
9008:                                           @Statement
9010:       | nProc :                           @Call( decl )
9019:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9021:                                           @AssignStmt( decl )
9028:       | nFunc :                           @AssignResultStmt( decl )
9037:       | * :                               #eBadStatement
9056:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9057: LabelDefinition( Node decl ):
9059:    [ oNodeGetBoolean( decl, qDefined )
9069:       | true :  #eAlreadyDefined
9072:       | * :
9077:    ]
9077:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9092:    oNodeSetBoolean( decl, qDefined, true )
9104:    ':'
9107:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9107: AssignStmt( Node decl ):
9109:    @LValueFromDecl( decl, true )
9119:    ':=' 
9121:    @Expr
9123:    @CoerceType
9125:    @Assign
9128:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9128: Assign:
9130:    [ oTypeSNodeType
9132:       | nIntegerType, nEnumType :  .tAssignI
9135:       | nBooleanType, nByteType, nCharType :  .tAssignB
9139:       | nDoubleType :  .tAssignD
9143:       | nFileType :   #eNotImplemented
9147:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9151:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9153:           int size = oNodeGetInt( oTypeSTop, qSize )
9165:           .tCopy  oEmitInt( size )    % multi-word copy
9173:    ]
9201:    oTypeSPop
9203:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9203: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9205:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9221:       | false :   #eNotCurrentFunction
9224:       | * :
9229:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9229:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9244:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9257:    ':='
9259:    @Expr
9261:    @CoerceType
9263:    [ oTypeSNodeType
9265:       | nIntegerType, nEnumType : .tAssignI
9268:       | nBooleanType, nByteType, nCharType :  .tAssignB
9272:       | nDoubleType :  .tAssignD
9276:       | nFileType :   #eNotImplemented
9280:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9284:       | nArrayType, nRecordType, nShortStringType :
9286:           int size = oNodeGetInt( oTypeSTop, qSize )
9298:           .tCopy  oEmitInt( size )    % multi-word copy
9306:    ]
9334:    oTypeSPop
9336:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9336: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9338:    pIdent
9340:    Node decl = oScopeFindRequire
9345:    @ResolveUnitRef( decl )
9352:    @LValueFromDecl( decl, writeable )
9363:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9363: LValueFromDecl( Node decl, boolean writeable ):
9365:    [ oNodeType( decl )
9372:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9373:          @LValueVar( decl, writeable )
      
9383:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9385:          oTypeSPush( oNodeGet( decl, qType ) )
9398:          '('
9400:          @LValueExpr( writeable )
9407:          ')'
9409:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9411:          [ oTypeSNodeType
9413:             | nPointerType :
9414:                [
9414:                   | '[' :
                           % dereference the pointer var first
9416:                      .tFetchP
9418:                      @PointerArraySubscript
9420:                   | * :
9425:                ]
9425:             | * :
9430:          ]
               % additional subscripts, if any
9430:          @LValueIndexes
       
9432:       | * :  #eNotVar
9447:    ]
9448:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9448: LValueCastType:
9450:    node_type nt = oTypeSNodeType
9455:    oTypeSPop
9456:    [ equal_node_type( nt, oTypeSNodeType )
9465:       | false :
               % Can we cast the value to the desired type?
9466:          [ oTypeSNodeType
9468:             | nIntegerType, nEnumType :
9469:                [ nt
9472:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9476:                   | nIntegerType, nEnumType :   >>
9479:                   | * :
9492:                ]
9492:             | nByteType, nCharType, nBooleanType :
9494:                [ nt
9497:                   | nByteType, nCharType, nBooleanType :   >>
9499:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9504:                   | * :
9517:                ]
9517:             | nPointerType :
9519:                [ nt
9522:                   | nUniversalPointerType :  >>
9524:                   | * :
9529:                ]
9529:             | nUniversalPointerType :
9531:                [ nt
9534:                   | nPointerType :  >>
9536:                   | * :
9541:                ]
9541:             | nShortStringType :
9543:                [ nt
9546:                   | nStrLitType :  >>
9548:                   | * :
9553:                ]
9553:             | * :
9572:          ]
9572:          #eTypeMismatch
9574:       | * :
9579:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9580: LValueVar( Node decl, boolean writeable ):
9582:    [ oNodeType( decl )
9589:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9599:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9610:       | nParam :
9612:          [ oNodeGetBoolean( decl, qInOut )
9622:             | true :   % VAR param points to variable.  No dereference.
9623:                        .tPushParamP @EmitValue( decl )
9632:             | * :      .tPushAddrParam @EmitValue( decl )
9646:          ]
9646:       | nTypedConst :
9648:          [ writeable
9651:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9661:             | * :      #eNotVar
9668:          ]
9668:       | * :            #eNotVar
9681:    ]
      
9681:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9694:    [ oTypeSNodeType
9696:       | nPointerType :
9697:          [
9697:             | '[' :
                     % dereference the pointer var first
9699:                .tFetchP
9701:                @PointerArraySubscript
9703:             | * :
9708:          ]
9708:       | * :
9713:    ]
         % additional subscripts, if any
9713:    @LValueIndexes
9716:    ;
      
      
9716: IncVar( Node decl ):
9718:    @LValueVar( decl, true )
9728:    @RequireIntPop
9730:    @VarExpr( decl )
9737:    oTypeSPop
9738:    .tIncI
9740:    .tAssignI;
      
9743: DecVar( Node decl ):
9745:    @LValueVar( decl, true )
9755:    @RequireIntPop
9757:    @VarExpr( decl )
9764:    oTypeSPop
9765:    .tDecI
9767:    .tAssignI;
      
      
9770: IfStmt:
9772:    Label falseLabel = labelNull
      
9778:    @BooleanExprControlFlow( falseLabel )
9785:    pThen
9787:    @Statement
9789:    [
9789:       | pElse :
9791:          Label doneLabel = oLabelNew
      
9796:          .tJump  oEmitLabel( doneLabel )
9804:          .tLabel oEmitLabel( falseLabel )
9812:          @Statement
9814:          .tLabel oEmitLabel( doneLabel )
      
9822:       | * :
9827:          .tLabel oEmitLabel( falseLabel )
9835:    ];
      
      
9836: ForStmt:
9838:    pIdent
      
9840:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9845:    @LValueVar( decl, true )
9855:    @RequireIntPop
      
9857:    ':='
      
9859:    @Expr
9861:    @RequireIntPop
9863:    .tAssignI
      
9865:    Label breakLabel = oLabelNew
      
9870:    Label checkLabel = oLabelNew
9875:    .tJump  oEmitLabel( checkLabel )
      
9883:    Label continueLabel = oLabelNew
9888:    .tLabel  oEmitLabel( continueLabel )
9896:    [
9896:       | pTo :
9898:          @IncVar( decl )
9905:          .tLabel  oEmitLabel( checkLabel )
9913:          @VarExpr( decl )  oTypeSPop
9921:          @Expr
9923:          @RequireIntPop
9925:          .tGreaterI
9927:          .tJumpTrue  oEmitLabel( breakLabel )
9935:       | pDownto :
9937:          @DecVar( decl )
9944:          .tLabel  oEmitLabel( checkLabel )
9952:          @VarExpr( decl )  oTypeSPop
9960:          @Expr
9962:          @RequireIntPop
9964:          .tLessI
9966:          .tJumpTrue  oEmitLabel( breakLabel )
9974:    ]
9982:    oLoopPush( continueLabel, breakLabel )
9991:    pDo
9993:    @Statement
9995:    .tJump  oEmitLabel( continueLabel )
10003:    .tLabel  oEmitLabel( breakLabel )
10011:    oLoopPop;
      
      
10013: RepeatStmt:
10015:    Label continueLabel = oLabelNew
10020:    .tLabel  oEmitLabel( continueLabel )
      
10028:    Label breakLabel = oLabelNew
      
10033:    oLoopPush( continueLabel, breakLabel )
10042:    @Statement
10044:    {[
10044:       | ';' :
10046:          @Statement
10048:       | pUntil :
10050:          Label falseLabel
10050:          @BooleanExprControlFlow( falseLabel )
10057:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10071:          >
10073:    ]}
10083:    .tLabel  oEmitLabel( breakLabel )
10091:    oLoopPop;
      
      
10093: WhileStmt:
10095:    Label continueLabel = oLabelNew
10100:    .tLabel  oEmitLabel( continueLabel )
      
10108:    Label breakLabel
10108:    @BooleanExprControlFlow( breakLabel )
      
10115:    oLoopPush( continueLabel, breakLabel )
10124:    pDo
10126:    @Statement
10128:    .tJump  oEmitLabel( continueLabel )
10136:    .tLabel  oEmitLabel( breakLabel )
10144:    oLoopPop;
      
      
10146: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10148:    [ equal_label( oLoopContinueLabel, labelNull )
10157:       | true :
10158:          #eNotInALoop
10160:       | false :
10162:          .tJump  oEmitLabel( oLoopContinueLabel )
10169:    ];
      
      
10178: BreakStmt:
10180:    [ equal_label( oLoopBreakLabel, labelNull )
10189:       | true :
10190:          #eNotInALoop
10192:       | false :
10194:          .tJump  oEmitLabel( oLoopBreakLabel )
10201:    ];
      
      
10210: CaseStmt:
10212:    Code tableCode = oCodeNew
10217:    Label tableLabel = oLabelNew
10222:    Label doneLabel = oLabelNew
10227:    Label otherwiseLabel = doneLabel
10233:    boolean isString = false
      
10239:    @Expr
         % Leave the expr type on the type stack throughout case statement
10241:    [ oTypeSNodeType
10243:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10252:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10262:       | nShortStringType, nStrLitType :        isString = true
10270:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10278:       | * :     #eNotAllowed
10297:    ]
10297:    pOf
      
10299:    {
10299:       [
10299:          | pOtherwise, pElse :
10301:             otherwiseLabel = oLabelNew
10306:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10314:             {[
10314:                | pEnd :  >
10318:                | * :
10323:                   @Statement
10325:                   [
10325:                      | ';' :
10327:                      | * :   pEnd  >
10336:                   ]
10336:             ]}
10338:             >
      
10340:          | pEnd :
                  % Reached end with no otherwise clause
10342:             >
      
10344:          | * :
10353:             Label caseLabel = oLabelNew
10358:             oCodePush( tableCode )
10364:             {
10364:                @ConstExpr
10366:                @ConstCoerceType
10368:                int val
10368:                [ isString
10371:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10381:                   | false :   val = oValueTop
10388:                ]
10396:                oValuePop
10397:                [
10397:                   | '..' :  @ConstExpr
10401:                             @ConstCoerceType
10403:                             int highval
10403:                             [ isString
10406:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10416:                                | false :  highval = oValueTop
10423:                             ]
10431:                             oValuePop
10432:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10452:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10471:                ]
10471:                [
10471:                   | ',' :
10473:                   | * :  >
10480:                ]
10480:             }
10482:             oCodePop
10483:             ':'
10485:             .tLabel  oEmitLabel( caseLabel )
10493:             @Statement
10495:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10503:             [
10503:                | ';' :
10505:                | * :
10510:             ]
                  
10510:       ]
         
10510:    }
      
10512:    .tLabel  oEmitLabel( tableLabel )
10520:    oEmitCode( tableCode )
10526:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10534:    .tLabel  oEmitLabel( doneLabel )
10542:    oTypeSPop
10544:    ;
      
      
10544: GotoStmt:
10546:    [
10546:       | pIdent :
10548:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10550:          oChangeIntLitToLabelIdent
10551:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10559:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10568:    oNodeSetBoolean( decl, qUsed, true )
10580:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10596:    ;
      
      
10596: BeginStmt:
10598:    @Statement
10600:    {[
10600:       | ';' :   @Statement
10604:       | pEnd :  >
10608:    ]};
      
      
10619: WritelnStmt:
10621:    @WriteStmt
10623:    .tWriteCR;
      
      
10626: WriteStmt:
10628:    [
10628:       | '(' :
10630:          {
10630:             @Expr
10632:             [ oTypeSNodeType
10634:                | nIntegerType :             .tWriteI
10637:                | nBooleanType :             .tWriteBool
10641:                | nByteType :                .tCastBtoI  .tWriteI
10647:                | nCharType :                .tWriteChar
10651:                | nDoubleType :              .tWriteD
10655:                | nShortStringType, nStrLitType :   .tWriteShortStr
10659:                | nFileType :                #eNotImplemented
10663:                | nEnumType :
                        % write name via table lookup
10665:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10679:                   .tWriteEnum
10681:                | nPointerType :
10683:                   [ equal_node( oTypeSTop, PCharType )
10692:                      | true :               .tWritePChar
10695:                      | * :                  .tWriteP
10702:                   ]
10702:                | nUniversalPointerType :    .tWriteP
10706:                | * :                        #eNotAllowed
10733:             ]
10733:             oTypeSPop
10734:             [
10734:                | ')' : >
10738:                | ',' :
10740:             ]
10748:          }
10750:       | * :
10755:    ];
      
      
10756: ReadlnStmt:
10758:    @ReadStmt
10760:    .tReadCR;
      
      
10763: ReadStmt:
10765:    [
10765:       | '(' :
10767:          {
10767:             @LValueExpr( true )
10774:             [ oTypeSNodeType
10776:                | nIntegerType :      .tReadI
10779:                | nCharType :         .tReadChar
10783:                | nShortStringType :  
10785:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
10804:                    .tReadShortStr  oEmitInt( capacity )
10812:                | * :                 #eNotAllowed
10823:             ]
10823:             oTypeSPop
10824:             [
10824:                | ')' : >
10828:                | ',' :
10830:             ]
10838:          }
10840:       | * :
10845:    ];
10846: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
10846: MoveIntoTempShortString >> int:
10848:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
10858:    [ oTypeSNodeType
10860:       | nShortStringType, nStrLitType :
10861:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
10869:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
10871:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
10886:       | nCharType :
               % temp[0] = 1
10888:          .tPushAddrLocal  oEmitInt( tempOffset )
10896:          .tPushConstI  oEmitInt( 1 )
10904:          .tAssignB
               % temp[1] = value
10906:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
10921:          .tSwap
10923:          .tAssignB
10925:       | * :   #eTypeMismatch
10936:    ]
10936:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
10937:    .tPushAddrLocal  oEmitInt( tempOffset )
10945:    oTypeSPush( ShortStringType )
10951:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10955: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
10957:    .tAllocActuals  oEmitInt( 16 )
10965:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10977:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10989:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
10998:    .tFreeActuals  oEmitInt( 16 )
11006:    oTypeSPop
11007:    oTypeSPop
11009:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11009: ShortStringAppendChar:
         % Note at the moment I don't align params
11011:    .tAllocActuals  oEmitInt( 12 )
11019:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11031:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11043:    .tCall  @EmitValue( System_ShortStringAppendChar )
11052:    .tFreeActuals  oEmitInt( 12 )
11060:    oTypeSPop
11061:    oTypeSPop
11063:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11063: ShortStringCmp:
11065:    .tAllocActualsCdecl  oEmitInt( 24 )
11073:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11085:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11097:    int tempOffset = oScopeAllocType( IntegerType )
11107:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11125:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11134:    .tPushLocalI  oEmitInt( tempOffset )
11142:    .tFreeActuals  oEmitInt( 24 )
11150:    oTypeSPop
11151:    oTypeSPush( IntegerType )
11158:    ;
11158: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11158: Call( Node method ):
11160:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11172:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11185:    Node resultType
11185:    int tempOffset
      
11185:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11202:    [ isFunc
11205:       | true :
11206:          resultType = oNodeGet( method, qType )
11219:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11229:       | * :
11234:    ]
         
      
11234:    Node paramScope = oNodeGet( method, qParams )
11247:    int actualsSize = oNodeGetInt( paramScope, qSize )
11260:    [ cdecl
11263:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11272:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11282:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11290:    [ greater( @DeclLevel( method ), 0 )
11305:       | true :
11306:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11314:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11333:          .tAssignP
11335:       | * :
11340:    ]
      
      
11340:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11353:    Node param = oNodeIterValue( paramIter )
11363:    [
11363:       | '(' :
            
11365:          {
11365:             [ oNodeNull( param )
11372:                | true : >
11375:                | * :
11380:             ]
      
11380:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11393:             .tPushAddrActual oEmitInt( offset )
11401:             oTypeSPush( oNodeGet( param, qType ) )
      
11414:             [ oNodeGetBoolean( param, qInOut )
11424:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11425:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11432:                           @MatchTypes
      
11434:                           .tAssignP
      
11436:                | false :  @Expr
11440:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11442:                           [ oTypeSNodeType
11444:                              | nIntegerType, nEnumType : .tAssignI
11447:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11451:                              | nDoubleType :  .tAssignD
11455:                              | nFileType :   #eNotImplemented
11459:                              | nPointerType, nUniversalPointerType :  .tAssignP
11463:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11465:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11477:                                  .tCopy  oEmitInt( size )    % multi-word copy
11485:                           ]
11513:             ]
11521:             oTypeSPop
      
11522:             oNodeIterNext( paramIter )
11528:             param = oNodeIterValue( paramIter )
11538:             [ oNodeNull( param )
11545:                | true :  >
11548:                | false :
11550:             ]
      
11558:             ','
11560:          }
      
11562:          ')'
      
11564:       | * :
11569:    ]
      
11569:    [ oNodeNull( param )
11576:       | false :    #eMissingParameter
11579:       | * :
11584:    ]
      
11584:    [ isFunc
11587:       | true :
               % Pass result temp as an additional VAR parameter.
11588:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11603:          .tPushAddrLocal  oEmitInt( tempOffset )
11611:          .tAssignP
11613:       | * :
11618:    ]
      
11618:    [ cdecl
11621:       | true :
11622:          .tCallCdecl  @EmitValue( method )
11631:       | false :
11633:          .tCall   @EmitValue( method )
11642:    ]
      
11650:    [ isFunc
11653:       | true :
               % push return value from temp
11654:          oTypeSPush( resultType )
      
11660:          [ oTypeSNodeType
11662:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11671:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11681:             | nFileType :  #eNotImplemented
11685:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11695:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11697:                                .tPushAddrLocal  oEmitInt( tempOffset )
11705:          ]
11731:       | * :
11736:    ]
         
11736:    .tFreeActuals  oEmitInt( actualsSize )
11745:    ;
      
      
      
      % Called on first use of an extern method
      %
11745: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
11747:    int strAddr
11747:    String externalName = oNodeGetString( method, qExternalName )
11760:    [ equal_string( externalName, stringNull )
11770:       | true :
11771:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
11792:       | false :
11794:          strAddr = oStringAllocLit( externalName )
11804:    ]
11812:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
11828:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11828: CallBuiltInFunc( Node method ):
      
         % Ord(x)
11830:    [ oNodeEqual( method, BuiltIn_Ord )
11840:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
11841:          '('
11843:          @Expr
11845:          [ oTypeSNodeType
11847:             | nIntegerType, nEnumType :
11848:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
11852:             | * :  #eTypeMismatch
11867:          ]
11867:          oTypeSPop
11868:          oTypeSPush( IntegerType )
11874:          ')'
11876:          >>
11877:       | * :
11882:    ]
      
         % Chr(x)
11882:    [ oNodeEqual( method, BuiltIn_Chr )
11892:       | true :
               % parameter is integer
               % result is char
11893:          '('
11895:          @Expr
11897:          [ oTypeSNodeType
11899:             | nIntegerType :    .tCastItoB
11902:             | nByteType :
11904:             | * :  #eTypeMismatch
11913:          ]
11913:          oTypeSPop
11914:          oTypeSPush( CharType )
11920:          ')'
11922:          >>
11923:       | * :
11928:    ]
      
         % Pred(x)
11928:    [ oNodeEqual( method, BuiltIn_Pred )
11938:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11939:          '('
11941:          @Expr
11943:          [ oTypeSNodeType
11945:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11946:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11955:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11958:                   | * :
11963:                ]
11963:             | * :  #eTypeMismatch
11970:          ]
11970:          .tDecI
11972:          ')'
11974:          >>
11975:       | * :
11980:    ]
      
         % Succ(x)
11980:    [ oNodeEqual( method, BuiltIn_Succ )
11990:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11991:          '('
11993:          @Expr
11995:          [ oTypeSNodeType
11997:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11998:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12007:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12010:                   | * :
12015:                ]
12015:             | * :  #eTypeMismatch
12022:          ]
12022:          .tIncI
12024:          ')'
12026:          >>
12027:       | * :
12032:    ]
      
         % Sizeof(x)
12032:    [ oNodeEqual( method, BuiltIn_Sizeof )
12042:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12043:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12045:          Code dummyCode = oCodeNew
12050:          oCodePush( dummyCode )
12056:          @ExprAllowTypeName
12058:          oCodePop
12059:          oCodeDiscard( dummyCode )
12065:          Node theType = oTypeSTop
12070:          oTypeSPop
12071:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12086:          oTypeSPush( IntegerType )
12092:          ')'
12094:          >>
      
12095:       | * :
12100:    ]
      
12100:    #eNotImplemented
12103:    ;
      
12103: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12103: newType( node_type nt, int size ) >> Node:
12105:   Node node = oNodeNew( nt )
12115:   oNodeSetInt( node, qSize, size )
12127:   oTypeAdd( node )
12133:   >> node
12137:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12137: TypeRef( out Node resultType ):
12139:    [
12139:       | pIdent :           % previously named type (including intrinsics)
12141:          Node decl = oScopeFindRequire
12146:          @ResolveUnitRef( decl )
12153:          [ oNodeType( decl )
12160:             | nTypeDecl :
12161:                resultType = oNodeGet( decl, qType )
12174:             | * :
12179:                #eNotType
12181:                resultType = IntegerType
12187:          ]
         
12187:       | pArray :
12189:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12191:          NodeVec dimensions = oNodeVecNew
      
12196:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12196:             Node subrange = oNodeNew( nSubrangeType )
      
12206:             @ConstExpr
12208:             oNodeSetInt( subrange, qLow, oValueTop )
12219:             oValuePop
12220:             '..'
12222:             @ConstExpr
12224:             oNodeSetInt( subrange, qHigh, oValueTop )
12235:             oValuePop
      
12236:             @ConstMatchTypes
12238:             oNodeSet( subrange, qBaseType, oTypeSTop )
12249:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12267:             oTypeSPop
12268:             oTypeAdd( subrange )
      
12274:             Node a = oNodeNew( nArrayType )
12284:             oNodeSet( a, qIndexType, subrange )
      
12296:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12305:             [
12305:                | ']' : >
12309:                | ',' :
12311:             ]
12319:          }
      
12321:          pOf
12323:          Node baseType
12323:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12330:          int dim = oNodeVecSize( dimensions )
      
12340:          {
12340:              dec(dim)
      
12346:              Node a = oNodeVecElement( dimensions, dim )
      
12359:              oNodeSet( a, qBaseType, baseType )
12371:              Node subrange = oNodeGet( a, qIndexType )
12384:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12411:              inc( width )
12417:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12443:              oTypeAdd( a )
12449:              baseType = a
      
12455:              [ equal_zero(dim)
12462:                  | true:  >
12465:                  | *:
12470:              ]
12470:          }
      
12472:          resultType = oNodeVecElement( dimensions, 0 )
12485:          oNodeVecDelete( dimensions )
      
12491:       | '^' :
12493:          Node theType
12493:          @TypeRef( theType )
12500:          resultType = @PointerTypeTo( theType )
      
12511:       | pRecord :
12513:          resultType = oNodeNew( nRecordType )
12523:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12532:          @VarDecl( nRecordField )
      
12539:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12551:          [ equal_zero( size )
12558:             | true : #eRecordEmpty
12561:             | * :
12566:          ]
      
12566:          pEnd
      
12568:          oNodeSet( resultType, qScope, oScopeCurrent )
12579:          oNodeSetInt( resultType, qSize, size )
12591:          oScopeEnd
12592:          oTypeAdd( resultType )
      
      
12598:       | '(' :
               % An enum type declaration.
12600:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12607:       | pSet :
12609:          pOf
12611:          Node theType
12611:          @TypeRef( theType )
12618:          #eNotImplemented
12620:       | * :       % this works for cases except where expr starts with an id
12635:          @ConstExpr '..' @ConstExpr
12641:          @ConstMatchTypes
12643:          #eNotImplemented
12645:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12646: EnumTypeRef( out Node resultType ):
      
12648:    resultType = oNodeNew( nEnumType )
12658:    int value = 0
12664:    int numValues = 0
12670:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12676:    Node outerScope = oScopeCurrent
12681:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12690:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12690:       pIdent
12692:       Node decl = @newIdent( nEnumValue, LAST_ID )
12705:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12718:       oNodeSet( decl, qType, resultType )
12730:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
12742:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
12755:       oNodeSetInt( decl, qNameOffset, nameOffset )
12767:       oNodeSetInt( decl2, qNameOffset, nameOffset )
12779:       [
12779:          | '=', ':=' :
12781:             oTypeSPush( IntegerType )
12787:             @ConstExpr
12789:             @ConstCoerceType
12791:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
12792:             [ equal_zero( numValues )
12799:                | false :
12800:                   [ greater( oValueTop, value )
12809:                      | false :   #eEnumValueNotAscending
12812:                      | * :
12817:                   ]
12817:                | * :
12822:             ]
12822:             [ equal( value, oValueTop )
12831:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
12832:                   oNodeSetBoolean( resultType, qHasGap, true )
12844:                | * :
12849:             ]
12849:             value = oValueTop
12854:             oValuePop
12855:          | * :
12862:       ]
12862:       oNodeSetInt( decl, qValue, value )
12874:       oNodeSetInt( decl2, qValue, value )
12886:       oScopeDeclare( decl )
      
12892:       oScopeEnter( outerScope )
12898:       oScopeDeclare( decl2 )
12904:       oScopeEnd
      
12905:       inc( value )
12911:       inc( numValues )
12917:       [
12917:          | ',' :
12919:          | * :    >
12926:       ]
12926:    }
12928:    ')'
      
12930:    oNodeSet( resultType, qScope, oScopeCurrent )
12941:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
12953:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
12954:    oCodePush( @GetOrCreateInitCode( globalScope ) )
12965:    oScopeEnter( globalScope )
12971:    int size = multiply( add( numValues, 1 ), 16 )
12991:    int addr = oScopeAlloc( size, 8 )
13004:    oScopeEnd
13005:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13017:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13037:    {
13037:       Node enumValue = oNodeIterValue( it )
13047:       [ oNodeNull( enumValue )
13054:          | true :  >
13057:          | * :
13062:       ]
13062:       .tPushAddrGlobal  oEmitInt( addr )
13070:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13085:       .tAssignI
13087:       addr = add( addr, 8 )
13100:       .tPushAddrGlobal  oEmitInt( addr )
13108:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13123:       .tAssignP
13125:       addr = add( addr, 8 )
13138:       oNodeIterNext( it )
13144:    }
         % final table entry
13146:    .tPushAddrGlobal  oEmitInt( addr )
13154:    .tPushConstI  oEmitInt( 0 )
13162:    .tAssignI
13164:    addr = add( addr, 8 )
13177:    .tPushAddrGlobal  oEmitInt( addr )
13185:    .tPushConstI  oEmitInt( 0 )
13193:    .tAssignP
13195:    addr = add( addr, 8 )
13208:    oCodePop
      
13209:    oTypeAdd( resultType )
13216:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13216: PointerTypeTo( Node theType ) >> Node:
13218:    Node ptrType = oNodeGet( theType, qPointerType )
13231:    [ oNodeNull( ptrType )
13238:       | true :
13239:          ptrType = oNodeNew( nPointerType )
13249:          oNodeSet( ptrType, qBaseType, theType )
13261:          oNodeSetInt( ptrType, qSize, 8 )
13273:          oTypeAdd( ptrType )
13279:          oNodeSet( theType, qPointerType, ptrType )
13291:       | * :
13296:    ]
13296:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13300: OrdinalLow( Node theType ) >> int:
13302:    [ oNodeType( theType )
13309:       | nIntegerType :  >> oMININT
13312:       | nBooleanType :  >> 0
13317:       | nCharType :     >> 0
13322:       | nEnumType :
13324:          Node enumScope = oNodeGet( theType, qScope )
13337:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13354:          >> oNodeGetInt( first, qValue )
13364:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13376:       | * :             #eNotOrdinalType
13391:                         >> 0
13394:    ];
      
      
      % Return the high value of an ordinal type
      %
13395: OrdinalHigh( Node theType ) >> int:
13397:    [ oNodeType( theType )
13404:       | nIntegerType :  >> oMAXINT
13407:       | nBooleanType :  >> 1
13412:       | nCharType :     >> 255
13417:       | nEnumType :
13419:          Node enumScope = oNodeGet( theType, qScope )
13432:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13449:          >> oNodeGetInt( last, qValue )
13459:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13471:       | * :             #eNotOrdinalType
13486:                         >> 0
13489:    ];
      
      
      
13490: Program:
13492:    Node t
      
13492:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13497:    oScopeBegin( 0, allocGlobal )
13506:    Node rootScope = oScopeCurrent
      
13511:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13513:    .tEnter  oEmitInt( 0 )
13521:    Label mainLabel = oLabelNew
      
13526:    .tAllocActuals  oEmitInt( 0 )
13534:    .tCall  oEmitLabel( mainLabel )
13542:    .tFreeActuals  oEmitInt( 0 )
13550:    .tReturn
      
13552:    pProgram
13554:    pIdent
      
13556:    Node program = oNodeNew( nProgram )
13566:    oNodeSetInt( program, qIdent, LAST_ID )
13577:    oNodeSet( workspace, qProgram, program )
      
      
13589:    [
13589:       | '(' :
13591:          pIdent      % input, output files
      
13593:          t = @newIdent( nVar, LAST_ID )
13606:          oNodeSet( t, qType, FileType )
13618:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13624:          ','
13626:          pIdent
      
13628:          t = @newIdent( nVar, LAST_ID )
13641:          oNodeSet( t, qType, FileType )
13653:          oScopeDeclareAlloc( t )
      
13659:          ')'
13661:       | * :
13666:    ]
13666:    ';'
      
13668:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13675:    [
13675:       | pUses :  @UsesClause( program )
13684:       | * :
13689:    ]
13689:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13696:    oScopeBegin( 0, allocGlobal )
13705:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13710:    oScopeBegin( 0, allocDown )
13719:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13730:    initScope = oScopeCurrent
13735:    oNodeSet( program, qMainRoutineScope, initScope )
13747:    oScopeEnd
      
13748:    @BlockDecls( nGlobalVar )
      
      
13755:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
13761:    boolean isMain = true
13767:    @BlockStmt( mainLabel, globalScope, isMain )
      
13780:    oScopeEnd   % main routine scope
      
13781:    '.'
13783:    @CheckForUndefinedLabels
13785:    oScopeEnd   % global scope
13786:    @EndUsedUnits( program )   % used units scopes
13794:    ;
      
      
      
      
13794: Block( node_type varNodeType, Label labelForBody ):
13796:    @BlockDecls( varNodeType )
13803:    @BlockStmt( labelForBody, oScopeCurrent, false )
13815:    @CheckForUndefinedLabels
13818:    ;
      
      
13818: BlockDecls( node_type varNodeType ):
13820:    {[
13820:       | pConst :     @ConstDecl
13824:       | pType :      @TypeDecl
13828:       | pVar :       @VarDecl( varNodeType )
13837:       | pLabel :     @LabelDecl
13841:       | pProcedure : @ProcDecl
13845:       | pFunction :  @FuncDecl
13849:       | * :          >
13866:    ]}
13868:    @CheckForUndefinedMethods
13871:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
13871: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
13874:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
13874: CheckForUndefinedLabels:
13876:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
13888:    {
13888:       Node decl = oNodeIterValue( it )
13898:       [ oNodeNull( decl )
13905:          | false :
13906:          | * :  >
13913:       ]
13913:       [ oNodeType( decl )
13920:          | nLabel :
13921:             [ oNodeGetBoolean( decl, qDefined )
13931:                | false :
13932:                   [ oNodeGetBoolean( decl, qUsed )
13942:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
13945:                      | * :
13950:                   ]
13950:                | * :
13955:             ]
13955:          | * :
13960:       ]
13960:       oNodeIterNext( it )
13966:    }
13969:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
13969: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
13971:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
13979:    int patchLS
13979:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
13988:    [ isMain
13991:       | true :  @InitializeUnits
13994:       | * :
13999:    ]
      
         % insert any code for initialization of this scope's variables
13999:    Code initCode = oNodeGetCode( varScope, qInitCode )
14012:    oEmitCode( initCode )
14018:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14030:    @Statement
      
14032:    [ isMain
14035:       | true :  @FinalizeUnits
14038:       | * :
14043:    ]
      
14043:    .tReturn
      
14045:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14057:    oPatch( patchLS, localSpace )
14067:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14067: GetOrCreateInitCode( Node scope ) >> Code:
14069:    Code initCode = oNodeGetCode( scope, qInitCode )
14082:    [ equal_code( initCode, codeNull )
14092:       | true :
14093:          initCode = oCodeNew
14098:          oNodeSetCode( scope, qInitCode, initCode )
14110:       | * :
14115:    ]
14115:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14119: ScopeLevel >> int:
14121:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14131: DeclLevel( Node decl ) >> int:
14133:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14151: DeclUpLevels( Node decl ) >> int:
14153:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14169: newIdent( node_type nt, int id ) >> Node:
14171:   Node t = oNodeNew( nt )
14181:   oNodeSetInt( t, qIdent, id )
14193:   >> t
14197:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14197: EmitValue( Node decl ):
14199:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14213: DeclareBuiltInFunc( int id ) >> Node:
14215:    Node decl = @newIdent( nBuiltInFunc, id )
14229:    oScopeDeclare( decl )
14235:    >> decl;
      
      
14239: installBuiltIns:
      
         % initialize some other globals too
14241:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14247:    mysystemId = oId_mysystem
      
         % install built-in types
14252:    FileType = @newType( nFileType, 4 )
14266:    IntegerType = @newType( nIntegerType, 4 )
14280:    BooleanType = @newType( nBooleanType, 1 )
14294:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14308:    CharType = @newType( nCharType, 1 )
14322:    PCharType = @PointerTypeTo( CharType )
14333:    ByteType = @newType( nByteType, 1 )
14347:    SingleType = @newType( nSingleType, 4 )
14361:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14375:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14389:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14401:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14415:    ShortStringType = @newType( nShortStringType, 256 )
14429:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14441:    Node t
      
14441:    t = @newIdent( nTypeDecl, oId_File )
14454:    oNodeSet( t, qType, FileType )
14466:    oScopeDeclare( t )
      
14472:    t = @newIdent( nTypeDecl, oId_Integer )
14485:    oNodeSet( t, qType, IntegerType )
14497:    oScopeDeclare( t )
      
14503:    t = @newIdent( nTypeDecl, oId_Boolean )
14516:    oNodeSet( t, qType, BooleanType )
14528:    oScopeDeclare( t )
      
14534:    t = @newIdent( nTypeDecl, oId_Char )
14547:    oNodeSet( t, qType, CharType )
14559:    oScopeDeclare( t )
      
14565:    t = @newIdent( nTypeDecl, oId_Byte )
14578:    oNodeSet( t, qType, ByteType )
14590:    oScopeDeclare( t )
      
14596:    t = @newIdent( nTypeDecl, oId_Single )
14609:    oNodeSet( t, qType, SingleType )
14621:    oScopeDeclare( t )
      
14627:    t = @newIdent( nTypeDecl, oId_Double )
14640:    oNodeSet( t, qType, DoubleType )
14652:    oScopeDeclare( t )
      
14658:    t = @newIdent( nTypeDecl, oId_Pointer )
14671:    oNodeSet( t, qType, UniversalPointerType )
14683:    oScopeDeclare( t )
      
14689:    t = @newIdent( nTypeDecl, oId_ShortString )
14702:    oNodeSet( t, qType, ShortStringType )
14714:    oScopeDeclare( t )
      
         % Built-in constants
      
14720:    t = @newIdent( nConst, oId_True )
14733:    oNodeSet( t, qType, BooleanType )
14745:    oNodeSetInt( t, qValue, 1 )
14757:    oScopeDeclare( t )
      
14763:    t = @newIdent( nConst, oId_False )
14776:    oNodeSet( t, qType, BooleanType )
14788:    oNodeSetInt( t, qValue, 0 )
14800:    oScopeDeclare( t )
      
14806:    t = @newIdent( nConst, oId_Nil )
14819:    oNodeSet( t, qType, UniversalPointerType )
14831:    oNodeSetInt( t, qValue, 0 )
14843:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
14849:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
14859:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
14869:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
14879:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
14889:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
14900:    ;
      
14900: end
      
14900: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13490
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 26
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 25
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3184
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3240
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 13818
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 88
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 78
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 106
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8882
1083: oInputChoice 1089
1085: oCall 8882
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 77
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 88
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 78
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 106
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8882
1177: oInputChoice 1183
1179: oCall 8882
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 77
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 72
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 75
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 74
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 72
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 75
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 74
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14131
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 11745
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14169
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 22
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 22
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 14119
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13216
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 22
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 13794
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14169
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 22
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 22
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 14119
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13216
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 12137
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13216
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 22
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 13794
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 24
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14169
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 34
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 12137
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13216
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2654
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3539
2556: oTypeSNodeType
2557: oChoice 2613
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14169
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2632
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 18
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14169
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 33
2605: oPushResult
2606: oValueTopString
2607: oPushResult
2608: oNodeSetString
2609: oPop 3
2611: oJumpForward 2632
2613: Choice Lookup Table
          41   2586
          37   2559
          36   2559
          43   2559
          30   2559
          35   2559
          29   2559
          33   2559
2630: oError 18
2632: oValuePop
2633: oGetLocal 2
2635: oPushResult
2636: oSetResult 21
2638: oPushResult
2639: oTypeSTop
2640: oPushResult
2641: oNodeSet
2642: oPop 3
2644: oTypeSPop
2645: oGetLocal 2
2647: oPushResult
2648: oScopeDeclare
2649: oPop 1
2651: oInput 6
2653: oReturn
2654: oLocalSpace 3
2656: oGetAddrLocal 1
2658: oPushResult
2659: oSetResult 25
2661: oPushResult
2662: LAST_ID
2663: oPushResult
2664: oCall 14169
2666: oPop 2
2668: oAssign
2669: oGetAddrLocal 2
2671: oPushResult
2672: oCall 12137
2674: oPop 1
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 21
2681: oPushResult
2682: oGetLocal 2
2684: oPushResult
2685: oNodeSet
2686: oPop 3
2688: oGetLocal 2
2690: oPushResult
2691: oNodeType
2692: oPop 1
2694: oChoice 2798
2696: oInput 7
2698: oGetLocal 2
2700: oPushResult
2701: oTypeSPush
2702: oPop 1
2704: oCall 3539
2706: oCall 4351
2708: oGetLocal 1
2710: oPushResult
2711: oSetResult 22
2713: oPushResult
2714: oValueTop
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oValuePop
2720: oTypeSPop
2721: oGetLocal 1
2723: oPushResult
2724: oScopeDeclare
2725: oPop 1
2727: oInput 6
2729: oJumpForward 2822
2731: oError 17
2733: oJumpForward 2822
2735: oGetGlobal 2
2737: oPushResult
2738: oScopeEnter
2739: oPop 1
2741: oGetAddrLocal 3
2743: oPushResult
2744: oGetLocal 2
2746: oPushResult
2747: oScopeAllocType
2748: oPop 1
2750: oAssign
2751: oScopeEnd
2752: oGetGlobal 2
2754: oPushResult
2755: oCall 14067
2757: oPop 1
2759: oPushResult
2760: oCodePush
2761: oPop 1
2763: oGetLocal 1
2765: oPushResult
2766: oSetResult 22
2768: oPushResult
2769: oGetLocal 3
2771: oPushResult
2772: oNodeSetInt
2773: oPop 3
2775: oInput 7
2777: oGetLocal 2
2779: oPushResult
2780: oGetLocal 3
2782: oPushResult
2783: oCall 2823
2785: oPop 2
2787: oCodePop
2788: oGetLocal 1
2790: oPushResult
2791: oScopeDeclare
2792: oPop 1
2794: oInput 6
2796: oJumpForward 2822
2798: Choice Lookup Table
          40   2735
          38   2735
          28   2731
          42   2731
          37   2696
          36   2696
          43   2696
          30   2696
          35   2696
          29   2696
          33   2696
2821: oEndChoice
2822: oReturn
2823: oLocalSpace 10
2825: oGetParam 2
2827: oPushResult
2828: oNodeType
2829: oPop 1
2831: oChoice 3157
2833: oGetAddrLocal 1
2835: oPushResult
2836: oGetParam 2
2838: oPushResult
2839: oSetResult 37
2841: oPushResult
2842: oNodeGet
2843: oPop 2
2845: oAssign
2846: oGetAddrLocal 2
2848: oPushResult
2849: oGetParam 2
2851: oPushResult
2852: oSetResult 38
2854: oPushResult
2855: oNodeGet
2856: oPop 2
2858: oAssign
2859: oGetAddrLocal 3
2861: oPushResult
2862: oGetLocal 2
2864: oPushResult
2865: oCall 13300
2867: oPop 1
2869: oAssign
2870: oGetAddrLocal 4
2872: oPushResult
2873: oGetLocal 2
2875: oPushResult
2876: oCall 13395
2878: oPop 1
2880: oAssign
2881: oGetAddrLocal 5
2883: oPushResult
2884: oGetLocal 1
2886: oPushResult
2887: oSetResult 17
2889: oPushResult
2890: oNodeGetInt
2891: oPop 2
2893: oAssign
2894: oInput 15
2896: oGetAddrLocal 6
2898: oPushResult
2899: oGetLocal 3
2901: oAssign
2902: oGetLocal 1
2904: oPushResult
2905: oGetParam 1
2907: oPushResult
2908: oCall 2823
2910: oPop 2
2912: oGetLocal 6
2914: oPushResult
2915: oGetLocal 4
2917: oPushResult
2918: equal
2919: oPop 2
2921: oChoice 2929
2923: oJumpForward 2958
2925: oJumpForward 2935
2927: oJumpForward 2935
2929: Choice Lookup Table
           0   2927
           1   2923
2934: oEndChoice
2935: oInput 14
2937: oGetAddrParam 1
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oGetLocal 5
2945: oPushResult
2946: add
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 6
2952: oPushResult
2953: inc
2954: oPop 1
2956: oJumpBack 2902
2958: oInput 16
2960: oJumpForward 3183
2962: oInput 15
2964: oGetAddrLocal 7
2966: oPushResult
2967: oGetParam 2
2969: oPushResult
2970: oSetResult 41
2972: oPushResult
2973: oNodeGet
2974: oPop 2
2976: oAssign
2977: oInputChoice 2981
2979: oJumpForward 2986
2981: Choice Lookup Table
           0   2979
2984: oJumpForward 3052
2986: oGetAddrLocal 8
2988: oPushResult
2989: oGetLocal 7
2991: oPushResult
2992: oScopeFindRequireInScope
2993: oPop 1
2995: oAssign
2996: oInput 13
2998: oGetAddrLocal 9
3000: oPushResult
3001: oGetLocal 8
3003: oPushResult
3004: oSetResult 21
3006: oPushResult
3007: oNodeGet
3008: oPop 2
3010: oAssign
3011: oGetAddrLocal 10
3013: oPushResult
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 8
3019: oPushResult
3020: oSetResult 22
3022: oPushResult
3023: oNodeGetInt
3024: oPop 2
3026: oPushResult
3027: add
3028: oPop 2
3030: oAssign
3031: oGetLocal 9
3033: oPushResult
3034: oGetLocal 10
3036: oPushResult
3037: oCall 2823
3039: oPop 2
3041: oInputChoice 3045
3043: oJumpForward 3050
3045: Choice Lookup Table
           6   3043
3048: oJumpForward 3052
3050: oJumpBack 2977
3052: oInput 16
3054: oJumpForward 3183
3056: oEmit 17
3058: oGetParam 1
3060: oPushResult
3061: oEmitInt
3062: oPop 1
3064: oGetParam 2
3066: oPushResult
3067: oTypeSPush
3068: oPop 1
3070: oCall 3539
3072: oCall 4351
3074: oEmit 15
3076: oValueTop
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oValuePop
3082: oTypeSPop
3083: oEmit 28
3085: oJumpForward 3183
3087: oEmit 17
3089: oGetParam 1
3091: oPushResult
3092: oEmitInt
3093: oPop 1
3095: oGetParam 2
3097: oPushResult
3098: oTypeSPush
3099: oPop 1
3101: oCall 3539
3103: oCall 4351
3105: oEmit 15
3107: oValueTop
3108: oPushResult
3109: oEmitInt
3110: oPop 1
3112: oValuePop
3113: oTypeSPop
3114: oEmit 27
3116: oJumpForward 3183
3118: oError 17
3120: oJumpForward 3183
3122: oEmit 17
3124: oGetParam 1
3126: oPushResult
3127: oEmitInt
3128: oPop 1
3130: oGetParam 2
3132: oPushResult
3133: oTypeSPush
3134: oPop 1
3136: oCall 3539
3138: oCall 4351
3140: oEmit 15
3142: oValueTop
3143: oPushResult
3144: oEmitInt
3145: oPop 1
3147: oValuePop
3148: oTypeSPop
3149: oEmit 29
3151: oJumpForward 3183
3153: oError 17
3155: oJumpForward 3183
3157: Choice Lookup Table
          28   3153
          42   3153
          37   3122
          36   3122
          32   3118
          43   3087
          30   3087
          35   3056
          29   3056
          33   3056
          40   2962
          38   2833
3182: oEndChoice
3183: oReturn
3184: oLocalSpace 2
3186: oInputChoice 3232
3188: oGetAddrLocal 1
3190: oPushResult
3191: oSetResult 19
3193: oPushResult
3194: LAST_ID
3195: oPushResult
3196: oCall 14169
3198: oPop 2
3200: oAssign
3201: oInput 7
3203: oGetAddrLocal 2
3205: oPushResult
3206: oCall 12137
3208: oPop 1
3210: oGetLocal 1
3212: oPushResult
3213: oSetResult 21
3215: oPushResult
3216: oGetLocal 2
3218: oPushResult
3219: oNodeSet
3220: oPop 3
3222: oGetLocal 1
3224: oPushResult
3225: oScopeDeclare
3226: oPop 1
3228: oInput 6
3230: oJumpForward 3237
3232: Choice Lookup Table
           0   3188
3235: oJumpForward 3239
3237: oJumpBack 3186
3239: oReturn
3240: oLocalSpace 6
3242: oInputChoice 3466
3244: oGetAddrLocal 1
3246: oPushResult
3247: oNodeVecNew
3248: oAssign
3249: oGetAddrLocal 2
3251: oPushResult
3252: oGetParam 1
3254: oPushResult
3255: LAST_ID
3256: oPushResult
3257: oCall 14169
3259: oPop 2
3261: oAssign
3262: oGetLocal 1
3264: oPushResult
3265: oGetLocal 2
3267: oPushResult
3268: oNodeVecAppend
3269: oPop 2
3271: oInputChoice 3277
3273: oInput 0
3275: oJumpForward 3282
3277: Choice Lookup Table
          14   3273
3280: oJumpForward 3284
3282: oJumpBack 3249
3284: oInput 13
3286: oGetAddrLocal 3
3288: oPushResult
3289: oCall 12137
3291: oPop 1
3293: oGetAddrLocal 4
3295: oPushResult
3296: oSetResult 0
3298: oAssign
3299: oGetLocal 4
3301: oPushResult
3302: oGetLocal 1
3304: oPushResult
3305: oNodeVecSize
3306: oPop 1
3308: oPushResult
3309: equal
3310: oPop 2
3312: oChoice 3353
3314: oGetAddrLocal 2
3316: oPushResult
3317: oGetLocal 1
3319: oPushResult
3320: oGetLocal 4
3322: oPushResult
3323: oNodeVecElement
3324: oPop 2
3326: oAssign
3327: oGetLocal 2
3329: oPushResult
3330: oSetResult 21
3332: oPushResult
3333: oGetLocal 3
3335: oPushResult
3336: oNodeSet
3337: oPop 3
3339: oGetLocal 2
3341: oPushResult
3342: oScopeDeclareAlloc
3343: oPop 1
3345: oGetAddrLocal 4
3347: oPushResult
3348: inc
3349: oPop 1
3351: oJumpForward 3358
3353: Choice Lookup Table
           0   3314
3356: oJumpForward 3360
3358: oJumpBack 3299
3360: oInputChoice 3453
3362: oGetLocal 1
3364: oPushResult
3365: oNodeVecSize
3366: oPop 1
3368: oChoice 3372
3370: oJumpForward 3377
3372: Choice Lookup Table
           1   3370
3375: oError 23
3377: oGetAddrLocal 5
3379: oPushResult
3380: oScopeCurrent
3381: oPushResult
3382: oCall 14067
3384: oPop 1
3386: oAssign
3387: oGetLocal 5
3389: oPushResult
3390: oCodePush
3391: oPop 1
3393: oGetAddrLocal 6
3395: oPushResult
3396: oSetResult 0
3398: oAssign
3399: oCall 14119
3401: oPushResult
3402: equal_zero
3403: oPop 1
3405: oChoice 3421
3407: oGetGlobal 3
3409: oPushResult
3410: oScopeEnter
3411: oPop 1
3413: oGetAddrLocal 6
3415: oPushResult
3416: oSetResult 1
3418: oAssign
3419: oJumpForward 3424
3421: Choice Lookup Table
           1   3407
3424: oGetLocal 2
3426: oPushResult
3427: oSetResult 1
3429: oPushResult
3430: oCall 9580
3432: oPop 2
3434: oCall 4887
3436: oCall 8345
3438: oCall 9128
3440: oGetLocal 6
3442: oChoice 3447
3444: oScopeEnd
3445: oJumpForward 3450
3447: Choice Lookup Table
           1   3444
3450: oCodePop
3451: oJumpForward 3456
3453: Choice Lookup Table
           7   3362
3456: oGetLocal 1
3458: oPushResult
3459: oNodeVecDelete
3460: oPop 1
3462: oInput 6
3464: oJumpForward 3471
3466: Choice Lookup Table
           0   3244
3469: oJumpForward 3473
3471: oJumpBack 3242
3473: oReturn
3474: oLocalSpace 2
3476: oInputChoice 3483
3478: oJumpForward 3489
3480: oChangeIntLitToLabelIdent
3481: oJumpForward 3489
3483: Choice Lookup Table
           1   3480
           0   3478
3488: oEndChoice
3489: oGetAddrLocal 1
3491: oPushResult
3492: oSetResult 26
3494: oPushResult
3495: LAST_ID
3496: oPushResult
3497: oCall 14169
3499: oPop 2
3501: oAssign
3502: oGetAddrLocal 2
3504: oPushResult
3505: oLabelNew
3506: oAssign
3507: oGetLocal 1
3509: oPushResult
3510: oSetResult 22
3512: oPushResult
3513: oGetLocal 2
3515: oPushResult
3516: oNodeSetLabel
3517: oPop 3
3519: oGetLocal 1
3521: oPushResult
3522: oScopeDeclare
3523: oPop 1
3525: oInputChoice 3529
3527: oJumpForward 3534
3529: Choice Lookup Table
          14   3527
3532: oJumpForward 3536
3534: oJumpBack 3476
3536: oInput 6
3538: oReturn
3539: oLocalSpace 0
3541: oCall 3766
3543: oInputChoice 3725
3545: oCall 3789
3547: oCall 4254
3549: oTypeSNodeType
3550: oChoice 3562
3552: oValueStringCmp
3553: oSetResult 0
3555: oPushResult
3556: oValuePush
3557: oPop 1
3559: oValueEqual
3560: oJumpForward 3566
3562: Choice Lookup Table
          41   3552
3565: oValueEqual
3566: oTypeSPop
3567: oGetGlobal 7
3569: oPushResult
3570: oTypeSPush
3571: oPop 1
3573: oJumpForward 3740
3575: oCall 3766
3577: oCall 4254
3579: oTypeSNodeType
3580: oChoice 3592
3582: oValueStringCmp
3583: oSetResult 0
3585: oPushResult
3586: oValuePush
3587: oPop 1
3589: oValueNotEqual
3590: oJumpForward 3596
3592: Choice Lookup Table
          41   3582
3595: oValueNotEqual
3596: oTypeSPop
3597: oGetGlobal 7
3599: oPushResult
3600: oTypeSPush
3601: oPop 1
3603: oJumpForward 3740
3605: oCall 3766
3607: oCall 4254
3609: oTypeSNodeType
3610: oChoice 3622
3612: oValueStringCmp
3613: oSetResult 0
3615: oPushResult
3616: oValuePush
3617: oPop 1
3619: oValueLess
3620: oJumpForward 3626
3622: Choice Lookup Table
          41   3612
3625: oValueLess
3626: oTypeSPop
3627: oGetGlobal 7
3629: oPushResult
3630: oTypeSPush
3631: oPop 1
3633: oJumpForward 3740
3635: oCall 3766
3637: oCall 4254
3639: oTypeSNodeType
3640: oChoice 3652
3642: oValueStringCmp
3643: oSetResult 0
3645: oPushResult
3646: oValuePush
3647: oPop 1
3649: oValueGreater
3650: oJumpForward 3656
3652: Choice Lookup Table
          41   3642
3655: oValueGreater
3656: oTypeSPop
3657: oGetGlobal 7
3659: oPushResult
3660: oTypeSPush
3661: oPop 1
3663: oJumpForward 3740
3665: oCall 3766
3667: oCall 4254
3669: oTypeSNodeType
3670: oChoice 3682
3672: oValueStringCmp
3673: oSetResult 0
3675: oPushResult
3676: oValuePush
3677: oPop 1
3679: oValueLessEqual
3680: oJumpForward 3686
3682: Choice Lookup Table
          41   3672
3685: oValueLessEqual
3686: oTypeSPop
3687: oGetGlobal 7
3689: oPushResult
3690: oTypeSPush
3691: oPop 1
3693: oJumpForward 3740
3695: oCall 3766
3697: oCall 4254
3699: oTypeSNodeType
3700: oChoice 3712
3702: oValueStringCmp
3703: oSetResult 0
3705: oPushResult
3706: oValuePush
3707: oPop 1
3709: oValueGreaterEqual
3710: oJumpForward 3716
3712: Choice Lookup Table
          41   3702
3715: oValueGreaterEqual
3716: oTypeSPop
3717: oGetGlobal 7
3719: oPushResult
3720: oTypeSPush
3721: oPop 1
3723: oJumpForward 3740
3725: Choice Lookup Table
          12   3695
          11   3665
          10   3635
           9   3605
           8   3575
           7   3545
3738: oJumpForward 3742
3740: oJumpBack 3543
3742: oReturn
3743: oLocalSpace 1
3745: oGetAddrLocal 1
3747: oPushResult
3748: oGetGlobal 25
3750: oAssign
3751: oGetAddrGlobal 25
3753: oPushResult
3754: oSetResult 1
3756: oAssign
3757: oCall 3539
3759: oGetAddrGlobal 25
3761: oPushResult
3762: oGetLocal 1
3764: oAssign
3765: oReturn
3766: oLocalSpace 0
3768: oCall 3789
3770: oInputChoice 3781
3772: oCall 4241
3774: oCall 3789
3776: oCall 4227
3778: oValueOr
3779: oJumpForward 3786
3781: Choice Lookup Table
          58   3772
3784: oJumpForward 3788
3786: oJumpBack 3770
3788: oReturn
3789: oLocalSpace 0
3791: oCall 3812
3793: oInputChoice 3804
3795: oCall 4241
3797: oCall 3812
3799: oCall 4227
3801: oValueAnd
3802: oJumpForward 3809
3804: Choice Lookup Table
          57   3795
3807: oJumpForward 3811
3809: oJumpBack 3793
3811: oReturn
3812: oLocalSpace 0
3814: oInputChoice 3823
3816: oCall 3812
3818: oCall 4241
3820: oValueNot
3821: oJumpForward 3828
3823: Choice Lookup Table
          59   3816
3826: oCall 3829
3828: oReturn
3829: oLocalSpace 0
3831: oCall 3878
3833: oInputChoice 3868
3835: oCall 3878
3837: oCall 4254
3839: oTypeSNodeType
3840: oChoice 3845
3842: oValueStringConcat
3843: oJumpForward 3849
3845: Choice Lookup Table
          41   3842
3848: oValueAdd
3849: oJumpForward 3875
3851: oCall 3878
3853: oCall 4254
3855: oTypeSNodeType
3856: oChoice 3862
3858: oError 18
3860: oJumpForward 3866
3862: Choice Lookup Table
          41   3858
3865: oValueSub
3866: oJumpForward 3875
3868: Choice Lookup Table
          26   3851
          25   3835
3873: oJumpForward 3877
3875: oJumpBack 3833
3877: oReturn
3878: oLocalSpace 0
3880: oCall 3928
3882: oInputChoice 3918
3884: oCall 3928
3886: oCall 4254
3888: oTypeSNodeType
3889: oChoice 3895
3891: oError 18
3893: oJumpForward 3899
3895: Choice Lookup Table
          41   3891
3898: oValueMult
3899: oJumpForward 3925
3901: oCall 3928
3903: oCall 4254
3905: oTypeSNodeType
3906: oChoice 3912
3908: oError 18
3910: oJumpForward 3916
3912: Choice Lookup Table
          41   3908
3915: oValueDiv
3916: oJumpForward 3925
3918: Choice Lookup Table
          24   3901
          23   3884
3923: oJumpForward 3927
3925: oJumpBack 3882
3927: oReturn
3928: oLocalSpace 0
3930: oInputChoice 3941
3932: oCall 3949
3934: oJumpForward 3948
3936: oCall 3949
3938: oValueNegate
3939: oJumpForward 3948
3941: Choice Lookup Table
          26   3936
          25   3932
3946: oCall 3949
3948: oReturn
3949: oLocalSpace 1
3951: oInputChoice 4199
3953: TOKEN_VALUE
3954: oPushResult
3955: oValuePush
3956: oPop 1
3958: oGetGlobal 6
3960: oPushResult
3961: oTypeSPush
3962: oPop 1
3964: oJumpForward 4226
3966: TOKEN_VALUE
3967: oPushResult
3968: oValuePush
3969: oPop 1
3971: oGetGlobal 9
3973: oPushResult
3974: oTypeSPush
3975: oPop 1
3977: oJumpForward 4226
3979: CURRENT_STRLIT
3980: oPushResult
3981: oValuePushString
3982: oPop 1
3984: oGetGlobal 15
3986: oPushResult
3987: oTypeSPush
3988: oPop 1
3990: oJumpForward 4226
3992: oCall 3539
3994: oInput 16
3996: oJumpForward 4226
3998: oGetAddrLocal 1
4000: oPushResult
4001: oScopeFindRequire
4002: oAssign
4003: oGetAddrLocal 1
4005: oPushResult
4006: oCall 244
4008: oPop 1
4010: oGetLocal 1
4012: oPushResult
4013: oNodeType
4014: oPop 1
4016: oChoice 4156
4018: oGetLocal 1
4020: oPushResult
4021: oCall 4621
4023: oPop 1
4025: oJumpForward 4181
4027: oGetLocal 1
4029: oPushResult
4030: oSetResult 22
4032: oPushResult
4033: oNodeGetInt
4034: oPop 2
4036: oPushResult
4037: oValuePush
4038: oPop 1
4040: oGetLocal 1
4042: oPushResult
4043: oSetResult 21
4045: oPushResult
4046: oNodeGet
4047: oPop 2
4049: oPushResult
4050: oTypeSPush
4051: oPop 1
4053: oJumpForward 4181
4055: oGetLocal 1
4057: oPushResult
4058: oSetResult 33
4060: oPushResult
4061: oNodeGetString
4062: oPop 2
4064: oPushResult
4065: oValuePushString
4066: oPop 1
4068: oGetLocal 1
4070: oPushResult
4071: oSetResult 21
4073: oPushResult
4074: oNodeGet
4075: oPop 2
4077: oPushResult
4078: oTypeSPush
4079: oPop 1
4081: oJumpForward 4181
4083: oGetLocal 1
4085: oPushResult
4086: oSetResult 22
4088: oPushResult
4089: oNodeGetInt
4090: oPop 2
4092: oPushResult
4093: oValuePush
4094: oPop 1
4096: oGetLocal 1
4098: oPushResult
4099: oSetResult 21
4101: oPushResult
4102: oNodeGet
4103: oPop 2
4105: oPushResult
4106: oTypeSPush
4107: oPop 1
4109: oJumpForward 4181
4111: oGetLocal 1
4113: oPushResult
4114: oSetResult 21
4116: oPushResult
4117: oNodeGet
4118: oPop 2
4120: oPushResult
4121: oTypeSPush
4122: oPop 1
4124: oInputChoice 4134
4126: oCall 3539
4128: oInput 16
4130: oCall 4472
4132: oJumpForward 4154
4134: Choice Lookup Table
          15   4126
4137: oGetGlobal 25
4139: oChoice 4149
4141: oSetResult 0
4143: oPushResult
4144: oValuePush
4145: oPop 1
4147: oJumpForward 4154
4149: Choice Lookup Table
           1   4141
4152: oError 32
4154: oJumpForward 4181
4156: Choice Lookup Table
          19   4111
          17   4083
          18   4055
          16   4027
          14   4018
4167: oError 1
4169: oSetResult 0
4171: oPushResult
4172: oValuePush
4173: oPop 1
4175: oGetGlobal 6
4177: oPushResult
4178: oTypeSPush
4179: oPop 1
4181: oJumpForward 4226
4183: oError 17
4185: oSetResult 0
4187: oPushResult
4188: oValuePush
4189: oPop 1
4191: oGetGlobal 14
4193: oPushResult
4194: oTypeSPush
4195: oPop 1
4197: oJumpForward 4226
4199: Choice Lookup Table
          20   4183
           0   3998
          15   3992
           3   3979
           4   3966
           1   3953
4212: oError 1
4214: oSetResult 0
4216: oPushResult
4217: oValuePush
4218: oPop 1
4220: oGetGlobal 6
4222: oPushResult
4223: oTypeSPush
4224: oPop 1
4226: oReturn
4227: oLocalSpace 0
4229: oTypeSNodeType
4230: oChoice 4234
4232: oJumpForward 4239
4234: Choice Lookup Table
          33   4232
4237: oError 8
4239: oTypeSPop
4240: oReturn
4241: oLocalSpace 0
4243: oTypeSNodeType
4244: oChoice 4248
4246: oJumpForward 4253
4248: Choice Lookup Table
          33   4246
4251: oError 8
4253: oReturn
4254: oLocalSpace 1
4256: oGetAddrLocal 1
4258: oPushResult
4259: oTypeSNodeType
4260: oAssign
4261: oTypeSPop
4262: oGetLocal 1
4264: oPushResult
4265: oTypeSNodeType
4266: oPushResult
4267: equal_node_type
4268: oPop 2
4270: oChoice 4347
4272: oTypeSNodeType
4273: oChoice 4334
4275: oGetLocal 1
4277: oChoice 4282
4279: oReturn
4280: oJumpForward 4285
4282: Choice Lookup Table
          37   4279
4285: oJumpForward 4343
4287: oGetLocal 1
4289: oChoice 4294
4291: oReturn
4292: oJumpForward 4297
4294: Choice Lookup Table
          36   4291
4297: oJumpForward 4343
4299: oGetLocal 1
4301: oChoice 4307
4303: oValueCharToString
4304: oReturn
4305: oJumpForward 4310
4307: Choice Lookup Table
          35   4303
4310: oJumpForward 4343
4312: oGetLocal 1
4314: oChoice 4329
4316: oValueSwap
4317: oValueCharToString
4318: oValueSwap
4319: oTypeSPop
4320: oGetGlobal 15
4322: oPushResult
4323: oTypeSPush
4324: oPop 1
4326: oReturn
4327: oJumpForward 4332
4329: Choice Lookup Table
          41   4316
4332: oJumpForward 4343
4334: Choice Lookup Table
          35   4312
          41   4299
          37   4287
          36   4275
4343: oError 15
4345: oJumpForward 4350
4347: Choice Lookup Table
           0   4272
4350: oReturn
4351: oLocalSpace 1
4353: oGetAddrLocal 1
4355: oPushResult
4356: oTypeSNodeType
4357: oAssign
4358: oTypeSPop
4359: oGetLocal 1
4361: oPushResult
4362: oTypeSNodeType
4363: oPushResult
4364: equal_node_type
4365: oPop 2
4367: oChoice 4468
4369: oTypeSNodeType
4370: oChoice 4451
4372: oGetLocal 1
4374: oChoice 4379
4376: oReturn
4377: oJumpForward 4382
4379: Choice Lookup Table
          29   4376
4382: oJumpForward 4464
4384: oGetLocal 1
4386: oChoice 4391
4388: oReturn
4389: oJumpForward 4394
4391: Choice Lookup Table
          30   4388
4394: oJumpForward 4464
4396: oGetLocal 1
4398: oChoice 4403
4400: oReturn
4401: oJumpForward 4406
4403: Choice Lookup Table
          37   4400
4406: oJumpForward 4464
4408: oGetLocal 1
4410: oChoice 4415
4412: oReturn
4413: oJumpForward 4418
4415: Choice Lookup Table
          36   4412
4418: oJumpForward 4464
4420: oGetLocal 1
4422: oChoice 4428
4424: oValueCharToString
4425: oReturn
4426: oJumpForward 4431
4428: Choice Lookup Table
          35   4424
4431: oJumpForward 4464
4433: oGetLocal 1
4435: oChoice 4444
4437: oReturn
4438: oJumpForward 4449
4440: oValueCharToString
4441: oReturn
4442: oJumpForward 4449
4444: Choice Lookup Table
          35   4440
          41   4437
4449: oJumpForward 4464
4451: Choice Lookup Table
          42   4433
          41   4420
          37   4408
          36   4396
          29   4384
          30   4372
4464: oError 15
4466: oJumpForward 4471
4468: Choice Lookup Table
           0   4369
4471: oReturn
4472: oLocalSpace 1
4474: oGetAddrLocal 1
4476: oPushResult
4477: oTypeSNodeType
4478: oAssign
4479: oTypeSPop
4480: oGetLocal 1
4482: oPushResult
4483: oTypeSNodeType
4484: oPushResult
4485: equal_node_type
4486: oPop 2
4488: oChoice 4617
4490: oTypeSNodeType
4491: oChoice 4594
4493: oGetLocal 1
4495: oChoice 4503
4497: oReturn
4498: oJumpForward 4514
4500: oReturn
4501: oJumpForward 4514
4503: Choice Lookup Table
          43   4500
          30   4500
          33   4497
          35   4497
          29   4497
4514: oJumpForward 4613
4516: oGetLocal 1
4518: oChoice 4526
4520: oReturn
4521: oJumpForward 4537
4523: oReturn
4524: oJumpForward 4537
4526: Choice Lookup Table
          43   4523
          30   4523
          33   4520
          35   4520
          29   4520
4537: oJumpForward 4613
4539: oGetLocal 1
4541: oChoice 4546
4543: oReturn
4544: oJumpForward 4549
4546: Choice Lookup Table
          37   4543
4549: oJumpForward 4613
4551: oGetLocal 1
4553: oChoice 4558
4555: oReturn
4556: oJumpForward 4561
4558: Choice Lookup Table
          36   4555
4561: oJumpForward 4613
4563: oGetLocal 1
4565: oChoice 4571
4567: oValueCharToString
4568: oReturn
4569: oJumpForward 4574
4571: Choice Lookup Table
          35   4567
4574: oJumpForward 4613
4576: oGetLocal 1
4578: oChoice 4587
4580: oReturn
4581: oJumpForward 4592
4583: oValueCharToString
4584: oReturn
4585: oJumpForward 4592
4587: Choice Lookup Table
          35   4583
          41   4580
4592: oJumpForward 4613
4594: Choice Lookup Table
          42   4576
          41   4563
          37   4551
          36   4539
          33   4516
          35   4516
          29   4516
          43   4493
          30   4493
4613: oError 15
4615: oJumpForward 4620
4617: Choice Lookup Table
           0   4490
4620: oReturn
4621: oLocalSpace 1
4623: oGetParam 1
4625: oPushResult
4626: oGetGlobal 17
4628: oPushResult
4629: oNodeEqual
4630: oPop 2
4632: oChoice 4672
4634: oInput 15
4636: oCall 3539
4638: oInput 16
4640: oTypeSNodeType
4641: oChoice 4647
4643: oJumpForward 4660
4645: oJumpForward 4660
4647: Choice Lookup Table
          35   4645
          29   4645
          33   4645
          43   4643
          30   4643
4658: oError 15
4660: oTypeSPop
4661: oGetGlobal 6
4663: oPushResult
4664: oTypeSPush
4665: oPop 1
4667: oInput 16
4669: oReturn
4670: oJumpForward 4675
4672: Choice Lookup Table
           1   4634
4675: oGetParam 1
4677: oPushResult
4678: oGetGlobal 18
4680: oPushResult
4681: oNodeEqual
4682: oPop 2
4684: oChoice 4718
4686: oInput 15
4688: oCall 3539
4690: oInput 16
4692: oTypeSNodeType
4693: oChoice 4699
4695: oJumpForward 4706
4697: oJumpForward 4706
4699: Choice Lookup Table
          29   4697
          30   4695
4704: oError 15
4706: oTypeSPop
4707: oGetGlobal 9
4709: oPushResult
4710: oTypeSPush
4711: oPop 1
4713: oInput 16
4715: oReturn
4716: oJumpForward 4721
4718: Choice Lookup Table
           1   4686
4721: oGetParam 1
4723: oPushResult
4724: oGetGlobal 19
4726: oPushResult
4727: oNodeEqual
4728: oPop 2
4730: oChoice 4775
4732: oInput 15
4734: oCall 3539
4736: oTypeSNodeType
4737: oChoice 4758
4739: oTypeSTop
4740: oPushResult
4741: oSetResult 44
4743: oPushResult
4744: oNodeGetBoolean
4745: oPop 2
4747: oChoice 4753
4749: oError 29
4751: oJumpForward 4756
4753: Choice Lookup Table
           1   4749
4756: oJumpForward 4763
4758: Choice Lookup Table
          43   4739
4761: oError 15
4763: oSetResult 1
4765: oPushResult
4766: oValuePush
4767: oPop 1
4769: oValueSub
4770: oInput 16
4772: oReturn
4773: oJumpForward 4778
4775: Choice Lookup Table
           1   4732
4778: oGetParam 1
4780: oPushResult
4781: oGetGlobal 20
4783: oPushResult
4784: oNodeEqual
4785: oPop 2
4787: oChoice 4832
4789: oInput 15
4791: oCall 3539
4793: oTypeSNodeType
4794: oChoice 4815
4796: oTypeSTop
4797: oPushResult
4798: oSetResult 44
4800: oPushResult
4801: oNodeGetBoolean
4802: oPop 2
4804: oChoice 4810
4806: oError 29
4808: oJumpForward 4813
4810: Choice Lookup Table
           1   4806
4813: oJumpForward 4820
4815: Choice Lookup Table
          43   4796
4818: oError 15
4820: oSetResult 1
4822: oPushResult
4823: oValuePush
4824: oPop 1
4826: oValueAdd
4827: oInput 16
4829: oReturn
4830: oJumpForward 4835
4832: Choice Lookup Table
           1   4789
4835: oGetParam 1
4837: oPushResult
4838: oGetGlobal 21
4840: oPushResult
4841: oNodeEqual
4842: oPop 2
4844: oChoice 4881
4846: oInput 15
4848: oCall 3743
4850: oValuePop
4851: oGetAddrLocal 1
4853: oPushResult
4854: oTypeSTop
4855: oAssign
4856: oTypeSPop
4857: oGetLocal 1
4859: oPushResult
4860: oSetResult 17
4862: oPushResult
4863: oNodeGetInt
4864: oPop 2
4866: oPushResult
4867: oValuePush
4868: oPop 1
4870: oGetGlobal 6
4872: oPushResult
4873: oTypeSPush
4874: oPop 1
4876: oInput 16
4878: oReturn
4879: oJumpForward 4884
4881: Choice Lookup Table
           1   4846
4884: oError 17
4886: oReturn
4887: oLocalSpace 1
4889: oGetAddrLocal 1
4891: oPushResult
4892: oSetResult 0
4894: oAssign
4895: oGetAddrLocal 1
4897: oPushResult
4898: oCall 5071
4900: oPop 1
4902: oGetAddrLocal 1
4904: oPushResult
4905: oCall 4971
4907: oPop 1
4909: oReturn
4910: oLocalSpace 1
4912: oGetAddrLocal 1
4914: oPushResult
4915: oGetGlobal 25
4917: oAssign
4918: oGetAddrGlobal 25
4920: oPushResult
4921: oSetResult 1
4923: oAssign
4924: oCall 4887
4926: oGetAddrGlobal 25
4928: oPushResult
4929: oGetLocal 1
4931: oAssign
4932: oReturn
4933: oLocalSpace 0
4935: oGetParam 1
4937: oPushResult
4938: oCall 5071
4940: oPop 1
4942: oTypeSNodeType
4943: oChoice 4962
4945: oJumpForward 4969
4947: oGetParam 1
4949: oPushResult
4950: oLabelNew
4951: oAssign
4952: oEmit 81
4954: oGetFromParam 1
4956: oPushResult
4957: oEmitLabel
4958: oPop 1
4960: oJumpForward 4969
4962: Choice Lookup Table
          33   4947
          34   4945
4967: oError 8
4969: oTypeSPop
4970: oReturn
4971: oLocalSpace 1
4973: oTypeSNodeType
4974: oChoice 5036
4976: oGetAddrLocal 1
4978: oPushResult
4979: oLabelNew
4980: oAssign
4981: oEmit 15
4983: oSetResult 1
4985: oPushResult
4986: oEmitInt
4987: oPop 1
4989: oEmit 79
4991: oGetLocal 1
4993: oPushResult
4994: oEmitLabel
4995: oPop 1
4997: oEmit 88
4999: oGetFromParam 1
5001: oPushResult
5002: oEmitLabel
5003: oPop 1
5005: oEmit 15
5007: oSetResult 0
5009: oPushResult
5010: oEmitInt
5011: oPop 1
5013: oEmit 88
5015: oGetLocal 1
5017: oPushResult
5018: oEmitLabel
5019: oPop 1
5021: oTypeSPop
5022: oGetGlobal 7
5024: oPushResult
5025: oTypeSPush
5026: oPop 1
5028: oGetParam 1
5030: oPushResult
5031: oSetResult 0
5033: oAssign
5034: oJumpForward 5039
5036: Choice Lookup Table
          34   4976
5039: oReturn
5040: oLocalSpace 0
5042: oTypeSNodeType
5043: oChoice 5067
5045: oGetParam 1
5047: oPushResult
5048: oLabelNew
5049: oAssign
5050: oEmit 81
5052: oGetFromParam 1
5054: oPushResult
5055: oEmitLabel
5056: oPop 1
5058: oTypeSPop
5059: oGetGlobal 8
5061: oPushResult
5062: oTypeSPush
5063: oPop 1
5065: oJumpForward 5070
5067: Choice Lookup Table
          33   5045
5070: oReturn
5071: oLocalSpace 0
5073: oGetParam 1
5075: oPushResult
5076: oCall 5604
5078: oPop 1
5080: oInputChoice 5586
5082: oGetParam 1
5084: oPushResult
5085: oCall 4971
5087: oPop 1
5089: oCall 8813
5091: oGetParam 1
5093: oPushResult
5094: oCall 5604
5096: oPop 1
5098: oGetParam 1
5100: oPushResult
5101: oCall 4971
5103: oPop 1
5105: oCall 8813
5107: oCall 8682
5109: oTypeSNodeType
5110: oChoice 5138
5112: oEmit 50
5114: oJumpForward 5157
5116: oEmit 56
5118: oJumpForward 5157
5120: oEmit 62
5122: oJumpForward 5157
5124: oCall 11063
5126: oEmit 15
5128: oSetResult 0
5130: oPushResult
5131: oEmitInt
5132: oPop 1
5134: oEmit 56
5136: oJumpForward 5157
5138: Choice Lookup Table
          41   5124
          42   5124
          37   5120
          36   5120
          43   5116
          30   5116
          35   5112
          33   5112
5155: oError 18
5157: oTypeSPop
5158: oGetGlobal 7
5160: oPushResult
5161: oTypeSPush
5162: oPop 1
5164: oJumpForward 5601
5166: oGetParam 1
5168: oPushResult
5169: oCall 4971
5171: oPop 1
5173: oCall 8813
5175: oGetParam 1
5177: oPushResult
5178: oCall 5604
5180: oPop 1
5182: oGetParam 1
5184: oPushResult
5185: oCall 4971
5187: oPop 1
5189: oCall 8813
5191: oCall 8682
5193: oTypeSNodeType
5194: oChoice 5222
5196: oEmit 51
5198: oJumpForward 5241
5200: oEmit 57
5202: oJumpForward 5241
5204: oEmit 63
5206: oJumpForward 5241
5208: oCall 11063
5210: oEmit 15
5212: oSetResult 0
5214: oPushResult
5215: oEmitInt
5216: oPop 1
5218: oEmit 57
5220: oJumpForward 5241
5222: Choice Lookup Table
          41   5208
          42   5208
          37   5204
          36   5204
          43   5200
          30   5200
          35   5196
          33   5196
5239: oError 18
5241: oTypeSPop
5242: oGetGlobal 7
5244: oPushResult
5245: oTypeSPush
5246: oPop 1
5248: oJumpForward 5601
5250: oGetParam 1
5252: oPushResult
5253: oCall 4971
5255: oPop 1
5257: oCall 8813
5259: oGetParam 1
5261: oPushResult
5262: oCall 5604
5264: oPop 1
5266: oGetParam 1
5268: oPushResult
5269: oCall 4971
5271: oPop 1
5273: oCall 8813
5275: oCall 8682
5277: oTypeSNodeType
5278: oChoice 5306
5280: oEmit 53
5282: oJumpForward 5325
5284: oEmit 59
5286: oJumpForward 5325
5288: oEmit 65
5290: oJumpForward 5325
5292: oCall 11063
5294: oEmit 15
5296: oSetResult 0
5298: oPushResult
5299: oEmitInt
5300: oPop 1
5302: oEmit 59
5304: oJumpForward 5325
5306: Choice Lookup Table
          41   5292
          42   5292
          37   5288
          36   5288
          43   5284
          30   5284
          35   5280
          33   5280
5323: oError 18
5325: oTypeSPop
5326: oGetGlobal 7
5328: oPushResult
5329: oTypeSPush
5330: oPop 1
5332: oJumpForward 5601
5334: oGetParam 1
5336: oPushResult
5337: oCall 4971
5339: oPop 1
5341: oCall 8813
5343: oGetParam 1
5345: oPushResult
5346: oCall 5604
5348: oPop 1
5350: oGetParam 1
5352: oPushResult
5353: oCall 4971
5355: oPop 1
5357: oCall 8813
5359: oCall 8682
5361: oTypeSNodeType
5362: oChoice 5390
5364: oEmit 52
5366: oJumpForward 5409
5368: oEmit 58
5370: oJumpForward 5409
5372: oEmit 64
5374: oJumpForward 5409
5376: oCall 11063
5378: oEmit 15
5380: oSetResult 0
5382: oPushResult
5383: oEmitInt
5384: oPop 1
5386: oEmit 58
5388: oJumpForward 5409
5390: Choice Lookup Table
          41   5376
          42   5376
          37   5372
          36   5372
          43   5368
          30   5368
          35   5364
          33   5364
5407: oError 18
5409: oTypeSPop
5410: oGetGlobal 7
5412: oPushResult
5413: oTypeSPush
5414: oPop 1
5416: oJumpForward 5601
5418: oGetParam 1
5420: oPushResult
5421: oCall 4971
5423: oPop 1
5425: oCall 8813
5427: oGetParam 1
5429: oPushResult
5430: oCall 5604
5432: oPop 1
5434: oGetParam 1
5436: oPushResult
5437: oCall 4971
5439: oPop 1
5441: oCall 8813
5443: oCall 8682
5445: oTypeSNodeType
5446: oChoice 5474
5448: oEmit 55
5450: oJumpForward 5493
5452: oEmit 61
5454: oJumpForward 5493
5456: oEmit 67
5458: oJumpForward 5493
5460: oCall 11063
5462: oEmit 15
5464: oSetResult 0
5466: oPushResult
5467: oEmitInt
5468: oPop 1
5470: oEmit 61
5472: oJumpForward 5493
5474: Choice Lookup Table
          41   5460
          42   5460
          37   5456
          36   5456
          43   5452
          30   5452
          35   5448
          33   5448
5491: oError 18
5493: oTypeSPop
5494: oGetGlobal 7
5496: oPushResult
5497: oTypeSPush
5498: oPop 1
5500: oJumpForward 5601
5502: oGetParam 1
5504: oPushResult
5505: oCall 4971
5507: oPop 1
5509: oCall 8813
5511: oGetParam 1
5513: oPushResult
5514: oCall 5604
5516: oPop 1
5518: oGetParam 1
5520: oPushResult
5521: oCall 4971
5523: oPop 1
5525: oCall 8813
5527: oCall 8682
5529: oTypeSNodeType
5530: oChoice 5558
5532: oEmit 54
5534: oJumpForward 5577
5536: oEmit 60
5538: oJumpForward 5577
5540: oEmit 66
5542: oJumpForward 5577
5544: oCall 11063
5546: oEmit 15
5548: oSetResult 0
5550: oPushResult
5551: oEmitInt
5552: oPop 1
5554: oEmit 60
5556: oJumpForward 5577
5558: Choice Lookup Table
          41   5544
          42   5544
          37   5540
          36   5540
          43   5536
          30   5536
          35   5532
          33   5532
5575: oError 18
5577: oTypeSPop
5578: oGetGlobal 7
5580: oPushResult
5581: oTypeSPush
5582: oPop 1
5584: oJumpForward 5601
5586: Choice Lookup Table
          12   5502
          11   5418
          10   5334
           9   5250
           8   5166
           7   5082
5599: oJumpForward 5603
5601: oJumpBack 5080
5603: oReturn
5604: oLocalSpace 1
5606: oGetAddrLocal 1
5608: oPushResult
5609: oSetResult 0
5611: oAssign
5612: oGetParam 1
5614: oPushResult
5615: oCall 5784
5617: oPop 1
5619: oInputChoice 5752
5621: oTypeSNodeType
5622: oChoice 5693
5624: oGetLocal 1
5626: oPushResult
5627: oSetResult 0
5629: oPushResult
5630: equal_label
5631: oPop 2
5633: oChoice 5642
5635: oGetAddrLocal 1
5637: oPushResult
5638: oLabelNew
5639: oAssign
5640: oJumpForward 5645
5642: Choice Lookup Table
           1   5635
5645: oEmit 79
5647: oGetLocal 1
5649: oPushResult
5650: oEmitLabel
5651: oPop 1
5653: oJumpForward 5700
5655: oGetParam 1
5657: oPushResult
5658: oCall 5040
5660: oPop 1
5662: oGetLocal 1
5664: oPushResult
5665: oSetResult 0
5667: oPushResult
5668: equal_label
5669: oPop 2
5671: oChoice 5680
5673: oGetAddrLocal 1
5675: oPushResult
5676: oLabelNew
5677: oAssign
5678: oJumpForward 5683
5680: Choice Lookup Table
           1   5673
5683: oEmit 79
5685: oGetLocal 1
5687: oPushResult
5688: oEmitLabel
5689: oPop 1
5691: oJumpForward 5700
5693: Choice Lookup Table
          33   5655
          34   5624
5698: oError 8
5700: oTypeSPop
5701: oEmit 88
5703: oGetFromParam 1
5705: oPushResult
5706: oEmitLabel
5707: oPop 1
5709: oGetParam 1
5711: oPushResult
5712: oSetResult 0
5714: oAssign
5715: oGetParam 1
5717: oPushResult
5718: oCall 5784
5720: oPop 1
5722: oTypeSNodeType
5723: oChoice 5736
5725: oJumpForward 5743
5727: oGetParam 1
5729: oPushResult
5730: oCall 5040
5732: oPop 1
5734: oJumpForward 5743
5736: Choice Lookup Table
          33   5727
          34   5725
5741: oError 8
5743: oTypeSPop
5744: oGetGlobal 8
5746: oPushResult
5747: oTypeSPush
5748: oPop 1
5750: oJumpForward 5757
5752: Choice Lookup Table
          58   5621
5755: oJumpForward 5759
5757: oJumpBack 5619
5759: oGetLocal 1
5761: oPushResult
5762: oSetResult 0
5764: oPushResult
5765: equal_label
5766: oPop 2
5768: oChoice 5780
5770: oEmit 88
5772: oGetLocal 1
5774: oPushResult
5775: oEmitLabel
5776: oPop 1
5778: oJumpForward 5783
5780: Choice Lookup Table
           0   5770
5783: oReturn
5784: oLocalSpace 2
5786: oGetAddrLocal 1
5788: oPushResult
5789: oSetResult 0
5791: oAssign
5792: oGetParam 1
5794: oPushResult
5795: oCall 5922
5797: oPop 1
5799: oInputChoice 5914
5801: oTypeSNodeType
5802: oChoice 5815
5804: oJumpForward 5822
5806: oGetParam 1
5808: oPushResult
5809: oCall 5040
5811: oPop 1
5813: oJumpForward 5822
5815: Choice Lookup Table
          33   5806
          34   5804
5820: oError 8
5822: oTypeSPop
5823: oGetLocal 1
5825: oPushResult
5826: oSetResult 0
5828: oPushResult
5829: equal_label
5830: oPop 2
5832: oChoice 5861
5834: oGetAddrLocal 1
5836: oPushResult
5837: oLabelNew
5838: oAssign
5839: oEmit 89
5841: oGetFromParam 1
5843: oPushResult
5844: oEmitLabel
5845: oPop 1
5847: oGetLocal 1
5849: oPushResult
5850: oEmitLabel
5851: oPop 1
5853: oGetParam 1
5855: oPushResult
5856: oGetLocal 1
5858: oAssign
5859: oJumpForward 5864
5861: Choice Lookup Table
           1   5834
5864: oGetAddrLocal 2
5866: oPushResult
5867: oSetResult 0
5869: oAssign
5870: oGetAddrLocal 2
5872: oPushResult
5873: oCall 5922
5875: oPop 1
5877: oTypeSNodeType
5878: oChoice 5891
5880: oJumpForward 5898
5882: oGetAddrLocal 2
5884: oPushResult
5885: oCall 5040
5887: oPop 1
5889: oJumpForward 5898
5891: Choice Lookup Table
          33   5882
          34   5880
5896: oError 8
5898: oEmit 89
5900: oGetLocal 2
5902: oPushResult
5903: oEmitLabel
5904: oPop 1
5906: oGetLocal 1
5908: oPushResult
5909: oEmitLabel
5910: oPop 1
5912: oJumpForward 5919
5914: Choice Lookup Table
          57   5801
5917: oJumpForward 5921
5919: oJumpBack 5799
5921: oReturn
5922: oLocalSpace 1
5924: oInputChoice 5978
5926: oGetAddrLocal 1
5928: oPushResult
5929: oSetResult 0
5931: oAssign
5932: oGetAddrLocal 1
5934: oPushResult
5935: oCall 5922
5937: oPop 1
5939: oTypeSNodeType
5940: oChoice 5969
5942: oGetParam 1
5944: oPushResult
5945: oLabelNew
5946: oAssign
5947: oEmit 79
5949: oGetFromParam 1
5951: oPushResult
5952: oEmitLabel
5953: oPop 1
5955: oEmit 88
5957: oGetLocal 1
5959: oPushResult
5960: oEmitLabel
5961: oPop 1
5963: oJumpForward 5976
5965: oEmit 49
5967: oJumpForward 5976
5969: Choice Lookup Table
          33   5965
          34   5942
5974: oError 8
5976: oJumpForward 5988
5978: Choice Lookup Table
          59   5926
5981: oGetParam 1
5983: oPushResult
5984: oCall 5989
5986: oPop 1
5988: oReturn
5989: oLocalSpace 2
5991: oGetAddrLocal 1
5993: oPushResult
5994: oSetResult 1
5996: oAssign
5997: oGetParam 1
5999: oPushResult
6000: oCall 6255
6002: oPop 1
6004: oInputChoice 6245
6006: oTypeSNodeType
6007: oChoice 6143
6009: oCall 8767
6011: oGetParam 1
6013: oPushResult
6014: oCall 6255
6016: oPop 1
6018: oTypeSNodeType
6019: oChoice 6027
6021: oEmit 23
6023: oCall 8130
6025: oJumpForward 6036
6027: Choice Lookup Table
          37   6021
          36   6021
6032: oCall 8787
6034: oEmit 39
6036: oJumpForward 6162
6038: oGetParam 1
6040: oPushResult
6041: oCall 6255
6043: oPop 1
6045: oCall 8833
6047: oEmit 46
6049: oJumpForward 6162
6051: oGetLocal 1
6053: oChoice 6069
6055: oGetAddrLocal 2
6057: oPushResult
6058: oCall 10846
6060: oAssign
6061: oGetAddrLocal 1
6063: oPushResult
6064: oSetResult 0
6066: oAssign
6067: oJumpForward 6072
6069: Choice Lookup Table
           1   6055
6072: oGetParam 1
6074: oPushResult
6075: oCall 6255
6077: oPop 1
6079: oTypeSNodeType
6080: oChoice 6118
6082: oCall 10955
6084: oEmit 18
6086: oGetLocal 2
6088: oPushResult
6089: oEmitInt
6090: oPop 1
6092: oGetGlobal 16
6094: oPushResult
6095: oTypeSPush
6096: oPop 1
6098: oJumpForward 6128
6100: oCall 11009
6102: oEmit 18
6104: oGetLocal 2
6106: oPushResult
6107: oEmitInt
6108: oPop 1
6110: oGetGlobal 16
6112: oPushResult
6113: oTypeSPush
6114: oPop 1
6116: oJumpForward 6128
6118: Choice Lookup Table
          35   6100
          41   6082
          42   6082
6125: oError 15
6127: oTypeSPop
6128: oJumpForward 6162
6130: oGetParam 1
6132: oPushResult
6133: oCall 6255
6135: oPop 1
6137: oCall 8767
6139: oCall 8130
6141: oJumpForward 6162
6143: Choice Lookup Table
          37   6130
          36   6130
          35   6051
          41   6051
          42   6051
          32   6038
          29   6009
          30   6009
6160: oError 18
6162: oJumpForward 6252
6164: oTypeSNodeType
6165: oChoice 6230
6167: oCall 8767
6169: oGetParam 1
6171: oPushResult
6172: oCall 6255
6174: oPop 1
6176: oCall 8787
6178: oEmit 42
6180: oJumpForward 6243
6182: oGetParam 1
6184: oPushResult
6185: oCall 6255
6187: oPop 1
6189: oCall 8833
6191: oEmit 47
6193: oJumpForward 6243
6195: oGetParam 1
6197: oPushResult
6198: oCall 6255
6200: oPop 1
6202: oTypeSNodeType
6203: oChoice 6217
6205: oCall 8767
6207: oCall 8186
6209: oJumpForward 6228
6211: oCall 8682
6213: oCall 8242
6215: oJumpForward 6228
6217: Choice Lookup Table
          37   6211
          36   6211
          29   6205
          30   6205
6226: oError 18
6228: oJumpForward 6243
6230: Choice Lookup Table
          37   6195
          36   6195
          32   6182
          29   6167
          30   6167
6241: oError 18
6243: oJumpForward 6252
6245: Choice Lookup Table
          26   6164
          25   6006
6250: oJumpForward 6254
6252: oJumpBack 6004
6254: oReturn
6255: oLocalSpace 0
6257: oGetParam 1
6259: oPushResult
6260: oCall 6360
6262: oPop 1
6264: oInputChoice 6350
6266: oTypeSNodeType
6267: oChoice 6297
6269: oCall 8767
6271: oGetParam 1
6273: oPushResult
6274: oCall 6360
6276: oPop 1
6278: oCall 8787
6280: oEmit 36
6282: oJumpForward 6306
6284: oGetParam 1
6286: oPushResult
6287: oCall 6360
6289: oPop 1
6291: oCall 8833
6293: oEmit 44
6295: oJumpForward 6306
6297: Choice Lookup Table
          32   6284
          29   6269
          30   6269
6304: oError 18
6306: oJumpForward 6357
6308: oTypeSNodeType
6309: oChoice 6339
6311: oCall 8767
6313: oGetParam 1
6315: oPushResult
6316: oCall 6360
6318: oPop 1
6320: oCall 8787
6322: oEmit 37
6324: oJumpForward 6348
6326: oGetParam 1
6328: oPushResult
6329: oCall 6360
6331: oPop 1
6333: oCall 8833
6335: oEmit 45
6337: oJumpForward 6348
6339: Choice Lookup Table
          32   6326
          29   6311
          30   6311
6346: oError 18
6348: oJumpForward 6357
6350: Choice Lookup Table
          24   6308
          23   6266
6355: oJumpForward 6359
6357: oJumpBack 6264
6359: oReturn
6360: oLocalSpace 0
6362: oInputChoice 6420
6364: oGetParam 1
6366: oPushResult
6367: oCall 6433
6369: oPop 1
6371: oTypeSNodeType
6372: oChoice 6378
6374: oJumpForward 6387
6376: oJumpForward 6387
6378: Choice Lookup Table
          32   6376
          29   6374
          30   6374
6385: oError 18
6387: oJumpForward 6432
6389: oGetParam 1
6391: oPushResult
6392: oCall 6433
6394: oPop 1
6396: oTypeSNodeType
6397: oChoice 6409
6399: oCall 8787
6401: oEmit 43
6403: oJumpForward 6418
6405: oEmit 48
6407: oJumpForward 6418
6409: Choice Lookup Table
          32   6405
          29   6399
          30   6399
6416: oError 18
6418: oJumpForward 6432
6420: Choice Lookup Table
          26   6389
          25   6364
6425: oGetParam 1
6427: oPushResult
6428: oCall 6433
6430: oPop 1
6432: oReturn
6433: oLocalSpace 7
6435: oInputChoice 6891
6437: oEmit 15
6439: TOKEN_VALUE
6440: oPushResult
6441: oEmitInt
6442: oPop 1
6444: oGetGlobal 6
6446: oPushResult
6447: oTypeSPush
6448: oPop 1
6450: oJumpForward 6914
6452: oEmit 15
6454: TOKEN_VALUE
6455: oPushResult
6456: oEmitInt
6457: oPop 1
6459: oGetGlobal 9
6461: oPushResult
6462: oTypeSPush
6463: oPop 1
6465: oJumpForward 6914
6467: oEmit 16
6469: TOKEN_VALUE_DOUBLE
6470: oPushResult
6471: oEmitDouble
6472: oPop 1
6474: oGetGlobal 13
6476: oPushResult
6477: oTypeSPush
6478: oPop 1
6480: oJumpForward 6914
6482: oGetParam 1
6484: oPushResult
6485: oCall 5071
6487: oPop 1
6489: oInput 16
6491: oJumpForward 6914
6493: oGetAddrLocal 1
6495: oPushResult
6496: CURRENT_STRLIT
6497: oPushResult
6498: oStringAllocShortStringLit
6499: oPop 1
6501: oAssign
6502: oEmit 17
6504: oGetLocal 1
6506: oPushResult
6507: oEmitInt
6508: oPop 1
6510: oGetGlobal 15
6512: oPushResult
6513: oTypeSPush
6514: oPop 1
6516: oCall 7728
6518: oCall 7674
6520: oJumpForward 6914
6522: oGetAddrLocal 2
6524: oPushResult
6525: oScopeFindRequire
6526: oAssign
6527: oGetAddrLocal 2
6529: oPushResult
6530: oCall 244
6532: oPop 1
6534: oGetLocal 2
6536: oPushResult
6537: oNodeType
6538: oPop 1
6540: oChoice 6811
6542: oGetLocal 2
6544: oPushResult
6545: oCall 11158
6547: oPop 1
6549: oJumpForward 6840
6551: oGetLocal 2
6553: oPushResult
6554: oCall 11828
6556: oPop 1
6558: oJumpForward 6840
6560: oGetAddrLocal 3
6562: oPushResult
6563: oGetLocal 2
6565: oPushResult
6566: oSetResult 21
6568: oPushResult
6569: oNodeGet
6570: oPop 2
6572: oAssign
6573: oGetLocal 3
6575: oPushResult
6576: oTypeSPush
6577: oPop 1
6579: oTypeSNodeType
6580: oChoice 6604
6582: oEmit 15
6584: oGetLocal 2
6586: oPushResult
6587: oCall 14197
6589: oPop 1
6591: oJumpForward 6621
6593: oEmit 15
6595: oGetLocal 2
6597: oPushResult
6598: oCall 14197
6600: oPop 1
6602: oJumpForward 6621
6604: Choice Lookup Table
          37   6593
          36   6593
          29   6582
          35   6582
          33   6582
          43   6582
          30   6582
6619: oError 17
6621: oJumpForward 6840
6623: oGetAddrLocal 4
6625: oPushResult
6626: oGetLocal 2
6628: oPushResult
6629: oSetResult 22
6631: oPushResult
6632: oNodeGetInt
6633: oPop 2
6635: oAssign
6636: oGetLocal 4
6638: oPushResult
6639: equal_zero
6640: oPop 1
6642: oChoice 6675
6644: oGetAddrLocal 4
6646: oPushResult
6647: oGetLocal 2
6649: oPushResult
6650: oSetResult 33
6652: oPushResult
6653: oNodeGetString
6654: oPop 2
6656: oPushResult
6657: oStringAllocShortStringLit
6658: oPop 1
6660: oAssign
6661: oGetLocal 2
6663: oPushResult
6664: oSetResult 22
6666: oPushResult
6667: oGetLocal 4
6669: oPushResult
6670: oNodeSetInt
6671: oPop 3
6673: oJumpForward 6678
6675: Choice Lookup Table
           1   6644
6678: oEmit 17
6680: oGetLocal 4
6682: oPushResult
6683: oEmitInt
6684: oPop 1
6686: oGetGlobal 15
6688: oPushResult
6689: oTypeSPush
6690: oPop 1
6692: oCall 7728
6694: oCall 7674
6696: oJumpForward 6840
6698: oGetLocal 2
6700: oPushResult
6701: oCall 6915
6703: oPop 1
6705: oJumpForward 6840
6707: oGetLocal 2
6709: oPushResult
6710: oSetResult 21
6712: oPushResult
6713: oNodeGet
6714: oPop 2
6716: oPushResult
6717: oTypeSPush
6718: oPop 1
6720: oInputChoice 6787
6722: oCall 4887
6724: oInput 16
6726: oCall 8502
6728: oTypeSNodeType
6729: oChoice 6774
6731: oInputChoice 6761
6733: oTypeSPop
6734: oGetLocal 3
6736: oPushResult
6737: oSetResult 37
6739: oPushResult
6740: oNodeGet
6741: oPop 2
6743: oPushResult
6744: oTypeSPush
6745: oPop 1
6747: oCall 7728
6749: oCall 7674
6751: oJumpForward 6766
6753: oCall 7923
6755: oCall 7728
6757: oCall 7674
6759: oJumpForward 6766
6761: Choice Lookup Table
          17   6753
          19   6733
6766: oJumpForward 6785
6768: oCall 7728
6770: oCall 7674
6772: oJumpForward 6785
6774: Choice Lookup Table
          42   6768
          40   6768
          38   6768
          37   6731
          36   6731
6785: oJumpForward 6809
6787: Choice Lookup Table
          15   6722
6790: oGetGlobal 25
6792: oChoice 6804
6794: oEmit 15
6796: oSetResult 0
6798: oPushResult
6799: oEmitInt
6800: oPop 1
6802: oJumpForward 6809
6804: Choice Lookup Table
           1   6794
6807: oError 32
6809: oJumpForward 6840
6811: Choice Lookup Table
          19   6707
          25   6698
          24   6698
          22   6698
          21   6698
          18   6623
          17   6560
          16   6560
          14   6551
          13   6542
6832: oError 6
6834: oGetGlobal 6
6836: oPushResult
6837: oTypeSPush
6838: oPop 1
6840: oJumpForward 6914
6842: oInput 0
6844: oGetAddrLocal 5
6846: oPushResult
6847: oScopeFindRequire
6848: oAssign
6849: oGetAddrLocal 5
6851: oPushResult
6852: oCall 244
6854: oPop 1
6856: oGetLocal 5
6858: oPushResult
6859: oSetResult 0
6861: oPushResult
6862: oCall 9363
6864: oPop 2
6866: oGetAddrLocal 6
6868: oPushResult
6869: oTypeSTop
6870: oAssign
6871: oTypeSPop
6872: oGetAddrLocal 7
6874: oPushResult
6875: oGetLocal 6
6877: oPushResult
6878: oCall 13216
6880: oPop 1
6882: oAssign
6883: oGetLocal 7
6885: oPushResult
6886: oTypeSPush
6887: oPop 1
6889: oJumpForward 6914
6891: Choice Lookup Table
          20   6842
           0   6522
           3   6493
          15   6482
           2   6467
           4   6452
           1   6437
6906: oError 6
6908: oGetGlobal 6
6910: oPushResult
6911: oTypeSPush
6912: oPop 1
6914: oReturn
6915: oLocalSpace 2
6917: oGetAddrLocal 1
6919: oPushResult
6920: oGetParam 1
6922: oPushResult
6923: oSetResult 21
6925: oPushResult
6926: oNodeGet
6927: oPop 2
6929: oAssign
6930: oGetAddrLocal 2
6932: oPushResult
6933: oGetParam 1
6935: oPushResult
6936: oCall 14151
6938: oPop 1
6940: oAssign
6941: oGetLocal 1
6943: oPushResult
6944: oTypeSPush
6945: oPop 1
6947: oTypeSNodeType
6948: oChoice 7647
6950: oGetParam 1
6952: oPushResult
6953: oNodeType
6954: oPop 1
6956: oChoice 7102
6958: oEmit 0
6960: oGetParam 1
6962: oPushResult
6963: oCall 14197
6965: oPop 1
6967: oJumpForward 7112
6969: oGetLocal 2
6971: oPushResult
6972: equal_zero
6973: oPop 1
6975: oChoice 6988
6977: oEmit 3
6979: oGetParam 1
6981: oPushResult
6982: oCall 14197
6984: oPop 1
6986: oJumpForward 7006
6988: Choice Lookup Table
           1   6977
6991: oEmit 9
6993: oGetLocal 2
6995: oPushResult
6996: oEmitInt
6997: oPop 1
6999: oGetParam 1
7001: oPushResult
7002: oCall 14197
7004: oPop 1
7006: oJumpForward 7112
7008: oGetParam 1
7010: oPushResult
7011: oSetResult 34
7013: oPushResult
7014: oNodeGetBoolean
7015: oPop 2
7017: oChoice 7060
7019: oGetLocal 2
7021: oPushResult
7022: equal_zero
7023: oPop 1
7025: oChoice 7038
7027: oEmit 8
7029: oGetParam 1
7031: oPushResult
7032: oCall 14197
7034: oPop 1
7036: oJumpForward 7056
7038: Choice Lookup Table
           1   7027
7041: oEmit 14
7043: oGetLocal 2
7045: oPushResult
7046: oEmitInt
7047: oPop 1
7049: oGetParam 1
7051: oPushResult
7052: oCall 14197
7054: oPop 1
7056: oEmit 24
7058: oJumpForward 7100
7060: Choice Lookup Table
           1   7019
7063: oGetLocal 2
7065: oPushResult
7066: equal_zero
7067: oPop 1
7069: oChoice 7082
7071: oEmit 6
7073: oGetParam 1
7075: oPushResult
7076: oCall 14197
7078: oPop 1
7080: oJumpForward 7100
7082: Choice Lookup Table
           1   7071
7085: oEmit 12
7087: oGetLocal 2
7089: oPushResult
7090: oEmitInt
7091: oPop 1
7093: oGetParam 1
7095: oPushResult
7096: oCall 14197
7098: oPop 1
7100: oJumpForward 7112
7102: Choice Lookup Table
          24   7008
          22   6969
          25   6958
          21   6958
7111: oEndChoice
7112: oJumpForward 7673
7114: oGetParam 1
7116: oPushResult
7117: oNodeType
7118: oPop 1
7120: oChoice 7266
7122: oEmit 1
7124: oGetParam 1
7126: oPushResult
7127: oCall 14197
7129: oPop 1
7131: oJumpForward 7276
7133: oGetLocal 2
7135: oPushResult
7136: equal_zero
7137: oPop 1
7139: oChoice 7152
7141: oEmit 4
7143: oGetParam 1
7145: oPushResult
7146: oCall 14197
7148: oPop 1
7150: oJumpForward 7170
7152: Choice Lookup Table
           1   7141
7155: oEmit 10
7157: oGetLocal 2
7159: oPushResult
7160: oEmitInt
7161: oPop 1
7163: oGetParam 1
7165: oPushResult
7166: oCall 14197
7168: oPop 1
7170: oJumpForward 7276
7172: oGetParam 1
7174: oPushResult
7175: oSetResult 34
7177: oPushResult
7178: oNodeGetBoolean
7179: oPop 2
7181: oChoice 7224
7183: oGetLocal 2
7185: oPushResult
7186: equal_zero
7187: oPop 1
7189: oChoice 7202
7191: oEmit 8
7193: oGetParam 1
7195: oPushResult
7196: oCall 14197
7198: oPop 1
7200: oJumpForward 7220
7202: Choice Lookup Table
           1   7191
7205: oEmit 14
7207: oGetLocal 2
7209: oPushResult
7210: oEmitInt
7211: oPop 1
7213: oGetParam 1
7215: oPushResult
7216: oCall 14197
7218: oPop 1
7220: oEmit 25
7222: oJumpForward 7264
7224: Choice Lookup Table
           1   7183
7227: oGetLocal 2
7229: oPushResult
7230: equal_zero
7231: oPop 1
7233: oChoice 7246
7235: oEmit 7
7237: oGetParam 1
7239: oPushResult
7240: oCall 14197
7242: oPop 1
7244: oJumpForward 7264
7246: Choice Lookup Table
           1   7235
7249: oEmit 13
7251: oGetLocal 2
7253: oPushResult
7254: oEmitInt
7255: oPop 1
7257: oGetParam 1
7259: oPushResult
7260: oCall 14197
7262: oPop 1
7264: oJumpForward 7276
7266: Choice Lookup Table
          24   7172
          22   7133
          25   7122
          21   7122
7275: oEndChoice
7276: oJumpForward 7673
7278: oError 17
7280: oJumpForward 7673
7282: oGetParam 1
7284: oPushResult
7285: oNodeType
7286: oPop 1
7288: oChoice 7434
7290: oEmit 2
7292: oGetParam 1
7294: oPushResult
7295: oCall 14197
7297: oPop 1
7299: oJumpForward 7444
7301: oGetLocal 2
7303: oPushResult
7304: equal_zero
7305: oPop 1
7307: oChoice 7320
7309: oEmit 5
7311: oGetParam 1
7313: oPushResult
7314: oCall 14197
7316: oPop 1
7318: oJumpForward 7338
7320: Choice Lookup Table
           1   7309
7323: oEmit 11
7325: oGetLocal 2
7327: oPushResult
7328: oEmitInt
7329: oPop 1
7331: oGetParam 1
7333: oPushResult
7334: oCall 14197
7336: oPop 1
7338: oJumpForward 7444
7340: oGetParam 1
7342: oPushResult
7343: oSetResult 34
7345: oPushResult
7346: oNodeGetBoolean
7347: oPop 2
7349: oChoice 7392
7351: oGetLocal 2
7353: oPushResult
7354: equal_zero
7355: oPop 1
7357: oChoice 7370
7359: oEmit 8
7361: oGetParam 1
7363: oPushResult
7364: oCall 14197
7366: oPop 1
7368: oJumpForward 7388
7370: Choice Lookup Table
           1   7359
7373: oEmit 14
7375: oGetLocal 2
7377: oPushResult
7378: oEmitInt
7379: oPop 1
7381: oGetParam 1
7383: oPushResult
7384: oCall 14197
7386: oPop 1
7388: oEmit 26
7390: oJumpForward 7432
7392: Choice Lookup Table
           1   7351
7395: oGetLocal 2
7397: oPushResult
7398: equal_zero
7399: oPop 1
7401: oChoice 7414
7403: oEmit 8
7405: oGetParam 1
7407: oPushResult
7408: oCall 14197
7410: oPop 1
7412: oJumpForward 7432
7414: Choice Lookup Table
           1   7403
7417: oEmit 14
7419: oGetLocal 2
7421: oPushResult
7422: oEmitInt
7423: oPop 1
7425: oGetParam 1
7427: oPushResult
7428: oCall 14197
7430: oPop 1
7432: oJumpForward 7444
7434: Choice Lookup Table
          24   7340
          22   7301
          25   7290
          21   7290
7443: oEndChoice
7444: oInputChoice 7474
7446: oTypeSPop
7447: oGetLocal 1
7449: oPushResult
7450: oSetResult 37
7452: oPushResult
7453: oNodeGet
7454: oPop 2
7456: oPushResult
7457: oTypeSPush
7458: oPop 1
7460: oCall 7728
7462: oCall 7674
7464: oJumpForward 7479
7466: oCall 7923
7468: oCall 7728
7470: oCall 7674
7472: oJumpForward 7479
7474: Choice Lookup Table
          17   7466
          19   7446
7479: oJumpForward 7673
7481: oGetParam 1
7483: oPushResult
7484: oNodeType
7485: oPop 1
7487: oChoice 7631
7489: oEmit 17
7491: oGetParam 1
7493: oPushResult
7494: oCall 14197
7496: oPop 1
7498: oJumpForward 7641
7500: oGetLocal 2
7502: oPushResult
7503: equal_zero
7504: oPop 1
7506: oChoice 7519
7508: oEmit 18
7510: oGetParam 1
7512: oPushResult
7513: oCall 14197
7515: oPop 1
7517: oJumpForward 7537
7519: Choice Lookup Table
           1   7508
7522: oEmit 21
7524: oGetLocal 2
7526: oPushResult
7527: oEmitInt
7528: oPop 1
7530: oGetParam 1
7532: oPushResult
7533: oCall 14197
7535: oPop 1
7537: oJumpForward 7641
7539: oGetParam 1
7541: oPushResult
7542: oSetResult 34
7544: oPushResult
7545: oNodeGetBoolean
7546: oPop 2
7548: oChoice 7589
7550: oGetLocal 2
7552: oPushResult
7553: equal_zero
7554: oPop 1
7556: oChoice 7569
7558: oEmit 8
7560: oGetParam 1
7562: oPushResult
7563: oCall 14197
7565: oPop 1
7567: oJumpForward 7587
7569: Choice Lookup Table
           1   7558
7572: oEmit 14
7574: oGetLocal 2
7576: oPushResult
7577: oEmitInt
7578: oPop 1
7580: oGetParam 1
7582: oPushResult
7583: oCall 14197
7585: oPop 1
7587: oJumpForward 7629
7589: Choice Lookup Table
           1   7550
7592: oGetLocal 2
7594: oPushResult
7595: equal_zero
7596: oPop 1
7598: oChoice 7611
7600: oEmit 19
7602: oGetParam 1
7604: oPushResult
7605: oCall 14197
7607: oPop 1
7609: oJumpForward 7629
7611: Choice Lookup Table
           1   7600
7614: oEmit 22
7616: oGetLocal 2
7618: oPushResult
7619: oEmitInt
7620: oPop 1
7622: oGetParam 1
7624: oPushResult
7625: oCall 14197
7627: oPop 1
7629: oJumpForward 7641
7631: Choice Lookup Table
          24   7539
          22   7500
          25   7489
          21   7489
7640: oEndChoice
7641: oCall 7728
7643: oCall 7674
7645: oJumpForward 7673
7647: Choice Lookup Table
          42   7481
          40   7481
          38   7481
          32   7282
          37   7282
          36   7282
          28   7278
          35   7114
          29   7114
          33   7114
          43   6950
          30   6950
7672: oEndChoice
7673: oReturn
7674: oLocalSpace 0
7676: oTypeSNodeType
7677: oChoice 7701
7679: oEmit 24
7681: oJumpForward 7727
7683: oEmit 25
7685: oJumpForward 7727
7687: oError 17
7689: oJumpForward 7727
7691: oEmit 26
7693: oJumpForward 7727
7695: oError 30
7697: oJumpForward 7727
7699: oJumpForward 7727
7701: Choice Lookup Table
          42   7699
          41   7699
          40   7699
          38   7699
          37   7695
          36   7691
          28   7687
          35   7683
          29   7683
          33   7683
          43   7679
          30   7679
7726: oEndChoice
7727: oReturn
7728: oLocalSpace 0
7730: oInputChoice 7768
7732: oTypeSNodeType
7733: oChoice 7747
7735: oCall 7780
7737: oJumpForward 7758
7739: oCall 7923
7741: oJumpForward 7758
7743: oCall 8002
7745: oJumpForward 7758
7747: Choice Lookup Table
          42   7743
          41   7743
          36   7739
          38   7735
7756: oError 11
7758: oJumpForward 7777
7760: oCall 8032
7762: oJumpForward 7777
7764: oCall 8305
7766: oJumpForward 7777
7768: Choice Lookup Table
          19   7764
          21   7760
          17   7732
7775: oJumpForward 7779
7777: oJumpBack 7730
7779: oReturn
7780: oLocalSpace 3
7782: oTypeSNodeType
7783: oChoice 7787
7785: oJumpForward 7792
7787: Choice Lookup Table
          38   7785
7790: oError 11
7792: oTypeSNodeType
7793: oChoice 7797
7795: oJumpForward 7802
7797: Choice Lookup Table
          38   7795
7800: oError 14
7802: oGetAddrLocal 1
7804: oPushResult
7805: oTypeSTop
7806: oPushResult
7807: oSetResult 38
7809: oPushResult
7810: oNodeGet
7811: oPop 2
7813: oPushResult
7814: oCall 13300
7816: oPop 1
7818: oAssign
7819: oGetAddrLocal 2
7821: oPushResult
7822: oTypeSTop
7823: oPushResult
7824: oSetResult 37
7826: oPushResult
7827: oNodeGet
7828: oPop 2
7830: oAssign
7831: oTypeSPop
7832: oGetLocal 2
7834: oPushResult
7835: oTypeSPush
7836: oPop 1
7838: oCall 4887
7840: oCall 8740
7842: oGetLocal 1
7844: oPushResult
7845: equal_zero
7846: oPop 1
7848: oChoice 7862
7850: oEmit 15
7852: oGetLocal 1
7854: oPushResult
7855: oEmitInt
7856: oPop 1
7858: oEmit 42
7860: oJumpForward 7865
7862: Choice Lookup Table
           0   7850
7865: oGetAddrLocal 3
7867: oPushResult
7868: oGetLocal 2
7870: oPushResult
7871: oSetResult 17
7873: oPushResult
7874: oNodeGetInt
7875: oPop 2
7877: oAssign
7878: oGetLocal 3
7880: oPushResult
7881: oSetResult 1
7883: oPushResult
7884: equal
7885: oPop 2
7887: oChoice 7901
7889: oEmit 15
7891: oGetLocal 3
7893: oPushResult
7894: oEmitInt
7895: oPop 1
7897: oEmit 36
7899: oJumpForward 7904
7901: Choice Lookup Table
           0   7889
7904: oEmit 38
7906: oInputChoice 7914
7908: oJumpForward 7922
7910: oJumpForward 7920
7912: oJumpForward 7920
7914: Choice Lookup Table
          14   7912
          18   7908
7919: oEndChoice
7920: oJumpBack 7792
7922: oReturn
7923: oLocalSpace 2
7925: oTypeSNodeType
7926: oChoice 7930
7928: oJumpForward 7935
7930: Choice Lookup Table
          36   7928
7933: oError 30
7935: oGetAddrLocal 1
7937: oPushResult
7938: oTypeSTop
7939: oPushResult
7940: oSetResult 37
7942: oPushResult
7943: oNodeGet
7944: oPop 2
7946: oAssign
7947: oTypeSPop
7948: oGetLocal 1
7950: oPushResult
7951: oTypeSPush
7952: oPop 1
7954: oCall 4887
7956: oCall 8740
7958: oGetAddrLocal 2
7960: oPushResult
7961: oGetLocal 1
7963: oPushResult
7964: oSetResult 17
7966: oPushResult
7967: oNodeGetInt
7968: oPop 2
7970: oAssign
7971: oGetLocal 2
7973: oPushResult
7974: oSetResult 1
7976: oPushResult
7977: equal
7978: oPop 2
7980: oChoice 7994
7982: oEmit 15
7984: oGetLocal 2
7986: oPushResult
7987: oEmitInt
7988: oPop 1
7990: oEmit 36
7992: oJumpForward 7997
7994: Choice Lookup Table
           0   7982
7997: oEmit 38
7999: oInput 18
8001: oReturn
8002: oLocalSpace 0
8004: oTypeSNodeType
8005: oChoice 8009
8007: oJumpForward 8016
8009: Choice Lookup Table
          42   8007
          41   8007
8014: oError 30
8016: oTypeSPop
8017: oGetGlobal 9
8019: oPushResult
8020: oTypeSPush
8021: oPop 1
8023: oCall 4887
8025: oCall 8740
8027: oEmit 38
8029: oInput 18
8031: oReturn
8032: oLocalSpace 2
8034: oTypeSNodeType
8035: oChoice 8039
8037: oJumpForward 8044
8039: Choice Lookup Table
          40   8037
8042: oError 12
8044: oTypeSTop
8045: oPushResult
8046: oSetResult 41
8048: oPushResult
8049: oNodeGet
8050: oPop 2
8052: oPushResult
8053: oScopeEnter
8054: oPop 1
8056: oInput 0
8058: oGetAddrLocal 1
8060: oPushResult
8061: oScopeFindRequire
8062: oAssign
8063: oGetLocal 1
8065: oPushResult
8066: oNodeType
8067: oPop 1
8069: oChoice 8073
8071: oJumpForward 8078
8073: Choice Lookup Table
          23   8071
8076: oError 13
8078: oScopeEnd
8079: oGetAddrLocal 2
8081: oPushResult
8082: oGetLocal 1
8084: oPushResult
8085: oSetResult 22
8087: oPushResult
8088: oNodeGetInt
8089: oPop 2
8091: oAssign
8092: oGetLocal 2
8094: oPushResult
8095: equal_zero
8096: oPop 1
8098: oChoice 8112
8100: oEmit 15
8102: oGetLocal 2
8104: oPushResult
8105: oEmitInt
8106: oPop 1
8108: oEmit 38
8110: oJumpForward 8115
8112: Choice Lookup Table
           0   8100
8115: oTypeSPop
8116: oGetLocal 1
8118: oPushResult
8119: oSetResult 21
8121: oPushResult
8122: oNodeGet
8123: oPop 2
8125: oPushResult
8126: oTypeSPush
8127: oPop 1
8129: oReturn
8130: oLocalSpace 2
8132: oGetAddrLocal 1
8134: oPushResult
8135: oTypeSTop
8136: oPushResult
8137: oSetResult 37
8139: oPushResult
8140: oNodeGet
8141: oPop 2
8143: oAssign
8144: oGetAddrLocal 2
8146: oPushResult
8147: oGetLocal 1
8149: oPushResult
8150: oSetResult 17
8152: oPushResult
8153: oNodeGetInt
8154: oPop 2
8156: oAssign
8157: oGetLocal 2
8159: oPushResult
8160: oSetResult 1
8162: oPushResult
8163: equal
8164: oPop 2
8166: oChoice 8180
8168: oEmit 15
8170: oGetLocal 2
8172: oPushResult
8173: oEmitInt
8174: oPop 1
8176: oEmit 36
8178: oJumpForward 8183
8180: Choice Lookup Table
           0   8168
8183: oEmit 38
8185: oReturn
8186: oLocalSpace 2
8188: oGetAddrLocal 1
8190: oPushResult
8191: oTypeSTop
8192: oPushResult
8193: oSetResult 37
8195: oPushResult
8196: oNodeGet
8197: oPop 2
8199: oAssign
8200: oGetAddrLocal 2
8202: oPushResult
8203: oGetLocal 1
8205: oPushResult
8206: oSetResult 17
8208: oPushResult
8209: oNodeGetInt
8210: oPop 2
8212: oAssign
8213: oGetLocal 2
8215: oPushResult
8216: oSetResult 1
8218: oPushResult
8219: equal
8220: oPop 2
8222: oChoice 8236
8224: oEmit 15
8226: oGetLocal 2
8228: oPushResult
8229: oEmitInt
8230: oPop 1
8232: oEmit 36
8234: oJumpForward 8239
8236: Choice Lookup Table
           0   8224
8239: oEmit 41
8241: oReturn
8242: oLocalSpace 2
8244: oEmit 40
8246: oGetAddrLocal 1
8248: oPushResult
8249: oTypeSTop
8250: oPushResult
8251: oSetResult 37
8253: oPushResult
8254: oNodeGet
8255: oPop 2
8257: oAssign
8258: oGetAddrLocal 2
8260: oPushResult
8261: oGetLocal 1
8263: oPushResult
8264: oSetResult 17
8266: oPushResult
8267: oNodeGetInt
8268: oPop 2
8270: oAssign
8271: oGetLocal 2
8273: oPushResult
8274: oSetResult 1
8276: oPushResult
8277: equal
8278: oPop 2
8280: oChoice 8294
8282: oEmit 15
8284: oGetLocal 2
8286: oPushResult
8287: oEmitInt
8288: oPop 1
8290: oEmit 37
8292: oJumpForward 8297
8294: Choice Lookup Table
           0   8282
8297: oTypeSPop
8298: oGetGlobal 6
8300: oPushResult
8301: oTypeSPush
8302: oPop 1
8304: oReturn
8305: oLocalSpace 1
8307: oTypeSNodeType
8308: oChoice 8316
8310: oJumpForward 8323
8312: oError 30
8314: oJumpForward 8323
8316: Choice Lookup Table
          37   8312
          36   8310
8321: oError 10
8323: oEmit 26
8325: oGetAddrLocal 1
8327: oPushResult
8328: oTypeSTop
8329: oAssign
8330: oTypeSPop
8331: oGetLocal 1
8333: oPushResult
8334: oSetResult 37
8336: oPushResult
8337: oNodeGet
8338: oPop 2
8340: oPushResult
8341: oTypeSPush
8342: oPop 1
8344: oReturn
8345: oLocalSpace 3
8347: oGetAddrLocal 1
8349: oPushResult
8350: oTypeSNodeType
8351: oAssign
8352: oGetAddrLocal 2
8354: oPushResult
8355: oTypeSTop
8356: oAssign
8357: oTypeSPop
8358: oGetLocal 1
8360: oPushResult
8361: oTypeSNodeType
8362: oPushResult
8363: equal_node_type
8364: oPop 2
8366: oChoice 8498
8368: oTypeSNodeType
8369: oChoice 8483
8371: oGetLocal 1
8373: oChoice 8380
8375: oEmit 32
8377: oReturn
8378: oJumpForward 8383
8380: Choice Lookup Table
          29   8375
8383: oJumpForward 8494
8385: oGetLocal 1
8387: oChoice 8394
8389: oEmit 33
8391: oReturn
8392: oJumpForward 8397
8394: Choice Lookup Table
          30   8389
8397: oJumpForward 8494
8399: oGetLocal 1
8401: oChoice 8434
8403: oReturn
8404: oJumpForward 8439
8406: oTypeSTop
8407: oPushResult
8408: oGetGlobal 10
8410: oPushResult
8411: equal_node
8412: oPop 2
8414: oChoice 8429
8416: oEmit 15
8418: oSetResult 1
8420: oPushResult
8421: oEmitInt
8422: oPop 1
8424: oEmit 38
8426: oReturn
8427: oJumpForward 8432
8429: Choice Lookup Table
           1   8416
8432: oJumpForward 8439
8434: Choice Lookup Table
          41   8406
          37   8403
8439: oJumpForward 8494
8441: oGetLocal 1
8443: oChoice 8448
8445: oReturn
8446: oJumpForward 8451
8448: Choice Lookup Table
          36   8445
8451: oJumpForward 8494
8453: oGetLocal 1
8455: oChoice 8476
8457: oReturn
8458: oJumpForward 8481
8460: oGetGlobal 9
8462: oPushResult
8463: oTypeSPush
8464: oPop 1
8466: oGetAddrLocal 3
8468: oPushResult
8469: oCall 10846
8471: oAssign
8472: oTypeSPop
8473: oReturn
8474: oJumpForward 8481
8476: Choice Lookup Table
          35   8460
          41   8457
8481: oJumpForward 8494
8483: Choice Lookup Table
          42   8453
          37   8441
          36   8399
          29   8385
          30   8371
8494: oError 15
8496: oJumpForward 8501
8498: Choice Lookup Table
           0   8368
8501: oReturn
8502: oLocalSpace 2
8504: oGetAddrLocal 1
8506: oPushResult
8507: oTypeSNodeType
8508: oAssign
8509: oTypeSPop
8510: oGetLocal 1
8512: oPushResult
8513: oTypeSNodeType
8514: oPushResult
8515: equal_node_type
8516: oPop 2
8518: oChoice 8678
8520: oTypeSNodeType
8521: oChoice 8657
8523: oGetLocal 1
8525: oChoice 8535
8527: oEmit 32
8529: oReturn
8530: oJumpForward 8546
8532: oReturn
8533: oJumpForward 8546
8535: Choice Lookup Table
          43   8532
          30   8532
          33   8527
          35   8527
          29   8527
8546: oJumpForward 8674
8548: oGetLocal 1
8550: oChoice 8560
8552: oReturn
8553: oJumpForward 8571
8555: oEmit 33
8557: oReturn
8558: oJumpForward 8571
8560: Choice Lookup Table
          43   8555
          30   8555
          33   8552
          35   8552
          29   8552
8571: oJumpForward 8674
8573: oGetLocal 1
8575: oChoice 8608
8577: oReturn
8578: oJumpForward 8613
8580: oTypeSTop
8581: oPushResult
8582: oGetGlobal 10
8584: oPushResult
8585: equal_node
8586: oPop 2
8588: oChoice 8603
8590: oEmit 15
8592: oSetResult 1
8594: oPushResult
8595: oEmitInt
8596: oPop 1
8598: oEmit 38
8600: oReturn
8601: oJumpForward 8606
8603: Choice Lookup Table
           1   8590
8606: oJumpForward 8613
8608: Choice Lookup Table
          41   8580
          37   8577
8613: oJumpForward 8674
8615: oGetLocal 1
8617: oChoice 8622
8619: oReturn
8620: oJumpForward 8625
8622: Choice Lookup Table
          36   8619
8625: oJumpForward 8674
8627: oGetLocal 1
8629: oChoice 8650
8631: oReturn
8632: oJumpForward 8655
8634: oGetGlobal 9
8636: oPushResult
8637: oTypeSPush
8638: oPop 1
8640: oGetAddrLocal 2
8642: oPushResult
8643: oCall 10846
8645: oAssign
8646: oTypeSPop
8647: oReturn
8648: oJumpForward 8655
8650: Choice Lookup Table
          35   8634
          41   8631
8655: oJumpForward 8674
8657: Choice Lookup Table
          42   8627
          37   8615
          36   8573
          33   8548
          35   8548
          29   8548
          43   8523
          30   8523
8674: oError 15
8676: oJumpForward 8681
8678: Choice Lookup Table
           0   8520
8681: oReturn
8682: oLocalSpace 1
8684: oGetAddrLocal 1
8686: oPushResult
8687: oTypeSNodeType
8688: oAssign
8689: oTypeSPop
8690: oGetLocal 1
8692: oPushResult
8693: oTypeSNodeType
8694: oPushResult
8695: equal_node_type
8696: oPop 2
8698: oChoice 8736
8700: oTypeSNodeType
8701: oChoice 8727
8703: oGetLocal 1
8705: oChoice 8710
8707: oReturn
8708: oJumpForward 8713
8710: Choice Lookup Table
          37   8707
8713: oJumpForward 8732
8715: oGetLocal 1
8717: oChoice 8722
8719: oReturn
8720: oJumpForward 8725
8722: Choice Lookup Table
          36   8719
8725: oJumpForward 8732
8727: Choice Lookup Table
          37   8715
          36   8703
8732: oError 15
8734: oJumpForward 8739
8736: Choice Lookup Table
           0   8700
8739: oReturn
8740: oLocalSpace 0
8742: oTypeSNodeType
8743: oChoice 8747
8745: oJumpForward 8752
8747: Choice Lookup Table
          30   8745
8750: oError 7
8752: oTypeSPop
8753: oReturn
8754: oLocalSpace 0
8756: oTypeSNodeType
8757: oChoice 8761
8759: oJumpForward 8766
8761: Choice Lookup Table
          30   8759
8764: oError 7
8766: oReturn
8767: oLocalSpace 0
8769: oTypeSNodeType
8770: oChoice 8778
8772: oJumpForward 8785
8774: oEmit 32
8776: oJumpForward 8785
8778: Choice Lookup Table
          29   8774
          30   8772
8783: oError 7
8785: oTypeSPop
8786: oReturn
8787: oLocalSpace 0
8789: oTypeSNodeType
8790: oChoice 8805
8792: oJumpForward 8812
8794: oEmit 32
8796: oTypeSPop
8797: oGetGlobal 6
8799: oPushResult
8800: oTypeSPush
8801: oPop 1
8803: oJumpForward 8812
8805: Choice Lookup Table
          29   8794
          30   8792
8810: oError 7
8812: oReturn
8813: oLocalSpace 0
8815: oTypeSNodeType
8816: oChoice 8829
8818: oEmit 32
8820: oTypeSPop
8821: oGetGlobal 6
8823: oPushResult
8824: oTypeSPush
8825: oPop 1
8827: oJumpForward 8832
8829: Choice Lookup Table
          29   8818
8832: oReturn
8833: oLocalSpace 0
8835: oTypeSNodeType
8836: oChoice 8844
8838: oJumpForward 8853
8840: oError 17
8842: oJumpForward 8853
8844: Choice Lookup Table
          29   8840
          30   8840
          32   8838
8851: oError 9
8853: oTypeSPop
8854: oReturn
8855: oLocalSpace 0
8857: oTypeSNodeType
8858: oChoice 8862
8860: oJumpForward 8867
8862: Choice Lookup Table
          33   8860
8865: oError 8
8867: oTypeSPop
8868: oReturn
8869: oLocalSpace 0
8871: oTypeSNodeType
8872: oChoice 8876
8874: oJumpForward 8881
8876: Choice Lookup Table
          33   8874
8879: oError 8
8881: oReturn
8882: oLocalSpace 0
8884: oInputChoice 8947
8886: oCall 10619
8888: oJumpForward 8978
8890: oCall 10626
8892: oJumpForward 8978
8894: oCall 10756
8896: oJumpForward 8978
8898: oCall 10763
8900: oJumpForward 8978
8902: oCall 9770
8904: oJumpForward 8978
8906: oCall 10093
8908: oJumpForward 8978
8910: oCall 9836
8912: oJumpForward 8978
8914: oCall 10013
8916: oJumpForward 8978
8918: oCall 10178
8920: oJumpForward 8978
8922: oCall 10146
8924: oJumpForward 8978
8926: oCall 10596
8928: oJumpForward 8978
8930: oCall 8979
8932: oJumpForward 8978
8934: oCall 10210
8936: oJumpForward 8978
8938: oCall 10544
8940: oJumpForward 8978
8942: oChangeIntLitToLabelIdent
8943: oCall 8979
8945: oJumpForward 8978
8947: Choice Lookup Table
           1   8942
          56   8938
          54   8934
           0   8930
          36   8926
          52   8922
          53   8918
          50   8914
          45   8910
          49   8906
          42   8902
          69   8898
          68   8894
          67   8890
          66   8886
8978: oReturn
8979: oLocalSpace 1
8981: oGetAddrLocal 1
8983: oPushResult
8984: oScopeFindRequire
8985: oAssign
8986: oGetAddrLocal 1
8988: oPushResult
8989: oCall 244
8991: oPop 1
8993: oGetLocal 1
8995: oPushResult
8996: oNodeType
8997: oPop 1
8999: oChoice 9039
9001: oGetLocal 1
9003: oPushResult
9004: oCall 9057
9006: oPop 1
9008: oCall 8882
9010: oJumpForward 9056
9012: oGetLocal 1
9014: oPushResult
9015: oCall 11158
9017: oPop 1
9019: oJumpForward 9056
9021: oGetLocal 1
9023: oPushResult
9024: oCall 9107
9026: oPop 1
9028: oJumpForward 9056
9030: oGetLocal 1
9032: oPushResult
9033: oCall 9203
9035: oPop 1
9037: oJumpForward 9056
9039: Choice Lookup Table
          13   9030
          19   9021
          24   9021
          22   9021
          21   9021
          12   9012
          26   9001
9054: oError 0
9056: oReturn
9057: oLocalSpace 0
9059: oGetParam 1
9061: oPushResult
9062: oSetResult 35
9064: oPushResult
9065: oNodeGetBoolean
9066: oPop 2
9068: oChoice 9074
9070: oError 22
9072: oJumpForward 9077
9074: Choice Lookup Table
           1   9070
9077: oEmit 88
9079: oGetParam 1
9081: oPushResult
9082: oSetResult 22
9084: oPushResult
9085: oNodeGetLabel
9086: oPop 2
9088: oPushResult
9089: oEmitLabel
9090: oPop 1
9092: oGetParam 1
9094: oPushResult
9095: oSetResult 35
9097: oPushResult
9098: oSetResult 1
9100: oPushResult
9101: oNodeSetBoolean
9102: oPop 3
9104: oInput 13
9106: oReturn
9107: oLocalSpace 0
9109: oGetParam 1
9111: oPushResult
9112: oSetResult 1
9114: oPushResult
9115: oCall 9363
9117: oPop 2
9119: oInput 5
9121: oCall 4887
9123: oCall 8345
9125: oCall 9128
9127: oReturn
9128: oLocalSpace 1
9130: oTypeSNodeType
9131: oChoice 9175
9133: oEmit 27
9135: oJumpForward 9201
9137: oEmit 28
9139: oJumpForward 9201
9141: oEmit 30
9143: oJumpForward 9201
9145: oError 17
9147: oJumpForward 9201
9149: oEmit 29
9151: oJumpForward 9201
9153: oGetAddrLocal 1
9155: oPushResult
9156: oTypeSTop
9157: oPushResult
9158: oSetResult 17
9160: oPushResult
9161: oNodeGetInt
9162: oPop 2
9164: oAssign
9165: oEmit 31
9167: oGetLocal 1
9169: oPushResult
9170: oEmitInt
9171: oPop 1
9173: oJumpForward 9201
9175: Choice Lookup Table
          42   9153
          40   9153
          38   9153
          37   9149
          36   9149
          28   9145
          32   9141
          35   9137
          29   9137
          33   9137
          43   9133
          30   9133
9200: oEndChoice
9201: oTypeSPop
9202: oReturn
9203: oLocalSpace 1
9205: oGetParam 1
9207: oPushResult
9208: oSetResult 6
9210: oPushResult
9211: oNodeGet
9212: oPop 2
9214: oPushResult
9215: oScopeCurrent
9216: oPushResult
9217: oNodeEqual
9218: oPop 2
9220: oChoice 9226
9222: oError 21
9224: oJumpForward 9229
9226: Choice Lookup Table
           0   9222
9229: oEmit 8
9231: oGetParam 1
9233: oPushResult
9234: oSetResult 31
9236: oPushResult
9237: oNodeGetInt
9238: oPop 2
9240: oPushResult
9241: oEmitInt
9242: oPop 1
9244: oGetParam 1
9246: oPushResult
9247: oSetResult 21
9249: oPushResult
9250: oNodeGet
9251: oPop 2
9253: oPushResult
9254: oTypeSPush
9255: oPop 1
9257: oInput 5
9259: oCall 4887
9261: oCall 8345
9263: oTypeSNodeType
9264: oChoice 9308
9266: oEmit 27
9268: oJumpForward 9334
9270: oEmit 28
9272: oJumpForward 9334
9274: oEmit 30
9276: oJumpForward 9334
9278: oError 17
9280: oJumpForward 9334
9282: oEmit 29
9284: oJumpForward 9334
9286: oGetAddrLocal 1
9288: oPushResult
9289: oTypeSTop
9290: oPushResult
9291: oSetResult 17
9293: oPushResult
9294: oNodeGetInt
9295: oPop 2
9297: oAssign
9298: oEmit 31
9300: oGetLocal 1
9302: oPushResult
9303: oEmitInt
9304: oPop 1
9306: oJumpForward 9334
9308: Choice Lookup Table
          42   9286
          40   9286
          38   9286
          37   9282
          36   9282
          28   9278
          32   9274
          35   9270
          29   9270
          33   9270
          43   9266
          30   9266
9333: oEndChoice
9334: oTypeSPop
9335: oReturn
9336: oLocalSpace 1
9338: oInput 0
9340: oGetAddrLocal 1
9342: oPushResult
9343: oScopeFindRequire
9344: oAssign
9345: oGetAddrLocal 1
9347: oPushResult
9348: oCall 244
9350: oPop 1
9352: oGetLocal 1
9354: oPushResult
9355: oGetParam 1
9357: oPushResult
9358: oCall 9363
9360: oPop 2
9362: oReturn
9363: oLocalSpace 0
9365: oGetParam 2
9367: oPushResult
9368: oNodeType
9369: oPop 1
9371: oChoice 9434
9373: oGetParam 2
9375: oPushResult
9376: oGetParam 1
9378: oPushResult
9379: oCall 9580
9381: oPop 2
9383: oJumpForward 9447
9385: oGetParam 2
9387: oPushResult
9388: oSetResult 21
9390: oPushResult
9391: oNodeGet
9392: oPop 2
9394: oPushResult
9395: oTypeSPush
9396: oPop 1
9398: oInput 15
9400: oGetParam 1
9402: oPushResult
9403: oCall 9336
9405: oPop 1
9407: oInput 16
9409: oCall 9448
9411: oTypeSNodeType
9412: oChoice 9427
9414: oInputChoice 9422
9416: oEmit 26
9418: oCall 7923
9420: oJumpForward 9425
9422: Choice Lookup Table
          17   9416
9425: oJumpForward 9430
9427: Choice Lookup Table
          36   9414
9430: oCall 7728
9432: oJumpForward 9447
9434: Choice Lookup Table
          19   9385
          25   9373
          24   9373
          22   9373
          21   9373
9445: oError 4
9447: oReturn
9448: oLocalSpace 1
9450: oGetAddrLocal 1
9452: oPushResult
9453: oTypeSNodeType
9454: oAssign
9455: oTypeSPop
9456: oGetLocal 1
9458: oPushResult
9459: oTypeSNodeType
9460: oPushResult
9461: equal_node_type
9462: oPop 2
9464: oChoice 9576
9466: oTypeSNodeType
9467: oChoice 9555
9469: oGetLocal 1
9471: oChoice 9481
9473: oError 31
9475: oReturn
9476: oJumpForward 9492
9478: oReturn
9479: oJumpForward 9492
9481: Choice Lookup Table
          43   9478
          30   9478
          33   9473
          35   9473
          29   9473
9492: oJumpForward 9572
9494: oGetLocal 1
9496: oChoice 9506
9498: oReturn
9499: oJumpForward 9517
9501: oError 31
9503: oReturn
9504: oJumpForward 9517
9506: Choice Lookup Table
          43   9501
          30   9501
          33   9498
          35   9498
          29   9498
9517: oJumpForward 9572
9519: oGetLocal 1
9521: oChoice 9526
9523: oReturn
9524: oJumpForward 9529
9526: Choice Lookup Table
          37   9523
9529: oJumpForward 9572
9531: oGetLocal 1
9533: oChoice 9538
9535: oReturn
9536: oJumpForward 9541
9538: Choice Lookup Table
          36   9535
9541: oJumpForward 9572
9543: oGetLocal 1
9545: oChoice 9550
9547: oReturn
9548: oJumpForward 9553
9550: Choice Lookup Table
          41   9547
9553: oJumpForward 9572
9555: Choice Lookup Table
          42   9543
          37   9531
          36   9519
          33   9494
          35   9494
          29   9494
          43   9469
          30   9469
9572: oError 15
9574: oJumpForward 9579
9576: Choice Lookup Table
           0   9466
9579: oReturn
9580: oLocalSpace 0
9582: oGetParam 2
9584: oPushResult
9585: oNodeType
9586: oPop 1
9588: oChoice 9670
9590: oEmit 17
9592: oGetParam 2
9594: oPushResult
9595: oCall 14197
9597: oPop 1
9599: oJumpForward 9681
9601: oEmit 18
9603: oGetParam 2
9605: oPushResult
9606: oCall 14197
9608: oPop 1
9610: oJumpForward 9681
9612: oGetParam 2
9614: oPushResult
9615: oSetResult 34
9617: oPushResult
9618: oNodeGetBoolean
9619: oPop 2
9621: oChoice 9634
9623: oEmit 8
9625: oGetParam 2
9627: oPushResult
9628: oCall 14197
9630: oPop 1
9632: oJumpForward 9646
9634: Choice Lookup Table
           1   9623
9637: oEmit 19
9639: oGetParam 2
9641: oPushResult
9642: oCall 14197
9644: oPop 1
9646: oJumpForward 9681
9648: oGetParam 1
9650: oChoice 9663
9652: oEmit 17
9654: oGetParam 2
9656: oPushResult
9657: oCall 14197
9659: oPop 1
9661: oJumpForward 9668
9663: Choice Lookup Table
           0   9652
9666: oError 4
9668: oJumpForward 9681
9670: Choice Lookup Table
          25   9648
          24   9612
          22   9601
          21   9590
9679: oError 4
9681: oGetParam 2
9683: oPushResult
9684: oSetResult 21
9686: oPushResult
9687: oNodeGet
9688: oPop 2
9690: oPushResult
9691: oTypeSPush
9692: oPop 1
9694: oTypeSNodeType
9695: oChoice 9710
9697: oInputChoice 9705
9699: oEmit 26
9701: oCall 7923
9703: oJumpForward 9708
9705: Choice Lookup Table
          17   9699
9708: oJumpForward 9713
9710: Choice Lookup Table
          36   9697
9713: oCall 7728
9715: oReturn
9716: oLocalSpace 0
9718: oGetParam 1
9720: oPushResult
9721: oSetResult 1
9723: oPushResult
9724: oCall 9580
9726: oPop 2
9728: oCall 8740
9730: oGetParam 1
9732: oPushResult
9733: oCall 6915
9735: oPop 1
9737: oTypeSPop
9738: oEmit 34
9740: oEmit 27
9742: oReturn
9743: oLocalSpace 0
9745: oGetParam 1
9747: oPushResult
9748: oSetResult 1
9750: oPushResult
9751: oCall 9580
9753: oPop 2
9755: oCall 8740
9757: oGetParam 1
9759: oPushResult
9760: oCall 6915
9762: oPop 1
9764: oTypeSPop
9765: oEmit 35
9767: oEmit 27
9769: oReturn
9770: oLocalSpace 2
9772: oGetAddrLocal 1
9774: oPushResult
9775: oSetResult 0
9777: oAssign
9778: oGetAddrLocal 1
9780: oPushResult
9781: oCall 4933
9783: oPop 1
9785: oInput 43
9787: oCall 8882
9789: oInputChoice 9824
9791: oGetAddrLocal 2
9793: oPushResult
9794: oLabelNew
9795: oAssign
9796: oEmit 79
9798: oGetLocal 2
9800: oPushResult
9801: oEmitLabel
9802: oPop 1
9804: oEmit 88
9806: oGetLocal 1
9808: oPushResult
9809: oEmitLabel
9810: oPop 1
9812: oCall 8882
9814: oEmit 88
9816: oGetLocal 2
9818: oPushResult
9819: oEmitLabel
9820: oPop 1
9822: oJumpForward 9835
9824: Choice Lookup Table
          44   9791
9827: oEmit 88
9829: oGetLocal 1
9831: oPushResult
9832: oEmitLabel
9833: oPop 1
9835: oReturn
9836: oLocalSpace 4
9838: oInput 0
9840: oGetAddrLocal 1
9842: oPushResult
9843: oScopeFindRequire
9844: oAssign
9845: oGetLocal 1
9847: oPushResult
9848: oSetResult 1
9850: oPushResult
9851: oCall 9580
9853: oPop 2
9855: oCall 8740
9857: oInput 5
9859: oCall 4887
9861: oCall 8740
9863: oEmit 27
9865: oGetAddrLocal 2
9867: oPushResult
9868: oLabelNew
9869: oAssign
9870: oGetAddrLocal 3
9872: oPushResult
9873: oLabelNew
9874: oAssign
9875: oEmit 79
9877: oGetLocal 3
9879: oPushResult
9880: oEmitLabel
9881: oPop 1
9883: oGetAddrLocal 4
9885: oPushResult
9886: oLabelNew
9887: oAssign
9888: oEmit 88
9890: oGetLocal 4
9892: oPushResult
9893: oEmitLabel
9894: oPop 1
9896: oInputChoice 9976
9898: oGetLocal 1
9900: oPushResult
9901: oCall 9716
9903: oPop 1
9905: oEmit 88
9907: oGetLocal 3
9909: oPushResult
9910: oEmitLabel
9911: oPop 1
9913: oGetLocal 1
9915: oPushResult
9916: oCall 6915
9918: oPop 1
9920: oTypeSPop
9921: oCall 4887
9923: oCall 8740
9925: oEmit 58
9927: oEmit 80
9929: oGetLocal 2
9931: oPushResult
9932: oEmitLabel
9933: oPop 1
9935: oJumpForward 9982
9937: oGetLocal 1
9939: oPushResult
9940: oCall 9743
9942: oPop 1
9944: oEmit 88
9946: oGetLocal 3
9948: oPushResult
9949: oEmitLabel
9950: oPop 1
9952: oGetLocal 1
9954: oPushResult
9955: oCall 6915
9957: oPop 1
9959: oTypeSPop
9960: oCall 4887
9962: oCall 8740
9964: oEmit 59
9966: oEmit 80
9968: oGetLocal 2
9970: oPushResult
9971: oEmitLabel
9972: oPop 1
9974: oJumpForward 9982
9976: Choice Lookup Table
          47   9937
          46   9898
9981: oEndChoice
9982: oGetLocal 4
9984: oPushResult
9985: oGetLocal 2
9987: oPushResult
9988: oLoopPush
9989: oPop 2
9991: oInput 48
9993: oCall 8882
9995: oEmit 79
9997: oGetLocal 4
9999: oPushResult
10000: oEmitLabel
10001: oPop 1
10003: oEmit 88
10005: oGetLocal 2
10007: oPushResult
10008: oEmitLabel
10009: oPop 1
10011: oLoopPop
10012: oReturn
10013: oLocalSpace 3
10015: oGetAddrLocal 1
10017: oPushResult
10018: oLabelNew
10019: oAssign
10020: oEmit 88
10022: oGetLocal 1
10024: oPushResult
10025: oEmitLabel
10026: oPop 1
10028: oGetAddrLocal 2
10030: oPushResult
10031: oLabelNew
10032: oAssign
10033: oGetLocal 1
10035: oPushResult
10036: oGetLocal 2
10038: oPushResult
10039: oLoopPush
10040: oPop 2
10042: oCall 8882
10044: oInputChoice 10075
10046: oCall 8882
10048: oJumpForward 10081
10050: oGetAddrLocal 3
10052: oPushResult
10053: oCall 4933
10055: oPop 1
10057: oEmit 89
10059: oGetLocal 3
10061: oPushResult
10062: oEmitLabel
10063: oPop 1
10065: oGetLocal 1
10067: oPushResult
10068: oEmitLabel
10069: oPop 1
10071: oJumpForward 10083
10073: oJumpForward 10081
10075: Choice Lookup Table
          51   10050
           6   10046
10080: oEndChoice
10081: oJumpBack 10044
10083: oEmit 88
10085: oGetLocal 2
10087: oPushResult
10088: oEmitLabel
10089: oPop 1
10091: oLoopPop
10092: oReturn
10093: oLocalSpace 2
10095: oGetAddrLocal 1
10097: oPushResult
10098: oLabelNew
10099: oAssign
10100: oEmit 88
10102: oGetLocal 1
10104: oPushResult
10105: oEmitLabel
10106: oPop 1
10108: oGetAddrLocal 2
10110: oPushResult
10111: oCall 4933
10113: oPop 1
10115: oGetLocal 1
10117: oPushResult
10118: oGetLocal 2
10120: oPushResult
10121: oLoopPush
10122: oPop 2
10124: oInput 48
10126: oCall 8882
10128: oEmit 79
10130: oGetLocal 1
10132: oPushResult
10133: oEmitLabel
10134: oPop 1
10136: oEmit 88
10138: oGetLocal 2
10140: oPushResult
10141: oEmitLabel
10142: oPop 1
10144: oLoopPop
10145: oReturn
10146: oLocalSpace 0
10148: oLoopContinueLabel
10149: oPushResult
10150: oSetResult 0
10152: oPushResult
10153: equal_label
10154: oPop 2
10156: oChoice 10171
10158: oError 19
10160: oJumpForward 10177
10162: oEmit 79
10164: oLoopContinueLabel
10165: oPushResult
10166: oEmitLabel
10167: oPop 1
10169: oJumpForward 10177
10171: Choice Lookup Table
           0   10162
           1   10158
10176: oEndChoice
10177: oReturn
10178: oLocalSpace 0
10180: oLoopBreakLabel
10181: oPushResult
10182: oSetResult 0
10184: oPushResult
10185: equal_label
10186: oPop 2
10188: oChoice 10203
10190: oError 19
10192: oJumpForward 10209
10194: oEmit 79
10196: oLoopBreakLabel
10197: oPushResult
10198: oEmitLabel
10199: oPop 1
10201: oJumpForward 10209
10203: Choice Lookup Table
           0   10194
           1   10190
10208: oEndChoice
10209: oReturn
10210: oLocalSpace 8
10212: oGetAddrLocal 1
10214: oPushResult
10215: oCodeNew
10216: oAssign
10217: oGetAddrLocal 2
10219: oPushResult
10220: oLabelNew
10221: oAssign
10222: oGetAddrLocal 3
10224: oPushResult
10225: oLabelNew
10226: oAssign
10227: oGetAddrLocal 4
10229: oPushResult
10230: oGetLocal 3
10232: oAssign
10233: oGetAddrLocal 5
10235: oPushResult
10236: oSetResult 0
10238: oAssign
10239: oCall 4887
10241: oTypeSNodeType
10242: oChoice 10280
10244: oEmit 82
10246: oGetLocal 2
10248: oPushResult
10249: oEmitLabel
10250: oPop 1
10252: oJumpForward 10297
10254: oEmit 83
10256: oGetLocal 2
10258: oPushResult
10259: oEmitLabel
10260: oPop 1
10262: oJumpForward 10297
10264: oGetAddrLocal 5
10266: oPushResult
10267: oSetResult 1
10269: oAssign
10270: oEmit 84
10272: oGetLocal 2
10274: oPushResult
10275: oEmitLabel
10276: oPop 1
10278: oJumpForward 10297
10280: Choice Lookup Table
          41   10264
          42   10264
          43   10254
          30   10254
          35   10244
          29   10244
          33   10244
10295: oError 18
10297: oInput 41
10299: oInputChoice 10346
10301: oGetAddrLocal 4
10303: oPushResult
10304: oLabelNew
10305: oAssign
10306: oEmit 88
10308: oGetLocal 4
10310: oPushResult
10311: oEmitLabel
10312: oPop 1
10314: oInputChoice 10320
10316: oJumpForward 10338
10318: oJumpForward 10336
10320: Choice Lookup Table
          37   10316
10323: oCall 8882
10325: oInputChoice 10329
10327: oJumpForward 10336
10329: Choice Lookup Table
           6   10327
10332: oInput 37
10334: oJumpForward 10338
10336: oJumpBack 10314
10338: oJumpForward 10512
10340: oJumpForward 10510
10342: oJumpForward 10512
10344: oJumpForward 10510
10346: Choice Lookup Table
          37   10342
          44   10301
          55   10301
10353: oGetAddrLocal 6
10355: oPushResult
10356: oLabelNew
10357: oAssign
10358: oGetLocal 1
10360: oPushResult
10361: oCodePush
10362: oPop 1
10364: oCall 3539
10366: oCall 4351
10368: oGetLocal 5
10370: oChoice 10390
10372: oGetAddrLocal 7
10374: oPushResult
10375: oValueTopString
10376: oPushResult
10377: oStringAllocShortStringLit
10378: oPop 1
10380: oAssign
10381: oJumpForward 10396
10383: oGetAddrLocal 7
10385: oPushResult
10386: oValueTop
10387: oAssign
10388: oJumpForward 10396
10390: Choice Lookup Table
           0   10383
           1   10372
10395: oEndChoice
10396: oValuePop
10397: oInputChoice 10454
10399: oCall 3539
10401: oCall 4351
10403: oGetLocal 5
10405: oChoice 10425
10407: oGetAddrLocal 8
10409: oPushResult
10410: oValueTopString
10411: oPushResult
10412: oStringAllocShortStringLit
10413: oPop 1
10415: oAssign
10416: oJumpForward 10431
10418: oGetAddrLocal 8
10420: oPushResult
10421: oValueTop
10422: oAssign
10423: oJumpForward 10431
10425: Choice Lookup Table
           0   10418
           1   10407
10430: oEndChoice
10431: oValuePop
10432: oEmit 86
10434: oGetLocal 7
10436: oPushResult
10437: oEmitInt
10438: oPop 1
10440: oGetLocal 8
10442: oPushResult
10443: oEmitInt
10444: oPop 1
10446: oGetLocal 6
10448: oPushResult
10449: oEmitLabel
10450: oPop 1
10452: oJumpForward 10471
10454: Choice Lookup Table
          22   10399
10457: oEmit 85
10459: oGetLocal 7
10461: oPushResult
10462: oEmitInt
10463: oPop 1
10465: oGetLocal 6
10467: oPushResult
10468: oEmitLabel
10469: oPop 1
10471: oInputChoice 10475
10473: oJumpForward 10480
10475: Choice Lookup Table
          14   10473
10478: oJumpForward 10482
10480: oJumpBack 10364
10482: oCodePop
10483: oInput 13
10485: oEmit 88
10487: oGetLocal 6
10489: oPushResult
10490: oEmitLabel
10491: oPop 1
10493: oCall 8882
10495: oEmit 79
10497: oGetLocal 3
10499: oPushResult
10500: oEmitLabel
10501: oPop 1
10503: oInputChoice 10507
10505: oJumpForward 10510
10507: Choice Lookup Table
           6   10505
10510: oJumpBack 10299
10512: oEmit 88
10514: oGetLocal 2
10516: oPushResult
10517: oEmitLabel
10518: oPop 1
10520: oGetLocal 1
10522: oPushResult
10523: oEmitCode
10524: oPop 1
10526: oEmit 87
10528: oGetLocal 4
10530: oPushResult
10531: oEmitLabel
10532: oPop 1
10534: oEmit 88
10536: oGetLocal 3
10538: oPushResult
10539: oEmitLabel
10540: oPop 1
10542: oTypeSPop
10543: oReturn
10544: oLocalSpace 1
10546: oInputChoice 10553
10548: oJumpForward 10559
10550: oChangeIntLitToLabelIdent
10551: oJumpForward 10559
10553: Choice Lookup Table
           1   10550
           0   10548
10558: oEndChoice
10559: oGetAddrLocal 1
10561: oPushResult
10562: oScopeCurrent
10563: oPushResult
10564: oScopeFindRequireInScope
10565: oPop 1
10567: oAssign
10568: oGetLocal 1
10570: oPushResult
10571: oSetResult 28
10573: oPushResult
10574: oSetResult 1
10576: oPushResult
10577: oNodeSetBoolean
10578: oPop 3
10580: oEmit 79
10582: oGetLocal 1
10584: oPushResult
10585: oSetResult 22
10587: oPushResult
10588: oNodeGetLabel
10589: oPop 2
10591: oPushResult
10592: oEmitLabel
10593: oPop 1
10595: oReturn
10596: oLocalSpace 0
10598: oCall 8882
10600: oInputChoice 10610
10602: oCall 8882
10604: oJumpForward 10616
10606: oJumpForward 10618
10608: oJumpForward 10616
10610: Choice Lookup Table
          37   10606
           6   10602
10615: oEndChoice
10616: oJumpBack 10600
10618: oReturn
10619: oLocalSpace 0
10621: oCall 10626
10623: oEmit 99
10625: oReturn
10626: oLocalSpace 0
10628: oInputChoice 10752
10630: oCall 4887
10632: oTypeSNodeType
10633: oChoice 10708
10635: oEmit 91
10637: oJumpForward 10733
10639: oEmit 92
10641: oJumpForward 10733
10643: oEmit 32
10645: oEmit 91
10647: oJumpForward 10733
10649: oEmit 93
10651: oJumpForward 10733
10653: oEmit 98
10655: oJumpForward 10733
10657: oEmit 94
10659: oJumpForward 10733
10661: oError 17
10663: oJumpForward 10733
10665: oEmit 17
10667: oTypeSTop
10668: oPushResult
10669: oSetResult 43
10671: oPushResult
10672: oNodeGetInt
10673: oPop 2
10675: oPushResult
10676: oEmitInt
10677: oPop 1
10679: oEmit 97
10681: oJumpForward 10733
10683: oTypeSTop
10684: oPushResult
10685: oGetGlobal 10
10687: oPushResult
10688: equal_node
10689: oPop 2
10691: oChoice 10697
10693: oEmit 95
10695: oJumpForward 10702
10697: Choice Lookup Table
           1   10693
10700: oEmit 96
10702: oJumpForward 10733
10704: oEmit 96
10706: oJumpForward 10733
10708: Choice Lookup Table
          37   10704
          36   10683
          43   10665
          28   10661
          41   10657
          42   10657
          32   10653
          35   10649
          29   10643
          33   10639
          30   10635
10731: oError 18
10733: oTypeSPop
10734: oInputChoice 10742
10736: oJumpForward 10750
10738: oJumpForward 10748
10740: oJumpForward 10748
10742: Choice Lookup Table
          14   10740
          16   10736
10747: oEndChoice
10748: oJumpBack 10630
10750: oJumpForward 10755
10752: Choice Lookup Table
          15   10630
10755: oReturn
10756: oLocalSpace 0
10758: oCall 10763
10760: oEmit 103
10762: oReturn
10763: oLocalSpace 1
10765: oInputChoice 10842
10767: oSetResult 1
10769: oPushResult
10770: oCall 9336
10772: oPop 1
10774: oTypeSNodeType
10775: oChoice 10814
10777: oEmit 100
10779: oJumpForward 10823
10781: oEmit 101
10783: oJumpForward 10823
10785: oGetAddrLocal 1
10787: oPushResult
10788: oTypeSTop
10789: oPushResult
10790: oSetResult 17
10792: oPushResult
10793: oNodeGetInt
10794: oPop 2
10796: oPushResult
10797: oSetResult 1
10799: oPushResult
10800: subtract
10801: oPop 2
10803: oAssign
10804: oEmit 102
10806: oGetLocal 1
10808: oPushResult
10809: oEmitInt
10810: oPop 1
10812: oJumpForward 10823
10814: Choice Lookup Table
          42   10785
          35   10781
          30   10777
10821: oError 18
10823: oTypeSPop
10824: oInputChoice 10832
10826: oJumpForward 10840
10828: oJumpForward 10838
10830: oJumpForward 10838
10832: Choice Lookup Table
          14   10830
          16   10826
10837: oEndChoice
10838: oJumpBack 10767
10840: oJumpForward 10845
10842: Choice Lookup Table
          15   10767
10845: oReturn
10846: oLocalSpace 1
10848: oGetAddrLocal 1
10850: oPushResult
10851: oGetGlobal 16
10853: oPushResult
10854: oScopeAllocType
10855: oPop 1
10857: oAssign
10858: oTypeSNodeType
10859: oChoice 10927
10861: oEmit 18
10863: oGetLocal 1
10865: oPushResult
10866: oEmitInt
10867: oPop 1
10869: oEmit 23
10871: oEmit 31
10873: oGetGlobal 16
10875: oPushResult
10876: oSetResult 17
10878: oPushResult
10879: oNodeGetInt
10880: oPop 2
10882: oPushResult
10883: oEmitInt
10884: oPop 1
10886: oJumpForward 10936
10888: oEmit 18
10890: oGetLocal 1
10892: oPushResult
10893: oEmitInt
10894: oPop 1
10896: oEmit 15
10898: oSetResult 1
10900: oPushResult
10901: oEmitInt
10902: oPop 1
10904: oEmit 28
10906: oEmit 18
10908: oGetLocal 1
10910: oPushResult
10911: oSetResult 1
10913: oPushResult
10914: add
10915: oPop 2
10917: oPushResult
10918: oEmitInt
10919: oPop 1
10921: oEmit 23
10923: oEmit 28
10925: oJumpForward 10936
10927: Choice Lookup Table
          35   10888
          41   10861
          42   10861
10934: oError 15
10936: oTypeSPop
10937: oEmit 18
10939: oGetLocal 1
10941: oPushResult
10942: oEmitInt
10943: oPop 1
10945: oGetGlobal 16
10947: oPushResult
10948: oTypeSPush
10949: oPop 1
10951: oGetLocal 1
10953: oReturn
10954: oReturn
10955: oLocalSpace 0
10957: oEmit 72
10959: oSetResult 16
10961: oPushResult
10962: oEmitInt
10963: oPop 1
10965: oEmit 20
10967: oSetResult 8
10969: oPushResult
10970: oEmitInt
10971: oPop 1
10973: oEmit 23
10975: oEmit 29
10977: oEmit 20
10979: oSetResult 0
10981: oPushResult
10982: oEmitInt
10983: oPop 1
10985: oEmit 23
10987: oEmit 29
10989: oEmit 75
10991: oGetGlobal 22
10993: oPushResult
10994: oCall 14197
10996: oPop 1
10998: oEmit 74
11000: oSetResult 16
11002: oPushResult
11003: oEmitInt
11004: oPop 1
11006: oTypeSPop
11007: oTypeSPop
11008: oReturn
11009: oLocalSpace 0
11011: oEmit 72
11013: oSetResult 12
11015: oPushResult
11016: oEmitInt
11017: oPop 1
11019: oEmit 20
11021: oSetResult 8
11023: oPushResult
11024: oEmitInt
11025: oPop 1
11027: oEmit 23
11029: oEmit 28
11031: oEmit 20
11033: oSetResult 0
11035: oPushResult
11036: oEmitInt
11037: oPop 1
11039: oEmit 23
11041: oEmit 29
11043: oEmit 75
11045: oGetGlobal 23
11047: oPushResult
11048: oCall 14197
11050: oPop 1
11052: oEmit 74
11054: oSetResult 12
11056: oPushResult
11057: oEmitInt
11058: oPop 1
11060: oTypeSPop
11061: oTypeSPop
11062: oReturn
11063: oLocalSpace 1
11065: oEmit 73
11067: oSetResult 24
11069: oPushResult
11070: oEmitInt
11071: oPop 1
11073: oEmit 20
11075: oSetResult 8
11077: oPushResult
11078: oEmitInt
11079: oPop 1
11081: oEmit 23
11083: oEmit 29
11085: oEmit 20
11087: oSetResult 0
11089: oPushResult
11090: oEmitInt
11091: oPop 1
11093: oEmit 23
11095: oEmit 29
11097: oGetAddrLocal 1
11099: oPushResult
11100: oGetGlobal 6
11102: oPushResult
11103: oScopeAllocType
11104: oPop 1
11106: oAssign
11107: oEmit 20
11109: oSetResult 16
11111: oPushResult
11112: oEmitInt
11113: oPop 1
11115: oEmit 18
11117: oGetLocal 1
11119: oPushResult
11120: oEmitInt
11121: oPop 1
11123: oEmit 29
11125: oEmit 76
11127: oGetGlobal 24
11129: oPushResult
11130: oCall 14197
11132: oPop 1
11134: oEmit 3
11136: oGetLocal 1
11138: oPushResult
11139: oEmitInt
11140: oPop 1
11142: oEmit 74
11144: oSetResult 24
11146: oPushResult
11147: oEmitInt
11148: oPop 1
11150: oTypeSPop
11151: oGetGlobal 6
11153: oPushResult
11154: oTypeSPush
11155: oPop 1
11157: oReturn
11158: oLocalSpace 10
11160: oGetParam 1
11162: oPushResult
11163: oSetResult 28
11165: oPushResult
11166: oSetResult 1
11168: oPushResult
11169: oNodeSetBoolean
11170: oPop 3
11172: oGetAddrLocal 1
11174: oPushResult
11175: oGetParam 1
11177: oPushResult
11178: oSetResult 27
11180: oPushResult
11181: oNodeGetBoolean
11182: oPop 2
11184: oAssign
11185: oGetAddrLocal 4
11187: oPushResult
11188: oGetParam 1
11190: oPushResult
11191: oNodeType
11192: oPop 1
11194: oPushResult
11195: oSetResult 13
11197: oPushResult
11198: equal_node_type
11199: oPop 2
11201: oAssign
11202: oGetLocal 4
11204: oChoice 11231
11206: oGetAddrLocal 2
11208: oPushResult
11209: oGetParam 1
11211: oPushResult
11212: oSetResult 21
11214: oPushResult
11215: oNodeGet
11216: oPop 2
11218: oAssign
11219: oGetAddrLocal 3
11221: oPushResult
11222: oGetLocal 2
11224: oPushResult
11225: oScopeAllocType
11226: oPop 1
11228: oAssign
11229: oJumpForward 11234
11231: Choice Lookup Table
           1   11206
11234: oGetAddrLocal 5
11236: oPushResult
11237: oGetParam 1
11239: oPushResult
11240: oSetResult 23
11242: oPushResult
11243: oNodeGet
11244: oPop 2
11246: oAssign
11247: oGetAddrLocal 6
11249: oPushResult
11250: oGetLocal 5
11252: oPushResult
11253: oSetResult 17
11255: oPushResult
11256: oNodeGetInt
11257: oPop 2
11259: oAssign
11260: oGetLocal 1
11262: oChoice 11284
11264: oEmit 73
11266: oGetLocal 6
11268: oPushResult
11269: oEmitInt
11270: oPop 1
11272: oJumpForward 11290
11274: oEmit 72
11276: oGetLocal 6
11278: oPushResult
11279: oEmitInt
11280: oPop 1
11282: oJumpForward 11290
11284: Choice Lookup Table
           0   11274
           1   11264
11289: oEndChoice
11290: oGetParam 1
11292: oPushResult
11293: oCall 14131
11295: oPop 1
11297: oPushResult
11298: oSetResult 0
11300: oPushResult
11301: greater
11302: oPop 2
11304: oChoice 11337
11306: oEmit 20
11308: oSetResult 0
11310: oPushResult
11311: oEmitInt
11312: oPop 1
11314: oEmit 21
11316: oGetParam 1
11318: oPushResult
11319: oCall 14151
11321: oPop 1
11323: oPushResult
11324: oEmitInt
11325: oPop 1
11327: oSetResult 0
11329: oPushResult
11330: oEmitInt
11331: oPop 1
11333: oEmit 29
11335: oJumpForward 11340
11337: Choice Lookup Table
           1   11306
11340: oGetAddrLocal 7
11342: oPushResult
11343: oGetLocal 5
11345: oPushResult
11346: oSetResult 15
11348: oPushResult
11349: oNodeGetIter
11350: oPop 2
11352: oAssign
11353: oGetAddrLocal 8
11355: oPushResult
11356: oGetLocal 7
11358: oPushResult
11359: oNodeIterValue
11360: oPop 1
11362: oAssign
11363: oInputChoice 11566
11365: oGetLocal 8
11367: oPushResult
11368: oNodeNull
11369: oPop 1
11371: oChoice 11377
11373: oJumpForward 11562
11375: oJumpForward 11380
11377: Choice Lookup Table
           1   11373
11380: oGetAddrLocal 9
11382: oPushResult
11383: oGetLocal 8
11385: oPushResult
11386: oSetResult 22
11388: oPushResult
11389: oNodeGetInt
11390: oPop 2
11392: oAssign
11393: oEmit 20
11395: oGetLocal 9
11397: oPushResult
11398: oEmitInt
11399: oPop 1
11401: oGetLocal 8
11403: oPushResult
11404: oSetResult 21
11406: oPushResult
11407: oNodeGet
11408: oPop 2
11410: oPushResult
11411: oTypeSPush
11412: oPop 1
11414: oGetLocal 8
11416: oPushResult
11417: oSetResult 34
11419: oPushResult
11420: oNodeGetBoolean
11421: oPop 2
11423: oChoice 11515
11425: oSetResult 1
11427: oPushResult
11428: oCall 9336
11430: oPop 1
11432: oCall 8682
11434: oEmit 29
11436: oJumpForward 11521
11438: oCall 4887
11440: oCall 8345
11442: oTypeSNodeType
11443: oChoice 11487
11445: oEmit 27
11447: oJumpForward 11513
11449: oEmit 28
11451: oJumpForward 11513
11453: oEmit 30
11455: oJumpForward 11513
11457: oError 17
11459: oJumpForward 11513
11461: oEmit 29
11463: oJumpForward 11513
11465: oGetAddrLocal 10
11467: oPushResult
11468: oTypeSTop
11469: oPushResult
11470: oSetResult 17
11472: oPushResult
11473: oNodeGetInt
11474: oPop 2
11476: oAssign
11477: oEmit 31
11479: oGetLocal 10
11481: oPushResult
11482: oEmitInt
11483: oPop 1
11485: oJumpForward 11513
11487: Choice Lookup Table
          42   11465
          40   11465
          38   11465
          37   11461
          36   11461
          28   11457
          32   11453
          35   11449
          29   11449
          33   11449
          43   11445
          30   11445
11512: oEndChoice
11513: oJumpForward 11521
11515: Choice Lookup Table
           0   11438
           1   11425
11520: oEndChoice
11521: oTypeSPop
11522: oGetAddrLocal 7
11524: oPushResult
11525: oNodeIterNext
11526: oPop 1
11528: oGetAddrLocal 8
11530: oPushResult
11531: oGetLocal 7
11533: oPushResult
11534: oNodeIterValue
11535: oPop 1
11537: oAssign
11538: oGetLocal 8
11540: oPushResult
11541: oNodeNull
11542: oPop 1
11544: oChoice 11552
11546: oJumpForward 11562
11548: oJumpForward 11558
11550: oJumpForward 11558
11552: Choice Lookup Table
           0   11550
           1   11546
11557: oEndChoice
11558: oInput 14
11560: oJumpBack 11365
11562: oInput 16
11564: oJumpForward 11569
11566: Choice Lookup Table
          15   11365
11569: oGetLocal 8
11571: oPushResult
11572: oNodeNull
11573: oPop 1
11575: oChoice 11581
11577: oError 16
11579: oJumpForward 11584
11581: Choice Lookup Table
           0   11577
11584: oGetLocal 4
11586: oChoice 11615
11588: oEmit 20
11590: oGetParam 1
11592: oPushResult
11593: oSetResult 31
11595: oPushResult
11596: oNodeGetInt
11597: oPop 2
11599: oPushResult
11600: oEmitInt
11601: oPop 1
11603: oEmit 18
11605: oGetLocal 3
11607: oPushResult
11608: oEmitInt
11609: oPop 1
11611: oEmit 29
11613: oJumpForward 11618
11615: Choice Lookup Table
           1   11588
11618: oGetLocal 1
11620: oChoice 11644
11622: oEmit 76
11624: oGetParam 1
11626: oPushResult
11627: oCall 14197
11629: oPop 1
11631: oJumpForward 11650
11633: oEmit 75
11635: oGetParam 1
11637: oPushResult
11638: oCall 14197
11640: oPop 1
11642: oJumpForward 11650
11644: Choice Lookup Table
           0   11633
           1   11622
11649: oEndChoice
11650: oGetLocal 4
11652: oChoice 11733
11654: oGetLocal 2
11656: oPushResult
11657: oTypeSPush
11658: oPop 1
11660: oTypeSNodeType
11661: oChoice 11707
11663: oEmit 3
11665: oGetLocal 3
11667: oPushResult
11668: oEmitInt
11669: oPop 1
11671: oJumpForward 11731
11673: oEmit 4
11675: oGetLocal 3
11677: oPushResult
11678: oEmitInt
11679: oPop 1
11681: oJumpForward 11731
11683: oError 17
11685: oJumpForward 11731
11687: oEmit 5
11689: oGetLocal 3
11691: oPushResult
11692: oEmitInt
11693: oPop 1
11695: oJumpForward 11731
11697: oEmit 18
11699: oGetLocal 3
11701: oPushResult
11702: oEmitInt
11703: oPop 1
11705: oJumpForward 11731
11707: Choice Lookup Table
          42   11697
          40   11697
          38   11697
          37   11687
          36   11687
          28   11683
          35   11673
          29   11673
          33   11673
          43   11663
          30   11663
11730: oEndChoice
11731: oJumpForward 11736
11733: Choice Lookup Table
           1   11654
11736: oEmit 74
11738: oGetLocal 6
11740: oPushResult
11741: oEmitInt
11742: oPop 1
11744: oReturn
11745: oLocalSpace 2
11747: oGetAddrLocal 2
11749: oPushResult
11750: oGetParam 1
11752: oPushResult
11753: oSetResult 26
11755: oPushResult
11756: oNodeGetString
11757: oPop 2
11759: oAssign
11760: oGetLocal 2
11762: oPushResult
11763: oSetResult 0
11765: oPushResult
11766: equal_string
11767: oPop 2
11769: oChoice 11806
11771: oGetAddrLocal 1
11773: oPushResult
11774: oGetParam 1
11776: oPushResult
11777: oSetResult 4
11779: oPushResult
11780: oNodeGetInt
11781: oPop 2
11783: oPushResult
11784: ID_STRING
11785: oPop 1
11787: oPushResult
11788: oStringAllocLit
11789: oPop 1
11791: oAssign
11792: oJumpForward 11812
11794: oGetAddrLocal 1
11796: oPushResult
11797: oGetLocal 2
11799: oPushResult
11800: oStringAllocLit
11801: oPop 1
11803: oAssign
11804: oJumpForward 11812
11806: Choice Lookup Table
           0   11794
           1   11771
11811: oEndChoice
11812: oEmit 90
11814: oGetParam 1
11816: oPushResult
11817: oCall 14197
11819: oPop 1
11821: oGetLocal 1
11823: oPushResult
11824: oEmitInt
11825: oPop 1
11827: oReturn
11828: oLocalSpace 2
11830: oGetParam 1
11832: oPushResult
11833: oGetGlobal 17
11835: oPushResult
11836: oNodeEqual
11837: oPop 2
11839: oChoice 11879
11841: oInput 15
11843: oCall 4887
11845: oTypeSNodeType
11846: oChoice 11854
11848: oJumpForward 11867
11850: oEmit 32
11852: oJumpForward 11867
11854: Choice Lookup Table
          35   11850
          29   11850
          33   11850
          43   11848
          30   11848
11865: oError 15
11867: oTypeSPop
11868: oGetGlobal 6
11870: oPushResult
11871: oTypeSPush
11872: oPop 1
11874: oInput 16
11876: oReturn
11877: oJumpForward 11882
11879: Choice Lookup Table
           1   11841
11882: oGetParam 1
11884: oPushResult
11885: oGetGlobal 18
11887: oPushResult
11888: oNodeEqual
11889: oPop 2
11891: oChoice 11925
11893: oInput 15
11895: oCall 4887
11897: oTypeSNodeType
11898: oChoice 11906
11900: oEmit 33
11902: oJumpForward 11913
11904: oJumpForward 11913
11906: Choice Lookup Table
          29   11904
          30   11900
11911: oError 15
11913: oTypeSPop
11914: oGetGlobal 9
11916: oPushResult
11917: oTypeSPush
11918: oPop 1
11920: oInput 16
11922: oReturn
11923: oJumpForward 11928
11925: Choice Lookup Table
           1   11893
11928: oGetParam 1
11930: oPushResult
11931: oGetGlobal 19
11933: oPushResult
11934: oNodeEqual
11935: oPop 2
11937: oChoice 11977
11939: oInput 15
11941: oCall 4887
11943: oTypeSNodeType
11944: oChoice 11965
11946: oTypeSTop
11947: oPushResult
11948: oSetResult 44
11950: oPushResult
11951: oNodeGetBoolean
11952: oPop 2
11954: oChoice 11960
11956: oError 29
11958: oJumpForward 11963
11960: Choice Lookup Table
           1   11956
11963: oJumpForward 11970
11965: Choice Lookup Table
          43   11946
11968: oError 15
11970: oEmit 35
11972: oInput 16
11974: oReturn
11975: oJumpForward 11980
11977: Choice Lookup Table
           1   11939
11980: oGetParam 1
11982: oPushResult
11983: oGetGlobal 20
11985: oPushResult
11986: oNodeEqual
11987: oPop 2
11989: oChoice 12029
11991: oInput 15
11993: oCall 4887
11995: oTypeSNodeType
11996: oChoice 12017
11998: oTypeSTop
11999: oPushResult
12000: oSetResult 44
12002: oPushResult
12003: oNodeGetBoolean
12004: oPop 2
12006: oChoice 12012
12008: oError 29
12010: oJumpForward 12015
12012: Choice Lookup Table
           1   12008
12015: oJumpForward 12022
12017: Choice Lookup Table
          43   11998
12020: oError 15
12022: oEmit 34
12024: oInput 16
12026: oReturn
12027: oJumpForward 12032
12029: Choice Lookup Table
           1   11991
12032: oGetParam 1
12034: oPushResult
12035: oGetGlobal 21
12037: oPushResult
12038: oNodeEqual
12039: oPop 2
12041: oChoice 12097
12043: oInput 15
12045: oGetAddrLocal 1
12047: oPushResult
12048: oCodeNew
12049: oAssign
12050: oGetLocal 1
12052: oPushResult
12053: oCodePush
12054: oPop 1
12056: oCall 4910
12058: oCodePop
12059: oGetLocal 1
12061: oPushResult
12062: oCodeDiscard
12063: oPop 1
12065: oGetAddrLocal 2
12067: oPushResult
12068: oTypeSTop
12069: oAssign
12070: oTypeSPop
12071: oEmit 15
12073: oGetLocal 2
12075: oPushResult
12076: oSetResult 17
12078: oPushResult
12079: oNodeGetInt
12080: oPop 2
12082: oPushResult
12083: oEmitInt
12084: oPop 1
12086: oGetGlobal 6
12088: oPushResult
12089: oTypeSPush
12090: oPop 1
12092: oInput 16
12094: oReturn
12095: oJumpForward 12100
12097: Choice Lookup Table
           1   12043
12100: oError 17
12102: oReturn
12103: oLocalSpace 1
12105: oGetAddrLocal 1
12107: oPushResult
12108: oGetParam 2
12110: oPushResult
12111: oNodeNew
12112: oPop 1
12114: oAssign
12115: oGetLocal 1
12117: oPushResult
12118: oSetResult 17
12120: oPushResult
12121: oGetParam 1
12123: oPushResult
12124: oNodeSetInt
12125: oPop 3
12127: oGetLocal 1
12129: oPushResult
12130: oTypeAdd
12131: oPop 1
12133: oGetLocal 1
12135: oReturn
12136: oReturn
12137: oLocalSpace 12
12139: oInputChoice 12622
12141: oGetAddrLocal 1
12143: oPushResult
12144: oScopeFindRequire
12145: oAssign
12146: oGetAddrLocal 1
12148: oPushResult
12149: oCall 244
12151: oPop 1
12153: oGetLocal 1
12155: oPushResult
12156: oNodeType
12157: oPop 1
12159: oChoice 12176
12161: oGetParam 1
12163: oPushResult
12164: oGetLocal 1
12166: oPushResult
12167: oSetResult 21
12169: oPushResult
12170: oNodeGet
12171: oPop 2
12173: oAssign
12174: oJumpForward 12187
12176: Choice Lookup Table
          19   12161
12179: oError 2
12181: oGetParam 1
12183: oPushResult
12184: oGetGlobal 6
12186: oAssign
12187: oJumpForward 12645
12189: oInput 17
12191: oGetAddrLocal 2
12193: oPushResult
12194: oNodeVecNew
12195: oAssign
12196: oGetAddrLocal 3
12198: oPushResult
12199: oSetResult 39
12201: oPushResult
12202: oNodeNew
12203: oPop 1
12205: oAssign
12206: oCall 3539
12208: oGetLocal 3
12210: oPushResult
12211: oSetResult 39
12213: oPushResult
12214: oValueTop
12215: oPushResult
12216: oNodeSetInt
12217: oPop 3
12219: oValuePop
12220: oInput 22
12222: oCall 3539
12224: oGetLocal 3
12226: oPushResult
12227: oSetResult 40
12229: oPushResult
12230: oValueTop
12231: oPushResult
12232: oNodeSetInt
12233: oPop 3
12235: oValuePop
12236: oCall 4254
12238: oGetLocal 3
12240: oPushResult
12241: oSetResult 37
12243: oPushResult
12244: oTypeSTop
12245: oPushResult
12246: oNodeSet
12247: oPop 3
12249: oGetLocal 3
12251: oPushResult
12252: oSetResult 17
12254: oPushResult
12255: oTypeSTop
12256: oPushResult
12257: oSetResult 17
12259: oPushResult
12260: oNodeGetInt
12261: oPop 2
12263: oPushResult
12264: oNodeSetInt
12265: oPop 3
12267: oTypeSPop
12268: oGetLocal 3
12270: oPushResult
12271: oTypeAdd
12272: oPop 1
12274: oGetAddrLocal 4
12276: oPushResult
12277: oSetResult 38
12279: oPushResult
12280: oNodeNew
12281: oPop 1
12283: oAssign
12284: oGetLocal 4
12286: oPushResult
12287: oSetResult 38
12289: oPushResult
12290: oGetLocal 3
12292: oPushResult
12293: oNodeSet
12294: oPop 3
12296: oGetLocal 2
12298: oPushResult
12299: oGetLocal 4
12301: oPushResult
12302: oNodeVecAppend
12303: oPop 2
12305: oInputChoice 12313
12307: oJumpForward 12321
12309: oJumpForward 12319
12311: oJumpForward 12319
12313: Choice Lookup Table
          14   12311
          18   12307
12318: oEndChoice
12319: oJumpBack 12196
12321: oInput 41
12323: oGetAddrLocal 5
12325: oPushResult
12326: oCall 12137
12328: oPop 1
12330: oGetAddrLocal 6
12332: oPushResult
12333: oGetLocal 2
12335: oPushResult
12336: oNodeVecSize
12337: oPop 1
12339: oAssign
12340: oGetAddrLocal 6
12342: oPushResult
12343: dec
12344: oPop 1
12346: oGetAddrLocal 7
12348: oPushResult
12349: oGetLocal 2
12351: oPushResult
12352: oGetLocal 6
12354: oPushResult
12355: oNodeVecElement
12356: oPop 2
12358: oAssign
12359: oGetLocal 7
12361: oPushResult
12362: oSetResult 37
12364: oPushResult
12365: oGetLocal 5
12367: oPushResult
12368: oNodeSet
12369: oPop 3
12371: oGetAddrLocal 8
12373: oPushResult
12374: oGetLocal 7
12376: oPushResult
12377: oSetResult 38
12379: oPushResult
12380: oNodeGet
12381: oPop 2
12383: oAssign
12384: oGetAddrLocal 9
12386: oPushResult
12387: oGetLocal 8
12389: oPushResult
12390: oSetResult 40
12392: oPushResult
12393: oNodeGetInt
12394: oPop 2
12396: oPushResult
12397: oGetLocal 8
12399: oPushResult
12400: oSetResult 39
12402: oPushResult
12403: oNodeGetInt
12404: oPop 2
12406: oPushResult
12407: subtract
12408: oPop 2
12410: oAssign
12411: oGetAddrLocal 9
12413: oPushResult
12414: inc
12415: oPop 1
12417: oGetLocal 7
12419: oPushResult
12420: oSetResult 17
12422: oPushResult
12423: oGetLocal 9
12425: oPushResult
12426: oGetLocal 5
12428: oPushResult
12429: oSetResult 17
12431: oPushResult
12432: oNodeGetInt
12433: oPop 2
12435: oPushResult
12436: multiply
12437: oPop 2
12439: oPushResult
12440: oNodeSetInt
12441: oPop 3
12443: oGetLocal 7
12445: oPushResult
12446: oTypeAdd
12447: oPop 1
12449: oGetAddrLocal 5
12451: oPushResult
12452: oGetLocal 7
12454: oAssign
12455: oGetLocal 6
12457: oPushResult
12458: equal_zero
12459: oPop 1
12461: oChoice 12467
12463: oJumpForward 12472
12465: oJumpForward 12470
12467: Choice Lookup Table
           1   12463
12470: oJumpBack 12340
12472: oGetParam 1
12474: oPushResult
12475: oGetLocal 2
12477: oPushResult
12478: oSetResult 0
12480: oPushResult
12481: oNodeVecElement
12482: oPop 2
12484: oAssign
12485: oGetLocal 2
12487: oPushResult
12488: oNodeVecDelete
12489: oPop 1
12491: oJumpForward 12645
12493: oGetAddrLocal 10
12495: oPushResult
12496: oCall 12137
12498: oPop 1
12500: oGetParam 1
12502: oPushResult
12503: oGetLocal 10
12505: oPushResult
12506: oCall 13216
12508: oPop 1
12510: oAssign
12511: oJumpForward 12645
12513: oGetParam 1
12515: oPushResult
12516: oSetResult 40
12518: oPushResult
12519: oNodeNew
12520: oPop 1
12522: oAssign
12523: oSetResult -1
12525: oPushResult
12526: oSetResult 2
12528: oPushResult
12529: oScopeBegin
12530: oPop 2
12532: oSetResult 23
12534: oPushResult
12535: oCall 3240
12537: oPop 1
12539: oGetAddrLocal 11
12541: oPushResult
12542: oScopeCurrent
12543: oPushResult
12544: oSetResult 17
12546: oPushResult
12547: oNodeGetInt
12548: oPop 2
12550: oAssign
12551: oGetLocal 11
12553: oPushResult
12554: equal_zero
12555: oPop 1
12557: oChoice 12563
12559: oError 20
12561: oJumpForward 12566
12563: Choice Lookup Table
           1   12559
12566: oInput 37
12568: oGetFromParam 1
12570: oPushResult
12571: oSetResult 41
12573: oPushResult
12574: oScopeCurrent
12575: oPushResult
12576: oNodeSet
12577: oPop 3
12579: oGetFromParam 1
12581: oPushResult
12582: oSetResult 17
12584: oPushResult
12585: oGetLocal 11
12587: oPushResult
12588: oNodeSetInt
12589: oPop 3
12591: oScopeEnd
12592: oGetFromParam 1
12594: oPushResult
12595: oTypeAdd
12596: oPop 1
12598: oJumpForward 12645
12600: oGetParam 1
12602: oPushResult
12603: oCall 12646
12605: oPop 1
12607: oJumpForward 12645
12609: oInput 41
12611: oGetAddrLocal 12
12613: oPushResult
12614: oCall 12137
12616: oPop 1
12618: oError 17
12620: oJumpForward 12645
12622: Choice Lookup Table
          40   12609
          15   12600
          39   12513
          19   12493
          38   12189
           0   12141
12635: oCall 3539
12637: oInput 22
12639: oCall 3539
12641: oCall 4254
12643: oError 17
12645: oReturn
12646: oLocalSpace 11
12648: oGetParam 1
12650: oPushResult
12651: oSetResult 43
12653: oPushResult
12654: oNodeNew
12655: oPop 1
12657: oAssign
12658: oGetAddrLocal 1
12660: oPushResult
12661: oSetResult 0
12663: oAssign
12664: oGetAddrLocal 2
12666: oPushResult
12667: oSetResult 0
12669: oAssign
12670: oGetAddrLocal 3
12672: oPushResult
12673: oSetResult 1
12675: oAssign
12676: oGetAddrLocal 4
12678: oPushResult
12679: oScopeCurrent
12680: oAssign
12681: oSetResult -1
12683: oPushResult
12684: oSetResult 2
12686: oPushResult
12687: oScopeBegin
12688: oPop 2
12690: oInput 0
12692: oGetAddrLocal 5
12694: oPushResult
12695: oSetResult 17
12697: oPushResult
12698: LAST_ID
12699: oPushResult
12700: oCall 14169
12702: oPop 2
12704: oAssign
12705: oGetAddrLocal 6
12707: oPushResult
12708: oSetResult 17
12710: oPushResult
12711: LAST_ID
12712: oPushResult
12713: oCall 14169
12715: oPop 2
12717: oAssign
12718: oGetLocal 5
12720: oPushResult
12721: oSetResult 21
12723: oPushResult
12724: oGetFromParam 1
12726: oPushResult
12727: oNodeSet
12728: oPop 3
12730: oGetLocal 6
12732: oPushResult
12733: oSetResult 21
12735: oPushResult
12736: oGetFromParam 1
12738: oPushResult
12739: oNodeSet
12740: oPop 3
12742: oGetAddrLocal 7
12744: oPushResult
12745: LAST_ID
12746: oPushResult
12747: ID_STRING
12748: oPop 1
12750: oPushResult
12751: oStringAllocLit
12752: oPop 1
12754: oAssign
12755: oGetLocal 5
12757: oPushResult
12758: oSetResult 32
12760: oPushResult
12761: oGetLocal 7
12763: oPushResult
12764: oNodeSetInt
12765: oPop 3
12767: oGetLocal 6
12769: oPushResult
12770: oSetResult 32
12772: oPushResult
12773: oGetLocal 7
12775: oPushResult
12776: oNodeSetInt
12777: oPop 3
12779: oInputChoice 12857
12781: oGetGlobal 6
12783: oPushResult
12784: oTypeSPush
12785: oPop 1
12787: oCall 3539
12789: oCall 4351
12791: oTypeSPop
12792: oGetLocal 2
12794: oPushResult
12795: equal_zero
12796: oPop 1
12798: oChoice 12819
12800: oValueTop
12801: oPushResult
12802: oGetLocal 1
12804: oPushResult
12805: greater
12806: oPop 2
12808: oChoice 12814
12810: oError 27
12812: oJumpForward 12817
12814: Choice Lookup Table
           0   12810
12817: oJumpForward 12822
12819: Choice Lookup Table
           0   12800
12822: oGetLocal 1
12824: oPushResult
12825: oValueTop
12826: oPushResult
12827: equal
12828: oPop 2
12830: oChoice 12846
12832: oGetFromParam 1
12834: oPushResult
12835: oSetResult 44
12837: oPushResult
12838: oSetResult 1
12840: oPushResult
12841: oNodeSetBoolean
12842: oPop 3
12844: oJumpForward 12849
12846: Choice Lookup Table
           0   12832
12849: oGetAddrLocal 1
12851: oPushResult
12852: oValueTop
12853: oAssign
12854: oValuePop
12855: oJumpForward 12862
12857: Choice Lookup Table
           5   12781
           7   12781
12862: oGetLocal 5
12864: oPushResult
12865: oSetResult 22
12867: oPushResult
12868: oGetLocal 1
12870: oPushResult
12871: oNodeSetInt
12872: oPop 3
12874: oGetLocal 6
12876: oPushResult
12877: oSetResult 22
12879: oPushResult
12880: oGetLocal 1
12882: oPushResult
12883: oNodeSetInt
12884: oPop 3
12886: oGetLocal 5
12888: oPushResult
12889: oScopeDeclare
12890: oPop 1
12892: oGetLocal 4
12894: oPushResult
12895: oScopeEnter
12896: oPop 1
12898: oGetLocal 6
12900: oPushResult
12901: oScopeDeclare
12902: oPop 1
12904: oScopeEnd
12905: oGetAddrLocal 1
12907: oPushResult
12908: inc
12909: oPop 1
12911: oGetAddrLocal 2
12913: oPushResult
12914: inc
12915: oPop 1
12917: oInputChoice 12921
12919: oJumpForward 12926
12921: Choice Lookup Table
          14   12919
12924: oJumpForward 12928
12926: oJumpBack 12690
12928: oInput 16
12930: oGetFromParam 1
12932: oPushResult
12933: oSetResult 41
12935: oPushResult
12936: oScopeCurrent
12937: oPushResult
12938: oNodeSet
12939: oPop 3
12941: oGetFromParam 1
12943: oPushResult
12944: oSetResult 17
12946: oPushResult
12947: oSetResult 4
12949: oPushResult
12950: oNodeSetInt
12951: oPop 3
12953: oScopeEnd
12954: oGetGlobal 2
12956: oPushResult
12957: oCall 14067
12959: oPop 1
12961: oPushResult
12962: oCodePush
12963: oPop 1
12965: oGetGlobal 2
12967: oPushResult
12968: oScopeEnter
12969: oPop 1
12971: oGetAddrLocal 8
12973: oPushResult
12974: oGetLocal 2
12976: oPushResult
12977: oSetResult 1
12979: oPushResult
12980: add
12981: oPop 2
12983: oPushResult
12984: oSetResult 16
12986: oPushResult
12987: multiply
12988: oPop 2
12990: oAssign
12991: oGetAddrLocal 9
12993: oPushResult
12994: oGetLocal 8
12996: oPushResult
12997: oSetResult 8
12999: oPushResult
13000: oScopeAlloc
13001: oPop 2
13003: oAssign
13004: oScopeEnd
13005: oGetFromParam 1
13007: oPushResult
13008: oSetResult 43
13010: oPushResult
13011: oGetLocal 9
13013: oPushResult
13014: oNodeSetInt
13015: oPop 3
13017: oGetAddrLocal 10
13019: oPushResult
13020: oGetFromParam 1
13022: oPushResult
13023: oSetResult 41
13025: oPushResult
13026: oNodeGet
13027: oPop 2
13029: oPushResult
13030: oSetResult 15
13032: oPushResult
13033: oNodeGetIter
13034: oPop 2
13036: oAssign
13037: oGetAddrLocal 11
13039: oPushResult
13040: oGetLocal 10
13042: oPushResult
13043: oNodeIterValue
13044: oPop 1
13046: oAssign
13047: oGetLocal 11
13049: oPushResult
13050: oNodeNull
13051: oPop 1
13053: oChoice 13059
13055: oJumpForward 13146
13057: oJumpForward 13062
13059: Choice Lookup Table
           1   13055
13062: oEmit 17
13064: oGetLocal 9
13066: oPushResult
13067: oEmitInt
13068: oPop 1
13070: oEmit 15
13072: oGetLocal 11
13074: oPushResult
13075: oSetResult 22
13077: oPushResult
13078: oNodeGetInt
13079: oPop 2
13081: oPushResult
13082: oEmitInt
13083: oPop 1
13085: oEmit 27
13087: oGetAddrLocal 9
13089: oPushResult
13090: oGetLocal 9
13092: oPushResult
13093: oSetResult 8
13095: oPushResult
13096: add
13097: oPop 2
13099: oAssign
13100: oEmit 17
13102: oGetLocal 9
13104: oPushResult
13105: oEmitInt
13106: oPop 1
13108: oEmit 17
13110: oGetLocal 11
13112: oPushResult
13113: oSetResult 32
13115: oPushResult
13116: oNodeGetInt
13117: oPop 2
13119: oPushResult
13120: oEmitInt
13121: oPop 1
13123: oEmit 29
13125: oGetAddrLocal 9
13127: oPushResult
13128: oGetLocal 9
13130: oPushResult
13131: oSetResult 8
13133: oPushResult
13134: add
13135: oPop 2
13137: oAssign
13138: oGetAddrLocal 10
13140: oPushResult
13141: oNodeIterNext
13142: oPop 1
13144: oJumpBack 13037
13146: oEmit 17
13148: oGetLocal 9
13150: oPushResult
13151: oEmitInt
13152: oPop 1
13154: oEmit 15
13156: oSetResult 0
13158: oPushResult
13159: oEmitInt
13160: oPop 1
13162: oEmit 27
13164: oGetAddrLocal 9
13166: oPushResult
13167: oGetLocal 9
13169: oPushResult
13170: oSetResult 8
13172: oPushResult
13173: add
13174: oPop 2
13176: oAssign
13177: oEmit 17
13179: oGetLocal 9
13181: oPushResult
13182: oEmitInt
13183: oPop 1
13185: oEmit 15
13187: oSetResult 0
13189: oPushResult
13190: oEmitInt
13191: oPop 1
13193: oEmit 29
13195: oGetAddrLocal 9
13197: oPushResult
13198: oGetLocal 9
13200: oPushResult
13201: oSetResult 8
13203: oPushResult
13204: add
13205: oPop 2
13207: oAssign
13208: oCodePop
13209: oGetFromParam 1
13211: oPushResult
13212: oTypeAdd
13213: oPop 1
13215: oReturn
13216: oLocalSpace 1
13218: oGetAddrLocal 1
13220: oPushResult
13221: oGetParam 1
13223: oPushResult
13224: oSetResult 36
13226: oPushResult
13227: oNodeGet
13228: oPop 2
13230: oAssign
13231: oGetLocal 1
13233: oPushResult
13234: oNodeNull
13235: oPop 1
13237: oChoice 13293
13239: oGetAddrLocal 1
13241: oPushResult
13242: oSetResult 36
13244: oPushResult
13245: oNodeNew
13246: oPop 1
13248: oAssign
13249: oGetLocal 1
13251: oPushResult
13252: oSetResult 37
13254: oPushResult
13255: oGetParam 1
13257: oPushResult
13258: oNodeSet
13259: oPop 3
13261: oGetLocal 1
13263: oPushResult
13264: oSetResult 17
13266: oPushResult
13267: oSetResult 8
13269: oPushResult
13270: oNodeSetInt
13271: oPop 3
13273: oGetLocal 1
13275: oPushResult
13276: oTypeAdd
13277: oPop 1
13279: oGetParam 1
13281: oPushResult
13282: oSetResult 36
13284: oPushResult
13285: oGetLocal 1
13287: oPushResult
13288: oNodeSet
13289: oPop 3
13291: oJumpForward 13296
13293: Choice Lookup Table
           1   13239
13296: oGetLocal 1
13298: oReturn
13299: oReturn
13300: oLocalSpace 2
13302: oGetParam 1
13304: oPushResult
13305: oNodeType
13306: oPop 1
13308: oChoice 13378
13310: oMININT
13311: oReturn
13312: oJumpForward 13394
13314: oSetResult 0
13316: oReturn
13317: oJumpForward 13394
13319: oSetResult 0
13321: oReturn
13322: oJumpForward 13394
13324: oGetAddrLocal 1
13326: oPushResult
13327: oGetParam 1
13329: oPushResult
13330: oSetResult 41
13332: oPushResult
13333: oNodeGet
13334: oPop 2
13336: oAssign
13337: oGetAddrLocal 2
13339: oPushResult
13340: oGetLocal 1
13342: oPushResult
13343: oSetResult 15
13345: oPushResult
13346: oNodeGetIter
13347: oPop 2
13349: oPushResult
13350: oNodeIterValue
13351: oPop 1
13353: oAssign
13354: oGetLocal 2
13356: oPushResult
13357: oSetResult 22
13359: oPushResult
13360: oNodeGetInt
13361: oPop 2
13363: oReturn
13364: oJumpForward 13394
13366: oGetParam 1
13368: oPushResult
13369: oSetResult 39
13371: oPushResult
13372: oNodeGetInt
13373: oPop 2
13375: oReturn
13376: oJumpForward 13394
13378: Choice Lookup Table
          39   13366
          43   13324
          35   13319
          33   13314
          30   13310
13389: oError 3
13391: oSetResult 0
13393: oReturn
13394: oReturn
13395: oLocalSpace 2
13397: oGetParam 1
13399: oPushResult
13400: oNodeType
13401: oPop 1
13403: oChoice 13473
13405: oMAXINT
13406: oReturn
13407: oJumpForward 13489
13409: oSetResult 1
13411: oReturn
13412: oJumpForward 13489
13414: oSetResult 255
13416: oReturn
13417: oJumpForward 13489
13419: oGetAddrLocal 1
13421: oPushResult
13422: oGetParam 1
13424: oPushResult
13425: oSetResult 41
13427: oPushResult
13428: oNodeGet
13429: oPop 2
13431: oAssign
13432: oGetAddrLocal 2
13434: oPushResult
13435: oGetLocal 1
13437: oPushResult
13438: oSetResult 15
13440: oPushResult
13441: oNodeGetIterLast
13442: oPop 2
13444: oPushResult
13445: oNodeIterValue
13446: oPop 1
13448: oAssign
13449: oGetLocal 2
13451: oPushResult
13452: oSetResult 22
13454: oPushResult
13455: oNodeGetInt
13456: oPop 2
13458: oReturn
13459: oJumpForward 13489
13461: oGetParam 1
13463: oPushResult
13464: oSetResult 40
13466: oPushResult
13467: oNodeGetInt
13468: oPop 2
13470: oReturn
13471: oJumpForward 13489
13473: Choice Lookup Table
          39   13461
          43   13419
          35   13414
          33   13409
          30   13405
13484: oError 3
13486: oSetResult 0
13488: oReturn
13489: oReturn
13490: oLocalSpace 5
13492: oGetAddrGlobal 1
13494: oPushResult
13495: oWorkspaceNew
13496: oAssign
13497: oSetResult 0
13499: oPushResult
13500: oSetResult 0
13502: oPushResult
13503: oScopeBegin
13504: oPop 2
13506: oGetAddrLocal 2
13508: oPushResult
13509: oScopeCurrent
13510: oAssign
13511: oCall 14239
13513: oEmit 78
13515: oSetResult 0
13517: oPushResult
13518: oEmitInt
13519: oPop 1
13521: oGetAddrLocal 3
13523: oPushResult
13524: oLabelNew
13525: oAssign
13526: oEmit 72
13528: oSetResult 0
13530: oPushResult
13531: oEmitInt
13532: oPop 1
13534: oEmit 75
13536: oGetLocal 3
13538: oPushResult
13539: oEmitLabel
13540: oPop 1
13542: oEmit 74
13544: oSetResult 0
13546: oPushResult
13547: oEmitInt
13548: oPop 1
13550: oEmit 77
13552: oInput 29
13554: oInput 0
13556: oGetAddrLocal 4
13558: oPushResult
13559: oSetResult 4
13561: oPushResult
13562: oNodeNew
13563: oPop 1
13565: oAssign
13566: oGetLocal 4
13568: oPushResult
13569: oSetResult 4
13571: oPushResult
13572: LAST_ID
13573: oPushResult
13574: oNodeSetInt
13575: oPop 3
13577: oGetGlobal 1
13579: oPushResult
13580: oSetResult 2
13582: oPushResult
13583: oGetLocal 4
13585: oPushResult
13586: oNodeSet
13587: oPop 3
13589: oInputChoice 13663
13591: oInput 0
13593: oGetAddrLocal 1
13595: oPushResult
13596: oSetResult 20
13598: oPushResult
13599: LAST_ID
13600: oPushResult
13601: oCall 14169
13603: oPop 2
13605: oAssign
13606: oGetLocal 1
13608: oPushResult
13609: oSetResult 21
13611: oPushResult
13612: oGetGlobal 5
13614: oPushResult
13615: oNodeSet
13616: oPop 3
13618: oGetLocal 1
13620: oPushResult
13621: oScopeDeclareAlloc
13622: oPop 1
13624: oInput 14
13626: oInput 0
13628: oGetAddrLocal 1
13630: oPushResult
13631: oSetResult 20
13633: oPushResult
13634: LAST_ID
13635: oPushResult
13636: oCall 14169
13638: oPop 2
13640: oAssign
13641: oGetLocal 1
13643: oPushResult
13644: oSetResult 21
13646: oPushResult
13647: oGetGlobal 5
13649: oPushResult
13650: oNodeSet
13651: oPop 3
13653: oGetLocal 1
13655: oPushResult
13656: oScopeDeclareAlloc
13657: oPop 1
13659: oInput 16
13661: oJumpForward 13666
13663: Choice Lookup Table
          15   13591
13666: oInput 6
13668: oGetLocal 4
13670: oPushResult
13671: oCall 34
13673: oPop 1
13675: oInputChoice 13686
13677: oGetLocal 4
13679: oPushResult
13680: oCall 7
13682: oPop 1
13684: oJumpForward 13689
13686: Choice Lookup Table
          60   13677
13689: oGetLocal 4
13691: oPushResult
13692: oCall 287
13694: oPop 1
13696: oSetResult 0
13698: oPushResult
13699: oSetResult 0
13701: oPushResult
13702: oScopeBegin
13703: oPop 2
13705: oGetAddrGlobal 2
13707: oPushResult
13708: oScopeCurrent
13709: oAssign
13710: oSetResult 0
13712: oPushResult
13713: oSetResult 1
13715: oPushResult
13716: oScopeBegin
13717: oPop 2
13719: oScopeCurrent
13720: oPushResult
13721: oSetResult 16
13723: oPushResult
13724: oGetGlobal 2
13726: oPushResult
13727: oNodeSet
13728: oPop 3
13730: oGetAddrGlobal 3
13732: oPushResult
13733: oScopeCurrent
13734: oAssign
13735: oGetLocal 4
13737: oPushResult
13738: oSetResult 7
13740: oPushResult
13741: oGetGlobal 3
13743: oPushResult
13744: oNodeSet
13745: oPop 3
13747: oScopeEnd
13748: oSetResult 21
13750: oPushResult
13751: oCall 13818
13753: oPop 1
13755: oGetGlobal 3
13757: oPushResult
13758: oScopeEnter
13759: oPop 1
13761: oGetAddrLocal 5
13763: oPushResult
13764: oSetResult 1
13766: oAssign
13767: oGetLocal 3
13769: oPushResult
13770: oGetGlobal 2
13772: oPushResult
13773: oGetLocal 5
13775: oPushResult
13776: oCall 13969
13778: oPop 3
13780: oScopeEnd
13781: oInput 21
13783: oCall 13874
13785: oScopeEnd
13786: oGetLocal 4
13788: oPushResult
13789: oCall 349
13791: oPop 1
13793: oReturn
13794: oLocalSpace 0
13796: oGetParam 2
13798: oPushResult
13799: oCall 13818
13801: oPop 1
13803: oGetParam 1
13805: oPushResult
13806: oScopeCurrent
13807: oPushResult
13808: oSetResult 0
13810: oPushResult
13811: oCall 13969
13813: oPop 3
13815: oCall 13874
13817: oReturn
13818: oLocalSpace 0
13820: oInputChoice 13851
13822: oCall 2520
13824: oJumpForward 13866
13826: oCall 3184
13828: oJumpForward 13866
13830: oGetParam 1
13832: oPushResult
13833: oCall 3240
13835: oPop 1
13837: oJumpForward 13866
13839: oCall 3474
13841: oJumpForward 13866
13843: oCall 1743
13845: oJumpForward 13866
13847: oCall 2178
13849: oJumpForward 13866
13851: Choice Lookup Table
          31   13847
          30   13843
          35   13839
          34   13830
          33   13826
          32   13822
13864: oJumpForward 13868
13866: oJumpBack 13820
13868: oCall 13871
13870: oReturn
13871: oLocalSpace 0
13873: oReturn
13874: oLocalSpace 2
13876: oGetAddrLocal 1
13878: oPushResult
13879: oScopeCurrent
13880: oPushResult
13881: oSetResult 15
13883: oPushResult
13884: oNodeGetIter
13885: oPop 2
13887: oAssign
13888: oGetAddrLocal 2
13890: oPushResult
13891: oGetLocal 1
13893: oPushResult
13894: oNodeIterValue
13895: oPop 1
13897: oAssign
13898: oGetLocal 2
13900: oPushResult
13901: oNodeNull
13902: oPop 1
13904: oChoice 13908
13906: oJumpForward 13913
13908: Choice Lookup Table
           0   13906
13911: oJumpForward 13968
13913: oGetLocal 2
13915: oPushResult
13916: oNodeType
13917: oPop 1
13919: oChoice 13957
13921: oGetLocal 2
13923: oPushResult
13924: oSetResult 35
13926: oPushResult
13927: oNodeGetBoolean
13928: oPop 2
13930: oChoice 13952
13932: oGetLocal 2
13934: oPushResult
13935: oSetResult 28
13937: oPushResult
13938: oNodeGetBoolean
13939: oPop 2
13941: oChoice 13947
13943: oError 28
13945: oJumpForward 13950
13947: Choice Lookup Table
           1   13943
13950: oJumpForward 13955
13952: Choice Lookup Table
           0   13932
13955: oJumpForward 13960
13957: Choice Lookup Table
          26   13921
13960: oGetAddrLocal 1
13962: oPushResult
13963: oNodeIterNext
13964: oPop 1
13966: oJumpBack 13888
13968: oReturn
13969: oLocalSpace 3
13971: oEmit 88
13973: oGetParam 3
13975: oPushResult
13976: oEmitLabel
13977: oPop 1
13979: oEmit 78
13981: oGetAddrLocal 1
13983: oPushResult
13984: Here
13985: oAssign
13986: oEmit 106
13988: oGetParam 1
13990: oChoice 13996
13992: oCall 1220
13994: oJumpForward 13999
13996: Choice Lookup Table
           1   13992
13999: oGetAddrLocal 2
14001: oPushResult
14002: oGetParam 2
14004: oPushResult
14005: oSetResult 19
14007: oPushResult
14008: oNodeGetCode
14009: oPop 2
14011: oAssign
14012: oGetLocal 2
14014: oPushResult
14015: oEmitCode
14016: oPop 1
14018: oGetParam 2
14020: oPushResult
14021: oSetResult 19
14023: oPushResult
14024: oSetResult 0
14026: oPushResult
14027: oNodeSetCode
14028: oPop 3
14030: oCall 8882
14032: oGetParam 1
14034: oChoice 14040
14036: oCall 1305
14038: oJumpForward 14043
14040: Choice Lookup Table
           1   14036
14043: oEmit 77
14045: oGetAddrLocal 3
14047: oPushResult
14048: oScopeCurrent
14049: oPushResult
14050: oSetResult 17
14052: oPushResult
14053: oNodeGetInt
14054: oPop 2
14056: oAssign
14057: oGetLocal 1
14059: oPushResult
14060: oGetLocal 3
14062: oPushResult
14063: oPatch
14064: oPop 2
14066: oReturn
14067: oLocalSpace 1
14069: oGetAddrLocal 1
14071: oPushResult
14072: oGetParam 1
14074: oPushResult
14075: oSetResult 19
14077: oPushResult
14078: oNodeGetCode
14079: oPop 2
14081: oAssign
14082: oGetLocal 1
14084: oPushResult
14085: oSetResult 0
14087: oPushResult
14088: equal_code
14089: oPop 2
14091: oChoice 14112
14093: oGetAddrLocal 1
14095: oPushResult
14096: oCodeNew
14097: oAssign
14098: oGetParam 1
14100: oPushResult
14101: oSetResult 19
14103: oPushResult
14104: oGetLocal 1
14106: oPushResult
14107: oNodeSetCode
14108: oPop 3
14110: oJumpForward 14115
14112: Choice Lookup Table
           1   14093
14115: oGetLocal 1
14117: oReturn
14118: oReturn
14119: oLocalSpace 0
14121: oScopeCurrent
14122: oPushResult
14123: oSetResult 14
14125: oPushResult
14126: oNodeGetInt
14127: oPop 2
14129: oReturn
14130: oReturn
14131: oLocalSpace 0
14133: oGetParam 1
14135: oPushResult
14136: oSetResult 20
14138: oPushResult
14139: oNodeGet
14140: oPop 2
14142: oPushResult
14143: oSetResult 14
14145: oPushResult
14146: oNodeGetInt
14147: oPop 2
14149: oReturn
14150: oReturn
14151: oLocalSpace 0
14153: oCall 14119
14155: oPushResult
14156: oGetParam 1
14158: oPushResult
14159: oCall 14131
14161: oPop 1
14163: oPushResult
14164: subtract
14165: oPop 2
14167: oReturn
14168: oReturn
14169: oLocalSpace 1
14171: oGetAddrLocal 1
14173: oPushResult
14174: oGetParam 2
14176: oPushResult
14177: oNodeNew
14178: oPop 1
14180: oAssign
14181: oGetLocal 1
14183: oPushResult
14184: oSetResult 4
14186: oPushResult
14187: oGetParam 1
14189: oPushResult
14190: oNodeSetInt
14191: oPop 3
14193: oGetLocal 1
14195: oReturn
14196: oReturn
14197: oLocalSpace 0
14199: oGetParam 1
14201: oPushResult
14202: oSetResult 22
14204: oPushResult
14205: oNodeGetInt
14206: oPop 2
14208: oPushResult
14209: oEmitInt
14210: oPop 1
14212: oReturn
14213: oLocalSpace 1
14215: oGetAddrLocal 1
14217: oPushResult
14218: oSetResult 14
14220: oPushResult
14221: oGetParam 1
14223: oPushResult
14224: oCall 14169
14226: oPop 2
14228: oAssign
14229: oGetLocal 1
14231: oPushResult
14232: oScopeDeclare
14233: oPop 1
14235: oGetLocal 1
14237: oReturn
14238: oReturn
14239: oLocalSpace 1
14241: oGetAddrGlobal 25
14243: oPushResult
14244: oSetResult 0
14246: oAssign
14247: oGetAddrGlobal 4
14249: oPushResult
14250: oId_mysystem
14251: oAssign
14252: oGetAddrGlobal 5
14254: oPushResult
14255: oSetResult 28
14257: oPushResult
14258: oSetResult 4
14260: oPushResult
14261: oCall 12103
14263: oPop 2
14265: oAssign
14266: oGetAddrGlobal 6
14268: oPushResult
14269: oSetResult 30
14271: oPushResult
14272: oSetResult 4
14274: oPushResult
14275: oCall 12103
14277: oPop 2
14279: oAssign
14280: oGetAddrGlobal 7
14282: oPushResult
14283: oSetResult 33
14285: oPushResult
14286: oSetResult 1
14288: oPushResult
14289: oCall 12103
14291: oPop 2
14293: oAssign
14294: oGetAddrGlobal 8
14296: oPushResult
14297: oSetResult 34
14299: oPushResult
14300: oSetResult 1
14302: oPushResult
14303: oCall 12103
14305: oPop 2
14307: oAssign
14308: oGetAddrGlobal 9
14310: oPushResult
14311: oSetResult 35
14313: oPushResult
14314: oSetResult 1
14316: oPushResult
14317: oCall 12103
14319: oPop 2
14321: oAssign
14322: oGetAddrGlobal 10
14324: oPushResult
14325: oGetGlobal 9
14327: oPushResult
14328: oCall 13216
14330: oPop 1
14332: oAssign
14333: oGetAddrGlobal 11
14335: oPushResult
14336: oSetResult 29
14338: oPushResult
14339: oSetResult 1
14341: oPushResult
14342: oCall 12103
14344: oPop 2
14346: oAssign
14347: oGetAddrGlobal 12
14349: oPushResult
14350: oSetResult 31
14352: oPushResult
14353: oSetResult 4
14355: oPushResult
14356: oCall 12103
14358: oPop 2
14360: oAssign
14361: oGetAddrGlobal 13
14363: oPushResult
14364: oSetResult 32
14366: oPushResult
14367: oSetResult 8
14369: oPushResult
14370: oCall 12103
14372: oPop 2
14374: oAssign
14375: oGetAddrGlobal 14
14377: oPushResult
14378: oSetResult 37
14380: oPushResult
14381: oSetResult 8
14383: oPushResult
14384: oCall 12103
14386: oPop 2
14388: oAssign
14389: oGetGlobal 14
14391: oPushResult
14392: oSetResult 37
14394: oPushResult
14395: oGetGlobal 11
14397: oPushResult
14398: oNodeSet
14399: oPop 3
14401: oGetAddrGlobal 15
14403: oPushResult
14404: oSetResult 41
14406: oPushResult
14407: oSetResult 256
14409: oPushResult
14410: oCall 12103
14412: oPop 2
14414: oAssign
14415: oGetAddrGlobal 16
14417: oPushResult
14418: oSetResult 42
14420: oPushResult
14421: oSetResult 256
14423: oPushResult
14424: oCall 12103
14426: oPop 2
14428: oAssign
14429: oGetGlobal 16
14431: oPushResult
14432: oSetResult 42
14434: oPushResult
14435: oSetResult 255
14437: oPushResult
14438: oNodeSetInt
14439: oPop 3
14441: oGetAddrLocal 1
14443: oPushResult
14444: oSetResult 19
14446: oPushResult
14447: oId_File
14448: oPushResult
14449: oCall 14169
14451: oPop 2
14453: oAssign
14454: oGetLocal 1
14456: oPushResult
14457: oSetResult 21
14459: oPushResult
14460: oGetGlobal 5
14462: oPushResult
14463: oNodeSet
14464: oPop 3
14466: oGetLocal 1
14468: oPushResult
14469: oScopeDeclare
14470: oPop 1
14472: oGetAddrLocal 1
14474: oPushResult
14475: oSetResult 19
14477: oPushResult
14478: oId_Integer
14479: oPushResult
14480: oCall 14169
14482: oPop 2
14484: oAssign
14485: oGetLocal 1
14487: oPushResult
14488: oSetResult 21
14490: oPushResult
14491: oGetGlobal 6
14493: oPushResult
14494: oNodeSet
14495: oPop 3
14497: oGetLocal 1
14499: oPushResult
14500: oScopeDeclare
14501: oPop 1
14503: oGetAddrLocal 1
14505: oPushResult
14506: oSetResult 19
14508: oPushResult
14509: oId_Boolean
14510: oPushResult
14511: oCall 14169
14513: oPop 2
14515: oAssign
14516: oGetLocal 1
14518: oPushResult
14519: oSetResult 21
14521: oPushResult
14522: oGetGlobal 7
14524: oPushResult
14525: oNodeSet
14526: oPop 3
14528: oGetLocal 1
14530: oPushResult
14531: oScopeDeclare
14532: oPop 1
14534: oGetAddrLocal 1
14536: oPushResult
14537: oSetResult 19
14539: oPushResult
14540: oId_Char
14541: oPushResult
14542: oCall 14169
14544: oPop 2
14546: oAssign
14547: oGetLocal 1
14549: oPushResult
14550: oSetResult 21
14552: oPushResult
14553: oGetGlobal 9
14555: oPushResult
14556: oNodeSet
14557: oPop 3
14559: oGetLocal 1
14561: oPushResult
14562: oScopeDeclare
14563: oPop 1
14565: oGetAddrLocal 1
14567: oPushResult
14568: oSetResult 19
14570: oPushResult
14571: oId_Byte
14572: oPushResult
14573: oCall 14169
14575: oPop 2
14577: oAssign
14578: oGetLocal 1
14580: oPushResult
14581: oSetResult 21
14583: oPushResult
14584: oGetGlobal 11
14586: oPushResult
14587: oNodeSet
14588: oPop 3
14590: oGetLocal 1
14592: oPushResult
14593: oScopeDeclare
14594: oPop 1
14596: oGetAddrLocal 1
14598: oPushResult
14599: oSetResult 19
14601: oPushResult
14602: oId_Single
14603: oPushResult
14604: oCall 14169
14606: oPop 2
14608: oAssign
14609: oGetLocal 1
14611: oPushResult
14612: oSetResult 21
14614: oPushResult
14615: oGetGlobal 12
14617: oPushResult
14618: oNodeSet
14619: oPop 3
14621: oGetLocal 1
14623: oPushResult
14624: oScopeDeclare
14625: oPop 1
14627: oGetAddrLocal 1
14629: oPushResult
14630: oSetResult 19
14632: oPushResult
14633: oId_Double
14634: oPushResult
14635: oCall 14169
14637: oPop 2
14639: oAssign
14640: oGetLocal 1
14642: oPushResult
14643: oSetResult 21
14645: oPushResult
14646: oGetGlobal 13
14648: oPushResult
14649: oNodeSet
14650: oPop 3
14652: oGetLocal 1
14654: oPushResult
14655: oScopeDeclare
14656: oPop 1
14658: oGetAddrLocal 1
14660: oPushResult
14661: oSetResult 19
14663: oPushResult
14664: oId_Pointer
14665: oPushResult
14666: oCall 14169
14668: oPop 2
14670: oAssign
14671: oGetLocal 1
14673: oPushResult
14674: oSetResult 21
14676: oPushResult
14677: oGetGlobal 14
14679: oPushResult
14680: oNodeSet
14681: oPop 3
14683: oGetLocal 1
14685: oPushResult
14686: oScopeDeclare
14687: oPop 1
14689: oGetAddrLocal 1
14691: oPushResult
14692: oSetResult 19
14694: oPushResult
14695: oId_ShortString
14696: oPushResult
14697: oCall 14169
14699: oPop 2
14701: oAssign
14702: oGetLocal 1
14704: oPushResult
14705: oSetResult 21
14707: oPushResult
14708: oGetGlobal 16
14710: oPushResult
14711: oNodeSet
14712: oPop 3
14714: oGetLocal 1
14716: oPushResult
14717: oScopeDeclare
14718: oPop 1
14720: oGetAddrLocal 1
14722: oPushResult
14723: oSetResult 16
14725: oPushResult
14726: oId_True
14727: oPushResult
14728: oCall 14169
14730: oPop 2
14732: oAssign
14733: oGetLocal 1
14735: oPushResult
14736: oSetResult 21
14738: oPushResult
14739: oGetGlobal 7
14741: oPushResult
14742: oNodeSet
14743: oPop 3
14745: oGetLocal 1
14747: oPushResult
14748: oSetResult 22
14750: oPushResult
14751: oSetResult 1
14753: oPushResult
14754: oNodeSetInt
14755: oPop 3
14757: oGetLocal 1
14759: oPushResult
14760: oScopeDeclare
14761: oPop 1
14763: oGetAddrLocal 1
14765: oPushResult
14766: oSetResult 16
14768: oPushResult
14769: oId_False
14770: oPushResult
14771: oCall 14169
14773: oPop 2
14775: oAssign
14776: oGetLocal 1
14778: oPushResult
14779: oSetResult 21
14781: oPushResult
14782: oGetGlobal 7
14784: oPushResult
14785: oNodeSet
14786: oPop 3
14788: oGetLocal 1
14790: oPushResult
14791: oSetResult 22
14793: oPushResult
14794: oSetResult 0
14796: oPushResult
14797: oNodeSetInt
14798: oPop 3
14800: oGetLocal 1
14802: oPushResult
14803: oScopeDeclare
14804: oPop 1
14806: oGetAddrLocal 1
14808: oPushResult
14809: oSetResult 16
14811: oPushResult
14812: oId_Nil
14813: oPushResult
14814: oCall 14169
14816: oPop 2
14818: oAssign
14819: oGetLocal 1
14821: oPushResult
14822: oSetResult 21
14824: oPushResult
14825: oGetGlobal 14
14827: oPushResult
14828: oNodeSet
14829: oPop 3
14831: oGetLocal 1
14833: oPushResult
14834: oSetResult 22
14836: oPushResult
14837: oSetResult 0
14839: oPushResult
14840: oNodeSetInt
14841: oPop 3
14843: oGetLocal 1
14845: oPushResult
14846: oScopeDeclare
14847: oPop 1
14849: oGetAddrGlobal 17
14851: oPushResult
14852: oId_Ord
14853: oPushResult
14854: oCall 14213
14856: oPop 1
14858: oAssign
14859: oGetAddrGlobal 18
14861: oPushResult
14862: oId_Chr
14863: oPushResult
14864: oCall 14213
14866: oPop 1
14868: oAssign
14869: oGetAddrGlobal 19
14871: oPushResult
14872: oId_Pred
14873: oPushResult
14874: oCall 14213
14876: oPop 1
14878: oAssign
14879: oGetAddrGlobal 20
14881: oPushResult
14882: oId_Succ
14883: oPushResult
14884: oCall 14213
14886: oPop 1
14888: oAssign
14889: oGetAddrGlobal 21
14891: oPushResult
14892: oId_Sizeof
14893: oPushResult
14894: oCall 14213
14896: oPop 1
14898: oAssign
14899: oReturn
