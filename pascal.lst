   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin( 0 )
  10:    globalScope = oScopeCurrent
      
  15:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  17:    .tEnter  oEmitInt( 0 )
  25:    Label mainLabel = oLabelNew
      
  30:    .tAllocActuals  oEmitInt( 0 )
  38:    .tCall  oEmitLabel( mainLabel )
  46:    .tFreeActuals  oEmitInt( 0 )
  54:    .tReturn
      
  56:    pProgram
  58:    pIdent
      
  60:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  76:    oScopeDeclare( progDecl )
      
  82:    [
  82:       | '(' :
  84:          pIdent      % input, output files
      
  86:          t = @newIdent( nVar, kVar, LAST_ID )
 102:          oNodeSet( t, qType, FileType )
 114:          oScopeDeclareAlloc( t )
      
 120:          ','
 122:          pIdent
      
 124:          t = @newIdent( nVar, kVar, LAST_ID )
 140:          oNodeSet( t, qType, FileType )
 152:          oScopeDeclareAlloc( t )
      
 158:          ')'
 160:       | * :
 165:    ]
 165:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 167:    oScopeBegin( 0 )
 173:    mainRoutineScope = oScopeCurrent
 178:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 189:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
 200:    oScopeEnd
      
 201:    @BlockDecls( nGlobalVar )
      
      
 208:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 214:    @BlockStmt( mainLabel, globalScope )
      
 224:    oScopeEnd   % main routine scope
      
 225:    '.'
 227:    oScopeEnd   % global scope
 229:    ;
      
      
 229: Block( node_type varNodeType, Label labelForBody ):
 231:    @BlockDecls( varNodeType )
 238:    @BlockStmt( labelForBody, oScopeCurrent )
 248:    ;
      
      
 248: BlockDecls( node_type varNodeType ):
 250:    {[
 250:       | pConst :     @ConstDecl
 254:       | pType :      @TypeDecl
 258:       | pVar :       @VarDecl( varNodeType )
 267:       | pProcedure : @ProcDecl
 271:       | pFunction :  @FuncDecl
 275:       | * :          >
 290:    ]}
 292:    @CheckForUndefinedMethods
 295:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 295: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 298:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 298: BlockStmt( Label labelForBody, Node varScope ):
 300:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 308:    int patchLS
 308:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 317:    Code initCode = oNodeGetCode( varScope, qInitCode )
 330:    oEmitCode( initCode )
 336:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 347:    @Statement
 349:    .tReturn
      
 351:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 363:    oPatch( patchLS, localSpace )
 373:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 373: MethodModifiers( Node decl ):
 375:    {[
 375:       | pCdecl :
 377:          oNodeSetBoolean( decl, qCdecl, true )
 389:          ';'
      
 391:       | * : >
 398:    ]}
 401:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 401: GetOrCreateInitCode >> Code:
 403:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 415:    [ equal_code( initCode, codeNull )
 425:       | true :
 426:          initCode = oCodeNew
 431:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 442:       | * :
 447:    ]
 447:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 451: ExternalDecl( Node decl ):
 453:    oNodeSetBoolean( decl, qExternal, true )
 465:    [
 465:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 467:          [
 467:             | pName :
 469:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 471:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 482:             | * :
 487:          ]
 487:       | * :
 492:    ]
 493:    ;
      
      
 493: ProcDecl:
 495:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 497:    boolean redeclaring = false
 503:    Node decl = oScopeFindInCurrentScope
      
 508:    [ oNodeNull( decl )
 515:       | true :
               % first declaration
 516:          decl = @newIdent( nProc, kProc, LAST_ID )
 532:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 543:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 545:          redeclaring = true
 551:          [ oNodeGetBoolean( decl, qBodyDefined )
 561:             | true : #eAlreadyDefined
 564:             | * :
 569:          ]
 569:          [ oNodeGetBoolean( decl, qExternal )
 579:             | true : #eAlreadyDefined
 582:             | * :
 587:          ]
 587:          [ oNodeType( decl )
 594:             | nProc :
 595:             | * : #eAlreadyDefined   % wrong kind
 602:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 602:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 621:          oNodeSet( decl, qParams, Null )
 633:    ]
      
 641:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 653:    inc( level )
 659:    oScopeBegin( level )
 665:    Node paramScope = oScopeCurrent
      
 670:    @FormalArgDecl
 672:    oNodeSet( decl, qParams, paramScope )
 684:    oScopeEnd
 685:    ';'
      
 687:    [ redeclaring
 690:       | false : oScopeDeclare( decl )
 697:       | true :  % TO DO: check that qParams is consistent with qOldParams
 699:    ]
      
 707:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 714:    [
 714:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 716:       | pExternal : @ExternalDecl( decl )
      
 725:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 732:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 738:          oScopeBegin( level )
 744:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 755:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 766:          Label label = oNodeGetLabel( decl, qValue )
 779:          @Block( nLocalVar, label )
 789:          oNodeSetBoolean( decl, qBodyDefined, true )
 801:          oScopeEnd
      
 802:          oScopeEnd  % paramScope
 803:    ]
 803:    ';';
      
      
 806: FuncDecl:
 808:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 810:    boolean redeclaring = false
 816:    Node decl = oScopeFindInCurrentScope
      
 821:    [ oNodeNull( decl )
 828:       | true :
               % first declaration
 829:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 845:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 856:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 858:          redeclaring = true
 864:          [ oNodeGetBoolean( decl, qBodyDefined )
 874:             | true : #eAlreadyDefined
 877:             | * :
 882:          ]
 882:          [ oNodeType( decl )
 889:             | nFunc :
 890:             | * : #eAlreadyDefined   % wrong kind
 897:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 897:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 916:          oNodeSet( decl, qParams, Null )
 928:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 947:          oNodeSet( decl, qType, Null )
 959:    ]
      
 967:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 979:    inc( level )
 985:    oScopeBegin( level )
 991:    Node paramScope = oScopeCurrent
      
 996:    @FormalArgDecl
 998:    oNodeSet( decl, qParams, paramScope )
      
1010:    ':'
      
1012:    Node theType
1012:    @TypeRef( theType )
1019:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1031:    Node ptrType = @PointerTypeTo( theType )
1042:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1058:    oScopeEnd
1059:    ';'
      
1061:    [ redeclaring
1064:       | false : oScopeDeclare( decl )
1071:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1073:    ]
      
1081:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1088:    [
1088:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1090:       | pExternal : @ExternalDecl( decl )
      
1099:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1106:          oScopeEnter( paramScope )
      
1112:          oScopeBegin( level )
1118:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1129:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1140:          Label label = oNodeGetLabel( decl, qValue )
1153:          @Block( nLocalVar, label )
1163:          oNodeSetBoolean( decl, qBodyDefined, true )
1175:          oScopeEnd
      
1176:          oScopeEnd  % paramScope
1177:    ]
1177:    ';';
      
      
1180: FormalArgDecl:
1182:    [
1182:       | '(' :
1184:          {
1184:             NodeVec decls = oNodeVecNew
1189:             Node decl
1189:             boolean isInOut = false
      
1195:             [
1195:                | pVar : isInOut = true
1203:                | * :
1208:             ]
      
1208:             {  pIdent
      
1210:                decl = @newIdent( nParam, kVar, LAST_ID )
1226:                oNodeSetBoolean( decl, qInOut, isInOut )
1238:                oNodeVecAppend( decls, decl )
      
1247:                [
1247:                   | ':' : >
1251:                   | ',' :
1253:                ]
1261:             }
      
1263:             Node theType
1263:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1270:             Node allocType
1270:             [ isInOut
1273:                | true :   allocType = @PointerTypeTo( theType )
1285:                | * :      allocType = theType
1296:             ]
      
1296:             int i = 0
1302:             {[ equal( i, oNodeVecSize( decls ) )
1316:                | false :
1317:                   decl = oNodeVecElement( decls, i )
      
1330:                   oNodeSet( decl, qType, theType )
1342:                   oScopeDeclare( decl )
1348:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1364:                   inc( i )
1370:                | * :
1375:                   >
1377:             ]}
      
1379:             oNodeVecDelete( decls )
      
1385:             [
1385:                | ')' : >
1389:                | ';' :
1391:             ]
1399:          }
1401:       | * :
1406:    ];
      
1407: ConstDecl:
1409:    {[
1409:       | pIdent :
1411:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1427:          '='
      
1429:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1431:          int val = oValueTop
1436:          oValuePop
1437:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1449:          oNodeSet( decl, qType, IntegerType )
      
1461:          oScopeDeclare( decl )
1467:          ';'
1469:       | * :
1474:          >
1476:    ]};
      
1479: TypeDecl:
1481:    {[
1481:       | pIdent :
1483:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1499:          '='
1501:          Node theType
1501:          @TypeRef( theType )
1508:          oNodeSet( decl, qType, theType )
1520:          oScopeDeclare( decl )
1526:          ';'
1528:       | * :
1533:          >
1535:    ]};
      
1538: VarDecl( node_type varNodeType ):
1540:    {[
1540:       | pIdent :
1542:          NodeVec decls = oNodeVecNew
1547:          Node decl
1547:          {
1547:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1563:             oNodeVecAppend( decls, decl )
1572:             [
1572:                | ',' :
1574:                   pIdent
1576:                | * :
1581:                   >
1583:             ]
1583:          }
1585:          ':'
1587:          Node theType
1587:          @TypeRef( theType )
      
1594:          int i = 0
1600:          {[ equal( i, oNodeVecSize( decls ) )
1614:             | false :
1615:                decl = oNodeVecElement( decls, i )
1628:                oNodeSet( decl, qType, theType )
1640:                oScopeDeclareAlloc( decl )
1646:                inc( i )
1652:             | * :
1657:               >
1659:          ]}
      
               % optional initialization
1661:          [
1661:             | '=' :
1663:                [ oNodeVecSize( decls )
1670:                   | 1 :
1671:                   | * :  #eOnlyOneVarCanBeInitialized
1678:                ]
      
                     % we need an initCode stream for this scope
1678:                Code initCode = @GetOrCreateInitCode
1684:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1690:                boolean changedScope = false
1696:                [ equal_node( oScopeCurrent, globalScope )
1705:                   | true : oScopeEnter( mainRoutineScope )
1712:                            changedScope = true
1718:                   | * :
1723:                ]
                     % generate assignment in initCode stream
1723:                @LValueVar( decl )
1730:                @Expr
1732:                @MatchTypes
1734:                @Assign
1736:                [ changedScope
1739:                   | true : oScopeEnd
1741:                   | * :
1746:                ]
1746:                oCodePop
                   
1747:             | * :
1752:          ]
      
1752:          oNodeVecDelete( decls )
1758:          ';'
1760:       | * :
1765:          >
1767:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1770: TypeRef( out Node resultType ):
1772:    [
1772:       | pIdent :           % previously named type (including intrinsics)
1774:          Node decl = oScopeFindRequire
1779:          [ oNodeType( decl )
1786:            | nTypeDecl :
1787:                resultType = oNodeGet( decl, qType )
1800:            | * :
1805:                #eNotType
1807:                resultType = IntegerType
1813:          ]
         
1813:       | pArray :
1815:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1817:          NodeVec dimensions = oNodeVecNew
      
1822:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1822:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1832:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1844:             @ConstExpr
1846:             oNodeSetInt( subrange, qLow, oValueTop )
1857:             oValuePop
1858:             '..'
1860:             @ConstExpr
1862:             oNodeSetInt( subrange, qHigh, oValueTop )
1873:             oValuePop
1874:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1886:             oTypeAdd( subrange )
      
1892:             Node a = oNodeNew( nArrayType )
1902:             oNodeSet( a, qIndexType, subrange )
      
1914:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1923:             [
1923:                | ']' : >
1927:                | ',' :
1929:             ]
1937:          }
      
1939:          pOf
1941:          Node baseType
1941:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1948:          int dim = oNodeVecSize( dimensions )
      
1958:          {
1958:              dec(dim)
      
1964:              Node a = oNodeVecElement( dimensions, dim )
      
1977:              oNodeSet( a, qBaseType, baseType )
1989:              Node subrange = oNodeGet( a, qIndexType )
2002:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2029:              inc( width )
2035:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2061:              oTypeAdd( a )
2067:              baseType = a
      
2073:              [ equal_zero(dim)
2080:                  | true:  >
2083:                  | *:
2088:              ]
2088:          }
      
2090:          resultType = oNodeVecElement( dimensions, 0 )
2103:          oNodeVecDelete( dimensions )
      
2109:       | '^' :
2111:          Node theType
2111:          @TypeRef( theType )
2118:          resultType = @PointerTypeTo( theType )
      
2129:       | pRecord :
2131:          resultType = oNodeNew( nRecordType )
2141:          oScopeBegin( -1 )    % level is meaningless here
      
2147:          @VarDecl( nRecordField )
      
2154:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2166:          [ equal_zero( size )
2173:             | true : #eRecordEmpty
2176:             | * :
2181:          ]
      
2181:          pEnd
      
2183:          oNodeSet( resultType, qScope, oScopeCurrent )
2194:          oNodeSetInt( resultType, qSize, size )
2206:          oScopeEnd
2207:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2213:       | pSet :
2215:          pOf
2217:          Node theType
2217:          @TypeRef( theType )
2224:       | * :       % this works for cases except where expr starts with an id
2237:          @ConstExpr '..' @ConstExpr
2243:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2244: ConstExpr:
2246:    [
2246:       | pIntLit :
2248:          oValuePush( TOKEN_VALUE )
2253:       | pIdent :
2255:          Node decl = oScopeFindRequire
2260:          [ oNodeType( decl )
2267:             | nConst :
2268:                oValuePush( oNodeGetInt( decl, qValue ) )
2281:             | * :
2286:                #eNotConst
2288:                oValuePush( 0 )
2294:          ]
2294:       | pMinus :
2296:          @ConstExpr
2298:          oValueNegate
2299:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2310: Expr:
2312:    Label falseLabel = labelNull
      
2318:    @ExprAllowCF( falseLabel )
2325:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2333: BooleanExprControlFlow( out Label falseLabel ):
2335:    @ExprAllowCF( falseLabel )
2342:    [ oTypeSNodeType
2344:       | nBooleanCFType :
2345:       | nBooleanType :
               % convert value to control flow
2347:          falseLabel = oLabelNew
2352:          .tJumpFalse  oEmitLabel( falseLabel )
2360:       | * :
2367:          #eNotBoolean
2369:    ]
2369:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2371: CFToVal( inout Label falseLabel ):
2373:    [ oTypeSNodeType
2375:       | nBooleanCFType :
2376:          Label doneLabel = oLabelNew
2381:          .tPushConstI  oEmitInt( 1 )
2389:          .tJump  oEmitLabel( doneLabel )
2397:          .tLabel  oEmitLabel( falseLabel )
2405:          .tPushConstI  oEmitInt( 0 )
2413:          .tLabel  oEmitLabel( doneLabel )
2421:          oTypeSPop
2422:          oTypeSPush( BooleanType )
2428:          falseLabel = labelNull
2434:       | * :
2439:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2440: ValToCF( out Label falseLabel ):
2442:    [ oTypeSNodeType
2444:       | nBooleanType :
2445:          falseLabel = oLabelNew
2450:          .tJumpFalse  oEmitLabel( falseLabel )
2458:          oTypeSPop
2459:          oTypeSPush( BooleanCFType )
2465:       | * :
2470:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2471: ExprAllowCF( out Label falseLabel ):
2473:    @BoolExprAllowCF( falseLabel )
2480:    {[
2480:       | '=' :
2482:          @CFToVal( falseLabel )
2489:          @BoolExprAllowCF( falseLabel )
2496:          @CFToVal( falseLabel )
2503:          @MatchTypes
2505:          [ oTypeSNodeType
2507:             | nIntegerType, nBooleanType :  .tEqualI
2510:             | nPointerType :                .tEqualP
2514:             | nCharType, nStringType :      #eNotImplemented
2518:             | * :                           #eNotAllowed
2533:          ]
2533:          oTypeSPop
2534:          oTypeSPush( BooleanType )
      
2540:       | '<>' :
2542:          @CFToVal( falseLabel )
2549:          @BoolExprAllowCF( falseLabel )
2556:          @CFToVal( falseLabel )
2563:          @MatchTypes
2565:          [ oTypeSNodeType
2567:             | nIntegerType, nBooleanType :  .tNotEqualI
2570:             | nPointerType :                .tNotEqualP
2574:             | nCharType, nStringType :      #eNotImplemented
2578:             | * :                           #eNotAllowed
2593:          ]
2593:          oTypeSPop
2594:          oTypeSPush( BooleanType )
      
2600:       | '<' :
2602:          @CFToVal( falseLabel )
2609:          @BoolExprAllowCF( falseLabel )
2616:          @CFToVal( falseLabel )
2623:          @MatchTypes
2625:          [ oTypeSNodeType
2627:             | nIntegerType, nBooleanType :  .tLessI
2630:             | nCharType, nStringType :      #eNotImplemented
2634:             | * :                           #eNotAllowed
2647:          ]
2647:          oTypeSPop
2648:          oTypeSPush( BooleanType )
      
2654:       | '>' :
2656:          @CFToVal( falseLabel )
2663:          @BoolExprAllowCF( falseLabel )
2670:          @CFToVal( falseLabel )
2677:          @MatchTypes
2679:          [ oTypeSNodeType
2681:             | nIntegerType, nBooleanType :  .tGreaterI
2684:             | nCharType, nStringType :      #eNotImplemented
2688:             | * :                           #eNotAllowed
2701:          ]
2701:          oTypeSPop
2702:          oTypeSPush( BooleanType )
      
2708:       | '<=' :
2710:          @CFToVal( falseLabel )
2717:          @BoolExprAllowCF( falseLabel )
2724:          @CFToVal( falseLabel )
2731:          @MatchTypes
2733:          [ oTypeSNodeType
2735:             | nIntegerType, nBooleanType :  .tLessEqualI
2738:             | nCharType, nStringType :      #eNotImplemented
2742:             | * :                           #eNotAllowed
2755:          ]
2755:          oTypeSPop
2756:          oTypeSPush( BooleanType )
      
2762:       | '>=' :
2764:          @CFToVal( falseLabel )
2771:          @BoolExprAllowCF( falseLabel )
2778:          @CFToVal( falseLabel )
2785:          @MatchTypes
2787:          [ oTypeSNodeType
2789:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2792:             | nCharType, nStringType :      #eNotImplemented
2796:             | * :                           #eNotAllowed
2809:          ]
2809:          oTypeSPop
2810:          oTypeSPush( BooleanType )
      
2816:       | * :
2831:          >
2833:    ]};
      
      
2836: BoolExprAllowCF( out Label falseLabel ):
2838:    Label trueLabel = labelNull
      
2844:    @BoolTermAllowCF( falseLabel )
2851:    {[
2851:       | pOr :
2853:          [ oTypeSNodeType
2855:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2856:                [ equal_label( trueLabel, labelNull )
2866:                   | true :  trueLabel = oLabelNew
2872:                   | * :
2877:                ]
2877:                .tJump  oEmitLabel( trueLabel )
2885:             | nBooleanType :
2887:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2894:                [ equal_label( trueLabel, labelNull )
2904:                   | true :  trueLabel = oLabelNew
2910:                   | * :
2915:                ]
2915:                .tJump  oEmitLabel( trueLabel )
2923:             | * : #eNotBoolean
2932:          ]
2932:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2933:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2941:          falseLabel = labelNull
2947:          @BoolTermAllowCF( falseLabel )
      
2954:          [ oTypeSNodeType
2956:             | nBooleanCFType :
2957:             | nBooleanType :
2959:                @ValToCF( falseLabel )
2966:             | * : #eNotBoolean
2975:          ]
      
2975:          oTypeSPop
2976:          oTypeSPush( BooleanCFType )
      
2982:       | * :
2987:          >
2989:    ]}
      
         % any short-circuit trues jump here to the end
2991:    [ equal_label( trueLabel, labelNull )
3001:       | false :
3002:          .tLabel  oEmitLabel( trueLabel )
3010:       | * :
3015:    ]
3016:    ;
      
      
3016: BoolTermAllowCF( out Label falseLabel ):
3018:    Label overallFalseLabel = labelNull
      
3024:    @BoolFactorAllowCF( falseLabel )
3031:    {[
3031:       | pAnd :
3033:          [ oTypeSNodeType
3035:             | nBooleanCFType :
3036:             | nBooleanType :
3038:                @ValToCF( falseLabel )
3045:             | * :
3052:                #eNotBoolean
3054:          ]
3054:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3055:          [ equal_label( overallFalseLabel, labelNull )
3065:             | true :
3066:                overallFalseLabel = oLabelNew
3071:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3085:                falseLabel = overallFalseLabel
3091:             | * :
3096:          ]
      
3096:          Label factorFalseLabel = labelNull
3102:          @BoolFactorAllowCF( factorFalseLabel )
      
3109:          [ oTypeSNodeType
3111:             | nBooleanCFType :
3112:             | nBooleanType :
3114:                @ValToCF( factorFalseLabel )
3121:             | * : #eNotBoolean
3130:          ]
3130:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3144:       | * :
3149:          >
3151:    ]};
      
3154: BoolFactorAllowCF( out Label falseLabel ):
3156:    [
3156:       | pNot :
3158:          Label factorFalseLabel = labelNull
      
3164:          @BoolFactorAllowCF( factorFalseLabel )
3171:          [ oTypeSNodeType
3173:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3174:                falseLabel = oLabelNew
3179:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3187:                .tLabel  oEmitLabel( factorFalseLabel )
      
3195:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3197:                .tNot
      
3199:             | * : #eNotBoolean
3208:          ]
      
3208:       | * :
3213:          @ArithExprAllowCF( falseLabel )
3220:    ];
      
3221: ArithExprAllowCF( out Label falseLabel ):
3223:    @TermAllowCF( falseLabel )
3230:    {[
3230:       | pPlus :
3232:          @RequireIntPop
3234:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3241:          @RequireInt
3243:          .tAddI
3245:       | pMinus :
3247:          @RequireIntPop
3249:          @TermAllowCF( falseLabel )
3256:          @RequireInt
3258:          .tSubI
3260:       | * :
3267:          >
3269:    ]};
      
3272: TermAllowCF( out Label falseLabel ):
3274:    @FactorAllowCF( falseLabel )
3281:    {[
3281:       | pTimes :
3283:          @RequireIntPop
3285:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3292:          @RequireInt
3294:          .tMultI
3296:       | pDivide :
3298:          @RequireIntPop
3300:          @FactorAllowCF( falseLabel )
3307:          @RequireInt
3309:          .tDivI
3311:       | * :
3318:          >
3320:    ]};
      
3323: FactorAllowCF( out Label falseLabel ):
3325:    [
3325:       | pPlus :
3327:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3334:          @RequireInt
3336:       | pMinus :
3338:          @PrimaryAllowCF( falseLabel )
3345:          @RequireInt
3347:          .tNegI
3349:       | * :
3356:          @PrimaryAllowCF( falseLabel )
3363:    ];
      
3364: PrimaryAllowCF( out Label falseLabel ):
3366:    [
3366:       | pIntLit :
3368:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3375:          oTypeSPush( IntegerType )
      
3381:       | '(' :
3383:          @ExprAllowCF( falseLabel )
3390:          ')'
      
3392:       | pStrLit :
3394:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3403:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3411:          oTypeSPush( StringType )
      
3417:       | pIdent :
3419:          Node decl = oScopeFindRequire
3424:          Node theType
      
3424:          [ oNodeType( decl )
3431:             | nFunc :
      
3432:                @Call( decl )
      
3439:             | nConst :
3441:                theType = oNodeGet( decl, qType )
3454:                oTypeSPush( theType )
3460:                [ oTypeSNodeType
3462:                   | nIntegerType, nBooleanType :
3463:                      .tPushConstI @EmitValue( decl )
3472:                   | * :
3479:                      #eNotImplemented
3481:                ]
      
3481:             | nGlobalVar, nLocalVar, nParam :
3483:                @VarExpr( decl )
      
3490:             | * :
3503:                #eNotValue
3505:                oTypeSPush( IntegerType )
3511:          ]
      
3511:       | '@' :        % @var -- pointer to var
3513:          pIdent
      
3515:          Node decl = oScopeFindRequire
3520:          Node theType
      
3520:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3527:          theType = oTypeSTop
3532:          oTypeSPop
3533:          Node ptrType = @PointerTypeTo( theType )
3544:          oTypeSPush( ptrType )
      
3550:       | * :
3563:          #eNotValue
3565:          oTypeSPush( IntegerType )
3571:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3572: VarExpr( Node decl ):
3574:    Node theType = oNodeGet( decl, qType )
3587:    oTypeSPush( theType )
3593:    [ oTypeSNodeType
3595:       | nIntegerType :
3596:          [ oNodeType( decl )
3603:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3613:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3624:             | nParam :
3626:                [ oNodeGetBoolean( decl, qInOut )
3636:                   | true :    % VAR param points to the var.  Auto dereference.
3637:                               .tPushParamP @EmitValue( decl )
3646:                               .tFetchI
3648:                   | * :       .tPushParamI @EmitValue( decl )
3662:                ]
3662:          ]
      
3672:       | nBooleanType :
3674:          [ oNodeType( decl )
3681:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3691:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3702:             | nParam :
3704:                [ oNodeGetBoolean( decl, qInOut )
3714:                   | true :    % VAR param points to the var.  Auto derefernce.
3715:                               .tPushParamP @EmitValue( decl )
3724:                               .tFetchB
3726:                   | * :       .tPushParamB @EmitValue( decl )
3740:                ]
3740:          ]
      
3750:       | nCharType, nStringType, nFileType :
3752:          #eNotImplemented
      
3754:       | nPointerType :
3756:          [ oNodeType( decl )
3763:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3773:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3784:             | nParam :
3786:                [ oNodeGetBoolean( decl, qInOut )
3796:                   | true :    % VAR param points to the var.  Auto derefernce.
3797:                               .tPushParamP @EmitValue( decl )
3806:                               .tFetchP
3808:                   | * :       .tPushParamP @EmitValue( decl )
3822:                ]
3822:          ]
3832:          [
3832:             | '^' :             % dereferenced
3834:                oTypeSPop
3835:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3848:                @LValueIndexes
3850:                @FetchVar
3852:             | * :               % just ptr value alone
3857:          ]
      
3857:       | * :
               % compound type
               % first, push addr of start of var
3872:          [ oNodeType( decl )
3879:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3889:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3900:             | nParam :
3902:                [ oNodeGetBoolean( decl, qInOut )
3912:                   | true :    % VAR param points to the var.  Auto derefernce.
3913:                               .tPushParamP @EmitValue( decl )
3922:                   | * :       .tPushAddrParam @EmitValue( decl )
3936:                ]
3936:          ]
               % modify addr for subscripts, field references, etc
3946:          @LValueIndexes
               % get final value
3948:          @FetchVar
3950:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3951: FetchVar:
3953:    [ oTypeSNodeType
3955:       | nIntegerType :   .tFetchI
3958:       | nBooleanType :   .tFetchB
3962:       | nCharType, nStringType, nFileType : #eNotImplemented
3966:       | nPointerType :   .tFetchP
3970:       | * :              % compound type; leave as addr
3985:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3986: LValueIndexes:
3988:    {[
3988:       | '[' :       @ArraySubscripts
3992:       | '.' :       @RecordFieldRef
3996:       | '^' :       @PointerDeref
4000:       | * :         >
4011:    ]};
      
4014: ArraySubscripts:
4016:    [ oTypeSNodeType
4018:       | nArrayType :
4019:       | * :       #eNotArray
4026:    ]
4026:    {
4026:       [ oTypeSNodeType
4028:          | nArrayType :
4029:          | * :    #eTooManySubscripts
4036:       ]
      
            % low subscript of this dimension
4036:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
4053:       Node baseType
4053:       baseType = oNodeGet( oTypeSTop, qBaseType )
4065:       oTypeSPop
4066:       oTypeSPush( baseType )
      
4072:       @Expr
4074:       @RequireIntPop
            % adjust for low subscript
4076:       [ equal_zero( low )
4083:          | false :
4084:             .tPushConstI oEmitInt( low ) .tSubI
4094:          | * :
4099:       ]
      
            % multiply by element size
4099:       int size = oNodeGetInt( baseType, qSize )
4112:       [ equal( size, 1 )
4122:          | false :
4123:             .tPushConstI oEmitInt( size ) .tMultI
4133:          | * :
4138:       ]
      
            % update start address
4138:       .tAddPI
4140:       [
4140:          | ']' :  >
4144:          | ',' :
4146:       ]
4154:    };
      
      
4157: RecordFieldRef:
4159:    [ oTypeSNodeType
4161:       | nRecordType :
4162:       | * :    #eNotRecord
4169:    ]
4169:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4181:    pIdent
4183:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4188:    [ oNodeType( field )
4195:       | nRecordField :
4196:       | * :   #eNotRecordField
4203:    ]
4203:    oScopeEnd
4204:    int offset = oNodeGetInt( field, qValue )
4217:    [ equal_zero( offset )
4224:       | false :
4225:          .tPushConstI oEmitInt( offset ) .tAddPI
4235:       | * :
4240:    ]
      
         % replace the type on the type stack, with the field type
4240:    oTypeSPop
4241:    oTypeSPush( oNodeGet( field, qType ) )
4255:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4255: PointerDeref:
4257:    [ oTypeSNodeType
4259:       | nPointerType :
4260:       | * :       #eNotPointer
4267:    ]
4267:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4269:    Node theType = oTypeSTop
4274:    oTypeSPop
4275:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4289:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4289: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4291:    @MatchTypes
4294:    ;
      
      
      % Called on first use of an extern method
      %
4294: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4296:    int strAddr
4296:    String externalName = oNodeGetString( method, qExternalName )
4309:    [ equal_string( externalName, stringNull )
4319:       | true :
4320:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4341:       | false :
4343:          strAddr = oStringAllocLit( externalName )
4353:    ]
4361:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4377:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4377: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4379:    [ oNodeGetBoolean( method, qExternal )
4389:       | true :
4390:          [ oNodeGetBoolean( method, qCalled )
4400:             | false :
                     % define the extern label on first use
4401:                @DefineExternLabel( method )
4408:             | * :
4413:          ]
4413:      | * :
4418:    ]
4418:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4430:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4443:    Node resultType
4443:    int tempOffset
      
4443:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4460:    [ isFunc
4463:       | true :
4464:          resultType = oNodeGet( method, qType )
4477:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4487:       | * :
4492:    ]
         
      
4492:    Node paramScope = oNodeGet( method, qParams )
4505:    int actualsSize = oNodeGetInt( paramScope, qSize )
4518:    [ cdecl
4521:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4530:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4540:    ]
      
4548:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4561:    Node param = oNodeIterValue( paramIter )
4571:    [
4571:       | '(' :
            
4573:          {
4573:             [ oNodeNull( param )
4580:                | true : >
4583:                | * :
4588:             ]
      
4588:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4601:             .tPushAddrActual oEmitInt( offset )
4609:             oTypeSPush( oNodeGet( param, qType ) )
      
4622:             [ oNodeGetBoolean( param, qInOut )
4632:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4633:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4635:                           @MatchTypes
      
4637:                           .tAssignP
      
4639:                | false :  @Expr
4643:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4645:                           [ oTypeSNodeType
4647:                              | nIntegerType :            .tAssignI
4650:                              | nBooleanType :            .tAssignB
4654:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4658:                              | nPointerType :            .tAssignP
4662:                              | * :
                                       % compound types: copy value into actuals space
4677:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4689:                                  .tCopy  oEmitInt( size )    % multi-word copy
4697:                           ]
4697:             ]
4705:             oTypeSPop
      
4706:             oNodeIterNext( paramIter )
4712:             param = oNodeIterValue( paramIter )
4722:             [ oNodeNull( param )
4729:                | true :  >
4732:                | false :
4734:             ]
      
4742:             ','
4744:          }
      
4746:          ')'
      
4748:       | * :
4753:    ]
      
4753:    [ oNodeNull( param )
4760:       | false :    #eMissingParameter
4763:       | * :
4768:    ]
      
4768:    [ isFunc
4771:       | true :
               % Pass result temp as an additional VAR parameter.
4772:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4787:          .tPushAddrLocal  oEmitInt( tempOffset )
4795:          .tAssignP
4797:       | * :
4802:    ]
      
4802:    [ cdecl
4805:       | true :
4806:          .tCallCdecl  @EmitValue( method )
4815:       | false :
4817:          .tCall   @EmitValue( method )
4826:    ]
      
4834:    [ isFunc
4837:       | true :
               % push return value from temp
4838:          oTypeSPush( resultType )
      
4844:          [ oTypeSNodeType
4846:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4855:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4865:             | nCharType, nStringType, nFileType : #eNotImplemented
4869:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4879:             | * :              % compound type: push address
4894:                                .tPushAddrLocal  oEmitInt( tempOffset )
4902:          ]
4902:       | * :
4907:    ]
         
4907:    .tFreeActuals  oEmitInt( actualsSize )
4916:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4916: Statement:
4918:    [
4918:       | pWriteln :     @WritelnStmt
4922:       | pWrite :       @WriteStmt
4926:       | pReadln :      @ReadlnStmt
4930:       | pRead :        @ReadStmt
4934:       | pIf :          @IfStmt
4938:       | pWhile :       @WhileStmt
4942:       | pFor :         @ForStmt
4946:       | pRepeat :      @RepeatStmt
4950:       | pBreak :       @BreakStmt
4954:       | pContinue :    @ContinueStmt
4958:       | pBegin :       @BeginStmt
4962:       | pIdent :       @AssignOrCallStmt
4966:       | * :            % null statement : don't accept any tokens
4993:    ];
      
      
4994: AssignOrCallStmt:
4996:    Node decl = oScopeFindRequire
5001:    [ oNodeType( decl )
5008:       | nProc :                           @Call( decl )
5016:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
5025:       | nFunc :                           @AssignResultStmt( decl )
5034:       | * :                               #eBadStatement
5049:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
5050: AssignStmt( Node decl ):
      
5052:    @LValueVar( decl )
5059:    ':=' 
5061:    @Expr
5063:    @MatchTypes
5065:    @Assign
5068:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
5068: Assign:
5070:    [ oTypeSNodeType
5072:       | nIntegerType :            .tAssignI
5075:       | nBooleanType :            .tAssignB
5079:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5083:       | nPointerType :            .tAssignP
5087:       | * :
5102:           int size = oNodeGetInt( oTypeSTop, qSize )
5114:           .tCopy  oEmitInt( size )    % multi-word copy
5122:    ]
5122:    oTypeSPop
5124:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5124: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5126:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5142:       | false :   #eNotCurrentFunction
5145:       | * :
5150:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5150:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5165:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5178:    ':='
5180:    @Expr
5182:    @MatchTypes
5184:    [ oTypeSNodeType
5186:       | nIntegerType :            .tAssignI
5189:       | nBooleanType :            .tAssignB
5193:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5197:       | nPointerType :            .tAssignP
5201:       | * :
5216:           int size = oNodeGetInt( oTypeSTop, qSize )
5228:           .tCopy  oEmitInt( size )    % multi-word copy
5236:    ]
5236:    oTypeSPop
5238:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5238: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5240:    pIdent
5242:    Node decl = oScopeFindRequire
5247:    [ oNodeType( decl )
5254:       | nGlobalVar, nLocalVar, nParam :
5255:       | * :  #eNotVar
5266:    ]
5266:    @LValueVar( decl )
5274:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5274: LValueVar( Node decl ):
5276:    [ oNodeType( decl )
5283:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5293:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5304:       | nParam :
5306:          [ oNodeGetBoolean( decl, qInOut )
5316:             | true :   % VAR param points to variable.  No dereference.
5317:                        .tPushParamP @EmitValue( decl )
5326:             | * :      .tPushAddrParam @EmitValue( decl )
5340:          ]
5340:       | * :            #eNotVar
5351:    ]
      
5351:    oTypeSPush( oNodeGet( decl, qType ) )
5364:    @LValueIndexes        % handle subscripts, if any
5367:    ;
      
      
5367: IncVar( Node decl ):
5369:    @LValueVar( decl )
5376:    @RequireIntPop
5378:    @VarExpr( decl )
5385:    oTypeSPop
5386:    .tIncI
5388:    .tAssignI;
      
5391: DecVar( Node decl ):
5393:    @LValueVar( decl )
5400:    @RequireIntPop
5402:    @VarExpr( decl )
5409:    oTypeSPop
5410:    .tDecI
5412:    .tAssignI;
      
      
5415: IfStmt:
5417:    Label falseLabel = labelNull
      
5423:    @BooleanExprControlFlow( falseLabel )
5430:    pThen
5432:    @Statement
5434:    [
5434:       | pElse :
5436:          Label doneLabel = oLabelNew
      
5441:          .tJump  oEmitLabel( doneLabel )
5449:          .tLabel oEmitLabel( falseLabel )
5457:          @Statement
5459:          .tLabel oEmitLabel( doneLabel )
      
5467:       | * :
5472:          .tLabel oEmitLabel( falseLabel )
5480:    ];
      
      
5481: ForStmt:
5483:    pIdent
      
5485:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5490:    @LValueVar( decl )
5497:    @RequireIntPop
      
5499:    ':='
      
5501:    @Expr
5503:    @RequireIntPop
5505:    .tAssignI
      
5507:    Label breakLabel = oLabelNew
      
5512:    Label checkLabel = oLabelNew
5517:    .tJump  oEmitLabel( checkLabel )
      
5525:    Label continueLabel = oLabelNew
5530:    .tLabel  oEmitLabel( continueLabel )
5538:    [
5538:       | pTo :
5540:          @IncVar( decl )
5547:          .tLabel  oEmitLabel( checkLabel )
5555:          @VarExpr( decl )  oTypeSPop
5563:          @Expr
5565:          @RequireIntPop
5567:          .tGreaterI
5569:          .tJumpTrue  oEmitLabel( breakLabel )
5577:       | pDownto :
5579:          @DecVar( decl )
5586:          .tLabel  oEmitLabel( checkLabel )
5594:          @VarExpr( decl )  oTypeSPop
5602:          @Expr
5604:          @RequireIntPop
5606:          .tLessI
5608:          .tJumpTrue  oEmitLabel( breakLabel )
5616:    ]
5624:    oLoopPush( continueLabel, breakLabel )
5633:    pDo
5635:    @Statement
5637:    .tJump  oEmitLabel( continueLabel )
5645:    .tLabel  oEmitLabel( breakLabel )
5653:    oLoopPop;
      
      
5655: RepeatStmt:
5657:    Label continueLabel = oLabelNew
5662:    .tLabel  oEmitLabel( continueLabel )
      
5670:    Label breakLabel = oLabelNew
      
5675:    oLoopPush( continueLabel, breakLabel )
5684:    @Statement
5686:    {[
5686:       | ';' :
5688:          @Statement
5690:       | pUntil :
5692:          Label falseLabel
5692:          @BooleanExprControlFlow( falseLabel )
5699:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5713:          >
5715:    ]}
5725:    .tLabel  oEmitLabel( breakLabel )
5733:    oLoopPop;
      
      
5735: WhileStmt:
5737:    Label continueLabel = oLabelNew
5742:    .tLabel  oEmitLabel( continueLabel )
      
5750:    Label breakLabel
5750:    @BooleanExprControlFlow( breakLabel )
      
5757:    oLoopPush( continueLabel, breakLabel )
5766:    pDo
5768:    @Statement
5770:    .tJump  oEmitLabel( continueLabel )
5778:    .tLabel  oEmitLabel( breakLabel )
5786:    oLoopPop;
      
      
5788: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5790:    [ equal_label( oLoopContinueLabel, labelNull )
5799:       | true :
5800:          #eNotInALoop
5802:       | false :
5804:          .tJump  oEmitLabel( oLoopContinueLabel )
5811:    ];
      
      
5820: BreakStmt:
5822:    [ equal_label( oLoopBreakLabel, labelNull )
5831:       | true :
5832:          #eNotInALoop
5834:       | false :
5836:          .tJump  oEmitLabel( oLoopBreakLabel )
5843:    ];
      
      
5852: BeginStmt:
5854:    @Statement
5856:    {[
5856:       | ';' :   @Statement
5860:       | pEnd :  >
5864:    ]};
      
      
5875: WritelnStmt:
5877:    @WriteStmt
5879:    .tWriteCR;
      
      
5882: WriteStmt:
5884:    [
5884:       | '(' :
5886:          {
5886:             @Expr
5888:             [ oTypeSNodeType
5890:                | nIntegerType :             .tWriteI
5893:                | nBooleanType :             .tWriteBool
5897:                | nStringType :              .tWriteStr
5901:                | nCharType, nFileType :     #eNotImplemented
5905:                | nPointerType :             .tWriteP
5909:                | * :                        #eNotAllowed
5926:             ]
5926:             oTypeSPop
5927:             [
5927:                | ')' : >
5931:                | ',' :
5933:             ]
5941:          }
5943:       | * :
5948:    ];
      
      
5949: ReadlnStmt:      % ***
         % TO DO
5952:    ;
      
5952: ReadStmt:
         % TO DO
5955:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5955: MatchTypes:
5957:    node_type nt = oTypeSNodeType
5962:    oTypeSPop
5963:    [ equal_node_type( nt, oTypeSNodeType )
5972:       | false :
5973:          #eTypeMismatch
5975:       | * :
5980:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5981: RequireIntPop:
5983:    [ oTypeSNodeType
5985:       | nIntegerType :
5986:       | * :          #eNotInteger
5993:    ]
5993:    oTypeSPop;
      
5995: RequireInt:
5997:    [ oTypeSNodeType
5999:       | nIntegerType :
6000:       | * :          #eNotInteger
6007:    ];
      
6008: RequireBoolPop:
6010:    [ oTypeSNodeType
6012:       | nBooleanType :
6013:       | * :          #eNotBoolean
6020:    ]
6020:    oTypeSPop;
      
6022: RequireBool:
6024:    [ oTypeSNodeType
6026:       | nBooleanType :
6027:       | * :          #eNotBoolean
6034:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
6035: newType( node_type nt, int size ) >> Node:
6037:   Node node = oNodeNew( nt )
6047:   oNodeSetInt( node, qSize, size )
6059:   oTypeAdd( node )
6065:   >> node
6069:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
6069: newIdent( node_type nt, kind k, int id ) >> Node:
6071:   Node t = oNodeNew( nt )
6081:   oNodeSetInt( t, qIdent, id )
6093:   >> t
6097:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6097: PointerTypeTo( Node theType ) >> Node:
6099:    Node ptrType = oNodeGet( theType, qPointerType )
6112:    [ oNodeNull( ptrType )
6119:       | true :
6120:          ptrType = oNodeNew( nPointerType )
6130:          oNodeSet( ptrType, qBaseType, theType )
6142:          oNodeSetInt( ptrType, qSize, 8 )
6154:          oTypeAdd( ptrType )
6160:          oNodeSet( theType, qPointerType, ptrType )
6172:       | * :
6177:    ]
6177:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6181: OrdinalLow( Node theType ) >> int:
6183:    [ oNodeType( theType )
6190:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
6193:       | nBooleanType :  >> 0
6198:       | nCharType :     >> 0
6203:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6215:       | * :             #eNotOrdinalType
6228:                         >> 0
6231:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6232: EmitValue( Node decl ):
6234:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6248: installBuiltIns:
      
         % install built-in types
6250:    FileType = @newType( nFileType, 4 )
6264:    IntegerType = @newType( nIntegerType, 4 )
6278:    BooleanType = @newType( nBooleanType, 1 )
6292:    BooleanCFType = @newType( nBooleanCFType, 1 )
6306:    CharType = @newType( nCharType, 1 )
6320:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6334:    Node t
      
6334:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6350:    oNodeSet( t, qType, FileType )
6362:    oScopeDeclare( t )
      
6368:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6384:    oNodeSet( t, qType, IntegerType )
6396:    oScopeDeclare( t )
      
6402:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6418:    oNodeSet( t, qType, BooleanType )
6430:    oScopeDeclare( t )
      
6436:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6452:    oNodeSet( t, qType, CharType )
6464:    oScopeDeclare( t )
      
6470:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6486:    oNodeSet( t, qType, StringType )
6498:    oScopeDeclare( t )
      
         % Built-in constants
      
6504:    t = @newIdent( nConst, kConst, oIdAdd_True )
6520:    oNodeSet( t, qType, BooleanType )
6532:    oNodeSetInt( t, qValue, 1 )
6544:    oScopeDeclare( t )
      
6550:    t = @newIdent( nConst, kConst, oIdAdd_False )
6566:    oNodeSet( t, qType, BooleanType )
6578:    oNodeSetInt( t, qValue, 0 )
6590:    oScopeDeclare( t )
      
6597:    ;
      
6597: end
      
6597: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 3
   4: oSetResult 0
   6: oPushResult
   7: oScopeBegin
   8: oPop 1
  10: oGetAddrGlobal 1
  12: oPushResult
  13: oScopeCurrent
  14: oAssign
  15: oCall 6248
  17: oEmit 44
  19: oSetResult 0
  21: oPushResult
  22: oEmitInt
  23: oPop 1
  25: oGetAddrLocal 2
  27: oPushResult
  28: oLabelNew
  29: oAssign
  30: oEmit 38
  32: oSetResult 0
  34: oPushResult
  35: oEmitInt
  36: oPop 1
  38: oEmit 41
  40: oGetLocal 2
  42: oPushResult
  43: oEmitLabel
  44: oPop 1
  46: oEmit 40
  48: oSetResult 0
  50: oPushResult
  51: oEmitInt
  52: oPop 1
  54: oEmit 43
  56: oInput 27
  58: oInput 0
  60: oGetAddrLocal 3
  62: oPushResult
  63: oSetResult 5
  65: oPushResult
  66: oSetResult 1
  68: oPushResult
  69: LAST_ID
  70: oPushResult
  71: oCall 6069
  73: oPop 3
  75: oAssign
  76: oGetLocal 3
  78: oPushResult
  79: oScopeDeclare
  80: oPop 1
  82: oInputChoice 162
  84: oInput 0
  86: oGetAddrLocal 1
  88: oPushResult
  89: oSetResult 11
  91: oPushResult
  92: oSetResult 6
  94: oPushResult
  95: LAST_ID
  96: oPushResult
  97: oCall 6069
  99: oPop 3
 101: oAssign
 102: oGetLocal 1
 104: oPushResult
 105: oSetResult 7
 107: oPushResult
 108: oGetGlobal 3
 110: oPushResult
 111: oNodeSet
 112: oPop 3
 114: oGetLocal 1
 116: oPushResult
 117: oScopeDeclareAlloc
 118: oPop 1
 120: oInput 12
 122: oInput 0
 124: oGetAddrLocal 1
 126: oPushResult
 127: oSetResult 11
 129: oPushResult
 130: oSetResult 6
 132: oPushResult
 133: LAST_ID
 134: oPushResult
 135: oCall 6069
 137: oPop 3
 139: oAssign
 140: oGetLocal 1
 142: oPushResult
 143: oSetResult 7
 145: oPushResult
 146: oGetGlobal 3
 148: oPushResult
 149: oNodeSet
 150: oPop 3
 152: oGetLocal 1
 154: oPushResult
 155: oScopeDeclareAlloc
 156: oPop 1
 158: oInput 14
 160: oJumpForward 165
 162: Choice Lookup Table
          13     84
 165: oInput 4
 167: oSetResult 0
 169: oPushResult
 170: oScopeBegin
 171: oPop 1
 173: oGetAddrGlobal 2
 175: oPushResult
 176: oScopeCurrent
 177: oAssign
 178: oScopeCurrent
 179: oPushResult
 180: oSetResult 4
 182: oPushResult
 183: oSetResult 1
 185: oPushResult
 186: oNodeSetBoolean
 187: oPop 3
 189: oGetLocal 3
 191: oPushResult
 192: oSetResult 9
 194: oPushResult
 195: oScopeCurrent
 196: oPushResult
 197: oNodeSet
 198: oPop 3
 200: oScopeEnd
 201: oSetResult 12
 203: oPushResult
 204: oCall 248
 206: oPop 1
 208: oGetGlobal 2
 210: oPushResult
 211: oScopeEnter
 212: oPop 1
 214: oGetLocal 2
 216: oPushResult
 217: oGetGlobal 1
 219: oPushResult
 220: oCall 298
 222: oPop 2
 224: oScopeEnd
 225: oInput 19
 227: oScopeEnd
 228: oReturn
 229: oLocalSpace 0
 231: oGetParam 2
 233: oPushResult
 234: oCall 248
 236: oPop 1
 238: oGetParam 1
 240: oPushResult
 241: oScopeCurrent
 242: oPushResult
 243: oCall 298
 245: oPop 2
 247: oReturn
 248: oLocalSpace 0
 250: oInputChoice 277
 252: oCall 1407
 254: oJumpForward 290
 256: oCall 1479
 258: oJumpForward 290
 260: oGetParam 1
 262: oPushResult
 263: oCall 1538
 265: oPop 1
 267: oJumpForward 290
 269: oCall 493
 271: oJumpForward 290
 273: oCall 806
 275: oJumpForward 290
 277: Choice Lookup Table
          29    273
          28    269
          32    260
          31    256
          30    252
 288: oJumpForward 292
 290: oJumpBack 250
 292: oCall 295
 294: oReturn
 295: oLocalSpace 0
 297: oReturn
 298: oLocalSpace 3
 300: oEmit 48
 302: oGetParam 2
 304: oPushResult
 305: oEmitLabel
 306: oPop 1
 308: oEmit 44
 310: oGetAddrLocal 1
 312: oPushResult
 313: Here
 314: oAssign
 315: oEmit 56
 317: oGetAddrLocal 2
 319: oPushResult
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 5
 325: oPushResult
 326: oNodeGetCode
 327: oPop 2
 329: oAssign
 330: oGetLocal 2
 332: oPushResult
 333: oEmitCode
 334: oPop 1
 336: oScopeCurrent
 337: oPushResult
 338: oSetResult 5
 340: oPushResult
 341: oSetResult 0
 343: oPushResult
 344: oNodeSetCode
 345: oPop 3
 347: oCall 4916
 349: oEmit 43
 351: oGetAddrLocal 3
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oSetResult 3
 358: oPushResult
 359: oNodeGetInt
 360: oPop 2
 362: oAssign
 363: oGetLocal 1
 365: oPushResult
 366: oGetLocal 3
 368: oPushResult
 369: oPatch
 370: oPop 2
 372: oReturn
 373: oLocalSpace 0
 375: oInputChoice 393
 377: oGetParam 1
 379: oPushResult
 380: oSetResult 15
 382: oPushResult
 383: oSetResult 1
 385: oPushResult
 386: oNodeSetBoolean
 387: oPop 3
 389: oInput 4
 391: oJumpForward 398
 393: Choice Lookup Table
          61    377
 396: oJumpForward 400
 398: oJumpBack 375
 400: oReturn
 401: oLocalSpace 1
 403: oGetAddrLocal 1
 405: oPushResult
 406: oScopeCurrent
 407: oPushResult
 408: oSetResult 5
 410: oPushResult
 411: oNodeGetCode
 412: oPop 2
 414: oAssign
 415: oGetLocal 1
 417: oPushResult
 418: oSetResult 0
 420: oPushResult
 421: equal_code
 422: oPop 2
 424: oChoice 444
 426: oGetAddrLocal 1
 428: oPushResult
 429: oCodeNew
 430: oAssign
 431: oScopeCurrent
 432: oPushResult
 433: oSetResult 5
 435: oPushResult
 436: oGetLocal 1
 438: oPushResult
 439: oNodeSetCode
 440: oPop 3
 442: oJumpForward 447
 444: Choice Lookup Table
           1    426
 447: oGetLocal 1
 449: oReturn
 450: oReturn
 451: oLocalSpace 0
 453: oGetParam 1
 455: oPushResult
 456: oSetResult 13
 458: oPushResult
 459: oSetResult 1
 461: oPushResult
 462: oNodeSetBoolean
 463: oPop 3
 465: oInputChoice 489
 467: oInputChoice 484
 469: oInput 2
 471: oGetParam 1
 473: oPushResult
 474: oSetResult 14
 476: oPushResult
 477: CURRENT_STRLIT
 478: oPushResult
 479: oNodeSetString
 480: oPop 3
 482: oJumpForward 487
 484: Choice Lookup Table
          60    469
 487: oJumpForward 492
 489: Choice Lookup Table
           2    467
 492: oReturn
 493: oLocalSpace 5
 495: oInput 0
 497: oGetAddrLocal 1
 499: oPushResult
 500: oSetResult 0
 502: oAssign
 503: oGetAddrLocal 2
 505: oPushResult
 506: oScopeFindInCurrentScope
 507: oAssign
 508: oGetLocal 2
 510: oPushResult
 511: oNodeNull
 512: oPop 1
 514: oChoice 635
 516: oGetAddrLocal 2
 518: oPushResult
 519: oSetResult 7
 521: oPushResult
 522: oSetResult 2
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oCall 6069
 529: oPop 3
 531: oAssign
 532: oGetLocal 2
 534: oPushResult
 535: oSetResult 8
 537: oPushResult
 538: oLabelNew
 539: oPushResult
 540: oNodeSetLabel
 541: oPop 3
 543: oJumpForward 641
 545: oGetAddrLocal 1
 547: oPushResult
 548: oSetResult 1
 550: oAssign
 551: oGetLocal 2
 553: oPushResult
 554: oSetResult 12
 556: oPushResult
 557: oNodeGetBoolean
 558: oPop 2
 560: oChoice 566
 562: oError 21
 564: oJumpForward 569
 566: Choice Lookup Table
           1    562
 569: oGetLocal 2
 571: oPushResult
 572: oSetResult 13
 574: oPushResult
 575: oNodeGetBoolean
 576: oPop 2
 578: oChoice 584
 580: oError 21
 582: oJumpForward 587
 584: Choice Lookup Table
           1    580
 587: oGetLocal 2
 589: oPushResult
 590: oNodeType
 591: oPop 1
 593: oChoice 597
 595: oJumpForward 602
 597: Choice Lookup Table
           7    595
 600: oError 21
 602: oGetLocal 2
 604: oPushResult
 605: oSetResult 17
 607: oPushResult
 608: oGetLocal 2
 610: oPushResult
 611: oSetResult 10
 613: oPushResult
 614: oNodeGet
 615: oPop 2
 617: oPushResult
 618: oNodeSet
 619: oPop 3
 621: oGetLocal 2
 623: oPushResult
 624: oSetResult 10
 626: oPushResult
 627: oSetResult 0
 629: oPushResult
 630: oNodeSet
 631: oPop 3
 633: oJumpForward 641
 635: Choice Lookup Table
           0    545
           1    516
 640: oEndChoice
 641: oGetAddrLocal 3
 643: oPushResult
 644: oScopeCurrent
 645: oPushResult
 646: oSetResult 1
 648: oPushResult
 649: oNodeGetInt
 650: oPop 2
 652: oAssign
 653: oGetAddrLocal 3
 655: oPushResult
 656: inc
 657: oPop 1
 659: oGetLocal 3
 661: oPushResult
 662: oScopeBegin
 663: oPop 1
 665: oGetAddrLocal 4
 667: oPushResult
 668: oScopeCurrent
 669: oAssign
 670: oCall 1180
 672: oGetLocal 2
 674: oPushResult
 675: oSetResult 10
 677: oPushResult
 678: oGetLocal 4
 680: oPushResult
 681: oNodeSet
 682: oPop 3
 684: oScopeEnd
 685: oInput 4
 687: oGetLocal 1
 689: oChoice 701
 691: oGetLocal 2
 693: oPushResult
 694: oScopeDeclare
 695: oPop 1
 697: oJumpForward 707
 699: oJumpForward 707
 701: Choice Lookup Table
           1    699
           0    691
 706: oEndChoice
 707: oGetLocal 2
 709: oPushResult
 710: oCall 373
 712: oPop 1
 714: oInputChoice 727
 716: oJumpForward 803
 718: oGetLocal 2
 720: oPushResult
 721: oCall 451
 723: oPop 1
 725: oJumpForward 803
 727: Choice Lookup Table
          59    718
          58    716
 732: oGetLocal 4
 734: oPushResult
 735: oScopeEnter
 736: oPop 1
 738: oGetLocal 3
 740: oPushResult
 741: oScopeBegin
 742: oPop 1
 744: oScopeCurrent
 745: oPushResult
 746: oSetResult 4
 748: oPushResult
 749: oSetResult 1
 751: oPushResult
 752: oNodeSetBoolean
 753: oPop 3
 755: oGetLocal 2
 757: oPushResult
 758: oSetResult 11
 760: oPushResult
 761: oScopeCurrent
 762: oPushResult
 763: oNodeSet
 764: oPop 3
 766: oGetAddrLocal 5
 768: oPushResult
 769: oGetLocal 2
 771: oPushResult
 772: oSetResult 8
 774: oPushResult
 775: oNodeGetLabel
 776: oPop 2
 778: oAssign
 779: oSetResult 13
 781: oPushResult
 782: oGetLocal 5
 784: oPushResult
 785: oCall 229
 787: oPop 2
 789: oGetLocal 2
 791: oPushResult
 792: oSetResult 12
 794: oPushResult
 795: oSetResult 1
 797: oPushResult
 798: oNodeSetBoolean
 799: oPop 3
 801: oScopeEnd
 802: oScopeEnd
 803: oInput 4
 805: oReturn
 806: oLocalSpace 7
 808: oInput 0
 810: oGetAddrLocal 1
 812: oPushResult
 813: oSetResult 0
 815: oAssign
 816: oGetAddrLocal 2
 818: oPushResult
 819: oScopeFindInCurrentScope
 820: oAssign
 821: oGetLocal 2
 823: oPushResult
 824: oNodeNull
 825: oPop 1
 827: oChoice 961
 829: oGetAddrLocal 2
 831: oPushResult
 832: oSetResult 8
 834: oPushResult
 835: oSetResult 3
 837: oPushResult
 838: LAST_ID
 839: oPushResult
 840: oCall 6069
 842: oPop 3
 844: oAssign
 845: oGetLocal 2
 847: oPushResult
 848: oSetResult 8
 850: oPushResult
 851: oLabelNew
 852: oPushResult
 853: oNodeSetLabel
 854: oPop 3
 856: oJumpForward 967
 858: oGetAddrLocal 1
 860: oPushResult
 861: oSetResult 1
 863: oAssign
 864: oGetLocal 2
 866: oPushResult
 867: oSetResult 12
 869: oPushResult
 870: oNodeGetBoolean
 871: oPop 2
 873: oChoice 879
 875: oError 21
 877: oJumpForward 882
 879: Choice Lookup Table
           1    875
 882: oGetLocal 2
 884: oPushResult
 885: oNodeType
 886: oPop 1
 888: oChoice 892
 890: oJumpForward 897
 892: Choice Lookup Table
           8    890
 895: oError 21
 897: oGetLocal 2
 899: oPushResult
 900: oSetResult 17
 902: oPushResult
 903: oGetLocal 2
 905: oPushResult
 906: oSetResult 10
 908: oPushResult
 909: oNodeGet
 910: oPop 2
 912: oPushResult
 913: oNodeSet
 914: oPop 3
 916: oGetLocal 2
 918: oPushResult
 919: oSetResult 10
 921: oPushResult
 922: oSetResult 0
 924: oPushResult
 925: oNodeSet
 926: oPop 3
 928: oGetLocal 2
 930: oPushResult
 931: oSetResult 18
 933: oPushResult
 934: oGetLocal 2
 936: oPushResult
 937: oSetResult 7
 939: oPushResult
 940: oNodeGet
 941: oPop 2
 943: oPushResult
 944: oNodeSet
 945: oPop 3
 947: oGetLocal 2
 949: oPushResult
 950: oSetResult 7
 952: oPushResult
 953: oSetResult 0
 955: oPushResult
 956: oNodeSet
 957: oPop 3
 959: oJumpForward 967
 961: Choice Lookup Table
           0    858
           1    829
 966: oEndChoice
 967: oGetAddrLocal 3
 969: oPushResult
 970: oScopeCurrent
 971: oPushResult
 972: oSetResult 1
 974: oPushResult
 975: oNodeGetInt
 976: oPop 2
 978: oAssign
 979: oGetAddrLocal 3
 981: oPushResult
 982: inc
 983: oPop 1
 985: oGetLocal 3
 987: oPushResult
 988: oScopeBegin
 989: oPop 1
 991: oGetAddrLocal 4
 993: oPushResult
 994: oScopeCurrent
 995: oAssign
 996: oCall 1180
 998: oGetLocal 2
1000: oPushResult
1001: oSetResult 10
1003: oPushResult
1004: oGetLocal 4
1006: oPushResult
1007: oNodeSet
1008: oPop 3
1010: oInput 11
1012: oGetAddrLocal 5
1014: oPushResult
1015: oCall 1770
1017: oPop 1
1019: oGetLocal 2
1021: oPushResult
1022: oSetResult 7
1024: oPushResult
1025: oGetLocal 5
1027: oPushResult
1028: oNodeSet
1029: oPop 3
1031: oGetAddrLocal 6
1033: oPushResult
1034: oGetLocal 5
1036: oPushResult
1037: oCall 6097
1039: oPop 1
1041: oAssign
1042: oGetLocal 2
1044: oPushResult
1045: oSetResult 19
1047: oPushResult
1048: oGetLocal 6
1050: oPushResult
1051: oScopeAllocType
1052: oPop 1
1054: oPushResult
1055: oNodeSetInt
1056: oPop 3
1058: oScopeEnd
1059: oInput 4
1061: oGetLocal 1
1063: oChoice 1075
1065: oGetLocal 2
1067: oPushResult
1068: oScopeDeclare
1069: oPop 1
1071: oJumpForward 1081
1073: oJumpForward 1081
1075: Choice Lookup Table
           1   1073
           0   1065
1080: oEndChoice
1081: oGetLocal 2
1083: oPushResult
1084: oCall 373
1086: oPop 1
1088: oInputChoice 1101
1090: oJumpForward 1177
1092: oGetLocal 2
1094: oPushResult
1095: oCall 451
1097: oPop 1
1099: oJumpForward 1177
1101: Choice Lookup Table
          59   1092
          58   1090
1106: oGetLocal 4
1108: oPushResult
1109: oScopeEnter
1110: oPop 1
1112: oGetLocal 3
1114: oPushResult
1115: oScopeBegin
1116: oPop 1
1118: oScopeCurrent
1119: oPushResult
1120: oSetResult 4
1122: oPushResult
1123: oSetResult 1
1125: oPushResult
1126: oNodeSetBoolean
1127: oPop 3
1129: oGetLocal 2
1131: oPushResult
1132: oSetResult 11
1134: oPushResult
1135: oScopeCurrent
1136: oPushResult
1137: oNodeSet
1138: oPop 3
1140: oGetAddrLocal 7
1142: oPushResult
1143: oGetLocal 2
1145: oPushResult
1146: oSetResult 8
1148: oPushResult
1149: oNodeGetLabel
1150: oPop 2
1152: oAssign
1153: oSetResult 13
1155: oPushResult
1156: oGetLocal 7
1158: oPushResult
1159: oCall 229
1161: oPop 2
1163: oGetLocal 2
1165: oPushResult
1166: oSetResult 12
1168: oPushResult
1169: oSetResult 1
1171: oPushResult
1172: oNodeSetBoolean
1173: oPop 3
1175: oScopeEnd
1176: oScopeEnd
1177: oInput 4
1179: oReturn
1180: oLocalSpace 6
1182: oInputChoice 1403
1184: oGetAddrLocal 1
1186: oPushResult
1187: oNodeVecNew
1188: oAssign
1189: oGetAddrLocal 3
1191: oPushResult
1192: oSetResult 0
1194: oAssign
1195: oInputChoice 1205
1197: oGetAddrLocal 3
1199: oPushResult
1200: oSetResult 1
1202: oAssign
1203: oJumpForward 1208
1205: Choice Lookup Table
          32   1197
1208: oInput 0
1210: oGetAddrLocal 2
1212: oPushResult
1213: oSetResult 15
1215: oPushResult
1216: oSetResult 6
1218: oPushResult
1219: LAST_ID
1220: oPushResult
1221: oCall 6069
1223: oPop 3
1225: oAssign
1226: oGetLocal 2
1228: oPushResult
1229: oSetResult 20
1231: oPushResult
1232: oGetLocal 3
1234: oPushResult
1235: oNodeSetBoolean
1236: oPop 3
1238: oGetLocal 1
1240: oPushResult
1241: oGetLocal 2
1243: oPushResult
1244: oNodeVecAppend
1245: oPop 2
1247: oInputChoice 1255
1249: oJumpForward 1263
1251: oJumpForward 1261
1253: oJumpForward 1261
1255: Choice Lookup Table
          12   1253
          11   1249
1260: oEndChoice
1261: oJumpBack 1208
1263: oGetAddrLocal 4
1265: oPushResult
1266: oCall 1770
1268: oPop 1
1270: oGetLocal 3
1272: oChoice 1287
1274: oGetAddrLocal 5
1276: oPushResult
1277: oGetLocal 4
1279: oPushResult
1280: oCall 6097
1282: oPop 1
1284: oAssign
1285: oJumpForward 1296
1287: Choice Lookup Table
           1   1274
1290: oGetAddrLocal 5
1292: oPushResult
1293: oGetLocal 4
1295: oAssign
1296: oGetAddrLocal 6
1298: oPushResult
1299: oSetResult 0
1301: oAssign
1302: oGetLocal 6
1304: oPushResult
1305: oGetLocal 1
1307: oPushResult
1308: oNodeVecSize
1309: oPop 1
1311: oPushResult
1312: equal
1313: oPop 2
1315: oChoice 1372
1317: oGetAddrLocal 2
1319: oPushResult
1320: oGetLocal 1
1322: oPushResult
1323: oGetLocal 6
1325: oPushResult
1326: oNodeVecElement
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oSetResult 7
1335: oPushResult
1336: oGetLocal 4
1338: oPushResult
1339: oNodeSet
1340: oPop 3
1342: oGetLocal 2
1344: oPushResult
1345: oScopeDeclare
1346: oPop 1
1348: oGetLocal 2
1350: oPushResult
1351: oSetResult 8
1353: oPushResult
1354: oGetLocal 5
1356: oPushResult
1357: oScopeAllocType
1358: oPop 1
1360: oPushResult
1361: oNodeSetInt
1362: oPop 3
1364: oGetAddrLocal 6
1366: oPushResult
1367: inc
1368: oPop 1
1370: oJumpForward 1377
1372: Choice Lookup Table
           0   1317
1375: oJumpForward 1379
1377: oJumpBack 1302
1379: oGetLocal 1
1381: oPushResult
1382: oNodeVecDelete
1383: oPop 1
1385: oInputChoice 1393
1387: oJumpForward 1401
1389: oJumpForward 1399
1391: oJumpForward 1399
1393: Choice Lookup Table
           4   1391
          14   1387
1398: oEndChoice
1399: oJumpBack 1184
1401: oJumpForward 1406
1403: Choice Lookup Table
          13   1184
1406: oReturn
1407: oLocalSpace 2
1409: oInputChoice 1471
1411: oGetAddrLocal 1
1413: oPushResult
1414: oSetResult 9
1416: oPushResult
1417: oSetResult 4
1419: oPushResult
1420: LAST_ID
1421: oPushResult
1422: oCall 6069
1424: oPop 3
1426: oAssign
1427: oInput 5
1429: oCall 2244
1431: oGetAddrLocal 2
1433: oPushResult
1434: oValueTop
1435: oAssign
1436: oValuePop
1437: oGetLocal 1
1439: oPushResult
1440: oSetResult 8
1442: oPushResult
1443: oGetLocal 2
1445: oPushResult
1446: oNodeSetInt
1447: oPop 3
1449: oGetLocal 1
1451: oPushResult
1452: oSetResult 7
1454: oPushResult
1455: oGetGlobal 4
1457: oPushResult
1458: oNodeSet
1459: oPop 3
1461: oGetLocal 1
1463: oPushResult
1464: oScopeDeclare
1465: oPop 1
1467: oInput 4
1469: oJumpForward 1476
1471: Choice Lookup Table
           0   1411
1474: oJumpForward 1478
1476: oJumpBack 1409
1478: oReturn
1479: oLocalSpace 2
1481: oInputChoice 1530
1483: oGetAddrLocal 1
1485: oPushResult
1486: oSetResult 10
1488: oPushResult
1489: oSetResult 5
1491: oPushResult
1492: LAST_ID
1493: oPushResult
1494: oCall 6069
1496: oPop 3
1498: oAssign
1499: oInput 5
1501: oGetAddrLocal 2
1503: oPushResult
1504: oCall 1770
1506: oPop 1
1508: oGetLocal 1
1510: oPushResult
1511: oSetResult 7
1513: oPushResult
1514: oGetLocal 2
1516: oPushResult
1517: oNodeSet
1518: oPop 3
1520: oGetLocal 1
1522: oPushResult
1523: oScopeDeclare
1524: oPop 1
1526: oInput 4
1528: oJumpForward 1535
1530: Choice Lookup Table
           0   1483
1533: oJumpForward 1537
1535: oJumpBack 1481
1537: oReturn
1538: oLocalSpace 6
1540: oInputChoice 1762
1542: oGetAddrLocal 1
1544: oPushResult
1545: oNodeVecNew
1546: oAssign
1547: oGetAddrLocal 2
1549: oPushResult
1550: oGetParam 1
1552: oPushResult
1553: oSetResult 6
1555: oPushResult
1556: LAST_ID
1557: oPushResult
1558: oCall 6069
1560: oPop 3
1562: oAssign
1563: oGetLocal 1
1565: oPushResult
1566: oGetLocal 2
1568: oPushResult
1569: oNodeVecAppend
1570: oPop 2
1572: oInputChoice 1578
1574: oInput 0
1576: oJumpForward 1583
1578: Choice Lookup Table
          12   1574
1581: oJumpForward 1585
1583: oJumpBack 1547
1585: oInput 11
1587: oGetAddrLocal 3
1589: oPushResult
1590: oCall 1770
1592: oPop 1
1594: oGetAddrLocal 4
1596: oPushResult
1597: oSetResult 0
1599: oAssign
1600: oGetLocal 4
1602: oPushResult
1603: oGetLocal 1
1605: oPushResult
1606: oNodeVecSize
1607: oPop 1
1609: oPushResult
1610: equal
1611: oPop 2
1613: oChoice 1654
1615: oGetAddrLocal 2
1617: oPushResult
1618: oGetLocal 1
1620: oPushResult
1621: oGetLocal 4
1623: oPushResult
1624: oNodeVecElement
1625: oPop 2
1627: oAssign
1628: oGetLocal 2
1630: oPushResult
1631: oSetResult 7
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oNodeSet
1638: oPop 3
1640: oGetLocal 2
1642: oPushResult
1643: oScopeDeclareAlloc
1644: oPop 1
1646: oGetAddrLocal 4
1648: oPushResult
1649: inc
1650: oPop 1
1652: oJumpForward 1659
1654: Choice Lookup Table
           0   1615
1657: oJumpForward 1661
1659: oJumpBack 1600
1661: oInputChoice 1749
1663: oGetLocal 1
1665: oPushResult
1666: oNodeVecSize
1667: oPop 1
1669: oChoice 1673
1671: oJumpForward 1678
1673: Choice Lookup Table
           1   1671
1676: oError 22
1678: oGetAddrLocal 5
1680: oPushResult
1681: oCall 401
1683: oAssign
1684: oGetLocal 5
1686: oPushResult
1687: oCodePush
1688: oPop 1
1690: oGetAddrLocal 6
1692: oPushResult
1693: oSetResult 0
1695: oAssign
1696: oScopeCurrent
1697: oPushResult
1698: oGetGlobal 1
1700: oPushResult
1701: equal_node
1702: oPop 2
1704: oChoice 1720
1706: oGetGlobal 2
1708: oPushResult
1709: oScopeEnter
1710: oPop 1
1712: oGetAddrLocal 6
1714: oPushResult
1715: oSetResult 1
1717: oAssign
1718: oJumpForward 1723
1720: Choice Lookup Table
           1   1706
1723: oGetLocal 2
1725: oPushResult
1726: oCall 5274
1728: oPop 1
1730: oCall 2310
1732: oCall 5955
1734: oCall 5068
1736: oGetLocal 6
1738: oChoice 1743
1740: oScopeEnd
1741: oJumpForward 1746
1743: Choice Lookup Table
           1   1740
1746: oCodePop
1747: oJumpForward 1752
1749: Choice Lookup Table
           5   1663
1752: oGetLocal 1
1754: oPushResult
1755: oNodeVecDelete
1756: oPop 1
1758: oInput 4
1760: oJumpForward 1767
1762: Choice Lookup Table
           0   1542
1765: oJumpForward 1769
1767: oJumpBack 1540
1769: oReturn
1770: oLocalSpace 12
1772: oInputChoice 2226
1774: oGetAddrLocal 1
1776: oPushResult
1777: oScopeFindRequire
1778: oAssign
1779: oGetLocal 1
1781: oPushResult
1782: oNodeType
1783: oPop 1
1785: oChoice 1802
1787: oGetParam 1
1789: oPushResult
1790: oGetLocal 1
1792: oPushResult
1793: oSetResult 7
1795: oPushResult
1796: oNodeGet
1797: oPop 2
1799: oAssign
1800: oJumpForward 1813
1802: Choice Lookup Table
          10   1787
1805: oError 2
1807: oGetParam 1
1809: oPushResult
1810: oGetGlobal 4
1812: oAssign
1813: oJumpForward 2243
1815: oInput 15
1817: oGetAddrLocal 2
1819: oPushResult
1820: oNodeVecNew
1821: oAssign
1822: oGetAddrLocal 3
1824: oPushResult
1825: oSetResult 25
1827: oPushResult
1828: oNodeNew
1829: oPop 1
1831: oAssign
1832: oGetLocal 3
1834: oPushResult
1835: oSetResult 22
1837: oPushResult
1838: oGetGlobal 4
1840: oPushResult
1841: oNodeSet
1842: oPop 3
1844: oCall 2244
1846: oGetLocal 3
1848: oPushResult
1849: oSetResult 24
1851: oPushResult
1852: oValueTop
1853: oPushResult
1854: oNodeSetInt
1855: oPop 3
1857: oValuePop
1858: oInput 20
1860: oCall 2244
1862: oGetLocal 3
1864: oPushResult
1865: oSetResult 25
1867: oPushResult
1868: oValueTop
1869: oPushResult
1870: oNodeSetInt
1871: oPop 3
1873: oValuePop
1874: oGetLocal 3
1876: oPushResult
1877: oSetResult 3
1879: oPushResult
1880: oSetResult 4
1882: oPushResult
1883: oNodeSetInt
1884: oPop 3
1886: oGetLocal 3
1888: oPushResult
1889: oTypeAdd
1890: oPop 1
1892: oGetAddrLocal 4
1894: oPushResult
1895: oSetResult 24
1897: oPushResult
1898: oNodeNew
1899: oPop 1
1901: oAssign
1902: oGetLocal 4
1904: oPushResult
1905: oSetResult 23
1907: oPushResult
1908: oGetLocal 3
1910: oPushResult
1911: oNodeSet
1912: oPop 3
1914: oGetLocal 2
1916: oPushResult
1917: oGetLocal 4
1919: oPushResult
1920: oNodeVecAppend
1921: oPop 2
1923: oInputChoice 1931
1925: oJumpForward 1939
1927: oJumpForward 1937
1929: oJumpForward 1937
1931: Choice Lookup Table
          12   1929
          16   1925
1936: oEndChoice
1937: oJumpBack 1822
1939: oInput 38
1941: oGetAddrLocal 5
1943: oPushResult
1944: oCall 1770
1946: oPop 1
1948: oGetAddrLocal 6
1950: oPushResult
1951: oGetLocal 2
1953: oPushResult
1954: oNodeVecSize
1955: oPop 1
1957: oAssign
1958: oGetAddrLocal 6
1960: oPushResult
1961: dec
1962: oPop 1
1964: oGetAddrLocal 7
1966: oPushResult
1967: oGetLocal 2
1969: oPushResult
1970: oGetLocal 6
1972: oPushResult
1973: oNodeVecElement
1974: oPop 2
1976: oAssign
1977: oGetLocal 7
1979: oPushResult
1980: oSetResult 22
1982: oPushResult
1983: oGetLocal 5
1985: oPushResult
1986: oNodeSet
1987: oPop 3
1989: oGetAddrLocal 8
1991: oPushResult
1992: oGetLocal 7
1994: oPushResult
1995: oSetResult 23
1997: oPushResult
1998: oNodeGet
1999: oPop 2
2001: oAssign
2002: oGetAddrLocal 9
2004: oPushResult
2005: oGetLocal 8
2007: oPushResult
2008: oSetResult 25
2010: oPushResult
2011: oNodeGetInt
2012: oPop 2
2014: oPushResult
2015: oGetLocal 8
2017: oPushResult
2018: oSetResult 24
2020: oPushResult
2021: oNodeGetInt
2022: oPop 2
2024: oPushResult
2025: subtract
2026: oPop 2
2028: oAssign
2029: oGetAddrLocal 9
2031: oPushResult
2032: inc
2033: oPop 1
2035: oGetLocal 7
2037: oPushResult
2038: oSetResult 3
2040: oPushResult
2041: oGetLocal 9
2043: oPushResult
2044: oGetLocal 5
2046: oPushResult
2047: oSetResult 3
2049: oPushResult
2050: oNodeGetInt
2051: oPop 2
2053: oPushResult
2054: multiply
2055: oPop 2
2057: oPushResult
2058: oNodeSetInt
2059: oPop 3
2061: oGetLocal 7
2063: oPushResult
2064: oTypeAdd
2065: oPop 1
2067: oGetAddrLocal 5
2069: oPushResult
2070: oGetLocal 7
2072: oAssign
2073: oGetLocal 6
2075: oPushResult
2076: equal_zero
2077: oPop 1
2079: oChoice 2085
2081: oJumpForward 2090
2083: oJumpForward 2088
2085: Choice Lookup Table
           1   2081
2088: oJumpBack 1958
2090: oGetParam 1
2092: oPushResult
2093: oGetLocal 2
2095: oPushResult
2096: oSetResult 0
2098: oPushResult
2099: oNodeVecElement
2100: oPop 2
2102: oAssign
2103: oGetLocal 2
2105: oPushResult
2106: oNodeVecDelete
2107: oPop 1
2109: oJumpForward 2243
2111: oGetAddrLocal 10
2113: oPushResult
2114: oCall 1770
2116: oPop 1
2118: oGetParam 1
2120: oPushResult
2121: oGetLocal 10
2123: oPushResult
2124: oCall 6097
2126: oPop 1
2128: oAssign
2129: oJumpForward 2243
2131: oGetParam 1
2133: oPushResult
2134: oSetResult 26
2136: oPushResult
2137: oNodeNew
2138: oPop 1
2140: oAssign
2141: oSetResult -1
2143: oPushResult
2144: oScopeBegin
2145: oPop 1
2147: oSetResult 14
2149: oPushResult
2150: oCall 1538
2152: oPop 1
2154: oGetAddrLocal 11
2156: oPushResult
2157: oScopeCurrent
2158: oPushResult
2159: oSetResult 3
2161: oPushResult
2162: oNodeGetInt
2163: oPop 2
2165: oAssign
2166: oGetLocal 11
2168: oPushResult
2169: equal_zero
2170: oPop 1
2172: oChoice 2178
2174: oError 19
2176: oJumpForward 2181
2178: Choice Lookup Table
           1   2174
2181: oInput 34
2183: oGetFromParam 1
2185: oPushResult
2186: oSetResult 26
2188: oPushResult
2189: oScopeCurrent
2190: oPushResult
2191: oNodeSet
2192: oPop 3
2194: oGetFromParam 1
2196: oPushResult
2197: oSetResult 3
2199: oPushResult
2200: oGetLocal 11
2202: oPushResult
2203: oNodeSetInt
2204: oPop 3
2206: oScopeEnd
2207: oGetFromParam 1
2209: oPushResult
2210: oTypeAdd
2211: oPop 1
2213: oJumpForward 2243
2215: oInput 38
2217: oGetAddrLocal 12
2219: oPushResult
2220: oCall 1770
2222: oPop 1
2224: oJumpForward 2243
2226: Choice Lookup Table
          37   2215
          36   2131
          17   2111
          35   1815
           0   1774
2237: oCall 2244
2239: oInput 20
2241: oCall 2244
2243: oReturn
2244: oLocalSpace 1
2246: oInputChoice 2301
2248: TOKEN_VALUE
2249: oPushResult
2250: oValuePush
2251: oPop 1
2253: oJumpForward 2309
2255: oGetAddrLocal 1
2257: oPushResult
2258: oScopeFindRequire
2259: oAssign
2260: oGetLocal 1
2262: oPushResult
2263: oNodeType
2264: oPop 1
2266: oChoice 2283
2268: oGetLocal 1
2270: oPushResult
2271: oSetResult 8
2273: oPushResult
2274: oNodeGetInt
2275: oPop 2
2277: oPushResult
2278: oValuePush
2279: oPop 1
2281: oJumpForward 2294
2283: Choice Lookup Table
           9   2268
2286: oError 1
2288: oSetResult 0
2290: oPushResult
2291: oValuePush
2292: oPop 1
2294: oJumpForward 2309
2296: oCall 2244
2298: oValueNegate
2299: oJumpForward 2309
2301: Choice Lookup Table
          24   2296
           0   2255
           1   2248
2308: oEndChoice
2309: oReturn
2310: oLocalSpace 1
2312: oGetAddrLocal 1
2314: oPushResult
2315: oSetResult 0
2317: oAssign
2318: oGetAddrLocal 1
2320: oPushResult
2321: oCall 2471
2323: oPop 1
2325: oGetAddrLocal 1
2327: oPushResult
2328: oCall 2371
2330: oPop 1
2332: oReturn
2333: oLocalSpace 0
2335: oGetParam 1
2337: oPushResult
2338: oCall 2471
2340: oPop 1
2342: oTypeSNodeType
2343: oChoice 2362
2345: oJumpForward 2369
2347: oGetParam 1
2349: oPushResult
2350: oLabelNew
2351: oAssign
2352: oEmit 47
2354: oGetFromParam 1
2356: oPushResult
2357: oEmitLabel
2358: oPop 1
2360: oJumpForward 2369
2362: Choice Lookup Table
          19   2347
          20   2345
2367: oError 8
2369: oTypeSPop
2370: oReturn
2371: oLocalSpace 1
2373: oTypeSNodeType
2374: oChoice 2436
2376: oGetAddrLocal 1
2378: oPushResult
2379: oLabelNew
2380: oAssign
2381: oEmit 9
2383: oSetResult 1
2385: oPushResult
2386: oEmitInt
2387: oPop 1
2389: oEmit 45
2391: oGetLocal 1
2393: oPushResult
2394: oEmitLabel
2395: oPop 1
2397: oEmit 48
2399: oGetFromParam 1
2401: oPushResult
2402: oEmitLabel
2403: oPop 1
2405: oEmit 9
2407: oSetResult 0
2409: oPushResult
2410: oEmitInt
2411: oPop 1
2413: oEmit 48
2415: oGetLocal 1
2417: oPushResult
2418: oEmitLabel
2419: oPop 1
2421: oTypeSPop
2422: oGetGlobal 5
2424: oPushResult
2425: oTypeSPush
2426: oPop 1
2428: oGetParam 1
2430: oPushResult
2431: oSetResult 0
2433: oAssign
2434: oJumpForward 2439
2436: Choice Lookup Table
          20   2376
2439: oReturn
2440: oLocalSpace 0
2442: oTypeSNodeType
2443: oChoice 2467
2445: oGetParam 1
2447: oPushResult
2448: oLabelNew
2449: oAssign
2450: oEmit 47
2452: oGetFromParam 1
2454: oPushResult
2455: oEmitLabel
2456: oPop 1
2458: oTypeSPop
2459: oGetGlobal 6
2461: oPushResult
2462: oTypeSPush
2463: oPop 1
2465: oJumpForward 2470
2467: Choice Lookup Table
          19   2445
2470: oReturn
2471: oLocalSpace 0
2473: oGetParam 1
2475: oPushResult
2476: oCall 2836
2478: oPop 1
2480: oInputChoice 2818
2482: oGetParam 1
2484: oPushResult
2485: oCall 2371
2487: oPop 1
2489: oGetParam 1
2491: oPushResult
2492: oCall 2836
2494: oPop 1
2496: oGetParam 1
2498: oPushResult
2499: oCall 2371
2501: oPop 1
2503: oCall 5955
2505: oTypeSNodeType
2506: oChoice 2520
2508: oEmit 30
2510: oJumpForward 2533
2512: oEmit 36
2514: oJumpForward 2533
2516: oError 16
2518: oJumpForward 2533
2520: Choice Lookup Table
          22   2516
          21   2516
          23   2512
          19   2508
          18   2508
2531: oError 17
2533: oTypeSPop
2534: oGetGlobal 5
2536: oPushResult
2537: oTypeSPush
2538: oPop 1
2540: oJumpForward 2833
2542: oGetParam 1
2544: oPushResult
2545: oCall 2371
2547: oPop 1
2549: oGetParam 1
2551: oPushResult
2552: oCall 2836
2554: oPop 1
2556: oGetParam 1
2558: oPushResult
2559: oCall 2371
2561: oPop 1
2563: oCall 5955
2565: oTypeSNodeType
2566: oChoice 2580
2568: oEmit 31
2570: oJumpForward 2593
2572: oEmit 37
2574: oJumpForward 2593
2576: oError 16
2578: oJumpForward 2593
2580: Choice Lookup Table
          22   2576
          21   2576
          23   2572
          19   2568
          18   2568
2591: oError 17
2593: oTypeSPop
2594: oGetGlobal 5
2596: oPushResult
2597: oTypeSPush
2598: oPop 1
2600: oJumpForward 2833
2602: oGetParam 1
2604: oPushResult
2605: oCall 2371
2607: oPop 1
2609: oGetParam 1
2611: oPushResult
2612: oCall 2836
2614: oPop 1
2616: oGetParam 1
2618: oPushResult
2619: oCall 2371
2621: oPop 1
2623: oCall 5955
2625: oTypeSNodeType
2626: oChoice 2636
2628: oEmit 33
2630: oJumpForward 2647
2632: oError 16
2634: oJumpForward 2647
2636: Choice Lookup Table
          22   2632
          21   2632
          19   2628
          18   2628
2645: oError 17
2647: oTypeSPop
2648: oGetGlobal 5
2650: oPushResult
2651: oTypeSPush
2652: oPop 1
2654: oJumpForward 2833
2656: oGetParam 1
2658: oPushResult
2659: oCall 2371
2661: oPop 1
2663: oGetParam 1
2665: oPushResult
2666: oCall 2836
2668: oPop 1
2670: oGetParam 1
2672: oPushResult
2673: oCall 2371
2675: oPop 1
2677: oCall 5955
2679: oTypeSNodeType
2680: oChoice 2690
2682: oEmit 32
2684: oJumpForward 2701
2686: oError 16
2688: oJumpForward 2701
2690: Choice Lookup Table
          22   2686
          21   2686
          19   2682
          18   2682
2699: oError 17
2701: oTypeSPop
2702: oGetGlobal 5
2704: oPushResult
2705: oTypeSPush
2706: oPop 1
2708: oJumpForward 2833
2710: oGetParam 1
2712: oPushResult
2713: oCall 2371
2715: oPop 1
2717: oGetParam 1
2719: oPushResult
2720: oCall 2836
2722: oPop 1
2724: oGetParam 1
2726: oPushResult
2727: oCall 2371
2729: oPop 1
2731: oCall 5955
2733: oTypeSNodeType
2734: oChoice 2744
2736: oEmit 35
2738: oJumpForward 2755
2740: oError 16
2742: oJumpForward 2755
2744: Choice Lookup Table
          22   2740
          21   2740
          19   2736
          18   2736
2753: oError 17
2755: oTypeSPop
2756: oGetGlobal 5
2758: oPushResult
2759: oTypeSPush
2760: oPop 1
2762: oJumpForward 2833
2764: oGetParam 1
2766: oPushResult
2767: oCall 2371
2769: oPop 1
2771: oGetParam 1
2773: oPushResult
2774: oCall 2836
2776: oPop 1
2778: oGetParam 1
2780: oPushResult
2781: oCall 2371
2783: oPop 1
2785: oCall 5955
2787: oTypeSNodeType
2788: oChoice 2798
2790: oEmit 34
2792: oJumpForward 2809
2794: oError 16
2796: oJumpForward 2809
2798: Choice Lookup Table
          22   2794
          21   2794
          19   2790
          18   2790
2807: oError 17
2809: oTypeSPop
2810: oGetGlobal 5
2812: oPushResult
2813: oTypeSPush
2814: oPop 1
2816: oJumpForward 2833
2818: Choice Lookup Table
          10   2764
           9   2710
           8   2656
           7   2602
           6   2542
           5   2482
2831: oJumpForward 2835
2833: oJumpBack 2480
2835: oReturn
2836: oLocalSpace 1
2838: oGetAddrLocal 1
2840: oPushResult
2841: oSetResult 0
2843: oAssign
2844: oGetParam 1
2846: oPushResult
2847: oCall 3016
2849: oPop 1
2851: oInputChoice 2984
2853: oTypeSNodeType
2854: oChoice 2925
2856: oGetLocal 1
2858: oPushResult
2859: oSetResult 0
2861: oPushResult
2862: equal_label
2863: oPop 2
2865: oChoice 2874
2867: oGetAddrLocal 1
2869: oPushResult
2870: oLabelNew
2871: oAssign
2872: oJumpForward 2877
2874: Choice Lookup Table
           1   2867
2877: oEmit 45
2879: oGetLocal 1
2881: oPushResult
2882: oEmitLabel
2883: oPop 1
2885: oJumpForward 2932
2887: oGetParam 1
2889: oPushResult
2890: oCall 2440
2892: oPop 1
2894: oGetLocal 1
2896: oPushResult
2897: oSetResult 0
2899: oPushResult
2900: equal_label
2901: oPop 2
2903: oChoice 2912
2905: oGetAddrLocal 1
2907: oPushResult
2908: oLabelNew
2909: oAssign
2910: oJumpForward 2915
2912: Choice Lookup Table
           1   2905
2915: oEmit 45
2917: oGetLocal 1
2919: oPushResult
2920: oEmitLabel
2921: oPop 1
2923: oJumpForward 2932
2925: Choice Lookup Table
          19   2887
          20   2856
2930: oError 8
2932: oTypeSPop
2933: oEmit 48
2935: oGetFromParam 1
2937: oPushResult
2938: oEmitLabel
2939: oPop 1
2941: oGetParam 1
2943: oPushResult
2944: oSetResult 0
2946: oAssign
2947: oGetParam 1
2949: oPushResult
2950: oCall 3016
2952: oPop 1
2954: oTypeSNodeType
2955: oChoice 2968
2957: oJumpForward 2975
2959: oGetParam 1
2961: oPushResult
2962: oCall 2440
2964: oPop 1
2966: oJumpForward 2975
2968: Choice Lookup Table
          19   2959
          20   2957
2973: oError 8
2975: oTypeSPop
2976: oGetGlobal 6
2978: oPushResult
2979: oTypeSPush
2980: oPop 1
2982: oJumpForward 2989
2984: Choice Lookup Table
          52   2853
2987: oJumpForward 2991
2989: oJumpBack 2851
2991: oGetLocal 1
2993: oPushResult
2994: oSetResult 0
2996: oPushResult
2997: equal_label
2998: oPop 2
3000: oChoice 3012
3002: oEmit 48
3004: oGetLocal 1
3006: oPushResult
3007: oEmitLabel
3008: oPop 1
3010: oJumpForward 3015
3012: Choice Lookup Table
           0   3002
3015: oReturn
3016: oLocalSpace 2
3018: oGetAddrLocal 1
3020: oPushResult
3021: oSetResult 0
3023: oAssign
3024: oGetParam 1
3026: oPushResult
3027: oCall 3154
3029: oPop 1
3031: oInputChoice 3146
3033: oTypeSNodeType
3034: oChoice 3047
3036: oJumpForward 3054
3038: oGetParam 1
3040: oPushResult
3041: oCall 2440
3043: oPop 1
3045: oJumpForward 3054
3047: Choice Lookup Table
          19   3038
          20   3036
3052: oError 8
3054: oTypeSPop
3055: oGetLocal 1
3057: oPushResult
3058: oSetResult 0
3060: oPushResult
3061: equal_label
3062: oPop 2
3064: oChoice 3093
3066: oGetAddrLocal 1
3068: oPushResult
3069: oLabelNew
3070: oAssign
3071: oEmit 49
3073: oGetFromParam 1
3075: oPushResult
3076: oEmitLabel
3077: oPop 1
3079: oGetLocal 1
3081: oPushResult
3082: oEmitLabel
3083: oPop 1
3085: oGetParam 1
3087: oPushResult
3088: oGetLocal 1
3090: oAssign
3091: oJumpForward 3096
3093: Choice Lookup Table
           1   3066
3096: oGetAddrLocal 2
3098: oPushResult
3099: oSetResult 0
3101: oAssign
3102: oGetAddrLocal 2
3104: oPushResult
3105: oCall 3154
3107: oPop 1
3109: oTypeSNodeType
3110: oChoice 3123
3112: oJumpForward 3130
3114: oGetAddrLocal 2
3116: oPushResult
3117: oCall 2440
3119: oPop 1
3121: oJumpForward 3130
3123: Choice Lookup Table
          19   3114
          20   3112
3128: oError 8
3130: oEmit 49
3132: oGetLocal 2
3134: oPushResult
3135: oEmitLabel
3136: oPop 1
3138: oGetLocal 1
3140: oPushResult
3141: oEmitLabel
3142: oPop 1
3144: oJumpForward 3151
3146: Choice Lookup Table
          51   3033
3149: oJumpForward 3153
3151: oJumpBack 3031
3153: oReturn
3154: oLocalSpace 1
3156: oInputChoice 3210
3158: oGetAddrLocal 1
3160: oPushResult
3161: oSetResult 0
3163: oAssign
3164: oGetAddrLocal 1
3166: oPushResult
3167: oCall 3154
3169: oPop 1
3171: oTypeSNodeType
3172: oChoice 3201
3174: oGetParam 1
3176: oPushResult
3177: oLabelNew
3178: oAssign
3179: oEmit 45
3181: oGetFromParam 1
3183: oPushResult
3184: oEmitLabel
3185: oPop 1
3187: oEmit 48
3189: oGetLocal 1
3191: oPushResult
3192: oEmitLabel
3193: oPop 1
3195: oJumpForward 3208
3197: oEmit 29
3199: oJumpForward 3208
3201: Choice Lookup Table
          19   3197
          20   3174
3206: oError 8
3208: oJumpForward 3220
3210: Choice Lookup Table
          53   3158
3213: oGetParam 1
3215: oPushResult
3216: oCall 3221
3218: oPop 1
3220: oReturn
3221: oLocalSpace 0
3223: oGetParam 1
3225: oPushResult
3226: oCall 3272
3228: oPop 1
3230: oInputChoice 3262
3232: oCall 5981
3234: oGetParam 1
3236: oPushResult
3237: oCall 3272
3239: oPop 1
3241: oCall 5995
3243: oEmit 26
3245: oJumpForward 3269
3247: oCall 5981
3249: oGetParam 1
3251: oPushResult
3252: oCall 3272
3254: oPop 1
3256: oCall 5995
3258: oEmit 27
3260: oJumpForward 3269
3262: Choice Lookup Table
          24   3247
          23   3232
3267: oJumpForward 3271
3269: oJumpBack 3230
3271: oReturn
3272: oLocalSpace 0
3274: oGetParam 1
3276: oPushResult
3277: oCall 3323
3279: oPop 1
3281: oInputChoice 3313
3283: oCall 5981
3285: oGetParam 1
3287: oPushResult
3288: oCall 3323
3290: oPop 1
3292: oCall 5995
3294: oEmit 23
3296: oJumpForward 3320
3298: oCall 5981
3300: oGetParam 1
3302: oPushResult
3303: oCall 3323
3305: oPop 1
3307: oCall 5995
3309: oEmit 24
3311: oJumpForward 3320
3313: Choice Lookup Table
          22   3298
          21   3283
3318: oJumpForward 3322
3320: oJumpBack 3281
3322: oReturn
3323: oLocalSpace 0
3325: oInputChoice 3351
3327: oGetParam 1
3329: oPushResult
3330: oCall 3364
3332: oPop 1
3334: oCall 5995
3336: oJumpForward 3363
3338: oGetParam 1
3340: oPushResult
3341: oCall 3364
3343: oPop 1
3345: oCall 5995
3347: oEmit 28
3349: oJumpForward 3363
3351: Choice Lookup Table
          24   3338
          23   3327
3356: oGetParam 1
3358: oPushResult
3359: oCall 3364
3361: oPop 1
3363: oReturn
3364: oLocalSpace 6
3366: oInputChoice 3552
3368: oEmit 9
3370: TOKEN_VALUE
3371: oPushResult
3372: oEmitInt
3373: oPop 1
3375: oGetGlobal 4
3377: oPushResult
3378: oTypeSPush
3379: oPop 1
3381: oJumpForward 3571
3383: oGetParam 1
3385: oPushResult
3386: oCall 2471
3388: oPop 1
3390: oInput 14
3392: oJumpForward 3571
3394: oGetAddrLocal 1
3396: oPushResult
3397: CURRENT_STRLIT
3398: oPushResult
3399: oStringAllocLit
3400: oPop 1
3402: oAssign
3403: oEmit 10
3405: oGetLocal 1
3407: oPushResult
3408: oEmitInt
3409: oPop 1
3411: oGetGlobal 8
3413: oPushResult
3414: oTypeSPush
3415: oPop 1
3417: oJumpForward 3571
3419: oGetAddrLocal 2
3421: oPushResult
3422: oScopeFindRequire
3423: oAssign
3424: oGetLocal 2
3426: oPushResult
3427: oNodeType
3428: oPop 1
3430: oChoice 3492
3432: oGetLocal 2
3434: oPushResult
3435: oCall 4377
3437: oPop 1
3439: oJumpForward 3511
3441: oGetAddrLocal 3
3443: oPushResult
3444: oGetLocal 2
3446: oPushResult
3447: oSetResult 7
3449: oPushResult
3450: oNodeGet
3451: oPop 2
3453: oAssign
3454: oGetLocal 3
3456: oPushResult
3457: oTypeSPush
3458: oPop 1
3460: oTypeSNodeType
3461: oChoice 3474
3463: oEmit 9
3465: oGetLocal 2
3467: oPushResult
3468: oCall 6232
3470: oPop 1
3472: oJumpForward 3481
3474: Choice Lookup Table
          19   3463
          18   3463
3479: oError 16
3481: oJumpForward 3511
3483: oGetLocal 2
3485: oPushResult
3486: oCall 3572
3488: oPop 1
3490: oJumpForward 3511
3492: Choice Lookup Table
          15   3483
          13   3483
          12   3483
           9   3441
           8   3432
3503: oError 6
3505: oGetGlobal 4
3507: oPushResult
3508: oTypeSPush
3509: oPop 1
3511: oJumpForward 3571
3513: oInput 0
3515: oGetAddrLocal 4
3517: oPushResult
3518: oScopeFindRequire
3519: oAssign
3520: oGetLocal 4
3522: oPushResult
3523: oCall 5274
3525: oPop 1
3527: oGetAddrLocal 5
3529: oPushResult
3530: oTypeSTop
3531: oAssign
3532: oTypeSPop
3533: oGetAddrLocal 6
3535: oPushResult
3536: oGetLocal 5
3538: oPushResult
3539: oCall 6097
3541: oPop 1
3543: oAssign
3544: oGetLocal 6
3546: oPushResult
3547: oTypeSPush
3548: oPop 1
3550: oJumpForward 3571
3552: Choice Lookup Table
          18   3513
           0   3419
           2   3394
          13   3383
           1   3368
3563: oError 6
3565: oGetGlobal 4
3567: oPushResult
3568: oTypeSPush
3569: oPop 1
3571: oReturn
3572: oLocalSpace 1
3574: oGetAddrLocal 1
3576: oPushResult
3577: oGetParam 1
3579: oPushResult
3580: oSetResult 7
3582: oPushResult
3583: oNodeGet
3584: oPop 2
3586: oAssign
3587: oGetLocal 1
3589: oPushResult
3590: oTypeSPush
3591: oPop 1
3593: oTypeSNodeType
3594: oChoice 3859
3596: oGetParam 1
3598: oPushResult
3599: oNodeType
3600: oPop 1
3602: oChoice 3664
3604: oEmit 0
3606: oGetParam 1
3608: oPushResult
3609: oCall 6232
3611: oPop 1
3613: oJumpForward 3672
3615: oEmit 3
3617: oGetParam 1
3619: oPushResult
3620: oCall 6232
3622: oPop 1
3624: oJumpForward 3672
3626: oGetParam 1
3628: oPushResult
3629: oSetResult 20
3631: oPushResult
3632: oNodeGetBoolean
3633: oPop 2
3635: oChoice 3650
3637: oEmit 8
3639: oGetParam 1
3641: oPushResult
3642: oCall 6232
3644: oPop 1
3646: oEmit 14
3648: oJumpForward 3662
3650: Choice Lookup Table
           1   3637
3653: oEmit 6
3655: oGetParam 1
3657: oPushResult
3658: oCall 6232
3660: oPop 1
3662: oJumpForward 3672
3664: Choice Lookup Table
          15   3626
          13   3615
          12   3604
3671: oEndChoice
3672: oJumpForward 3950
3674: oGetParam 1
3676: oPushResult
3677: oNodeType
3678: oPop 1
3680: oChoice 3742
3682: oEmit 1
3684: oGetParam 1
3686: oPushResult
3687: oCall 6232
3689: oPop 1
3691: oJumpForward 3750
3693: oEmit 4
3695: oGetParam 1
3697: oPushResult
3698: oCall 6232
3700: oPop 1
3702: oJumpForward 3750
3704: oGetParam 1
3706: oPushResult
3707: oSetResult 20
3709: oPushResult
3710: oNodeGetBoolean
3711: oPop 2
3713: oChoice 3728
3715: oEmit 8
3717: oGetParam 1
3719: oPushResult
3720: oCall 6232
3722: oPop 1
3724: oEmit 15
3726: oJumpForward 3740
3728: Choice Lookup Table
           1   3715
3731: oEmit 7
3733: oGetParam 1
3735: oPushResult
3736: oCall 6232
3738: oPop 1
3740: oJumpForward 3750
3742: Choice Lookup Table
          15   3704
          13   3693
          12   3682
3749: oEndChoice
3750: oJumpForward 3950
3752: oError 16
3754: oJumpForward 3950
3756: oGetParam 1
3758: oPushResult
3759: oNodeType
3760: oPop 1
3762: oChoice 3824
3764: oEmit 2
3766: oGetParam 1
3768: oPushResult
3769: oCall 6232
3771: oPop 1
3773: oJumpForward 3832
3775: oEmit 5
3777: oGetParam 1
3779: oPushResult
3780: oCall 6232
3782: oPop 1
3784: oJumpForward 3832
3786: oGetParam 1
3788: oPushResult
3789: oSetResult 20
3791: oPushResult
3792: oNodeGetBoolean
3793: oPop 2
3795: oChoice 3810
3797: oEmit 8
3799: oGetParam 1
3801: oPushResult
3802: oCall 6232
3804: oPop 1
3806: oEmit 16
3808: oJumpForward 3822
3810: Choice Lookup Table
           1   3797
3813: oEmit 8
3815: oGetParam 1
3817: oPushResult
3818: oCall 6232
3820: oPop 1
3822: oJumpForward 3832
3824: Choice Lookup Table
          15   3786
          13   3775
          12   3764
3831: oEndChoice
3832: oInputChoice 3854
3834: oTypeSPop
3835: oGetLocal 1
3837: oPushResult
3838: oSetResult 22
3840: oPushResult
3841: oNodeGet
3842: oPop 2
3844: oPushResult
3845: oTypeSPush
3846: oPop 1
3848: oCall 3986
3850: oCall 3951
3852: oJumpForward 3857
3854: Choice Lookup Table
          17   3834
3857: oJumpForward 3950
3859: Choice Lookup Table
          23   3756
          17   3752
          22   3752
          21   3752
          19   3674
          18   3596
3872: oGetParam 1
3874: oPushResult
3875: oNodeType
3876: oPop 1
3878: oChoice 3938
3880: oEmit 10
3882: oGetParam 1
3884: oPushResult
3885: oCall 6232
3887: oPop 1
3889: oJumpForward 3946
3891: oEmit 11
3893: oGetParam 1
3895: oPushResult
3896: oCall 6232
3898: oPop 1
3900: oJumpForward 3946
3902: oGetParam 1
3904: oPushResult
3905: oSetResult 20
3907: oPushResult
3908: oNodeGetBoolean
3909: oPop 2
3911: oChoice 3924
3913: oEmit 8
3915: oGetParam 1
3917: oPushResult
3918: oCall 6232
3920: oPop 1
3922: oJumpForward 3936
3924: Choice Lookup Table
           1   3913
3927: oEmit 12
3929: oGetParam 1
3931: oPushResult
3932: oCall 6232
3934: oPop 1
3936: oJumpForward 3946
3938: Choice Lookup Table
          15   3902
          13   3891
          12   3880
3945: oEndChoice
3946: oCall 3986
3948: oCall 3951
3950: oReturn
3951: oLocalSpace 0
3953: oTypeSNodeType
3954: oChoice 3972
3956: oEmit 14
3958: oJumpForward 3985
3960: oEmit 15
3962: oJumpForward 3985
3964: oError 16
3966: oJumpForward 3985
3968: oEmit 16
3970: oJumpForward 3985
3972: Choice Lookup Table
          23   3968
          17   3964
          22   3964
          21   3964
          19   3960
          18   3956
3985: oReturn
3986: oLocalSpace 0
3988: oInputChoice 4002
3990: oCall 4014
3992: oJumpForward 4011
3994: oCall 4157
3996: oJumpForward 4011
3998: oCall 4255
4000: oJumpForward 4011
4002: Choice Lookup Table
          17   3998
          19   3994
          15   3990
4009: oJumpForward 4013
4011: oJumpBack 3988
4013: oReturn
4014: oLocalSpace 3
4016: oTypeSNodeType
4017: oChoice 4021
4019: oJumpForward 4026
4021: Choice Lookup Table
          24   4019
4024: oError 10
4026: oTypeSNodeType
4027: oChoice 4031
4029: oJumpForward 4036
4031: Choice Lookup Table
          24   4029
4034: oError 13
4036: oGetAddrLocal 1
4038: oPushResult
4039: oTypeSTop
4040: oPushResult
4041: oSetResult 23
4043: oPushResult
4044: oNodeGet
4045: oPop 2
4047: oPushResult
4048: oCall 6181
4050: oPop 1
4052: oAssign
4053: oGetAddrLocal 2
4055: oPushResult
4056: oTypeSTop
4057: oPushResult
4058: oSetResult 22
4060: oPushResult
4061: oNodeGet
4062: oPop 2
4064: oAssign
4065: oTypeSPop
4066: oGetLocal 2
4068: oPushResult
4069: oTypeSPush
4070: oPop 1
4072: oCall 2310
4074: oCall 5981
4076: oGetLocal 1
4078: oPushResult
4079: equal_zero
4080: oPop 1
4082: oChoice 4096
4084: oEmit 9
4086: oGetLocal 1
4088: oPushResult
4089: oEmitInt
4090: oPop 1
4092: oEmit 27
4094: oJumpForward 4099
4096: Choice Lookup Table
           0   4084
4099: oGetAddrLocal 3
4101: oPushResult
4102: oGetLocal 2
4104: oPushResult
4105: oSetResult 3
4107: oPushResult
4108: oNodeGetInt
4109: oPop 2
4111: oAssign
4112: oGetLocal 3
4114: oPushResult
4115: oSetResult 1
4117: oPushResult
4118: equal
4119: oPop 2
4121: oChoice 4135
4123: oEmit 9
4125: oGetLocal 3
4127: oPushResult
4128: oEmitInt
4129: oPop 1
4131: oEmit 23
4133: oJumpForward 4138
4135: Choice Lookup Table
           0   4123
4138: oEmit 25
4140: oInputChoice 4148
4142: oJumpForward 4156
4144: oJumpForward 4154
4146: oJumpForward 4154
4148: Choice Lookup Table
          12   4146
          16   4142
4153: oEndChoice
4154: oJumpBack 4026
4156: oReturn
4157: oLocalSpace 2
4159: oTypeSNodeType
4160: oChoice 4164
4162: oJumpForward 4169
4164: Choice Lookup Table
          26   4162
4167: oError 11
4169: oTypeSTop
4170: oPushResult
4171: oSetResult 26
4173: oPushResult
4174: oNodeGet
4175: oPop 2
4177: oPushResult
4178: oScopeEnter
4179: oPop 1
4181: oInput 0
4183: oGetAddrLocal 1
4185: oPushResult
4186: oScopeFindRequire
4187: oAssign
4188: oGetLocal 1
4190: oPushResult
4191: oNodeType
4192: oPop 1
4194: oChoice 4198
4196: oJumpForward 4203
4198: Choice Lookup Table
          14   4196
4201: oError 12
4203: oScopeEnd
4204: oGetAddrLocal 2
4206: oPushResult
4207: oGetLocal 1
4209: oPushResult
4210: oSetResult 8
4212: oPushResult
4213: oNodeGetInt
4214: oPop 2
4216: oAssign
4217: oGetLocal 2
4219: oPushResult
4220: equal_zero
4221: oPop 1
4223: oChoice 4237
4225: oEmit 9
4227: oGetLocal 2
4229: oPushResult
4230: oEmitInt
4231: oPop 1
4233: oEmit 25
4235: oJumpForward 4240
4237: Choice Lookup Table
           0   4225
4240: oTypeSPop
4241: oGetLocal 1
4243: oPushResult
4244: oSetResult 7
4246: oPushResult
4247: oNodeGet
4248: oPop 2
4250: oPushResult
4251: oTypeSPush
4252: oPop 1
4254: oReturn
4255: oLocalSpace 1
4257: oTypeSNodeType
4258: oChoice 4262
4260: oJumpForward 4267
4262: Choice Lookup Table
          23   4260
4265: oError 9
4267: oEmit 16
4269: oGetAddrLocal 1
4271: oPushResult
4272: oTypeSTop
4273: oAssign
4274: oTypeSPop
4275: oGetLocal 1
4277: oPushResult
4278: oSetResult 22
4280: oPushResult
4281: oNodeGet
4282: oPop 2
4284: oPushResult
4285: oTypeSPush
4286: oPop 1
4288: oReturn
4289: oLocalSpace 0
4291: oCall 5955
4293: oReturn
4294: oLocalSpace 2
4296: oGetAddrLocal 2
4298: oPushResult
4299: oGetParam 1
4301: oPushResult
4302: oSetResult 14
4304: oPushResult
4305: oNodeGetString
4306: oPop 2
4308: oAssign
4309: oGetLocal 2
4311: oPushResult
4312: oSetResult 0
4314: oPushResult
4315: equal_string
4316: oPop 2
4318: oChoice 4355
4320: oGetAddrLocal 1
4322: oPushResult
4323: oGetParam 1
4325: oPushResult
4326: oSetResult 6
4328: oPushResult
4329: oNodeGetInt
4330: oPop 2
4332: oPushResult
4333: ID_STRING
4334: oPop 1
4336: oPushResult
4337: oStringAllocLit
4338: oPop 1
4340: oAssign
4341: oJumpForward 4361
4343: oGetAddrLocal 1
4345: oPushResult
4346: oGetLocal 2
4348: oPushResult
4349: oStringAllocLit
4350: oPop 1
4352: oAssign
4353: oJumpForward 4361
4355: Choice Lookup Table
           0   4343
           1   4320
4360: oEndChoice
4361: oEmit 50
4363: oGetParam 1
4365: oPushResult
4366: oCall 6232
4368: oPop 1
4370: oGetLocal 1
4372: oPushResult
4373: oEmitInt
4374: oPop 1
4376: oReturn
4377: oLocalSpace 10
4379: oGetParam 1
4381: oPushResult
4382: oSetResult 13
4384: oPushResult
4385: oNodeGetBoolean
4386: oPop 2
4388: oChoice 4415
4390: oGetParam 1
4392: oPushResult
4393: oSetResult 16
4395: oPushResult
4396: oNodeGetBoolean
4397: oPop 2
4399: oChoice 4410
4401: oGetParam 1
4403: oPushResult
4404: oCall 4294
4406: oPop 1
4408: oJumpForward 4413
4410: Choice Lookup Table
           0   4401
4413: oJumpForward 4418
4415: Choice Lookup Table
           1   4390
4418: oGetParam 1
4420: oPushResult
4421: oSetResult 16
4423: oPushResult
4424: oSetResult 1
4426: oPushResult
4427: oNodeSetBoolean
4428: oPop 3
4430: oGetAddrLocal 1
4432: oPushResult
4433: oGetParam 1
4435: oPushResult
4436: oSetResult 15
4438: oPushResult
4439: oNodeGetBoolean
4440: oPop 2
4442: oAssign
4443: oGetAddrLocal 4
4445: oPushResult
4446: oGetParam 1
4448: oPushResult
4449: oNodeType
4450: oPop 1
4452: oPushResult
4453: oSetResult 8
4455: oPushResult
4456: equal_node_type
4457: oPop 2
4459: oAssign
4460: oGetLocal 4
4462: oChoice 4489
4464: oGetAddrLocal 2
4466: oPushResult
4467: oGetParam 1
4469: oPushResult
4470: oSetResult 7
4472: oPushResult
4473: oNodeGet
4474: oPop 2
4476: oAssign
4477: oGetAddrLocal 3
4479: oPushResult
4480: oGetLocal 2
4482: oPushResult
4483: oScopeAllocType
4484: oPop 1
4486: oAssign
4487: oJumpForward 4492
4489: Choice Lookup Table
           1   4464
4492: oGetAddrLocal 5
4494: oPushResult
4495: oGetParam 1
4497: oPushResult
4498: oSetResult 10
4500: oPushResult
4501: oNodeGet
4502: oPop 2
4504: oAssign
4505: oGetAddrLocal 6
4507: oPushResult
4508: oGetLocal 5
4510: oPushResult
4511: oSetResult 3
4513: oPushResult
4514: oNodeGetInt
4515: oPop 2
4517: oAssign
4518: oGetLocal 1
4520: oChoice 4542
4522: oEmit 39
4524: oGetLocal 6
4526: oPushResult
4527: oEmitInt
4528: oPop 1
4530: oJumpForward 4548
4532: oEmit 38
4534: oGetLocal 6
4536: oPushResult
4537: oEmitInt
4538: oPop 1
4540: oJumpForward 4548
4542: Choice Lookup Table
           0   4532
           1   4522
4547: oEndChoice
4548: oGetAddrLocal 7
4550: oPushResult
4551: oGetLocal 5
4553: oPushResult
4554: oSetResult 2
4556: oPushResult
4557: oNodeGetIter
4558: oPop 2
4560: oAssign
4561: oGetAddrLocal 8
4563: oPushResult
4564: oGetLocal 7
4566: oPushResult
4567: oNodeIterValue
4568: oPop 1
4570: oAssign
4571: oInputChoice 4750
4573: oGetLocal 8
4575: oPushResult
4576: oNodeNull
4577: oPop 1
4579: oChoice 4585
4581: oJumpForward 4746
4583: oJumpForward 4588
4585: Choice Lookup Table
           1   4581
4588: oGetAddrLocal 9
4590: oPushResult
4591: oGetLocal 8
4593: oPushResult
4594: oSetResult 8
4596: oPushResult
4597: oNodeGetInt
4598: oPop 2
4600: oAssign
4601: oEmit 13
4603: oGetLocal 9
4605: oPushResult
4606: oEmitInt
4607: oPop 1
4609: oGetLocal 8
4611: oPushResult
4612: oSetResult 7
4614: oPushResult
4615: oNodeGet
4616: oPop 2
4618: oPushResult
4619: oTypeSPush
4620: oPop 1
4622: oGetLocal 8
4624: oPushResult
4625: oSetResult 20
4627: oPushResult
4628: oNodeGetBoolean
4629: oPop 2
4631: oChoice 4699
4633: oCall 5238
4635: oCall 5955
4637: oEmit 19
4639: oJumpForward 4705
4641: oCall 2310
4643: oCall 4289
4645: oTypeSNodeType
4646: oChoice 4664
4648: oEmit 17
4650: oJumpForward 4697
4652: oEmit 18
4654: oJumpForward 4697
4656: oError 16
4658: oJumpForward 4697
4660: oEmit 19
4662: oJumpForward 4697
4664: Choice Lookup Table
          23   4660
          17   4656
          22   4656
          21   4656
          19   4652
          18   4648
4677: oGetAddrLocal 10
4679: oPushResult
4680: oTypeSTop
4681: oPushResult
4682: oSetResult 3
4684: oPushResult
4685: oNodeGetInt
4686: oPop 2
4688: oAssign
4689: oEmit 20
4691: oGetLocal 10
4693: oPushResult
4694: oEmitInt
4695: oPop 1
4697: oJumpForward 4705
4699: Choice Lookup Table
           0   4641
           1   4633
4704: oEndChoice
4705: oTypeSPop
4706: oGetAddrLocal 7
4708: oPushResult
4709: oNodeIterNext
4710: oPop 1
4712: oGetAddrLocal 8
4714: oPushResult
4715: oGetLocal 7
4717: oPushResult
4718: oNodeIterValue
4719: oPop 1
4721: oAssign
4722: oGetLocal 8
4724: oPushResult
4725: oNodeNull
4726: oPop 1
4728: oChoice 4736
4730: oJumpForward 4746
4732: oJumpForward 4742
4734: oJumpForward 4742
4736: Choice Lookup Table
           0   4734
           1   4730
4741: oEndChoice
4742: oInput 12
4744: oJumpBack 4573
4746: oInput 14
4748: oJumpForward 4753
4750: Choice Lookup Table
          13   4573
4753: oGetLocal 8
4755: oPushResult
4756: oNodeNull
4757: oPop 1
4759: oChoice 4765
4761: oError 15
4763: oJumpForward 4768
4765: Choice Lookup Table
           0   4761
4768: oGetLocal 4
4770: oChoice 4799
4772: oEmit 13
4774: oGetParam 1
4776: oPushResult
4777: oSetResult 19
4779: oPushResult
4780: oNodeGetInt
4781: oPop 2
4783: oPushResult
4784: oEmitInt
4785: oPop 1
4787: oEmit 11
4789: oGetLocal 3
4791: oPushResult
4792: oEmitInt
4793: oPop 1
4795: oEmit 19
4797: oJumpForward 4802
4799: Choice Lookup Table
           1   4772
4802: oGetLocal 1
4804: oChoice 4828
4806: oEmit 42
4808: oGetParam 1
4810: oPushResult
4811: oCall 6232
4813: oPop 1
4815: oJumpForward 4834
4817: oEmit 41
4819: oGetParam 1
4821: oPushResult
4822: oCall 6232
4824: oPop 1
4826: oJumpForward 4834
4828: Choice Lookup Table
           0   4817
           1   4806
4833: oEndChoice
4834: oGetLocal 4
4836: oChoice 4904
4838: oGetLocal 2
4840: oPushResult
4841: oTypeSPush
4842: oPop 1
4844: oTypeSNodeType
4845: oChoice 4881
4847: oEmit 3
4849: oGetLocal 3
4851: oPushResult
4852: oEmitInt
4853: oPop 1
4855: oJumpForward 4902
4857: oEmit 4
4859: oGetLocal 3
4861: oPushResult
4862: oEmitInt
4863: oPop 1
4865: oJumpForward 4902
4867: oError 16
4869: oJumpForward 4902
4871: oEmit 5
4873: oGetLocal 3
4875: oPushResult
4876: oEmitInt
4877: oPop 1
4879: oJumpForward 4902
4881: Choice Lookup Table
          23   4871
          17   4867
          22   4867
          21   4867
          19   4857
          18   4847
4894: oEmit 11
4896: oGetLocal 3
4898: oPushResult
4899: oEmitInt
4900: oPop 1
4902: oJumpForward 4907
4904: Choice Lookup Table
           1   4838
4907: oEmit 40
4909: oGetLocal 6
4911: oPushResult
4912: oEmitInt
4913: oPop 1
4915: oReturn
4916: oLocalSpace 0
4918: oInputChoice 4968
4920: oCall 5875
4922: oJumpForward 4993
4924: oCall 5882
4926: oJumpForward 4993
4928: oCall 5949
4930: oJumpForward 4993
4932: oCall 5952
4934: oJumpForward 4993
4936: oCall 5415
4938: oJumpForward 4993
4940: oCall 5735
4942: oJumpForward 4993
4944: oCall 5481
4946: oJumpForward 4993
4948: oCall 5655
4950: oJumpForward 4993
4952: oCall 5820
4954: oJumpForward 4993
4956: oCall 5788
4958: oJumpForward 4993
4960: oCall 5852
4962: oJumpForward 4993
4964: oCall 4994
4966: oJumpForward 4993
4968: Choice Lookup Table
           0   4964
          33   4960
          49   4956
          50   4952
          47   4948
          42   4944
          46   4940
          39   4936
          57   4932
          56   4928
          55   4924
          54   4920
4993: oReturn
4994: oLocalSpace 1
4996: oGetAddrLocal 1
4998: oPushResult
4999: oScopeFindRequire
5000: oAssign
5001: oGetLocal 1
5003: oPushResult
5004: oNodeType
5005: oPop 1
5007: oChoice 5036
5009: oGetLocal 1
5011: oPushResult
5012: oCall 4377
5014: oPop 1
5016: oJumpForward 5049
5018: oGetLocal 1
5020: oPushResult
5021: oCall 5050
5023: oPop 1
5025: oJumpForward 5049
5027: oGetLocal 1
5029: oPushResult
5030: oCall 5124
5032: oPop 1
5034: oJumpForward 5049
5036: Choice Lookup Table
           8   5027
          15   5018
          13   5018
          12   5018
           7   5009
5047: oError 0
5049: oReturn
5050: oLocalSpace 0
5052: oGetParam 1
5054: oPushResult
5055: oCall 5274
5057: oPop 1
5059: oInput 3
5061: oCall 2310
5063: oCall 5955
5065: oCall 5068
5067: oReturn
5068: oLocalSpace 1
5070: oTypeSNodeType
5071: oChoice 5089
5073: oEmit 17
5075: oJumpForward 5122
5077: oEmit 18
5079: oJumpForward 5122
5081: oError 16
5083: oJumpForward 5122
5085: oEmit 19
5087: oJumpForward 5122
5089: Choice Lookup Table
          23   5085
          17   5081
          22   5081
          21   5081
          19   5077
          18   5073
5102: oGetAddrLocal 1
5104: oPushResult
5105: oTypeSTop
5106: oPushResult
5107: oSetResult 3
5109: oPushResult
5110: oNodeGetInt
5111: oPop 2
5113: oAssign
5114: oEmit 20
5116: oGetLocal 1
5118: oPushResult
5119: oEmitInt
5120: oPop 1
5122: oTypeSPop
5123: oReturn
5124: oLocalSpace 1
5126: oGetParam 1
5128: oPushResult
5129: oSetResult 11
5131: oPushResult
5132: oNodeGet
5133: oPop 2
5135: oPushResult
5136: oScopeCurrent
5137: oPushResult
5138: oNodeEqual
5139: oPop 2
5141: oChoice 5147
5143: oError 20
5145: oJumpForward 5150
5147: Choice Lookup Table
           0   5143
5150: oEmit 8
5152: oGetParam 1
5154: oPushResult
5155: oSetResult 19
5157: oPushResult
5158: oNodeGetInt
5159: oPop 2
5161: oPushResult
5162: oEmitInt
5163: oPop 1
5165: oGetParam 1
5167: oPushResult
5168: oSetResult 7
5170: oPushResult
5171: oNodeGet
5172: oPop 2
5174: oPushResult
5175: oTypeSPush
5176: oPop 1
5178: oInput 3
5180: oCall 2310
5182: oCall 5955
5184: oTypeSNodeType
5185: oChoice 5203
5187: oEmit 17
5189: oJumpForward 5236
5191: oEmit 18
5193: oJumpForward 5236
5195: oError 16
5197: oJumpForward 5236
5199: oEmit 19
5201: oJumpForward 5236
5203: Choice Lookup Table
          23   5199
          17   5195
          22   5195
          21   5195
          19   5191
          18   5187
5216: oGetAddrLocal 1
5218: oPushResult
5219: oTypeSTop
5220: oPushResult
5221: oSetResult 3
5223: oPushResult
5224: oNodeGetInt
5225: oPop 2
5227: oAssign
5228: oEmit 20
5230: oGetLocal 1
5232: oPushResult
5233: oEmitInt
5234: oPop 1
5236: oTypeSPop
5237: oReturn
5238: oLocalSpace 1
5240: oInput 0
5242: oGetAddrLocal 1
5244: oPushResult
5245: oScopeFindRequire
5246: oAssign
5247: oGetLocal 1
5249: oPushResult
5250: oNodeType
5251: oPop 1
5253: oChoice 5257
5255: oJumpForward 5266
5257: Choice Lookup Table
          15   5255
          13   5255
          12   5255
5264: oError 4
5266: oGetLocal 1
5268: oPushResult
5269: oCall 5274
5271: oPop 1
5273: oReturn
5274: oLocalSpace 0
5276: oGetParam 1
5278: oPushResult
5279: oNodeType
5280: oPop 1
5282: oChoice 5342
5284: oEmit 10
5286: oGetParam 1
5288: oPushResult
5289: oCall 6232
5291: oPop 1
5293: oJumpForward 5351
5295: oEmit 11
5297: oGetParam 1
5299: oPushResult
5300: oCall 6232
5302: oPop 1
5304: oJumpForward 5351
5306: oGetParam 1
5308: oPushResult
5309: oSetResult 20
5311: oPushResult
5312: oNodeGetBoolean
5313: oPop 2
5315: oChoice 5328
5317: oEmit 8
5319: oGetParam 1
5321: oPushResult
5322: oCall 6232
5324: oPop 1
5326: oJumpForward 5340
5328: Choice Lookup Table
           1   5317
5331: oEmit 12
5333: oGetParam 1
5335: oPushResult
5336: oCall 6232
5338: oPop 1
5340: oJumpForward 5351
5342: Choice Lookup Table
          15   5306
          13   5295
          12   5284
5349: oError 4
5351: oGetParam 1
5353: oPushResult
5354: oSetResult 7
5356: oPushResult
5357: oNodeGet
5358: oPop 2
5360: oPushResult
5361: oTypeSPush
5362: oPop 1
5364: oCall 3986
5366: oReturn
5367: oLocalSpace 0
5369: oGetParam 1
5371: oPushResult
5372: oCall 5274
5374: oPop 1
5376: oCall 5981
5378: oGetParam 1
5380: oPushResult
5381: oCall 3572
5383: oPop 1
5385: oTypeSPop
5386: oEmit 21
5388: oEmit 17
5390: oReturn
5391: oLocalSpace 0
5393: oGetParam 1
5395: oPushResult
5396: oCall 5274
5398: oPop 1
5400: oCall 5981
5402: oGetParam 1
5404: oPushResult
5405: oCall 3572
5407: oPop 1
5409: oTypeSPop
5410: oEmit 22
5412: oEmit 17
5414: oReturn
5415: oLocalSpace 2
5417: oGetAddrLocal 1
5419: oPushResult
5420: oSetResult 0
5422: oAssign
5423: oGetAddrLocal 1
5425: oPushResult
5426: oCall 2333
5428: oPop 1
5430: oInput 40
5432: oCall 4916
5434: oInputChoice 5469
5436: oGetAddrLocal 2
5438: oPushResult
5439: oLabelNew
5440: oAssign
5441: oEmit 45
5443: oGetLocal 2
5445: oPushResult
5446: oEmitLabel
5447: oPop 1
5449: oEmit 48
5451: oGetLocal 1
5453: oPushResult
5454: oEmitLabel
5455: oPop 1
5457: oCall 4916
5459: oEmit 48
5461: oGetLocal 2
5463: oPushResult
5464: oEmitLabel
5465: oPop 1
5467: oJumpForward 5480
5469: Choice Lookup Table
          41   5436
5472: oEmit 48
5474: oGetLocal 1
5476: oPushResult
5477: oEmitLabel
5478: oPop 1
5480: oReturn
5481: oLocalSpace 4
5483: oInput 0
5485: oGetAddrLocal 1
5487: oPushResult
5488: oScopeFindRequire
5489: oAssign
5490: oGetLocal 1
5492: oPushResult
5493: oCall 5274
5495: oPop 1
5497: oCall 5981
5499: oInput 3
5501: oCall 2310
5503: oCall 5981
5505: oEmit 17
5507: oGetAddrLocal 2
5509: oPushResult
5510: oLabelNew
5511: oAssign
5512: oGetAddrLocal 3
5514: oPushResult
5515: oLabelNew
5516: oAssign
5517: oEmit 45
5519: oGetLocal 3
5521: oPushResult
5522: oEmitLabel
5523: oPop 1
5525: oGetAddrLocal 4
5527: oPushResult
5528: oLabelNew
5529: oAssign
5530: oEmit 48
5532: oGetLocal 4
5534: oPushResult
5535: oEmitLabel
5536: oPop 1
5538: oInputChoice 5618
5540: oGetLocal 1
5542: oPushResult
5543: oCall 5367
5545: oPop 1
5547: oEmit 48
5549: oGetLocal 3
5551: oPushResult
5552: oEmitLabel
5553: oPop 1
5555: oGetLocal 1
5557: oPushResult
5558: oCall 3572
5560: oPop 1
5562: oTypeSPop
5563: oCall 2310
5565: oCall 5981
5567: oEmit 32
5569: oEmit 46
5571: oGetLocal 2
5573: oPushResult
5574: oEmitLabel
5575: oPop 1
5577: oJumpForward 5624
5579: oGetLocal 1
5581: oPushResult
5582: oCall 5391
5584: oPop 1
5586: oEmit 48
5588: oGetLocal 3
5590: oPushResult
5591: oEmitLabel
5592: oPop 1
5594: oGetLocal 1
5596: oPushResult
5597: oCall 3572
5599: oPop 1
5601: oTypeSPop
5602: oCall 2310
5604: oCall 5981
5606: oEmit 33
5608: oEmit 46
5610: oGetLocal 2
5612: oPushResult
5613: oEmitLabel
5614: oPop 1
5616: oJumpForward 5624
5618: Choice Lookup Table
          44   5579
          43   5540
5623: oEndChoice
5624: oGetLocal 4
5626: oPushResult
5627: oGetLocal 2
5629: oPushResult
5630: oLoopPush
5631: oPop 2
5633: oInput 45
5635: oCall 4916
5637: oEmit 45
5639: oGetLocal 4
5641: oPushResult
5642: oEmitLabel
5643: oPop 1
5645: oEmit 48
5647: oGetLocal 2
5649: oPushResult
5650: oEmitLabel
5651: oPop 1
5653: oLoopPop
5654: oReturn
5655: oLocalSpace 3
5657: oGetAddrLocal 1
5659: oPushResult
5660: oLabelNew
5661: oAssign
5662: oEmit 48
5664: oGetLocal 1
5666: oPushResult
5667: oEmitLabel
5668: oPop 1
5670: oGetAddrLocal 2
5672: oPushResult
5673: oLabelNew
5674: oAssign
5675: oGetLocal 1
5677: oPushResult
5678: oGetLocal 2
5680: oPushResult
5681: oLoopPush
5682: oPop 2
5684: oCall 4916
5686: oInputChoice 5717
5688: oCall 4916
5690: oJumpForward 5723
5692: oGetAddrLocal 3
5694: oPushResult
5695: oCall 2333
5697: oPop 1
5699: oEmit 49
5701: oGetLocal 3
5703: oPushResult
5704: oEmitLabel
5705: oPop 1
5707: oGetLocal 1
5709: oPushResult
5710: oEmitLabel
5711: oPop 1
5713: oJumpForward 5725
5715: oJumpForward 5723
5717: Choice Lookup Table
          48   5692
           4   5688
5722: oEndChoice
5723: oJumpBack 5686
5725: oEmit 48
5727: oGetLocal 2
5729: oPushResult
5730: oEmitLabel
5731: oPop 1
5733: oLoopPop
5734: oReturn
5735: oLocalSpace 2
5737: oGetAddrLocal 1
5739: oPushResult
5740: oLabelNew
5741: oAssign
5742: oEmit 48
5744: oGetLocal 1
5746: oPushResult
5747: oEmitLabel
5748: oPop 1
5750: oGetAddrLocal 2
5752: oPushResult
5753: oCall 2333
5755: oPop 1
5757: oGetLocal 1
5759: oPushResult
5760: oGetLocal 2
5762: oPushResult
5763: oLoopPush
5764: oPop 2
5766: oInput 45
5768: oCall 4916
5770: oEmit 45
5772: oGetLocal 1
5774: oPushResult
5775: oEmitLabel
5776: oPop 1
5778: oEmit 48
5780: oGetLocal 2
5782: oPushResult
5783: oEmitLabel
5784: oPop 1
5786: oLoopPop
5787: oReturn
5788: oLocalSpace 0
5790: oLoopContinueLabel
5791: oPushResult
5792: oSetResult 0
5794: oPushResult
5795: equal_label
5796: oPop 2
5798: oChoice 5813
5800: oError 18
5802: oJumpForward 5819
5804: oEmit 45
5806: oLoopContinueLabel
5807: oPushResult
5808: oEmitLabel
5809: oPop 1
5811: oJumpForward 5819
5813: Choice Lookup Table
           0   5804
           1   5800
5818: oEndChoice
5819: oReturn
5820: oLocalSpace 0
5822: oLoopBreakLabel
5823: oPushResult
5824: oSetResult 0
5826: oPushResult
5827: equal_label
5828: oPop 2
5830: oChoice 5845
5832: oError 18
5834: oJumpForward 5851
5836: oEmit 45
5838: oLoopBreakLabel
5839: oPushResult
5840: oEmitLabel
5841: oPop 1
5843: oJumpForward 5851
5845: Choice Lookup Table
           0   5836
           1   5832
5850: oEndChoice
5851: oReturn
5852: oLocalSpace 0
5854: oCall 4916
5856: oInputChoice 5866
5858: oCall 4916
5860: oJumpForward 5872
5862: oJumpForward 5874
5864: oJumpForward 5872
5866: Choice Lookup Table
          34   5862
           4   5858
5871: oEndChoice
5872: oJumpBack 5856
5874: oReturn
5875: oLocalSpace 0
5877: oCall 5882
5879: oEmit 55
5881: oReturn
5882: oLocalSpace 0
5884: oInputChoice 5945
5886: oCall 2310
5888: oTypeSNodeType
5889: oChoice 5911
5891: oEmit 51
5893: oJumpForward 5926
5895: oEmit 52
5897: oJumpForward 5926
5899: oEmit 53
5901: oJumpForward 5926
5903: oError 16
5905: oJumpForward 5926
5907: oEmit 54
5909: oJumpForward 5926
5911: Choice Lookup Table
          23   5907
          17   5903
          21   5903
          22   5899
          19   5895
          18   5891
5924: oError 17
5926: oTypeSPop
5927: oInputChoice 5935
5929: oJumpForward 5943
5931: oJumpForward 5941
5933: oJumpForward 5941
5935: Choice Lookup Table
          12   5933
          14   5929
5940: oEndChoice
5941: oJumpBack 5886
5943: oJumpForward 5948
5945: Choice Lookup Table
          13   5886
5948: oReturn
5949: oLocalSpace 0
5951: oReturn
5952: oLocalSpace 0
5954: oReturn
5955: oLocalSpace 1
5957: oGetAddrLocal 1
5959: oPushResult
5960: oTypeSNodeType
5961: oAssign
5962: oTypeSPop
5963: oGetLocal 1
5965: oPushResult
5966: oTypeSNodeType
5967: oPushResult
5968: equal_node_type
5969: oPop 2
5971: oChoice 5977
5973: oError 14
5975: oJumpForward 5980
5977: Choice Lookup Table
           0   5973
5980: oReturn
5981: oLocalSpace 0
5983: oTypeSNodeType
5984: oChoice 5988
5986: oJumpForward 5993
5988: Choice Lookup Table
          18   5986
5991: oError 7
5993: oTypeSPop
5994: oReturn
5995: oLocalSpace 0
5997: oTypeSNodeType
5998: oChoice 6002
6000: oJumpForward 6007
6002: Choice Lookup Table
          18   6000
6005: oError 7
6007: oReturn
6008: oLocalSpace 0
6010: oTypeSNodeType
6011: oChoice 6015
6013: oJumpForward 6020
6015: Choice Lookup Table
          19   6013
6018: oError 8
6020: oTypeSPop
6021: oReturn
6022: oLocalSpace 0
6024: oTypeSNodeType
6025: oChoice 6029
6027: oJumpForward 6034
6029: Choice Lookup Table
          19   6027
6032: oError 8
6034: oReturn
6035: oLocalSpace 1
6037: oGetAddrLocal 1
6039: oPushResult
6040: oGetParam 2
6042: oPushResult
6043: oNodeNew
6044: oPop 1
6046: oAssign
6047: oGetLocal 1
6049: oPushResult
6050: oSetResult 3
6052: oPushResult
6053: oGetParam 1
6055: oPushResult
6056: oNodeSetInt
6057: oPop 3
6059: oGetLocal 1
6061: oPushResult
6062: oTypeAdd
6063: oPop 1
6065: oGetLocal 1
6067: oReturn
6068: oReturn
6069: oLocalSpace 1
6071: oGetAddrLocal 1
6073: oPushResult
6074: oGetParam 3
6076: oPushResult
6077: oNodeNew
6078: oPop 1
6080: oAssign
6081: oGetLocal 1
6083: oPushResult
6084: oSetResult 6
6086: oPushResult
6087: oGetParam 1
6089: oPushResult
6090: oNodeSetInt
6091: oPop 3
6093: oGetLocal 1
6095: oReturn
6096: oReturn
6097: oLocalSpace 1
6099: oGetAddrLocal 1
6101: oPushResult
6102: oGetParam 1
6104: oPushResult
6105: oSetResult 21
6107: oPushResult
6108: oNodeGet
6109: oPop 2
6111: oAssign
6112: oGetLocal 1
6114: oPushResult
6115: oNodeNull
6116: oPop 1
6118: oChoice 6174
6120: oGetAddrLocal 1
6122: oPushResult
6123: oSetResult 23
6125: oPushResult
6126: oNodeNew
6127: oPop 1
6129: oAssign
6130: oGetLocal 1
6132: oPushResult
6133: oSetResult 22
6135: oPushResult
6136: oGetParam 1
6138: oPushResult
6139: oNodeSet
6140: oPop 3
6142: oGetLocal 1
6144: oPushResult
6145: oSetResult 3
6147: oPushResult
6148: oSetResult 8
6150: oPushResult
6151: oNodeSetInt
6152: oPop 3
6154: oGetLocal 1
6156: oPushResult
6157: oTypeAdd
6158: oPop 1
6160: oGetParam 1
6162: oPushResult
6163: oSetResult 21
6165: oPushResult
6166: oGetLocal 1
6168: oPushResult
6169: oNodeSet
6170: oPop 3
6172: oJumpForward 6177
6174: Choice Lookup Table
           1   6120
6177: oGetLocal 1
6179: oReturn
6180: oReturn
6181: oLocalSpace 0
6183: oGetParam 1
6185: oPushResult
6186: oNodeType
6187: oPop 1
6189: oChoice 6217
6191: oMININT
6192: oReturn
6193: oJumpForward 6231
6195: oSetResult 0
6197: oReturn
6198: oJumpForward 6231
6200: oSetResult 0
6202: oReturn
6203: oJumpForward 6231
6205: oGetParam 1
6207: oPushResult
6208: oSetResult 24
6210: oPushResult
6211: oNodeGetInt
6212: oPop 2
6214: oReturn
6215: oJumpForward 6231
6217: Choice Lookup Table
          25   6205
          21   6200
          19   6195
          18   6191
6226: oError 3
6228: oSetResult 0
6230: oReturn
6231: oReturn
6232: oLocalSpace 0
6234: oGetParam 1
6236: oPushResult
6237: oSetResult 8
6239: oPushResult
6240: oNodeGetInt
6241: oPop 2
6243: oPushResult
6244: oEmitInt
6245: oPop 1
6247: oReturn
6248: oLocalSpace 1
6250: oGetAddrGlobal 3
6252: oPushResult
6253: oSetResult 17
6255: oPushResult
6256: oSetResult 4
6258: oPushResult
6259: oCall 6035
6261: oPop 2
6263: oAssign
6264: oGetAddrGlobal 4
6266: oPushResult
6267: oSetResult 18
6269: oPushResult
6270: oSetResult 4
6272: oPushResult
6273: oCall 6035
6275: oPop 2
6277: oAssign
6278: oGetAddrGlobal 5
6280: oPushResult
6281: oSetResult 19
6283: oPushResult
6284: oSetResult 1
6286: oPushResult
6287: oCall 6035
6289: oPop 2
6291: oAssign
6292: oGetAddrGlobal 6
6294: oPushResult
6295: oSetResult 20
6297: oPushResult
6298: oSetResult 1
6300: oPushResult
6301: oCall 6035
6303: oPop 2
6305: oAssign
6306: oGetAddrGlobal 7
6308: oPushResult
6309: oSetResult 21
6311: oPushResult
6312: oSetResult 1
6314: oPushResult
6315: oCall 6035
6317: oPop 2
6319: oAssign
6320: oGetAddrGlobal 8
6322: oPushResult
6323: oSetResult 22
6325: oPushResult
6326: oSetResult 256
6328: oPushResult
6329: oCall 6035
6331: oPop 2
6333: oAssign
6334: oGetAddrLocal 1
6336: oPushResult
6337: oSetResult 10
6339: oPushResult
6340: oSetResult 5
6342: oPushResult
6343: oIdAdd_File
6344: oPushResult
6345: oCall 6069
6347: oPop 3
6349: oAssign
6350: oGetLocal 1
6352: oPushResult
6353: oSetResult 7
6355: oPushResult
6356: oGetGlobal 3
6358: oPushResult
6359: oNodeSet
6360: oPop 3
6362: oGetLocal 1
6364: oPushResult
6365: oScopeDeclare
6366: oPop 1
6368: oGetAddrLocal 1
6370: oPushResult
6371: oSetResult 10
6373: oPushResult
6374: oSetResult 5
6376: oPushResult
6377: oIdAdd_Integer
6378: oPushResult
6379: oCall 6069
6381: oPop 3
6383: oAssign
6384: oGetLocal 1
6386: oPushResult
6387: oSetResult 7
6389: oPushResult
6390: oGetGlobal 4
6392: oPushResult
6393: oNodeSet
6394: oPop 3
6396: oGetLocal 1
6398: oPushResult
6399: oScopeDeclare
6400: oPop 1
6402: oGetAddrLocal 1
6404: oPushResult
6405: oSetResult 10
6407: oPushResult
6408: oSetResult 5
6410: oPushResult
6411: oIdAdd_Boolean
6412: oPushResult
6413: oCall 6069
6415: oPop 3
6417: oAssign
6418: oGetLocal 1
6420: oPushResult
6421: oSetResult 7
6423: oPushResult
6424: oGetGlobal 5
6426: oPushResult
6427: oNodeSet
6428: oPop 3
6430: oGetLocal 1
6432: oPushResult
6433: oScopeDeclare
6434: oPop 1
6436: oGetAddrLocal 1
6438: oPushResult
6439: oSetResult 10
6441: oPushResult
6442: oSetResult 5
6444: oPushResult
6445: oIdAdd_Char
6446: oPushResult
6447: oCall 6069
6449: oPop 3
6451: oAssign
6452: oGetLocal 1
6454: oPushResult
6455: oSetResult 7
6457: oPushResult
6458: oGetGlobal 7
6460: oPushResult
6461: oNodeSet
6462: oPop 3
6464: oGetLocal 1
6466: oPushResult
6467: oScopeDeclare
6468: oPop 1
6470: oGetAddrLocal 1
6472: oPushResult
6473: oSetResult 10
6475: oPushResult
6476: oSetResult 5
6478: oPushResult
6479: oIdAdd_String
6480: oPushResult
6481: oCall 6069
6483: oPop 3
6485: oAssign
6486: oGetLocal 1
6488: oPushResult
6489: oSetResult 7
6491: oPushResult
6492: oGetGlobal 8
6494: oPushResult
6495: oNodeSet
6496: oPop 3
6498: oGetLocal 1
6500: oPushResult
6501: oScopeDeclare
6502: oPop 1
6504: oGetAddrLocal 1
6506: oPushResult
6507: oSetResult 9
6509: oPushResult
6510: oSetResult 4
6512: oPushResult
6513: oIdAdd_True
6514: oPushResult
6515: oCall 6069
6517: oPop 3
6519: oAssign
6520: oGetLocal 1
6522: oPushResult
6523: oSetResult 7
6525: oPushResult
6526: oGetGlobal 5
6528: oPushResult
6529: oNodeSet
6530: oPop 3
6532: oGetLocal 1
6534: oPushResult
6535: oSetResult 8
6537: oPushResult
6538: oSetResult 1
6540: oPushResult
6541: oNodeSetInt
6542: oPop 3
6544: oGetLocal 1
6546: oPushResult
6547: oScopeDeclare
6548: oPop 1
6550: oGetAddrLocal 1
6552: oPushResult
6553: oSetResult 9
6555: oPushResult
6556: oSetResult 4
6558: oPushResult
6559: oIdAdd_False
6560: oPushResult
6561: oCall 6069
6563: oPop 3
6565: oAssign
6566: oGetLocal 1
6568: oPushResult
6569: oSetResult 7
6571: oPushResult
6572: oGetGlobal 5
6574: oPushResult
6575: oNodeSet
6576: oPop 3
6578: oGetLocal 1
6580: oPushResult
6581: oSetResult 8
6583: oPushResult
6584: oSetResult 0
6586: oPushResult
6587: oNodeSetInt
6588: oPop 3
6590: oGetLocal 1
6592: oPushResult
6593: oScopeDeclare
6594: oPop 1
6596: oReturn
