   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % addr follows
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, out int addr );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( out int addr );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node progDecl
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    int patchCallMain
  12:    .tCall  patchCallMain = Here  .tSpace
  21:    .tReturn
      
  23:    pProgram
  25:    pIdent
      
  27:    progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  43:    oScopeDeclare( progDecl )
      
  49:    [
  49:       | '(' :
  51:          pIdent      % input, output files
      
  53:          t = @newIdent( nVar, kVar, LAST_ID )
  69:          oNodeSet( t, qType, FileType )
  81:          oScopeDeclareAlloc( t )
      
  87:          ','
  89:          pIdent
      
  91:          t = @newIdent( nVar, kVar, LAST_ID )
 107:          oNodeSet( t, qType, FileType )
 119:          oScopeDeclareAlloc( t )
      
 125:          ')'
 127:       | * :
 132:    ]
 132:    ';'
      
 134:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 141:    oScopeBegin
 142:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 153:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 164:    int addr
 164:    @BlockStmt( addr )
      
 171:    oScopeEnd   % main routine scope
      
 172:    oPatch( patchCallMain, addr )
      
 181:    '.'
 183:    oScopeEnd   % global scope
 185:    ;
      
      
      % Returns the addr of the block's statements.
      % This might differ from the Here on entry to this rule,
      % due to method declarations in the block.
      %
 185: Block( node_type varNodeType, out int addr ):
 187:    @BlockDecls( varNodeType )
 194:    @BlockStmt( addr )
 202:    ;
      
      
 202: BlockDecls( node_type varNodeType ):
 204:    {[
 204:       | pConst :     @ConstDecl
 208:       | pType :      @TypeDecl
 212:       | pVar :       @VarDecl( varNodeType )
 221:       | pProcedure : @ProcDecl
 225:       | pFunction :  @FuncDecl
 229:       | * :          >
 244:    ]};
      
      
 247: BlockStmt( out int addr ):
 249:    addr = Here
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 254:    int patchLS
 254:    .tEnter  patchLS = Here  .tSpace
      
 263:    @Statement
 265:    .tReturn
      
 267:    int localSpace
 267:    localSpace = oNodeGetInt( oScopeCurrent, qSize )
 279:    oPatch( patchLS, localSpace )
 289:    ;
      
      
      
 289: ProcDecl:
 291:    Node decl
      
 291:    pIdent
 293:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 309:    oScopeBegin
 310:    Node paramScope
 310:    paramScope = oScopeCurrent
      
 315:    @FormalArgDecl
 317:    oNodeSet( decl, qParams, paramScope )
 329:    oScopeEnd
      
 330:    oScopeDeclare( decl )
 336:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 338:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 344:    oScopeBegin
 345:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 356:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 367:    int addr
 367:    @Block( nLocalVar, addr )
 377:    oNodeSetInt( decl, qValue, addr )
 389:    oNodeSetBoolean( decl, qAddrDefined, true )
 401:    oScopeEnd
      
 402:    oScopeEnd  % paramScope
 403:    ';';
      
 406: FuncDecl:
 408:    Node decl
 408:    Node theType
      
 408:    pIdent
 410:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 426:    oScopeBegin
 427:    Node paramScope
 427:    paramScope = oScopeCurrent
      
 432:    @FormalArgDecl
 434:    oNodeSet( decl, qParams, paramScope )
      
 446:    ':'
      
 448:    @TypeRef( theType )
 455:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 467:    Node ptrType
 467:    ptrType = @PointerTypeTo( theType )
 478:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
      
 494:    ';'
      
 496:    oScopeEnd
 497:    oScopeDeclare( decl )
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 503:    oScopeEnter( paramScope )
      
 509:    oScopeBegin
 510:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 521:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 532:    int addr
 532:    @Block( nLocalVar, addr )
 542:    oNodeSetInt( decl, qValue, addr )
 554:    oNodeSetBoolean( decl, qAddrDefined, true )
 566:    oScopeEnd
      
 567:    oScopeEnd  % paramScope
 568:    ';';
      
      
 571: FormalArgDecl:
 573:    [
 573:       | '(' :
 575:          {
 575:             NodeVec decls
 575:             decls = oNodeVecNew
 580:             Node decl
 580:             boolean isInOut
 580:             isInOut = false
      
 586:             [
 586:                | pVar : isInOut = true
 594:                | * :
 599:             ]
      
 599:             {  pIdent
      
 601:                decl = @newIdent( nParam, kVar, LAST_ID )
 617:                oNodeSetBoolean( decl, qInOut, isInOut )
 629:                oNodeVecAppend( decls, decl )
      
 638:                [
 638:                   | ':' : >
 642:                   | ',' :
 644:                ]
 652:             }
      
 654:             Node theType
 654:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 661:             Node allocType
 661:             [ isInOut
 664:                | true :   allocType = @PointerTypeTo( theType )
 676:                | * :      allocType = theType
 687:             ]
      
 687:             int i
 687:             i = 0
 693:             {[ equal( i, oNodeVecSize( decls ) )
 707:                | false :
 708:                   decl = oNodeVecElement( decls, i )
      
 721:                   oNodeSet( decl, qType, theType )
 733:                   oScopeDeclare( decl )
 739:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 755:                   inc( i )
 761:                | * :
 766:                   >
 768:             ]}
      
 770:             oNodeVecDelete( decls )
      
 776:             [
 776:                | ')' : >
 780:                | ';' :
 782:             ]
 790:          }
 792:       | * :
 797:    ];
      
 798: ConstDecl:
 800:    {[
 800:       | pIdent :
 802:          Node decl
 802:          decl = @newIdent( nConst, kConst, LAST_ID )
 818:          '='
      
 820:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 822:          int val
 822:          val = oValueTop
 827:          oValuePop
 828:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 840:          oNodeSet( decl, qType, IntegerType )
      
 852:          oScopeDeclare( decl )
 858:          ';'
 860:       | * :
 865:          >
 867:    ]};
      
 870: TypeDecl:
 872:    {[
 872:       | pIdent :
 874:          Node decl
 874:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 890:          '='
 892:          Node theType
 892:          @TypeRef( theType )
 899:          oNodeSet( decl, qType, theType )
 911:          oScopeDeclare( decl )
 917:          ';'
 919:       | * :
 924:          >
 926:    ]};
      
 929: VarDecl( node_type varNodeType ):
 931:    {[
 931:       | pIdent :
 933:          NodeVec decls
 933:          decls = oNodeVecNew
 938:          Node decl
 938:          {
 938:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 954:             oNodeVecAppend( decls, decl )
 963:             [
 963:                | ',' :
 965:                   pIdent
 967:                | * :
 972:                   >
 974:             ]
 974:          }
 976:          ':'
 978:          Node theType
 978:          @TypeRef( theType )
      
 985:          int i
 985:          i = 0
 991:          {[ equal( i, oNodeVecSize( decls ) )
1005:            | false :
1006:              decl = oNodeVecElement( decls, i )
1019:              oNodeSet( decl, qType, theType )
1031:              oScopeDeclareAlloc( decl )
1037:              inc( i )
1043:             | * :
1048:               >
1050:          ]}
      
1052:          oNodeVecDelete( decls )
1058:          ';'
1060:       | * :
1065:          >
1067:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1070: TypeRef( out Node resultType ):
1072:    [
1072:       | pIdent :           % previously named type (including intrinsics)
1074:          Node decl
1074:          decl = oScopeFindRequire
1079:          [ oNodeType( decl )
1086:            | nTypeDecl :
1087:                resultType = oNodeGet( decl, qType )
1100:            | * :
1105:                #eNotType
1107:                resultType = IntegerType
1113:          ]
         
1113:       | pArray :
1115:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1117:          NodeVec dimensions
1117:          dimensions = oNodeVecNew
      
1122:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1122:             Node subrange
1122:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1132:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1144:             @ConstExpr
1146:             oNodeSetInt( subrange, qLow, oValueTop )
1157:             oValuePop
1158:             '..'
1160:             @ConstExpr
1162:             oNodeSetInt( subrange, qHigh, oValueTop )
1173:             oValuePop
1174:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1186:             oTypeAdd( subrange )
      
1192:             Node a
1192:             a = oNodeNew( nArrayType )
1202:             oNodeSet( a, qIndexType, subrange )
      
1214:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1223:             [
1223:                | ']' : >
1227:                | ',' :
1229:             ]
1237:          }
1239:          pOf
1241:          Node baseType
1241:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1248:          int dim
1248:          dim = oNodeVecSize( dimensions )
1258:          {
1258:              dec(dim)
      
1264:              Node a
1264:              a = oNodeVecElement( dimensions, dim )
1277:              oNodeSet( a, qBaseType, baseType )
1289:              Node subrange
1289:              subrange = oNodeGet( a, qIndexType )
1302:              int width
1302:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1329:              inc( width )
1335:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1361:              oTypeAdd( a )
1367:              baseType = a
      
1373:              [ equal_zero(dim)
1380:                  | true:  >
1383:                  | *:
1388:              ]
1388:          }
      
1390:          resultType = oNodeVecElement( dimensions, 0 )
1403:          oNodeVecDelete( dimensions )
      
1409:       | '^' :
1411:          Node theType
1411:          @TypeRef( theType )
1418:          resultType = @PointerTypeTo( theType )
      
1429:       | pRecord :
1431:          resultType = oNodeNew( nRecordType )
1441:          oScopeBegin
      
1442:          @VarDecl( nRecordField )
      
1449:          int size
1449:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1461:          [ equal_zero( size )
1468:             | true : #eRecordEmpty
1471:             | * :
1476:          ]
      
1476:          pEnd
      
1478:          oNodeSet( resultType, qScope, oScopeCurrent )
1489:          oNodeSetInt( resultType, qSize, size )
1501:          oScopeEnd
1502:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1508:       | pSet :
1510:          pOf
1512:          Node theType
1512:          @TypeRef( theType )
1519:       | * :       % this works for cases except where expr starts with an id
1532:          @ConstExpr '..' @ConstExpr
1538:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1539: ConstExpr:
1541:    [
1541:       | pIntLit :
1543:          oValuePush( TOKEN_VALUE )
1548:       | pIdent :
1550:          Node decl
1550:          decl = oScopeFindRequire
1555:          [ oNodeType( decl )
1562:             | nConst :
1563:                oValuePush( oNodeGetInt( decl, qValue ) )
1576:             | * :
1581:                #eNotConst
1583:                oValuePush( 0 )
1589:          ]
1589:       | pMinus :
1591:          @ConstExpr
1593:          oValueNegate
1594:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1605: Expr:
1607:    @BoolExpr
1609:    {[
1609:       | '=' :
1611:          @BoolExpr
1613:          @MatchTypes
1615:          [ oTypeSNodeType
1617:             | nIntegerType, nBooleanType :  .tEqualI
1620:             | nPointerType :                .tEqualP
1624:             | nCharType, nStringType :      #eNotImplemented
1628:             | * :                           #eNotAllowed
1643:          ]
1643:          oTypeSPop
1644:          oTypeSPush( BooleanType )
      
1650:       | '<>' :
1652:          @BoolExpr
1654:          @MatchTypes
1656:          [ oTypeSNodeType
1658:             | nIntegerType, nBooleanType :  .tNotEqualI
1661:             | nPointerType :                .tNotEqualP
1665:             | nCharType, nStringType :      #eNotImplemented
1669:             | * :                           #eNotAllowed
1684:          ]
1684:          oTypeSPop
1685:          oTypeSPush( BooleanType )
      
1691:       | '<' :
1693:          @BoolExpr
1695:          @MatchTypes
1697:          [ oTypeSNodeType
1699:             | nIntegerType, nBooleanType :  .tLessI
1702:             | nCharType, nStringType :      #eNotImplemented
1706:             | * :                           #eNotAllowed
1719:          ]
1719:          oTypeSPop
1720:          oTypeSPush( BooleanType )
      
1726:       | '>' :
1728:          @BoolExpr
1730:          @MatchTypes
1732:          [ oTypeSNodeType
1734:             | nIntegerType, nBooleanType :  .tGreaterI
1737:             | nCharType, nStringType :      #eNotImplemented
1741:             | * :                           #eNotAllowed
1754:          ]
1754:          oTypeSPop
1755:          oTypeSPush( BooleanType )
      
1761:       | '<=' :
1763:          @BoolExpr
1765:          @MatchTypes
1767:          [ oTypeSNodeType
1769:             | nIntegerType, nBooleanType :  .tLessEqualI
1772:             | nCharType, nStringType :      #eNotImplemented
1776:             | * :                           #eNotAllowed
1789:          ]
1789:          oTypeSPop
1790:          oTypeSPush( BooleanType )
      
1796:       | '>=' :
1798:          @BoolExpr
1800:          @MatchTypes
1802:          [ oTypeSNodeType
1804:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1807:             | nCharType, nStringType :      #eNotImplemented
1811:             | * :                           #eNotAllowed
1824:          ]
1824:          oTypeSPop
1825:          oTypeSPush( BooleanType )
      
1831:       | * :
1846:          >
1848:    ]};
      
1851: BoolExpr:
1853:    @BoolTerm
1855:    {[
1855:       | pOr :
1857:          @RequireBoolPop
1859:          @BoolTerm
1861:          @RequireBool
1863:          .tOr
1865:       | * :
1870:          >
1872:    ]};
      
1875: BoolTerm:
1877:    @BoolFactor
1879:    {[
1879:       | pAnd :
1881:          @RequireBoolPop
1883:          @BoolFactor
1885:          @RequireBool
1887:          .tAnd
1889:       | * :
1894:          >
1896:    ]};
      
1899: BoolFactor:
1901:    [
1901:       | pNot :
1903:          @ArithExpr
1905:          @RequireBool
1907:          .tNot
1909:       | * :
1914:          @ArithExpr
1916:    ];
      
1917: ArithExpr:
1919:    @Term
1921:    {[
1921:       | pPlus :
1923:          @RequireIntPop
1925:          @Term
1927:          @RequireInt
1929:          .tAddI
1931:       | pMinus :
1933:          @RequireIntPop
1935:          @Term
1937:          @RequireInt
1939:          .tSubI
1941:       | * :
1948:          >
1950:    ]};
      
1953: Term:
1955:    @Factor
1957:    {[
1957:       | pTimes :
1959:          @RequireIntPop
1961:          @Factor
1963:          @RequireInt
1965:          .tMultI
1967:       | pDivide :
1969:          @RequireIntPop
1971:          @Factor
1973:          @RequireInt
1975:          .tDivI
1977:       | * :
1984:          >
1986:    ]};
      
1989: Factor:
1991:    [
1991:       | pPlus :
1993:          @Primary
1995:          @RequireInt
1997:       | pMinus :
1999:          @Primary
2001:          @RequireInt
2003:          .tNegI
2005:       | * :
2012:          @Primary
2014:    ];
      
2015: Primary:
2017:    [
2017:       | pIntLit :
2019:          .tPushConstI  oEmitInt( TOKEN_VALUE )
2026:          oTypeSPush( IntegerType )
      
2032:       | '(' :
2034:          @Expr
2036:          ')'
      
2038:       | pStrLit :
2040:          oStringAllocLit     % store in global data, push offset on value stack
2041:          .tPushAddrGlobal oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2049:          oTypeSPush( StringType )
      
2055:       | pIdent :
2057:          Node decl
2057:          Node theType
2057:          decl = oScopeFindRequire
      
2062:          [ oNodeType( decl )
2069:             | nFunc :
      
2070:                @Call( decl )
      
2077:             | nConst :
2079:                theType = oNodeGet( decl, qType )
2092:                oTypeSPush( theType )
2098:                [ oTypeSNodeType
2100:                   | nIntegerType, nBooleanType :
2101:                      .tPushConstI @EmitValue( decl )
2110:                   | * :
2117:                      #eNotImplemented
2119:                ]
      
2119:             | nGlobalVar, nLocalVar, nParam :
2121:                @VarExpr( decl )
      
2128:             | * :
2141:                #eNotValue
2143:                oTypeSPush( IntegerType )
2149:          ]
      
2149:       | '^' :        % ^var
2151:          pIdent
      
2153:          Node decl
2153:          Node theType
2153:          decl = oScopeFindRequire
      
2158:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2165:          theType = oTypeSTop
2170:          oTypeSPop
2171:          Node ptrType
2171:          ptrType = @PointerTypeTo( theType )
2182:          oTypeSPush( ptrType )
      
2188:       | * :
2201:          #eNotValue
2203:          oTypeSPush( IntegerType )
2209:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2210: VarExpr( Node decl ):
2212:    Node theType
2212:    theType = oNodeGet( decl, qType )
2225:    oTypeSPush( theType )
2231:    [ oTypeSNodeType
2233:       | nIntegerType :
2234:          [ oNodeType( decl )
2241:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2251:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2262:             | nParam :
2264:                [ oNodeGetBoolean( decl, qInOut )
2274:                   | true :    % VAR param points to the var.  Auto dereference.
2275:                               .tPushParamP @EmitValue( decl )
2284:                               .tFetchI
2286:                   | * :       .tPushParamI @EmitValue( decl )
2300:                ]
2300:          ]
      
2310:       | nBooleanType :
2312:          [ oNodeType( decl )
2319:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2329:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2340:             | nParam :
2342:                [ oNodeGetBoolean( decl, qInOut )
2352:                   | true :    % VAR param points to the var.  Auto derefernce.
2353:                               .tPushParamP @EmitValue( decl )
2362:                               .tFetchB
2364:                   | * :       .tPushParamB @EmitValue( decl )
2378:                ]
2378:          ]
      
2388:       | nCharType, nStringType, nFileType :
2390:          #eNotImplemented
      
2392:       | nPointerType :
2394:          [ oNodeType( decl )
2401:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2411:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2422:             | nParam :
2424:                [ oNodeGetBoolean( decl, qInOut )
2434:                   | true :    % VAR param points to the var.  Auto derefernce.
2435:                               .tPushParamP @EmitValue( decl )
2444:                               .tFetchP
2446:                   | * :       .tPushParamP @EmitValue( decl )
2460:                ]
2460:          ]
2470:          [
2470:             | '^' :             % dereferenced
2472:                oTypeSPop
2473:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2486:                @LValueIndexes
2488:                @FetchVar
2490:             | * :               % just ptr value alone
2495:          ]
      
2495:       | * :
               % compound type
               % first, push addr of start of var
2510:          [ oNodeType( decl )
2517:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2527:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2538:             | nParam :
2540:                [ oNodeGetBoolean( decl, qInOut )
2550:                   | true :    % VAR param points to the var.  Auto derefernce.
2551:                               .tPushParamP @EmitValue( decl )
2560:                   | * :       .tPushAddrParam @EmitValue( decl )
2574:                ]
2574:          ]
               % modify addr for subscripts, field references, etc
2584:          @LValueIndexes
               % get final value
2586:          @FetchVar
2588:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2589: FetchVar:
2591:    [ oTypeSNodeType
2593:       | nIntegerType :   .tFetchI
2596:       | nBooleanType :   .tFetchB
2600:       | nCharType, nStringType, nFileType : #eNotImplemented
2604:       | nPointerType :   .tFetchP
2608:       | * :              % compound type; leave as addr
2623:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
2624: LValueIndexes:
2626:    {[
2626:       | '[' :       @ArraySubscripts
2630:       | '.' :       @RecordFieldRef
2634:       | '^' :       @PointerDeref
2638:       | * :         >
2649:    ]};
      
2652: ArraySubscripts:
2654:    [ oTypeSNodeType
2656:       | nArrayType :
2657:       | * :       #eNotArray
2664:    ]
2664:    {
2664:       [ oTypeSNodeType
2666:          | nArrayType :
2667:          | * :    #eTooManySubscripts
2674:       ]
      
            % low subscript of this dimension
2674:       int low
2674:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2691:       Node baseType
2691:       baseType = oNodeGet( oTypeSTop, qBaseType )
2703:       oTypeSPop
2704:       oTypeSPush( baseType )
      
2710:       @Expr
2712:       @RequireIntPop
            % adjust for low subscript
2714:       [ equal_zero( low )
2721:          | false :
2722:             .tPushConstI oEmitInt( low ) .tSubI
2732:          | * :
2737:       ]
      
            % multiply by element size
2737:       int size
2737:       size = oNodeGetInt( baseType, qSize )
2750:       [ equal( size, 1 )
2760:          | false :
2761:             .tPushConstI oEmitInt( size ) .tMultI
2771:          | * :
2776:       ]
      
            % update start address
2776:       .tAddPI
2778:       [
2778:          | ']' :  >
2782:          | ',' :
2784:       ]
2792:    };
      
      
2795: RecordFieldRef:
2797:    [ oTypeSNodeType
2799:       | nRecordType :
2800:       | * :    #eNotRecord
2807:    ]
2807:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2819:    pIdent
2821:    Node field
2821:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2826:    [ oNodeType( field )
2833:       | nRecordField :
2834:       | * :   #eNotRecordField
2841:    ]
2841:    oScopeEnd
2842:    int offset
2842:    offset = oNodeGetInt( field, qValue )
2855:    [ equal_zero( offset )
2862:       | false :
2863:          .tPushConstI oEmitInt( offset ) .tAddPI
2873:       | * :
2878:    ]
      
         % replace the type on the type stack, with the field type
2878:    oTypeSPop
2879:    oTypeSPush( oNodeGet( field, qType ) )
2893:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2893: PointerDeref:
2895:    [ oTypeSNodeType
2897:       | nPointerType :
2898:       | * :       #eNotPointer
2905:    ]
2905:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2907:    Node theType
2907:    theType = oTypeSTop
2912:    oTypeSPop
2913:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2927:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2927: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2929:    @MatchTypes
2932:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2932: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
2934:    boolean isFunc
2934:    Node resultType
2934:    int tempOffset
      
2934:    isFunc = equal_node_type( oNodeType( method ), nFunc )
      
2951:    [ isFunc
2954:       | true :
2955:          resultType = oNodeGet( method, qType )
2968:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
2978:       | * :
2983:    ]
         
      
2983:    Node paramScope
2983:    paramScope = oNodeGet( method, qParams )
2996:    int actualsSize
2996:    actualsSize = oNodeGetInt( paramScope, qSize )
3009:    .tAllocActuals  oEmitInt( actualsSize )
      
3017:    Node param
3017:    param = oNodeGet( paramScope, qDecls )
3030:    [
3030:       | '(' :
            
3032:          {
3032:             [ oNodeNull( param )
3039:                | true : >
3042:                | * :
3047:             ]
      
3047:             int offset
3047:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
3060:             .tPushAddrActual oEmitInt( offset )
3068:             oTypeSPush( oNodeGet( param, qType ) )
      
3081:             [ oNodeGetBoolean( param, qInOut )
3091:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
3092:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3094:                           @MatchTypes
      
3096:                           .tAssignP
      
3098:                | false :  @Expr
3102:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3104:                           [ oTypeSNodeType
3106:                              | nIntegerType :            .tAssignI
3109:                              | nBooleanType :            .tAssignB
3113:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3117:                              | nPointerType :            .tAssignP
3121:                              | * :
                                       % compound types: copy value into actuals space
3136:                                  int size
3136:                                  size = oNodeGetInt( oTypeSTop, qSize )
3148:                                  .tCopy  oEmitInt( size )    % multi-word copy
3156:                           ]
3156:             ]
3164:             oTypeSPop
      
3165:             oNodeNext( param )
3171:             [ oNodeNull( param )
3178:                | true :  >
3181:                | false :
3183:             ]
      
3191:             ','
3193:          }
      
3195:          ')'
      
3197:       | * :
3202:    ]
      
3202:    [ oNodeNull( param )
3209:       | false :    #eMissingParameter
3212:       | * :
3217:    ]
      
3217:    [ isFunc
3220:       | true :
               % Pass result temp as an additional VAR parameter.
3221:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
3236:          .tPushAddrLocal  oEmitInt( tempOffset )
3244:          .tAssignP
3246:       | * :
3251:    ]
      
3251:    .tCall   @EmitValue( method )
      
3260:    [ isFunc
3263:       | true :
               % push return value from temp
3264:          oTypeSPush( resultType )
3270:          .tPushAddrLocal  oEmitInt( tempOffset )
3278:          @FetchVar
3280:       | * :
3285:    ]
         
3285:    .tFreeActuals  oEmitInt( actualsSize )
3294:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3294: Statement:
3296:    [
3296:       | pWriteln :     @WritelnStmt
3300:       | pWrite :       @WriteStmt
3304:       | pReadln :      @ReadlnStmt
3308:       | pRead :        @ReadStmt
3312:       | pIf :          @IfStmt
3316:       | pWhile :       @WhileStmt
3320:       | pFor :         @ForStmt
3324:       | pRepeat :      @RepeatStmt
3328:       | pExit :        @ExitStmt
3332:       | pCycle :       @CycleStmt
3336:       | pBegin :       @BeginStmt
3340:       | pIdent :       @AssignOrCallStmt
3344:       | * :            % null statement : don't accept any tokens
3371:    ];
      
      
3372: AssignOrCallStmt:
3374:    Node decl
3374:    decl = oScopeFindRequire
3379:    [ oNodeType( decl )
3386:       | nProc :                           @Call( decl )
3394:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3403:       | nFunc :                           @AssignResultStmt( decl )
3412:       | * :                               #eBadStatement
3427:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3428: AssignStmt( Node decl ):
      
3430:    @LValueVar( decl )
      
3437:    ':=' 
3439:    @Expr
3441:    @MatchTypes
3443:    [ oTypeSNodeType
3445:       | nIntegerType :            .tAssignI
3448:       | nBooleanType :            .tAssignB
3452:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3456:       | nPointerType :            .tAssignP
3460:       | * :
3475:           int size
3475:           size = oNodeGetInt( oTypeSTop, qSize )
3487:           .tCopy  oEmitInt( size )    % multi-word copy
3495:    ]
3495:    oTypeSPop
3497:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
3497: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
3499:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
3515:       | false :   #eNotCurrentFunction
3518:       | * :
3523:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
3523:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
3538:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
3551:    ':='
3553:    @Expr
3555:    @MatchTypes
3557:    [ oTypeSNodeType
3559:       | nIntegerType :            .tAssignI
3562:       | nBooleanType :            .tAssignB
3566:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3570:       | nPointerType :            .tAssignP
3574:       | * :
3589:           int size
3589:           size = oNodeGetInt( oTypeSTop, qSize )
3601:           .tCopy  oEmitInt( size )    % multi-word copy
3609:    ]
3609:    oTypeSPop
3611:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
3611: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
3613:    pIdent
3615:    Node decl
3615:    decl = oScopeFindRequire
3620:    [ oNodeType( decl )
3627:       | nGlobalVar, nLocalVar, nParam :
3628:       | * :  #eNotVar
3639:    ]
3639:    @LValueVar( decl )
3647:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
3647: LValueVar( Node decl ):
3649:    [ oNodeType( decl )
3656:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3666:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3677:       | nParam :
3679:          [ oNodeGetBoolean( decl, qInOut )
3689:             | true :   % VAR param points to variable.  No dereference.
3690:                        .tPushParamP @EmitValue( decl )
3699:             | * :      .tPushAddrParam @EmitValue( decl )
3713:          ]
3713:       | * :            #eNotVar
3724:    ]
      
3724:    oTypeSPush( oNodeGet( decl, qType ) )
3737:    @LValueIndexes        % handle subscripts, if any
3740:    ;
      
      
3740: IncVar( Node decl ):
3742:    @LValueVar( decl )
3749:    @RequireIntPop
3751:    @VarExpr( decl )
3758:    oTypeSPop
3759:    .tIncI
3761:    .tAssignI;
      
3764: DecVar( Node decl ):
3766:    @LValueVar( decl )
3773:    @RequireIntPop
3775:    @VarExpr( decl )
3782:    oTypeSPop
3783:    .tDecI
3785:    .tAssignI;
      
      
3788: IfStmt:
3790:    @Expr
3792:    @RequireBoolPop
3794:    pThen
3796:    .tJumpFalse
3798:    oPatchPushHere(patchIf)
3804:    .tSpace
3806:    @Statement
3808:    [
3808:       | pElse :
3810:          .tJump
3812:          oPatchPushHere(patchIf)
3818:          .tSpace
3820:          oPatchSwap(patchIf)
3826:          oPatchPopFwd(patchIf)
3832:          @Statement
3834:       | * :
3839:    ]
3839:    oPatchPopFwd(patchIf);
      
      
3846: ForStmt:
3848:    pIdent
      
3850:    Node decl
3850:    decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
3855:    @LValueVar( decl )
3862:    @RequireIntPop
      
3864:    ':='
      
3866:    @Expr
3868:    @RequireIntPop
3870:    .tAssignI
      
3872:    .tJump oPatchPushHere(patchLoop) .tSpace
3882:    oPatchPushHere(patchLoop)
3888:    oPatchSwap(patchLoop)
3894:    [
3894:       | pTo :
3896:          @IncVar( decl )
3903:          oPatchPopFwd(patchLoop)
3909:          @VarExpr( decl )  oTypeSPop
3917:          @Expr
3919:          @RequireIntPop
3921:          .tGreaterI
3923:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3933:          oPatchSwap(patchLoop)
3939:       | pDownto :
3941:          @DecVar( decl )
3948:          oPatchPopFwd(patchLoop)
3954:          @VarExpr( decl )  oTypeSPop
3962:          @Expr
3964:          @RequireIntPop
3966:          .tLessI
3968:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3978:          oPatchSwap(patchLoop)
3984:    ]
3992:    oCountPush(0)          % count 'exit' patches
3998:    pDo
4000:    @Statement
4002:    .tJump oPatchPopBack(patchLoop)
4010:    oPatchPopFwd(patchLoop)
4016:    @PatchExitsPop;
      
      
4019: RepeatStmt:
4021:    oPatchPushHere(patchLoop) % start of loop
4027:    oCountPush(0)          % count the 'exit' patches
4033:    @Statement
4035:    {[
4035:       | ';' :
4037:          @Statement
4039:       | pUntil :
4041:          @Expr
4043:          @RequireBoolPop
4045:          .tJumpFalse
4047:          oPatchPopBack(patchLoop)
4053:          @PatchExitsPop
4055:          >
4057:    ]};
      
      
4068: WhileStmt:
4070:    oPatchPushHere(patchLoop)    % start of loop
4076:    oCountPush(0)
4082:    @Expr
4084:    @RequireBoolPop
4086:    pDo
4088:    .tJumpFalse
4090:    oPatchPushHere(patchLoop)    % jump out
4096:    .tSpace
4098:    oPatchSwap(patchLoop)        % start on top
4104:    @Statement
4106:    .tJump
4108:    oPatchPopBack(patchLoop)
4114:    oPatchPopFwd(patchLoop)
4120:    @PatchExitsPop;
      
      
4123: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
4125:    [ oPatchAnyEntries(patchLoop)
4132:       | true :
4133:          .tJump
4135:          oPatchDup(patchLoop)  % addr of start
4141:          oPatchPopBack(patchLoop)
4147:       | * :
4152:          #eNotInALoop
4154:    ];
      
      
4155: ExitStmt:
4157:    [ oPatchAnyEntries(patchLoop)
4164:       | true :
4165:          .tJump
4167:          oPatchPushHere(patchExit)
4173:          .tSpace
4175:          oCountInc
4176:       | * :
4181:          #eNotInALoop
4183:    ];
      
      
4184: BeginStmt:
4186:    @Statement
4188:    {[
4188:       | ';' :   @Statement
4192:       | pEnd :  >
4196:    ]};
      
      
4207: WritelnStmt:
4209:    @WriteStmt
4211:    .tWriteCR;
      
      
4214: WriteStmt:
4216:    [
4216:       | '(' :
4218:          {
4218:             @Expr
4220:             [ oTypeSNodeType
4222:                | nIntegerType :             .tWriteI
4225:                | nBooleanType :             .tWriteBool
4229:                | nStringType :              .tWriteStr
4233:                | nCharType, nFileType :     #eNotImplemented
4237:                | nPointerType :             .tWriteP
4241:                | * :                        #eNotAllowed
4258:             ]
4258:             oTypeSPop
4259:             [
4259:                | ')' : >
4263:                | ',' :
4265:             ]
4273:          }
4275:       | * :
4280:    ];
      
      
4281: ReadlnStmt:      % ***
         % TO DO
4284:    ;
      
4284: ReadStmt:
         % TO DO
4287:    ;
      
      % -------------------------------- Utilities -------------------------------
      
4287: PatchExitsPop:
4289:    {[ oCountIsZero
4291:       | false : oPatchPopFwd(patchExit)
4298:                 oCountDec
4299:       | * :     >
4306:    ]}
4308:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4310: MatchTypes:
4312:    node_type nt
4312:    nt = oTypeSNodeType
4317:    oTypeSPop
4318:    [ equal_node_type( nt, oTypeSNodeType )
4327:       | false :
4328:          #eTypeMismatch
4330:       | * :
4335:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
4336: RequireIntPop:
4338:    [ oTypeSNodeType
4340:       | nIntegerType :
4341:       | * :          #eNotInteger
4348:    ]
4348:    oTypeSPop;
      
4350: RequireInt:
4352:    [ oTypeSNodeType
4354:       | nIntegerType :
4355:       | * :          #eNotInteger
4362:    ];
      
4363: RequireBoolPop:
4365:    [ oTypeSNodeType
4367:       | nBooleanType :
4368:       | * :          #eNotBoolean
4375:    ]
4375:    oTypeSPop;
      
4377: RequireBool:
4379:    [ oTypeSNodeType
4381:       | nBooleanType :
4382:       | * :          #eNotBoolean
4389:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
4390: newType( node_type nt, int size ) >> Node:
4392:   Node node
4392:   node = oNodeNew( nt )
4402:   oNodeSetInt( node, qSize, size )
4414:   oTypeAdd( node )
4420:   >> node
4424:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
4424: newIdent( node_type nt, kind k, int id ) >> Node:
4426:   Node t
4426:   t = oNodeNew( nt )
4436:   oNodeSetInt( t, qIdent, id )
4448:   >> t
4452:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
4452: PointerTypeTo( Node theType ) >> Node:
4454:    Node ptrType
4454:    ptrType = oNodeGet( theType, qPointerType )
4467:    [ oNodeNull( ptrType )
4474:       | true :
4475:          ptrType = oNodeNew( nPointerType )
4485:          oNodeSet( ptrType, qBaseType, theType )
4497:          oNodeSetInt( ptrType, qSize, 8 )
4509:          oTypeAdd( ptrType )
4515:          oNodeSet( theType, qPointerType, ptrType )
4527:       | * :
4532:    ]
4532:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4536: OrdinalLow( Node theType ) >> int:
4538:    [ oNodeType( theType )
4545:       | nIntegerType :  >> -2147483648
4549:       | nBooleanType :  >> 0
4554:       | nCharType :     >> 0
4559:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4571:       | * :             #eNotOrdinalType
4584:                         >> 0
4587:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4588: EmitValue( Node decl ):
4590:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4604: installBuiltIns:
      
         % install built-in types
4606:    FileType = @newType( nFileType, 4 )
4620:    IntegerType = @newType( nIntegerType, 4 )
4634:    BooleanType = @newType( nBooleanType, 1 )
4648:    CharType = @newType( nCharType, 1 )
4662:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4676:    Node t
      
4676:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4692:    oNodeSet( t, qType, FileType )
4704:    oScopeDeclare( t )
      
4710:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4726:    oNodeSet( t, qType, IntegerType )
4738:    oScopeDeclare( t )
      
4744:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4760:    oNodeSet( t, qType, BooleanType )
4772:    oScopeDeclare( t )
      
4778:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4794:    oNodeSet( t, qType, CharType )
4806:    oScopeDeclare( t )
      
4812:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4828:    oNodeSet( t, qType, StringType )
4840:    oScopeDeclare( t )
      
         % Built-in constants
      
4846:    t = @newIdent( nConst, kConst, oIdAdd_True )
4862:    oNodeSet( t, qType, BooleanType )
4874:    oNodeSetInt( t, qValue, 1 )
4886:    oScopeDeclare( t )
      
4892:    t = @newIdent( nConst, kConst, oIdAdd_False )
4908:    oNodeSet( t, qType, BooleanType )
4920:    oNodeSetInt( t, qValue, 0 )
4932:    oScopeDeclare( t )
      
4939:    ;
      
4939: end
      
4939: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 4
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4604
  12: oEmit 42
  14: oGetAddrLocal 3
  16: oPushResult
  17: Here
  18: oAssign
  19: oEmit 53
  21: oEmit 43
  23: oInput 26
  25: oInput 0
  27: oGetAddrLocal 1
  29: oPushResult
  30: oSetResult 5
  32: oPushResult
  33: oSetResult 1
  35: oPushResult
  36: LAST_ID
  37: oPushResult
  38: oCall 4424
  40: oPop 3
  42: oAssign
  43: oGetLocal 1
  45: oPushResult
  46: oScopeDeclare
  47: oPop 1
  49: oInputChoice 129
  51: oInput 0
  53: oGetAddrLocal 2
  55: oPushResult
  56: oSetResult 11
  58: oPushResult
  59: oSetResult 6
  61: oPushResult
  62: LAST_ID
  63: oPushResult
  64: oCall 4424
  66: oPop 3
  68: oAssign
  69: oGetLocal 2
  71: oPushResult
  72: oSetResult 5
  74: oPushResult
  75: oGetGlobal 2
  77: oPushResult
  78: oNodeSet
  79: oPop 3
  81: oGetLocal 2
  83: oPushResult
  84: oScopeDeclareAlloc
  85: oPop 1
  87: oInput 12
  89: oInput 0
  91: oGetAddrLocal 2
  93: oPushResult
  94: oSetResult 11
  96: oPushResult
  97: oSetResult 6
  99: oPushResult
 100: LAST_ID
 101: oPushResult
 102: oCall 4424
 104: oPop 3
 106: oAssign
 107: oGetLocal 2
 109: oPushResult
 110: oSetResult 5
 112: oPushResult
 113: oGetGlobal 2
 115: oPushResult
 116: oNodeSet
 117: oPop 3
 119: oGetLocal 2
 121: oPushResult
 122: oScopeDeclareAlloc
 123: oPop 1
 125: oInput 14
 127: oJumpForward 132
 129: Choice Lookup Table
          13     51
 132: oInput 4
 134: oSetResult 12
 136: oPushResult
 137: oCall 202
 139: oPop 1
 141: oScopeBegin
 142: oScopeCurrent
 143: oPushResult
 144: oSetResult 3
 146: oPushResult
 147: oSetResult 1
 149: oPushResult
 150: oNodeSetBoolean
 151: oPop 3
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 7
 158: oPushResult
 159: oScopeCurrent
 160: oPushResult
 161: oNodeSet
 162: oPop 3
 164: oGetAddrLocal 4
 166: oPushResult
 167: oCall 247
 169: oPop 1
 171: oScopeEnd
 172: oGetLocal 3
 174: oPushResult
 175: oGetLocal 4
 177: oPushResult
 178: oPatch
 179: oPop 2
 181: oInput 18
 183: oScopeEnd
 184: oReturn
 185: oLocalSpace 0
 187: oGetParam 2
 189: oPushResult
 190: oCall 202
 192: oPop 1
 194: oGetParam 1
 196: oPushResult
 197: oCall 247
 199: oPop 1
 201: oReturn
 202: oLocalSpace 0
 204: oInputChoice 231
 206: oCall 798
 208: oJumpForward 244
 210: oCall 870
 212: oJumpForward 244
 214: oGetParam 1
 216: oPushResult
 217: oCall 929
 219: oPop 1
 221: oJumpForward 244
 223: oCall 289
 225: oJumpForward 244
 227: oCall 406
 229: oJumpForward 244
 231: Choice Lookup Table
          28    227
          27    223
          31    214
          30    210
          29    206
 242: oJumpForward 246
 244: oJumpBack 204
 246: oReturn
 247: oLocalSpace 2
 249: oGetParam 1
 251: oPushResult
 252: Here
 253: oAssign
 254: oEmit 44
 256: oGetAddrLocal 1
 258: oPushResult
 259: Here
 260: oAssign
 261: oEmit 53
 263: oCall 3294
 265: oEmit 43
 267: oGetAddrLocal 2
 269: oPushResult
 270: oScopeCurrent
 271: oPushResult
 272: oSetResult 2
 274: oPushResult
 275: oNodeGetInt
 276: oPop 2
 278: oAssign
 279: oGetLocal 1
 281: oPushResult
 282: oGetLocal 2
 284: oPushResult
 285: oPatch
 286: oPop 2
 288: oReturn
 289: oLocalSpace 3
 291: oInput 0
 293: oGetAddrLocal 1
 295: oPushResult
 296: oSetResult 7
 298: oPushResult
 299: oSetResult 2
 301: oPushResult
 302: LAST_ID
 303: oPushResult
 304: oCall 4424
 306: oPop 3
 308: oAssign
 309: oScopeBegin
 310: oGetAddrLocal 2
 312: oPushResult
 313: oScopeCurrent
 314: oAssign
 315: oCall 571
 317: oGetLocal 1
 319: oPushResult
 320: oSetResult 8
 322: oPushResult
 323: oGetLocal 2
 325: oPushResult
 326: oNodeSet
 327: oPop 3
 329: oScopeEnd
 330: oGetLocal 1
 332: oPushResult
 333: oScopeDeclare
 334: oPop 1
 336: oInput 4
 338: oGetLocal 2
 340: oPushResult
 341: oScopeEnter
 342: oPop 1
 344: oScopeBegin
 345: oScopeCurrent
 346: oPushResult
 347: oSetResult 3
 349: oPushResult
 350: oSetResult 1
 352: oPushResult
 353: oNodeSetBoolean
 354: oPop 3
 356: oGetLocal 1
 358: oPushResult
 359: oSetResult 9
 361: oPushResult
 362: oScopeCurrent
 363: oPushResult
 364: oNodeSet
 365: oPop 3
 367: oSetResult 13
 369: oPushResult
 370: oGetAddrLocal 3
 372: oPushResult
 373: oCall 185
 375: oPop 2
 377: oGetLocal 1
 379: oPushResult
 380: oSetResult 6
 382: oPushResult
 383: oGetLocal 3
 385: oPushResult
 386: oNodeSetInt
 387: oPop 3
 389: oGetLocal 1
 391: oPushResult
 392: oSetResult 10
 394: oPushResult
 395: oSetResult 1
 397: oPushResult
 398: oNodeSetBoolean
 399: oPop 3
 401: oScopeEnd
 402: oScopeEnd
 403: oInput 4
 405: oReturn
 406: oLocalSpace 5
 408: oInput 0
 410: oGetAddrLocal 1
 412: oPushResult
 413: oSetResult 8
 415: oPushResult
 416: oSetResult 3
 418: oPushResult
 419: LAST_ID
 420: oPushResult
 421: oCall 4424
 423: oPop 3
 425: oAssign
 426: oScopeBegin
 427: oGetAddrLocal 3
 429: oPushResult
 430: oScopeCurrent
 431: oAssign
 432: oCall 571
 434: oGetLocal 1
 436: oPushResult
 437: oSetResult 8
 439: oPushResult
 440: oGetLocal 3
 442: oPushResult
 443: oNodeSet
 444: oPop 3
 446: oInput 11
 448: oGetAddrLocal 2
 450: oPushResult
 451: oCall 1070
 453: oPop 1
 455: oGetLocal 1
 457: oPushResult
 458: oSetResult 5
 460: oPushResult
 461: oGetLocal 2
 463: oPushResult
 464: oNodeSet
 465: oPop 3
 467: oGetAddrLocal 4
 469: oPushResult
 470: oGetLocal 2
 472: oPushResult
 473: oCall 4452
 475: oPop 1
 477: oAssign
 478: oGetLocal 1
 480: oPushResult
 481: oSetResult 11
 483: oPushResult
 484: oGetLocal 4
 486: oPushResult
 487: oScopeAllocType
 488: oPop 1
 490: oPushResult
 491: oNodeSetInt
 492: oPop 3
 494: oInput 4
 496: oScopeEnd
 497: oGetLocal 1
 499: oPushResult
 500: oScopeDeclare
 501: oPop 1
 503: oGetLocal 3
 505: oPushResult
 506: oScopeEnter
 507: oPop 1
 509: oScopeBegin
 510: oScopeCurrent
 511: oPushResult
 512: oSetResult 3
 514: oPushResult
 515: oSetResult 1
 517: oPushResult
 518: oNodeSetBoolean
 519: oPop 3
 521: oGetLocal 1
 523: oPushResult
 524: oSetResult 9
 526: oPushResult
 527: oScopeCurrent
 528: oPushResult
 529: oNodeSet
 530: oPop 3
 532: oSetResult 13
 534: oPushResult
 535: oGetAddrLocal 5
 537: oPushResult
 538: oCall 185
 540: oPop 2
 542: oGetLocal 1
 544: oPushResult
 545: oSetResult 6
 547: oPushResult
 548: oGetLocal 5
 550: oPushResult
 551: oNodeSetInt
 552: oPop 3
 554: oGetLocal 1
 556: oPushResult
 557: oSetResult 10
 559: oPushResult
 560: oSetResult 1
 562: oPushResult
 563: oNodeSetBoolean
 564: oPop 3
 566: oScopeEnd
 567: oScopeEnd
 568: oInput 4
 570: oReturn
 571: oLocalSpace 6
 573: oInputChoice 794
 575: oGetAddrLocal 1
 577: oPushResult
 578: oNodeVecNew
 579: oAssign
 580: oGetAddrLocal 3
 582: oPushResult
 583: oSetResult 0
 585: oAssign
 586: oInputChoice 596
 588: oGetAddrLocal 3
 590: oPushResult
 591: oSetResult 1
 593: oAssign
 594: oJumpForward 599
 596: Choice Lookup Table
          31    588
 599: oInput 0
 601: oGetAddrLocal 2
 603: oPushResult
 604: oSetResult 15
 606: oPushResult
 607: oSetResult 6
 609: oPushResult
 610: LAST_ID
 611: oPushResult
 612: oCall 4424
 614: oPop 3
 616: oAssign
 617: oGetLocal 2
 619: oPushResult
 620: oSetResult 12
 622: oPushResult
 623: oGetLocal 3
 625: oPushResult
 626: oNodeSetBoolean
 627: oPop 3
 629: oGetLocal 1
 631: oPushResult
 632: oGetLocal 2
 634: oPushResult
 635: oNodeVecAppend
 636: oPop 2
 638: oInputChoice 646
 640: oJumpForward 654
 642: oJumpForward 652
 644: oJumpForward 652
 646: Choice Lookup Table
          12    644
          11    640
 651: oEndChoice
 652: oJumpBack 599
 654: oGetAddrLocal 4
 656: oPushResult
 657: oCall 1070
 659: oPop 1
 661: oGetLocal 3
 663: oChoice 678
 665: oGetAddrLocal 5
 667: oPushResult
 668: oGetLocal 4
 670: oPushResult
 671: oCall 4452
 673: oPop 1
 675: oAssign
 676: oJumpForward 687
 678: Choice Lookup Table
           1    665
 681: oGetAddrLocal 5
 683: oPushResult
 684: oGetLocal 4
 686: oAssign
 687: oGetAddrLocal 6
 689: oPushResult
 690: oSetResult 0
 692: oAssign
 693: oGetLocal 6
 695: oPushResult
 696: oGetLocal 1
 698: oPushResult
 699: oNodeVecSize
 700: oPop 1
 702: oPushResult
 703: equal
 704: oPop 2
 706: oChoice 763
 708: oGetAddrLocal 2
 710: oPushResult
 711: oGetLocal 1
 713: oPushResult
 714: oGetLocal 6
 716: oPushResult
 717: oNodeVecElement
 718: oPop 2
 720: oAssign
 721: oGetLocal 2
 723: oPushResult
 724: oSetResult 5
 726: oPushResult
 727: oGetLocal 4
 729: oPushResult
 730: oNodeSet
 731: oPop 3
 733: oGetLocal 2
 735: oPushResult
 736: oScopeDeclare
 737: oPop 1
 739: oGetLocal 2
 741: oPushResult
 742: oSetResult 6
 744: oPushResult
 745: oGetLocal 5
 747: oPushResult
 748: oScopeAllocType
 749: oPop 1
 751: oPushResult
 752: oNodeSetInt
 753: oPop 3
 755: oGetAddrLocal 6
 757: oPushResult
 758: inc
 759: oPop 1
 761: oJumpForward 768
 763: Choice Lookup Table
           0    708
 766: oJumpForward 770
 768: oJumpBack 693
 770: oGetLocal 1
 772: oPushResult
 773: oNodeVecDelete
 774: oPop 1
 776: oInputChoice 784
 778: oJumpForward 792
 780: oJumpForward 790
 782: oJumpForward 790
 784: Choice Lookup Table
           4    782
          14    778
 789: oEndChoice
 790: oJumpBack 575
 792: oJumpForward 797
 794: Choice Lookup Table
          13    575
 797: oReturn
 798: oLocalSpace 2
 800: oInputChoice 862
 802: oGetAddrLocal 1
 804: oPushResult
 805: oSetResult 9
 807: oPushResult
 808: oSetResult 4
 810: oPushResult
 811: LAST_ID
 812: oPushResult
 813: oCall 4424
 815: oPop 3
 817: oAssign
 818: oInput 5
 820: oCall 1539
 822: oGetAddrLocal 2
 824: oPushResult
 825: oValueTop
 826: oAssign
 827: oValuePop
 828: oGetLocal 1
 830: oPushResult
 831: oSetResult 6
 833: oPushResult
 834: oGetLocal 2
 836: oPushResult
 837: oNodeSetInt
 838: oPop 3
 840: oGetLocal 1
 842: oPushResult
 843: oSetResult 5
 845: oPushResult
 846: oGetGlobal 3
 848: oPushResult
 849: oNodeSet
 850: oPop 3
 852: oGetLocal 1
 854: oPushResult
 855: oScopeDeclare
 856: oPop 1
 858: oInput 4
 860: oJumpForward 867
 862: Choice Lookup Table
           0    802
 865: oJumpForward 869
 867: oJumpBack 800
 869: oReturn
 870: oLocalSpace 2
 872: oInputChoice 921
 874: oGetAddrLocal 1
 876: oPushResult
 877: oSetResult 10
 879: oPushResult
 880: oSetResult 5
 882: oPushResult
 883: LAST_ID
 884: oPushResult
 885: oCall 4424
 887: oPop 3
 889: oAssign
 890: oInput 5
 892: oGetAddrLocal 2
 894: oPushResult
 895: oCall 1070
 897: oPop 1
 899: oGetLocal 1
 901: oPushResult
 902: oSetResult 5
 904: oPushResult
 905: oGetLocal 2
 907: oPushResult
 908: oNodeSet
 909: oPop 3
 911: oGetLocal 1
 913: oPushResult
 914: oScopeDeclare
 915: oPop 1
 917: oInput 4
 919: oJumpForward 926
 921: Choice Lookup Table
           0    874
 924: oJumpForward 928
 926: oJumpBack 872
 928: oReturn
 929: oLocalSpace 4
 931: oInputChoice 1062
 933: oGetAddrLocal 1
 935: oPushResult
 936: oNodeVecNew
 937: oAssign
 938: oGetAddrLocal 2
 940: oPushResult
 941: oGetParam 1
 943: oPushResult
 944: oSetResult 6
 946: oPushResult
 947: LAST_ID
 948: oPushResult
 949: oCall 4424
 951: oPop 3
 953: oAssign
 954: oGetLocal 1
 956: oPushResult
 957: oGetLocal 2
 959: oPushResult
 960: oNodeVecAppend
 961: oPop 2
 963: oInputChoice 969
 965: oInput 0
 967: oJumpForward 974
 969: Choice Lookup Table
          12    965
 972: oJumpForward 976
 974: oJumpBack 938
 976: oInput 11
 978: oGetAddrLocal 3
 980: oPushResult
 981: oCall 1070
 983: oPop 1
 985: oGetAddrLocal 4
 987: oPushResult
 988: oSetResult 0
 990: oAssign
 991: oGetLocal 4
 993: oPushResult
 994: oGetLocal 1
 996: oPushResult
 997: oNodeVecSize
 998: oPop 1
1000: oPushResult
1001: equal
1002: oPop 2
1004: oChoice 1045
1006: oGetAddrLocal 2
1008: oPushResult
1009: oGetLocal 1
1011: oPushResult
1012: oGetLocal 4
1014: oPushResult
1015: oNodeVecElement
1016: oPop 2
1018: oAssign
1019: oGetLocal 2
1021: oPushResult
1022: oSetResult 5
1024: oPushResult
1025: oGetLocal 3
1027: oPushResult
1028: oNodeSet
1029: oPop 3
1031: oGetLocal 2
1033: oPushResult
1034: oScopeDeclareAlloc
1035: oPop 1
1037: oGetAddrLocal 4
1039: oPushResult
1040: inc
1041: oPop 1
1043: oJumpForward 1050
1045: Choice Lookup Table
           0   1006
1048: oJumpForward 1052
1050: oJumpBack 991
1052: oGetLocal 1
1054: oPushResult
1055: oNodeVecDelete
1056: oPop 1
1058: oInput 4
1060: oJumpForward 1067
1062: Choice Lookup Table
           0    933
1065: oJumpForward 1069
1067: oJumpBack 931
1069: oReturn
1070: oLocalSpace 12
1072: oInputChoice 1521
1074: oGetAddrLocal 1
1076: oPushResult
1077: oScopeFindRequire
1078: oAssign
1079: oGetLocal 1
1081: oPushResult
1082: oNodeType
1083: oPop 1
1085: oChoice 1102
1087: oGetParam 1
1089: oPushResult
1090: oGetLocal 1
1092: oPushResult
1093: oSetResult 5
1095: oPushResult
1096: oNodeGet
1097: oPop 2
1099: oAssign
1100: oJumpForward 1113
1102: Choice Lookup Table
          10   1087
1105: oError 2
1107: oGetParam 1
1109: oPushResult
1110: oGetGlobal 3
1112: oAssign
1113: oJumpForward 1538
1115: oInput 15
1117: oGetAddrLocal 2
1119: oPushResult
1120: oNodeVecNew
1121: oAssign
1122: oGetAddrLocal 3
1124: oPushResult
1125: oSetResult 24
1127: oPushResult
1128: oNodeNew
1129: oPop 1
1131: oAssign
1132: oGetLocal 3
1134: oPushResult
1135: oSetResult 14
1137: oPushResult
1138: oGetGlobal 3
1140: oPushResult
1141: oNodeSet
1142: oPop 3
1144: oCall 1539
1146: oGetLocal 3
1148: oPushResult
1149: oSetResult 16
1151: oPushResult
1152: oValueTop
1153: oPushResult
1154: oNodeSetInt
1155: oPop 3
1157: oValuePop
1158: oInput 19
1160: oCall 1539
1162: oGetLocal 3
1164: oPushResult
1165: oSetResult 17
1167: oPushResult
1168: oValueTop
1169: oPushResult
1170: oNodeSetInt
1171: oPop 3
1173: oValuePop
1174: oGetLocal 3
1176: oPushResult
1177: oSetResult 2
1179: oPushResult
1180: oSetResult 4
1182: oPushResult
1183: oNodeSetInt
1184: oPop 3
1186: oGetLocal 3
1188: oPushResult
1189: oTypeAdd
1190: oPop 1
1192: oGetAddrLocal 4
1194: oPushResult
1195: oSetResult 23
1197: oPushResult
1198: oNodeNew
1199: oPop 1
1201: oAssign
1202: oGetLocal 4
1204: oPushResult
1205: oSetResult 15
1207: oPushResult
1208: oGetLocal 3
1210: oPushResult
1211: oNodeSet
1212: oPop 3
1214: oGetLocal 2
1216: oPushResult
1217: oGetLocal 4
1219: oPushResult
1220: oNodeVecAppend
1221: oPop 2
1223: oInputChoice 1231
1225: oJumpForward 1239
1227: oJumpForward 1237
1229: oJumpForward 1237
1231: Choice Lookup Table
          12   1229
          16   1225
1236: oEndChoice
1237: oJumpBack 1122
1239: oInput 37
1241: oGetAddrLocal 5
1243: oPushResult
1244: oCall 1070
1246: oPop 1
1248: oGetAddrLocal 6
1250: oPushResult
1251: oGetLocal 2
1253: oPushResult
1254: oNodeVecSize
1255: oPop 1
1257: oAssign
1258: oGetAddrLocal 6
1260: oPushResult
1261: dec
1262: oPop 1
1264: oGetAddrLocal 4
1266: oPushResult
1267: oGetLocal 2
1269: oPushResult
1270: oGetLocal 6
1272: oPushResult
1273: oNodeVecElement
1274: oPop 2
1276: oAssign
1277: oGetLocal 4
1279: oPushResult
1280: oSetResult 14
1282: oPushResult
1283: oGetLocal 5
1285: oPushResult
1286: oNodeSet
1287: oPop 3
1289: oGetAddrLocal 3
1291: oPushResult
1292: oGetLocal 4
1294: oPushResult
1295: oSetResult 15
1297: oPushResult
1298: oNodeGet
1299: oPop 2
1301: oAssign
1302: oGetAddrLocal 9
1304: oPushResult
1305: oGetLocal 3
1307: oPushResult
1308: oSetResult 17
1310: oPushResult
1311: oNodeGetInt
1312: oPop 2
1314: oPushResult
1315: oGetLocal 3
1317: oPushResult
1318: oSetResult 16
1320: oPushResult
1321: oNodeGetInt
1322: oPop 2
1324: oPushResult
1325: subtract
1326: oPop 2
1328: oAssign
1329: oGetAddrLocal 9
1331: oPushResult
1332: inc
1333: oPop 1
1335: oGetLocal 4
1337: oPushResult
1338: oSetResult 2
1340: oPushResult
1341: oGetLocal 9
1343: oPushResult
1344: oGetLocal 5
1346: oPushResult
1347: oSetResult 2
1349: oPushResult
1350: oNodeGetInt
1351: oPop 2
1353: oPushResult
1354: multiply
1355: oPop 2
1357: oPushResult
1358: oNodeSetInt
1359: oPop 3
1361: oGetLocal 4
1363: oPushResult
1364: oTypeAdd
1365: oPop 1
1367: oGetAddrLocal 5
1369: oPushResult
1370: oGetLocal 4
1372: oAssign
1373: oGetLocal 6
1375: oPushResult
1376: equal_zero
1377: oPop 1
1379: oChoice 1385
1381: oJumpForward 1390
1383: oJumpForward 1388
1385: Choice Lookup Table
           1   1381
1388: oJumpBack 1258
1390: oGetParam 1
1392: oPushResult
1393: oGetLocal 2
1395: oPushResult
1396: oSetResult 0
1398: oPushResult
1399: oNodeVecElement
1400: oPop 2
1402: oAssign
1403: oGetLocal 2
1405: oPushResult
1406: oNodeVecDelete
1407: oPop 1
1409: oJumpForward 1538
1411: oGetAddrLocal 10
1413: oPushResult
1414: oCall 1070
1416: oPop 1
1418: oGetParam 1
1420: oPushResult
1421: oGetLocal 10
1423: oPushResult
1424: oCall 4452
1426: oPop 1
1428: oAssign
1429: oJumpForward 1538
1431: oGetParam 1
1433: oPushResult
1434: oSetResult 25
1436: oPushResult
1437: oNodeNew
1438: oPop 1
1440: oAssign
1441: oScopeBegin
1442: oSetResult 14
1444: oPushResult
1445: oCall 929
1447: oPop 1
1449: oGetAddrLocal 11
1451: oPushResult
1452: oScopeCurrent
1453: oPushResult
1454: oSetResult 2
1456: oPushResult
1457: oNodeGetInt
1458: oPop 2
1460: oAssign
1461: oGetLocal 11
1463: oPushResult
1464: equal_zero
1465: oPop 1
1467: oChoice 1473
1469: oError 19
1471: oJumpForward 1476
1473: Choice Lookup Table
           1   1469
1476: oInput 33
1478: oGetFromParam 1
1480: oPushResult
1481: oSetResult 18
1483: oPushResult
1484: oScopeCurrent
1485: oPushResult
1486: oNodeSet
1487: oPop 3
1489: oGetFromParam 1
1491: oPushResult
1492: oSetResult 2
1494: oPushResult
1495: oGetLocal 11
1497: oPushResult
1498: oNodeSetInt
1499: oPop 3
1501: oScopeEnd
1502: oGetFromParam 1
1504: oPushResult
1505: oTypeAdd
1506: oPop 1
1508: oJumpForward 1538
1510: oInput 37
1512: oGetAddrLocal 10
1514: oPushResult
1515: oCall 1070
1517: oPop 1
1519: oJumpForward 1538
1521: Choice Lookup Table
          36   1510
          35   1431
          17   1411
          34   1115
           0   1074
1532: oCall 1539
1534: oInput 19
1536: oCall 1539
1538: oReturn
1539: oLocalSpace 1
1541: oInputChoice 1596
1543: TOKEN_VALUE
1544: oPushResult
1545: oValuePush
1546: oPop 1
1548: oJumpForward 1604
1550: oGetAddrLocal 1
1552: oPushResult
1553: oScopeFindRequire
1554: oAssign
1555: oGetLocal 1
1557: oPushResult
1558: oNodeType
1559: oPop 1
1561: oChoice 1578
1563: oGetLocal 1
1565: oPushResult
1566: oSetResult 6
1568: oPushResult
1569: oNodeGetInt
1570: oPop 2
1572: oPushResult
1573: oValuePush
1574: oPop 1
1576: oJumpForward 1589
1578: Choice Lookup Table
           9   1563
1581: oError 1
1583: oSetResult 0
1585: oPushResult
1586: oValuePush
1587: oPop 1
1589: oJumpForward 1604
1591: oCall 1539
1593: oValueNegate
1594: oJumpForward 1604
1596: Choice Lookup Table
          23   1591
           0   1550
           1   1543
1603: oEndChoice
1604: oReturn
1605: oLocalSpace 0
1607: oCall 1851
1609: oInputChoice 1833
1611: oCall 1851
1613: oCall 4310
1615: oTypeSNodeType
1616: oChoice 1630
1618: oEmit 32
1620: oJumpForward 1643
1622: oEmit 38
1624: oJumpForward 1643
1626: oError 16
1628: oJumpForward 1643
1630: Choice Lookup Table
          21   1626
          20   1626
          22   1622
          19   1618
          18   1618
1641: oError 17
1643: oTypeSPop
1644: oGetGlobal 4
1646: oPushResult
1647: oTypeSPush
1648: oPop 1
1650: oJumpForward 1848
1652: oCall 1851
1654: oCall 4310
1656: oTypeSNodeType
1657: oChoice 1671
1659: oEmit 33
1661: oJumpForward 1684
1663: oEmit 39
1665: oJumpForward 1684
1667: oError 16
1669: oJumpForward 1684
1671: Choice Lookup Table
          21   1667
          20   1667
          22   1663
          19   1659
          18   1659
1682: oError 17
1684: oTypeSPop
1685: oGetGlobal 4
1687: oPushResult
1688: oTypeSPush
1689: oPop 1
1691: oJumpForward 1848
1693: oCall 1851
1695: oCall 4310
1697: oTypeSNodeType
1698: oChoice 1708
1700: oEmit 35
1702: oJumpForward 1719
1704: oError 16
1706: oJumpForward 1719
1708: Choice Lookup Table
          21   1704
          20   1704
          19   1700
          18   1700
1717: oError 17
1719: oTypeSPop
1720: oGetGlobal 4
1722: oPushResult
1723: oTypeSPush
1724: oPop 1
1726: oJumpForward 1848
1728: oCall 1851
1730: oCall 4310
1732: oTypeSNodeType
1733: oChoice 1743
1735: oEmit 34
1737: oJumpForward 1754
1739: oError 16
1741: oJumpForward 1754
1743: Choice Lookup Table
          21   1739
          20   1739
          19   1735
          18   1735
1752: oError 17
1754: oTypeSPop
1755: oGetGlobal 4
1757: oPushResult
1758: oTypeSPush
1759: oPop 1
1761: oJumpForward 1848
1763: oCall 1851
1765: oCall 4310
1767: oTypeSNodeType
1768: oChoice 1778
1770: oEmit 37
1772: oJumpForward 1789
1774: oError 16
1776: oJumpForward 1789
1778: Choice Lookup Table
          21   1774
          20   1774
          19   1770
          18   1770
1787: oError 17
1789: oTypeSPop
1790: oGetGlobal 4
1792: oPushResult
1793: oTypeSPush
1794: oPop 1
1796: oJumpForward 1848
1798: oCall 1851
1800: oCall 4310
1802: oTypeSNodeType
1803: oChoice 1813
1805: oEmit 36
1807: oJumpForward 1824
1809: oError 16
1811: oJumpForward 1824
1813: Choice Lookup Table
          21   1809
          20   1809
          19   1805
          18   1805
1822: oError 17
1824: oTypeSPop
1825: oGetGlobal 4
1827: oPushResult
1828: oTypeSPush
1829: oPop 1
1831: oJumpForward 1848
1833: Choice Lookup Table
          10   1798
           9   1763
           8   1728
           7   1693
           6   1652
           5   1611
1846: oJumpForward 1850
1848: oJumpBack 1609
1850: oReturn
1851: oLocalSpace 0
1853: oCall 1875
1855: oInputChoice 1867
1857: oCall 4363
1859: oCall 1875
1861: oCall 4377
1863: oEmit 31
1865: oJumpForward 1872
1867: Choice Lookup Table
          52   1857
1870: oJumpForward 1874
1872: oJumpBack 1855
1874: oReturn
1875: oLocalSpace 0
1877: oCall 1899
1879: oInputChoice 1891
1881: oCall 4363
1883: oCall 1899
1885: oCall 4377
1887: oEmit 30
1889: oJumpForward 1896
1891: Choice Lookup Table
          51   1881
1894: oJumpForward 1898
1896: oJumpBack 1879
1898: oReturn
1899: oLocalSpace 0
1901: oInputChoice 1911
1903: oCall 1917
1905: oCall 4377
1907: oEmit 29
1909: oJumpForward 1916
1911: Choice Lookup Table
          53   1903
1914: oCall 1917
1916: oReturn
1917: oLocalSpace 0
1919: oCall 1953
1921: oInputChoice 1943
1923: oCall 4336
1925: oCall 1953
1927: oCall 4350
1929: oEmit 26
1931: oJumpForward 1950
1933: oCall 4336
1935: oCall 1953
1937: oCall 4350
1939: oEmit 27
1941: oJumpForward 1950
1943: Choice Lookup Table
          23   1933
          22   1923
1948: oJumpForward 1952
1950: oJumpBack 1921
1952: oReturn
1953: oLocalSpace 0
1955: oCall 1989
1957: oInputChoice 1979
1959: oCall 4336
1961: oCall 1989
1963: oCall 4350
1965: oEmit 23
1967: oJumpForward 1986
1969: oCall 4336
1971: oCall 1989
1973: oCall 4350
1975: oEmit 24
1977: oJumpForward 1986
1979: Choice Lookup Table
          21   1969
          20   1959
1984: oJumpForward 1988
1986: oJumpBack 1957
1988: oReturn
1989: oLocalSpace 0
1991: oInputChoice 2007
1993: oCall 2015
1995: oCall 4350
1997: oJumpForward 2014
1999: oCall 2015
2001: oCall 4350
2003: oEmit 28
2005: oJumpForward 2014
2007: Choice Lookup Table
          23   1999
          22   1993
2012: oCall 2015
2014: oReturn
2015: oLocalSpace 5
2017: oInputChoice 2190
2019: oEmit 9
2021: TOKEN_VALUE
2022: oPushResult
2023: oEmitInt
2024: oPop 1
2026: oGetGlobal 3
2028: oPushResult
2029: oTypeSPush
2030: oPop 1
2032: oJumpForward 2209
2034: oCall 1605
2036: oInput 14
2038: oJumpForward 2209
2040: oStringAllocLit
2041: oEmit 10
2043: oValueTop
2044: oPushResult
2045: oEmitInt
2046: oPop 1
2048: oValuePop
2049: oGetGlobal 6
2051: oPushResult
2052: oTypeSPush
2053: oPop 1
2055: oJumpForward 2209
2057: oGetAddrLocal 1
2059: oPushResult
2060: oScopeFindRequire
2061: oAssign
2062: oGetLocal 1
2064: oPushResult
2065: oNodeType
2066: oPop 1
2068: oChoice 2130
2070: oGetLocal 1
2072: oPushResult
2073: oCall 2932
2075: oPop 1
2077: oJumpForward 2149
2079: oGetAddrLocal 2
2081: oPushResult
2082: oGetLocal 1
2084: oPushResult
2085: oSetResult 5
2087: oPushResult
2088: oNodeGet
2089: oPop 2
2091: oAssign
2092: oGetLocal 2
2094: oPushResult
2095: oTypeSPush
2096: oPop 1
2098: oTypeSNodeType
2099: oChoice 2112
2101: oEmit 9
2103: oGetLocal 1
2105: oPushResult
2106: oCall 4588
2108: oPop 1
2110: oJumpForward 2119
2112: Choice Lookup Table
          19   2101
          18   2101
2117: oError 16
2119: oJumpForward 2149
2121: oGetLocal 1
2123: oPushResult
2124: oCall 2210
2126: oPop 1
2128: oJumpForward 2149
2130: Choice Lookup Table
          15   2121
          13   2121
          12   2121
           9   2079
           8   2070
2141: oError 6
2143: oGetGlobal 3
2145: oPushResult
2146: oTypeSPush
2147: oPop 1
2149: oJumpForward 2209
2151: oInput 0
2153: oGetAddrLocal 1
2155: oPushResult
2156: oScopeFindRequire
2157: oAssign
2158: oGetLocal 1
2160: oPushResult
2161: oCall 3647
2163: oPop 1
2165: oGetAddrLocal 2
2167: oPushResult
2168: oTypeSTop
2169: oAssign
2170: oTypeSPop
2171: oGetAddrLocal 5
2173: oPushResult
2174: oGetLocal 2
2176: oPushResult
2177: oCall 4452
2179: oPop 1
2181: oAssign
2182: oGetLocal 5
2184: oPushResult
2185: oTypeSPush
2186: oPop 1
2188: oJumpForward 2209
2190: Choice Lookup Table
          17   2151
           0   2057
           2   2040
          13   2034
           1   2019
2201: oError 6
2203: oGetGlobal 3
2205: oPushResult
2206: oTypeSPush
2207: oPop 1
2209: oReturn
2210: oLocalSpace 1
2212: oGetAddrLocal 1
2214: oPushResult
2215: oGetParam 1
2217: oPushResult
2218: oSetResult 5
2220: oPushResult
2221: oNodeGet
2222: oPop 2
2224: oAssign
2225: oGetLocal 1
2227: oPushResult
2228: oTypeSPush
2229: oPop 1
2231: oTypeSNodeType
2232: oChoice 2497
2234: oGetParam 1
2236: oPushResult
2237: oNodeType
2238: oPop 1
2240: oChoice 2302
2242: oEmit 0
2244: oGetParam 1
2246: oPushResult
2247: oCall 4588
2249: oPop 1
2251: oJumpForward 2310
2253: oEmit 3
2255: oGetParam 1
2257: oPushResult
2258: oCall 4588
2260: oPop 1
2262: oJumpForward 2310
2264: oGetParam 1
2266: oPushResult
2267: oSetResult 12
2269: oPushResult
2270: oNodeGetBoolean
2271: oPop 2
2273: oChoice 2288
2275: oEmit 8
2277: oGetParam 1
2279: oPushResult
2280: oCall 4588
2282: oPop 1
2284: oEmit 14
2286: oJumpForward 2300
2288: Choice Lookup Table
           1   2275
2291: oEmit 6
2293: oGetParam 1
2295: oPushResult
2296: oCall 4588
2298: oPop 1
2300: oJumpForward 2310
2302: Choice Lookup Table
          15   2264
          13   2253
          12   2242
2309: oEndChoice
2310: oJumpForward 2588
2312: oGetParam 1
2314: oPushResult
2315: oNodeType
2316: oPop 1
2318: oChoice 2380
2320: oEmit 1
2322: oGetParam 1
2324: oPushResult
2325: oCall 4588
2327: oPop 1
2329: oJumpForward 2388
2331: oEmit 4
2333: oGetParam 1
2335: oPushResult
2336: oCall 4588
2338: oPop 1
2340: oJumpForward 2388
2342: oGetParam 1
2344: oPushResult
2345: oSetResult 12
2347: oPushResult
2348: oNodeGetBoolean
2349: oPop 2
2351: oChoice 2366
2353: oEmit 8
2355: oGetParam 1
2357: oPushResult
2358: oCall 4588
2360: oPop 1
2362: oEmit 15
2364: oJumpForward 2378
2366: Choice Lookup Table
           1   2353
2369: oEmit 7
2371: oGetParam 1
2373: oPushResult
2374: oCall 4588
2376: oPop 1
2378: oJumpForward 2388
2380: Choice Lookup Table
          15   2342
          13   2331
          12   2320
2387: oEndChoice
2388: oJumpForward 2588
2390: oError 16
2392: oJumpForward 2588
2394: oGetParam 1
2396: oPushResult
2397: oNodeType
2398: oPop 1
2400: oChoice 2462
2402: oEmit 2
2404: oGetParam 1
2406: oPushResult
2407: oCall 4588
2409: oPop 1
2411: oJumpForward 2470
2413: oEmit 5
2415: oGetParam 1
2417: oPushResult
2418: oCall 4588
2420: oPop 1
2422: oJumpForward 2470
2424: oGetParam 1
2426: oPushResult
2427: oSetResult 12
2429: oPushResult
2430: oNodeGetBoolean
2431: oPop 2
2433: oChoice 2448
2435: oEmit 8
2437: oGetParam 1
2439: oPushResult
2440: oCall 4588
2442: oPop 1
2444: oEmit 16
2446: oJumpForward 2460
2448: Choice Lookup Table
           1   2435
2451: oEmit 8
2453: oGetParam 1
2455: oPushResult
2456: oCall 4588
2458: oPop 1
2460: oJumpForward 2470
2462: Choice Lookup Table
          15   2424
          13   2413
          12   2402
2469: oEndChoice
2470: oInputChoice 2492
2472: oTypeSPop
2473: oGetLocal 1
2475: oPushResult
2476: oSetResult 14
2478: oPushResult
2479: oNodeGet
2480: oPop 2
2482: oPushResult
2483: oTypeSPush
2484: oPop 1
2486: oCall 2624
2488: oCall 2589
2490: oJumpForward 2495
2492: Choice Lookup Table
          17   2472
2495: oJumpForward 2588
2497: Choice Lookup Table
          22   2394
          17   2390
          21   2390
          20   2390
          19   2312
          18   2234
2510: oGetParam 1
2512: oPushResult
2513: oNodeType
2514: oPop 1
2516: oChoice 2576
2518: oEmit 10
2520: oGetParam 1
2522: oPushResult
2523: oCall 4588
2525: oPop 1
2527: oJumpForward 2584
2529: oEmit 11
2531: oGetParam 1
2533: oPushResult
2534: oCall 4588
2536: oPop 1
2538: oJumpForward 2584
2540: oGetParam 1
2542: oPushResult
2543: oSetResult 12
2545: oPushResult
2546: oNodeGetBoolean
2547: oPop 2
2549: oChoice 2562
2551: oEmit 8
2553: oGetParam 1
2555: oPushResult
2556: oCall 4588
2558: oPop 1
2560: oJumpForward 2574
2562: Choice Lookup Table
           1   2551
2565: oEmit 12
2567: oGetParam 1
2569: oPushResult
2570: oCall 4588
2572: oPop 1
2574: oJumpForward 2584
2576: Choice Lookup Table
          15   2540
          13   2529
          12   2518
2583: oEndChoice
2584: oCall 2624
2586: oCall 2589
2588: oReturn
2589: oLocalSpace 0
2591: oTypeSNodeType
2592: oChoice 2610
2594: oEmit 14
2596: oJumpForward 2623
2598: oEmit 15
2600: oJumpForward 2623
2602: oError 16
2604: oJumpForward 2623
2606: oEmit 16
2608: oJumpForward 2623
2610: Choice Lookup Table
          22   2606
          17   2602
          21   2602
          20   2602
          19   2598
          18   2594
2623: oReturn
2624: oLocalSpace 0
2626: oInputChoice 2640
2628: oCall 2652
2630: oJumpForward 2649
2632: oCall 2795
2634: oJumpForward 2649
2636: oCall 2893
2638: oJumpForward 2649
2640: Choice Lookup Table
          17   2636
          18   2632
          15   2628
2647: oJumpForward 2651
2649: oJumpBack 2626
2651: oReturn
2652: oLocalSpace 3
2654: oTypeSNodeType
2655: oChoice 2659
2657: oJumpForward 2664
2659: Choice Lookup Table
          23   2657
2662: oError 10
2664: oTypeSNodeType
2665: oChoice 2669
2667: oJumpForward 2674
2669: Choice Lookup Table
          23   2667
2672: oError 13
2674: oGetAddrLocal 1
2676: oPushResult
2677: oTypeSTop
2678: oPushResult
2679: oSetResult 15
2681: oPushResult
2682: oNodeGet
2683: oPop 2
2685: oPushResult
2686: oCall 4536
2688: oPop 1
2690: oAssign
2691: oGetAddrLocal 2
2693: oPushResult
2694: oTypeSTop
2695: oPushResult
2696: oSetResult 14
2698: oPushResult
2699: oNodeGet
2700: oPop 2
2702: oAssign
2703: oTypeSPop
2704: oGetLocal 2
2706: oPushResult
2707: oTypeSPush
2708: oPop 1
2710: oCall 1605
2712: oCall 4336
2714: oGetLocal 1
2716: oPushResult
2717: equal_zero
2718: oPop 1
2720: oChoice 2734
2722: oEmit 9
2724: oGetLocal 1
2726: oPushResult
2727: oEmitInt
2728: oPop 1
2730: oEmit 27
2732: oJumpForward 2737
2734: Choice Lookup Table
           0   2722
2737: oGetAddrLocal 3
2739: oPushResult
2740: oGetLocal 2
2742: oPushResult
2743: oSetResult 2
2745: oPushResult
2746: oNodeGetInt
2747: oPop 2
2749: oAssign
2750: oGetLocal 3
2752: oPushResult
2753: oSetResult 1
2755: oPushResult
2756: equal
2757: oPop 2
2759: oChoice 2773
2761: oEmit 9
2763: oGetLocal 3
2765: oPushResult
2766: oEmitInt
2767: oPop 1
2769: oEmit 23
2771: oJumpForward 2776
2773: Choice Lookup Table
           0   2761
2776: oEmit 25
2778: oInputChoice 2786
2780: oJumpForward 2794
2782: oJumpForward 2792
2784: oJumpForward 2792
2786: Choice Lookup Table
          12   2784
          16   2780
2791: oEndChoice
2792: oJumpBack 2664
2794: oReturn
2795: oLocalSpace 2
2797: oTypeSNodeType
2798: oChoice 2802
2800: oJumpForward 2807
2802: Choice Lookup Table
          25   2800
2805: oError 11
2807: oTypeSTop
2808: oPushResult
2809: oSetResult 18
2811: oPushResult
2812: oNodeGet
2813: oPop 2
2815: oPushResult
2816: oScopeEnter
2817: oPop 1
2819: oInput 0
2821: oGetAddrLocal 1
2823: oPushResult
2824: oScopeFindRequire
2825: oAssign
2826: oGetLocal 1
2828: oPushResult
2829: oNodeType
2830: oPop 1
2832: oChoice 2836
2834: oJumpForward 2841
2836: Choice Lookup Table
          14   2834
2839: oError 12
2841: oScopeEnd
2842: oGetAddrLocal 2
2844: oPushResult
2845: oGetLocal 1
2847: oPushResult
2848: oSetResult 6
2850: oPushResult
2851: oNodeGetInt
2852: oPop 2
2854: oAssign
2855: oGetLocal 2
2857: oPushResult
2858: equal_zero
2859: oPop 1
2861: oChoice 2875
2863: oEmit 9
2865: oGetLocal 2
2867: oPushResult
2868: oEmitInt
2869: oPop 1
2871: oEmit 25
2873: oJumpForward 2878
2875: Choice Lookup Table
           0   2863
2878: oTypeSPop
2879: oGetLocal 1
2881: oPushResult
2882: oSetResult 5
2884: oPushResult
2885: oNodeGet
2886: oPop 2
2888: oPushResult
2889: oTypeSPush
2890: oPop 1
2892: oReturn
2893: oLocalSpace 1
2895: oTypeSNodeType
2896: oChoice 2900
2898: oJumpForward 2905
2900: Choice Lookup Table
          22   2898
2903: oError 9
2905: oEmit 16
2907: oGetAddrLocal 1
2909: oPushResult
2910: oTypeSTop
2911: oAssign
2912: oTypeSPop
2913: oGetLocal 1
2915: oPushResult
2916: oSetResult 14
2918: oPushResult
2919: oNodeGet
2920: oPop 2
2922: oPushResult
2923: oTypeSPush
2924: oPop 1
2926: oReturn
2927: oLocalSpace 0
2929: oCall 4310
2931: oReturn
2932: oLocalSpace 8
2934: oGetAddrLocal 1
2936: oPushResult
2937: oGetParam 1
2939: oPushResult
2940: oNodeType
2941: oPop 1
2943: oPushResult
2944: oSetResult 8
2946: oPushResult
2947: equal_node_type
2948: oPop 2
2950: oAssign
2951: oGetLocal 1
2953: oChoice 2980
2955: oGetAddrLocal 2
2957: oPushResult
2958: oGetParam 1
2960: oPushResult
2961: oSetResult 5
2963: oPushResult
2964: oNodeGet
2965: oPop 2
2967: oAssign
2968: oGetAddrLocal 3
2970: oPushResult
2971: oGetLocal 2
2973: oPushResult
2974: oScopeAllocType
2975: oPop 1
2977: oAssign
2978: oJumpForward 2983
2980: Choice Lookup Table
           1   2955
2983: oGetAddrLocal 4
2985: oPushResult
2986: oGetParam 1
2988: oPushResult
2989: oSetResult 8
2991: oPushResult
2992: oNodeGet
2993: oPop 2
2995: oAssign
2996: oGetAddrLocal 5
2998: oPushResult
2999: oGetLocal 4
3001: oPushResult
3002: oSetResult 2
3004: oPushResult
3005: oNodeGetInt
3006: oPop 2
3008: oAssign
3009: oEmit 40
3011: oGetLocal 5
3013: oPushResult
3014: oEmitInt
3015: oPop 1
3017: oGetAddrLocal 6
3019: oPushResult
3020: oGetLocal 4
3022: oPushResult
3023: oSetResult 1
3025: oPushResult
3026: oNodeGet
3027: oPop 2
3029: oAssign
3030: oInputChoice 3199
3032: oGetLocal 6
3034: oPushResult
3035: oNodeNull
3036: oPop 1
3038: oChoice 3044
3040: oJumpForward 3195
3042: oJumpForward 3047
3044: Choice Lookup Table
           1   3040
3047: oGetAddrLocal 7
3049: oPushResult
3050: oGetLocal 6
3052: oPushResult
3053: oSetResult 6
3055: oPushResult
3056: oNodeGetInt
3057: oPop 2
3059: oAssign
3060: oEmit 13
3062: oGetLocal 7
3064: oPushResult
3065: oEmitInt
3066: oPop 1
3068: oGetLocal 6
3070: oPushResult
3071: oSetResult 5
3073: oPushResult
3074: oNodeGet
3075: oPop 2
3077: oPushResult
3078: oTypeSPush
3079: oPop 1
3081: oGetLocal 6
3083: oPushResult
3084: oSetResult 12
3086: oPushResult
3087: oNodeGetBoolean
3088: oPop 2
3090: oChoice 3158
3092: oCall 3611
3094: oCall 4310
3096: oEmit 19
3098: oJumpForward 3164
3100: oCall 1605
3102: oCall 2927
3104: oTypeSNodeType
3105: oChoice 3123
3107: oEmit 17
3109: oJumpForward 3156
3111: oEmit 18
3113: oJumpForward 3156
3115: oError 16
3117: oJumpForward 3156
3119: oEmit 19
3121: oJumpForward 3156
3123: Choice Lookup Table
          22   3119
          17   3115
          21   3115
          20   3115
          19   3111
          18   3107
3136: oGetAddrLocal 8
3138: oPushResult
3139: oTypeSTop
3140: oPushResult
3141: oSetResult 2
3143: oPushResult
3144: oNodeGetInt
3145: oPop 2
3147: oAssign
3148: oEmit 20
3150: oGetLocal 8
3152: oPushResult
3153: oEmitInt
3154: oPop 1
3156: oJumpForward 3164
3158: Choice Lookup Table
           0   3100
           1   3092
3163: oEndChoice
3164: oTypeSPop
3165: oGetAddrLocal 6
3167: oPushResult
3168: oNodeNext
3169: oPop 1
3171: oGetLocal 6
3173: oPushResult
3174: oNodeNull
3175: oPop 1
3177: oChoice 3185
3179: oJumpForward 3195
3181: oJumpForward 3191
3183: oJumpForward 3191
3185: Choice Lookup Table
           0   3183
           1   3179
3190: oEndChoice
3191: oInput 12
3193: oJumpBack 3032
3195: oInput 14
3197: oJumpForward 3202
3199: Choice Lookup Table
          13   3032
3202: oGetLocal 6
3204: oPushResult
3205: oNodeNull
3206: oPop 1
3208: oChoice 3214
3210: oError 15
3212: oJumpForward 3217
3214: Choice Lookup Table
           0   3210
3217: oGetLocal 1
3219: oChoice 3248
3221: oEmit 13
3223: oGetParam 1
3225: oPushResult
3226: oSetResult 11
3228: oPushResult
3229: oNodeGetInt
3230: oPop 2
3232: oPushResult
3233: oEmitInt
3234: oPop 1
3236: oEmit 11
3238: oGetLocal 3
3240: oPushResult
3241: oEmitInt
3242: oPop 1
3244: oEmit 19
3246: oJumpForward 3251
3248: Choice Lookup Table
           1   3221
3251: oEmit 42
3253: oGetParam 1
3255: oPushResult
3256: oCall 4588
3258: oPop 1
3260: oGetLocal 1
3262: oChoice 3282
3264: oGetLocal 2
3266: oPushResult
3267: oTypeSPush
3268: oPop 1
3270: oEmit 11
3272: oGetLocal 3
3274: oPushResult
3275: oEmitInt
3276: oPop 1
3278: oCall 2589
3280: oJumpForward 3285
3282: Choice Lookup Table
           1   3264
3285: oEmit 41
3287: oGetLocal 5
3289: oPushResult
3290: oEmitInt
3291: oPop 1
3293: oReturn
3294: oLocalSpace 0
3296: oInputChoice 3346
3298: oCall 4207
3300: oJumpForward 3371
3302: oCall 4214
3304: oJumpForward 3371
3306: oCall 4281
3308: oJumpForward 3371
3310: oCall 4284
3312: oJumpForward 3371
3314: oCall 3788
3316: oJumpForward 3371
3318: oCall 4068
3320: oJumpForward 3371
3322: oCall 3846
3324: oJumpForward 3371
3326: oCall 4019
3328: oJumpForward 3371
3330: oCall 4155
3332: oJumpForward 3371
3334: oCall 4123
3336: oJumpForward 3371
3338: oCall 4184
3340: oJumpForward 3371
3342: oCall 3372
3344: oJumpForward 3371
3346: Choice Lookup Table
           0   3342
          32   3338
          48   3334
          49   3330
          46   3326
          41   3322
          45   3318
          38   3314
          57   3310
          56   3306
          55   3302
          54   3298
3371: oReturn
3372: oLocalSpace 1
3374: oGetAddrLocal 1
3376: oPushResult
3377: oScopeFindRequire
3378: oAssign
3379: oGetLocal 1
3381: oPushResult
3382: oNodeType
3383: oPop 1
3385: oChoice 3414
3387: oGetLocal 1
3389: oPushResult
3390: oCall 2932
3392: oPop 1
3394: oJumpForward 3427
3396: oGetLocal 1
3398: oPushResult
3399: oCall 3428
3401: oPop 1
3403: oJumpForward 3427
3405: oGetLocal 1
3407: oPushResult
3408: oCall 3497
3410: oPop 1
3412: oJumpForward 3427
3414: Choice Lookup Table
           8   3405
          15   3396
          13   3396
          12   3396
           7   3387
3425: oError 0
3427: oReturn
3428: oLocalSpace 1
3430: oGetParam 1
3432: oPushResult
3433: oCall 3647
3435: oPop 1
3437: oInput 3
3439: oCall 1605
3441: oCall 4310
3443: oTypeSNodeType
3444: oChoice 3462
3446: oEmit 17
3448: oJumpForward 3495
3450: oEmit 18
3452: oJumpForward 3495
3454: oError 16
3456: oJumpForward 3495
3458: oEmit 19
3460: oJumpForward 3495
3462: Choice Lookup Table
          22   3458
          17   3454
          21   3454
          20   3454
          19   3450
          18   3446
3475: oGetAddrLocal 1
3477: oPushResult
3478: oTypeSTop
3479: oPushResult
3480: oSetResult 2
3482: oPushResult
3483: oNodeGetInt
3484: oPop 2
3486: oAssign
3487: oEmit 20
3489: oGetLocal 1
3491: oPushResult
3492: oEmitInt
3493: oPop 1
3495: oTypeSPop
3496: oReturn
3497: oLocalSpace 1
3499: oGetParam 1
3501: oPushResult
3502: oSetResult 9
3504: oPushResult
3505: oNodeGet
3506: oPop 2
3508: oPushResult
3509: oScopeCurrent
3510: oPushResult
3511: oNodeEqual
3512: oPop 2
3514: oChoice 3520
3516: oError 20
3518: oJumpForward 3523
3520: Choice Lookup Table
           0   3516
3523: oEmit 8
3525: oGetParam 1
3527: oPushResult
3528: oSetResult 11
3530: oPushResult
3531: oNodeGetInt
3532: oPop 2
3534: oPushResult
3535: oEmitInt
3536: oPop 1
3538: oGetParam 1
3540: oPushResult
3541: oSetResult 5
3543: oPushResult
3544: oNodeGet
3545: oPop 2
3547: oPushResult
3548: oTypeSPush
3549: oPop 1
3551: oInput 3
3553: oCall 1605
3555: oCall 4310
3557: oTypeSNodeType
3558: oChoice 3576
3560: oEmit 17
3562: oJumpForward 3609
3564: oEmit 18
3566: oJumpForward 3609
3568: oError 16
3570: oJumpForward 3609
3572: oEmit 19
3574: oJumpForward 3609
3576: Choice Lookup Table
          22   3572
          17   3568
          21   3568
          20   3568
          19   3564
          18   3560
3589: oGetAddrLocal 1
3591: oPushResult
3592: oTypeSTop
3593: oPushResult
3594: oSetResult 2
3596: oPushResult
3597: oNodeGetInt
3598: oPop 2
3600: oAssign
3601: oEmit 20
3603: oGetLocal 1
3605: oPushResult
3606: oEmitInt
3607: oPop 1
3609: oTypeSPop
3610: oReturn
3611: oLocalSpace 1
3613: oInput 0
3615: oGetAddrLocal 1
3617: oPushResult
3618: oScopeFindRequire
3619: oAssign
3620: oGetLocal 1
3622: oPushResult
3623: oNodeType
3624: oPop 1
3626: oChoice 3630
3628: oJumpForward 3639
3630: Choice Lookup Table
          15   3628
          13   3628
          12   3628
3637: oError 4
3639: oGetLocal 1
3641: oPushResult
3642: oCall 3647
3644: oPop 1
3646: oReturn
3647: oLocalSpace 0
3649: oGetParam 1
3651: oPushResult
3652: oNodeType
3653: oPop 1
3655: oChoice 3715
3657: oEmit 10
3659: oGetParam 1
3661: oPushResult
3662: oCall 4588
3664: oPop 1
3666: oJumpForward 3724
3668: oEmit 11
3670: oGetParam 1
3672: oPushResult
3673: oCall 4588
3675: oPop 1
3677: oJumpForward 3724
3679: oGetParam 1
3681: oPushResult
3682: oSetResult 12
3684: oPushResult
3685: oNodeGetBoolean
3686: oPop 2
3688: oChoice 3701
3690: oEmit 8
3692: oGetParam 1
3694: oPushResult
3695: oCall 4588
3697: oPop 1
3699: oJumpForward 3713
3701: Choice Lookup Table
           1   3690
3704: oEmit 12
3706: oGetParam 1
3708: oPushResult
3709: oCall 4588
3711: oPop 1
3713: oJumpForward 3724
3715: Choice Lookup Table
          15   3679
          13   3668
          12   3657
3722: oError 4
3724: oGetParam 1
3726: oPushResult
3727: oSetResult 5
3729: oPushResult
3730: oNodeGet
3731: oPop 2
3733: oPushResult
3734: oTypeSPush
3735: oPop 1
3737: oCall 2624
3739: oReturn
3740: oLocalSpace 0
3742: oGetParam 1
3744: oPushResult
3745: oCall 3647
3747: oPop 1
3749: oCall 4336
3751: oGetParam 1
3753: oPushResult
3754: oCall 2210
3756: oPop 1
3758: oTypeSPop
3759: oEmit 21
3761: oEmit 17
3763: oReturn
3764: oLocalSpace 0
3766: oGetParam 1
3768: oPushResult
3769: oCall 3647
3771: oPop 1
3773: oCall 4336
3775: oGetParam 1
3777: oPushResult
3778: oCall 2210
3780: oPop 1
3782: oTypeSPop
3783: oEmit 22
3785: oEmit 17
3787: oReturn
3788: oLocalSpace 0
3790: oCall 1605
3792: oCall 4363
3794: oInput 39
3796: oEmit 47
3798: oSetResult 2
3800: oPushResult
3801: oPatchPushHere
3802: oPop 1
3804: oEmit 53
3806: oCall 3294
3808: oInputChoice 3836
3810: oEmit 45
3812: oSetResult 2
3814: oPushResult
3815: oPatchPushHere
3816: oPop 1
3818: oEmit 53
3820: oSetResult 2
3822: oPushResult
3823: oPatchSwap
3824: oPop 1
3826: oSetResult 2
3828: oPushResult
3829: oPatchPopFwd
3830: oPop 1
3832: oCall 3294
3834: oJumpForward 3839
3836: Choice Lookup Table
          40   3810
3839: oSetResult 2
3841: oPushResult
3842: oPatchPopFwd
3843: oPop 1
3845: oReturn
3846: oLocalSpace 1
3848: oInput 0
3850: oGetAddrLocal 1
3852: oPushResult
3853: oScopeFindRequire
3854: oAssign
3855: oGetLocal 1
3857: oPushResult
3858: oCall 3647
3860: oPop 1
3862: oCall 4336
3864: oInput 3
3866: oCall 1605
3868: oCall 4336
3870: oEmit 17
3872: oEmit 45
3874: oSetResult 0
3876: oPushResult
3877: oPatchPushHere
3878: oPop 1
3880: oEmit 53
3882: oSetResult 0
3884: oPushResult
3885: oPatchPushHere
3886: oPop 1
3888: oSetResult 0
3890: oPushResult
3891: oPatchSwap
3892: oPop 1
3894: oInputChoice 3986
3896: oGetLocal 1
3898: oPushResult
3899: oCall 3740
3901: oPop 1
3903: oSetResult 0
3905: oPushResult
3906: oPatchPopFwd
3907: oPop 1
3909: oGetLocal 1
3911: oPushResult
3912: oCall 2210
3914: oPop 1
3916: oTypeSPop
3917: oCall 1605
3919: oCall 4336
3921: oEmit 34
3923: oEmit 46
3925: oSetResult 0
3927: oPushResult
3928: oPatchPushHere
3929: oPop 1
3931: oEmit 53
3933: oSetResult 0
3935: oPushResult
3936: oPatchSwap
3937: oPop 1
3939: oJumpForward 3992
3941: oGetLocal 1
3943: oPushResult
3944: oCall 3764
3946: oPop 1
3948: oSetResult 0
3950: oPushResult
3951: oPatchPopFwd
3952: oPop 1
3954: oGetLocal 1
3956: oPushResult
3957: oCall 2210
3959: oPop 1
3961: oTypeSPop
3962: oCall 1605
3964: oCall 4336
3966: oEmit 35
3968: oEmit 46
3970: oSetResult 0
3972: oPushResult
3973: oPatchPushHere
3974: oPop 1
3976: oEmit 53
3978: oSetResult 0
3980: oPushResult
3981: oPatchSwap
3982: oPop 1
3984: oJumpForward 3992
3986: Choice Lookup Table
          43   3941
          42   3896
3991: oEndChoice
3992: oSetResult 0
3994: oPushResult
3995: oCountPush
3996: oPop 1
3998: oInput 44
4000: oCall 3294
4002: oEmit 45
4004: oSetResult 0
4006: oPushResult
4007: oPatchPopBack
4008: oPop 1
4010: oSetResult 0
4012: oPushResult
4013: oPatchPopFwd
4014: oPop 1
4016: oCall 4287
4018: oReturn
4019: oLocalSpace 0
4021: oSetResult 0
4023: oPushResult
4024: oPatchPushHere
4025: oPop 1
4027: oSetResult 0
4029: oPushResult
4030: oCountPush
4031: oPop 1
4033: oCall 3294
4035: oInputChoice 4059
4037: oCall 3294
4039: oJumpForward 4065
4041: oCall 1605
4043: oCall 4363
4045: oEmit 47
4047: oSetResult 0
4049: oPushResult
4050: oPatchPopBack
4051: oPop 1
4053: oCall 4287
4055: oJumpForward 4067
4057: oJumpForward 4065
4059: Choice Lookup Table
          47   4041
           4   4037
4064: oEndChoice
4065: oJumpBack 4035
4067: oReturn
4068: oLocalSpace 0
4070: oSetResult 0
4072: oPushResult
4073: oPatchPushHere
4074: oPop 1
4076: oSetResult 0
4078: oPushResult
4079: oCountPush
4080: oPop 1
4082: oCall 1605
4084: oCall 4363
4086: oInput 44
4088: oEmit 47
4090: oSetResult 0
4092: oPushResult
4093: oPatchPushHere
4094: oPop 1
4096: oEmit 53
4098: oSetResult 0
4100: oPushResult
4101: oPatchSwap
4102: oPop 1
4104: oCall 3294
4106: oEmit 45
4108: oSetResult 0
4110: oPushResult
4111: oPatchPopBack
4112: oPop 1
4114: oSetResult 0
4116: oPushResult
4117: oPatchPopFwd
4118: oPop 1
4120: oCall 4287
4122: oReturn
4123: oLocalSpace 0
4125: oSetResult 0
4127: oPushResult
4128: oPatchAnyEntries
4129: oPop 1
4131: oChoice 4149
4133: oEmit 45
4135: oSetResult 0
4137: oPushResult
4138: oPatchDup
4139: oPop 1
4141: oSetResult 0
4143: oPushResult
4144: oPatchPopBack
4145: oPop 1
4147: oJumpForward 4154
4149: Choice Lookup Table
           1   4133
4152: oError 18
4154: oReturn
4155: oLocalSpace 0
4157: oSetResult 0
4159: oPushResult
4160: oPatchAnyEntries
4161: oPop 1
4163: oChoice 4178
4165: oEmit 45
4167: oSetResult 1
4169: oPushResult
4170: oPatchPushHere
4171: oPop 1
4173: oEmit 53
4175: oCountInc
4176: oJumpForward 4183
4178: Choice Lookup Table
           1   4165
4181: oError 18
4183: oReturn
4184: oLocalSpace 0
4186: oCall 3294
4188: oInputChoice 4198
4190: oCall 3294
4192: oJumpForward 4204
4194: oJumpForward 4206
4196: oJumpForward 4204
4198: Choice Lookup Table
          33   4194
           4   4190
4203: oEndChoice
4204: oJumpBack 4188
4206: oReturn
4207: oLocalSpace 0
4209: oCall 4214
4211: oEmit 52
4213: oReturn
4214: oLocalSpace 0
4216: oInputChoice 4277
4218: oCall 1605
4220: oTypeSNodeType
4221: oChoice 4243
4223: oEmit 48
4225: oJumpForward 4258
4227: oEmit 49
4229: oJumpForward 4258
4231: oEmit 50
4233: oJumpForward 4258
4235: oError 16
4237: oJumpForward 4258
4239: oEmit 51
4241: oJumpForward 4258
4243: Choice Lookup Table
          22   4239
          17   4235
          20   4235
          21   4231
          19   4227
          18   4223
4256: oError 17
4258: oTypeSPop
4259: oInputChoice 4267
4261: oJumpForward 4275
4263: oJumpForward 4273
4265: oJumpForward 4273
4267: Choice Lookup Table
          12   4265
          14   4261
4272: oEndChoice
4273: oJumpBack 4218
4275: oJumpForward 4280
4277: Choice Lookup Table
          13   4218
4280: oReturn
4281: oLocalSpace 0
4283: oReturn
4284: oLocalSpace 0
4286: oReturn
4287: oLocalSpace 0
4289: oCountIsZero
4290: oChoice 4301
4292: oSetResult 1
4294: oPushResult
4295: oPatchPopFwd
4296: oPop 1
4298: oCountDec
4299: oJumpForward 4306
4301: Choice Lookup Table
           0   4292
4304: oJumpForward 4308
4306: oJumpBack 4289
4308: oCountPop
4309: oReturn
4310: oLocalSpace 1
4312: oGetAddrLocal 1
4314: oPushResult
4315: oTypeSNodeType
4316: oAssign
4317: oTypeSPop
4318: oGetLocal 1
4320: oPushResult
4321: oTypeSNodeType
4322: oPushResult
4323: equal_node_type
4324: oPop 2
4326: oChoice 4332
4328: oError 14
4330: oJumpForward 4335
4332: Choice Lookup Table
           0   4328
4335: oReturn
4336: oLocalSpace 0
4338: oTypeSNodeType
4339: oChoice 4343
4341: oJumpForward 4348
4343: Choice Lookup Table
          18   4341
4346: oError 7
4348: oTypeSPop
4349: oReturn
4350: oLocalSpace 0
4352: oTypeSNodeType
4353: oChoice 4357
4355: oJumpForward 4362
4357: Choice Lookup Table
          18   4355
4360: oError 7
4362: oReturn
4363: oLocalSpace 0
4365: oTypeSNodeType
4366: oChoice 4370
4368: oJumpForward 4375
4370: Choice Lookup Table
          19   4368
4373: oError 8
4375: oTypeSPop
4376: oReturn
4377: oLocalSpace 0
4379: oTypeSNodeType
4380: oChoice 4384
4382: oJumpForward 4389
4384: Choice Lookup Table
          19   4382
4387: oError 8
4389: oReturn
4390: oLocalSpace 1
4392: oGetAddrLocal 1
4394: oPushResult
4395: oGetParam 2
4397: oPushResult
4398: oNodeNew
4399: oPop 1
4401: oAssign
4402: oGetLocal 1
4404: oPushResult
4405: oSetResult 2
4407: oPushResult
4408: oGetParam 1
4410: oPushResult
4411: oNodeSetInt
4412: oPop 3
4414: oGetLocal 1
4416: oPushResult
4417: oTypeAdd
4418: oPop 1
4420: oGetLocal 1
4422: oReturn
4423: oReturn
4424: oLocalSpace 1
4426: oGetAddrLocal 1
4428: oPushResult
4429: oGetParam 3
4431: oPushResult
4432: oNodeNew
4433: oPop 1
4435: oAssign
4436: oGetLocal 1
4438: oPushResult
4439: oSetResult 4
4441: oPushResult
4442: oGetParam 1
4444: oPushResult
4445: oNodeSetInt
4446: oPop 3
4448: oGetLocal 1
4450: oReturn
4451: oReturn
4452: oLocalSpace 1
4454: oGetAddrLocal 1
4456: oPushResult
4457: oGetParam 1
4459: oPushResult
4460: oSetResult 13
4462: oPushResult
4463: oNodeGet
4464: oPop 2
4466: oAssign
4467: oGetLocal 1
4469: oPushResult
4470: oNodeNull
4471: oPop 1
4473: oChoice 4529
4475: oGetAddrLocal 1
4477: oPushResult
4478: oSetResult 22
4480: oPushResult
4481: oNodeNew
4482: oPop 1
4484: oAssign
4485: oGetLocal 1
4487: oPushResult
4488: oSetResult 14
4490: oPushResult
4491: oGetParam 1
4493: oPushResult
4494: oNodeSet
4495: oPop 3
4497: oGetLocal 1
4499: oPushResult
4500: oSetResult 2
4502: oPushResult
4503: oSetResult 8
4505: oPushResult
4506: oNodeSetInt
4507: oPop 3
4509: oGetLocal 1
4511: oPushResult
4512: oTypeAdd
4513: oPop 1
4515: oGetParam 1
4517: oPushResult
4518: oSetResult 13
4520: oPushResult
4521: oGetLocal 1
4523: oPushResult
4524: oNodeSet
4525: oPop 3
4527: oJumpForward 4532
4529: Choice Lookup Table
           1   4475
4532: oGetLocal 1
4534: oReturn
4535: oReturn
4536: oLocalSpace 0
4538: oGetParam 1
4540: oPushResult
4541: oNodeType
4542: oPop 1
4544: oChoice 4573
4546: oSetResult 0
4548: oReturn
4549: oJumpForward 4587
4551: oSetResult 0
4553: oReturn
4554: oJumpForward 4587
4556: oSetResult 0
4558: oReturn
4559: oJumpForward 4587
4561: oGetParam 1
4563: oPushResult
4564: oSetResult 16
4566: oPushResult
4567: oNodeGetInt
4568: oPop 2
4570: oReturn
4571: oJumpForward 4587
4573: Choice Lookup Table
          24   4561
          20   4556
          19   4551
          18   4546
4582: oError 3
4584: oSetResult 0
4586: oReturn
4587: oReturn
4588: oLocalSpace 0
4590: oGetParam 1
4592: oPushResult
4593: oSetResult 6
4595: oPushResult
4596: oNodeGetInt
4597: oPop 2
4599: oPushResult
4600: oEmitInt
4601: oPop 1
4603: oReturn
4604: oLocalSpace 1
4606: oGetAddrGlobal 2
4608: oPushResult
4609: oSetResult 17
4611: oPushResult
4612: oSetResult 4
4614: oPushResult
4615: oCall 4390
4617: oPop 2
4619: oAssign
4620: oGetAddrGlobal 3
4622: oPushResult
4623: oSetResult 18
4625: oPushResult
4626: oSetResult 4
4628: oPushResult
4629: oCall 4390
4631: oPop 2
4633: oAssign
4634: oGetAddrGlobal 4
4636: oPushResult
4637: oSetResult 19
4639: oPushResult
4640: oSetResult 1
4642: oPushResult
4643: oCall 4390
4645: oPop 2
4647: oAssign
4648: oGetAddrGlobal 5
4650: oPushResult
4651: oSetResult 20
4653: oPushResult
4654: oSetResult 1
4656: oPushResult
4657: oCall 4390
4659: oPop 2
4661: oAssign
4662: oGetAddrGlobal 6
4664: oPushResult
4665: oSetResult 21
4667: oPushResult
4668: oSetResult 256
4670: oPushResult
4671: oCall 4390
4673: oPop 2
4675: oAssign
4676: oGetAddrLocal 1
4678: oPushResult
4679: oSetResult 10
4681: oPushResult
4682: oSetResult 5
4684: oPushResult
4685: oIdAdd_File
4686: oPushResult
4687: oCall 4424
4689: oPop 3
4691: oAssign
4692: oGetLocal 1
4694: oPushResult
4695: oSetResult 5
4697: oPushResult
4698: oGetGlobal 2
4700: oPushResult
4701: oNodeSet
4702: oPop 3
4704: oGetLocal 1
4706: oPushResult
4707: oScopeDeclare
4708: oPop 1
4710: oGetAddrLocal 1
4712: oPushResult
4713: oSetResult 10
4715: oPushResult
4716: oSetResult 5
4718: oPushResult
4719: oIdAdd_Integer
4720: oPushResult
4721: oCall 4424
4723: oPop 3
4725: oAssign
4726: oGetLocal 1
4728: oPushResult
4729: oSetResult 5
4731: oPushResult
4732: oGetGlobal 3
4734: oPushResult
4735: oNodeSet
4736: oPop 3
4738: oGetLocal 1
4740: oPushResult
4741: oScopeDeclare
4742: oPop 1
4744: oGetAddrLocal 1
4746: oPushResult
4747: oSetResult 10
4749: oPushResult
4750: oSetResult 5
4752: oPushResult
4753: oIdAdd_Boolean
4754: oPushResult
4755: oCall 4424
4757: oPop 3
4759: oAssign
4760: oGetLocal 1
4762: oPushResult
4763: oSetResult 5
4765: oPushResult
4766: oGetGlobal 4
4768: oPushResult
4769: oNodeSet
4770: oPop 3
4772: oGetLocal 1
4774: oPushResult
4775: oScopeDeclare
4776: oPop 1
4778: oGetAddrLocal 1
4780: oPushResult
4781: oSetResult 10
4783: oPushResult
4784: oSetResult 5
4786: oPushResult
4787: oIdAdd_Char
4788: oPushResult
4789: oCall 4424
4791: oPop 3
4793: oAssign
4794: oGetLocal 1
4796: oPushResult
4797: oSetResult 5
4799: oPushResult
4800: oGetGlobal 5
4802: oPushResult
4803: oNodeSet
4804: oPop 3
4806: oGetLocal 1
4808: oPushResult
4809: oScopeDeclare
4810: oPop 1
4812: oGetAddrLocal 1
4814: oPushResult
4815: oSetResult 10
4817: oPushResult
4818: oSetResult 5
4820: oPushResult
4821: oIdAdd_String
4822: oPushResult
4823: oCall 4424
4825: oPop 3
4827: oAssign
4828: oGetLocal 1
4830: oPushResult
4831: oSetResult 5
4833: oPushResult
4834: oGetGlobal 6
4836: oPushResult
4837: oNodeSet
4838: oPop 3
4840: oGetLocal 1
4842: oPushResult
4843: oScopeDeclare
4844: oPop 1
4846: oGetAddrLocal 1
4848: oPushResult
4849: oSetResult 9
4851: oPushResult
4852: oSetResult 4
4854: oPushResult
4855: oIdAdd_True
4856: oPushResult
4857: oCall 4424
4859: oPop 3
4861: oAssign
4862: oGetLocal 1
4864: oPushResult
4865: oSetResult 5
4867: oPushResult
4868: oGetGlobal 4
4870: oPushResult
4871: oNodeSet
4872: oPop 3
4874: oGetLocal 1
4876: oPushResult
4877: oSetResult 6
4879: oPushResult
4880: oSetResult 1
4882: oPushResult
4883: oNodeSetInt
4884: oPop 3
4886: oGetLocal 1
4888: oPushResult
4889: oScopeDeclare
4890: oPop 1
4892: oGetAddrLocal 1
4894: oPushResult
4895: oSetResult 9
4897: oPushResult
4898: oSetResult 4
4900: oPushResult
4901: oIdAdd_False
4902: oPushResult
4903: oCall 4424
4905: oPop 3
4907: oAssign
4908: oGetLocal 1
4910: oPushResult
4911: oSetResult 5
4913: oPushResult
4914: oGetGlobal 4
4916: oPushResult
4917: oNodeSet
4918: oPop 3
4920: oGetLocal 1
4922: oPushResult
4923: oSetResult 6
4925: oPushResult
4926: oSetResult 0
4928: oPushResult
4929: oNodeSetInt
4930: oPop 3
4932: oGetLocal 1
4934: oPushResult
4935: oScopeDeclare
4936: oPop 1
4938: oReturn
