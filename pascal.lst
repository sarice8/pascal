   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nStrLitType :
2586:          decl = @newIdent( nConstStr, id )
2600:          oNodeSetString( decl, qValueStr, oValueTopString )
2611:       | * :  #eNotAllowed
2632:    ]
2632:    oValuePop
2633:    oNodeSet( decl, qType, oTypeSTop )
2644:    oTypeSPop
2645:    oScopeDeclare( decl )
2651:    ';'
2654:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2654: TypedConstDecl:
2656:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2669:    Node theType
2669:    @TypeRef( theType )
2676:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2688:    [ oNodeType( theType )
2695:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2696:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2696:          '='
      
2698:          oTypeSPush( theType )
2704:          @ConstExpr
2706:          @ConstCoerceType
      
2708:          oNodeSetInt( decl, qValue, oValueTop )
2719:          oValuePop
2720:          oTypeSPop
2721:          oScopeDeclare( decl )
2727:          ';'
      
2729:       | nShortStringType, nFileType :
2731:          #eNotImplemented
      
2733:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2735:          oScopeEnter( globalScope )
2741:          int addr = oScopeAllocType( theType )
2751:          oScopeEnd
2752:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2763:          oNodeSetInt( decl, qValue, addr )
2775:          '='
2777:          @TypedConstInit( theType, addr )
2787:          oCodePop
2788:          oScopeDeclare( decl )
2794:          ';'
2796:    ]
2823:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2823: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2825:    [ oNodeType( theType )
2832:       | nArrayType :
2833:          Node baseType = oNodeGet( theType, qBaseType )
2846:          Node indexType = oNodeGet( theType, qIndexType )
2859:          int low = @OrdinalLow( indexType )
2870:          int high = @OrdinalHigh( indexType )
2881:          int elementSize = oNodeGetInt( baseType, qSize )
      
2894:          '('
               % Loop over elements
2896:          int i = low
2902:          {
2902:             @TypedConstInit( baseType, addr )
2912:             [ equal( i, high )
2922:                | true : >
2925:                | false :
2927:             ]
2935:             ','
2937:             addr = add( addr, elementSize )
2950:             inc( i )
2956:          }
2958:          ')'
      
2960:       | nRecordType :
2962:          '('
2964:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2977:          {
2977:             [
2977:                | pIdent :
2979:                | * :  >
2986:             ]
2986:             Node field = oScopeFindRequireInScope( fieldScope )
2996:             ':'
2998:             Node fieldType = oNodeGet( field, qType )
3011:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3031:             @TypedConstInit( fieldType, fieldAddr )
3041:             [
3041:                | ';' :
3043:                | * :  >
3050:             ]
3050:          }
3052:          ')'
      
3054:       | nBooleanType, nByteType, nCharType:
3056:          .tPushAddrGlobal  oEmitInt( addr )
3064:          oTypeSPush( theType )
3070:          @ConstExpr
3072:          @ConstCoerceType
3074:          .tPushConstI  oEmitInt( oValueTop )
3081:          oValuePop
3082:          oTypeSPop
3083:          .tAssignB
      
3085:       | nIntegerType, nEnumType:
3087:          .tPushAddrGlobal  oEmitInt( addr )
3095:          oTypeSPush( theType )
3101:          @ConstExpr
3103:          @ConstCoerceType
3105:          .tPushConstI  oEmitInt( oValueTop )
3112:          oValuePop
3113:          oTypeSPop
3114:          .tAssignI
      
3116:       | nPointerType, nUniversalPointerType :
3118:          .tPushAddrGlobal  oEmitInt( addr )
3126:          oTypeSPush( theType )
3132:          @ConstExpr
3134:          @ConstCoerceType
3136:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3143:          oValuePop
3144:          oTypeSPop
3145:          .tAssignP
      
3147:       | nShortStringType, nFileType :
3149:          #eNotImplemented
3151:    ]
3178:    ;
      
      
3178: TypeDecl:
3180:    {[
3180:       | pIdent :
3182:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3195:          '='
3197:          Node theType
3197:          @TypeRef( theType )
3204:          oNodeSet( decl, qType, theType )
3216:          oScopeDeclare( decl )
3222:          ';'
3224:       | * :
3229:          >
3231:    ]};
      
3234: VarDecl( node_type varNodeType ):
3236:    {[
3236:       | pIdent :
3238:          NodeVec decls = oNodeVecNew
3243:          Node decl
3243:          {
3243:             decl = @newIdent( varNodeType, LAST_ID )
3256:             oNodeVecAppend( decls, decl )
3265:             [
3265:                | ',' :
3267:                   pIdent
3269:                | * :
3274:                   >
3276:             ]
3276:          }
3278:          ':'
3280:          Node theType
3280:          @TypeRef( theType )
      
3287:          int i = 0
3293:          {[ equal( i, oNodeVecSize( decls ) )
3307:             | false :
3308:                decl = oNodeVecElement( decls, i )
3321:                oNodeSet( decl, qType, theType )
3333:                oScopeDeclareAlloc( decl )
3339:                inc( i )
3345:             | * :
3350:               >
3352:          ]}
      
               % optional initialization
3354:          [
3354:             | '=' :
3356:                [ oNodeVecSize( decls )
3363:                   | 1 :
3364:                   | * :  #eOnlyOneVarCanBeInitialized
3371:                ]
      
                     % we need an initCode stream for this scope
3371:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3381:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3387:                boolean changedScope = false
3393:                [ equal_zero( @ScopeLevel )
3400:                   | true : oScopeEnter( initScope )
3407:                            changedScope = true
3413:                   | * :
3418:                ]
                     % generate assignment in initCode stream
3418:                @LValueVar( decl, true )
3428:                @Expr
3430:                @CoerceType
3432:                @Assign
3434:                [ changedScope
3437:                   | true : oScopeEnd
3439:                   | * :
3444:                ]
3444:                oCodePop
                   
3445:             | * :
3450:          ]
      
3450:          oNodeVecDelete( decls )
3456:          ';'
3458:       | * :
3463:          >
3465:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3468: LabelDecl:
3470:    {
3470:       Node decl
3470:       [
3470:          | pIdent :
3472:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3474:             oChangeIntLitToLabelIdent
3475:       ]
3483:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3496:       Label label = oLabelNew
3501:       oNodeSetLabel( decl, qValue, label )
3513:       oScopeDeclare( decl )
3519:       [
3519:          | ',' :
3521:          | * :
3526:             >
3528:       ]
3528:    }
3530:    ';'
3533:    ;
3533: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3533: ConstExpr:
3535:    @ConstBoolExpr
3537:    {[
3537:       | '=' :
3539:          @ConstBoolTerm
3541:          @ConstMatchTypes
3543:          [ oTypeSNodeType
3545:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3554:             | * :             oValueEqual
3560:          ]
3560:          oTypeSPop  oTypeSPush( BooleanType )
3567:       | '<>' :
3569:          @ConstBoolExpr
3571:          @ConstMatchTypes
3573:          [ oTypeSNodeType
3575:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3584:             | * :             oValueNotEqual
3590:          ]
3590:          oTypeSPop  oTypeSPush( BooleanType )
3597:       | '<' :
3599:          @ConstBoolExpr
3601:          @ConstMatchTypes
3603:          [ oTypeSNodeType
3605:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3614:             | * :             oValueLess
3620:          ]
3620:          oTypeSPop  oTypeSPush( BooleanType )
3627:       | '>' :
3629:          @ConstBoolExpr
3631:          @ConstMatchTypes
3633:          [ oTypeSNodeType
3635:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3644:             | * :             oValueGreater
3650:          ]
3650:          oTypeSPop  oTypeSPush( BooleanType )
3657:       | '<=' :
3659:          @ConstBoolExpr
3661:          @ConstMatchTypes
3663:          [ oTypeSNodeType
3665:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3674:             | * :             oValueLessEqual
3680:          ]
3680:          oTypeSPop  oTypeSPush( BooleanType )
3687:       | '>=' :
3689:          @ConstBoolExpr
3691:          @ConstMatchTypes
3693:          [ oTypeSNodeType
3695:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3704:             | * :             oValueGreaterEqual
3710:          ]
3710:          oTypeSPop  oTypeSPush( BooleanType )
3717:       | * :  >
3734:    ]};
      
      
3737: ConstBoolExpr:
3739:    @ConstBoolTerm
3741:    {[
3741:       | pOr :
3743:          @ConstRequireBool
3745:          @ConstBoolTerm
3747:          @ConstRequireBoolPop
3749:          oValueOr
3750:       | * :  >
3757:    ]};
      
      
3760: ConstBoolTerm:
3762:    @ConstBoolFactor
3764:    {[
3764:       | pAnd :
3766:          @ConstRequireBool
3768:          @ConstBoolFactor
3770:          @ConstRequireBoolPop
3772:          oValueAnd
3773:       | * :  >
3780:    ]};
      
      
3783: ConstBoolFactor:
3785:    [
3785:       | pNot :
3787:          @ConstBoolFactor
3789:          @ConstRequireBool
3791:          oValueNot
3792:       | * :
3797:          @ConstArithExpr
3799:    ];
      
      
3800: ConstArithExpr:
3802:    @ConstTerm
3804:    {[
3804:       | '+' :
3806:          @ConstTerm
3808:          @ConstMatchTypes
3810:          [ oTypeSNodeType
3812:             | nStrLitType :   oValueStringConcat
3814:             | * :             oValueAdd
3820:          ]
3820:       | '-' :
3822:          @ConstTerm
3824:          @ConstMatchTypes
3826:          [ oTypeSNodeType
3828:             | nStrLitType :   #eNotAllowed
3831:             | * :             oValueSub
3837:          ]
3837:       | * :  >
3846:    ]};
      
      
3849: ConstTerm:
3851:    @ConstFactor
3853:    {[
3853:       | pTimes :
3855:          @ConstFactor
3857:          @ConstMatchTypes
3859:          [ oTypeSNodeType
3861:             | nStrLitType :   #eNotAllowed
3864:             | * :             oValueMult
3870:          ]
3870:       | pDivide :
3872:          @ConstFactor
3874:          @ConstMatchTypes
3876:          [ oTypeSNodeType
3878:             | nStrLitType :   #eNotAllowed
3881:             | * :             oValueDiv
3887:          ]
3887:       | * :  >
3896:    ]};
      
      
3899: ConstFactor:
3901:    [
3901:       | pPlus :
3903:          @ConstPrimary
3905:       | pMinus :
3907:          @ConstPrimary
3909:          oValueNegate
3910:       | * :
3917:          @ConstPrimary
3919:    ];
      
      
3920: ConstPrimary:
3922:    [
3922:       | pIntLit :
3924:          oValuePush( TOKEN_VALUE )
3929:          oTypeSPush( IntegerType )
3935:       | pCharLit :
3937:          oValuePush( TOKEN_VALUE )
3942:          oTypeSPush( CharType )
3948:       | pStrLit :
3950:          oValuePushString( CURRENT_STRLIT )
3955:          oTypeSPush( StrLitType )
3961:       | '(' :
3963:          @ConstExpr
3965:          ')'
3967:       | pIdent :
3969:          Node decl = oScopeFindRequire
3974:          @ResolveUnitRef( decl )
3981:          [ oNodeType( decl )
3988:             | nBuiltInFunc :
3989:                @ConstBuiltInFunc( decl )
3996:             | nConst :
3998:                oValuePush( oNodeGetInt( decl, qValue ) )
4011:                oTypeSPush( oNodeGet( decl, qType ) )
4024:             | nConstStr :
4026:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4039:                oTypeSPush( oNodeGet( decl, qType ) )
4052:             | nEnumValue :
4054:                oValuePush( oNodeGetInt( decl, qValue ) )
4067:                oTypeSPush( oNodeGet( decl, qType ) )
4080:             | * :
4091:                #eNotConst
4093:                oValuePush( 0 )
4099:                oTypeSPush( IntegerType )
4105:          ]
4105:       | '@' :
4107:          #eNotImplemented
4109:          oValuePush( 0 )
4115:          oTypeSPush( UniversalPointerType )
4121:       | * :
4136:          #eNotConst
4138:          oValuePush( 0 )
4144:          oTypeSPush( IntegerType )
4150:    ];
      
4151: ConstRequireBoolPop:
4153:    [ oTypeSNodeType
4155:       | nBooleanType :
4156:       | * :          #eNotBoolean
4163:    ]
4163:    oTypeSPop;
      
      
4165: ConstRequireBool:
4167:    [ oTypeSNodeType
4169:       | nBooleanType :
4170:       | * :          #eNotBoolean
4177:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4178: ConstMatchTypes:
4180:    node_type nt = oTypeSNodeType
4185:    oTypeSPop
4186:    [ equal_node_type( nt, oTypeSNodeType )
4195:       | false :
               % Some implicit conversion is allowed even here
4196:          [ oTypeSNodeType
4198:             | nPointerType :
4199:                [ nt
4202:                   | nUniversalPointerType :  >>
4204:                   | * :
4209:                ]
4209:             | nUniversalPointerType :
4211:                [ nt
4214:                   | nPointerType :  >>
4216:                   | * :
4221:                ]
4221:             | nStrLitType :
4223:                [ nt
4226:                   | nCharType :
4227:                      oValueCharToString
4228:                      >>
4229:                   | * :
4234:                ]
4234:             | nCharType :
4236:                [ nt
4239:                   | nStrLitType :
4240:                      oValueSwap
4241:                      oValueCharToString
4242:                      oValueSwap
4243:                      oTypeSPop
4244:                      oTypeSPush( StrLitType )
4250:                      >>
4251:                   | * :
4256:                ]
4256:             | * :
4267:          ]
4267:          #eTypeMismatch
4269:       | * :
4274:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4275: ConstCoerceType:
4277:    node_type nt = oTypeSNodeType
4282:    oTypeSPop
4283:    [ equal_node_type( nt, oTypeSNodeType )
4292:       | false :
               % Can we implicitly convert the value to the desired type?
4293:          [ oTypeSNodeType
4295:             | nIntegerType :
4296:                [ nt
4299:                   | nByteType :  >>
4301:                   | * :
4306:                ]
4306:             | nByteType :
4308:                [ nt
4311:                   | nIntegerType :  >>
4313:                   | * :
4318:                ]
4318:             | nPointerType :
4320:                [ nt
4323:                   | nUniversalPointerType :  >>
4325:                   | * :
4330:                ]
4330:             | nUniversalPointerType :
4332:                [ nt
4335:                   | nPointerType :  >>
4337:                   | * :
4342:                ]
4342:             | nStrLitType :
4344:                [ nt
4347:                   | nCharType :
4348:                      oValueCharToString
4349:                      >>
4350:                   | * :
4355:                ]
4355:             | nShortStringType :
4357:                [ nt
4360:                   | nStrLitType :  >>
4362:                   | nCharType :
4364:                      oValueCharToString
4365:                      >>
4366:                   | * :
4373:                ]
4373:             | * :
4388:          ]
4388:          #eTypeMismatch
4390:       | * :
4395:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4396: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4398:    [ oNodeEqual( method, BuiltIn_Ord )
4408:       | true :
4409:          '('
4411:          @ConstExpr
4413:          ')'
4415:          [ oTypeSNodeType
4417:             | nIntegerType, nEnumType :
4418:             | nBooleanType, nByteType, nCharType :
4420:             | * :  #eTypeMismatch
4435:          ]
4435:          oTypeSPop
4436:          oTypeSPush( IntegerType )
4442:          ')'
4444:          >>
4445:       | * :
4450:    ]
      
         % Chr(x)
4450:    [ oNodeEqual( method, BuiltIn_Chr )
4460:       | true :
4461:          '('
4463:          @ConstExpr
4465:          ')'
4467:          [ oTypeSNodeType
4469:             | nIntegerType :
4470:             | nByteType :
4472:             | * :  #eTypeMismatch
4481:          ]
4481:          oTypeSPop
4482:          oTypeSPush( CharType )
4488:          ')'
4490:          >>
4491:       | * :
4496:    ]
      
         % Pred(x)
4496:    [ oNodeEqual( method, BuiltIn_Pred )
4506:       | true :
4507:          '('
4509:          @ConstExpr
4511:          [ oTypeSNodeType
4513:             | nEnumType :
4514:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4523:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4526:                   | * :
4531:                ]
4531:             | * :  #eTypeMismatch
4538:          ]
4538:          oValuePush( 1 )  oValueSub
4545:          ')'
4547:          >>
4548:       | * :
4553:    ]
      
         % Succ(x)
4553:    [ oNodeEqual( method, BuiltIn_Succ )
4563:       | true :
4564:          '('
4566:          @ConstExpr
4568:          [ oTypeSNodeType
4570:             | nEnumType :
4571:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4580:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4583:                   | * :
4588:                ]
4588:             | * :  #eTypeMismatch
4595:          ]
4595:          oValuePush( 1 )  oValueAdd
4602:          ')'
4604:          >>
4605:       | * :
4610:    ]
      
4610:    #eNotImplemented
4613:    ;
      
      
4613: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4613: Expr:
4615:    Label falseLabel = labelNull
      
4621:    @ExprAllowFlow( falseLabel )
4628:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4636: BooleanExprControlFlow( out Label falseLabel ):
4638:    @ExprAllowFlow( falseLabel )
4645:    [ oTypeSNodeType
4647:       | nBooleanFlowType :
4648:       | nBooleanType :
               % convert value to control flow
4650:          falseLabel = oLabelNew
4655:          .tJumpFalse  oEmitLabel( falseLabel )
4663:       | * :
4670:          #eNotBoolean
4672:    ]
4672:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4674: FlowToVal( inout Label falseLabel ):
4676:    [ oTypeSNodeType
4678:       | nBooleanFlowType :
4679:          Label doneLabel = oLabelNew
4684:          .tPushConstI  oEmitInt( 1 )
4692:          .tJump  oEmitLabel( doneLabel )
4700:          .tLabel  oEmitLabel( falseLabel )
4708:          .tPushConstI  oEmitInt( 0 )
4716:          .tLabel  oEmitLabel( doneLabel )
4724:          oTypeSPop
4725:          oTypeSPush( BooleanType )
4731:          falseLabel = labelNull
4737:       | * :
4742:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4743: ValToFlow( out Label falseLabel ):
4745:    [ oTypeSNodeType
4747:       | nBooleanType :
4748:          falseLabel = oLabelNew
4753:          .tJumpFalse  oEmitLabel( falseLabel )
4761:          oTypeSPop
4762:          oTypeSPush( BooleanFlowType )
4768:       | * :
4773:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4774: ExprAllowFlow( out Label falseLabel ):
4776:    @BoolExprAllowFlow( falseLabel )
4783:    {[
4783:       | '=' :
4785:          @FlowToVal( falseLabel )
4792:          @PromoteToIntOptional
4794:          @BoolExprAllowFlow( falseLabel )
4801:          @FlowToVal( falseLabel )
4808:          @PromoteToIntOptional
4810:          @MatchTypes
4812:          [ oTypeSNodeType
4814:             | nBooleanType, nCharType :     .tEqualB
4817:             | nIntegerType, nEnumType :     .tEqualI
4821:             | nPointerType, nUniversalPointerType :    .tEqualP
4825:             | nShortStringType, nStrLitType :
4827:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
4839:             | * :                           #eNotAllowed
4860:          ]
4860:          oTypeSPop
4861:          oTypeSPush( BooleanType )
      
4867:       | '<>' :
4869:          @FlowToVal( falseLabel )
4876:          @PromoteToIntOptional
4878:          @BoolExprAllowFlow( falseLabel )
4885:          @FlowToVal( falseLabel )
4892:          @PromoteToIntOptional
4894:          @MatchTypes
4896:          [ oTypeSNodeType
4898:             | nBooleanType, nCharType :     .tNotEqualB
4901:             | nIntegerType, nEnumType :     .tNotEqualI
4905:             | nPointerType, nUniversalPointerType :    .tNotEqualP
4909:             | nShortStringType, nStrLitType :
4911:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
4923:             | * :                           #eNotAllowed
4944:          ]
4944:          oTypeSPop
4945:          oTypeSPush( BooleanType )
      
4951:       | '<' :
4953:          @FlowToVal( falseLabel )
4960:          @PromoteToIntOptional
4962:          @BoolExprAllowFlow( falseLabel )
4969:          @FlowToVal( falseLabel )
4976:          @PromoteToIntOptional
4978:          @MatchTypes
4980:          [ oTypeSNodeType
4982:             | nBooleanType, nCharType :     .tLessB
4985:             | nIntegerType, nEnumType :     .tLessI
4989:             | nPointerType, nUniversalPointerType :   .tLessP
4993:             | nShortStringType, nStrLitType :
4995:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5007:             | * :                           #eNotAllowed
5028:          ]
5028:          oTypeSPop
5029:          oTypeSPush( BooleanType )
      
5035:       | '>' :
5037:          @FlowToVal( falseLabel )
5044:          @PromoteToIntOptional
5046:          @BoolExprAllowFlow( falseLabel )
5053:          @FlowToVal( falseLabel )
5060:          @PromoteToIntOptional
5062:          @MatchTypes
5064:          [ oTypeSNodeType
5066:             | nBooleanType, nCharType :     .tGreaterB
5069:             | nIntegerType, nEnumType :     .tGreaterI
5073:             | nPointerType, nUniversalPointerType :   .tGreaterP
5077:             | nShortStringType, nStrLitType :
5079:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5091:             | * :                           #eNotAllowed
5112:          ]
5112:          oTypeSPop
5113:          oTypeSPush( BooleanType )
      
5119:       | '<=' :
5121:          @FlowToVal( falseLabel )
5128:          @PromoteToIntOptional
5130:          @BoolExprAllowFlow( falseLabel )
5137:          @FlowToVal( falseLabel )
5144:          @PromoteToIntOptional
5146:          @MatchTypes
5148:          [ oTypeSNodeType
5150:             | nBooleanType, nCharType :     .tLessEqualB
5153:             | nIntegerType, nEnumType :     .tLessEqualI
5157:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5161:             | nShortStringType, nStrLitType :
5163:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5175:             | * :                           #eNotAllowed
5196:          ]
5196:          oTypeSPop
5197:          oTypeSPush( BooleanType )
      
5203:       | '>=' :
5205:          @FlowToVal( falseLabel )
5212:          @PromoteToIntOptional
5214:          @BoolExprAllowFlow( falseLabel )
5221:          @FlowToVal( falseLabel )
5228:          @PromoteToIntOptional
5230:          @MatchTypes
5232:          [ oTypeSNodeType
5234:             | nBooleanType, nCharType :     .tGreaterEqualB
5237:             | nIntegerType, nEnumType :     .tGreaterEqualI
5241:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5245:             | nShortStringType, nStrLitType :
5247:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5259:             | * :                           #eNotAllowed
5280:          ]
5280:          oTypeSPop
5281:          oTypeSPush( BooleanType )
      
5287:       | * :
5302:          >
5304:    ]};
      
      
5307: BoolExprAllowFlow( out Label falseLabel ):
5309:    Label trueLabel = labelNull
      
5315:    @BoolTermAllowFlow( falseLabel )
5322:    {[
5322:       | pOr :
5324:          [ oTypeSNodeType
5326:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5327:                [ equal_label( trueLabel, labelNull )
5337:                   | true :  trueLabel = oLabelNew
5343:                   | * :
5348:                ]
5348:                .tJump  oEmitLabel( trueLabel )
5356:             | nBooleanType :
5358:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5365:                [ equal_label( trueLabel, labelNull )
5375:                   | true :  trueLabel = oLabelNew
5381:                   | * :
5386:                ]
5386:                .tJump  oEmitLabel( trueLabel )
5394:             | * : #eNotBoolean
5403:          ]
5403:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5404:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5412:          falseLabel = labelNull
5418:          @BoolTermAllowFlow( falseLabel )
      
5425:          [ oTypeSNodeType
5427:             | nBooleanFlowType :
5428:             | nBooleanType :
5430:                @ValToFlow( falseLabel )
5437:             | * : #eNotBoolean
5446:          ]
      
5446:          oTypeSPop
5447:          oTypeSPush( BooleanFlowType )
      
5453:       | * :
5458:          >
5460:    ]}
      
         % any short-circuit trues jump here to the end
5462:    [ equal_label( trueLabel, labelNull )
5472:       | false :
5473:          .tLabel  oEmitLabel( trueLabel )
5481:       | * :
5486:    ]
5487:    ;
      
      
5487: BoolTermAllowFlow( out Label falseLabel ):
5489:    Label overallFalseLabel = labelNull
      
5495:    @BoolFactorAllowFlow( falseLabel )
5502:    {[
5502:       | pAnd :
5504:          [ oTypeSNodeType
5506:             | nBooleanFlowType :
5507:             | nBooleanType :
5509:                @ValToFlow( falseLabel )
5516:             | * :
5523:                #eNotBoolean
5525:          ]
5525:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5526:          [ equal_label( overallFalseLabel, labelNull )
5536:             | true :
5537:                overallFalseLabel = oLabelNew
5542:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5556:                falseLabel = overallFalseLabel
5562:             | * :
5567:          ]
      
5567:          Label factorFalseLabel = labelNull
5573:          @BoolFactorAllowFlow( factorFalseLabel )
      
5580:          [ oTypeSNodeType
5582:             | nBooleanFlowType :
5583:             | nBooleanType :
5585:                @ValToFlow( factorFalseLabel )
5592:             | * : #eNotBoolean
5601:          ]
5601:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5615:       | * :
5620:          >
5622:    ]};
      
      
5625: BoolFactorAllowFlow( out Label falseLabel ):
5627:    [
5627:       | pNot :
5629:          Label factorFalseLabel = labelNull
      
5635:          @BoolFactorAllowFlow( factorFalseLabel )
5642:          [ oTypeSNodeType
5644:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5645:                falseLabel = oLabelNew
5650:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5658:                .tLabel  oEmitLabel( factorFalseLabel )
      
5666:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5668:                .tNot
      
5670:             | * : #eNotBoolean
5679:          ]
      
5679:       | * :
5684:          @ArithExprAllowFlow( falseLabel )
5691:    ];
      
      
5692: ArithExprAllowFlow( out Label falseLabel ):
5694:    boolean first = true
5700:    int tempStrOffset
      
5700:    @TermAllowFlow( falseLabel )
5707:    {[
5707:       | '+' :
5709:          [ oTypeSNodeType
5711:             | nIntegerType, nByteType :
5712:                @PromoteToIntPop
5714:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5721:                [ oTypeSNodeType
5723:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5724:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5726:                      @PointerAddition
5728:                   | * :
5735:                      @PromoteToInt
5737:                      .tAddI
5739:                ]
      
5739:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5741:                [ first
5744:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5745:                             tempStrOffset = @MoveIntoTempShortString
5751:                             first = false
5757:                   | * :
5762:                ]
5762:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5769:                [ oTypeSNodeType
5771:                   | nShortStringType, nStrLitType :
5772:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5774:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5782:                      oTypeSPush( ShortStringType )
5788:                   | nCharType :
5790:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5792:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5800:                      oTypeSPush( ShortStringType )
5806:                   | * :
5815:                      #eTypeMismatch
5817:                      oTypeSPop
5818:                ]
      
5818:             | nPointerType, nUniversalPointerType :
5820:                @TermAllowFlow( falseLabel )   % actually not allowing CF
5827:                @PromoteToIntPop
5829:                @PointerAddition
      
5831:             | * :
5848:                #eNotAllowed
5850:          ]
      
5850:       | '-' :
5852:          [ oTypeSNodeType
5854:             | nIntegerType, nByteType :
5855:                @PromoteToIntPop
5857:                @TermAllowFlow( falseLabel )
5864:                @PromoteToInt
5866:                .tSubI
      
5868:             | nPointerType, nUniversalPointerType :
5870:                @TermAllowFlow( falseLabel )
5877:                [ oTypeSNodeType
5879:                   | nIntegerType, nByteType :
5880:                      @PromoteToIntPop
5882:                      @PointerSubInt
5884:                   | nPointerType, nUniversalPointerType :
5886:                      @MatchTypes
5888:                      @PointerSubPointer
5890:                   | * :
5901:                      #eNotAllowed
5903:                ]
      
5903:             | * :  #eNotAllowed
      
5916:          ]
5916:       | * :
5923:          >
5925:    ]};
      
      
5928: TermAllowFlow( out Label falseLabel ):
5930:    @FactorAllowFlow( falseLabel )
5937:    {[
5937:       | pTimes :
5939:          @PromoteToIntPop
5941:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5948:          @PromoteToInt
5950:          .tMultI
5952:       | pDivide :
5954:          @PromoteToIntPop
5956:          @FactorAllowFlow( falseLabel )
5963:          @PromoteToInt
5965:          .tDivI
5967:       | * :
5974:          >
5976:    ]};
      
      
5979: FactorAllowFlow( out Label falseLabel ):
5981:    [
5981:       | pPlus :
5983:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5990:          @PromoteToInt
5992:       | pMinus :
5994:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6001:          @PromoteToInt
6003:          .tNegI
6005:       | * :
6012:          @PrimaryAllowFlow( falseLabel )
6019:    ];
      
      
6020: PrimaryAllowFlow( out Label falseLabel ):
6022:    [
6022:       | pIntLit :
6024:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6031:          oTypeSPush( IntegerType )
      
6037:       | pCharLit :
6039:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6046:          oTypeSPush( CharType )
      
6052:       | '(' :
6054:          @ExprAllowFlow( falseLabel )
6061:          ')'
      
6063:       | pStrLit :
6065:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6074:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6082:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6088:          @LValueIndexes
               % get final value of dereferencing, if any
6090:          @FetchVar
      
6092:       | pIdent :
6094:          Node decl = oScopeFindRequire
6099:          @ResolveUnitRef( decl )
6106:          Node theType
      
6106:          [ oNodeType( decl )
6113:             | nFunc :
6114:                @Call( decl )
      
6121:             | nBuiltInFunc :
6123:                @CallBuiltInFunc( decl )
      
6130:             | nConst, nEnumValue :
6132:                theType = oNodeGet( decl, qType )
6145:                oTypeSPush( theType )
6151:                [ oTypeSNodeType
6153:                   | nIntegerType, nEnumType, nBooleanType :
6154:                      .tPushConstI @EmitValue( decl )
6163:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6165:                      .tPushConstI @EmitValue( decl )
6174:                   | * :
6187:                      #eNotImplemented
6189:                ]
      
6189:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6191:                int addr = oNodeGetInt( decl, qValue )
6204:                [ equal_zero( addr )
6211:                   | true :
6212:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6229:                      oNodeSetInt( decl, qValue, addr )
6241:                   | * :
6246:                ]
6246:                .tPushAddrGlobal oEmitInt( addr )
6254:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6260:                @LValueIndexes
                     % get final value of dereferencing, if any
6262:                @FetchVar
      
6264:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6266:                @VarExpr( decl )
      
6273:             | * :
6294:                #eNotValue
6296:                oTypeSPush( IntegerType )
6302:          ]
      
6302:       | '@' :        % @var -- pointer to var
6304:          pIdent
      
6306:          Node decl = oScopeFindRequire
6311:          @ResolveUnitRef( decl )
6318:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6318:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6328:          theType = oTypeSTop
6333:          oTypeSPop
6334:          Node ptrType = @PointerTypeTo( theType )
6345:          oTypeSPush( ptrType )
      
6351:       | * :
6366:          #eNotValue
6368:          oTypeSPush( IntegerType )
6374:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6375: VarExpr( Node decl ):
6377:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6390:    int uplevels = @DeclUpLevels( decl )
      
6401:    oTypeSPush( theType )
6407:    [ oTypeSNodeType
6409:       | nIntegerType, nEnumType :
6410:          [ oNodeType( decl )
6417:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6427:             | nLocalVar :
6429:                [ equal_zero( uplevels )
6436:                   | true :  .tPushLocalI  @EmitValue( decl )
6446:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6466:                ]
6466:             | nParam :
6468:                [ oNodeGetBoolean( decl, qInOut )
6478:                   | true :    % VAR param points to the var.  Auto dereference.
6479:                      [ equal_zero( uplevels )
6486:                         | true :  .tPushParamP  @EmitValue( decl )
6496:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6516:                      ]
6516:                      .tFetchI
6518:                   | * :
6523:                      [ equal_zero( uplevels )
6530:                         | true :  .tPushParamI  @EmitValue( decl )
6540:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6560:                      ]
6560:                ]
6560:          ]
      
6572:       | nBooleanType, nByteType, nCharType :
6574:          [ oNodeType( decl )
6581:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6591:             | nLocalVar :
6593:                [ equal_zero( uplevels )
6600:                   | true :  .tPushLocalB  @EmitValue( decl )
6610:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6630:                ]
6630:             | nParam :
6632:                [ oNodeGetBoolean( decl, qInOut )
6642:                   | true :    % VAR param points to the var.  Auto dereference.
6643:                      [ equal_zero( uplevels )
6650:                         | true :  .tPushParamP  @EmitValue( decl )
6660:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6680:                      ]
6680:                      .tFetchB
6682:                   | * :
6687:                      [ equal_zero( uplevels )
6694:                         | true :  .tPushParamB  @EmitValue( decl )
6704:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6724:                      ]
6724:                ]
6724:          ]
      
6736:       | nFileType :
6738:          #eNotImplemented
      
6740:       | nPointerType, nUniversalPointerType :
6742:          [ oNodeType( decl )
6749:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6759:             | nLocalVar :
6761:                [ equal_zero( uplevels )
6768:                   | true :  .tPushLocalP  @EmitValue( decl )
6778:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6798:                ]
6798:             | nParam :
6800:                [ oNodeGetBoolean( decl, qInOut )
6810:                   | true :    % VAR param points to the var.  Auto dereference.
6811:                      [ equal_zero( uplevels )
6818:                         | true :  .tPushParamP  @EmitValue( decl )
6828:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6848:                      ]
6848:                      .tFetchP
6850:                   | * :
6855:                      [ equal_zero( uplevels )
6862:                         | true :  .tPushParamP  @EmitValue( decl )
6872:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6892:                      ]
6892:                ]               
6892:          ]
6904:          [
6904:             | '^' :             % dereferenced
6906:                oTypeSPop
6907:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6920:                @LValueIndexes
6922:                @FetchVar
6924:             | '[' :             % dereferencing pointer like an array [0..] of baseType
6926:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
6928:                @LValueIndexes
6930:                @FetchVar
6932:             | * :               % just ptr value alone
6939:          ]
      
6939:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
6941:          [ oNodeType( decl )
6948:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6958:             | nLocalVar :
6960:                [ equal_zero( uplevels )
6967:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6977:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6997:                ]
6997:             | nParam :
6999:                [ oNodeGetBoolean( decl, qInOut )
7009:                   | true :    % VAR param points to the var.  Auto dereference.
7010:                      [ equal_zero( uplevels )
7017:                         | true :  .tPushParamP  @EmitValue( decl )
7027:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7047:                      ]
7047:                   | * :
7052:                      [ equal_zero( uplevels )
7059:                         | true :  .tPushAddrParam  @EmitValue( decl )
7069:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7089:                      ]
7089:                ]
7089:          ]
               % modify addr for subscripts, field references, etc
7101:          @LValueIndexes
               % get final value
7103:          @FetchVar
7105:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7132: FetchVar:
7134:    [ oTypeSNodeType
7136:       | nIntegerType, nEnumType :  .tFetchI
7139:       | nBooleanType, nByteType, nCharType :  .tFetchB
7143:       | nFileType :   #eNotImplemented
7147:       | nPointerType :             .tFetchP
7151:       | nUniversalPointerType :    #eCantDereference
7155:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7157:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7186: LValueIndexes:
7188:    {[
7188:       | '[' :
7190:          [ oTypeSNodeType
7192:             | nArrayType :    @ArraySubscripts
7195:             | nPointerType :  @PointerArraySubscript
7199:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7203:             | * :             #eNotArray
7216:          ]
7216:       | '.' :       @RecordFieldRef
7220:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7224:       | * :         >
7235:    ]};
      
      
7238: ArraySubscripts:
7240:    [ oTypeSNodeType
7242:       | nArrayType :
7243:       | * :       #eNotArray
7250:    ]
7250:    {
7250:       [ oTypeSNodeType
7252:          | nArrayType :
7253:          | * :    #eTooManySubscripts
7260:       ]
      
            % low subscript of this dimension
7260:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7277:       Node baseType
7277:       baseType = oNodeGet( oTypeSTop, qBaseType )
7289:       oTypeSPop
7290:       oTypeSPush( baseType )
      
7296:       @Expr
7298:       @RequireIntPop
            % adjust for low subscript
7300:       [ equal_zero( low )
7307:          | false :
7308:             .tPushConstI oEmitInt( low ) .tSubI
7318:          | * :
7323:       ]
      
            % multiply by element size
7323:       int size = oNodeGetInt( baseType, qSize )
7336:       [ equal( size, 1 )
7346:          | false :
7347:             .tPushConstI oEmitInt( size ) .tMultI
7357:          | * :
7362:       ]
      
            % update start address
7362:       .tAddPI
7364:       [
7364:          | ']' :  >
7368:          | ',' :
7370:       ]
7378:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7381: PointerArraySubscript:
7383:    [ oTypeSNodeType
7385:       | nPointerType :
7386:       | * :    #eCantDereference
7393:    ]
         % replace type stack with base type
7393:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7405:    oTypeSPop
7406:    oTypeSPush( baseType )
         
7412:    @Expr
7414:    @RequireIntPop
         % multiply by element size
7416:    int size = oNodeGetInt( baseType, qSize )
7429:    [ equal( size, 1 )
7439:       | false :
7440:          .tPushConstI  oEmitInt( size )  .tMultI
7450:       | * :
7455:    ]
         % update start address
7455:    .tAddPI
7457:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7460: ShortStringArraySubscript:
7462:    [ oTypeSNodeType
7464:       | nStrLitType, nShortStringType :
7465:       | * :    #eCantDereference
7474:    ]
7474:    oTypeSPop
7475:    oTypeSPush( CharType )
7481:    @Expr
7483:    @RequireIntPop
7485:    .tAddPI
7487:    ']';
      
      
7490: RecordFieldRef:
7492:    [ oTypeSNodeType
7494:       | nRecordType :
7495:       | * :    #eNotRecord
7502:    ]
7502:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7514:    pIdent
7516:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7521:    [ oNodeType( field )
7528:       | nRecordField :
7529:       | * :   #eNotRecordField
7536:    ]
7536:    oScopeEnd
7537:    int offset = oNodeGetInt( field, qValue )
7550:    [ equal_zero( offset )
7557:       | false :
7558:          .tPushConstI oEmitInt( offset ) .tAddPI
7568:       | * :
7573:    ]
      
         % replace the type on the type stack, with the field type
7573:    oTypeSPop
7574:    oTypeSPush( oNodeGet( field, qType ) )
7588:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7588: PointerAddition:
7590:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7602:    int elementSize = oNodeGetInt( elementType, qSize )
7615:    [ equal( elementSize, 1 )
7625:       | false :
7626:          .tPushConstI  oEmitInt( elementSize )
7634:          .tMultI
7636:       | * :
7641:    ]
7641:    .tAddPI
7644:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7644: PointerSubInt:
7646:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7658:    int elementSize = oNodeGetInt( elementType, qSize )
7671:    [ equal( elementSize, 1 )
7681:       | false :
7682:          .tPushConstI  oEmitInt( elementSize )
7690:          .tMultI
7692:       | * :
7697:    ]
7697:    .tSubPI
7700:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7700: PointerSubPointer:
7702:    .tSubP
7704:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7716:    int elementSize = oNodeGetInt( elementType, qSize )
7729:    [ equal( elementSize, 1 )
7739:       | false :
7740:          .tPushConstI  oEmitInt( elementSize )
7748:          .tDivI
7750:       | * :
7755:    ]
7755:    oTypeSPop
7756:    oTypeSPush( IntegerType )
7763:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7763: PointerDeref:
7765:    [ oTypeSNodeType
7767:       | nPointerType :
7768:       | nUniversalPointerType :   #eCantDereference
7772:       | * :       #eNotPointer
7781:    ]
7781:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7783:    Node theType = oTypeSTop
7788:    oTypeSPop
7789:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7803:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7803: CoerceType:
7805:    node_type nt = oTypeSNodeType
7810:    oTypeSPop
7811:    [ equal_node_type( nt, oTypeSNodeType )
7820:       | false :
               % Can we implicitly convert the value to the desired type?
7821:          [ oTypeSNodeType
7823:             | nIntegerType :
7824:                [ nt
7827:                   | nByteType :   .tCastBtoI  >>
7831:                   | * :
7836:                ]
7836:             | nByteType :
7838:                [ nt
7841:                   | nIntegerType :   .tCastItoB  >>
7845:                   | * :
7850:                ]
7850:             | nPointerType :
7852:                [ nt
7855:                   | nUniversalPointerType :  >>
7857:                   | nStrLitType :
7859:                      [ equal_node( oTypeSTop, PCharType )
7868:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7869:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7880:                         | * :
7885:                      ]
7885:                   | * :
7892:                ]
7892:             | nUniversalPointerType :
7894:                [ nt
7897:                   | nPointerType :  >>
7899:                   | * :
7904:                ]
7904:             | nShortStringType :
7906:                [ nt
7909:                   | nStrLitType :  >>
7911:                   | nCharType :
                           % Store char as a temp ShortString.
7913:                      oTypeSPush( CharType )
7919:                      int tempOffset = @MoveIntoTempShortString
7925:                      oTypeSPop
7926:                      >>
7927:                   | * :
7934:                ]
7934:             | * :
7947:          ]
7947:          #eTypeMismatch
7949:       | * :
7954:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7955: MatchTypes:
7957:    node_type nt = oTypeSNodeType
7962:    oTypeSPop
7963:    [ equal_node_type( nt, oTypeSNodeType )
7972:       | false :
               % Some implicit conversion is allowed even here
7973:          [ oTypeSNodeType
7975:             | nPointerType :
7976:                [ nt
7979:                   | nUniversalPointerType :  >>
7981:                   | * :
7986:                ]
7986:             | nUniversalPointerType :
7988:                [ nt
7991:                   | nPointerType :  >>
7993:                   | * :
7998:                ]
7998:             | * :
8005:          ]
8005:          #eTypeMismatch
8007:       | * :
8012:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8013: RequireIntPop:
8015:    [ oTypeSNodeType
8017:       | nIntegerType :
8018:       | * :          #eNotInteger
8025:    ]
8025:    oTypeSPop;
      
8027: RequireInt:
8029:    [ oTypeSNodeType
8031:       | nIntegerType :
8032:       | * :          #eNotInteger
8039:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8040: PromoteToIntPop:
8042:    [ oTypeSNodeType
8044:       | nIntegerType :
8045:       | nByteType :        .tCastBtoI
8049:       | * :                #eNotInteger
8058:    ]
8058:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8060: PromoteToInt:
8062:    [ oTypeSNodeType
8064:       | nIntegerType :
8065:       | nByteType :        .tCastBtoI
8069:                            oTypeSPop
8070:                            oTypeSPush( IntegerType )
8076:       | * :                #eNotInteger
8085:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8086: PromoteToIntOptional:
8088:    [ oTypeSNodeType
8090:       | nByteType :        .tCastBtoI
8093:                            oTypeSPop
8094:                            oTypeSPush( IntegerType )
8100:       | * :
8105:    ];
      
      
8106: RequireBoolPop:
8108:    [ oTypeSNodeType
8110:       | nBooleanType :
8111:       | * :          #eNotBoolean
8118:    ]
8118:    oTypeSPop;
      
8120: RequireBool:
8122:    [ oTypeSNodeType
8124:       | nBooleanType :
8125:       | * :          #eNotBoolean
8132:    ];
      
      
8133: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8133: Statement:
8135:    [
8135:       | pWriteln :     @WritelnStmt
8139:       | pWrite :       @WriteStmt
8143:       | pReadln :      @ReadlnStmt
8147:       | pRead :        @ReadStmt
8151:       | pIf :          @IfStmt
8155:       | pWhile :       @WhileStmt
8159:       | pFor :         @ForStmt
8163:       | pRepeat :      @RepeatStmt
8167:       | pBreak :       @BreakStmt
8171:       | pContinue :    @ContinueStmt
8175:       | pBegin :       @BeginStmt
8179:       | pIdent :       @LabelOrAssignOrCallStmt
8183:       | pCase :        @CaseStmt
8187:       | pGoto :        @GotoStmt
8191:       | pIntLit :      % should be an integer label
8193:                        oChangeIntLitToLabelIdent
8194:                        @LabelOrAssignOrCallStmt
8196:       | * :            % null statement : don't accept any tokens
8229:    ];
      
      
8230: LabelOrAssignOrCallStmt:
8232:    Node decl = oScopeFindRequire
8237:    @ResolveUnitRef( decl )
8244:    [ oNodeType( decl )
8251:       | nLabel :                          @LabelDefinition( decl )
8259:                                           @Statement
8261:       | nProc :                           @Call( decl )
8270:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8279:       | nFunc :                           @AssignResultStmt( decl )
8288:       | * :                               #eBadStatement
8305:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8306: LabelDefinition( Node decl ):
8308:    [ oNodeGetBoolean( decl, qDefined )
8318:       | true :  #eAlreadyDefined
8321:       | * :
8326:    ]
8326:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8341:    oNodeSetBoolean( decl, qDefined, true )
8353:    ':'
8356:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8356: AssignStmt( Node decl ):
      
8358:    @LValueVar( decl, true )
8368:    ':=' 
8370:    @Expr
8372:    @CoerceType
8374:    @Assign
8377:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8377: Assign:
8379:    [ oTypeSNodeType
8381:       | nIntegerType, nEnumType :  .tAssignI
8384:       | nBooleanType, nByteType, nCharType :  .tAssignB
8388:       | nFileType :   #eNotImplemented
8392:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8396:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
8398:           int size = oNodeGetInt( oTypeSTop, qSize )
8410:           .tCopy  oEmitInt( size )    % multi-word copy
8418:    ]
8444:    oTypeSPop
8446:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8446: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8448:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8464:       | false :   #eNotCurrentFunction
8467:       | * :
8472:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8472:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8487:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8500:    ':='
8502:    @Expr
8504:    @CoerceType
8506:    [ oTypeSNodeType
8508:       | nIntegerType, nEnumType : .tAssignI
8511:       | nBooleanType, nByteType, nCharType :  .tAssignB
8515:       | nFileType :   #eNotImplemented
8519:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8523:       | nArrayType, nRecordType, nShortStringType :
8525:           int size = oNodeGetInt( oTypeSTop, qSize )
8537:           .tCopy  oEmitInt( size )    % multi-word copy
8545:    ]
8571:    oTypeSPop
8573:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
8573: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8575:    pIdent
8577:    Node decl = oScopeFindRequire
8582:    @ResolveUnitRef( decl )
8589:    [ oNodeType( decl )
8596:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
8597:       | * :  #eNotVar
8610:    ]
8610:    @LValueVar( decl, writeable )
8621:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8621: LValueVar( Node decl, boolean writeable ):
8623:    [ oNodeType( decl )
8630:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8640:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8651:       | nParam :
8653:          [ oNodeGetBoolean( decl, qInOut )
8663:             | true :   % VAR param points to variable.  No dereference.
8664:                        .tPushParamP @EmitValue( decl )
8673:             | * :      .tPushAddrParam @EmitValue( decl )
8687:          ]
8687:       | nTypedConst :
8689:          [ writeable
8692:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
8702:             | * :      #eNotVar
8709:          ]
8709:       | * :            #eNotVar
8722:    ]
      
8722:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
8735:    [ oTypeSNodeType
8737:       | nPointerType :
8738:          [
8738:             | '[' :
                     % dereference the pointer var first
8740:                .tFetchP
8742:                @PointerArraySubscript
8744:             | * :
8749:          ]
8749:       | * :
8754:    ]
         % additional subscripts, if any
8754:    @LValueIndexes
8757:    ;
      
      
8757: IncVar( Node decl ):
8759:    @LValueVar( decl, true )
8769:    @RequireIntPop
8771:    @VarExpr( decl )
8778:    oTypeSPop
8779:    .tIncI
8781:    .tAssignI;
      
8784: DecVar( Node decl ):
8786:    @LValueVar( decl, true )
8796:    @RequireIntPop
8798:    @VarExpr( decl )
8805:    oTypeSPop
8806:    .tDecI
8808:    .tAssignI;
      
      
8811: IfStmt:
8813:    Label falseLabel = labelNull
      
8819:    @BooleanExprControlFlow( falseLabel )
8826:    pThen
8828:    @Statement
8830:    [
8830:       | pElse :
8832:          Label doneLabel = oLabelNew
      
8837:          .tJump  oEmitLabel( doneLabel )
8845:          .tLabel oEmitLabel( falseLabel )
8853:          @Statement
8855:          .tLabel oEmitLabel( doneLabel )
      
8863:       | * :
8868:          .tLabel oEmitLabel( falseLabel )
8876:    ];
      
      
8877: ForStmt:
8879:    pIdent
      
8881:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8886:    @LValueVar( decl, true )
8896:    @RequireIntPop
      
8898:    ':='
      
8900:    @Expr
8902:    @RequireIntPop
8904:    .tAssignI
      
8906:    Label breakLabel = oLabelNew
      
8911:    Label checkLabel = oLabelNew
8916:    .tJump  oEmitLabel( checkLabel )
      
8924:    Label continueLabel = oLabelNew
8929:    .tLabel  oEmitLabel( continueLabel )
8937:    [
8937:       | pTo :
8939:          @IncVar( decl )
8946:          .tLabel  oEmitLabel( checkLabel )
8954:          @VarExpr( decl )  oTypeSPop
8962:          @Expr
8964:          @RequireIntPop
8966:          .tGreaterI
8968:          .tJumpTrue  oEmitLabel( breakLabel )
8976:       | pDownto :
8978:          @DecVar( decl )
8985:          .tLabel  oEmitLabel( checkLabel )
8993:          @VarExpr( decl )  oTypeSPop
9001:          @Expr
9003:          @RequireIntPop
9005:          .tLessI
9007:          .tJumpTrue  oEmitLabel( breakLabel )
9015:    ]
9023:    oLoopPush( continueLabel, breakLabel )
9032:    pDo
9034:    @Statement
9036:    .tJump  oEmitLabel( continueLabel )
9044:    .tLabel  oEmitLabel( breakLabel )
9052:    oLoopPop;
      
      
9054: RepeatStmt:
9056:    Label continueLabel = oLabelNew
9061:    .tLabel  oEmitLabel( continueLabel )
      
9069:    Label breakLabel = oLabelNew
      
9074:    oLoopPush( continueLabel, breakLabel )
9083:    @Statement
9085:    {[
9085:       | ';' :
9087:          @Statement
9089:       | pUntil :
9091:          Label falseLabel
9091:          @BooleanExprControlFlow( falseLabel )
9098:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9112:          >
9114:    ]}
9124:    .tLabel  oEmitLabel( breakLabel )
9132:    oLoopPop;
      
      
9134: WhileStmt:
9136:    Label continueLabel = oLabelNew
9141:    .tLabel  oEmitLabel( continueLabel )
      
9149:    Label breakLabel
9149:    @BooleanExprControlFlow( breakLabel )
      
9156:    oLoopPush( continueLabel, breakLabel )
9165:    pDo
9167:    @Statement
9169:    .tJump  oEmitLabel( continueLabel )
9177:    .tLabel  oEmitLabel( breakLabel )
9185:    oLoopPop;
      
      
9187: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9189:    [ equal_label( oLoopContinueLabel, labelNull )
9198:       | true :
9199:          #eNotInALoop
9201:       | false :
9203:          .tJump  oEmitLabel( oLoopContinueLabel )
9210:    ];
      
      
9219: BreakStmt:
9221:    [ equal_label( oLoopBreakLabel, labelNull )
9230:       | true :
9231:          #eNotInALoop
9233:       | false :
9235:          .tJump  oEmitLabel( oLoopBreakLabel )
9242:    ];
      
      
9251: CaseStmt:
9253:    Code tableCode = oCodeNew
9258:    Label tableLabel = oLabelNew
9263:    Label doneLabel = oLabelNew
9268:    Label otherwiseLabel = doneLabel
9274:    boolean isString = false
      
9280:    @Expr
         % Leave the expr type on the type stack throughout case statement
9282:    [ oTypeSNodeType
9284:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
9293:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
9303:       | nShortStringType, nStrLitType :        isString = true
9311:                                                .tJumpCaseS  oEmitLabel( tableLabel )
9319:       | * :     #eNotAllowed
9338:    ]
9338:    pOf
      
9340:    {
9340:       [
9340:          | pOtherwise, pElse :
9342:             otherwiseLabel = oLabelNew
9347:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
9355:             {[
9355:                | pEnd :  >
9359:                | * :
9364:                   @Statement
9366:                   [
9366:                      | ';' :
9368:                      | * :   pEnd  >
9377:                   ]
9377:             ]}
9379:             >
      
9381:          | pEnd :
                  % Reached end with no otherwise clause
9383:             >
      
9385:          | * :
9394:             Label caseLabel = oLabelNew
9399:             oCodePush( tableCode )
9405:             {
9405:                @ConstExpr
9407:                @ConstCoerceType
9409:                int val
9409:                [ isString
9412:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
9422:                   | false :   val = oValueTop
9429:                ]
9437:                oValuePop
9438:                [
9438:                   | '..' :  @ConstExpr
9442:                             @ConstCoerceType
9444:                             int highval
9444:                             [ isString
9447:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
9457:                                | false :  highval = oValueTop
9464:                             ]
9472:                             oValuePop
9473:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
9493:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
9512:                ]
9512:                [
9512:                   | ',' :
9514:                   | * :  >
9521:                ]
9521:             }
9523:             oCodePop
9524:             ':'
9526:             .tLabel  oEmitLabel( caseLabel )
9534:             @Statement
9536:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
9544:             [
9544:                | ';' :
9546:                | * :
9551:             ]
                  
9551:       ]
         
9551:    }
      
9553:    .tLabel  oEmitLabel( tableLabel )
9561:    oEmitCode( tableCode )
9567:    .tCaseEnd  oEmitLabel( otherwiseLabel )
9575:    .tLabel  oEmitLabel( doneLabel )
9583:    oTypeSPop
9585:    ;
      
      
9585: GotoStmt:
9587:    [
9587:       | pIdent :
9589:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9591:          oChangeIntLitToLabelIdent
9592:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9600:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9609:    oNodeSetBoolean( decl, qUsed, true )
9621:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9637:    ;
      
      
9637: BeginStmt:
9639:    @Statement
9641:    {[
9641:       | ';' :   @Statement
9645:       | pEnd :  >
9649:    ]};
      
      
9660: WritelnStmt:
9662:    @WriteStmt
9664:    .tWriteCR;
      
      
9667: WriteStmt:
9669:    [
9669:       | '(' :
9671:          {
9671:             @Expr
9673:             [ oTypeSNodeType
9675:                | nIntegerType :             .tWriteI
9678:                | nBooleanType :             .tWriteBool
9682:                | nByteType :                .tCastBtoI  .tWriteI
9688:                | nCharType :                .tWriteChar
9692:                | nShortStringType, nStrLitType :   .tWriteShortStr
9696:                | nFileType :                #eNotImplemented
9700:                | nEnumType :
                        % write name via table lookup
9702:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9716:                   .tWriteEnum
9718:                | nPointerType :
9720:                   [ equal_node( oTypeSTop, PCharType )
9729:                      | true :               .tWritePChar
9732:                      | * :                  .tWriteP
9739:                   ]
9739:                | nUniversalPointerType :    .tWriteP
9743:                | * :                        #eNotAllowed
9768:             ]
9768:             oTypeSPop
9769:             [
9769:                | ')' : >
9773:                | ',' :
9775:             ]
9783:          }
9785:       | * :
9790:    ];
      
      
9791: ReadlnStmt:      % ***
         % TO DO
9794:    ;
      
9794: ReadStmt:
         % TO DO
9797:    ;
9797: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9797: MoveIntoTempShortString >> int:
9799:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9809:    [ oTypeSNodeType
9811:       | nShortStringType, nStrLitType :
9812:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9820:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9822:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9837:       | nCharType :
               % temp[0] = 1
9839:          .tPushAddrLocal  oEmitInt( tempOffset )
9847:          .tPushConstI  oEmitInt( 1 )
9855:          .tAssignB
               % temp[1] = value
9857:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9872:          .tSwap
9874:          .tAssignB
9876:       | * :   #eTypeMismatch
9887:    ]
9887:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9888:    .tPushAddrLocal  oEmitInt( tempOffset )
9896:    oTypeSPush( ShortStringType )
9902:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9906: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9908:    .tAllocActuals  oEmitInt( 16 )
9916:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9928:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9940:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9949:    .tFreeActuals  oEmitInt( 16 )
9957:    oTypeSPop
9958:    oTypeSPop
9960:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9960: ShortStringAppendChar:
         % Note at the moment I don't align params
9962:    .tAllocActuals  oEmitInt( 12 )
9970:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
9982:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9994:    .tCall  @EmitValue( System_ShortStringAppendChar )
10003:    .tFreeActuals  oEmitInt( 12 )
10011:    oTypeSPop
10012:    oTypeSPop
10014:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
10014: ShortStringCmp:
10016:    .tAllocActualsCdecl  oEmitInt( 24 )
10024:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10036:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10048:    int tempOffset = oScopeAllocType( IntegerType )
10058:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10076:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
10085:    .tPushLocalI  oEmitInt( tempOffset )
10093:    .tFreeActuals  oEmitInt( 24 )
10101:    oTypeSPop
10102:    oTypeSPush( IntegerType )
10109:    ;
10109: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10109: Call( Node method ):
10111:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
10123:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
10136:    Node resultType
10136:    int tempOffset
      
10136:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
10153:    [ isFunc
10156:       | true :
10157:          resultType = oNodeGet( method, qType )
10170:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
10180:       | * :
10185:    ]
         
      
10185:    Node paramScope = oNodeGet( method, qParams )
10198:    int actualsSize = oNodeGetInt( paramScope, qSize )
10211:    [ cdecl
10214:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
10223:       | false :  .tAllocActuals  oEmitInt( actualsSize )
10233:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
10241:    [ greater( @DeclLevel( method ), 0 )
10256:       | true :
10257:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
10265:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
10284:          .tAssignP
10286:       | * :
10291:    ]
      
      
10291:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
10304:    Node param = oNodeIterValue( paramIter )
10314:    [
10314:       | '(' :
            
10316:          {
10316:             [ oNodeNull( param )
10323:                | true : >
10326:                | * :
10331:             ]
      
10331:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
10344:             .tPushAddrActual oEmitInt( offset )
10352:             oTypeSPush( oNodeGet( param, qType ) )
      
10365:             [ oNodeGetBoolean( param, qInOut )
10375:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
10376:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
10383:                           @MatchTypes
      
10385:                           .tAssignP
      
10387:                | false :  @Expr
10391:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
10393:                           [ oTypeSNodeType
10395:                              | nIntegerType, nEnumType : .tAssignI
10398:                              | nBooleanType, nByteType, nCharType :  .tAssignB
10402:                              | nFileType :   #eNotImplemented
10406:                              | nPointerType, nUniversalPointerType :  .tAssignP
10410:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
10412:                                  int size = oNodeGetInt( oTypeSTop, qSize )
10424:                                  .tCopy  oEmitInt( size )    % multi-word copy
10432:                           ]
10458:             ]
10466:             oTypeSPop
      
10467:             oNodeIterNext( paramIter )
10473:             param = oNodeIterValue( paramIter )
10483:             [ oNodeNull( param )
10490:                | true :  >
10493:                | false :
10495:             ]
      
10503:             ','
10505:          }
      
10507:          ')'
      
10509:       | * :
10514:    ]
      
10514:    [ oNodeNull( param )
10521:       | false :    #eMissingParameter
10524:       | * :
10529:    ]
      
10529:    [ isFunc
10532:       | true :
               % Pass result temp as an additional VAR parameter.
10533:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10548:          .tPushAddrLocal  oEmitInt( tempOffset )
10556:          .tAssignP
10558:       | * :
10563:    ]
      
10563:    [ cdecl
10566:       | true :
10567:          .tCallCdecl  @EmitValue( method )
10576:       | false :
10578:          .tCall   @EmitValue( method )
10587:    ]
      
10595:    [ isFunc
10598:       | true :
               % push return value from temp
10599:          oTypeSPush( resultType )
      
10605:          [ oTypeSNodeType
10607:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10616:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10626:             | nFileType :  #eNotImplemented
10630:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10640:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10642:                                .tPushAddrLocal  oEmitInt( tempOffset )
10650:          ]
10676:       | * :
10681:    ]
         
10681:    .tFreeActuals  oEmitInt( actualsSize )
10690:    ;
      
      
      
      % Called on first use of an extern method
      %
10690: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
10692:    int strAddr
10692:    String externalName = oNodeGetString( method, qExternalName )
10705:    [ equal_string( externalName, stringNull )
10715:       | true :
10716:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
10737:       | false :
10739:          strAddr = oStringAllocLit( externalName )
10749:    ]
10757:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
10773:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10773: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10775:    [ oNodeEqual( method, BuiltIn_Ord )
10785:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10786:          '('
10788:          @Expr
10790:          [ oTypeSNodeType
10792:             | nIntegerType, nEnumType :
10793:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10797:             | * :  #eTypeMismatch
10812:          ]
10812:          oTypeSPop
10813:          oTypeSPush( IntegerType )
10819:          ')'
10821:          >>
10822:       | * :
10827:    ]
      
         % Chr(x)
10827:    [ oNodeEqual( method, BuiltIn_Chr )
10837:       | true :
               % parameter is integer
               % result is char
10838:          '('
10840:          @Expr
10842:          [ oTypeSNodeType
10844:             | nIntegerType :    .tCastItoB
10847:             | nByteType :
10849:             | * :  #eTypeMismatch
10858:          ]
10858:          oTypeSPop
10859:          oTypeSPush( CharType )
10865:          ')'
10867:          >>
10868:       | * :
10873:    ]
      
         % Pred(x)
10873:    [ oNodeEqual( method, BuiltIn_Pred )
10883:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10884:          '('
10886:          @Expr
10888:          [ oTypeSNodeType
10890:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10891:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10900:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10903:                   | * :
10908:                ]
10908:             | * :  #eTypeMismatch
10915:          ]
10915:          .tDecI
10917:          ')'
10919:          >>
10920:       | * :
10925:    ]
      
         % Succ(x)
10925:    [ oNodeEqual( method, BuiltIn_Succ )
10935:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10936:          '('
10938:          @Expr
10940:          [ oTypeSNodeType
10942:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10943:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10952:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10955:                   | * :
10960:                ]
10960:             | * :  #eTypeMismatch
10967:          ]
10967:          .tIncI
10969:          ')'
10971:          >>
10972:       | * :
10977:    ]
      
10977:    #eNotImplemented
10980:    ;
      
10980: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10980: newType( node_type nt, int size ) >> Node:
10982:   Node node = oNodeNew( nt )
10992:   oNodeSetInt( node, qSize, size )
11004:   oTypeAdd( node )
11010:   >> node
11014:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11014: TypeRef( out Node resultType ):
11016:    [
11016:       | pIdent :           % previously named type (including intrinsics)
11018:          Node decl = oScopeFindRequire
11023:          @ResolveUnitRef( decl )
11030:          [ oNodeType( decl )
11037:             | nTypeDecl :
11038:                resultType = oNodeGet( decl, qType )
11051:             | * :
11056:                #eNotType
11058:                resultType = IntegerType
11064:          ]
         
11064:       | pArray :
11066:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
11068:          NodeVec dimensions = oNodeVecNew
      
11073:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
11073:             Node subrange = oNodeNew( nSubrangeType )
      
11083:             @ConstExpr
11085:             oNodeSetInt( subrange, qLow, oValueTop )
11096:             oValuePop
11097:             '..'
11099:             @ConstExpr
11101:             oNodeSetInt( subrange, qHigh, oValueTop )
11112:             oValuePop
      
11113:             @ConstMatchTypes
11115:             oNodeSet( subrange, qBaseType, oTypeSTop )
11126:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
11144:             oTypeSPop
11145:             oTypeAdd( subrange )
      
11151:             Node a = oNodeNew( nArrayType )
11161:             oNodeSet( a, qIndexType, subrange )
      
11173:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
11182:             [
11182:                | ']' : >
11186:                | ',' :
11188:             ]
11196:          }
      
11198:          pOf
11200:          Node baseType
11200:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
11207:          int dim = oNodeVecSize( dimensions )
      
11217:          {
11217:              dec(dim)
      
11223:              Node a = oNodeVecElement( dimensions, dim )
      
11236:              oNodeSet( a, qBaseType, baseType )
11248:              Node subrange = oNodeGet( a, qIndexType )
11261:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
11288:              inc( width )
11294:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
11320:              oTypeAdd( a )
11326:              baseType = a
      
11332:              [ equal_zero(dim)
11339:                  | true:  >
11342:                  | *:
11347:              ]
11347:          }
      
11349:          resultType = oNodeVecElement( dimensions, 0 )
11362:          oNodeVecDelete( dimensions )
      
11368:       | '^' :
11370:          Node theType
11370:          @TypeRef( theType )
11377:          resultType = @PointerTypeTo( theType )
      
11388:       | pRecord :
11390:          resultType = oNodeNew( nRecordType )
11400:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
11409:          @VarDecl( nRecordField )
      
11416:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
11428:          [ equal_zero( size )
11435:             | true : #eRecordEmpty
11438:             | * :
11443:          ]
      
11443:          pEnd
      
11445:          oNodeSet( resultType, qScope, oScopeCurrent )
11456:          oNodeSetInt( resultType, qSize, size )
11468:          oScopeEnd
11469:          oTypeAdd( resultType )
      
      
11475:       | '(' :
               % An enum type declaration.
11477:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
11484:       | pSet :
11486:          pOf
11488:          Node theType
11488:          @TypeRef( theType )
11495:          #eNotImplemented
11497:       | * :       % this works for cases except where expr starts with an id
11512:          @ConstExpr '..' @ConstExpr
11518:          @ConstMatchTypes
11520:          #eNotImplemented
11522:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
11523: EnumTypeRef( out Node resultType ):
      
11525:    resultType = oNodeNew( nEnumType )
11535:    int value = 0
11541:    int numValues = 0
11547:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
11553:    Node outerScope = oScopeCurrent
11558:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
11567:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
11567:       pIdent
11569:       Node decl = @newIdent( nEnumValue, LAST_ID )
11582:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
11595:       oNodeSet( decl, qType, resultType )
11607:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
11619:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
11632:       oNodeSetInt( decl, qNameOffset, nameOffset )
11644:       oNodeSetInt( decl2, qNameOffset, nameOffset )
11656:       [
11656:          | '=', ':=' :
11658:             oTypeSPush( IntegerType )
11664:             @ConstExpr
11666:             @ConstCoerceType
11668:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
11669:             [ equal_zero( numValues )
11676:                | false :
11677:                   [ greater( oValueTop, value )
11686:                      | false :   #eEnumValueNotAscending
11689:                      | * :
11694:                   ]
11694:                | * :
11699:             ]
11699:             [ equal( value, oValueTop )
11708:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
11709:                   oNodeSetBoolean( resultType, qHasGap, true )
11721:                | * :
11726:             ]
11726:             value = oValueTop
11731:             oValuePop
11732:          | * :
11739:       ]
11739:       oNodeSetInt( decl, qValue, value )
11751:       oNodeSetInt( decl2, qValue, value )
11763:       oScopeDeclare( decl )
      
11769:       oScopeEnter( outerScope )
11775:       oScopeDeclare( decl2 )
11781:       oScopeEnd
      
11782:       inc( value )
11788:       inc( numValues )
11794:       [
11794:          | ',' :
11796:          | * :    >
11803:       ]
11803:    }
11805:    ')'
      
11807:    oNodeSet( resultType, qScope, oScopeCurrent )
11818:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
11830:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
11831:    oCodePush( @GetOrCreateInitCode( globalScope ) )
11842:    oScopeEnter( globalScope )
11848:    int size = multiply( add( numValues, 1 ), 16 )
11868:    int addr = oScopeAlloc( size, 8 )
11881:    oScopeEnd
11882:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
11894:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
11914:    {
11914:       Node enumValue = oNodeIterValue( it )
11924:       [ oNodeNull( enumValue )
11931:          | true :  >
11934:          | * :
11939:       ]
11939:       .tPushAddrGlobal  oEmitInt( addr )
11947:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
11962:       .tAssignI
11964:       addr = add( addr, 8 )
11977:       .tPushAddrGlobal  oEmitInt( addr )
11985:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12000:       .tAssignP
12002:       addr = add( addr, 8 )
12015:       oNodeIterNext( it )
12021:    }
         % final table entry
12023:    .tPushAddrGlobal  oEmitInt( addr )
12031:    .tPushConstI  oEmitInt( 0 )
12039:    .tAssignI
12041:    addr = add( addr, 8 )
12054:    .tPushAddrGlobal  oEmitInt( addr )
12062:    .tPushConstI  oEmitInt( 0 )
12070:    .tAssignP
12072:    addr = add( addr, 8 )
12085:    oCodePop
      
12086:    oTypeAdd( resultType )
12093:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12093: PointerTypeTo( Node theType ) >> Node:
12095:    Node ptrType = oNodeGet( theType, qPointerType )
12108:    [ oNodeNull( ptrType )
12115:       | true :
12116:          ptrType = oNodeNew( nPointerType )
12126:          oNodeSet( ptrType, qBaseType, theType )
12138:          oNodeSetInt( ptrType, qSize, 8 )
12150:          oTypeAdd( ptrType )
12156:          oNodeSet( theType, qPointerType, ptrType )
12168:       | * :
12173:    ]
12173:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
12177: OrdinalLow( Node theType ) >> int:
12179:    [ oNodeType( theType )
12186:       | nIntegerType :  >> oMININT
12189:       | nBooleanType :  >> 0
12194:       | nCharType :     >> 0
12199:       | nEnumType :
12201:          Node enumScope = oNodeGet( theType, qScope )
12214:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12231:          >> oNodeGetInt( first, qValue )
12241:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12253:       | * :             #eNotOrdinalType
12268:                         >> 0
12271:    ];
      
      
      % Return the high value of an ordinal type
      %
12272: OrdinalHigh( Node theType ) >> int:
12274:    [ oNodeType( theType )
12281:       | nIntegerType :  >> oMAXINT
12284:       | nBooleanType :  >> 1
12289:       | nCharType :     >> 255
12294:       | nEnumType :
12296:          Node enumScope = oNodeGet( theType, qScope )
12309:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12326:          >> oNodeGetInt( last, qValue )
12336:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12348:       | * :             #eNotOrdinalType
12363:                         >> 0
12366:    ];
      
      
      
12367: Program:
12369:    Node t
      
12369:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
12374:    oScopeBegin( 0, allocGlobal )
12383:    Node rootScope = oScopeCurrent
      
12388:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
12390:    .tEnter  oEmitInt( 0 )
12398:    Label mainLabel = oLabelNew
      
12403:    .tAllocActuals  oEmitInt( 0 )
12411:    .tCall  oEmitLabel( mainLabel )
12419:    .tFreeActuals  oEmitInt( 0 )
12427:    .tReturn
      
12429:    pProgram
12431:    pIdent
      
12433:    Node program = oNodeNew( nProgram )
12443:    oNodeSetInt( program, qIdent, LAST_ID )
12454:    oNodeSet( workspace, qProgram, program )
      
      
12466:    [
12466:       | '(' :
12468:          pIdent      % input, output files
      
12470:          t = @newIdent( nVar, LAST_ID )
12483:          oNodeSet( t, qType, FileType )
12495:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
12501:          ','
12503:          pIdent
      
12505:          t = @newIdent( nVar, LAST_ID )
12518:          oNodeSet( t, qType, FileType )
12530:          oScopeDeclareAlloc( t )
      
12536:          ')'
12538:       | * :
12543:    ]
12543:    ';'
      
12545:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
12552:    [
12552:       | pUses :  @UsesClause( program )
12561:       | * :
12566:    ]
12566:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
12573:    oScopeBegin( 0, allocGlobal )
12582:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
12587:    oScopeBegin( 0, allocDown )
12596:    oNodeSet( oScopeCurrent, qExtends, globalScope )
12607:    initScope = oScopeCurrent
12612:    oNodeSet( program, qMainRoutineScope, initScope )
12624:    oScopeEnd
      
12625:    @BlockDecls( nGlobalVar )
      
      
12632:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
12638:    boolean isMain = true
12644:    @BlockStmt( mainLabel, globalScope, isMain )
      
12657:    oScopeEnd   % main routine scope
      
12658:    '.'
12660:    @CheckForUndefinedLabels
12662:    oScopeEnd   % global scope
12663:    @EndUsedUnits( program )   % used units scopes
12671:    ;
      
      
      
      
12671: Block( node_type varNodeType, Label labelForBody ):
12673:    @BlockDecls( varNodeType )
12680:    @BlockStmt( labelForBody, oScopeCurrent, false )
12692:    @CheckForUndefinedLabels
12695:    ;
      
      
12695: BlockDecls( node_type varNodeType ):
12697:    {[
12697:       | pConst :     @ConstDecl
12701:       | pType :      @TypeDecl
12705:       | pVar :       @VarDecl( varNodeType )
12714:       | pLabel :     @LabelDecl
12718:       | pProcedure : @ProcDecl
12722:       | pFunction :  @FuncDecl
12726:       | * :          >
12743:    ]}
12745:    @CheckForUndefinedMethods
12748:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
12748: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
12751:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
12751: CheckForUndefinedLabels:
12753:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
12765:    {
12765:       Node decl = oNodeIterValue( it )
12775:       [ oNodeNull( decl )
12782:          | false :
12783:          | * :  >
12790:       ]
12790:       [ oNodeType( decl )
12797:          | nLabel :
12798:             [ oNodeGetBoolean( decl, qDefined )
12808:                | false :
12809:                   [ oNodeGetBoolean( decl, qUsed )
12819:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
12822:                      | * :
12827:                   ]
12827:                | * :
12832:             ]
12832:          | * :
12837:       ]
12837:       oNodeIterNext( it )
12843:    }
12846:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
12846: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
12848:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
12856:    int patchLS
12856:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
12865:    [ isMain
12868:       | true :  @InitializeUnits
12871:       | * :
12876:    ]
      
         % insert any code for initialization of this scope's variables
12876:    Code initCode = oNodeGetCode( varScope, qInitCode )
12889:    oEmitCode( initCode )
12895:    oNodeSetCode( varScope, qInitCode, codeNull )
      
12907:    @Statement
      
12909:    [ isMain
12912:       | true :  @FinalizeUnits
12915:       | * :
12920:    ]
      
12920:    .tReturn
      
12922:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
12934:    oPatch( patchLS, localSpace )
12944:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
12944: GetOrCreateInitCode( Node scope ) >> Code:
12946:    Code initCode = oNodeGetCode( scope, qInitCode )
12959:    [ equal_code( initCode, codeNull )
12969:       | true :
12970:          initCode = oCodeNew
12975:          oNodeSetCode( scope, qInitCode, initCode )
12987:       | * :
12992:    ]
12992:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
12996: ScopeLevel >> int:
12998:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13008: DeclLevel( Node decl ) >> int:
13010:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
13028: DeclUpLevels( Node decl ) >> int:
13030:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
13046: newIdent( node_type nt, int id ) >> Node:
13048:   Node t = oNodeNew( nt )
13058:   oNodeSetInt( t, qIdent, id )
13070:   >> t
13074:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
13074: EmitValue( Node decl ):
13076:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
13090: DeclareBuiltInFunc( int id ) >> Node:
13092:    Node decl = @newIdent( nBuiltInFunc, id )
13106:    oScopeDeclare( decl )
13112:    >> decl;
      
      
13116: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
13118:    mysystemId = oId_mysystem
      
         % install built-in types
13123:    FileType = @newType( nFileType, 4 )
13137:    IntegerType = @newType( nIntegerType, 4 )
13151:    BooleanType = @newType( nBooleanType, 1 )
13165:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
13179:    CharType = @newType( nCharType, 1 )
13193:    PCharType = @PointerTypeTo( CharType )
13204:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
13218:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
13232:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
13244:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
13258:    ShortStringType = @newType( nShortStringType, 256 )
13272:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
13284:    Node t
      
13284:    t = @newIdent( nTypeDecl, oId_File )
13297:    oNodeSet( t, qType, FileType )
13309:    oScopeDeclare( t )
      
13315:    t = @newIdent( nTypeDecl, oId_Integer )
13328:    oNodeSet( t, qType, IntegerType )
13340:    oScopeDeclare( t )
      
13346:    t = @newIdent( nTypeDecl, oId_Boolean )
13359:    oNodeSet( t, qType, BooleanType )
13371:    oScopeDeclare( t )
      
13377:    t = @newIdent( nTypeDecl, oId_Char )
13390:    oNodeSet( t, qType, CharType )
13402:    oScopeDeclare( t )
      
13408:    t = @newIdent( nTypeDecl, oId_Byte )
13421:    oNodeSet( t, qType, ByteType )
13433:    oScopeDeclare( t )
      
13439:    t = @newIdent( nTypeDecl, oId_Pointer )
13452:    oNodeSet( t, qType, UniversalPointerType )
13464:    oScopeDeclare( t )
      
13470:    t = @newIdent( nTypeDecl, oId_ShortString )
13483:    oNodeSet( t, qType, ShortStringType )
13495:    oScopeDeclare( t )
      
         % Built-in constants
      
13501:    t = @newIdent( nConst, oId_True )
13514:    oNodeSet( t, qType, BooleanType )
13526:    oNodeSetInt( t, qValue, 1 )
13538:    oScopeDeclare( t )
      
13544:    t = @newIdent( nConst, oId_False )
13557:    oNodeSet( t, qType, BooleanType )
13569:    oNodeSetInt( t, qValue, 0 )
13581:    oScopeDeclare( t )
      
13587:    t = @newIdent( nConst, oId_Nil )
13600:    oNodeSet( t, qType, UniversalPointerType )
13612:    oNodeSetInt( t, qValue, 0 )
13624:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13630:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13640:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13650:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13660:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13671:    ;
      
13671: end
      
13671: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 12367
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3178
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3234
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 12695
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8133
1083: oInputChoice 1089
1085: oCall 8133
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8133
1177: oInputChoice 1183
1179: oCall 8133
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13008
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 10690
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 13046
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 21
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 21
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 21
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 12996
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 12093
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 5
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          70   1755
          69   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 22
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 12671
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 5
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 13046
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 21
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 21
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 12996
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 12093
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 12
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 11014
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 12093
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 5
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          70   2190
          69   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 22
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 12671
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 5
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          33   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 24
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 13046
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 34
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          13   2366
          12   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 11014
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 12093
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           5   2504
          15   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          14   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2654
2528: oJumpForward 2535
2530: Choice Lookup Table
          12   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 6
2554: oCall 3533
2556: oTypeSNodeType
2557: oChoice 2613
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 13046
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2632
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 18
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 13046
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 33
2605: oPushResult
2606: oValueTopString
2607: oPushResult
2608: oNodeSetString
2609: oPop 3
2611: oJumpForward 2632
2613: Choice Lookup Table
          39   2586
          35   2559
          34   2559
          41   2559
          29   2559
          33   2559
          30   2559
          31   2559
2630: oError 17
2632: oValuePop
2633: oGetLocal 2
2635: oPushResult
2636: oSetResult 21
2638: oPushResult
2639: oTypeSTop
2640: oPushResult
2641: oNodeSet
2642: oPop 3
2644: oTypeSPop
2645: oGetLocal 2
2647: oPushResult
2648: oScopeDeclare
2649: oPop 1
2651: oInput 5
2653: oReturn
2654: oLocalSpace 3
2656: oGetAddrLocal 1
2658: oPushResult
2659: oSetResult 25
2661: oPushResult
2662: LAST_ID
2663: oPushResult
2664: oCall 13046
2666: oPop 2
2668: oAssign
2669: oGetAddrLocal 2
2671: oPushResult
2672: oCall 11014
2674: oPop 1
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 21
2681: oPushResult
2682: oGetLocal 2
2684: oPushResult
2685: oNodeSet
2686: oPop 3
2688: oGetLocal 2
2690: oPushResult
2691: oNodeType
2692: oPop 1
2694: oChoice 2798
2696: oInput 6
2698: oGetLocal 2
2700: oPushResult
2701: oTypeSPush
2702: oPop 1
2704: oCall 3533
2706: oCall 4275
2708: oGetLocal 1
2710: oPushResult
2711: oSetResult 22
2713: oPushResult
2714: oValueTop
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oValuePop
2720: oTypeSPop
2721: oGetLocal 1
2723: oPushResult
2724: oScopeDeclare
2725: oPop 1
2727: oInput 5
2729: oJumpForward 2822
2731: oError 16
2733: oJumpForward 2822
2735: oGetGlobal 2
2737: oPushResult
2738: oScopeEnter
2739: oPop 1
2741: oGetAddrLocal 3
2743: oPushResult
2744: oGetLocal 2
2746: oPushResult
2747: oScopeAllocType
2748: oPop 1
2750: oAssign
2751: oScopeEnd
2752: oGetGlobal 2
2754: oPushResult
2755: oCall 12944
2757: oPop 1
2759: oPushResult
2760: oCodePush
2761: oPop 1
2763: oGetLocal 1
2765: oPushResult
2766: oSetResult 22
2768: oPushResult
2769: oGetLocal 3
2771: oPushResult
2772: oNodeSetInt
2773: oPop 3
2775: oInput 6
2777: oGetLocal 2
2779: oPushResult
2780: oGetLocal 3
2782: oPushResult
2783: oCall 2823
2785: oPop 2
2787: oCodePop
2788: oGetLocal 1
2790: oPushResult
2791: oScopeDeclare
2792: oPop 1
2794: oInput 5
2796: oJumpForward 2822
2798: Choice Lookup Table
          38   2735
          36   2735
          28   2731
          40   2731
          35   2696
          34   2696
          41   2696
          29   2696
          33   2696
          30   2696
          31   2696
2821: oEndChoice
2822: oReturn
2823: oLocalSpace 10
2825: oGetParam 2
2827: oPushResult
2828: oNodeType
2829: oPop 1
2831: oChoice 3153
2833: oGetAddrLocal 1
2835: oPushResult
2836: oGetParam 2
2838: oPushResult
2839: oSetResult 37
2841: oPushResult
2842: oNodeGet
2843: oPop 2
2845: oAssign
2846: oGetAddrLocal 2
2848: oPushResult
2849: oGetParam 2
2851: oPushResult
2852: oSetResult 38
2854: oPushResult
2855: oNodeGet
2856: oPop 2
2858: oAssign
2859: oGetAddrLocal 3
2861: oPushResult
2862: oGetLocal 2
2864: oPushResult
2865: oCall 12177
2867: oPop 1
2869: oAssign
2870: oGetAddrLocal 4
2872: oPushResult
2873: oGetLocal 2
2875: oPushResult
2876: oCall 12272
2878: oPop 1
2880: oAssign
2881: oGetAddrLocal 5
2883: oPushResult
2884: oGetLocal 1
2886: oPushResult
2887: oSetResult 17
2889: oPushResult
2890: oNodeGetInt
2891: oPop 2
2893: oAssign
2894: oInput 14
2896: oGetAddrLocal 6
2898: oPushResult
2899: oGetLocal 3
2901: oAssign
2902: oGetLocal 1
2904: oPushResult
2905: oGetParam 1
2907: oPushResult
2908: oCall 2823
2910: oPop 2
2912: oGetLocal 6
2914: oPushResult
2915: oGetLocal 4
2917: oPushResult
2918: equal
2919: oPop 2
2921: oChoice 2929
2923: oJumpForward 2958
2925: oJumpForward 2935
2927: oJumpForward 2935
2929: Choice Lookup Table
           0   2927
           1   2923
2934: oEndChoice
2935: oInput 13
2937: oGetAddrParam 1
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oGetLocal 5
2945: oPushResult
2946: add
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 6
2952: oPushResult
2953: inc
2954: oPop 1
2956: oJumpBack 2902
2958: oInput 15
2960: oJumpForward 3177
2962: oInput 14
2964: oGetAddrLocal 7
2966: oPushResult
2967: oGetParam 2
2969: oPushResult
2970: oSetResult 41
2972: oPushResult
2973: oNodeGet
2974: oPop 2
2976: oAssign
2977: oInputChoice 2981
2979: oJumpForward 2986
2981: Choice Lookup Table
           0   2979
2984: oJumpForward 3052
2986: oGetAddrLocal 8
2988: oPushResult
2989: oGetLocal 7
2991: oPushResult
2992: oScopeFindRequireInScope
2993: oPop 1
2995: oAssign
2996: oInput 12
2998: oGetAddrLocal 9
3000: oPushResult
3001: oGetLocal 8
3003: oPushResult
3004: oSetResult 21
3006: oPushResult
3007: oNodeGet
3008: oPop 2
3010: oAssign
3011: oGetAddrLocal 10
3013: oPushResult
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 8
3019: oPushResult
3020: oSetResult 22
3022: oPushResult
3023: oNodeGetInt
3024: oPop 2
3026: oPushResult
3027: add
3028: oPop 2
3030: oAssign
3031: oGetLocal 9
3033: oPushResult
3034: oGetLocal 10
3036: oPushResult
3037: oCall 2823
3039: oPop 2
3041: oInputChoice 3045
3043: oJumpForward 3050
3045: Choice Lookup Table
           5   3043
3048: oJumpForward 3052
3050: oJumpBack 2977
3052: oInput 15
3054: oJumpForward 3177
3056: oEmit 16
3058: oGetParam 1
3060: oPushResult
3061: oEmitInt
3062: oPop 1
3064: oGetParam 2
3066: oPushResult
3067: oTypeSPush
3068: oPop 1
3070: oCall 3533
3072: oCall 4275
3074: oEmit 15
3076: oValueTop
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oValuePop
3082: oTypeSPop
3083: oEmit 27
3085: oJumpForward 3177
3087: oEmit 16
3089: oGetParam 1
3091: oPushResult
3092: oEmitInt
3093: oPop 1
3095: oGetParam 2
3097: oPushResult
3098: oTypeSPush
3099: oPop 1
3101: oCall 3533
3103: oCall 4275
3105: oEmit 15
3107: oValueTop
3108: oPushResult
3109: oEmitInt
3110: oPop 1
3112: oValuePop
3113: oTypeSPop
3114: oEmit 26
3116: oJumpForward 3177
3118: oEmit 16
3120: oGetParam 1
3122: oPushResult
3123: oEmitInt
3124: oPop 1
3126: oGetParam 2
3128: oPushResult
3129: oTypeSPush
3130: oPop 1
3132: oCall 3533
3134: oCall 4275
3136: oEmit 15
3138: oValueTop
3139: oPushResult
3140: oEmitInt
3141: oPop 1
3143: oValuePop
3144: oTypeSPop
3145: oEmit 28
3147: oJumpForward 3177
3149: oError 16
3151: oJumpForward 3177
3153: Choice Lookup Table
          28   3149
          40   3149
          35   3118
          34   3118
          41   3087
          29   3087
          33   3056
          30   3056
          31   3056
          38   2962
          36   2833
3176: oEndChoice
3177: oReturn
3178: oLocalSpace 2
3180: oInputChoice 3226
3182: oGetAddrLocal 1
3184: oPushResult
3185: oSetResult 19
3187: oPushResult
3188: LAST_ID
3189: oPushResult
3190: oCall 13046
3192: oPop 2
3194: oAssign
3195: oInput 6
3197: oGetAddrLocal 2
3199: oPushResult
3200: oCall 11014
3202: oPop 1
3204: oGetLocal 1
3206: oPushResult
3207: oSetResult 21
3209: oPushResult
3210: oGetLocal 2
3212: oPushResult
3213: oNodeSet
3214: oPop 3
3216: oGetLocal 1
3218: oPushResult
3219: oScopeDeclare
3220: oPop 1
3222: oInput 5
3224: oJumpForward 3231
3226: Choice Lookup Table
           0   3182
3229: oJumpForward 3233
3231: oJumpBack 3180
3233: oReturn
3234: oLocalSpace 6
3236: oInputChoice 3460
3238: oGetAddrLocal 1
3240: oPushResult
3241: oNodeVecNew
3242: oAssign
3243: oGetAddrLocal 2
3245: oPushResult
3246: oGetParam 1
3248: oPushResult
3249: LAST_ID
3250: oPushResult
3251: oCall 13046
3253: oPop 2
3255: oAssign
3256: oGetLocal 1
3258: oPushResult
3259: oGetLocal 2
3261: oPushResult
3262: oNodeVecAppend
3263: oPop 2
3265: oInputChoice 3271
3267: oInput 0
3269: oJumpForward 3276
3271: Choice Lookup Table
          13   3267
3274: oJumpForward 3278
3276: oJumpBack 3243
3278: oInput 12
3280: oGetAddrLocal 3
3282: oPushResult
3283: oCall 11014
3285: oPop 1
3287: oGetAddrLocal 4
3289: oPushResult
3290: oSetResult 0
3292: oAssign
3293: oGetLocal 4
3295: oPushResult
3296: oGetLocal 1
3298: oPushResult
3299: oNodeVecSize
3300: oPop 1
3302: oPushResult
3303: equal
3304: oPop 2
3306: oChoice 3347
3308: oGetAddrLocal 2
3310: oPushResult
3311: oGetLocal 1
3313: oPushResult
3314: oGetLocal 4
3316: oPushResult
3317: oNodeVecElement
3318: oPop 2
3320: oAssign
3321: oGetLocal 2
3323: oPushResult
3324: oSetResult 21
3326: oPushResult
3327: oGetLocal 3
3329: oPushResult
3330: oNodeSet
3331: oPop 3
3333: oGetLocal 2
3335: oPushResult
3336: oScopeDeclareAlloc
3337: oPop 1
3339: oGetAddrLocal 4
3341: oPushResult
3342: inc
3343: oPop 1
3345: oJumpForward 3352
3347: Choice Lookup Table
           0   3308
3350: oJumpForward 3354
3352: oJumpBack 3293
3354: oInputChoice 3447
3356: oGetLocal 1
3358: oPushResult
3359: oNodeVecSize
3360: oPop 1
3362: oChoice 3366
3364: oJumpForward 3371
3366: Choice Lookup Table
           1   3364
3369: oError 22
3371: oGetAddrLocal 5
3373: oPushResult
3374: oScopeCurrent
3375: oPushResult
3376: oCall 12944
3378: oPop 1
3380: oAssign
3381: oGetLocal 5
3383: oPushResult
3384: oCodePush
3385: oPop 1
3387: oGetAddrLocal 6
3389: oPushResult
3390: oSetResult 0
3392: oAssign
3393: oCall 12996
3395: oPushResult
3396: equal_zero
3397: oPop 1
3399: oChoice 3415
3401: oGetGlobal 3
3403: oPushResult
3404: oScopeEnter
3405: oPop 1
3407: oGetAddrLocal 6
3409: oPushResult
3410: oSetResult 1
3412: oAssign
3413: oJumpForward 3418
3415: Choice Lookup Table
           1   3401
3418: oGetLocal 2
3420: oPushResult
3421: oSetResult 1
3423: oPushResult
3424: oCall 8621
3426: oPop 2
3428: oCall 4613
3430: oCall 7803
3432: oCall 8377
3434: oGetLocal 6
3436: oChoice 3441
3438: oScopeEnd
3439: oJumpForward 3444
3441: Choice Lookup Table
           1   3438
3444: oCodePop
3445: oJumpForward 3450
3447: Choice Lookup Table
           6   3356
3450: oGetLocal 1
3452: oPushResult
3453: oNodeVecDelete
3454: oPop 1
3456: oInput 5
3458: oJumpForward 3465
3460: Choice Lookup Table
           0   3238
3463: oJumpForward 3467
3465: oJumpBack 3236
3467: oReturn
3468: oLocalSpace 2
3470: oInputChoice 3477
3472: oJumpForward 3483
3474: oChangeIntLitToLabelIdent
3475: oJumpForward 3483
3477: Choice Lookup Table
           1   3474
           0   3472
3482: oEndChoice
3483: oGetAddrLocal 1
3485: oPushResult
3486: oSetResult 26
3488: oPushResult
3489: LAST_ID
3490: oPushResult
3491: oCall 13046
3493: oPop 2
3495: oAssign
3496: oGetAddrLocal 2
3498: oPushResult
3499: oLabelNew
3500: oAssign
3501: oGetLocal 1
3503: oPushResult
3504: oSetResult 22
3506: oPushResult
3507: oGetLocal 2
3509: oPushResult
3510: oNodeSetLabel
3511: oPop 3
3513: oGetLocal 1
3515: oPushResult
3516: oScopeDeclare
3517: oPop 1
3519: oInputChoice 3523
3521: oJumpForward 3528
3523: Choice Lookup Table
          13   3521
3526: oJumpForward 3530
3528: oJumpBack 3470
3530: oInput 5
3532: oReturn
3533: oLocalSpace 0
3535: oCall 3737
3537: oInputChoice 3719
3539: oCall 3760
3541: oCall 4178
3543: oTypeSNodeType
3544: oChoice 3556
3546: oValueStringCmp
3547: oSetResult 0
3549: oPushResult
3550: oValuePush
3551: oPop 1
3553: oValueEqual
3554: oJumpForward 3560
3556: Choice Lookup Table
          39   3546
3559: oValueEqual
3560: oTypeSPop
3561: oGetGlobal 7
3563: oPushResult
3564: oTypeSPush
3565: oPop 1
3567: oJumpForward 3734
3569: oCall 3737
3571: oCall 4178
3573: oTypeSNodeType
3574: oChoice 3586
3576: oValueStringCmp
3577: oSetResult 0
3579: oPushResult
3580: oValuePush
3581: oPop 1
3583: oValueNotEqual
3584: oJumpForward 3590
3586: Choice Lookup Table
          39   3576
3589: oValueNotEqual
3590: oTypeSPop
3591: oGetGlobal 7
3593: oPushResult
3594: oTypeSPush
3595: oPop 1
3597: oJumpForward 3734
3599: oCall 3737
3601: oCall 4178
3603: oTypeSNodeType
3604: oChoice 3616
3606: oValueStringCmp
3607: oSetResult 0
3609: oPushResult
3610: oValuePush
3611: oPop 1
3613: oValueLess
3614: oJumpForward 3620
3616: Choice Lookup Table
          39   3606
3619: oValueLess
3620: oTypeSPop
3621: oGetGlobal 7
3623: oPushResult
3624: oTypeSPush
3625: oPop 1
3627: oJumpForward 3734
3629: oCall 3737
3631: oCall 4178
3633: oTypeSNodeType
3634: oChoice 3646
3636: oValueStringCmp
3637: oSetResult 0
3639: oPushResult
3640: oValuePush
3641: oPop 1
3643: oValueGreater
3644: oJumpForward 3650
3646: Choice Lookup Table
          39   3636
3649: oValueGreater
3650: oTypeSPop
3651: oGetGlobal 7
3653: oPushResult
3654: oTypeSPush
3655: oPop 1
3657: oJumpForward 3734
3659: oCall 3737
3661: oCall 4178
3663: oTypeSNodeType
3664: oChoice 3676
3666: oValueStringCmp
3667: oSetResult 0
3669: oPushResult
3670: oValuePush
3671: oPop 1
3673: oValueLessEqual
3674: oJumpForward 3680
3676: Choice Lookup Table
          39   3666
3679: oValueLessEqual
3680: oTypeSPop
3681: oGetGlobal 7
3683: oPushResult
3684: oTypeSPush
3685: oPop 1
3687: oJumpForward 3734
3689: oCall 3737
3691: oCall 4178
3693: oTypeSNodeType
3694: oChoice 3706
3696: oValueStringCmp
3697: oSetResult 0
3699: oPushResult
3700: oValuePush
3701: oPop 1
3703: oValueGreaterEqual
3704: oJumpForward 3710
3706: Choice Lookup Table
          39   3696
3709: oValueGreaterEqual
3710: oTypeSPop
3711: oGetGlobal 7
3713: oPushResult
3714: oTypeSPush
3715: oPop 1
3717: oJumpForward 3734
3719: Choice Lookup Table
          11   3689
          10   3659
           9   3629
           8   3599
           7   3569
           6   3539
3732: oJumpForward 3736
3734: oJumpBack 3537
3736: oReturn
3737: oLocalSpace 0
3739: oCall 3760
3741: oInputChoice 3752
3743: oCall 4165
3745: oCall 3760
3747: oCall 4151
3749: oValueOr
3750: oJumpForward 3757
3752: Choice Lookup Table
          57   3743
3755: oJumpForward 3759
3757: oJumpBack 3741
3759: oReturn
3760: oLocalSpace 0
3762: oCall 3783
3764: oInputChoice 3775
3766: oCall 4165
3768: oCall 3783
3770: oCall 4151
3772: oValueAnd
3773: oJumpForward 3780
3775: Choice Lookup Table
          56   3766
3778: oJumpForward 3782
3780: oJumpBack 3764
3782: oReturn
3783: oLocalSpace 0
3785: oInputChoice 3794
3787: oCall 3783
3789: oCall 4165
3791: oValueNot
3792: oJumpForward 3799
3794: Choice Lookup Table
          58   3787
3797: oCall 3800
3799: oReturn
3800: oLocalSpace 0
3802: oCall 3849
3804: oInputChoice 3839
3806: oCall 3849
3808: oCall 4178
3810: oTypeSNodeType
3811: oChoice 3816
3813: oValueStringConcat
3814: oJumpForward 3820
3816: Choice Lookup Table
          39   3813
3819: oValueAdd
3820: oJumpForward 3846
3822: oCall 3849
3824: oCall 4178
3826: oTypeSNodeType
3827: oChoice 3833
3829: oError 17
3831: oJumpForward 3837
3833: Choice Lookup Table
          39   3829
3836: oValueSub
3837: oJumpForward 3846
3839: Choice Lookup Table
          25   3822
          24   3806
3844: oJumpForward 3848
3846: oJumpBack 3804
3848: oReturn
3849: oLocalSpace 0
3851: oCall 3899
3853: oInputChoice 3889
3855: oCall 3899
3857: oCall 4178
3859: oTypeSNodeType
3860: oChoice 3866
3862: oError 17
3864: oJumpForward 3870
3866: Choice Lookup Table
          39   3862
3869: oValueMult
3870: oJumpForward 3896
3872: oCall 3899
3874: oCall 4178
3876: oTypeSNodeType
3877: oChoice 3883
3879: oError 17
3881: oJumpForward 3887
3883: Choice Lookup Table
          39   3879
3886: oValueDiv
3887: oJumpForward 3896
3889: Choice Lookup Table
          23   3872
          22   3855
3894: oJumpForward 3898
3896: oJumpBack 3853
3898: oReturn
3899: oLocalSpace 0
3901: oInputChoice 3912
3903: oCall 3920
3905: oJumpForward 3919
3907: oCall 3920
3909: oValueNegate
3910: oJumpForward 3919
3912: Choice Lookup Table
          25   3907
          24   3903
3917: oCall 3920
3919: oReturn
3920: oLocalSpace 1
3922: oInputChoice 4123
3924: TOKEN_VALUE
3925: oPushResult
3926: oValuePush
3927: oPop 1
3929: oGetGlobal 6
3931: oPushResult
3932: oTypeSPush
3933: oPop 1
3935: oJumpForward 4150
3937: TOKEN_VALUE
3938: oPushResult
3939: oValuePush
3940: oPop 1
3942: oGetGlobal 9
3944: oPushResult
3945: oTypeSPush
3946: oPop 1
3948: oJumpForward 4150
3950: CURRENT_STRLIT
3951: oPushResult
3952: oValuePushString
3953: oPop 1
3955: oGetGlobal 13
3957: oPushResult
3958: oTypeSPush
3959: oPop 1
3961: oJumpForward 4150
3963: oCall 3533
3965: oInput 15
3967: oJumpForward 4150
3969: oGetAddrLocal 1
3971: oPushResult
3972: oScopeFindRequire
3973: oAssign
3974: oGetAddrLocal 1
3976: oPushResult
3977: oCall 244
3979: oPop 1
3981: oGetLocal 1
3983: oPushResult
3984: oNodeType
3985: oPop 1
3987: oChoice 4082
3989: oGetLocal 1
3991: oPushResult
3992: oCall 4396
3994: oPop 1
3996: oJumpForward 4105
3998: oGetLocal 1
4000: oPushResult
4001: oSetResult 22
4003: oPushResult
4004: oNodeGetInt
4005: oPop 2
4007: oPushResult
4008: oValuePush
4009: oPop 1
4011: oGetLocal 1
4013: oPushResult
4014: oSetResult 21
4016: oPushResult
4017: oNodeGet
4018: oPop 2
4020: oPushResult
4021: oTypeSPush
4022: oPop 1
4024: oJumpForward 4105
4026: oGetLocal 1
4028: oPushResult
4029: oSetResult 33
4031: oPushResult
4032: oNodeGetString
4033: oPop 2
4035: oPushResult
4036: oValuePushString
4037: oPop 1
4039: oGetLocal 1
4041: oPushResult
4042: oSetResult 21
4044: oPushResult
4045: oNodeGet
4046: oPop 2
4048: oPushResult
4049: oTypeSPush
4050: oPop 1
4052: oJumpForward 4105
4054: oGetLocal 1
4056: oPushResult
4057: oSetResult 22
4059: oPushResult
4060: oNodeGetInt
4061: oPop 2
4063: oPushResult
4064: oValuePush
4065: oPop 1
4067: oGetLocal 1
4069: oPushResult
4070: oSetResult 21
4072: oPushResult
4073: oNodeGet
4074: oPop 2
4076: oPushResult
4077: oTypeSPush
4078: oPop 1
4080: oJumpForward 4105
4082: Choice Lookup Table
          17   4054
          18   4026
          16   3998
          14   3989
4091: oError 1
4093: oSetResult 0
4095: oPushResult
4096: oValuePush
4097: oPop 1
4099: oGetGlobal 6
4101: oPushResult
4102: oTypeSPush
4103: oPop 1
4105: oJumpForward 4150
4107: oError 16
4109: oSetResult 0
4111: oPushResult
4112: oValuePush
4113: oPop 1
4115: oGetGlobal 12
4117: oPushResult
4118: oTypeSPush
4119: oPop 1
4121: oJumpForward 4150
4123: Choice Lookup Table
          19   4107
           0   3969
          14   3963
           2   3950
           3   3937
           1   3924
4136: oError 1
4138: oSetResult 0
4140: oPushResult
4141: oValuePush
4142: oPop 1
4144: oGetGlobal 6
4146: oPushResult
4147: oTypeSPush
4148: oPop 1
4150: oReturn
4151: oLocalSpace 0
4153: oTypeSNodeType
4154: oChoice 4158
4156: oJumpForward 4163
4158: Choice Lookup Table
          31   4156
4161: oError 8
4163: oTypeSPop
4164: oReturn
4165: oLocalSpace 0
4167: oTypeSNodeType
4168: oChoice 4172
4170: oJumpForward 4177
4172: Choice Lookup Table
          31   4170
4175: oError 8
4177: oReturn
4178: oLocalSpace 1
4180: oGetAddrLocal 1
4182: oPushResult
4183: oTypeSNodeType
4184: oAssign
4185: oTypeSPop
4186: oGetLocal 1
4188: oPushResult
4189: oTypeSNodeType
4190: oPushResult
4191: equal_node_type
4192: oPop 2
4194: oChoice 4271
4196: oTypeSNodeType
4197: oChoice 4258
4199: oGetLocal 1
4201: oChoice 4206
4203: oReturn
4204: oJumpForward 4209
4206: Choice Lookup Table
          35   4203
4209: oJumpForward 4267
4211: oGetLocal 1
4213: oChoice 4218
4215: oReturn
4216: oJumpForward 4221
4218: Choice Lookup Table
          34   4215
4221: oJumpForward 4267
4223: oGetLocal 1
4225: oChoice 4231
4227: oValueCharToString
4228: oReturn
4229: oJumpForward 4234
4231: Choice Lookup Table
          33   4227
4234: oJumpForward 4267
4236: oGetLocal 1
4238: oChoice 4253
4240: oValueSwap
4241: oValueCharToString
4242: oValueSwap
4243: oTypeSPop
4244: oGetGlobal 13
4246: oPushResult
4247: oTypeSPush
4248: oPop 1
4250: oReturn
4251: oJumpForward 4256
4253: Choice Lookup Table
          39   4240
4256: oJumpForward 4267
4258: Choice Lookup Table
          33   4236
          39   4223
          35   4211
          34   4199
4267: oError 14
4269: oJumpForward 4274
4271: Choice Lookup Table
           0   4196
4274: oReturn
4275: oLocalSpace 1
4277: oGetAddrLocal 1
4279: oPushResult
4280: oTypeSNodeType
4281: oAssign
4282: oTypeSPop
4283: oGetLocal 1
4285: oPushResult
4286: oTypeSNodeType
4287: oPushResult
4288: equal_node_type
4289: oPop 2
4291: oChoice 4392
4293: oTypeSNodeType
4294: oChoice 4375
4296: oGetLocal 1
4298: oChoice 4303
4300: oReturn
4301: oJumpForward 4306
4303: Choice Lookup Table
          30   4300
4306: oJumpForward 4388
4308: oGetLocal 1
4310: oChoice 4315
4312: oReturn
4313: oJumpForward 4318
4315: Choice Lookup Table
          29   4312
4318: oJumpForward 4388
4320: oGetLocal 1
4322: oChoice 4327
4324: oReturn
4325: oJumpForward 4330
4327: Choice Lookup Table
          35   4324
4330: oJumpForward 4388
4332: oGetLocal 1
4334: oChoice 4339
4336: oReturn
4337: oJumpForward 4342
4339: Choice Lookup Table
          34   4336
4342: oJumpForward 4388
4344: oGetLocal 1
4346: oChoice 4352
4348: oValueCharToString
4349: oReturn
4350: oJumpForward 4355
4352: Choice Lookup Table
          33   4348
4355: oJumpForward 4388
4357: oGetLocal 1
4359: oChoice 4368
4361: oReturn
4362: oJumpForward 4373
4364: oValueCharToString
4365: oReturn
4366: oJumpForward 4373
4368: Choice Lookup Table
          33   4364
          39   4361
4373: oJumpForward 4388
4375: Choice Lookup Table
          40   4357
          39   4344
          35   4332
          34   4320
          30   4308
          29   4296
4388: oError 14
4390: oJumpForward 4395
4392: Choice Lookup Table
           0   4293
4395: oReturn
4396: oLocalSpace 0
4398: oGetParam 1
4400: oPushResult
4401: oGetGlobal 15
4403: oPushResult
4404: oNodeEqual
4405: oPop 2
4407: oChoice 4447
4409: oInput 14
4411: oCall 3533
4413: oInput 15
4415: oTypeSNodeType
4416: oChoice 4422
4418: oJumpForward 4435
4420: oJumpForward 4435
4422: Choice Lookup Table
          33   4420
          30   4420
          31   4420
          41   4418
          29   4418
4433: oError 14
4435: oTypeSPop
4436: oGetGlobal 6
4438: oPushResult
4439: oTypeSPush
4440: oPop 1
4442: oInput 15
4444: oReturn
4445: oJumpForward 4450
4447: Choice Lookup Table
           1   4409
4450: oGetParam 1
4452: oPushResult
4453: oGetGlobal 16
4455: oPushResult
4456: oNodeEqual
4457: oPop 2
4459: oChoice 4493
4461: oInput 14
4463: oCall 3533
4465: oInput 15
4467: oTypeSNodeType
4468: oChoice 4474
4470: oJumpForward 4481
4472: oJumpForward 4481
4474: Choice Lookup Table
          30   4472
          29   4470
4479: oError 14
4481: oTypeSPop
4482: oGetGlobal 9
4484: oPushResult
4485: oTypeSPush
4486: oPop 1
4488: oInput 15
4490: oReturn
4491: oJumpForward 4496
4493: Choice Lookup Table
           1   4461
4496: oGetParam 1
4498: oPushResult
4499: oGetGlobal 17
4501: oPushResult
4502: oNodeEqual
4503: oPop 2
4505: oChoice 4550
4507: oInput 14
4509: oCall 3533
4511: oTypeSNodeType
4512: oChoice 4533
4514: oTypeSTop
4515: oPushResult
4516: oSetResult 44
4518: oPushResult
4519: oNodeGetBoolean
4520: oPop 2
4522: oChoice 4528
4524: oError 28
4526: oJumpForward 4531
4528: Choice Lookup Table
           1   4524
4531: oJumpForward 4538
4533: Choice Lookup Table
          41   4514
4536: oError 14
4538: oSetResult 1
4540: oPushResult
4541: oValuePush
4542: oPop 1
4544: oValueSub
4545: oInput 15
4547: oReturn
4548: oJumpForward 4553
4550: Choice Lookup Table
           1   4507
4553: oGetParam 1
4555: oPushResult
4556: oGetGlobal 18
4558: oPushResult
4559: oNodeEqual
4560: oPop 2
4562: oChoice 4607
4564: oInput 14
4566: oCall 3533
4568: oTypeSNodeType
4569: oChoice 4590
4571: oTypeSTop
4572: oPushResult
4573: oSetResult 44
4575: oPushResult
4576: oNodeGetBoolean
4577: oPop 2
4579: oChoice 4585
4581: oError 28
4583: oJumpForward 4588
4585: Choice Lookup Table
           1   4581
4588: oJumpForward 4595
4590: Choice Lookup Table
          41   4571
4593: oError 14
4595: oSetResult 1
4597: oPushResult
4598: oValuePush
4599: oPop 1
4601: oValueAdd
4602: oInput 15
4604: oReturn
4605: oJumpForward 4610
4607: Choice Lookup Table
           1   4564
4610: oError 16
4612: oReturn
4613: oLocalSpace 1
4615: oGetAddrLocal 1
4617: oPushResult
4618: oSetResult 0
4620: oAssign
4621: oGetAddrLocal 1
4623: oPushResult
4624: oCall 4774
4626: oPop 1
4628: oGetAddrLocal 1
4630: oPushResult
4631: oCall 4674
4633: oPop 1
4635: oReturn
4636: oLocalSpace 0
4638: oGetParam 1
4640: oPushResult
4641: oCall 4774
4643: oPop 1
4645: oTypeSNodeType
4646: oChoice 4665
4648: oJumpForward 4672
4650: oGetParam 1
4652: oPushResult
4653: oLabelNew
4654: oAssign
4655: oEmit 70
4657: oGetFromParam 1
4659: oPushResult
4660: oEmitLabel
4661: oPop 1
4663: oJumpForward 4672
4665: Choice Lookup Table
          31   4650
          32   4648
4670: oError 8
4672: oTypeSPop
4673: oReturn
4674: oLocalSpace 1
4676: oTypeSNodeType
4677: oChoice 4739
4679: oGetAddrLocal 1
4681: oPushResult
4682: oLabelNew
4683: oAssign
4684: oEmit 15
4686: oSetResult 1
4688: oPushResult
4689: oEmitInt
4690: oPop 1
4692: oEmit 68
4694: oGetLocal 1
4696: oPushResult
4697: oEmitLabel
4698: oPop 1
4700: oEmit 77
4702: oGetFromParam 1
4704: oPushResult
4705: oEmitLabel
4706: oPop 1
4708: oEmit 15
4710: oSetResult 0
4712: oPushResult
4713: oEmitInt
4714: oPop 1
4716: oEmit 77
4718: oGetLocal 1
4720: oPushResult
4721: oEmitLabel
4722: oPop 1
4724: oTypeSPop
4725: oGetGlobal 7
4727: oPushResult
4728: oTypeSPush
4729: oPop 1
4731: oGetParam 1
4733: oPushResult
4734: oSetResult 0
4736: oAssign
4737: oJumpForward 4742
4739: Choice Lookup Table
          32   4679
4742: oReturn
4743: oLocalSpace 0
4745: oTypeSNodeType
4746: oChoice 4770
4748: oGetParam 1
4750: oPushResult
4751: oLabelNew
4752: oAssign
4753: oEmit 70
4755: oGetFromParam 1
4757: oPushResult
4758: oEmitLabel
4759: oPop 1
4761: oTypeSPop
4762: oGetGlobal 8
4764: oPushResult
4765: oTypeSPush
4766: oPop 1
4768: oJumpForward 4773
4770: Choice Lookup Table
          31   4748
4773: oReturn
4774: oLocalSpace 0
4776: oGetParam 1
4778: oPushResult
4779: oCall 5307
4781: oPop 1
4783: oInputChoice 5289
4785: oGetParam 1
4787: oPushResult
4788: oCall 4674
4790: oPop 1
4792: oCall 8086
4794: oGetParam 1
4796: oPushResult
4797: oCall 5307
4799: oPop 1
4801: oGetParam 1
4803: oPushResult
4804: oCall 4674
4806: oPop 1
4808: oCall 8086
4810: oCall 7955
4812: oTypeSNodeType
4813: oChoice 4841
4815: oEmit 43
4817: oJumpForward 4860
4819: oEmit 49
4821: oJumpForward 4860
4823: oEmit 55
4825: oJumpForward 4860
4827: oCall 10014
4829: oEmit 15
4831: oSetResult 0
4833: oPushResult
4834: oEmitInt
4835: oPop 1
4837: oEmit 49
4839: oJumpForward 4860
4841: Choice Lookup Table
          39   4827
          40   4827
          35   4823
          34   4823
          41   4819
          29   4819
          33   4815
          31   4815
4858: oError 17
4860: oTypeSPop
4861: oGetGlobal 7
4863: oPushResult
4864: oTypeSPush
4865: oPop 1
4867: oJumpForward 5304
4869: oGetParam 1
4871: oPushResult
4872: oCall 4674
4874: oPop 1
4876: oCall 8086
4878: oGetParam 1
4880: oPushResult
4881: oCall 5307
4883: oPop 1
4885: oGetParam 1
4887: oPushResult
4888: oCall 4674
4890: oPop 1
4892: oCall 8086
4894: oCall 7955
4896: oTypeSNodeType
4897: oChoice 4925
4899: oEmit 44
4901: oJumpForward 4944
4903: oEmit 50
4905: oJumpForward 4944
4907: oEmit 56
4909: oJumpForward 4944
4911: oCall 10014
4913: oEmit 15
4915: oSetResult 0
4917: oPushResult
4918: oEmitInt
4919: oPop 1
4921: oEmit 50
4923: oJumpForward 4944
4925: Choice Lookup Table
          39   4911
          40   4911
          35   4907
          34   4907
          41   4903
          29   4903
          33   4899
          31   4899
4942: oError 17
4944: oTypeSPop
4945: oGetGlobal 7
4947: oPushResult
4948: oTypeSPush
4949: oPop 1
4951: oJumpForward 5304
4953: oGetParam 1
4955: oPushResult
4956: oCall 4674
4958: oPop 1
4960: oCall 8086
4962: oGetParam 1
4964: oPushResult
4965: oCall 5307
4967: oPop 1
4969: oGetParam 1
4971: oPushResult
4972: oCall 4674
4974: oPop 1
4976: oCall 8086
4978: oCall 7955
4980: oTypeSNodeType
4981: oChoice 5009
4983: oEmit 46
4985: oJumpForward 5028
4987: oEmit 52
4989: oJumpForward 5028
4991: oEmit 58
4993: oJumpForward 5028
4995: oCall 10014
4997: oEmit 15
4999: oSetResult 0
5001: oPushResult
5002: oEmitInt
5003: oPop 1
5005: oEmit 52
5007: oJumpForward 5028
5009: Choice Lookup Table
          39   4995
          40   4995
          35   4991
          34   4991
          41   4987
          29   4987
          33   4983
          31   4983
5026: oError 17
5028: oTypeSPop
5029: oGetGlobal 7
5031: oPushResult
5032: oTypeSPush
5033: oPop 1
5035: oJumpForward 5304
5037: oGetParam 1
5039: oPushResult
5040: oCall 4674
5042: oPop 1
5044: oCall 8086
5046: oGetParam 1
5048: oPushResult
5049: oCall 5307
5051: oPop 1
5053: oGetParam 1
5055: oPushResult
5056: oCall 4674
5058: oPop 1
5060: oCall 8086
5062: oCall 7955
5064: oTypeSNodeType
5065: oChoice 5093
5067: oEmit 45
5069: oJumpForward 5112
5071: oEmit 51
5073: oJumpForward 5112
5075: oEmit 57
5077: oJumpForward 5112
5079: oCall 10014
5081: oEmit 15
5083: oSetResult 0
5085: oPushResult
5086: oEmitInt
5087: oPop 1
5089: oEmit 51
5091: oJumpForward 5112
5093: Choice Lookup Table
          39   5079
          40   5079
          35   5075
          34   5075
          41   5071
          29   5071
          33   5067
          31   5067
5110: oError 17
5112: oTypeSPop
5113: oGetGlobal 7
5115: oPushResult
5116: oTypeSPush
5117: oPop 1
5119: oJumpForward 5304
5121: oGetParam 1
5123: oPushResult
5124: oCall 4674
5126: oPop 1
5128: oCall 8086
5130: oGetParam 1
5132: oPushResult
5133: oCall 5307
5135: oPop 1
5137: oGetParam 1
5139: oPushResult
5140: oCall 4674
5142: oPop 1
5144: oCall 8086
5146: oCall 7955
5148: oTypeSNodeType
5149: oChoice 5177
5151: oEmit 48
5153: oJumpForward 5196
5155: oEmit 54
5157: oJumpForward 5196
5159: oEmit 60
5161: oJumpForward 5196
5163: oCall 10014
5165: oEmit 15
5167: oSetResult 0
5169: oPushResult
5170: oEmitInt
5171: oPop 1
5173: oEmit 54
5175: oJumpForward 5196
5177: Choice Lookup Table
          39   5163
          40   5163
          35   5159
          34   5159
          41   5155
          29   5155
          33   5151
          31   5151
5194: oError 17
5196: oTypeSPop
5197: oGetGlobal 7
5199: oPushResult
5200: oTypeSPush
5201: oPop 1
5203: oJumpForward 5304
5205: oGetParam 1
5207: oPushResult
5208: oCall 4674
5210: oPop 1
5212: oCall 8086
5214: oGetParam 1
5216: oPushResult
5217: oCall 5307
5219: oPop 1
5221: oGetParam 1
5223: oPushResult
5224: oCall 4674
5226: oPop 1
5228: oCall 8086
5230: oCall 7955
5232: oTypeSNodeType
5233: oChoice 5261
5235: oEmit 47
5237: oJumpForward 5280
5239: oEmit 53
5241: oJumpForward 5280
5243: oEmit 59
5245: oJumpForward 5280
5247: oCall 10014
5249: oEmit 15
5251: oSetResult 0
5253: oPushResult
5254: oEmitInt
5255: oPop 1
5257: oEmit 53
5259: oJumpForward 5280
5261: Choice Lookup Table
          39   5247
          40   5247
          35   5243
          34   5243
          41   5239
          29   5239
          33   5235
          31   5235
5278: oError 17
5280: oTypeSPop
5281: oGetGlobal 7
5283: oPushResult
5284: oTypeSPush
5285: oPop 1
5287: oJumpForward 5304
5289: Choice Lookup Table
          11   5205
          10   5121
           9   5037
           8   4953
           7   4869
           6   4785
5302: oJumpForward 5306
5304: oJumpBack 4783
5306: oReturn
5307: oLocalSpace 1
5309: oGetAddrLocal 1
5311: oPushResult
5312: oSetResult 0
5314: oAssign
5315: oGetParam 1
5317: oPushResult
5318: oCall 5487
5320: oPop 1
5322: oInputChoice 5455
5324: oTypeSNodeType
5325: oChoice 5396
5327: oGetLocal 1
5329: oPushResult
5330: oSetResult 0
5332: oPushResult
5333: equal_label
5334: oPop 2
5336: oChoice 5345
5338: oGetAddrLocal 1
5340: oPushResult
5341: oLabelNew
5342: oAssign
5343: oJumpForward 5348
5345: Choice Lookup Table
           1   5338
5348: oEmit 68
5350: oGetLocal 1
5352: oPushResult
5353: oEmitLabel
5354: oPop 1
5356: oJumpForward 5403
5358: oGetParam 1
5360: oPushResult
5361: oCall 4743
5363: oPop 1
5365: oGetLocal 1
5367: oPushResult
5368: oSetResult 0
5370: oPushResult
5371: equal_label
5372: oPop 2
5374: oChoice 5383
5376: oGetAddrLocal 1
5378: oPushResult
5379: oLabelNew
5380: oAssign
5381: oJumpForward 5386
5383: Choice Lookup Table
           1   5376
5386: oEmit 68
5388: oGetLocal 1
5390: oPushResult
5391: oEmitLabel
5392: oPop 1
5394: oJumpForward 5403
5396: Choice Lookup Table
          31   5358
          32   5327
5401: oError 8
5403: oTypeSPop
5404: oEmit 77
5406: oGetFromParam 1
5408: oPushResult
5409: oEmitLabel
5410: oPop 1
5412: oGetParam 1
5414: oPushResult
5415: oSetResult 0
5417: oAssign
5418: oGetParam 1
5420: oPushResult
5421: oCall 5487
5423: oPop 1
5425: oTypeSNodeType
5426: oChoice 5439
5428: oJumpForward 5446
5430: oGetParam 1
5432: oPushResult
5433: oCall 4743
5435: oPop 1
5437: oJumpForward 5446
5439: Choice Lookup Table
          31   5430
          32   5428
5444: oError 8
5446: oTypeSPop
5447: oGetGlobal 8
5449: oPushResult
5450: oTypeSPush
5451: oPop 1
5453: oJumpForward 5460
5455: Choice Lookup Table
          57   5324
5458: oJumpForward 5462
5460: oJumpBack 5322
5462: oGetLocal 1
5464: oPushResult
5465: oSetResult 0
5467: oPushResult
5468: equal_label
5469: oPop 2
5471: oChoice 5483
5473: oEmit 77
5475: oGetLocal 1
5477: oPushResult
5478: oEmitLabel
5479: oPop 1
5481: oJumpForward 5486
5483: Choice Lookup Table
           0   5473
5486: oReturn
5487: oLocalSpace 2
5489: oGetAddrLocal 1
5491: oPushResult
5492: oSetResult 0
5494: oAssign
5495: oGetParam 1
5497: oPushResult
5498: oCall 5625
5500: oPop 1
5502: oInputChoice 5617
5504: oTypeSNodeType
5505: oChoice 5518
5507: oJumpForward 5525
5509: oGetParam 1
5511: oPushResult
5512: oCall 4743
5514: oPop 1
5516: oJumpForward 5525
5518: Choice Lookup Table
          31   5509
          32   5507
5523: oError 8
5525: oTypeSPop
5526: oGetLocal 1
5528: oPushResult
5529: oSetResult 0
5531: oPushResult
5532: equal_label
5533: oPop 2
5535: oChoice 5564
5537: oGetAddrLocal 1
5539: oPushResult
5540: oLabelNew
5541: oAssign
5542: oEmit 78
5544: oGetFromParam 1
5546: oPushResult
5547: oEmitLabel
5548: oPop 1
5550: oGetLocal 1
5552: oPushResult
5553: oEmitLabel
5554: oPop 1
5556: oGetParam 1
5558: oPushResult
5559: oGetLocal 1
5561: oAssign
5562: oJumpForward 5567
5564: Choice Lookup Table
           1   5537
5567: oGetAddrLocal 2
5569: oPushResult
5570: oSetResult 0
5572: oAssign
5573: oGetAddrLocal 2
5575: oPushResult
5576: oCall 5625
5578: oPop 1
5580: oTypeSNodeType
5581: oChoice 5594
5583: oJumpForward 5601
5585: oGetAddrLocal 2
5587: oPushResult
5588: oCall 4743
5590: oPop 1
5592: oJumpForward 5601
5594: Choice Lookup Table
          31   5585
          32   5583
5599: oError 8
5601: oEmit 78
5603: oGetLocal 2
5605: oPushResult
5606: oEmitLabel
5607: oPop 1
5609: oGetLocal 1
5611: oPushResult
5612: oEmitLabel
5613: oPop 1
5615: oJumpForward 5622
5617: Choice Lookup Table
          56   5504
5620: oJumpForward 5624
5622: oJumpBack 5502
5624: oReturn
5625: oLocalSpace 1
5627: oInputChoice 5681
5629: oGetAddrLocal 1
5631: oPushResult
5632: oSetResult 0
5634: oAssign
5635: oGetAddrLocal 1
5637: oPushResult
5638: oCall 5625
5640: oPop 1
5642: oTypeSNodeType
5643: oChoice 5672
5645: oGetParam 1
5647: oPushResult
5648: oLabelNew
5649: oAssign
5650: oEmit 68
5652: oGetFromParam 1
5654: oPushResult
5655: oEmitLabel
5656: oPop 1
5658: oEmit 77
5660: oGetLocal 1
5662: oPushResult
5663: oEmitLabel
5664: oPop 1
5666: oJumpForward 5679
5668: oEmit 42
5670: oJumpForward 5679
5672: Choice Lookup Table
          31   5668
          32   5645
5677: oError 8
5679: oJumpForward 5691
5681: Choice Lookup Table
          58   5629
5684: oGetParam 1
5686: oPushResult
5687: oCall 5692
5689: oPop 1
5691: oReturn
5692: oLocalSpace 2
5694: oGetAddrLocal 1
5696: oPushResult
5697: oSetResult 1
5699: oAssign
5700: oGetParam 1
5702: oPushResult
5703: oCall 5928
5705: oPop 1
5707: oInputChoice 5918
5709: oTypeSNodeType
5710: oChoice 5833
5712: oCall 8040
5714: oGetParam 1
5716: oPushResult
5717: oCall 5928
5719: oPop 1
5721: oTypeSNodeType
5722: oChoice 5730
5724: oEmit 22
5726: oCall 7588
5728: oJumpForward 5739
5730: Choice Lookup Table
          35   5724
          34   5724
5735: oCall 8060
5737: oEmit 37
5739: oJumpForward 5850
5741: oGetLocal 1
5743: oChoice 5759
5745: oGetAddrLocal 2
5747: oPushResult
5748: oCall 9797
5750: oAssign
5751: oGetAddrLocal 1
5753: oPushResult
5754: oSetResult 0
5756: oAssign
5757: oJumpForward 5762
5759: Choice Lookup Table
           1   5745
5762: oGetParam 1
5764: oPushResult
5765: oCall 5928
5767: oPop 1
5769: oTypeSNodeType
5770: oChoice 5808
5772: oCall 9906
5774: oEmit 17
5776: oGetLocal 2
5778: oPushResult
5779: oEmitInt
5780: oPop 1
5782: oGetGlobal 14
5784: oPushResult
5785: oTypeSPush
5786: oPop 1
5788: oJumpForward 5818
5790: oCall 9960
5792: oEmit 17
5794: oGetLocal 2
5796: oPushResult
5797: oEmitInt
5798: oPop 1
5800: oGetGlobal 14
5802: oPushResult
5803: oTypeSPush
5804: oPop 1
5806: oJumpForward 5818
5808: Choice Lookup Table
          33   5790
          39   5772
          40   5772
5815: oError 14
5817: oTypeSPop
5818: oJumpForward 5850
5820: oGetParam 1
5822: oPushResult
5823: oCall 5928
5825: oPop 1
5827: oCall 8040
5829: oCall 7588
5831: oJumpForward 5850
5833: Choice Lookup Table
          35   5820
          34   5820
          33   5741
          39   5741
          40   5741
          30   5712
          29   5712
5848: oError 17
5850: oJumpForward 5925
5852: oTypeSNodeType
5853: oChoice 5905
5855: oCall 8040
5857: oGetParam 1
5859: oPushResult
5860: oCall 5928
5862: oPop 1
5864: oCall 8060
5866: oEmit 40
5868: oJumpForward 5916
5870: oGetParam 1
5872: oPushResult
5873: oCall 5928
5875: oPop 1
5877: oTypeSNodeType
5878: oChoice 5892
5880: oCall 8040
5882: oCall 7644
5884: oJumpForward 5903
5886: oCall 7955
5888: oCall 7700
5890: oJumpForward 5903
5892: Choice Lookup Table
          35   5886
          34   5886
          30   5880
          29   5880
5901: oError 17
5903: oJumpForward 5916
5905: Choice Lookup Table
          35   5870
          34   5870
          30   5855
          29   5855
5914: oError 17
5916: oJumpForward 5925
5918: Choice Lookup Table
          25   5852
          24   5709
5923: oJumpForward 5927
5925: oJumpBack 5707
5927: oReturn
5928: oLocalSpace 0
5930: oGetParam 1
5932: oPushResult
5933: oCall 5979
5935: oPop 1
5937: oInputChoice 5969
5939: oCall 8040
5941: oGetParam 1
5943: oPushResult
5944: oCall 5979
5946: oPop 1
5948: oCall 8060
5950: oEmit 34
5952: oJumpForward 5976
5954: oCall 8040
5956: oGetParam 1
5958: oPushResult
5959: oCall 5979
5961: oPop 1
5963: oCall 8060
5965: oEmit 35
5967: oJumpForward 5976
5969: Choice Lookup Table
          23   5954
          22   5939
5974: oJumpForward 5978
5976: oJumpBack 5937
5978: oReturn
5979: oLocalSpace 0
5981: oInputChoice 6007
5983: oGetParam 1
5985: oPushResult
5986: oCall 6020
5988: oPop 1
5990: oCall 8060
5992: oJumpForward 6019
5994: oGetParam 1
5996: oPushResult
5997: oCall 6020
5999: oPop 1
6001: oCall 8060
6003: oEmit 41
6005: oJumpForward 6019
6007: Choice Lookup Table
          25   5994
          24   5983
6012: oGetParam 1
6014: oPushResult
6015: oCall 6020
6017: oPop 1
6019: oReturn
6020: oLocalSpace 7
6022: oInputChoice 6353
6024: oEmit 15
6026: TOKEN_VALUE
6027: oPushResult
6028: oEmitInt
6029: oPop 1
6031: oGetGlobal 6
6033: oPushResult
6034: oTypeSPush
6035: oPop 1
6037: oJumpForward 6374
6039: oEmit 15
6041: TOKEN_VALUE
6042: oPushResult
6043: oEmitInt
6044: oPop 1
6046: oGetGlobal 9
6048: oPushResult
6049: oTypeSPush
6050: oPop 1
6052: oJumpForward 6374
6054: oGetParam 1
6056: oPushResult
6057: oCall 4774
6059: oPop 1
6061: oInput 15
6063: oJumpForward 6374
6065: oGetAddrLocal 1
6067: oPushResult
6068: CURRENT_STRLIT
6069: oPushResult
6070: oStringAllocShortStringLit
6071: oPop 1
6073: oAssign
6074: oEmit 16
6076: oGetLocal 1
6078: oPushResult
6079: oEmitInt
6080: oPop 1
6082: oGetGlobal 13
6084: oPushResult
6085: oTypeSPush
6086: oPop 1
6088: oCall 7186
6090: oCall 7132
6092: oJumpForward 6374
6094: oGetAddrLocal 2
6096: oPushResult
6097: oScopeFindRequire
6098: oAssign
6099: oGetAddrLocal 2
6101: oPushResult
6102: oCall 244
6104: oPop 1
6106: oGetLocal 2
6108: oPushResult
6109: oNodeType
6110: oPop 1
6112: oChoice 6275
6114: oGetLocal 2
6116: oPushResult
6117: oCall 10109
6119: oPop 1
6121: oJumpForward 6302
6123: oGetLocal 2
6125: oPushResult
6126: oCall 10773
6128: oPop 1
6130: oJumpForward 6302
6132: oGetAddrLocal 3
6134: oPushResult
6135: oGetLocal 2
6137: oPushResult
6138: oSetResult 21
6140: oPushResult
6141: oNodeGet
6142: oPop 2
6144: oAssign
6145: oGetLocal 3
6147: oPushResult
6148: oTypeSPush
6149: oPop 1
6151: oTypeSNodeType
6152: oChoice 6176
6154: oEmit 15
6156: oGetLocal 2
6158: oPushResult
6159: oCall 13074
6161: oPop 1
6163: oJumpForward 6189
6165: oEmit 15
6167: oGetLocal 2
6169: oPushResult
6170: oCall 13074
6172: oPop 1
6174: oJumpForward 6189
6176: Choice Lookup Table
          35   6165
          34   6165
          31   6154
          41   6154
          29   6154
6187: oError 16
6189: oJumpForward 6302
6191: oGetAddrLocal 4
6193: oPushResult
6194: oGetLocal 2
6196: oPushResult
6197: oSetResult 22
6199: oPushResult
6200: oNodeGetInt
6201: oPop 2
6203: oAssign
6204: oGetLocal 4
6206: oPushResult
6207: equal_zero
6208: oPop 1
6210: oChoice 6243
6212: oGetAddrLocal 4
6214: oPushResult
6215: oGetLocal 2
6217: oPushResult
6218: oSetResult 33
6220: oPushResult
6221: oNodeGetString
6222: oPop 2
6224: oPushResult
6225: oStringAllocShortStringLit
6226: oPop 1
6228: oAssign
6229: oGetLocal 2
6231: oPushResult
6232: oSetResult 22
6234: oPushResult
6235: oGetLocal 4
6237: oPushResult
6238: oNodeSetInt
6239: oPop 3
6241: oJumpForward 6246
6243: Choice Lookup Table
           1   6212
6246: oEmit 16
6248: oGetLocal 4
6250: oPushResult
6251: oEmitInt
6252: oPop 1
6254: oGetGlobal 13
6256: oPushResult
6257: oTypeSPush
6258: oPop 1
6260: oCall 7186
6262: oCall 7132
6264: oJumpForward 6302
6266: oGetLocal 2
6268: oPushResult
6269: oCall 6375
6271: oPop 1
6273: oJumpForward 6302
6275: Choice Lookup Table
          25   6266
          24   6266
          22   6266
          21   6266
          18   6191
          17   6132
          16   6132
          14   6123
          13   6114
6294: oError 6
6296: oGetGlobal 6
6298: oPushResult
6299: oTypeSPush
6300: oPop 1
6302: oJumpForward 6374
6304: oInput 0
6306: oGetAddrLocal 5
6308: oPushResult
6309: oScopeFindRequire
6310: oAssign
6311: oGetAddrLocal 5
6313: oPushResult
6314: oCall 244
6316: oPop 1
6318: oGetLocal 5
6320: oPushResult
6321: oSetResult 0
6323: oPushResult
6324: oCall 8621
6326: oPop 2
6328: oGetAddrLocal 6
6330: oPushResult
6331: oTypeSTop
6332: oAssign
6333: oTypeSPop
6334: oGetAddrLocal 7
6336: oPushResult
6337: oGetLocal 6
6339: oPushResult
6340: oCall 12093
6342: oPop 1
6344: oAssign
6345: oGetLocal 7
6347: oPushResult
6348: oTypeSPush
6349: oPop 1
6351: oJumpForward 6374
6353: Choice Lookup Table
          19   6304
           0   6094
           2   6065
          14   6054
           3   6039
           1   6024
6366: oError 6
6368: oGetGlobal 6
6370: oPushResult
6371: oTypeSPush
6372: oPop 1
6374: oReturn
6375: oLocalSpace 2
6377: oGetAddrLocal 1
6379: oPushResult
6380: oGetParam 1
6382: oPushResult
6383: oSetResult 21
6385: oPushResult
6386: oNodeGet
6387: oPop 2
6389: oAssign
6390: oGetAddrLocal 2
6392: oPushResult
6393: oGetParam 1
6395: oPushResult
6396: oCall 13028
6398: oPop 1
6400: oAssign
6401: oGetLocal 1
6403: oPushResult
6404: oTypeSPush
6405: oPop 1
6407: oTypeSNodeType
6408: oChoice 7107
6410: oGetParam 1
6412: oPushResult
6413: oNodeType
6414: oPop 1
6416: oChoice 6562
6418: oEmit 0
6420: oGetParam 1
6422: oPushResult
6423: oCall 13074
6425: oPop 1
6427: oJumpForward 6572
6429: oGetLocal 2
6431: oPushResult
6432: equal_zero
6433: oPop 1
6435: oChoice 6448
6437: oEmit 3
6439: oGetParam 1
6441: oPushResult
6442: oCall 13074
6444: oPop 1
6446: oJumpForward 6466
6448: Choice Lookup Table
           1   6437
6451: oEmit 9
6453: oGetLocal 2
6455: oPushResult
6456: oEmitInt
6457: oPop 1
6459: oGetParam 1
6461: oPushResult
6462: oCall 13074
6464: oPop 1
6466: oJumpForward 6572
6468: oGetParam 1
6470: oPushResult
6471: oSetResult 34
6473: oPushResult
6474: oNodeGetBoolean
6475: oPop 2
6477: oChoice 6520
6479: oGetLocal 2
6481: oPushResult
6482: equal_zero
6483: oPop 1
6485: oChoice 6498
6487: oEmit 8
6489: oGetParam 1
6491: oPushResult
6492: oCall 13074
6494: oPop 1
6496: oJumpForward 6516
6498: Choice Lookup Table
           1   6487
6501: oEmit 14
6503: oGetLocal 2
6505: oPushResult
6506: oEmitInt
6507: oPop 1
6509: oGetParam 1
6511: oPushResult
6512: oCall 13074
6514: oPop 1
6516: oEmit 23
6518: oJumpForward 6560
6520: Choice Lookup Table
           1   6479
6523: oGetLocal 2
6525: oPushResult
6526: equal_zero
6527: oPop 1
6529: oChoice 6542
6531: oEmit 6
6533: oGetParam 1
6535: oPushResult
6536: oCall 13074
6538: oPop 1
6540: oJumpForward 6560
6542: Choice Lookup Table
           1   6531
6545: oEmit 12
6547: oGetLocal 2
6549: oPushResult
6550: oEmitInt
6551: oPop 1
6553: oGetParam 1
6555: oPushResult
6556: oCall 13074
6558: oPop 1
6560: oJumpForward 6572
6562: Choice Lookup Table
          24   6468
          22   6429
          25   6418
          21   6418
6571: oEndChoice
6572: oJumpForward 7131
6574: oGetParam 1
6576: oPushResult
6577: oNodeType
6578: oPop 1
6580: oChoice 6726
6582: oEmit 1
6584: oGetParam 1
6586: oPushResult
6587: oCall 13074
6589: oPop 1
6591: oJumpForward 6736
6593: oGetLocal 2
6595: oPushResult
6596: equal_zero
6597: oPop 1
6599: oChoice 6612
6601: oEmit 4
6603: oGetParam 1
6605: oPushResult
6606: oCall 13074
6608: oPop 1
6610: oJumpForward 6630
6612: Choice Lookup Table
           1   6601
6615: oEmit 10
6617: oGetLocal 2
6619: oPushResult
6620: oEmitInt
6621: oPop 1
6623: oGetParam 1
6625: oPushResult
6626: oCall 13074
6628: oPop 1
6630: oJumpForward 6736
6632: oGetParam 1
6634: oPushResult
6635: oSetResult 34
6637: oPushResult
6638: oNodeGetBoolean
6639: oPop 2
6641: oChoice 6684
6643: oGetLocal 2
6645: oPushResult
6646: equal_zero
6647: oPop 1
6649: oChoice 6662
6651: oEmit 8
6653: oGetParam 1
6655: oPushResult
6656: oCall 13074
6658: oPop 1
6660: oJumpForward 6680
6662: Choice Lookup Table
           1   6651
6665: oEmit 14
6667: oGetLocal 2
6669: oPushResult
6670: oEmitInt
6671: oPop 1
6673: oGetParam 1
6675: oPushResult
6676: oCall 13074
6678: oPop 1
6680: oEmit 24
6682: oJumpForward 6724
6684: Choice Lookup Table
           1   6643
6687: oGetLocal 2
6689: oPushResult
6690: equal_zero
6691: oPop 1
6693: oChoice 6706
6695: oEmit 7
6697: oGetParam 1
6699: oPushResult
6700: oCall 13074
6702: oPop 1
6704: oJumpForward 6724
6706: Choice Lookup Table
           1   6695
6709: oEmit 13
6711: oGetLocal 2
6713: oPushResult
6714: oEmitInt
6715: oPop 1
6717: oGetParam 1
6719: oPushResult
6720: oCall 13074
6722: oPop 1
6724: oJumpForward 6736
6726: Choice Lookup Table
          24   6632
          22   6593
          25   6582
          21   6582
6735: oEndChoice
6736: oJumpForward 7131
6738: oError 16
6740: oJumpForward 7131
6742: oGetParam 1
6744: oPushResult
6745: oNodeType
6746: oPop 1
6748: oChoice 6894
6750: oEmit 2
6752: oGetParam 1
6754: oPushResult
6755: oCall 13074
6757: oPop 1
6759: oJumpForward 6904
6761: oGetLocal 2
6763: oPushResult
6764: equal_zero
6765: oPop 1
6767: oChoice 6780
6769: oEmit 5
6771: oGetParam 1
6773: oPushResult
6774: oCall 13074
6776: oPop 1
6778: oJumpForward 6798
6780: Choice Lookup Table
           1   6769
6783: oEmit 11
6785: oGetLocal 2
6787: oPushResult
6788: oEmitInt
6789: oPop 1
6791: oGetParam 1
6793: oPushResult
6794: oCall 13074
6796: oPop 1
6798: oJumpForward 6904
6800: oGetParam 1
6802: oPushResult
6803: oSetResult 34
6805: oPushResult
6806: oNodeGetBoolean
6807: oPop 2
6809: oChoice 6852
6811: oGetLocal 2
6813: oPushResult
6814: equal_zero
6815: oPop 1
6817: oChoice 6830
6819: oEmit 8
6821: oGetParam 1
6823: oPushResult
6824: oCall 13074
6826: oPop 1
6828: oJumpForward 6848
6830: Choice Lookup Table
           1   6819
6833: oEmit 14
6835: oGetLocal 2
6837: oPushResult
6838: oEmitInt
6839: oPop 1
6841: oGetParam 1
6843: oPushResult
6844: oCall 13074
6846: oPop 1
6848: oEmit 25
6850: oJumpForward 6892
6852: Choice Lookup Table
           1   6811
6855: oGetLocal 2
6857: oPushResult
6858: equal_zero
6859: oPop 1
6861: oChoice 6874
6863: oEmit 8
6865: oGetParam 1
6867: oPushResult
6868: oCall 13074
6870: oPop 1
6872: oJumpForward 6892
6874: Choice Lookup Table
           1   6863
6877: oEmit 14
6879: oGetLocal 2
6881: oPushResult
6882: oEmitInt
6883: oPop 1
6885: oGetParam 1
6887: oPushResult
6888: oCall 13074
6890: oPop 1
6892: oJumpForward 6904
6894: Choice Lookup Table
          24   6800
          22   6761
          25   6750
          21   6750
6903: oEndChoice
6904: oInputChoice 6934
6906: oTypeSPop
6907: oGetLocal 1
6909: oPushResult
6910: oSetResult 37
6912: oPushResult
6913: oNodeGet
6914: oPop 2
6916: oPushResult
6917: oTypeSPush
6918: oPop 1
6920: oCall 7186
6922: oCall 7132
6924: oJumpForward 6939
6926: oCall 7381
6928: oCall 7186
6930: oCall 7132
6932: oJumpForward 6939
6934: Choice Lookup Table
          16   6926
          18   6906
6939: oJumpForward 7131
6941: oGetParam 1
6943: oPushResult
6944: oNodeType
6945: oPop 1
6947: oChoice 7091
6949: oEmit 16
6951: oGetParam 1
6953: oPushResult
6954: oCall 13074
6956: oPop 1
6958: oJumpForward 7101
6960: oGetLocal 2
6962: oPushResult
6963: equal_zero
6964: oPop 1
6966: oChoice 6979
6968: oEmit 17
6970: oGetParam 1
6972: oPushResult
6973: oCall 13074
6975: oPop 1
6977: oJumpForward 6997
6979: Choice Lookup Table
           1   6968
6982: oEmit 20
6984: oGetLocal 2
6986: oPushResult
6987: oEmitInt
6988: oPop 1
6990: oGetParam 1
6992: oPushResult
6993: oCall 13074
6995: oPop 1
6997: oJumpForward 7101
6999: oGetParam 1
7001: oPushResult
7002: oSetResult 34
7004: oPushResult
7005: oNodeGetBoolean
7006: oPop 2
7008: oChoice 7049
7010: oGetLocal 2
7012: oPushResult
7013: equal_zero
7014: oPop 1
7016: oChoice 7029
7018: oEmit 8
7020: oGetParam 1
7022: oPushResult
7023: oCall 13074
7025: oPop 1
7027: oJumpForward 7047
7029: Choice Lookup Table
           1   7018
7032: oEmit 14
7034: oGetLocal 2
7036: oPushResult
7037: oEmitInt
7038: oPop 1
7040: oGetParam 1
7042: oPushResult
7043: oCall 13074
7045: oPop 1
7047: oJumpForward 7089
7049: Choice Lookup Table
           1   7010
7052: oGetLocal 2
7054: oPushResult
7055: equal_zero
7056: oPop 1
7058: oChoice 7071
7060: oEmit 18
7062: oGetParam 1
7064: oPushResult
7065: oCall 13074
7067: oPop 1
7069: oJumpForward 7089
7071: Choice Lookup Table
           1   7060
7074: oEmit 21
7076: oGetLocal 2
7078: oPushResult
7079: oEmitInt
7080: oPop 1
7082: oGetParam 1
7084: oPushResult
7085: oCall 13074
7087: oPop 1
7089: oJumpForward 7101
7091: Choice Lookup Table
          24   6999
          22   6960
          25   6949
          21   6949
7100: oEndChoice
7101: oCall 7186
7103: oCall 7132
7105: oJumpForward 7131
7107: Choice Lookup Table
          40   6941
          38   6941
          36   6941
          35   6742
          34   6742
          28   6738
          33   6574
          30   6574
          31   6574
          41   6410
          29   6410
7130: oEndChoice
7131: oReturn
7132: oLocalSpace 0
7134: oTypeSNodeType
7135: oChoice 7159
7137: oEmit 23
7139: oJumpForward 7185
7141: oEmit 24
7143: oJumpForward 7185
7145: oError 16
7147: oJumpForward 7185
7149: oEmit 25
7151: oJumpForward 7185
7153: oError 29
7155: oJumpForward 7185
7157: oJumpForward 7185
7159: Choice Lookup Table
          40   7157
          39   7157
          38   7157
          36   7157
          35   7153
          34   7149
          28   7145
          33   7141
          30   7141
          31   7141
          41   7137
          29   7137
7184: oEndChoice
7185: oReturn
7186: oLocalSpace 0
7188: oInputChoice 7226
7190: oTypeSNodeType
7191: oChoice 7205
7193: oCall 7238
7195: oJumpForward 7216
7197: oCall 7381
7199: oJumpForward 7216
7201: oCall 7460
7203: oJumpForward 7216
7205: Choice Lookup Table
          40   7201
          39   7201
          34   7197
          36   7193
7214: oError 10
7216: oJumpForward 7235
7218: oCall 7490
7220: oJumpForward 7235
7222: oCall 7763
7224: oJumpForward 7235
7226: Choice Lookup Table
          18   7222
          20   7218
          16   7190
7233: oJumpForward 7237
7235: oJumpBack 7188
7237: oReturn
7238: oLocalSpace 3
7240: oTypeSNodeType
7241: oChoice 7245
7243: oJumpForward 7250
7245: Choice Lookup Table
          36   7243
7248: oError 10
7250: oTypeSNodeType
7251: oChoice 7255
7253: oJumpForward 7260
7255: Choice Lookup Table
          36   7253
7258: oError 13
7260: oGetAddrLocal 1
7262: oPushResult
7263: oTypeSTop
7264: oPushResult
7265: oSetResult 38
7267: oPushResult
7268: oNodeGet
7269: oPop 2
7271: oPushResult
7272: oCall 12177
7274: oPop 1
7276: oAssign
7277: oGetAddrLocal 2
7279: oPushResult
7280: oTypeSTop
7281: oPushResult
7282: oSetResult 37
7284: oPushResult
7285: oNodeGet
7286: oPop 2
7288: oAssign
7289: oTypeSPop
7290: oGetLocal 2
7292: oPushResult
7293: oTypeSPush
7294: oPop 1
7296: oCall 4613
7298: oCall 8013
7300: oGetLocal 1
7302: oPushResult
7303: equal_zero
7304: oPop 1
7306: oChoice 7320
7308: oEmit 15
7310: oGetLocal 1
7312: oPushResult
7313: oEmitInt
7314: oPop 1
7316: oEmit 40
7318: oJumpForward 7323
7320: Choice Lookup Table
           0   7308
7323: oGetAddrLocal 3
7325: oPushResult
7326: oGetLocal 2
7328: oPushResult
7329: oSetResult 17
7331: oPushResult
7332: oNodeGetInt
7333: oPop 2
7335: oAssign
7336: oGetLocal 3
7338: oPushResult
7339: oSetResult 1
7341: oPushResult
7342: equal
7343: oPop 2
7345: oChoice 7359
7347: oEmit 15
7349: oGetLocal 3
7351: oPushResult
7352: oEmitInt
7353: oPop 1
7355: oEmit 34
7357: oJumpForward 7362
7359: Choice Lookup Table
           0   7347
7362: oEmit 36
7364: oInputChoice 7372
7366: oJumpForward 7380
7368: oJumpForward 7378
7370: oJumpForward 7378
7372: Choice Lookup Table
          13   7370
          17   7366
7377: oEndChoice
7378: oJumpBack 7250
7380: oReturn
7381: oLocalSpace 2
7383: oTypeSNodeType
7384: oChoice 7388
7386: oJumpForward 7393
7388: Choice Lookup Table
          34   7386
7391: oError 29
7393: oGetAddrLocal 1
7395: oPushResult
7396: oTypeSTop
7397: oPushResult
7398: oSetResult 37
7400: oPushResult
7401: oNodeGet
7402: oPop 2
7404: oAssign
7405: oTypeSPop
7406: oGetLocal 1
7408: oPushResult
7409: oTypeSPush
7410: oPop 1
7412: oCall 4613
7414: oCall 8013
7416: oGetAddrLocal 2
7418: oPushResult
7419: oGetLocal 1
7421: oPushResult
7422: oSetResult 17
7424: oPushResult
7425: oNodeGetInt
7426: oPop 2
7428: oAssign
7429: oGetLocal 2
7431: oPushResult
7432: oSetResult 1
7434: oPushResult
7435: equal
7436: oPop 2
7438: oChoice 7452
7440: oEmit 15
7442: oGetLocal 2
7444: oPushResult
7445: oEmitInt
7446: oPop 1
7448: oEmit 34
7450: oJumpForward 7455
7452: Choice Lookup Table
           0   7440
7455: oEmit 36
7457: oInput 17
7459: oReturn
7460: oLocalSpace 0
7462: oTypeSNodeType
7463: oChoice 7467
7465: oJumpForward 7474
7467: Choice Lookup Table
          40   7465
          39   7465
7472: oError 29
7474: oTypeSPop
7475: oGetGlobal 9
7477: oPushResult
7478: oTypeSPush
7479: oPop 1
7481: oCall 4613
7483: oCall 8013
7485: oEmit 36
7487: oInput 17
7489: oReturn
7490: oLocalSpace 2
7492: oTypeSNodeType
7493: oChoice 7497
7495: oJumpForward 7502
7497: Choice Lookup Table
          38   7495
7500: oError 11
7502: oTypeSTop
7503: oPushResult
7504: oSetResult 41
7506: oPushResult
7507: oNodeGet
7508: oPop 2
7510: oPushResult
7511: oScopeEnter
7512: oPop 1
7514: oInput 0
7516: oGetAddrLocal 1
7518: oPushResult
7519: oScopeFindRequire
7520: oAssign
7521: oGetLocal 1
7523: oPushResult
7524: oNodeType
7525: oPop 1
7527: oChoice 7531
7529: oJumpForward 7536
7531: Choice Lookup Table
          23   7529
7534: oError 12
7536: oScopeEnd
7537: oGetAddrLocal 2
7539: oPushResult
7540: oGetLocal 1
7542: oPushResult
7543: oSetResult 22
7545: oPushResult
7546: oNodeGetInt
7547: oPop 2
7549: oAssign
7550: oGetLocal 2
7552: oPushResult
7553: equal_zero
7554: oPop 1
7556: oChoice 7570
7558: oEmit 15
7560: oGetLocal 2
7562: oPushResult
7563: oEmitInt
7564: oPop 1
7566: oEmit 36
7568: oJumpForward 7573
7570: Choice Lookup Table
           0   7558
7573: oTypeSPop
7574: oGetLocal 1
7576: oPushResult
7577: oSetResult 21
7579: oPushResult
7580: oNodeGet
7581: oPop 2
7583: oPushResult
7584: oTypeSPush
7585: oPop 1
7587: oReturn
7588: oLocalSpace 2
7590: oGetAddrLocal 1
7592: oPushResult
7593: oTypeSTop
7594: oPushResult
7595: oSetResult 37
7597: oPushResult
7598: oNodeGet
7599: oPop 2
7601: oAssign
7602: oGetAddrLocal 2
7604: oPushResult
7605: oGetLocal 1
7607: oPushResult
7608: oSetResult 17
7610: oPushResult
7611: oNodeGetInt
7612: oPop 2
7614: oAssign
7615: oGetLocal 2
7617: oPushResult
7618: oSetResult 1
7620: oPushResult
7621: equal
7622: oPop 2
7624: oChoice 7638
7626: oEmit 15
7628: oGetLocal 2
7630: oPushResult
7631: oEmitInt
7632: oPop 1
7634: oEmit 34
7636: oJumpForward 7641
7638: Choice Lookup Table
           0   7626
7641: oEmit 36
7643: oReturn
7644: oLocalSpace 2
7646: oGetAddrLocal 1
7648: oPushResult
7649: oTypeSTop
7650: oPushResult
7651: oSetResult 37
7653: oPushResult
7654: oNodeGet
7655: oPop 2
7657: oAssign
7658: oGetAddrLocal 2
7660: oPushResult
7661: oGetLocal 1
7663: oPushResult
7664: oSetResult 17
7666: oPushResult
7667: oNodeGetInt
7668: oPop 2
7670: oAssign
7671: oGetLocal 2
7673: oPushResult
7674: oSetResult 1
7676: oPushResult
7677: equal
7678: oPop 2
7680: oChoice 7694
7682: oEmit 15
7684: oGetLocal 2
7686: oPushResult
7687: oEmitInt
7688: oPop 1
7690: oEmit 34
7692: oJumpForward 7697
7694: Choice Lookup Table
           0   7682
7697: oEmit 39
7699: oReturn
7700: oLocalSpace 2
7702: oEmit 38
7704: oGetAddrLocal 1
7706: oPushResult
7707: oTypeSTop
7708: oPushResult
7709: oSetResult 37
7711: oPushResult
7712: oNodeGet
7713: oPop 2
7715: oAssign
7716: oGetAddrLocal 2
7718: oPushResult
7719: oGetLocal 1
7721: oPushResult
7722: oSetResult 17
7724: oPushResult
7725: oNodeGetInt
7726: oPop 2
7728: oAssign
7729: oGetLocal 2
7731: oPushResult
7732: oSetResult 1
7734: oPushResult
7735: equal
7736: oPop 2
7738: oChoice 7752
7740: oEmit 15
7742: oGetLocal 2
7744: oPushResult
7745: oEmitInt
7746: oPop 1
7748: oEmit 35
7750: oJumpForward 7755
7752: Choice Lookup Table
           0   7740
7755: oTypeSPop
7756: oGetGlobal 6
7758: oPushResult
7759: oTypeSPush
7760: oPop 1
7762: oReturn
7763: oLocalSpace 1
7765: oTypeSNodeType
7766: oChoice 7774
7768: oJumpForward 7781
7770: oError 29
7772: oJumpForward 7781
7774: Choice Lookup Table
          35   7770
          34   7768
7779: oError 9
7781: oEmit 25
7783: oGetAddrLocal 1
7785: oPushResult
7786: oTypeSTop
7787: oAssign
7788: oTypeSPop
7789: oGetLocal 1
7791: oPushResult
7792: oSetResult 37
7794: oPushResult
7795: oNodeGet
7796: oPop 2
7798: oPushResult
7799: oTypeSPush
7800: oPop 1
7802: oReturn
7803: oLocalSpace 2
7805: oGetAddrLocal 1
7807: oPushResult
7808: oTypeSNodeType
7809: oAssign
7810: oTypeSPop
7811: oGetLocal 1
7813: oPushResult
7814: oTypeSNodeType
7815: oPushResult
7816: equal_node_type
7817: oPop 2
7819: oChoice 7951
7821: oTypeSNodeType
7822: oChoice 7936
7824: oGetLocal 1
7826: oChoice 7833
7828: oEmit 30
7830: oReturn
7831: oJumpForward 7836
7833: Choice Lookup Table
          30   7828
7836: oJumpForward 7947
7838: oGetLocal 1
7840: oChoice 7847
7842: oEmit 31
7844: oReturn
7845: oJumpForward 7850
7847: Choice Lookup Table
          29   7842
7850: oJumpForward 7947
7852: oGetLocal 1
7854: oChoice 7887
7856: oReturn
7857: oJumpForward 7892
7859: oTypeSTop
7860: oPushResult
7861: oGetGlobal 10
7863: oPushResult
7864: equal_node
7865: oPop 2
7867: oChoice 7882
7869: oEmit 15
7871: oSetResult 1
7873: oPushResult
7874: oEmitInt
7875: oPop 1
7877: oEmit 36
7879: oReturn
7880: oJumpForward 7885
7882: Choice Lookup Table
           1   7869
7885: oJumpForward 7892
7887: Choice Lookup Table
          39   7859
          35   7856
7892: oJumpForward 7947
7894: oGetLocal 1
7896: oChoice 7901
7898: oReturn
7899: oJumpForward 7904
7901: Choice Lookup Table
          34   7898
7904: oJumpForward 7947
7906: oGetLocal 1
7908: oChoice 7929
7910: oReturn
7911: oJumpForward 7934
7913: oGetGlobal 9
7915: oPushResult
7916: oTypeSPush
7917: oPop 1
7919: oGetAddrLocal 2
7921: oPushResult
7922: oCall 9797
7924: oAssign
7925: oTypeSPop
7926: oReturn
7927: oJumpForward 7934
7929: Choice Lookup Table
          33   7913
          39   7910
7934: oJumpForward 7947
7936: Choice Lookup Table
          40   7906
          35   7894
          34   7852
          30   7838
          29   7824
7947: oError 14
7949: oJumpForward 7954
7951: Choice Lookup Table
           0   7821
7954: oReturn
7955: oLocalSpace 1
7957: oGetAddrLocal 1
7959: oPushResult
7960: oTypeSNodeType
7961: oAssign
7962: oTypeSPop
7963: oGetLocal 1
7965: oPushResult
7966: oTypeSNodeType
7967: oPushResult
7968: equal_node_type
7969: oPop 2
7971: oChoice 8009
7973: oTypeSNodeType
7974: oChoice 8000
7976: oGetLocal 1
7978: oChoice 7983
7980: oReturn
7981: oJumpForward 7986
7983: Choice Lookup Table
          35   7980
7986: oJumpForward 8005
7988: oGetLocal 1
7990: oChoice 7995
7992: oReturn
7993: oJumpForward 7998
7995: Choice Lookup Table
          34   7992
7998: oJumpForward 8005
8000: Choice Lookup Table
          35   7988
          34   7976
8005: oError 14
8007: oJumpForward 8012
8009: Choice Lookup Table
           0   7973
8012: oReturn
8013: oLocalSpace 0
8015: oTypeSNodeType
8016: oChoice 8020
8018: oJumpForward 8025
8020: Choice Lookup Table
          29   8018
8023: oError 7
8025: oTypeSPop
8026: oReturn
8027: oLocalSpace 0
8029: oTypeSNodeType
8030: oChoice 8034
8032: oJumpForward 8039
8034: Choice Lookup Table
          29   8032
8037: oError 7
8039: oReturn
8040: oLocalSpace 0
8042: oTypeSNodeType
8043: oChoice 8051
8045: oJumpForward 8058
8047: oEmit 30
8049: oJumpForward 8058
8051: Choice Lookup Table
          30   8047
          29   8045
8056: oError 7
8058: oTypeSPop
8059: oReturn
8060: oLocalSpace 0
8062: oTypeSNodeType
8063: oChoice 8078
8065: oJumpForward 8085
8067: oEmit 30
8069: oTypeSPop
8070: oGetGlobal 6
8072: oPushResult
8073: oTypeSPush
8074: oPop 1
8076: oJumpForward 8085
8078: Choice Lookup Table
          30   8067
          29   8065
8083: oError 7
8085: oReturn
8086: oLocalSpace 0
8088: oTypeSNodeType
8089: oChoice 8102
8091: oEmit 30
8093: oTypeSPop
8094: oGetGlobal 6
8096: oPushResult
8097: oTypeSPush
8098: oPop 1
8100: oJumpForward 8105
8102: Choice Lookup Table
          30   8091
8105: oReturn
8106: oLocalSpace 0
8108: oTypeSNodeType
8109: oChoice 8113
8111: oJumpForward 8118
8113: Choice Lookup Table
          31   8111
8116: oError 8
8118: oTypeSPop
8119: oReturn
8120: oLocalSpace 0
8122: oTypeSNodeType
8123: oChoice 8127
8125: oJumpForward 8132
8127: Choice Lookup Table
          31   8125
8130: oError 8
8132: oReturn
8133: oLocalSpace 0
8135: oInputChoice 8198
8137: oCall 9660
8139: oJumpForward 8229
8141: oCall 9667
8143: oJumpForward 8229
8145: oCall 9791
8147: oJumpForward 8229
8149: oCall 9794
8151: oJumpForward 8229
8153: oCall 8811
8155: oJumpForward 8229
8157: oCall 9134
8159: oJumpForward 8229
8161: oCall 8877
8163: oJumpForward 8229
8165: oCall 9054
8167: oJumpForward 8229
8169: oCall 9219
8171: oJumpForward 8229
8173: oCall 9187
8175: oJumpForward 8229
8177: oCall 9637
8179: oJumpForward 8229
8181: oCall 8230
8183: oJumpForward 8229
8185: oCall 9251
8187: oJumpForward 8229
8189: oCall 9585
8191: oJumpForward 8229
8193: oChangeIntLitToLabelIdent
8194: oCall 8230
8196: oJumpForward 8229
8198: Choice Lookup Table
           1   8193
          55   8189
          53   8185
           0   8181
          35   8177
          51   8173
          52   8169
          49   8165
          44   8161
          48   8157
          41   8153
          68   8149
          67   8145
          66   8141
          65   8137
8229: oReturn
8230: oLocalSpace 1
8232: oGetAddrLocal 1
8234: oPushResult
8235: oScopeFindRequire
8236: oAssign
8237: oGetAddrLocal 1
8239: oPushResult
8240: oCall 244
8242: oPop 1
8244: oGetLocal 1
8246: oPushResult
8247: oNodeType
8248: oPop 1
8250: oChoice 8290
8252: oGetLocal 1
8254: oPushResult
8255: oCall 8306
8257: oPop 1
8259: oCall 8133
8261: oJumpForward 8305
8263: oGetLocal 1
8265: oPushResult
8266: oCall 10109
8268: oPop 1
8270: oJumpForward 8305
8272: oGetLocal 1
8274: oPushResult
8275: oCall 8356
8277: oPop 1
8279: oJumpForward 8305
8281: oGetLocal 1
8283: oPushResult
8284: oCall 8446
8286: oPop 1
8288: oJumpForward 8305
8290: Choice Lookup Table
          13   8281
          24   8272
          22   8272
          21   8272
          12   8263
          26   8252
8303: oError 0
8305: oReturn
8306: oLocalSpace 0
8308: oGetParam 1
8310: oPushResult
8311: oSetResult 35
8313: oPushResult
8314: oNodeGetBoolean
8315: oPop 2
8317: oChoice 8323
8319: oError 21
8321: oJumpForward 8326
8323: Choice Lookup Table
           1   8319
8326: oEmit 77
8328: oGetParam 1
8330: oPushResult
8331: oSetResult 22
8333: oPushResult
8334: oNodeGetLabel
8335: oPop 2
8337: oPushResult
8338: oEmitLabel
8339: oPop 1
8341: oGetParam 1
8343: oPushResult
8344: oSetResult 35
8346: oPushResult
8347: oSetResult 1
8349: oPushResult
8350: oNodeSetBoolean
8351: oPop 3
8353: oInput 12
8355: oReturn
8356: oLocalSpace 0
8358: oGetParam 1
8360: oPushResult
8361: oSetResult 1
8363: oPushResult
8364: oCall 8621
8366: oPop 2
8368: oInput 4
8370: oCall 4613
8372: oCall 7803
8374: oCall 8377
8376: oReturn
8377: oLocalSpace 1
8379: oTypeSNodeType
8380: oChoice 8420
8382: oEmit 26
8384: oJumpForward 8444
8386: oEmit 27
8388: oJumpForward 8444
8390: oError 16
8392: oJumpForward 8444
8394: oEmit 28
8396: oJumpForward 8444
8398: oGetAddrLocal 1
8400: oPushResult
8401: oTypeSTop
8402: oPushResult
8403: oSetResult 17
8405: oPushResult
8406: oNodeGetInt
8407: oPop 2
8409: oAssign
8410: oEmit 29
8412: oGetLocal 1
8414: oPushResult
8415: oEmitInt
8416: oPop 1
8418: oJumpForward 8444
8420: Choice Lookup Table
          40   8398
          38   8398
          36   8398
          35   8394
          34   8394
          28   8390
          33   8386
          30   8386
          31   8386
          41   8382
          29   8382
8443: oEndChoice
8444: oTypeSPop
8445: oReturn
8446: oLocalSpace 1
8448: oGetParam 1
8450: oPushResult
8451: oSetResult 6
8453: oPushResult
8454: oNodeGet
8455: oPop 2
8457: oPushResult
8458: oScopeCurrent
8459: oPushResult
8460: oNodeEqual
8461: oPop 2
8463: oChoice 8469
8465: oError 20
8467: oJumpForward 8472
8469: Choice Lookup Table
           0   8465
8472: oEmit 8
8474: oGetParam 1
8476: oPushResult
8477: oSetResult 31
8479: oPushResult
8480: oNodeGetInt
8481: oPop 2
8483: oPushResult
8484: oEmitInt
8485: oPop 1
8487: oGetParam 1
8489: oPushResult
8490: oSetResult 21
8492: oPushResult
8493: oNodeGet
8494: oPop 2
8496: oPushResult
8497: oTypeSPush
8498: oPop 1
8500: oInput 4
8502: oCall 4613
8504: oCall 7803
8506: oTypeSNodeType
8507: oChoice 8547
8509: oEmit 26
8511: oJumpForward 8571
8513: oEmit 27
8515: oJumpForward 8571
8517: oError 16
8519: oJumpForward 8571
8521: oEmit 28
8523: oJumpForward 8571
8525: oGetAddrLocal 1
8527: oPushResult
8528: oTypeSTop
8529: oPushResult
8530: oSetResult 17
8532: oPushResult
8533: oNodeGetInt
8534: oPop 2
8536: oAssign
8537: oEmit 29
8539: oGetLocal 1
8541: oPushResult
8542: oEmitInt
8543: oPop 1
8545: oJumpForward 8571
8547: Choice Lookup Table
          40   8525
          38   8525
          36   8525
          35   8521
          34   8521
          28   8517
          33   8513
          30   8513
          31   8513
          41   8509
          29   8509
8570: oEndChoice
8571: oTypeSPop
8572: oReturn
8573: oLocalSpace 1
8575: oInput 0
8577: oGetAddrLocal 1
8579: oPushResult
8580: oScopeFindRequire
8581: oAssign
8582: oGetAddrLocal 1
8584: oPushResult
8585: oCall 244
8587: oPop 1
8589: oGetLocal 1
8591: oPushResult
8592: oNodeType
8593: oPop 1
8595: oChoice 8599
8597: oJumpForward 8610
8599: Choice Lookup Table
          25   8597
          24   8597
          22   8597
          21   8597
8608: oError 4
8610: oGetLocal 1
8612: oPushResult
8613: oGetParam 1
8615: oPushResult
8616: oCall 8621
8618: oPop 2
8620: oReturn
8621: oLocalSpace 0
8623: oGetParam 2
8625: oPushResult
8626: oNodeType
8627: oPop 1
8629: oChoice 8711
8631: oEmit 16
8633: oGetParam 2
8635: oPushResult
8636: oCall 13074
8638: oPop 1
8640: oJumpForward 8722
8642: oEmit 17
8644: oGetParam 2
8646: oPushResult
8647: oCall 13074
8649: oPop 1
8651: oJumpForward 8722
8653: oGetParam 2
8655: oPushResult
8656: oSetResult 34
8658: oPushResult
8659: oNodeGetBoolean
8660: oPop 2
8662: oChoice 8675
8664: oEmit 8
8666: oGetParam 2
8668: oPushResult
8669: oCall 13074
8671: oPop 1
8673: oJumpForward 8687
8675: Choice Lookup Table
           1   8664
8678: oEmit 18
8680: oGetParam 2
8682: oPushResult
8683: oCall 13074
8685: oPop 1
8687: oJumpForward 8722
8689: oGetParam 1
8691: oChoice 8704
8693: oEmit 16
8695: oGetParam 2
8697: oPushResult
8698: oCall 13074
8700: oPop 1
8702: oJumpForward 8709
8704: Choice Lookup Table
           0   8693
8707: oError 4
8709: oJumpForward 8722
8711: Choice Lookup Table
          25   8689
          24   8653
          22   8642
          21   8631
8720: oError 4
8722: oGetParam 2
8724: oPushResult
8725: oSetResult 21
8727: oPushResult
8728: oNodeGet
8729: oPop 2
8731: oPushResult
8732: oTypeSPush
8733: oPop 1
8735: oTypeSNodeType
8736: oChoice 8751
8738: oInputChoice 8746
8740: oEmit 25
8742: oCall 7381
8744: oJumpForward 8749
8746: Choice Lookup Table
          16   8740
8749: oJumpForward 8754
8751: Choice Lookup Table
          34   8738
8754: oCall 7186
8756: oReturn
8757: oLocalSpace 0
8759: oGetParam 1
8761: oPushResult
8762: oSetResult 1
8764: oPushResult
8765: oCall 8621
8767: oPop 2
8769: oCall 8013
8771: oGetParam 1
8773: oPushResult
8774: oCall 6375
8776: oPop 1
8778: oTypeSPop
8779: oEmit 32
8781: oEmit 26
8783: oReturn
8784: oLocalSpace 0
8786: oGetParam 1
8788: oPushResult
8789: oSetResult 1
8791: oPushResult
8792: oCall 8621
8794: oPop 2
8796: oCall 8013
8798: oGetParam 1
8800: oPushResult
8801: oCall 6375
8803: oPop 1
8805: oTypeSPop
8806: oEmit 33
8808: oEmit 26
8810: oReturn
8811: oLocalSpace 2
8813: oGetAddrLocal 1
8815: oPushResult
8816: oSetResult 0
8818: oAssign
8819: oGetAddrLocal 1
8821: oPushResult
8822: oCall 4636
8824: oPop 1
8826: oInput 42
8828: oCall 8133
8830: oInputChoice 8865
8832: oGetAddrLocal 2
8834: oPushResult
8835: oLabelNew
8836: oAssign
8837: oEmit 68
8839: oGetLocal 2
8841: oPushResult
8842: oEmitLabel
8843: oPop 1
8845: oEmit 77
8847: oGetLocal 1
8849: oPushResult
8850: oEmitLabel
8851: oPop 1
8853: oCall 8133
8855: oEmit 77
8857: oGetLocal 2
8859: oPushResult
8860: oEmitLabel
8861: oPop 1
8863: oJumpForward 8876
8865: Choice Lookup Table
          43   8832
8868: oEmit 77
8870: oGetLocal 1
8872: oPushResult
8873: oEmitLabel
8874: oPop 1
8876: oReturn
8877: oLocalSpace 4
8879: oInput 0
8881: oGetAddrLocal 1
8883: oPushResult
8884: oScopeFindRequire
8885: oAssign
8886: oGetLocal 1
8888: oPushResult
8889: oSetResult 1
8891: oPushResult
8892: oCall 8621
8894: oPop 2
8896: oCall 8013
8898: oInput 4
8900: oCall 4613
8902: oCall 8013
8904: oEmit 26
8906: oGetAddrLocal 2
8908: oPushResult
8909: oLabelNew
8910: oAssign
8911: oGetAddrLocal 3
8913: oPushResult
8914: oLabelNew
8915: oAssign
8916: oEmit 68
8918: oGetLocal 3
8920: oPushResult
8921: oEmitLabel
8922: oPop 1
8924: oGetAddrLocal 4
8926: oPushResult
8927: oLabelNew
8928: oAssign
8929: oEmit 77
8931: oGetLocal 4
8933: oPushResult
8934: oEmitLabel
8935: oPop 1
8937: oInputChoice 9017
8939: oGetLocal 1
8941: oPushResult
8942: oCall 8757
8944: oPop 1
8946: oEmit 77
8948: oGetLocal 3
8950: oPushResult
8951: oEmitLabel
8952: oPop 1
8954: oGetLocal 1
8956: oPushResult
8957: oCall 6375
8959: oPop 1
8961: oTypeSPop
8962: oCall 4613
8964: oCall 8013
8966: oEmit 51
8968: oEmit 69
8970: oGetLocal 2
8972: oPushResult
8973: oEmitLabel
8974: oPop 1
8976: oJumpForward 9023
8978: oGetLocal 1
8980: oPushResult
8981: oCall 8784
8983: oPop 1
8985: oEmit 77
8987: oGetLocal 3
8989: oPushResult
8990: oEmitLabel
8991: oPop 1
8993: oGetLocal 1
8995: oPushResult
8996: oCall 6375
8998: oPop 1
9000: oTypeSPop
9001: oCall 4613
9003: oCall 8013
9005: oEmit 52
9007: oEmit 69
9009: oGetLocal 2
9011: oPushResult
9012: oEmitLabel
9013: oPop 1
9015: oJumpForward 9023
9017: Choice Lookup Table
          46   8978
          45   8939
9022: oEndChoice
9023: oGetLocal 4
9025: oPushResult
9026: oGetLocal 2
9028: oPushResult
9029: oLoopPush
9030: oPop 2
9032: oInput 47
9034: oCall 8133
9036: oEmit 68
9038: oGetLocal 4
9040: oPushResult
9041: oEmitLabel
9042: oPop 1
9044: oEmit 77
9046: oGetLocal 2
9048: oPushResult
9049: oEmitLabel
9050: oPop 1
9052: oLoopPop
9053: oReturn
9054: oLocalSpace 3
9056: oGetAddrLocal 1
9058: oPushResult
9059: oLabelNew
9060: oAssign
9061: oEmit 77
9063: oGetLocal 1
9065: oPushResult
9066: oEmitLabel
9067: oPop 1
9069: oGetAddrLocal 2
9071: oPushResult
9072: oLabelNew
9073: oAssign
9074: oGetLocal 1
9076: oPushResult
9077: oGetLocal 2
9079: oPushResult
9080: oLoopPush
9081: oPop 2
9083: oCall 8133
9085: oInputChoice 9116
9087: oCall 8133
9089: oJumpForward 9122
9091: oGetAddrLocal 3
9093: oPushResult
9094: oCall 4636
9096: oPop 1
9098: oEmit 78
9100: oGetLocal 3
9102: oPushResult
9103: oEmitLabel
9104: oPop 1
9106: oGetLocal 1
9108: oPushResult
9109: oEmitLabel
9110: oPop 1
9112: oJumpForward 9124
9114: oJumpForward 9122
9116: Choice Lookup Table
          50   9091
           5   9087
9121: oEndChoice
9122: oJumpBack 9085
9124: oEmit 77
9126: oGetLocal 2
9128: oPushResult
9129: oEmitLabel
9130: oPop 1
9132: oLoopPop
9133: oReturn
9134: oLocalSpace 2
9136: oGetAddrLocal 1
9138: oPushResult
9139: oLabelNew
9140: oAssign
9141: oEmit 77
9143: oGetLocal 1
9145: oPushResult
9146: oEmitLabel
9147: oPop 1
9149: oGetAddrLocal 2
9151: oPushResult
9152: oCall 4636
9154: oPop 1
9156: oGetLocal 1
9158: oPushResult
9159: oGetLocal 2
9161: oPushResult
9162: oLoopPush
9163: oPop 2
9165: oInput 47
9167: oCall 8133
9169: oEmit 68
9171: oGetLocal 1
9173: oPushResult
9174: oEmitLabel
9175: oPop 1
9177: oEmit 77
9179: oGetLocal 2
9181: oPushResult
9182: oEmitLabel
9183: oPop 1
9185: oLoopPop
9186: oReturn
9187: oLocalSpace 0
9189: oLoopContinueLabel
9190: oPushResult
9191: oSetResult 0
9193: oPushResult
9194: equal_label
9195: oPop 2
9197: oChoice 9212
9199: oError 18
9201: oJumpForward 9218
9203: oEmit 68
9205: oLoopContinueLabel
9206: oPushResult
9207: oEmitLabel
9208: oPop 1
9210: oJumpForward 9218
9212: Choice Lookup Table
           0   9203
           1   9199
9217: oEndChoice
9218: oReturn
9219: oLocalSpace 0
9221: oLoopBreakLabel
9222: oPushResult
9223: oSetResult 0
9225: oPushResult
9226: equal_label
9227: oPop 2
9229: oChoice 9244
9231: oError 18
9233: oJumpForward 9250
9235: oEmit 68
9237: oLoopBreakLabel
9238: oPushResult
9239: oEmitLabel
9240: oPop 1
9242: oJumpForward 9250
9244: Choice Lookup Table
           0   9235
           1   9231
9249: oEndChoice
9250: oReturn
9251: oLocalSpace 8
9253: oGetAddrLocal 1
9255: oPushResult
9256: oCodeNew
9257: oAssign
9258: oGetAddrLocal 2
9260: oPushResult
9261: oLabelNew
9262: oAssign
9263: oGetAddrLocal 3
9265: oPushResult
9266: oLabelNew
9267: oAssign
9268: oGetAddrLocal 4
9270: oPushResult
9271: oGetLocal 3
9273: oAssign
9274: oGetAddrLocal 5
9276: oPushResult
9277: oSetResult 0
9279: oAssign
9280: oCall 4613
9282: oTypeSNodeType
9283: oChoice 9321
9285: oEmit 71
9287: oGetLocal 2
9289: oPushResult
9290: oEmitLabel
9291: oPop 1
9293: oJumpForward 9338
9295: oEmit 72
9297: oGetLocal 2
9299: oPushResult
9300: oEmitLabel
9301: oPop 1
9303: oJumpForward 9338
9305: oGetAddrLocal 5
9307: oPushResult
9308: oSetResult 1
9310: oAssign
9311: oEmit 73
9313: oGetLocal 2
9315: oPushResult
9316: oEmitLabel
9317: oPop 1
9319: oJumpForward 9338
9321: Choice Lookup Table
          39   9305
          40   9305
          41   9295
          29   9295
          33   9285
          30   9285
          31   9285
9336: oError 17
9338: oInput 40
9340: oInputChoice 9387
9342: oGetAddrLocal 4
9344: oPushResult
9345: oLabelNew
9346: oAssign
9347: oEmit 77
9349: oGetLocal 4
9351: oPushResult
9352: oEmitLabel
9353: oPop 1
9355: oInputChoice 9361
9357: oJumpForward 9379
9359: oJumpForward 9377
9361: Choice Lookup Table
          36   9357
9364: oCall 8133
9366: oInputChoice 9370
9368: oJumpForward 9377
9370: Choice Lookup Table
           5   9368
9373: oInput 36
9375: oJumpForward 9379
9377: oJumpBack 9355
9379: oJumpForward 9553
9381: oJumpForward 9551
9383: oJumpForward 9553
9385: oJumpForward 9551
9387: Choice Lookup Table
          36   9383
          43   9342
          54   9342
9394: oGetAddrLocal 6
9396: oPushResult
9397: oLabelNew
9398: oAssign
9399: oGetLocal 1
9401: oPushResult
9402: oCodePush
9403: oPop 1
9405: oCall 3533
9407: oCall 4275
9409: oGetLocal 5
9411: oChoice 9431
9413: oGetAddrLocal 7
9415: oPushResult
9416: oValueTopString
9417: oPushResult
9418: oStringAllocShortStringLit
9419: oPop 1
9421: oAssign
9422: oJumpForward 9437
9424: oGetAddrLocal 7
9426: oPushResult
9427: oValueTop
9428: oAssign
9429: oJumpForward 9437
9431: Choice Lookup Table
           0   9424
           1   9413
9436: oEndChoice
9437: oValuePop
9438: oInputChoice 9495
9440: oCall 3533
9442: oCall 4275
9444: oGetLocal 5
9446: oChoice 9466
9448: oGetAddrLocal 8
9450: oPushResult
9451: oValueTopString
9452: oPushResult
9453: oStringAllocShortStringLit
9454: oPop 1
9456: oAssign
9457: oJumpForward 9472
9459: oGetAddrLocal 8
9461: oPushResult
9462: oValueTop
9463: oAssign
9464: oJumpForward 9472
9466: Choice Lookup Table
           0   9459
           1   9448
9471: oEndChoice
9472: oValuePop
9473: oEmit 75
9475: oGetLocal 7
9477: oPushResult
9478: oEmitInt
9479: oPop 1
9481: oGetLocal 8
9483: oPushResult
9484: oEmitInt
9485: oPop 1
9487: oGetLocal 6
9489: oPushResult
9490: oEmitLabel
9491: oPop 1
9493: oJumpForward 9512
9495: Choice Lookup Table
          21   9440
9498: oEmit 74
9500: oGetLocal 7
9502: oPushResult
9503: oEmitInt
9504: oPop 1
9506: oGetLocal 6
9508: oPushResult
9509: oEmitLabel
9510: oPop 1
9512: oInputChoice 9516
9514: oJumpForward 9521
9516: Choice Lookup Table
          13   9514
9519: oJumpForward 9523
9521: oJumpBack 9405
9523: oCodePop
9524: oInput 12
9526: oEmit 77
9528: oGetLocal 6
9530: oPushResult
9531: oEmitLabel
9532: oPop 1
9534: oCall 8133
9536: oEmit 68
9538: oGetLocal 3
9540: oPushResult
9541: oEmitLabel
9542: oPop 1
9544: oInputChoice 9548
9546: oJumpForward 9551
9548: Choice Lookup Table
           5   9546
9551: oJumpBack 9340
9553: oEmit 77
9555: oGetLocal 2
9557: oPushResult
9558: oEmitLabel
9559: oPop 1
9561: oGetLocal 1
9563: oPushResult
9564: oEmitCode
9565: oPop 1
9567: oEmit 76
9569: oGetLocal 4
9571: oPushResult
9572: oEmitLabel
9573: oPop 1
9575: oEmit 77
9577: oGetLocal 3
9579: oPushResult
9580: oEmitLabel
9581: oPop 1
9583: oTypeSPop
9584: oReturn
9585: oLocalSpace 1
9587: oInputChoice 9594
9589: oJumpForward 9600
9591: oChangeIntLitToLabelIdent
9592: oJumpForward 9600
9594: Choice Lookup Table
           1   9591
           0   9589
9599: oEndChoice
9600: oGetAddrLocal 1
9602: oPushResult
9603: oScopeCurrent
9604: oPushResult
9605: oScopeFindRequireInScope
9606: oPop 1
9608: oAssign
9609: oGetLocal 1
9611: oPushResult
9612: oSetResult 28
9614: oPushResult
9615: oSetResult 1
9617: oPushResult
9618: oNodeSetBoolean
9619: oPop 3
9621: oEmit 68
9623: oGetLocal 1
9625: oPushResult
9626: oSetResult 22
9628: oPushResult
9629: oNodeGetLabel
9630: oPop 2
9632: oPushResult
9633: oEmitLabel
9634: oPop 1
9636: oReturn
9637: oLocalSpace 0
9639: oCall 8133
9641: oInputChoice 9651
9643: oCall 8133
9645: oJumpForward 9657
9647: oJumpForward 9659
9649: oJumpForward 9657
9651: Choice Lookup Table
          36   9647
           5   9643
9656: oEndChoice
9657: oJumpBack 9641
9659: oReturn
9660: oLocalSpace 0
9662: oCall 9667
9664: oEmit 87
9666: oReturn
9667: oLocalSpace 0
9669: oInputChoice 9787
9671: oCall 4613
9673: oTypeSNodeType
9674: oChoice 9745
9676: oEmit 80
9678: oJumpForward 9768
9680: oEmit 81
9682: oJumpForward 9768
9684: oEmit 30
9686: oEmit 80
9688: oJumpForward 9768
9690: oEmit 82
9692: oJumpForward 9768
9694: oEmit 83
9696: oJumpForward 9768
9698: oError 16
9700: oJumpForward 9768
9702: oEmit 16
9704: oTypeSTop
9705: oPushResult
9706: oSetResult 43
9708: oPushResult
9709: oNodeGetInt
9710: oPop 2
9712: oPushResult
9713: oEmitInt
9714: oPop 1
9716: oEmit 86
9718: oJumpForward 9768
9720: oTypeSTop
9721: oPushResult
9722: oGetGlobal 10
9724: oPushResult
9725: equal_node
9726: oPop 2
9728: oChoice 9734
9730: oEmit 84
9732: oJumpForward 9739
9734: Choice Lookup Table
           1   9730
9737: oEmit 85
9739: oJumpForward 9768
9741: oEmit 85
9743: oJumpForward 9768
9745: Choice Lookup Table
          35   9741
          34   9720
          41   9702
          28   9698
          39   9694
          40   9694
          33   9690
          30   9684
          31   9680
          29   9676
9766: oError 17
9768: oTypeSPop
9769: oInputChoice 9777
9771: oJumpForward 9785
9773: oJumpForward 9783
9775: oJumpForward 9783
9777: Choice Lookup Table
          13   9775
          15   9771
9782: oEndChoice
9783: oJumpBack 9671
9785: oJumpForward 9790
9787: Choice Lookup Table
          14   9671
9790: oReturn
9791: oLocalSpace 0
9793: oReturn
9794: oLocalSpace 0
9796: oReturn
9797: oLocalSpace 1
9799: oGetAddrLocal 1
9801: oPushResult
9802: oGetGlobal 14
9804: oPushResult
9805: oScopeAllocType
9806: oPop 1
9808: oAssign
9809: oTypeSNodeType
9810: oChoice 9878
9812: oEmit 17
9814: oGetLocal 1
9816: oPushResult
9817: oEmitInt
9818: oPop 1
9820: oEmit 22
9822: oEmit 29
9824: oGetGlobal 14
9826: oPushResult
9827: oSetResult 17
9829: oPushResult
9830: oNodeGetInt
9831: oPop 2
9833: oPushResult
9834: oEmitInt
9835: oPop 1
9837: oJumpForward 9887
9839: oEmit 17
9841: oGetLocal 1
9843: oPushResult
9844: oEmitInt
9845: oPop 1
9847: oEmit 15
9849: oSetResult 1
9851: oPushResult
9852: oEmitInt
9853: oPop 1
9855: oEmit 27
9857: oEmit 17
9859: oGetLocal 1
9861: oPushResult
9862: oSetResult 1
9864: oPushResult
9865: add
9866: oPop 2
9868: oPushResult
9869: oEmitInt
9870: oPop 1
9872: oEmit 22
9874: oEmit 27
9876: oJumpForward 9887
9878: Choice Lookup Table
          33   9839
          39   9812
          40   9812
9885: oError 14
9887: oTypeSPop
9888: oEmit 17
9890: oGetLocal 1
9892: oPushResult
9893: oEmitInt
9894: oPop 1
9896: oGetGlobal 14
9898: oPushResult
9899: oTypeSPush
9900: oPop 1
9902: oGetLocal 1
9904: oReturn
9905: oReturn
9906: oLocalSpace 0
9908: oEmit 61
9910: oSetResult 16
9912: oPushResult
9913: oEmitInt
9914: oPop 1
9916: oEmit 19
9918: oSetResult 8
9920: oPushResult
9921: oEmitInt
9922: oPop 1
9924: oEmit 22
9926: oEmit 28
9928: oEmit 19
9930: oSetResult 0
9932: oPushResult
9933: oEmitInt
9934: oPop 1
9936: oEmit 22
9938: oEmit 28
9940: oEmit 64
9942: oGetGlobal 19
9944: oPushResult
9945: oCall 13074
9947: oPop 1
9949: oEmit 63
9951: oSetResult 16
9953: oPushResult
9954: oEmitInt
9955: oPop 1
9957: oTypeSPop
9958: oTypeSPop
9959: oReturn
9960: oLocalSpace 0
9962: oEmit 61
9964: oSetResult 12
9966: oPushResult
9967: oEmitInt
9968: oPop 1
9970: oEmit 19
9972: oSetResult 8
9974: oPushResult
9975: oEmitInt
9976: oPop 1
9978: oEmit 22
9980: oEmit 27
9982: oEmit 19
9984: oSetResult 0
9986: oPushResult
9987: oEmitInt
9988: oPop 1
9990: oEmit 22
9992: oEmit 28
9994: oEmit 64
9996: oGetGlobal 20
9998: oPushResult
9999: oCall 13074
10001: oPop 1
10003: oEmit 63
10005: oSetResult 12
10007: oPushResult
10008: oEmitInt
10009: oPop 1
10011: oTypeSPop
10012: oTypeSPop
10013: oReturn
10014: oLocalSpace 1
10016: oEmit 62
10018: oSetResult 24
10020: oPushResult
10021: oEmitInt
10022: oPop 1
10024: oEmit 19
10026: oSetResult 8
10028: oPushResult
10029: oEmitInt
10030: oPop 1
10032: oEmit 22
10034: oEmit 28
10036: oEmit 19
10038: oSetResult 0
10040: oPushResult
10041: oEmitInt
10042: oPop 1
10044: oEmit 22
10046: oEmit 28
10048: oGetAddrLocal 1
10050: oPushResult
10051: oGetGlobal 6
10053: oPushResult
10054: oScopeAllocType
10055: oPop 1
10057: oAssign
10058: oEmit 19
10060: oSetResult 16
10062: oPushResult
10063: oEmitInt
10064: oPop 1
10066: oEmit 17
10068: oGetLocal 1
10070: oPushResult
10071: oEmitInt
10072: oPop 1
10074: oEmit 28
10076: oEmit 65
10078: oGetGlobal 21
10080: oPushResult
10081: oCall 13074
10083: oPop 1
10085: oEmit 3
10087: oGetLocal 1
10089: oPushResult
10090: oEmitInt
10091: oPop 1
10093: oEmit 63
10095: oSetResult 24
10097: oPushResult
10098: oEmitInt
10099: oPop 1
10101: oTypeSPop
10102: oGetGlobal 6
10104: oPushResult
10105: oTypeSPush
10106: oPop 1
10108: oReturn
10109: oLocalSpace 10
10111: oGetParam 1
10113: oPushResult
10114: oSetResult 28
10116: oPushResult
10117: oSetResult 1
10119: oPushResult
10120: oNodeSetBoolean
10121: oPop 3
10123: oGetAddrLocal 1
10125: oPushResult
10126: oGetParam 1
10128: oPushResult
10129: oSetResult 27
10131: oPushResult
10132: oNodeGetBoolean
10133: oPop 2
10135: oAssign
10136: oGetAddrLocal 4
10138: oPushResult
10139: oGetParam 1
10141: oPushResult
10142: oNodeType
10143: oPop 1
10145: oPushResult
10146: oSetResult 13
10148: oPushResult
10149: equal_node_type
10150: oPop 2
10152: oAssign
10153: oGetLocal 4
10155: oChoice 10182
10157: oGetAddrLocal 2
10159: oPushResult
10160: oGetParam 1
10162: oPushResult
10163: oSetResult 21
10165: oPushResult
10166: oNodeGet
10167: oPop 2
10169: oAssign
10170: oGetAddrLocal 3
10172: oPushResult
10173: oGetLocal 2
10175: oPushResult
10176: oScopeAllocType
10177: oPop 1
10179: oAssign
10180: oJumpForward 10185
10182: Choice Lookup Table
           1   10157
10185: oGetAddrLocal 5
10187: oPushResult
10188: oGetParam 1
10190: oPushResult
10191: oSetResult 23
10193: oPushResult
10194: oNodeGet
10195: oPop 2
10197: oAssign
10198: oGetAddrLocal 6
10200: oPushResult
10201: oGetLocal 5
10203: oPushResult
10204: oSetResult 17
10206: oPushResult
10207: oNodeGetInt
10208: oPop 2
10210: oAssign
10211: oGetLocal 1
10213: oChoice 10235
10215: oEmit 62
10217: oGetLocal 6
10219: oPushResult
10220: oEmitInt
10221: oPop 1
10223: oJumpForward 10241
10225: oEmit 61
10227: oGetLocal 6
10229: oPushResult
10230: oEmitInt
10231: oPop 1
10233: oJumpForward 10241
10235: Choice Lookup Table
           0   10225
           1   10215
10240: oEndChoice
10241: oGetParam 1
10243: oPushResult
10244: oCall 13008
10246: oPop 1
10248: oPushResult
10249: oSetResult 0
10251: oPushResult
10252: greater
10253: oPop 2
10255: oChoice 10288
10257: oEmit 19
10259: oSetResult 0
10261: oPushResult
10262: oEmitInt
10263: oPop 1
10265: oEmit 20
10267: oGetParam 1
10269: oPushResult
10270: oCall 13028
10272: oPop 1
10274: oPushResult
10275: oEmitInt
10276: oPop 1
10278: oSetResult 0
10280: oPushResult
10281: oEmitInt
10282: oPop 1
10284: oEmit 28
10286: oJumpForward 10291
10288: Choice Lookup Table
           1   10257
10291: oGetAddrLocal 7
10293: oPushResult
10294: oGetLocal 5
10296: oPushResult
10297: oSetResult 15
10299: oPushResult
10300: oNodeGetIter
10301: oPop 2
10303: oAssign
10304: oGetAddrLocal 8
10306: oPushResult
10307: oGetLocal 7
10309: oPushResult
10310: oNodeIterValue
10311: oPop 1
10313: oAssign
10314: oInputChoice 10511
10316: oGetLocal 8
10318: oPushResult
10319: oNodeNull
10320: oPop 1
10322: oChoice 10328
10324: oJumpForward 10507
10326: oJumpForward 10331
10328: Choice Lookup Table
           1   10324
10331: oGetAddrLocal 9
10333: oPushResult
10334: oGetLocal 8
10336: oPushResult
10337: oSetResult 22
10339: oPushResult
10340: oNodeGetInt
10341: oPop 2
10343: oAssign
10344: oEmit 19
10346: oGetLocal 9
10348: oPushResult
10349: oEmitInt
10350: oPop 1
10352: oGetLocal 8
10354: oPushResult
10355: oSetResult 21
10357: oPushResult
10358: oNodeGet
10359: oPop 2
10361: oPushResult
10362: oTypeSPush
10363: oPop 1
10365: oGetLocal 8
10367: oPushResult
10368: oSetResult 34
10370: oPushResult
10371: oNodeGetBoolean
10372: oPop 2
10374: oChoice 10460
10376: oSetResult 1
10378: oPushResult
10379: oCall 8573
10381: oPop 1
10383: oCall 7955
10385: oEmit 28
10387: oJumpForward 10466
10389: oCall 4613
10391: oCall 7803
10393: oTypeSNodeType
10394: oChoice 10434
10396: oEmit 26
10398: oJumpForward 10458
10400: oEmit 27
10402: oJumpForward 10458
10404: oError 16
10406: oJumpForward 10458
10408: oEmit 28
10410: oJumpForward 10458
10412: oGetAddrLocal 10
10414: oPushResult
10415: oTypeSTop
10416: oPushResult
10417: oSetResult 17
10419: oPushResult
10420: oNodeGetInt
10421: oPop 2
10423: oAssign
10424: oEmit 29
10426: oGetLocal 10
10428: oPushResult
10429: oEmitInt
10430: oPop 1
10432: oJumpForward 10458
10434: Choice Lookup Table
          40   10412
          38   10412
          36   10412
          35   10408
          34   10408
          28   10404
          33   10400
          30   10400
          31   10400
          41   10396
          29   10396
10457: oEndChoice
10458: oJumpForward 10466
10460: Choice Lookup Table
           0   10389
           1   10376
10465: oEndChoice
10466: oTypeSPop
10467: oGetAddrLocal 7
10469: oPushResult
10470: oNodeIterNext
10471: oPop 1
10473: oGetAddrLocal 8
10475: oPushResult
10476: oGetLocal 7
10478: oPushResult
10479: oNodeIterValue
10480: oPop 1
10482: oAssign
10483: oGetLocal 8
10485: oPushResult
10486: oNodeNull
10487: oPop 1
10489: oChoice 10497
10491: oJumpForward 10507
10493: oJumpForward 10503
10495: oJumpForward 10503
10497: Choice Lookup Table
           0   10495
           1   10491
10502: oEndChoice
10503: oInput 13
10505: oJumpBack 10316
10507: oInput 15
10509: oJumpForward 10514
10511: Choice Lookup Table
          14   10316
10514: oGetLocal 8
10516: oPushResult
10517: oNodeNull
10518: oPop 1
10520: oChoice 10526
10522: oError 15
10524: oJumpForward 10529
10526: Choice Lookup Table
           0   10522
10529: oGetLocal 4
10531: oChoice 10560
10533: oEmit 19
10535: oGetParam 1
10537: oPushResult
10538: oSetResult 31
10540: oPushResult
10541: oNodeGetInt
10542: oPop 2
10544: oPushResult
10545: oEmitInt
10546: oPop 1
10548: oEmit 17
10550: oGetLocal 3
10552: oPushResult
10553: oEmitInt
10554: oPop 1
10556: oEmit 28
10558: oJumpForward 10563
10560: Choice Lookup Table
           1   10533
10563: oGetLocal 1
10565: oChoice 10589
10567: oEmit 65
10569: oGetParam 1
10571: oPushResult
10572: oCall 13074
10574: oPop 1
10576: oJumpForward 10595
10578: oEmit 64
10580: oGetParam 1
10582: oPushResult
10583: oCall 13074
10585: oPop 1
10587: oJumpForward 10595
10589: Choice Lookup Table
           0   10578
           1   10567
10594: oEndChoice
10595: oGetLocal 4
10597: oChoice 10678
10599: oGetLocal 2
10601: oPushResult
10602: oTypeSPush
10603: oPop 1
10605: oTypeSNodeType
10606: oChoice 10652
10608: oEmit 3
10610: oGetLocal 3
10612: oPushResult
10613: oEmitInt
10614: oPop 1
10616: oJumpForward 10676
10618: oEmit 4
10620: oGetLocal 3
10622: oPushResult
10623: oEmitInt
10624: oPop 1
10626: oJumpForward 10676
10628: oError 16
10630: oJumpForward 10676
10632: oEmit 5
10634: oGetLocal 3
10636: oPushResult
10637: oEmitInt
10638: oPop 1
10640: oJumpForward 10676
10642: oEmit 17
10644: oGetLocal 3
10646: oPushResult
10647: oEmitInt
10648: oPop 1
10650: oJumpForward 10676
10652: Choice Lookup Table
          40   10642
          38   10642
          36   10642
          35   10632
          34   10632
          28   10628
          33   10618
          30   10618
          31   10618
          41   10608
          29   10608
10675: oEndChoice
10676: oJumpForward 10681
10678: Choice Lookup Table
           1   10599
10681: oEmit 63
10683: oGetLocal 6
10685: oPushResult
10686: oEmitInt
10687: oPop 1
10689: oReturn
10690: oLocalSpace 2
10692: oGetAddrLocal 2
10694: oPushResult
10695: oGetParam 1
10697: oPushResult
10698: oSetResult 26
10700: oPushResult
10701: oNodeGetString
10702: oPop 2
10704: oAssign
10705: oGetLocal 2
10707: oPushResult
10708: oSetResult 0
10710: oPushResult
10711: equal_string
10712: oPop 2
10714: oChoice 10751
10716: oGetAddrLocal 1
10718: oPushResult
10719: oGetParam 1
10721: oPushResult
10722: oSetResult 4
10724: oPushResult
10725: oNodeGetInt
10726: oPop 2
10728: oPushResult
10729: ID_STRING
10730: oPop 1
10732: oPushResult
10733: oStringAllocLit
10734: oPop 1
10736: oAssign
10737: oJumpForward 10757
10739: oGetAddrLocal 1
10741: oPushResult
10742: oGetLocal 2
10744: oPushResult
10745: oStringAllocLit
10746: oPop 1
10748: oAssign
10749: oJumpForward 10757
10751: Choice Lookup Table
           0   10739
           1   10716
10756: oEndChoice
10757: oEmit 79
10759: oGetParam 1
10761: oPushResult
10762: oCall 13074
10764: oPop 1
10766: oGetLocal 1
10768: oPushResult
10769: oEmitInt
10770: oPop 1
10772: oReturn
10773: oLocalSpace 0
10775: oGetParam 1
10777: oPushResult
10778: oGetGlobal 15
10780: oPushResult
10781: oNodeEqual
10782: oPop 2
10784: oChoice 10824
10786: oInput 14
10788: oCall 4613
10790: oTypeSNodeType
10791: oChoice 10799
10793: oJumpForward 10812
10795: oEmit 30
10797: oJumpForward 10812
10799: Choice Lookup Table
          33   10795
          30   10795
          31   10795
          41   10793
          29   10793
10810: oError 14
10812: oTypeSPop
10813: oGetGlobal 6
10815: oPushResult
10816: oTypeSPush
10817: oPop 1
10819: oInput 15
10821: oReturn
10822: oJumpForward 10827
10824: Choice Lookup Table
           1   10786
10827: oGetParam 1
10829: oPushResult
10830: oGetGlobal 16
10832: oPushResult
10833: oNodeEqual
10834: oPop 2
10836: oChoice 10870
10838: oInput 14
10840: oCall 4613
10842: oTypeSNodeType
10843: oChoice 10851
10845: oEmit 31
10847: oJumpForward 10858
10849: oJumpForward 10858
10851: Choice Lookup Table
          30   10849
          29   10845
10856: oError 14
10858: oTypeSPop
10859: oGetGlobal 9
10861: oPushResult
10862: oTypeSPush
10863: oPop 1
10865: oInput 15
10867: oReturn
10868: oJumpForward 10873
10870: Choice Lookup Table
           1   10838
10873: oGetParam 1
10875: oPushResult
10876: oGetGlobal 17
10878: oPushResult
10879: oNodeEqual
10880: oPop 2
10882: oChoice 10922
10884: oInput 14
10886: oCall 4613
10888: oTypeSNodeType
10889: oChoice 10910
10891: oTypeSTop
10892: oPushResult
10893: oSetResult 44
10895: oPushResult
10896: oNodeGetBoolean
10897: oPop 2
10899: oChoice 10905
10901: oError 28
10903: oJumpForward 10908
10905: Choice Lookup Table
           1   10901
10908: oJumpForward 10915
10910: Choice Lookup Table
          41   10891
10913: oError 14
10915: oEmit 33
10917: oInput 15
10919: oReturn
10920: oJumpForward 10925
10922: Choice Lookup Table
           1   10884
10925: oGetParam 1
10927: oPushResult
10928: oGetGlobal 18
10930: oPushResult
10931: oNodeEqual
10932: oPop 2
10934: oChoice 10974
10936: oInput 14
10938: oCall 4613
10940: oTypeSNodeType
10941: oChoice 10962
10943: oTypeSTop
10944: oPushResult
10945: oSetResult 44
10947: oPushResult
10948: oNodeGetBoolean
10949: oPop 2
10951: oChoice 10957
10953: oError 28
10955: oJumpForward 10960
10957: Choice Lookup Table
           1   10953
10960: oJumpForward 10967
10962: Choice Lookup Table
          41   10943
10965: oError 14
10967: oEmit 32
10969: oInput 15
10971: oReturn
10972: oJumpForward 10977
10974: Choice Lookup Table
           1   10936
10977: oError 16
10979: oReturn
10980: oLocalSpace 1
10982: oGetAddrLocal 1
10984: oPushResult
10985: oGetParam 2
10987: oPushResult
10988: oNodeNew
10989: oPop 1
10991: oAssign
10992: oGetLocal 1
10994: oPushResult
10995: oSetResult 17
10997: oPushResult
10998: oGetParam 1
11000: oPushResult
11001: oNodeSetInt
11002: oPop 3
11004: oGetLocal 1
11006: oPushResult
11007: oTypeAdd
11008: oPop 1
11010: oGetLocal 1
11012: oReturn
11013: oReturn
11014: oLocalSpace 12
11016: oInputChoice 11499
11018: oGetAddrLocal 1
11020: oPushResult
11021: oScopeFindRequire
11022: oAssign
11023: oGetAddrLocal 1
11025: oPushResult
11026: oCall 244
11028: oPop 1
11030: oGetLocal 1
11032: oPushResult
11033: oNodeType
11034: oPop 1
11036: oChoice 11053
11038: oGetParam 1
11040: oPushResult
11041: oGetLocal 1
11043: oPushResult
11044: oSetResult 21
11046: oPushResult
11047: oNodeGet
11048: oPop 2
11050: oAssign
11051: oJumpForward 11064
11053: Choice Lookup Table
          19   11038
11056: oError 2
11058: oGetParam 1
11060: oPushResult
11061: oGetGlobal 6
11063: oAssign
11064: oJumpForward 11522
11066: oInput 16
11068: oGetAddrLocal 2
11070: oPushResult
11071: oNodeVecNew
11072: oAssign
11073: oGetAddrLocal 3
11075: oPushResult
11076: oSetResult 37
11078: oPushResult
11079: oNodeNew
11080: oPop 1
11082: oAssign
11083: oCall 3533
11085: oGetLocal 3
11087: oPushResult
11088: oSetResult 39
11090: oPushResult
11091: oValueTop
11092: oPushResult
11093: oNodeSetInt
11094: oPop 3
11096: oValuePop
11097: oInput 21
11099: oCall 3533
11101: oGetLocal 3
11103: oPushResult
11104: oSetResult 40
11106: oPushResult
11107: oValueTop
11108: oPushResult
11109: oNodeSetInt
11110: oPop 3
11112: oValuePop
11113: oCall 4178
11115: oGetLocal 3
11117: oPushResult
11118: oSetResult 37
11120: oPushResult
11121: oTypeSTop
11122: oPushResult
11123: oNodeSet
11124: oPop 3
11126: oGetLocal 3
11128: oPushResult
11129: oSetResult 17
11131: oPushResult
11132: oTypeSTop
11133: oPushResult
11134: oSetResult 17
11136: oPushResult
11137: oNodeGetInt
11138: oPop 2
11140: oPushResult
11141: oNodeSetInt
11142: oPop 3
11144: oTypeSPop
11145: oGetLocal 3
11147: oPushResult
11148: oTypeAdd
11149: oPop 1
11151: oGetAddrLocal 4
11153: oPushResult
11154: oSetResult 36
11156: oPushResult
11157: oNodeNew
11158: oPop 1
11160: oAssign
11161: oGetLocal 4
11163: oPushResult
11164: oSetResult 38
11166: oPushResult
11167: oGetLocal 3
11169: oPushResult
11170: oNodeSet
11171: oPop 3
11173: oGetLocal 2
11175: oPushResult
11176: oGetLocal 4
11178: oPushResult
11179: oNodeVecAppend
11180: oPop 2
11182: oInputChoice 11190
11184: oJumpForward 11198
11186: oJumpForward 11196
11188: oJumpForward 11196
11190: Choice Lookup Table
          13   11188
          17   11184
11195: oEndChoice
11196: oJumpBack 11073
11198: oInput 40
11200: oGetAddrLocal 5
11202: oPushResult
11203: oCall 11014
11205: oPop 1
11207: oGetAddrLocal 6
11209: oPushResult
11210: oGetLocal 2
11212: oPushResult
11213: oNodeVecSize
11214: oPop 1
11216: oAssign
11217: oGetAddrLocal 6
11219: oPushResult
11220: dec
11221: oPop 1
11223: oGetAddrLocal 7
11225: oPushResult
11226: oGetLocal 2
11228: oPushResult
11229: oGetLocal 6
11231: oPushResult
11232: oNodeVecElement
11233: oPop 2
11235: oAssign
11236: oGetLocal 7
11238: oPushResult
11239: oSetResult 37
11241: oPushResult
11242: oGetLocal 5
11244: oPushResult
11245: oNodeSet
11246: oPop 3
11248: oGetAddrLocal 8
11250: oPushResult
11251: oGetLocal 7
11253: oPushResult
11254: oSetResult 38
11256: oPushResult
11257: oNodeGet
11258: oPop 2
11260: oAssign
11261: oGetAddrLocal 9
11263: oPushResult
11264: oGetLocal 8
11266: oPushResult
11267: oSetResult 40
11269: oPushResult
11270: oNodeGetInt
11271: oPop 2
11273: oPushResult
11274: oGetLocal 8
11276: oPushResult
11277: oSetResult 39
11279: oPushResult
11280: oNodeGetInt
11281: oPop 2
11283: oPushResult
11284: subtract
11285: oPop 2
11287: oAssign
11288: oGetAddrLocal 9
11290: oPushResult
11291: inc
11292: oPop 1
11294: oGetLocal 7
11296: oPushResult
11297: oSetResult 17
11299: oPushResult
11300: oGetLocal 9
11302: oPushResult
11303: oGetLocal 5
11305: oPushResult
11306: oSetResult 17
11308: oPushResult
11309: oNodeGetInt
11310: oPop 2
11312: oPushResult
11313: multiply
11314: oPop 2
11316: oPushResult
11317: oNodeSetInt
11318: oPop 3
11320: oGetLocal 7
11322: oPushResult
11323: oTypeAdd
11324: oPop 1
11326: oGetAddrLocal 5
11328: oPushResult
11329: oGetLocal 7
11331: oAssign
11332: oGetLocal 6
11334: oPushResult
11335: equal_zero
11336: oPop 1
11338: oChoice 11344
11340: oJumpForward 11349
11342: oJumpForward 11347
11344: Choice Lookup Table
           1   11340
11347: oJumpBack 11217
11349: oGetParam 1
11351: oPushResult
11352: oGetLocal 2
11354: oPushResult
11355: oSetResult 0
11357: oPushResult
11358: oNodeVecElement
11359: oPop 2
11361: oAssign
11362: oGetLocal 2
11364: oPushResult
11365: oNodeVecDelete
11366: oPop 1
11368: oJumpForward 11522
11370: oGetAddrLocal 10
11372: oPushResult
11373: oCall 11014
11375: oPop 1
11377: oGetParam 1
11379: oPushResult
11380: oGetLocal 10
11382: oPushResult
11383: oCall 12093
11385: oPop 1
11387: oAssign
11388: oJumpForward 11522
11390: oGetParam 1
11392: oPushResult
11393: oSetResult 38
11395: oPushResult
11396: oNodeNew
11397: oPop 1
11399: oAssign
11400: oSetResult -1
11402: oPushResult
11403: oSetResult 2
11405: oPushResult
11406: oScopeBegin
11407: oPop 2
11409: oSetResult 23
11411: oPushResult
11412: oCall 3234
11414: oPop 1
11416: oGetAddrLocal 11
11418: oPushResult
11419: oScopeCurrent
11420: oPushResult
11421: oSetResult 17
11423: oPushResult
11424: oNodeGetInt
11425: oPop 2
11427: oAssign
11428: oGetLocal 11
11430: oPushResult
11431: equal_zero
11432: oPop 1
11434: oChoice 11440
11436: oError 19
11438: oJumpForward 11443
11440: Choice Lookup Table
           1   11436
11443: oInput 36
11445: oGetFromParam 1
11447: oPushResult
11448: oSetResult 41
11450: oPushResult
11451: oScopeCurrent
11452: oPushResult
11453: oNodeSet
11454: oPop 3
11456: oGetFromParam 1
11458: oPushResult
11459: oSetResult 17
11461: oPushResult
11462: oGetLocal 11
11464: oPushResult
11465: oNodeSetInt
11466: oPop 3
11468: oScopeEnd
11469: oGetFromParam 1
11471: oPushResult
11472: oTypeAdd
11473: oPop 1
11475: oJumpForward 11522
11477: oGetParam 1
11479: oPushResult
11480: oCall 11523
11482: oPop 1
11484: oJumpForward 11522
11486: oInput 40
11488: oGetAddrLocal 12
11490: oPushResult
11491: oCall 11014
11493: oPop 1
11495: oError 16
11497: oJumpForward 11522
11499: Choice Lookup Table
          39   11486
          14   11477
          38   11390
          18   11370
          37   11066
           0   11018
11512: oCall 3533
11514: oInput 21
11516: oCall 3533
11518: oCall 4178
11520: oError 16
11522: oReturn
11523: oLocalSpace 11
11525: oGetParam 1
11527: oPushResult
11528: oSetResult 41
11530: oPushResult
11531: oNodeNew
11532: oPop 1
11534: oAssign
11535: oGetAddrLocal 1
11537: oPushResult
11538: oSetResult 0
11540: oAssign
11541: oGetAddrLocal 2
11543: oPushResult
11544: oSetResult 0
11546: oAssign
11547: oGetAddrLocal 3
11549: oPushResult
11550: oSetResult 1
11552: oAssign
11553: oGetAddrLocal 4
11555: oPushResult
11556: oScopeCurrent
11557: oAssign
11558: oSetResult -1
11560: oPushResult
11561: oSetResult 2
11563: oPushResult
11564: oScopeBegin
11565: oPop 2
11567: oInput 0
11569: oGetAddrLocal 5
11571: oPushResult
11572: oSetResult 17
11574: oPushResult
11575: LAST_ID
11576: oPushResult
11577: oCall 13046
11579: oPop 2
11581: oAssign
11582: oGetAddrLocal 6
11584: oPushResult
11585: oSetResult 17
11587: oPushResult
11588: LAST_ID
11589: oPushResult
11590: oCall 13046
11592: oPop 2
11594: oAssign
11595: oGetLocal 5
11597: oPushResult
11598: oSetResult 21
11600: oPushResult
11601: oGetFromParam 1
11603: oPushResult
11604: oNodeSet
11605: oPop 3
11607: oGetLocal 6
11609: oPushResult
11610: oSetResult 21
11612: oPushResult
11613: oGetFromParam 1
11615: oPushResult
11616: oNodeSet
11617: oPop 3
11619: oGetAddrLocal 7
11621: oPushResult
11622: LAST_ID
11623: oPushResult
11624: ID_STRING
11625: oPop 1
11627: oPushResult
11628: oStringAllocLit
11629: oPop 1
11631: oAssign
11632: oGetLocal 5
11634: oPushResult
11635: oSetResult 32
11637: oPushResult
11638: oGetLocal 7
11640: oPushResult
11641: oNodeSetInt
11642: oPop 3
11644: oGetLocal 6
11646: oPushResult
11647: oSetResult 32
11649: oPushResult
11650: oGetLocal 7
11652: oPushResult
11653: oNodeSetInt
11654: oPop 3
11656: oInputChoice 11734
11658: oGetGlobal 6
11660: oPushResult
11661: oTypeSPush
11662: oPop 1
11664: oCall 3533
11666: oCall 4275
11668: oTypeSPop
11669: oGetLocal 2
11671: oPushResult
11672: equal_zero
11673: oPop 1
11675: oChoice 11696
11677: oValueTop
11678: oPushResult
11679: oGetLocal 1
11681: oPushResult
11682: greater
11683: oPop 2
11685: oChoice 11691
11687: oError 26
11689: oJumpForward 11694
11691: Choice Lookup Table
           0   11687
11694: oJumpForward 11699
11696: Choice Lookup Table
           0   11677
11699: oGetLocal 1
11701: oPushResult
11702: oValueTop
11703: oPushResult
11704: equal
11705: oPop 2
11707: oChoice 11723
11709: oGetFromParam 1
11711: oPushResult
11712: oSetResult 44
11714: oPushResult
11715: oSetResult 1
11717: oPushResult
11718: oNodeSetBoolean
11719: oPop 3
11721: oJumpForward 11726
11723: Choice Lookup Table
           0   11709
11726: oGetAddrLocal 1
11728: oPushResult
11729: oValueTop
11730: oAssign
11731: oValuePop
11732: oJumpForward 11739
11734: Choice Lookup Table
           4   11658
           6   11658
11739: oGetLocal 5
11741: oPushResult
11742: oSetResult 22
11744: oPushResult
11745: oGetLocal 1
11747: oPushResult
11748: oNodeSetInt
11749: oPop 3
11751: oGetLocal 6
11753: oPushResult
11754: oSetResult 22
11756: oPushResult
11757: oGetLocal 1
11759: oPushResult
11760: oNodeSetInt
11761: oPop 3
11763: oGetLocal 5
11765: oPushResult
11766: oScopeDeclare
11767: oPop 1
11769: oGetLocal 4
11771: oPushResult
11772: oScopeEnter
11773: oPop 1
11775: oGetLocal 6
11777: oPushResult
11778: oScopeDeclare
11779: oPop 1
11781: oScopeEnd
11782: oGetAddrLocal 1
11784: oPushResult
11785: inc
11786: oPop 1
11788: oGetAddrLocal 2
11790: oPushResult
11791: inc
11792: oPop 1
11794: oInputChoice 11798
11796: oJumpForward 11803
11798: Choice Lookup Table
          13   11796
11801: oJumpForward 11805
11803: oJumpBack 11567
11805: oInput 15
11807: oGetFromParam 1
11809: oPushResult
11810: oSetResult 41
11812: oPushResult
11813: oScopeCurrent
11814: oPushResult
11815: oNodeSet
11816: oPop 3
11818: oGetFromParam 1
11820: oPushResult
11821: oSetResult 17
11823: oPushResult
11824: oSetResult 4
11826: oPushResult
11827: oNodeSetInt
11828: oPop 3
11830: oScopeEnd
11831: oGetGlobal 2
11833: oPushResult
11834: oCall 12944
11836: oPop 1
11838: oPushResult
11839: oCodePush
11840: oPop 1
11842: oGetGlobal 2
11844: oPushResult
11845: oScopeEnter
11846: oPop 1
11848: oGetAddrLocal 8
11850: oPushResult
11851: oGetLocal 2
11853: oPushResult
11854: oSetResult 1
11856: oPushResult
11857: add
11858: oPop 2
11860: oPushResult
11861: oSetResult 16
11863: oPushResult
11864: multiply
11865: oPop 2
11867: oAssign
11868: oGetAddrLocal 9
11870: oPushResult
11871: oGetLocal 8
11873: oPushResult
11874: oSetResult 8
11876: oPushResult
11877: oScopeAlloc
11878: oPop 2
11880: oAssign
11881: oScopeEnd
11882: oGetFromParam 1
11884: oPushResult
11885: oSetResult 43
11887: oPushResult
11888: oGetLocal 9
11890: oPushResult
11891: oNodeSetInt
11892: oPop 3
11894: oGetAddrLocal 10
11896: oPushResult
11897: oGetFromParam 1
11899: oPushResult
11900: oSetResult 41
11902: oPushResult
11903: oNodeGet
11904: oPop 2
11906: oPushResult
11907: oSetResult 15
11909: oPushResult
11910: oNodeGetIter
11911: oPop 2
11913: oAssign
11914: oGetAddrLocal 11
11916: oPushResult
11917: oGetLocal 10
11919: oPushResult
11920: oNodeIterValue
11921: oPop 1
11923: oAssign
11924: oGetLocal 11
11926: oPushResult
11927: oNodeNull
11928: oPop 1
11930: oChoice 11936
11932: oJumpForward 12023
11934: oJumpForward 11939
11936: Choice Lookup Table
           1   11932
11939: oEmit 16
11941: oGetLocal 9
11943: oPushResult
11944: oEmitInt
11945: oPop 1
11947: oEmit 15
11949: oGetLocal 11
11951: oPushResult
11952: oSetResult 22
11954: oPushResult
11955: oNodeGetInt
11956: oPop 2
11958: oPushResult
11959: oEmitInt
11960: oPop 1
11962: oEmit 26
11964: oGetAddrLocal 9
11966: oPushResult
11967: oGetLocal 9
11969: oPushResult
11970: oSetResult 8
11972: oPushResult
11973: add
11974: oPop 2
11976: oAssign
11977: oEmit 16
11979: oGetLocal 9
11981: oPushResult
11982: oEmitInt
11983: oPop 1
11985: oEmit 16
11987: oGetLocal 11
11989: oPushResult
11990: oSetResult 32
11992: oPushResult
11993: oNodeGetInt
11994: oPop 2
11996: oPushResult
11997: oEmitInt
11998: oPop 1
12000: oEmit 28
12002: oGetAddrLocal 9
12004: oPushResult
12005: oGetLocal 9
12007: oPushResult
12008: oSetResult 8
12010: oPushResult
12011: add
12012: oPop 2
12014: oAssign
12015: oGetAddrLocal 10
12017: oPushResult
12018: oNodeIterNext
12019: oPop 1
12021: oJumpBack 11914
12023: oEmit 16
12025: oGetLocal 9
12027: oPushResult
12028: oEmitInt
12029: oPop 1
12031: oEmit 15
12033: oSetResult 0
12035: oPushResult
12036: oEmitInt
12037: oPop 1
12039: oEmit 26
12041: oGetAddrLocal 9
12043: oPushResult
12044: oGetLocal 9
12046: oPushResult
12047: oSetResult 8
12049: oPushResult
12050: add
12051: oPop 2
12053: oAssign
12054: oEmit 16
12056: oGetLocal 9
12058: oPushResult
12059: oEmitInt
12060: oPop 1
12062: oEmit 15
12064: oSetResult 0
12066: oPushResult
12067: oEmitInt
12068: oPop 1
12070: oEmit 28
12072: oGetAddrLocal 9
12074: oPushResult
12075: oGetLocal 9
12077: oPushResult
12078: oSetResult 8
12080: oPushResult
12081: add
12082: oPop 2
12084: oAssign
12085: oCodePop
12086: oGetFromParam 1
12088: oPushResult
12089: oTypeAdd
12090: oPop 1
12092: oReturn
12093: oLocalSpace 1
12095: oGetAddrLocal 1
12097: oPushResult
12098: oGetParam 1
12100: oPushResult
12101: oSetResult 36
12103: oPushResult
12104: oNodeGet
12105: oPop 2
12107: oAssign
12108: oGetLocal 1
12110: oPushResult
12111: oNodeNull
12112: oPop 1
12114: oChoice 12170
12116: oGetAddrLocal 1
12118: oPushResult
12119: oSetResult 34
12121: oPushResult
12122: oNodeNew
12123: oPop 1
12125: oAssign
12126: oGetLocal 1
12128: oPushResult
12129: oSetResult 37
12131: oPushResult
12132: oGetParam 1
12134: oPushResult
12135: oNodeSet
12136: oPop 3
12138: oGetLocal 1
12140: oPushResult
12141: oSetResult 17
12143: oPushResult
12144: oSetResult 8
12146: oPushResult
12147: oNodeSetInt
12148: oPop 3
12150: oGetLocal 1
12152: oPushResult
12153: oTypeAdd
12154: oPop 1
12156: oGetParam 1
12158: oPushResult
12159: oSetResult 36
12161: oPushResult
12162: oGetLocal 1
12164: oPushResult
12165: oNodeSet
12166: oPop 3
12168: oJumpForward 12173
12170: Choice Lookup Table
           1   12116
12173: oGetLocal 1
12175: oReturn
12176: oReturn
12177: oLocalSpace 2
12179: oGetParam 1
12181: oPushResult
12182: oNodeType
12183: oPop 1
12185: oChoice 12255
12187: oMININT
12188: oReturn
12189: oJumpForward 12271
12191: oSetResult 0
12193: oReturn
12194: oJumpForward 12271
12196: oSetResult 0
12198: oReturn
12199: oJumpForward 12271
12201: oGetAddrLocal 1
12203: oPushResult
12204: oGetParam 1
12206: oPushResult
12207: oSetResult 41
12209: oPushResult
12210: oNodeGet
12211: oPop 2
12213: oAssign
12214: oGetAddrLocal 2
12216: oPushResult
12217: oGetLocal 1
12219: oPushResult
12220: oSetResult 15
12222: oPushResult
12223: oNodeGetIter
12224: oPop 2
12226: oPushResult
12227: oNodeIterValue
12228: oPop 1
12230: oAssign
12231: oGetLocal 2
12233: oPushResult
12234: oSetResult 22
12236: oPushResult
12237: oNodeGetInt
12238: oPop 2
12240: oReturn
12241: oJumpForward 12271
12243: oGetParam 1
12245: oPushResult
12246: oSetResult 39
12248: oPushResult
12249: oNodeGetInt
12250: oPop 2
12252: oReturn
12253: oJumpForward 12271
12255: Choice Lookup Table
          37   12243
          41   12201
          33   12196
          31   12191
          29   12187
12266: oError 3
12268: oSetResult 0
12270: oReturn
12271: oReturn
12272: oLocalSpace 2
12274: oGetParam 1
12276: oPushResult
12277: oNodeType
12278: oPop 1
12280: oChoice 12350
12282: oMAXINT
12283: oReturn
12284: oJumpForward 12366
12286: oSetResult 1
12288: oReturn
12289: oJumpForward 12366
12291: oSetResult 255
12293: oReturn
12294: oJumpForward 12366
12296: oGetAddrLocal 1
12298: oPushResult
12299: oGetParam 1
12301: oPushResult
12302: oSetResult 41
12304: oPushResult
12305: oNodeGet
12306: oPop 2
12308: oAssign
12309: oGetAddrLocal 2
12311: oPushResult
12312: oGetLocal 1
12314: oPushResult
12315: oSetResult 15
12317: oPushResult
12318: oNodeGetIterLast
12319: oPop 2
12321: oPushResult
12322: oNodeIterValue
12323: oPop 1
12325: oAssign
12326: oGetLocal 2
12328: oPushResult
12329: oSetResult 22
12331: oPushResult
12332: oNodeGetInt
12333: oPop 2
12335: oReturn
12336: oJumpForward 12366
12338: oGetParam 1
12340: oPushResult
12341: oSetResult 40
12343: oPushResult
12344: oNodeGetInt
12345: oPop 2
12347: oReturn
12348: oJumpForward 12366
12350: Choice Lookup Table
          37   12338
          41   12296
          33   12291
          31   12286
          29   12282
12361: oError 3
12363: oSetResult 0
12365: oReturn
12366: oReturn
12367: oLocalSpace 5
12369: oGetAddrGlobal 1
12371: oPushResult
12372: oWorkspaceNew
12373: oAssign
12374: oSetResult 0
12376: oPushResult
12377: oSetResult 0
12379: oPushResult
12380: oScopeBegin
12381: oPop 2
12383: oGetAddrLocal 2
12385: oPushResult
12386: oScopeCurrent
12387: oAssign
12388: oCall 13116
12390: oEmit 67
12392: oSetResult 0
12394: oPushResult
12395: oEmitInt
12396: oPop 1
12398: oGetAddrLocal 3
12400: oPushResult
12401: oLabelNew
12402: oAssign
12403: oEmit 61
12405: oSetResult 0
12407: oPushResult
12408: oEmitInt
12409: oPop 1
12411: oEmit 64
12413: oGetLocal 3
12415: oPushResult
12416: oEmitLabel
12417: oPop 1
12419: oEmit 63
12421: oSetResult 0
12423: oPushResult
12424: oEmitInt
12425: oPop 1
12427: oEmit 66
12429: oInput 28
12431: oInput 0
12433: oGetAddrLocal 4
12435: oPushResult
12436: oSetResult 4
12438: oPushResult
12439: oNodeNew
12440: oPop 1
12442: oAssign
12443: oGetLocal 4
12445: oPushResult
12446: oSetResult 4
12448: oPushResult
12449: LAST_ID
12450: oPushResult
12451: oNodeSetInt
12452: oPop 3
12454: oGetGlobal 1
12456: oPushResult
12457: oSetResult 2
12459: oPushResult
12460: oGetLocal 4
12462: oPushResult
12463: oNodeSet
12464: oPop 3
12466: oInputChoice 12540
12468: oInput 0
12470: oGetAddrLocal 1
12472: oPushResult
12473: oSetResult 20
12475: oPushResult
12476: LAST_ID
12477: oPushResult
12478: oCall 13046
12480: oPop 2
12482: oAssign
12483: oGetLocal 1
12485: oPushResult
12486: oSetResult 21
12488: oPushResult
12489: oGetGlobal 5
12491: oPushResult
12492: oNodeSet
12493: oPop 3
12495: oGetLocal 1
12497: oPushResult
12498: oScopeDeclareAlloc
12499: oPop 1
12501: oInput 13
12503: oInput 0
12505: oGetAddrLocal 1
12507: oPushResult
12508: oSetResult 20
12510: oPushResult
12511: LAST_ID
12512: oPushResult
12513: oCall 13046
12515: oPop 2
12517: oAssign
12518: oGetLocal 1
12520: oPushResult
12521: oSetResult 21
12523: oPushResult
12524: oGetGlobal 5
12526: oPushResult
12527: oNodeSet
12528: oPop 3
12530: oGetLocal 1
12532: oPushResult
12533: oScopeDeclareAlloc
12534: oPop 1
12536: oInput 15
12538: oJumpForward 12543
12540: Choice Lookup Table
          14   12468
12543: oInput 5
12545: oGetLocal 4
12547: oPushResult
12548: oCall 34
12550: oPop 1
12552: oInputChoice 12563
12554: oGetLocal 4
12556: oPushResult
12557: oCall 7
12559: oPop 1
12561: oJumpForward 12566
12563: Choice Lookup Table
          59   12554
12566: oGetLocal 4
12568: oPushResult
12569: oCall 287
12571: oPop 1
12573: oSetResult 0
12575: oPushResult
12576: oSetResult 0
12578: oPushResult
12579: oScopeBegin
12580: oPop 2
12582: oGetAddrGlobal 2
12584: oPushResult
12585: oScopeCurrent
12586: oAssign
12587: oSetResult 0
12589: oPushResult
12590: oSetResult 1
12592: oPushResult
12593: oScopeBegin
12594: oPop 2
12596: oScopeCurrent
12597: oPushResult
12598: oSetResult 16
12600: oPushResult
12601: oGetGlobal 2
12603: oPushResult
12604: oNodeSet
12605: oPop 3
12607: oGetAddrGlobal 3
12609: oPushResult
12610: oScopeCurrent
12611: oAssign
12612: oGetLocal 4
12614: oPushResult
12615: oSetResult 7
12617: oPushResult
12618: oGetGlobal 3
12620: oPushResult
12621: oNodeSet
12622: oPop 3
12624: oScopeEnd
12625: oSetResult 21
12627: oPushResult
12628: oCall 12695
12630: oPop 1
12632: oGetGlobal 3
12634: oPushResult
12635: oScopeEnter
12636: oPop 1
12638: oGetAddrLocal 5
12640: oPushResult
12641: oSetResult 1
12643: oAssign
12644: oGetLocal 3
12646: oPushResult
12647: oGetGlobal 2
12649: oPushResult
12650: oGetLocal 5
12652: oPushResult
12653: oCall 12846
12655: oPop 3
12657: oScopeEnd
12658: oInput 20
12660: oCall 12751
12662: oScopeEnd
12663: oGetLocal 4
12665: oPushResult
12666: oCall 349
12668: oPop 1
12670: oReturn
12671: oLocalSpace 0
12673: oGetParam 2
12675: oPushResult
12676: oCall 12695
12678: oPop 1
12680: oGetParam 1
12682: oPushResult
12683: oScopeCurrent
12684: oPushResult
12685: oSetResult 0
12687: oPushResult
12688: oCall 12846
12690: oPop 3
12692: oCall 12751
12694: oReturn
12695: oLocalSpace 0
12697: oInputChoice 12728
12699: oCall 2520
12701: oJumpForward 12743
12703: oCall 3178
12705: oJumpForward 12743
12707: oGetParam 1
12709: oPushResult
12710: oCall 3234
12712: oPop 1
12714: oJumpForward 12743
12716: oCall 3468
12718: oJumpForward 12743
12720: oCall 1743
12722: oJumpForward 12743
12724: oCall 2178
12726: oJumpForward 12743
12728: Choice Lookup Table
          30   12724
          29   12720
          34   12716
          33   12707
          32   12703
          31   12699
12741: oJumpForward 12745
12743: oJumpBack 12697
12745: oCall 12748
12747: oReturn
12748: oLocalSpace 0
12750: oReturn
12751: oLocalSpace 2
12753: oGetAddrLocal 1
12755: oPushResult
12756: oScopeCurrent
12757: oPushResult
12758: oSetResult 15
12760: oPushResult
12761: oNodeGetIter
12762: oPop 2
12764: oAssign
12765: oGetAddrLocal 2
12767: oPushResult
12768: oGetLocal 1
12770: oPushResult
12771: oNodeIterValue
12772: oPop 1
12774: oAssign
12775: oGetLocal 2
12777: oPushResult
12778: oNodeNull
12779: oPop 1
12781: oChoice 12785
12783: oJumpForward 12790
12785: Choice Lookup Table
           0   12783
12788: oJumpForward 12845
12790: oGetLocal 2
12792: oPushResult
12793: oNodeType
12794: oPop 1
12796: oChoice 12834
12798: oGetLocal 2
12800: oPushResult
12801: oSetResult 35
12803: oPushResult
12804: oNodeGetBoolean
12805: oPop 2
12807: oChoice 12829
12809: oGetLocal 2
12811: oPushResult
12812: oSetResult 28
12814: oPushResult
12815: oNodeGetBoolean
12816: oPop 2
12818: oChoice 12824
12820: oError 27
12822: oJumpForward 12827
12824: Choice Lookup Table
           1   12820
12827: oJumpForward 12832
12829: Choice Lookup Table
           0   12809
12832: oJumpForward 12837
12834: Choice Lookup Table
          26   12798
12837: oGetAddrLocal 1
12839: oPushResult
12840: oNodeIterNext
12841: oPop 1
12843: oJumpBack 12765
12845: oReturn
12846: oLocalSpace 3
12848: oEmit 77
12850: oGetParam 3
12852: oPushResult
12853: oEmitLabel
12854: oPop 1
12856: oEmit 67
12858: oGetAddrLocal 1
12860: oPushResult
12861: Here
12862: oAssign
12863: oEmit 90
12865: oGetParam 1
12867: oChoice 12873
12869: oCall 1220
12871: oJumpForward 12876
12873: Choice Lookup Table
           1   12869
12876: oGetAddrLocal 2
12878: oPushResult
12879: oGetParam 2
12881: oPushResult
12882: oSetResult 19
12884: oPushResult
12885: oNodeGetCode
12886: oPop 2
12888: oAssign
12889: oGetLocal 2
12891: oPushResult
12892: oEmitCode
12893: oPop 1
12895: oGetParam 2
12897: oPushResult
12898: oSetResult 19
12900: oPushResult
12901: oSetResult 0
12903: oPushResult
12904: oNodeSetCode
12905: oPop 3
12907: oCall 8133
12909: oGetParam 1
12911: oChoice 12917
12913: oCall 1305
12915: oJumpForward 12920
12917: Choice Lookup Table
           1   12913
12920: oEmit 66
12922: oGetAddrLocal 3
12924: oPushResult
12925: oScopeCurrent
12926: oPushResult
12927: oSetResult 17
12929: oPushResult
12930: oNodeGetInt
12931: oPop 2
12933: oAssign
12934: oGetLocal 1
12936: oPushResult
12937: oGetLocal 3
12939: oPushResult
12940: oPatch
12941: oPop 2
12943: oReturn
12944: oLocalSpace 1
12946: oGetAddrLocal 1
12948: oPushResult
12949: oGetParam 1
12951: oPushResult
12952: oSetResult 19
12954: oPushResult
12955: oNodeGetCode
12956: oPop 2
12958: oAssign
12959: oGetLocal 1
12961: oPushResult
12962: oSetResult 0
12964: oPushResult
12965: equal_code
12966: oPop 2
12968: oChoice 12989
12970: oGetAddrLocal 1
12972: oPushResult
12973: oCodeNew
12974: oAssign
12975: oGetParam 1
12977: oPushResult
12978: oSetResult 19
12980: oPushResult
12981: oGetLocal 1
12983: oPushResult
12984: oNodeSetCode
12985: oPop 3
12987: oJumpForward 12992
12989: Choice Lookup Table
           1   12970
12992: oGetLocal 1
12994: oReturn
12995: oReturn
12996: oLocalSpace 0
12998: oScopeCurrent
12999: oPushResult
13000: oSetResult 14
13002: oPushResult
13003: oNodeGetInt
13004: oPop 2
13006: oReturn
13007: oReturn
13008: oLocalSpace 0
13010: oGetParam 1
13012: oPushResult
13013: oSetResult 20
13015: oPushResult
13016: oNodeGet
13017: oPop 2
13019: oPushResult
13020: oSetResult 14
13022: oPushResult
13023: oNodeGetInt
13024: oPop 2
13026: oReturn
13027: oReturn
13028: oLocalSpace 0
13030: oCall 12996
13032: oPushResult
13033: oGetParam 1
13035: oPushResult
13036: oCall 13008
13038: oPop 1
13040: oPushResult
13041: subtract
13042: oPop 2
13044: oReturn
13045: oReturn
13046: oLocalSpace 1
13048: oGetAddrLocal 1
13050: oPushResult
13051: oGetParam 2
13053: oPushResult
13054: oNodeNew
13055: oPop 1
13057: oAssign
13058: oGetLocal 1
13060: oPushResult
13061: oSetResult 4
13063: oPushResult
13064: oGetParam 1
13066: oPushResult
13067: oNodeSetInt
13068: oPop 3
13070: oGetLocal 1
13072: oReturn
13073: oReturn
13074: oLocalSpace 0
13076: oGetParam 1
13078: oPushResult
13079: oSetResult 22
13081: oPushResult
13082: oNodeGetInt
13083: oPop 2
13085: oPushResult
13086: oEmitInt
13087: oPop 1
13089: oReturn
13090: oLocalSpace 1
13092: oGetAddrLocal 1
13094: oPushResult
13095: oSetResult 14
13097: oPushResult
13098: oGetParam 1
13100: oPushResult
13101: oCall 13046
13103: oPop 2
13105: oAssign
13106: oGetLocal 1
13108: oPushResult
13109: oScopeDeclare
13110: oPop 1
13112: oGetLocal 1
13114: oReturn
13115: oReturn
13116: oLocalSpace 1
13118: oGetAddrGlobal 4
13120: oPushResult
13121: oId_mysystem
13122: oAssign
13123: oGetAddrGlobal 5
13125: oPushResult
13126: oSetResult 28
13128: oPushResult
13129: oSetResult 4
13131: oPushResult
13132: oCall 10980
13134: oPop 2
13136: oAssign
13137: oGetAddrGlobal 6
13139: oPushResult
13140: oSetResult 29
13142: oPushResult
13143: oSetResult 4
13145: oPushResult
13146: oCall 10980
13148: oPop 2
13150: oAssign
13151: oGetAddrGlobal 7
13153: oPushResult
13154: oSetResult 31
13156: oPushResult
13157: oSetResult 1
13159: oPushResult
13160: oCall 10980
13162: oPop 2
13164: oAssign
13165: oGetAddrGlobal 8
13167: oPushResult
13168: oSetResult 32
13170: oPushResult
13171: oSetResult 1
13173: oPushResult
13174: oCall 10980
13176: oPop 2
13178: oAssign
13179: oGetAddrGlobal 9
13181: oPushResult
13182: oSetResult 33
13184: oPushResult
13185: oSetResult 1
13187: oPushResult
13188: oCall 10980
13190: oPop 2
13192: oAssign
13193: oGetAddrGlobal 10
13195: oPushResult
13196: oGetGlobal 9
13198: oPushResult
13199: oCall 12093
13201: oPop 1
13203: oAssign
13204: oGetAddrGlobal 11
13206: oPushResult
13207: oSetResult 30
13209: oPushResult
13210: oSetResult 1
13212: oPushResult
13213: oCall 10980
13215: oPop 2
13217: oAssign
13218: oGetAddrGlobal 12
13220: oPushResult
13221: oSetResult 35
13223: oPushResult
13224: oSetResult 8
13226: oPushResult
13227: oCall 10980
13229: oPop 2
13231: oAssign
13232: oGetGlobal 12
13234: oPushResult
13235: oSetResult 37
13237: oPushResult
13238: oGetGlobal 11
13240: oPushResult
13241: oNodeSet
13242: oPop 3
13244: oGetAddrGlobal 13
13246: oPushResult
13247: oSetResult 39
13249: oPushResult
13250: oSetResult 256
13252: oPushResult
13253: oCall 10980
13255: oPop 2
13257: oAssign
13258: oGetAddrGlobal 14
13260: oPushResult
13261: oSetResult 40
13263: oPushResult
13264: oSetResult 256
13266: oPushResult
13267: oCall 10980
13269: oPop 2
13271: oAssign
13272: oGetGlobal 14
13274: oPushResult
13275: oSetResult 42
13277: oPushResult
13278: oSetResult 255
13280: oPushResult
13281: oNodeSetInt
13282: oPop 3
13284: oGetAddrLocal 1
13286: oPushResult
13287: oSetResult 19
13289: oPushResult
13290: oId_File
13291: oPushResult
13292: oCall 13046
13294: oPop 2
13296: oAssign
13297: oGetLocal 1
13299: oPushResult
13300: oSetResult 21
13302: oPushResult
13303: oGetGlobal 5
13305: oPushResult
13306: oNodeSet
13307: oPop 3
13309: oGetLocal 1
13311: oPushResult
13312: oScopeDeclare
13313: oPop 1
13315: oGetAddrLocal 1
13317: oPushResult
13318: oSetResult 19
13320: oPushResult
13321: oId_Integer
13322: oPushResult
13323: oCall 13046
13325: oPop 2
13327: oAssign
13328: oGetLocal 1
13330: oPushResult
13331: oSetResult 21
13333: oPushResult
13334: oGetGlobal 6
13336: oPushResult
13337: oNodeSet
13338: oPop 3
13340: oGetLocal 1
13342: oPushResult
13343: oScopeDeclare
13344: oPop 1
13346: oGetAddrLocal 1
13348: oPushResult
13349: oSetResult 19
13351: oPushResult
13352: oId_Boolean
13353: oPushResult
13354: oCall 13046
13356: oPop 2
13358: oAssign
13359: oGetLocal 1
13361: oPushResult
13362: oSetResult 21
13364: oPushResult
13365: oGetGlobal 7
13367: oPushResult
13368: oNodeSet
13369: oPop 3
13371: oGetLocal 1
13373: oPushResult
13374: oScopeDeclare
13375: oPop 1
13377: oGetAddrLocal 1
13379: oPushResult
13380: oSetResult 19
13382: oPushResult
13383: oId_Char
13384: oPushResult
13385: oCall 13046
13387: oPop 2
13389: oAssign
13390: oGetLocal 1
13392: oPushResult
13393: oSetResult 21
13395: oPushResult
13396: oGetGlobal 9
13398: oPushResult
13399: oNodeSet
13400: oPop 3
13402: oGetLocal 1
13404: oPushResult
13405: oScopeDeclare
13406: oPop 1
13408: oGetAddrLocal 1
13410: oPushResult
13411: oSetResult 19
13413: oPushResult
13414: oId_Byte
13415: oPushResult
13416: oCall 13046
13418: oPop 2
13420: oAssign
13421: oGetLocal 1
13423: oPushResult
13424: oSetResult 21
13426: oPushResult
13427: oGetGlobal 11
13429: oPushResult
13430: oNodeSet
13431: oPop 3
13433: oGetLocal 1
13435: oPushResult
13436: oScopeDeclare
13437: oPop 1
13439: oGetAddrLocal 1
13441: oPushResult
13442: oSetResult 19
13444: oPushResult
13445: oId_Pointer
13446: oPushResult
13447: oCall 13046
13449: oPop 2
13451: oAssign
13452: oGetLocal 1
13454: oPushResult
13455: oSetResult 21
13457: oPushResult
13458: oGetGlobal 12
13460: oPushResult
13461: oNodeSet
13462: oPop 3
13464: oGetLocal 1
13466: oPushResult
13467: oScopeDeclare
13468: oPop 1
13470: oGetAddrLocal 1
13472: oPushResult
13473: oSetResult 19
13475: oPushResult
13476: oId_ShortString
13477: oPushResult
13478: oCall 13046
13480: oPop 2
13482: oAssign
13483: oGetLocal 1
13485: oPushResult
13486: oSetResult 21
13488: oPushResult
13489: oGetGlobal 14
13491: oPushResult
13492: oNodeSet
13493: oPop 3
13495: oGetLocal 1
13497: oPushResult
13498: oScopeDeclare
13499: oPop 1
13501: oGetAddrLocal 1
13503: oPushResult
13504: oSetResult 16
13506: oPushResult
13507: oId_True
13508: oPushResult
13509: oCall 13046
13511: oPop 2
13513: oAssign
13514: oGetLocal 1
13516: oPushResult
13517: oSetResult 21
13519: oPushResult
13520: oGetGlobal 7
13522: oPushResult
13523: oNodeSet
13524: oPop 3
13526: oGetLocal 1
13528: oPushResult
13529: oSetResult 22
13531: oPushResult
13532: oSetResult 1
13534: oPushResult
13535: oNodeSetInt
13536: oPop 3
13538: oGetLocal 1
13540: oPushResult
13541: oScopeDeclare
13542: oPop 1
13544: oGetAddrLocal 1
13546: oPushResult
13547: oSetResult 16
13549: oPushResult
13550: oId_False
13551: oPushResult
13552: oCall 13046
13554: oPop 2
13556: oAssign
13557: oGetLocal 1
13559: oPushResult
13560: oSetResult 21
13562: oPushResult
13563: oGetGlobal 7
13565: oPushResult
13566: oNodeSet
13567: oPop 3
13569: oGetLocal 1
13571: oPushResult
13572: oSetResult 22
13574: oPushResult
13575: oSetResult 0
13577: oPushResult
13578: oNodeSetInt
13579: oPop 3
13581: oGetLocal 1
13583: oPushResult
13584: oScopeDeclare
13585: oPop 1
13587: oGetAddrLocal 1
13589: oPushResult
13590: oSetResult 16
13592: oPushResult
13593: oId_Nil
13594: oPushResult
13595: oCall 13046
13597: oPop 2
13599: oAssign
13600: oGetLocal 1
13602: oPushResult
13603: oSetResult 21
13605: oPushResult
13606: oGetGlobal 12
13608: oPushResult
13609: oNodeSet
13610: oPop 3
13612: oGetLocal 1
13614: oPushResult
13615: oSetResult 22
13617: oPushResult
13618: oSetResult 0
13620: oPushResult
13621: oNodeSetInt
13622: oPop 3
13624: oGetLocal 1
13626: oPushResult
13627: oScopeDeclare
13628: oPop 1
13630: oGetAddrGlobal 15
13632: oPushResult
13633: oId_Ord
13634: oPushResult
13635: oCall 13090
13637: oPop 1
13639: oAssign
13640: oGetAddrGlobal 16
13642: oPushResult
13643: oId_Chr
13644: oPushResult
13645: oCall 13090
13647: oPop 1
13649: oAssign
13650: oGetAddrGlobal 17
13652: oPushResult
13653: oId_Pred
13654: oPushResult
13655: oCall 13090
13657: oPop 1
13659: oAssign
13660: oGetAddrGlobal 18
13662: oPushResult
13663: oId_Succ
13664: oPushResult
13665: oCall 13090
13667: oPop 1
13669: oAssign
13670: oReturn
