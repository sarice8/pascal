   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nStrLitType :
2586:          decl = @newIdent( nConstStr, id )
2600:          oNodeSetString( decl, qValueStr, oValueTopString )
2611:       | * :  #eNotAllowed
2632:    ]
2632:    oValuePop
2633:    oNodeSet( decl, qType, oTypeSTop )
2644:    oTypeSPop
2645:    oScopeDeclare( decl )
2651:    ';'
2654:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2654: TypedConstDecl:
2656:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2669:    Node theType
2669:    @TypeRef( theType )
2676:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2688:    [ oNodeType( theType )
2695:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2696:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2696:          '='
      
2698:          oTypeSPush( theType )
2704:          @ConstExpr
2706:          @ConstCoerceType
      
2708:          oNodeSetInt( decl, qValue, oValueTop )
2719:          oValuePop
2720:          oTypeSPop
2721:          oScopeDeclare( decl )
2727:          ';'
      
2729:       | nShortStringType, nFileType :
2731:          #eNotImplemented
      
2733:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2735:          oScopeEnter( globalScope )
2741:          int addr = oScopeAllocType( theType )
2751:          oScopeEnd
2752:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2763:          oNodeSetInt( decl, qValue, addr )
2775:          '='
2777:          @TypedConstInit( theType, addr )
2787:          oCodePop
2788:          oScopeDeclare( decl )
2794:          ';'
2796:    ]
2823:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2823: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2825:    [ oNodeType( theType )
2832:       | nArrayType :
2833:          Node baseType = oNodeGet( theType, qBaseType )
2846:          Node indexType = oNodeGet( theType, qIndexType )
2859:          int low = @OrdinalLow( indexType )
2870:          int high = @OrdinalHigh( indexType )
2881:          int elementSize = oNodeGetInt( baseType, qSize )
      
2894:          '('
               % Loop over elements
2896:          int i = low
2902:          {
2902:             @TypedConstInit( baseType, addr )
2912:             [ equal( i, high )
2922:                | true : >
2925:                | false :
2927:             ]
2935:             ','
2937:             addr = add( addr, elementSize )
2950:             inc( i )
2956:          }
2958:          ')'
      
2960:       | nRecordType :
2962:          '('
2964:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2977:          {
2977:             [
2977:                | pIdent :
2979:                | * :  >
2986:             ]
2986:             Node field = oScopeFindRequireInScope( fieldScope )
2996:             ':'
2998:             Node fieldType = oNodeGet( field, qType )
3011:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3031:             @TypedConstInit( fieldType, fieldAddr )
3041:             [
3041:                | ';' :
3043:                | * :  >
3050:             ]
3050:          }
3052:          ')'
      
3054:       | nBooleanType, nByteType, nCharType:
3056:          .tPushAddrGlobal  oEmitInt( addr )
3064:          oTypeSPush( theType )
3070:          @ConstExpr
3072:          @ConstCoerceType
3074:          .tPushConstI  oEmitInt( oValueTop )
3081:          oValuePop
3082:          oTypeSPop
3083:          .tAssignB
      
3085:       | nIntegerType, nEnumType:
3087:          .tPushAddrGlobal  oEmitInt( addr )
3095:          oTypeSPush( theType )
3101:          @ConstExpr
3103:          @ConstCoerceType
3105:          .tPushConstI  oEmitInt( oValueTop )
3112:          oValuePop
3113:          oTypeSPop
3114:          .tAssignI
      
3116:       | nPointerType, nUniversalPointerType :
3118:          .tPushAddrGlobal  oEmitInt( addr )
3126:          oTypeSPush( theType )
3132:          @ConstExpr
3134:          @ConstCoerceType
3136:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3143:          oValuePop
3144:          oTypeSPop
3145:          .tAssignP
      
3147:       | nShortStringType, nFileType :
3149:          #eNotImplemented
3151:    ]
3178:    ;
      
      
3178: TypeDecl:
3180:    {[
3180:       | pIdent :
3182:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3195:          '='
3197:          Node theType
3197:          @TypeRef( theType )
3204:          oNodeSet( decl, qType, theType )
3216:          oScopeDeclare( decl )
3222:          ';'
3224:       | * :
3229:          >
3231:    ]};
      
3234: VarDecl( node_type varNodeType ):
3236:    {[
3236:       | pIdent :
3238:          NodeVec decls = oNodeVecNew
3243:          Node decl
3243:          {
3243:             decl = @newIdent( varNodeType, LAST_ID )
3256:             oNodeVecAppend( decls, decl )
3265:             [
3265:                | ',' :
3267:                   pIdent
3269:                | * :
3274:                   >
3276:             ]
3276:          }
3278:          ':'
3280:          Node theType
3280:          @TypeRef( theType )
      
3287:          int i = 0
3293:          {[ equal( i, oNodeVecSize( decls ) )
3307:             | false :
3308:                decl = oNodeVecElement( decls, i )
3321:                oNodeSet( decl, qType, theType )
3333:                oScopeDeclareAlloc( decl )
3339:                inc( i )
3345:             | * :
3350:               >
3352:          ]}
      
               % optional initialization
3354:          [
3354:             | '=' :
3356:                [ oNodeVecSize( decls )
3363:                   | 1 :
3364:                   | * :  #eOnlyOneVarCanBeInitialized
3371:                ]
      
                     % we need an initCode stream for this scope
3371:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3381:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3387:                boolean changedScope = false
3393:                [ equal_zero( @ScopeLevel )
3400:                   | true : oScopeEnter( initScope )
3407:                            changedScope = true
3413:                   | * :
3418:                ]
                     % generate assignment in initCode stream
3418:                @LValueVar( decl, true )
3428:                @Expr
3430:                @CoerceType
3432:                @Assign
3434:                [ changedScope
3437:                   | true : oScopeEnd
3439:                   | * :
3444:                ]
3444:                oCodePop
                   
3445:             | * :
3450:          ]
      
3450:          oNodeVecDelete( decls )
3456:          ';'
3458:       | * :
3463:          >
3465:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3468: LabelDecl:
3470:    {
3470:       Node decl
3470:       [
3470:          | pIdent :
3472:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3474:             oChangeIntLitToLabelIdent
3475:       ]
3483:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3496:       Label label = oLabelNew
3501:       oNodeSetLabel( decl, qValue, label )
3513:       oScopeDeclare( decl )
3519:       [
3519:          | ',' :
3521:          | * :
3526:             >
3528:       ]
3528:    }
3530:    ';'
3533:    ;
3533: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3533: ConstExpr:
3535:    @ConstBoolExpr
3537:    {[
3537:       | '=' :
3539:          @ConstBoolTerm
3541:          @ConstMatchTypes
3543:          [ oTypeSNodeType
3545:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3554:             | * :             oValueEqual
3560:          ]
3560:          oTypeSPop  oTypeSPush( BooleanType )
3567:       | '<>' :
3569:          @ConstBoolExpr
3571:          @ConstMatchTypes
3573:          [ oTypeSNodeType
3575:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3584:             | * :             oValueNotEqual
3590:          ]
3590:          oTypeSPop  oTypeSPush( BooleanType )
3597:       | '<' :
3599:          @ConstBoolExpr
3601:          @ConstMatchTypes
3603:          [ oTypeSNodeType
3605:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3614:             | * :             oValueLess
3620:          ]
3620:          oTypeSPop  oTypeSPush( BooleanType )
3627:       | '>' :
3629:          @ConstBoolExpr
3631:          @ConstMatchTypes
3633:          [ oTypeSNodeType
3635:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3644:             | * :             oValueGreater
3650:          ]
3650:          oTypeSPop  oTypeSPush( BooleanType )
3657:       | '<=' :
3659:          @ConstBoolExpr
3661:          @ConstMatchTypes
3663:          [ oTypeSNodeType
3665:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3674:             | * :             oValueLessEqual
3680:          ]
3680:          oTypeSPop  oTypeSPush( BooleanType )
3687:       | '>=' :
3689:          @ConstBoolExpr
3691:          @ConstMatchTypes
3693:          [ oTypeSNodeType
3695:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3704:             | * :             oValueGreaterEqual
3710:          ]
3710:          oTypeSPop  oTypeSPush( BooleanType )
3717:       | * :  >
3734:    ]};
      
      
3737: ConstBoolExpr:
3739:    @ConstBoolTerm
3741:    {[
3741:       | pOr :
3743:          @ConstRequireBool
3745:          @ConstBoolTerm
3747:          @ConstRequireBoolPop
3749:          oValueOr
3750:       | * :  >
3757:    ]};
      
      
3760: ConstBoolTerm:
3762:    @ConstBoolFactor
3764:    {[
3764:       | pAnd :
3766:          @ConstRequireBool
3768:          @ConstBoolFactor
3770:          @ConstRequireBoolPop
3772:          oValueAnd
3773:       | * :  >
3780:    ]};
      
      
3783: ConstBoolFactor:
3785:    [
3785:       | pNot :
3787:          @ConstBoolFactor
3789:          @ConstRequireBool
3791:          oValueNot
3792:       | * :
3797:          @ConstArithExpr
3799:    ];
      
      
3800: ConstArithExpr:
3802:    @ConstTerm
3804:    {[
3804:       | '+' :
3806:          @ConstTerm
3808:          @ConstMatchTypes
3810:          [ oTypeSNodeType
3812:             | nStrLitType :   oValueStringConcat
3814:             | * :             oValueAdd
3820:          ]
3820:       | '-' :
3822:          @ConstTerm
3824:          @ConstMatchTypes
3826:          [ oTypeSNodeType
3828:             | nStrLitType :   #eNotAllowed
3831:             | * :             oValueSub
3837:          ]
3837:       | * :  >
3846:    ]};
      
      
3849: ConstTerm:
3851:    @ConstFactor
3853:    {[
3853:       | pTimes :
3855:          @ConstFactor
3857:          @ConstMatchTypes
3859:          [ oTypeSNodeType
3861:             | nStrLitType :   #eNotAllowed
3864:             | * :             oValueMult
3870:          ]
3870:       | pDivide :
3872:          @ConstFactor
3874:          @ConstMatchTypes
3876:          [ oTypeSNodeType
3878:             | nStrLitType :   #eNotAllowed
3881:             | * :             oValueDiv
3887:          ]
3887:       | * :  >
3896:    ]};
      
      
3899: ConstFactor:
3901:    [
3901:       | pPlus :
3903:          @ConstPrimary
3905:       | pMinus :
3907:          @ConstPrimary
3909:          oValueNegate
3910:       | * :
3917:          @ConstPrimary
3919:    ];
      
      
3920: ConstPrimary:
3922:    [
3922:       | pIntLit :
3924:          oValuePush( TOKEN_VALUE )
3929:          oTypeSPush( IntegerType )
3935:       | pCharLit :
3937:          oValuePush( TOKEN_VALUE )
3942:          oTypeSPush( CharType )
3948:       | pStrLit :
3950:          oValuePushString( CURRENT_STRLIT )
3955:          oTypeSPush( StrLitType )
3961:       | '(' :
3963:          @ConstExpr
3965:          ')'
3967:       | pIdent :
3969:          Node decl = oScopeFindRequire
3974:          @ResolveUnitRef( decl )
3981:          [ oNodeType( decl )
3988:             | nBuiltInFunc :
3989:                @ConstBuiltInFunc( decl )
3996:             | nConst :
3998:                oValuePush( oNodeGetInt( decl, qValue ) )
4011:                oTypeSPush( oNodeGet( decl, qType ) )
4024:             | nConstStr :
4026:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4039:                oTypeSPush( oNodeGet( decl, qType ) )
4052:             | nEnumValue :
4054:                oValuePush( oNodeGetInt( decl, qValue ) )
4067:                oTypeSPush( oNodeGet( decl, qType ) )
4080:             | nTypeDecl :
                     % A type cast
4082:                oTypeSPush( oNodeGet( decl, qType ) )
4095:                '('
4097:                @ConstExpr
4099:                ')'
4101:                @ConstCastType
                     % Constexprs are not compound types or dereferenceable pointers (I believe)
                     % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4103:             | * :
4116:                #eNotConst
4118:                oValuePush( 0 )
4124:                oTypeSPush( IntegerType )
4130:          ]
4130:       | '@' :
4132:          #eNotImplemented
4134:          oValuePush( 0 )
4140:          oTypeSPush( UniversalPointerType )
4146:       | * :
4161:          #eNotConst
4163:          oValuePush( 0 )
4169:          oTypeSPush( IntegerType )
4175:    ];
      
4176: ConstRequireBoolPop:
4178:    [ oTypeSNodeType
4180:       | nBooleanType :
4181:       | * :          #eNotBoolean
4188:    ]
4188:    oTypeSPop;
      
      
4190: ConstRequireBool:
4192:    [ oTypeSNodeType
4194:       | nBooleanType :
4195:       | * :          #eNotBoolean
4202:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4203: ConstMatchTypes:
4205:    node_type nt = oTypeSNodeType
4210:    oTypeSPop
4211:    [ equal_node_type( nt, oTypeSNodeType )
4220:       | false :
               % Some implicit conversion is allowed even here
4221:          [ oTypeSNodeType
4223:             | nPointerType :
4224:                [ nt
4227:                   | nUniversalPointerType :  >>
4229:                   | * :
4234:                ]
4234:             | nUniversalPointerType :
4236:                [ nt
4239:                   | nPointerType :  >>
4241:                   | * :
4246:                ]
4246:             | nStrLitType :
4248:                [ nt
4251:                   | nCharType :
4252:                      oValueCharToString
4253:                      >>
4254:                   | * :
4259:                ]
4259:             | nCharType :
4261:                [ nt
4264:                   | nStrLitType :
4265:                      oValueSwap
4266:                      oValueCharToString
4267:                      oValueSwap
4268:                      oTypeSPop
4269:                      oTypeSPush( StrLitType )
4275:                      >>
4276:                   | * :
4281:                ]
4281:             | * :
4292:          ]
4292:          #eTypeMismatch
4294:       | * :
4299:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4300: ConstCoerceType:
4302:    node_type nt = oTypeSNodeType
4307:    oTypeSPop
4308:    [ equal_node_type( nt, oTypeSNodeType )
4317:       | false :
               % Can we implicitly convert the value to the desired type?
4318:          [ oTypeSNodeType
4320:             | nIntegerType :
4321:                [ nt
4324:                   | nByteType :  >>
4326:                   | * :
4331:                ]
4331:             | nByteType :
4333:                [ nt
4336:                   | nIntegerType :  >>
4338:                   | * :
4343:                ]
4343:             | nPointerType :
4345:                [ nt
4348:                   | nUniversalPointerType :  >>
4350:                   | * :
4355:                ]
4355:             | nUniversalPointerType :
4357:                [ nt
4360:                   | nPointerType :  >>
4362:                   | * :
4367:                ]
4367:             | nStrLitType :
4369:                [ nt
4372:                   | nCharType :
4373:                      oValueCharToString
4374:                      >>
4375:                   | * :
4380:                ]
4380:             | nShortStringType :
4382:                [ nt
4385:                   | nStrLitType :  >>
4387:                   | nCharType :
4389:                      oValueCharToString
4390:                      >>
4391:                   | * :
4398:                ]
4398:             | * :
4413:          ]
4413:          #eTypeMismatch
4415:       | * :
4420:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4421: ConstCastType:
4423:    node_type nt = oTypeSNodeType
4428:    oTypeSPop
4429:    [ equal_node_type( nt, oTypeSNodeType )
4438:       | false :
               % Can we cast the value to the desired type?
4439:          [ oTypeSNodeType
4441:             | nIntegerType, nEnumType :
4442:                [ nt
4445:                   | nByteType, nCharType, nBooleanType :  >>
4447:                   | nIntegerType, nEnumType :  >>
4450:                   | * :
4463:                ]
4463:             | nByteType, nCharType, nBooleanType :
4465:                [ nt
4468:                   | nByteType, nCharType, nBooleanType :  >>
4470:                   | nIntegerType, nEnumType :  >>
4473:                   | * :
4486:                ]
4486:             | nPointerType :
4488:                [ nt
4491:                   | nUniversalPointerType :  >>
4493:                   | * :
4498:                ]
4498:             | nUniversalPointerType :
4500:                [ nt
4503:                   | nPointerType :  >>
4505:                   | * :
4510:                ]
4510:             | nStrLitType :
4512:                [ nt
4515:                   | nCharType :
4516:                      oValueCharToString
4517:                      >>
4518:                   | * :
4523:                ]
4523:             | nShortStringType :
4525:                [ nt
4528:                   | nStrLitType :  >>
4530:                   | nCharType :
4532:                      oValueCharToString
4533:                      >>
4534:                   | * :
4541:                ]
4541:             | * :
4562:          ]
4562:          #eTypeMismatch
4564:       | * :
4569:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4570: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4572:    [ oNodeEqual( method, BuiltIn_Ord )
4582:       | true :
4583:          '('
4585:          @ConstExpr
4587:          ')'
4589:          [ oTypeSNodeType
4591:             | nIntegerType, nEnumType :
4592:             | nBooleanType, nByteType, nCharType :
4594:             | * :  #eTypeMismatch
4609:          ]
4609:          oTypeSPop
4610:          oTypeSPush( IntegerType )
4616:          ')'
4618:          >>
4619:       | * :
4624:    ]
      
         % Chr(x)
4624:    [ oNodeEqual( method, BuiltIn_Chr )
4634:       | true :
4635:          '('
4637:          @ConstExpr
4639:          ')'
4641:          [ oTypeSNodeType
4643:             | nIntegerType :
4644:             | nByteType :
4646:             | * :  #eTypeMismatch
4655:          ]
4655:          oTypeSPop
4656:          oTypeSPush( CharType )
4662:          ')'
4664:          >>
4665:       | * :
4670:    ]
      
         % Pred(x)
4670:    [ oNodeEqual( method, BuiltIn_Pred )
4680:       | true :
4681:          '('
4683:          @ConstExpr
4685:          [ oTypeSNodeType
4687:             | nEnumType :
4688:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4697:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4700:                   | * :
4705:                ]
4705:             | * :  #eTypeMismatch
4712:          ]
4712:          oValuePush( 1 )  oValueSub
4719:          ')'
4721:          >>
4722:       | * :
4727:    ]
      
         % Succ(x)
4727:    [ oNodeEqual( method, BuiltIn_Succ )
4737:       | true :
4738:          '('
4740:          @ConstExpr
4742:          [ oTypeSNodeType
4744:             | nEnumType :
4745:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4754:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4757:                   | * :
4762:                ]
4762:             | * :  #eTypeMismatch
4769:          ]
4769:          oValuePush( 1 )  oValueAdd
4776:          ')'
4778:          >>
4779:       | * :
4784:    ]
      
4784:    #eNotImplemented
4787:    ;
      
      
4787: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4787: Expr:
4789:    Label falseLabel = labelNull
      
4795:    @ExprAllowFlow( falseLabel )
4802:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4810: BooleanExprControlFlow( out Label falseLabel ):
4812:    @ExprAllowFlow( falseLabel )
4819:    [ oTypeSNodeType
4821:       | nBooleanFlowType :
4822:       | nBooleanType :
               % convert value to control flow
4824:          falseLabel = oLabelNew
4829:          .tJumpFalse  oEmitLabel( falseLabel )
4837:       | * :
4844:          #eNotBoolean
4846:    ]
4846:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4848: FlowToVal( inout Label falseLabel ):
4850:    [ oTypeSNodeType
4852:       | nBooleanFlowType :
4853:          Label doneLabel = oLabelNew
4858:          .tPushConstI  oEmitInt( 1 )
4866:          .tJump  oEmitLabel( doneLabel )
4874:          .tLabel  oEmitLabel( falseLabel )
4882:          .tPushConstI  oEmitInt( 0 )
4890:          .tLabel  oEmitLabel( doneLabel )
4898:          oTypeSPop
4899:          oTypeSPush( BooleanType )
4905:          falseLabel = labelNull
4911:       | * :
4916:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4917: ValToFlow( out Label falseLabel ):
4919:    [ oTypeSNodeType
4921:       | nBooleanType :
4922:          falseLabel = oLabelNew
4927:          .tJumpFalse  oEmitLabel( falseLabel )
4935:          oTypeSPop
4936:          oTypeSPush( BooleanFlowType )
4942:       | * :
4947:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4948: ExprAllowFlow( out Label falseLabel ):
4950:    @BoolExprAllowFlow( falseLabel )
4957:    {[
4957:       | '=' :
4959:          @FlowToVal( falseLabel )
4966:          @PromoteToIntOptional
4968:          @BoolExprAllowFlow( falseLabel )
4975:          @FlowToVal( falseLabel )
4982:          @PromoteToIntOptional
4984:          @MatchTypes
4986:          [ oTypeSNodeType
4988:             | nBooleanType, nCharType :     .tEqualB
4991:             | nIntegerType, nEnumType :     .tEqualI
4995:             | nPointerType, nUniversalPointerType :    .tEqualP
4999:             | nShortStringType, nStrLitType :
5001:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5013:             | * :                           #eNotAllowed
5034:          ]
5034:          oTypeSPop
5035:          oTypeSPush( BooleanType )
      
5041:       | '<>' :
5043:          @FlowToVal( falseLabel )
5050:          @PromoteToIntOptional
5052:          @BoolExprAllowFlow( falseLabel )
5059:          @FlowToVal( falseLabel )
5066:          @PromoteToIntOptional
5068:          @MatchTypes
5070:          [ oTypeSNodeType
5072:             | nBooleanType, nCharType :     .tNotEqualB
5075:             | nIntegerType, nEnumType :     .tNotEqualI
5079:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5083:             | nShortStringType, nStrLitType :
5085:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5097:             | * :                           #eNotAllowed
5118:          ]
5118:          oTypeSPop
5119:          oTypeSPush( BooleanType )
      
5125:       | '<' :
5127:          @FlowToVal( falseLabel )
5134:          @PromoteToIntOptional
5136:          @BoolExprAllowFlow( falseLabel )
5143:          @FlowToVal( falseLabel )
5150:          @PromoteToIntOptional
5152:          @MatchTypes
5154:          [ oTypeSNodeType
5156:             | nBooleanType, nCharType :     .tLessB
5159:             | nIntegerType, nEnumType :     .tLessI
5163:             | nPointerType, nUniversalPointerType :   .tLessP
5167:             | nShortStringType, nStrLitType :
5169:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5181:             | * :                           #eNotAllowed
5202:          ]
5202:          oTypeSPop
5203:          oTypeSPush( BooleanType )
      
5209:       | '>' :
5211:          @FlowToVal( falseLabel )
5218:          @PromoteToIntOptional
5220:          @BoolExprAllowFlow( falseLabel )
5227:          @FlowToVal( falseLabel )
5234:          @PromoteToIntOptional
5236:          @MatchTypes
5238:          [ oTypeSNodeType
5240:             | nBooleanType, nCharType :     .tGreaterB
5243:             | nIntegerType, nEnumType :     .tGreaterI
5247:             | nPointerType, nUniversalPointerType :   .tGreaterP
5251:             | nShortStringType, nStrLitType :
5253:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5265:             | * :                           #eNotAllowed
5286:          ]
5286:          oTypeSPop
5287:          oTypeSPush( BooleanType )
      
5293:       | '<=' :
5295:          @FlowToVal( falseLabel )
5302:          @PromoteToIntOptional
5304:          @BoolExprAllowFlow( falseLabel )
5311:          @FlowToVal( falseLabel )
5318:          @PromoteToIntOptional
5320:          @MatchTypes
5322:          [ oTypeSNodeType
5324:             | nBooleanType, nCharType :     .tLessEqualB
5327:             | nIntegerType, nEnumType :     .tLessEqualI
5331:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5335:             | nShortStringType, nStrLitType :
5337:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5349:             | * :                           #eNotAllowed
5370:          ]
5370:          oTypeSPop
5371:          oTypeSPush( BooleanType )
      
5377:       | '>=' :
5379:          @FlowToVal( falseLabel )
5386:          @PromoteToIntOptional
5388:          @BoolExprAllowFlow( falseLabel )
5395:          @FlowToVal( falseLabel )
5402:          @PromoteToIntOptional
5404:          @MatchTypes
5406:          [ oTypeSNodeType
5408:             | nBooleanType, nCharType :     .tGreaterEqualB
5411:             | nIntegerType, nEnumType :     .tGreaterEqualI
5415:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5419:             | nShortStringType, nStrLitType :
5421:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5433:             | * :                           #eNotAllowed
5454:          ]
5454:          oTypeSPop
5455:          oTypeSPush( BooleanType )
      
5461:       | * :
5476:          >
5478:    ]};
      
      
5481: BoolExprAllowFlow( out Label falseLabel ):
5483:    Label trueLabel = labelNull
      
5489:    @BoolTermAllowFlow( falseLabel )
5496:    {[
5496:       | pOr :
5498:          [ oTypeSNodeType
5500:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5501:                [ equal_label( trueLabel, labelNull )
5511:                   | true :  trueLabel = oLabelNew
5517:                   | * :
5522:                ]
5522:                .tJump  oEmitLabel( trueLabel )
5530:             | nBooleanType :
5532:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5539:                [ equal_label( trueLabel, labelNull )
5549:                   | true :  trueLabel = oLabelNew
5555:                   | * :
5560:                ]
5560:                .tJump  oEmitLabel( trueLabel )
5568:             | * : #eNotBoolean
5577:          ]
5577:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5578:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5586:          falseLabel = labelNull
5592:          @BoolTermAllowFlow( falseLabel )
      
5599:          [ oTypeSNodeType
5601:             | nBooleanFlowType :
5602:             | nBooleanType :
5604:                @ValToFlow( falseLabel )
5611:             | * : #eNotBoolean
5620:          ]
      
5620:          oTypeSPop
5621:          oTypeSPush( BooleanFlowType )
      
5627:       | * :
5632:          >
5634:    ]}
      
         % any short-circuit trues jump here to the end
5636:    [ equal_label( trueLabel, labelNull )
5646:       | false :
5647:          .tLabel  oEmitLabel( trueLabel )
5655:       | * :
5660:    ]
5661:    ;
      
      
5661: BoolTermAllowFlow( out Label falseLabel ):
5663:    Label overallFalseLabel = labelNull
      
5669:    @BoolFactorAllowFlow( falseLabel )
5676:    {[
5676:       | pAnd :
5678:          [ oTypeSNodeType
5680:             | nBooleanFlowType :
5681:             | nBooleanType :
5683:                @ValToFlow( falseLabel )
5690:             | * :
5697:                #eNotBoolean
5699:          ]
5699:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5700:          [ equal_label( overallFalseLabel, labelNull )
5710:             | true :
5711:                overallFalseLabel = oLabelNew
5716:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5730:                falseLabel = overallFalseLabel
5736:             | * :
5741:          ]
      
5741:          Label factorFalseLabel = labelNull
5747:          @BoolFactorAllowFlow( factorFalseLabel )
      
5754:          [ oTypeSNodeType
5756:             | nBooleanFlowType :
5757:             | nBooleanType :
5759:                @ValToFlow( factorFalseLabel )
5766:             | * : #eNotBoolean
5775:          ]
5775:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5789:       | * :
5794:          >
5796:    ]};
      
      
5799: BoolFactorAllowFlow( out Label falseLabel ):
5801:    [
5801:       | pNot :
5803:          Label factorFalseLabel = labelNull
      
5809:          @BoolFactorAllowFlow( factorFalseLabel )
5816:          [ oTypeSNodeType
5818:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5819:                falseLabel = oLabelNew
5824:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5832:                .tLabel  oEmitLabel( factorFalseLabel )
      
5840:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5842:                .tNot
      
5844:             | * : #eNotBoolean
5853:          ]
      
5853:       | * :
5858:          @ArithExprAllowFlow( falseLabel )
5865:    ];
      
      
5866: ArithExprAllowFlow( out Label falseLabel ):
5868:    boolean first = true
5874:    int tempStrOffset
      
5874:    @TermAllowFlow( falseLabel )
5881:    {[
5881:       | '+' :
5883:          [ oTypeSNodeType
5885:             | nIntegerType, nByteType :
5886:                @PromoteToIntPop
5888:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5895:                [ oTypeSNodeType
5897:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5898:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5900:                      @PointerAddition
5902:                   | * :
5909:                      @PromoteToInt
5911:                      .tAddI
5913:                ]
      
5913:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5915:                [ first
5918:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5919:                             tempStrOffset = @MoveIntoTempShortString
5925:                             first = false
5931:                   | * :
5936:                ]
5936:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5943:                [ oTypeSNodeType
5945:                   | nShortStringType, nStrLitType :
5946:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5948:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5956:                      oTypeSPush( ShortStringType )
5962:                   | nCharType :
5964:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5966:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5974:                      oTypeSPush( ShortStringType )
5980:                   | * :
5989:                      #eTypeMismatch
5991:                      oTypeSPop
5992:                ]
      
5992:             | nPointerType, nUniversalPointerType :
5994:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6001:                @PromoteToIntPop
6003:                @PointerAddition
      
6005:             | * :
6022:                #eNotAllowed
6024:          ]
      
6024:       | '-' :
6026:          [ oTypeSNodeType
6028:             | nIntegerType, nByteType :
6029:                @PromoteToIntPop
6031:                @TermAllowFlow( falseLabel )
6038:                @PromoteToInt
6040:                .tSubI
      
6042:             | nPointerType, nUniversalPointerType :
6044:                @TermAllowFlow( falseLabel )
6051:                [ oTypeSNodeType
6053:                   | nIntegerType, nByteType :
6054:                      @PromoteToIntPop
6056:                      @PointerSubInt
6058:                   | nPointerType, nUniversalPointerType :
6060:                      @MatchTypes
6062:                      @PointerSubPointer
6064:                   | * :
6075:                      #eNotAllowed
6077:                ]
      
6077:             | * :  #eNotAllowed
      
6090:          ]
6090:       | * :
6097:          >
6099:    ]};
      
      
6102: TermAllowFlow( out Label falseLabel ):
6104:    @FactorAllowFlow( falseLabel )
6111:    {[
6111:       | pTimes :
6113:          @PromoteToIntPop
6115:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6122:          @PromoteToInt
6124:          .tMultI
6126:       | pDivide :
6128:          @PromoteToIntPop
6130:          @FactorAllowFlow( falseLabel )
6137:          @PromoteToInt
6139:          .tDivI
6141:       | * :
6148:          >
6150:    ]};
      
      
6153: FactorAllowFlow( out Label falseLabel ):
6155:    [
6155:       | pPlus :
6157:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6164:          @PromoteToInt
6166:       | pMinus :
6168:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6175:          @PromoteToInt
6177:          .tNegI
6179:       | * :
6186:          @PrimaryAllowFlow( falseLabel )
6193:    ];
      
      
6194: PrimaryAllowFlow( out Label falseLabel ):
6196:    [
6196:       | pIntLit :
6198:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6205:          oTypeSPush( IntegerType )
      
6211:       | pCharLit :
6213:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6220:          oTypeSPush( CharType )
      
6226:       | '(' :
6228:          @ExprAllowFlow( falseLabel )
6235:          ')'
      
6237:       | pStrLit :
6239:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6248:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6256:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6262:          @LValueIndexes
               % get final value of dereferencing, if any
6264:          @FetchVar
      
6266:       | pIdent :
6268:          Node decl = oScopeFindRequire
6273:          @ResolveUnitRef( decl )
6280:          Node theType
      
6280:          [ oNodeType( decl )
6287:             | nFunc :
6288:                @Call( decl )
      
6295:             | nBuiltInFunc :
6297:                @CallBuiltInFunc( decl )
      
6304:             | nConst, nEnumValue :
6306:                theType = oNodeGet( decl, qType )
6319:                oTypeSPush( theType )
6325:                [ oTypeSNodeType
6327:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6328:                      .tPushConstI @EmitValue( decl )
6337:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6339:                      .tPushConstI @EmitValue( decl )
6348:                   | * :
6365:                      #eNotImplemented
6367:                ]
      
6367:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6369:                int addr = oNodeGetInt( decl, qValue )
6382:                [ equal_zero( addr )
6389:                   | true :
6390:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6407:                      oNodeSetInt( decl, qValue, addr )
6419:                   | * :
6424:                ]
6424:                .tPushAddrGlobal oEmitInt( addr )
6432:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6438:                @LValueIndexes
                     % get final value of dereferencing, if any
6440:                @FetchVar
      
6442:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6444:                @VarExpr( decl )
      
6451:             | nTypeDecl :
                     % A type cast
6453:                oTypeSPush( oNodeGet( decl, qType ) )
6466:                '('
6468:                @Expr
6470:                ')'
6472:                @CastType
      
                     % The expression can be further modified after the typecast.
                     % This is taken from VarExpr.  Try to consolidate.
      
6474:                [ oTypeSNodeType
6476:                   | nPointerType, nUniversalPointerType :
6477:                      [
6477:                         | '^' :             % dereferenced
6479:                            oTypeSPop
6480:                            oTypeSPush( oNodeGet( theType, qBaseType ) )
6493:                            @LValueIndexes
6495:                            @FetchVar
6497:                         | '[' :             % dereferencing pointer like an array [0..] of baseType
6499:                            @PointerArraySubscript
                                 % modify addr for any subsequent subscripts, field references, etc
6501:                            @LValueIndexes
6503:                            @FetchVar
6505:                         | * :               % just ptr value alone
6512:                      ]
      
6512:                   | nArrayType, nRecordType, nShortStringType :
                           % So far we would have the addr of the compound value.
                           % Modify addr for subscripts, field references, etc
6514:                      @LValueIndexes
                           % get final value, if no longer compound
6516:                      @FetchVar
      
6518:                   | *:
6531:                ]
      
6531:             | * :
6554:                #eNotValue
6556:                oTypeSPush( IntegerType )
6562:          ]
      
6562:       | '@' :        % @var -- pointer to var
6564:          pIdent
      
6566:          Node decl = oScopeFindRequire
6571:          @ResolveUnitRef( decl )
6578:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
6578:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6588:          theType = oTypeSTop
6593:          oTypeSPop
6594:          Node ptrType = @PointerTypeTo( theType )
6605:          oTypeSPush( ptrType )
      
6611:       | * :
6626:          #eNotValue
6628:          oTypeSPush( IntegerType )
6634:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6635: VarExpr( Node decl ):
6637:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6650:    int uplevels = @DeclUpLevels( decl )
      
6661:    oTypeSPush( theType )
6667:    [ oTypeSNodeType
6669:       | nIntegerType, nEnumType :
6670:          [ oNodeType( decl )
6677:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6687:             | nLocalVar :
6689:                [ equal_zero( uplevels )
6696:                   | true :  .tPushLocalI  @EmitValue( decl )
6706:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6726:                ]
6726:             | nParam :
6728:                [ oNodeGetBoolean( decl, qInOut )
6738:                   | true :    % VAR param points to the var.  Auto dereference.
6739:                      [ equal_zero( uplevels )
6746:                         | true :  .tPushParamP  @EmitValue( decl )
6756:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6776:                      ]
6776:                      .tFetchI
6778:                   | * :
6783:                      [ equal_zero( uplevels )
6790:                         | true :  .tPushParamI  @EmitValue( decl )
6800:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6820:                      ]
6820:                ]
6820:          ]
      
6832:       | nBooleanType, nByteType, nCharType :
6834:          [ oNodeType( decl )
6841:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6851:             | nLocalVar :
6853:                [ equal_zero( uplevels )
6860:                   | true :  .tPushLocalB  @EmitValue( decl )
6870:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6890:                ]
6890:             | nParam :
6892:                [ oNodeGetBoolean( decl, qInOut )
6902:                   | true :    % VAR param points to the var.  Auto dereference.
6903:                      [ equal_zero( uplevels )
6910:                         | true :  .tPushParamP  @EmitValue( decl )
6920:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6940:                      ]
6940:                      .tFetchB
6942:                   | * :
6947:                      [ equal_zero( uplevels )
6954:                         | true :  .tPushParamB  @EmitValue( decl )
6964:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6984:                      ]
6984:                ]
6984:          ]
      
6996:       | nFileType :
6998:          #eNotImplemented
      
7000:       | nPointerType, nUniversalPointerType :
7002:          [ oNodeType( decl )
7009:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7019:             | nLocalVar :
7021:                [ equal_zero( uplevels )
7028:                   | true :  .tPushLocalP  @EmitValue( decl )
7038:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7058:                ]
7058:             | nParam :
7060:                [ oNodeGetBoolean( decl, qInOut )
7070:                   | true :    % VAR param points to the var.  Auto dereference.
7071:                      [ equal_zero( uplevels )
7078:                         | true :  .tPushParamP  @EmitValue( decl )
7088:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7108:                      ]
7108:                      .tFetchP
7110:                   | * :
7115:                      [ equal_zero( uplevels )
7122:                         | true :  .tPushParamP  @EmitValue( decl )
7132:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7152:                      ]
7152:                ]               
7152:          ]
7164:          [
7164:             | '^' :             % dereferenced
7166:                oTypeSPop
7167:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7180:                @LValueIndexes
7182:                @FetchVar
7184:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7186:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7188:                @LValueIndexes
7190:                @FetchVar
7192:             | * :               % just ptr value alone
7199:          ]
      
7199:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7201:          [ oNodeType( decl )
7208:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7218:             | nLocalVar :
7220:                [ equal_zero( uplevels )
7227:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7237:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7257:                ]
7257:             | nParam :
7259:                [ oNodeGetBoolean( decl, qInOut )
7269:                   | true :    % VAR param points to the var.  Auto dereference.
7270:                      [ equal_zero( uplevels )
7277:                         | true :  .tPushParamP  @EmitValue( decl )
7287:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7307:                      ]
7307:                   | * :
7312:                      [ equal_zero( uplevels )
7319:                         | true :  .tPushAddrParam  @EmitValue( decl )
7329:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7349:                      ]
7349:                ]
7349:          ]
               % modify addr for subscripts, field references, etc
7361:          @LValueIndexes
               % get final value
7363:          @FetchVar
7365:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7392: FetchVar:
7394:    [ oTypeSNodeType
7396:       | nIntegerType, nEnumType :  .tFetchI
7399:       | nBooleanType, nByteType, nCharType :  .tFetchB
7403:       | nFileType :   #eNotImplemented
7407:       | nPointerType :             .tFetchP
7411:       | nUniversalPointerType :    #eCantDereference
7415:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7417:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7446: LValueIndexes:
7448:    {[
7448:       | '[' :
7450:          [ oTypeSNodeType
7452:             | nArrayType :    @ArraySubscripts
7455:             | nPointerType :  @PointerArraySubscript
7459:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7463:             | * :             #eNotArray
7476:          ]
7476:       | '.' :       @RecordFieldRef
7480:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7484:       | * :         >
7495:    ]};
      
      
7498: ArraySubscripts:
7500:    [ oTypeSNodeType
7502:       | nArrayType :
7503:       | * :       #eNotArray
7510:    ]
7510:    {
7510:       [ oTypeSNodeType
7512:          | nArrayType :
7513:          | * :    #eTooManySubscripts
7520:       ]
      
            % low subscript of this dimension
7520:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7537:       Node baseType
7537:       baseType = oNodeGet( oTypeSTop, qBaseType )
7549:       oTypeSPop
7550:       oTypeSPush( baseType )
      
7556:       @Expr
7558:       @RequireIntPop
            % adjust for low subscript
7560:       [ equal_zero( low )
7567:          | false :
7568:             .tPushConstI oEmitInt( low ) .tSubI
7578:          | * :
7583:       ]
      
            % multiply by element size
7583:       int size = oNodeGetInt( baseType, qSize )
7596:       [ equal( size, 1 )
7606:          | false :
7607:             .tPushConstI oEmitInt( size ) .tMultI
7617:          | * :
7622:       ]
      
            % update start address
7622:       .tAddPI
7624:       [
7624:          | ']' :  >
7628:          | ',' :
7630:       ]
7638:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7641: PointerArraySubscript:
7643:    [ oTypeSNodeType
7645:       | nPointerType :
7646:       | * :    #eCantDereference
7653:    ]
         % replace type stack with base type
7653:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7665:    oTypeSPop
7666:    oTypeSPush( baseType )
         
7672:    @Expr
7674:    @RequireIntPop
         % multiply by element size
7676:    int size = oNodeGetInt( baseType, qSize )
7689:    [ equal( size, 1 )
7699:       | false :
7700:          .tPushConstI  oEmitInt( size )  .tMultI
7710:       | * :
7715:    ]
         % update start address
7715:    .tAddPI
7717:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7720: ShortStringArraySubscript:
7722:    [ oTypeSNodeType
7724:       | nStrLitType, nShortStringType :
7725:       | * :    #eCantDereference
7734:    ]
7734:    oTypeSPop
7735:    oTypeSPush( CharType )
7741:    @Expr
7743:    @RequireIntPop
7745:    .tAddPI
7747:    ']';
      
      
7750: RecordFieldRef:
7752:    [ oTypeSNodeType
7754:       | nRecordType :
7755:       | * :    #eNotRecord
7762:    ]
7762:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7774:    pIdent
7776:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7781:    [ oNodeType( field )
7788:       | nRecordField :
7789:       | * :   #eNotRecordField
7796:    ]
7796:    oScopeEnd
7797:    int offset = oNodeGetInt( field, qValue )
7810:    [ equal_zero( offset )
7817:       | false :
7818:          .tPushConstI oEmitInt( offset ) .tAddPI
7828:       | * :
7833:    ]
      
         % replace the type on the type stack, with the field type
7833:    oTypeSPop
7834:    oTypeSPush( oNodeGet( field, qType ) )
7848:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7848: PointerAddition:
7850:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7862:    int elementSize = oNodeGetInt( elementType, qSize )
7875:    [ equal( elementSize, 1 )
7885:       | false :
7886:          .tPushConstI  oEmitInt( elementSize )
7894:          .tMultI
7896:       | * :
7901:    ]
7901:    .tAddPI
7904:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7904: PointerSubInt:
7906:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7918:    int elementSize = oNodeGetInt( elementType, qSize )
7931:    [ equal( elementSize, 1 )
7941:       | false :
7942:          .tPushConstI  oEmitInt( elementSize )
7950:          .tMultI
7952:       | * :
7957:    ]
7957:    .tSubPI
7960:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7960: PointerSubPointer:
7962:    .tSubP
7964:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7976:    int elementSize = oNodeGetInt( elementType, qSize )
7989:    [ equal( elementSize, 1 )
7999:       | false :
8000:          .tPushConstI  oEmitInt( elementSize )
8008:          .tDivI
8010:       | * :
8015:    ]
8015:    oTypeSPop
8016:    oTypeSPush( IntegerType )
8023:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8023: PointerDeref:
8025:    [ oTypeSNodeType
8027:       | nPointerType :
8028:       | nUniversalPointerType :   #eCantDereference
8032:       | * :       #eNotPointer
8041:    ]
8041:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8043:    Node theType = oTypeSTop
8048:    oTypeSPop
8049:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8063:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8063: CoerceType:
8065:    node_type nt = oTypeSNodeType
8070:    Node given = oTypeSTop
8075:    oTypeSPop
8076:    [ equal_node_type( nt, oTypeSNodeType )
8085:       | false :
               % Can we implicitly convert the value to the desired type?
8086:          [ oTypeSNodeType
8088:             | nIntegerType :
8089:                [ nt
8092:                   | nByteType :   .tCastBtoI  >>
8096:                   | * :
8101:                ]
8101:             | nByteType :
8103:                [ nt
8106:                   | nIntegerType :   .tCastItoB  >>
8110:                   | * :
8115:                ]
8115:             | nPointerType :
8117:                [ nt
8120:                   | nUniversalPointerType :  >>
8122:                   | nStrLitType :
8124:                      [ equal_node( oTypeSTop, PCharType )
8133:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8134:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8145:                         | * :
8150:                      ]
8150:                   | * :
8157:                ]
8157:             | nUniversalPointerType :
8159:                [ nt
8162:                   | nPointerType :  >>
8164:                   | * :
8169:                ]
8169:             | nShortStringType :
8171:                [ nt
8174:                   | nStrLitType :  >>
8176:                   | nCharType :
                           % Store char as a temp ShortString.
8178:                      oTypeSPush( CharType )
8184:                      int tempOffset = @MoveIntoTempShortString
8190:                      oTypeSPop
8191:                      >>
8192:                   | * :
8199:                ]
8199:             | * :
8212:          ]
8212:          #eTypeMismatch
8214:       | * :
8219:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8220: CastType:
8222:    node_type nt = oTypeSNodeType
8227:    oTypeSPop
8228:    [ equal_node_type( nt, oTypeSNodeType )
8237:       | false :
               % Can we cast the value to the desired type?
8238:          [ oTypeSNodeType
8240:             | nIntegerType, nEnumType :
8241:                [ nt
8244:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8248:                   | nIntegerType, nEnumType :   >>
8251:                   | * :
8264:                ]
8264:             | nByteType, nCharType, nBooleanType :
8266:                [ nt
8269:                   | nByteType, nCharType, nBooleanType :   >>
8271:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8276:                   | * :
8289:                ]
8289:             | nPointerType :
8291:                [ nt
8294:                   | nUniversalPointerType :  >>
8296:                   | nStrLitType :
8298:                      [ equal_node( oTypeSTop, PCharType )
8307:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8308:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8319:                         | * :
8324:                      ]
8324:                   | * :
8331:                ]
8331:             | nUniversalPointerType :
8333:                [ nt
8336:                   | nPointerType :  >>
8338:                   | * :
8343:                ]
8343:             | nShortStringType :
8345:                [ nt
8348:                   | nStrLitType :  >>
8350:                   | nCharType :
                           % Store char as a temp ShortString.
8352:                      oTypeSPush( CharType )
8358:                      int tempOffset = @MoveIntoTempShortString
8364:                      oTypeSPop
8365:                      >>
8366:                   | * :
8373:                ]
8373:             | * :
8392:          ]
8392:          #eTypeMismatch
8394:       | * :
8399:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8400: MatchTypes:
8402:    node_type nt = oTypeSNodeType
8407:    oTypeSPop
8408:    [ equal_node_type( nt, oTypeSNodeType )
8417:       | false :
               % Some implicit conversion is allowed even here
8418:          [ oTypeSNodeType
8420:             | nPointerType :
8421:                [ nt
8424:                   | nUniversalPointerType :  >>
8426:                   | * :
8431:                ]
8431:             | nUniversalPointerType :
8433:                [ nt
8436:                   | nPointerType :  >>
8438:                   | * :
8443:                ]
8443:             | * :
8450:          ]
8450:          #eTypeMismatch
8452:       | * :
8457:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8458: RequireIntPop:
8460:    [ oTypeSNodeType
8462:       | nIntegerType :
8463:       | * :          #eNotInteger
8470:    ]
8470:    oTypeSPop;
      
8472: RequireInt:
8474:    [ oTypeSNodeType
8476:       | nIntegerType :
8477:       | * :          #eNotInteger
8484:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8485: PromoteToIntPop:
8487:    [ oTypeSNodeType
8489:       | nIntegerType :
8490:       | nByteType :        .tCastBtoI
8494:       | * :                #eNotInteger
8503:    ]
8503:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8505: PromoteToInt:
8507:    [ oTypeSNodeType
8509:       | nIntegerType :
8510:       | nByteType :        .tCastBtoI
8514:                            oTypeSPop
8515:                            oTypeSPush( IntegerType )
8521:       | * :                #eNotInteger
8530:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8531: PromoteToIntOptional:
8533:    [ oTypeSNodeType
8535:       | nByteType :        .tCastBtoI
8538:                            oTypeSPop
8539:                            oTypeSPush( IntegerType )
8545:       | * :
8550:    ];
      
      
8551: RequireBoolPop:
8553:    [ oTypeSNodeType
8555:       | nBooleanType :
8556:       | * :          #eNotBoolean
8563:    ]
8563:    oTypeSPop;
      
8565: RequireBool:
8567:    [ oTypeSNodeType
8569:       | nBooleanType :
8570:       | * :          #eNotBoolean
8577:    ];
      
      
8578: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8578: Statement:
8580:    [
8580:       | pWriteln :     @WritelnStmt
8584:       | pWrite :       @WriteStmt
8588:       | pReadln :      @ReadlnStmt
8592:       | pRead :        @ReadStmt
8596:       | pIf :          @IfStmt
8600:       | pWhile :       @WhileStmt
8604:       | pFor :         @ForStmt
8608:       | pRepeat :      @RepeatStmt
8612:       | pBreak :       @BreakStmt
8616:       | pContinue :    @ContinueStmt
8620:       | pBegin :       @BeginStmt
8624:       | pIdent :       @LabelOrAssignOrCallStmt
8628:       | pCase :        @CaseStmt
8632:       | pGoto :        @GotoStmt
8636:       | pIntLit :      % should be an integer label
8638:                        oChangeIntLitToLabelIdent
8639:                        @LabelOrAssignOrCallStmt
8641:       | * :            % null statement : don't accept any tokens
8674:    ];
      
      
8675: LabelOrAssignOrCallStmt:
8677:    Node decl = oScopeFindRequire
8682:    @ResolveUnitRef( decl )
8689:    [ oNodeType( decl )
8696:       | nLabel :                          @LabelDefinition( decl )
8704:                                           @Statement
8706:       | nProc :                           @Call( decl )
8715:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
8717:                                           @AssignStmt( decl )
8724:       | nFunc :                           @AssignResultStmt( decl )
8733:       | * :                               #eBadStatement
8752:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8753: LabelDefinition( Node decl ):
8755:    [ oNodeGetBoolean( decl, qDefined )
8765:       | true :  #eAlreadyDefined
8768:       | * :
8773:    ]
8773:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8788:    oNodeSetBoolean( decl, qDefined, true )
8800:    ':'
8803:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8803: AssignStmt( Node decl ):
8805:    @LValueFromDecl( decl, true )
8815:    ':=' 
8817:    @Expr
8819:    @CoerceType
8821:    @Assign
8824:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8824: Assign:
8826:    [ oTypeSNodeType
8828:       | nIntegerType, nEnumType :  .tAssignI
8831:       | nBooleanType, nByteType, nCharType :  .tAssignB
8835:       | nFileType :   #eNotImplemented
8839:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8843:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
8845:           int size = oNodeGetInt( oTypeSTop, qSize )
8857:           .tCopy  oEmitInt( size )    % multi-word copy
8865:    ]
8891:    oTypeSPop
8893:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8893: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8895:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8911:       | false :   #eNotCurrentFunction
8914:       | * :
8919:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8919:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8934:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8947:    ':='
8949:    @Expr
8951:    @CoerceType
8953:    [ oTypeSNodeType
8955:       | nIntegerType, nEnumType : .tAssignI
8958:       | nBooleanType, nByteType, nCharType :  .tAssignB
8962:       | nFileType :   #eNotImplemented
8966:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8970:       | nArrayType, nRecordType, nShortStringType :
8972:           int size = oNodeGetInt( oTypeSTop, qSize )
8984:           .tCopy  oEmitInt( size )    % multi-word copy
8992:    ]
9018:    oTypeSPop
9020:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9020: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9022:    pIdent
9024:    Node decl = oScopeFindRequire
9029:    @ResolveUnitRef( decl )
9036:    @LValueFromDecl( decl, writeable )
9047:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9047: LValueFromDecl( Node decl, boolean writeable ):
9049:    [ oNodeType( decl )
9056:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9057:          @LValueVar( decl, writeable )
      
9067:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9069:          oTypeSPush( oNodeGet( decl, qType ) )
9082:          '('
9084:          @LValueExpr( writeable )
9091:          ')'
9093:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9095:          [ oTypeSNodeType
9097:             | nPointerType :
9098:                [
9098:                   | '[' :
                           % dereference the pointer var first
9100:                      .tFetchP
9102:                      @PointerArraySubscript
9104:                   | * :
9109:                ]
9109:             | * :
9114:          ]
               % additional subscripts, if any
9114:          @LValueIndexes
       
9116:       | * :  #eNotVar
9131:    ]
9132:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9132: LValueCastType:
9134:    node_type nt = oTypeSNodeType
9139:    oTypeSPop
9140:    [ equal_node_type( nt, oTypeSNodeType )
9149:       | false :
               % Can we cast the value to the desired type?
9150:          [ oTypeSNodeType
9152:             | nIntegerType, nEnumType :
9153:                [ nt
9156:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9160:                   | nIntegerType, nEnumType :   >>
9163:                   | * :
9176:                ]
9176:             | nByteType, nCharType, nBooleanType :
9178:                [ nt
9181:                   | nByteType, nCharType, nBooleanType :   >>
9183:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9188:                   | * :
9201:                ]
9201:             | nPointerType :
9203:                [ nt
9206:                   | nUniversalPointerType :  >>
9208:                   | * :
9213:                ]
9213:             | nUniversalPointerType :
9215:                [ nt
9218:                   | nPointerType :  >>
9220:                   | * :
9225:                ]
9225:             | nShortStringType :
9227:                [ nt
9230:                   | nStrLitType :  >>
9232:                   | * :
9237:                ]
9237:             | * :
9256:          ]
9256:          #eTypeMismatch
9258:       | * :
9263:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9264: LValueVar( Node decl, boolean writeable ):
9266:    [ oNodeType( decl )
9273:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9283:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9294:       | nParam :
9296:          [ oNodeGetBoolean( decl, qInOut )
9306:             | true :   % VAR param points to variable.  No dereference.
9307:                        .tPushParamP @EmitValue( decl )
9316:             | * :      .tPushAddrParam @EmitValue( decl )
9330:          ]
9330:       | nTypedConst :
9332:          [ writeable
9335:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9345:             | * :      #eNotVar
9352:          ]
9352:       | * :            #eNotVar
9365:    ]
      
9365:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9378:    [ oTypeSNodeType
9380:       | nPointerType :
9381:          [
9381:             | '[' :
                     % dereference the pointer var first
9383:                .tFetchP
9385:                @PointerArraySubscript
9387:             | * :
9392:          ]
9392:       | * :
9397:    ]
         % additional subscripts, if any
9397:    @LValueIndexes
9400:    ;
      
      
9400: IncVar( Node decl ):
9402:    @LValueVar( decl, true )
9412:    @RequireIntPop
9414:    @VarExpr( decl )
9421:    oTypeSPop
9422:    .tIncI
9424:    .tAssignI;
      
9427: DecVar( Node decl ):
9429:    @LValueVar( decl, true )
9439:    @RequireIntPop
9441:    @VarExpr( decl )
9448:    oTypeSPop
9449:    .tDecI
9451:    .tAssignI;
      
      
9454: IfStmt:
9456:    Label falseLabel = labelNull
      
9462:    @BooleanExprControlFlow( falseLabel )
9469:    pThen
9471:    @Statement
9473:    [
9473:       | pElse :
9475:          Label doneLabel = oLabelNew
      
9480:          .tJump  oEmitLabel( doneLabel )
9488:          .tLabel oEmitLabel( falseLabel )
9496:          @Statement
9498:          .tLabel oEmitLabel( doneLabel )
      
9506:       | * :
9511:          .tLabel oEmitLabel( falseLabel )
9519:    ];
      
      
9520: ForStmt:
9522:    pIdent
      
9524:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9529:    @LValueVar( decl, true )
9539:    @RequireIntPop
      
9541:    ':='
      
9543:    @Expr
9545:    @RequireIntPop
9547:    .tAssignI
      
9549:    Label breakLabel = oLabelNew
      
9554:    Label checkLabel = oLabelNew
9559:    .tJump  oEmitLabel( checkLabel )
      
9567:    Label continueLabel = oLabelNew
9572:    .tLabel  oEmitLabel( continueLabel )
9580:    [
9580:       | pTo :
9582:          @IncVar( decl )
9589:          .tLabel  oEmitLabel( checkLabel )
9597:          @VarExpr( decl )  oTypeSPop
9605:          @Expr
9607:          @RequireIntPop
9609:          .tGreaterI
9611:          .tJumpTrue  oEmitLabel( breakLabel )
9619:       | pDownto :
9621:          @DecVar( decl )
9628:          .tLabel  oEmitLabel( checkLabel )
9636:          @VarExpr( decl )  oTypeSPop
9644:          @Expr
9646:          @RequireIntPop
9648:          .tLessI
9650:          .tJumpTrue  oEmitLabel( breakLabel )
9658:    ]
9666:    oLoopPush( continueLabel, breakLabel )
9675:    pDo
9677:    @Statement
9679:    .tJump  oEmitLabel( continueLabel )
9687:    .tLabel  oEmitLabel( breakLabel )
9695:    oLoopPop;
      
      
9697: RepeatStmt:
9699:    Label continueLabel = oLabelNew
9704:    .tLabel  oEmitLabel( continueLabel )
      
9712:    Label breakLabel = oLabelNew
      
9717:    oLoopPush( continueLabel, breakLabel )
9726:    @Statement
9728:    {[
9728:       | ';' :
9730:          @Statement
9732:       | pUntil :
9734:          Label falseLabel
9734:          @BooleanExprControlFlow( falseLabel )
9741:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9755:          >
9757:    ]}
9767:    .tLabel  oEmitLabel( breakLabel )
9775:    oLoopPop;
      
      
9777: WhileStmt:
9779:    Label continueLabel = oLabelNew
9784:    .tLabel  oEmitLabel( continueLabel )
      
9792:    Label breakLabel
9792:    @BooleanExprControlFlow( breakLabel )
      
9799:    oLoopPush( continueLabel, breakLabel )
9808:    pDo
9810:    @Statement
9812:    .tJump  oEmitLabel( continueLabel )
9820:    .tLabel  oEmitLabel( breakLabel )
9828:    oLoopPop;
      
      
9830: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9832:    [ equal_label( oLoopContinueLabel, labelNull )
9841:       | true :
9842:          #eNotInALoop
9844:       | false :
9846:          .tJump  oEmitLabel( oLoopContinueLabel )
9853:    ];
      
      
9862: BreakStmt:
9864:    [ equal_label( oLoopBreakLabel, labelNull )
9873:       | true :
9874:          #eNotInALoop
9876:       | false :
9878:          .tJump  oEmitLabel( oLoopBreakLabel )
9885:    ];
      
      
9894: CaseStmt:
9896:    Code tableCode = oCodeNew
9901:    Label tableLabel = oLabelNew
9906:    Label doneLabel = oLabelNew
9911:    Label otherwiseLabel = doneLabel
9917:    boolean isString = false
      
9923:    @Expr
         % Leave the expr type on the type stack throughout case statement
9925:    [ oTypeSNodeType
9927:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
9936:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
9946:       | nShortStringType, nStrLitType :        isString = true
9954:                                                .tJumpCaseS  oEmitLabel( tableLabel )
9962:       | * :     #eNotAllowed
9981:    ]
9981:    pOf
      
9983:    {
9983:       [
9983:          | pOtherwise, pElse :
9985:             otherwiseLabel = oLabelNew
9990:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
9998:             {[
9998:                | pEnd :  >
10002:                | * :
10007:                   @Statement
10009:                   [
10009:                      | ';' :
10011:                      | * :   pEnd  >
10020:                   ]
10020:             ]}
10022:             >
      
10024:          | pEnd :
                  % Reached end with no otherwise clause
10026:             >
      
10028:          | * :
10037:             Label caseLabel = oLabelNew
10042:             oCodePush( tableCode )
10048:             {
10048:                @ConstExpr
10050:                @ConstCoerceType
10052:                int val
10052:                [ isString
10055:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10065:                   | false :   val = oValueTop
10072:                ]
10080:                oValuePop
10081:                [
10081:                   | '..' :  @ConstExpr
10085:                             @ConstCoerceType
10087:                             int highval
10087:                             [ isString
10090:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10100:                                | false :  highval = oValueTop
10107:                             ]
10115:                             oValuePop
10116:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10136:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10155:                ]
10155:                [
10155:                   | ',' :
10157:                   | * :  >
10164:                ]
10164:             }
10166:             oCodePop
10167:             ':'
10169:             .tLabel  oEmitLabel( caseLabel )
10177:             @Statement
10179:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10187:             [
10187:                | ';' :
10189:                | * :
10194:             ]
                  
10194:       ]
         
10194:    }
      
10196:    .tLabel  oEmitLabel( tableLabel )
10204:    oEmitCode( tableCode )
10210:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10218:    .tLabel  oEmitLabel( doneLabel )
10226:    oTypeSPop
10228:    ;
      
      
10228: GotoStmt:
10230:    [
10230:       | pIdent :
10232:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10234:          oChangeIntLitToLabelIdent
10235:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10243:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10252:    oNodeSetBoolean( decl, qUsed, true )
10264:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10280:    ;
      
      
10280: BeginStmt:
10282:    @Statement
10284:    {[
10284:       | ';' :   @Statement
10288:       | pEnd :  >
10292:    ]};
      
      
10303: WritelnStmt:
10305:    @WriteStmt
10307:    .tWriteCR;
      
      
10310: WriteStmt:
10312:    [
10312:       | '(' :
10314:          {
10314:             @Expr
10316:             [ oTypeSNodeType
10318:                | nIntegerType :             .tWriteI
10321:                | nBooleanType :             .tWriteBool
10325:                | nByteType :                .tCastBtoI  .tWriteI
10331:                | nCharType :                .tWriteChar
10335:                | nShortStringType, nStrLitType :   .tWriteShortStr
10339:                | nFileType :                #eNotImplemented
10343:                | nEnumType :
                        % write name via table lookup
10345:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10359:                   .tWriteEnum
10361:                | nPointerType :
10363:                   [ equal_node( oTypeSTop, PCharType )
10372:                      | true :               .tWritePChar
10375:                      | * :                  .tWriteP
10382:                   ]
10382:                | nUniversalPointerType :    .tWriteP
10386:                | * :                        #eNotAllowed
10411:             ]
10411:             oTypeSPop
10412:             [
10412:                | ')' : >
10416:                | ',' :
10418:             ]
10426:          }
10428:       | * :
10433:    ];
      
      
10434: ReadlnStmt:      % ***
         % TO DO
10437:    ;
      
10437: ReadStmt:
         % TO DO
10440:    ;
10440: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
10440: MoveIntoTempShortString >> int:
10442:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
10452:    [ oTypeSNodeType
10454:       | nShortStringType, nStrLitType :
10455:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
10463:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
10465:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
10480:       | nCharType :
               % temp[0] = 1
10482:          .tPushAddrLocal  oEmitInt( tempOffset )
10490:          .tPushConstI  oEmitInt( 1 )
10498:          .tAssignB
               % temp[1] = value
10500:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
10515:          .tSwap
10517:          .tAssignB
10519:       | * :   #eTypeMismatch
10530:    ]
10530:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
10531:    .tPushAddrLocal  oEmitInt( tempOffset )
10539:    oTypeSPush( ShortStringType )
10545:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10549: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
10551:    .tAllocActuals  oEmitInt( 16 )
10559:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10571:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10583:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
10592:    .tFreeActuals  oEmitInt( 16 )
10600:    oTypeSPop
10601:    oTypeSPop
10603:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10603: ShortStringAppendChar:
         % Note at the moment I don't align params
10605:    .tAllocActuals  oEmitInt( 12 )
10613:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
10625:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10637:    .tCall  @EmitValue( System_ShortStringAppendChar )
10646:    .tFreeActuals  oEmitInt( 12 )
10654:    oTypeSPop
10655:    oTypeSPop
10657:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
10657: ShortStringCmp:
10659:    .tAllocActualsCdecl  oEmitInt( 24 )
10667:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10679:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10691:    int tempOffset = oScopeAllocType( IntegerType )
10701:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10719:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
10728:    .tPushLocalI  oEmitInt( tempOffset )
10736:    .tFreeActuals  oEmitInt( 24 )
10744:    oTypeSPop
10745:    oTypeSPush( IntegerType )
10752:    ;
10752: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10752: Call( Node method ):
10754:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
10766:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
10779:    Node resultType
10779:    int tempOffset
      
10779:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
10796:    [ isFunc
10799:       | true :
10800:          resultType = oNodeGet( method, qType )
10813:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
10823:       | * :
10828:    ]
         
      
10828:    Node paramScope = oNodeGet( method, qParams )
10841:    int actualsSize = oNodeGetInt( paramScope, qSize )
10854:    [ cdecl
10857:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
10866:       | false :  .tAllocActuals  oEmitInt( actualsSize )
10876:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
10884:    [ greater( @DeclLevel( method ), 0 )
10899:       | true :
10900:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
10908:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
10927:          .tAssignP
10929:       | * :
10934:    ]
      
      
10934:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
10947:    Node param = oNodeIterValue( paramIter )
10957:    [
10957:       | '(' :
            
10959:          {
10959:             [ oNodeNull( param )
10966:                | true : >
10969:                | * :
10974:             ]
      
10974:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
10987:             .tPushAddrActual oEmitInt( offset )
10995:             oTypeSPush( oNodeGet( param, qType ) )
      
11008:             [ oNodeGetBoolean( param, qInOut )
11018:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11019:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11026:                           @MatchTypes
      
11028:                           .tAssignP
      
11030:                | false :  @Expr
11034:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11036:                           [ oTypeSNodeType
11038:                              | nIntegerType, nEnumType : .tAssignI
11041:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11045:                              | nFileType :   #eNotImplemented
11049:                              | nPointerType, nUniversalPointerType :  .tAssignP
11053:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11055:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11067:                                  .tCopy  oEmitInt( size )    % multi-word copy
11075:                           ]
11101:             ]
11109:             oTypeSPop
      
11110:             oNodeIterNext( paramIter )
11116:             param = oNodeIterValue( paramIter )
11126:             [ oNodeNull( param )
11133:                | true :  >
11136:                | false :
11138:             ]
      
11146:             ','
11148:          }
      
11150:          ')'
      
11152:       | * :
11157:    ]
      
11157:    [ oNodeNull( param )
11164:       | false :    #eMissingParameter
11167:       | * :
11172:    ]
      
11172:    [ isFunc
11175:       | true :
               % Pass result temp as an additional VAR parameter.
11176:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11191:          .tPushAddrLocal  oEmitInt( tempOffset )
11199:          .tAssignP
11201:       | * :
11206:    ]
      
11206:    [ cdecl
11209:       | true :
11210:          .tCallCdecl  @EmitValue( method )
11219:       | false :
11221:          .tCall   @EmitValue( method )
11230:    ]
      
11238:    [ isFunc
11241:       | true :
               % push return value from temp
11242:          oTypeSPush( resultType )
      
11248:          [ oTypeSNodeType
11250:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11259:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11269:             | nFileType :  #eNotImplemented
11273:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11283:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11285:                                .tPushAddrLocal  oEmitInt( tempOffset )
11293:          ]
11319:       | * :
11324:    ]
         
11324:    .tFreeActuals  oEmitInt( actualsSize )
11333:    ;
      
      
      
      % Called on first use of an extern method
      %
11333: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
11335:    int strAddr
11335:    String externalName = oNodeGetString( method, qExternalName )
11348:    [ equal_string( externalName, stringNull )
11358:       | true :
11359:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
11380:       | false :
11382:          strAddr = oStringAllocLit( externalName )
11392:    ]
11400:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
11416:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11416: CallBuiltInFunc( Node method ):
      
         % Ord(x)
11418:    [ oNodeEqual( method, BuiltIn_Ord )
11428:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
11429:          '('
11431:          @Expr
11433:          [ oTypeSNodeType
11435:             | nIntegerType, nEnumType :
11436:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
11440:             | * :  #eTypeMismatch
11455:          ]
11455:          oTypeSPop
11456:          oTypeSPush( IntegerType )
11462:          ')'
11464:          >>
11465:       | * :
11470:    ]
      
         % Chr(x)
11470:    [ oNodeEqual( method, BuiltIn_Chr )
11480:       | true :
               % parameter is integer
               % result is char
11481:          '('
11483:          @Expr
11485:          [ oTypeSNodeType
11487:             | nIntegerType :    .tCastItoB
11490:             | nByteType :
11492:             | * :  #eTypeMismatch
11501:          ]
11501:          oTypeSPop
11502:          oTypeSPush( CharType )
11508:          ')'
11510:          >>
11511:       | * :
11516:    ]
      
         % Pred(x)
11516:    [ oNodeEqual( method, BuiltIn_Pred )
11526:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11527:          '('
11529:          @Expr
11531:          [ oTypeSNodeType
11533:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11534:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11543:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11546:                   | * :
11551:                ]
11551:             | * :  #eTypeMismatch
11558:          ]
11558:          .tDecI
11560:          ')'
11562:          >>
11563:       | * :
11568:    ]
      
         % Succ(x)
11568:    [ oNodeEqual( method, BuiltIn_Succ )
11578:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11579:          '('
11581:          @Expr
11583:          [ oTypeSNodeType
11585:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11586:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11595:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11598:                   | * :
11603:                ]
11603:             | * :  #eTypeMismatch
11610:          ]
11610:          .tIncI
11612:          ')'
11614:          >>
11615:       | * :
11620:    ]
      
11620:    #eNotImplemented
11623:    ;
      
11623: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11623: newType( node_type nt, int size ) >> Node:
11625:   Node node = oNodeNew( nt )
11635:   oNodeSetInt( node, qSize, size )
11647:   oTypeAdd( node )
11653:   >> node
11657:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11657: TypeRef( out Node resultType ):
11659:    [
11659:       | pIdent :           % previously named type (including intrinsics)
11661:          Node decl = oScopeFindRequire
11666:          @ResolveUnitRef( decl )
11673:          [ oNodeType( decl )
11680:             | nTypeDecl :
11681:                resultType = oNodeGet( decl, qType )
11694:             | * :
11699:                #eNotType
11701:                resultType = IntegerType
11707:          ]
         
11707:       | pArray :
11709:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
11711:          NodeVec dimensions = oNodeVecNew
      
11716:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
11716:             Node subrange = oNodeNew( nSubrangeType )
      
11726:             @ConstExpr
11728:             oNodeSetInt( subrange, qLow, oValueTop )
11739:             oValuePop
11740:             '..'
11742:             @ConstExpr
11744:             oNodeSetInt( subrange, qHigh, oValueTop )
11755:             oValuePop
      
11756:             @ConstMatchTypes
11758:             oNodeSet( subrange, qBaseType, oTypeSTop )
11769:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
11787:             oTypeSPop
11788:             oTypeAdd( subrange )
      
11794:             Node a = oNodeNew( nArrayType )
11804:             oNodeSet( a, qIndexType, subrange )
      
11816:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
11825:             [
11825:                | ']' : >
11829:                | ',' :
11831:             ]
11839:          }
      
11841:          pOf
11843:          Node baseType
11843:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
11850:          int dim = oNodeVecSize( dimensions )
      
11860:          {
11860:              dec(dim)
      
11866:              Node a = oNodeVecElement( dimensions, dim )
      
11879:              oNodeSet( a, qBaseType, baseType )
11891:              Node subrange = oNodeGet( a, qIndexType )
11904:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
11931:              inc( width )
11937:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
11963:              oTypeAdd( a )
11969:              baseType = a
      
11975:              [ equal_zero(dim)
11982:                  | true:  >
11985:                  | *:
11990:              ]
11990:          }
      
11992:          resultType = oNodeVecElement( dimensions, 0 )
12005:          oNodeVecDelete( dimensions )
      
12011:       | '^' :
12013:          Node theType
12013:          @TypeRef( theType )
12020:          resultType = @PointerTypeTo( theType )
      
12031:       | pRecord :
12033:          resultType = oNodeNew( nRecordType )
12043:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12052:          @VarDecl( nRecordField )
      
12059:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12071:          [ equal_zero( size )
12078:             | true : #eRecordEmpty
12081:             | * :
12086:          ]
      
12086:          pEnd
      
12088:          oNodeSet( resultType, qScope, oScopeCurrent )
12099:          oNodeSetInt( resultType, qSize, size )
12111:          oScopeEnd
12112:          oTypeAdd( resultType )
      
      
12118:       | '(' :
               % An enum type declaration.
12120:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12127:       | pSet :
12129:          pOf
12131:          Node theType
12131:          @TypeRef( theType )
12138:          #eNotImplemented
12140:       | * :       % this works for cases except where expr starts with an id
12155:          @ConstExpr '..' @ConstExpr
12161:          @ConstMatchTypes
12163:          #eNotImplemented
12165:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12166: EnumTypeRef( out Node resultType ):
      
12168:    resultType = oNodeNew( nEnumType )
12178:    int value = 0
12184:    int numValues = 0
12190:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12196:    Node outerScope = oScopeCurrent
12201:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12210:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12210:       pIdent
12212:       Node decl = @newIdent( nEnumValue, LAST_ID )
12225:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12238:       oNodeSet( decl, qType, resultType )
12250:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
12262:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
12275:       oNodeSetInt( decl, qNameOffset, nameOffset )
12287:       oNodeSetInt( decl2, qNameOffset, nameOffset )
12299:       [
12299:          | '=', ':=' :
12301:             oTypeSPush( IntegerType )
12307:             @ConstExpr
12309:             @ConstCoerceType
12311:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
12312:             [ equal_zero( numValues )
12319:                | false :
12320:                   [ greater( oValueTop, value )
12329:                      | false :   #eEnumValueNotAscending
12332:                      | * :
12337:                   ]
12337:                | * :
12342:             ]
12342:             [ equal( value, oValueTop )
12351:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
12352:                   oNodeSetBoolean( resultType, qHasGap, true )
12364:                | * :
12369:             ]
12369:             value = oValueTop
12374:             oValuePop
12375:          | * :
12382:       ]
12382:       oNodeSetInt( decl, qValue, value )
12394:       oNodeSetInt( decl2, qValue, value )
12406:       oScopeDeclare( decl )
      
12412:       oScopeEnter( outerScope )
12418:       oScopeDeclare( decl2 )
12424:       oScopeEnd
      
12425:       inc( value )
12431:       inc( numValues )
12437:       [
12437:          | ',' :
12439:          | * :    >
12446:       ]
12446:    }
12448:    ')'
      
12450:    oNodeSet( resultType, qScope, oScopeCurrent )
12461:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
12473:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
12474:    oCodePush( @GetOrCreateInitCode( globalScope ) )
12485:    oScopeEnter( globalScope )
12491:    int size = multiply( add( numValues, 1 ), 16 )
12511:    int addr = oScopeAlloc( size, 8 )
12524:    oScopeEnd
12525:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
12537:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
12557:    {
12557:       Node enumValue = oNodeIterValue( it )
12567:       [ oNodeNull( enumValue )
12574:          | true :  >
12577:          | * :
12582:       ]
12582:       .tPushAddrGlobal  oEmitInt( addr )
12590:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
12605:       .tAssignI
12607:       addr = add( addr, 8 )
12620:       .tPushAddrGlobal  oEmitInt( addr )
12628:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12643:       .tAssignP
12645:       addr = add( addr, 8 )
12658:       oNodeIterNext( it )
12664:    }
         % final table entry
12666:    .tPushAddrGlobal  oEmitInt( addr )
12674:    .tPushConstI  oEmitInt( 0 )
12682:    .tAssignI
12684:    addr = add( addr, 8 )
12697:    .tPushAddrGlobal  oEmitInt( addr )
12705:    .tPushConstI  oEmitInt( 0 )
12713:    .tAssignP
12715:    addr = add( addr, 8 )
12728:    oCodePop
      
12729:    oTypeAdd( resultType )
12736:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12736: PointerTypeTo( Node theType ) >> Node:
12738:    Node ptrType = oNodeGet( theType, qPointerType )
12751:    [ oNodeNull( ptrType )
12758:       | true :
12759:          ptrType = oNodeNew( nPointerType )
12769:          oNodeSet( ptrType, qBaseType, theType )
12781:          oNodeSetInt( ptrType, qSize, 8 )
12793:          oTypeAdd( ptrType )
12799:          oNodeSet( theType, qPointerType, ptrType )
12811:       | * :
12816:    ]
12816:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
12820: OrdinalLow( Node theType ) >> int:
12822:    [ oNodeType( theType )
12829:       | nIntegerType :  >> oMININT
12832:       | nBooleanType :  >> 0
12837:       | nCharType :     >> 0
12842:       | nEnumType :
12844:          Node enumScope = oNodeGet( theType, qScope )
12857:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12874:          >> oNodeGetInt( first, qValue )
12884:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12896:       | * :             #eNotOrdinalType
12911:                         >> 0
12914:    ];
      
      
      % Return the high value of an ordinal type
      %
12915: OrdinalHigh( Node theType ) >> int:
12917:    [ oNodeType( theType )
12924:       | nIntegerType :  >> oMAXINT
12927:       | nBooleanType :  >> 1
12932:       | nCharType :     >> 255
12937:       | nEnumType :
12939:          Node enumScope = oNodeGet( theType, qScope )
12952:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12969:          >> oNodeGetInt( last, qValue )
12979:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12991:       | * :             #eNotOrdinalType
13006:                         >> 0
13009:    ];
      
      
      
13010: Program:
13012:    Node t
      
13012:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13017:    oScopeBegin( 0, allocGlobal )
13026:    Node rootScope = oScopeCurrent
      
13031:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13033:    .tEnter  oEmitInt( 0 )
13041:    Label mainLabel = oLabelNew
      
13046:    .tAllocActuals  oEmitInt( 0 )
13054:    .tCall  oEmitLabel( mainLabel )
13062:    .tFreeActuals  oEmitInt( 0 )
13070:    .tReturn
      
13072:    pProgram
13074:    pIdent
      
13076:    Node program = oNodeNew( nProgram )
13086:    oNodeSetInt( program, qIdent, LAST_ID )
13097:    oNodeSet( workspace, qProgram, program )
      
      
13109:    [
13109:       | '(' :
13111:          pIdent      % input, output files
      
13113:          t = @newIdent( nVar, LAST_ID )
13126:          oNodeSet( t, qType, FileType )
13138:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13144:          ','
13146:          pIdent
      
13148:          t = @newIdent( nVar, LAST_ID )
13161:          oNodeSet( t, qType, FileType )
13173:          oScopeDeclareAlloc( t )
      
13179:          ')'
13181:       | * :
13186:    ]
13186:    ';'
      
13188:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13195:    [
13195:       | pUses :  @UsesClause( program )
13204:       | * :
13209:    ]
13209:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13216:    oScopeBegin( 0, allocGlobal )
13225:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13230:    oScopeBegin( 0, allocDown )
13239:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13250:    initScope = oScopeCurrent
13255:    oNodeSet( program, qMainRoutineScope, initScope )
13267:    oScopeEnd
      
13268:    @BlockDecls( nGlobalVar )
      
      
13275:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
13281:    boolean isMain = true
13287:    @BlockStmt( mainLabel, globalScope, isMain )
      
13300:    oScopeEnd   % main routine scope
      
13301:    '.'
13303:    @CheckForUndefinedLabels
13305:    oScopeEnd   % global scope
13306:    @EndUsedUnits( program )   % used units scopes
13314:    ;
      
      
      
      
13314: Block( node_type varNodeType, Label labelForBody ):
13316:    @BlockDecls( varNodeType )
13323:    @BlockStmt( labelForBody, oScopeCurrent, false )
13335:    @CheckForUndefinedLabels
13338:    ;
      
      
13338: BlockDecls( node_type varNodeType ):
13340:    {[
13340:       | pConst :     @ConstDecl
13344:       | pType :      @TypeDecl
13348:       | pVar :       @VarDecl( varNodeType )
13357:       | pLabel :     @LabelDecl
13361:       | pProcedure : @ProcDecl
13365:       | pFunction :  @FuncDecl
13369:       | * :          >
13386:    ]}
13388:    @CheckForUndefinedMethods
13391:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
13391: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
13394:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
13394: CheckForUndefinedLabels:
13396:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
13408:    {
13408:       Node decl = oNodeIterValue( it )
13418:       [ oNodeNull( decl )
13425:          | false :
13426:          | * :  >
13433:       ]
13433:       [ oNodeType( decl )
13440:          | nLabel :
13441:             [ oNodeGetBoolean( decl, qDefined )
13451:                | false :
13452:                   [ oNodeGetBoolean( decl, qUsed )
13462:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
13465:                      | * :
13470:                   ]
13470:                | * :
13475:             ]
13475:          | * :
13480:       ]
13480:       oNodeIterNext( it )
13486:    }
13489:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
13489: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
13491:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
13499:    int patchLS
13499:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
13508:    [ isMain
13511:       | true :  @InitializeUnits
13514:       | * :
13519:    ]
      
         % insert any code for initialization of this scope's variables
13519:    Code initCode = oNodeGetCode( varScope, qInitCode )
13532:    oEmitCode( initCode )
13538:    oNodeSetCode( varScope, qInitCode, codeNull )
      
13550:    @Statement
      
13552:    [ isMain
13555:       | true :  @FinalizeUnits
13558:       | * :
13563:    ]
      
13563:    .tReturn
      
13565:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
13577:    oPatch( patchLS, localSpace )
13587:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
13587: GetOrCreateInitCode( Node scope ) >> Code:
13589:    Code initCode = oNodeGetCode( scope, qInitCode )
13602:    [ equal_code( initCode, codeNull )
13612:       | true :
13613:          initCode = oCodeNew
13618:          oNodeSetCode( scope, qInitCode, initCode )
13630:       | * :
13635:    ]
13635:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
13639: ScopeLevel >> int:
13641:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13651: DeclLevel( Node decl ) >> int:
13653:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
13671: DeclUpLevels( Node decl ) >> int:
13673:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
13689: newIdent( node_type nt, int id ) >> Node:
13691:   Node t = oNodeNew( nt )
13701:   oNodeSetInt( t, qIdent, id )
13713:   >> t
13717:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
13717: EmitValue( Node decl ):
13719:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
13733: DeclareBuiltInFunc( int id ) >> Node:
13735:    Node decl = @newIdent( nBuiltInFunc, id )
13749:    oScopeDeclare( decl )
13755:    >> decl;
      
      
13759: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
13761:    mysystemId = oId_mysystem
      
         % install built-in types
13766:    FileType = @newType( nFileType, 4 )
13780:    IntegerType = @newType( nIntegerType, 4 )
13794:    BooleanType = @newType( nBooleanType, 1 )
13808:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
13822:    CharType = @newType( nCharType, 1 )
13836:    PCharType = @PointerTypeTo( CharType )
13847:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
13861:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
13875:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
13887:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
13901:    ShortStringType = @newType( nShortStringType, 256 )
13915:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
13927:    Node t
      
13927:    t = @newIdent( nTypeDecl, oId_File )
13940:    oNodeSet( t, qType, FileType )
13952:    oScopeDeclare( t )
      
13958:    t = @newIdent( nTypeDecl, oId_Integer )
13971:    oNodeSet( t, qType, IntegerType )
13983:    oScopeDeclare( t )
      
13989:    t = @newIdent( nTypeDecl, oId_Boolean )
14002:    oNodeSet( t, qType, BooleanType )
14014:    oScopeDeclare( t )
      
14020:    t = @newIdent( nTypeDecl, oId_Char )
14033:    oNodeSet( t, qType, CharType )
14045:    oScopeDeclare( t )
      
14051:    t = @newIdent( nTypeDecl, oId_Byte )
14064:    oNodeSet( t, qType, ByteType )
14076:    oScopeDeclare( t )
      
14082:    t = @newIdent( nTypeDecl, oId_Pointer )
14095:    oNodeSet( t, qType, UniversalPointerType )
14107:    oScopeDeclare( t )
      
14113:    t = @newIdent( nTypeDecl, oId_ShortString )
14126:    oNodeSet( t, qType, ShortStringType )
14138:    oScopeDeclare( t )
      
         % Built-in constants
      
14144:    t = @newIdent( nConst, oId_True )
14157:    oNodeSet( t, qType, BooleanType )
14169:    oNodeSetInt( t, qValue, 1 )
14181:    oScopeDeclare( t )
      
14187:    t = @newIdent( nConst, oId_False )
14200:    oNodeSet( t, qType, BooleanType )
14212:    oNodeSetInt( t, qValue, 0 )
14224:    oScopeDeclare( t )
      
14230:    t = @newIdent( nConst, oId_Nil )
14243:    oNodeSet( t, qType, UniversalPointerType )
14255:    oNodeSetInt( t, qValue, 0 )
14267:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
14273:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
14283:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
14293:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
14303:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
14314:    ;
      
14314: end
      
14314: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 13010
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3178
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3234
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 13338
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8578
1083: oInputChoice 1089
1085: oCall 8578
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8578
1177: oInputChoice 1183
1179: oCall 8578
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13651
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 11333
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 13689
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 21
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 21
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 21
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 13639
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 12736
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 5
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          70   1755
          69   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 22
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 13314
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 5
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 13689
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 21
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 21
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 13639
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 12736
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 12
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 11657
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 12736
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 5
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          70   2190
          69   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 22
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 13314
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 5
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          33   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 24
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 13689
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 34
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          13   2366
          12   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 11657
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 12736
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           5   2504
          15   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          14   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2654
2528: oJumpForward 2535
2530: Choice Lookup Table
          12   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 6
2554: oCall 3533
2556: oTypeSNodeType
2557: oChoice 2613
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 13689
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2632
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 18
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 13689
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 33
2605: oPushResult
2606: oValueTopString
2607: oPushResult
2608: oNodeSetString
2609: oPop 3
2611: oJumpForward 2632
2613: Choice Lookup Table
          39   2586
          35   2559
          34   2559
          41   2559
          29   2559
          33   2559
          30   2559
          31   2559
2630: oError 17
2632: oValuePop
2633: oGetLocal 2
2635: oPushResult
2636: oSetResult 21
2638: oPushResult
2639: oTypeSTop
2640: oPushResult
2641: oNodeSet
2642: oPop 3
2644: oTypeSPop
2645: oGetLocal 2
2647: oPushResult
2648: oScopeDeclare
2649: oPop 1
2651: oInput 5
2653: oReturn
2654: oLocalSpace 3
2656: oGetAddrLocal 1
2658: oPushResult
2659: oSetResult 25
2661: oPushResult
2662: LAST_ID
2663: oPushResult
2664: oCall 13689
2666: oPop 2
2668: oAssign
2669: oGetAddrLocal 2
2671: oPushResult
2672: oCall 11657
2674: oPop 1
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 21
2681: oPushResult
2682: oGetLocal 2
2684: oPushResult
2685: oNodeSet
2686: oPop 3
2688: oGetLocal 2
2690: oPushResult
2691: oNodeType
2692: oPop 1
2694: oChoice 2798
2696: oInput 6
2698: oGetLocal 2
2700: oPushResult
2701: oTypeSPush
2702: oPop 1
2704: oCall 3533
2706: oCall 4300
2708: oGetLocal 1
2710: oPushResult
2711: oSetResult 22
2713: oPushResult
2714: oValueTop
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oValuePop
2720: oTypeSPop
2721: oGetLocal 1
2723: oPushResult
2724: oScopeDeclare
2725: oPop 1
2727: oInput 5
2729: oJumpForward 2822
2731: oError 16
2733: oJumpForward 2822
2735: oGetGlobal 2
2737: oPushResult
2738: oScopeEnter
2739: oPop 1
2741: oGetAddrLocal 3
2743: oPushResult
2744: oGetLocal 2
2746: oPushResult
2747: oScopeAllocType
2748: oPop 1
2750: oAssign
2751: oScopeEnd
2752: oGetGlobal 2
2754: oPushResult
2755: oCall 13587
2757: oPop 1
2759: oPushResult
2760: oCodePush
2761: oPop 1
2763: oGetLocal 1
2765: oPushResult
2766: oSetResult 22
2768: oPushResult
2769: oGetLocal 3
2771: oPushResult
2772: oNodeSetInt
2773: oPop 3
2775: oInput 6
2777: oGetLocal 2
2779: oPushResult
2780: oGetLocal 3
2782: oPushResult
2783: oCall 2823
2785: oPop 2
2787: oCodePop
2788: oGetLocal 1
2790: oPushResult
2791: oScopeDeclare
2792: oPop 1
2794: oInput 5
2796: oJumpForward 2822
2798: Choice Lookup Table
          38   2735
          36   2735
          28   2731
          40   2731
          35   2696
          34   2696
          41   2696
          29   2696
          33   2696
          30   2696
          31   2696
2821: oEndChoice
2822: oReturn
2823: oLocalSpace 10
2825: oGetParam 2
2827: oPushResult
2828: oNodeType
2829: oPop 1
2831: oChoice 3153
2833: oGetAddrLocal 1
2835: oPushResult
2836: oGetParam 2
2838: oPushResult
2839: oSetResult 37
2841: oPushResult
2842: oNodeGet
2843: oPop 2
2845: oAssign
2846: oGetAddrLocal 2
2848: oPushResult
2849: oGetParam 2
2851: oPushResult
2852: oSetResult 38
2854: oPushResult
2855: oNodeGet
2856: oPop 2
2858: oAssign
2859: oGetAddrLocal 3
2861: oPushResult
2862: oGetLocal 2
2864: oPushResult
2865: oCall 12820
2867: oPop 1
2869: oAssign
2870: oGetAddrLocal 4
2872: oPushResult
2873: oGetLocal 2
2875: oPushResult
2876: oCall 12915
2878: oPop 1
2880: oAssign
2881: oGetAddrLocal 5
2883: oPushResult
2884: oGetLocal 1
2886: oPushResult
2887: oSetResult 17
2889: oPushResult
2890: oNodeGetInt
2891: oPop 2
2893: oAssign
2894: oInput 14
2896: oGetAddrLocal 6
2898: oPushResult
2899: oGetLocal 3
2901: oAssign
2902: oGetLocal 1
2904: oPushResult
2905: oGetParam 1
2907: oPushResult
2908: oCall 2823
2910: oPop 2
2912: oGetLocal 6
2914: oPushResult
2915: oGetLocal 4
2917: oPushResult
2918: equal
2919: oPop 2
2921: oChoice 2929
2923: oJumpForward 2958
2925: oJumpForward 2935
2927: oJumpForward 2935
2929: Choice Lookup Table
           0   2927
           1   2923
2934: oEndChoice
2935: oInput 13
2937: oGetAddrParam 1
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oGetLocal 5
2945: oPushResult
2946: add
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 6
2952: oPushResult
2953: inc
2954: oPop 1
2956: oJumpBack 2902
2958: oInput 15
2960: oJumpForward 3177
2962: oInput 14
2964: oGetAddrLocal 7
2966: oPushResult
2967: oGetParam 2
2969: oPushResult
2970: oSetResult 41
2972: oPushResult
2973: oNodeGet
2974: oPop 2
2976: oAssign
2977: oInputChoice 2981
2979: oJumpForward 2986
2981: Choice Lookup Table
           0   2979
2984: oJumpForward 3052
2986: oGetAddrLocal 8
2988: oPushResult
2989: oGetLocal 7
2991: oPushResult
2992: oScopeFindRequireInScope
2993: oPop 1
2995: oAssign
2996: oInput 12
2998: oGetAddrLocal 9
3000: oPushResult
3001: oGetLocal 8
3003: oPushResult
3004: oSetResult 21
3006: oPushResult
3007: oNodeGet
3008: oPop 2
3010: oAssign
3011: oGetAddrLocal 10
3013: oPushResult
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 8
3019: oPushResult
3020: oSetResult 22
3022: oPushResult
3023: oNodeGetInt
3024: oPop 2
3026: oPushResult
3027: add
3028: oPop 2
3030: oAssign
3031: oGetLocal 9
3033: oPushResult
3034: oGetLocal 10
3036: oPushResult
3037: oCall 2823
3039: oPop 2
3041: oInputChoice 3045
3043: oJumpForward 3050
3045: Choice Lookup Table
           5   3043
3048: oJumpForward 3052
3050: oJumpBack 2977
3052: oInput 15
3054: oJumpForward 3177
3056: oEmit 16
3058: oGetParam 1
3060: oPushResult
3061: oEmitInt
3062: oPop 1
3064: oGetParam 2
3066: oPushResult
3067: oTypeSPush
3068: oPop 1
3070: oCall 3533
3072: oCall 4300
3074: oEmit 15
3076: oValueTop
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oValuePop
3082: oTypeSPop
3083: oEmit 27
3085: oJumpForward 3177
3087: oEmit 16
3089: oGetParam 1
3091: oPushResult
3092: oEmitInt
3093: oPop 1
3095: oGetParam 2
3097: oPushResult
3098: oTypeSPush
3099: oPop 1
3101: oCall 3533
3103: oCall 4300
3105: oEmit 15
3107: oValueTop
3108: oPushResult
3109: oEmitInt
3110: oPop 1
3112: oValuePop
3113: oTypeSPop
3114: oEmit 26
3116: oJumpForward 3177
3118: oEmit 16
3120: oGetParam 1
3122: oPushResult
3123: oEmitInt
3124: oPop 1
3126: oGetParam 2
3128: oPushResult
3129: oTypeSPush
3130: oPop 1
3132: oCall 3533
3134: oCall 4300
3136: oEmit 15
3138: oValueTop
3139: oPushResult
3140: oEmitInt
3141: oPop 1
3143: oValuePop
3144: oTypeSPop
3145: oEmit 28
3147: oJumpForward 3177
3149: oError 16
3151: oJumpForward 3177
3153: Choice Lookup Table
          28   3149
          40   3149
          35   3118
          34   3118
          41   3087
          29   3087
          33   3056
          30   3056
          31   3056
          38   2962
          36   2833
3176: oEndChoice
3177: oReturn
3178: oLocalSpace 2
3180: oInputChoice 3226
3182: oGetAddrLocal 1
3184: oPushResult
3185: oSetResult 19
3187: oPushResult
3188: LAST_ID
3189: oPushResult
3190: oCall 13689
3192: oPop 2
3194: oAssign
3195: oInput 6
3197: oGetAddrLocal 2
3199: oPushResult
3200: oCall 11657
3202: oPop 1
3204: oGetLocal 1
3206: oPushResult
3207: oSetResult 21
3209: oPushResult
3210: oGetLocal 2
3212: oPushResult
3213: oNodeSet
3214: oPop 3
3216: oGetLocal 1
3218: oPushResult
3219: oScopeDeclare
3220: oPop 1
3222: oInput 5
3224: oJumpForward 3231
3226: Choice Lookup Table
           0   3182
3229: oJumpForward 3233
3231: oJumpBack 3180
3233: oReturn
3234: oLocalSpace 6
3236: oInputChoice 3460
3238: oGetAddrLocal 1
3240: oPushResult
3241: oNodeVecNew
3242: oAssign
3243: oGetAddrLocal 2
3245: oPushResult
3246: oGetParam 1
3248: oPushResult
3249: LAST_ID
3250: oPushResult
3251: oCall 13689
3253: oPop 2
3255: oAssign
3256: oGetLocal 1
3258: oPushResult
3259: oGetLocal 2
3261: oPushResult
3262: oNodeVecAppend
3263: oPop 2
3265: oInputChoice 3271
3267: oInput 0
3269: oJumpForward 3276
3271: Choice Lookup Table
          13   3267
3274: oJumpForward 3278
3276: oJumpBack 3243
3278: oInput 12
3280: oGetAddrLocal 3
3282: oPushResult
3283: oCall 11657
3285: oPop 1
3287: oGetAddrLocal 4
3289: oPushResult
3290: oSetResult 0
3292: oAssign
3293: oGetLocal 4
3295: oPushResult
3296: oGetLocal 1
3298: oPushResult
3299: oNodeVecSize
3300: oPop 1
3302: oPushResult
3303: equal
3304: oPop 2
3306: oChoice 3347
3308: oGetAddrLocal 2
3310: oPushResult
3311: oGetLocal 1
3313: oPushResult
3314: oGetLocal 4
3316: oPushResult
3317: oNodeVecElement
3318: oPop 2
3320: oAssign
3321: oGetLocal 2
3323: oPushResult
3324: oSetResult 21
3326: oPushResult
3327: oGetLocal 3
3329: oPushResult
3330: oNodeSet
3331: oPop 3
3333: oGetLocal 2
3335: oPushResult
3336: oScopeDeclareAlloc
3337: oPop 1
3339: oGetAddrLocal 4
3341: oPushResult
3342: inc
3343: oPop 1
3345: oJumpForward 3352
3347: Choice Lookup Table
           0   3308
3350: oJumpForward 3354
3352: oJumpBack 3293
3354: oInputChoice 3447
3356: oGetLocal 1
3358: oPushResult
3359: oNodeVecSize
3360: oPop 1
3362: oChoice 3366
3364: oJumpForward 3371
3366: Choice Lookup Table
           1   3364
3369: oError 22
3371: oGetAddrLocal 5
3373: oPushResult
3374: oScopeCurrent
3375: oPushResult
3376: oCall 13587
3378: oPop 1
3380: oAssign
3381: oGetLocal 5
3383: oPushResult
3384: oCodePush
3385: oPop 1
3387: oGetAddrLocal 6
3389: oPushResult
3390: oSetResult 0
3392: oAssign
3393: oCall 13639
3395: oPushResult
3396: equal_zero
3397: oPop 1
3399: oChoice 3415
3401: oGetGlobal 3
3403: oPushResult
3404: oScopeEnter
3405: oPop 1
3407: oGetAddrLocal 6
3409: oPushResult
3410: oSetResult 1
3412: oAssign
3413: oJumpForward 3418
3415: Choice Lookup Table
           1   3401
3418: oGetLocal 2
3420: oPushResult
3421: oSetResult 1
3423: oPushResult
3424: oCall 9264
3426: oPop 2
3428: oCall 4787
3430: oCall 8063
3432: oCall 8824
3434: oGetLocal 6
3436: oChoice 3441
3438: oScopeEnd
3439: oJumpForward 3444
3441: Choice Lookup Table
           1   3438
3444: oCodePop
3445: oJumpForward 3450
3447: Choice Lookup Table
           6   3356
3450: oGetLocal 1
3452: oPushResult
3453: oNodeVecDelete
3454: oPop 1
3456: oInput 5
3458: oJumpForward 3465
3460: Choice Lookup Table
           0   3238
3463: oJumpForward 3467
3465: oJumpBack 3236
3467: oReturn
3468: oLocalSpace 2
3470: oInputChoice 3477
3472: oJumpForward 3483
3474: oChangeIntLitToLabelIdent
3475: oJumpForward 3483
3477: Choice Lookup Table
           1   3474
           0   3472
3482: oEndChoice
3483: oGetAddrLocal 1
3485: oPushResult
3486: oSetResult 26
3488: oPushResult
3489: LAST_ID
3490: oPushResult
3491: oCall 13689
3493: oPop 2
3495: oAssign
3496: oGetAddrLocal 2
3498: oPushResult
3499: oLabelNew
3500: oAssign
3501: oGetLocal 1
3503: oPushResult
3504: oSetResult 22
3506: oPushResult
3507: oGetLocal 2
3509: oPushResult
3510: oNodeSetLabel
3511: oPop 3
3513: oGetLocal 1
3515: oPushResult
3516: oScopeDeclare
3517: oPop 1
3519: oInputChoice 3523
3521: oJumpForward 3528
3523: Choice Lookup Table
          13   3521
3526: oJumpForward 3530
3528: oJumpBack 3470
3530: oInput 5
3532: oReturn
3533: oLocalSpace 0
3535: oCall 3737
3537: oInputChoice 3719
3539: oCall 3760
3541: oCall 4203
3543: oTypeSNodeType
3544: oChoice 3556
3546: oValueStringCmp
3547: oSetResult 0
3549: oPushResult
3550: oValuePush
3551: oPop 1
3553: oValueEqual
3554: oJumpForward 3560
3556: Choice Lookup Table
          39   3546
3559: oValueEqual
3560: oTypeSPop
3561: oGetGlobal 7
3563: oPushResult
3564: oTypeSPush
3565: oPop 1
3567: oJumpForward 3734
3569: oCall 3737
3571: oCall 4203
3573: oTypeSNodeType
3574: oChoice 3586
3576: oValueStringCmp
3577: oSetResult 0
3579: oPushResult
3580: oValuePush
3581: oPop 1
3583: oValueNotEqual
3584: oJumpForward 3590
3586: Choice Lookup Table
          39   3576
3589: oValueNotEqual
3590: oTypeSPop
3591: oGetGlobal 7
3593: oPushResult
3594: oTypeSPush
3595: oPop 1
3597: oJumpForward 3734
3599: oCall 3737
3601: oCall 4203
3603: oTypeSNodeType
3604: oChoice 3616
3606: oValueStringCmp
3607: oSetResult 0
3609: oPushResult
3610: oValuePush
3611: oPop 1
3613: oValueLess
3614: oJumpForward 3620
3616: Choice Lookup Table
          39   3606
3619: oValueLess
3620: oTypeSPop
3621: oGetGlobal 7
3623: oPushResult
3624: oTypeSPush
3625: oPop 1
3627: oJumpForward 3734
3629: oCall 3737
3631: oCall 4203
3633: oTypeSNodeType
3634: oChoice 3646
3636: oValueStringCmp
3637: oSetResult 0
3639: oPushResult
3640: oValuePush
3641: oPop 1
3643: oValueGreater
3644: oJumpForward 3650
3646: Choice Lookup Table
          39   3636
3649: oValueGreater
3650: oTypeSPop
3651: oGetGlobal 7
3653: oPushResult
3654: oTypeSPush
3655: oPop 1
3657: oJumpForward 3734
3659: oCall 3737
3661: oCall 4203
3663: oTypeSNodeType
3664: oChoice 3676
3666: oValueStringCmp
3667: oSetResult 0
3669: oPushResult
3670: oValuePush
3671: oPop 1
3673: oValueLessEqual
3674: oJumpForward 3680
3676: Choice Lookup Table
          39   3666
3679: oValueLessEqual
3680: oTypeSPop
3681: oGetGlobal 7
3683: oPushResult
3684: oTypeSPush
3685: oPop 1
3687: oJumpForward 3734
3689: oCall 3737
3691: oCall 4203
3693: oTypeSNodeType
3694: oChoice 3706
3696: oValueStringCmp
3697: oSetResult 0
3699: oPushResult
3700: oValuePush
3701: oPop 1
3703: oValueGreaterEqual
3704: oJumpForward 3710
3706: Choice Lookup Table
          39   3696
3709: oValueGreaterEqual
3710: oTypeSPop
3711: oGetGlobal 7
3713: oPushResult
3714: oTypeSPush
3715: oPop 1
3717: oJumpForward 3734
3719: Choice Lookup Table
          11   3689
          10   3659
           9   3629
           8   3599
           7   3569
           6   3539
3732: oJumpForward 3736
3734: oJumpBack 3537
3736: oReturn
3737: oLocalSpace 0
3739: oCall 3760
3741: oInputChoice 3752
3743: oCall 4190
3745: oCall 3760
3747: oCall 4176
3749: oValueOr
3750: oJumpForward 3757
3752: Choice Lookup Table
          57   3743
3755: oJumpForward 3759
3757: oJumpBack 3741
3759: oReturn
3760: oLocalSpace 0
3762: oCall 3783
3764: oInputChoice 3775
3766: oCall 4190
3768: oCall 3783
3770: oCall 4176
3772: oValueAnd
3773: oJumpForward 3780
3775: Choice Lookup Table
          56   3766
3778: oJumpForward 3782
3780: oJumpBack 3764
3782: oReturn
3783: oLocalSpace 0
3785: oInputChoice 3794
3787: oCall 3783
3789: oCall 4190
3791: oValueNot
3792: oJumpForward 3799
3794: Choice Lookup Table
          58   3787
3797: oCall 3800
3799: oReturn
3800: oLocalSpace 0
3802: oCall 3849
3804: oInputChoice 3839
3806: oCall 3849
3808: oCall 4203
3810: oTypeSNodeType
3811: oChoice 3816
3813: oValueStringConcat
3814: oJumpForward 3820
3816: Choice Lookup Table
          39   3813
3819: oValueAdd
3820: oJumpForward 3846
3822: oCall 3849
3824: oCall 4203
3826: oTypeSNodeType
3827: oChoice 3833
3829: oError 17
3831: oJumpForward 3837
3833: Choice Lookup Table
          39   3829
3836: oValueSub
3837: oJumpForward 3846
3839: Choice Lookup Table
          25   3822
          24   3806
3844: oJumpForward 3848
3846: oJumpBack 3804
3848: oReturn
3849: oLocalSpace 0
3851: oCall 3899
3853: oInputChoice 3889
3855: oCall 3899
3857: oCall 4203
3859: oTypeSNodeType
3860: oChoice 3866
3862: oError 17
3864: oJumpForward 3870
3866: Choice Lookup Table
          39   3862
3869: oValueMult
3870: oJumpForward 3896
3872: oCall 3899
3874: oCall 4203
3876: oTypeSNodeType
3877: oChoice 3883
3879: oError 17
3881: oJumpForward 3887
3883: Choice Lookup Table
          39   3879
3886: oValueDiv
3887: oJumpForward 3896
3889: Choice Lookup Table
          23   3872
          22   3855
3894: oJumpForward 3898
3896: oJumpBack 3853
3898: oReturn
3899: oLocalSpace 0
3901: oInputChoice 3912
3903: oCall 3920
3905: oJumpForward 3919
3907: oCall 3920
3909: oValueNegate
3910: oJumpForward 3919
3912: Choice Lookup Table
          25   3907
          24   3903
3917: oCall 3920
3919: oReturn
3920: oLocalSpace 1
3922: oInputChoice 4148
3924: TOKEN_VALUE
3925: oPushResult
3926: oValuePush
3927: oPop 1
3929: oGetGlobal 6
3931: oPushResult
3932: oTypeSPush
3933: oPop 1
3935: oJumpForward 4175
3937: TOKEN_VALUE
3938: oPushResult
3939: oValuePush
3940: oPop 1
3942: oGetGlobal 9
3944: oPushResult
3945: oTypeSPush
3946: oPop 1
3948: oJumpForward 4175
3950: CURRENT_STRLIT
3951: oPushResult
3952: oValuePushString
3953: oPop 1
3955: oGetGlobal 13
3957: oPushResult
3958: oTypeSPush
3959: oPop 1
3961: oJumpForward 4175
3963: oCall 3533
3965: oInput 15
3967: oJumpForward 4175
3969: oGetAddrLocal 1
3971: oPushResult
3972: oScopeFindRequire
3973: oAssign
3974: oGetAddrLocal 1
3976: oPushResult
3977: oCall 244
3979: oPop 1
3981: oGetLocal 1
3983: oPushResult
3984: oNodeType
3985: oPop 1
3987: oChoice 4105
3989: oGetLocal 1
3991: oPushResult
3992: oCall 4570
3994: oPop 1
3996: oJumpForward 4130
3998: oGetLocal 1
4000: oPushResult
4001: oSetResult 22
4003: oPushResult
4004: oNodeGetInt
4005: oPop 2
4007: oPushResult
4008: oValuePush
4009: oPop 1
4011: oGetLocal 1
4013: oPushResult
4014: oSetResult 21
4016: oPushResult
4017: oNodeGet
4018: oPop 2
4020: oPushResult
4021: oTypeSPush
4022: oPop 1
4024: oJumpForward 4130
4026: oGetLocal 1
4028: oPushResult
4029: oSetResult 33
4031: oPushResult
4032: oNodeGetString
4033: oPop 2
4035: oPushResult
4036: oValuePushString
4037: oPop 1
4039: oGetLocal 1
4041: oPushResult
4042: oSetResult 21
4044: oPushResult
4045: oNodeGet
4046: oPop 2
4048: oPushResult
4049: oTypeSPush
4050: oPop 1
4052: oJumpForward 4130
4054: oGetLocal 1
4056: oPushResult
4057: oSetResult 22
4059: oPushResult
4060: oNodeGetInt
4061: oPop 2
4063: oPushResult
4064: oValuePush
4065: oPop 1
4067: oGetLocal 1
4069: oPushResult
4070: oSetResult 21
4072: oPushResult
4073: oNodeGet
4074: oPop 2
4076: oPushResult
4077: oTypeSPush
4078: oPop 1
4080: oJumpForward 4130
4082: oGetLocal 1
4084: oPushResult
4085: oSetResult 21
4087: oPushResult
4088: oNodeGet
4089: oPop 2
4091: oPushResult
4092: oTypeSPush
4093: oPop 1
4095: oInput 14
4097: oCall 3533
4099: oInput 15
4101: oCall 4421
4103: oJumpForward 4130
4105: Choice Lookup Table
          19   4082
          17   4054
          18   4026
          16   3998
          14   3989
4116: oError 1
4118: oSetResult 0
4120: oPushResult
4121: oValuePush
4122: oPop 1
4124: oGetGlobal 6
4126: oPushResult
4127: oTypeSPush
4128: oPop 1
4130: oJumpForward 4175
4132: oError 16
4134: oSetResult 0
4136: oPushResult
4137: oValuePush
4138: oPop 1
4140: oGetGlobal 12
4142: oPushResult
4143: oTypeSPush
4144: oPop 1
4146: oJumpForward 4175
4148: Choice Lookup Table
          19   4132
           0   3969
          14   3963
           2   3950
           3   3937
           1   3924
4161: oError 1
4163: oSetResult 0
4165: oPushResult
4166: oValuePush
4167: oPop 1
4169: oGetGlobal 6
4171: oPushResult
4172: oTypeSPush
4173: oPop 1
4175: oReturn
4176: oLocalSpace 0
4178: oTypeSNodeType
4179: oChoice 4183
4181: oJumpForward 4188
4183: Choice Lookup Table
          31   4181
4186: oError 8
4188: oTypeSPop
4189: oReturn
4190: oLocalSpace 0
4192: oTypeSNodeType
4193: oChoice 4197
4195: oJumpForward 4202
4197: Choice Lookup Table
          31   4195
4200: oError 8
4202: oReturn
4203: oLocalSpace 1
4205: oGetAddrLocal 1
4207: oPushResult
4208: oTypeSNodeType
4209: oAssign
4210: oTypeSPop
4211: oGetLocal 1
4213: oPushResult
4214: oTypeSNodeType
4215: oPushResult
4216: equal_node_type
4217: oPop 2
4219: oChoice 4296
4221: oTypeSNodeType
4222: oChoice 4283
4224: oGetLocal 1
4226: oChoice 4231
4228: oReturn
4229: oJumpForward 4234
4231: Choice Lookup Table
          35   4228
4234: oJumpForward 4292
4236: oGetLocal 1
4238: oChoice 4243
4240: oReturn
4241: oJumpForward 4246
4243: Choice Lookup Table
          34   4240
4246: oJumpForward 4292
4248: oGetLocal 1
4250: oChoice 4256
4252: oValueCharToString
4253: oReturn
4254: oJumpForward 4259
4256: Choice Lookup Table
          33   4252
4259: oJumpForward 4292
4261: oGetLocal 1
4263: oChoice 4278
4265: oValueSwap
4266: oValueCharToString
4267: oValueSwap
4268: oTypeSPop
4269: oGetGlobal 13
4271: oPushResult
4272: oTypeSPush
4273: oPop 1
4275: oReturn
4276: oJumpForward 4281
4278: Choice Lookup Table
          39   4265
4281: oJumpForward 4292
4283: Choice Lookup Table
          33   4261
          39   4248
          35   4236
          34   4224
4292: oError 14
4294: oJumpForward 4299
4296: Choice Lookup Table
           0   4221
4299: oReturn
4300: oLocalSpace 1
4302: oGetAddrLocal 1
4304: oPushResult
4305: oTypeSNodeType
4306: oAssign
4307: oTypeSPop
4308: oGetLocal 1
4310: oPushResult
4311: oTypeSNodeType
4312: oPushResult
4313: equal_node_type
4314: oPop 2
4316: oChoice 4417
4318: oTypeSNodeType
4319: oChoice 4400
4321: oGetLocal 1
4323: oChoice 4328
4325: oReturn
4326: oJumpForward 4331
4328: Choice Lookup Table
          30   4325
4331: oJumpForward 4413
4333: oGetLocal 1
4335: oChoice 4340
4337: oReturn
4338: oJumpForward 4343
4340: Choice Lookup Table
          29   4337
4343: oJumpForward 4413
4345: oGetLocal 1
4347: oChoice 4352
4349: oReturn
4350: oJumpForward 4355
4352: Choice Lookup Table
          35   4349
4355: oJumpForward 4413
4357: oGetLocal 1
4359: oChoice 4364
4361: oReturn
4362: oJumpForward 4367
4364: Choice Lookup Table
          34   4361
4367: oJumpForward 4413
4369: oGetLocal 1
4371: oChoice 4377
4373: oValueCharToString
4374: oReturn
4375: oJumpForward 4380
4377: Choice Lookup Table
          33   4373
4380: oJumpForward 4413
4382: oGetLocal 1
4384: oChoice 4393
4386: oReturn
4387: oJumpForward 4398
4389: oValueCharToString
4390: oReturn
4391: oJumpForward 4398
4393: Choice Lookup Table
          33   4389
          39   4386
4398: oJumpForward 4413
4400: Choice Lookup Table
          40   4382
          39   4369
          35   4357
          34   4345
          30   4333
          29   4321
4413: oError 14
4415: oJumpForward 4420
4417: Choice Lookup Table
           0   4318
4420: oReturn
4421: oLocalSpace 1
4423: oGetAddrLocal 1
4425: oPushResult
4426: oTypeSNodeType
4427: oAssign
4428: oTypeSPop
4429: oGetLocal 1
4431: oPushResult
4432: oTypeSNodeType
4433: oPushResult
4434: equal_node_type
4435: oPop 2
4437: oChoice 4566
4439: oTypeSNodeType
4440: oChoice 4543
4442: oGetLocal 1
4444: oChoice 4452
4446: oReturn
4447: oJumpForward 4463
4449: oReturn
4450: oJumpForward 4463
4452: Choice Lookup Table
          41   4449
          29   4449
          31   4446
          33   4446
          30   4446
4463: oJumpForward 4562
4465: oGetLocal 1
4467: oChoice 4475
4469: oReturn
4470: oJumpForward 4486
4472: oReturn
4473: oJumpForward 4486
4475: Choice Lookup Table
          41   4472
          29   4472
          31   4469
          33   4469
          30   4469
4486: oJumpForward 4562
4488: oGetLocal 1
4490: oChoice 4495
4492: oReturn
4493: oJumpForward 4498
4495: Choice Lookup Table
          35   4492
4498: oJumpForward 4562
4500: oGetLocal 1
4502: oChoice 4507
4504: oReturn
4505: oJumpForward 4510
4507: Choice Lookup Table
          34   4504
4510: oJumpForward 4562
4512: oGetLocal 1
4514: oChoice 4520
4516: oValueCharToString
4517: oReturn
4518: oJumpForward 4523
4520: Choice Lookup Table
          33   4516
4523: oJumpForward 4562
4525: oGetLocal 1
4527: oChoice 4536
4529: oReturn
4530: oJumpForward 4541
4532: oValueCharToString
4533: oReturn
4534: oJumpForward 4541
4536: Choice Lookup Table
          33   4532
          39   4529
4541: oJumpForward 4562
4543: Choice Lookup Table
          40   4525
          39   4512
          35   4500
          34   4488
          31   4465
          33   4465
          30   4465
          41   4442
          29   4442
4562: oError 14
4564: oJumpForward 4569
4566: Choice Lookup Table
           0   4439
4569: oReturn
4570: oLocalSpace 0
4572: oGetParam 1
4574: oPushResult
4575: oGetGlobal 15
4577: oPushResult
4578: oNodeEqual
4579: oPop 2
4581: oChoice 4621
4583: oInput 14
4585: oCall 3533
4587: oInput 15
4589: oTypeSNodeType
4590: oChoice 4596
4592: oJumpForward 4609
4594: oJumpForward 4609
4596: Choice Lookup Table
          33   4594
          30   4594
          31   4594
          41   4592
          29   4592
4607: oError 14
4609: oTypeSPop
4610: oGetGlobal 6
4612: oPushResult
4613: oTypeSPush
4614: oPop 1
4616: oInput 15
4618: oReturn
4619: oJumpForward 4624
4621: Choice Lookup Table
           1   4583
4624: oGetParam 1
4626: oPushResult
4627: oGetGlobal 16
4629: oPushResult
4630: oNodeEqual
4631: oPop 2
4633: oChoice 4667
4635: oInput 14
4637: oCall 3533
4639: oInput 15
4641: oTypeSNodeType
4642: oChoice 4648
4644: oJumpForward 4655
4646: oJumpForward 4655
4648: Choice Lookup Table
          30   4646
          29   4644
4653: oError 14
4655: oTypeSPop
4656: oGetGlobal 9
4658: oPushResult
4659: oTypeSPush
4660: oPop 1
4662: oInput 15
4664: oReturn
4665: oJumpForward 4670
4667: Choice Lookup Table
           1   4635
4670: oGetParam 1
4672: oPushResult
4673: oGetGlobal 17
4675: oPushResult
4676: oNodeEqual
4677: oPop 2
4679: oChoice 4724
4681: oInput 14
4683: oCall 3533
4685: oTypeSNodeType
4686: oChoice 4707
4688: oTypeSTop
4689: oPushResult
4690: oSetResult 44
4692: oPushResult
4693: oNodeGetBoolean
4694: oPop 2
4696: oChoice 4702
4698: oError 28
4700: oJumpForward 4705
4702: Choice Lookup Table
           1   4698
4705: oJumpForward 4712
4707: Choice Lookup Table
          41   4688
4710: oError 14
4712: oSetResult 1
4714: oPushResult
4715: oValuePush
4716: oPop 1
4718: oValueSub
4719: oInput 15
4721: oReturn
4722: oJumpForward 4727
4724: Choice Lookup Table
           1   4681
4727: oGetParam 1
4729: oPushResult
4730: oGetGlobal 18
4732: oPushResult
4733: oNodeEqual
4734: oPop 2
4736: oChoice 4781
4738: oInput 14
4740: oCall 3533
4742: oTypeSNodeType
4743: oChoice 4764
4745: oTypeSTop
4746: oPushResult
4747: oSetResult 44
4749: oPushResult
4750: oNodeGetBoolean
4751: oPop 2
4753: oChoice 4759
4755: oError 28
4757: oJumpForward 4762
4759: Choice Lookup Table
           1   4755
4762: oJumpForward 4769
4764: Choice Lookup Table
          41   4745
4767: oError 14
4769: oSetResult 1
4771: oPushResult
4772: oValuePush
4773: oPop 1
4775: oValueAdd
4776: oInput 15
4778: oReturn
4779: oJumpForward 4784
4781: Choice Lookup Table
           1   4738
4784: oError 16
4786: oReturn
4787: oLocalSpace 1
4789: oGetAddrLocal 1
4791: oPushResult
4792: oSetResult 0
4794: oAssign
4795: oGetAddrLocal 1
4797: oPushResult
4798: oCall 4948
4800: oPop 1
4802: oGetAddrLocal 1
4804: oPushResult
4805: oCall 4848
4807: oPop 1
4809: oReturn
4810: oLocalSpace 0
4812: oGetParam 1
4814: oPushResult
4815: oCall 4948
4817: oPop 1
4819: oTypeSNodeType
4820: oChoice 4839
4822: oJumpForward 4846
4824: oGetParam 1
4826: oPushResult
4827: oLabelNew
4828: oAssign
4829: oEmit 70
4831: oGetFromParam 1
4833: oPushResult
4834: oEmitLabel
4835: oPop 1
4837: oJumpForward 4846
4839: Choice Lookup Table
          31   4824
          32   4822
4844: oError 8
4846: oTypeSPop
4847: oReturn
4848: oLocalSpace 1
4850: oTypeSNodeType
4851: oChoice 4913
4853: oGetAddrLocal 1
4855: oPushResult
4856: oLabelNew
4857: oAssign
4858: oEmit 15
4860: oSetResult 1
4862: oPushResult
4863: oEmitInt
4864: oPop 1
4866: oEmit 68
4868: oGetLocal 1
4870: oPushResult
4871: oEmitLabel
4872: oPop 1
4874: oEmit 77
4876: oGetFromParam 1
4878: oPushResult
4879: oEmitLabel
4880: oPop 1
4882: oEmit 15
4884: oSetResult 0
4886: oPushResult
4887: oEmitInt
4888: oPop 1
4890: oEmit 77
4892: oGetLocal 1
4894: oPushResult
4895: oEmitLabel
4896: oPop 1
4898: oTypeSPop
4899: oGetGlobal 7
4901: oPushResult
4902: oTypeSPush
4903: oPop 1
4905: oGetParam 1
4907: oPushResult
4908: oSetResult 0
4910: oAssign
4911: oJumpForward 4916
4913: Choice Lookup Table
          32   4853
4916: oReturn
4917: oLocalSpace 0
4919: oTypeSNodeType
4920: oChoice 4944
4922: oGetParam 1
4924: oPushResult
4925: oLabelNew
4926: oAssign
4927: oEmit 70
4929: oGetFromParam 1
4931: oPushResult
4932: oEmitLabel
4933: oPop 1
4935: oTypeSPop
4936: oGetGlobal 8
4938: oPushResult
4939: oTypeSPush
4940: oPop 1
4942: oJumpForward 4947
4944: Choice Lookup Table
          31   4922
4947: oReturn
4948: oLocalSpace 0
4950: oGetParam 1
4952: oPushResult
4953: oCall 5481
4955: oPop 1
4957: oInputChoice 5463
4959: oGetParam 1
4961: oPushResult
4962: oCall 4848
4964: oPop 1
4966: oCall 8531
4968: oGetParam 1
4970: oPushResult
4971: oCall 5481
4973: oPop 1
4975: oGetParam 1
4977: oPushResult
4978: oCall 4848
4980: oPop 1
4982: oCall 8531
4984: oCall 8400
4986: oTypeSNodeType
4987: oChoice 5015
4989: oEmit 43
4991: oJumpForward 5034
4993: oEmit 49
4995: oJumpForward 5034
4997: oEmit 55
4999: oJumpForward 5034
5001: oCall 10657
5003: oEmit 15
5005: oSetResult 0
5007: oPushResult
5008: oEmitInt
5009: oPop 1
5011: oEmit 49
5013: oJumpForward 5034
5015: Choice Lookup Table
          39   5001
          40   5001
          35   4997
          34   4997
          41   4993
          29   4993
          33   4989
          31   4989
5032: oError 17
5034: oTypeSPop
5035: oGetGlobal 7
5037: oPushResult
5038: oTypeSPush
5039: oPop 1
5041: oJumpForward 5478
5043: oGetParam 1
5045: oPushResult
5046: oCall 4848
5048: oPop 1
5050: oCall 8531
5052: oGetParam 1
5054: oPushResult
5055: oCall 5481
5057: oPop 1
5059: oGetParam 1
5061: oPushResult
5062: oCall 4848
5064: oPop 1
5066: oCall 8531
5068: oCall 8400
5070: oTypeSNodeType
5071: oChoice 5099
5073: oEmit 44
5075: oJumpForward 5118
5077: oEmit 50
5079: oJumpForward 5118
5081: oEmit 56
5083: oJumpForward 5118
5085: oCall 10657
5087: oEmit 15
5089: oSetResult 0
5091: oPushResult
5092: oEmitInt
5093: oPop 1
5095: oEmit 50
5097: oJumpForward 5118
5099: Choice Lookup Table
          39   5085
          40   5085
          35   5081
          34   5081
          41   5077
          29   5077
          33   5073
          31   5073
5116: oError 17
5118: oTypeSPop
5119: oGetGlobal 7
5121: oPushResult
5122: oTypeSPush
5123: oPop 1
5125: oJumpForward 5478
5127: oGetParam 1
5129: oPushResult
5130: oCall 4848
5132: oPop 1
5134: oCall 8531
5136: oGetParam 1
5138: oPushResult
5139: oCall 5481
5141: oPop 1
5143: oGetParam 1
5145: oPushResult
5146: oCall 4848
5148: oPop 1
5150: oCall 8531
5152: oCall 8400
5154: oTypeSNodeType
5155: oChoice 5183
5157: oEmit 46
5159: oJumpForward 5202
5161: oEmit 52
5163: oJumpForward 5202
5165: oEmit 58
5167: oJumpForward 5202
5169: oCall 10657
5171: oEmit 15
5173: oSetResult 0
5175: oPushResult
5176: oEmitInt
5177: oPop 1
5179: oEmit 52
5181: oJumpForward 5202
5183: Choice Lookup Table
          39   5169
          40   5169
          35   5165
          34   5165
          41   5161
          29   5161
          33   5157
          31   5157
5200: oError 17
5202: oTypeSPop
5203: oGetGlobal 7
5205: oPushResult
5206: oTypeSPush
5207: oPop 1
5209: oJumpForward 5478
5211: oGetParam 1
5213: oPushResult
5214: oCall 4848
5216: oPop 1
5218: oCall 8531
5220: oGetParam 1
5222: oPushResult
5223: oCall 5481
5225: oPop 1
5227: oGetParam 1
5229: oPushResult
5230: oCall 4848
5232: oPop 1
5234: oCall 8531
5236: oCall 8400
5238: oTypeSNodeType
5239: oChoice 5267
5241: oEmit 45
5243: oJumpForward 5286
5245: oEmit 51
5247: oJumpForward 5286
5249: oEmit 57
5251: oJumpForward 5286
5253: oCall 10657
5255: oEmit 15
5257: oSetResult 0
5259: oPushResult
5260: oEmitInt
5261: oPop 1
5263: oEmit 51
5265: oJumpForward 5286
5267: Choice Lookup Table
          39   5253
          40   5253
          35   5249
          34   5249
          41   5245
          29   5245
          33   5241
          31   5241
5284: oError 17
5286: oTypeSPop
5287: oGetGlobal 7
5289: oPushResult
5290: oTypeSPush
5291: oPop 1
5293: oJumpForward 5478
5295: oGetParam 1
5297: oPushResult
5298: oCall 4848
5300: oPop 1
5302: oCall 8531
5304: oGetParam 1
5306: oPushResult
5307: oCall 5481
5309: oPop 1
5311: oGetParam 1
5313: oPushResult
5314: oCall 4848
5316: oPop 1
5318: oCall 8531
5320: oCall 8400
5322: oTypeSNodeType
5323: oChoice 5351
5325: oEmit 48
5327: oJumpForward 5370
5329: oEmit 54
5331: oJumpForward 5370
5333: oEmit 60
5335: oJumpForward 5370
5337: oCall 10657
5339: oEmit 15
5341: oSetResult 0
5343: oPushResult
5344: oEmitInt
5345: oPop 1
5347: oEmit 54
5349: oJumpForward 5370
5351: Choice Lookup Table
          39   5337
          40   5337
          35   5333
          34   5333
          41   5329
          29   5329
          33   5325
          31   5325
5368: oError 17
5370: oTypeSPop
5371: oGetGlobal 7
5373: oPushResult
5374: oTypeSPush
5375: oPop 1
5377: oJumpForward 5478
5379: oGetParam 1
5381: oPushResult
5382: oCall 4848
5384: oPop 1
5386: oCall 8531
5388: oGetParam 1
5390: oPushResult
5391: oCall 5481
5393: oPop 1
5395: oGetParam 1
5397: oPushResult
5398: oCall 4848
5400: oPop 1
5402: oCall 8531
5404: oCall 8400
5406: oTypeSNodeType
5407: oChoice 5435
5409: oEmit 47
5411: oJumpForward 5454
5413: oEmit 53
5415: oJumpForward 5454
5417: oEmit 59
5419: oJumpForward 5454
5421: oCall 10657
5423: oEmit 15
5425: oSetResult 0
5427: oPushResult
5428: oEmitInt
5429: oPop 1
5431: oEmit 53
5433: oJumpForward 5454
5435: Choice Lookup Table
          39   5421
          40   5421
          35   5417
          34   5417
          41   5413
          29   5413
          33   5409
          31   5409
5452: oError 17
5454: oTypeSPop
5455: oGetGlobal 7
5457: oPushResult
5458: oTypeSPush
5459: oPop 1
5461: oJumpForward 5478
5463: Choice Lookup Table
          11   5379
          10   5295
           9   5211
           8   5127
           7   5043
           6   4959
5476: oJumpForward 5480
5478: oJumpBack 4957
5480: oReturn
5481: oLocalSpace 1
5483: oGetAddrLocal 1
5485: oPushResult
5486: oSetResult 0
5488: oAssign
5489: oGetParam 1
5491: oPushResult
5492: oCall 5661
5494: oPop 1
5496: oInputChoice 5629
5498: oTypeSNodeType
5499: oChoice 5570
5501: oGetLocal 1
5503: oPushResult
5504: oSetResult 0
5506: oPushResult
5507: equal_label
5508: oPop 2
5510: oChoice 5519
5512: oGetAddrLocal 1
5514: oPushResult
5515: oLabelNew
5516: oAssign
5517: oJumpForward 5522
5519: Choice Lookup Table
           1   5512
5522: oEmit 68
5524: oGetLocal 1
5526: oPushResult
5527: oEmitLabel
5528: oPop 1
5530: oJumpForward 5577
5532: oGetParam 1
5534: oPushResult
5535: oCall 4917
5537: oPop 1
5539: oGetLocal 1
5541: oPushResult
5542: oSetResult 0
5544: oPushResult
5545: equal_label
5546: oPop 2
5548: oChoice 5557
5550: oGetAddrLocal 1
5552: oPushResult
5553: oLabelNew
5554: oAssign
5555: oJumpForward 5560
5557: Choice Lookup Table
           1   5550
5560: oEmit 68
5562: oGetLocal 1
5564: oPushResult
5565: oEmitLabel
5566: oPop 1
5568: oJumpForward 5577
5570: Choice Lookup Table
          31   5532
          32   5501
5575: oError 8
5577: oTypeSPop
5578: oEmit 77
5580: oGetFromParam 1
5582: oPushResult
5583: oEmitLabel
5584: oPop 1
5586: oGetParam 1
5588: oPushResult
5589: oSetResult 0
5591: oAssign
5592: oGetParam 1
5594: oPushResult
5595: oCall 5661
5597: oPop 1
5599: oTypeSNodeType
5600: oChoice 5613
5602: oJumpForward 5620
5604: oGetParam 1
5606: oPushResult
5607: oCall 4917
5609: oPop 1
5611: oJumpForward 5620
5613: Choice Lookup Table
          31   5604
          32   5602
5618: oError 8
5620: oTypeSPop
5621: oGetGlobal 8
5623: oPushResult
5624: oTypeSPush
5625: oPop 1
5627: oJumpForward 5634
5629: Choice Lookup Table
          57   5498
5632: oJumpForward 5636
5634: oJumpBack 5496
5636: oGetLocal 1
5638: oPushResult
5639: oSetResult 0
5641: oPushResult
5642: equal_label
5643: oPop 2
5645: oChoice 5657
5647: oEmit 77
5649: oGetLocal 1
5651: oPushResult
5652: oEmitLabel
5653: oPop 1
5655: oJumpForward 5660
5657: Choice Lookup Table
           0   5647
5660: oReturn
5661: oLocalSpace 2
5663: oGetAddrLocal 1
5665: oPushResult
5666: oSetResult 0
5668: oAssign
5669: oGetParam 1
5671: oPushResult
5672: oCall 5799
5674: oPop 1
5676: oInputChoice 5791
5678: oTypeSNodeType
5679: oChoice 5692
5681: oJumpForward 5699
5683: oGetParam 1
5685: oPushResult
5686: oCall 4917
5688: oPop 1
5690: oJumpForward 5699
5692: Choice Lookup Table
          31   5683
          32   5681
5697: oError 8
5699: oTypeSPop
5700: oGetLocal 1
5702: oPushResult
5703: oSetResult 0
5705: oPushResult
5706: equal_label
5707: oPop 2
5709: oChoice 5738
5711: oGetAddrLocal 1
5713: oPushResult
5714: oLabelNew
5715: oAssign
5716: oEmit 78
5718: oGetFromParam 1
5720: oPushResult
5721: oEmitLabel
5722: oPop 1
5724: oGetLocal 1
5726: oPushResult
5727: oEmitLabel
5728: oPop 1
5730: oGetParam 1
5732: oPushResult
5733: oGetLocal 1
5735: oAssign
5736: oJumpForward 5741
5738: Choice Lookup Table
           1   5711
5741: oGetAddrLocal 2
5743: oPushResult
5744: oSetResult 0
5746: oAssign
5747: oGetAddrLocal 2
5749: oPushResult
5750: oCall 5799
5752: oPop 1
5754: oTypeSNodeType
5755: oChoice 5768
5757: oJumpForward 5775
5759: oGetAddrLocal 2
5761: oPushResult
5762: oCall 4917
5764: oPop 1
5766: oJumpForward 5775
5768: Choice Lookup Table
          31   5759
          32   5757
5773: oError 8
5775: oEmit 78
5777: oGetLocal 2
5779: oPushResult
5780: oEmitLabel
5781: oPop 1
5783: oGetLocal 1
5785: oPushResult
5786: oEmitLabel
5787: oPop 1
5789: oJumpForward 5796
5791: Choice Lookup Table
          56   5678
5794: oJumpForward 5798
5796: oJumpBack 5676
5798: oReturn
5799: oLocalSpace 1
5801: oInputChoice 5855
5803: oGetAddrLocal 1
5805: oPushResult
5806: oSetResult 0
5808: oAssign
5809: oGetAddrLocal 1
5811: oPushResult
5812: oCall 5799
5814: oPop 1
5816: oTypeSNodeType
5817: oChoice 5846
5819: oGetParam 1
5821: oPushResult
5822: oLabelNew
5823: oAssign
5824: oEmit 68
5826: oGetFromParam 1
5828: oPushResult
5829: oEmitLabel
5830: oPop 1
5832: oEmit 77
5834: oGetLocal 1
5836: oPushResult
5837: oEmitLabel
5838: oPop 1
5840: oJumpForward 5853
5842: oEmit 42
5844: oJumpForward 5853
5846: Choice Lookup Table
          31   5842
          32   5819
5851: oError 8
5853: oJumpForward 5865
5855: Choice Lookup Table
          58   5803
5858: oGetParam 1
5860: oPushResult
5861: oCall 5866
5863: oPop 1
5865: oReturn
5866: oLocalSpace 2
5868: oGetAddrLocal 1
5870: oPushResult
5871: oSetResult 1
5873: oAssign
5874: oGetParam 1
5876: oPushResult
5877: oCall 6102
5879: oPop 1
5881: oInputChoice 6092
5883: oTypeSNodeType
5884: oChoice 6007
5886: oCall 8485
5888: oGetParam 1
5890: oPushResult
5891: oCall 6102
5893: oPop 1
5895: oTypeSNodeType
5896: oChoice 5904
5898: oEmit 22
5900: oCall 7848
5902: oJumpForward 5913
5904: Choice Lookup Table
          35   5898
          34   5898
5909: oCall 8505
5911: oEmit 37
5913: oJumpForward 6024
5915: oGetLocal 1
5917: oChoice 5933
5919: oGetAddrLocal 2
5921: oPushResult
5922: oCall 10440
5924: oAssign
5925: oGetAddrLocal 1
5927: oPushResult
5928: oSetResult 0
5930: oAssign
5931: oJumpForward 5936
5933: Choice Lookup Table
           1   5919
5936: oGetParam 1
5938: oPushResult
5939: oCall 6102
5941: oPop 1
5943: oTypeSNodeType
5944: oChoice 5982
5946: oCall 10549
5948: oEmit 17
5950: oGetLocal 2
5952: oPushResult
5953: oEmitInt
5954: oPop 1
5956: oGetGlobal 14
5958: oPushResult
5959: oTypeSPush
5960: oPop 1
5962: oJumpForward 5992
5964: oCall 10603
5966: oEmit 17
5968: oGetLocal 2
5970: oPushResult
5971: oEmitInt
5972: oPop 1
5974: oGetGlobal 14
5976: oPushResult
5977: oTypeSPush
5978: oPop 1
5980: oJumpForward 5992
5982: Choice Lookup Table
          33   5964
          39   5946
          40   5946
5989: oError 14
5991: oTypeSPop
5992: oJumpForward 6024
5994: oGetParam 1
5996: oPushResult
5997: oCall 6102
5999: oPop 1
6001: oCall 8485
6003: oCall 7848
6005: oJumpForward 6024
6007: Choice Lookup Table
          35   5994
          34   5994
          33   5915
          39   5915
          40   5915
          30   5886
          29   5886
6022: oError 17
6024: oJumpForward 6099
6026: oTypeSNodeType
6027: oChoice 6079
6029: oCall 8485
6031: oGetParam 1
6033: oPushResult
6034: oCall 6102
6036: oPop 1
6038: oCall 8505
6040: oEmit 40
6042: oJumpForward 6090
6044: oGetParam 1
6046: oPushResult
6047: oCall 6102
6049: oPop 1
6051: oTypeSNodeType
6052: oChoice 6066
6054: oCall 8485
6056: oCall 7904
6058: oJumpForward 6077
6060: oCall 8400
6062: oCall 7960
6064: oJumpForward 6077
6066: Choice Lookup Table
          35   6060
          34   6060
          30   6054
          29   6054
6075: oError 17
6077: oJumpForward 6090
6079: Choice Lookup Table
          35   6044
          34   6044
          30   6029
          29   6029
6088: oError 17
6090: oJumpForward 6099
6092: Choice Lookup Table
          25   6026
          24   5883
6097: oJumpForward 6101
6099: oJumpBack 5881
6101: oReturn
6102: oLocalSpace 0
6104: oGetParam 1
6106: oPushResult
6107: oCall 6153
6109: oPop 1
6111: oInputChoice 6143
6113: oCall 8485
6115: oGetParam 1
6117: oPushResult
6118: oCall 6153
6120: oPop 1
6122: oCall 8505
6124: oEmit 34
6126: oJumpForward 6150
6128: oCall 8485
6130: oGetParam 1
6132: oPushResult
6133: oCall 6153
6135: oPop 1
6137: oCall 8505
6139: oEmit 35
6141: oJumpForward 6150
6143: Choice Lookup Table
          23   6128
          22   6113
6148: oJumpForward 6152
6150: oJumpBack 6111
6152: oReturn
6153: oLocalSpace 0
6155: oInputChoice 6181
6157: oGetParam 1
6159: oPushResult
6160: oCall 6194
6162: oPop 1
6164: oCall 8505
6166: oJumpForward 6193
6168: oGetParam 1
6170: oPushResult
6171: oCall 6194
6173: oPop 1
6175: oCall 8505
6177: oEmit 41
6179: oJumpForward 6193
6181: Choice Lookup Table
          25   6168
          24   6157
6186: oGetParam 1
6188: oPushResult
6189: oCall 6194
6191: oPop 1
6193: oReturn
6194: oLocalSpace 7
6196: oInputChoice 6613
6198: oEmit 15
6200: TOKEN_VALUE
6201: oPushResult
6202: oEmitInt
6203: oPop 1
6205: oGetGlobal 6
6207: oPushResult
6208: oTypeSPush
6209: oPop 1
6211: oJumpForward 6634
6213: oEmit 15
6215: TOKEN_VALUE
6216: oPushResult
6217: oEmitInt
6218: oPop 1
6220: oGetGlobal 9
6222: oPushResult
6223: oTypeSPush
6224: oPop 1
6226: oJumpForward 6634
6228: oGetParam 1
6230: oPushResult
6231: oCall 4948
6233: oPop 1
6235: oInput 15
6237: oJumpForward 6634
6239: oGetAddrLocal 1
6241: oPushResult
6242: CURRENT_STRLIT
6243: oPushResult
6244: oStringAllocShortStringLit
6245: oPop 1
6247: oAssign
6248: oEmit 16
6250: oGetLocal 1
6252: oPushResult
6253: oEmitInt
6254: oPop 1
6256: oGetGlobal 13
6258: oPushResult
6259: oTypeSPush
6260: oPop 1
6262: oCall 7446
6264: oCall 7392
6266: oJumpForward 6634
6268: oGetAddrLocal 2
6270: oPushResult
6271: oScopeFindRequire
6272: oAssign
6273: oGetAddrLocal 2
6275: oPushResult
6276: oCall 244
6278: oPop 1
6280: oGetLocal 2
6282: oPushResult
6283: oNodeType
6284: oPop 1
6286: oChoice 6533
6288: oGetLocal 2
6290: oPushResult
6291: oCall 10752
6293: oPop 1
6295: oJumpForward 6562
6297: oGetLocal 2
6299: oPushResult
6300: oCall 11416
6302: oPop 1
6304: oJumpForward 6562
6306: oGetAddrLocal 3
6308: oPushResult
6309: oGetLocal 2
6311: oPushResult
6312: oSetResult 21
6314: oPushResult
6315: oNodeGet
6316: oPop 2
6318: oAssign
6319: oGetLocal 3
6321: oPushResult
6322: oTypeSPush
6323: oPop 1
6325: oTypeSNodeType
6326: oChoice 6350
6328: oEmit 15
6330: oGetLocal 2
6332: oPushResult
6333: oCall 13717
6335: oPop 1
6337: oJumpForward 6367
6339: oEmit 15
6341: oGetLocal 2
6343: oPushResult
6344: oCall 13717
6346: oPop 1
6348: oJumpForward 6367
6350: Choice Lookup Table
          35   6339
          34   6339
          30   6328
          33   6328
          31   6328
          41   6328
          29   6328
6365: oError 16
6367: oJumpForward 6562
6369: oGetAddrLocal 4
6371: oPushResult
6372: oGetLocal 2
6374: oPushResult
6375: oSetResult 22
6377: oPushResult
6378: oNodeGetInt
6379: oPop 2
6381: oAssign
6382: oGetLocal 4
6384: oPushResult
6385: equal_zero
6386: oPop 1
6388: oChoice 6421
6390: oGetAddrLocal 4
6392: oPushResult
6393: oGetLocal 2
6395: oPushResult
6396: oSetResult 33
6398: oPushResult
6399: oNodeGetString
6400: oPop 2
6402: oPushResult
6403: oStringAllocShortStringLit
6404: oPop 1
6406: oAssign
6407: oGetLocal 2
6409: oPushResult
6410: oSetResult 22
6412: oPushResult
6413: oGetLocal 4
6415: oPushResult
6416: oNodeSetInt
6417: oPop 3
6419: oJumpForward 6424
6421: Choice Lookup Table
           1   6390
6424: oEmit 16
6426: oGetLocal 4
6428: oPushResult
6429: oEmitInt
6430: oPop 1
6432: oGetGlobal 13
6434: oPushResult
6435: oTypeSPush
6436: oPop 1
6438: oCall 7446
6440: oCall 7392
6442: oJumpForward 6562
6444: oGetLocal 2
6446: oPushResult
6447: oCall 6635
6449: oPop 1
6451: oJumpForward 6562
6453: oGetLocal 2
6455: oPushResult
6456: oSetResult 21
6458: oPushResult
6459: oNodeGet
6460: oPop 2
6462: oPushResult
6463: oTypeSPush
6464: oPop 1
6466: oInput 14
6468: oCall 4787
6470: oInput 15
6472: oCall 8220
6474: oTypeSNodeType
6475: oChoice 6520
6477: oInputChoice 6507
6479: oTypeSPop
6480: oGetLocal 3
6482: oPushResult
6483: oSetResult 37
6485: oPushResult
6486: oNodeGet
6487: oPop 2
6489: oPushResult
6490: oTypeSPush
6491: oPop 1
6493: oCall 7446
6495: oCall 7392
6497: oJumpForward 6512
6499: oCall 7641
6501: oCall 7446
6503: oCall 7392
6505: oJumpForward 6512
6507: Choice Lookup Table
          16   6499
          18   6479
6512: oJumpForward 6531
6514: oCall 7446
6516: oCall 7392
6518: oJumpForward 6531
6520: Choice Lookup Table
          40   6514
          38   6514
          36   6514
          35   6477
          34   6477
6531: oJumpForward 6562
6533: Choice Lookup Table
          19   6453
          25   6444
          24   6444
          22   6444
          21   6444
          18   6369
          17   6306
          16   6306
          14   6297
          13   6288
6554: oError 6
6556: oGetGlobal 6
6558: oPushResult
6559: oTypeSPush
6560: oPop 1
6562: oJumpForward 6634
6564: oInput 0
6566: oGetAddrLocal 5
6568: oPushResult
6569: oScopeFindRequire
6570: oAssign
6571: oGetAddrLocal 5
6573: oPushResult
6574: oCall 244
6576: oPop 1
6578: oGetLocal 5
6580: oPushResult
6581: oSetResult 0
6583: oPushResult
6584: oCall 9047
6586: oPop 2
6588: oGetAddrLocal 6
6590: oPushResult
6591: oTypeSTop
6592: oAssign
6593: oTypeSPop
6594: oGetAddrLocal 7
6596: oPushResult
6597: oGetLocal 6
6599: oPushResult
6600: oCall 12736
6602: oPop 1
6604: oAssign
6605: oGetLocal 7
6607: oPushResult
6608: oTypeSPush
6609: oPop 1
6611: oJumpForward 6634
6613: Choice Lookup Table
          19   6564
           0   6268
           2   6239
          14   6228
           3   6213
           1   6198
6626: oError 6
6628: oGetGlobal 6
6630: oPushResult
6631: oTypeSPush
6632: oPop 1
6634: oReturn
6635: oLocalSpace 2
6637: oGetAddrLocal 1
6639: oPushResult
6640: oGetParam 1
6642: oPushResult
6643: oSetResult 21
6645: oPushResult
6646: oNodeGet
6647: oPop 2
6649: oAssign
6650: oGetAddrLocal 2
6652: oPushResult
6653: oGetParam 1
6655: oPushResult
6656: oCall 13671
6658: oPop 1
6660: oAssign
6661: oGetLocal 1
6663: oPushResult
6664: oTypeSPush
6665: oPop 1
6667: oTypeSNodeType
6668: oChoice 7367
6670: oGetParam 1
6672: oPushResult
6673: oNodeType
6674: oPop 1
6676: oChoice 6822
6678: oEmit 0
6680: oGetParam 1
6682: oPushResult
6683: oCall 13717
6685: oPop 1
6687: oJumpForward 6832
6689: oGetLocal 2
6691: oPushResult
6692: equal_zero
6693: oPop 1
6695: oChoice 6708
6697: oEmit 3
6699: oGetParam 1
6701: oPushResult
6702: oCall 13717
6704: oPop 1
6706: oJumpForward 6726
6708: Choice Lookup Table
           1   6697
6711: oEmit 9
6713: oGetLocal 2
6715: oPushResult
6716: oEmitInt
6717: oPop 1
6719: oGetParam 1
6721: oPushResult
6722: oCall 13717
6724: oPop 1
6726: oJumpForward 6832
6728: oGetParam 1
6730: oPushResult
6731: oSetResult 34
6733: oPushResult
6734: oNodeGetBoolean
6735: oPop 2
6737: oChoice 6780
6739: oGetLocal 2
6741: oPushResult
6742: equal_zero
6743: oPop 1
6745: oChoice 6758
6747: oEmit 8
6749: oGetParam 1
6751: oPushResult
6752: oCall 13717
6754: oPop 1
6756: oJumpForward 6776
6758: Choice Lookup Table
           1   6747
6761: oEmit 14
6763: oGetLocal 2
6765: oPushResult
6766: oEmitInt
6767: oPop 1
6769: oGetParam 1
6771: oPushResult
6772: oCall 13717
6774: oPop 1
6776: oEmit 23
6778: oJumpForward 6820
6780: Choice Lookup Table
           1   6739
6783: oGetLocal 2
6785: oPushResult
6786: equal_zero
6787: oPop 1
6789: oChoice 6802
6791: oEmit 6
6793: oGetParam 1
6795: oPushResult
6796: oCall 13717
6798: oPop 1
6800: oJumpForward 6820
6802: Choice Lookup Table
           1   6791
6805: oEmit 12
6807: oGetLocal 2
6809: oPushResult
6810: oEmitInt
6811: oPop 1
6813: oGetParam 1
6815: oPushResult
6816: oCall 13717
6818: oPop 1
6820: oJumpForward 6832
6822: Choice Lookup Table
          24   6728
          22   6689
          25   6678
          21   6678
6831: oEndChoice
6832: oJumpForward 7391
6834: oGetParam 1
6836: oPushResult
6837: oNodeType
6838: oPop 1
6840: oChoice 6986
6842: oEmit 1
6844: oGetParam 1
6846: oPushResult
6847: oCall 13717
6849: oPop 1
6851: oJumpForward 6996
6853: oGetLocal 2
6855: oPushResult
6856: equal_zero
6857: oPop 1
6859: oChoice 6872
6861: oEmit 4
6863: oGetParam 1
6865: oPushResult
6866: oCall 13717
6868: oPop 1
6870: oJumpForward 6890
6872: Choice Lookup Table
           1   6861
6875: oEmit 10
6877: oGetLocal 2
6879: oPushResult
6880: oEmitInt
6881: oPop 1
6883: oGetParam 1
6885: oPushResult
6886: oCall 13717
6888: oPop 1
6890: oJumpForward 6996
6892: oGetParam 1
6894: oPushResult
6895: oSetResult 34
6897: oPushResult
6898: oNodeGetBoolean
6899: oPop 2
6901: oChoice 6944
6903: oGetLocal 2
6905: oPushResult
6906: equal_zero
6907: oPop 1
6909: oChoice 6922
6911: oEmit 8
6913: oGetParam 1
6915: oPushResult
6916: oCall 13717
6918: oPop 1
6920: oJumpForward 6940
6922: Choice Lookup Table
           1   6911
6925: oEmit 14
6927: oGetLocal 2
6929: oPushResult
6930: oEmitInt
6931: oPop 1
6933: oGetParam 1
6935: oPushResult
6936: oCall 13717
6938: oPop 1
6940: oEmit 24
6942: oJumpForward 6984
6944: Choice Lookup Table
           1   6903
6947: oGetLocal 2
6949: oPushResult
6950: equal_zero
6951: oPop 1
6953: oChoice 6966
6955: oEmit 7
6957: oGetParam 1
6959: oPushResult
6960: oCall 13717
6962: oPop 1
6964: oJumpForward 6984
6966: Choice Lookup Table
           1   6955
6969: oEmit 13
6971: oGetLocal 2
6973: oPushResult
6974: oEmitInt
6975: oPop 1
6977: oGetParam 1
6979: oPushResult
6980: oCall 13717
6982: oPop 1
6984: oJumpForward 6996
6986: Choice Lookup Table
          24   6892
          22   6853
          25   6842
          21   6842
6995: oEndChoice
6996: oJumpForward 7391
6998: oError 16
7000: oJumpForward 7391
7002: oGetParam 1
7004: oPushResult
7005: oNodeType
7006: oPop 1
7008: oChoice 7154
7010: oEmit 2
7012: oGetParam 1
7014: oPushResult
7015: oCall 13717
7017: oPop 1
7019: oJumpForward 7164
7021: oGetLocal 2
7023: oPushResult
7024: equal_zero
7025: oPop 1
7027: oChoice 7040
7029: oEmit 5
7031: oGetParam 1
7033: oPushResult
7034: oCall 13717
7036: oPop 1
7038: oJumpForward 7058
7040: Choice Lookup Table
           1   7029
7043: oEmit 11
7045: oGetLocal 2
7047: oPushResult
7048: oEmitInt
7049: oPop 1
7051: oGetParam 1
7053: oPushResult
7054: oCall 13717
7056: oPop 1
7058: oJumpForward 7164
7060: oGetParam 1
7062: oPushResult
7063: oSetResult 34
7065: oPushResult
7066: oNodeGetBoolean
7067: oPop 2
7069: oChoice 7112
7071: oGetLocal 2
7073: oPushResult
7074: equal_zero
7075: oPop 1
7077: oChoice 7090
7079: oEmit 8
7081: oGetParam 1
7083: oPushResult
7084: oCall 13717
7086: oPop 1
7088: oJumpForward 7108
7090: Choice Lookup Table
           1   7079
7093: oEmit 14
7095: oGetLocal 2
7097: oPushResult
7098: oEmitInt
7099: oPop 1
7101: oGetParam 1
7103: oPushResult
7104: oCall 13717
7106: oPop 1
7108: oEmit 25
7110: oJumpForward 7152
7112: Choice Lookup Table
           1   7071
7115: oGetLocal 2
7117: oPushResult
7118: equal_zero
7119: oPop 1
7121: oChoice 7134
7123: oEmit 8
7125: oGetParam 1
7127: oPushResult
7128: oCall 13717
7130: oPop 1
7132: oJumpForward 7152
7134: Choice Lookup Table
           1   7123
7137: oEmit 14
7139: oGetLocal 2
7141: oPushResult
7142: oEmitInt
7143: oPop 1
7145: oGetParam 1
7147: oPushResult
7148: oCall 13717
7150: oPop 1
7152: oJumpForward 7164
7154: Choice Lookup Table
          24   7060
          22   7021
          25   7010
          21   7010
7163: oEndChoice
7164: oInputChoice 7194
7166: oTypeSPop
7167: oGetLocal 1
7169: oPushResult
7170: oSetResult 37
7172: oPushResult
7173: oNodeGet
7174: oPop 2
7176: oPushResult
7177: oTypeSPush
7178: oPop 1
7180: oCall 7446
7182: oCall 7392
7184: oJumpForward 7199
7186: oCall 7641
7188: oCall 7446
7190: oCall 7392
7192: oJumpForward 7199
7194: Choice Lookup Table
          16   7186
          18   7166
7199: oJumpForward 7391
7201: oGetParam 1
7203: oPushResult
7204: oNodeType
7205: oPop 1
7207: oChoice 7351
7209: oEmit 16
7211: oGetParam 1
7213: oPushResult
7214: oCall 13717
7216: oPop 1
7218: oJumpForward 7361
7220: oGetLocal 2
7222: oPushResult
7223: equal_zero
7224: oPop 1
7226: oChoice 7239
7228: oEmit 17
7230: oGetParam 1
7232: oPushResult
7233: oCall 13717
7235: oPop 1
7237: oJumpForward 7257
7239: Choice Lookup Table
           1   7228
7242: oEmit 20
7244: oGetLocal 2
7246: oPushResult
7247: oEmitInt
7248: oPop 1
7250: oGetParam 1
7252: oPushResult
7253: oCall 13717
7255: oPop 1
7257: oJumpForward 7361
7259: oGetParam 1
7261: oPushResult
7262: oSetResult 34
7264: oPushResult
7265: oNodeGetBoolean
7266: oPop 2
7268: oChoice 7309
7270: oGetLocal 2
7272: oPushResult
7273: equal_zero
7274: oPop 1
7276: oChoice 7289
7278: oEmit 8
7280: oGetParam 1
7282: oPushResult
7283: oCall 13717
7285: oPop 1
7287: oJumpForward 7307
7289: Choice Lookup Table
           1   7278
7292: oEmit 14
7294: oGetLocal 2
7296: oPushResult
7297: oEmitInt
7298: oPop 1
7300: oGetParam 1
7302: oPushResult
7303: oCall 13717
7305: oPop 1
7307: oJumpForward 7349
7309: Choice Lookup Table
           1   7270
7312: oGetLocal 2
7314: oPushResult
7315: equal_zero
7316: oPop 1
7318: oChoice 7331
7320: oEmit 18
7322: oGetParam 1
7324: oPushResult
7325: oCall 13717
7327: oPop 1
7329: oJumpForward 7349
7331: Choice Lookup Table
           1   7320
7334: oEmit 21
7336: oGetLocal 2
7338: oPushResult
7339: oEmitInt
7340: oPop 1
7342: oGetParam 1
7344: oPushResult
7345: oCall 13717
7347: oPop 1
7349: oJumpForward 7361
7351: Choice Lookup Table
          24   7259
          22   7220
          25   7209
          21   7209
7360: oEndChoice
7361: oCall 7446
7363: oCall 7392
7365: oJumpForward 7391
7367: Choice Lookup Table
          40   7201
          38   7201
          36   7201
          35   7002
          34   7002
          28   6998
          33   6834
          30   6834
          31   6834
          41   6670
          29   6670
7390: oEndChoice
7391: oReturn
7392: oLocalSpace 0
7394: oTypeSNodeType
7395: oChoice 7419
7397: oEmit 23
7399: oJumpForward 7445
7401: oEmit 24
7403: oJumpForward 7445
7405: oError 16
7407: oJumpForward 7445
7409: oEmit 25
7411: oJumpForward 7445
7413: oError 29
7415: oJumpForward 7445
7417: oJumpForward 7445
7419: Choice Lookup Table
          40   7417
          39   7417
          38   7417
          36   7417
          35   7413
          34   7409
          28   7405
          33   7401
          30   7401
          31   7401
          41   7397
          29   7397
7444: oEndChoice
7445: oReturn
7446: oLocalSpace 0
7448: oInputChoice 7486
7450: oTypeSNodeType
7451: oChoice 7465
7453: oCall 7498
7455: oJumpForward 7476
7457: oCall 7641
7459: oJumpForward 7476
7461: oCall 7720
7463: oJumpForward 7476
7465: Choice Lookup Table
          40   7461
          39   7461
          34   7457
          36   7453
7474: oError 10
7476: oJumpForward 7495
7478: oCall 7750
7480: oJumpForward 7495
7482: oCall 8023
7484: oJumpForward 7495
7486: Choice Lookup Table
          18   7482
          20   7478
          16   7450
7493: oJumpForward 7497
7495: oJumpBack 7448
7497: oReturn
7498: oLocalSpace 3
7500: oTypeSNodeType
7501: oChoice 7505
7503: oJumpForward 7510
7505: Choice Lookup Table
          36   7503
7508: oError 10
7510: oTypeSNodeType
7511: oChoice 7515
7513: oJumpForward 7520
7515: Choice Lookup Table
          36   7513
7518: oError 13
7520: oGetAddrLocal 1
7522: oPushResult
7523: oTypeSTop
7524: oPushResult
7525: oSetResult 38
7527: oPushResult
7528: oNodeGet
7529: oPop 2
7531: oPushResult
7532: oCall 12820
7534: oPop 1
7536: oAssign
7537: oGetAddrLocal 2
7539: oPushResult
7540: oTypeSTop
7541: oPushResult
7542: oSetResult 37
7544: oPushResult
7545: oNodeGet
7546: oPop 2
7548: oAssign
7549: oTypeSPop
7550: oGetLocal 2
7552: oPushResult
7553: oTypeSPush
7554: oPop 1
7556: oCall 4787
7558: oCall 8458
7560: oGetLocal 1
7562: oPushResult
7563: equal_zero
7564: oPop 1
7566: oChoice 7580
7568: oEmit 15
7570: oGetLocal 1
7572: oPushResult
7573: oEmitInt
7574: oPop 1
7576: oEmit 40
7578: oJumpForward 7583
7580: Choice Lookup Table
           0   7568
7583: oGetAddrLocal 3
7585: oPushResult
7586: oGetLocal 2
7588: oPushResult
7589: oSetResult 17
7591: oPushResult
7592: oNodeGetInt
7593: oPop 2
7595: oAssign
7596: oGetLocal 3
7598: oPushResult
7599: oSetResult 1
7601: oPushResult
7602: equal
7603: oPop 2
7605: oChoice 7619
7607: oEmit 15
7609: oGetLocal 3
7611: oPushResult
7612: oEmitInt
7613: oPop 1
7615: oEmit 34
7617: oJumpForward 7622
7619: Choice Lookup Table
           0   7607
7622: oEmit 36
7624: oInputChoice 7632
7626: oJumpForward 7640
7628: oJumpForward 7638
7630: oJumpForward 7638
7632: Choice Lookup Table
          13   7630
          17   7626
7637: oEndChoice
7638: oJumpBack 7510
7640: oReturn
7641: oLocalSpace 2
7643: oTypeSNodeType
7644: oChoice 7648
7646: oJumpForward 7653
7648: Choice Lookup Table
          34   7646
7651: oError 29
7653: oGetAddrLocal 1
7655: oPushResult
7656: oTypeSTop
7657: oPushResult
7658: oSetResult 37
7660: oPushResult
7661: oNodeGet
7662: oPop 2
7664: oAssign
7665: oTypeSPop
7666: oGetLocal 1
7668: oPushResult
7669: oTypeSPush
7670: oPop 1
7672: oCall 4787
7674: oCall 8458
7676: oGetAddrLocal 2
7678: oPushResult
7679: oGetLocal 1
7681: oPushResult
7682: oSetResult 17
7684: oPushResult
7685: oNodeGetInt
7686: oPop 2
7688: oAssign
7689: oGetLocal 2
7691: oPushResult
7692: oSetResult 1
7694: oPushResult
7695: equal
7696: oPop 2
7698: oChoice 7712
7700: oEmit 15
7702: oGetLocal 2
7704: oPushResult
7705: oEmitInt
7706: oPop 1
7708: oEmit 34
7710: oJumpForward 7715
7712: Choice Lookup Table
           0   7700
7715: oEmit 36
7717: oInput 17
7719: oReturn
7720: oLocalSpace 0
7722: oTypeSNodeType
7723: oChoice 7727
7725: oJumpForward 7734
7727: Choice Lookup Table
          40   7725
          39   7725
7732: oError 29
7734: oTypeSPop
7735: oGetGlobal 9
7737: oPushResult
7738: oTypeSPush
7739: oPop 1
7741: oCall 4787
7743: oCall 8458
7745: oEmit 36
7747: oInput 17
7749: oReturn
7750: oLocalSpace 2
7752: oTypeSNodeType
7753: oChoice 7757
7755: oJumpForward 7762
7757: Choice Lookup Table
          38   7755
7760: oError 11
7762: oTypeSTop
7763: oPushResult
7764: oSetResult 41
7766: oPushResult
7767: oNodeGet
7768: oPop 2
7770: oPushResult
7771: oScopeEnter
7772: oPop 1
7774: oInput 0
7776: oGetAddrLocal 1
7778: oPushResult
7779: oScopeFindRequire
7780: oAssign
7781: oGetLocal 1
7783: oPushResult
7784: oNodeType
7785: oPop 1
7787: oChoice 7791
7789: oJumpForward 7796
7791: Choice Lookup Table
          23   7789
7794: oError 12
7796: oScopeEnd
7797: oGetAddrLocal 2
7799: oPushResult
7800: oGetLocal 1
7802: oPushResult
7803: oSetResult 22
7805: oPushResult
7806: oNodeGetInt
7807: oPop 2
7809: oAssign
7810: oGetLocal 2
7812: oPushResult
7813: equal_zero
7814: oPop 1
7816: oChoice 7830
7818: oEmit 15
7820: oGetLocal 2
7822: oPushResult
7823: oEmitInt
7824: oPop 1
7826: oEmit 36
7828: oJumpForward 7833
7830: Choice Lookup Table
           0   7818
7833: oTypeSPop
7834: oGetLocal 1
7836: oPushResult
7837: oSetResult 21
7839: oPushResult
7840: oNodeGet
7841: oPop 2
7843: oPushResult
7844: oTypeSPush
7845: oPop 1
7847: oReturn
7848: oLocalSpace 2
7850: oGetAddrLocal 1
7852: oPushResult
7853: oTypeSTop
7854: oPushResult
7855: oSetResult 37
7857: oPushResult
7858: oNodeGet
7859: oPop 2
7861: oAssign
7862: oGetAddrLocal 2
7864: oPushResult
7865: oGetLocal 1
7867: oPushResult
7868: oSetResult 17
7870: oPushResult
7871: oNodeGetInt
7872: oPop 2
7874: oAssign
7875: oGetLocal 2
7877: oPushResult
7878: oSetResult 1
7880: oPushResult
7881: equal
7882: oPop 2
7884: oChoice 7898
7886: oEmit 15
7888: oGetLocal 2
7890: oPushResult
7891: oEmitInt
7892: oPop 1
7894: oEmit 34
7896: oJumpForward 7901
7898: Choice Lookup Table
           0   7886
7901: oEmit 36
7903: oReturn
7904: oLocalSpace 2
7906: oGetAddrLocal 1
7908: oPushResult
7909: oTypeSTop
7910: oPushResult
7911: oSetResult 37
7913: oPushResult
7914: oNodeGet
7915: oPop 2
7917: oAssign
7918: oGetAddrLocal 2
7920: oPushResult
7921: oGetLocal 1
7923: oPushResult
7924: oSetResult 17
7926: oPushResult
7927: oNodeGetInt
7928: oPop 2
7930: oAssign
7931: oGetLocal 2
7933: oPushResult
7934: oSetResult 1
7936: oPushResult
7937: equal
7938: oPop 2
7940: oChoice 7954
7942: oEmit 15
7944: oGetLocal 2
7946: oPushResult
7947: oEmitInt
7948: oPop 1
7950: oEmit 34
7952: oJumpForward 7957
7954: Choice Lookup Table
           0   7942
7957: oEmit 39
7959: oReturn
7960: oLocalSpace 2
7962: oEmit 38
7964: oGetAddrLocal 1
7966: oPushResult
7967: oTypeSTop
7968: oPushResult
7969: oSetResult 37
7971: oPushResult
7972: oNodeGet
7973: oPop 2
7975: oAssign
7976: oGetAddrLocal 2
7978: oPushResult
7979: oGetLocal 1
7981: oPushResult
7982: oSetResult 17
7984: oPushResult
7985: oNodeGetInt
7986: oPop 2
7988: oAssign
7989: oGetLocal 2
7991: oPushResult
7992: oSetResult 1
7994: oPushResult
7995: equal
7996: oPop 2
7998: oChoice 8012
8000: oEmit 15
8002: oGetLocal 2
8004: oPushResult
8005: oEmitInt
8006: oPop 1
8008: oEmit 35
8010: oJumpForward 8015
8012: Choice Lookup Table
           0   8000
8015: oTypeSPop
8016: oGetGlobal 6
8018: oPushResult
8019: oTypeSPush
8020: oPop 1
8022: oReturn
8023: oLocalSpace 1
8025: oTypeSNodeType
8026: oChoice 8034
8028: oJumpForward 8041
8030: oError 29
8032: oJumpForward 8041
8034: Choice Lookup Table
          35   8030
          34   8028
8039: oError 9
8041: oEmit 25
8043: oGetAddrLocal 1
8045: oPushResult
8046: oTypeSTop
8047: oAssign
8048: oTypeSPop
8049: oGetLocal 1
8051: oPushResult
8052: oSetResult 37
8054: oPushResult
8055: oNodeGet
8056: oPop 2
8058: oPushResult
8059: oTypeSPush
8060: oPop 1
8062: oReturn
8063: oLocalSpace 3
8065: oGetAddrLocal 1
8067: oPushResult
8068: oTypeSNodeType
8069: oAssign
8070: oGetAddrLocal 2
8072: oPushResult
8073: oTypeSTop
8074: oAssign
8075: oTypeSPop
8076: oGetLocal 1
8078: oPushResult
8079: oTypeSNodeType
8080: oPushResult
8081: equal_node_type
8082: oPop 2
8084: oChoice 8216
8086: oTypeSNodeType
8087: oChoice 8201
8089: oGetLocal 1
8091: oChoice 8098
8093: oEmit 30
8095: oReturn
8096: oJumpForward 8101
8098: Choice Lookup Table
          30   8093
8101: oJumpForward 8212
8103: oGetLocal 1
8105: oChoice 8112
8107: oEmit 31
8109: oReturn
8110: oJumpForward 8115
8112: Choice Lookup Table
          29   8107
8115: oJumpForward 8212
8117: oGetLocal 1
8119: oChoice 8152
8121: oReturn
8122: oJumpForward 8157
8124: oTypeSTop
8125: oPushResult
8126: oGetGlobal 10
8128: oPushResult
8129: equal_node
8130: oPop 2
8132: oChoice 8147
8134: oEmit 15
8136: oSetResult 1
8138: oPushResult
8139: oEmitInt
8140: oPop 1
8142: oEmit 36
8144: oReturn
8145: oJumpForward 8150
8147: Choice Lookup Table
           1   8134
8150: oJumpForward 8157
8152: Choice Lookup Table
          39   8124
          35   8121
8157: oJumpForward 8212
8159: oGetLocal 1
8161: oChoice 8166
8163: oReturn
8164: oJumpForward 8169
8166: Choice Lookup Table
          34   8163
8169: oJumpForward 8212
8171: oGetLocal 1
8173: oChoice 8194
8175: oReturn
8176: oJumpForward 8199
8178: oGetGlobal 9
8180: oPushResult
8181: oTypeSPush
8182: oPop 1
8184: oGetAddrLocal 3
8186: oPushResult
8187: oCall 10440
8189: oAssign
8190: oTypeSPop
8191: oReturn
8192: oJumpForward 8199
8194: Choice Lookup Table
          33   8178
          39   8175
8199: oJumpForward 8212
8201: Choice Lookup Table
          40   8171
          35   8159
          34   8117
          30   8103
          29   8089
8212: oError 14
8214: oJumpForward 8219
8216: Choice Lookup Table
           0   8086
8219: oReturn
8220: oLocalSpace 2
8222: oGetAddrLocal 1
8224: oPushResult
8225: oTypeSNodeType
8226: oAssign
8227: oTypeSPop
8228: oGetLocal 1
8230: oPushResult
8231: oTypeSNodeType
8232: oPushResult
8233: equal_node_type
8234: oPop 2
8236: oChoice 8396
8238: oTypeSNodeType
8239: oChoice 8375
8241: oGetLocal 1
8243: oChoice 8253
8245: oEmit 30
8247: oReturn
8248: oJumpForward 8264
8250: oReturn
8251: oJumpForward 8264
8253: Choice Lookup Table
          41   8250
          29   8250
          31   8245
          33   8245
          30   8245
8264: oJumpForward 8392
8266: oGetLocal 1
8268: oChoice 8278
8270: oReturn
8271: oJumpForward 8289
8273: oEmit 31
8275: oReturn
8276: oJumpForward 8289
8278: Choice Lookup Table
          41   8273
          29   8273
          31   8270
          33   8270
          30   8270
8289: oJumpForward 8392
8291: oGetLocal 1
8293: oChoice 8326
8295: oReturn
8296: oJumpForward 8331
8298: oTypeSTop
8299: oPushResult
8300: oGetGlobal 10
8302: oPushResult
8303: equal_node
8304: oPop 2
8306: oChoice 8321
8308: oEmit 15
8310: oSetResult 1
8312: oPushResult
8313: oEmitInt
8314: oPop 1
8316: oEmit 36
8318: oReturn
8319: oJumpForward 8324
8321: Choice Lookup Table
           1   8308
8324: oJumpForward 8331
8326: Choice Lookup Table
          39   8298
          35   8295
8331: oJumpForward 8392
8333: oGetLocal 1
8335: oChoice 8340
8337: oReturn
8338: oJumpForward 8343
8340: Choice Lookup Table
          34   8337
8343: oJumpForward 8392
8345: oGetLocal 1
8347: oChoice 8368
8349: oReturn
8350: oJumpForward 8373
8352: oGetGlobal 9
8354: oPushResult
8355: oTypeSPush
8356: oPop 1
8358: oGetAddrLocal 2
8360: oPushResult
8361: oCall 10440
8363: oAssign
8364: oTypeSPop
8365: oReturn
8366: oJumpForward 8373
8368: Choice Lookup Table
          33   8352
          39   8349
8373: oJumpForward 8392
8375: Choice Lookup Table
          40   8345
          35   8333
          34   8291
          31   8266
          33   8266
          30   8266
          41   8241
          29   8241
8392: oError 14
8394: oJumpForward 8399
8396: Choice Lookup Table
           0   8238
8399: oReturn
8400: oLocalSpace 1
8402: oGetAddrLocal 1
8404: oPushResult
8405: oTypeSNodeType
8406: oAssign
8407: oTypeSPop
8408: oGetLocal 1
8410: oPushResult
8411: oTypeSNodeType
8412: oPushResult
8413: equal_node_type
8414: oPop 2
8416: oChoice 8454
8418: oTypeSNodeType
8419: oChoice 8445
8421: oGetLocal 1
8423: oChoice 8428
8425: oReturn
8426: oJumpForward 8431
8428: Choice Lookup Table
          35   8425
8431: oJumpForward 8450
8433: oGetLocal 1
8435: oChoice 8440
8437: oReturn
8438: oJumpForward 8443
8440: Choice Lookup Table
          34   8437
8443: oJumpForward 8450
8445: Choice Lookup Table
          35   8433
          34   8421
8450: oError 14
8452: oJumpForward 8457
8454: Choice Lookup Table
           0   8418
8457: oReturn
8458: oLocalSpace 0
8460: oTypeSNodeType
8461: oChoice 8465
8463: oJumpForward 8470
8465: Choice Lookup Table
          29   8463
8468: oError 7
8470: oTypeSPop
8471: oReturn
8472: oLocalSpace 0
8474: oTypeSNodeType
8475: oChoice 8479
8477: oJumpForward 8484
8479: Choice Lookup Table
          29   8477
8482: oError 7
8484: oReturn
8485: oLocalSpace 0
8487: oTypeSNodeType
8488: oChoice 8496
8490: oJumpForward 8503
8492: oEmit 30
8494: oJumpForward 8503
8496: Choice Lookup Table
          30   8492
          29   8490
8501: oError 7
8503: oTypeSPop
8504: oReturn
8505: oLocalSpace 0
8507: oTypeSNodeType
8508: oChoice 8523
8510: oJumpForward 8530
8512: oEmit 30
8514: oTypeSPop
8515: oGetGlobal 6
8517: oPushResult
8518: oTypeSPush
8519: oPop 1
8521: oJumpForward 8530
8523: Choice Lookup Table
          30   8512
          29   8510
8528: oError 7
8530: oReturn
8531: oLocalSpace 0
8533: oTypeSNodeType
8534: oChoice 8547
8536: oEmit 30
8538: oTypeSPop
8539: oGetGlobal 6
8541: oPushResult
8542: oTypeSPush
8543: oPop 1
8545: oJumpForward 8550
8547: Choice Lookup Table
          30   8536
8550: oReturn
8551: oLocalSpace 0
8553: oTypeSNodeType
8554: oChoice 8558
8556: oJumpForward 8563
8558: Choice Lookup Table
          31   8556
8561: oError 8
8563: oTypeSPop
8564: oReturn
8565: oLocalSpace 0
8567: oTypeSNodeType
8568: oChoice 8572
8570: oJumpForward 8577
8572: Choice Lookup Table
          31   8570
8575: oError 8
8577: oReturn
8578: oLocalSpace 0
8580: oInputChoice 8643
8582: oCall 10303
8584: oJumpForward 8674
8586: oCall 10310
8588: oJumpForward 8674
8590: oCall 10434
8592: oJumpForward 8674
8594: oCall 10437
8596: oJumpForward 8674
8598: oCall 9454
8600: oJumpForward 8674
8602: oCall 9777
8604: oJumpForward 8674
8606: oCall 9520
8608: oJumpForward 8674
8610: oCall 9697
8612: oJumpForward 8674
8614: oCall 9862
8616: oJumpForward 8674
8618: oCall 9830
8620: oJumpForward 8674
8622: oCall 10280
8624: oJumpForward 8674
8626: oCall 8675
8628: oJumpForward 8674
8630: oCall 9894
8632: oJumpForward 8674
8634: oCall 10228
8636: oJumpForward 8674
8638: oChangeIntLitToLabelIdent
8639: oCall 8675
8641: oJumpForward 8674
8643: Choice Lookup Table
           1   8638
          55   8634
          53   8630
           0   8626
          35   8622
          51   8618
          52   8614
          49   8610
          44   8606
          48   8602
          41   8598
          68   8594
          67   8590
          66   8586
          65   8582
8674: oReturn
8675: oLocalSpace 1
8677: oGetAddrLocal 1
8679: oPushResult
8680: oScopeFindRequire
8681: oAssign
8682: oGetAddrLocal 1
8684: oPushResult
8685: oCall 244
8687: oPop 1
8689: oGetLocal 1
8691: oPushResult
8692: oNodeType
8693: oPop 1
8695: oChoice 8735
8697: oGetLocal 1
8699: oPushResult
8700: oCall 8753
8702: oPop 1
8704: oCall 8578
8706: oJumpForward 8752
8708: oGetLocal 1
8710: oPushResult
8711: oCall 10752
8713: oPop 1
8715: oJumpForward 8752
8717: oGetLocal 1
8719: oPushResult
8720: oCall 8803
8722: oPop 1
8724: oJumpForward 8752
8726: oGetLocal 1
8728: oPushResult
8729: oCall 8893
8731: oPop 1
8733: oJumpForward 8752
8735: Choice Lookup Table
          13   8726
          19   8717
          24   8717
          22   8717
          21   8717
          12   8708
          26   8697
8750: oError 0
8752: oReturn
8753: oLocalSpace 0
8755: oGetParam 1
8757: oPushResult
8758: oSetResult 35
8760: oPushResult
8761: oNodeGetBoolean
8762: oPop 2
8764: oChoice 8770
8766: oError 21
8768: oJumpForward 8773
8770: Choice Lookup Table
           1   8766
8773: oEmit 77
8775: oGetParam 1
8777: oPushResult
8778: oSetResult 22
8780: oPushResult
8781: oNodeGetLabel
8782: oPop 2
8784: oPushResult
8785: oEmitLabel
8786: oPop 1
8788: oGetParam 1
8790: oPushResult
8791: oSetResult 35
8793: oPushResult
8794: oSetResult 1
8796: oPushResult
8797: oNodeSetBoolean
8798: oPop 3
8800: oInput 12
8802: oReturn
8803: oLocalSpace 0
8805: oGetParam 1
8807: oPushResult
8808: oSetResult 1
8810: oPushResult
8811: oCall 9047
8813: oPop 2
8815: oInput 4
8817: oCall 4787
8819: oCall 8063
8821: oCall 8824
8823: oReturn
8824: oLocalSpace 1
8826: oTypeSNodeType
8827: oChoice 8867
8829: oEmit 26
8831: oJumpForward 8891
8833: oEmit 27
8835: oJumpForward 8891
8837: oError 16
8839: oJumpForward 8891
8841: oEmit 28
8843: oJumpForward 8891
8845: oGetAddrLocal 1
8847: oPushResult
8848: oTypeSTop
8849: oPushResult
8850: oSetResult 17
8852: oPushResult
8853: oNodeGetInt
8854: oPop 2
8856: oAssign
8857: oEmit 29
8859: oGetLocal 1
8861: oPushResult
8862: oEmitInt
8863: oPop 1
8865: oJumpForward 8891
8867: Choice Lookup Table
          40   8845
          38   8845
          36   8845
          35   8841
          34   8841
          28   8837
          33   8833
          30   8833
          31   8833
          41   8829
          29   8829
8890: oEndChoice
8891: oTypeSPop
8892: oReturn
8893: oLocalSpace 1
8895: oGetParam 1
8897: oPushResult
8898: oSetResult 6
8900: oPushResult
8901: oNodeGet
8902: oPop 2
8904: oPushResult
8905: oScopeCurrent
8906: oPushResult
8907: oNodeEqual
8908: oPop 2
8910: oChoice 8916
8912: oError 20
8914: oJumpForward 8919
8916: Choice Lookup Table
           0   8912
8919: oEmit 8
8921: oGetParam 1
8923: oPushResult
8924: oSetResult 31
8926: oPushResult
8927: oNodeGetInt
8928: oPop 2
8930: oPushResult
8931: oEmitInt
8932: oPop 1
8934: oGetParam 1
8936: oPushResult
8937: oSetResult 21
8939: oPushResult
8940: oNodeGet
8941: oPop 2
8943: oPushResult
8944: oTypeSPush
8945: oPop 1
8947: oInput 4
8949: oCall 4787
8951: oCall 8063
8953: oTypeSNodeType
8954: oChoice 8994
8956: oEmit 26
8958: oJumpForward 9018
8960: oEmit 27
8962: oJumpForward 9018
8964: oError 16
8966: oJumpForward 9018
8968: oEmit 28
8970: oJumpForward 9018
8972: oGetAddrLocal 1
8974: oPushResult
8975: oTypeSTop
8976: oPushResult
8977: oSetResult 17
8979: oPushResult
8980: oNodeGetInt
8981: oPop 2
8983: oAssign
8984: oEmit 29
8986: oGetLocal 1
8988: oPushResult
8989: oEmitInt
8990: oPop 1
8992: oJumpForward 9018
8994: Choice Lookup Table
          40   8972
          38   8972
          36   8972
          35   8968
          34   8968
          28   8964
          33   8960
          30   8960
          31   8960
          41   8956
          29   8956
9017: oEndChoice
9018: oTypeSPop
9019: oReturn
9020: oLocalSpace 1
9022: oInput 0
9024: oGetAddrLocal 1
9026: oPushResult
9027: oScopeFindRequire
9028: oAssign
9029: oGetAddrLocal 1
9031: oPushResult
9032: oCall 244
9034: oPop 1
9036: oGetLocal 1
9038: oPushResult
9039: oGetParam 1
9041: oPushResult
9042: oCall 9047
9044: oPop 2
9046: oReturn
9047: oLocalSpace 0
9049: oGetParam 2
9051: oPushResult
9052: oNodeType
9053: oPop 1
9055: oChoice 9118
9057: oGetParam 2
9059: oPushResult
9060: oGetParam 1
9062: oPushResult
9063: oCall 9264
9065: oPop 2
9067: oJumpForward 9131
9069: oGetParam 2
9071: oPushResult
9072: oSetResult 21
9074: oPushResult
9075: oNodeGet
9076: oPop 2
9078: oPushResult
9079: oTypeSPush
9080: oPop 1
9082: oInput 14
9084: oGetParam 1
9086: oPushResult
9087: oCall 9020
9089: oPop 1
9091: oInput 15
9093: oCall 9132
9095: oTypeSNodeType
9096: oChoice 9111
9098: oInputChoice 9106
9100: oEmit 25
9102: oCall 7641
9104: oJumpForward 9109
9106: Choice Lookup Table
          16   9100
9109: oJumpForward 9114
9111: Choice Lookup Table
          34   9098
9114: oCall 7446
9116: oJumpForward 9131
9118: Choice Lookup Table
          19   9069
          25   9057
          24   9057
          22   9057
          21   9057
9129: oError 4
9131: oReturn
9132: oLocalSpace 1
9134: oGetAddrLocal 1
9136: oPushResult
9137: oTypeSNodeType
9138: oAssign
9139: oTypeSPop
9140: oGetLocal 1
9142: oPushResult
9143: oTypeSNodeType
9144: oPushResult
9145: equal_node_type
9146: oPop 2
9148: oChoice 9260
9150: oTypeSNodeType
9151: oChoice 9239
9153: oGetLocal 1
9155: oChoice 9165
9157: oError 30
9159: oReturn
9160: oJumpForward 9176
9162: oReturn
9163: oJumpForward 9176
9165: Choice Lookup Table
          41   9162
          29   9162
          31   9157
          33   9157
          30   9157
9176: oJumpForward 9256
9178: oGetLocal 1
9180: oChoice 9190
9182: oReturn
9183: oJumpForward 9201
9185: oError 30
9187: oReturn
9188: oJumpForward 9201
9190: Choice Lookup Table
          41   9185
          29   9185
          31   9182
          33   9182
          30   9182
9201: oJumpForward 9256
9203: oGetLocal 1
9205: oChoice 9210
9207: oReturn
9208: oJumpForward 9213
9210: Choice Lookup Table
          35   9207
9213: oJumpForward 9256
9215: oGetLocal 1
9217: oChoice 9222
9219: oReturn
9220: oJumpForward 9225
9222: Choice Lookup Table
          34   9219
9225: oJumpForward 9256
9227: oGetLocal 1
9229: oChoice 9234
9231: oReturn
9232: oJumpForward 9237
9234: Choice Lookup Table
          39   9231
9237: oJumpForward 9256
9239: Choice Lookup Table
          40   9227
          35   9215
          34   9203
          31   9178
          33   9178
          30   9178
          41   9153
          29   9153
9256: oError 14
9258: oJumpForward 9263
9260: Choice Lookup Table
           0   9150
9263: oReturn
9264: oLocalSpace 0
9266: oGetParam 2
9268: oPushResult
9269: oNodeType
9270: oPop 1
9272: oChoice 9354
9274: oEmit 16
9276: oGetParam 2
9278: oPushResult
9279: oCall 13717
9281: oPop 1
9283: oJumpForward 9365
9285: oEmit 17
9287: oGetParam 2
9289: oPushResult
9290: oCall 13717
9292: oPop 1
9294: oJumpForward 9365
9296: oGetParam 2
9298: oPushResult
9299: oSetResult 34
9301: oPushResult
9302: oNodeGetBoolean
9303: oPop 2
9305: oChoice 9318
9307: oEmit 8
9309: oGetParam 2
9311: oPushResult
9312: oCall 13717
9314: oPop 1
9316: oJumpForward 9330
9318: Choice Lookup Table
           1   9307
9321: oEmit 18
9323: oGetParam 2
9325: oPushResult
9326: oCall 13717
9328: oPop 1
9330: oJumpForward 9365
9332: oGetParam 1
9334: oChoice 9347
9336: oEmit 16
9338: oGetParam 2
9340: oPushResult
9341: oCall 13717
9343: oPop 1
9345: oJumpForward 9352
9347: Choice Lookup Table
           0   9336
9350: oError 4
9352: oJumpForward 9365
9354: Choice Lookup Table
          25   9332
          24   9296
          22   9285
          21   9274
9363: oError 4
9365: oGetParam 2
9367: oPushResult
9368: oSetResult 21
9370: oPushResult
9371: oNodeGet
9372: oPop 2
9374: oPushResult
9375: oTypeSPush
9376: oPop 1
9378: oTypeSNodeType
9379: oChoice 9394
9381: oInputChoice 9389
9383: oEmit 25
9385: oCall 7641
9387: oJumpForward 9392
9389: Choice Lookup Table
          16   9383
9392: oJumpForward 9397
9394: Choice Lookup Table
          34   9381
9397: oCall 7446
9399: oReturn
9400: oLocalSpace 0
9402: oGetParam 1
9404: oPushResult
9405: oSetResult 1
9407: oPushResult
9408: oCall 9264
9410: oPop 2
9412: oCall 8458
9414: oGetParam 1
9416: oPushResult
9417: oCall 6635
9419: oPop 1
9421: oTypeSPop
9422: oEmit 32
9424: oEmit 26
9426: oReturn
9427: oLocalSpace 0
9429: oGetParam 1
9431: oPushResult
9432: oSetResult 1
9434: oPushResult
9435: oCall 9264
9437: oPop 2
9439: oCall 8458
9441: oGetParam 1
9443: oPushResult
9444: oCall 6635
9446: oPop 1
9448: oTypeSPop
9449: oEmit 33
9451: oEmit 26
9453: oReturn
9454: oLocalSpace 2
9456: oGetAddrLocal 1
9458: oPushResult
9459: oSetResult 0
9461: oAssign
9462: oGetAddrLocal 1
9464: oPushResult
9465: oCall 4810
9467: oPop 1
9469: oInput 42
9471: oCall 8578
9473: oInputChoice 9508
9475: oGetAddrLocal 2
9477: oPushResult
9478: oLabelNew
9479: oAssign
9480: oEmit 68
9482: oGetLocal 2
9484: oPushResult
9485: oEmitLabel
9486: oPop 1
9488: oEmit 77
9490: oGetLocal 1
9492: oPushResult
9493: oEmitLabel
9494: oPop 1
9496: oCall 8578
9498: oEmit 77
9500: oGetLocal 2
9502: oPushResult
9503: oEmitLabel
9504: oPop 1
9506: oJumpForward 9519
9508: Choice Lookup Table
          43   9475
9511: oEmit 77
9513: oGetLocal 1
9515: oPushResult
9516: oEmitLabel
9517: oPop 1
9519: oReturn
9520: oLocalSpace 4
9522: oInput 0
9524: oGetAddrLocal 1
9526: oPushResult
9527: oScopeFindRequire
9528: oAssign
9529: oGetLocal 1
9531: oPushResult
9532: oSetResult 1
9534: oPushResult
9535: oCall 9264
9537: oPop 2
9539: oCall 8458
9541: oInput 4
9543: oCall 4787
9545: oCall 8458
9547: oEmit 26
9549: oGetAddrLocal 2
9551: oPushResult
9552: oLabelNew
9553: oAssign
9554: oGetAddrLocal 3
9556: oPushResult
9557: oLabelNew
9558: oAssign
9559: oEmit 68
9561: oGetLocal 3
9563: oPushResult
9564: oEmitLabel
9565: oPop 1
9567: oGetAddrLocal 4
9569: oPushResult
9570: oLabelNew
9571: oAssign
9572: oEmit 77
9574: oGetLocal 4
9576: oPushResult
9577: oEmitLabel
9578: oPop 1
9580: oInputChoice 9660
9582: oGetLocal 1
9584: oPushResult
9585: oCall 9400
9587: oPop 1
9589: oEmit 77
9591: oGetLocal 3
9593: oPushResult
9594: oEmitLabel
9595: oPop 1
9597: oGetLocal 1
9599: oPushResult
9600: oCall 6635
9602: oPop 1
9604: oTypeSPop
9605: oCall 4787
9607: oCall 8458
9609: oEmit 51
9611: oEmit 69
9613: oGetLocal 2
9615: oPushResult
9616: oEmitLabel
9617: oPop 1
9619: oJumpForward 9666
9621: oGetLocal 1
9623: oPushResult
9624: oCall 9427
9626: oPop 1
9628: oEmit 77
9630: oGetLocal 3
9632: oPushResult
9633: oEmitLabel
9634: oPop 1
9636: oGetLocal 1
9638: oPushResult
9639: oCall 6635
9641: oPop 1
9643: oTypeSPop
9644: oCall 4787
9646: oCall 8458
9648: oEmit 52
9650: oEmit 69
9652: oGetLocal 2
9654: oPushResult
9655: oEmitLabel
9656: oPop 1
9658: oJumpForward 9666
9660: Choice Lookup Table
          46   9621
          45   9582
9665: oEndChoice
9666: oGetLocal 4
9668: oPushResult
9669: oGetLocal 2
9671: oPushResult
9672: oLoopPush
9673: oPop 2
9675: oInput 47
9677: oCall 8578
9679: oEmit 68
9681: oGetLocal 4
9683: oPushResult
9684: oEmitLabel
9685: oPop 1
9687: oEmit 77
9689: oGetLocal 2
9691: oPushResult
9692: oEmitLabel
9693: oPop 1
9695: oLoopPop
9696: oReturn
9697: oLocalSpace 3
9699: oGetAddrLocal 1
9701: oPushResult
9702: oLabelNew
9703: oAssign
9704: oEmit 77
9706: oGetLocal 1
9708: oPushResult
9709: oEmitLabel
9710: oPop 1
9712: oGetAddrLocal 2
9714: oPushResult
9715: oLabelNew
9716: oAssign
9717: oGetLocal 1
9719: oPushResult
9720: oGetLocal 2
9722: oPushResult
9723: oLoopPush
9724: oPop 2
9726: oCall 8578
9728: oInputChoice 9759
9730: oCall 8578
9732: oJumpForward 9765
9734: oGetAddrLocal 3
9736: oPushResult
9737: oCall 4810
9739: oPop 1
9741: oEmit 78
9743: oGetLocal 3
9745: oPushResult
9746: oEmitLabel
9747: oPop 1
9749: oGetLocal 1
9751: oPushResult
9752: oEmitLabel
9753: oPop 1
9755: oJumpForward 9767
9757: oJumpForward 9765
9759: Choice Lookup Table
          50   9734
           5   9730
9764: oEndChoice
9765: oJumpBack 9728
9767: oEmit 77
9769: oGetLocal 2
9771: oPushResult
9772: oEmitLabel
9773: oPop 1
9775: oLoopPop
9776: oReturn
9777: oLocalSpace 2
9779: oGetAddrLocal 1
9781: oPushResult
9782: oLabelNew
9783: oAssign
9784: oEmit 77
9786: oGetLocal 1
9788: oPushResult
9789: oEmitLabel
9790: oPop 1
9792: oGetAddrLocal 2
9794: oPushResult
9795: oCall 4810
9797: oPop 1
9799: oGetLocal 1
9801: oPushResult
9802: oGetLocal 2
9804: oPushResult
9805: oLoopPush
9806: oPop 2
9808: oInput 47
9810: oCall 8578
9812: oEmit 68
9814: oGetLocal 1
9816: oPushResult
9817: oEmitLabel
9818: oPop 1
9820: oEmit 77
9822: oGetLocal 2
9824: oPushResult
9825: oEmitLabel
9826: oPop 1
9828: oLoopPop
9829: oReturn
9830: oLocalSpace 0
9832: oLoopContinueLabel
9833: oPushResult
9834: oSetResult 0
9836: oPushResult
9837: equal_label
9838: oPop 2
9840: oChoice 9855
9842: oError 18
9844: oJumpForward 9861
9846: oEmit 68
9848: oLoopContinueLabel
9849: oPushResult
9850: oEmitLabel
9851: oPop 1
9853: oJumpForward 9861
9855: Choice Lookup Table
           0   9846
           1   9842
9860: oEndChoice
9861: oReturn
9862: oLocalSpace 0
9864: oLoopBreakLabel
9865: oPushResult
9866: oSetResult 0
9868: oPushResult
9869: equal_label
9870: oPop 2
9872: oChoice 9887
9874: oError 18
9876: oJumpForward 9893
9878: oEmit 68
9880: oLoopBreakLabel
9881: oPushResult
9882: oEmitLabel
9883: oPop 1
9885: oJumpForward 9893
9887: Choice Lookup Table
           0   9878
           1   9874
9892: oEndChoice
9893: oReturn
9894: oLocalSpace 8
9896: oGetAddrLocal 1
9898: oPushResult
9899: oCodeNew
9900: oAssign
9901: oGetAddrLocal 2
9903: oPushResult
9904: oLabelNew
9905: oAssign
9906: oGetAddrLocal 3
9908: oPushResult
9909: oLabelNew
9910: oAssign
9911: oGetAddrLocal 4
9913: oPushResult
9914: oGetLocal 3
9916: oAssign
9917: oGetAddrLocal 5
9919: oPushResult
9920: oSetResult 0
9922: oAssign
9923: oCall 4787
9925: oTypeSNodeType
9926: oChoice 9964
9928: oEmit 71
9930: oGetLocal 2
9932: oPushResult
9933: oEmitLabel
9934: oPop 1
9936: oJumpForward 9981
9938: oEmit 72
9940: oGetLocal 2
9942: oPushResult
9943: oEmitLabel
9944: oPop 1
9946: oJumpForward 9981
9948: oGetAddrLocal 5
9950: oPushResult
9951: oSetResult 1
9953: oAssign
9954: oEmit 73
9956: oGetLocal 2
9958: oPushResult
9959: oEmitLabel
9960: oPop 1
9962: oJumpForward 9981
9964: Choice Lookup Table
          39   9948
          40   9948
          41   9938
          29   9938
          33   9928
          30   9928
          31   9928
9979: oError 17
9981: oInput 40
9983: oInputChoice 10030
9985: oGetAddrLocal 4
9987: oPushResult
9988: oLabelNew
9989: oAssign
9990: oEmit 77
9992: oGetLocal 4
9994: oPushResult
9995: oEmitLabel
9996: oPop 1
9998: oInputChoice 10004
10000: oJumpForward 10022
10002: oJumpForward 10020
10004: Choice Lookup Table
          36   10000
10007: oCall 8578
10009: oInputChoice 10013
10011: oJumpForward 10020
10013: Choice Lookup Table
           5   10011
10016: oInput 36
10018: oJumpForward 10022
10020: oJumpBack 9998
10022: oJumpForward 10196
10024: oJumpForward 10194
10026: oJumpForward 10196
10028: oJumpForward 10194
10030: Choice Lookup Table
          36   10026
          43   9985
          54   9985
10037: oGetAddrLocal 6
10039: oPushResult
10040: oLabelNew
10041: oAssign
10042: oGetLocal 1
10044: oPushResult
10045: oCodePush
10046: oPop 1
10048: oCall 3533
10050: oCall 4300
10052: oGetLocal 5
10054: oChoice 10074
10056: oGetAddrLocal 7
10058: oPushResult
10059: oValueTopString
10060: oPushResult
10061: oStringAllocShortStringLit
10062: oPop 1
10064: oAssign
10065: oJumpForward 10080
10067: oGetAddrLocal 7
10069: oPushResult
10070: oValueTop
10071: oAssign
10072: oJumpForward 10080
10074: Choice Lookup Table
           0   10067
           1   10056
10079: oEndChoice
10080: oValuePop
10081: oInputChoice 10138
10083: oCall 3533
10085: oCall 4300
10087: oGetLocal 5
10089: oChoice 10109
10091: oGetAddrLocal 8
10093: oPushResult
10094: oValueTopString
10095: oPushResult
10096: oStringAllocShortStringLit
10097: oPop 1
10099: oAssign
10100: oJumpForward 10115
10102: oGetAddrLocal 8
10104: oPushResult
10105: oValueTop
10106: oAssign
10107: oJumpForward 10115
10109: Choice Lookup Table
           0   10102
           1   10091
10114: oEndChoice
10115: oValuePop
10116: oEmit 75
10118: oGetLocal 7
10120: oPushResult
10121: oEmitInt
10122: oPop 1
10124: oGetLocal 8
10126: oPushResult
10127: oEmitInt
10128: oPop 1
10130: oGetLocal 6
10132: oPushResult
10133: oEmitLabel
10134: oPop 1
10136: oJumpForward 10155
10138: Choice Lookup Table
          21   10083
10141: oEmit 74
10143: oGetLocal 7
10145: oPushResult
10146: oEmitInt
10147: oPop 1
10149: oGetLocal 6
10151: oPushResult
10152: oEmitLabel
10153: oPop 1
10155: oInputChoice 10159
10157: oJumpForward 10164
10159: Choice Lookup Table
          13   10157
10162: oJumpForward 10166
10164: oJumpBack 10048
10166: oCodePop
10167: oInput 12
10169: oEmit 77
10171: oGetLocal 6
10173: oPushResult
10174: oEmitLabel
10175: oPop 1
10177: oCall 8578
10179: oEmit 68
10181: oGetLocal 3
10183: oPushResult
10184: oEmitLabel
10185: oPop 1
10187: oInputChoice 10191
10189: oJumpForward 10194
10191: Choice Lookup Table
           5   10189
10194: oJumpBack 9983
10196: oEmit 77
10198: oGetLocal 2
10200: oPushResult
10201: oEmitLabel
10202: oPop 1
10204: oGetLocal 1
10206: oPushResult
10207: oEmitCode
10208: oPop 1
10210: oEmit 76
10212: oGetLocal 4
10214: oPushResult
10215: oEmitLabel
10216: oPop 1
10218: oEmit 77
10220: oGetLocal 3
10222: oPushResult
10223: oEmitLabel
10224: oPop 1
10226: oTypeSPop
10227: oReturn
10228: oLocalSpace 1
10230: oInputChoice 10237
10232: oJumpForward 10243
10234: oChangeIntLitToLabelIdent
10235: oJumpForward 10243
10237: Choice Lookup Table
           1   10234
           0   10232
10242: oEndChoice
10243: oGetAddrLocal 1
10245: oPushResult
10246: oScopeCurrent
10247: oPushResult
10248: oScopeFindRequireInScope
10249: oPop 1
10251: oAssign
10252: oGetLocal 1
10254: oPushResult
10255: oSetResult 28
10257: oPushResult
10258: oSetResult 1
10260: oPushResult
10261: oNodeSetBoolean
10262: oPop 3
10264: oEmit 68
10266: oGetLocal 1
10268: oPushResult
10269: oSetResult 22
10271: oPushResult
10272: oNodeGetLabel
10273: oPop 2
10275: oPushResult
10276: oEmitLabel
10277: oPop 1
10279: oReturn
10280: oLocalSpace 0
10282: oCall 8578
10284: oInputChoice 10294
10286: oCall 8578
10288: oJumpForward 10300
10290: oJumpForward 10302
10292: oJumpForward 10300
10294: Choice Lookup Table
          36   10290
           5   10286
10299: oEndChoice
10300: oJumpBack 10284
10302: oReturn
10303: oLocalSpace 0
10305: oCall 10310
10307: oEmit 87
10309: oReturn
10310: oLocalSpace 0
10312: oInputChoice 10430
10314: oCall 4787
10316: oTypeSNodeType
10317: oChoice 10388
10319: oEmit 80
10321: oJumpForward 10411
10323: oEmit 81
10325: oJumpForward 10411
10327: oEmit 30
10329: oEmit 80
10331: oJumpForward 10411
10333: oEmit 82
10335: oJumpForward 10411
10337: oEmit 83
10339: oJumpForward 10411
10341: oError 16
10343: oJumpForward 10411
10345: oEmit 16
10347: oTypeSTop
10348: oPushResult
10349: oSetResult 43
10351: oPushResult
10352: oNodeGetInt
10353: oPop 2
10355: oPushResult
10356: oEmitInt
10357: oPop 1
10359: oEmit 86
10361: oJumpForward 10411
10363: oTypeSTop
10364: oPushResult
10365: oGetGlobal 10
10367: oPushResult
10368: equal_node
10369: oPop 2
10371: oChoice 10377
10373: oEmit 84
10375: oJumpForward 10382
10377: Choice Lookup Table
           1   10373
10380: oEmit 85
10382: oJumpForward 10411
10384: oEmit 85
10386: oJumpForward 10411
10388: Choice Lookup Table
          35   10384
          34   10363
          41   10345
          28   10341
          39   10337
          40   10337
          33   10333
          30   10327
          31   10323
          29   10319
10409: oError 17
10411: oTypeSPop
10412: oInputChoice 10420
10414: oJumpForward 10428
10416: oJumpForward 10426
10418: oJumpForward 10426
10420: Choice Lookup Table
          13   10418
          15   10414
10425: oEndChoice
10426: oJumpBack 10314
10428: oJumpForward 10433
10430: Choice Lookup Table
          14   10314
10433: oReturn
10434: oLocalSpace 0
10436: oReturn
10437: oLocalSpace 0
10439: oReturn
10440: oLocalSpace 1
10442: oGetAddrLocal 1
10444: oPushResult
10445: oGetGlobal 14
10447: oPushResult
10448: oScopeAllocType
10449: oPop 1
10451: oAssign
10452: oTypeSNodeType
10453: oChoice 10521
10455: oEmit 17
10457: oGetLocal 1
10459: oPushResult
10460: oEmitInt
10461: oPop 1
10463: oEmit 22
10465: oEmit 29
10467: oGetGlobal 14
10469: oPushResult
10470: oSetResult 17
10472: oPushResult
10473: oNodeGetInt
10474: oPop 2
10476: oPushResult
10477: oEmitInt
10478: oPop 1
10480: oJumpForward 10530
10482: oEmit 17
10484: oGetLocal 1
10486: oPushResult
10487: oEmitInt
10488: oPop 1
10490: oEmit 15
10492: oSetResult 1
10494: oPushResult
10495: oEmitInt
10496: oPop 1
10498: oEmit 27
10500: oEmit 17
10502: oGetLocal 1
10504: oPushResult
10505: oSetResult 1
10507: oPushResult
10508: add
10509: oPop 2
10511: oPushResult
10512: oEmitInt
10513: oPop 1
10515: oEmit 22
10517: oEmit 27
10519: oJumpForward 10530
10521: Choice Lookup Table
          33   10482
          39   10455
          40   10455
10528: oError 14
10530: oTypeSPop
10531: oEmit 17
10533: oGetLocal 1
10535: oPushResult
10536: oEmitInt
10537: oPop 1
10539: oGetGlobal 14
10541: oPushResult
10542: oTypeSPush
10543: oPop 1
10545: oGetLocal 1
10547: oReturn
10548: oReturn
10549: oLocalSpace 0
10551: oEmit 61
10553: oSetResult 16
10555: oPushResult
10556: oEmitInt
10557: oPop 1
10559: oEmit 19
10561: oSetResult 8
10563: oPushResult
10564: oEmitInt
10565: oPop 1
10567: oEmit 22
10569: oEmit 28
10571: oEmit 19
10573: oSetResult 0
10575: oPushResult
10576: oEmitInt
10577: oPop 1
10579: oEmit 22
10581: oEmit 28
10583: oEmit 64
10585: oGetGlobal 19
10587: oPushResult
10588: oCall 13717
10590: oPop 1
10592: oEmit 63
10594: oSetResult 16
10596: oPushResult
10597: oEmitInt
10598: oPop 1
10600: oTypeSPop
10601: oTypeSPop
10602: oReturn
10603: oLocalSpace 0
10605: oEmit 61
10607: oSetResult 12
10609: oPushResult
10610: oEmitInt
10611: oPop 1
10613: oEmit 19
10615: oSetResult 8
10617: oPushResult
10618: oEmitInt
10619: oPop 1
10621: oEmit 22
10623: oEmit 27
10625: oEmit 19
10627: oSetResult 0
10629: oPushResult
10630: oEmitInt
10631: oPop 1
10633: oEmit 22
10635: oEmit 28
10637: oEmit 64
10639: oGetGlobal 20
10641: oPushResult
10642: oCall 13717
10644: oPop 1
10646: oEmit 63
10648: oSetResult 12
10650: oPushResult
10651: oEmitInt
10652: oPop 1
10654: oTypeSPop
10655: oTypeSPop
10656: oReturn
10657: oLocalSpace 1
10659: oEmit 62
10661: oSetResult 24
10663: oPushResult
10664: oEmitInt
10665: oPop 1
10667: oEmit 19
10669: oSetResult 8
10671: oPushResult
10672: oEmitInt
10673: oPop 1
10675: oEmit 22
10677: oEmit 28
10679: oEmit 19
10681: oSetResult 0
10683: oPushResult
10684: oEmitInt
10685: oPop 1
10687: oEmit 22
10689: oEmit 28
10691: oGetAddrLocal 1
10693: oPushResult
10694: oGetGlobal 6
10696: oPushResult
10697: oScopeAllocType
10698: oPop 1
10700: oAssign
10701: oEmit 19
10703: oSetResult 16
10705: oPushResult
10706: oEmitInt
10707: oPop 1
10709: oEmit 17
10711: oGetLocal 1
10713: oPushResult
10714: oEmitInt
10715: oPop 1
10717: oEmit 28
10719: oEmit 65
10721: oGetGlobal 21
10723: oPushResult
10724: oCall 13717
10726: oPop 1
10728: oEmit 3
10730: oGetLocal 1
10732: oPushResult
10733: oEmitInt
10734: oPop 1
10736: oEmit 63
10738: oSetResult 24
10740: oPushResult
10741: oEmitInt
10742: oPop 1
10744: oTypeSPop
10745: oGetGlobal 6
10747: oPushResult
10748: oTypeSPush
10749: oPop 1
10751: oReturn
10752: oLocalSpace 10
10754: oGetParam 1
10756: oPushResult
10757: oSetResult 28
10759: oPushResult
10760: oSetResult 1
10762: oPushResult
10763: oNodeSetBoolean
10764: oPop 3
10766: oGetAddrLocal 1
10768: oPushResult
10769: oGetParam 1
10771: oPushResult
10772: oSetResult 27
10774: oPushResult
10775: oNodeGetBoolean
10776: oPop 2
10778: oAssign
10779: oGetAddrLocal 4
10781: oPushResult
10782: oGetParam 1
10784: oPushResult
10785: oNodeType
10786: oPop 1
10788: oPushResult
10789: oSetResult 13
10791: oPushResult
10792: equal_node_type
10793: oPop 2
10795: oAssign
10796: oGetLocal 4
10798: oChoice 10825
10800: oGetAddrLocal 2
10802: oPushResult
10803: oGetParam 1
10805: oPushResult
10806: oSetResult 21
10808: oPushResult
10809: oNodeGet
10810: oPop 2
10812: oAssign
10813: oGetAddrLocal 3
10815: oPushResult
10816: oGetLocal 2
10818: oPushResult
10819: oScopeAllocType
10820: oPop 1
10822: oAssign
10823: oJumpForward 10828
10825: Choice Lookup Table
           1   10800
10828: oGetAddrLocal 5
10830: oPushResult
10831: oGetParam 1
10833: oPushResult
10834: oSetResult 23
10836: oPushResult
10837: oNodeGet
10838: oPop 2
10840: oAssign
10841: oGetAddrLocal 6
10843: oPushResult
10844: oGetLocal 5
10846: oPushResult
10847: oSetResult 17
10849: oPushResult
10850: oNodeGetInt
10851: oPop 2
10853: oAssign
10854: oGetLocal 1
10856: oChoice 10878
10858: oEmit 62
10860: oGetLocal 6
10862: oPushResult
10863: oEmitInt
10864: oPop 1
10866: oJumpForward 10884
10868: oEmit 61
10870: oGetLocal 6
10872: oPushResult
10873: oEmitInt
10874: oPop 1
10876: oJumpForward 10884
10878: Choice Lookup Table
           0   10868
           1   10858
10883: oEndChoice
10884: oGetParam 1
10886: oPushResult
10887: oCall 13651
10889: oPop 1
10891: oPushResult
10892: oSetResult 0
10894: oPushResult
10895: greater
10896: oPop 2
10898: oChoice 10931
10900: oEmit 19
10902: oSetResult 0
10904: oPushResult
10905: oEmitInt
10906: oPop 1
10908: oEmit 20
10910: oGetParam 1
10912: oPushResult
10913: oCall 13671
10915: oPop 1
10917: oPushResult
10918: oEmitInt
10919: oPop 1
10921: oSetResult 0
10923: oPushResult
10924: oEmitInt
10925: oPop 1
10927: oEmit 28
10929: oJumpForward 10934
10931: Choice Lookup Table
           1   10900
10934: oGetAddrLocal 7
10936: oPushResult
10937: oGetLocal 5
10939: oPushResult
10940: oSetResult 15
10942: oPushResult
10943: oNodeGetIter
10944: oPop 2
10946: oAssign
10947: oGetAddrLocal 8
10949: oPushResult
10950: oGetLocal 7
10952: oPushResult
10953: oNodeIterValue
10954: oPop 1
10956: oAssign
10957: oInputChoice 11154
10959: oGetLocal 8
10961: oPushResult
10962: oNodeNull
10963: oPop 1
10965: oChoice 10971
10967: oJumpForward 11150
10969: oJumpForward 10974
10971: Choice Lookup Table
           1   10967
10974: oGetAddrLocal 9
10976: oPushResult
10977: oGetLocal 8
10979: oPushResult
10980: oSetResult 22
10982: oPushResult
10983: oNodeGetInt
10984: oPop 2
10986: oAssign
10987: oEmit 19
10989: oGetLocal 9
10991: oPushResult
10992: oEmitInt
10993: oPop 1
10995: oGetLocal 8
10997: oPushResult
10998: oSetResult 21
11000: oPushResult
11001: oNodeGet
11002: oPop 2
11004: oPushResult
11005: oTypeSPush
11006: oPop 1
11008: oGetLocal 8
11010: oPushResult
11011: oSetResult 34
11013: oPushResult
11014: oNodeGetBoolean
11015: oPop 2
11017: oChoice 11103
11019: oSetResult 1
11021: oPushResult
11022: oCall 9020
11024: oPop 1
11026: oCall 8400
11028: oEmit 28
11030: oJumpForward 11109
11032: oCall 4787
11034: oCall 8063
11036: oTypeSNodeType
11037: oChoice 11077
11039: oEmit 26
11041: oJumpForward 11101
11043: oEmit 27
11045: oJumpForward 11101
11047: oError 16
11049: oJumpForward 11101
11051: oEmit 28
11053: oJumpForward 11101
11055: oGetAddrLocal 10
11057: oPushResult
11058: oTypeSTop
11059: oPushResult
11060: oSetResult 17
11062: oPushResult
11063: oNodeGetInt
11064: oPop 2
11066: oAssign
11067: oEmit 29
11069: oGetLocal 10
11071: oPushResult
11072: oEmitInt
11073: oPop 1
11075: oJumpForward 11101
11077: Choice Lookup Table
          40   11055
          38   11055
          36   11055
          35   11051
          34   11051
          28   11047
          33   11043
          30   11043
          31   11043
          41   11039
          29   11039
11100: oEndChoice
11101: oJumpForward 11109
11103: Choice Lookup Table
           0   11032
           1   11019
11108: oEndChoice
11109: oTypeSPop
11110: oGetAddrLocal 7
11112: oPushResult
11113: oNodeIterNext
11114: oPop 1
11116: oGetAddrLocal 8
11118: oPushResult
11119: oGetLocal 7
11121: oPushResult
11122: oNodeIterValue
11123: oPop 1
11125: oAssign
11126: oGetLocal 8
11128: oPushResult
11129: oNodeNull
11130: oPop 1
11132: oChoice 11140
11134: oJumpForward 11150
11136: oJumpForward 11146
11138: oJumpForward 11146
11140: Choice Lookup Table
           0   11138
           1   11134
11145: oEndChoice
11146: oInput 13
11148: oJumpBack 10959
11150: oInput 15
11152: oJumpForward 11157
11154: Choice Lookup Table
          14   10959
11157: oGetLocal 8
11159: oPushResult
11160: oNodeNull
11161: oPop 1
11163: oChoice 11169
11165: oError 15
11167: oJumpForward 11172
11169: Choice Lookup Table
           0   11165
11172: oGetLocal 4
11174: oChoice 11203
11176: oEmit 19
11178: oGetParam 1
11180: oPushResult
11181: oSetResult 31
11183: oPushResult
11184: oNodeGetInt
11185: oPop 2
11187: oPushResult
11188: oEmitInt
11189: oPop 1
11191: oEmit 17
11193: oGetLocal 3
11195: oPushResult
11196: oEmitInt
11197: oPop 1
11199: oEmit 28
11201: oJumpForward 11206
11203: Choice Lookup Table
           1   11176
11206: oGetLocal 1
11208: oChoice 11232
11210: oEmit 65
11212: oGetParam 1
11214: oPushResult
11215: oCall 13717
11217: oPop 1
11219: oJumpForward 11238
11221: oEmit 64
11223: oGetParam 1
11225: oPushResult
11226: oCall 13717
11228: oPop 1
11230: oJumpForward 11238
11232: Choice Lookup Table
           0   11221
           1   11210
11237: oEndChoice
11238: oGetLocal 4
11240: oChoice 11321
11242: oGetLocal 2
11244: oPushResult
11245: oTypeSPush
11246: oPop 1
11248: oTypeSNodeType
11249: oChoice 11295
11251: oEmit 3
11253: oGetLocal 3
11255: oPushResult
11256: oEmitInt
11257: oPop 1
11259: oJumpForward 11319
11261: oEmit 4
11263: oGetLocal 3
11265: oPushResult
11266: oEmitInt
11267: oPop 1
11269: oJumpForward 11319
11271: oError 16
11273: oJumpForward 11319
11275: oEmit 5
11277: oGetLocal 3
11279: oPushResult
11280: oEmitInt
11281: oPop 1
11283: oJumpForward 11319
11285: oEmit 17
11287: oGetLocal 3
11289: oPushResult
11290: oEmitInt
11291: oPop 1
11293: oJumpForward 11319
11295: Choice Lookup Table
          40   11285
          38   11285
          36   11285
          35   11275
          34   11275
          28   11271
          33   11261
          30   11261
          31   11261
          41   11251
          29   11251
11318: oEndChoice
11319: oJumpForward 11324
11321: Choice Lookup Table
           1   11242
11324: oEmit 63
11326: oGetLocal 6
11328: oPushResult
11329: oEmitInt
11330: oPop 1
11332: oReturn
11333: oLocalSpace 2
11335: oGetAddrLocal 2
11337: oPushResult
11338: oGetParam 1
11340: oPushResult
11341: oSetResult 26
11343: oPushResult
11344: oNodeGetString
11345: oPop 2
11347: oAssign
11348: oGetLocal 2
11350: oPushResult
11351: oSetResult 0
11353: oPushResult
11354: equal_string
11355: oPop 2
11357: oChoice 11394
11359: oGetAddrLocal 1
11361: oPushResult
11362: oGetParam 1
11364: oPushResult
11365: oSetResult 4
11367: oPushResult
11368: oNodeGetInt
11369: oPop 2
11371: oPushResult
11372: ID_STRING
11373: oPop 1
11375: oPushResult
11376: oStringAllocLit
11377: oPop 1
11379: oAssign
11380: oJumpForward 11400
11382: oGetAddrLocal 1
11384: oPushResult
11385: oGetLocal 2
11387: oPushResult
11388: oStringAllocLit
11389: oPop 1
11391: oAssign
11392: oJumpForward 11400
11394: Choice Lookup Table
           0   11382
           1   11359
11399: oEndChoice
11400: oEmit 79
11402: oGetParam 1
11404: oPushResult
11405: oCall 13717
11407: oPop 1
11409: oGetLocal 1
11411: oPushResult
11412: oEmitInt
11413: oPop 1
11415: oReturn
11416: oLocalSpace 0
11418: oGetParam 1
11420: oPushResult
11421: oGetGlobal 15
11423: oPushResult
11424: oNodeEqual
11425: oPop 2
11427: oChoice 11467
11429: oInput 14
11431: oCall 4787
11433: oTypeSNodeType
11434: oChoice 11442
11436: oJumpForward 11455
11438: oEmit 30
11440: oJumpForward 11455
11442: Choice Lookup Table
          33   11438
          30   11438
          31   11438
          41   11436
          29   11436
11453: oError 14
11455: oTypeSPop
11456: oGetGlobal 6
11458: oPushResult
11459: oTypeSPush
11460: oPop 1
11462: oInput 15
11464: oReturn
11465: oJumpForward 11470
11467: Choice Lookup Table
           1   11429
11470: oGetParam 1
11472: oPushResult
11473: oGetGlobal 16
11475: oPushResult
11476: oNodeEqual
11477: oPop 2
11479: oChoice 11513
11481: oInput 14
11483: oCall 4787
11485: oTypeSNodeType
11486: oChoice 11494
11488: oEmit 31
11490: oJumpForward 11501
11492: oJumpForward 11501
11494: Choice Lookup Table
          30   11492
          29   11488
11499: oError 14
11501: oTypeSPop
11502: oGetGlobal 9
11504: oPushResult
11505: oTypeSPush
11506: oPop 1
11508: oInput 15
11510: oReturn
11511: oJumpForward 11516
11513: Choice Lookup Table
           1   11481
11516: oGetParam 1
11518: oPushResult
11519: oGetGlobal 17
11521: oPushResult
11522: oNodeEqual
11523: oPop 2
11525: oChoice 11565
11527: oInput 14
11529: oCall 4787
11531: oTypeSNodeType
11532: oChoice 11553
11534: oTypeSTop
11535: oPushResult
11536: oSetResult 44
11538: oPushResult
11539: oNodeGetBoolean
11540: oPop 2
11542: oChoice 11548
11544: oError 28
11546: oJumpForward 11551
11548: Choice Lookup Table
           1   11544
11551: oJumpForward 11558
11553: Choice Lookup Table
          41   11534
11556: oError 14
11558: oEmit 33
11560: oInput 15
11562: oReturn
11563: oJumpForward 11568
11565: Choice Lookup Table
           1   11527
11568: oGetParam 1
11570: oPushResult
11571: oGetGlobal 18
11573: oPushResult
11574: oNodeEqual
11575: oPop 2
11577: oChoice 11617
11579: oInput 14
11581: oCall 4787
11583: oTypeSNodeType
11584: oChoice 11605
11586: oTypeSTop
11587: oPushResult
11588: oSetResult 44
11590: oPushResult
11591: oNodeGetBoolean
11592: oPop 2
11594: oChoice 11600
11596: oError 28
11598: oJumpForward 11603
11600: Choice Lookup Table
           1   11596
11603: oJumpForward 11610
11605: Choice Lookup Table
          41   11586
11608: oError 14
11610: oEmit 32
11612: oInput 15
11614: oReturn
11615: oJumpForward 11620
11617: Choice Lookup Table
           1   11579
11620: oError 16
11622: oReturn
11623: oLocalSpace 1
11625: oGetAddrLocal 1
11627: oPushResult
11628: oGetParam 2
11630: oPushResult
11631: oNodeNew
11632: oPop 1
11634: oAssign
11635: oGetLocal 1
11637: oPushResult
11638: oSetResult 17
11640: oPushResult
11641: oGetParam 1
11643: oPushResult
11644: oNodeSetInt
11645: oPop 3
11647: oGetLocal 1
11649: oPushResult
11650: oTypeAdd
11651: oPop 1
11653: oGetLocal 1
11655: oReturn
11656: oReturn
11657: oLocalSpace 12
11659: oInputChoice 12142
11661: oGetAddrLocal 1
11663: oPushResult
11664: oScopeFindRequire
11665: oAssign
11666: oGetAddrLocal 1
11668: oPushResult
11669: oCall 244
11671: oPop 1
11673: oGetLocal 1
11675: oPushResult
11676: oNodeType
11677: oPop 1
11679: oChoice 11696
11681: oGetParam 1
11683: oPushResult
11684: oGetLocal 1
11686: oPushResult
11687: oSetResult 21
11689: oPushResult
11690: oNodeGet
11691: oPop 2
11693: oAssign
11694: oJumpForward 11707
11696: Choice Lookup Table
          19   11681
11699: oError 2
11701: oGetParam 1
11703: oPushResult
11704: oGetGlobal 6
11706: oAssign
11707: oJumpForward 12165
11709: oInput 16
11711: oGetAddrLocal 2
11713: oPushResult
11714: oNodeVecNew
11715: oAssign
11716: oGetAddrLocal 3
11718: oPushResult
11719: oSetResult 37
11721: oPushResult
11722: oNodeNew
11723: oPop 1
11725: oAssign
11726: oCall 3533
11728: oGetLocal 3
11730: oPushResult
11731: oSetResult 39
11733: oPushResult
11734: oValueTop
11735: oPushResult
11736: oNodeSetInt
11737: oPop 3
11739: oValuePop
11740: oInput 21
11742: oCall 3533
11744: oGetLocal 3
11746: oPushResult
11747: oSetResult 40
11749: oPushResult
11750: oValueTop
11751: oPushResult
11752: oNodeSetInt
11753: oPop 3
11755: oValuePop
11756: oCall 4203
11758: oGetLocal 3
11760: oPushResult
11761: oSetResult 37
11763: oPushResult
11764: oTypeSTop
11765: oPushResult
11766: oNodeSet
11767: oPop 3
11769: oGetLocal 3
11771: oPushResult
11772: oSetResult 17
11774: oPushResult
11775: oTypeSTop
11776: oPushResult
11777: oSetResult 17
11779: oPushResult
11780: oNodeGetInt
11781: oPop 2
11783: oPushResult
11784: oNodeSetInt
11785: oPop 3
11787: oTypeSPop
11788: oGetLocal 3
11790: oPushResult
11791: oTypeAdd
11792: oPop 1
11794: oGetAddrLocal 4
11796: oPushResult
11797: oSetResult 36
11799: oPushResult
11800: oNodeNew
11801: oPop 1
11803: oAssign
11804: oGetLocal 4
11806: oPushResult
11807: oSetResult 38
11809: oPushResult
11810: oGetLocal 3
11812: oPushResult
11813: oNodeSet
11814: oPop 3
11816: oGetLocal 2
11818: oPushResult
11819: oGetLocal 4
11821: oPushResult
11822: oNodeVecAppend
11823: oPop 2
11825: oInputChoice 11833
11827: oJumpForward 11841
11829: oJumpForward 11839
11831: oJumpForward 11839
11833: Choice Lookup Table
          13   11831
          17   11827
11838: oEndChoice
11839: oJumpBack 11716
11841: oInput 40
11843: oGetAddrLocal 5
11845: oPushResult
11846: oCall 11657
11848: oPop 1
11850: oGetAddrLocal 6
11852: oPushResult
11853: oGetLocal 2
11855: oPushResult
11856: oNodeVecSize
11857: oPop 1
11859: oAssign
11860: oGetAddrLocal 6
11862: oPushResult
11863: dec
11864: oPop 1
11866: oGetAddrLocal 7
11868: oPushResult
11869: oGetLocal 2
11871: oPushResult
11872: oGetLocal 6
11874: oPushResult
11875: oNodeVecElement
11876: oPop 2
11878: oAssign
11879: oGetLocal 7
11881: oPushResult
11882: oSetResult 37
11884: oPushResult
11885: oGetLocal 5
11887: oPushResult
11888: oNodeSet
11889: oPop 3
11891: oGetAddrLocal 8
11893: oPushResult
11894: oGetLocal 7
11896: oPushResult
11897: oSetResult 38
11899: oPushResult
11900: oNodeGet
11901: oPop 2
11903: oAssign
11904: oGetAddrLocal 9
11906: oPushResult
11907: oGetLocal 8
11909: oPushResult
11910: oSetResult 40
11912: oPushResult
11913: oNodeGetInt
11914: oPop 2
11916: oPushResult
11917: oGetLocal 8
11919: oPushResult
11920: oSetResult 39
11922: oPushResult
11923: oNodeGetInt
11924: oPop 2
11926: oPushResult
11927: subtract
11928: oPop 2
11930: oAssign
11931: oGetAddrLocal 9
11933: oPushResult
11934: inc
11935: oPop 1
11937: oGetLocal 7
11939: oPushResult
11940: oSetResult 17
11942: oPushResult
11943: oGetLocal 9
11945: oPushResult
11946: oGetLocal 5
11948: oPushResult
11949: oSetResult 17
11951: oPushResult
11952: oNodeGetInt
11953: oPop 2
11955: oPushResult
11956: multiply
11957: oPop 2
11959: oPushResult
11960: oNodeSetInt
11961: oPop 3
11963: oGetLocal 7
11965: oPushResult
11966: oTypeAdd
11967: oPop 1
11969: oGetAddrLocal 5
11971: oPushResult
11972: oGetLocal 7
11974: oAssign
11975: oGetLocal 6
11977: oPushResult
11978: equal_zero
11979: oPop 1
11981: oChoice 11987
11983: oJumpForward 11992
11985: oJumpForward 11990
11987: Choice Lookup Table
           1   11983
11990: oJumpBack 11860
11992: oGetParam 1
11994: oPushResult
11995: oGetLocal 2
11997: oPushResult
11998: oSetResult 0
12000: oPushResult
12001: oNodeVecElement
12002: oPop 2
12004: oAssign
12005: oGetLocal 2
12007: oPushResult
12008: oNodeVecDelete
12009: oPop 1
12011: oJumpForward 12165
12013: oGetAddrLocal 10
12015: oPushResult
12016: oCall 11657
12018: oPop 1
12020: oGetParam 1
12022: oPushResult
12023: oGetLocal 10
12025: oPushResult
12026: oCall 12736
12028: oPop 1
12030: oAssign
12031: oJumpForward 12165
12033: oGetParam 1
12035: oPushResult
12036: oSetResult 38
12038: oPushResult
12039: oNodeNew
12040: oPop 1
12042: oAssign
12043: oSetResult -1
12045: oPushResult
12046: oSetResult 2
12048: oPushResult
12049: oScopeBegin
12050: oPop 2
12052: oSetResult 23
12054: oPushResult
12055: oCall 3234
12057: oPop 1
12059: oGetAddrLocal 11
12061: oPushResult
12062: oScopeCurrent
12063: oPushResult
12064: oSetResult 17
12066: oPushResult
12067: oNodeGetInt
12068: oPop 2
12070: oAssign
12071: oGetLocal 11
12073: oPushResult
12074: equal_zero
12075: oPop 1
12077: oChoice 12083
12079: oError 19
12081: oJumpForward 12086
12083: Choice Lookup Table
           1   12079
12086: oInput 36
12088: oGetFromParam 1
12090: oPushResult
12091: oSetResult 41
12093: oPushResult
12094: oScopeCurrent
12095: oPushResult
12096: oNodeSet
12097: oPop 3
12099: oGetFromParam 1
12101: oPushResult
12102: oSetResult 17
12104: oPushResult
12105: oGetLocal 11
12107: oPushResult
12108: oNodeSetInt
12109: oPop 3
12111: oScopeEnd
12112: oGetFromParam 1
12114: oPushResult
12115: oTypeAdd
12116: oPop 1
12118: oJumpForward 12165
12120: oGetParam 1
12122: oPushResult
12123: oCall 12166
12125: oPop 1
12127: oJumpForward 12165
12129: oInput 40
12131: oGetAddrLocal 12
12133: oPushResult
12134: oCall 11657
12136: oPop 1
12138: oError 16
12140: oJumpForward 12165
12142: Choice Lookup Table
          39   12129
          14   12120
          38   12033
          18   12013
          37   11709
           0   11661
12155: oCall 3533
12157: oInput 21
12159: oCall 3533
12161: oCall 4203
12163: oError 16
12165: oReturn
12166: oLocalSpace 11
12168: oGetParam 1
12170: oPushResult
12171: oSetResult 41
12173: oPushResult
12174: oNodeNew
12175: oPop 1
12177: oAssign
12178: oGetAddrLocal 1
12180: oPushResult
12181: oSetResult 0
12183: oAssign
12184: oGetAddrLocal 2
12186: oPushResult
12187: oSetResult 0
12189: oAssign
12190: oGetAddrLocal 3
12192: oPushResult
12193: oSetResult 1
12195: oAssign
12196: oGetAddrLocal 4
12198: oPushResult
12199: oScopeCurrent
12200: oAssign
12201: oSetResult -1
12203: oPushResult
12204: oSetResult 2
12206: oPushResult
12207: oScopeBegin
12208: oPop 2
12210: oInput 0
12212: oGetAddrLocal 5
12214: oPushResult
12215: oSetResult 17
12217: oPushResult
12218: LAST_ID
12219: oPushResult
12220: oCall 13689
12222: oPop 2
12224: oAssign
12225: oGetAddrLocal 6
12227: oPushResult
12228: oSetResult 17
12230: oPushResult
12231: LAST_ID
12232: oPushResult
12233: oCall 13689
12235: oPop 2
12237: oAssign
12238: oGetLocal 5
12240: oPushResult
12241: oSetResult 21
12243: oPushResult
12244: oGetFromParam 1
12246: oPushResult
12247: oNodeSet
12248: oPop 3
12250: oGetLocal 6
12252: oPushResult
12253: oSetResult 21
12255: oPushResult
12256: oGetFromParam 1
12258: oPushResult
12259: oNodeSet
12260: oPop 3
12262: oGetAddrLocal 7
12264: oPushResult
12265: LAST_ID
12266: oPushResult
12267: ID_STRING
12268: oPop 1
12270: oPushResult
12271: oStringAllocLit
12272: oPop 1
12274: oAssign
12275: oGetLocal 5
12277: oPushResult
12278: oSetResult 32
12280: oPushResult
12281: oGetLocal 7
12283: oPushResult
12284: oNodeSetInt
12285: oPop 3
12287: oGetLocal 6
12289: oPushResult
12290: oSetResult 32
12292: oPushResult
12293: oGetLocal 7
12295: oPushResult
12296: oNodeSetInt
12297: oPop 3
12299: oInputChoice 12377
12301: oGetGlobal 6
12303: oPushResult
12304: oTypeSPush
12305: oPop 1
12307: oCall 3533
12309: oCall 4300
12311: oTypeSPop
12312: oGetLocal 2
12314: oPushResult
12315: equal_zero
12316: oPop 1
12318: oChoice 12339
12320: oValueTop
12321: oPushResult
12322: oGetLocal 1
12324: oPushResult
12325: greater
12326: oPop 2
12328: oChoice 12334
12330: oError 26
12332: oJumpForward 12337
12334: Choice Lookup Table
           0   12330
12337: oJumpForward 12342
12339: Choice Lookup Table
           0   12320
12342: oGetLocal 1
12344: oPushResult
12345: oValueTop
12346: oPushResult
12347: equal
12348: oPop 2
12350: oChoice 12366
12352: oGetFromParam 1
12354: oPushResult
12355: oSetResult 44
12357: oPushResult
12358: oSetResult 1
12360: oPushResult
12361: oNodeSetBoolean
12362: oPop 3
12364: oJumpForward 12369
12366: Choice Lookup Table
           0   12352
12369: oGetAddrLocal 1
12371: oPushResult
12372: oValueTop
12373: oAssign
12374: oValuePop
12375: oJumpForward 12382
12377: Choice Lookup Table
           4   12301
           6   12301
12382: oGetLocal 5
12384: oPushResult
12385: oSetResult 22
12387: oPushResult
12388: oGetLocal 1
12390: oPushResult
12391: oNodeSetInt
12392: oPop 3
12394: oGetLocal 6
12396: oPushResult
12397: oSetResult 22
12399: oPushResult
12400: oGetLocal 1
12402: oPushResult
12403: oNodeSetInt
12404: oPop 3
12406: oGetLocal 5
12408: oPushResult
12409: oScopeDeclare
12410: oPop 1
12412: oGetLocal 4
12414: oPushResult
12415: oScopeEnter
12416: oPop 1
12418: oGetLocal 6
12420: oPushResult
12421: oScopeDeclare
12422: oPop 1
12424: oScopeEnd
12425: oGetAddrLocal 1
12427: oPushResult
12428: inc
12429: oPop 1
12431: oGetAddrLocal 2
12433: oPushResult
12434: inc
12435: oPop 1
12437: oInputChoice 12441
12439: oJumpForward 12446
12441: Choice Lookup Table
          13   12439
12444: oJumpForward 12448
12446: oJumpBack 12210
12448: oInput 15
12450: oGetFromParam 1
12452: oPushResult
12453: oSetResult 41
12455: oPushResult
12456: oScopeCurrent
12457: oPushResult
12458: oNodeSet
12459: oPop 3
12461: oGetFromParam 1
12463: oPushResult
12464: oSetResult 17
12466: oPushResult
12467: oSetResult 4
12469: oPushResult
12470: oNodeSetInt
12471: oPop 3
12473: oScopeEnd
12474: oGetGlobal 2
12476: oPushResult
12477: oCall 13587
12479: oPop 1
12481: oPushResult
12482: oCodePush
12483: oPop 1
12485: oGetGlobal 2
12487: oPushResult
12488: oScopeEnter
12489: oPop 1
12491: oGetAddrLocal 8
12493: oPushResult
12494: oGetLocal 2
12496: oPushResult
12497: oSetResult 1
12499: oPushResult
12500: add
12501: oPop 2
12503: oPushResult
12504: oSetResult 16
12506: oPushResult
12507: multiply
12508: oPop 2
12510: oAssign
12511: oGetAddrLocal 9
12513: oPushResult
12514: oGetLocal 8
12516: oPushResult
12517: oSetResult 8
12519: oPushResult
12520: oScopeAlloc
12521: oPop 2
12523: oAssign
12524: oScopeEnd
12525: oGetFromParam 1
12527: oPushResult
12528: oSetResult 43
12530: oPushResult
12531: oGetLocal 9
12533: oPushResult
12534: oNodeSetInt
12535: oPop 3
12537: oGetAddrLocal 10
12539: oPushResult
12540: oGetFromParam 1
12542: oPushResult
12543: oSetResult 41
12545: oPushResult
12546: oNodeGet
12547: oPop 2
12549: oPushResult
12550: oSetResult 15
12552: oPushResult
12553: oNodeGetIter
12554: oPop 2
12556: oAssign
12557: oGetAddrLocal 11
12559: oPushResult
12560: oGetLocal 10
12562: oPushResult
12563: oNodeIterValue
12564: oPop 1
12566: oAssign
12567: oGetLocal 11
12569: oPushResult
12570: oNodeNull
12571: oPop 1
12573: oChoice 12579
12575: oJumpForward 12666
12577: oJumpForward 12582
12579: Choice Lookup Table
           1   12575
12582: oEmit 16
12584: oGetLocal 9
12586: oPushResult
12587: oEmitInt
12588: oPop 1
12590: oEmit 15
12592: oGetLocal 11
12594: oPushResult
12595: oSetResult 22
12597: oPushResult
12598: oNodeGetInt
12599: oPop 2
12601: oPushResult
12602: oEmitInt
12603: oPop 1
12605: oEmit 26
12607: oGetAddrLocal 9
12609: oPushResult
12610: oGetLocal 9
12612: oPushResult
12613: oSetResult 8
12615: oPushResult
12616: add
12617: oPop 2
12619: oAssign
12620: oEmit 16
12622: oGetLocal 9
12624: oPushResult
12625: oEmitInt
12626: oPop 1
12628: oEmit 16
12630: oGetLocal 11
12632: oPushResult
12633: oSetResult 32
12635: oPushResult
12636: oNodeGetInt
12637: oPop 2
12639: oPushResult
12640: oEmitInt
12641: oPop 1
12643: oEmit 28
12645: oGetAddrLocal 9
12647: oPushResult
12648: oGetLocal 9
12650: oPushResult
12651: oSetResult 8
12653: oPushResult
12654: add
12655: oPop 2
12657: oAssign
12658: oGetAddrLocal 10
12660: oPushResult
12661: oNodeIterNext
12662: oPop 1
12664: oJumpBack 12557
12666: oEmit 16
12668: oGetLocal 9
12670: oPushResult
12671: oEmitInt
12672: oPop 1
12674: oEmit 15
12676: oSetResult 0
12678: oPushResult
12679: oEmitInt
12680: oPop 1
12682: oEmit 26
12684: oGetAddrLocal 9
12686: oPushResult
12687: oGetLocal 9
12689: oPushResult
12690: oSetResult 8
12692: oPushResult
12693: add
12694: oPop 2
12696: oAssign
12697: oEmit 16
12699: oGetLocal 9
12701: oPushResult
12702: oEmitInt
12703: oPop 1
12705: oEmit 15
12707: oSetResult 0
12709: oPushResult
12710: oEmitInt
12711: oPop 1
12713: oEmit 28
12715: oGetAddrLocal 9
12717: oPushResult
12718: oGetLocal 9
12720: oPushResult
12721: oSetResult 8
12723: oPushResult
12724: add
12725: oPop 2
12727: oAssign
12728: oCodePop
12729: oGetFromParam 1
12731: oPushResult
12732: oTypeAdd
12733: oPop 1
12735: oReturn
12736: oLocalSpace 1
12738: oGetAddrLocal 1
12740: oPushResult
12741: oGetParam 1
12743: oPushResult
12744: oSetResult 36
12746: oPushResult
12747: oNodeGet
12748: oPop 2
12750: oAssign
12751: oGetLocal 1
12753: oPushResult
12754: oNodeNull
12755: oPop 1
12757: oChoice 12813
12759: oGetAddrLocal 1
12761: oPushResult
12762: oSetResult 34
12764: oPushResult
12765: oNodeNew
12766: oPop 1
12768: oAssign
12769: oGetLocal 1
12771: oPushResult
12772: oSetResult 37
12774: oPushResult
12775: oGetParam 1
12777: oPushResult
12778: oNodeSet
12779: oPop 3
12781: oGetLocal 1
12783: oPushResult
12784: oSetResult 17
12786: oPushResult
12787: oSetResult 8
12789: oPushResult
12790: oNodeSetInt
12791: oPop 3
12793: oGetLocal 1
12795: oPushResult
12796: oTypeAdd
12797: oPop 1
12799: oGetParam 1
12801: oPushResult
12802: oSetResult 36
12804: oPushResult
12805: oGetLocal 1
12807: oPushResult
12808: oNodeSet
12809: oPop 3
12811: oJumpForward 12816
12813: Choice Lookup Table
           1   12759
12816: oGetLocal 1
12818: oReturn
12819: oReturn
12820: oLocalSpace 2
12822: oGetParam 1
12824: oPushResult
12825: oNodeType
12826: oPop 1
12828: oChoice 12898
12830: oMININT
12831: oReturn
12832: oJumpForward 12914
12834: oSetResult 0
12836: oReturn
12837: oJumpForward 12914
12839: oSetResult 0
12841: oReturn
12842: oJumpForward 12914
12844: oGetAddrLocal 1
12846: oPushResult
12847: oGetParam 1
12849: oPushResult
12850: oSetResult 41
12852: oPushResult
12853: oNodeGet
12854: oPop 2
12856: oAssign
12857: oGetAddrLocal 2
12859: oPushResult
12860: oGetLocal 1
12862: oPushResult
12863: oSetResult 15
12865: oPushResult
12866: oNodeGetIter
12867: oPop 2
12869: oPushResult
12870: oNodeIterValue
12871: oPop 1
12873: oAssign
12874: oGetLocal 2
12876: oPushResult
12877: oSetResult 22
12879: oPushResult
12880: oNodeGetInt
12881: oPop 2
12883: oReturn
12884: oJumpForward 12914
12886: oGetParam 1
12888: oPushResult
12889: oSetResult 39
12891: oPushResult
12892: oNodeGetInt
12893: oPop 2
12895: oReturn
12896: oJumpForward 12914
12898: Choice Lookup Table
          37   12886
          41   12844
          33   12839
          31   12834
          29   12830
12909: oError 3
12911: oSetResult 0
12913: oReturn
12914: oReturn
12915: oLocalSpace 2
12917: oGetParam 1
12919: oPushResult
12920: oNodeType
12921: oPop 1
12923: oChoice 12993
12925: oMAXINT
12926: oReturn
12927: oJumpForward 13009
12929: oSetResult 1
12931: oReturn
12932: oJumpForward 13009
12934: oSetResult 255
12936: oReturn
12937: oJumpForward 13009
12939: oGetAddrLocal 1
12941: oPushResult
12942: oGetParam 1
12944: oPushResult
12945: oSetResult 41
12947: oPushResult
12948: oNodeGet
12949: oPop 2
12951: oAssign
12952: oGetAddrLocal 2
12954: oPushResult
12955: oGetLocal 1
12957: oPushResult
12958: oSetResult 15
12960: oPushResult
12961: oNodeGetIterLast
12962: oPop 2
12964: oPushResult
12965: oNodeIterValue
12966: oPop 1
12968: oAssign
12969: oGetLocal 2
12971: oPushResult
12972: oSetResult 22
12974: oPushResult
12975: oNodeGetInt
12976: oPop 2
12978: oReturn
12979: oJumpForward 13009
12981: oGetParam 1
12983: oPushResult
12984: oSetResult 40
12986: oPushResult
12987: oNodeGetInt
12988: oPop 2
12990: oReturn
12991: oJumpForward 13009
12993: Choice Lookup Table
          37   12981
          41   12939
          33   12934
          31   12929
          29   12925
13004: oError 3
13006: oSetResult 0
13008: oReturn
13009: oReturn
13010: oLocalSpace 5
13012: oGetAddrGlobal 1
13014: oPushResult
13015: oWorkspaceNew
13016: oAssign
13017: oSetResult 0
13019: oPushResult
13020: oSetResult 0
13022: oPushResult
13023: oScopeBegin
13024: oPop 2
13026: oGetAddrLocal 2
13028: oPushResult
13029: oScopeCurrent
13030: oAssign
13031: oCall 13759
13033: oEmit 67
13035: oSetResult 0
13037: oPushResult
13038: oEmitInt
13039: oPop 1
13041: oGetAddrLocal 3
13043: oPushResult
13044: oLabelNew
13045: oAssign
13046: oEmit 61
13048: oSetResult 0
13050: oPushResult
13051: oEmitInt
13052: oPop 1
13054: oEmit 64
13056: oGetLocal 3
13058: oPushResult
13059: oEmitLabel
13060: oPop 1
13062: oEmit 63
13064: oSetResult 0
13066: oPushResult
13067: oEmitInt
13068: oPop 1
13070: oEmit 66
13072: oInput 28
13074: oInput 0
13076: oGetAddrLocal 4
13078: oPushResult
13079: oSetResult 4
13081: oPushResult
13082: oNodeNew
13083: oPop 1
13085: oAssign
13086: oGetLocal 4
13088: oPushResult
13089: oSetResult 4
13091: oPushResult
13092: LAST_ID
13093: oPushResult
13094: oNodeSetInt
13095: oPop 3
13097: oGetGlobal 1
13099: oPushResult
13100: oSetResult 2
13102: oPushResult
13103: oGetLocal 4
13105: oPushResult
13106: oNodeSet
13107: oPop 3
13109: oInputChoice 13183
13111: oInput 0
13113: oGetAddrLocal 1
13115: oPushResult
13116: oSetResult 20
13118: oPushResult
13119: LAST_ID
13120: oPushResult
13121: oCall 13689
13123: oPop 2
13125: oAssign
13126: oGetLocal 1
13128: oPushResult
13129: oSetResult 21
13131: oPushResult
13132: oGetGlobal 5
13134: oPushResult
13135: oNodeSet
13136: oPop 3
13138: oGetLocal 1
13140: oPushResult
13141: oScopeDeclareAlloc
13142: oPop 1
13144: oInput 13
13146: oInput 0
13148: oGetAddrLocal 1
13150: oPushResult
13151: oSetResult 20
13153: oPushResult
13154: LAST_ID
13155: oPushResult
13156: oCall 13689
13158: oPop 2
13160: oAssign
13161: oGetLocal 1
13163: oPushResult
13164: oSetResult 21
13166: oPushResult
13167: oGetGlobal 5
13169: oPushResult
13170: oNodeSet
13171: oPop 3
13173: oGetLocal 1
13175: oPushResult
13176: oScopeDeclareAlloc
13177: oPop 1
13179: oInput 15
13181: oJumpForward 13186
13183: Choice Lookup Table
          14   13111
13186: oInput 5
13188: oGetLocal 4
13190: oPushResult
13191: oCall 34
13193: oPop 1
13195: oInputChoice 13206
13197: oGetLocal 4
13199: oPushResult
13200: oCall 7
13202: oPop 1
13204: oJumpForward 13209
13206: Choice Lookup Table
          59   13197
13209: oGetLocal 4
13211: oPushResult
13212: oCall 287
13214: oPop 1
13216: oSetResult 0
13218: oPushResult
13219: oSetResult 0
13221: oPushResult
13222: oScopeBegin
13223: oPop 2
13225: oGetAddrGlobal 2
13227: oPushResult
13228: oScopeCurrent
13229: oAssign
13230: oSetResult 0
13232: oPushResult
13233: oSetResult 1
13235: oPushResult
13236: oScopeBegin
13237: oPop 2
13239: oScopeCurrent
13240: oPushResult
13241: oSetResult 16
13243: oPushResult
13244: oGetGlobal 2
13246: oPushResult
13247: oNodeSet
13248: oPop 3
13250: oGetAddrGlobal 3
13252: oPushResult
13253: oScopeCurrent
13254: oAssign
13255: oGetLocal 4
13257: oPushResult
13258: oSetResult 7
13260: oPushResult
13261: oGetGlobal 3
13263: oPushResult
13264: oNodeSet
13265: oPop 3
13267: oScopeEnd
13268: oSetResult 21
13270: oPushResult
13271: oCall 13338
13273: oPop 1
13275: oGetGlobal 3
13277: oPushResult
13278: oScopeEnter
13279: oPop 1
13281: oGetAddrLocal 5
13283: oPushResult
13284: oSetResult 1
13286: oAssign
13287: oGetLocal 3
13289: oPushResult
13290: oGetGlobal 2
13292: oPushResult
13293: oGetLocal 5
13295: oPushResult
13296: oCall 13489
13298: oPop 3
13300: oScopeEnd
13301: oInput 20
13303: oCall 13394
13305: oScopeEnd
13306: oGetLocal 4
13308: oPushResult
13309: oCall 349
13311: oPop 1
13313: oReturn
13314: oLocalSpace 0
13316: oGetParam 2
13318: oPushResult
13319: oCall 13338
13321: oPop 1
13323: oGetParam 1
13325: oPushResult
13326: oScopeCurrent
13327: oPushResult
13328: oSetResult 0
13330: oPushResult
13331: oCall 13489
13333: oPop 3
13335: oCall 13394
13337: oReturn
13338: oLocalSpace 0
13340: oInputChoice 13371
13342: oCall 2520
13344: oJumpForward 13386
13346: oCall 3178
13348: oJumpForward 13386
13350: oGetParam 1
13352: oPushResult
13353: oCall 3234
13355: oPop 1
13357: oJumpForward 13386
13359: oCall 3468
13361: oJumpForward 13386
13363: oCall 1743
13365: oJumpForward 13386
13367: oCall 2178
13369: oJumpForward 13386
13371: Choice Lookup Table
          30   13367
          29   13363
          34   13359
          33   13350
          32   13346
          31   13342
13384: oJumpForward 13388
13386: oJumpBack 13340
13388: oCall 13391
13390: oReturn
13391: oLocalSpace 0
13393: oReturn
13394: oLocalSpace 2
13396: oGetAddrLocal 1
13398: oPushResult
13399: oScopeCurrent
13400: oPushResult
13401: oSetResult 15
13403: oPushResult
13404: oNodeGetIter
13405: oPop 2
13407: oAssign
13408: oGetAddrLocal 2
13410: oPushResult
13411: oGetLocal 1
13413: oPushResult
13414: oNodeIterValue
13415: oPop 1
13417: oAssign
13418: oGetLocal 2
13420: oPushResult
13421: oNodeNull
13422: oPop 1
13424: oChoice 13428
13426: oJumpForward 13433
13428: Choice Lookup Table
           0   13426
13431: oJumpForward 13488
13433: oGetLocal 2
13435: oPushResult
13436: oNodeType
13437: oPop 1
13439: oChoice 13477
13441: oGetLocal 2
13443: oPushResult
13444: oSetResult 35
13446: oPushResult
13447: oNodeGetBoolean
13448: oPop 2
13450: oChoice 13472
13452: oGetLocal 2
13454: oPushResult
13455: oSetResult 28
13457: oPushResult
13458: oNodeGetBoolean
13459: oPop 2
13461: oChoice 13467
13463: oError 27
13465: oJumpForward 13470
13467: Choice Lookup Table
           1   13463
13470: oJumpForward 13475
13472: Choice Lookup Table
           0   13452
13475: oJumpForward 13480
13477: Choice Lookup Table
          26   13441
13480: oGetAddrLocal 1
13482: oPushResult
13483: oNodeIterNext
13484: oPop 1
13486: oJumpBack 13408
13488: oReturn
13489: oLocalSpace 3
13491: oEmit 77
13493: oGetParam 3
13495: oPushResult
13496: oEmitLabel
13497: oPop 1
13499: oEmit 67
13501: oGetAddrLocal 1
13503: oPushResult
13504: Here
13505: oAssign
13506: oEmit 90
13508: oGetParam 1
13510: oChoice 13516
13512: oCall 1220
13514: oJumpForward 13519
13516: Choice Lookup Table
           1   13512
13519: oGetAddrLocal 2
13521: oPushResult
13522: oGetParam 2
13524: oPushResult
13525: oSetResult 19
13527: oPushResult
13528: oNodeGetCode
13529: oPop 2
13531: oAssign
13532: oGetLocal 2
13534: oPushResult
13535: oEmitCode
13536: oPop 1
13538: oGetParam 2
13540: oPushResult
13541: oSetResult 19
13543: oPushResult
13544: oSetResult 0
13546: oPushResult
13547: oNodeSetCode
13548: oPop 3
13550: oCall 8578
13552: oGetParam 1
13554: oChoice 13560
13556: oCall 1305
13558: oJumpForward 13563
13560: Choice Lookup Table
           1   13556
13563: oEmit 66
13565: oGetAddrLocal 3
13567: oPushResult
13568: oScopeCurrent
13569: oPushResult
13570: oSetResult 17
13572: oPushResult
13573: oNodeGetInt
13574: oPop 2
13576: oAssign
13577: oGetLocal 1
13579: oPushResult
13580: oGetLocal 3
13582: oPushResult
13583: oPatch
13584: oPop 2
13586: oReturn
13587: oLocalSpace 1
13589: oGetAddrLocal 1
13591: oPushResult
13592: oGetParam 1
13594: oPushResult
13595: oSetResult 19
13597: oPushResult
13598: oNodeGetCode
13599: oPop 2
13601: oAssign
13602: oGetLocal 1
13604: oPushResult
13605: oSetResult 0
13607: oPushResult
13608: equal_code
13609: oPop 2
13611: oChoice 13632
13613: oGetAddrLocal 1
13615: oPushResult
13616: oCodeNew
13617: oAssign
13618: oGetParam 1
13620: oPushResult
13621: oSetResult 19
13623: oPushResult
13624: oGetLocal 1
13626: oPushResult
13627: oNodeSetCode
13628: oPop 3
13630: oJumpForward 13635
13632: Choice Lookup Table
           1   13613
13635: oGetLocal 1
13637: oReturn
13638: oReturn
13639: oLocalSpace 0
13641: oScopeCurrent
13642: oPushResult
13643: oSetResult 14
13645: oPushResult
13646: oNodeGetInt
13647: oPop 2
13649: oReturn
13650: oReturn
13651: oLocalSpace 0
13653: oGetParam 1
13655: oPushResult
13656: oSetResult 20
13658: oPushResult
13659: oNodeGet
13660: oPop 2
13662: oPushResult
13663: oSetResult 14
13665: oPushResult
13666: oNodeGetInt
13667: oPop 2
13669: oReturn
13670: oReturn
13671: oLocalSpace 0
13673: oCall 13639
13675: oPushResult
13676: oGetParam 1
13678: oPushResult
13679: oCall 13651
13681: oPop 1
13683: oPushResult
13684: subtract
13685: oPop 2
13687: oReturn
13688: oReturn
13689: oLocalSpace 1
13691: oGetAddrLocal 1
13693: oPushResult
13694: oGetParam 2
13696: oPushResult
13697: oNodeNew
13698: oPop 1
13700: oAssign
13701: oGetLocal 1
13703: oPushResult
13704: oSetResult 4
13706: oPushResult
13707: oGetParam 1
13709: oPushResult
13710: oNodeSetInt
13711: oPop 3
13713: oGetLocal 1
13715: oReturn
13716: oReturn
13717: oLocalSpace 0
13719: oGetParam 1
13721: oPushResult
13722: oSetResult 22
13724: oPushResult
13725: oNodeGetInt
13726: oPop 2
13728: oPushResult
13729: oEmitInt
13730: oPop 1
13732: oReturn
13733: oLocalSpace 1
13735: oGetAddrLocal 1
13737: oPushResult
13738: oSetResult 14
13740: oPushResult
13741: oGetParam 1
13743: oPushResult
13744: oCall 13689
13746: oPop 2
13748: oAssign
13749: oGetLocal 1
13751: oPushResult
13752: oScopeDeclare
13753: oPop 1
13755: oGetLocal 1
13757: oReturn
13758: oReturn
13759: oLocalSpace 1
13761: oGetAddrGlobal 4
13763: oPushResult
13764: oId_mysystem
13765: oAssign
13766: oGetAddrGlobal 5
13768: oPushResult
13769: oSetResult 28
13771: oPushResult
13772: oSetResult 4
13774: oPushResult
13775: oCall 11623
13777: oPop 2
13779: oAssign
13780: oGetAddrGlobal 6
13782: oPushResult
13783: oSetResult 29
13785: oPushResult
13786: oSetResult 4
13788: oPushResult
13789: oCall 11623
13791: oPop 2
13793: oAssign
13794: oGetAddrGlobal 7
13796: oPushResult
13797: oSetResult 31
13799: oPushResult
13800: oSetResult 1
13802: oPushResult
13803: oCall 11623
13805: oPop 2
13807: oAssign
13808: oGetAddrGlobal 8
13810: oPushResult
13811: oSetResult 32
13813: oPushResult
13814: oSetResult 1
13816: oPushResult
13817: oCall 11623
13819: oPop 2
13821: oAssign
13822: oGetAddrGlobal 9
13824: oPushResult
13825: oSetResult 33
13827: oPushResult
13828: oSetResult 1
13830: oPushResult
13831: oCall 11623
13833: oPop 2
13835: oAssign
13836: oGetAddrGlobal 10
13838: oPushResult
13839: oGetGlobal 9
13841: oPushResult
13842: oCall 12736
13844: oPop 1
13846: oAssign
13847: oGetAddrGlobal 11
13849: oPushResult
13850: oSetResult 30
13852: oPushResult
13853: oSetResult 1
13855: oPushResult
13856: oCall 11623
13858: oPop 2
13860: oAssign
13861: oGetAddrGlobal 12
13863: oPushResult
13864: oSetResult 35
13866: oPushResult
13867: oSetResult 8
13869: oPushResult
13870: oCall 11623
13872: oPop 2
13874: oAssign
13875: oGetGlobal 12
13877: oPushResult
13878: oSetResult 37
13880: oPushResult
13881: oGetGlobal 11
13883: oPushResult
13884: oNodeSet
13885: oPop 3
13887: oGetAddrGlobal 13
13889: oPushResult
13890: oSetResult 39
13892: oPushResult
13893: oSetResult 256
13895: oPushResult
13896: oCall 11623
13898: oPop 2
13900: oAssign
13901: oGetAddrGlobal 14
13903: oPushResult
13904: oSetResult 40
13906: oPushResult
13907: oSetResult 256
13909: oPushResult
13910: oCall 11623
13912: oPop 2
13914: oAssign
13915: oGetGlobal 14
13917: oPushResult
13918: oSetResult 42
13920: oPushResult
13921: oSetResult 255
13923: oPushResult
13924: oNodeSetInt
13925: oPop 3
13927: oGetAddrLocal 1
13929: oPushResult
13930: oSetResult 19
13932: oPushResult
13933: oId_File
13934: oPushResult
13935: oCall 13689
13937: oPop 2
13939: oAssign
13940: oGetLocal 1
13942: oPushResult
13943: oSetResult 21
13945: oPushResult
13946: oGetGlobal 5
13948: oPushResult
13949: oNodeSet
13950: oPop 3
13952: oGetLocal 1
13954: oPushResult
13955: oScopeDeclare
13956: oPop 1
13958: oGetAddrLocal 1
13960: oPushResult
13961: oSetResult 19
13963: oPushResult
13964: oId_Integer
13965: oPushResult
13966: oCall 13689
13968: oPop 2
13970: oAssign
13971: oGetLocal 1
13973: oPushResult
13974: oSetResult 21
13976: oPushResult
13977: oGetGlobal 6
13979: oPushResult
13980: oNodeSet
13981: oPop 3
13983: oGetLocal 1
13985: oPushResult
13986: oScopeDeclare
13987: oPop 1
13989: oGetAddrLocal 1
13991: oPushResult
13992: oSetResult 19
13994: oPushResult
13995: oId_Boolean
13996: oPushResult
13997: oCall 13689
13999: oPop 2
14001: oAssign
14002: oGetLocal 1
14004: oPushResult
14005: oSetResult 21
14007: oPushResult
14008: oGetGlobal 7
14010: oPushResult
14011: oNodeSet
14012: oPop 3
14014: oGetLocal 1
14016: oPushResult
14017: oScopeDeclare
14018: oPop 1
14020: oGetAddrLocal 1
14022: oPushResult
14023: oSetResult 19
14025: oPushResult
14026: oId_Char
14027: oPushResult
14028: oCall 13689
14030: oPop 2
14032: oAssign
14033: oGetLocal 1
14035: oPushResult
14036: oSetResult 21
14038: oPushResult
14039: oGetGlobal 9
14041: oPushResult
14042: oNodeSet
14043: oPop 3
14045: oGetLocal 1
14047: oPushResult
14048: oScopeDeclare
14049: oPop 1
14051: oGetAddrLocal 1
14053: oPushResult
14054: oSetResult 19
14056: oPushResult
14057: oId_Byte
14058: oPushResult
14059: oCall 13689
14061: oPop 2
14063: oAssign
14064: oGetLocal 1
14066: oPushResult
14067: oSetResult 21
14069: oPushResult
14070: oGetGlobal 11
14072: oPushResult
14073: oNodeSet
14074: oPop 3
14076: oGetLocal 1
14078: oPushResult
14079: oScopeDeclare
14080: oPop 1
14082: oGetAddrLocal 1
14084: oPushResult
14085: oSetResult 19
14087: oPushResult
14088: oId_Pointer
14089: oPushResult
14090: oCall 13689
14092: oPop 2
14094: oAssign
14095: oGetLocal 1
14097: oPushResult
14098: oSetResult 21
14100: oPushResult
14101: oGetGlobal 12
14103: oPushResult
14104: oNodeSet
14105: oPop 3
14107: oGetLocal 1
14109: oPushResult
14110: oScopeDeclare
14111: oPop 1
14113: oGetAddrLocal 1
14115: oPushResult
14116: oSetResult 19
14118: oPushResult
14119: oId_ShortString
14120: oPushResult
14121: oCall 13689
14123: oPop 2
14125: oAssign
14126: oGetLocal 1
14128: oPushResult
14129: oSetResult 21
14131: oPushResult
14132: oGetGlobal 14
14134: oPushResult
14135: oNodeSet
14136: oPop 3
14138: oGetLocal 1
14140: oPushResult
14141: oScopeDeclare
14142: oPop 1
14144: oGetAddrLocal 1
14146: oPushResult
14147: oSetResult 16
14149: oPushResult
14150: oId_True
14151: oPushResult
14152: oCall 13689
14154: oPop 2
14156: oAssign
14157: oGetLocal 1
14159: oPushResult
14160: oSetResult 21
14162: oPushResult
14163: oGetGlobal 7
14165: oPushResult
14166: oNodeSet
14167: oPop 3
14169: oGetLocal 1
14171: oPushResult
14172: oSetResult 22
14174: oPushResult
14175: oSetResult 1
14177: oPushResult
14178: oNodeSetInt
14179: oPop 3
14181: oGetLocal 1
14183: oPushResult
14184: oScopeDeclare
14185: oPop 1
14187: oGetAddrLocal 1
14189: oPushResult
14190: oSetResult 16
14192: oPushResult
14193: oId_False
14194: oPushResult
14195: oCall 13689
14197: oPop 2
14199: oAssign
14200: oGetLocal 1
14202: oPushResult
14203: oSetResult 21
14205: oPushResult
14206: oGetGlobal 7
14208: oPushResult
14209: oNodeSet
14210: oPop 3
14212: oGetLocal 1
14214: oPushResult
14215: oSetResult 22
14217: oPushResult
14218: oSetResult 0
14220: oPushResult
14221: oNodeSetInt
14222: oPop 3
14224: oGetLocal 1
14226: oPushResult
14227: oScopeDeclare
14228: oPop 1
14230: oGetAddrLocal 1
14232: oPushResult
14233: oSetResult 16
14235: oPushResult
14236: oId_Nil
14237: oPushResult
14238: oCall 13689
14240: oPop 2
14242: oAssign
14243: oGetLocal 1
14245: oPushResult
14246: oSetResult 21
14248: oPushResult
14249: oGetGlobal 12
14251: oPushResult
14252: oNodeSet
14253: oPop 3
14255: oGetLocal 1
14257: oPushResult
14258: oSetResult 22
14260: oPushResult
14261: oSetResult 0
14263: oPushResult
14264: oNodeSetInt
14265: oPop 3
14267: oGetLocal 1
14269: oPushResult
14270: oScopeDeclare
14271: oPop 1
14273: oGetAddrGlobal 15
14275: oPushResult
14276: oId_Ord
14277: oPushResult
14278: oCall 13733
14280: oPop 1
14282: oAssign
14283: oGetAddrGlobal 16
14285: oPushResult
14286: oId_Chr
14287: oPushResult
14288: oCall 13733
14290: oPop 1
14292: oAssign
14293: oGetAddrGlobal 17
14295: oPushResult
14296: oId_Pred
14297: oPushResult
14298: oCall 13733
14300: oPop 1
14302: oAssign
14303: oGetAddrGlobal 18
14305: oPushResult
14306: oId_Succ
14307: oPushResult
14308: oCall 13733
14310: oPop 1
14312: oAssign
14313: oReturn
