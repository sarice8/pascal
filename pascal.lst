   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    ByteType
   2: Node    StringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 215:    oScopeBegin( 0, allocDown )
 224:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 235:    initScope = oScopeCurrent
 240:    oNodeSet( program, qMainRoutineScope, initScope )
 252:    oScopeEnd
      
 253:    @BlockDecls( nGlobalVar )
      
      
 260:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 266:    boolean isMain = true
 272:    @BlockStmt( mainLabel, globalScope, isMain )
      
 285:    oScopeEnd   % main routine scope
      
 286:    '.'
 288:    @CheckForUndefinedLabels
 290:    oScopeEnd   % global scope
 291:    @EndUsedUnits( program )   % used units scopes
 299:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 299: UsesClause( Node user ):
 301:    {
 301:       pIdent
 303:       Node unit = @FindOrCompileUnit( LAST_ID )
 313:       [ equal_node( unit, Null )
 323:          | false :
 324:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 336:             Node unitRef = oNodeNew( nUnitRef )
 346:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 365:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 384:             oScopeDeclare( unitRef )
 390:          | * :
 395:       ]
 395:       [
 395:          | ',' :
 397:          | * :  >
 404:       ]
 404:    }   
 406:    ';'
 409:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 409: ResolveUnitRef( inout Node decl ):
 411:    [ oNodeType( decl )
 418:       | nUnitRef :
 419:          Node scope = oNodeGet( decl, qPublicScope )
 432:          '.'
 434:          pIdent
 436:          decl = oScopeFindRequireInScope( scope )
 446:       | * :
 451:    ];
      
      
 452: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 454:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 467:    {
 467:       Node unit = oNodeIterValue( unitIt )
 477:       [ oNodeNull( unit )
 484:          | false :
 485:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 498:          | * :
 503:             >
 505:       ]
 505:       oNodeIterNext( unitIt )
 511:    }
 514:    ;
      
 514: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 516:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 529:    {
 529:       Node unit = oNodeIterValue( unitIt )
 539:       [ oNodeNull( unit )
 546:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 547:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 563:                | true :
 564:                | false :  #eInternalScopeMismatch
 568:             ]
 576:             oScopeEnd
 577:          | * :
 582:             >
 584:       ]
 584:       oNodeIterPrev( unitIt )
 590:    }
 593:    ;
      
      
 593: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 595:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 614:    [ equal_node( unit, Null )
 624:       | false :  >> unit
 628:       | * :
 633:    ]
      
         % If not, search for the source file on disk
 633:    boolean ok = oIncludeUnitFile( id )
 643:    [ ok
 646:       | false :  #eCantFindUnitFile  >> Null
 652:       | * :
 657:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 657:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 663:    oIncludeEnd
 664:    >> unit;
      
      
      
 668: Unit >> Node:
 670:    pUnit
 672:    pIdent
 674:    Node unit = oNodeNew( nUnit )
 684:    oNodeSetInt( unit, qIdent, LAST_ID )
 695:    Node unitImpl = oNodeNew( nUnitImpl )
 705:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 716:    oNodeSet( unit, qImpl, unitImpl )
 728:    ';'
      
         % mandatory sections
      
 730:    pInterface
 732:    [
 732:       | pUses :   @UsesClause( unit )
 741:       | * :
 746:    ]
 746:    @EnterUsedUnits( unit )
      
 753:    oScopeBegin( 0, allocGlobal )
 762:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 773:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 778:    oScopeBegin( 0, allocDown )
 787:    initScope = oScopeCurrent
 792:    oNodeSet( unit, qInitRoutineScope, initScope )
 804:    oScopeEnd
      
 805:    @UnitInterface( unit )
 812:    oScopeEnd  % interface scope
      
 813:    pImplementation
 815:    [
 815:       | pUses :   @UsesClause( unitImpl )
 824:       | * :
 829:    ]
 829:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 836:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 849:    oScopeBegin( 0, allocGlobal )
 858:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 869:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 887:    globalScope = oScopeCurrent
 892:    @UnitImplementation( unit )
      
 899:    [
 899:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 911:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 926:    ]
 926:    [
 926:       | pFinalization :  @UnitFinalization( unit, true )
 938:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 953:    ]
 953:    pEnd  '.'
      
 957:    oScopeEnd  % impl scope
 958:    oScopeEnd  % interface scope
 959:    @EndUsedUnits( unitImpl )  % used units scopes
 966:    @EndUsedUnits( unit )
 973:    oNodeAddLast( workspace, qUnits, unit )
 985:    >> unit;
      
      
 989: UnitInterface( Node unit ):
 991:    {[
 991:       | pConst :     @ConstDecl
 995:       | pType :      @TypeDecl
 999:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1008:       | pProcedure :
1010:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1016:          [
1016:             | pExternal :
1018:                @ExternalDecl( decl )
1025:                ';'
1027:             | * :
1032:          ]
      
1032:       | pFunction :
1034:          Node decl = @FuncHeaderDecl
1040:          [
1040:             | pExternal :
1042:                @ExternalDecl( decl )
1049:                ';'
1051:             | * :
1056:          ]
      
1056:       | * :          >
1071:    ]}
1074:    ;
      
1074: UnitImplementation( Node unit ):
1076:    @BlockDecls( nGlobalVar )
1084:    ;
      
      
1084: UnitInitialization( Node unit, boolean hasStmts ):
1086:    Label label = oLabelNew
1091:    .tLabel  oEmitLabel( label )
1099:    oNodeSetLabel( unit, qInitLabel, label )
      
1111:    int patchLS
1111:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1120:    Node scope
1120:    Code initCode
      
1120:    scope = oNodeGet( unit, qPublicScope )
1133:    initCode = oNodeGetCode( scope, qInitCode )
1146:    oEmitCode( initCode )
1152:    oNodeSetCode( scope, qInitCode, codeNull )
      
1164:    scope = oNodeGet( unit, qPrivateScope )
1177:    initCode = oNodeGetCode( scope, qInitCode )
1190:    oEmitCode( initCode )
1196:    oNodeSetCode( scope, qInitCode, codeNull )
      
1208:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1221:    [ hasStmts
1224:       | true :     
1225:          @Statement
1227:          {[
1227:             | ';' :  @Statement
1231:             | * :    >
1238:          ]}
1240:       | * :
1245:    ]
      
1245:    .tReturn
      
1247:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1259:    oPatch( patchLS, localSpace )
1268:    oScopeEnd   % init routine scope, for temporaries
1270:    ;
      
      
1270: UnitFinalization( Node unit, boolean hasStmts ):
1272:    Label label = oLabelNew
1277:    .tLabel  oEmitLabel( label )
1285:    oNodeSetLabel( unit, qFinalLabel, label )
      
1297:    int patchLS
1297:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1306:    oScopeBegin( 0, allocDown )
      
1315:    [ hasStmts
1318:       | true :     
1319:          @Statement
1321:          {[
1321:             | ';' :  @Statement
1325:             | * :    >
1332:          ]}
1334:       | * :
1339:    ]
      
1339:    .tReturn
      
1341:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1353:    oPatch( patchLS, localSpace )
1362:    oScopeEnd   % final routine scope, for temporaries
1364:    ;
      
      
1364: Block( node_type varNodeType, Label labelForBody ):
1366:    @BlockDecls( varNodeType )
1373:    @BlockStmt( labelForBody, oScopeCurrent, false )
1385:    @CheckForUndefinedLabels
1388:    ;
      
      
1388: BlockDecls( node_type varNodeType ):
1390:    {[
1390:       | pConst :     @ConstDecl
1394:       | pType :      @TypeDecl
1398:       | pVar :       @VarDecl( varNodeType )
1407:       | pLabel :     @LabelDecl
1411:       | pProcedure : @ProcDecl
1415:       | pFunction :  @FuncDecl
1419:       | * :          >
1436:    ]}
1438:    @CheckForUndefinedMethods
1441:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1441: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1444:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1444: CheckForUndefinedLabels:
1446:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1458:    {
1458:       Node decl = oNodeIterValue( it )
1468:       [ oNodeNull( decl )
1475:          | false :
1476:          | * :  >
1483:       ]
1483:       [ oNodeType( decl )
1490:          | nLabel :
1491:             [ oNodeGetBoolean( decl, qDefined )
1501:                | false :
1502:                   [ oNodeGetBoolean( decl, qUsed )
1512:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1515:                      | * :
1520:                   ]
1520:                | * :
1525:             ]
1525:          | * :
1530:       ]
1530:       oNodeIterNext( it )
1536:    }
1539:    ;
      
      
1539: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1541:    NodeIter it = oNodeGetIter( workspace, qUnits )
1554:    {
1554:       Node unit = oNodeIterValue( it )
1564:       [ oNodeNull( unit )
1571:          | true :  >
1574:          | false :
1576:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1584:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1599:             .tFreeActuals  oEmitInt( 0 )
1607:             oNodeIterNext( it )
1613:       ]
1621:    };
      
      
1624: FinalizeUnits:
1626:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1639:    {
1639:       Node unit = oNodeIterValue( it )
1649:       [ oNodeNull( unit )
1656:          | true :  >
1659:          | false :
1661:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1669:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1684:             .tFreeActuals  oEmitInt( 0 )
1692:             oNodeIterPrev( it )
1698:       ]
1706:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1709: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1711:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1719:    int patchLS
1719:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1728:    [ isMain
1731:       | true :  @InitializeUnits
1734:       | * :
1739:    ]
      
         % insert any code for initialization of this scope's variables
1739:    Code initCode = oNodeGetCode( varScope, qInitCode )
1752:    oEmitCode( initCode )
1758:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1770:    @Statement
      
1772:    [ isMain
1775:       | true :  @FinalizeUnits
1778:       | * :
1783:    ]
      
1783:    .tReturn
      
1785:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1797:    oPatch( patchLS, localSpace )
1807:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1807: MethodModifiers( Node decl ):
1809:    {[
1809:       | pCdecl :
1811:          oNodeSetBoolean( decl, qCdecl, true )
1823:          ';'
      
1825:       | * : >
1832:    ]}
1835:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1835: GetOrCreateInitCode( Node scope ) >> Code:
1837:    Code initCode = oNodeGetCode( scope, qInitCode )
1850:    [ equal_code( initCode, codeNull )
1860:       | true :
1861:          initCode = oCodeNew
1866:          oNodeSetCode( scope, qInitCode, initCode )
1878:       | * :
1883:    ]
1883:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1887: ExternalDecl( Node decl ):
1889:    [ equal_zero( @DeclLevel( decl ) )
1901:       | false :  #eExternalMethodCannotBeNested
1904:       | * :
1909:    ]
1909:    oNodeSetBoolean( decl, qExternal, true )
1921:    [
1921:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1923:          [
1923:             | pName :
1925:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1927:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1938:             | * :
1943:          ]
1943:       | * :
1948:    ]
1949:    ;
      
      
1949: ProcHeaderDecl >> Node:
1951:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1953:    boolean redeclaring = false
1959:    Node decl = oScopeFindInCurrentScope
      
1964:    [ oNodeNull( decl )
1971:       | true :
               % first declaration
1972:          decl = @newIdent( nProc, LAST_ID )
1985:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1996:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1998:          redeclaring = true
2004:          [ oNodeGetBoolean( decl, qBodyDefined )
2014:             | true : #eAlreadyDefined
2017:             | * :
2022:          ]
2022:          [ oNodeGetBoolean( decl, qExternal )
2032:             | true : #eAlreadyDefined
2035:             | * :
2040:          ]
2040:          [ oNodeType( decl )
2047:             | nProc :
2048:             | * : #eAlreadyDefined   % wrong kind
2055:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2055:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2074:          oNodeSet( decl, qParams, Null )
2086:    ]
      
2094:    int level = @ScopeLevel
2100:    boolean nested = greater( level, 0 )
2113:    inc( level )
2119:    oScopeBegin( level, allocUp )
2128:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2133:    [ nested
2136:       | true :
2137:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2152:       | * :
2157:    ]
      
2157:    @FormalArgDecl
2159:    oNodeSet( decl, qParams, paramScope )
2171:    oScopeEnd
2172:    ';'
      
2174:    [ redeclaring
2177:       | false : oScopeDeclare( decl )
2184:       | true :  % TO DO: check that qParams is consistent with qOldParams
2186:    ]
      
2194:    @MethodModifiers( decl )
2201:    >> decl;
      
      
2205: ProcDecl:
2207:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2213:    [
2213:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2215:       | pExternal : @ExternalDecl( decl )
      
2224:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2231:          Node paramScope = oNodeGet( decl, qParams )
2244:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2250:          int level = oNodeGetInt( paramScope, qLevel )
2263:          oScopeBegin( level, allocDown )
2272:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2283:          Label label = oNodeGetLabel( decl, qValue )
2296:          @Block( nLocalVar, label )
2306:          oNodeSetBoolean( decl, qBodyDefined, true )
2318:          oScopeEnd
      
2319:          oScopeEnd  % paramScope
2320:    ]
2320:    ';';
      
      
      
2323: FuncHeaderDecl >> Node:
2325:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2327:    boolean redeclaring = false
2333:    Node decl = oScopeFindInCurrentScope
      
2338:    [ oNodeNull( decl )
2345:       | true :
               % first declaration
2346:          decl = @newIdent( nFunc, LAST_ID )
2359:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2370:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2372:          redeclaring = true
2378:          [ oNodeGetBoolean( decl, qBodyDefined )
2388:             | true : #eAlreadyDefined
2391:             | * :
2396:          ]
2396:          [ oNodeType( decl )
2403:             | nFunc :
2404:             | * : #eAlreadyDefined   % wrong kind
2411:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2411:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2430:          oNodeSet( decl, qParams, Null )
2442:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2461:          oNodeSet( decl, qType, Null )
2473:    ]
      
2481:    int level = @ScopeLevel
2487:    boolean nested = greater( level, 0 )
2500:    inc( level )
2506:    oScopeBegin( level, allocUp )
2515:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2520:    [ nested
2523:       | true :
2524:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2539:       | * :
2544:    ]
      
2544:    @FormalArgDecl
2546:    oNodeSet( decl, qParams, paramScope )
      
2558:    ':'
      
2560:    Node theType
2560:    @TypeRef( theType )
2567:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2579:    Node ptrType = @PointerTypeTo( theType )
2590:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2606:    oScopeEnd
2607:    ';'
      
2609:    [ redeclaring
2612:       | false : oScopeDeclare( decl )
2619:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2621:    ]
      
2629:    @MethodModifiers( decl )
      
2636:    >> decl;
      
      
2640: FuncDecl:
2642:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2648:    [
2648:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2650:       | pExternal : @ExternalDecl( decl )
      
2659:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2666:          Node paramScope = oNodeGet( decl, qParams )
2679:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2685:          int level = oNodeGetInt( paramScope, qLevel )
2698:          oScopeBegin( level, allocDown )
2707:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2718:          Label label = oNodeGetLabel( decl, qValue )
2731:          @Block( nLocalVar, label )
2741:          oNodeSetBoolean( decl, qBodyDefined, true )
2753:          oScopeEnd
      
2754:          oScopeEnd  % paramScope
2755:    ]
2755:    ';';
      
      
2758: FormalArgDecl:
2760:    [
2760:       | '(' :
2762:          {
2762:             NodeVec decls = oNodeVecNew
2767:             Node decl
2767:             boolean isInOut = false
      
2773:             [
2773:                | pVar : isInOut = true
2781:                | * :
2786:             ]
      
2786:             {  pIdent
      
2788:                decl = @newIdent( nParam, LAST_ID )
2801:                oNodeSetBoolean( decl, qInOut, isInOut )
2813:                oNodeVecAppend( decls, decl )
      
2822:                [
2822:                   | ':' : >
2826:                   | ',' :
2828:                ]
2836:             }
      
2838:             Node theType
2838:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2845:             Node allocType
2845:             [ isInOut
2848:                | true :   allocType = @PointerTypeTo( theType )
2860:                | * :      allocType = theType
2871:             ]
      
2871:             int i = 0
2877:             {[ equal( i, oNodeVecSize( decls ) )
2891:                | false :
2892:                   decl = oNodeVecElement( decls, i )
      
2905:                   oNodeSet( decl, qType, theType )
2917:                   oScopeDeclare( decl )
2923:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2939:                   inc( i )
2945:                | * :
2950:                   >
2952:             ]}
      
2954:             oNodeVecDelete( decls )
      
2960:             [
2960:                | ')' : >
2964:                | ';' :
2966:             ]
2974:          }
2976:       | * :
2981:    ];
      
      
2982: ConstDecl:
2984:    {[
2984:       | pIdent :
2986:          [
2986:             | ':' :
2988:                @TypedConstDecl
2990:             | * :
2995:                @UntypedConstDecl
2997:          ]
2997:       | * :
3002:          >
3004:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3007: UntypedConstDecl:
3009:    Node decl = @newIdent( nConst, LAST_ID )
3022:    '='
      
3024:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3026:    int val = oValueTop
3031:    oValuePop
3032:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3044:    oNodeSet( decl, qType, IntegerType )
      
3056:    oScopeDeclare( decl )
3062:    ';'
3065:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3065: TypedConstDecl:
3067:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3080:    Node theType
3080:    @TypeRef( theType )
3087:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3099:    [ oNodeType( theType )
3106:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3107:          '='
      
3109:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3111:          int val = oValueTop
3116:          oValuePop
3117:          oNodeSetInt( decl, qValue, val )
3129:          oScopeDeclare( decl )
3135:          ';'
      
3137:       | nStringType, nFileType, nPointerType :
3139:          #eNotImplemented
      
3141:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3143:          oScopeEnter( globalScope )
3149:          int addr = oScopeAllocType( theType )
3159:          oScopeEnd
3160:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3171:          oNodeSetInt( decl, qValue, addr )
3183:          '='
3185:          @TypedConstInit( theType, addr )
3195:          oCodePop
3196:          oScopeDeclare( decl )
3202:          ';'
3204:    ]
3229:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3229: TypedConstInit( Node theType, int addr ):
         % TO DO: need to write into global init code stream
         % which might not be current code stream (e.g. a const declared in a procedure)
         % Probably the caller should do that, since it also allocated the global memory.
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3231:    [ oNodeType( theType )
3238:       | nArrayType :
3239:          Node baseType = oNodeGet( theType, qBaseType )
3252:          Node indexType = oNodeGet( theType, qIndexType )
3265:          int low = @OrdinalLow( indexType )
3276:          int high = @OrdinalHigh( indexType )
3287:          int elementSize = oNodeGetInt( baseType, qSize )
      
3300:          '('
               % Loop over elements
3302:          int i = low
3308:          {
3308:             @TypedConstInit( baseType, addr )
3318:             [ equal( i, high )
3328:                | true : >
3331:                | false :
3333:             ]
3341:             ','
3343:             addr = add( addr, elementSize )
3356:             inc( i )
3362:          }
3364:          ')'
      
3366:       | nRecordType :
3368:          '('
3370:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3383:          {
3383:             [
3383:                | pIdent :
3385:                | * :  >
3392:             ]
3392:             Node field = oScopeFindRequireInScope( fieldScope )
3402:             ':'
3404:             Node fieldType = oNodeGet( field, qType )
3417:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3437:             @TypedConstInit( fieldType, fieldAddr )
3447:             [
3447:                | ';' :
3449:                | * :  >
3456:             ]
3456:          }
3458:          ')'
      
3460:       | nBooleanType, nByteType, nCharType:
3462:          .tPushAddrGlobal  oEmitInt( addr )
3470:          @ConstExpr
3472:          .tPushConstI  oEmitInt( oValueTop )
3479:          oValuePop
3480:          .tAssignB
      
3482:       | nIntegerType, nEnumType:
3484:          .tPushAddrGlobal  oEmitInt( addr )
3492:          @ConstExpr
3494:          .tPushConstI  oEmitInt( oValueTop )
3501:          oValuePop
3502:          .tAssignI
      
3504:       | nStringType, nFileType, nPointerType :
3506:          #eNotImplemented
3508:    ]
3533:    ;
      
      
3533: TypeDecl:
3535:    {[
3535:       | pIdent :
3537:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3550:          '='
3552:          Node theType
3552:          @TypeRef( theType )
3559:          oNodeSet( decl, qType, theType )
3571:          oScopeDeclare( decl )
3577:          ';'
3579:       | * :
3584:          >
3586:    ]};
      
3589: VarDecl( node_type varNodeType ):
3591:    {[
3591:       | pIdent :
3593:          NodeVec decls = oNodeVecNew
3598:          Node decl
3598:          {
3598:             decl = @newIdent( varNodeType, LAST_ID )
3611:             oNodeVecAppend( decls, decl )
3620:             [
3620:                | ',' :
3622:                   pIdent
3624:                | * :
3629:                   >
3631:             ]
3631:          }
3633:          ':'
3635:          Node theType
3635:          @TypeRef( theType )
      
3642:          int i = 0
3648:          {[ equal( i, oNodeVecSize( decls ) )
3662:             | false :
3663:                decl = oNodeVecElement( decls, i )
3676:                oNodeSet( decl, qType, theType )
3688:                oScopeDeclareAlloc( decl )
3694:                inc( i )
3700:             | * :
3705:               >
3707:          ]}
      
               % optional initialization
3709:          [
3709:             | '=' :
3711:                [ oNodeVecSize( decls )
3718:                   | 1 :
3719:                   | * :  #eOnlyOneVarCanBeInitialized
3726:                ]
      
                     % we need an initCode stream for this scope
3726:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3736:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3742:                boolean changedScope = false
3748:                [ equal_zero( @ScopeLevel )
3755:                   | true : oScopeEnter( initScope )
3762:                            changedScope = true
3768:                   | * :
3773:                ]
                     % generate assignment in initCode stream
3773:                @LValueVar( decl )
3780:                @Expr
3782:                @MatchTypes
3784:                @Assign
3786:                [ changedScope
3789:                   | true : oScopeEnd
3791:                   | * :
3796:                ]
3796:                oCodePop
                   
3797:             | * :
3802:          ]
      
3802:          oNodeVecDelete( decls )
3808:          ';'
3810:       | * :
3815:          >
3817:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3820: LabelDecl:
3822:    {
3822:       Node decl
3822:       [
3822:          | pIdent :
3824:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3826:             oChangeIntLitToLabelIdent
3827:       ]
3835:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3848:       Label label = oLabelNew
3853:       oNodeSetLabel( decl, qValue, label )
3865:       oScopeDeclare( decl )
3871:       [
3871:          | ',' :
3873:          | * :
3878:             >
3880:       ]
3880:    }
3882:    ';'
3885:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3885: TypeRef( out Node resultType ):
3887:    [
3887:       | pIdent :           % previously named type (including intrinsics)
3889:          Node decl = oScopeFindRequire
3894:          @ResolveUnitRef( decl )
3901:          [ oNodeType( decl )
3908:             | nTypeDecl :
3909:                resultType = oNodeGet( decl, qType )
3922:             | * :
3927:                #eNotType
3929:                resultType = IntegerType
3935:          ]
         
3935:       | pArray :
3937:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3939:          NodeVec dimensions = oNodeVecNew
      
3944:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3944:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3954:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3966:             @ConstExpr
3968:             oNodeSetInt( subrange, qLow, oValueTop )
3979:             oValuePop
3980:             '..'
3982:             @ConstExpr
3984:             oNodeSetInt( subrange, qHigh, oValueTop )
3995:             oValuePop
3996:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4008:             oTypeAdd( subrange )
      
4014:             Node a = oNodeNew( nArrayType )
4024:             oNodeSet( a, qIndexType, subrange )
      
4036:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4045:             [
4045:                | ']' : >
4049:                | ',' :
4051:             ]
4059:          }
      
4061:          pOf
4063:          Node baseType
4063:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4070:          int dim = oNodeVecSize( dimensions )
      
4080:          {
4080:              dec(dim)
      
4086:              Node a = oNodeVecElement( dimensions, dim )
      
4099:              oNodeSet( a, qBaseType, baseType )
4111:              Node subrange = oNodeGet( a, qIndexType )
4124:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4151:              inc( width )
4157:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4183:              oTypeAdd( a )
4189:              baseType = a
      
4195:              [ equal_zero(dim)
4202:                  | true:  >
4205:                  | *:
4210:              ]
4210:          }
      
4212:          resultType = oNodeVecElement( dimensions, 0 )
4225:          oNodeVecDelete( dimensions )
      
4231:       | '^' :
4233:          Node theType
4233:          @TypeRef( theType )
4240:          resultType = @PointerTypeTo( theType )
      
4251:       | pRecord :
4253:          resultType = oNodeNew( nRecordType )
4263:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4272:          @VarDecl( nRecordField )
      
4279:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4291:          [ equal_zero( size )
4298:             | true : #eRecordEmpty
4301:             | * :
4306:          ]
      
4306:          pEnd
      
4308:          oNodeSet( resultType, qScope, oScopeCurrent )
4319:          oNodeSetInt( resultType, qSize, size )
4331:          oScopeEnd
4332:          oTypeAdd( resultType )
      
      
4338:       | '(' :
               % An enum type declaration.
4340:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4347:       | pSet :
4349:          pOf
4351:          Node theType
4351:          @TypeRef( theType )
4358:       | * :       % this works for cases except where expr starts with an id
4373:          @ConstExpr '..' @ConstExpr
4379:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4380: EnumTypeRef( out Node resultType ):
      
4382:    resultType = oNodeNew( nEnumType )
4392:    int value = 0
4398:    int numValues = 0
4404:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4410:    Node outerScope = oScopeCurrent
4415:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4424:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4424:       pIdent
4426:       Node decl = @newIdent( nEnumValue, LAST_ID )
4439:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4452:       oNodeSet( decl, qType, resultType )
4464:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4476:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4489:       oNodeSetInt( decl, qNameOffset, nameOffset )
4501:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4513:       [
4513:          | '=', ':=' :
4515:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4517:             [ equal_zero( numValues )
4524:                | false :
4525:                   [ greater( oValueTop, value )
4534:                      | false :   #eEnumValueNotAscending
4537:                      | * :
4542:                   ]
4542:                | * :
4547:             ]
4547:             [ equal( value, oValueTop )
4556:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4557:                   oNodeSetBoolean( resultType, qHasGap, true )
4569:                | * :
4574:             ]
4574:             value = oValueTop
4579:             oValuePop
4580:          | * :
4587:       ]
4587:       oNodeSetInt( decl, qValue, value )
4599:       oNodeSetInt( decl2, qValue, value )
4611:       oScopeDeclare( decl )
      
4617:       oScopeEnter( outerScope )
4623:       oScopeDeclare( decl2 )
4629:       oScopeEnd
      
4630:       inc( value )
4636:       inc( numValues )
4642:       [
4642:          | ',' :
4644:          | * :    >
4651:       ]
4651:    }
4653:    ')'
      
4655:    oNodeSet( resultType, qScope, oScopeCurrent )
4666:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4678:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4679:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4690:    oScopeEnter( globalScope )
4696:    int size = multiply( add( numValues, 1 ), 16 )
4716:    int addr = oScopeAlloc( size, 8 )
4729:    oScopeEnd
4730:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4742:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4762:    {
4762:       Node enumValue = oNodeIterValue( it )
4772:       [ oNodeNull( enumValue )
4779:          | true :  >
4782:          | * :
4787:       ]
4787:       .tPushAddrGlobal  oEmitInt( addr )
4795:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4810:       .tAssignI
4812:       addr = add( addr, 8 )
4825:       .tPushAddrGlobal  oEmitInt( addr )
4833:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4848:       .tAssignP
4850:       addr = add( addr, 8 )
4863:       oNodeIterNext( it )
4869:    }
         % final table entry
4871:    .tPushAddrGlobal  oEmitInt( addr )
4879:    .tPushConstI  oEmitInt( 0 )
4887:    .tAssignI
4889:    addr = add( addr, 8 )
4902:    .tPushAddrGlobal  oEmitInt( addr )
4910:    .tPushConstI  oEmitInt( 0 )
4918:    .tAssignP
4920:    addr = add( addr, 8 )
4933:    oCodePop
      
4934:    oTypeAdd( resultType )
4941:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
4941: ConstExpr:
4943:    [
4943:       | pIntLit :
4945:          oValuePush( TOKEN_VALUE )
4950:       | pIdent :
4952:          Node decl = oScopeFindRequire
4957:          @ResolveUnitRef( decl )
4964:          [ oNodeType( decl )
4971:             | nConst :
4972:                oValuePush( oNodeGetInt( decl, qValue ) )
4985:             | * :
4990:                #eNotConst
4992:                oValuePush( 0 )
4998:          ]
4998:       | pMinus :
5000:          @ConstExpr
5002:          oValueNegate
5003:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5014: Expr:
5016:    Label falseLabel = labelNull
      
5022:    @ExprAllowCF( falseLabel )
5029:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5037: BooleanExprControlFlow( out Label falseLabel ):
5039:    @ExprAllowCF( falseLabel )
5046:    [ oTypeSNodeType
5048:       | nBooleanCFType :
5049:       | nBooleanType :
               % convert value to control flow
5051:          falseLabel = oLabelNew
5056:          .tJumpFalse  oEmitLabel( falseLabel )
5064:       | * :
5071:          #eNotBoolean
5073:    ]
5073:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5075: CFToVal( inout Label falseLabel ):
5077:    [ oTypeSNodeType
5079:       | nBooleanCFType :
5080:          Label doneLabel = oLabelNew
5085:          .tPushConstI  oEmitInt( 1 )
5093:          .tJump  oEmitLabel( doneLabel )
5101:          .tLabel  oEmitLabel( falseLabel )
5109:          .tPushConstI  oEmitInt( 0 )
5117:          .tLabel  oEmitLabel( doneLabel )
5125:          oTypeSPop
5126:          oTypeSPush( BooleanType )
5132:          falseLabel = labelNull
5138:       | * :
5143:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5144: ValToCF( out Label falseLabel ):
5146:    [ oTypeSNodeType
5148:       | nBooleanType :
5149:          falseLabel = oLabelNew
5154:          .tJumpFalse  oEmitLabel( falseLabel )
5162:          oTypeSPop
5163:          oTypeSPush( BooleanCFType )
5169:       | * :
5174:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5175: ExprAllowCF( out Label falseLabel ):
5177:    @BoolExprAllowCF( falseLabel )
5184:    {[
5184:       | '=' :
5186:          @CFToVal( falseLabel )
5193:          @PromoteToIntOptional
5195:          @BoolExprAllowCF( falseLabel )
5202:          @CFToVal( falseLabel )
5209:          @PromoteToIntOptional
5211:          @MatchTypes
5213:          [ oTypeSNodeType
5215:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
5218:             | nPointerType :                .tEqualP
5222:             | nCharType, nStringType :      #eNotImplemented
5226:             | * :                           #eNotAllowed
5243:          ]
5243:          oTypeSPop
5244:          oTypeSPush( BooleanType )
      
5250:       | '<>' :
5252:          @CFToVal( falseLabel )
5259:          @PromoteToIntOptional
5261:          @BoolExprAllowCF( falseLabel )
5268:          @CFToVal( falseLabel )
5275:          @PromoteToIntOptional
5277:          @MatchTypes
5279:          [ oTypeSNodeType
5281:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
5284:             | nPointerType :                .tNotEqualP
5288:             | nCharType, nStringType :      #eNotImplemented
5292:             | * :                           #eNotAllowed
5309:          ]
5309:          oTypeSPop
5310:          oTypeSPush( BooleanType )
      
5316:       | '<' :
5318:          @CFToVal( falseLabel )
5325:          @PromoteToIntOptional
5327:          @BoolExprAllowCF( falseLabel )
5334:          @CFToVal( falseLabel )
5341:          @PromoteToIntOptional
5343:          @MatchTypes
5345:          [ oTypeSNodeType
5347:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
5350:             | nCharType, nStringType :      #eNotImplemented
5354:             | * :                           #eNotAllowed
5369:          ]
5369:          oTypeSPop
5370:          oTypeSPush( BooleanType )
      
5376:       | '>' :
5378:          @CFToVal( falseLabel )
5385:          @PromoteToIntOptional
5387:          @BoolExprAllowCF( falseLabel )
5394:          @CFToVal( falseLabel )
5401:          @PromoteToIntOptional
5403:          @MatchTypes
5405:          [ oTypeSNodeType
5407:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
5410:             | nCharType, nStringType :      #eNotImplemented
5414:             | * :                           #eNotAllowed
5429:          ]
5429:          oTypeSPop
5430:          oTypeSPush( BooleanType )
      
5436:       | '<=' :
5438:          @CFToVal( falseLabel )
5445:          @PromoteToIntOptional
5447:          @BoolExprAllowCF( falseLabel )
5454:          @CFToVal( falseLabel )
5461:          @PromoteToIntOptional
5463:          @MatchTypes
5465:          [ oTypeSNodeType
5467:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
5470:             | nCharType, nStringType :      #eNotImplemented
5474:             | * :                           #eNotAllowed
5489:          ]
5489:          oTypeSPop
5490:          oTypeSPush( BooleanType )
      
5496:       | '>=' :
5498:          @CFToVal( falseLabel )
5505:          @PromoteToIntOptional
5507:          @BoolExprAllowCF( falseLabel )
5514:          @CFToVal( falseLabel )
5521:          @PromoteToIntOptional
5523:          @MatchTypes
5525:          [ oTypeSNodeType
5527:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
5530:             | nCharType, nStringType :      #eNotImplemented
5534:             | * :                           #eNotAllowed
5549:          ]
5549:          oTypeSPop
5550:          oTypeSPush( BooleanType )
      
5556:       | * :
5571:          >
5573:    ]};
      
      
5576: BoolExprAllowCF( out Label falseLabel ):
5578:    Label trueLabel = labelNull
      
5584:    @BoolTermAllowCF( falseLabel )
5591:    {[
5591:       | pOr :
5593:          [ oTypeSNodeType
5595:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5596:                [ equal_label( trueLabel, labelNull )
5606:                   | true :  trueLabel = oLabelNew
5612:                   | * :
5617:                ]
5617:                .tJump  oEmitLabel( trueLabel )
5625:             | nBooleanType :
5627:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5634:                [ equal_label( trueLabel, labelNull )
5644:                   | true :  trueLabel = oLabelNew
5650:                   | * :
5655:                ]
5655:                .tJump  oEmitLabel( trueLabel )
5663:             | * : #eNotBoolean
5672:          ]
5672:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5673:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5681:          falseLabel = labelNull
5687:          @BoolTermAllowCF( falseLabel )
      
5694:          [ oTypeSNodeType
5696:             | nBooleanCFType :
5697:             | nBooleanType :
5699:                @ValToCF( falseLabel )
5706:             | * : #eNotBoolean
5715:          ]
      
5715:          oTypeSPop
5716:          oTypeSPush( BooleanCFType )
      
5722:       | * :
5727:          >
5729:    ]}
      
         % any short-circuit trues jump here to the end
5731:    [ equal_label( trueLabel, labelNull )
5741:       | false :
5742:          .tLabel  oEmitLabel( trueLabel )
5750:       | * :
5755:    ]
5756:    ;
      
      
5756: BoolTermAllowCF( out Label falseLabel ):
5758:    Label overallFalseLabel = labelNull
      
5764:    @BoolFactorAllowCF( falseLabel )
5771:    {[
5771:       | pAnd :
5773:          [ oTypeSNodeType
5775:             | nBooleanCFType :
5776:             | nBooleanType :
5778:                @ValToCF( falseLabel )
5785:             | * :
5792:                #eNotBoolean
5794:          ]
5794:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5795:          [ equal_label( overallFalseLabel, labelNull )
5805:             | true :
5806:                overallFalseLabel = oLabelNew
5811:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5825:                falseLabel = overallFalseLabel
5831:             | * :
5836:          ]
      
5836:          Label factorFalseLabel = labelNull
5842:          @BoolFactorAllowCF( factorFalseLabel )
      
5849:          [ oTypeSNodeType
5851:             | nBooleanCFType :
5852:             | nBooleanType :
5854:                @ValToCF( factorFalseLabel )
5861:             | * : #eNotBoolean
5870:          ]
5870:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5884:       | * :
5889:          >
5891:    ]};
      
5894: BoolFactorAllowCF( out Label falseLabel ):
5896:    [
5896:       | pNot :
5898:          Label factorFalseLabel = labelNull
      
5904:          @BoolFactorAllowCF( factorFalseLabel )
5911:          [ oTypeSNodeType
5913:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5914:                falseLabel = oLabelNew
5919:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5927:                .tLabel  oEmitLabel( factorFalseLabel )
      
5935:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5937:                .tNot
      
5939:             | * : #eNotBoolean
5948:          ]
      
5948:       | * :
5953:          @ArithExprAllowCF( falseLabel )
5960:    ];
      
5961: ArithExprAllowCF( out Label falseLabel ):
5963:    @TermAllowCF( falseLabel )
5970:    {[
5970:       | pPlus :
5972:          @PromoteToIntPop
5974:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5981:          @PromoteToInt
5983:          .tAddI
5985:       | pMinus :
5987:          @PromoteToIntPop
5989:          @TermAllowCF( falseLabel )
5996:          @PromoteToInt
5998:          .tSubI
6000:       | * :
6007:          >
6009:    ]};
      
6012: TermAllowCF( out Label falseLabel ):
6014:    @FactorAllowCF( falseLabel )
6021:    {[
6021:       | pTimes :
6023:          @PromoteToIntPop
6025:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6032:          @PromoteToInt
6034:          .tMultI
6036:       | pDivide :
6038:          @PromoteToIntPop
6040:          @FactorAllowCF( falseLabel )
6047:          @PromoteToInt
6049:          .tDivI
6051:       | * :
6058:          >
6060:    ]};
      
6063: FactorAllowCF( out Label falseLabel ):
6065:    [
6065:       | pPlus :
6067:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6074:          @PromoteToInt
6076:       | pMinus :
6078:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6085:          @PromoteToInt
6087:          .tNegI
6089:       | * :
6096:          @PrimaryAllowCF( falseLabel )
6103:    ];
      
6104: PrimaryAllowCF( out Label falseLabel ):
6106:    [
6106:       | pIntLit :
6108:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6115:          oTypeSPush( IntegerType )
      
6121:       | pCharLit :
6123:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6130:          oTypeSPush( CharType )
      
6136:       | '(' :
6138:          @ExprAllowCF( falseLabel )
6145:          ')'
      
6147:       | pStrLit :
6149:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
6158:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
6166:          oTypeSPush( StringType )
      
6172:       | pIdent :
6174:          Node decl = oScopeFindRequire
6179:          @ResolveUnitRef( decl )
6186:          Node theType
      
6186:          [ oNodeType( decl )
6193:             | nFunc :
6194:                @Call( decl )
      
6201:             | nBuiltInFunc :
6203:                @CallBuiltInFunc( decl )
      
6210:             | nConst, nEnumValue :
6212:                theType = oNodeGet( decl, qType )
6225:                oTypeSPush( theType )
6231:                [ oTypeSNodeType
6233:                   | nIntegerType, nEnumType, nBooleanType :
6234:                      .tPushConstI @EmitValue( decl )
6243:                   | * :
6252:                      #eNotImplemented
6254:                ]
      
6254:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6256:                @VarExpr( decl )
      
6263:             | * :
6282:                #eNotValue
6284:                oTypeSPush( IntegerType )
6290:          ]
      
6290:       | '@' :        % @var -- pointer to var
6292:          pIdent
      
6294:          Node decl = oScopeFindRequire
6299:          @ResolveUnitRef( decl )
6306:          Node theType
      
6306:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6313:          theType = oTypeSTop
6318:          oTypeSPop
6319:          Node ptrType = @PointerTypeTo( theType )
6330:          oTypeSPush( ptrType )
      
6336:       | * :
6351:          #eNotValue
6353:          oTypeSPush( IntegerType )
6359:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6360: VarExpr( Node decl ):
6362:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6375:    int uplevels = @DeclUpLevels( decl )
      
6386:    oTypeSPush( theType )
6392:    [ oTypeSNodeType
6394:       | nIntegerType, nEnumType :
6395:          [ oNodeType( decl )
6402:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6412:             | nLocalVar :
6414:                [ equal_zero( uplevels )
6421:                   | true :  .tPushLocalI  @EmitValue( decl )
6431:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6451:                ]
6451:             | nParam :
6453:                [ oNodeGetBoolean( decl, qInOut )
6463:                   | true :    % VAR param points to the var.  Auto dereference.
6464:                      [ equal_zero( uplevels )
6471:                         | true :  .tPushParamP  @EmitValue( decl )
6481:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6501:                      ]
6501:                      .tFetchI
6503:                   | * :
6508:                      [ equal_zero( uplevels )
6515:                         | true :  .tPushParamI  @EmitValue( decl )
6525:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6545:                      ]
6545:                ]
6545:          ]
      
6557:       | nBooleanType, nByteType, nCharType :
6559:          [ oNodeType( decl )
6566:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6576:             | nLocalVar :
6578:                [ equal_zero( uplevels )
6585:                   | true :  .tPushLocalB  @EmitValue( decl )
6595:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6615:                ]
6615:             | nParam :
6617:                [ oNodeGetBoolean( decl, qInOut )
6627:                   | true :    % VAR param points to the var.  Auto dereference.
6628:                      [ equal_zero( uplevels )
6635:                         | true :  .tPushParamP  @EmitValue( decl )
6645:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6665:                      ]
6665:                      .tFetchB
6667:                   | * :
6672:                      [ equal_zero( uplevels )
6679:                         | true :  .tPushParamB  @EmitValue( decl )
6689:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6709:                      ]
6709:                ]
6709:          ]
      
6721:       | nStringType, nFileType :
6723:          #eNotImplemented
      
6725:       | nPointerType :
6727:          [ oNodeType( decl )
6734:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6744:             | nLocalVar :
6746:                [ equal_zero( uplevels )
6753:                   | true :  .tPushLocalP  @EmitValue( decl )
6763:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6783:                ]
6783:             | nParam :
6785:                [ oNodeGetBoolean( decl, qInOut )
6795:                   | true :    % VAR param points to the var.  Auto dereference.
6796:                      [ equal_zero( uplevels )
6803:                         | true :  .tPushParamP  @EmitValue( decl )
6813:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6833:                      ]
6833:                      .tFetchP
6835:                   | * :
6840:                      [ equal_zero( uplevels )
6847:                         | true :  .tPushParamP  @EmitValue( decl )
6857:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6877:                      ]
6877:                ]
6877:          ]
6889:          [
6889:             | '^' :             % dereferenced
6891:                oTypeSPop
6892:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6905:                @LValueIndexes
6907:                @FetchVar
6909:             | * :               % just ptr value alone
6914:          ]
      
6914:       | nArrayType, nRecordType :
               % compound type
               % first, push addr of start of var
6916:          [ oNodeType( decl )
6923:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6933:             | nLocalVar :
6935:                [ equal_zero( uplevels )
6942:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6952:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6972:                ]
6972:             | nParam :
6974:                [ oNodeGetBoolean( decl, qInOut )
6984:                   | true :    % VAR param points to the var.  Auto dereference.
6985:                      [ equal_zero( uplevels )
6992:                         | true :  .tPushParamP  @EmitValue( decl )
7002:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7022:                      ]
7022:                   | * :
7027:                      [ equal_zero( uplevels )
7034:                         | true :  .tPushAddrParam  @EmitValue( decl )
7044:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7064:                      ]
7064:                ]
7064:          ]
               % modify addr for subscripts, field references, etc
7076:          @LValueIndexes
               % get final value
7078:          @FetchVar
7080:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7105: FetchVar:
7107:    [ oTypeSNodeType
7109:       | nIntegerType, nEnumType :  .tFetchI
7112:       | nBooleanType, nByteType, nCharType :  .tFetchB
7116:       | nStringType, nFileType :   #eNotImplemented
7120:       | nPointerType :             .tFetchP
7124:       | nArrayType, nRecordType :  % compound type; leave as addr
7126:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7151: LValueIndexes:
7153:    {[
7153:       | '[' :       @ArraySubscripts
7157:       | '.' :       @RecordFieldRef
7161:       | '^' :       @PointerDeref
7165:       | * :         >
7176:    ]};
      
7179: ArraySubscripts:
7181:    [ oTypeSNodeType
7183:       | nArrayType :
7184:       | * :       #eNotArray
7191:    ]
7191:    {
7191:       [ oTypeSNodeType
7193:          | nArrayType :
7194:          | * :    #eTooManySubscripts
7201:       ]
      
            % low subscript of this dimension
7201:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7218:       Node baseType
7218:       baseType = oNodeGet( oTypeSTop, qBaseType )
7230:       oTypeSPop
7231:       oTypeSPush( baseType )
      
7237:       @Expr
7239:       @RequireIntPop
            % adjust for low subscript
7241:       [ equal_zero( low )
7248:          | false :
7249:             .tPushConstI oEmitInt( low ) .tSubI
7259:          | * :
7264:       ]
      
            % multiply by element size
7264:       int size = oNodeGetInt( baseType, qSize )
7277:       [ equal( size, 1 )
7287:          | false :
7288:             .tPushConstI oEmitInt( size ) .tMultI
7298:          | * :
7303:       ]
      
            % update start address
7303:       .tAddPI
7305:       [
7305:          | ']' :  >
7309:          | ',' :
7311:       ]
7319:    };
      
      
7322: RecordFieldRef:
7324:    [ oTypeSNodeType
7326:       | nRecordType :
7327:       | * :    #eNotRecord
7334:    ]
7334:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7346:    pIdent
7348:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7353:    [ oNodeType( field )
7360:       | nRecordField :
7361:       | * :   #eNotRecordField
7368:    ]
7368:    oScopeEnd
7369:    int offset = oNodeGetInt( field, qValue )
7382:    [ equal_zero( offset )
7389:       | false :
7390:          .tPushConstI oEmitInt( offset ) .tAddPI
7400:       | * :
7405:    ]
      
         % replace the type on the type stack, with the field type
7405:    oTypeSPop
7406:    oTypeSPush( oNodeGet( field, qType ) )
7420:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7420: PointerDeref:
7422:    [ oTypeSNodeType
7424:       | nPointerType :
7425:       | * :       #eNotPointer
7432:    ]
7432:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7434:    Node theType = oTypeSTop
7439:    oTypeSPop
7440:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7454:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7454: CoerceType:
7456:    node_type nt = oTypeSNodeType
7461:    oTypeSPop
7462:    [ equal_node_type( nt, oTypeSNodeType )
7471:       | false :
               % Can we implicitly convert the value to the desired type?
7472:          [ oTypeSNodeType
7474:             | nIntegerType :
7475:                [ nt
7478:                   | nByteType :   .tCastBtoI  >>
7482:                   | * :
7487:                ]
7487:             | nByteType :
7489:                [ nt
7492:                   | nIntegerType :   .tCastItoB  >>
7496:                   | * :
7501:                ]
7501:             | * :
7508:          ]
7508:          #eTypeMismatch
7510:       | * :
7515:    ];
      
      
      % Called on first use of an extern method
      %
7516: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7518:    int strAddr
7518:    String externalName = oNodeGetString( method, qExternalName )
7531:    [ equal_string( externalName, stringNull )
7541:       | true :
7542:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7563:       | false :
7565:          strAddr = oStringAllocLit( externalName )
7575:    ]
7583:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
7599:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7599: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
7601:    [ oNodeGetBoolean( method, qExternal )
7611:       | true :
7612:          [ oNodeGetBoolean( method, qUsed )
7622:             | false :
                     % define the extern label on first use
7623:                @DefineExternLabel( method )
7630:             | * :
7635:          ]
7635:      | * :
7640:    ]
7640:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
7652:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
7665:    Node resultType
7665:    int tempOffset
      
7665:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
7682:    [ isFunc
7685:       | true :
7686:          resultType = oNodeGet( method, qType )
7699:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
7709:       | * :
7714:    ]
         
      
7714:    Node paramScope = oNodeGet( method, qParams )
7727:    int actualsSize = oNodeGetInt( paramScope, qSize )
7740:    [ cdecl
7743:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
7752:       | false :  .tAllocActuals  oEmitInt( actualsSize )
7762:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
7770:    [ greater( @DeclLevel( method ), 0 )
7785:       | true :
7786:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
7794:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
7813:          .tAssignP
7815:       | * :
7820:    ]
      
      
7820:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
7833:    Node param = oNodeIterValue( paramIter )
7843:    [
7843:       | '(' :
            
7845:          {
7845:             [ oNodeNull( param )
7852:                | true : >
7855:                | * :
7860:             ]
      
7860:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
7873:             .tPushAddrActual oEmitInt( offset )
7881:             oTypeSPush( oNodeGet( param, qType ) )
      
7894:             [ oNodeGetBoolean( param, qInOut )
7904:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
7905:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
7907:                           @MatchTypes
      
7909:                           .tAssignP
      
7911:                | false :  @Expr
7915:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
7917:                           [ oTypeSNodeType
7919:                              | nIntegerType, nEnumType : .tAssignI
7922:                              | nBooleanType, nByteType, nCharType :  .tAssignB
7926:                              | nStringType, nFileType :   #eNotImplemented
7930:                              | nPointerType :            .tAssignP
7934:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
7936:                                  int size = oNodeGetInt( oTypeSTop, qSize )
7948:                                  .tCopy  oEmitInt( size )    % multi-word copy
7956:                           ]
7980:             ]
7988:             oTypeSPop
      
7989:             oNodeIterNext( paramIter )
7995:             param = oNodeIterValue( paramIter )
8005:             [ oNodeNull( param )
8012:                | true :  >
8015:                | false :
8017:             ]
      
8025:             ','
8027:          }
      
8029:          ')'
      
8031:       | * :
8036:    ]
      
8036:    [ oNodeNull( param )
8043:       | false :    #eMissingParameter
8046:       | * :
8051:    ]
      
8051:    [ isFunc
8054:       | true :
               % Pass result temp as an additional VAR parameter.
8055:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
8070:          .tPushAddrLocal  oEmitInt( tempOffset )
8078:          .tAssignP
8080:       | * :
8085:    ]
      
8085:    [ cdecl
8088:       | true :
8089:          .tCallCdecl  @EmitValue( method )
8098:       | false :
8100:          .tCall   @EmitValue( method )
8109:    ]
      
8117:    [ isFunc
8120:       | true :
               % push return value from temp
8121:          oTypeSPush( resultType )
      
8127:          [ oTypeSNodeType
8129:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8138:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8148:             | nStringType, nFileType :  #eNotImplemented
8152:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8162:             | nArrayType, nRecordType :   % compound type: push address
8164:                                .tPushAddrLocal  oEmitInt( tempOffset )
8172:          ]
8196:       | * :
8201:    ]
         
8201:    .tFreeActuals  oEmitInt( actualsSize )
8210:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8210: CallBuiltInFunc( Node method ):
      
         % Ord(x)
8212:    [ oNodeEqual( method, BuiltIn_Ord )
8222:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
8223:          '('
8225:          @Expr
8227:          [ oTypeSNodeType
8229:             | nIntegerType, nEnumType :
8230:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
8234:             | * :  #eTypeMismatch
8249:          ]
8249:          oTypeSPop
8250:          oTypeSPush( IntegerType )
8256:          ')'
8258:          >>
8259:       | * :
8264:    ]
      
         % Chr(x)
8264:    [ oNodeEqual( method, BuiltIn_Chr )
8274:       | true :
               % parameter is integer
               % result is char
8275:          '('
8277:          @Expr
8279:          [ oTypeSNodeType
8281:             | nIntegerType :    .tCastItoB
8284:             | nByteType :
8286:             | * :  #eTypeMismatch
8295:          ]
8295:          oTypeSPop
8296:          oTypeSPush( CharType )
8302:          ')'
8304:          >>
8305:       | * :
8310:    ]
      
         % Pred(x)
8310:    [ oNodeEqual( method, BuiltIn_Pred )
8320:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8321:          '('
8323:          @Expr
8325:          [ oTypeSNodeType
8327:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8328:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8337:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8340:                   | * :
8345:                ]
8345:             | * :  #eTypeMismatch
8352:          ]
8352:          .tDecI
8354:          ')'
8356:          >>
8357:       | * :
8362:    ]
      
         % Succ(x)
8362:    [ oNodeEqual( method, BuiltIn_Succ )
8372:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8373:          '('
8375:          @Expr
8377:          [ oTypeSNodeType
8379:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8380:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8389:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8392:                   | * :
8397:                ]
8397:             | * :  #eTypeMismatch
8404:          ]
8404:          .tIncI
8406:          ')'
8408:          >>
8409:       | * :
8414:    ]
      
8414:    #eNotImplemented
8417:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
8417: Statement:
8419:    [
8419:       | pWriteln :     @WritelnStmt
8423:       | pWrite :       @WriteStmt
8427:       | pReadln :      @ReadlnStmt
8431:       | pRead :        @ReadStmt
8435:       | pIf :          @IfStmt
8439:       | pWhile :       @WhileStmt
8443:       | pFor :         @ForStmt
8447:       | pRepeat :      @RepeatStmt
8451:       | pBreak :       @BreakStmt
8455:       | pContinue :    @ContinueStmt
8459:       | pBegin :       @BeginStmt
8463:       | pIdent :       @LabelOrAssignOrCallStmt
8467:       | pGoto :        @GotoStmt
8471:       | pIntLit :      % should be an integer label
8473:                        oChangeIntLitToLabelIdent
8474:                        @LabelOrAssignOrCallStmt
8476:       | * :            % null statement : don't accept any tokens
8507:    ];
      
      
8508: LabelOrAssignOrCallStmt:
8510:    Node decl = oScopeFindRequire
8515:    @ResolveUnitRef( decl )
8522:    [ oNodeType( decl )
8529:       | nLabel :                          @LabelDefinition( decl )
8537:                                           @Statement
8539:       | nProc :                           @Call( decl )
8548:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8557:       | nFunc :                           @AssignResultStmt( decl )
8566:       | * :                               #eBadStatement
8583:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8584: LabelDefinition( Node decl ):
8586:    [ oNodeGetBoolean( decl, qDefined )
8596:       | true :  #eAlreadyDefined
8599:       | * :
8604:    ]
8604:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8619:    oNodeSetBoolean( decl, qDefined, true )
8631:    ':'
8634:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8634: AssignStmt( Node decl ):
      
8636:    @LValueVar( decl )
8643:    ':=' 
8645:    @Expr
8647:    @CoerceType
8649:    @Assign
8652:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8652: Assign:
8654:    [ oTypeSNodeType
8656:       | nIntegerType, nEnumType :  .tAssignI
8659:       | nBooleanType, nByteType, nCharType :  .tAssignB
8663:       | nStringType, nFileType :   #eNotImplemented
8667:       | nPointerType :             .tAssignP
            % compound var assigns; addrs of src, dest on stack
8671:       | nArrayType, nRecordType :
8673:           int size = oNodeGetInt( oTypeSTop, qSize )
8685:           .tCopy  oEmitInt( size )    % multi-word copy
8693:    ]
8717:    oTypeSPop
8719:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8719: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8721:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8737:       | false :   #eNotCurrentFunction
8740:       | * :
8745:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8745:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8760:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8773:    ':='
8775:    @Expr
8777:    @CoerceType
8779:    [ oTypeSNodeType
8781:       | nIntegerType, nEnumType : .tAssignI
8784:       | nBooleanType, nByteType, nCharType :  .tAssignB
8788:       | nStringType, nFileType :   #eNotImplemented
8792:       | nPointerType :            .tAssignP
            % compound var assigns; addrs of src, dest on stack
8796:       | nArrayType, nRecordType :
8798:           int size = oNodeGetInt( oTypeSTop, qSize )
8810:           .tCopy  oEmitInt( size )    % multi-word copy
8818:    ]
8842:    oTypeSPop
8844:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
8844: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8846:    pIdent
8848:    Node decl = oScopeFindRequire
8853:    @ResolveUnitRef( decl )
8860:    [ oNodeType( decl )
8867:       | nGlobalVar, nLocalVar, nParam :
8868:       | * :  #eNotVar
8879:    ]
8879:    @LValueVar( decl )
8887:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8887: LValueVar( Node decl ):
8889:    [ oNodeType( decl )
8896:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8906:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8917:       | nParam :
8919:          [ oNodeGetBoolean( decl, qInOut )
8929:             | true :   % VAR param points to variable.  No dereference.
8930:                        .tPushParamP @EmitValue( decl )
8939:             | * :      .tPushAddrParam @EmitValue( decl )
8953:          ]
8953:       | * :            #eNotVar
8964:    ]
      
8964:    oTypeSPush( oNodeGet( decl, qType ) )
8977:    @LValueIndexes        % handle subscripts, if any
8980:    ;
      
      
8980: IncVar( Node decl ):
8982:    @LValueVar( decl )
8989:    @RequireIntPop
8991:    @VarExpr( decl )
8998:    oTypeSPop
8999:    .tIncI
9001:    .tAssignI;
      
9004: DecVar( Node decl ):
9006:    @LValueVar( decl )
9013:    @RequireIntPop
9015:    @VarExpr( decl )
9022:    oTypeSPop
9023:    .tDecI
9025:    .tAssignI;
      
      
9028: IfStmt:
9030:    Label falseLabel = labelNull
      
9036:    @BooleanExprControlFlow( falseLabel )
9043:    pThen
9045:    @Statement
9047:    [
9047:       | pElse :
9049:          Label doneLabel = oLabelNew
      
9054:          .tJump  oEmitLabel( doneLabel )
9062:          .tLabel oEmitLabel( falseLabel )
9070:          @Statement
9072:          .tLabel oEmitLabel( doneLabel )
      
9080:       | * :
9085:          .tLabel oEmitLabel( falseLabel )
9093:    ];
      
      
9094: ForStmt:
9096:    pIdent
      
9098:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9103:    @LValueVar( decl )
9110:    @RequireIntPop
      
9112:    ':='
      
9114:    @Expr
9116:    @RequireIntPop
9118:    .tAssignI
      
9120:    Label breakLabel = oLabelNew
      
9125:    Label checkLabel = oLabelNew
9130:    .tJump  oEmitLabel( checkLabel )
      
9138:    Label continueLabel = oLabelNew
9143:    .tLabel  oEmitLabel( continueLabel )
9151:    [
9151:       | pTo :
9153:          @IncVar( decl )
9160:          .tLabel  oEmitLabel( checkLabel )
9168:          @VarExpr( decl )  oTypeSPop
9176:          @Expr
9178:          @RequireIntPop
9180:          .tGreaterI
9182:          .tJumpTrue  oEmitLabel( breakLabel )
9190:       | pDownto :
9192:          @DecVar( decl )
9199:          .tLabel  oEmitLabel( checkLabel )
9207:          @VarExpr( decl )  oTypeSPop
9215:          @Expr
9217:          @RequireIntPop
9219:          .tLessI
9221:          .tJumpTrue  oEmitLabel( breakLabel )
9229:    ]
9237:    oLoopPush( continueLabel, breakLabel )
9246:    pDo
9248:    @Statement
9250:    .tJump  oEmitLabel( continueLabel )
9258:    .tLabel  oEmitLabel( breakLabel )
9266:    oLoopPop;
      
      
9268: RepeatStmt:
9270:    Label continueLabel = oLabelNew
9275:    .tLabel  oEmitLabel( continueLabel )
      
9283:    Label breakLabel = oLabelNew
      
9288:    oLoopPush( continueLabel, breakLabel )
9297:    @Statement
9299:    {[
9299:       | ';' :
9301:          @Statement
9303:       | pUntil :
9305:          Label falseLabel
9305:          @BooleanExprControlFlow( falseLabel )
9312:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9326:          >
9328:    ]}
9338:    .tLabel  oEmitLabel( breakLabel )
9346:    oLoopPop;
      
      
9348: WhileStmt:
9350:    Label continueLabel = oLabelNew
9355:    .tLabel  oEmitLabel( continueLabel )
      
9363:    Label breakLabel
9363:    @BooleanExprControlFlow( breakLabel )
      
9370:    oLoopPush( continueLabel, breakLabel )
9379:    pDo
9381:    @Statement
9383:    .tJump  oEmitLabel( continueLabel )
9391:    .tLabel  oEmitLabel( breakLabel )
9399:    oLoopPop;
      
      
9401: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9403:    [ equal_label( oLoopContinueLabel, labelNull )
9412:       | true :
9413:          #eNotInALoop
9415:       | false :
9417:          .tJump  oEmitLabel( oLoopContinueLabel )
9424:    ];
      
      
9433: BreakStmt:
9435:    [ equal_label( oLoopBreakLabel, labelNull )
9444:       | true :
9445:          #eNotInALoop
9447:       | false :
9449:          .tJump  oEmitLabel( oLoopBreakLabel )
9456:    ];
      
      
9465: GotoStmt:
9467:    [
9467:       | pIdent :
9469:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9471:          oChangeIntLitToLabelIdent
9472:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9480:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9489:    oNodeSetBoolean( decl, qUsed, true )
9501:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9517:    ;
      
      
9517: BeginStmt:
9519:    @Statement
9521:    {[
9521:       | ';' :   @Statement
9525:       | pEnd :  >
9529:    ]};
      
      
9540: WritelnStmt:
9542:    @WriteStmt
9544:    .tWriteCR;
      
      
9547: WriteStmt:
9549:    [
9549:       | '(' :
9551:          {
9551:             @Expr
9553:             [ oTypeSNodeType
9555:                | nIntegerType :             .tWriteI
9558:                | nBooleanType :             .tWriteBool
9562:                | nByteType :                .tCastBtoI  .tWriteI
9568:                | nCharType :                .tWriteChar
9572:                | nStringType :              .tWriteStr
9576:                | nFileType :                #eNotImplemented
9580:                | nEnumType :
                        % write name via table lookup
9582:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9596:                   .tWriteEnum
9598:                | nPointerType :             .tWriteP
9602:                | * :                        #eNotAllowed
9623:             ]
9623:             oTypeSPop
9624:             [
9624:                | ')' : >
9628:                | ',' :
9630:             ]
9638:          }
9640:       | * :
9645:    ];
      
      
9646: ReadlnStmt:      % ***
         % TO DO
9649:    ;
      
9649: ReadStmt:
         % TO DO
9652:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
9652: ScopeLevel >> int:
9654:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
9664: DeclLevel( Node decl ) >> int:
9666:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
9684: DeclUpLevels( Node decl ) >> int:
9686:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
9702: MatchTypes:
9704:    node_type nt = oTypeSNodeType
9709:    oTypeSPop
9710:    [ equal_node_type( nt, oTypeSNodeType )
9719:       | false :
9720:          #eTypeMismatch
9722:       | * :
9727:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9728: RequireIntPop:
9730:    [ oTypeSNodeType
9732:       | nIntegerType :
9733:       | * :          #eNotInteger
9740:    ]
9740:    oTypeSPop;
      
9742: RequireInt:
9744:    [ oTypeSNodeType
9746:       | nIntegerType :
9747:       | * :          #eNotInteger
9754:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9755: PromoteToIntPop:
9757:    [ oTypeSNodeType
9759:       | nIntegerType :
9760:       | nByteType :        .tCastBtoI
9764:       | * :                #eNotInteger
9773:    ]
9773:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9775: PromoteToInt:
9777:    [ oTypeSNodeType
9779:       | nIntegerType :
9780:       | nByteType :        .tCastBtoI
9784:                            oTypeSPop
9785:                            oTypeSPush( IntegerType )
9791:       | * :                #eNotInteger
9800:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9801: PromoteToIntOptional:
9803:    [ oTypeSNodeType
9805:       | nByteType :        .tCastBtoI
9808:                            oTypeSPop
9809:                            oTypeSPush( IntegerType )
9815:       | * :
9820:    ];
      
      
      
      
9821: RequireBoolPop:
9823:    [ oTypeSNodeType
9825:       | nBooleanType :
9826:       | * :          #eNotBoolean
9833:    ]
9833:    oTypeSPop;
      
9835: RequireBool:
9837:    [ oTypeSNodeType
9839:       | nBooleanType :
9840:       | * :          #eNotBoolean
9847:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
9848: newType( node_type nt, int size ) >> Node:
9850:   Node node = oNodeNew( nt )
9860:   oNodeSetInt( node, qSize, size )
9872:   oTypeAdd( node )
9878:   >> node
9882:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
9882: newIdent( node_type nt, int id ) >> Node:
9884:   Node t = oNodeNew( nt )
9894:   oNodeSetInt( t, qIdent, id )
9906:   >> t
9910:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
9910: PointerTypeTo( Node theType ) >> Node:
9912:    Node ptrType = oNodeGet( theType, qPointerType )
9925:    [ oNodeNull( ptrType )
9932:       | true :
9933:          ptrType = oNodeNew( nPointerType )
9943:          oNodeSet( ptrType, qBaseType, theType )
9955:          oNodeSetInt( ptrType, qSize, 8 )
9967:          oTypeAdd( ptrType )
9973:          oNodeSet( theType, qPointerType, ptrType )
9985:       | * :
9990:    ]
9990:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
9994: OrdinalLow( Node theType ) >> int:
9996:    [ oNodeType( theType )
10003:       | nIntegerType :  >> oMININT
10006:       | nBooleanType :  >> 0
10011:       | nCharType :     >> 0
10016:       | nEnumType :
10018:          Node enumScope = oNodeGet( theType, qScope )
10031:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
10048:          >> oNodeGetInt( first, qValue )
10058:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
10070:       | * :             #eNotOrdinalType
10085:                         >> 0
10088:    ];
      
      
      % Return the high value of an ordinal type
      %
10089: OrdinalHigh( Node theType ) >> int:
10091:    [ oNodeType( theType )
10098:       | nIntegerType :  >> oMAXINT
10101:       | nBooleanType :  >> 1
10106:       | nCharType :     >> 255
10111:       | nEnumType :
10113:          Node enumScope = oNodeGet( theType, qScope )
10126:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
10143:          >> oNodeGetInt( last, qValue )
10153:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
10165:       | * :             #eNotOrdinalType
10180:                         >> 0
10183:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
10184: EmitValue( Node decl ):
10186:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
10200: DeclareBuiltInFunc( int id ) >> Node:
10202:    Node decl = @newIdent( nBuiltInFunc, id )
10216:    oScopeDeclare( decl )
10222:    >> decl;
      
      
10226: installBuiltIns:
      
         % install built-in types
10228:    FileType = @newType( nFileType, 4 )
10242:    IntegerType = @newType( nIntegerType, 4 )
10256:    BooleanType = @newType( nBooleanType, 1 )
10270:    BooleanCFType = @newType( nBooleanCFType, 1 )
10284:    CharType = @newType( nCharType, 1 )
10298:    ByteType = @newType( nByteType, 1 )
10312:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
10326:    Node t
      
10326:    t = @newIdent( nTypeDecl, oIdAdd_File )
10339:    oNodeSet( t, qType, FileType )
10351:    oScopeDeclare( t )
      
10357:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
10370:    oNodeSet( t, qType, IntegerType )
10382:    oScopeDeclare( t )
      
10388:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
10401:    oNodeSet( t, qType, BooleanType )
10413:    oScopeDeclare( t )
      
10419:    t = @newIdent( nTypeDecl, oIdAdd_Char )
10432:    oNodeSet( t, qType, CharType )
10444:    oScopeDeclare( t )
      
10450:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
10463:    oNodeSet( t, qType, ByteType )
10475:    oScopeDeclare( t )
      
10481:    t = @newIdent( nTypeDecl, oIdAdd_String )
10494:    oNodeSet( t, qType, StringType )
10506:    oScopeDeclare( t )
      
         % Built-in constants
      
10512:    t = @newIdent( nConst, oIdAdd_True )
10525:    oNodeSet( t, qType, BooleanType )
10537:    oNodeSetInt( t, qValue, 1 )
10549:    oScopeDeclare( t )
      
10555:    t = @newIdent( nConst, oIdAdd_False )
10568:    oNodeSet( t, qType, BooleanType )
10580:    oNodeSetInt( t, qValue, 0 )
10592:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
10598:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
10608:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
10618:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
10628:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
10639:    ;
      
10639: end
      
10639: 

Generated code:

   0: oGlobalSpace 15
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 10226
  25: oEmit 54
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 48
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 51
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 50
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 53
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 9882
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 4
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 9882
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 4
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 299
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          57    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 452
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrGlobal 2
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oScopeCurrent
 225: oPushResult
 226: oSetResult 16
 228: oPushResult
 229: oGetGlobal 2
 231: oPushResult
 232: oNodeSet
 233: oPop 3
 235: oGetAddrGlobal 3
 237: oPushResult
 238: oScopeCurrent
 239: oAssign
 240: oGetLocal 4
 242: oPushResult
 243: oSetResult 7
 245: oPushResult
 246: oGetGlobal 3
 248: oPushResult
 249: oNodeSet
 250: oPop 3
 252: oScopeEnd
 253: oSetResult 20
 255: oPushResult
 256: oCall 1388
 258: oPop 1
 260: oGetGlobal 3
 262: oPushResult
 263: oScopeEnter
 264: oPop 1
 266: oGetAddrLocal 5
 268: oPushResult
 269: oSetResult 1
 271: oAssign
 272: oGetLocal 3
 274: oPushResult
 275: oGetGlobal 2
 277: oPushResult
 278: oGetLocal 5
 280: oPushResult
 281: oCall 1709
 283: oPop 3
 285: oScopeEnd
 286: oInput 20
 288: oCall 1444
 290: oScopeEnd
 291: oGetLocal 4
 293: oPushResult
 294: oCall 514
 296: oPop 1
 298: oReturn
 299: oLocalSpace 2
 301: oInput 0
 303: oGetAddrLocal 1
 305: oPushResult
 306: LAST_ID
 307: oPushResult
 308: oCall 593
 310: oPop 1
 312: oAssign
 313: oGetLocal 1
 315: oPushResult
 316: oSetResult 0
 318: oPushResult
 319: equal_node
 320: oPop 2
 322: oChoice 392
 324: oGetParam 1
 326: oPushResult
 327: oSetResult 5
 329: oPushResult
 330: oGetLocal 1
 332: oPushResult
 333: oNodeAddLast
 334: oPop 3
 336: oGetAddrLocal 2
 338: oPushResult
 339: oSetResult 10
 341: oPushResult
 342: oNodeNew
 343: oPop 1
 345: oAssign
 346: oGetLocal 2
 348: oPushResult
 349: oSetResult 4
 351: oPushResult
 352: oGetLocal 1
 354: oPushResult
 355: oSetResult 4
 357: oPushResult
 358: oNodeGetInt
 359: oPop 2
 361: oPushResult
 362: oNodeSetInt
 363: oPop 3
 365: oGetLocal 2
 367: oPushResult
 368: oSetResult 9
 370: oPushResult
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 9
 376: oPushResult
 377: oNodeGet
 378: oPop 2
 380: oPushResult
 381: oNodeSet
 382: oPop 3
 384: oGetLocal 2
 386: oPushResult
 387: oScopeDeclare
 388: oPop 1
 390: oJumpForward 395
 392: Choice Lookup Table
           0    324
 395: oInputChoice 399
 397: oJumpForward 404
 399: Choice Lookup Table
          13    397
 402: oJumpForward 406
 404: oJumpBack 301
 406: oInput 5
 408: oReturn
 409: oLocalSpace 1
 411: oGetFromParam 1
 413: oPushResult
 414: oNodeType
 415: oPop 1
 417: oChoice 448
 419: oGetAddrLocal 1
 421: oPushResult
 422: oGetFromParam 1
 424: oPushResult
 425: oSetResult 9
 427: oPushResult
 428: oNodeGet
 429: oPop 2
 431: oAssign
 432: oInput 20
 434: oInput 0
 436: oGetParam 1
 438: oPushResult
 439: oGetLocal 1
 441: oPushResult
 442: oScopeFindRequireInScope
 443: oPop 1
 445: oAssign
 446: oJumpForward 451
 448: Choice Lookup Table
          10    419
 451: oReturn
 452: oLocalSpace 2
 454: oGetAddrLocal 1
 456: oPushResult
 457: oGetParam 1
 459: oPushResult
 460: oSetResult 5
 462: oPushResult
 463: oNodeGetIter
 464: oPop 2
 466: oAssign
 467: oGetAddrLocal 2
 469: oPushResult
 470: oGetLocal 1
 472: oPushResult
 473: oNodeIterValue
 474: oPop 1
 476: oAssign
 477: oGetLocal 2
 479: oPushResult
 480: oNodeNull
 481: oPop 1
 483: oChoice 500
 485: oGetLocal 2
 487: oPushResult
 488: oSetResult 9
 490: oPushResult
 491: oNodeGet
 492: oPop 2
 494: oPushResult
 495: oScopeEnter
 496: oPop 1
 498: oJumpForward 505
 500: Choice Lookup Table
           0    485
 503: oJumpForward 513
 505: oGetAddrLocal 1
 507: oPushResult
 508: oNodeIterNext
 509: oPop 1
 511: oJumpBack 467
 513: oReturn
 514: oLocalSpace 2
 516: oGetAddrLocal 1
 518: oPushResult
 519: oGetParam 1
 521: oPushResult
 522: oSetResult 5
 524: oPushResult
 525: oNodeGetIterLast
 526: oPop 2
 528: oAssign
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetLocal 1
 534: oPushResult
 535: oNodeIterValue
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oPushResult
 542: oNodeNull
 543: oPop 1
 545: oChoice 579
 547: oScopeCurrent
 548: oPushResult
 549: oGetLocal 2
 551: oPushResult
 552: oSetResult 9
 554: oPushResult
 555: oNodeGet
 556: oPop 2
 558: oPushResult
 559: oNodeEqual
 560: oPop 2
 562: oChoice 570
 564: oJumpForward 576
 566: oError 25
 568: oJumpForward 576
 570: Choice Lookup Table
           0    566
           1    564
 575: oEndChoice
 576: oScopeEnd
 577: oJumpForward 584
 579: Choice Lookup Table
           0    547
 582: oJumpForward 592
 584: oGetAddrLocal 1
 586: oPushResult
 587: oNodeIterPrev
 588: oPop 1
 590: oJumpBack 529
 592: oReturn
 593: oLocalSpace 2
 595: oGetAddrLocal 1
 597: oPushResult
 598: oGetGlobal 1
 600: oPushResult
 601: oSetResult 1
 603: oPushResult
 604: oSetResult 4
 606: oPushResult
 607: oGetParam 1
 609: oPushResult
 610: oNodeFind
 611: oPop 4
 613: oAssign
 614: oGetLocal 1
 616: oPushResult
 617: oSetResult 0
 619: oPushResult
 620: equal_node
 621: oPop 2
 623: oChoice 630
 625: oGetLocal 1
 627: oReturn
 628: oJumpForward 633
 630: Choice Lookup Table
           0    625
 633: oGetAddrLocal 2
 635: oPushResult
 636: oGetParam 1
 638: oPushResult
 639: oIncludeUnitFile
 640: oPop 1
 642: oAssign
 643: oGetLocal 2
 645: oChoice 654
 647: oError 24
 649: oSetResult 0
 651: oReturn
 652: oJumpForward 657
 654: Choice Lookup Table
           0    647
 657: oGetAddrLocal 1
 659: oPushResult
 660: oCall 668
 662: oAssign
 663: oIncludeEnd
 664: oGetLocal 1
 666: oReturn
 667: oReturn
 668: oLocalSpace 2
 670: oInput 58
 672: oInput 0
 674: oGetAddrLocal 1
 676: oPushResult
 677: oSetResult 5
 679: oPushResult
 680: oNodeNew
 681: oPop 1
 683: oAssign
 684: oGetLocal 1
 686: oPushResult
 687: oSetResult 4
 689: oPushResult
 690: LAST_ID
 691: oPushResult
 692: oNodeSetInt
 693: oPop 3
 695: oGetAddrLocal 2
 697: oPushResult
 698: oSetResult 6
 700: oPushResult
 701: oNodeNew
 702: oPop 1
 704: oAssign
 705: oGetLocal 2
 707: oPushResult
 708: oSetResult 4
 710: oPushResult
 711: LAST_ID
 712: oPushResult
 713: oNodeSetInt
 714: oPop 3
 716: oGetLocal 1
 718: oPushResult
 719: oSetResult 8
 721: oPushResult
 722: oGetLocal 2
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oInput 5
 730: oInput 59
 732: oInputChoice 743
 734: oGetLocal 1
 736: oPushResult
 737: oCall 299
 739: oPop 1
 741: oJumpForward 746
 743: Choice Lookup Table
          57    734
 746: oGetLocal 1
 748: oPushResult
 749: oCall 452
 751: oPop 1
 753: oSetResult 0
 755: oPushResult
 756: oSetResult 0
 758: oPushResult
 759: oScopeBegin
 760: oPop 2
 762: oGetLocal 1
 764: oPushResult
 765: oSetResult 9
 767: oPushResult
 768: oScopeCurrent
 769: oPushResult
 770: oNodeSet
 771: oPop 3
 773: oGetAddrGlobal 2
 775: oPushResult
 776: oScopeCurrent
 777: oAssign
 778: oSetResult 0
 780: oPushResult
 781: oSetResult 1
 783: oPushResult
 784: oScopeBegin
 785: oPop 2
 787: oGetAddrGlobal 3
 789: oPushResult
 790: oScopeCurrent
 791: oAssign
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 13
 797: oPushResult
 798: oGetGlobal 3
 800: oPushResult
 801: oNodeSet
 802: oPop 3
 804: oScopeEnd
 805: oGetLocal 1
 807: oPushResult
 808: oCall 989
 810: oPop 1
 812: oScopeEnd
 813: oInput 60
 815: oInputChoice 826
 817: oGetLocal 2
 819: oPushResult
 820: oCall 299
 822: oPop 1
 824: oJumpForward 829
 826: Choice Lookup Table
          57    817
 829: oGetLocal 2
 831: oPushResult
 832: oCall 452
 834: oPop 1
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 9
 841: oPushResult
 842: oNodeGet
 843: oPop 2
 845: oPushResult
 846: oScopeEnter
 847: oPop 1
 849: oSetResult 0
 851: oPushResult
 852: oSetResult 0
 854: oPushResult
 855: oScopeBegin
 856: oPop 2
 858: oGetLocal 1
 860: oPushResult
 861: oSetResult 10
 863: oPushResult
 864: oScopeCurrent
 865: oPushResult
 866: oNodeSet
 867: oPop 3
 869: oScopeCurrent
 870: oPushResult
 871: oSetResult 16
 873: oPushResult
 874: oGetLocal 1
 876: oPushResult
 877: oSetResult 9
 879: oPushResult
 880: oNodeGet
 881: oPop 2
 883: oPushResult
 884: oNodeSet
 885: oPop 3
 887: oGetAddrGlobal 2
 889: oPushResult
 890: oScopeCurrent
 891: oAssign
 892: oGetLocal 1
 894: oPushResult
 895: oCall 1074
 897: oPop 1
 899: oInputChoice 913
 901: oGetLocal 1
 903: oPushResult
 904: oSetResult 1
 906: oPushResult
 907: oCall 1084
 909: oPop 2
 911: oJumpForward 926
 913: Choice Lookup Table
          61    901
 916: oGetLocal 1
 918: oPushResult
 919: oSetResult 0
 921: oPushResult
 922: oCall 1084
 924: oPop 2
 926: oInputChoice 940
 928: oGetLocal 1
 930: oPushResult
 931: oSetResult 1
 933: oPushResult
 934: oCall 1270
 936: oPop 2
 938: oJumpForward 953
 940: Choice Lookup Table
          62    928
 943: oGetLocal 1
 945: oPushResult
 946: oSetResult 0
 948: oPushResult
 949: oCall 1270
 951: oPop 2
 953: oInput 36
 955: oInput 20
 957: oScopeEnd
 958: oScopeEnd
 959: oGetLocal 2
 961: oPushResult
 962: oCall 514
 964: oPop 1
 966: oGetLocal 1
 968: oPushResult
 969: oCall 514
 971: oPop 1
 973: oGetGlobal 1
 975: oPushResult
 976: oSetResult 1
 978: oPushResult
 979: oGetLocal 1
 981: oPushResult
 982: oNodeAddLast
 983: oPop 3
 985: oGetLocal 1
 987: oReturn
 988: oReturn
 989: oLocalSpace 2
 991: oInputChoice 1058
 993: oCall 2982
 995: oJumpForward 1071
 997: oCall 3533
 999: oJumpForward 1071
1001: oSetResult 20
1003: oPushResult
1004: oCall 3589
1006: oPop 1
1008: oJumpForward 1071
1010: oGetAddrLocal 1
1012: oPushResult
1013: oCall 1949
1015: oAssign
1016: oInputChoice 1029
1018: oGetLocal 1
1020: oPushResult
1021: oCall 1887
1023: oPop 1
1025: oInput 5
1027: oJumpForward 1032
1029: Choice Lookup Table
          68   1018
1032: oJumpForward 1071
1034: oGetAddrLocal 2
1036: oPushResult
1037: oCall 2323
1039: oAssign
1040: oInputChoice 1053
1042: oGetLocal 2
1044: oPushResult
1045: oCall 1887
1047: oPop 1
1049: oInput 5
1051: oJumpForward 1056
1053: Choice Lookup Table
          68   1042
1056: oJumpForward 1071
1058: Choice Lookup Table
          30   1034
          29   1010
          33   1001
          32    997
          31    993
1069: oJumpForward 1073
1071: oJumpBack 991
1073: oReturn
1074: oLocalSpace 0
1076: oSetResult 20
1078: oPushResult
1079: oCall 1388
1081: oPop 1
1083: oReturn
1084: oLocalSpace 5
1086: oGetAddrLocal 1
1088: oPushResult
1089: oLabelNew
1090: oAssign
1091: oEmit 58
1093: oGetLocal 1
1095: oPushResult
1096: oEmitLabel
1097: oPop 1
1099: oGetParam 2
1101: oPushResult
1102: oSetResult 11
1104: oPushResult
1105: oGetLocal 1
1107: oPushResult
1108: oNodeSetLabel
1109: oPop 3
1111: oEmit 54
1113: oGetAddrLocal 2
1115: oPushResult
1116: Here
1117: oAssign
1118: oEmit 68
1120: oGetAddrLocal 3
1122: oPushResult
1123: oGetParam 2
1125: oPushResult
1126: oSetResult 9
1128: oPushResult
1129: oNodeGet
1130: oPop 2
1132: oAssign
1133: oGetAddrLocal 4
1135: oPushResult
1136: oGetLocal 3
1138: oPushResult
1139: oSetResult 19
1141: oPushResult
1142: oNodeGetCode
1143: oPop 2
1145: oAssign
1146: oGetLocal 4
1148: oPushResult
1149: oEmitCode
1150: oPop 1
1152: oGetLocal 3
1154: oPushResult
1155: oSetResult 19
1157: oPushResult
1158: oSetResult 0
1160: oPushResult
1161: oNodeSetCode
1162: oPop 3
1164: oGetAddrLocal 3
1166: oPushResult
1167: oGetParam 2
1169: oPushResult
1170: oSetResult 10
1172: oPushResult
1173: oNodeGet
1174: oPop 2
1176: oAssign
1177: oGetAddrLocal 4
1179: oPushResult
1180: oGetLocal 3
1182: oPushResult
1183: oSetResult 19
1185: oPushResult
1186: oNodeGetCode
1187: oPop 2
1189: oAssign
1190: oGetLocal 4
1192: oPushResult
1193: oEmitCode
1194: oPop 1
1196: oGetLocal 3
1198: oPushResult
1199: oSetResult 19
1201: oPushResult
1202: oSetResult 0
1204: oPushResult
1205: oNodeSetCode
1206: oPop 3
1208: oGetParam 2
1210: oPushResult
1211: oSetResult 13
1213: oPushResult
1214: oNodeGet
1215: oPop 2
1217: oPushResult
1218: oScopeEnter
1219: oPop 1
1221: oGetParam 1
1223: oChoice 1242
1225: oCall 8417
1227: oInputChoice 1233
1229: oCall 8417
1231: oJumpForward 1238
1233: Choice Lookup Table
           5   1229
1236: oJumpForward 1240
1238: oJumpBack 1227
1240: oJumpForward 1245
1242: Choice Lookup Table
           1   1225
1245: oEmit 53
1247: oGetAddrLocal 5
1249: oPushResult
1250: oScopeCurrent
1251: oPushResult
1252: oSetResult 17
1254: oPushResult
1255: oNodeGetInt
1256: oPop 2
1258: oAssign
1259: oGetLocal 2
1261: oPushResult
1262: oGetLocal 5
1264: oPushResult
1265: oPatch
1266: oPop 2
1268: oScopeEnd
1269: oReturn
1270: oLocalSpace 3
1272: oGetAddrLocal 1
1274: oPushResult
1275: oLabelNew
1276: oAssign
1277: oEmit 58
1279: oGetLocal 1
1281: oPushResult
1282: oEmitLabel
1283: oPop 1
1285: oGetParam 2
1287: oPushResult
1288: oSetResult 12
1290: oPushResult
1291: oGetLocal 1
1293: oPushResult
1294: oNodeSetLabel
1295: oPop 3
1297: oEmit 54
1299: oGetAddrLocal 2
1301: oPushResult
1302: Here
1303: oAssign
1304: oEmit 68
1306: oSetResult 0
1308: oPushResult
1309: oSetResult 1
1311: oPushResult
1312: oScopeBegin
1313: oPop 2
1315: oGetParam 1
1317: oChoice 1336
1319: oCall 8417
1321: oInputChoice 1327
1323: oCall 8417
1325: oJumpForward 1332
1327: Choice Lookup Table
           5   1323
1330: oJumpForward 1334
1332: oJumpBack 1321
1334: oJumpForward 1339
1336: Choice Lookup Table
           1   1319
1339: oEmit 53
1341: oGetAddrLocal 3
1343: oPushResult
1344: oScopeCurrent
1345: oPushResult
1346: oSetResult 17
1348: oPushResult
1349: oNodeGetInt
1350: oPop 2
1352: oAssign
1353: oGetLocal 2
1355: oPushResult
1356: oGetLocal 3
1358: oPushResult
1359: oPatch
1360: oPop 2
1362: oScopeEnd
1363: oReturn
1364: oLocalSpace 0
1366: oGetParam 2
1368: oPushResult
1369: oCall 1388
1371: oPop 1
1373: oGetParam 1
1375: oPushResult
1376: oScopeCurrent
1377: oPushResult
1378: oSetResult 0
1380: oPushResult
1381: oCall 1709
1383: oPop 3
1385: oCall 1444
1387: oReturn
1388: oLocalSpace 0
1390: oInputChoice 1421
1392: oCall 2982
1394: oJumpForward 1436
1396: oCall 3533
1398: oJumpForward 1436
1400: oGetParam 1
1402: oPushResult
1403: oCall 3589
1405: oPop 1
1407: oJumpForward 1436
1409: oCall 3820
1411: oJumpForward 1436
1413: oCall 2205
1415: oJumpForward 1436
1417: oCall 2640
1419: oJumpForward 1436
1421: Choice Lookup Table
          30   1417
          29   1413
          34   1409
          33   1400
          32   1396
          31   1392
1434: oJumpForward 1438
1436: oJumpBack 1390
1438: oCall 1441
1440: oReturn
1441: oLocalSpace 0
1443: oReturn
1444: oLocalSpace 2
1446: oGetAddrLocal 1
1448: oPushResult
1449: oScopeCurrent
1450: oPushResult
1451: oSetResult 15
1453: oPushResult
1454: oNodeGetIter
1455: oPop 2
1457: oAssign
1458: oGetAddrLocal 2
1460: oPushResult
1461: oGetLocal 1
1463: oPushResult
1464: oNodeIterValue
1465: oPop 1
1467: oAssign
1468: oGetLocal 2
1470: oPushResult
1471: oNodeNull
1472: oPop 1
1474: oChoice 1478
1476: oJumpForward 1483
1478: Choice Lookup Table
           0   1476
1481: oJumpForward 1538
1483: oGetLocal 2
1485: oPushResult
1486: oNodeType
1487: oPop 1
1489: oChoice 1527
1491: oGetLocal 2
1493: oPushResult
1494: oSetResult 34
1496: oPushResult
1497: oNodeGetBoolean
1498: oPop 2
1500: oChoice 1522
1502: oGetLocal 2
1504: oPushResult
1505: oSetResult 28
1507: oPushResult
1508: oNodeGetBoolean
1509: oPop 2
1511: oChoice 1517
1513: oError 27
1515: oJumpForward 1520
1517: Choice Lookup Table
           1   1513
1520: oJumpForward 1525
1522: Choice Lookup Table
           0   1502
1525: oJumpForward 1530
1527: Choice Lookup Table
          25   1491
1530: oGetAddrLocal 1
1532: oPushResult
1533: oNodeIterNext
1534: oPop 1
1536: oJumpBack 1458
1538: oReturn
1539: oLocalSpace 2
1541: oGetAddrLocal 1
1543: oPushResult
1544: oGetGlobal 1
1546: oPushResult
1547: oSetResult 1
1549: oPushResult
1550: oNodeGetIter
1551: oPop 2
1553: oAssign
1554: oGetAddrLocal 2
1556: oPushResult
1557: oGetLocal 1
1559: oPushResult
1560: oNodeIterValue
1561: oPop 1
1563: oAssign
1564: oGetLocal 2
1566: oPushResult
1567: oNodeNull
1568: oPop 1
1570: oChoice 1615
1572: oJumpForward 1623
1574: oJumpForward 1621
1576: oEmit 48
1578: oSetResult 0
1580: oPushResult
1581: oEmitInt
1582: oPop 1
1584: oEmit 51
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 11
1591: oPushResult
1592: oNodeGetLabel
1593: oPop 2
1595: oPushResult
1596: oEmitLabel
1597: oPop 1
1599: oEmit 50
1601: oSetResult 0
1603: oPushResult
1604: oEmitInt
1605: oPop 1
1607: oGetAddrLocal 1
1609: oPushResult
1610: oNodeIterNext
1611: oPop 1
1613: oJumpForward 1621
1615: Choice Lookup Table
           0   1576
           1   1572
1620: oEndChoice
1621: oJumpBack 1554
1623: oReturn
1624: oLocalSpace 2
1626: oGetAddrLocal 1
1628: oPushResult
1629: oGetGlobal 1
1631: oPushResult
1632: oSetResult 1
1634: oPushResult
1635: oNodeGetIterLast
1636: oPop 2
1638: oAssign
1639: oGetAddrLocal 2
1641: oPushResult
1642: oGetLocal 1
1644: oPushResult
1645: oNodeIterValue
1646: oPop 1
1648: oAssign
1649: oGetLocal 2
1651: oPushResult
1652: oNodeNull
1653: oPop 1
1655: oChoice 1700
1657: oJumpForward 1708
1659: oJumpForward 1706
1661: oEmit 48
1663: oSetResult 0
1665: oPushResult
1666: oEmitInt
1667: oPop 1
1669: oEmit 51
1671: oGetLocal 2
1673: oPushResult
1674: oSetResult 12
1676: oPushResult
1677: oNodeGetLabel
1678: oPop 2
1680: oPushResult
1681: oEmitLabel
1682: oPop 1
1684: oEmit 50
1686: oSetResult 0
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oGetAddrLocal 1
1694: oPushResult
1695: oNodeIterPrev
1696: oPop 1
1698: oJumpForward 1706
1700: Choice Lookup Table
           0   1661
           1   1657
1705: oEndChoice
1706: oJumpBack 1639
1708: oReturn
1709: oLocalSpace 3
1711: oEmit 58
1713: oGetParam 3
1715: oPushResult
1716: oEmitLabel
1717: oPop 1
1719: oEmit 54
1721: oGetAddrLocal 1
1723: oPushResult
1724: Here
1725: oAssign
1726: oEmit 68
1728: oGetParam 1
1730: oChoice 1736
1732: oCall 1539
1734: oJumpForward 1739
1736: Choice Lookup Table
           1   1732
1739: oGetAddrLocal 2
1741: oPushResult
1742: oGetParam 2
1744: oPushResult
1745: oSetResult 19
1747: oPushResult
1748: oNodeGetCode
1749: oPop 2
1751: oAssign
1752: oGetLocal 2
1754: oPushResult
1755: oEmitCode
1756: oPop 1
1758: oGetParam 2
1760: oPushResult
1761: oSetResult 19
1763: oPushResult
1764: oSetResult 0
1766: oPushResult
1767: oNodeSetCode
1768: oPop 3
1770: oCall 8417
1772: oGetParam 1
1774: oChoice 1780
1776: oCall 1624
1778: oJumpForward 1783
1780: Choice Lookup Table
           1   1776
1783: oEmit 53
1785: oGetAddrLocal 3
1787: oPushResult
1788: oScopeCurrent
1789: oPushResult
1790: oSetResult 17
1792: oPushResult
1793: oNodeGetInt
1794: oPop 2
1796: oAssign
1797: oGetLocal 1
1799: oPushResult
1800: oGetLocal 3
1802: oPushResult
1803: oPatch
1804: oPop 2
1806: oReturn
1807: oLocalSpace 0
1809: oInputChoice 1827
1811: oGetParam 1
1813: oPushResult
1814: oSetResult 27
1816: oPushResult
1817: oSetResult 1
1819: oPushResult
1820: oNodeSetBoolean
1821: oPop 3
1823: oInput 5
1825: oJumpForward 1832
1827: Choice Lookup Table
          70   1811
1830: oJumpForward 1834
1832: oJumpBack 1809
1834: oReturn
1835: oLocalSpace 1
1837: oGetAddrLocal 1
1839: oPushResult
1840: oGetParam 1
1842: oPushResult
1843: oSetResult 19
1845: oPushResult
1846: oNodeGetCode
1847: oPop 2
1849: oAssign
1850: oGetLocal 1
1852: oPushResult
1853: oSetResult 0
1855: oPushResult
1856: equal_code
1857: oPop 2
1859: oChoice 1880
1861: oGetAddrLocal 1
1863: oPushResult
1864: oCodeNew
1865: oAssign
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 19
1871: oPushResult
1872: oGetLocal 1
1874: oPushResult
1875: oNodeSetCode
1876: oPop 3
1878: oJumpForward 1883
1880: Choice Lookup Table
           1   1861
1883: oGetLocal 1
1885: oReturn
1886: oReturn
1887: oLocalSpace 0
1889: oGetParam 1
1891: oPushResult
1892: oCall 9664
1894: oPop 1
1896: oPushResult
1897: equal_zero
1898: oPop 1
1900: oChoice 1906
1902: oError 23
1904: oJumpForward 1909
1906: Choice Lookup Table
           0   1902
1909: oGetParam 1
1911: oPushResult
1912: oSetResult 25
1914: oPushResult
1915: oSetResult 1
1917: oPushResult
1918: oNodeSetBoolean
1919: oPop 3
1921: oInputChoice 1945
1923: oInputChoice 1940
1925: oInput 2
1927: oGetParam 1
1929: oPushResult
1930: oSetResult 26
1932: oPushResult
1933: CURRENT_STRLIT
1934: oPushResult
1935: oNodeSetString
1936: oPop 3
1938: oJumpForward 1943
1940: Choice Lookup Table
          69   1925
1943: oJumpForward 1948
1945: Choice Lookup Table
           2   1923
1948: oReturn
1949: oLocalSpace 6
1951: oInput 0
1953: oGetAddrLocal 1
1955: oPushResult
1956: oSetResult 0
1958: oAssign
1959: oGetAddrLocal 2
1961: oPushResult
1962: oScopeFindInCurrentScope
1963: oAssign
1964: oGetLocal 2
1966: oPushResult
1967: oNodeNull
1968: oPop 1
1970: oChoice 2088
1972: oGetAddrLocal 2
1974: oPushResult
1975: oSetResult 12
1977: oPushResult
1978: LAST_ID
1979: oPushResult
1980: oCall 9882
1982: oPop 2
1984: oAssign
1985: oGetLocal 2
1987: oPushResult
1988: oSetResult 22
1990: oPushResult
1991: oLabelNew
1992: oPushResult
1993: oNodeSetLabel
1994: oPop 3
1996: oJumpForward 2094
1998: oGetAddrLocal 1
2000: oPushResult
2001: oSetResult 1
2003: oAssign
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 24
2009: oPushResult
2010: oNodeGetBoolean
2011: oPop 2
2013: oChoice 2019
2015: oError 21
2017: oJumpForward 2022
2019: Choice Lookup Table
           1   2015
2022: oGetLocal 2
2024: oPushResult
2025: oSetResult 25
2027: oPushResult
2028: oNodeGetBoolean
2029: oPop 2
2031: oChoice 2037
2033: oError 21
2035: oJumpForward 2040
2037: Choice Lookup Table
           1   2033
2040: oGetLocal 2
2042: oPushResult
2043: oNodeType
2044: oPop 1
2046: oChoice 2050
2048: oJumpForward 2055
2050: Choice Lookup Table
          12   2048
2053: oError 21
2055: oGetLocal 2
2057: oPushResult
2058: oSetResult 29
2060: oPushResult
2061: oGetLocal 2
2063: oPushResult
2064: oSetResult 23
2066: oPushResult
2067: oNodeGet
2068: oPop 2
2070: oPushResult
2071: oNodeSet
2072: oPop 3
2074: oGetLocal 2
2076: oPushResult
2077: oSetResult 23
2079: oPushResult
2080: oSetResult 0
2082: oPushResult
2083: oNodeSet
2084: oPop 3
2086: oJumpForward 2094
2088: Choice Lookup Table
           0   1998
           1   1972
2093: oEndChoice
2094: oGetAddrLocal 3
2096: oPushResult
2097: oCall 9652
2099: oAssign
2100: oGetAddrLocal 4
2102: oPushResult
2103: oGetLocal 3
2105: oPushResult
2106: oSetResult 0
2108: oPushResult
2109: greater
2110: oPop 2
2112: oAssign
2113: oGetAddrLocal 3
2115: oPushResult
2116: inc
2117: oPop 1
2119: oGetLocal 3
2121: oPushResult
2122: oSetResult 2
2124: oPushResult
2125: oScopeBegin
2126: oPop 2
2128: oGetAddrLocal 5
2130: oPushResult
2131: oScopeCurrent
2132: oAssign
2133: oGetLocal 4
2135: oChoice 2154
2137: oGetAddrLocal 6
2139: oPushResult
2140: oGetGlobal 5
2142: oPushResult
2143: oCall 9910
2145: oPop 1
2147: oPushResult
2148: oScopeAllocType
2149: oPop 1
2151: oAssign
2152: oJumpForward 2157
2154: Choice Lookup Table
           1   2137
2157: oCall 2758
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 23
2164: oPushResult
2165: oGetLocal 5
2167: oPushResult
2168: oNodeSet
2169: oPop 3
2171: oScopeEnd
2172: oInput 5
2174: oGetLocal 1
2176: oChoice 2188
2178: oGetLocal 2
2180: oPushResult
2181: oScopeDeclare
2182: oPop 1
2184: oJumpForward 2194
2186: oJumpForward 2194
2188: Choice Lookup Table
           1   2186
           0   2178
2193: oEndChoice
2194: oGetLocal 2
2196: oPushResult
2197: oCall 1807
2199: oPop 1
2201: oGetLocal 2
2203: oReturn
2204: oReturn
2205: oLocalSpace 4
2207: oGetAddrLocal 1
2209: oPushResult
2210: oCall 1949
2212: oAssign
2213: oInputChoice 2226
2215: oJumpForward 2320
2217: oGetLocal 1
2219: oPushResult
2220: oCall 1887
2222: oPop 1
2224: oJumpForward 2320
2226: Choice Lookup Table
          68   2217
          67   2215
2231: oGetAddrLocal 2
2233: oPushResult
2234: oGetLocal 1
2236: oPushResult
2237: oSetResult 23
2239: oPushResult
2240: oNodeGet
2241: oPop 2
2243: oAssign
2244: oGetLocal 2
2246: oPushResult
2247: oScopeEnter
2248: oPop 1
2250: oGetAddrLocal 3
2252: oPushResult
2253: oGetLocal 2
2255: oPushResult
2256: oSetResult 14
2258: oPushResult
2259: oNodeGetInt
2260: oPop 2
2262: oAssign
2263: oGetLocal 3
2265: oPushResult
2266: oSetResult 1
2268: oPushResult
2269: oScopeBegin
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 6
2277: oPushResult
2278: oScopeCurrent
2279: oPushResult
2280: oNodeSet
2281: oPop 3
2283: oGetAddrLocal 4
2285: oPushResult
2286: oGetLocal 1
2288: oPushResult
2289: oSetResult 22
2291: oPushResult
2292: oNodeGetLabel
2293: oPop 2
2295: oAssign
2296: oSetResult 21
2298: oPushResult
2299: oGetLocal 4
2301: oPushResult
2302: oCall 1364
2304: oPop 2
2306: oGetLocal 1
2308: oPushResult
2309: oSetResult 24
2311: oPushResult
2312: oSetResult 1
2314: oPushResult
2315: oNodeSetBoolean
2316: oPop 3
2318: oScopeEnd
2319: oScopeEnd
2320: oInput 5
2322: oReturn
2323: oLocalSpace 8
2325: oInput 0
2327: oGetAddrLocal 1
2329: oPushResult
2330: oSetResult 0
2332: oAssign
2333: oGetAddrLocal 2
2335: oPushResult
2336: oScopeFindInCurrentScope
2337: oAssign
2338: oGetLocal 2
2340: oPushResult
2341: oNodeNull
2342: oPop 1
2344: oChoice 2475
2346: oGetAddrLocal 2
2348: oPushResult
2349: oSetResult 13
2351: oPushResult
2352: LAST_ID
2353: oPushResult
2354: oCall 9882
2356: oPop 2
2358: oAssign
2359: oGetLocal 2
2361: oPushResult
2362: oSetResult 22
2364: oPushResult
2365: oLabelNew
2366: oPushResult
2367: oNodeSetLabel
2368: oPop 3
2370: oJumpForward 2481
2372: oGetAddrLocal 1
2374: oPushResult
2375: oSetResult 1
2377: oAssign
2378: oGetLocal 2
2380: oPushResult
2381: oSetResult 24
2383: oPushResult
2384: oNodeGetBoolean
2385: oPop 2
2387: oChoice 2393
2389: oError 21
2391: oJumpForward 2396
2393: Choice Lookup Table
           1   2389
2396: oGetLocal 2
2398: oPushResult
2399: oNodeType
2400: oPop 1
2402: oChoice 2406
2404: oJumpForward 2411
2406: Choice Lookup Table
          13   2404
2409: oError 21
2411: oGetLocal 2
2413: oPushResult
2414: oSetResult 29
2416: oPushResult
2417: oGetLocal 2
2419: oPushResult
2420: oSetResult 23
2422: oPushResult
2423: oNodeGet
2424: oPop 2
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oSetResult 0
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oGetLocal 2
2444: oPushResult
2445: oSetResult 30
2447: oPushResult
2448: oGetLocal 2
2450: oPushResult
2451: oSetResult 21
2453: oPushResult
2454: oNodeGet
2455: oPop 2
2457: oPushResult
2458: oNodeSet
2459: oPop 3
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oSetResult 0
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oJumpForward 2481
2475: Choice Lookup Table
           0   2372
           1   2346
2480: oEndChoice
2481: oGetAddrLocal 3
2483: oPushResult
2484: oCall 9652
2486: oAssign
2487: oGetAddrLocal 4
2489: oPushResult
2490: oGetLocal 3
2492: oPushResult
2493: oSetResult 0
2495: oPushResult
2496: greater
2497: oPop 2
2499: oAssign
2500: oGetAddrLocal 3
2502: oPushResult
2503: inc
2504: oPop 1
2506: oGetLocal 3
2508: oPushResult
2509: oSetResult 2
2511: oPushResult
2512: oScopeBegin
2513: oPop 2
2515: oGetAddrLocal 5
2517: oPushResult
2518: oScopeCurrent
2519: oAssign
2520: oGetLocal 4
2522: oChoice 2541
2524: oGetAddrLocal 6
2526: oPushResult
2527: oGetGlobal 5
2529: oPushResult
2530: oCall 9910
2532: oPop 1
2534: oPushResult
2535: oScopeAllocType
2536: oPop 1
2538: oAssign
2539: oJumpForward 2544
2541: Choice Lookup Table
           1   2524
2544: oCall 2758
2546: oGetLocal 2
2548: oPushResult
2549: oSetResult 23
2551: oPushResult
2552: oGetLocal 5
2554: oPushResult
2555: oNodeSet
2556: oPop 3
2558: oInput 12
2560: oGetAddrLocal 7
2562: oPushResult
2563: oCall 3885
2565: oPop 1
2567: oGetLocal 2
2569: oPushResult
2570: oSetResult 21
2572: oPushResult
2573: oGetLocal 7
2575: oPushResult
2576: oNodeSet
2577: oPop 3
2579: oGetAddrLocal 8
2581: oPushResult
2582: oGetLocal 7
2584: oPushResult
2585: oCall 9910
2587: oPop 1
2589: oAssign
2590: oGetLocal 2
2592: oPushResult
2593: oSetResult 31
2595: oPushResult
2596: oGetLocal 8
2598: oPushResult
2599: oScopeAllocType
2600: oPop 1
2602: oPushResult
2603: oNodeSetInt
2604: oPop 3
2606: oScopeEnd
2607: oInput 5
2609: oGetLocal 1
2611: oChoice 2623
2613: oGetLocal 2
2615: oPushResult
2616: oScopeDeclare
2617: oPop 1
2619: oJumpForward 2629
2621: oJumpForward 2629
2623: Choice Lookup Table
           1   2621
           0   2613
2628: oEndChoice
2629: oGetLocal 2
2631: oPushResult
2632: oCall 1807
2634: oPop 1
2636: oGetLocal 2
2638: oReturn
2639: oReturn
2640: oLocalSpace 4
2642: oGetAddrLocal 1
2644: oPushResult
2645: oCall 2323
2647: oAssign
2648: oInputChoice 2661
2650: oJumpForward 2755
2652: oGetLocal 1
2654: oPushResult
2655: oCall 1887
2657: oPop 1
2659: oJumpForward 2755
2661: Choice Lookup Table
          68   2652
          67   2650
2666: oGetAddrLocal 2
2668: oPushResult
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 23
2674: oPushResult
2675: oNodeGet
2676: oPop 2
2678: oAssign
2679: oGetLocal 2
2681: oPushResult
2682: oScopeEnter
2683: oPop 1
2685: oGetAddrLocal 3
2687: oPushResult
2688: oGetLocal 2
2690: oPushResult
2691: oSetResult 14
2693: oPushResult
2694: oNodeGetInt
2695: oPop 2
2697: oAssign
2698: oGetLocal 3
2700: oPushResult
2701: oSetResult 1
2703: oPushResult
2704: oScopeBegin
2705: oPop 2
2707: oGetLocal 1
2709: oPushResult
2710: oSetResult 6
2712: oPushResult
2713: oScopeCurrent
2714: oPushResult
2715: oNodeSet
2716: oPop 3
2718: oGetAddrLocal 4
2720: oPushResult
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 22
2726: oPushResult
2727: oNodeGetLabel
2728: oPop 2
2730: oAssign
2731: oSetResult 21
2733: oPushResult
2734: oGetLocal 4
2736: oPushResult
2737: oCall 1364
2739: oPop 2
2741: oGetLocal 1
2743: oPushResult
2744: oSetResult 24
2746: oPushResult
2747: oSetResult 1
2749: oPushResult
2750: oNodeSetBoolean
2751: oPop 3
2753: oScopeEnd
2754: oScopeEnd
2755: oInput 5
2757: oReturn
2758: oLocalSpace 6
2760: oInputChoice 2978
2762: oGetAddrLocal 1
2764: oPushResult
2765: oNodeVecNew
2766: oAssign
2767: oGetAddrLocal 3
2769: oPushResult
2770: oSetResult 0
2772: oAssign
2773: oInputChoice 2783
2775: oGetAddrLocal 3
2777: oPushResult
2778: oSetResult 1
2780: oAssign
2781: oJumpForward 2786
2783: Choice Lookup Table
          33   2775
2786: oInput 0
2788: oGetAddrLocal 2
2790: oPushResult
2791: oSetResult 23
2793: oPushResult
2794: LAST_ID
2795: oPushResult
2796: oCall 9882
2798: oPop 2
2800: oAssign
2801: oGetLocal 2
2803: oPushResult
2804: oSetResult 33
2806: oPushResult
2807: oGetLocal 3
2809: oPushResult
2810: oNodeSetBoolean
2811: oPop 3
2813: oGetLocal 1
2815: oPushResult
2816: oGetLocal 2
2818: oPushResult
2819: oNodeVecAppend
2820: oPop 2
2822: oInputChoice 2830
2824: oJumpForward 2838
2826: oJumpForward 2836
2828: oJumpForward 2836
2830: Choice Lookup Table
          13   2828
          12   2824
2835: oEndChoice
2836: oJumpBack 2786
2838: oGetAddrLocal 4
2840: oPushResult
2841: oCall 3885
2843: oPop 1
2845: oGetLocal 3
2847: oChoice 2862
2849: oGetAddrLocal 5
2851: oPushResult
2852: oGetLocal 4
2854: oPushResult
2855: oCall 9910
2857: oPop 1
2859: oAssign
2860: oJumpForward 2871
2862: Choice Lookup Table
           1   2849
2865: oGetAddrLocal 5
2867: oPushResult
2868: oGetLocal 4
2870: oAssign
2871: oGetAddrLocal 6
2873: oPushResult
2874: oSetResult 0
2876: oAssign
2877: oGetLocal 6
2879: oPushResult
2880: oGetLocal 1
2882: oPushResult
2883: oNodeVecSize
2884: oPop 1
2886: oPushResult
2887: equal
2888: oPop 2
2890: oChoice 2947
2892: oGetAddrLocal 2
2894: oPushResult
2895: oGetLocal 1
2897: oPushResult
2898: oGetLocal 6
2900: oPushResult
2901: oNodeVecElement
2902: oPop 2
2904: oAssign
2905: oGetLocal 2
2907: oPushResult
2908: oSetResult 21
2910: oPushResult
2911: oGetLocal 4
2913: oPushResult
2914: oNodeSet
2915: oPop 3
2917: oGetLocal 2
2919: oPushResult
2920: oScopeDeclare
2921: oPop 1
2923: oGetLocal 2
2925: oPushResult
2926: oSetResult 22
2928: oPushResult
2929: oGetLocal 5
2931: oPushResult
2932: oScopeAllocType
2933: oPop 1
2935: oPushResult
2936: oNodeSetInt
2937: oPop 3
2939: oGetAddrLocal 6
2941: oPushResult
2942: inc
2943: oPop 1
2945: oJumpForward 2952
2947: Choice Lookup Table
           0   2892
2950: oJumpForward 2954
2952: oJumpBack 2877
2954: oGetLocal 1
2956: oPushResult
2957: oNodeVecDelete
2958: oPop 1
2960: oInputChoice 2968
2962: oJumpForward 2976
2964: oJumpForward 2974
2966: oJumpForward 2974
2968: Choice Lookup Table
           5   2966
          15   2962
2973: oEndChoice
2974: oJumpBack 2762
2976: oJumpForward 2981
2978: Choice Lookup Table
          14   2762
2981: oReturn
2982: oLocalSpace 0
2984: oInputChoice 2999
2986: oInputChoice 2992
2988: oCall 3065
2990: oJumpForward 2997
2992: Choice Lookup Table
          12   2988
2995: oCall 3007
2997: oJumpForward 3004
2999: Choice Lookup Table
           0   2986
3002: oJumpForward 3006
3004: oJumpBack 2984
3006: oReturn
3007: oLocalSpace 2
3009: oGetAddrLocal 1
3011: oPushResult
3012: oSetResult 16
3014: oPushResult
3015: LAST_ID
3016: oPushResult
3017: oCall 9882
3019: oPop 2
3021: oAssign
3022: oInput 6
3024: oCall 4941
3026: oGetAddrLocal 2
3028: oPushResult
3029: oValueTop
3030: oAssign
3031: oValuePop
3032: oGetLocal 1
3034: oPushResult
3035: oSetResult 22
3037: oPushResult
3038: oGetLocal 2
3040: oPushResult
3041: oNodeSetInt
3042: oPop 3
3044: oGetLocal 1
3046: oPushResult
3047: oSetResult 21
3049: oPushResult
3050: oGetGlobal 5
3052: oPushResult
3053: oNodeSet
3054: oPop 3
3056: oGetLocal 1
3058: oPushResult
3059: oScopeDeclare
3060: oPop 1
3062: oInput 5
3064: oReturn
3065: oLocalSpace 4
3067: oGetAddrLocal 1
3069: oPushResult
3070: oSetResult 24
3072: oPushResult
3073: LAST_ID
3074: oPushResult
3075: oCall 9882
3077: oPop 2
3079: oAssign
3080: oGetAddrLocal 2
3082: oPushResult
3083: oCall 3885
3085: oPop 1
3087: oGetLocal 1
3089: oPushResult
3090: oSetResult 21
3092: oPushResult
3093: oGetLocal 2
3095: oPushResult
3096: oNodeSet
3097: oPop 3
3099: oGetLocal 2
3101: oPushResult
3102: oNodeType
3103: oPop 1
3105: oChoice 3206
3107: oInput 6
3109: oCall 4941
3111: oGetAddrLocal 3
3113: oPushResult
3114: oValueTop
3115: oAssign
3116: oValuePop
3117: oGetLocal 1
3119: oPushResult
3120: oSetResult 22
3122: oPushResult
3123: oGetLocal 3
3125: oPushResult
3126: oNodeSetInt
3127: oPop 3
3129: oGetLocal 1
3131: oPushResult
3132: oScopeDeclare
3133: oPop 1
3135: oInput 5
3137: oJumpForward 3228
3139: oError 16
3141: oJumpForward 3228
3143: oGetGlobal 2
3145: oPushResult
3146: oScopeEnter
3147: oPop 1
3149: oGetAddrLocal 4
3151: oPushResult
3152: oGetLocal 2
3154: oPushResult
3155: oScopeAllocType
3156: oPop 1
3158: oAssign
3159: oScopeEnd
3160: oGetGlobal 2
3162: oPushResult
3163: oCall 1835
3165: oPop 1
3167: oPushResult
3168: oCodePush
3169: oPop 1
3171: oGetLocal 1
3173: oPushResult
3174: oSetResult 22
3176: oPushResult
3177: oGetLocal 4
3179: oPushResult
3180: oNodeSetInt
3181: oPop 3
3183: oInput 6
3185: oGetLocal 2
3187: oPushResult
3188: oGetLocal 4
3190: oPushResult
3191: oCall 3229
3193: oPop 2
3195: oCodePop
3196: oGetLocal 1
3198: oPushResult
3199: oScopeDeclare
3200: oPop 1
3202: oInput 5
3204: oJumpForward 3228
3206: Choice Lookup Table
          37   3143
          35   3143
          34   3139
          27   3139
          33   3139
          38   3107
          28   3107
          32   3107
          29   3107
          30   3107
3227: oEndChoice
3228: oReturn
3229: oLocalSpace 10
3231: oGetParam 2
3233: oPushResult
3234: oNodeType
3235: oPop 1
3237: oChoice 3510
3239: oGetAddrLocal 1
3241: oPushResult
3242: oGetParam 2
3244: oPushResult
3245: oSetResult 36
3247: oPushResult
3248: oNodeGet
3249: oPop 2
3251: oAssign
3252: oGetAddrLocal 2
3254: oPushResult
3255: oGetParam 2
3257: oPushResult
3258: oSetResult 37
3260: oPushResult
3261: oNodeGet
3262: oPop 2
3264: oAssign
3265: oGetAddrLocal 3
3267: oPushResult
3268: oGetLocal 2
3270: oPushResult
3271: oCall 9994
3273: oPop 1
3275: oAssign
3276: oGetAddrLocal 4
3278: oPushResult
3279: oGetLocal 2
3281: oPushResult
3282: oCall 10089
3284: oPop 1
3286: oAssign
3287: oGetAddrLocal 5
3289: oPushResult
3290: oGetLocal 1
3292: oPushResult
3293: oSetResult 17
3295: oPushResult
3296: oNodeGetInt
3297: oPop 2
3299: oAssign
3300: oInput 14
3302: oGetAddrLocal 6
3304: oPushResult
3305: oGetLocal 3
3307: oAssign
3308: oGetLocal 1
3310: oPushResult
3311: oGetParam 1
3313: oPushResult
3314: oCall 3229
3316: oPop 2
3318: oGetLocal 6
3320: oPushResult
3321: oGetLocal 4
3323: oPushResult
3324: equal
3325: oPop 2
3327: oChoice 3335
3329: oJumpForward 3364
3331: oJumpForward 3341
3333: oJumpForward 3341
3335: Choice Lookup Table
           0   3333
           1   3329
3340: oEndChoice
3341: oInput 13
3343: oGetAddrParam 1
3345: oPushResult
3346: oGetParam 1
3348: oPushResult
3349: oGetLocal 5
3351: oPushResult
3352: add
3353: oPop 2
3355: oAssign
3356: oGetAddrLocal 6
3358: oPushResult
3359: inc
3360: oPop 1
3362: oJumpBack 3308
3364: oInput 15
3366: oJumpForward 3532
3368: oInput 14
3370: oGetAddrLocal 7
3372: oPushResult
3373: oGetParam 2
3375: oPushResult
3376: oSetResult 40
3378: oPushResult
3379: oNodeGet
3380: oPop 2
3382: oAssign
3383: oInputChoice 3387
3385: oJumpForward 3392
3387: Choice Lookup Table
           0   3385
3390: oJumpForward 3458
3392: oGetAddrLocal 8
3394: oPushResult
3395: oGetLocal 7
3397: oPushResult
3398: oScopeFindRequireInScope
3399: oPop 1
3401: oAssign
3402: oInput 12
3404: oGetAddrLocal 9
3406: oPushResult
3407: oGetLocal 8
3409: oPushResult
3410: oSetResult 21
3412: oPushResult
3413: oNodeGet
3414: oPop 2
3416: oAssign
3417: oGetAddrLocal 10
3419: oPushResult
3420: oGetParam 1
3422: oPushResult
3423: oGetLocal 8
3425: oPushResult
3426: oSetResult 22
3428: oPushResult
3429: oNodeGetInt
3430: oPop 2
3432: oPushResult
3433: add
3434: oPop 2
3436: oAssign
3437: oGetLocal 9
3439: oPushResult
3440: oGetLocal 10
3442: oPushResult
3443: oCall 3229
3445: oPop 2
3447: oInputChoice 3451
3449: oJumpForward 3456
3451: Choice Lookup Table
           5   3449
3454: oJumpForward 3458
3456: oJumpBack 3383
3458: oInput 15
3460: oJumpForward 3532
3462: oEmit 16
3464: oGetParam 1
3466: oPushResult
3467: oEmitInt
3468: oPop 1
3470: oCall 4941
3472: oEmit 15
3474: oValueTop
3475: oPushResult
3476: oEmitInt
3477: oPop 1
3479: oValuePop
3480: oEmit 26
3482: oJumpForward 3532
3484: oEmit 16
3486: oGetParam 1
3488: oPushResult
3489: oEmitInt
3490: oPop 1
3492: oCall 4941
3494: oEmit 15
3496: oValueTop
3497: oPushResult
3498: oEmitInt
3499: oPop 1
3501: oValuePop
3502: oEmit 25
3504: oJumpForward 3532
3506: oError 16
3508: oJumpForward 3532
3510: Choice Lookup Table
          34   3506
          27   3506
          33   3506
          38   3484
          28   3484
          32   3462
          29   3462
          30   3462
          37   3368
          35   3239
3531: oEndChoice
3532: oReturn
3533: oLocalSpace 2
3535: oInputChoice 3581
3537: oGetAddrLocal 1
3539: oPushResult
3540: oSetResult 18
3542: oPushResult
3543: LAST_ID
3544: oPushResult
3545: oCall 9882
3547: oPop 2
3549: oAssign
3550: oInput 6
3552: oGetAddrLocal 2
3554: oPushResult
3555: oCall 3885
3557: oPop 1
3559: oGetLocal 1
3561: oPushResult
3562: oSetResult 21
3564: oPushResult
3565: oGetLocal 2
3567: oPushResult
3568: oNodeSet
3569: oPop 3
3571: oGetLocal 1
3573: oPushResult
3574: oScopeDeclare
3575: oPop 1
3577: oInput 5
3579: oJumpForward 3586
3581: Choice Lookup Table
           0   3537
3584: oJumpForward 3588
3586: oJumpBack 3535
3588: oReturn
3589: oLocalSpace 6
3591: oInputChoice 3812
3593: oGetAddrLocal 1
3595: oPushResult
3596: oNodeVecNew
3597: oAssign
3598: oGetAddrLocal 2
3600: oPushResult
3601: oGetParam 1
3603: oPushResult
3604: LAST_ID
3605: oPushResult
3606: oCall 9882
3608: oPop 2
3610: oAssign
3611: oGetLocal 1
3613: oPushResult
3614: oGetLocal 2
3616: oPushResult
3617: oNodeVecAppend
3618: oPop 2
3620: oInputChoice 3626
3622: oInput 0
3624: oJumpForward 3631
3626: Choice Lookup Table
          13   3622
3629: oJumpForward 3633
3631: oJumpBack 3598
3633: oInput 12
3635: oGetAddrLocal 3
3637: oPushResult
3638: oCall 3885
3640: oPop 1
3642: oGetAddrLocal 4
3644: oPushResult
3645: oSetResult 0
3647: oAssign
3648: oGetLocal 4
3650: oPushResult
3651: oGetLocal 1
3653: oPushResult
3654: oNodeVecSize
3655: oPop 1
3657: oPushResult
3658: equal
3659: oPop 2
3661: oChoice 3702
3663: oGetAddrLocal 2
3665: oPushResult
3666: oGetLocal 1
3668: oPushResult
3669: oGetLocal 4
3671: oPushResult
3672: oNodeVecElement
3673: oPop 2
3675: oAssign
3676: oGetLocal 2
3678: oPushResult
3679: oSetResult 21
3681: oPushResult
3682: oGetLocal 3
3684: oPushResult
3685: oNodeSet
3686: oPop 3
3688: oGetLocal 2
3690: oPushResult
3691: oScopeDeclareAlloc
3692: oPop 1
3694: oGetAddrLocal 4
3696: oPushResult
3697: inc
3698: oPop 1
3700: oJumpForward 3707
3702: Choice Lookup Table
           0   3663
3705: oJumpForward 3709
3707: oJumpBack 3648
3709: oInputChoice 3799
3711: oGetLocal 1
3713: oPushResult
3714: oNodeVecSize
3715: oPop 1
3717: oChoice 3721
3719: oJumpForward 3726
3721: Choice Lookup Table
           1   3719
3724: oError 22
3726: oGetAddrLocal 5
3728: oPushResult
3729: oScopeCurrent
3730: oPushResult
3731: oCall 1835
3733: oPop 1
3735: oAssign
3736: oGetLocal 5
3738: oPushResult
3739: oCodePush
3740: oPop 1
3742: oGetAddrLocal 6
3744: oPushResult
3745: oSetResult 0
3747: oAssign
3748: oCall 9652
3750: oPushResult
3751: equal_zero
3752: oPop 1
3754: oChoice 3770
3756: oGetGlobal 3
3758: oPushResult
3759: oScopeEnter
3760: oPop 1
3762: oGetAddrLocal 6
3764: oPushResult
3765: oSetResult 1
3767: oAssign
3768: oJumpForward 3773
3770: Choice Lookup Table
           1   3756
3773: oGetLocal 2
3775: oPushResult
3776: oCall 8887
3778: oPop 1
3780: oCall 5014
3782: oCall 9702
3784: oCall 8652
3786: oGetLocal 6
3788: oChoice 3793
3790: oScopeEnd
3791: oJumpForward 3796
3793: Choice Lookup Table
           1   3790
3796: oCodePop
3797: oJumpForward 3802
3799: Choice Lookup Table
           6   3711
3802: oGetLocal 1
3804: oPushResult
3805: oNodeVecDelete
3806: oPop 1
3808: oInput 5
3810: oJumpForward 3817
3812: Choice Lookup Table
           0   3593
3815: oJumpForward 3819
3817: oJumpBack 3591
3819: oReturn
3820: oLocalSpace 2
3822: oInputChoice 3829
3824: oJumpForward 3835
3826: oChangeIntLitToLabelIdent
3827: oJumpForward 3835
3829: Choice Lookup Table
           1   3826
           0   3824
3834: oEndChoice
3835: oGetAddrLocal 1
3837: oPushResult
3838: oSetResult 25
3840: oPushResult
3841: LAST_ID
3842: oPushResult
3843: oCall 9882
3845: oPop 2
3847: oAssign
3848: oGetAddrLocal 2
3850: oPushResult
3851: oLabelNew
3852: oAssign
3853: oGetLocal 1
3855: oPushResult
3856: oSetResult 22
3858: oPushResult
3859: oGetLocal 2
3861: oPushResult
3862: oNodeSetLabel
3863: oPop 3
3865: oGetLocal 1
3867: oPushResult
3868: oScopeDeclare
3869: oPop 1
3871: oInputChoice 3875
3873: oJumpForward 3880
3875: Choice Lookup Table
          13   3873
3878: oJumpForward 3882
3880: oJumpBack 3822
3882: oInput 5
3884: oReturn
3885: oLocalSpace 12
3887: oInputChoice 4360
3889: oGetAddrLocal 1
3891: oPushResult
3892: oScopeFindRequire
3893: oAssign
3894: oGetAddrLocal 1
3896: oPushResult
3897: oCall 409
3899: oPop 1
3901: oGetLocal 1
3903: oPushResult
3904: oNodeType
3905: oPop 1
3907: oChoice 3924
3909: oGetParam 1
3911: oPushResult
3912: oGetLocal 1
3914: oPushResult
3915: oSetResult 21
3917: oPushResult
3918: oNodeGet
3919: oPop 2
3921: oAssign
3922: oJumpForward 3935
3924: Choice Lookup Table
          18   3909
3927: oError 2
3929: oGetParam 1
3931: oPushResult
3932: oGetGlobal 5
3934: oAssign
3935: oJumpForward 4379
3937: oInput 16
3939: oGetAddrLocal 2
3941: oPushResult
3942: oNodeVecNew
3943: oAssign
3944: oGetAddrLocal 3
3946: oPushResult
3947: oSetResult 36
3949: oPushResult
3950: oNodeNew
3951: oPop 1
3953: oAssign
3954: oGetLocal 3
3956: oPushResult
3957: oSetResult 36
3959: oPushResult
3960: oGetGlobal 5
3962: oPushResult
3963: oNodeSet
3964: oPop 3
3966: oCall 4941
3968: oGetLocal 3
3970: oPushResult
3971: oSetResult 38
3973: oPushResult
3974: oValueTop
3975: oPushResult
3976: oNodeSetInt
3977: oPop 3
3979: oValuePop
3980: oInput 21
3982: oCall 4941
3984: oGetLocal 3
3986: oPushResult
3987: oSetResult 39
3989: oPushResult
3990: oValueTop
3991: oPushResult
3992: oNodeSetInt
3993: oPop 3
3995: oValuePop
3996: oGetLocal 3
3998: oPushResult
3999: oSetResult 17
4001: oPushResult
4002: oSetResult 4
4004: oPushResult
4005: oNodeSetInt
4006: oPop 3
4008: oGetLocal 3
4010: oPushResult
4011: oTypeAdd
4012: oPop 1
4014: oGetAddrLocal 4
4016: oPushResult
4017: oSetResult 35
4019: oPushResult
4020: oNodeNew
4021: oPop 1
4023: oAssign
4024: oGetLocal 4
4026: oPushResult
4027: oSetResult 37
4029: oPushResult
4030: oGetLocal 3
4032: oPushResult
4033: oNodeSet
4034: oPop 3
4036: oGetLocal 2
4038: oPushResult
4039: oGetLocal 4
4041: oPushResult
4042: oNodeVecAppend
4043: oPop 2
4045: oInputChoice 4053
4047: oJumpForward 4061
4049: oJumpForward 4059
4051: oJumpForward 4059
4053: Choice Lookup Table
          13   4051
          17   4047
4058: oEndChoice
4059: oJumpBack 3944
4061: oInput 40
4063: oGetAddrLocal 5
4065: oPushResult
4066: oCall 3885
4068: oPop 1
4070: oGetAddrLocal 6
4072: oPushResult
4073: oGetLocal 2
4075: oPushResult
4076: oNodeVecSize
4077: oPop 1
4079: oAssign
4080: oGetAddrLocal 6
4082: oPushResult
4083: dec
4084: oPop 1
4086: oGetAddrLocal 7
4088: oPushResult
4089: oGetLocal 2
4091: oPushResult
4092: oGetLocal 6
4094: oPushResult
4095: oNodeVecElement
4096: oPop 2
4098: oAssign
4099: oGetLocal 7
4101: oPushResult
4102: oSetResult 36
4104: oPushResult
4105: oGetLocal 5
4107: oPushResult
4108: oNodeSet
4109: oPop 3
4111: oGetAddrLocal 8
4113: oPushResult
4114: oGetLocal 7
4116: oPushResult
4117: oSetResult 37
4119: oPushResult
4120: oNodeGet
4121: oPop 2
4123: oAssign
4124: oGetAddrLocal 9
4126: oPushResult
4127: oGetLocal 8
4129: oPushResult
4130: oSetResult 39
4132: oPushResult
4133: oNodeGetInt
4134: oPop 2
4136: oPushResult
4137: oGetLocal 8
4139: oPushResult
4140: oSetResult 38
4142: oPushResult
4143: oNodeGetInt
4144: oPop 2
4146: oPushResult
4147: subtract
4148: oPop 2
4150: oAssign
4151: oGetAddrLocal 9
4153: oPushResult
4154: inc
4155: oPop 1
4157: oGetLocal 7
4159: oPushResult
4160: oSetResult 17
4162: oPushResult
4163: oGetLocal 9
4165: oPushResult
4166: oGetLocal 5
4168: oPushResult
4169: oSetResult 17
4171: oPushResult
4172: oNodeGetInt
4173: oPop 2
4175: oPushResult
4176: multiply
4177: oPop 2
4179: oPushResult
4180: oNodeSetInt
4181: oPop 3
4183: oGetLocal 7
4185: oPushResult
4186: oTypeAdd
4187: oPop 1
4189: oGetAddrLocal 5
4191: oPushResult
4192: oGetLocal 7
4194: oAssign
4195: oGetLocal 6
4197: oPushResult
4198: equal_zero
4199: oPop 1
4201: oChoice 4207
4203: oJumpForward 4212
4205: oJumpForward 4210
4207: Choice Lookup Table
           1   4203
4210: oJumpBack 4080
4212: oGetParam 1
4214: oPushResult
4215: oGetLocal 2
4217: oPushResult
4218: oSetResult 0
4220: oPushResult
4221: oNodeVecElement
4222: oPop 2
4224: oAssign
4225: oGetLocal 2
4227: oPushResult
4228: oNodeVecDelete
4229: oPop 1
4231: oJumpForward 4379
4233: oGetAddrLocal 10
4235: oPushResult
4236: oCall 3885
4238: oPop 1
4240: oGetParam 1
4242: oPushResult
4243: oGetLocal 10
4245: oPushResult
4246: oCall 9910
4248: oPop 1
4250: oAssign
4251: oJumpForward 4379
4253: oGetParam 1
4255: oPushResult
4256: oSetResult 37
4258: oPushResult
4259: oNodeNew
4260: oPop 1
4262: oAssign
4263: oSetResult -1
4265: oPushResult
4266: oSetResult 2
4268: oPushResult
4269: oScopeBegin
4270: oPop 2
4272: oSetResult 22
4274: oPushResult
4275: oCall 3589
4277: oPop 1
4279: oGetAddrLocal 11
4281: oPushResult
4282: oScopeCurrent
4283: oPushResult
4284: oSetResult 17
4286: oPushResult
4287: oNodeGetInt
4288: oPop 2
4290: oAssign
4291: oGetLocal 11
4293: oPushResult
4294: equal_zero
4295: oPop 1
4297: oChoice 4303
4299: oError 19
4301: oJumpForward 4306
4303: Choice Lookup Table
           1   4299
4306: oInput 36
4308: oGetFromParam 1
4310: oPushResult
4311: oSetResult 40
4313: oPushResult
4314: oScopeCurrent
4315: oPushResult
4316: oNodeSet
4317: oPop 3
4319: oGetFromParam 1
4321: oPushResult
4322: oSetResult 17
4324: oPushResult
4325: oGetLocal 11
4327: oPushResult
4328: oNodeSetInt
4329: oPop 3
4331: oScopeEnd
4332: oGetFromParam 1
4334: oPushResult
4335: oTypeAdd
4336: oPop 1
4338: oJumpForward 4379
4340: oGetParam 1
4342: oPushResult
4343: oCall 4380
4345: oPop 1
4347: oJumpForward 4379
4349: oInput 40
4351: oGetAddrLocal 12
4353: oPushResult
4354: oCall 3885
4356: oPop 1
4358: oJumpForward 4379
4360: Choice Lookup Table
          39   4349
          14   4340
          38   4253
          18   4233
          37   3937
           0   3889
4373: oCall 4941
4375: oInput 21
4377: oCall 4941
4379: oReturn
4380: oLocalSpace 11
4382: oGetParam 1
4384: oPushResult
4385: oSetResult 38
4387: oPushResult
4388: oNodeNew
4389: oPop 1
4391: oAssign
4392: oGetAddrLocal 1
4394: oPushResult
4395: oSetResult 0
4397: oAssign
4398: oGetAddrLocal 2
4400: oPushResult
4401: oSetResult 0
4403: oAssign
4404: oGetAddrLocal 3
4406: oPushResult
4407: oSetResult 1
4409: oAssign
4410: oGetAddrLocal 4
4412: oPushResult
4413: oScopeCurrent
4414: oAssign
4415: oSetResult -1
4417: oPushResult
4418: oSetResult 2
4420: oPushResult
4421: oScopeBegin
4422: oPop 2
4424: oInput 0
4426: oGetAddrLocal 5
4428: oPushResult
4429: oSetResult 17
4431: oPushResult
4432: LAST_ID
4433: oPushResult
4434: oCall 9882
4436: oPop 2
4438: oAssign
4439: oGetAddrLocal 6
4441: oPushResult
4442: oSetResult 17
4444: oPushResult
4445: LAST_ID
4446: oPushResult
4447: oCall 9882
4449: oPop 2
4451: oAssign
4452: oGetLocal 5
4454: oPushResult
4455: oSetResult 21
4457: oPushResult
4458: oGetFromParam 1
4460: oPushResult
4461: oNodeSet
4462: oPop 3
4464: oGetLocal 6
4466: oPushResult
4467: oSetResult 21
4469: oPushResult
4470: oGetFromParam 1
4472: oPushResult
4473: oNodeSet
4474: oPop 3
4476: oGetAddrLocal 7
4478: oPushResult
4479: LAST_ID
4480: oPushResult
4481: ID_STRING
4482: oPop 1
4484: oPushResult
4485: oStringAllocLit
4486: oPop 1
4488: oAssign
4489: oGetLocal 5
4491: oPushResult
4492: oSetResult 32
4494: oPushResult
4495: oGetLocal 7
4497: oPushResult
4498: oNodeSetInt
4499: oPop 3
4501: oGetLocal 6
4503: oPushResult
4504: oSetResult 32
4506: oPushResult
4507: oGetLocal 7
4509: oPushResult
4510: oNodeSetInt
4511: oPop 3
4513: oInputChoice 4582
4515: oCall 4941
4517: oGetLocal 2
4519: oPushResult
4520: equal_zero
4521: oPop 1
4523: oChoice 4544
4525: oValueTop
4526: oPushResult
4527: oGetLocal 1
4529: oPushResult
4530: greater
4531: oPop 2
4533: oChoice 4539
4535: oError 26
4537: oJumpForward 4542
4539: Choice Lookup Table
           0   4535
4542: oJumpForward 4547
4544: Choice Lookup Table
           0   4525
4547: oGetLocal 1
4549: oPushResult
4550: oValueTop
4551: oPushResult
4552: equal
4553: oPop 2
4555: oChoice 4571
4557: oGetFromParam 1
4559: oPushResult
4560: oSetResult 42
4562: oPushResult
4563: oSetResult 1
4565: oPushResult
4566: oNodeSetBoolean
4567: oPop 3
4569: oJumpForward 4574
4571: Choice Lookup Table
           0   4557
4574: oGetAddrLocal 1
4576: oPushResult
4577: oValueTop
4578: oAssign
4579: oValuePop
4580: oJumpForward 4587
4582: Choice Lookup Table
           4   4515
           6   4515
4587: oGetLocal 5
4589: oPushResult
4590: oSetResult 22
4592: oPushResult
4593: oGetLocal 1
4595: oPushResult
4596: oNodeSetInt
4597: oPop 3
4599: oGetLocal 6
4601: oPushResult
4602: oSetResult 22
4604: oPushResult
4605: oGetLocal 1
4607: oPushResult
4608: oNodeSetInt
4609: oPop 3
4611: oGetLocal 5
4613: oPushResult
4614: oScopeDeclare
4615: oPop 1
4617: oGetLocal 4
4619: oPushResult
4620: oScopeEnter
4621: oPop 1
4623: oGetLocal 6
4625: oPushResult
4626: oScopeDeclare
4627: oPop 1
4629: oScopeEnd
4630: oGetAddrLocal 1
4632: oPushResult
4633: inc
4634: oPop 1
4636: oGetAddrLocal 2
4638: oPushResult
4639: inc
4640: oPop 1
4642: oInputChoice 4646
4644: oJumpForward 4651
4646: Choice Lookup Table
          13   4644
4649: oJumpForward 4653
4651: oJumpBack 4424
4653: oInput 15
4655: oGetFromParam 1
4657: oPushResult
4658: oSetResult 40
4660: oPushResult
4661: oScopeCurrent
4662: oPushResult
4663: oNodeSet
4664: oPop 3
4666: oGetFromParam 1
4668: oPushResult
4669: oSetResult 17
4671: oPushResult
4672: oSetResult 4
4674: oPushResult
4675: oNodeSetInt
4676: oPop 3
4678: oScopeEnd
4679: oGetGlobal 2
4681: oPushResult
4682: oCall 1835
4684: oPop 1
4686: oPushResult
4687: oCodePush
4688: oPop 1
4690: oGetGlobal 2
4692: oPushResult
4693: oScopeEnter
4694: oPop 1
4696: oGetAddrLocal 8
4698: oPushResult
4699: oGetLocal 2
4701: oPushResult
4702: oSetResult 1
4704: oPushResult
4705: add
4706: oPop 2
4708: oPushResult
4709: oSetResult 16
4711: oPushResult
4712: multiply
4713: oPop 2
4715: oAssign
4716: oGetAddrLocal 9
4718: oPushResult
4719: oGetLocal 8
4721: oPushResult
4722: oSetResult 8
4724: oPushResult
4725: oScopeAlloc
4726: oPop 2
4728: oAssign
4729: oScopeEnd
4730: oGetFromParam 1
4732: oPushResult
4733: oSetResult 41
4735: oPushResult
4736: oGetLocal 9
4738: oPushResult
4739: oNodeSetInt
4740: oPop 3
4742: oGetAddrLocal 10
4744: oPushResult
4745: oGetFromParam 1
4747: oPushResult
4748: oSetResult 40
4750: oPushResult
4751: oNodeGet
4752: oPop 2
4754: oPushResult
4755: oSetResult 15
4757: oPushResult
4758: oNodeGetIter
4759: oPop 2
4761: oAssign
4762: oGetAddrLocal 11
4764: oPushResult
4765: oGetLocal 10
4767: oPushResult
4768: oNodeIterValue
4769: oPop 1
4771: oAssign
4772: oGetLocal 11
4774: oPushResult
4775: oNodeNull
4776: oPop 1
4778: oChoice 4784
4780: oJumpForward 4871
4782: oJumpForward 4787
4784: Choice Lookup Table
           1   4780
4787: oEmit 16
4789: oGetLocal 9
4791: oPushResult
4792: oEmitInt
4793: oPop 1
4795: oEmit 15
4797: oGetLocal 11
4799: oPushResult
4800: oSetResult 22
4802: oPushResult
4803: oNodeGetInt
4804: oPop 2
4806: oPushResult
4807: oEmitInt
4808: oPop 1
4810: oEmit 25
4812: oGetAddrLocal 9
4814: oPushResult
4815: oGetLocal 9
4817: oPushResult
4818: oSetResult 8
4820: oPushResult
4821: add
4822: oPop 2
4824: oAssign
4825: oEmit 16
4827: oGetLocal 9
4829: oPushResult
4830: oEmitInt
4831: oPop 1
4833: oEmit 16
4835: oGetLocal 11
4837: oPushResult
4838: oSetResult 32
4840: oPushResult
4841: oNodeGetInt
4842: oPop 2
4844: oPushResult
4845: oEmitInt
4846: oPop 1
4848: oEmit 27
4850: oGetAddrLocal 9
4852: oPushResult
4853: oGetLocal 9
4855: oPushResult
4856: oSetResult 8
4858: oPushResult
4859: add
4860: oPop 2
4862: oAssign
4863: oGetAddrLocal 10
4865: oPushResult
4866: oNodeIterNext
4867: oPop 1
4869: oJumpBack 4762
4871: oEmit 16
4873: oGetLocal 9
4875: oPushResult
4876: oEmitInt
4877: oPop 1
4879: oEmit 15
4881: oSetResult 0
4883: oPushResult
4884: oEmitInt
4885: oPop 1
4887: oEmit 25
4889: oGetAddrLocal 9
4891: oPushResult
4892: oGetLocal 9
4894: oPushResult
4895: oSetResult 8
4897: oPushResult
4898: add
4899: oPop 2
4901: oAssign
4902: oEmit 16
4904: oGetLocal 9
4906: oPushResult
4907: oEmitInt
4908: oPop 1
4910: oEmit 15
4912: oSetResult 0
4914: oPushResult
4915: oEmitInt
4916: oPop 1
4918: oEmit 27
4920: oGetAddrLocal 9
4922: oPushResult
4923: oGetLocal 9
4925: oPushResult
4926: oSetResult 8
4928: oPushResult
4929: add
4930: oPop 2
4932: oAssign
4933: oCodePop
4934: oGetFromParam 1
4936: oPushResult
4937: oTypeAdd
4938: oPop 1
4940: oReturn
4941: oLocalSpace 1
4943: oInputChoice 5005
4945: TOKEN_VALUE
4946: oPushResult
4947: oValuePush
4948: oPop 1
4950: oJumpForward 5013
4952: oGetAddrLocal 1
4954: oPushResult
4955: oScopeFindRequire
4956: oAssign
4957: oGetAddrLocal 1
4959: oPushResult
4960: oCall 409
4962: oPop 1
4964: oGetLocal 1
4966: oPushResult
4967: oNodeType
4968: oPop 1
4970: oChoice 4987
4972: oGetLocal 1
4974: oPushResult
4975: oSetResult 22
4977: oPushResult
4978: oNodeGetInt
4979: oPop 2
4981: oPushResult
4982: oValuePush
4983: oPop 1
4985: oJumpForward 4998
4987: Choice Lookup Table
          16   4972
4990: oError 1
4992: oSetResult 0
4994: oPushResult
4995: oValuePush
4996: oPop 1
4998: oJumpForward 5013
5000: oCall 4941
5002: oValueNegate
5003: oJumpForward 5013
5005: Choice Lookup Table
          25   5000
           0   4952
           1   4945
5012: oEndChoice
5013: oReturn
5014: oLocalSpace 1
5016: oGetAddrLocal 1
5018: oPushResult
5019: oSetResult 0
5021: oAssign
5022: oGetAddrLocal 1
5024: oPushResult
5025: oCall 5175
5027: oPop 1
5029: oGetAddrLocal 1
5031: oPushResult
5032: oCall 5075
5034: oPop 1
5036: oReturn
5037: oLocalSpace 0
5039: oGetParam 1
5041: oPushResult
5042: oCall 5175
5044: oPop 1
5046: oTypeSNodeType
5047: oChoice 5066
5049: oJumpForward 5073
5051: oGetParam 1
5053: oPushResult
5054: oLabelNew
5055: oAssign
5056: oEmit 57
5058: oGetFromParam 1
5060: oPushResult
5061: oEmitLabel
5062: oPop 1
5064: oJumpForward 5073
5066: Choice Lookup Table
          30   5051
          31   5049
5071: oError 8
5073: oTypeSPop
5074: oReturn
5075: oLocalSpace 1
5077: oTypeSNodeType
5078: oChoice 5140
5080: oGetAddrLocal 1
5082: oPushResult
5083: oLabelNew
5084: oAssign
5085: oEmit 15
5087: oSetResult 1
5089: oPushResult
5090: oEmitInt
5091: oPop 1
5093: oEmit 55
5095: oGetLocal 1
5097: oPushResult
5098: oEmitLabel
5099: oPop 1
5101: oEmit 58
5103: oGetFromParam 1
5105: oPushResult
5106: oEmitLabel
5107: oPop 1
5109: oEmit 15
5111: oSetResult 0
5113: oPushResult
5114: oEmitInt
5115: oPop 1
5117: oEmit 58
5119: oGetLocal 1
5121: oPushResult
5122: oEmitLabel
5123: oPop 1
5125: oTypeSPop
5126: oGetGlobal 6
5128: oPushResult
5129: oTypeSPush
5130: oPop 1
5132: oGetParam 1
5134: oPushResult
5135: oSetResult 0
5137: oAssign
5138: oJumpForward 5143
5140: Choice Lookup Table
          31   5080
5143: oReturn
5144: oLocalSpace 0
5146: oTypeSNodeType
5147: oChoice 5171
5149: oGetParam 1
5151: oPushResult
5152: oLabelNew
5153: oAssign
5154: oEmit 57
5156: oGetFromParam 1
5158: oPushResult
5159: oEmitLabel
5160: oPop 1
5162: oTypeSPop
5163: oGetGlobal 7
5165: oPushResult
5166: oTypeSPush
5167: oPop 1
5169: oJumpForward 5174
5171: Choice Lookup Table
          30   5149
5174: oReturn
5175: oLocalSpace 0
5177: oGetParam 1
5179: oPushResult
5180: oCall 5576
5182: oPop 1
5184: oInputChoice 5558
5186: oGetParam 1
5188: oPushResult
5189: oCall 5075
5191: oPop 1
5193: oCall 9801
5195: oGetParam 1
5197: oPushResult
5198: oCall 5576
5200: oPop 1
5202: oGetParam 1
5204: oPushResult
5205: oCall 5075
5207: oPop 1
5209: oCall 9801
5211: oCall 9702
5213: oTypeSNodeType
5214: oChoice 5228
5216: oEmit 40
5218: oJumpForward 5243
5220: oEmit 46
5222: oJumpForward 5243
5224: oError 16
5226: oJumpForward 5243
5228: Choice Lookup Table
          33   5224
          32   5224
          34   5220
          30   5216
          38   5216
          28   5216
5241: oError 17
5243: oTypeSPop
5244: oGetGlobal 6
5246: oPushResult
5247: oTypeSPush
5248: oPop 1
5250: oJumpForward 5573
5252: oGetParam 1
5254: oPushResult
5255: oCall 5075
5257: oPop 1
5259: oCall 9801
5261: oGetParam 1
5263: oPushResult
5264: oCall 5576
5266: oPop 1
5268: oGetParam 1
5270: oPushResult
5271: oCall 5075
5273: oPop 1
5275: oCall 9801
5277: oCall 9702
5279: oTypeSNodeType
5280: oChoice 5294
5282: oEmit 41
5284: oJumpForward 5309
5286: oEmit 47
5288: oJumpForward 5309
5290: oError 16
5292: oJumpForward 5309
5294: Choice Lookup Table
          33   5290
          32   5290
          34   5286
          30   5282
          38   5282
          28   5282
5307: oError 17
5309: oTypeSPop
5310: oGetGlobal 6
5312: oPushResult
5313: oTypeSPush
5314: oPop 1
5316: oJumpForward 5573
5318: oGetParam 1
5320: oPushResult
5321: oCall 5075
5323: oPop 1
5325: oCall 9801
5327: oGetParam 1
5329: oPushResult
5330: oCall 5576
5332: oPop 1
5334: oGetParam 1
5336: oPushResult
5337: oCall 5075
5339: oPop 1
5341: oCall 9801
5343: oCall 9702
5345: oTypeSNodeType
5346: oChoice 5356
5348: oEmit 43
5350: oJumpForward 5369
5352: oError 16
5354: oJumpForward 5369
5356: Choice Lookup Table
          33   5352
          32   5352
          30   5348
          38   5348
          28   5348
5367: oError 17
5369: oTypeSPop
5370: oGetGlobal 6
5372: oPushResult
5373: oTypeSPush
5374: oPop 1
5376: oJumpForward 5573
5378: oGetParam 1
5380: oPushResult
5381: oCall 5075
5383: oPop 1
5385: oCall 9801
5387: oGetParam 1
5389: oPushResult
5390: oCall 5576
5392: oPop 1
5394: oGetParam 1
5396: oPushResult
5397: oCall 5075
5399: oPop 1
5401: oCall 9801
5403: oCall 9702
5405: oTypeSNodeType
5406: oChoice 5416
5408: oEmit 42
5410: oJumpForward 5429
5412: oError 16
5414: oJumpForward 5429
5416: Choice Lookup Table
          33   5412
          32   5412
          30   5408
          38   5408
          28   5408
5427: oError 17
5429: oTypeSPop
5430: oGetGlobal 6
5432: oPushResult
5433: oTypeSPush
5434: oPop 1
5436: oJumpForward 5573
5438: oGetParam 1
5440: oPushResult
5441: oCall 5075
5443: oPop 1
5445: oCall 9801
5447: oGetParam 1
5449: oPushResult
5450: oCall 5576
5452: oPop 1
5454: oGetParam 1
5456: oPushResult
5457: oCall 5075
5459: oPop 1
5461: oCall 9801
5463: oCall 9702
5465: oTypeSNodeType
5466: oChoice 5476
5468: oEmit 45
5470: oJumpForward 5489
5472: oError 16
5474: oJumpForward 5489
5476: Choice Lookup Table
          33   5472
          32   5472
          30   5468
          38   5468
          28   5468
5487: oError 17
5489: oTypeSPop
5490: oGetGlobal 6
5492: oPushResult
5493: oTypeSPush
5494: oPop 1
5496: oJumpForward 5573
5498: oGetParam 1
5500: oPushResult
5501: oCall 5075
5503: oPop 1
5505: oCall 9801
5507: oGetParam 1
5509: oPushResult
5510: oCall 5576
5512: oPop 1
5514: oGetParam 1
5516: oPushResult
5517: oCall 5075
5519: oPop 1
5521: oCall 9801
5523: oCall 9702
5525: oTypeSNodeType
5526: oChoice 5536
5528: oEmit 44
5530: oJumpForward 5549
5532: oError 16
5534: oJumpForward 5549
5536: Choice Lookup Table
          33   5532
          32   5532
          30   5528
          38   5528
          28   5528
5547: oError 17
5549: oTypeSPop
5550: oGetGlobal 6
5552: oPushResult
5553: oTypeSPush
5554: oPop 1
5556: oJumpForward 5573
5558: Choice Lookup Table
          11   5498
          10   5438
           9   5378
           8   5318
           7   5252
           6   5186
5571: oJumpForward 5575
5573: oJumpBack 5184
5575: oReturn
5576: oLocalSpace 1
5578: oGetAddrLocal 1
5580: oPushResult
5581: oSetResult 0
5583: oAssign
5584: oGetParam 1
5586: oPushResult
5587: oCall 5756
5589: oPop 1
5591: oInputChoice 5724
5593: oTypeSNodeType
5594: oChoice 5665
5596: oGetLocal 1
5598: oPushResult
5599: oSetResult 0
5601: oPushResult
5602: equal_label
5603: oPop 2
5605: oChoice 5614
5607: oGetAddrLocal 1
5609: oPushResult
5610: oLabelNew
5611: oAssign
5612: oJumpForward 5617
5614: Choice Lookup Table
           1   5607
5617: oEmit 55
5619: oGetLocal 1
5621: oPushResult
5622: oEmitLabel
5623: oPop 1
5625: oJumpForward 5672
5627: oGetParam 1
5629: oPushResult
5630: oCall 5144
5632: oPop 1
5634: oGetLocal 1
5636: oPushResult
5637: oSetResult 0
5639: oPushResult
5640: equal_label
5641: oPop 2
5643: oChoice 5652
5645: oGetAddrLocal 1
5647: oPushResult
5648: oLabelNew
5649: oAssign
5650: oJumpForward 5655
5652: Choice Lookup Table
           1   5645
5655: oEmit 55
5657: oGetLocal 1
5659: oPushResult
5660: oEmitLabel
5661: oPop 1
5663: oJumpForward 5672
5665: Choice Lookup Table
          30   5627
          31   5596
5670: oError 8
5672: oTypeSPop
5673: oEmit 58
5675: oGetFromParam 1
5677: oPushResult
5678: oEmitLabel
5679: oPop 1
5681: oGetParam 1
5683: oPushResult
5684: oSetResult 0
5686: oAssign
5687: oGetParam 1
5689: oPushResult
5690: oCall 5756
5692: oPop 1
5694: oTypeSNodeType
5695: oChoice 5708
5697: oJumpForward 5715
5699: oGetParam 1
5701: oPushResult
5702: oCall 5144
5704: oPop 1
5706: oJumpForward 5715
5708: Choice Lookup Table
          30   5699
          31   5697
5713: oError 8
5715: oTypeSPop
5716: oGetGlobal 7
5718: oPushResult
5719: oTypeSPush
5720: oPop 1
5722: oJumpForward 5729
5724: Choice Lookup Table
          55   5593
5727: oJumpForward 5731
5729: oJumpBack 5591
5731: oGetLocal 1
5733: oPushResult
5734: oSetResult 0
5736: oPushResult
5737: equal_label
5738: oPop 2
5740: oChoice 5752
5742: oEmit 58
5744: oGetLocal 1
5746: oPushResult
5747: oEmitLabel
5748: oPop 1
5750: oJumpForward 5755
5752: Choice Lookup Table
           0   5742
5755: oReturn
5756: oLocalSpace 2
5758: oGetAddrLocal 1
5760: oPushResult
5761: oSetResult 0
5763: oAssign
5764: oGetParam 1
5766: oPushResult
5767: oCall 5894
5769: oPop 1
5771: oInputChoice 5886
5773: oTypeSNodeType
5774: oChoice 5787
5776: oJumpForward 5794
5778: oGetParam 1
5780: oPushResult
5781: oCall 5144
5783: oPop 1
5785: oJumpForward 5794
5787: Choice Lookup Table
          30   5778
          31   5776
5792: oError 8
5794: oTypeSPop
5795: oGetLocal 1
5797: oPushResult
5798: oSetResult 0
5800: oPushResult
5801: equal_label
5802: oPop 2
5804: oChoice 5833
5806: oGetAddrLocal 1
5808: oPushResult
5809: oLabelNew
5810: oAssign
5811: oEmit 59
5813: oGetFromParam 1
5815: oPushResult
5816: oEmitLabel
5817: oPop 1
5819: oGetLocal 1
5821: oPushResult
5822: oEmitLabel
5823: oPop 1
5825: oGetParam 1
5827: oPushResult
5828: oGetLocal 1
5830: oAssign
5831: oJumpForward 5836
5833: Choice Lookup Table
           1   5806
5836: oGetAddrLocal 2
5838: oPushResult
5839: oSetResult 0
5841: oAssign
5842: oGetAddrLocal 2
5844: oPushResult
5845: oCall 5894
5847: oPop 1
5849: oTypeSNodeType
5850: oChoice 5863
5852: oJumpForward 5870
5854: oGetAddrLocal 2
5856: oPushResult
5857: oCall 5144
5859: oPop 1
5861: oJumpForward 5870
5863: Choice Lookup Table
          30   5854
          31   5852
5868: oError 8
5870: oEmit 59
5872: oGetLocal 2
5874: oPushResult
5875: oEmitLabel
5876: oPop 1
5878: oGetLocal 1
5880: oPushResult
5881: oEmitLabel
5882: oPop 1
5884: oJumpForward 5891
5886: Choice Lookup Table
          54   5773
5889: oJumpForward 5893
5891: oJumpBack 5771
5893: oReturn
5894: oLocalSpace 1
5896: oInputChoice 5950
5898: oGetAddrLocal 1
5900: oPushResult
5901: oSetResult 0
5903: oAssign
5904: oGetAddrLocal 1
5906: oPushResult
5907: oCall 5894
5909: oPop 1
5911: oTypeSNodeType
5912: oChoice 5941
5914: oGetParam 1
5916: oPushResult
5917: oLabelNew
5918: oAssign
5919: oEmit 55
5921: oGetFromParam 1
5923: oPushResult
5924: oEmitLabel
5925: oPop 1
5927: oEmit 58
5929: oGetLocal 1
5931: oPushResult
5932: oEmitLabel
5933: oPop 1
5935: oJumpForward 5948
5937: oEmit 39
5939: oJumpForward 5948
5941: Choice Lookup Table
          30   5937
          31   5914
5946: oError 8
5948: oJumpForward 5960
5950: Choice Lookup Table
          56   5898
5953: oGetParam 1
5955: oPushResult
5956: oCall 5961
5958: oPop 1
5960: oReturn
5961: oLocalSpace 0
5963: oGetParam 1
5965: oPushResult
5966: oCall 6012
5968: oPop 1
5970: oInputChoice 6002
5972: oCall 9755
5974: oGetParam 1
5976: oPushResult
5977: oCall 6012
5979: oPop 1
5981: oCall 9775
5983: oEmit 36
5985: oJumpForward 6009
5987: oCall 9755
5989: oGetParam 1
5991: oPushResult
5992: oCall 6012
5994: oPop 1
5996: oCall 9775
5998: oEmit 37
6000: oJumpForward 6009
6002: Choice Lookup Table
          25   5987
          24   5972
6007: oJumpForward 6011
6009: oJumpBack 5970
6011: oReturn
6012: oLocalSpace 0
6014: oGetParam 1
6016: oPushResult
6017: oCall 6063
6019: oPop 1
6021: oInputChoice 6053
6023: oCall 9755
6025: oGetParam 1
6027: oPushResult
6028: oCall 6063
6030: oPop 1
6032: oCall 9775
6034: oEmit 33
6036: oJumpForward 6060
6038: oCall 9755
6040: oGetParam 1
6042: oPushResult
6043: oCall 6063
6045: oPop 1
6047: oCall 9775
6049: oEmit 34
6051: oJumpForward 6060
6053: Choice Lookup Table
          23   6038
          22   6023
6058: oJumpForward 6062
6060: oJumpBack 6021
6062: oReturn
6063: oLocalSpace 0
6065: oInputChoice 6091
6067: oGetParam 1
6069: oPushResult
6070: oCall 6104
6072: oPop 1
6074: oCall 9775
6076: oJumpForward 6103
6078: oGetParam 1
6080: oPushResult
6081: oCall 6104
6083: oPop 1
6085: oCall 9775
6087: oEmit 38
6089: oJumpForward 6103
6091: Choice Lookup Table
          25   6078
          24   6067
6096: oGetParam 1
6098: oPushResult
6099: oCall 6104
6101: oPop 1
6103: oReturn
6104: oLocalSpace 6
6106: oInputChoice 6338
6108: oEmit 15
6110: TOKEN_VALUE
6111: oPushResult
6112: oEmitInt
6113: oPop 1
6115: oGetGlobal 5
6117: oPushResult
6118: oTypeSPush
6119: oPop 1
6121: oJumpForward 6359
6123: oEmit 15
6125: TOKEN_VALUE
6126: oPushResult
6127: oEmitInt
6128: oPop 1
6130: oGetGlobal 8
6132: oPushResult
6133: oTypeSPush
6134: oPop 1
6136: oJumpForward 6359
6138: oGetParam 1
6140: oPushResult
6141: oCall 5175
6143: oPop 1
6145: oInput 15
6147: oJumpForward 6359
6149: oGetAddrLocal 1
6151: oPushResult
6152: CURRENT_STRLIT
6153: oPushResult
6154: oStringAllocLit
6155: oPop 1
6157: oAssign
6158: oEmit 16
6160: oGetLocal 1
6162: oPushResult
6163: oEmitInt
6164: oPop 1
6166: oGetGlobal 10
6168: oPushResult
6169: oTypeSPush
6170: oPop 1
6172: oJumpForward 6359
6174: oGetAddrLocal 2
6176: oPushResult
6177: oScopeFindRequire
6178: oAssign
6179: oGetAddrLocal 2
6181: oPushResult
6182: oCall 409
6184: oPop 1
6186: oGetLocal 2
6188: oPushResult
6189: oNodeType
6190: oPop 1
6192: oChoice 6265
6194: oGetLocal 2
6196: oPushResult
6197: oCall 7599
6199: oPop 1
6201: oJumpForward 6290
6203: oGetLocal 2
6205: oPushResult
6206: oCall 8210
6208: oPop 1
6210: oJumpForward 6290
6212: oGetAddrLocal 3
6214: oPushResult
6215: oGetLocal 2
6217: oPushResult
6218: oSetResult 21
6220: oPushResult
6221: oNodeGet
6222: oPop 2
6224: oAssign
6225: oGetLocal 3
6227: oPushResult
6228: oTypeSPush
6229: oPop 1
6231: oTypeSNodeType
6232: oChoice 6245
6234: oEmit 15
6236: oGetLocal 2
6238: oPushResult
6239: oCall 10184
6241: oPop 1
6243: oJumpForward 6254
6245: Choice Lookup Table
          30   6234
          38   6234
          28   6234
6252: oError 16
6254: oJumpForward 6290
6256: oGetLocal 2
6258: oPushResult
6259: oCall 6360
6261: oPop 1
6263: oJumpForward 6290
6265: Choice Lookup Table
          24   6256
          23   6256
          21   6256
          20   6256
          17   6212
          16   6212
          14   6203
          13   6194
6282: oError 6
6284: oGetGlobal 5
6286: oPushResult
6287: oTypeSPush
6288: oPop 1
6290: oJumpForward 6359
6292: oInput 0
6294: oGetAddrLocal 4
6296: oPushResult
6297: oScopeFindRequire
6298: oAssign
6299: oGetAddrLocal 4
6301: oPushResult
6302: oCall 409
6304: oPop 1
6306: oGetLocal 4
6308: oPushResult
6309: oCall 8887
6311: oPop 1
6313: oGetAddrLocal 5
6315: oPushResult
6316: oTypeSTop
6317: oAssign
6318: oTypeSPop
6319: oGetAddrLocal 6
6321: oPushResult
6322: oGetLocal 5
6324: oPushResult
6325: oCall 9910
6327: oPop 1
6329: oAssign
6330: oGetLocal 6
6332: oPushResult
6333: oTypeSPush
6334: oPop 1
6336: oJumpForward 6359
6338: Choice Lookup Table
          19   6292
           0   6174
           2   6149
          14   6138
           3   6123
           1   6108
6351: oError 6
6353: oGetGlobal 5
6355: oPushResult
6356: oTypeSPush
6357: oPop 1
6359: oReturn
6360: oLocalSpace 2
6362: oGetAddrLocal 1
6364: oPushResult
6365: oGetParam 1
6367: oPushResult
6368: oSetResult 21
6370: oPushResult
6371: oNodeGet
6372: oPop 2
6374: oAssign
6375: oGetAddrLocal 2
6377: oPushResult
6378: oGetParam 1
6380: oPushResult
6381: oCall 9684
6383: oPop 1
6385: oAssign
6386: oGetLocal 1
6388: oPushResult
6389: oTypeSPush
6390: oPop 1
6392: oTypeSNodeType
6393: oChoice 7082
6395: oGetParam 1
6397: oPushResult
6398: oNodeType
6399: oPop 1
6401: oChoice 6547
6403: oEmit 0
6405: oGetParam 1
6407: oPushResult
6408: oCall 10184
6410: oPop 1
6412: oJumpForward 6557
6414: oGetLocal 2
6416: oPushResult
6417: equal_zero
6418: oPop 1
6420: oChoice 6433
6422: oEmit 3
6424: oGetParam 1
6426: oPushResult
6427: oCall 10184
6429: oPop 1
6431: oJumpForward 6451
6433: Choice Lookup Table
           1   6422
6436: oEmit 9
6438: oGetLocal 2
6440: oPushResult
6441: oEmitInt
6442: oPop 1
6444: oGetParam 1
6446: oPushResult
6447: oCall 10184
6449: oPop 1
6451: oJumpForward 6557
6453: oGetParam 1
6455: oPushResult
6456: oSetResult 33
6458: oPushResult
6459: oNodeGetBoolean
6460: oPop 2
6462: oChoice 6505
6464: oGetLocal 2
6466: oPushResult
6467: equal_zero
6468: oPop 1
6470: oChoice 6483
6472: oEmit 8
6474: oGetParam 1
6476: oPushResult
6477: oCall 10184
6479: oPop 1
6481: oJumpForward 6501
6483: Choice Lookup Table
           1   6472
6486: oEmit 14
6488: oGetLocal 2
6490: oPushResult
6491: oEmitInt
6492: oPop 1
6494: oGetParam 1
6496: oPushResult
6497: oCall 10184
6499: oPop 1
6501: oEmit 22
6503: oJumpForward 6545
6505: Choice Lookup Table
           1   6464
6508: oGetLocal 2
6510: oPushResult
6511: equal_zero
6512: oPop 1
6514: oChoice 6527
6516: oEmit 6
6518: oGetParam 1
6520: oPushResult
6521: oCall 10184
6523: oPop 1
6525: oJumpForward 6545
6527: Choice Lookup Table
           1   6516
6530: oEmit 12
6532: oGetLocal 2
6534: oPushResult
6535: oEmitInt
6536: oPop 1
6538: oGetParam 1
6540: oPushResult
6541: oCall 10184
6543: oPop 1
6545: oJumpForward 6557
6547: Choice Lookup Table
          23   6453
          21   6414
          24   6403
          20   6403
6556: oEndChoice
6557: oJumpForward 7104
6559: oGetParam 1
6561: oPushResult
6562: oNodeType
6563: oPop 1
6565: oChoice 6711
6567: oEmit 1
6569: oGetParam 1
6571: oPushResult
6572: oCall 10184
6574: oPop 1
6576: oJumpForward 6721
6578: oGetLocal 2
6580: oPushResult
6581: equal_zero
6582: oPop 1
6584: oChoice 6597
6586: oEmit 4
6588: oGetParam 1
6590: oPushResult
6591: oCall 10184
6593: oPop 1
6595: oJumpForward 6615
6597: Choice Lookup Table
           1   6586
6600: oEmit 10
6602: oGetLocal 2
6604: oPushResult
6605: oEmitInt
6606: oPop 1
6608: oGetParam 1
6610: oPushResult
6611: oCall 10184
6613: oPop 1
6615: oJumpForward 6721
6617: oGetParam 1
6619: oPushResult
6620: oSetResult 33
6622: oPushResult
6623: oNodeGetBoolean
6624: oPop 2
6626: oChoice 6669
6628: oGetLocal 2
6630: oPushResult
6631: equal_zero
6632: oPop 1
6634: oChoice 6647
6636: oEmit 8
6638: oGetParam 1
6640: oPushResult
6641: oCall 10184
6643: oPop 1
6645: oJumpForward 6665
6647: Choice Lookup Table
           1   6636
6650: oEmit 14
6652: oGetLocal 2
6654: oPushResult
6655: oEmitInt
6656: oPop 1
6658: oGetParam 1
6660: oPushResult
6661: oCall 10184
6663: oPop 1
6665: oEmit 23
6667: oJumpForward 6709
6669: Choice Lookup Table
           1   6628
6672: oGetLocal 2
6674: oPushResult
6675: equal_zero
6676: oPop 1
6678: oChoice 6691
6680: oEmit 7
6682: oGetParam 1
6684: oPushResult
6685: oCall 10184
6687: oPop 1
6689: oJumpForward 6709
6691: Choice Lookup Table
           1   6680
6694: oEmit 13
6696: oGetLocal 2
6698: oPushResult
6699: oEmitInt
6700: oPop 1
6702: oGetParam 1
6704: oPushResult
6705: oCall 10184
6707: oPop 1
6709: oJumpForward 6721
6711: Choice Lookup Table
          23   6617
          21   6578
          24   6567
          20   6567
6720: oEndChoice
6721: oJumpForward 7104
6723: oError 16
6725: oJumpForward 7104
6727: oGetParam 1
6729: oPushResult
6730: oNodeType
6731: oPop 1
6733: oChoice 6879
6735: oEmit 2
6737: oGetParam 1
6739: oPushResult
6740: oCall 10184
6742: oPop 1
6744: oJumpForward 6889
6746: oGetLocal 2
6748: oPushResult
6749: equal_zero
6750: oPop 1
6752: oChoice 6765
6754: oEmit 5
6756: oGetParam 1
6758: oPushResult
6759: oCall 10184
6761: oPop 1
6763: oJumpForward 6783
6765: Choice Lookup Table
           1   6754
6768: oEmit 11
6770: oGetLocal 2
6772: oPushResult
6773: oEmitInt
6774: oPop 1
6776: oGetParam 1
6778: oPushResult
6779: oCall 10184
6781: oPop 1
6783: oJumpForward 6889
6785: oGetParam 1
6787: oPushResult
6788: oSetResult 33
6790: oPushResult
6791: oNodeGetBoolean
6792: oPop 2
6794: oChoice 6837
6796: oGetLocal 2
6798: oPushResult
6799: equal_zero
6800: oPop 1
6802: oChoice 6815
6804: oEmit 8
6806: oGetParam 1
6808: oPushResult
6809: oCall 10184
6811: oPop 1
6813: oJumpForward 6833
6815: Choice Lookup Table
           1   6804
6818: oEmit 14
6820: oGetLocal 2
6822: oPushResult
6823: oEmitInt
6824: oPop 1
6826: oGetParam 1
6828: oPushResult
6829: oCall 10184
6831: oPop 1
6833: oEmit 24
6835: oJumpForward 6877
6837: Choice Lookup Table
           1   6796
6840: oGetLocal 2
6842: oPushResult
6843: equal_zero
6844: oPop 1
6846: oChoice 6859
6848: oEmit 8
6850: oGetParam 1
6852: oPushResult
6853: oCall 10184
6855: oPop 1
6857: oJumpForward 6877
6859: Choice Lookup Table
           1   6848
6862: oEmit 14
6864: oGetLocal 2
6866: oPushResult
6867: oEmitInt
6868: oPop 1
6870: oGetParam 1
6872: oPushResult
6873: oCall 10184
6875: oPop 1
6877: oJumpForward 6889
6879: Choice Lookup Table
          23   6785
          21   6746
          24   6735
          20   6735
6888: oEndChoice
6889: oInputChoice 6911
6891: oTypeSPop
6892: oGetLocal 1
6894: oPushResult
6895: oSetResult 36
6897: oPushResult
6898: oNodeGet
6899: oPop 2
6901: oPushResult
6902: oTypeSPush
6903: oPop 1
6905: oCall 7151
6907: oCall 7105
6909: oJumpForward 6914
6911: Choice Lookup Table
          18   6891
6914: oJumpForward 7104
6916: oGetParam 1
6918: oPushResult
6919: oNodeType
6920: oPop 1
6922: oChoice 7066
6924: oEmit 16
6926: oGetParam 1
6928: oPushResult
6929: oCall 10184
6931: oPop 1
6933: oJumpForward 7076
6935: oGetLocal 2
6937: oPushResult
6938: equal_zero
6939: oPop 1
6941: oChoice 6954
6943: oEmit 17
6945: oGetParam 1
6947: oPushResult
6948: oCall 10184
6950: oPop 1
6952: oJumpForward 6972
6954: Choice Lookup Table
           1   6943
6957: oEmit 20
6959: oGetLocal 2
6961: oPushResult
6962: oEmitInt
6963: oPop 1
6965: oGetParam 1
6967: oPushResult
6968: oCall 10184
6970: oPop 1
6972: oJumpForward 7076
6974: oGetParam 1
6976: oPushResult
6977: oSetResult 33
6979: oPushResult
6980: oNodeGetBoolean
6981: oPop 2
6983: oChoice 7024
6985: oGetLocal 2
6987: oPushResult
6988: equal_zero
6989: oPop 1
6991: oChoice 7004
6993: oEmit 8
6995: oGetParam 1
6997: oPushResult
6998: oCall 10184
7000: oPop 1
7002: oJumpForward 7022
7004: Choice Lookup Table
           1   6993
7007: oEmit 14
7009: oGetLocal 2
7011: oPushResult
7012: oEmitInt
7013: oPop 1
7015: oGetParam 1
7017: oPushResult
7018: oCall 10184
7020: oPop 1
7022: oJumpForward 7064
7024: Choice Lookup Table
           1   6985
7027: oGetLocal 2
7029: oPushResult
7030: equal_zero
7031: oPop 1
7033: oChoice 7046
7035: oEmit 18
7037: oGetParam 1
7039: oPushResult
7040: oCall 10184
7042: oPop 1
7044: oJumpForward 7064
7046: Choice Lookup Table
           1   7035
7049: oEmit 21
7051: oGetLocal 2
7053: oPushResult
7054: oEmitInt
7055: oPop 1
7057: oGetParam 1
7059: oPushResult
7060: oCall 10184
7062: oPop 1
7064: oJumpForward 7076
7066: Choice Lookup Table
          23   6974
          21   6935
          24   6924
          20   6924
7075: oEndChoice
7076: oCall 7151
7078: oCall 7105
7080: oJumpForward 7104
7082: Choice Lookup Table
          37   6916
          35   6916
          34   6727
          27   6723
          33   6723
          32   6559
          29   6559
          30   6559
          38   6395
          28   6395
7103: oEndChoice
7104: oReturn
7105: oLocalSpace 0
7107: oTypeSNodeType
7108: oChoice 7128
7110: oEmit 22
7112: oJumpForward 7150
7114: oEmit 23
7116: oJumpForward 7150
7118: oError 16
7120: oJumpForward 7150
7122: oEmit 24
7124: oJumpForward 7150
7126: oJumpForward 7150
7128: Choice Lookup Table
          37   7126
          35   7126
          34   7122
          27   7118
          33   7118
          32   7114
          29   7114
          30   7114
          38   7110
          28   7110
7149: oEndChoice
7150: oReturn
7151: oLocalSpace 0
7153: oInputChoice 7167
7155: oCall 7179
7157: oJumpForward 7176
7159: oCall 7322
7161: oJumpForward 7176
7163: oCall 7420
7165: oJumpForward 7176
7167: Choice Lookup Table
          18   7163
          20   7159
          16   7155
7174: oJumpForward 7178
7176: oJumpBack 7153
7178: oReturn
7179: oLocalSpace 3
7181: oTypeSNodeType
7182: oChoice 7186
7184: oJumpForward 7191
7186: Choice Lookup Table
          35   7184
7189: oError 10
7191: oTypeSNodeType
7192: oChoice 7196
7194: oJumpForward 7201
7196: Choice Lookup Table
          35   7194
7199: oError 13
7201: oGetAddrLocal 1
7203: oPushResult
7204: oTypeSTop
7205: oPushResult
7206: oSetResult 37
7208: oPushResult
7209: oNodeGet
7210: oPop 2
7212: oPushResult
7213: oCall 9994
7215: oPop 1
7217: oAssign
7218: oGetAddrLocal 2
7220: oPushResult
7221: oTypeSTop
7222: oPushResult
7223: oSetResult 36
7225: oPushResult
7226: oNodeGet
7227: oPop 2
7229: oAssign
7230: oTypeSPop
7231: oGetLocal 2
7233: oPushResult
7234: oTypeSPush
7235: oPop 1
7237: oCall 5014
7239: oCall 9728
7241: oGetLocal 1
7243: oPushResult
7244: equal_zero
7245: oPop 1
7247: oChoice 7261
7249: oEmit 15
7251: oGetLocal 1
7253: oPushResult
7254: oEmitInt
7255: oPop 1
7257: oEmit 37
7259: oJumpForward 7264
7261: Choice Lookup Table
           0   7249
7264: oGetAddrLocal 3
7266: oPushResult
7267: oGetLocal 2
7269: oPushResult
7270: oSetResult 17
7272: oPushResult
7273: oNodeGetInt
7274: oPop 2
7276: oAssign
7277: oGetLocal 3
7279: oPushResult
7280: oSetResult 1
7282: oPushResult
7283: equal
7284: oPop 2
7286: oChoice 7300
7288: oEmit 15
7290: oGetLocal 3
7292: oPushResult
7293: oEmitInt
7294: oPop 1
7296: oEmit 33
7298: oJumpForward 7303
7300: Choice Lookup Table
           0   7288
7303: oEmit 35
7305: oInputChoice 7313
7307: oJumpForward 7321
7309: oJumpForward 7319
7311: oJumpForward 7319
7313: Choice Lookup Table
          13   7311
          17   7307
7318: oEndChoice
7319: oJumpBack 7191
7321: oReturn
7322: oLocalSpace 2
7324: oTypeSNodeType
7325: oChoice 7329
7327: oJumpForward 7334
7329: Choice Lookup Table
          37   7327
7332: oError 11
7334: oTypeSTop
7335: oPushResult
7336: oSetResult 40
7338: oPushResult
7339: oNodeGet
7340: oPop 2
7342: oPushResult
7343: oScopeEnter
7344: oPop 1
7346: oInput 0
7348: oGetAddrLocal 1
7350: oPushResult
7351: oScopeFindRequire
7352: oAssign
7353: oGetLocal 1
7355: oPushResult
7356: oNodeType
7357: oPop 1
7359: oChoice 7363
7361: oJumpForward 7368
7363: Choice Lookup Table
          22   7361
7366: oError 12
7368: oScopeEnd
7369: oGetAddrLocal 2
7371: oPushResult
7372: oGetLocal 1
7374: oPushResult
7375: oSetResult 22
7377: oPushResult
7378: oNodeGetInt
7379: oPop 2
7381: oAssign
7382: oGetLocal 2
7384: oPushResult
7385: equal_zero
7386: oPop 1
7388: oChoice 7402
7390: oEmit 15
7392: oGetLocal 2
7394: oPushResult
7395: oEmitInt
7396: oPop 1
7398: oEmit 35
7400: oJumpForward 7405
7402: Choice Lookup Table
           0   7390
7405: oTypeSPop
7406: oGetLocal 1
7408: oPushResult
7409: oSetResult 21
7411: oPushResult
7412: oNodeGet
7413: oPop 2
7415: oPushResult
7416: oTypeSPush
7417: oPop 1
7419: oReturn
7420: oLocalSpace 1
7422: oTypeSNodeType
7423: oChoice 7427
7425: oJumpForward 7432
7427: Choice Lookup Table
          34   7425
7430: oError 9
7432: oEmit 24
7434: oGetAddrLocal 1
7436: oPushResult
7437: oTypeSTop
7438: oAssign
7439: oTypeSPop
7440: oGetLocal 1
7442: oPushResult
7443: oSetResult 36
7445: oPushResult
7446: oNodeGet
7447: oPop 2
7449: oPushResult
7450: oTypeSPush
7451: oPop 1
7453: oReturn
7454: oLocalSpace 1
7456: oGetAddrLocal 1
7458: oPushResult
7459: oTypeSNodeType
7460: oAssign
7461: oTypeSPop
7462: oGetLocal 1
7464: oPushResult
7465: oTypeSNodeType
7466: oPushResult
7467: equal_node_type
7468: oPop 2
7470: oChoice 7512
7472: oTypeSNodeType
7473: oChoice 7503
7475: oGetLocal 1
7477: oChoice 7484
7479: oEmit 29
7481: oReturn
7482: oJumpForward 7487
7484: Choice Lookup Table
          29   7479
7487: oJumpForward 7508
7489: oGetLocal 1
7491: oChoice 7498
7493: oEmit 30
7495: oReturn
7496: oJumpForward 7501
7498: Choice Lookup Table
          28   7493
7501: oJumpForward 7508
7503: Choice Lookup Table
          29   7489
          28   7475
7508: oError 14
7510: oJumpForward 7515
7512: Choice Lookup Table
           0   7472
7515: oReturn
7516: oLocalSpace 2
7518: oGetAddrLocal 2
7520: oPushResult
7521: oGetParam 1
7523: oPushResult
7524: oSetResult 26
7526: oPushResult
7527: oNodeGetString
7528: oPop 2
7530: oAssign
7531: oGetLocal 2
7533: oPushResult
7534: oSetResult 0
7536: oPushResult
7537: equal_string
7538: oPop 2
7540: oChoice 7577
7542: oGetAddrLocal 1
7544: oPushResult
7545: oGetParam 1
7547: oPushResult
7548: oSetResult 4
7550: oPushResult
7551: oNodeGetInt
7552: oPop 2
7554: oPushResult
7555: ID_STRING
7556: oPop 1
7558: oPushResult
7559: oStringAllocLit
7560: oPop 1
7562: oAssign
7563: oJumpForward 7583
7565: oGetAddrLocal 1
7567: oPushResult
7568: oGetLocal 2
7570: oPushResult
7571: oStringAllocLit
7572: oPop 1
7574: oAssign
7575: oJumpForward 7583
7577: Choice Lookup Table
           0   7565
           1   7542
7582: oEndChoice
7583: oEmit 60
7585: oGetParam 1
7587: oPushResult
7588: oCall 10184
7590: oPop 1
7592: oGetLocal 1
7594: oPushResult
7595: oEmitInt
7596: oPop 1
7598: oReturn
7599: oLocalSpace 10
7601: oGetParam 1
7603: oPushResult
7604: oSetResult 25
7606: oPushResult
7607: oNodeGetBoolean
7608: oPop 2
7610: oChoice 7637
7612: oGetParam 1
7614: oPushResult
7615: oSetResult 28
7617: oPushResult
7618: oNodeGetBoolean
7619: oPop 2
7621: oChoice 7632
7623: oGetParam 1
7625: oPushResult
7626: oCall 7516
7628: oPop 1
7630: oJumpForward 7635
7632: Choice Lookup Table
           0   7623
7635: oJumpForward 7640
7637: Choice Lookup Table
           1   7612
7640: oGetParam 1
7642: oPushResult
7643: oSetResult 28
7645: oPushResult
7646: oSetResult 1
7648: oPushResult
7649: oNodeSetBoolean
7650: oPop 3
7652: oGetAddrLocal 1
7654: oPushResult
7655: oGetParam 1
7657: oPushResult
7658: oSetResult 27
7660: oPushResult
7661: oNodeGetBoolean
7662: oPop 2
7664: oAssign
7665: oGetAddrLocal 4
7667: oPushResult
7668: oGetParam 1
7670: oPushResult
7671: oNodeType
7672: oPop 1
7674: oPushResult
7675: oSetResult 13
7677: oPushResult
7678: equal_node_type
7679: oPop 2
7681: oAssign
7682: oGetLocal 4
7684: oChoice 7711
7686: oGetAddrLocal 2
7688: oPushResult
7689: oGetParam 1
7691: oPushResult
7692: oSetResult 21
7694: oPushResult
7695: oNodeGet
7696: oPop 2
7698: oAssign
7699: oGetAddrLocal 3
7701: oPushResult
7702: oGetLocal 2
7704: oPushResult
7705: oScopeAllocType
7706: oPop 1
7708: oAssign
7709: oJumpForward 7714
7711: Choice Lookup Table
           1   7686
7714: oGetAddrLocal 5
7716: oPushResult
7717: oGetParam 1
7719: oPushResult
7720: oSetResult 23
7722: oPushResult
7723: oNodeGet
7724: oPop 2
7726: oAssign
7727: oGetAddrLocal 6
7729: oPushResult
7730: oGetLocal 5
7732: oPushResult
7733: oSetResult 17
7735: oPushResult
7736: oNodeGetInt
7737: oPop 2
7739: oAssign
7740: oGetLocal 1
7742: oChoice 7764
7744: oEmit 49
7746: oGetLocal 6
7748: oPushResult
7749: oEmitInt
7750: oPop 1
7752: oJumpForward 7770
7754: oEmit 48
7756: oGetLocal 6
7758: oPushResult
7759: oEmitInt
7760: oPop 1
7762: oJumpForward 7770
7764: Choice Lookup Table
           0   7754
           1   7744
7769: oEndChoice
7770: oGetParam 1
7772: oPushResult
7773: oCall 9664
7775: oPop 1
7777: oPushResult
7778: oSetResult 0
7780: oPushResult
7781: greater
7782: oPop 2
7784: oChoice 7817
7786: oEmit 19
7788: oSetResult 0
7790: oPushResult
7791: oEmitInt
7792: oPop 1
7794: oEmit 20
7796: oGetParam 1
7798: oPushResult
7799: oCall 9684
7801: oPop 1
7803: oPushResult
7804: oEmitInt
7805: oPop 1
7807: oSetResult 0
7809: oPushResult
7810: oEmitInt
7811: oPop 1
7813: oEmit 27
7815: oJumpForward 7820
7817: Choice Lookup Table
           1   7786
7820: oGetAddrLocal 7
7822: oPushResult
7823: oGetLocal 5
7825: oPushResult
7826: oSetResult 15
7828: oPushResult
7829: oNodeGetIter
7830: oPop 2
7832: oAssign
7833: oGetAddrLocal 8
7835: oPushResult
7836: oGetLocal 7
7838: oPushResult
7839: oNodeIterValue
7840: oPop 1
7842: oAssign
7843: oInputChoice 8033
7845: oGetLocal 8
7847: oPushResult
7848: oNodeNull
7849: oPop 1
7851: oChoice 7857
7853: oJumpForward 8029
7855: oJumpForward 7860
7857: Choice Lookup Table
           1   7853
7860: oGetAddrLocal 9
7862: oPushResult
7863: oGetLocal 8
7865: oPushResult
7866: oSetResult 22
7868: oPushResult
7869: oNodeGetInt
7870: oPop 2
7872: oAssign
7873: oEmit 19
7875: oGetLocal 9
7877: oPushResult
7878: oEmitInt
7879: oPop 1
7881: oGetLocal 8
7883: oPushResult
7884: oSetResult 21
7886: oPushResult
7887: oNodeGet
7888: oPop 2
7890: oPushResult
7891: oTypeSPush
7892: oPop 1
7894: oGetLocal 8
7896: oPushResult
7897: oSetResult 33
7899: oPushResult
7900: oNodeGetBoolean
7901: oPop 2
7903: oChoice 7982
7905: oCall 8844
7907: oCall 9702
7909: oEmit 27
7911: oJumpForward 7988
7913: oCall 5014
7915: oCall 7454
7917: oTypeSNodeType
7918: oChoice 7958
7920: oEmit 25
7922: oJumpForward 7980
7924: oEmit 26
7926: oJumpForward 7980
7928: oError 16
7930: oJumpForward 7980
7932: oEmit 27
7934: oJumpForward 7980
7936: oGetAddrLocal 10
7938: oPushResult
7939: oTypeSTop
7940: oPushResult
7941: oSetResult 17
7943: oPushResult
7944: oNodeGetInt
7945: oPop 2
7947: oAssign
7948: oEmit 28
7950: oGetLocal 10
7952: oPushResult
7953: oEmitInt
7954: oPop 1
7956: oJumpForward 7980
7958: Choice Lookup Table
          37   7936
          35   7936
          34   7932
          27   7928
          33   7928
          32   7924
          29   7924
          30   7924
          38   7920
          28   7920
7979: oEndChoice
7980: oJumpForward 7988
7982: Choice Lookup Table
           0   7913
           1   7905
7987: oEndChoice
7988: oTypeSPop
7989: oGetAddrLocal 7
7991: oPushResult
7992: oNodeIterNext
7993: oPop 1
7995: oGetAddrLocal 8
7997: oPushResult
7998: oGetLocal 7
8000: oPushResult
8001: oNodeIterValue
8002: oPop 1
8004: oAssign
8005: oGetLocal 8
8007: oPushResult
8008: oNodeNull
8009: oPop 1
8011: oChoice 8019
8013: oJumpForward 8029
8015: oJumpForward 8025
8017: oJumpForward 8025
8019: Choice Lookup Table
           0   8017
           1   8013
8024: oEndChoice
8025: oInput 13
8027: oJumpBack 7845
8029: oInput 15
8031: oJumpForward 8036
8033: Choice Lookup Table
          14   7845
8036: oGetLocal 8
8038: oPushResult
8039: oNodeNull
8040: oPop 1
8042: oChoice 8048
8044: oError 15
8046: oJumpForward 8051
8048: Choice Lookup Table
           0   8044
8051: oGetLocal 4
8053: oChoice 8082
8055: oEmit 19
8057: oGetParam 1
8059: oPushResult
8060: oSetResult 31
8062: oPushResult
8063: oNodeGetInt
8064: oPop 2
8066: oPushResult
8067: oEmitInt
8068: oPop 1
8070: oEmit 17
8072: oGetLocal 3
8074: oPushResult
8075: oEmitInt
8076: oPop 1
8078: oEmit 27
8080: oJumpForward 8085
8082: Choice Lookup Table
           1   8055
8085: oGetLocal 1
8087: oChoice 8111
8089: oEmit 52
8091: oGetParam 1
8093: oPushResult
8094: oCall 10184
8096: oPop 1
8098: oJumpForward 8117
8100: oEmit 51
8102: oGetParam 1
8104: oPushResult
8105: oCall 10184
8107: oPop 1
8109: oJumpForward 8117
8111: Choice Lookup Table
           0   8100
           1   8089
8116: oEndChoice
8117: oGetLocal 4
8119: oChoice 8198
8121: oGetLocal 2
8123: oPushResult
8124: oTypeSPush
8125: oPop 1
8127: oTypeSNodeType
8128: oChoice 8174
8130: oEmit 3
8132: oGetLocal 3
8134: oPushResult
8135: oEmitInt
8136: oPop 1
8138: oJumpForward 8196
8140: oEmit 4
8142: oGetLocal 3
8144: oPushResult
8145: oEmitInt
8146: oPop 1
8148: oJumpForward 8196
8150: oError 16
8152: oJumpForward 8196
8154: oEmit 5
8156: oGetLocal 3
8158: oPushResult
8159: oEmitInt
8160: oPop 1
8162: oJumpForward 8196
8164: oEmit 17
8166: oGetLocal 3
8168: oPushResult
8169: oEmitInt
8170: oPop 1
8172: oJumpForward 8196
8174: Choice Lookup Table
          37   8164
          35   8164
          34   8154
          27   8150
          33   8150
          32   8140
          29   8140
          30   8140
          38   8130
          28   8130
8195: oEndChoice
8196: oJumpForward 8201
8198: Choice Lookup Table
           1   8121
8201: oEmit 50
8203: oGetLocal 6
8205: oPushResult
8206: oEmitInt
8207: oPop 1
8209: oReturn
8210: oLocalSpace 0
8212: oGetParam 1
8214: oPushResult
8215: oGetGlobal 11
8217: oPushResult
8218: oNodeEqual
8219: oPop 2
8221: oChoice 8261
8223: oInput 14
8225: oCall 5014
8227: oTypeSNodeType
8228: oChoice 8236
8230: oJumpForward 8249
8232: oEmit 29
8234: oJumpForward 8249
8236: Choice Lookup Table
          32   8232
          29   8232
          30   8232
          38   8230
          28   8230
8247: oError 14
8249: oTypeSPop
8250: oGetGlobal 5
8252: oPushResult
8253: oTypeSPush
8254: oPop 1
8256: oInput 15
8258: oReturn
8259: oJumpForward 8264
8261: Choice Lookup Table
           1   8223
8264: oGetParam 1
8266: oPushResult
8267: oGetGlobal 12
8269: oPushResult
8270: oNodeEqual
8271: oPop 2
8273: oChoice 8307
8275: oInput 14
8277: oCall 5014
8279: oTypeSNodeType
8280: oChoice 8288
8282: oEmit 30
8284: oJumpForward 8295
8286: oJumpForward 8295
8288: Choice Lookup Table
          29   8286
          28   8282
8293: oError 14
8295: oTypeSPop
8296: oGetGlobal 8
8298: oPushResult
8299: oTypeSPush
8300: oPop 1
8302: oInput 15
8304: oReturn
8305: oJumpForward 8310
8307: Choice Lookup Table
           1   8275
8310: oGetParam 1
8312: oPushResult
8313: oGetGlobal 13
8315: oPushResult
8316: oNodeEqual
8317: oPop 2
8319: oChoice 8359
8321: oInput 14
8323: oCall 5014
8325: oTypeSNodeType
8326: oChoice 8347
8328: oTypeSTop
8329: oPushResult
8330: oSetResult 42
8332: oPushResult
8333: oNodeGetBoolean
8334: oPop 2
8336: oChoice 8342
8338: oError 28
8340: oJumpForward 8345
8342: Choice Lookup Table
           1   8338
8345: oJumpForward 8352
8347: Choice Lookup Table
          38   8328
8350: oError 14
8352: oEmit 32
8354: oInput 15
8356: oReturn
8357: oJumpForward 8362
8359: Choice Lookup Table
           1   8321
8362: oGetParam 1
8364: oPushResult
8365: oGetGlobal 14
8367: oPushResult
8368: oNodeEqual
8369: oPop 2
8371: oChoice 8411
8373: oInput 14
8375: oCall 5014
8377: oTypeSNodeType
8378: oChoice 8399
8380: oTypeSTop
8381: oPushResult
8382: oSetResult 42
8384: oPushResult
8385: oNodeGetBoolean
8386: oPop 2
8388: oChoice 8394
8390: oError 28
8392: oJumpForward 8397
8394: Choice Lookup Table
           1   8390
8397: oJumpForward 8404
8399: Choice Lookup Table
          38   8380
8402: oError 14
8404: oEmit 31
8406: oInput 15
8408: oReturn
8409: oJumpForward 8414
8411: Choice Lookup Table
           1   8373
8414: oError 16
8416: oReturn
8417: oLocalSpace 0
8419: oInputChoice 8478
8421: oCall 9540
8423: oJumpForward 8507
8425: oCall 9547
8427: oJumpForward 8507
8429: oCall 9646
8431: oJumpForward 8507
8433: oCall 9649
8435: oJumpForward 8507
8437: oCall 9028
8439: oJumpForward 8507
8441: oCall 9348
8443: oJumpForward 8507
8445: oCall 9094
8447: oJumpForward 8507
8449: oCall 9268
8451: oJumpForward 8507
8453: oCall 9433
8455: oJumpForward 8507
8457: oCall 9401
8459: oJumpForward 8507
8461: oCall 9517
8463: oJumpForward 8507
8465: oCall 8508
8467: oJumpForward 8507
8469: oCall 9465
8471: oJumpForward 8507
8473: oChangeIntLitToLabelIdent
8474: oCall 8508
8476: oJumpForward 8507
8478: Choice Lookup Table
           1   8473
          53   8469
           0   8465
          35   8461
          51   8457
          52   8453
          49   8449
          44   8445
          48   8441
          41   8437
          66   8433
          65   8429
          64   8425
          63   8421
8507: oReturn
8508: oLocalSpace 1
8510: oGetAddrLocal 1
8512: oPushResult
8513: oScopeFindRequire
8514: oAssign
8515: oGetAddrLocal 1
8517: oPushResult
8518: oCall 409
8520: oPop 1
8522: oGetLocal 1
8524: oPushResult
8525: oNodeType
8526: oPop 1
8528: oChoice 8568
8530: oGetLocal 1
8532: oPushResult
8533: oCall 8584
8535: oPop 1
8537: oCall 8417
8539: oJumpForward 8583
8541: oGetLocal 1
8543: oPushResult
8544: oCall 7599
8546: oPop 1
8548: oJumpForward 8583
8550: oGetLocal 1
8552: oPushResult
8553: oCall 8634
8555: oPop 1
8557: oJumpForward 8583
8559: oGetLocal 1
8561: oPushResult
8562: oCall 8719
8564: oPop 1
8566: oJumpForward 8583
8568: Choice Lookup Table
          13   8559
          23   8550
          21   8550
          20   8550
          12   8541
          25   8530
8581: oError 0
8583: oReturn
8584: oLocalSpace 0
8586: oGetParam 1
8588: oPushResult
8589: oSetResult 34
8591: oPushResult
8592: oNodeGetBoolean
8593: oPop 2
8595: oChoice 8601
8597: oError 21
8599: oJumpForward 8604
8601: Choice Lookup Table
           1   8597
8604: oEmit 58
8606: oGetParam 1
8608: oPushResult
8609: oSetResult 22
8611: oPushResult
8612: oNodeGetLabel
8613: oPop 2
8615: oPushResult
8616: oEmitLabel
8617: oPop 1
8619: oGetParam 1
8621: oPushResult
8622: oSetResult 34
8624: oPushResult
8625: oSetResult 1
8627: oPushResult
8628: oNodeSetBoolean
8629: oPop 3
8631: oInput 12
8633: oReturn
8634: oLocalSpace 0
8636: oGetParam 1
8638: oPushResult
8639: oCall 8887
8641: oPop 1
8643: oInput 4
8645: oCall 5014
8647: oCall 7454
8649: oCall 8652
8651: oReturn
8652: oLocalSpace 1
8654: oTypeSNodeType
8655: oChoice 8695
8657: oEmit 25
8659: oJumpForward 8717
8661: oEmit 26
8663: oJumpForward 8717
8665: oError 16
8667: oJumpForward 8717
8669: oEmit 27
8671: oJumpForward 8717
8673: oGetAddrLocal 1
8675: oPushResult
8676: oTypeSTop
8677: oPushResult
8678: oSetResult 17
8680: oPushResult
8681: oNodeGetInt
8682: oPop 2
8684: oAssign
8685: oEmit 28
8687: oGetLocal 1
8689: oPushResult
8690: oEmitInt
8691: oPop 1
8693: oJumpForward 8717
8695: Choice Lookup Table
          37   8673
          35   8673
          34   8669
          27   8665
          33   8665
          32   8661
          29   8661
          30   8661
          38   8657
          28   8657
8716: oEndChoice
8717: oTypeSPop
8718: oReturn
8719: oLocalSpace 1
8721: oGetParam 1
8723: oPushResult
8724: oSetResult 6
8726: oPushResult
8727: oNodeGet
8728: oPop 2
8730: oPushResult
8731: oScopeCurrent
8732: oPushResult
8733: oNodeEqual
8734: oPop 2
8736: oChoice 8742
8738: oError 20
8740: oJumpForward 8745
8742: Choice Lookup Table
           0   8738
8745: oEmit 8
8747: oGetParam 1
8749: oPushResult
8750: oSetResult 31
8752: oPushResult
8753: oNodeGetInt
8754: oPop 2
8756: oPushResult
8757: oEmitInt
8758: oPop 1
8760: oGetParam 1
8762: oPushResult
8763: oSetResult 21
8765: oPushResult
8766: oNodeGet
8767: oPop 2
8769: oPushResult
8770: oTypeSPush
8771: oPop 1
8773: oInput 4
8775: oCall 5014
8777: oCall 7454
8779: oTypeSNodeType
8780: oChoice 8820
8782: oEmit 25
8784: oJumpForward 8842
8786: oEmit 26
8788: oJumpForward 8842
8790: oError 16
8792: oJumpForward 8842
8794: oEmit 27
8796: oJumpForward 8842
8798: oGetAddrLocal 1
8800: oPushResult
8801: oTypeSTop
8802: oPushResult
8803: oSetResult 17
8805: oPushResult
8806: oNodeGetInt
8807: oPop 2
8809: oAssign
8810: oEmit 28
8812: oGetLocal 1
8814: oPushResult
8815: oEmitInt
8816: oPop 1
8818: oJumpForward 8842
8820: Choice Lookup Table
          37   8798
          35   8798
          34   8794
          27   8790
          33   8790
          32   8786
          29   8786
          30   8786
          38   8782
          28   8782
8841: oEndChoice
8842: oTypeSPop
8843: oReturn
8844: oLocalSpace 1
8846: oInput 0
8848: oGetAddrLocal 1
8850: oPushResult
8851: oScopeFindRequire
8852: oAssign
8853: oGetAddrLocal 1
8855: oPushResult
8856: oCall 409
8858: oPop 1
8860: oGetLocal 1
8862: oPushResult
8863: oNodeType
8864: oPop 1
8866: oChoice 8870
8868: oJumpForward 8879
8870: Choice Lookup Table
          23   8868
          21   8868
          20   8868
8877: oError 4
8879: oGetLocal 1
8881: oPushResult
8882: oCall 8887
8884: oPop 1
8886: oReturn
8887: oLocalSpace 0
8889: oGetParam 1
8891: oPushResult
8892: oNodeType
8893: oPop 1
8895: oChoice 8955
8897: oEmit 16
8899: oGetParam 1
8901: oPushResult
8902: oCall 10184
8904: oPop 1
8906: oJumpForward 8964
8908: oEmit 17
8910: oGetParam 1
8912: oPushResult
8913: oCall 10184
8915: oPop 1
8917: oJumpForward 8964
8919: oGetParam 1
8921: oPushResult
8922: oSetResult 33
8924: oPushResult
8925: oNodeGetBoolean
8926: oPop 2
8928: oChoice 8941
8930: oEmit 8
8932: oGetParam 1
8934: oPushResult
8935: oCall 10184
8937: oPop 1
8939: oJumpForward 8953
8941: Choice Lookup Table
           1   8930
8944: oEmit 18
8946: oGetParam 1
8948: oPushResult
8949: oCall 10184
8951: oPop 1
8953: oJumpForward 8964
8955: Choice Lookup Table
          23   8919
          21   8908
          20   8897
8962: oError 4
8964: oGetParam 1
8966: oPushResult
8967: oSetResult 21
8969: oPushResult
8970: oNodeGet
8971: oPop 2
8973: oPushResult
8974: oTypeSPush
8975: oPop 1
8977: oCall 7151
8979: oReturn
8980: oLocalSpace 0
8982: oGetParam 1
8984: oPushResult
8985: oCall 8887
8987: oPop 1
8989: oCall 9728
8991: oGetParam 1
8993: oPushResult
8994: oCall 6360
8996: oPop 1
8998: oTypeSPop
8999: oEmit 31
9001: oEmit 25
9003: oReturn
9004: oLocalSpace 0
9006: oGetParam 1
9008: oPushResult
9009: oCall 8887
9011: oPop 1
9013: oCall 9728
9015: oGetParam 1
9017: oPushResult
9018: oCall 6360
9020: oPop 1
9022: oTypeSPop
9023: oEmit 32
9025: oEmit 25
9027: oReturn
9028: oLocalSpace 2
9030: oGetAddrLocal 1
9032: oPushResult
9033: oSetResult 0
9035: oAssign
9036: oGetAddrLocal 1
9038: oPushResult
9039: oCall 5037
9041: oPop 1
9043: oInput 42
9045: oCall 8417
9047: oInputChoice 9082
9049: oGetAddrLocal 2
9051: oPushResult
9052: oLabelNew
9053: oAssign
9054: oEmit 55
9056: oGetLocal 2
9058: oPushResult
9059: oEmitLabel
9060: oPop 1
9062: oEmit 58
9064: oGetLocal 1
9066: oPushResult
9067: oEmitLabel
9068: oPop 1
9070: oCall 8417
9072: oEmit 58
9074: oGetLocal 2
9076: oPushResult
9077: oEmitLabel
9078: oPop 1
9080: oJumpForward 9093
9082: Choice Lookup Table
          43   9049
9085: oEmit 58
9087: oGetLocal 1
9089: oPushResult
9090: oEmitLabel
9091: oPop 1
9093: oReturn
9094: oLocalSpace 4
9096: oInput 0
9098: oGetAddrLocal 1
9100: oPushResult
9101: oScopeFindRequire
9102: oAssign
9103: oGetLocal 1
9105: oPushResult
9106: oCall 8887
9108: oPop 1
9110: oCall 9728
9112: oInput 4
9114: oCall 5014
9116: oCall 9728
9118: oEmit 25
9120: oGetAddrLocal 2
9122: oPushResult
9123: oLabelNew
9124: oAssign
9125: oGetAddrLocal 3
9127: oPushResult
9128: oLabelNew
9129: oAssign
9130: oEmit 55
9132: oGetLocal 3
9134: oPushResult
9135: oEmitLabel
9136: oPop 1
9138: oGetAddrLocal 4
9140: oPushResult
9141: oLabelNew
9142: oAssign
9143: oEmit 58
9145: oGetLocal 4
9147: oPushResult
9148: oEmitLabel
9149: oPop 1
9151: oInputChoice 9231
9153: oGetLocal 1
9155: oPushResult
9156: oCall 8980
9158: oPop 1
9160: oEmit 58
9162: oGetLocal 3
9164: oPushResult
9165: oEmitLabel
9166: oPop 1
9168: oGetLocal 1
9170: oPushResult
9171: oCall 6360
9173: oPop 1
9175: oTypeSPop
9176: oCall 5014
9178: oCall 9728
9180: oEmit 42
9182: oEmit 56
9184: oGetLocal 2
9186: oPushResult
9187: oEmitLabel
9188: oPop 1
9190: oJumpForward 9237
9192: oGetLocal 1
9194: oPushResult
9195: oCall 9004
9197: oPop 1
9199: oEmit 58
9201: oGetLocal 3
9203: oPushResult
9204: oEmitLabel
9205: oPop 1
9207: oGetLocal 1
9209: oPushResult
9210: oCall 6360
9212: oPop 1
9214: oTypeSPop
9215: oCall 5014
9217: oCall 9728
9219: oEmit 43
9221: oEmit 56
9223: oGetLocal 2
9225: oPushResult
9226: oEmitLabel
9227: oPop 1
9229: oJumpForward 9237
9231: Choice Lookup Table
          46   9192
          45   9153
9236: oEndChoice
9237: oGetLocal 4
9239: oPushResult
9240: oGetLocal 2
9242: oPushResult
9243: oLoopPush
9244: oPop 2
9246: oInput 47
9248: oCall 8417
9250: oEmit 55
9252: oGetLocal 4
9254: oPushResult
9255: oEmitLabel
9256: oPop 1
9258: oEmit 58
9260: oGetLocal 2
9262: oPushResult
9263: oEmitLabel
9264: oPop 1
9266: oLoopPop
9267: oReturn
9268: oLocalSpace 3
9270: oGetAddrLocal 1
9272: oPushResult
9273: oLabelNew
9274: oAssign
9275: oEmit 58
9277: oGetLocal 1
9279: oPushResult
9280: oEmitLabel
9281: oPop 1
9283: oGetAddrLocal 2
9285: oPushResult
9286: oLabelNew
9287: oAssign
9288: oGetLocal 1
9290: oPushResult
9291: oGetLocal 2
9293: oPushResult
9294: oLoopPush
9295: oPop 2
9297: oCall 8417
9299: oInputChoice 9330
9301: oCall 8417
9303: oJumpForward 9336
9305: oGetAddrLocal 3
9307: oPushResult
9308: oCall 5037
9310: oPop 1
9312: oEmit 59
9314: oGetLocal 3
9316: oPushResult
9317: oEmitLabel
9318: oPop 1
9320: oGetLocal 1
9322: oPushResult
9323: oEmitLabel
9324: oPop 1
9326: oJumpForward 9338
9328: oJumpForward 9336
9330: Choice Lookup Table
          50   9305
           5   9301
9335: oEndChoice
9336: oJumpBack 9299
9338: oEmit 58
9340: oGetLocal 2
9342: oPushResult
9343: oEmitLabel
9344: oPop 1
9346: oLoopPop
9347: oReturn
9348: oLocalSpace 2
9350: oGetAddrLocal 1
9352: oPushResult
9353: oLabelNew
9354: oAssign
9355: oEmit 58
9357: oGetLocal 1
9359: oPushResult
9360: oEmitLabel
9361: oPop 1
9363: oGetAddrLocal 2
9365: oPushResult
9366: oCall 5037
9368: oPop 1
9370: oGetLocal 1
9372: oPushResult
9373: oGetLocal 2
9375: oPushResult
9376: oLoopPush
9377: oPop 2
9379: oInput 47
9381: oCall 8417
9383: oEmit 55
9385: oGetLocal 1
9387: oPushResult
9388: oEmitLabel
9389: oPop 1
9391: oEmit 58
9393: oGetLocal 2
9395: oPushResult
9396: oEmitLabel
9397: oPop 1
9399: oLoopPop
9400: oReturn
9401: oLocalSpace 0
9403: oLoopContinueLabel
9404: oPushResult
9405: oSetResult 0
9407: oPushResult
9408: equal_label
9409: oPop 2
9411: oChoice 9426
9413: oError 18
9415: oJumpForward 9432
9417: oEmit 55
9419: oLoopContinueLabel
9420: oPushResult
9421: oEmitLabel
9422: oPop 1
9424: oJumpForward 9432
9426: Choice Lookup Table
           0   9417
           1   9413
9431: oEndChoice
9432: oReturn
9433: oLocalSpace 0
9435: oLoopBreakLabel
9436: oPushResult
9437: oSetResult 0
9439: oPushResult
9440: equal_label
9441: oPop 2
9443: oChoice 9458
9445: oError 18
9447: oJumpForward 9464
9449: oEmit 55
9451: oLoopBreakLabel
9452: oPushResult
9453: oEmitLabel
9454: oPop 1
9456: oJumpForward 9464
9458: Choice Lookup Table
           0   9449
           1   9445
9463: oEndChoice
9464: oReturn
9465: oLocalSpace 1
9467: oInputChoice 9474
9469: oJumpForward 9480
9471: oChangeIntLitToLabelIdent
9472: oJumpForward 9480
9474: Choice Lookup Table
           1   9471
           0   9469
9479: oEndChoice
9480: oGetAddrLocal 1
9482: oPushResult
9483: oScopeCurrent
9484: oPushResult
9485: oScopeFindRequireInScope
9486: oPop 1
9488: oAssign
9489: oGetLocal 1
9491: oPushResult
9492: oSetResult 28
9494: oPushResult
9495: oSetResult 1
9497: oPushResult
9498: oNodeSetBoolean
9499: oPop 3
9501: oEmit 55
9503: oGetLocal 1
9505: oPushResult
9506: oSetResult 22
9508: oPushResult
9509: oNodeGetLabel
9510: oPop 2
9512: oPushResult
9513: oEmitLabel
9514: oPop 1
9516: oReturn
9517: oLocalSpace 0
9519: oCall 8417
9521: oInputChoice 9531
9523: oCall 8417
9525: oJumpForward 9537
9527: oJumpForward 9539
9529: oJumpForward 9537
9531: Choice Lookup Table
          36   9527
           5   9523
9536: oEndChoice
9537: oJumpBack 9521
9539: oReturn
9540: oLocalSpace 0
9542: oCall 9547
9544: oEmit 67
9546: oReturn
9547: oLocalSpace 0
9549: oInputChoice 9642
9551: oCall 5014
9553: oTypeSNodeType
9554: oChoice 9604
9556: oEmit 61
9558: oJumpForward 9623
9560: oEmit 62
9562: oJumpForward 9623
9564: oEmit 29
9566: oEmit 61
9568: oJumpForward 9623
9570: oEmit 63
9572: oJumpForward 9623
9574: oEmit 64
9576: oJumpForward 9623
9578: oError 16
9580: oJumpForward 9623
9582: oEmit 16
9584: oTypeSTop
9585: oPushResult
9586: oSetResult 41
9588: oPushResult
9589: oNodeGetInt
9590: oPop 2
9592: oPushResult
9593: oEmitInt
9594: oPop 1
9596: oEmit 66
9598: oJumpForward 9623
9600: oEmit 65
9602: oJumpForward 9623
9604: Choice Lookup Table
          34   9600
          38   9582
          27   9578
          33   9574
          32   9570
          29   9564
          30   9560
          28   9556
9621: oError 17
9623: oTypeSPop
9624: oInputChoice 9632
9626: oJumpForward 9640
9628: oJumpForward 9638
9630: oJumpForward 9638
9632: Choice Lookup Table
          13   9630
          15   9626
9637: oEndChoice
9638: oJumpBack 9551
9640: oJumpForward 9645
9642: Choice Lookup Table
          14   9551
9645: oReturn
9646: oLocalSpace 0
9648: oReturn
9649: oLocalSpace 0
9651: oReturn
9652: oLocalSpace 0
9654: oScopeCurrent
9655: oPushResult
9656: oSetResult 14
9658: oPushResult
9659: oNodeGetInt
9660: oPop 2
9662: oReturn
9663: oReturn
9664: oLocalSpace 0
9666: oGetParam 1
9668: oPushResult
9669: oSetResult 20
9671: oPushResult
9672: oNodeGet
9673: oPop 2
9675: oPushResult
9676: oSetResult 14
9678: oPushResult
9679: oNodeGetInt
9680: oPop 2
9682: oReturn
9683: oReturn
9684: oLocalSpace 0
9686: oCall 9652
9688: oPushResult
9689: oGetParam 1
9691: oPushResult
9692: oCall 9664
9694: oPop 1
9696: oPushResult
9697: subtract
9698: oPop 2
9700: oReturn
9701: oReturn
9702: oLocalSpace 1
9704: oGetAddrLocal 1
9706: oPushResult
9707: oTypeSNodeType
9708: oAssign
9709: oTypeSPop
9710: oGetLocal 1
9712: oPushResult
9713: oTypeSNodeType
9714: oPushResult
9715: equal_node_type
9716: oPop 2
9718: oChoice 9724
9720: oError 14
9722: oJumpForward 9727
9724: Choice Lookup Table
           0   9720
9727: oReturn
9728: oLocalSpace 0
9730: oTypeSNodeType
9731: oChoice 9735
9733: oJumpForward 9740
9735: Choice Lookup Table
          28   9733
9738: oError 7
9740: oTypeSPop
9741: oReturn
9742: oLocalSpace 0
9744: oTypeSNodeType
9745: oChoice 9749
9747: oJumpForward 9754
9749: Choice Lookup Table
          28   9747
9752: oError 7
9754: oReturn
9755: oLocalSpace 0
9757: oTypeSNodeType
9758: oChoice 9766
9760: oJumpForward 9773
9762: oEmit 29
9764: oJumpForward 9773
9766: Choice Lookup Table
          29   9762
          28   9760
9771: oError 7
9773: oTypeSPop
9774: oReturn
9775: oLocalSpace 0
9777: oTypeSNodeType
9778: oChoice 9793
9780: oJumpForward 9800
9782: oEmit 29
9784: oTypeSPop
9785: oGetGlobal 5
9787: oPushResult
9788: oTypeSPush
9789: oPop 1
9791: oJumpForward 9800
9793: Choice Lookup Table
          29   9782
          28   9780
9798: oError 7
9800: oReturn
9801: oLocalSpace 0
9803: oTypeSNodeType
9804: oChoice 9817
9806: oEmit 29
9808: oTypeSPop
9809: oGetGlobal 5
9811: oPushResult
9812: oTypeSPush
9813: oPop 1
9815: oJumpForward 9820
9817: Choice Lookup Table
          29   9806
9820: oReturn
9821: oLocalSpace 0
9823: oTypeSNodeType
9824: oChoice 9828
9826: oJumpForward 9833
9828: Choice Lookup Table
          30   9826
9831: oError 8
9833: oTypeSPop
9834: oReturn
9835: oLocalSpace 0
9837: oTypeSNodeType
9838: oChoice 9842
9840: oJumpForward 9847
9842: Choice Lookup Table
          30   9840
9845: oError 8
9847: oReturn
9848: oLocalSpace 1
9850: oGetAddrLocal 1
9852: oPushResult
9853: oGetParam 2
9855: oPushResult
9856: oNodeNew
9857: oPop 1
9859: oAssign
9860: oGetLocal 1
9862: oPushResult
9863: oSetResult 17
9865: oPushResult
9866: oGetParam 1
9868: oPushResult
9869: oNodeSetInt
9870: oPop 3
9872: oGetLocal 1
9874: oPushResult
9875: oTypeAdd
9876: oPop 1
9878: oGetLocal 1
9880: oReturn
9881: oReturn
9882: oLocalSpace 1
9884: oGetAddrLocal 1
9886: oPushResult
9887: oGetParam 2
9889: oPushResult
9890: oNodeNew
9891: oPop 1
9893: oAssign
9894: oGetLocal 1
9896: oPushResult
9897: oSetResult 4
9899: oPushResult
9900: oGetParam 1
9902: oPushResult
9903: oNodeSetInt
9904: oPop 3
9906: oGetLocal 1
9908: oReturn
9909: oReturn
9910: oLocalSpace 1
9912: oGetAddrLocal 1
9914: oPushResult
9915: oGetParam 1
9917: oPushResult
9918: oSetResult 35
9920: oPushResult
9921: oNodeGet
9922: oPop 2
9924: oAssign
9925: oGetLocal 1
9927: oPushResult
9928: oNodeNull
9929: oPop 1
9931: oChoice 9987
9933: oGetAddrLocal 1
9935: oPushResult
9936: oSetResult 34
9938: oPushResult
9939: oNodeNew
9940: oPop 1
9942: oAssign
9943: oGetLocal 1
9945: oPushResult
9946: oSetResult 36
9948: oPushResult
9949: oGetParam 1
9951: oPushResult
9952: oNodeSet
9953: oPop 3
9955: oGetLocal 1
9957: oPushResult
9958: oSetResult 17
9960: oPushResult
9961: oSetResult 8
9963: oPushResult
9964: oNodeSetInt
9965: oPop 3
9967: oGetLocal 1
9969: oPushResult
9970: oTypeAdd
9971: oPop 1
9973: oGetParam 1
9975: oPushResult
9976: oSetResult 35
9978: oPushResult
9979: oGetLocal 1
9981: oPushResult
9982: oNodeSet
9983: oPop 3
9985: oJumpForward 9990
9987: Choice Lookup Table
           1   9933
9990: oGetLocal 1
9992: oReturn
9993: oReturn
9994: oLocalSpace 2
9996: oGetParam 1
9998: oPushResult
9999: oNodeType
10000: oPop 1
10002: oChoice 10072
10004: oMININT
10005: oReturn
10006: oJumpForward 10088
10008: oSetResult 0
10010: oReturn
10011: oJumpForward 10088
10013: oSetResult 0
10015: oReturn
10016: oJumpForward 10088
10018: oGetAddrLocal 1
10020: oPushResult
10021: oGetParam 1
10023: oPushResult
10024: oSetResult 40
10026: oPushResult
10027: oNodeGet
10028: oPop 2
10030: oAssign
10031: oGetAddrLocal 2
10033: oPushResult
10034: oGetLocal 1
10036: oPushResult
10037: oSetResult 15
10039: oPushResult
10040: oNodeGetIter
10041: oPop 2
10043: oPushResult
10044: oNodeIterValue
10045: oPop 1
10047: oAssign
10048: oGetLocal 2
10050: oPushResult
10051: oSetResult 22
10053: oPushResult
10054: oNodeGetInt
10055: oPop 2
10057: oReturn
10058: oJumpForward 10088
10060: oGetParam 1
10062: oPushResult
10063: oSetResult 38
10065: oPushResult
10066: oNodeGetInt
10067: oPop 2
10069: oReturn
10070: oJumpForward 10088
10072: Choice Lookup Table
          36   10060
          38   10018
          32   10013
          30   10008
          28   10004
10083: oError 3
10085: oSetResult 0
10087: oReturn
10088: oReturn
10089: oLocalSpace 2
10091: oGetParam 1
10093: oPushResult
10094: oNodeType
10095: oPop 1
10097: oChoice 10167
10099: oMAXINT
10100: oReturn
10101: oJumpForward 10183
10103: oSetResult 1
10105: oReturn
10106: oJumpForward 10183
10108: oSetResult 255
10110: oReturn
10111: oJumpForward 10183
10113: oGetAddrLocal 1
10115: oPushResult
10116: oGetParam 1
10118: oPushResult
10119: oSetResult 40
10121: oPushResult
10122: oNodeGet
10123: oPop 2
10125: oAssign
10126: oGetAddrLocal 2
10128: oPushResult
10129: oGetLocal 1
10131: oPushResult
10132: oSetResult 15
10134: oPushResult
10135: oNodeGetIterLast
10136: oPop 2
10138: oPushResult
10139: oNodeIterValue
10140: oPop 1
10142: oAssign
10143: oGetLocal 2
10145: oPushResult
10146: oSetResult 22
10148: oPushResult
10149: oNodeGetInt
10150: oPop 2
10152: oReturn
10153: oJumpForward 10183
10155: oGetParam 1
10157: oPushResult
10158: oSetResult 39
10160: oPushResult
10161: oNodeGetInt
10162: oPop 2
10164: oReturn
10165: oJumpForward 10183
10167: Choice Lookup Table
          36   10155
          38   10113
          32   10108
          30   10103
          28   10099
10178: oError 3
10180: oSetResult 0
10182: oReturn
10183: oReturn
10184: oLocalSpace 0
10186: oGetParam 1
10188: oPushResult
10189: oSetResult 22
10191: oPushResult
10192: oNodeGetInt
10193: oPop 2
10195: oPushResult
10196: oEmitInt
10197: oPop 1
10199: oReturn
10200: oLocalSpace 1
10202: oGetAddrLocal 1
10204: oPushResult
10205: oSetResult 14
10207: oPushResult
10208: oGetParam 1
10210: oPushResult
10211: oCall 9882
10213: oPop 2
10215: oAssign
10216: oGetLocal 1
10218: oPushResult
10219: oScopeDeclare
10220: oPop 1
10222: oGetLocal 1
10224: oReturn
10225: oReturn
10226: oLocalSpace 1
10228: oGetAddrGlobal 4
10230: oPushResult
10231: oSetResult 27
10233: oPushResult
10234: oSetResult 4
10236: oPushResult
10237: oCall 9848
10239: oPop 2
10241: oAssign
10242: oGetAddrGlobal 5
10244: oPushResult
10245: oSetResult 28
10247: oPushResult
10248: oSetResult 4
10250: oPushResult
10251: oCall 9848
10253: oPop 2
10255: oAssign
10256: oGetAddrGlobal 6
10258: oPushResult
10259: oSetResult 30
10261: oPushResult
10262: oSetResult 1
10264: oPushResult
10265: oCall 9848
10267: oPop 2
10269: oAssign
10270: oGetAddrGlobal 7
10272: oPushResult
10273: oSetResult 31
10275: oPushResult
10276: oSetResult 1
10278: oPushResult
10279: oCall 9848
10281: oPop 2
10283: oAssign
10284: oGetAddrGlobal 8
10286: oPushResult
10287: oSetResult 32
10289: oPushResult
10290: oSetResult 1
10292: oPushResult
10293: oCall 9848
10295: oPop 2
10297: oAssign
10298: oGetAddrGlobal 9
10300: oPushResult
10301: oSetResult 29
10303: oPushResult
10304: oSetResult 1
10306: oPushResult
10307: oCall 9848
10309: oPop 2
10311: oAssign
10312: oGetAddrGlobal 10
10314: oPushResult
10315: oSetResult 33
10317: oPushResult
10318: oSetResult 256
10320: oPushResult
10321: oCall 9848
10323: oPop 2
10325: oAssign
10326: oGetAddrLocal 1
10328: oPushResult
10329: oSetResult 18
10331: oPushResult
10332: oIdAdd_File
10333: oPushResult
10334: oCall 9882
10336: oPop 2
10338: oAssign
10339: oGetLocal 1
10341: oPushResult
10342: oSetResult 21
10344: oPushResult
10345: oGetGlobal 4
10347: oPushResult
10348: oNodeSet
10349: oPop 3
10351: oGetLocal 1
10353: oPushResult
10354: oScopeDeclare
10355: oPop 1
10357: oGetAddrLocal 1
10359: oPushResult
10360: oSetResult 18
10362: oPushResult
10363: oIdAdd_Integer
10364: oPushResult
10365: oCall 9882
10367: oPop 2
10369: oAssign
10370: oGetLocal 1
10372: oPushResult
10373: oSetResult 21
10375: oPushResult
10376: oGetGlobal 5
10378: oPushResult
10379: oNodeSet
10380: oPop 3
10382: oGetLocal 1
10384: oPushResult
10385: oScopeDeclare
10386: oPop 1
10388: oGetAddrLocal 1
10390: oPushResult
10391: oSetResult 18
10393: oPushResult
10394: oIdAdd_Boolean
10395: oPushResult
10396: oCall 9882
10398: oPop 2
10400: oAssign
10401: oGetLocal 1
10403: oPushResult
10404: oSetResult 21
10406: oPushResult
10407: oGetGlobal 6
10409: oPushResult
10410: oNodeSet
10411: oPop 3
10413: oGetLocal 1
10415: oPushResult
10416: oScopeDeclare
10417: oPop 1
10419: oGetAddrLocal 1
10421: oPushResult
10422: oSetResult 18
10424: oPushResult
10425: oIdAdd_Char
10426: oPushResult
10427: oCall 9882
10429: oPop 2
10431: oAssign
10432: oGetLocal 1
10434: oPushResult
10435: oSetResult 21
10437: oPushResult
10438: oGetGlobal 8
10440: oPushResult
10441: oNodeSet
10442: oPop 3
10444: oGetLocal 1
10446: oPushResult
10447: oScopeDeclare
10448: oPop 1
10450: oGetAddrLocal 1
10452: oPushResult
10453: oSetResult 18
10455: oPushResult
10456: oIdAdd_Byte
10457: oPushResult
10458: oCall 9882
10460: oPop 2
10462: oAssign
10463: oGetLocal 1
10465: oPushResult
10466: oSetResult 21
10468: oPushResult
10469: oGetGlobal 9
10471: oPushResult
10472: oNodeSet
10473: oPop 3
10475: oGetLocal 1
10477: oPushResult
10478: oScopeDeclare
10479: oPop 1
10481: oGetAddrLocal 1
10483: oPushResult
10484: oSetResult 18
10486: oPushResult
10487: oIdAdd_String
10488: oPushResult
10489: oCall 9882
10491: oPop 2
10493: oAssign
10494: oGetLocal 1
10496: oPushResult
10497: oSetResult 21
10499: oPushResult
10500: oGetGlobal 10
10502: oPushResult
10503: oNodeSet
10504: oPop 3
10506: oGetLocal 1
10508: oPushResult
10509: oScopeDeclare
10510: oPop 1
10512: oGetAddrLocal 1
10514: oPushResult
10515: oSetResult 16
10517: oPushResult
10518: oIdAdd_True
10519: oPushResult
10520: oCall 9882
10522: oPop 2
10524: oAssign
10525: oGetLocal 1
10527: oPushResult
10528: oSetResult 21
10530: oPushResult
10531: oGetGlobal 6
10533: oPushResult
10534: oNodeSet
10535: oPop 3
10537: oGetLocal 1
10539: oPushResult
10540: oSetResult 22
10542: oPushResult
10543: oSetResult 1
10545: oPushResult
10546: oNodeSetInt
10547: oPop 3
10549: oGetLocal 1
10551: oPushResult
10552: oScopeDeclare
10553: oPop 1
10555: oGetAddrLocal 1
10557: oPushResult
10558: oSetResult 16
10560: oPushResult
10561: oIdAdd_False
10562: oPushResult
10563: oCall 9882
10565: oPop 2
10567: oAssign
10568: oGetLocal 1
10570: oPushResult
10571: oSetResult 21
10573: oPushResult
10574: oGetGlobal 6
10576: oPushResult
10577: oNodeSet
10578: oPop 3
10580: oGetLocal 1
10582: oPushResult
10583: oSetResult 22
10585: oPushResult
10586: oSetResult 0
10588: oPushResult
10589: oNodeSetInt
10590: oPop 3
10592: oGetLocal 1
10594: oPushResult
10595: oScopeDeclare
10596: oPop 1
10598: oGetAddrGlobal 11
10600: oPushResult
10601: oIdAdd_Ord
10602: oPushResult
10603: oCall 10200
10605: oPop 1
10607: oAssign
10608: oGetAddrGlobal 12
10610: oPushResult
10611: oIdAdd_Chr
10612: oPushResult
10613: oCall 10200
10615: oPop 1
10617: oAssign
10618: oGetAddrGlobal 13
10620: oPushResult
10621: oIdAdd_Pred
10622: oPushResult
10623: oCall 10200
10625: oPop 1
10627: oAssign
10628: oGetAddrGlobal 14
10630: oPushResult
10631: oIdAdd_Succ
10632: oPushResult
10633: oCall 10200
10635: oPop 1
10637: oAssign
10638: oReturn
