   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions.  make room in the actual params space for the result value.
      %      Function body will assign value there.  Caller will pick it up and
      %      push onto expr stack.
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Non-ISO extensions.  Look at "Units" e.g. from Turbo Pascal wikipedia page.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstP       % <ptr> - push constant ptr value
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncGlobalI       % <ptr> - increment int value pointed to by ptr
   2:    tDecGlobalI       % <ptr> - decrement int value pointed to by ptr
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddI  
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % addr follows
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node )                % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, out int addr );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: VarLValue( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by jumping to the main program statement
  12:    int patchJumpMain
  12:    .tJump 
  14:    patchJumpMain = Here
  19:    .tSpace
      
  21:    pProgram
  23:    pIdent
      
  25:    t = @newIdent( nProgram, kProgram, LAST_ID )
  41:    oScopeDeclare( t )
      
  47:    [
  47:       | '(' :
  49:          pIdent      % input, output files
      
  51:          t = @newIdent( nVar, kVar, LAST_ID )
  67:          oNodeSet( t, qType, FileType )
  79:          oScopeDeclareAlloc( t )
      
  85:          ','
  87:          pIdent
      
  89:          t = @newIdent( nVar, kVar, LAST_ID )
 105:          oNodeSet( t, qType, FileType )
 117:          oScopeDeclareAlloc( t )
      
 123:          ')'
 125:       | * :
 130:    ]
 130:    ';'
      
 132:    int addr
 132:    @Block( nGlobalVar, addr )    % not including punctuation after body's 'end'
 142:    oPatch( patchJumpMain, addr )
      
 151:    '.'
 153:    oScopeEnd
 155:    ;
      
      
      % Returns the addr of the block's statements.
      % This might differ from the Here on entry to this rule,
      % due to method declarations in the block.
      %
 155: Block( node_type varNodeType, out int addr ):
 157:    {[
 157:       | pConst :     @ConstDecl
 161:       | pType :      @TypeDecl
 165:       | pVar :       @VarDecl( varNodeType )
 174:       | pProcedure : @ProcDecl
 178:       | pFunction :  @FuncDecl
 182:       | * :          >
 197:    ]}
 199:    addr = Here
      
         % proc/func body begins with tEnter
 204:    int patchLS
 204:    [ equal_node_type( varNodeType, nLocalVar )
 214:       | true :       .tEnter  patchLS = Here  .tSpace
 224:       | * :
 229:    ]
      
 229:    @Statement
 231:    .tReturn
      
 233:    [ equal_node_type( varNodeType, nLocalVar )
 243:       | true :
 244:          int localSpace
 244:          localSpace = oNodeGetInt( oScopeCurrent, qSize )
 256:          oPatch( patchLS, localSpace )
 265:       | * :
 270:    ];
      
      
 271: ProcDecl:
 273:    Node decl
      
 273:    pIdent
 275:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 291:    oScopeBegin
 292:    Node paramScope
 292:    paramScope = oScopeCurrent
      
 297:    @FormalArgDecl
 299:    oNodeSet( decl, qParams, paramScope )
 311:    oScopeEnd
      
 312:    oScopeDeclare( decl )
 318:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 320:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 326:    oScopeBegin
 327:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
      
 338:    int addr
 338:    @Block( nLocalVar, addr )
 348:    oNodeSet( decl, qChildScope, oScopeCurrent )
 359:    oNodeSetInt( decl, qValue, addr )
 371:    oNodeSetBoolean( decl, qAddrDefined, true )
 383:    oScopeEnd
      
 384:    oScopeEnd  % paramScope
 385:    ';';
      
 388: FuncDecl:
 390:    Node decl
 390:    Node theType
      
 390:    pIdent
 392:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 408:    oScopeBegin
 409:    Node paramScope
 409:    paramScope = oScopeCurrent
      
 414:    @FormalArgDecl
 416:    oNodeSet( decl, qParams, paramScope )
 428:    oScopeEnd
      
 429:    oScopeDeclare( decl )
 435:    ':'
      
 437:    @TypeRef( theType )
 444:    oNodeSet( decl, qType, theType )
 456:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 458:    oScopeEnter( paramScope )
      
 464:    oScopeBegin
 465:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
      
 476:    int addr
 476:    @Block( nLocalVar, addr )
 486:    oNodeSet( decl, qChildScope, oScopeCurrent )
 497:    oNodeSetInt( decl, qValue, addr )
 509:    oNodeSetBoolean( decl, qAddrDefined, true )
 521:    oScopeEnd
      
 522:    oScopeEnd  % paramScope
 523:    ';';
      
      
      % TO DO:
      %   This code is declaring params in the wrong order.
      %   Also ignoring var keyword.
      %   Also not using schema yet.
      %   Also should use a var instead of count stack.
      %
 526: FormalArgDecl:
 528:    [
 528:       | '(' :
 530:          {
 530:             NodeVec decls
 530:             decls = oNodeVecNew
 535:             Node decl
 535:             boolean isInOut
 535:             isInOut = false
      
 541:             [
 541:                | pVar : isInOut = true
 549:                | * :
 554:             ]
      
 554:             {  pIdent
      
 556:                decl = @newIdent( nParam, kVar, LAST_ID )
 572:                oNodeSetBoolean( decl, qInOut, isInOut )
 584:                oNodeVecAppend( decls, decl )
      
 593:                [
 593:                   | ':' : >
 597:                   | ',' :
 599:                ]
 607:             }
      
 609:             Node theType
 609:             @TypeRef( theType )
      
 616:             int i
 616:             i = 0
 622:             {[ equal( i, oNodeVecSize( decls ) )
 636:                | false :
 637:                   decl = oNodeVecElement( decls, i )
 650:                   oNodeSet( decl, qType, theType )
 662:                   oScopeDeclareAlloc( decl )
 668:                   inc( i )
 674:                | * :
 679:                   >
 681:             ]}
      
 683:             oNodeVecDelete( decls )
      
 689:             [
 689:                | ')' : >
 693:                | ';' :
 695:             ]
 703:          }
 705:       | * :
 710:    ];
      
 711: ConstDecl:
 713:    {[
 713:       | pIdent :
 715:          Node decl
 715:          decl = @newIdent( nConst, kConst, LAST_ID )
 731:          '='
      
 733:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 735:          int val
 735:          val = oValueTop
 740:          oValuePop
 741:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 753:          oNodeSet( decl, qType, IntegerType )
      
 765:          oScopeDeclare( decl )
 771:          ';'
 773:       | * :
 778:          >
 780:    ]};
      
 783: TypeDecl:
 785:    {[
 785:       | pIdent :
 787:          Node decl
 787:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 803:          '='
 805:          Node theType
 805:          @TypeRef( theType )
 812:          oNodeSet( decl, qType, theType )
 824:          oScopeDeclare( decl )
 830:          ';'
 832:       | * :
 837:          >
 839:    ]};
      
 842: VarDecl( node_type varNodeType ):
 844:    {[
 844:       | pIdent :
 846:          NodeVec decls
 846:          decls = oNodeVecNew
 851:          Node decl
 851:          {
 851:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 867:             oNodeVecAppend( decls, decl )
 876:             [
 876:                | ',' :
 878:                   pIdent
 880:                | * :
 885:                   >
 887:             ]
 887:          }
 889:          ':'
 891:          Node theType
 891:          @TypeRef( theType )
      
 898:          int i
 898:          i = 0
 904:          {[ equal( i, oNodeVecSize( decls ) )
 918:            | false :
 919:              decl = oNodeVecElement( decls, i )
 932:              oNodeSet( decl, qType, theType )
 944:              oScopeDeclareAlloc( decl )
 950:              inc( i )
 956:             | * :
 961:               >
 963:          ]}
      
 965:          oNodeVecDelete( decls )
 971:          ';'
 973:       | * :
 978:          >
 980:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
 983: TypeRef( out Node resultType ):
 985:    [
 985:       | pIdent :           % previously named type (including intrinsics)
 987:          Node decl
 987:          decl = oScopeFindRequire
 992:          [ oNodeType( decl )
 999:            | nTypeDecl :
1000:                resultType = oNodeGet( decl, qType )
1013:            | * :
1018:                #eNotType
1020:                resultType = IntegerType
1026:          ]
         
1026:       | pArray :
1028:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1030:          NodeVec dimensions
1030:          dimensions = oNodeVecNew
      
1035:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1035:             Node subrange
1035:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1045:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1057:             @ConstExpr
1059:             oNodeSetInt( subrange, qLow, oValueTop )
1070:             oValuePop
1071:             '..'
1073:             @ConstExpr
1075:             oNodeSetInt( subrange, qHigh, oValueTop )
1086:             oValuePop
1087:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1099:             oTypeAdd( subrange )
      
1105:             Node a
1105:             a = oNodeNew( nArrayType )
1115:             oNodeSet( a, qIndexType, subrange )
      
1127:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1136:             [
1136:                | ']' : >
1140:                | ',' :
1142:             ]
1150:          }
1152:          pOf
1154:          Node baseType
1154:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1161:          int dim
1161:          dim = oNodeVecSize( dimensions )
1171:          {
1171:              dec(dim)
      
1177:              Node a
1177:              a = oNodeVecElement( dimensions, dim )
1190:              oNodeSet( a, qBaseType, baseType )
1202:              Node subrange
1202:              subrange = oNodeGet( a, qIndexType )
1215:              int width
1215:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1242:              inc( width )
1248:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1274:              oTypeAdd( a )
1280:              baseType = a
      
1286:              [ equal_zero(dim)
1293:                  | true:  >
1296:                  | *:
1301:              ]
1301:          }
      
1303:          resultType = oNodeVecElement( dimensions, 0 )
1316:          oNodeVecDelete( dimensions )
      
1322:       | '^' :
1324:          Node theType
1324:          @TypeRef( theType )
1331:          resultType = @PointerTypeTo( theType )
      
1342:       | pRecord :
1344:          resultType = oNodeNew( nRecordType )
1354:          oScopeBegin
      
1355:          @VarDecl( nRecordField )
      
1362:          int size
1362:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1374:          [ equal_zero( size )
1381:             | true : #eRecordEmpty
1384:             | * :
1389:          ]
      
1389:          pEnd
      
1391:          oNodeSet( resultType, qScope, oScopeCurrent )
1402:          oNodeSetInt( resultType, qSize, size )
1414:          oScopeEnd
1415:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1421:       | pSet :
1423:          pOf
1425:          Node theType
1425:          @TypeRef( theType )
1432:       | * :       % this works for cases except where expr starts with an id
1445:          @ConstExpr '..' @ConstExpr
1451:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1452: ConstExpr:
1454:    [
1454:       | pIntLit :
1456:          oValuePush( TOKEN_VALUE )
1461:       | pIdent :
1463:          Node decl
1463:          decl = oScopeFindRequire
1468:          [ oNodeType( decl )
1475:             | nConst :
1476:                oValuePush( oNodeGetInt( decl, qValue ) )
1489:             | * :
1494:                #eNotConst
1496:                oValuePush( 0 )
1502:          ]
1502:       | pMinus :
1504:          @ConstExpr
1506:          oValueNegate
1507:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1518: Expr:
1520:    @BoolExpr
1522:    {[
1522:       | '=' :
1524:          @BoolExpr
1526:          @MatchTypes
1528:          [ oTypeSNodeType
1530:             | nIntegerType, nBooleanType :  .tEqualI
1533:             | nPointerType :                .tEqualP
1537:             | nCharType, nStringType :      #eNotImplemented
1541:             | * :                           #eNotAllowed
1556:          ]
1556:          oTypeSPop
1557:          oTypeSPush( BooleanType )
      
1563:       | '<>' :
1565:          @BoolExpr
1567:          @MatchTypes
1569:          [ oTypeSNodeType
1571:             | nIntegerType, nBooleanType :  .tNotEqualI
1574:             | nPointerType :                .tNotEqualP
1578:             | nCharType, nStringType :      #eNotImplemented
1582:             | * :                           #eNotAllowed
1597:          ]
1597:          oTypeSPop
1598:          oTypeSPush( BooleanType )
      
1604:       | '<' :
1606:          @BoolExpr
1608:          @MatchTypes
1610:          [ oTypeSNodeType
1612:             | nIntegerType, nBooleanType :  .tLessI
1615:             | nCharType, nStringType :      #eNotImplemented
1619:             | * :                           #eNotAllowed
1632:          ]
1632:          oTypeSPop
1633:          oTypeSPush( BooleanType )
      
1639:       | '>' :
1641:          @BoolExpr
1643:          @MatchTypes
1645:          [ oTypeSNodeType
1647:             | nIntegerType, nBooleanType :  .tGreaterI
1650:             | nCharType, nStringType :      #eNotImplemented
1654:             | * :                           #eNotAllowed
1667:          ]
1667:          oTypeSPop
1668:          oTypeSPush( BooleanType )
      
1674:       | '<=' :
1676:          @BoolExpr
1678:          @MatchTypes
1680:          [ oTypeSNodeType
1682:             | nIntegerType, nBooleanType :  .tLessEqualI
1685:             | nCharType, nStringType :      #eNotImplemented
1689:             | * :                           #eNotAllowed
1702:          ]
1702:          oTypeSPop
1703:          oTypeSPush( BooleanType )
      
1709:       | '>=' :
1711:          @BoolExpr
1713:          @MatchTypes
1715:          [ oTypeSNodeType
1717:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1720:             | nCharType, nStringType :      #eNotImplemented
1724:             | * :                           #eNotAllowed
1737:          ]
1737:          oTypeSPop
1738:          oTypeSPush( BooleanType )
      
1744:       | * :
1759:          >
1761:    ]};
      
1764: BoolExpr:
1766:    @BoolTerm
1768:    {[
1768:       | pOr :
1770:          @RequireBoolPop
1772:          @BoolTerm
1774:          @RequireBool
1776:          .tOr
1778:       | * :
1783:          >
1785:    ]};
      
1788: BoolTerm:
1790:    @BoolFactor
1792:    {[
1792:       | pAnd :
1794:          @RequireBoolPop
1796:          @BoolFactor
1798:          @RequireBool
1800:          .tAnd
1802:       | * :
1807:          >
1809:    ]};
      
1812: BoolFactor:
1814:    [
1814:       | pNot :
1816:          @ArithExpr
1818:          @RequireBool
1820:          .tNot
1822:       | * :
1827:          @ArithExpr
1829:    ];
      
1830: ArithExpr:
1832:    @Term
1834:    {[
1834:       | pPlus :
1836:          @RequireIntPop
1838:          @Term
1840:          @RequireInt
1842:          .tAddI
1844:       | pMinus :
1846:          @RequireIntPop
1848:          @Term
1850:          @RequireInt
1852:          .tSubI
1854:       | * :
1861:          >
1863:    ]};
      
1866: Term:
1868:    @Factor
1870:    {[
1870:       | pTimes :
1872:          @RequireIntPop
1874:          @Factor
1876:          @RequireInt
1878:          .tMultI
1880:       | pDivide :
1882:          @RequireIntPop
1884:          @Factor
1886:          @RequireInt
1888:          .tDivI
1890:       | * :
1897:          >
1899:    ]};
      
1902: Factor:
1904:    [
1904:       | pPlus :
1906:          @Primary
1908:          @RequireInt
1910:       | pMinus :
1912:          @Primary
1914:          @RequireInt
1916:          .tNegI
1918:       | * :
1925:          @Primary
1927:    ];
      
1928: Primary:
1930:    [
1930:       | pIntLit :
1932:          .tPushConstI  oEmitInt( TOKEN_VALUE )
1939:          oTypeSPush( IntegerType )
      
1945:       | '(' :
1947:          @Expr
1949:          ')'
      
1951:       | pStrLit :
1953:          oStringAllocLit     % store, put addr on value stack
1954:          .tPushConstP oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
1962:          oTypeSPush( StringType )
      
1968:       | pIdent :
1970:          Node decl
1970:          Node theType
1970:          decl = oScopeFindRequire
      
1975:          [ oNodeType( decl )
1982:             | nFunc :
      
1983:                @Call( decl )
      
1990:             | nConst :
1992:                theType = oNodeGet( decl, qType )
2005:                oTypeSPush( theType )
2011:                [ oTypeSNodeType
2013:                   | nIntegerType, nBooleanType :
2014:                      .tPushConstI @EmitValue( decl )
2023:                   | * :
2030:                      #eNotImplemented
2032:                ]
      
2032:             | nGlobalVar, nLocalVar, nParam :
2034:                @VarExpr( decl )
      
2041:             | * :
2054:                #eNotValue
2056:                oTypeSPush( IntegerType )
2062:          ]
      
2062:       | '^' :        % ^var
2064:          pIdent
      
2066:          Node decl
2066:          Node theType
2066:          decl = oScopeFindRequire
      
2071:          @VarLValue( decl )
      
               % The above leaves the pointed-to type on type stack.
               % But our expression type is actually ptr-to-<type>.
2078:          theType = oTypeSTop
2083:          oTypeSPop
2084:          Node ptrType
2084:          ptrType = @PointerTypeTo( theType )
2095:          oTypeSPush( ptrType )
      
2101:       | * :
2114:          #eNotValue
2116:          oTypeSPush( IntegerType )
2122:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2123: VarExpr( Node decl ):
2125:    Node theType
2125:    theType = oNodeGet( decl, qType )
2138:    oTypeSPush( theType )
2144:    [ oTypeSNodeType
2146:       | nIntegerType :
2147:          [ oNodeType( decl )
2154:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2164:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2175:             | nParam :       .tPushParamI @EmitValue( decl )
                           % TO DO:   VAR params may need adjustment? (also cases below...)
2186:          ]
      
2196:       | nBooleanType :
2198:          [ oNodeType( decl )
2205:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2215:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2226:             | nParam :       .tPushParamB @EmitValue( decl )
2237:          ]
      
2247:       | nCharType, nStringType, nFileType :
2249:          #eNotImplemented
      
2251:       | nPointerType :
2253:          [ oNodeType( decl )
2260:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2270:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2281:             | nParam :       .tPushParamP @EmitValue( decl )
2292:          ]
2302:          [
2302:             | '^' :             % dereferenced
2304:                oTypeSPop
2305:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2318:                @LValue
2320:                @FetchVar
2322:             | * :               % just ptr value alone
2327:          ]
      
2327:       | * :
               % compound type
               % first, push addr of start of var
2342:          [ oNodeType( decl )
2349:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2359:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2370:             | nParam :       .tPushAddrParam @EmitValue( decl )
2381:          ]
               % modify addr for subscripts, field references, etc
2391:          @LValue
               % get final value
2393:          @FetchVar
2395:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2396: FetchVar:
2398:    [ oTypeSNodeType
2400:       | nIntegerType :   .tFetchI
2403:       | nBooleanType :   .tFetchB
2407:       | nCharType, nStringType, nFileType : #eNotImplemented
2411:       | nPointerType :   .tFetchP
2415:       | * :              % compound type; leave as addr
2430:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, etc, to get final addr on run stack, and final type
      % on type stack.
      
2431: LValue:
2433:    {[
2433:       | '[' :       @ArraySubscripts
2437:       | '.' :       @RecordFieldRef
2441:       | '^' :       @PointerDeref
2445:       | * :         >
2456:    ]};
      
2459: ArraySubscripts:
2461:    [ oTypeSNodeType
2463:       | nArrayType :
2464:       | * :       #eNotArray
2471:    ]
2471:    {
2471:       [ oTypeSNodeType
2473:          | nArrayType :
2474:          | * :    #eTooManySubscripts
2481:       ]
      
            % low subscript of this dimension
2481:       int low
2481:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2498:       Node baseType
2498:       baseType = oNodeGet( oTypeSTop, qBaseType )
2510:       oTypeSPop
2511:       oTypeSPush( baseType )
      
2517:       @Expr
2519:       @RequireIntPop
            % adjust for low subscript
2521:       [ equal_zero( low )
2528:          | false :
2529:             .tPushConstI oEmitInt( low ) .tSubI
2539:          | * :
2544:       ]
      
            % multiply by element size
2544:       int size
2544:       size = oNodeGetInt( baseType, qSize )
2557:       [ equal( size, 1 )
2567:          | false :
2568:             .tPushConstI oEmitInt( size ) .tMultI
2578:          | * :
2583:       ]
      
            % update start address
2583:       .tAddI
2585:       [
2585:          | ']' :  >
2589:          | ',' :
2591:       ]
2599:    };
      
      
2602: RecordFieldRef:
2604:    [ oTypeSNodeType
2606:       | nRecordType :
2607:       | * :    #eNotRecord
2614:    ]
2614:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2626:    pIdent
2628:    Node field
2628:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2633:    [ oNodeType( field )
2640:       | nRecordField :
2641:       | * :   #eNotRecordField
2648:    ]
2648:    oScopeEnd
2649:    int offset
2649:    offset = oNodeGetInt( field, qValue )
2662:    [ equal_zero( offset )
2669:       | false :
2670:          .tPushConstI oEmitInt( offset ) .tAddI
2680:       | * :
2685:    ]
      
         % replace the type on the type stack, with the field type
2685:    oTypeSPop
2686:    oTypeSPush( oNodeGet( field, qType ) )
2700:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2700: PointerDeref:
2702:    [ oTypeSNodeType
2704:       | nPointerType :
2705:       | * :       #eNotPointer
2712:    ]
2712:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2714:    Node theType
2714:    theType = oTypeSTop
2719:    oTypeSPop
2720:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2734:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2734: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2736:    @MatchTypes
2739:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2739: Call( Node method ):
      
2741:    Node paramScope
2741:    paramScope = oNodeGet( method, qParams )
2754:    int actualsSize
2754:    actualsSize = oNodeGetInt( paramScope, qSize )
2767:    .tAllocActuals  oEmitInt( actualsSize )
      
2775:    Node param
2775:    param = oNodeGet( paramScope, qDecls )
2788:    [
2788:       | '(' :
            
2790:          {
2790:             [ oNodeNull( param )
2797:                | true : >
2800:                | * :
2805:             ]
      
2805:             Node actualType
2805:             actualType = oNodeGet( param, qType )
2818:             int offset
2818:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
2831:             .tPushAddrActual oEmitInt( offset )
2839:             oTypeSPush( oNodeGet( param, qType ) )
      
2852:             [ oNodeGetBoolean( param, qInOut )
2862:                | true :
                                % I need something like @LvalueExpr
                                % that parses expr, generating code to push addr, and push type on type stack.
                                % Close to what I have but need to refactor.
2863:                           #eNotImplemented
                                % TO DO: match types more exactly. not sufficient to be assign compatible
                                %        since the method will be assigning to the actual using the param type.
                                %        Maybe something like type contents must match, incl subrange bounds.
2865:                           .tAssignP
      
2867:                | false :  @Expr
2871:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
2873:                           [ oTypeSNodeType
2875:                              | nIntegerType :            .tAssignI
2878:                              | nBooleanType :            .tAssignB
2882:                              | nCharType, nStringType, nFileType :   #eNotImplemented
2886:                              | nPointerType :            .tAssignP
2890:                              | * :
                                       % compound types: copy value into actuals space
2905:                                  int size
2905:                                  size = oNodeGetInt( oTypeSTop, qSize )
2917:                                  .tCopy  oEmitInt( size )    % multi-word copy
2925:                           ]
2925:             ]
      
2933:             oNodeNext( param )
2939:             [ oNodeNull( param )
2946:                | true :  >
2949:                | false :
2951:             ]
      
2959:             ','
2961:          }
      
2963:          ')'
      
2965:       | * :
2970:          [ oNodeNull( param )
2977:             | false :    #eMissingParameter
2980:             | * :
2985:          ]
2985:    ]
      
2985:    .tCall   @EmitValue( method )
      
2994:    [ oNodeType( method )
3001:       | nFunc :
               % TO DO: push return value from actuals space
3002:          oTypeSPush( oNodeGet( method, qType ) )
3015:       | * :
3020:    ]
         
3020:    .tFreeActuals  oEmitInt( actualsSize )
3029:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3029: Statement:
3031:    [
3031:       | pWriteln :     @WritelnStmt
3035:       | pWrite :       @WriteStmt
3039:       | pReadln :      @ReadlnStmt
3043:       | pRead :        @ReadStmt
3047:       | pIf :          @IfStmt
3051:       | pWhile :       @WhileStmt
3055:       | pFor :         @ForStmt
3059:       | pRepeat :      @RepeatStmt
3063:       | pExit :        @ExitStmt
3067:       | pCycle :       @CycleStmt
3071:       | pBegin :       @BeginStmt
3075:       | pIdent :       @AssignOrCallStmt
3079:       | * :            % null statement : don't accept any tokens
3106:    ];
      
      
3107: AssignOrCallStmt:
3109:    Node decl
3109:    decl = oScopeFindRequire
3114:    [ oNodeType( decl )
3121:       | nProc :                           @Call( decl )
3129:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3138:       | * :                               #eBadStatement
3151:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3152: AssignStmt( Node decl ):
      
3154:    @VarLValue( decl )
      
3161:    ':=' 
3163:    @Expr
3165:    @MatchTypes
3167:    [ oTypeSNodeType
3169:       | nIntegerType :            .tAssignI
3172:       | nBooleanType :            .tAssignB
3176:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3180:       | nPointerType :            .tAssignP
3184:       | * :
3199:           int size
3199:           size = oNodeGetInt( oTypeSTop, qSize )
3211:           .tCopy  oEmitInt( size )    % multi-word copy
3219:    ]
3219:    oTypeSPop
3221:    ;
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that stars with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack, and the type on the type stack.
      %
3221: VarLValue( Node decl ):
3223:    [ oNodeType( decl )
3230:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3240:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3251:       | nParam :       .tPushAddrParam @EmitValue( decl )
                % TO DO:   VAR params may need adjustment?
3262:       | * :            #eNotVar
3273:    ]
      
3273:    oTypeSPush( oNodeGet( decl, qType ) )
3286:    @LValue        % handle subscripts, if any
3289:    ;
      
      
3289: IfStmt:
3291:    @Expr
3293:    @RequireBoolPop
3295:    pThen
3297:    .tJumpFalse
3299:    oPatchPushHere(patchIf)
3305:    .tSpace
3307:    @Statement
3309:    [
3309:       | pElse :
3311:          .tJump
3313:          oPatchPushHere(patchIf)
3319:          .tSpace
3321:          oPatchSwap(patchIf)
3327:          oPatchPopFwd(patchIf)
3333:          @Statement
3335:       | * :
3340:    ]
3340:    oPatchPopFwd(patchIf);
      
3347: ForStmt:
3349:    pIdent
      
3351:    Node decl
3351:    decl = oScopeFindRequire
3356:    [ oNodeType( decl )
3363:       | nGlobalVar :
3364:       | nLocalVar :    #eNotImplemented
3368:       | nParam :       #eNotImplemented
3372:       | * :            #eNotIntVar
3383:    ]
3383:    oTypeSPush( oNodeGet( decl, qType ) )
3396:    @RequireIntPop
3398:    .tPushConstP  @EmitValue( decl )
      
3407:    ':='
      
3409:    @Expr
3411:    @RequireIntPop
3413:    .tAssignI
      
3415:    .tJump oPatchPushHere(patchLoop) .tSpace
3425:    oPatchPushHere(patchLoop)
3431:    oPatchSwap(patchLoop)
3437:    [
3437:       | pTo :
3439:          .tIncGlobalI @EmitValue( decl )
3448:          oPatchPopFwd(patchLoop)
3454:          .tPushGlobalI @EmitValue( decl )
3463:          @Expr
3465:          @RequireIntPop
3467:          .tGreaterI
3469:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3479:          oPatchSwap(patchLoop)
3485:       | pDownto :
3487:          .tDecGlobalI @EmitValue( decl )
3496:          oPatchPopFwd(patchLoop)
3502:          .tPushGlobalI @EmitValue( decl )
3511:          @Expr
3513:          @RequireIntPop
3515:          .tLessI
3517:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
3527:          oPatchSwap(patchLoop)
3533:    ]
3541:    oCountPush(0)          % count 'exit' patches
3547:    pDo
3549:    @Statement
3551:    .tJump oPatchPopBack(patchLoop)
3559:    oPatchPopFwd(patchLoop)
3565:    @PatchExitsPop;
      
3568: RepeatStmt:
3570:    oPatchPushHere(patchLoop) % start of loop
3576:    oCountPush(0)          % count the 'exit' patches
3582:    @Statement
3584:    {[
3584:       | ';' :
3586:          @Statement
3588:       | pUntil :
3590:          @Expr
3592:          @RequireBoolPop
3594:          .tJumpFalse
3596:          oPatchPopBack(patchLoop)
3602:          @PatchExitsPop
3604:          >
3606:    ]};
      
3617: WhileStmt:
3619:    oPatchPushHere(patchLoop)    % start of loop
3625:    oCountPush(0)
3631:    @Expr
3633:    @RequireBoolPop
3635:    pDo
3637:    .tJumpFalse
3639:    oPatchPushHere(patchLoop)    % jump out
3645:    .tSpace
3647:    oPatchSwap(patchLoop)        % start on top
3653:    @Statement
3655:    .tJump
3657:    oPatchPopBack(patchLoop)
3663:    oPatchPopFwd(patchLoop)
3669:    @PatchExitsPop;
      
3672: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
3674:    [ oPatchAnyEntries(patchLoop)
3681:       | true :
3682:          .tJump
3684:          oPatchDup(patchLoop)  % addr of start
3690:          oPatchPopBack(patchLoop)
3696:       | * :
3701:          #eNotInALoop
3703:    ];
      
3704: ExitStmt:
3706:    [ oPatchAnyEntries(patchLoop)
3713:       | true :
3714:          .tJump
3716:          oPatchPushHere(patchExit)
3722:          .tSpace
3724:          oCountInc
3725:       | * :
3730:          #eNotInALoop
3732:    ];
      
3733: BeginStmt:
3735:    @Statement
3737:    {[
3737:       | ';' :   @Statement
3741:       | pEnd :  >
3745:    ]};
      
3756: WritelnStmt:
3758:    @WriteStmt
3760:    .tWriteCR;
      
3763: WriteStmt:
3765:    [
3765:       | '(' :
3767:          {
3767:             @Expr
3769:             [ oTypeSNodeType
3771:                | nIntegerType :             .tWriteI
3774:                | nBooleanType :             .tWriteBool
3778:                | nStringType :              .tWriteStr
3782:                | nCharType, nFileType :     #eNotImplemented
3786:                | nPointerType :             .tWriteP
3790:                | * :                        #eNotAllowed
3807:             ]
3807:             oTypeSPop
3808:             [
3808:                | ')' : >
3812:                | ',' :
3814:             ]
3822:          }
3824:       | * :
3829:    ];
      
      
3830: ReadlnStmt:      % ***
3833:    ;
3833: ReadStmt:
3836:    ;
      
      % -------------------------------- Utilities -------------------------------
      
3836: PatchExitsPop:
3838:    {[ oCountIsZero
3840:       | false : oPatchPopFwd(patchExit)
3847:                 oCountDec
3848:       | * :     >
3855:    ]}
3857:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
3859: MatchTypes:
3861:    node_type nt
3861:    nt = oTypeSNodeType
3866:    oTypeSPop
3867:    [ equal_node_type( nt, oTypeSNodeType )
3876:       | false :
3877:          #eTypeMismatch
3879:       | * :
3884:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
3885: RequireIntPop:
3887:    [ oTypeSNodeType
3889:       | nIntegerType :
3890:       | * :          #eNotInteger
3897:    ]
3897:    oTypeSPop;
      
3899: RequireInt:
3901:    [ oTypeSNodeType
3903:       | nIntegerType :
3904:       | * :          #eNotInteger
3911:    ];
      
3912: RequireBoolPop:
3914:    [ oTypeSNodeType
3916:       | nBooleanType :
3917:       | * :          #eNotBoolean
3924:    ]
3924:    oTypeSPop;
      
3926: RequireBool:
3928:    [ oTypeSNodeType
3930:       | nBooleanType :
3931:       | * :          #eNotBoolean
3938:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
3939: newType( node_type nt, int size ) >> Node:
3941:   Node node
3941:   node = oNodeNew( nt )
3951:   oNodeSetInt( node, qSize, size )
3963:   oTypeAdd( node )
3969:   >> node
3973:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
3973: newIdent( node_type nt, kind k, int id ) >> Node:
3975:   Node t
3975:   t = oNodeNew( nt )
3985:   oNodeSetKind( t, qKind, k )   % deprecated attribute
3997:   oNodeSetInt( t, qIdent, id )
4009:   >> t
4013:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
4013: PointerTypeTo( Node theType ) >> Node:
4015:    Node ptrType
4015:    ptrType = oNodeGet( theType, qPointerType )
4028:    [ oNodeNull( ptrType )
4035:       | true :
4036:          ptrType = oNodeNew( nPointerType )
4046:          oNodeSet( ptrType, qBaseType, theType )
4058:          oNodeSetInt( ptrType, qSize, 8 )
4070:          oTypeAdd( ptrType )
4076:          oNodeSet( theType, qPointerType, ptrType )
4088:       | * :
4093:    ]
4093:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4097: OrdinalLow( Node theType ) >> int:
4099:    [ oNodeType( theType )
4106:       | nIntegerType :  >> -2147483648
4110:       | nBooleanType :  >> 0
4115:       | nCharType :     >> 0
4120:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4132:       | * :             #eNotOrdinalType
4145:                         >> 0
4148:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4149: EmitValue( Node decl ):
4151:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4165: installBuiltIns:
      
         % install built-in types
4167:    FileType = @newType( nFileType, 4 )
4181:    IntegerType = @newType( nIntegerType, 4 )
4195:    BooleanType = @newType( nBooleanType, 1 )
4209:    CharType = @newType( nCharType, 1 )
4223:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4237:    Node t
      
4237:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4253:    oNodeSet( t, qType, FileType )
4265:    oScopeDeclare( t )
      
4271:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4287:    oNodeSet( t, qType, IntegerType )
4299:    oScopeDeclare( t )
      
4305:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4321:    oNodeSet( t, qType, BooleanType )
4333:    oScopeDeclare( t )
      
4339:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4355:    oNodeSet( t, qType, CharType )
4367:    oScopeDeclare( t )
      
4373:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4389:    oNodeSet( t, qType, StringType )
4401:    oScopeDeclare( t )
      
         % Built-in constants
      
4407:    t = @newIdent( nConst, kConst, oIdAdd_True )
4423:    oNodeSet( t, qType, BooleanType )
4435:    oNodeSetInt( t, qValue, 1 )
4447:    oScopeDeclare( t )
      
4453:    t = @newIdent( nConst, kConst, oIdAdd_False )
4469:    oNodeSet( t, qType, BooleanType )
4481:    oNodeSetInt( t, qValue, 0 )
4493:    oScopeDeclare( t )
      
4500:    ;
      
4500: end
      
4500: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4165
  12: oEmit 45
  14: oGetAddrLocal 2
  16: oPushResult
  17: Here
  18: oAssign
  19: oEmit 53
  21: oInput 26
  23: oInput 0
  25: oGetAddrLocal 1
  27: oPushResult
  28: oSetResult 5
  30: oPushResult
  31: oSetResult 1
  33: oPushResult
  34: LAST_ID
  35: oPushResult
  36: oCall 3973
  38: oPop 3
  40: oAssign
  41: oGetLocal 1
  43: oPushResult
  44: oScopeDeclare
  45: oPop 1
  47: oInputChoice 127
  49: oInput 0
  51: oGetAddrLocal 1
  53: oPushResult
  54: oSetResult 11
  56: oPushResult
  57: oSetResult 6
  59: oPushResult
  60: LAST_ID
  61: oPushResult
  62: oCall 3973
  64: oPop 3
  66: oAssign
  67: oGetLocal 1
  69: oPushResult
  70: oSetResult 6
  72: oPushResult
  73: oGetGlobal 2
  75: oPushResult
  76: oNodeSet
  77: oPop 3
  79: oGetLocal 1
  81: oPushResult
  82: oScopeDeclareAlloc
  83: oPop 1
  85: oInput 12
  87: oInput 0
  89: oGetAddrLocal 1
  91: oPushResult
  92: oSetResult 11
  94: oPushResult
  95: oSetResult 6
  97: oPushResult
  98: LAST_ID
  99: oPushResult
 100: oCall 3973
 102: oPop 3
 104: oAssign
 105: oGetLocal 1
 107: oPushResult
 108: oSetResult 6
 110: oPushResult
 111: oGetGlobal 2
 113: oPushResult
 114: oNodeSet
 115: oPop 3
 117: oGetLocal 1
 119: oPushResult
 120: oScopeDeclareAlloc
 121: oPop 1
 123: oInput 14
 125: oJumpForward 130
 127: Choice Lookup Table
          13     49
 130: oInput 4
 132: oSetResult 12
 134: oPushResult
 135: oGetAddrLocal 3
 137: oPushResult
 138: oCall 155
 140: oPop 2
 142: oGetLocal 2
 144: oPushResult
 145: oGetLocal 3
 147: oPushResult
 148: oPatch
 149: oPop 2
 151: oInput 18
 153: oScopeEnd
 154: oReturn
 155: oLocalSpace 2
 157: oInputChoice 184
 159: oCall 711
 161: oJumpForward 197
 163: oCall 783
 165: oJumpForward 197
 167: oGetParam 2
 169: oPushResult
 170: oCall 842
 172: oPop 1
 174: oJumpForward 197
 176: oCall 271
 178: oJumpForward 197
 180: oCall 388
 182: oJumpForward 197
 184: Choice Lookup Table
          28    180
          27    176
          31    167
          30    163
          29    159
 195: oJumpForward 199
 197: oJumpBack 157
 199: oGetParam 1
 201: oPushResult
 202: Here
 203: oAssign
 204: oGetParam 2
 206: oPushResult
 207: oSetResult 13
 209: oPushResult
 210: equal_node_type
 211: oPop 2
 213: oChoice 226
 215: oEmit 44
 217: oGetAddrLocal 1
 219: oPushResult
 220: Here
 221: oAssign
 222: oEmit 53
 224: oJumpForward 229
 226: Choice Lookup Table
           1    215
 229: oCall 3029
 231: oEmit 43
 233: oGetParam 2
 235: oPushResult
 236: oSetResult 13
 238: oPushResult
 239: equal_node_type
 240: oPop 2
 242: oChoice 267
 244: oGetAddrLocal 2
 246: oPushResult
 247: oScopeCurrent
 248: oPushResult
 249: oSetResult 2
 251: oPushResult
 252: oNodeGetInt
 253: oPop 2
 255: oAssign
 256: oGetLocal 1
 258: oPushResult
 259: oGetLocal 2
 261: oPushResult
 262: oPatch
 263: oPop 2
 265: oJumpForward 270
 267: Choice Lookup Table
           1    244
 270: oReturn
 271: oLocalSpace 3
 273: oInput 0
 275: oGetAddrLocal 1
 277: oPushResult
 278: oSetResult 7
 280: oPushResult
 281: oSetResult 2
 283: oPushResult
 284: LAST_ID
 285: oPushResult
 286: oCall 3973
 288: oPop 3
 290: oAssign
 291: oScopeBegin
 292: oGetAddrLocal 2
 294: oPushResult
 295: oScopeCurrent
 296: oAssign
 297: oCall 526
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 9
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oScopeEnd
 312: oGetLocal 1
 314: oPushResult
 315: oScopeDeclare
 316: oPop 1
 318: oInput 4
 320: oGetLocal 2
 322: oPushResult
 323: oScopeEnter
 324: oPop 1
 326: oScopeBegin
 327: oScopeCurrent
 328: oPushResult
 329: oSetResult 3
 331: oPushResult
 332: oSetResult 1
 334: oPushResult
 335: oNodeSetBoolean
 336: oPop 3
 338: oSetResult 13
 340: oPushResult
 341: oGetAddrLocal 3
 343: oPushResult
 344: oCall 155
 346: oPop 2
 348: oGetLocal 1
 350: oPushResult
 351: oSetResult 10
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oNodeSet
 357: oPop 3
 359: oGetLocal 1
 361: oPushResult
 362: oSetResult 8
 364: oPushResult
 365: oGetLocal 3
 367: oPushResult
 368: oNodeSetInt
 369: oPop 3
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 11
 376: oPushResult
 377: oSetResult 1
 379: oPushResult
 380: oNodeSetBoolean
 381: oPop 3
 383: oScopeEnd
 384: oScopeEnd
 385: oInput 4
 387: oReturn
 388: oLocalSpace 4
 390: oInput 0
 392: oGetAddrLocal 1
 394: oPushResult
 395: oSetResult 8
 397: oPushResult
 398: oSetResult 3
 400: oPushResult
 401: LAST_ID
 402: oPushResult
 403: oCall 3973
 405: oPop 3
 407: oAssign
 408: oScopeBegin
 409: oGetAddrLocal 3
 411: oPushResult
 412: oScopeCurrent
 413: oAssign
 414: oCall 526
 416: oGetLocal 1
 418: oPushResult
 419: oSetResult 9
 421: oPushResult
 422: oGetLocal 3
 424: oPushResult
 425: oNodeSet
 426: oPop 3
 428: oScopeEnd
 429: oGetLocal 1
 431: oPushResult
 432: oScopeDeclare
 433: oPop 1
 435: oInput 11
 437: oGetAddrLocal 2
 439: oPushResult
 440: oCall 983
 442: oPop 1
 444: oGetLocal 1
 446: oPushResult
 447: oSetResult 6
 449: oPushResult
 450: oGetLocal 2
 452: oPushResult
 453: oNodeSet
 454: oPop 3
 456: oInput 4
 458: oGetLocal 3
 460: oPushResult
 461: oScopeEnter
 462: oPop 1
 464: oScopeBegin
 465: oScopeCurrent
 466: oPushResult
 467: oSetResult 3
 469: oPushResult
 470: oSetResult 1
 472: oPushResult
 473: oNodeSetBoolean
 474: oPop 3
 476: oSetResult 13
 478: oPushResult
 479: oGetAddrLocal 4
 481: oPushResult
 482: oCall 155
 484: oPop 2
 486: oGetLocal 1
 488: oPushResult
 489: oSetResult 10
 491: oPushResult
 492: oScopeCurrent
 493: oPushResult
 494: oNodeSet
 495: oPop 3
 497: oGetLocal 1
 499: oPushResult
 500: oSetResult 8
 502: oPushResult
 503: oGetLocal 4
 505: oPushResult
 506: oNodeSetInt
 507: oPop 3
 509: oGetLocal 1
 511: oPushResult
 512: oSetResult 11
 514: oPushResult
 515: oSetResult 1
 517: oPushResult
 518: oNodeSetBoolean
 519: oPop 3
 521: oScopeEnd
 522: oScopeEnd
 523: oInput 4
 525: oReturn
 526: oLocalSpace 5
 528: oInputChoice 707
 530: oGetAddrLocal 1
 532: oPushResult
 533: oNodeVecNew
 534: oAssign
 535: oGetAddrLocal 3
 537: oPushResult
 538: oSetResult 0
 540: oAssign
 541: oInputChoice 551
 543: oGetAddrLocal 3
 545: oPushResult
 546: oSetResult 1
 548: oAssign
 549: oJumpForward 554
 551: Choice Lookup Table
          31    543
 554: oInput 0
 556: oGetAddrLocal 2
 558: oPushResult
 559: oSetResult 15
 561: oPushResult
 562: oSetResult 6
 564: oPushResult
 565: LAST_ID
 566: oPushResult
 567: oCall 3973
 569: oPop 3
 571: oAssign
 572: oGetLocal 2
 574: oPushResult
 575: oSetResult 12
 577: oPushResult
 578: oGetLocal 3
 580: oPushResult
 581: oNodeSetBoolean
 582: oPop 3
 584: oGetLocal 1
 586: oPushResult
 587: oGetLocal 2
 589: oPushResult
 590: oNodeVecAppend
 591: oPop 2
 593: oInputChoice 601
 595: oJumpForward 609
 597: oJumpForward 607
 599: oJumpForward 607
 601: Choice Lookup Table
          12    599
          11    595
 606: oEndChoice
 607: oJumpBack 554
 609: oGetAddrLocal 4
 611: oPushResult
 612: oCall 983
 614: oPop 1
 616: oGetAddrLocal 5
 618: oPushResult
 619: oSetResult 0
 621: oAssign
 622: oGetLocal 5
 624: oPushResult
 625: oGetLocal 1
 627: oPushResult
 628: oNodeVecSize
 629: oPop 1
 631: oPushResult
 632: equal
 633: oPop 2
 635: oChoice 676
 637: oGetAddrLocal 2
 639: oPushResult
 640: oGetLocal 1
 642: oPushResult
 643: oGetLocal 5
 645: oPushResult
 646: oNodeVecElement
 647: oPop 2
 649: oAssign
 650: oGetLocal 2
 652: oPushResult
 653: oSetResult 6
 655: oPushResult
 656: oGetLocal 4
 658: oPushResult
 659: oNodeSet
 660: oPop 3
 662: oGetLocal 2
 664: oPushResult
 665: oScopeDeclareAlloc
 666: oPop 1
 668: oGetAddrLocal 5
 670: oPushResult
 671: inc
 672: oPop 1
 674: oJumpForward 681
 676: Choice Lookup Table
           0    637
 679: oJumpForward 683
 681: oJumpBack 622
 683: oGetLocal 1
 685: oPushResult
 686: oNodeVecDelete
 687: oPop 1
 689: oInputChoice 697
 691: oJumpForward 705
 693: oJumpForward 703
 695: oJumpForward 703
 697: Choice Lookup Table
           4    695
          14    691
 702: oEndChoice
 703: oJumpBack 530
 705: oJumpForward 710
 707: Choice Lookup Table
          13    530
 710: oReturn
 711: oLocalSpace 2
 713: oInputChoice 775
 715: oGetAddrLocal 1
 717: oPushResult
 718: oSetResult 9
 720: oPushResult
 721: oSetResult 4
 723: oPushResult
 724: LAST_ID
 725: oPushResult
 726: oCall 3973
 728: oPop 3
 730: oAssign
 731: oInput 5
 733: oCall 1452
 735: oGetAddrLocal 2
 737: oPushResult
 738: oValueTop
 739: oAssign
 740: oValuePop
 741: oGetLocal 1
 743: oPushResult
 744: oSetResult 8
 746: oPushResult
 747: oGetLocal 2
 749: oPushResult
 750: oNodeSetInt
 751: oPop 3
 753: oGetLocal 1
 755: oPushResult
 756: oSetResult 6
 758: oPushResult
 759: oGetGlobal 3
 761: oPushResult
 762: oNodeSet
 763: oPop 3
 765: oGetLocal 1
 767: oPushResult
 768: oScopeDeclare
 769: oPop 1
 771: oInput 4
 773: oJumpForward 780
 775: Choice Lookup Table
           0    715
 778: oJumpForward 782
 780: oJumpBack 713
 782: oReturn
 783: oLocalSpace 2
 785: oInputChoice 834
 787: oGetAddrLocal 1
 789: oPushResult
 790: oSetResult 10
 792: oPushResult
 793: oSetResult 5
 795: oPushResult
 796: LAST_ID
 797: oPushResult
 798: oCall 3973
 800: oPop 3
 802: oAssign
 803: oInput 5
 805: oGetAddrLocal 2
 807: oPushResult
 808: oCall 983
 810: oPop 1
 812: oGetLocal 1
 814: oPushResult
 815: oSetResult 6
 817: oPushResult
 818: oGetLocal 2
 820: oPushResult
 821: oNodeSet
 822: oPop 3
 824: oGetLocal 1
 826: oPushResult
 827: oScopeDeclare
 828: oPop 1
 830: oInput 4
 832: oJumpForward 839
 834: Choice Lookup Table
           0    787
 837: oJumpForward 841
 839: oJumpBack 785
 841: oReturn
 842: oLocalSpace 4
 844: oInputChoice 975
 846: oGetAddrLocal 1
 848: oPushResult
 849: oNodeVecNew
 850: oAssign
 851: oGetAddrLocal 2
 853: oPushResult
 854: oGetParam 1
 856: oPushResult
 857: oSetResult 6
 859: oPushResult
 860: LAST_ID
 861: oPushResult
 862: oCall 3973
 864: oPop 3
 866: oAssign
 867: oGetLocal 1
 869: oPushResult
 870: oGetLocal 2
 872: oPushResult
 873: oNodeVecAppend
 874: oPop 2
 876: oInputChoice 882
 878: oInput 0
 880: oJumpForward 887
 882: Choice Lookup Table
          12    878
 885: oJumpForward 889
 887: oJumpBack 851
 889: oInput 11
 891: oGetAddrLocal 3
 893: oPushResult
 894: oCall 983
 896: oPop 1
 898: oGetAddrLocal 4
 900: oPushResult
 901: oSetResult 0
 903: oAssign
 904: oGetLocal 4
 906: oPushResult
 907: oGetLocal 1
 909: oPushResult
 910: oNodeVecSize
 911: oPop 1
 913: oPushResult
 914: equal
 915: oPop 2
 917: oChoice 958
 919: oGetAddrLocal 2
 921: oPushResult
 922: oGetLocal 1
 924: oPushResult
 925: oGetLocal 4
 927: oPushResult
 928: oNodeVecElement
 929: oPop 2
 931: oAssign
 932: oGetLocal 2
 934: oPushResult
 935: oSetResult 6
 937: oPushResult
 938: oGetLocal 3
 940: oPushResult
 941: oNodeSet
 942: oPop 3
 944: oGetLocal 2
 946: oPushResult
 947: oScopeDeclareAlloc
 948: oPop 1
 950: oGetAddrLocal 4
 952: oPushResult
 953: inc
 954: oPop 1
 956: oJumpForward 963
 958: Choice Lookup Table
           0    919
 961: oJumpForward 965
 963: oJumpBack 904
 965: oGetLocal 1
 967: oPushResult
 968: oNodeVecDelete
 969: oPop 1
 971: oInput 4
 973: oJumpForward 980
 975: Choice Lookup Table
           0    846
 978: oJumpForward 982
 980: oJumpBack 844
 982: oReturn
 983: oLocalSpace 12
 985: oInputChoice 1434
 987: oGetAddrLocal 1
 989: oPushResult
 990: oScopeFindRequire
 991: oAssign
 992: oGetLocal 1
 994: oPushResult
 995: oNodeType
 996: oPop 1
 998: oChoice 1015
1000: oGetParam 1
1002: oPushResult
1003: oGetLocal 1
1005: oPushResult
1006: oSetResult 6
1008: oPushResult
1009: oNodeGet
1010: oPop 2
1012: oAssign
1013: oJumpForward 1026
1015: Choice Lookup Table
          10   1000
1018: oError 2
1020: oGetParam 1
1022: oPushResult
1023: oGetGlobal 3
1025: oAssign
1026: oJumpForward 1451
1028: oInput 15
1030: oGetAddrLocal 2
1032: oPushResult
1033: oNodeVecNew
1034: oAssign
1035: oGetAddrLocal 3
1037: oPushResult
1038: oSetResult 24
1040: oPushResult
1041: oNodeNew
1042: oPop 1
1044: oAssign
1045: oGetLocal 3
1047: oPushResult
1048: oSetResult 14
1050: oPushResult
1051: oGetGlobal 3
1053: oPushResult
1054: oNodeSet
1055: oPop 3
1057: oCall 1452
1059: oGetLocal 3
1061: oPushResult
1062: oSetResult 16
1064: oPushResult
1065: oValueTop
1066: oPushResult
1067: oNodeSetInt
1068: oPop 3
1070: oValuePop
1071: oInput 19
1073: oCall 1452
1075: oGetLocal 3
1077: oPushResult
1078: oSetResult 17
1080: oPushResult
1081: oValueTop
1082: oPushResult
1083: oNodeSetInt
1084: oPop 3
1086: oValuePop
1087: oGetLocal 3
1089: oPushResult
1090: oSetResult 2
1092: oPushResult
1093: oSetResult 4
1095: oPushResult
1096: oNodeSetInt
1097: oPop 3
1099: oGetLocal 3
1101: oPushResult
1102: oTypeAdd
1103: oPop 1
1105: oGetAddrLocal 4
1107: oPushResult
1108: oSetResult 23
1110: oPushResult
1111: oNodeNew
1112: oPop 1
1114: oAssign
1115: oGetLocal 4
1117: oPushResult
1118: oSetResult 15
1120: oPushResult
1121: oGetLocal 3
1123: oPushResult
1124: oNodeSet
1125: oPop 3
1127: oGetLocal 2
1129: oPushResult
1130: oGetLocal 4
1132: oPushResult
1133: oNodeVecAppend
1134: oPop 2
1136: oInputChoice 1144
1138: oJumpForward 1152
1140: oJumpForward 1150
1142: oJumpForward 1150
1144: Choice Lookup Table
          12   1142
          16   1138
1149: oEndChoice
1150: oJumpBack 1035
1152: oInput 37
1154: oGetAddrLocal 5
1156: oPushResult
1157: oCall 983
1159: oPop 1
1161: oGetAddrLocal 6
1163: oPushResult
1164: oGetLocal 2
1166: oPushResult
1167: oNodeVecSize
1168: oPop 1
1170: oAssign
1171: oGetAddrLocal 6
1173: oPushResult
1174: dec
1175: oPop 1
1177: oGetAddrLocal 4
1179: oPushResult
1180: oGetLocal 2
1182: oPushResult
1183: oGetLocal 6
1185: oPushResult
1186: oNodeVecElement
1187: oPop 2
1189: oAssign
1190: oGetLocal 4
1192: oPushResult
1193: oSetResult 14
1195: oPushResult
1196: oGetLocal 5
1198: oPushResult
1199: oNodeSet
1200: oPop 3
1202: oGetAddrLocal 3
1204: oPushResult
1205: oGetLocal 4
1207: oPushResult
1208: oSetResult 15
1210: oPushResult
1211: oNodeGet
1212: oPop 2
1214: oAssign
1215: oGetAddrLocal 9
1217: oPushResult
1218: oGetLocal 3
1220: oPushResult
1221: oSetResult 17
1223: oPushResult
1224: oNodeGetInt
1225: oPop 2
1227: oPushResult
1228: oGetLocal 3
1230: oPushResult
1231: oSetResult 16
1233: oPushResult
1234: oNodeGetInt
1235: oPop 2
1237: oPushResult
1238: subtract
1239: oPop 2
1241: oAssign
1242: oGetAddrLocal 9
1244: oPushResult
1245: inc
1246: oPop 1
1248: oGetLocal 4
1250: oPushResult
1251: oSetResult 2
1253: oPushResult
1254: oGetLocal 9
1256: oPushResult
1257: oGetLocal 5
1259: oPushResult
1260: oSetResult 2
1262: oPushResult
1263: oNodeGetInt
1264: oPop 2
1266: oPushResult
1267: multiply
1268: oPop 2
1270: oPushResult
1271: oNodeSetInt
1272: oPop 3
1274: oGetLocal 4
1276: oPushResult
1277: oTypeAdd
1278: oPop 1
1280: oGetAddrLocal 5
1282: oPushResult
1283: oGetLocal 4
1285: oAssign
1286: oGetLocal 6
1288: oPushResult
1289: equal_zero
1290: oPop 1
1292: oChoice 1298
1294: oJumpForward 1303
1296: oJumpForward 1301
1298: Choice Lookup Table
           1   1294
1301: oJumpBack 1171
1303: oGetParam 1
1305: oPushResult
1306: oGetLocal 2
1308: oPushResult
1309: oSetResult 0
1311: oPushResult
1312: oNodeVecElement
1313: oPop 2
1315: oAssign
1316: oGetLocal 2
1318: oPushResult
1319: oNodeVecDelete
1320: oPop 1
1322: oJumpForward 1451
1324: oGetAddrLocal 10
1326: oPushResult
1327: oCall 983
1329: oPop 1
1331: oGetParam 1
1333: oPushResult
1334: oGetLocal 10
1336: oPushResult
1337: oCall 4013
1339: oPop 1
1341: oAssign
1342: oJumpForward 1451
1344: oGetParam 1
1346: oPushResult
1347: oSetResult 25
1349: oPushResult
1350: oNodeNew
1351: oPop 1
1353: oAssign
1354: oScopeBegin
1355: oSetResult 14
1357: oPushResult
1358: oCall 842
1360: oPop 1
1362: oGetAddrLocal 11
1364: oPushResult
1365: oScopeCurrent
1366: oPushResult
1367: oSetResult 2
1369: oPushResult
1370: oNodeGetInt
1371: oPop 2
1373: oAssign
1374: oGetLocal 11
1376: oPushResult
1377: equal_zero
1378: oPop 1
1380: oChoice 1386
1382: oError 19
1384: oJumpForward 1389
1386: Choice Lookup Table
           1   1382
1389: oInput 33
1391: oGetFromParam 1
1393: oPushResult
1394: oSetResult 18
1396: oPushResult
1397: oScopeCurrent
1398: oPushResult
1399: oNodeSet
1400: oPop 3
1402: oGetFromParam 1
1404: oPushResult
1405: oSetResult 2
1407: oPushResult
1408: oGetLocal 11
1410: oPushResult
1411: oNodeSetInt
1412: oPop 3
1414: oScopeEnd
1415: oGetFromParam 1
1417: oPushResult
1418: oTypeAdd
1419: oPop 1
1421: oJumpForward 1451
1423: oInput 37
1425: oGetAddrLocal 10
1427: oPushResult
1428: oCall 983
1430: oPop 1
1432: oJumpForward 1451
1434: Choice Lookup Table
          36   1423
          35   1344
          17   1324
          34   1028
           0    987
1445: oCall 1452
1447: oInput 19
1449: oCall 1452
1451: oReturn
1452: oLocalSpace 1
1454: oInputChoice 1509
1456: TOKEN_VALUE
1457: oPushResult
1458: oValuePush
1459: oPop 1
1461: oJumpForward 1517
1463: oGetAddrLocal 1
1465: oPushResult
1466: oScopeFindRequire
1467: oAssign
1468: oGetLocal 1
1470: oPushResult
1471: oNodeType
1472: oPop 1
1474: oChoice 1491
1476: oGetLocal 1
1478: oPushResult
1479: oSetResult 8
1481: oPushResult
1482: oNodeGetInt
1483: oPop 2
1485: oPushResult
1486: oValuePush
1487: oPop 1
1489: oJumpForward 1502
1491: Choice Lookup Table
           9   1476
1494: oError 1
1496: oSetResult 0
1498: oPushResult
1499: oValuePush
1500: oPop 1
1502: oJumpForward 1517
1504: oCall 1452
1506: oValueNegate
1507: oJumpForward 1517
1509: Choice Lookup Table
          23   1504
           0   1463
           1   1456
1516: oEndChoice
1517: oReturn
1518: oLocalSpace 0
1520: oCall 1764
1522: oInputChoice 1746
1524: oCall 1764
1526: oCall 3859
1528: oTypeSNodeType
1529: oChoice 1543
1531: oEmit 32
1533: oJumpForward 1556
1535: oEmit 38
1537: oJumpForward 1556
1539: oError 16
1541: oJumpForward 1556
1543: Choice Lookup Table
          21   1539
          20   1539
          22   1535
          19   1531
          18   1531
1554: oError 17
1556: oTypeSPop
1557: oGetGlobal 4
1559: oPushResult
1560: oTypeSPush
1561: oPop 1
1563: oJumpForward 1761
1565: oCall 1764
1567: oCall 3859
1569: oTypeSNodeType
1570: oChoice 1584
1572: oEmit 33
1574: oJumpForward 1597
1576: oEmit 39
1578: oJumpForward 1597
1580: oError 16
1582: oJumpForward 1597
1584: Choice Lookup Table
          21   1580
          20   1580
          22   1576
          19   1572
          18   1572
1595: oError 17
1597: oTypeSPop
1598: oGetGlobal 4
1600: oPushResult
1601: oTypeSPush
1602: oPop 1
1604: oJumpForward 1761
1606: oCall 1764
1608: oCall 3859
1610: oTypeSNodeType
1611: oChoice 1621
1613: oEmit 35
1615: oJumpForward 1632
1617: oError 16
1619: oJumpForward 1632
1621: Choice Lookup Table
          21   1617
          20   1617
          19   1613
          18   1613
1630: oError 17
1632: oTypeSPop
1633: oGetGlobal 4
1635: oPushResult
1636: oTypeSPush
1637: oPop 1
1639: oJumpForward 1761
1641: oCall 1764
1643: oCall 3859
1645: oTypeSNodeType
1646: oChoice 1656
1648: oEmit 34
1650: oJumpForward 1667
1652: oError 16
1654: oJumpForward 1667
1656: Choice Lookup Table
          21   1652
          20   1652
          19   1648
          18   1648
1665: oError 17
1667: oTypeSPop
1668: oGetGlobal 4
1670: oPushResult
1671: oTypeSPush
1672: oPop 1
1674: oJumpForward 1761
1676: oCall 1764
1678: oCall 3859
1680: oTypeSNodeType
1681: oChoice 1691
1683: oEmit 37
1685: oJumpForward 1702
1687: oError 16
1689: oJumpForward 1702
1691: Choice Lookup Table
          21   1687
          20   1687
          19   1683
          18   1683
1700: oError 17
1702: oTypeSPop
1703: oGetGlobal 4
1705: oPushResult
1706: oTypeSPush
1707: oPop 1
1709: oJumpForward 1761
1711: oCall 1764
1713: oCall 3859
1715: oTypeSNodeType
1716: oChoice 1726
1718: oEmit 36
1720: oJumpForward 1737
1722: oError 16
1724: oJumpForward 1737
1726: Choice Lookup Table
          21   1722
          20   1722
          19   1718
          18   1718
1735: oError 17
1737: oTypeSPop
1738: oGetGlobal 4
1740: oPushResult
1741: oTypeSPush
1742: oPop 1
1744: oJumpForward 1761
1746: Choice Lookup Table
          10   1711
           9   1676
           8   1641
           7   1606
           6   1565
           5   1524
1759: oJumpForward 1763
1761: oJumpBack 1522
1763: oReturn
1764: oLocalSpace 0
1766: oCall 1788
1768: oInputChoice 1780
1770: oCall 3912
1772: oCall 1788
1774: oCall 3926
1776: oEmit 31
1778: oJumpForward 1785
1780: Choice Lookup Table
          52   1770
1783: oJumpForward 1787
1785: oJumpBack 1768
1787: oReturn
1788: oLocalSpace 0
1790: oCall 1812
1792: oInputChoice 1804
1794: oCall 3912
1796: oCall 1812
1798: oCall 3926
1800: oEmit 30
1802: oJumpForward 1809
1804: Choice Lookup Table
          51   1794
1807: oJumpForward 1811
1809: oJumpBack 1792
1811: oReturn
1812: oLocalSpace 0
1814: oInputChoice 1824
1816: oCall 1830
1818: oCall 3926
1820: oEmit 29
1822: oJumpForward 1829
1824: Choice Lookup Table
          53   1816
1827: oCall 1830
1829: oReturn
1830: oLocalSpace 0
1832: oCall 1866
1834: oInputChoice 1856
1836: oCall 3885
1838: oCall 1866
1840: oCall 3899
1842: oEmit 26
1844: oJumpForward 1863
1846: oCall 3885
1848: oCall 1866
1850: oCall 3899
1852: oEmit 27
1854: oJumpForward 1863
1856: Choice Lookup Table
          23   1846
          22   1836
1861: oJumpForward 1865
1863: oJumpBack 1834
1865: oReturn
1866: oLocalSpace 0
1868: oCall 1902
1870: oInputChoice 1892
1872: oCall 3885
1874: oCall 1902
1876: oCall 3899
1878: oEmit 24
1880: oJumpForward 1899
1882: oCall 3885
1884: oCall 1902
1886: oCall 3899
1888: oEmit 25
1890: oJumpForward 1899
1892: Choice Lookup Table
          21   1882
          20   1872
1897: oJumpForward 1901
1899: oJumpBack 1870
1901: oReturn
1902: oLocalSpace 0
1904: oInputChoice 1920
1906: oCall 1928
1908: oCall 3899
1910: oJumpForward 1927
1912: oCall 1928
1914: oCall 3899
1916: oEmit 28
1918: oJumpForward 1927
1920: Choice Lookup Table
          23   1912
          22   1906
1925: oCall 1928
1927: oReturn
1928: oLocalSpace 5
1930: oInputChoice 2103
1932: oEmit 9
1934: TOKEN_VALUE
1935: oPushResult
1936: oEmitInt
1937: oPop 1
1939: oGetGlobal 3
1941: oPushResult
1942: oTypeSPush
1943: oPop 1
1945: oJumpForward 2122
1947: oCall 1518
1949: oInput 14
1951: oJumpForward 2122
1953: oStringAllocLit
1954: oEmit 10
1956: oValueTop
1957: oPushResult
1958: oEmitInt
1959: oPop 1
1961: oValuePop
1962: oGetGlobal 6
1964: oPushResult
1965: oTypeSPush
1966: oPop 1
1968: oJumpForward 2122
1970: oGetAddrLocal 1
1972: oPushResult
1973: oScopeFindRequire
1974: oAssign
1975: oGetLocal 1
1977: oPushResult
1978: oNodeType
1979: oPop 1
1981: oChoice 2043
1983: oGetLocal 1
1985: oPushResult
1986: oCall 2739
1988: oPop 1
1990: oJumpForward 2062
1992: oGetAddrLocal 2
1994: oPushResult
1995: oGetLocal 1
1997: oPushResult
1998: oSetResult 6
2000: oPushResult
2001: oNodeGet
2002: oPop 2
2004: oAssign
2005: oGetLocal 2
2007: oPushResult
2008: oTypeSPush
2009: oPop 1
2011: oTypeSNodeType
2012: oChoice 2025
2014: oEmit 9
2016: oGetLocal 1
2018: oPushResult
2019: oCall 4149
2021: oPop 1
2023: oJumpForward 2032
2025: Choice Lookup Table
          19   2014
          18   2014
2030: oError 16
2032: oJumpForward 2062
2034: oGetLocal 1
2036: oPushResult
2037: oCall 2123
2039: oPop 1
2041: oJumpForward 2062
2043: Choice Lookup Table
          15   2034
          13   2034
          12   2034
           9   1992
           8   1983
2054: oError 6
2056: oGetGlobal 3
2058: oPushResult
2059: oTypeSPush
2060: oPop 1
2062: oJumpForward 2122
2064: oInput 0
2066: oGetAddrLocal 1
2068: oPushResult
2069: oScopeFindRequire
2070: oAssign
2071: oGetLocal 1
2073: oPushResult
2074: oCall 3221
2076: oPop 1
2078: oGetAddrLocal 2
2080: oPushResult
2081: oTypeSTop
2082: oAssign
2083: oTypeSPop
2084: oGetAddrLocal 5
2086: oPushResult
2087: oGetLocal 2
2089: oPushResult
2090: oCall 4013
2092: oPop 1
2094: oAssign
2095: oGetLocal 5
2097: oPushResult
2098: oTypeSPush
2099: oPop 1
2101: oJumpForward 2122
2103: Choice Lookup Table
          17   2064
           0   1970
           2   1953
          13   1947
           1   1932
2114: oError 6
2116: oGetGlobal 3
2118: oPushResult
2119: oTypeSPush
2120: oPop 1
2122: oReturn
2123: oLocalSpace 1
2125: oGetAddrLocal 1
2127: oPushResult
2128: oGetParam 1
2130: oPushResult
2131: oSetResult 6
2133: oPushResult
2134: oNodeGet
2135: oPop 2
2137: oAssign
2138: oGetLocal 1
2140: oPushResult
2141: oTypeSPush
2142: oPop 1
2144: oTypeSNodeType
2145: oChoice 2329
2147: oGetParam 1
2149: oPushResult
2150: oNodeType
2151: oPop 1
2153: oChoice 2188
2155: oEmit 0
2157: oGetParam 1
2159: oPushResult
2160: oCall 4149
2162: oPop 1
2164: oJumpForward 2196
2166: oEmit 3
2168: oGetParam 1
2170: oPushResult
2171: oCall 4149
2173: oPop 1
2175: oJumpForward 2196
2177: oEmit 6
2179: oGetParam 1
2181: oPushResult
2182: oCall 4149
2184: oPop 1
2186: oJumpForward 2196
2188: Choice Lookup Table
          15   2177
          13   2166
          12   2155
2195: oEndChoice
2196: oJumpForward 2395
2198: oGetParam 1
2200: oPushResult
2201: oNodeType
2202: oPop 1
2204: oChoice 2239
2206: oEmit 1
2208: oGetParam 1
2210: oPushResult
2211: oCall 4149
2213: oPop 1
2215: oJumpForward 2247
2217: oEmit 4
2219: oGetParam 1
2221: oPushResult
2222: oCall 4149
2224: oPop 1
2226: oJumpForward 2247
2228: oEmit 7
2230: oGetParam 1
2232: oPushResult
2233: oCall 4149
2235: oPop 1
2237: oJumpForward 2247
2239: Choice Lookup Table
          15   2228
          13   2217
          12   2206
2246: oEndChoice
2247: oJumpForward 2395
2249: oError 16
2251: oJumpForward 2395
2253: oGetParam 1
2255: oPushResult
2256: oNodeType
2257: oPop 1
2259: oChoice 2294
2261: oEmit 2
2263: oGetParam 1
2265: oPushResult
2266: oCall 4149
2268: oPop 1
2270: oJumpForward 2302
2272: oEmit 5
2274: oGetParam 1
2276: oPushResult
2277: oCall 4149
2279: oPop 1
2281: oJumpForward 2302
2283: oEmit 8
2285: oGetParam 1
2287: oPushResult
2288: oCall 4149
2290: oPop 1
2292: oJumpForward 2302
2294: Choice Lookup Table
          15   2283
          13   2272
          12   2261
2301: oEndChoice
2302: oInputChoice 2324
2304: oTypeSPop
2305: oGetLocal 1
2307: oPushResult
2308: oSetResult 14
2310: oPushResult
2311: oNodeGet
2312: oPop 2
2314: oPushResult
2315: oTypeSPush
2316: oPop 1
2318: oCall 2431
2320: oCall 2396
2322: oJumpForward 2327
2324: Choice Lookup Table
          17   2304
2327: oJumpForward 2395
2329: Choice Lookup Table
          22   2253
          17   2249
          21   2249
          20   2249
          19   2198
          18   2147
2342: oGetParam 1
2344: oPushResult
2345: oNodeType
2346: oPop 1
2348: oChoice 2383
2350: oEmit 11
2352: oGetParam 1
2354: oPushResult
2355: oCall 4149
2357: oPop 1
2359: oJumpForward 2391
2361: oEmit 12
2363: oGetParam 1
2365: oPushResult
2366: oCall 4149
2368: oPop 1
2370: oJumpForward 2391
2372: oEmit 13
2374: oGetParam 1
2376: oPushResult
2377: oCall 4149
2379: oPop 1
2381: oJumpForward 2391
2383: Choice Lookup Table
          15   2372
          13   2361
          12   2350
2390: oEndChoice
2391: oCall 2431
2393: oCall 2396
2395: oReturn
2396: oLocalSpace 0
2398: oTypeSNodeType
2399: oChoice 2417
2401: oEmit 15
2403: oJumpForward 2430
2405: oEmit 16
2407: oJumpForward 2430
2409: oError 16
2411: oJumpForward 2430
2413: oEmit 17
2415: oJumpForward 2430
2417: Choice Lookup Table
          22   2413
          17   2409
          21   2409
          20   2409
          19   2405
          18   2401
2430: oReturn
2431: oLocalSpace 0
2433: oInputChoice 2447
2435: oCall 2459
2437: oJumpForward 2456
2439: oCall 2602
2441: oJumpForward 2456
2443: oCall 2700
2445: oJumpForward 2456
2447: Choice Lookup Table
          17   2443
          18   2439
          15   2435
2454: oJumpForward 2458
2456: oJumpBack 2433
2458: oReturn
2459: oLocalSpace 3
2461: oTypeSNodeType
2462: oChoice 2466
2464: oJumpForward 2471
2466: Choice Lookup Table
          23   2464
2469: oError 10
2471: oTypeSNodeType
2472: oChoice 2476
2474: oJumpForward 2481
2476: Choice Lookup Table
          23   2474
2479: oError 13
2481: oGetAddrLocal 1
2483: oPushResult
2484: oTypeSTop
2485: oPushResult
2486: oSetResult 15
2488: oPushResult
2489: oNodeGet
2490: oPop 2
2492: oPushResult
2493: oCall 4097
2495: oPop 1
2497: oAssign
2498: oGetAddrLocal 2
2500: oPushResult
2501: oTypeSTop
2502: oPushResult
2503: oSetResult 14
2505: oPushResult
2506: oNodeGet
2507: oPop 2
2509: oAssign
2510: oTypeSPop
2511: oGetLocal 2
2513: oPushResult
2514: oTypeSPush
2515: oPop 1
2517: oCall 1518
2519: oCall 3885
2521: oGetLocal 1
2523: oPushResult
2524: equal_zero
2525: oPop 1
2527: oChoice 2541
2529: oEmit 9
2531: oGetLocal 1
2533: oPushResult
2534: oEmitInt
2535: oPop 1
2537: oEmit 27
2539: oJumpForward 2544
2541: Choice Lookup Table
           0   2529
2544: oGetAddrLocal 3
2546: oPushResult
2547: oGetLocal 2
2549: oPushResult
2550: oSetResult 2
2552: oPushResult
2553: oNodeGetInt
2554: oPop 2
2556: oAssign
2557: oGetLocal 3
2559: oPushResult
2560: oSetResult 1
2562: oPushResult
2563: equal
2564: oPop 2
2566: oChoice 2580
2568: oEmit 9
2570: oGetLocal 3
2572: oPushResult
2573: oEmitInt
2574: oPop 1
2576: oEmit 24
2578: oJumpForward 2583
2580: Choice Lookup Table
           0   2568
2583: oEmit 26
2585: oInputChoice 2593
2587: oJumpForward 2601
2589: oJumpForward 2599
2591: oJumpForward 2599
2593: Choice Lookup Table
          12   2591
          16   2587
2598: oEndChoice
2599: oJumpBack 2471
2601: oReturn
2602: oLocalSpace 2
2604: oTypeSNodeType
2605: oChoice 2609
2607: oJumpForward 2614
2609: Choice Lookup Table
          25   2607
2612: oError 11
2614: oTypeSTop
2615: oPushResult
2616: oSetResult 18
2618: oPushResult
2619: oNodeGet
2620: oPop 2
2622: oPushResult
2623: oScopeEnter
2624: oPop 1
2626: oInput 0
2628: oGetAddrLocal 1
2630: oPushResult
2631: oScopeFindRequire
2632: oAssign
2633: oGetLocal 1
2635: oPushResult
2636: oNodeType
2637: oPop 1
2639: oChoice 2643
2641: oJumpForward 2648
2643: Choice Lookup Table
          14   2641
2646: oError 12
2648: oScopeEnd
2649: oGetAddrLocal 2
2651: oPushResult
2652: oGetLocal 1
2654: oPushResult
2655: oSetResult 8
2657: oPushResult
2658: oNodeGetInt
2659: oPop 2
2661: oAssign
2662: oGetLocal 2
2664: oPushResult
2665: equal_zero
2666: oPop 1
2668: oChoice 2682
2670: oEmit 9
2672: oGetLocal 2
2674: oPushResult
2675: oEmitInt
2676: oPop 1
2678: oEmit 26
2680: oJumpForward 2685
2682: Choice Lookup Table
           0   2670
2685: oTypeSPop
2686: oGetLocal 1
2688: oPushResult
2689: oSetResult 6
2691: oPushResult
2692: oNodeGet
2693: oPop 2
2695: oPushResult
2696: oTypeSPush
2697: oPop 1
2699: oReturn
2700: oLocalSpace 1
2702: oTypeSNodeType
2703: oChoice 2707
2705: oJumpForward 2712
2707: Choice Lookup Table
          22   2705
2710: oError 9
2712: oEmit 17
2714: oGetAddrLocal 1
2716: oPushResult
2717: oTypeSTop
2718: oAssign
2719: oTypeSPop
2720: oGetLocal 1
2722: oPushResult
2723: oSetResult 14
2725: oPushResult
2726: oNodeGet
2727: oPop 2
2729: oPushResult
2730: oTypeSPush
2731: oPop 1
2733: oReturn
2734: oLocalSpace 0
2736: oCall 3859
2738: oReturn
2739: oLocalSpace 6
2741: oGetAddrLocal 1
2743: oPushResult
2744: oGetParam 1
2746: oPushResult
2747: oSetResult 9
2749: oPushResult
2750: oNodeGet
2751: oPop 2
2753: oAssign
2754: oGetAddrLocal 2
2756: oPushResult
2757: oGetLocal 1
2759: oPushResult
2760: oSetResult 2
2762: oPushResult
2763: oNodeGetInt
2764: oPop 2
2766: oAssign
2767: oEmit 40
2769: oGetLocal 2
2771: oPushResult
2772: oEmitInt
2773: oPop 1
2775: oGetAddrLocal 3
2777: oPushResult
2778: oGetLocal 1
2780: oPushResult
2781: oSetResult 1
2783: oPushResult
2784: oNodeGet
2785: oPop 2
2787: oAssign
2788: oInputChoice 2967
2790: oGetLocal 3
2792: oPushResult
2793: oNodeNull
2794: oPop 1
2796: oChoice 2802
2798: oJumpForward 2963
2800: oJumpForward 2805
2802: Choice Lookup Table
           1   2798
2805: oGetAddrLocal 4
2807: oPushResult
2808: oGetLocal 3
2810: oPushResult
2811: oSetResult 6
2813: oPushResult
2814: oNodeGet
2815: oPop 2
2817: oAssign
2818: oGetAddrLocal 5
2820: oPushResult
2821: oGetLocal 3
2823: oPushResult
2824: oSetResult 8
2826: oPushResult
2827: oNodeGetInt
2828: oPop 2
2830: oAssign
2831: oEmit 14
2833: oGetLocal 5
2835: oPushResult
2836: oEmitInt
2837: oPop 1
2839: oGetLocal 3
2841: oPushResult
2842: oSetResult 6
2844: oPushResult
2845: oNodeGet
2846: oPop 2
2848: oPushResult
2849: oTypeSPush
2850: oPop 1
2852: oGetLocal 3
2854: oPushResult
2855: oSetResult 12
2857: oPushResult
2858: oNodeGetBoolean
2859: oPop 2
2861: oChoice 2927
2863: oError 16
2865: oEmit 20
2867: oJumpForward 2933
2869: oCall 1518
2871: oCall 2734
2873: oTypeSNodeType
2874: oChoice 2892
2876: oEmit 18
2878: oJumpForward 2925
2880: oEmit 19
2882: oJumpForward 2925
2884: oError 16
2886: oJumpForward 2925
2888: oEmit 20
2890: oJumpForward 2925
2892: Choice Lookup Table
          22   2888
          17   2884
          21   2884
          20   2884
          19   2880
          18   2876
2905: oGetAddrLocal 6
2907: oPushResult
2908: oTypeSTop
2909: oPushResult
2910: oSetResult 2
2912: oPushResult
2913: oNodeGetInt
2914: oPop 2
2916: oAssign
2917: oEmit 21
2919: oGetLocal 6
2921: oPushResult
2922: oEmitInt
2923: oPop 1
2925: oJumpForward 2933
2927: Choice Lookup Table
           0   2869
           1   2863
2932: oEndChoice
2933: oGetAddrLocal 3
2935: oPushResult
2936: oNodeNext
2937: oPop 1
2939: oGetLocal 3
2941: oPushResult
2942: oNodeNull
2943: oPop 1
2945: oChoice 2953
2947: oJumpForward 2963
2949: oJumpForward 2959
2951: oJumpForward 2959
2953: Choice Lookup Table
           0   2951
           1   2947
2958: oEndChoice
2959: oInput 12
2961: oJumpBack 2790
2963: oInput 14
2965: oJumpForward 2985
2967: Choice Lookup Table
          13   2790
2970: oGetLocal 3
2972: oPushResult
2973: oNodeNull
2974: oPop 1
2976: oChoice 2982
2978: oError 15
2980: oJumpForward 2985
2982: Choice Lookup Table
           0   2978
2985: oEmit 42
2987: oGetParam 1
2989: oPushResult
2990: oCall 4149
2992: oPop 1
2994: oGetParam 1
2996: oPushResult
2997: oNodeType
2998: oPop 1
3000: oChoice 3017
3002: oGetParam 1
3004: oPushResult
3005: oSetResult 6
3007: oPushResult
3008: oNodeGet
3009: oPop 2
3011: oPushResult
3012: oTypeSPush
3013: oPop 1
3015: oJumpForward 3020
3017: Choice Lookup Table
           8   3002
3020: oEmit 41
3022: oGetLocal 2
3024: oPushResult
3025: oEmitInt
3026: oPop 1
3028: oReturn
3029: oLocalSpace 0
3031: oInputChoice 3081
3033: oCall 3756
3035: oJumpForward 3106
3037: oCall 3763
3039: oJumpForward 3106
3041: oCall 3830
3043: oJumpForward 3106
3045: oCall 3833
3047: oJumpForward 3106
3049: oCall 3289
3051: oJumpForward 3106
3053: oCall 3617
3055: oJumpForward 3106
3057: oCall 3347
3059: oJumpForward 3106
3061: oCall 3568
3063: oJumpForward 3106
3065: oCall 3704
3067: oJumpForward 3106
3069: oCall 3672
3071: oJumpForward 3106
3073: oCall 3733
3075: oJumpForward 3106
3077: oCall 3107
3079: oJumpForward 3106
3081: Choice Lookup Table
           0   3077
          32   3073
          48   3069
          49   3065
          46   3061
          41   3057
          45   3053
          38   3049
          57   3045
          56   3041
          55   3037
          54   3033
3106: oReturn
3107: oLocalSpace 1
3109: oGetAddrLocal 1
3111: oPushResult
3112: oScopeFindRequire
3113: oAssign
3114: oGetLocal 1
3116: oPushResult
3117: oNodeType
3118: oPop 1
3120: oChoice 3140
3122: oGetLocal 1
3124: oPushResult
3125: oCall 2739
3127: oPop 1
3129: oJumpForward 3151
3131: oGetLocal 1
3133: oPushResult
3134: oCall 3152
3136: oPop 1
3138: oJumpForward 3151
3140: Choice Lookup Table
          15   3131
          13   3131
          12   3131
           7   3122
3149: oError 0
3151: oReturn
3152: oLocalSpace 1
3154: oGetParam 1
3156: oPushResult
3157: oCall 3221
3159: oPop 1
3161: oInput 3
3163: oCall 1518
3165: oCall 3859
3167: oTypeSNodeType
3168: oChoice 3186
3170: oEmit 18
3172: oJumpForward 3219
3174: oEmit 19
3176: oJumpForward 3219
3178: oError 16
3180: oJumpForward 3219
3182: oEmit 20
3184: oJumpForward 3219
3186: Choice Lookup Table
          22   3182
          17   3178
          21   3178
          20   3178
          19   3174
          18   3170
3199: oGetAddrLocal 1
3201: oPushResult
3202: oTypeSTop
3203: oPushResult
3204: oSetResult 2
3206: oPushResult
3207: oNodeGetInt
3208: oPop 2
3210: oAssign
3211: oEmit 21
3213: oGetLocal 1
3215: oPushResult
3216: oEmitInt
3217: oPop 1
3219: oTypeSPop
3220: oReturn
3221: oLocalSpace 0
3223: oGetParam 1
3225: oPushResult
3226: oNodeType
3227: oPop 1
3229: oChoice 3264
3231: oEmit 11
3233: oGetParam 1
3235: oPushResult
3236: oCall 4149
3238: oPop 1
3240: oJumpForward 3273
3242: oEmit 12
3244: oGetParam 1
3246: oPushResult
3247: oCall 4149
3249: oPop 1
3251: oJumpForward 3273
3253: oEmit 13
3255: oGetParam 1
3257: oPushResult
3258: oCall 4149
3260: oPop 1
3262: oJumpForward 3273
3264: Choice Lookup Table
          15   3253
          13   3242
          12   3231
3271: oError 4
3273: oGetParam 1
3275: oPushResult
3276: oSetResult 6
3278: oPushResult
3279: oNodeGet
3280: oPop 2
3282: oPushResult
3283: oTypeSPush
3284: oPop 1
3286: oCall 2431
3288: oReturn
3289: oLocalSpace 0
3291: oCall 1518
3293: oCall 3912
3295: oInput 39
3297: oEmit 47
3299: oSetResult 2
3301: oPushResult
3302: oPatchPushHere
3303: oPop 1
3305: oEmit 53
3307: oCall 3029
3309: oInputChoice 3337
3311: oEmit 45
3313: oSetResult 2
3315: oPushResult
3316: oPatchPushHere
3317: oPop 1
3319: oEmit 53
3321: oSetResult 2
3323: oPushResult
3324: oPatchSwap
3325: oPop 1
3327: oSetResult 2
3329: oPushResult
3330: oPatchPopFwd
3331: oPop 1
3333: oCall 3029
3335: oJumpForward 3340
3337: Choice Lookup Table
          40   3311
3340: oSetResult 2
3342: oPushResult
3343: oPatchPopFwd
3344: oPop 1
3346: oReturn
3347: oLocalSpace 1
3349: oInput 0
3351: oGetAddrLocal 1
3353: oPushResult
3354: oScopeFindRequire
3355: oAssign
3356: oGetLocal 1
3358: oPushResult
3359: oNodeType
3360: oPop 1
3362: oChoice 3374
3364: oJumpForward 3383
3366: oError 16
3368: oJumpForward 3383
3370: oError 16
3372: oJumpForward 3383
3374: Choice Lookup Table
          15   3370
          13   3366
          12   3364
3381: oError 5
3383: oGetLocal 1
3385: oPushResult
3386: oSetResult 6
3388: oPushResult
3389: oNodeGet
3390: oPop 2
3392: oPushResult
3393: oTypeSPush
3394: oPop 1
3396: oCall 3885
3398: oEmit 10
3400: oGetLocal 1
3402: oPushResult
3403: oCall 4149
3405: oPop 1
3407: oInput 3
3409: oCall 1518
3411: oCall 3885
3413: oEmit 18
3415: oEmit 45
3417: oSetResult 0
3419: oPushResult
3420: oPatchPushHere
3421: oPop 1
3423: oEmit 53
3425: oSetResult 0
3427: oPushResult
3428: oPatchPushHere
3429: oPop 1
3431: oSetResult 0
3433: oPushResult
3434: oPatchSwap
3435: oPop 1
3437: oInputChoice 3535
3439: oEmit 22
3441: oGetLocal 1
3443: oPushResult
3444: oCall 4149
3446: oPop 1
3448: oSetResult 0
3450: oPushResult
3451: oPatchPopFwd
3452: oPop 1
3454: oEmit 0
3456: oGetLocal 1
3458: oPushResult
3459: oCall 4149
3461: oPop 1
3463: oCall 1518
3465: oCall 3885
3467: oEmit 34
3469: oEmit 46
3471: oSetResult 0
3473: oPushResult
3474: oPatchPushHere
3475: oPop 1
3477: oEmit 53
3479: oSetResult 0
3481: oPushResult
3482: oPatchSwap
3483: oPop 1
3485: oJumpForward 3541
3487: oEmit 23
3489: oGetLocal 1
3491: oPushResult
3492: oCall 4149
3494: oPop 1
3496: oSetResult 0
3498: oPushResult
3499: oPatchPopFwd
3500: oPop 1
3502: oEmit 0
3504: oGetLocal 1
3506: oPushResult
3507: oCall 4149
3509: oPop 1
3511: oCall 1518
3513: oCall 3885
3515: oEmit 35
3517: oEmit 46
3519: oSetResult 0
3521: oPushResult
3522: oPatchPushHere
3523: oPop 1
3525: oEmit 53
3527: oSetResult 0
3529: oPushResult
3530: oPatchSwap
3531: oPop 1
3533: oJumpForward 3541
3535: Choice Lookup Table
          43   3487
          42   3439
3540: oEndChoice
3541: oSetResult 0
3543: oPushResult
3544: oCountPush
3545: oPop 1
3547: oInput 44
3549: oCall 3029
3551: oEmit 45
3553: oSetResult 0
3555: oPushResult
3556: oPatchPopBack
3557: oPop 1
3559: oSetResult 0
3561: oPushResult
3562: oPatchPopFwd
3563: oPop 1
3565: oCall 3836
3567: oReturn
3568: oLocalSpace 0
3570: oSetResult 0
3572: oPushResult
3573: oPatchPushHere
3574: oPop 1
3576: oSetResult 0
3578: oPushResult
3579: oCountPush
3580: oPop 1
3582: oCall 3029
3584: oInputChoice 3608
3586: oCall 3029
3588: oJumpForward 3614
3590: oCall 1518
3592: oCall 3912
3594: oEmit 47
3596: oSetResult 0
3598: oPushResult
3599: oPatchPopBack
3600: oPop 1
3602: oCall 3836
3604: oJumpForward 3616
3606: oJumpForward 3614
3608: Choice Lookup Table
          47   3590
           4   3586
3613: oEndChoice
3614: oJumpBack 3584
3616: oReturn
3617: oLocalSpace 0
3619: oSetResult 0
3621: oPushResult
3622: oPatchPushHere
3623: oPop 1
3625: oSetResult 0
3627: oPushResult
3628: oCountPush
3629: oPop 1
3631: oCall 1518
3633: oCall 3912
3635: oInput 44
3637: oEmit 47
3639: oSetResult 0
3641: oPushResult
3642: oPatchPushHere
3643: oPop 1
3645: oEmit 53
3647: oSetResult 0
3649: oPushResult
3650: oPatchSwap
3651: oPop 1
3653: oCall 3029
3655: oEmit 45
3657: oSetResult 0
3659: oPushResult
3660: oPatchPopBack
3661: oPop 1
3663: oSetResult 0
3665: oPushResult
3666: oPatchPopFwd
3667: oPop 1
3669: oCall 3836
3671: oReturn
3672: oLocalSpace 0
3674: oSetResult 0
3676: oPushResult
3677: oPatchAnyEntries
3678: oPop 1
3680: oChoice 3698
3682: oEmit 45
3684: oSetResult 0
3686: oPushResult
3687: oPatchDup
3688: oPop 1
3690: oSetResult 0
3692: oPushResult
3693: oPatchPopBack
3694: oPop 1
3696: oJumpForward 3703
3698: Choice Lookup Table
           1   3682
3701: oError 18
3703: oReturn
3704: oLocalSpace 0
3706: oSetResult 0
3708: oPushResult
3709: oPatchAnyEntries
3710: oPop 1
3712: oChoice 3727
3714: oEmit 45
3716: oSetResult 1
3718: oPushResult
3719: oPatchPushHere
3720: oPop 1
3722: oEmit 53
3724: oCountInc
3725: oJumpForward 3732
3727: Choice Lookup Table
           1   3714
3730: oError 18
3732: oReturn
3733: oLocalSpace 0
3735: oCall 3029
3737: oInputChoice 3747
3739: oCall 3029
3741: oJumpForward 3753
3743: oJumpForward 3755
3745: oJumpForward 3753
3747: Choice Lookup Table
          33   3743
           4   3739
3752: oEndChoice
3753: oJumpBack 3737
3755: oReturn
3756: oLocalSpace 0
3758: oCall 3763
3760: oEmit 52
3762: oReturn
3763: oLocalSpace 0
3765: oInputChoice 3826
3767: oCall 1518
3769: oTypeSNodeType
3770: oChoice 3792
3772: oEmit 48
3774: oJumpForward 3807
3776: oEmit 49
3778: oJumpForward 3807
3780: oEmit 50
3782: oJumpForward 3807
3784: oError 16
3786: oJumpForward 3807
3788: oEmit 51
3790: oJumpForward 3807
3792: Choice Lookup Table
          22   3788
          17   3784
          20   3784
          21   3780
          19   3776
          18   3772
3805: oError 17
3807: oTypeSPop
3808: oInputChoice 3816
3810: oJumpForward 3824
3812: oJumpForward 3822
3814: oJumpForward 3822
3816: Choice Lookup Table
          12   3814
          14   3810
3821: oEndChoice
3822: oJumpBack 3767
3824: oJumpForward 3829
3826: Choice Lookup Table
          13   3767
3829: oReturn
3830: oLocalSpace 0
3832: oReturn
3833: oLocalSpace 0
3835: oReturn
3836: oLocalSpace 0
3838: oCountIsZero
3839: oChoice 3850
3841: oSetResult 1
3843: oPushResult
3844: oPatchPopFwd
3845: oPop 1
3847: oCountDec
3848: oJumpForward 3855
3850: Choice Lookup Table
           0   3841
3853: oJumpForward 3857
3855: oJumpBack 3838
3857: oCountPop
3858: oReturn
3859: oLocalSpace 1
3861: oGetAddrLocal 1
3863: oPushResult
3864: oTypeSNodeType
3865: oAssign
3866: oTypeSPop
3867: oGetLocal 1
3869: oPushResult
3870: oTypeSNodeType
3871: oPushResult
3872: equal_node_type
3873: oPop 2
3875: oChoice 3881
3877: oError 14
3879: oJumpForward 3884
3881: Choice Lookup Table
           0   3877
3884: oReturn
3885: oLocalSpace 0
3887: oTypeSNodeType
3888: oChoice 3892
3890: oJumpForward 3897
3892: Choice Lookup Table
          18   3890
3895: oError 7
3897: oTypeSPop
3898: oReturn
3899: oLocalSpace 0
3901: oTypeSNodeType
3902: oChoice 3906
3904: oJumpForward 3911
3906: Choice Lookup Table
          18   3904
3909: oError 7
3911: oReturn
3912: oLocalSpace 0
3914: oTypeSNodeType
3915: oChoice 3919
3917: oJumpForward 3924
3919: Choice Lookup Table
          19   3917
3922: oError 8
3924: oTypeSPop
3925: oReturn
3926: oLocalSpace 0
3928: oTypeSNodeType
3929: oChoice 3933
3931: oJumpForward 3938
3933: Choice Lookup Table
          19   3931
3936: oError 8
3938: oReturn
3939: oLocalSpace 1
3941: oGetAddrLocal 1
3943: oPushResult
3944: oGetParam 2
3946: oPushResult
3947: oNodeNew
3948: oPop 1
3950: oAssign
3951: oGetLocal 1
3953: oPushResult
3954: oSetResult 2
3956: oPushResult
3957: oGetParam 1
3959: oPushResult
3960: oNodeSetInt
3961: oPop 3
3963: oGetLocal 1
3965: oPushResult
3966: oTypeAdd
3967: oPop 1
3969: oGetLocal 1
3971: oReturn
3972: oReturn
3973: oLocalSpace 1
3975: oGetAddrLocal 1
3977: oPushResult
3978: oGetParam 3
3980: oPushResult
3981: oNodeNew
3982: oPop 1
3984: oAssign
3985: oGetLocal 1
3987: oPushResult
3988: oSetResult 5
3990: oPushResult
3991: oGetParam 2
3993: oPushResult
3994: oNodeSetKind
3995: oPop 3
3997: oGetLocal 1
3999: oPushResult
4000: oSetResult 4
4002: oPushResult
4003: oGetParam 1
4005: oPushResult
4006: oNodeSetInt
4007: oPop 3
4009: oGetLocal 1
4011: oReturn
4012: oReturn
4013: oLocalSpace 1
4015: oGetAddrLocal 1
4017: oPushResult
4018: oGetParam 1
4020: oPushResult
4021: oSetResult 13
4023: oPushResult
4024: oNodeGet
4025: oPop 2
4027: oAssign
4028: oGetLocal 1
4030: oPushResult
4031: oNodeNull
4032: oPop 1
4034: oChoice 4090
4036: oGetAddrLocal 1
4038: oPushResult
4039: oSetResult 22
4041: oPushResult
4042: oNodeNew
4043: oPop 1
4045: oAssign
4046: oGetLocal 1
4048: oPushResult
4049: oSetResult 14
4051: oPushResult
4052: oGetParam 1
4054: oPushResult
4055: oNodeSet
4056: oPop 3
4058: oGetLocal 1
4060: oPushResult
4061: oSetResult 2
4063: oPushResult
4064: oSetResult 8
4066: oPushResult
4067: oNodeSetInt
4068: oPop 3
4070: oGetLocal 1
4072: oPushResult
4073: oTypeAdd
4074: oPop 1
4076: oGetParam 1
4078: oPushResult
4079: oSetResult 13
4081: oPushResult
4082: oGetLocal 1
4084: oPushResult
4085: oNodeSet
4086: oPop 3
4088: oJumpForward 4093
4090: Choice Lookup Table
           1   4036
4093: oGetLocal 1
4095: oReturn
4096: oReturn
4097: oLocalSpace 0
4099: oGetParam 1
4101: oPushResult
4102: oNodeType
4103: oPop 1
4105: oChoice 4134
4107: oSetResult 0
4109: oReturn
4110: oJumpForward 4148
4112: oSetResult 0
4114: oReturn
4115: oJumpForward 4148
4117: oSetResult 0
4119: oReturn
4120: oJumpForward 4148
4122: oGetParam 1
4124: oPushResult
4125: oSetResult 16
4127: oPushResult
4128: oNodeGetInt
4129: oPop 2
4131: oReturn
4132: oJumpForward 4148
4134: Choice Lookup Table
          24   4122
          20   4117
          19   4112
          18   4107
4143: oError 3
4145: oSetResult 0
4147: oReturn
4148: oReturn
4149: oLocalSpace 0
4151: oGetParam 1
4153: oPushResult
4154: oSetResult 8
4156: oPushResult
4157: oNodeGetInt
4158: oPop 2
4160: oPushResult
4161: oEmitInt
4162: oPop 1
4164: oReturn
4165: oLocalSpace 1
4167: oGetAddrGlobal 2
4169: oPushResult
4170: oSetResult 17
4172: oPushResult
4173: oSetResult 4
4175: oPushResult
4176: oCall 3939
4178: oPop 2
4180: oAssign
4181: oGetAddrGlobal 3
4183: oPushResult
4184: oSetResult 18
4186: oPushResult
4187: oSetResult 4
4189: oPushResult
4190: oCall 3939
4192: oPop 2
4194: oAssign
4195: oGetAddrGlobal 4
4197: oPushResult
4198: oSetResult 19
4200: oPushResult
4201: oSetResult 1
4203: oPushResult
4204: oCall 3939
4206: oPop 2
4208: oAssign
4209: oGetAddrGlobal 5
4211: oPushResult
4212: oSetResult 20
4214: oPushResult
4215: oSetResult 1
4217: oPushResult
4218: oCall 3939
4220: oPop 2
4222: oAssign
4223: oGetAddrGlobal 6
4225: oPushResult
4226: oSetResult 21
4228: oPushResult
4229: oSetResult 256
4231: oPushResult
4232: oCall 3939
4234: oPop 2
4236: oAssign
4237: oGetAddrLocal 1
4239: oPushResult
4240: oSetResult 10
4242: oPushResult
4243: oSetResult 5
4245: oPushResult
4246: oIdAdd_File
4247: oPushResult
4248: oCall 3973
4250: oPop 3
4252: oAssign
4253: oGetLocal 1
4255: oPushResult
4256: oSetResult 6
4258: oPushResult
4259: oGetGlobal 2
4261: oPushResult
4262: oNodeSet
4263: oPop 3
4265: oGetLocal 1
4267: oPushResult
4268: oScopeDeclare
4269: oPop 1
4271: oGetAddrLocal 1
4273: oPushResult
4274: oSetResult 10
4276: oPushResult
4277: oSetResult 5
4279: oPushResult
4280: oIdAdd_Integer
4281: oPushResult
4282: oCall 3973
4284: oPop 3
4286: oAssign
4287: oGetLocal 1
4289: oPushResult
4290: oSetResult 6
4292: oPushResult
4293: oGetGlobal 3
4295: oPushResult
4296: oNodeSet
4297: oPop 3
4299: oGetLocal 1
4301: oPushResult
4302: oScopeDeclare
4303: oPop 1
4305: oGetAddrLocal 1
4307: oPushResult
4308: oSetResult 10
4310: oPushResult
4311: oSetResult 5
4313: oPushResult
4314: oIdAdd_Boolean
4315: oPushResult
4316: oCall 3973
4318: oPop 3
4320: oAssign
4321: oGetLocal 1
4323: oPushResult
4324: oSetResult 6
4326: oPushResult
4327: oGetGlobal 4
4329: oPushResult
4330: oNodeSet
4331: oPop 3
4333: oGetLocal 1
4335: oPushResult
4336: oScopeDeclare
4337: oPop 1
4339: oGetAddrLocal 1
4341: oPushResult
4342: oSetResult 10
4344: oPushResult
4345: oSetResult 5
4347: oPushResult
4348: oIdAdd_Char
4349: oPushResult
4350: oCall 3973
4352: oPop 3
4354: oAssign
4355: oGetLocal 1
4357: oPushResult
4358: oSetResult 6
4360: oPushResult
4361: oGetGlobal 5
4363: oPushResult
4364: oNodeSet
4365: oPop 3
4367: oGetLocal 1
4369: oPushResult
4370: oScopeDeclare
4371: oPop 1
4373: oGetAddrLocal 1
4375: oPushResult
4376: oSetResult 10
4378: oPushResult
4379: oSetResult 5
4381: oPushResult
4382: oIdAdd_String
4383: oPushResult
4384: oCall 3973
4386: oPop 3
4388: oAssign
4389: oGetLocal 1
4391: oPushResult
4392: oSetResult 6
4394: oPushResult
4395: oGetGlobal 6
4397: oPushResult
4398: oNodeSet
4399: oPop 3
4401: oGetLocal 1
4403: oPushResult
4404: oScopeDeclare
4405: oPop 1
4407: oGetAddrLocal 1
4409: oPushResult
4410: oSetResult 9
4412: oPushResult
4413: oSetResult 4
4415: oPushResult
4416: oIdAdd_True
4417: oPushResult
4418: oCall 3973
4420: oPop 3
4422: oAssign
4423: oGetLocal 1
4425: oPushResult
4426: oSetResult 6
4428: oPushResult
4429: oGetGlobal 4
4431: oPushResult
4432: oNodeSet
4433: oPop 3
4435: oGetLocal 1
4437: oPushResult
4438: oSetResult 8
4440: oPushResult
4441: oSetResult 1
4443: oPushResult
4444: oNodeSetInt
4445: oPop 3
4447: oGetLocal 1
4449: oPushResult
4450: oScopeDeclare
4451: oPop 1
4453: oGetAddrLocal 1
4455: oPushResult
4456: oSetResult 9
4458: oPushResult
4459: oSetResult 4
4461: oPushResult
4462: oIdAdd_False
4463: oPushResult
4464: oCall 3973
4466: oPop 3
4468: oAssign
4469: oGetLocal 1
4471: oPushResult
4472: oSetResult 6
4474: oPushResult
4475: oGetGlobal 4
4477: oPushResult
4478: oNodeSet
4479: oPop 3
4481: oGetLocal 1
4483: oPushResult
4484: oSetResult 8
4486: oPushResult
4487: oSetResult 0
4489: oPushResult
4490: oNodeSetInt
4491: oPop 3
4493: oGetLocal 1
4495: oPushResult
4496: oScopeDeclare
4497: oPop 1
4499: oReturn
