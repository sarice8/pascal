   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qFinalRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, kVar, LAST_ID )
 121:          oNodeSet( t, qType, FileType )
 133:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 139:          ','
 141:          pIdent
      
 143:          t = @newIdent( nVar, kVar, LAST_ID )
 159:          oNodeSet( t, qType, FileType )
 171:          oScopeDeclareAlloc( t )
      
 177:          ')'
 179:       | * :
 184:    ]
 184:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 186:    [
 186:       | pUses :  @UsesClause( program )
 195:       | * :
 200:    ]
      
         % Global scope for the program, below any used units.
         % TO DO: I have a problem here.  I want separate scopes for visibility,
         %    but need to allocate global vars from a common offset counter,
         %    which I have in Scope currently.
         %    I need a way to share allocators.  Should only be necessary for global scopes.
         %    I could make global scope (with allocUp) a special case, and allocate from a
         %    global counter despite having separate Scopes.
         %    Or I could declare Scopes to "extend" another scope, meaning it shares the allocator.
 200:    oScopeBegin( 0, allocGlobal )
 209:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 214:    oScopeBegin( 0, allocDown )
 223:    initScope = oScopeCurrent
 228:    oNodeSet( program, qMainRoutineScope, initScope )
 240:    oScopeEnd
      
 241:    @BlockDecls( nGlobalVar )
      
      
 248:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 254:    @BlockStmt( mainLabel, globalScope )
      
 264:    oScopeEnd   % main routine scope
      
 265:    '.'
 267:    oScopeEnd   % global scope
 269:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded)
      % and make the public portions of the named units visible to this program.
 269: UsesClause( Node user ):
 271:    {
 271:       pIdent
 273:       Node unit = @FindOrCompileUnit( LAST_ID )
 283:       [ equal_node( unit, Null )
 293:          | false :
 294:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % TO DO: put a declaration in the current scope, naming the unit and pointing to it.
                  %   This is to allow references to  <unit>.<identifier_in_unit>
                  %   Maybe something like nUsedUnit or nImportUnit
      
                  % Make unit's public scope directly visible.
                  % We can do this by entering the unit's public scope, prior to creating the user's scope.
                  % (The user scope will be able to shadow declarations in the unit.)
                  % Need to take care that this scope nesting doesn't confuse me, including with units that
                  % include other units.  But since use clauses are always at the start of a program or unit,
                  % it may work out ok.
 306:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
      
                  % TO DO: don't do the scopeEnter above.  Instead, do them after the loop that obtains
                  % all the used units.  So they don't interfere with compilation of other units.
                  % Also TO DO: at the end of a module (unit/program) end the scopes we enter here.
                  % e.g. enterUsedUnits / endUsedUnits.  That should let us compile indirectly-used units
                  %     while not leaving those visible to other users e.g. program.
      
 319:          | * :
 324:       ]
      
 324:       [
 324:          | ',' :
 326:          | * :  >
 333:       ]
 333:    }
 335:    ';'
 338:    ;
      
      
 338: FindOrCompileUnit( int id ) >> Node:
         % TO DO
 340:    oMsg( 10 )  oMsg( id )
         % We might have this unit loaded already
 352:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 371:    [ equal_node( unit, Null )
 381:       | false :  >> unit
 385:       | * :
 390:    ]
      
         % If not, search for the source file on disk
 390:    boolean ok = oIncludeUnitFile( id )
 400:    [ ok
 403:       | false :  #eCantFindUnitFile  >> Null
 409:       | * :
 414:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 414:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 420:    oIncludeEnd
 421:    >> unit;
      
      
      
 425: Unit >> Node:
 427:    pUnit
 429:    pIdent
 431:    Node unit = oNodeNew( nUnit )
 441:    oNodeSetInt( unit, qIdent, LAST_ID )
 452:    oNodeAddLast( workspace, qUnits, unit )
 464:    ';'
 466:    [
 466:       | pUses :   @UsesClause( unit )
 475:       | * :
 480:    ]
      
         % mandatory sections
      
         % NOTE, despite syntax diagrams, method headers in the interface may have 'external' clause.
         % Confirmed this looking at some units shipped with fpc.
 480:    pInterface
 482:    oScopeBegin( 0, allocGlobal )
 491:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 502:    oScopeBegin( 0, allocDown )
 511:    initScope = oScopeCurrent
 516:    oNodeSet( unit, qInitRoutineScope, initScope )
 528:    oScopeEnd
      
 529:    @UnitInterface( unit )
      
 536:    pImplementation
 538:    oScopeBegin( 0, allocGlobal )
 547:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 558:    @UnitImplementation( unit )
      
 565:    [
 565:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 577:       | * :                @UnitInitialization( unit, false )  % still need an implicit init routine
 592:    ]
 592:    [
 592:       | pFinalization :  @UnitFinalization( unit )
 601:       | * :
 606:    ]
 606:    pEnd  '.'
 610:    oScopeEnd  % impl scope
 611:    oScopeEnd  % interface scope
 612:    >> unit;
      
      
 616: UnitInterface( Node unit ):
 618:    {[
 618:       | pConst :     @ConstDecl
 622:       | pType :      @TypeDecl
 626:       | pVar :       @VarDecl( nGlobalVar )
 635:       | pProcedure : @ProcHeaderDecl
 639:       | pFunction :  @FuncHeaderDecl
 643:       | * :          >
 658:    ]}
 661:    ;
      
 661: UnitImplementation( Node unit ):
 663:    @BlockDecls( nGlobalVar )
 671:    ;
      
      
 671: UnitInitialization( Node unit, boolean hasStmts ):
 673:    Label label = oLabelNew
 678:    .tLabel  oEmitLabel( label )
 686:    oNodeSetLabel( unit, qInitLabel, label )
      
 698:    int patchLS
 698:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 707:    Node scope
 707:    Code initCode
      
 707:    scope = oNodeGet( unit, qPublicScope )
 720:    initCode = oNodeGetCode( scope, qInitCode )
 733:    oMsg( 3000 )
 739:    oMsgNodeLong( scope )
 745:    oMsg( 3001 )
 751:    oEmitCode( initCode )
 757:    oNodeSetCode( scope, qInitCode, codeNull )
      
 769:    scope = oNodeGet( unit, qPrivateScope )
 782:    initCode = oNodeGetCode( scope, qInitCode )
 795:    oEmitCode( initCode )
 801:    oNodeSetCode( scope, qInitCode, codeNull )
      
 813:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
 826:    [ hasStmts
 829:       | true :     
 830:          @Statement
 832:          {[
 832:             | ';' :  @Statement
 836:             | * :
 841:          ]}
 843:       | * :
 848:    ]
      
 848:    .tReturn
      
 850:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 862:    oPatch( patchLS, localSpace )
 871:    oScopeEnd   % init routine scope, for temporaries
 873:    ;
      
 873: UnitFinalization( Node unit ):
 875:    #eNotImplemented
 878:    ;
      
 878: ProcHeaderDecl:
 880:    #eNotImplemented
 883:    ;
      
 883: FuncHeaderDecl:
 885:    #eNotImplemented
 888:    ;
      
      
 888: Block( node_type varNodeType, Label labelForBody ):
 890:    @BlockDecls( varNodeType )
 897:    @BlockStmt( labelForBody, oScopeCurrent )
 907:    ;
      
      
 907: BlockDecls( node_type varNodeType ):
 909:    {[
 909:       | pConst :     @ConstDecl
 913:       | pType :      @TypeDecl
 917:       | pVar :       @VarDecl( varNodeType )
 926:       | pProcedure : @ProcDecl
 930:       | pFunction :  @FuncDecl
 934:       | * :          >
 949:    ]}
 951:    @CheckForUndefinedMethods
 954:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 954: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 957:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 957: BlockStmt( Label labelForBody, Node varScope ):
 959:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
 976:    NodeIter it = oNodeGetIter( workspace, qUnits )
 989:    {
 989:       Node unit = oNodeIterValue( it )
 999:       [ oNodeNull( unit )
1006:          | true :  >
1009:          | false :
1011:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1019:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1034:             .tFreeActuals  oEmitInt( 0 )
1042:             oNodeIterNext( it )
1048:       ]
1056:    }
      
         % insert any code for initialization of this scope's variables
1058:    Code initCode = oNodeGetCode( varScope, qInitCode )
1071:    oEmitCode( initCode )
1077:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1089:    @Statement
1091:    .tReturn
      
1093:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1105:    oPatch( patchLS, localSpace )
1115:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1115: MethodModifiers( Node decl ):
1117:    {[
1117:       | pCdecl :
1119:          oNodeSetBoolean( decl, qCdecl, true )
1131:          ';'
      
1133:       | * : >
1140:    ]}
1143:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1143: GetOrCreateInitCode >> Code:
1145:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1157:    [ equal_code( initCode, codeNull )
1167:       | true :
1168:          initCode = oCodeNew
1173:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1184:       | * :
1189:    ]
1189:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1193: ExternalDecl( Node decl ):
1195:    [ equal_zero( @DeclLevel( decl ) )
1207:       | false :  #eExternalMethodCannotBeNested
1210:       | * :
1215:    ]
1215:    oNodeSetBoolean( decl, qExternal, true )
1227:    [
1227:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1229:          [
1229:             | pName :
1231:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1233:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1244:             | * :
1249:          ]
1249:       | * :
1254:    ]
1255:    ;
      
      
1255: ProcDecl:
1257:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1259:    boolean redeclaring = false
1265:    Node decl = oScopeFindInCurrentScope
      
1270:    [ oNodeNull( decl )
1277:       | true :
               % first declaration
1278:          decl = @newIdent( nProc, kProc, LAST_ID )
1294:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1305:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1307:          redeclaring = true
1313:          [ oNodeGetBoolean( decl, qBodyDefined )
1323:             | true : #eAlreadyDefined
1326:             | * :
1331:          ]
1331:          [ oNodeGetBoolean( decl, qExternal )
1341:             | true : #eAlreadyDefined
1344:             | * :
1349:          ]
1349:          [ oNodeType( decl )
1356:             | nProc :
1357:             | * : #eAlreadyDefined   % wrong kind
1364:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1364:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1383:          oNodeSet( decl, qParams, Null )
1395:    ]
      
1403:    int level = @ScopeLevel
1409:    boolean nested = greater( level, 0 )
1422:    inc( level )
1428:    oScopeBegin( level, allocUp )
1437:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1442:    [ nested
1445:       | true :
1446:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1461:       | * :
1466:    ]
      
1466:    @FormalArgDecl
1468:    oNodeSet( decl, qParams, paramScope )
1480:    oScopeEnd
1481:    ';'
      
1483:    [ redeclaring
1486:       | false : oScopeDeclare( decl )
1493:       | true :  % TO DO: check that qParams is consistent with qOldParams
1495:    ]
      
1503:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1510:    [
1510:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1512:       | pExternal : @ExternalDecl( decl )
      
1521:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1528:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1534:          oScopeBegin( level, allocDown )
1543:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1554:          Label label = oNodeGetLabel( decl, qValue )
1567:          @Block( nLocalVar, label )
1577:          oNodeSetBoolean( decl, qBodyDefined, true )
1589:          oScopeEnd
      
1590:          oScopeEnd  % paramScope
1591:    ]
1591:    ';';
      
      
1594: FuncDecl:
1596:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1598:    boolean redeclaring = false
1604:    Node decl = oScopeFindInCurrentScope
      
1609:    [ oNodeNull( decl )
1616:       | true :
               % first declaration
1617:          decl = @newIdent( nFunc, kFunc, LAST_ID )
1633:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1644:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1646:          redeclaring = true
1652:          [ oNodeGetBoolean( decl, qBodyDefined )
1662:             | true : #eAlreadyDefined
1665:             | * :
1670:          ]
1670:          [ oNodeType( decl )
1677:             | nFunc :
1678:             | * : #eAlreadyDefined   % wrong kind
1685:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1685:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1704:          oNodeSet( decl, qParams, Null )
1716:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1735:          oNodeSet( decl, qType, Null )
1747:    ]
      
1755:    int level = @ScopeLevel
1761:    boolean nested = greater( level, 0 )
1774:    inc( level )
1780:    oScopeBegin( level, allocUp )
1789:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1794:    [ nested
1797:       | true :
1798:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1813:       | * :
1818:    ]
      
1818:    @FormalArgDecl
1820:    oNodeSet( decl, qParams, paramScope )
      
1832:    ':'
      
1834:    Node theType
1834:    @TypeRef( theType )
1841:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1853:    Node ptrType = @PointerTypeTo( theType )
1864:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1880:    oScopeEnd
1881:    ';'
      
1883:    [ redeclaring
1886:       | false : oScopeDeclare( decl )
1893:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1895:    ]
      
1903:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1910:    [
1910:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1912:       | pExternal : @ExternalDecl( decl )
      
1921:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1928:          oScopeEnter( paramScope )
      
1934:          oScopeBegin( level, allocDown )
1943:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1954:          Label label = oNodeGetLabel( decl, qValue )
1967:          @Block( nLocalVar, label )
1977:          oNodeSetBoolean( decl, qBodyDefined, true )
1989:          oScopeEnd
      
1990:          oScopeEnd  % paramScope
1991:    ]
1991:    ';';
      
      
1994: FormalArgDecl:
1996:    [
1996:       | '(' :
1998:          {
1998:             NodeVec decls = oNodeVecNew
2003:             Node decl
2003:             boolean isInOut = false
      
2009:             [
2009:                | pVar : isInOut = true
2017:                | * :
2022:             ]
      
2022:             {  pIdent
      
2024:                decl = @newIdent( nParam, kVar, LAST_ID )
2040:                oNodeSetBoolean( decl, qInOut, isInOut )
2052:                oNodeVecAppend( decls, decl )
      
2061:                [
2061:                   | ':' : >
2065:                   | ',' :
2067:                ]
2075:             }
      
2077:             Node theType
2077:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2084:             Node allocType
2084:             [ isInOut
2087:                | true :   allocType = @PointerTypeTo( theType )
2099:                | * :      allocType = theType
2110:             ]
      
2110:             int i = 0
2116:             {[ equal( i, oNodeVecSize( decls ) )
2130:                | false :
2131:                   decl = oNodeVecElement( decls, i )
      
2144:                   oNodeSet( decl, qType, theType )
2156:                   oScopeDeclare( decl )
2162:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2178:                   inc( i )
2184:                | * :
2189:                   >
2191:             ]}
      
2193:             oNodeVecDelete( decls )
      
2199:             [
2199:                | ')' : >
2203:                | ';' :
2205:             ]
2213:          }
2215:       | * :
2220:    ];
      
2221: ConstDecl:
2223:    {[
2223:       | pIdent :
2225:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2241:          '='
      
2243:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2245:          int val = oValueTop
2250:          oValuePop
2251:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2263:          oNodeSet( decl, qType, IntegerType )
      
2275:          oScopeDeclare( decl )
2281:          ';'
2283:       | * :
2288:          >
2290:    ]};
      
2293: TypeDecl:
2295:    {[
2295:       | pIdent :
2297:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2313:          '='
2315:          Node theType
2315:          @TypeRef( theType )
2322:          oNodeSet( decl, qType, theType )
2334:          oScopeDeclare( decl )
2340:          ';'
2342:       | * :
2347:          >
2349:    ]};
      
2352: VarDecl( node_type varNodeType ):
2354:    {[
2354:       | pIdent :
2356:          NodeVec decls = oNodeVecNew
2361:          Node decl
2361:          {
2361:             decl = @newIdent( varNodeType, kVar, LAST_ID )
2377:             oNodeVecAppend( decls, decl )
2386:             [
2386:                | ',' :
2388:                   pIdent
2390:                | * :
2395:                   >
2397:             ]
2397:          }
2399:          ':'
2401:          Node theType
2401:          @TypeRef( theType )
      
2408:          int i = 0
2414:          {[ equal( i, oNodeVecSize( decls ) )
2428:             | false :
2429:                decl = oNodeVecElement( decls, i )
2442:                oNodeSet( decl, qType, theType )
2454:                oScopeDeclareAlloc( decl )
2460:                inc( i )
2466:             | * :
2471:               >
2473:          ]}
      
               % optional initialization
2475:          [
2475:             | '=' :
2477:                [ oNodeVecSize( decls )
2484:                   | 1 :
2485:                   | * :  #eOnlyOneVarCanBeInitialized
2492:                ]
      
                     % we need an initCode stream for this scope
2492:                Code initCode = @GetOrCreateInitCode
2498:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
2504:                boolean changedScope = false
2510:                [ equal_zero( @ScopeLevel )
2517:                   | true : oScopeEnter( initScope )
2524:                            changedScope = true
2530:                   | * :
2535:                ]
                     % generate assignment in initCode stream
2535:                @LValueVar( decl )
2542:                @Expr
2544:                @MatchTypes
2546:                @Assign
2548:                [ changedScope
2551:                   | true : oScopeEnd
2553:                   | * :
2558:                ]
2558:                oCodePop
                   
2559:             | * :
2564:          ]
      
2564:          oNodeVecDelete( decls )
2570:          ';'
2572:       | * :
2577:          >
2579:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
2582: TypeRef( out Node resultType ):
2584:    [
2584:       | pIdent :           % previously named type (including intrinsics)
2586:          Node decl = oScopeFindRequire
2591:          [ oNodeType( decl )
2598:            | nTypeDecl :
2599:                resultType = oNodeGet( decl, qType )
2612:            | * :
2617:                #eNotType
2619:                resultType = IntegerType
2625:          ]
         
2625:       | pArray :
2627:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
2629:          NodeVec dimensions = oNodeVecNew
      
2634:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
2634:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
2644:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
2656:             @ConstExpr
2658:             oNodeSetInt( subrange, qLow, oValueTop )
2669:             oValuePop
2670:             '..'
2672:             @ConstExpr
2674:             oNodeSetInt( subrange, qHigh, oValueTop )
2685:             oValuePop
2686:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
2698:             oTypeAdd( subrange )
      
2704:             Node a = oNodeNew( nArrayType )
2714:             oNodeSet( a, qIndexType, subrange )
      
2726:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
2735:             [
2735:                | ']' : >
2739:                | ',' :
2741:             ]
2749:          }
      
2751:          pOf
2753:          Node baseType
2753:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
2760:          int dim = oNodeVecSize( dimensions )
      
2770:          {
2770:              dec(dim)
      
2776:              Node a = oNodeVecElement( dimensions, dim )
      
2789:              oNodeSet( a, qBaseType, baseType )
2801:              Node subrange = oNodeGet( a, qIndexType )
2814:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2841:              inc( width )
2847:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2873:              oTypeAdd( a )
2879:              baseType = a
      
2885:              [ equal_zero(dim)
2892:                  | true:  >
2895:                  | *:
2900:              ]
2900:          }
      
2902:          resultType = oNodeVecElement( dimensions, 0 )
2915:          oNodeVecDelete( dimensions )
      
2921:       | '^' :
2923:          Node theType
2923:          @TypeRef( theType )
2930:          resultType = @PointerTypeTo( theType )
      
2941:       | pRecord :
2943:          resultType = oNodeNew( nRecordType )
2953:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
2962:          @VarDecl( nRecordField )
      
2969:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2981:          [ equal_zero( size )
2988:             | true : #eRecordEmpty
2991:             | * :
2996:          ]
      
2996:          pEnd
      
2998:          oNodeSet( resultType, qScope, oScopeCurrent )
3009:          oNodeSetInt( resultType, qSize, size )
3021:          oScopeEnd
3022:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3028:       | pSet :
3030:          pOf
3032:          Node theType
3032:          @TypeRef( theType )
3039:       | * :       % this works for cases except where expr starts with an id
3052:          @ConstExpr '..' @ConstExpr
3058:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3059: ConstExpr:
3061:    [
3061:       | pIntLit :
3063:          oValuePush( TOKEN_VALUE )
3068:       | pIdent :
3070:          Node decl = oScopeFindRequire
3075:          [ oNodeType( decl )
3082:             | nConst :
3083:                oValuePush( oNodeGetInt( decl, qValue ) )
3096:             | * :
3101:                #eNotConst
3103:                oValuePush( 0 )
3109:          ]
3109:       | pMinus :
3111:          @ConstExpr
3113:          oValueNegate
3114:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3125: Expr:
3127:    Label falseLabel = labelNull
      
3133:    @ExprAllowCF( falseLabel )
3140:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3148: BooleanExprControlFlow( out Label falseLabel ):
3150:    @ExprAllowCF( falseLabel )
3157:    [ oTypeSNodeType
3159:       | nBooleanCFType :
3160:       | nBooleanType :
               % convert value to control flow
3162:          falseLabel = oLabelNew
3167:          .tJumpFalse  oEmitLabel( falseLabel )
3175:       | * :
3182:          #eNotBoolean
3184:    ]
3184:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3186: CFToVal( inout Label falseLabel ):
3188:    [ oTypeSNodeType
3190:       | nBooleanCFType :
3191:          Label doneLabel = oLabelNew
3196:          .tPushConstI  oEmitInt( 1 )
3204:          .tJump  oEmitLabel( doneLabel )
3212:          .tLabel  oEmitLabel( falseLabel )
3220:          .tPushConstI  oEmitInt( 0 )
3228:          .tLabel  oEmitLabel( doneLabel )
3236:          oTypeSPop
3237:          oTypeSPush( BooleanType )
3243:          falseLabel = labelNull
3249:       | * :
3254:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3255: ValToCF( out Label falseLabel ):
3257:    [ oTypeSNodeType
3259:       | nBooleanType :
3260:          falseLabel = oLabelNew
3265:          .tJumpFalse  oEmitLabel( falseLabel )
3273:          oTypeSPop
3274:          oTypeSPush( BooleanCFType )
3280:       | * :
3285:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3286: ExprAllowCF( out Label falseLabel ):
3288:    @BoolExprAllowCF( falseLabel )
3295:    {[
3295:       | '=' :
3297:          @CFToVal( falseLabel )
3304:          @BoolExprAllowCF( falseLabel )
3311:          @CFToVal( falseLabel )
3318:          @MatchTypes
3320:          [ oTypeSNodeType
3322:             | nIntegerType, nBooleanType :  .tEqualI
3325:             | nPointerType :                .tEqualP
3329:             | nCharType, nStringType :      #eNotImplemented
3333:             | * :                           #eNotAllowed
3348:          ]
3348:          oTypeSPop
3349:          oTypeSPush( BooleanType )
      
3355:       | '<>' :
3357:          @CFToVal( falseLabel )
3364:          @BoolExprAllowCF( falseLabel )
3371:          @CFToVal( falseLabel )
3378:          @MatchTypes
3380:          [ oTypeSNodeType
3382:             | nIntegerType, nBooleanType :  .tNotEqualI
3385:             | nPointerType :                .tNotEqualP
3389:             | nCharType, nStringType :      #eNotImplemented
3393:             | * :                           #eNotAllowed
3408:          ]
3408:          oTypeSPop
3409:          oTypeSPush( BooleanType )
      
3415:       | '<' :
3417:          @CFToVal( falseLabel )
3424:          @BoolExprAllowCF( falseLabel )
3431:          @CFToVal( falseLabel )
3438:          @MatchTypes
3440:          [ oTypeSNodeType
3442:             | nIntegerType, nBooleanType :  .tLessI
3445:             | nCharType, nStringType :      #eNotImplemented
3449:             | * :                           #eNotAllowed
3462:          ]
3462:          oTypeSPop
3463:          oTypeSPush( BooleanType )
      
3469:       | '>' :
3471:          @CFToVal( falseLabel )
3478:          @BoolExprAllowCF( falseLabel )
3485:          @CFToVal( falseLabel )
3492:          @MatchTypes
3494:          [ oTypeSNodeType
3496:             | nIntegerType, nBooleanType :  .tGreaterI
3499:             | nCharType, nStringType :      #eNotImplemented
3503:             | * :                           #eNotAllowed
3516:          ]
3516:          oTypeSPop
3517:          oTypeSPush( BooleanType )
      
3523:       | '<=' :
3525:          @CFToVal( falseLabel )
3532:          @BoolExprAllowCF( falseLabel )
3539:          @CFToVal( falseLabel )
3546:          @MatchTypes
3548:          [ oTypeSNodeType
3550:             | nIntegerType, nBooleanType :  .tLessEqualI
3553:             | nCharType, nStringType :      #eNotImplemented
3557:             | * :                           #eNotAllowed
3570:          ]
3570:          oTypeSPop
3571:          oTypeSPush( BooleanType )
      
3577:       | '>=' :
3579:          @CFToVal( falseLabel )
3586:          @BoolExprAllowCF( falseLabel )
3593:          @CFToVal( falseLabel )
3600:          @MatchTypes
3602:          [ oTypeSNodeType
3604:             | nIntegerType, nBooleanType :  .tGreaterEqualI
3607:             | nCharType, nStringType :      #eNotImplemented
3611:             | * :                           #eNotAllowed
3624:          ]
3624:          oTypeSPop
3625:          oTypeSPush( BooleanType )
      
3631:       | * :
3646:          >
3648:    ]};
      
      
3651: BoolExprAllowCF( out Label falseLabel ):
3653:    Label trueLabel = labelNull
      
3659:    @BoolTermAllowCF( falseLabel )
3666:    {[
3666:       | pOr :
3668:          [ oTypeSNodeType
3670:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
3671:                [ equal_label( trueLabel, labelNull )
3681:                   | true :  trueLabel = oLabelNew
3687:                   | * :
3692:                ]
3692:                .tJump  oEmitLabel( trueLabel )
3700:             | nBooleanType :
3702:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
3709:                [ equal_label( trueLabel, labelNull )
3719:                   | true :  trueLabel = oLabelNew
3725:                   | * :
3730:                ]
3730:                .tJump  oEmitLabel( trueLabel )
3738:             | * : #eNotBoolean
3747:          ]
3747:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
3748:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
3756:          falseLabel = labelNull
3762:          @BoolTermAllowCF( falseLabel )
      
3769:          [ oTypeSNodeType
3771:             | nBooleanCFType :
3772:             | nBooleanType :
3774:                @ValToCF( falseLabel )
3781:             | * : #eNotBoolean
3790:          ]
      
3790:          oTypeSPop
3791:          oTypeSPush( BooleanCFType )
      
3797:       | * :
3802:          >
3804:    ]}
      
         % any short-circuit trues jump here to the end
3806:    [ equal_label( trueLabel, labelNull )
3816:       | false :
3817:          .tLabel  oEmitLabel( trueLabel )
3825:       | * :
3830:    ]
3831:    ;
      
      
3831: BoolTermAllowCF( out Label falseLabel ):
3833:    Label overallFalseLabel = labelNull
      
3839:    @BoolFactorAllowCF( falseLabel )
3846:    {[
3846:       | pAnd :
3848:          [ oTypeSNodeType
3850:             | nBooleanCFType :
3851:             | nBooleanType :
3853:                @ValToCF( falseLabel )
3860:             | * :
3867:                #eNotBoolean
3869:          ]
3869:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3870:          [ equal_label( overallFalseLabel, labelNull )
3880:             | true :
3881:                overallFalseLabel = oLabelNew
3886:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3900:                falseLabel = overallFalseLabel
3906:             | * :
3911:          ]
      
3911:          Label factorFalseLabel = labelNull
3917:          @BoolFactorAllowCF( factorFalseLabel )
      
3924:          [ oTypeSNodeType
3926:             | nBooleanCFType :
3927:             | nBooleanType :
3929:                @ValToCF( factorFalseLabel )
3936:             | * : #eNotBoolean
3945:          ]
3945:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3959:       | * :
3964:          >
3966:    ]};
      
3969: BoolFactorAllowCF( out Label falseLabel ):
3971:    [
3971:       | pNot :
3973:          Label factorFalseLabel = labelNull
      
3979:          @BoolFactorAllowCF( factorFalseLabel )
3986:          [ oTypeSNodeType
3988:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3989:                falseLabel = oLabelNew
3994:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4002:                .tLabel  oEmitLabel( factorFalseLabel )
      
4010:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4012:                .tNot
      
4014:             | * : #eNotBoolean
4023:          ]
      
4023:       | * :
4028:          @ArithExprAllowCF( falseLabel )
4035:    ];
      
4036: ArithExprAllowCF( out Label falseLabel ):
4038:    @TermAllowCF( falseLabel )
4045:    {[
4045:       | pPlus :
4047:          @RequireIntPop
4049:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4056:          @RequireInt
4058:          .tAddI
4060:       | pMinus :
4062:          @RequireIntPop
4064:          @TermAllowCF( falseLabel )
4071:          @RequireInt
4073:          .tSubI
4075:       | * :
4082:          >
4084:    ]};
      
4087: TermAllowCF( out Label falseLabel ):
4089:    @FactorAllowCF( falseLabel )
4096:    {[
4096:       | pTimes :
4098:          @RequireIntPop
4100:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4107:          @RequireInt
4109:          .tMultI
4111:       | pDivide :
4113:          @RequireIntPop
4115:          @FactorAllowCF( falseLabel )
4122:          @RequireInt
4124:          .tDivI
4126:       | * :
4133:          >
4135:    ]};
      
4138: FactorAllowCF( out Label falseLabel ):
4140:    [
4140:       | pPlus :
4142:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4149:          @RequireInt
4151:       | pMinus :
4153:          @PrimaryAllowCF( falseLabel )
4160:          @RequireInt
4162:          .tNegI
4164:       | * :
4171:          @PrimaryAllowCF( falseLabel )
4178:    ];
      
4179: PrimaryAllowCF( out Label falseLabel ):
4181:    [
4181:       | pIntLit :
4183:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4190:          oTypeSPush( IntegerType )
      
4196:       | '(' :
4198:          @ExprAllowCF( falseLabel )
4205:          ')'
      
4207:       | pStrLit :
4209:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4218:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4226:          oTypeSPush( StringType )
      
4232:       | pIdent :
4234:          Node decl = oScopeFindRequire
4239:          Node theType
      
4239:          [ oNodeType( decl )
4246:             | nFunc :
      
4247:                @Call( decl )
      
4254:             | nConst :
4256:                theType = oNodeGet( decl, qType )
4269:                oTypeSPush( theType )
4275:                [ oTypeSNodeType
4277:                   | nIntegerType, nBooleanType :
4278:                      .tPushConstI @EmitValue( decl )
4287:                   | * :
4294:                      #eNotImplemented
4296:                ]
      
4296:             | nGlobalVar, nLocalVar, nParam :
4298:                @VarExpr( decl )
      
4305:             | * :
4318:                #eNotValue
4320:                oTypeSPush( IntegerType )
4326:          ]
      
4326:       | '@' :        % @var -- pointer to var
4328:          pIdent
      
4330:          Node decl = oScopeFindRequire
4335:          Node theType
      
4335:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
4342:          theType = oTypeSTop
4347:          oTypeSPop
4348:          Node ptrType = @PointerTypeTo( theType )
4359:          oTypeSPush( ptrType )
      
4365:       | * :
4378:          #eNotValue
4380:          oTypeSPush( IntegerType )
4386:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
4387: VarExpr( Node decl ):
4389:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
4402:    int uplevels = @DeclUpLevels( decl )
      
4413:    oTypeSPush( theType )
4419:    [ oTypeSNodeType
4421:       | nIntegerType :
4422:          [ oNodeType( decl )
4429:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
4439:             | nLocalVar :
4441:                [ equal_zero( uplevels )
4448:                   | true :  .tPushLocalI  @EmitValue( decl )
4458:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
4478:                ]
4478:             | nParam :
4480:                [ oNodeGetBoolean( decl, qInOut )
4490:                   | true :    % VAR param points to the var.  Auto dereference.
4491:                      [ equal_zero( uplevels )
4498:                         | true :  .tPushParamP  @EmitValue( decl )
4508:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4528:                      ]
4528:                      .tFetchI
4530:                   | * :
4535:                      [ equal_zero( uplevels )
4542:                         | true :  .tPushParamI  @EmitValue( decl )
4552:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
4572:                      ]
4572:                ]
4572:          ]
      
4582:       | nBooleanType :
4584:          [ oNodeType( decl )
4591:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
4601:             | nLocalVar :
4603:                [ equal_zero( uplevels )
4610:                   | true :  .tPushLocalB  @EmitValue( decl )
4620:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
4640:                ]
4640:             | nParam :
4642:                [ oNodeGetBoolean( decl, qInOut )
4652:                   | true :    % VAR param points to the var.  Auto dereference.
4653:                      [ equal_zero( uplevels )
4660:                         | true :  .tPushParamP  @EmitValue( decl )
4670:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4690:                      ]
4690:                      .tFetchB
4692:                   | * :
4697:                      [ equal_zero( uplevels )
4704:                         | true :  .tPushParamB  @EmitValue( decl )
4714:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
4734:                      ]
4734:                ]
4734:          ]
      
4744:       | nCharType, nStringType, nFileType :
4746:          #eNotImplemented
      
4748:       | nPointerType :
4750:          [ oNodeType( decl )
4757:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
4767:             | nLocalVar :
4769:                [ equal_zero( uplevels )
4776:                   | true :  .tPushLocalP  @EmitValue( decl )
4786:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4806:                ]
4806:             | nParam :
4808:                [ oNodeGetBoolean( decl, qInOut )
4818:                   | true :    % VAR param points to the var.  Auto dereference.
4819:                      [ equal_zero( uplevels )
4826:                         | true :  .tPushParamP  @EmitValue( decl )
4836:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4856:                      ]
4856:                      .tFetchP
4858:                   | * :
4863:                      [ equal_zero( uplevels )
4870:                         | true :  .tPushParamP  @EmitValue( decl )
4880:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4900:                      ]
4900:                ]
4900:          ]
4910:          [
4910:             | '^' :             % dereferenced
4912:                oTypeSPop
4913:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4926:                @LValueIndexes
4928:                @FetchVar
4930:             | * :               % just ptr value alone
4935:          ]
      
4935:       | * :
               % compound type
               % first, push addr of start of var
4950:          [ oNodeType( decl )
4957:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4967:             | nLocalVar :
4969:                [ equal_zero( uplevels )
4976:                   | true :  .tPushAddrLocal  @EmitValue( decl )
4986:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5006:                ]
5006:             | nParam :
5008:                [ oNodeGetBoolean( decl, qInOut )
5018:                   | true :    % VAR param points to the var.  Auto dereference.
5019:                      [ equal_zero( uplevels )
5026:                         | true :  .tPushParamP  @EmitValue( decl )
5036:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5056:                      ]
5056:                   | * :
5061:                      [ equal_zero( uplevels )
5068:                         | true :  .tPushAddrParam  @EmitValue( decl )
5078:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5098:                      ]
5098:                ]
5098:          ]
               % modify addr for subscripts, field references, etc
5108:          @LValueIndexes
               % get final value
5110:          @FetchVar
5112:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5113: FetchVar:
5115:    [ oTypeSNodeType
5117:       | nIntegerType :   .tFetchI
5120:       | nBooleanType :   .tFetchB
5124:       | nCharType, nStringType, nFileType : #eNotImplemented
5128:       | nPointerType :   .tFetchP
5132:       | * :              % compound type; leave as addr
5147:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5148: LValueIndexes:
5150:    {[
5150:       | '[' :       @ArraySubscripts
5154:       | '.' :       @RecordFieldRef
5158:       | '^' :       @PointerDeref
5162:       | * :         >
5173:    ]};
      
5176: ArraySubscripts:
5178:    [ oTypeSNodeType
5180:       | nArrayType :
5181:       | * :       #eNotArray
5188:    ]
5188:    {
5188:       [ oTypeSNodeType
5190:          | nArrayType :
5191:          | * :    #eTooManySubscripts
5198:       ]
      
            % low subscript of this dimension
5198:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5215:       Node baseType
5215:       baseType = oNodeGet( oTypeSTop, qBaseType )
5227:       oTypeSPop
5228:       oTypeSPush( baseType )
      
5234:       @Expr
5236:       @RequireIntPop
            % adjust for low subscript
5238:       [ equal_zero( low )
5245:          | false :
5246:             .tPushConstI oEmitInt( low ) .tSubI
5256:          | * :
5261:       ]
      
            % multiply by element size
5261:       int size = oNodeGetInt( baseType, qSize )
5274:       [ equal( size, 1 )
5284:          | false :
5285:             .tPushConstI oEmitInt( size ) .tMultI
5295:          | * :
5300:       ]
      
            % update start address
5300:       .tAddPI
5302:       [
5302:          | ']' :  >
5306:          | ',' :
5308:       ]
5316:    };
      
      
5319: RecordFieldRef:
5321:    [ oTypeSNodeType
5323:       | nRecordType :
5324:       | * :    #eNotRecord
5331:    ]
5331:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
5343:    pIdent
5345:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
5350:    [ oNodeType( field )
5357:       | nRecordField :
5358:       | * :   #eNotRecordField
5365:    ]
5365:    oScopeEnd
5366:    int offset = oNodeGetInt( field, qValue )
5379:    [ equal_zero( offset )
5386:       | false :
5387:          .tPushConstI oEmitInt( offset ) .tAddPI
5397:       | * :
5402:    ]
      
         % replace the type on the type stack, with the field type
5402:    oTypeSPop
5403:    oTypeSPush( oNodeGet( field, qType ) )
5417:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
5417: PointerDeref:
5419:    [ oTypeSNodeType
5421:       | nPointerType :
5422:       | * :       #eNotPointer
5429:    ]
5429:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
5431:    Node theType = oTypeSTop
5436:    oTypeSPop
5437:    oTypeSPush( oNodeGet( theType, qBaseType ) )
5451:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
5451: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
5453:    @MatchTypes
5456:    ;
      
      
      % Called on first use of an extern method
      %
5456: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
5458:    int strAddr
5458:    String externalName = oNodeGetString( method, qExternalName )
5471:    [ equal_string( externalName, stringNull )
5481:       | true :
5482:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
5503:       | false :
5505:          strAddr = oStringAllocLit( externalName )
5515:    ]
5523:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
5539:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
5539: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
5541:    [ oNodeGetBoolean( method, qExternal )
5551:       | true :
5552:          [ oNodeGetBoolean( method, qCalled )
5562:             | false :
                     % define the extern label on first use
5563:                @DefineExternLabel( method )
5570:             | * :
5575:          ]
5575:      | * :
5580:    ]
5580:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
5592:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
5605:    Node resultType
5605:    int tempOffset
      
5605:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
5622:    [ isFunc
5625:       | true :
5626:          resultType = oNodeGet( method, qType )
5639:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
5649:       | * :
5654:    ]
         
      
5654:    Node paramScope = oNodeGet( method, qParams )
5667:    int actualsSize = oNodeGetInt( paramScope, qSize )
5680:    [ cdecl
5683:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
5692:       | false :  .tAllocActuals  oEmitInt( actualsSize )
5702:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
5710:    [ greater( @DeclLevel( method ), 0 )
5725:       | true :
5726:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
5734:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
5753:          .tAssignP
5755:       | * :
5760:    ]
      
      
5760:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
5773:    Node param = oNodeIterValue( paramIter )
5783:    [
5783:       | '(' :
            
5785:          {
5785:             [ oNodeNull( param )
5792:                | true : >
5795:                | * :
5800:             ]
      
5800:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
5813:             .tPushAddrActual oEmitInt( offset )
5821:             oTypeSPush( oNodeGet( param, qType ) )
      
5834:             [ oNodeGetBoolean( param, qInOut )
5844:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5845:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5847:                           @MatchTypes
      
5849:                           .tAssignP
      
5851:                | false :  @Expr
5855:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5857:                           [ oTypeSNodeType
5859:                              | nIntegerType :            .tAssignI
5862:                              | nBooleanType :            .tAssignB
5866:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5870:                              | nPointerType :            .tAssignP
5874:                              | * :
                                       % compound types: copy value into actuals space
5889:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5901:                                  .tCopy  oEmitInt( size )    % multi-word copy
5909:                           ]
5909:             ]
5917:             oTypeSPop
      
5918:             oNodeIterNext( paramIter )
5924:             param = oNodeIterValue( paramIter )
5934:             [ oNodeNull( param )
5941:                | true :  >
5944:                | false :
5946:             ]
      
5954:             ','
5956:          }
      
5958:          ')'
      
5960:       | * :
5965:    ]
      
5965:    [ oNodeNull( param )
5972:       | false :    #eMissingParameter
5975:       | * :
5980:    ]
      
5980:    [ isFunc
5983:       | true :
               % Pass result temp as an additional VAR parameter.
5984:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
5999:          .tPushAddrLocal  oEmitInt( tempOffset )
6007:          .tAssignP
6009:       | * :
6014:    ]
      
6014:    [ cdecl
6017:       | true :
6018:          .tCallCdecl  @EmitValue( method )
6027:       | false :
6029:          .tCall   @EmitValue( method )
6038:    ]
      
6046:    [ isFunc
6049:       | true :
               % push return value from temp
6050:          oTypeSPush( resultType )
      
6056:          [ oTypeSNodeType
6058:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6067:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6077:             | nCharType, nStringType, nFileType : #eNotImplemented
6081:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6091:             | * :              % compound type: push address
6106:                                .tPushAddrLocal  oEmitInt( tempOffset )
6114:          ]
6114:       | * :
6119:    ]
         
6119:    .tFreeActuals  oEmitInt( actualsSize )
6128:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6128: Statement:
6130:    [
6130:       | pWriteln :     @WritelnStmt
6134:       | pWrite :       @WriteStmt
6138:       | pReadln :      @ReadlnStmt
6142:       | pRead :        @ReadStmt
6146:       | pIf :          @IfStmt
6150:       | pWhile :       @WhileStmt
6154:       | pFor :         @ForStmt
6158:       | pRepeat :      @RepeatStmt
6162:       | pBreak :       @BreakStmt
6166:       | pContinue :    @ContinueStmt
6170:       | pBegin :       @BeginStmt
6174:       | pIdent :       @AssignOrCallStmt
6178:       | * :            % null statement : don't accept any tokens
6205:    ];
      
      
6206: AssignOrCallStmt:
6208:    Node decl = oScopeFindRequire
6213:    [ oNodeType( decl )
6220:       | nProc :                           @Call( decl )
6228:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6237:       | nFunc :                           @AssignResultStmt( decl )
6246:       | * :                               #eBadStatement
6261:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6262: AssignStmt( Node decl ):
      
6264:    @LValueVar( decl )
6271:    ':=' 
6273:    @Expr
6275:    @MatchTypes
6277:    @Assign
6280:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6280: Assign:
6282:    [ oTypeSNodeType
6284:       | nIntegerType :            .tAssignI
6287:       | nBooleanType :            .tAssignB
6291:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6295:       | nPointerType :            .tAssignP
6299:       | * :
6314:           int size = oNodeGetInt( oTypeSTop, qSize )
6326:           .tCopy  oEmitInt( size )    % multi-word copy
6334:    ]
6334:    oTypeSPop
6336:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
6336: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
6338:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
6354:       | false :   #eNotCurrentFunction
6357:       | * :
6362:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
6362:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
6377:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
6390:    ':='
6392:    @Expr
6394:    @MatchTypes
6396:    [ oTypeSNodeType
6398:       | nIntegerType :            .tAssignI
6401:       | nBooleanType :            .tAssignB
6405:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6409:       | nPointerType :            .tAssignP
6413:       | * :
6428:           int size = oNodeGetInt( oTypeSTop, qSize )
6440:           .tCopy  oEmitInt( size )    % multi-word copy
6448:    ]
6448:    oTypeSPop
6450:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
6450: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
6452:    pIdent
6454:    Node decl = oScopeFindRequire
6459:    [ oNodeType( decl )
6466:       | nGlobalVar, nLocalVar, nParam :
6467:       | * :  #eNotVar
6478:    ]
6478:    @LValueVar( decl )
6486:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
6486: LValueVar( Node decl ):
6488:    [ oNodeType( decl )
6495:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6505:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
6516:       | nParam :
6518:          [ oNodeGetBoolean( decl, qInOut )
6528:             | true :   % VAR param points to variable.  No dereference.
6529:                        .tPushParamP @EmitValue( decl )
6538:             | * :      .tPushAddrParam @EmitValue( decl )
6552:          ]
6552:       | * :            #eNotVar
6563:    ]
      
6563:    oTypeSPush( oNodeGet( decl, qType ) )
6576:    @LValueIndexes        % handle subscripts, if any
6579:    ;
      
      
6579: IncVar( Node decl ):
6581:    @LValueVar( decl )
6588:    @RequireIntPop
6590:    @VarExpr( decl )
6597:    oTypeSPop
6598:    .tIncI
6600:    .tAssignI;
      
6603: DecVar( Node decl ):
6605:    @LValueVar( decl )
6612:    @RequireIntPop
6614:    @VarExpr( decl )
6621:    oTypeSPop
6622:    .tDecI
6624:    .tAssignI;
      
      
6627: IfStmt:
6629:    Label falseLabel = labelNull
      
6635:    @BooleanExprControlFlow( falseLabel )
6642:    pThen
6644:    @Statement
6646:    [
6646:       | pElse :
6648:          Label doneLabel = oLabelNew
      
6653:          .tJump  oEmitLabel( doneLabel )
6661:          .tLabel oEmitLabel( falseLabel )
6669:          @Statement
6671:          .tLabel oEmitLabel( doneLabel )
      
6679:       | * :
6684:          .tLabel oEmitLabel( falseLabel )
6692:    ];
      
      
6693: ForStmt:
6695:    pIdent
      
6697:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
6702:    @LValueVar( decl )
6709:    @RequireIntPop
      
6711:    ':='
      
6713:    @Expr
6715:    @RequireIntPop
6717:    .tAssignI
      
6719:    Label breakLabel = oLabelNew
      
6724:    Label checkLabel = oLabelNew
6729:    .tJump  oEmitLabel( checkLabel )
      
6737:    Label continueLabel = oLabelNew
6742:    .tLabel  oEmitLabel( continueLabel )
6750:    [
6750:       | pTo :
6752:          @IncVar( decl )
6759:          .tLabel  oEmitLabel( checkLabel )
6767:          @VarExpr( decl )  oTypeSPop
6775:          @Expr
6777:          @RequireIntPop
6779:          .tGreaterI
6781:          .tJumpTrue  oEmitLabel( breakLabel )
6789:       | pDownto :
6791:          @DecVar( decl )
6798:          .tLabel  oEmitLabel( checkLabel )
6806:          @VarExpr( decl )  oTypeSPop
6814:          @Expr
6816:          @RequireIntPop
6818:          .tLessI
6820:          .tJumpTrue  oEmitLabel( breakLabel )
6828:    ]
6836:    oLoopPush( continueLabel, breakLabel )
6845:    pDo
6847:    @Statement
6849:    .tJump  oEmitLabel( continueLabel )
6857:    .tLabel  oEmitLabel( breakLabel )
6865:    oLoopPop;
      
      
6867: RepeatStmt:
6869:    Label continueLabel = oLabelNew
6874:    .tLabel  oEmitLabel( continueLabel )
      
6882:    Label breakLabel = oLabelNew
      
6887:    oLoopPush( continueLabel, breakLabel )
6896:    @Statement
6898:    {[
6898:       | ';' :
6900:          @Statement
6902:       | pUntil :
6904:          Label falseLabel
6904:          @BooleanExprControlFlow( falseLabel )
6911:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6925:          >
6927:    ]}
6937:    .tLabel  oEmitLabel( breakLabel )
6945:    oLoopPop;
      
      
6947: WhileStmt:
6949:    Label continueLabel = oLabelNew
6954:    .tLabel  oEmitLabel( continueLabel )
      
6962:    Label breakLabel
6962:    @BooleanExprControlFlow( breakLabel )
      
6969:    oLoopPush( continueLabel, breakLabel )
6978:    pDo
6980:    @Statement
6982:    .tJump  oEmitLabel( continueLabel )
6990:    .tLabel  oEmitLabel( breakLabel )
6998:    oLoopPop;
      
      
7000: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7002:    [ equal_label( oLoopContinueLabel, labelNull )
7011:       | true :
7012:          #eNotInALoop
7014:       | false :
7016:          .tJump  oEmitLabel( oLoopContinueLabel )
7023:    ];
      
      
7032: BreakStmt:
7034:    [ equal_label( oLoopBreakLabel, labelNull )
7043:       | true :
7044:          #eNotInALoop
7046:       | false :
7048:          .tJump  oEmitLabel( oLoopBreakLabel )
7055:    ];
      
      
7064: BeginStmt:
7066:    @Statement
7068:    {[
7068:       | ';' :   @Statement
7072:       | pEnd :  >
7076:    ]};
      
      
7087: WritelnStmt:
7089:    @WriteStmt
7091:    .tWriteCR;
      
      
7094: WriteStmt:
7096:    [
7096:       | '(' :
7098:          {
7098:             @Expr
7100:             [ oTypeSNodeType
7102:                | nIntegerType :             .tWriteI
7105:                | nBooleanType :             .tWriteBool
7109:                | nStringType :              .tWriteStr
7113:                | nCharType, nFileType :     #eNotImplemented
7117:                | nPointerType :             .tWriteP
7121:                | * :                        #eNotAllowed
7138:             ]
7138:             oTypeSPop
7139:             [
7139:                | ')' : >
7143:                | ',' :
7145:             ]
7153:          }
7155:       | * :
7160:    ];
      
      
7161: ReadlnStmt:      % ***
         % TO DO
7164:    ;
      
7164: ReadStmt:
         % TO DO
7167:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7167: ScopeLevel >> int:
7169:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7179: DeclLevel( Node decl ) >> int:
7181:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7199: DeclUpLevels( Node decl ) >> int:
7201:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7217: MatchTypes:
7219:    node_type nt = oTypeSNodeType
7224:    oTypeSPop
7225:    [ equal_node_type( nt, oTypeSNodeType )
7234:       | false :
7235:          #eTypeMismatch
7237:       | * :
7242:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7243: RequireIntPop:
7245:    [ oTypeSNodeType
7247:       | nIntegerType :
7248:       | * :          #eNotInteger
7255:    ]
7255:    oTypeSPop;
      
7257: RequireInt:
7259:    [ oTypeSNodeType
7261:       | nIntegerType :
7262:       | * :          #eNotInteger
7269:    ];
      
7270: RequireBoolPop:
7272:    [ oTypeSNodeType
7274:       | nBooleanType :
7275:       | * :          #eNotBoolean
7282:    ]
7282:    oTypeSPop;
      
7284: RequireBool:
7286:    [ oTypeSNodeType
7288:       | nBooleanType :
7289:       | * :          #eNotBoolean
7296:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7297: newType( node_type nt, int size ) >> Node:
7299:   Node node = oNodeNew( nt )
7309:   oNodeSetInt( node, qSize, size )
7321:   oTypeAdd( node )
7327:   >> node
7331:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
7331: newIdent( node_type nt, kind k, int id ) >> Node:
7333:   Node t = oNodeNew( nt )
7343:   oNodeSetInt( t, qIdent, id )
7355:   >> t
7359:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
7359: PointerTypeTo( Node theType ) >> Node:
7361:    Node ptrType = oNodeGet( theType, qPointerType )
7374:    [ oNodeNull( ptrType )
7381:       | true :
7382:          ptrType = oNodeNew( nPointerType )
7392:          oNodeSet( ptrType, qBaseType, theType )
7404:          oNodeSetInt( ptrType, qSize, 8 )
7416:          oTypeAdd( ptrType )
7422:          oNodeSet( theType, qPointerType, ptrType )
7434:       | * :
7439:    ]
7439:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
7443: OrdinalLow( Node theType ) >> int:
7445:    [ oNodeType( theType )
7452:       | nIntegerType :  >> oMININT
7455:       | nBooleanType :  >> 0
7460:       | nCharType :     >> 0
7465:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
7477:       | * :             #eNotOrdinalType
7490:                         >> 0
7493:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
7494: EmitValue( Node decl ):
7496:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
7510: installBuiltIns:
      
         % install built-in types
7512:    FileType = @newType( nFileType, 4 )
7526:    IntegerType = @newType( nIntegerType, 4 )
7540:    BooleanType = @newType( nBooleanType, 1 )
7554:    BooleanCFType = @newType( nBooleanCFType, 1 )
7568:    CharType = @newType( nCharType, 1 )
7582:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
7596:    Node t
      
7596:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
7612:    oNodeSet( t, qType, FileType )
7624:    oScopeDeclare( t )
      
7630:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
7646:    oNodeSet( t, qType, IntegerType )
7658:    oScopeDeclare( t )
      
7664:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
7680:    oNodeSet( t, qType, BooleanType )
7692:    oScopeDeclare( t )
      
7698:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
7714:    oNodeSet( t, qType, CharType )
7726:    oScopeDeclare( t )
      
7732:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
7748:    oNodeSet( t, qType, StringType )
7760:    oScopeDeclare( t )
      
         % Built-in constants
      
7766:    t = @newIdent( nConst, kConst, oIdAdd_True )
7782:    oNodeSet( t, qType, BooleanType )
7794:    oNodeSetInt( t, qValue, 1 )
7806:    oScopeDeclare( t )
      
7812:    t = @newIdent( nConst, kConst, oIdAdd_False )
7828:    oNodeSet( t, qType, BooleanType )
7840:    oNodeSetInt( t, qValue, 0 )
7852:    oScopeDeclare( t )
      
7859:    ;
      
7859: end
      
7859: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 7510
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 181
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 14
 110: oPushResult
 111: oSetResult 6
 113: oPushResult
 114: LAST_ID
 115: oPushResult
 116: oCall 7331
 118: oPop 3
 120: oAssign
 121: oGetLocal 1
 123: oPushResult
 124: oSetResult 20
 126: oPushResult
 127: oGetGlobal 3
 129: oPushResult
 130: oNodeSet
 131: oPop 3
 133: oGetLocal 1
 135: oPushResult
 136: oScopeDeclareAlloc
 137: oPop 1
 139: oInput 12
 141: oInput 0
 143: oGetAddrLocal 1
 145: oPushResult
 146: oSetResult 14
 148: oPushResult
 149: oSetResult 6
 151: oPushResult
 152: LAST_ID
 153: oPushResult
 154: oCall 7331
 156: oPop 3
 158: oAssign
 159: oGetLocal 1
 161: oPushResult
 162: oSetResult 20
 164: oPushResult
 165: oGetGlobal 3
 167: oPushResult
 168: oNodeSet
 169: oPop 3
 171: oGetLocal 1
 173: oPushResult
 174: oScopeDeclareAlloc
 175: oPop 1
 177: oInput 14
 179: oJumpForward 184
 181: Choice Lookup Table
          13    103
 184: oInput 4
 186: oInputChoice 197
 188: oGetLocal 4
 190: oPushResult
 191: oCall 269
 193: oPop 1
 195: oJumpForward 200
 197: Choice Lookup Table
          54    188
 200: oSetResult 0
 202: oPushResult
 203: oSetResult 0
 205: oPushResult
 206: oScopeBegin
 207: oPop 2
 209: oGetAddrLocal 5
 211: oPushResult
 212: oScopeCurrent
 213: oAssign
 214: oSetResult 0
 216: oPushResult
 217: oSetResult 1
 219: oPushResult
 220: oScopeBegin
 221: oPop 2
 223: oGetAddrGlobal 2
 225: oPushResult
 226: oScopeCurrent
 227: oAssign
 228: oGetLocal 4
 230: oPushResult
 231: oSetResult 7
 233: oPushResult
 234: oGetGlobal 2
 236: oPushResult
 237: oNodeSet
 238: oPop 3
 240: oScopeEnd
 241: oSetResult 15
 243: oPushResult
 244: oCall 907
 246: oPop 1
 248: oGetGlobal 2
 250: oPushResult
 251: oScopeEnter
 252: oPop 1
 254: oGetLocal 3
 256: oPushResult
 257: oGetLocal 5
 259: oPushResult
 260: oCall 957
 262: oPop 2
 264: oScopeEnd
 265: oInput 19
 267: oScopeEnd
 268: oReturn
 269: oLocalSpace 1
 271: oInput 0
 273: oGetAddrLocal 1
 275: oPushResult
 276: LAST_ID
 277: oPushResult
 278: oCall 338
 280: oPop 1
 282: oAssign
 283: oGetLocal 1
 285: oPushResult
 286: oSetResult 0
 288: oPushResult
 289: equal_node
 290: oPop 2
 292: oChoice 321
 294: oGetParam 1
 296: oPushResult
 297: oSetResult 5
 299: oPushResult
 300: oGetLocal 1
 302: oPushResult
 303: oNodeAddLast
 304: oPop 3
 306: oGetLocal 1
 308: oPushResult
 309: oSetResult 8
 311: oPushResult
 312: oNodeGet
 313: oPop 2
 315: oPushResult
 316: oScopeEnter
 317: oPop 1
 319: oJumpForward 324
 321: Choice Lookup Table
           0    294
 324: oInputChoice 328
 326: oJumpForward 333
 328: Choice Lookup Table
          12    326
 331: oJumpForward 335
 333: oJumpBack 271
 335: oInput 4
 337: oReturn
 338: oLocalSpace 2
 340: oSetResult 10
 342: oPushResult
 343: oMsg
 344: oPop 1
 346: oGetParam 1
 348: oPushResult
 349: oMsg
 350: oPop 1
 352: oGetAddrLocal 1
 354: oPushResult
 355: oGetGlobal 1
 357: oPushResult
 358: oSetResult 1
 360: oPushResult
 361: oSetResult 4
 363: oPushResult
 364: oGetParam 1
 366: oPushResult
 367: oNodeFind
 368: oPop 4
 370: oAssign
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 0
 376: oPushResult
 377: equal_node
 378: oPop 2
 380: oChoice 387
 382: oGetLocal 1
 384: oReturn
 385: oJumpForward 390
 387: Choice Lookup Table
           0    382
 390: oGetAddrLocal 2
 392: oPushResult
 393: oGetParam 1
 395: oPushResult
 396: oIncludeUnitFile
 397: oPop 1
 399: oAssign
 400: oGetLocal 2
 402: oChoice 411
 404: oError 24
 406: oSetResult 0
 408: oReturn
 409: oJumpForward 414
 411: Choice Lookup Table
           0    404
 414: oGetAddrLocal 1
 416: oPushResult
 417: oCall 425
 419: oAssign
 420: oIncludeEnd
 421: oGetLocal 1
 423: oReturn
 424: oReturn
 425: oLocalSpace 1
 427: oInput 55
 429: oInput 0
 431: oGetAddrLocal 1
 433: oPushResult
 434: oSetResult 5
 436: oPushResult
 437: oNodeNew
 438: oPop 1
 440: oAssign
 441: oGetLocal 1
 443: oPushResult
 444: oSetResult 4
 446: oPushResult
 447: LAST_ID
 448: oPushResult
 449: oNodeSetInt
 450: oPop 3
 452: oGetGlobal 1
 454: oPushResult
 455: oSetResult 1
 457: oPushResult
 458: oGetLocal 1
 460: oPushResult
 461: oNodeAddLast
 462: oPop 3
 464: oInput 4
 466: oInputChoice 477
 468: oGetLocal 1
 470: oPushResult
 471: oCall 269
 473: oPop 1
 475: oJumpForward 480
 477: Choice Lookup Table
          54    468
 480: oInput 56
 482: oSetResult 0
 484: oPushResult
 485: oSetResult 0
 487: oPushResult
 488: oScopeBegin
 489: oPop 2
 491: oGetLocal 1
 493: oPushResult
 494: oSetResult 8
 496: oPushResult
 497: oScopeCurrent
 498: oPushResult
 499: oNodeSet
 500: oPop 3
 502: oSetResult 0
 504: oPushResult
 505: oSetResult 1
 507: oPushResult
 508: oScopeBegin
 509: oPop 2
 511: oGetAddrGlobal 2
 513: oPushResult
 514: oScopeCurrent
 515: oAssign
 516: oGetLocal 1
 518: oPushResult
 519: oSetResult 12
 521: oPushResult
 522: oGetGlobal 2
 524: oPushResult
 525: oNodeSet
 526: oPop 3
 528: oScopeEnd
 529: oGetLocal 1
 531: oPushResult
 532: oCall 616
 534: oPop 1
 536: oInput 57
 538: oSetResult 0
 540: oPushResult
 541: oSetResult 0
 543: oPushResult
 544: oScopeBegin
 545: oPop 2
 547: oGetLocal 1
 549: oPushResult
 550: oSetResult 9
 552: oPushResult
 553: oScopeCurrent
 554: oPushResult
 555: oNodeSet
 556: oPop 3
 558: oGetLocal 1
 560: oPushResult
 561: oCall 661
 563: oPop 1
 565: oInputChoice 579
 567: oGetLocal 1
 569: oPushResult
 570: oSetResult 1
 572: oPushResult
 573: oCall 671
 575: oPop 2
 577: oJumpForward 592
 579: Choice Lookup Table
          58    567
 582: oGetLocal 1
 584: oPushResult
 585: oSetResult 0
 587: oPushResult
 588: oCall 671
 590: oPop 2
 592: oInputChoice 603
 594: oGetLocal 1
 596: oPushResult
 597: oCall 873
 599: oPop 1
 601: oJumpForward 606
 603: Choice Lookup Table
          59    594
 606: oInput 34
 608: oInput 19
 610: oScopeEnd
 611: oScopeEnd
 612: oGetLocal 1
 614: oReturn
 615: oReturn
 616: oLocalSpace 0
 618: oInputChoice 645
 620: oCall 2221
 622: oJumpForward 658
 624: oCall 2293
 626: oJumpForward 658
 628: oSetResult 15
 630: oPushResult
 631: oCall 2352
 633: oPop 1
 635: oJumpForward 658
 637: oCall 878
 639: oJumpForward 658
 641: oCall 883
 643: oJumpForward 658
 645: Choice Lookup Table
          29    641
          28    637
          32    628
          31    624
          30    620
 656: oJumpForward 660
 658: oJumpBack 618
 660: oReturn
 661: oLocalSpace 0
 663: oSetResult 15
 665: oPushResult
 666: oCall 907
 668: oPop 1
 670: oReturn
 671: oLocalSpace 5
 673: oGetAddrLocal 1
 675: oPushResult
 676: oLabelNew
 677: oAssign
 678: oEmit 56
 680: oGetLocal 1
 682: oPushResult
 683: oEmitLabel
 684: oPop 1
 686: oGetParam 2
 688: oPushResult
 689: oSetResult 10
 691: oPushResult
 692: oGetLocal 1
 694: oPushResult
 695: oNodeSetLabel
 696: oPop 3
 698: oEmit 52
 700: oGetAddrLocal 2
 702: oPushResult
 703: Here
 704: oAssign
 705: oEmit 64
 707: oGetAddrLocal 3
 709: oPushResult
 710: oGetParam 2
 712: oPushResult
 713: oSetResult 8
 715: oPushResult
 716: oNodeGet
 717: oPop 2
 719: oAssign
 720: oGetAddrLocal 4
 722: oPushResult
 723: oGetLocal 3
 725: oPushResult
 726: oSetResult 18
 728: oPushResult
 729: oNodeGetCode
 730: oPop 2
 732: oAssign
 733: oSetResult 3000
 735: oPushResult
 736: oMsg
 737: oPop 1
 739: oGetLocal 3
 741: oPushResult
 742: oMsgNodeLong
 743: oPop 1
 745: oSetResult 3001
 747: oPushResult
 748: oMsg
 749: oPop 1
 751: oGetLocal 4
 753: oPushResult
 754: oEmitCode
 755: oPop 1
 757: oGetLocal 3
 759: oPushResult
 760: oSetResult 18
 762: oPushResult
 763: oSetResult 0
 765: oPushResult
 766: oNodeSetCode
 767: oPop 3
 769: oGetAddrLocal 3
 771: oPushResult
 772: oGetParam 2
 774: oPushResult
 775: oSetResult 9
 777: oPushResult
 778: oNodeGet
 779: oPop 2
 781: oAssign
 782: oGetAddrLocal 4
 784: oPushResult
 785: oGetLocal 3
 787: oPushResult
 788: oSetResult 18
 790: oPushResult
 791: oNodeGetCode
 792: oPop 2
 794: oAssign
 795: oGetLocal 4
 797: oPushResult
 798: oEmitCode
 799: oPop 1
 801: oGetLocal 3
 803: oPushResult
 804: oSetResult 18
 806: oPushResult
 807: oSetResult 0
 809: oPushResult
 810: oNodeSetCode
 811: oPop 3
 813: oGetParam 2
 815: oPushResult
 816: oSetResult 12
 818: oPushResult
 819: oNodeGet
 820: oPop 2
 822: oPushResult
 823: oScopeEnter
 824: oPop 1
 826: oGetParam 1
 828: oChoice 845
 830: oCall 6128
 832: oInputChoice 838
 834: oCall 6128
 836: oJumpForward 841
 838: Choice Lookup Table
           4    834
 841: oJumpBack 832
 843: oJumpForward 848
 845: Choice Lookup Table
           1    830
 848: oEmit 51
 850: oGetAddrLocal 5
 852: oPushResult
 853: oScopeCurrent
 854: oPushResult
 855: oSetResult 16
 857: oPushResult
 858: oNodeGetInt
 859: oPop 2
 861: oAssign
 862: oGetLocal 2
 864: oPushResult
 865: oGetLocal 5
 867: oPushResult
 868: oPatch
 869: oPop 2
 871: oScopeEnd
 872: oReturn
 873: oLocalSpace 0
 875: oError 16
 877: oReturn
 878: oLocalSpace 0
 880: oError 16
 882: oReturn
 883: oLocalSpace 0
 885: oError 16
 887: oReturn
 888: oLocalSpace 0
 890: oGetParam 2
 892: oPushResult
 893: oCall 907
 895: oPop 1
 897: oGetParam 1
 899: oPushResult
 900: oScopeCurrent
 901: oPushResult
 902: oCall 957
 904: oPop 2
 906: oReturn
 907: oLocalSpace 0
 909: oInputChoice 936
 911: oCall 2221
 913: oJumpForward 949
 915: oCall 2293
 917: oJumpForward 949
 919: oGetParam 1
 921: oPushResult
 922: oCall 2352
 924: oPop 1
 926: oJumpForward 949
 928: oCall 1255
 930: oJumpForward 949
 932: oCall 1594
 934: oJumpForward 949
 936: Choice Lookup Table
          29    932
          28    928
          32    919
          31    915
          30    911
 947: oJumpForward 951
 949: oJumpBack 909
 951: oCall 954
 953: oReturn
 954: oLocalSpace 0
 956: oReturn
 957: oLocalSpace 5
 959: oEmit 56
 961: oGetParam 2
 963: oPushResult
 964: oEmitLabel
 965: oPop 1
 967: oEmit 52
 969: oGetAddrLocal 1
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 64
 976: oGetAddrLocal 2
 978: oPushResult
 979: oGetGlobal 1
 981: oPushResult
 982: oSetResult 1
 984: oPushResult
 985: oNodeGetIter
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 3
 991: oPushResult
 992: oGetLocal 2
 994: oPushResult
 995: oNodeIterValue
 996: oPop 1
 998: oAssign
 999: oGetLocal 3
1001: oPushResult
1002: oNodeNull
1003: oPop 1
1005: oChoice 1050
1007: oJumpForward 1058
1009: oJumpForward 1056
1011: oEmit 46
1013: oSetResult 0
1015: oPushResult
1016: oEmitInt
1017: oPop 1
1019: oEmit 49
1021: oGetLocal 3
1023: oPushResult
1024: oSetResult 10
1026: oPushResult
1027: oNodeGetLabel
1028: oPop 2
1030: oPushResult
1031: oEmitLabel
1032: oPop 1
1034: oEmit 48
1036: oSetResult 0
1038: oPushResult
1039: oEmitInt
1040: oPop 1
1042: oGetAddrLocal 2
1044: oPushResult
1045: oNodeIterNext
1046: oPop 1
1048: oJumpForward 1056
1050: Choice Lookup Table
           0   1011
           1   1007
1055: oEndChoice
1056: oJumpBack 989
1058: oGetAddrLocal 4
1060: oPushResult
1061: oGetParam 1
1063: oPushResult
1064: oSetResult 18
1066: oPushResult
1067: oNodeGetCode
1068: oPop 2
1070: oAssign
1071: oGetLocal 4
1073: oPushResult
1074: oEmitCode
1075: oPop 1
1077: oGetParam 1
1079: oPushResult
1080: oSetResult 18
1082: oPushResult
1083: oSetResult 0
1085: oPushResult
1086: oNodeSetCode
1087: oPop 3
1089: oCall 6128
1091: oEmit 51
1093: oGetAddrLocal 5
1095: oPushResult
1096: oScopeCurrent
1097: oPushResult
1098: oSetResult 16
1100: oPushResult
1101: oNodeGetInt
1102: oPop 2
1104: oAssign
1105: oGetLocal 1
1107: oPushResult
1108: oGetLocal 5
1110: oPushResult
1111: oPatch
1112: oPop 2
1114: oReturn
1115: oLocalSpace 0
1117: oInputChoice 1135
1119: oGetParam 1
1121: oPushResult
1122: oSetResult 26
1124: oPushResult
1125: oSetResult 1
1127: oPushResult
1128: oNodeSetBoolean
1129: oPop 3
1131: oInput 4
1133: oJumpForward 1140
1135: Choice Lookup Table
          67   1119
1138: oJumpForward 1142
1140: oJumpBack 1117
1142: oReturn
1143: oLocalSpace 1
1145: oGetAddrLocal 1
1147: oPushResult
1148: oScopeCurrent
1149: oPushResult
1150: oSetResult 18
1152: oPushResult
1153: oNodeGetCode
1154: oPop 2
1156: oAssign
1157: oGetLocal 1
1159: oPushResult
1160: oSetResult 0
1162: oPushResult
1163: equal_code
1164: oPop 2
1166: oChoice 1186
1168: oGetAddrLocal 1
1170: oPushResult
1171: oCodeNew
1172: oAssign
1173: oScopeCurrent
1174: oPushResult
1175: oSetResult 18
1177: oPushResult
1178: oGetLocal 1
1180: oPushResult
1181: oNodeSetCode
1182: oPop 3
1184: oJumpForward 1189
1186: Choice Lookup Table
           1   1168
1189: oGetLocal 1
1191: oReturn
1192: oReturn
1193: oLocalSpace 0
1195: oGetParam 1
1197: oPushResult
1198: oCall 7179
1200: oPop 1
1202: oPushResult
1203: equal_zero
1204: oPop 1
1206: oChoice 1212
1208: oError 23
1210: oJumpForward 1215
1212: Choice Lookup Table
           0   1208
1215: oGetParam 1
1217: oPushResult
1218: oSetResult 24
1220: oPushResult
1221: oSetResult 1
1223: oPushResult
1224: oNodeSetBoolean
1225: oPop 3
1227: oInputChoice 1251
1229: oInputChoice 1246
1231: oInput 2
1233: oGetParam 1
1235: oPushResult
1236: oSetResult 25
1238: oPushResult
1239: CURRENT_STRLIT
1240: oPushResult
1241: oNodeSetString
1242: oPop 3
1244: oJumpForward 1249
1246: Choice Lookup Table
          66   1231
1249: oJumpForward 1254
1251: Choice Lookup Table
           2   1229
1254: oReturn
1255: oLocalSpace 7
1257: oInput 0
1259: oGetAddrLocal 1
1261: oPushResult
1262: oSetResult 0
1264: oAssign
1265: oGetAddrLocal 2
1267: oPushResult
1268: oScopeFindInCurrentScope
1269: oAssign
1270: oGetLocal 2
1272: oPushResult
1273: oNodeNull
1274: oPop 1
1276: oChoice 1397
1278: oGetAddrLocal 2
1280: oPushResult
1281: oSetResult 10
1283: oPushResult
1284: oSetResult 2
1286: oPushResult
1287: LAST_ID
1288: oPushResult
1289: oCall 7331
1291: oPop 3
1293: oAssign
1294: oGetLocal 2
1296: oPushResult
1297: oSetResult 21
1299: oPushResult
1300: oLabelNew
1301: oPushResult
1302: oNodeSetLabel
1303: oPop 3
1305: oJumpForward 1403
1307: oGetAddrLocal 1
1309: oPushResult
1310: oSetResult 1
1312: oAssign
1313: oGetLocal 2
1315: oPushResult
1316: oSetResult 23
1318: oPushResult
1319: oNodeGetBoolean
1320: oPop 2
1322: oChoice 1328
1324: oError 21
1326: oJumpForward 1331
1328: Choice Lookup Table
           1   1324
1331: oGetLocal 2
1333: oPushResult
1334: oSetResult 24
1336: oPushResult
1337: oNodeGetBoolean
1338: oPop 2
1340: oChoice 1346
1342: oError 21
1344: oJumpForward 1349
1346: Choice Lookup Table
           1   1342
1349: oGetLocal 2
1351: oPushResult
1352: oNodeType
1353: oPop 1
1355: oChoice 1359
1357: oJumpForward 1364
1359: Choice Lookup Table
          10   1357
1362: oError 21
1364: oGetLocal 2
1366: oPushResult
1367: oSetResult 28
1369: oPushResult
1370: oGetLocal 2
1372: oPushResult
1373: oSetResult 22
1375: oPushResult
1376: oNodeGet
1377: oPop 2
1379: oPushResult
1380: oNodeSet
1381: oPop 3
1383: oGetLocal 2
1385: oPushResult
1386: oSetResult 22
1388: oPushResult
1389: oSetResult 0
1391: oPushResult
1392: oNodeSet
1393: oPop 3
1395: oJumpForward 1403
1397: Choice Lookup Table
           0   1307
           1   1278
1402: oEndChoice
1403: oGetAddrLocal 3
1405: oPushResult
1406: oCall 7167
1408: oAssign
1409: oGetAddrLocal 4
1411: oPushResult
1412: oGetLocal 3
1414: oPushResult
1415: oSetResult 0
1417: oPushResult
1418: greater
1419: oPop 2
1421: oAssign
1422: oGetAddrLocal 3
1424: oPushResult
1425: inc
1426: oPop 1
1428: oGetLocal 3
1430: oPushResult
1431: oSetResult 2
1433: oPushResult
1434: oScopeBegin
1435: oPop 2
1437: oGetAddrLocal 5
1439: oPushResult
1440: oScopeCurrent
1441: oAssign
1442: oGetLocal 4
1444: oChoice 1463
1446: oGetAddrLocal 6
1448: oPushResult
1449: oGetGlobal 4
1451: oPushResult
1452: oCall 7359
1454: oPop 1
1456: oPushResult
1457: oScopeAllocType
1458: oPop 1
1460: oAssign
1461: oJumpForward 1466
1463: Choice Lookup Table
           1   1446
1466: oCall 1994
1468: oGetLocal 2
1470: oPushResult
1471: oSetResult 22
1473: oPushResult
1474: oGetLocal 5
1476: oPushResult
1477: oNodeSet
1478: oPop 3
1480: oScopeEnd
1481: oInput 4
1483: oGetLocal 1
1485: oChoice 1497
1487: oGetLocal 2
1489: oPushResult
1490: oScopeDeclare
1491: oPop 1
1493: oJumpForward 1503
1495: oJumpForward 1503
1497: Choice Lookup Table
           1   1495
           0   1487
1502: oEndChoice
1503: oGetLocal 2
1505: oPushResult
1506: oCall 1115
1508: oPop 1
1510: oInputChoice 1523
1512: oJumpForward 1591
1514: oGetLocal 2
1516: oPushResult
1517: oCall 1193
1519: oPop 1
1521: oJumpForward 1591
1523: Choice Lookup Table
          65   1514
          64   1512
1528: oGetLocal 5
1530: oPushResult
1531: oScopeEnter
1532: oPop 1
1534: oGetLocal 3
1536: oPushResult
1537: oSetResult 1
1539: oPushResult
1540: oScopeBegin
1541: oPop 2
1543: oGetLocal 2
1545: oPushResult
1546: oSetResult 6
1548: oPushResult
1549: oScopeCurrent
1550: oPushResult
1551: oNodeSet
1552: oPop 3
1554: oGetAddrLocal 7
1556: oPushResult
1557: oGetLocal 2
1559: oPushResult
1560: oSetResult 21
1562: oPushResult
1563: oNodeGetLabel
1564: oPop 2
1566: oAssign
1567: oSetResult 16
1569: oPushResult
1570: oGetLocal 7
1572: oPushResult
1573: oCall 888
1575: oPop 2
1577: oGetLocal 2
1579: oPushResult
1580: oSetResult 23
1582: oPushResult
1583: oSetResult 1
1585: oPushResult
1586: oNodeSetBoolean
1587: oPop 3
1589: oScopeEnd
1590: oScopeEnd
1591: oInput 4
1593: oReturn
1594: oLocalSpace 9
1596: oInput 0
1598: oGetAddrLocal 1
1600: oPushResult
1601: oSetResult 0
1603: oAssign
1604: oGetAddrLocal 2
1606: oPushResult
1607: oScopeFindInCurrentScope
1608: oAssign
1609: oGetLocal 2
1611: oPushResult
1612: oNodeNull
1613: oPop 1
1615: oChoice 1749
1617: oGetAddrLocal 2
1619: oPushResult
1620: oSetResult 11
1622: oPushResult
1623: oSetResult 3
1625: oPushResult
1626: LAST_ID
1627: oPushResult
1628: oCall 7331
1630: oPop 3
1632: oAssign
1633: oGetLocal 2
1635: oPushResult
1636: oSetResult 21
1638: oPushResult
1639: oLabelNew
1640: oPushResult
1641: oNodeSetLabel
1642: oPop 3
1644: oJumpForward 1755
1646: oGetAddrLocal 1
1648: oPushResult
1649: oSetResult 1
1651: oAssign
1652: oGetLocal 2
1654: oPushResult
1655: oSetResult 23
1657: oPushResult
1658: oNodeGetBoolean
1659: oPop 2
1661: oChoice 1667
1663: oError 21
1665: oJumpForward 1670
1667: Choice Lookup Table
           1   1663
1670: oGetLocal 2
1672: oPushResult
1673: oNodeType
1674: oPop 1
1676: oChoice 1680
1678: oJumpForward 1685
1680: Choice Lookup Table
          11   1678
1683: oError 21
1685: oGetLocal 2
1687: oPushResult
1688: oSetResult 28
1690: oPushResult
1691: oGetLocal 2
1693: oPushResult
1694: oSetResult 22
1696: oPushResult
1697: oNodeGet
1698: oPop 2
1700: oPushResult
1701: oNodeSet
1702: oPop 3
1704: oGetLocal 2
1706: oPushResult
1707: oSetResult 22
1709: oPushResult
1710: oSetResult 0
1712: oPushResult
1713: oNodeSet
1714: oPop 3
1716: oGetLocal 2
1718: oPushResult
1719: oSetResult 29
1721: oPushResult
1722: oGetLocal 2
1724: oPushResult
1725: oSetResult 20
1727: oPushResult
1728: oNodeGet
1729: oPop 2
1731: oPushResult
1732: oNodeSet
1733: oPop 3
1735: oGetLocal 2
1737: oPushResult
1738: oSetResult 20
1740: oPushResult
1741: oSetResult 0
1743: oPushResult
1744: oNodeSet
1745: oPop 3
1747: oJumpForward 1755
1749: Choice Lookup Table
           0   1646
           1   1617
1754: oEndChoice
1755: oGetAddrLocal 3
1757: oPushResult
1758: oCall 7167
1760: oAssign
1761: oGetAddrLocal 4
1763: oPushResult
1764: oGetLocal 3
1766: oPushResult
1767: oSetResult 0
1769: oPushResult
1770: greater
1771: oPop 2
1773: oAssign
1774: oGetAddrLocal 3
1776: oPushResult
1777: inc
1778: oPop 1
1780: oGetLocal 3
1782: oPushResult
1783: oSetResult 2
1785: oPushResult
1786: oScopeBegin
1787: oPop 2
1789: oGetAddrLocal 5
1791: oPushResult
1792: oScopeCurrent
1793: oAssign
1794: oGetLocal 4
1796: oChoice 1815
1798: oGetAddrLocal 6
1800: oPushResult
1801: oGetGlobal 4
1803: oPushResult
1804: oCall 7359
1806: oPop 1
1808: oPushResult
1809: oScopeAllocType
1810: oPop 1
1812: oAssign
1813: oJumpForward 1818
1815: Choice Lookup Table
           1   1798
1818: oCall 1994
1820: oGetLocal 2
1822: oPushResult
1823: oSetResult 22
1825: oPushResult
1826: oGetLocal 5
1828: oPushResult
1829: oNodeSet
1830: oPop 3
1832: oInput 11
1834: oGetAddrLocal 7
1836: oPushResult
1837: oCall 2582
1839: oPop 1
1841: oGetLocal 2
1843: oPushResult
1844: oSetResult 20
1846: oPushResult
1847: oGetLocal 7
1849: oPushResult
1850: oNodeSet
1851: oPop 3
1853: oGetAddrLocal 8
1855: oPushResult
1856: oGetLocal 7
1858: oPushResult
1859: oCall 7359
1861: oPop 1
1863: oAssign
1864: oGetLocal 2
1866: oPushResult
1867: oSetResult 30
1869: oPushResult
1870: oGetLocal 8
1872: oPushResult
1873: oScopeAllocType
1874: oPop 1
1876: oPushResult
1877: oNodeSetInt
1878: oPop 3
1880: oScopeEnd
1881: oInput 4
1883: oGetLocal 1
1885: oChoice 1897
1887: oGetLocal 2
1889: oPushResult
1890: oScopeDeclare
1891: oPop 1
1893: oJumpForward 1903
1895: oJumpForward 1903
1897: Choice Lookup Table
           1   1895
           0   1887
1902: oEndChoice
1903: oGetLocal 2
1905: oPushResult
1906: oCall 1115
1908: oPop 1
1910: oInputChoice 1923
1912: oJumpForward 1991
1914: oGetLocal 2
1916: oPushResult
1917: oCall 1193
1919: oPop 1
1921: oJumpForward 1991
1923: Choice Lookup Table
          65   1914
          64   1912
1928: oGetLocal 5
1930: oPushResult
1931: oScopeEnter
1932: oPop 1
1934: oGetLocal 3
1936: oPushResult
1937: oSetResult 1
1939: oPushResult
1940: oScopeBegin
1941: oPop 2
1943: oGetLocal 2
1945: oPushResult
1946: oSetResult 6
1948: oPushResult
1949: oScopeCurrent
1950: oPushResult
1951: oNodeSet
1952: oPop 3
1954: oGetAddrLocal 9
1956: oPushResult
1957: oGetLocal 2
1959: oPushResult
1960: oSetResult 21
1962: oPushResult
1963: oNodeGetLabel
1964: oPop 2
1966: oAssign
1967: oSetResult 16
1969: oPushResult
1970: oGetLocal 9
1972: oPushResult
1973: oCall 888
1975: oPop 2
1977: oGetLocal 2
1979: oPushResult
1980: oSetResult 23
1982: oPushResult
1983: oSetResult 1
1985: oPushResult
1986: oNodeSetBoolean
1987: oPop 3
1989: oScopeEnd
1990: oScopeEnd
1991: oInput 4
1993: oReturn
1994: oLocalSpace 6
1996: oInputChoice 2217
1998: oGetAddrLocal 1
2000: oPushResult
2001: oNodeVecNew
2002: oAssign
2003: oGetAddrLocal 3
2005: oPushResult
2006: oSetResult 0
2008: oAssign
2009: oInputChoice 2019
2011: oGetAddrLocal 3
2013: oPushResult
2014: oSetResult 1
2016: oAssign
2017: oJumpForward 2022
2019: Choice Lookup Table
          32   2011
2022: oInput 0
2024: oGetAddrLocal 2
2026: oPushResult
2027: oSetResult 18
2029: oPushResult
2030: oSetResult 6
2032: oPushResult
2033: LAST_ID
2034: oPushResult
2035: oCall 7331
2037: oPop 3
2039: oAssign
2040: oGetLocal 2
2042: oPushResult
2043: oSetResult 31
2045: oPushResult
2046: oGetLocal 3
2048: oPushResult
2049: oNodeSetBoolean
2050: oPop 3
2052: oGetLocal 1
2054: oPushResult
2055: oGetLocal 2
2057: oPushResult
2058: oNodeVecAppend
2059: oPop 2
2061: oInputChoice 2069
2063: oJumpForward 2077
2065: oJumpForward 2075
2067: oJumpForward 2075
2069: Choice Lookup Table
          12   2067
          11   2063
2074: oEndChoice
2075: oJumpBack 2022
2077: oGetAddrLocal 4
2079: oPushResult
2080: oCall 2582
2082: oPop 1
2084: oGetLocal 3
2086: oChoice 2101
2088: oGetAddrLocal 5
2090: oPushResult
2091: oGetLocal 4
2093: oPushResult
2094: oCall 7359
2096: oPop 1
2098: oAssign
2099: oJumpForward 2110
2101: Choice Lookup Table
           1   2088
2104: oGetAddrLocal 5
2106: oPushResult
2107: oGetLocal 4
2109: oAssign
2110: oGetAddrLocal 6
2112: oPushResult
2113: oSetResult 0
2115: oAssign
2116: oGetLocal 6
2118: oPushResult
2119: oGetLocal 1
2121: oPushResult
2122: oNodeVecSize
2123: oPop 1
2125: oPushResult
2126: equal
2127: oPop 2
2129: oChoice 2186
2131: oGetAddrLocal 2
2133: oPushResult
2134: oGetLocal 1
2136: oPushResult
2137: oGetLocal 6
2139: oPushResult
2140: oNodeVecElement
2141: oPop 2
2143: oAssign
2144: oGetLocal 2
2146: oPushResult
2147: oSetResult 20
2149: oPushResult
2150: oGetLocal 4
2152: oPushResult
2153: oNodeSet
2154: oPop 3
2156: oGetLocal 2
2158: oPushResult
2159: oScopeDeclare
2160: oPop 1
2162: oGetLocal 2
2164: oPushResult
2165: oSetResult 21
2167: oPushResult
2168: oGetLocal 5
2170: oPushResult
2171: oScopeAllocType
2172: oPop 1
2174: oPushResult
2175: oNodeSetInt
2176: oPop 3
2178: oGetAddrLocal 6
2180: oPushResult
2181: inc
2182: oPop 1
2184: oJumpForward 2191
2186: Choice Lookup Table
           0   2131
2189: oJumpForward 2193
2191: oJumpBack 2116
2193: oGetLocal 1
2195: oPushResult
2196: oNodeVecDelete
2197: oPop 1
2199: oInputChoice 2207
2201: oJumpForward 2215
2203: oJumpForward 2213
2205: oJumpForward 2213
2207: Choice Lookup Table
           4   2205
          14   2201
2212: oEndChoice
2213: oJumpBack 1998
2215: oJumpForward 2220
2217: Choice Lookup Table
          13   1998
2220: oReturn
2221: oLocalSpace 2
2223: oInputChoice 2285
2225: oGetAddrLocal 1
2227: oPushResult
2228: oSetResult 12
2230: oPushResult
2231: oSetResult 4
2233: oPushResult
2234: LAST_ID
2235: oPushResult
2236: oCall 7331
2238: oPop 3
2240: oAssign
2241: oInput 5
2243: oCall 3059
2245: oGetAddrLocal 2
2247: oPushResult
2248: oValueTop
2249: oAssign
2250: oValuePop
2251: oGetLocal 1
2253: oPushResult
2254: oSetResult 21
2256: oPushResult
2257: oGetLocal 2
2259: oPushResult
2260: oNodeSetInt
2261: oPop 3
2263: oGetLocal 1
2265: oPushResult
2266: oSetResult 20
2268: oPushResult
2269: oGetGlobal 4
2271: oPushResult
2272: oNodeSet
2273: oPop 3
2275: oGetLocal 1
2277: oPushResult
2278: oScopeDeclare
2279: oPop 1
2281: oInput 4
2283: oJumpForward 2290
2285: Choice Lookup Table
           0   2225
2288: oJumpForward 2292
2290: oJumpBack 2223
2292: oReturn
2293: oLocalSpace 2
2295: oInputChoice 2344
2297: oGetAddrLocal 1
2299: oPushResult
2300: oSetResult 13
2302: oPushResult
2303: oSetResult 5
2305: oPushResult
2306: LAST_ID
2307: oPushResult
2308: oCall 7331
2310: oPop 3
2312: oAssign
2313: oInput 5
2315: oGetAddrLocal 2
2317: oPushResult
2318: oCall 2582
2320: oPop 1
2322: oGetLocal 1
2324: oPushResult
2325: oSetResult 20
2327: oPushResult
2328: oGetLocal 2
2330: oPushResult
2331: oNodeSet
2332: oPop 3
2334: oGetLocal 1
2336: oPushResult
2337: oScopeDeclare
2338: oPop 1
2340: oInput 4
2342: oJumpForward 2349
2344: Choice Lookup Table
           0   2297
2347: oJumpForward 2351
2349: oJumpBack 2295
2351: oReturn
2352: oLocalSpace 6
2354: oInputChoice 2574
2356: oGetAddrLocal 1
2358: oPushResult
2359: oNodeVecNew
2360: oAssign
2361: oGetAddrLocal 2
2363: oPushResult
2364: oGetParam 1
2366: oPushResult
2367: oSetResult 6
2369: oPushResult
2370: LAST_ID
2371: oPushResult
2372: oCall 7331
2374: oPop 3
2376: oAssign
2377: oGetLocal 1
2379: oPushResult
2380: oGetLocal 2
2382: oPushResult
2383: oNodeVecAppend
2384: oPop 2
2386: oInputChoice 2392
2388: oInput 0
2390: oJumpForward 2397
2392: Choice Lookup Table
          12   2388
2395: oJumpForward 2399
2397: oJumpBack 2361
2399: oInput 11
2401: oGetAddrLocal 3
2403: oPushResult
2404: oCall 2582
2406: oPop 1
2408: oGetAddrLocal 4
2410: oPushResult
2411: oSetResult 0
2413: oAssign
2414: oGetLocal 4
2416: oPushResult
2417: oGetLocal 1
2419: oPushResult
2420: oNodeVecSize
2421: oPop 1
2423: oPushResult
2424: equal
2425: oPop 2
2427: oChoice 2468
2429: oGetAddrLocal 2
2431: oPushResult
2432: oGetLocal 1
2434: oPushResult
2435: oGetLocal 4
2437: oPushResult
2438: oNodeVecElement
2439: oPop 2
2441: oAssign
2442: oGetLocal 2
2444: oPushResult
2445: oSetResult 20
2447: oPushResult
2448: oGetLocal 3
2450: oPushResult
2451: oNodeSet
2452: oPop 3
2454: oGetLocal 2
2456: oPushResult
2457: oScopeDeclareAlloc
2458: oPop 1
2460: oGetAddrLocal 4
2462: oPushResult
2463: inc
2464: oPop 1
2466: oJumpForward 2473
2468: Choice Lookup Table
           0   2429
2471: oJumpForward 2475
2473: oJumpBack 2414
2475: oInputChoice 2561
2477: oGetLocal 1
2479: oPushResult
2480: oNodeVecSize
2481: oPop 1
2483: oChoice 2487
2485: oJumpForward 2492
2487: Choice Lookup Table
           1   2485
2490: oError 22
2492: oGetAddrLocal 5
2494: oPushResult
2495: oCall 1143
2497: oAssign
2498: oGetLocal 5
2500: oPushResult
2501: oCodePush
2502: oPop 1
2504: oGetAddrLocal 6
2506: oPushResult
2507: oSetResult 0
2509: oAssign
2510: oCall 7167
2512: oPushResult
2513: equal_zero
2514: oPop 1
2516: oChoice 2532
2518: oGetGlobal 2
2520: oPushResult
2521: oScopeEnter
2522: oPop 1
2524: oGetAddrLocal 6
2526: oPushResult
2527: oSetResult 1
2529: oAssign
2530: oJumpForward 2535
2532: Choice Lookup Table
           1   2518
2535: oGetLocal 2
2537: oPushResult
2538: oCall 6486
2540: oPop 1
2542: oCall 3125
2544: oCall 7217
2546: oCall 6280
2548: oGetLocal 6
2550: oChoice 2555
2552: oScopeEnd
2553: oJumpForward 2558
2555: Choice Lookup Table
           1   2552
2558: oCodePop
2559: oJumpForward 2564
2561: Choice Lookup Table
           5   2477
2564: oGetLocal 1
2566: oPushResult
2567: oNodeVecDelete
2568: oPop 1
2570: oInput 4
2572: oJumpForward 2579
2574: Choice Lookup Table
           0   2356
2577: oJumpForward 2581
2579: oJumpBack 2354
2581: oReturn
2582: oLocalSpace 12
2584: oInputChoice 3041
2586: oGetAddrLocal 1
2588: oPushResult
2589: oScopeFindRequire
2590: oAssign
2591: oGetLocal 1
2593: oPushResult
2594: oNodeType
2595: oPop 1
2597: oChoice 2614
2599: oGetParam 1
2601: oPushResult
2602: oGetLocal 1
2604: oPushResult
2605: oSetResult 20
2607: oPushResult
2608: oNodeGet
2609: oPop 2
2611: oAssign
2612: oJumpForward 2625
2614: Choice Lookup Table
          13   2599
2617: oError 2
2619: oGetParam 1
2621: oPushResult
2622: oGetGlobal 4
2624: oAssign
2625: oJumpForward 3058
2627: oInput 15
2629: oGetAddrLocal 2
2631: oPushResult
2632: oNodeVecNew
2633: oAssign
2634: oGetAddrLocal 3
2636: oPushResult
2637: oSetResult 28
2639: oPushResult
2640: oNodeNew
2641: oPop 1
2643: oAssign
2644: oGetLocal 3
2646: oPushResult
2647: oSetResult 33
2649: oPushResult
2650: oGetGlobal 4
2652: oPushResult
2653: oNodeSet
2654: oPop 3
2656: oCall 3059
2658: oGetLocal 3
2660: oPushResult
2661: oSetResult 35
2663: oPushResult
2664: oValueTop
2665: oPushResult
2666: oNodeSetInt
2667: oPop 3
2669: oValuePop
2670: oInput 20
2672: oCall 3059
2674: oGetLocal 3
2676: oPushResult
2677: oSetResult 36
2679: oPushResult
2680: oValueTop
2681: oPushResult
2682: oNodeSetInt
2683: oPop 3
2685: oValuePop
2686: oGetLocal 3
2688: oPushResult
2689: oSetResult 16
2691: oPushResult
2692: oSetResult 4
2694: oPushResult
2695: oNodeSetInt
2696: oPop 3
2698: oGetLocal 3
2700: oPushResult
2701: oTypeAdd
2702: oPop 1
2704: oGetAddrLocal 4
2706: oPushResult
2707: oSetResult 27
2709: oPushResult
2710: oNodeNew
2711: oPop 1
2713: oAssign
2714: oGetLocal 4
2716: oPushResult
2717: oSetResult 34
2719: oPushResult
2720: oGetLocal 3
2722: oPushResult
2723: oNodeSet
2724: oPop 3
2726: oGetLocal 2
2728: oPushResult
2729: oGetLocal 4
2731: oPushResult
2732: oNodeVecAppend
2733: oPop 2
2735: oInputChoice 2743
2737: oJumpForward 2751
2739: oJumpForward 2749
2741: oJumpForward 2749
2743: Choice Lookup Table
          12   2741
          16   2737
2748: oEndChoice
2749: oJumpBack 2634
2751: oInput 38
2753: oGetAddrLocal 5
2755: oPushResult
2756: oCall 2582
2758: oPop 1
2760: oGetAddrLocal 6
2762: oPushResult
2763: oGetLocal 2
2765: oPushResult
2766: oNodeVecSize
2767: oPop 1
2769: oAssign
2770: oGetAddrLocal 6
2772: oPushResult
2773: dec
2774: oPop 1
2776: oGetAddrLocal 7
2778: oPushResult
2779: oGetLocal 2
2781: oPushResult
2782: oGetLocal 6
2784: oPushResult
2785: oNodeVecElement
2786: oPop 2
2788: oAssign
2789: oGetLocal 7
2791: oPushResult
2792: oSetResult 33
2794: oPushResult
2795: oGetLocal 5
2797: oPushResult
2798: oNodeSet
2799: oPop 3
2801: oGetAddrLocal 8
2803: oPushResult
2804: oGetLocal 7
2806: oPushResult
2807: oSetResult 34
2809: oPushResult
2810: oNodeGet
2811: oPop 2
2813: oAssign
2814: oGetAddrLocal 9
2816: oPushResult
2817: oGetLocal 8
2819: oPushResult
2820: oSetResult 36
2822: oPushResult
2823: oNodeGetInt
2824: oPop 2
2826: oPushResult
2827: oGetLocal 8
2829: oPushResult
2830: oSetResult 35
2832: oPushResult
2833: oNodeGetInt
2834: oPop 2
2836: oPushResult
2837: subtract
2838: oPop 2
2840: oAssign
2841: oGetAddrLocal 9
2843: oPushResult
2844: inc
2845: oPop 1
2847: oGetLocal 7
2849: oPushResult
2850: oSetResult 16
2852: oPushResult
2853: oGetLocal 9
2855: oPushResult
2856: oGetLocal 5
2858: oPushResult
2859: oSetResult 16
2861: oPushResult
2862: oNodeGetInt
2863: oPop 2
2865: oPushResult
2866: multiply
2867: oPop 2
2869: oPushResult
2870: oNodeSetInt
2871: oPop 3
2873: oGetLocal 7
2875: oPushResult
2876: oTypeAdd
2877: oPop 1
2879: oGetAddrLocal 5
2881: oPushResult
2882: oGetLocal 7
2884: oAssign
2885: oGetLocal 6
2887: oPushResult
2888: equal_zero
2889: oPop 1
2891: oChoice 2897
2893: oJumpForward 2902
2895: oJumpForward 2900
2897: Choice Lookup Table
           1   2893
2900: oJumpBack 2770
2902: oGetParam 1
2904: oPushResult
2905: oGetLocal 2
2907: oPushResult
2908: oSetResult 0
2910: oPushResult
2911: oNodeVecElement
2912: oPop 2
2914: oAssign
2915: oGetLocal 2
2917: oPushResult
2918: oNodeVecDelete
2919: oPop 1
2921: oJumpForward 3058
2923: oGetAddrLocal 10
2925: oPushResult
2926: oCall 2582
2928: oPop 1
2930: oGetParam 1
2932: oPushResult
2933: oGetLocal 10
2935: oPushResult
2936: oCall 7359
2938: oPop 1
2940: oAssign
2941: oJumpForward 3058
2943: oGetParam 1
2945: oPushResult
2946: oSetResult 29
2948: oPushResult
2949: oNodeNew
2950: oPop 1
2952: oAssign
2953: oSetResult -1
2955: oPushResult
2956: oSetResult 2
2958: oPushResult
2959: oScopeBegin
2960: oPop 2
2962: oSetResult 17
2964: oPushResult
2965: oCall 2352
2967: oPop 1
2969: oGetAddrLocal 11
2971: oPushResult
2972: oScopeCurrent
2973: oPushResult
2974: oSetResult 16
2976: oPushResult
2977: oNodeGetInt
2978: oPop 2
2980: oAssign
2981: oGetLocal 11
2983: oPushResult
2984: equal_zero
2985: oPop 1
2987: oChoice 2993
2989: oError 19
2991: oJumpForward 2996
2993: Choice Lookup Table
           1   2989
2996: oInput 34
2998: oGetFromParam 1
3000: oPushResult
3001: oSetResult 37
3003: oPushResult
3004: oScopeCurrent
3005: oPushResult
3006: oNodeSet
3007: oPop 3
3009: oGetFromParam 1
3011: oPushResult
3012: oSetResult 16
3014: oPushResult
3015: oGetLocal 11
3017: oPushResult
3018: oNodeSetInt
3019: oPop 3
3021: oScopeEnd
3022: oGetFromParam 1
3024: oPushResult
3025: oTypeAdd
3026: oPop 1
3028: oJumpForward 3058
3030: oInput 38
3032: oGetAddrLocal 12
3034: oPushResult
3035: oCall 2582
3037: oPop 1
3039: oJumpForward 3058
3041: Choice Lookup Table
          37   3030
          36   2943
          17   2923
          35   2627
           0   2586
3052: oCall 3059
3054: oInput 20
3056: oCall 3059
3058: oReturn
3059: oLocalSpace 1
3061: oInputChoice 3116
3063: TOKEN_VALUE
3064: oPushResult
3065: oValuePush
3066: oPop 1
3068: oJumpForward 3124
3070: oGetAddrLocal 1
3072: oPushResult
3073: oScopeFindRequire
3074: oAssign
3075: oGetLocal 1
3077: oPushResult
3078: oNodeType
3079: oPop 1
3081: oChoice 3098
3083: oGetLocal 1
3085: oPushResult
3086: oSetResult 21
3088: oPushResult
3089: oNodeGetInt
3090: oPop 2
3092: oPushResult
3093: oValuePush
3094: oPop 1
3096: oJumpForward 3109
3098: Choice Lookup Table
          12   3083
3101: oError 1
3103: oSetResult 0
3105: oPushResult
3106: oValuePush
3107: oPop 1
3109: oJumpForward 3124
3111: oCall 3059
3113: oValueNegate
3114: oJumpForward 3124
3116: Choice Lookup Table
          24   3111
           0   3070
           1   3063
3123: oEndChoice
3124: oReturn
3125: oLocalSpace 1
3127: oGetAddrLocal 1
3129: oPushResult
3130: oSetResult 0
3132: oAssign
3133: oGetAddrLocal 1
3135: oPushResult
3136: oCall 3286
3138: oPop 1
3140: oGetAddrLocal 1
3142: oPushResult
3143: oCall 3186
3145: oPop 1
3147: oReturn
3148: oLocalSpace 0
3150: oGetParam 1
3152: oPushResult
3153: oCall 3286
3155: oPop 1
3157: oTypeSNodeType
3158: oChoice 3177
3160: oJumpForward 3184
3162: oGetParam 1
3164: oPushResult
3165: oLabelNew
3166: oAssign
3167: oEmit 55
3169: oGetFromParam 1
3171: oPushResult
3172: oEmitLabel
3173: oPop 1
3175: oJumpForward 3184
3177: Choice Lookup Table
          22   3162
          23   3160
3182: oError 8
3184: oTypeSPop
3185: oReturn
3186: oLocalSpace 1
3188: oTypeSNodeType
3189: oChoice 3251
3191: oGetAddrLocal 1
3193: oPushResult
3194: oLabelNew
3195: oAssign
3196: oEmit 15
3198: oSetResult 1
3200: oPushResult
3201: oEmitInt
3202: oPop 1
3204: oEmit 53
3206: oGetLocal 1
3208: oPushResult
3209: oEmitLabel
3210: oPop 1
3212: oEmit 56
3214: oGetFromParam 1
3216: oPushResult
3217: oEmitLabel
3218: oPop 1
3220: oEmit 15
3222: oSetResult 0
3224: oPushResult
3225: oEmitInt
3226: oPop 1
3228: oEmit 56
3230: oGetLocal 1
3232: oPushResult
3233: oEmitLabel
3234: oPop 1
3236: oTypeSPop
3237: oGetGlobal 5
3239: oPushResult
3240: oTypeSPush
3241: oPop 1
3243: oGetParam 1
3245: oPushResult
3246: oSetResult 0
3248: oAssign
3249: oJumpForward 3254
3251: Choice Lookup Table
          23   3191
3254: oReturn
3255: oLocalSpace 0
3257: oTypeSNodeType
3258: oChoice 3282
3260: oGetParam 1
3262: oPushResult
3263: oLabelNew
3264: oAssign
3265: oEmit 55
3267: oGetFromParam 1
3269: oPushResult
3270: oEmitLabel
3271: oPop 1
3273: oTypeSPop
3274: oGetGlobal 6
3276: oPushResult
3277: oTypeSPush
3278: oPop 1
3280: oJumpForward 3285
3282: Choice Lookup Table
          22   3260
3285: oReturn
3286: oLocalSpace 0
3288: oGetParam 1
3290: oPushResult
3291: oCall 3651
3293: oPop 1
3295: oInputChoice 3633
3297: oGetParam 1
3299: oPushResult
3300: oCall 3186
3302: oPop 1
3304: oGetParam 1
3306: oPushResult
3307: oCall 3651
3309: oPop 1
3311: oGetParam 1
3313: oPushResult
3314: oCall 3186
3316: oPop 1
3318: oCall 7217
3320: oTypeSNodeType
3321: oChoice 3335
3323: oEmit 38
3325: oJumpForward 3348
3327: oEmit 44
3329: oJumpForward 3348
3331: oError 16
3333: oJumpForward 3348
3335: Choice Lookup Table
          25   3331
          24   3331
          26   3327
          22   3323
          21   3323
3346: oError 17
3348: oTypeSPop
3349: oGetGlobal 5
3351: oPushResult
3352: oTypeSPush
3353: oPop 1
3355: oJumpForward 3648
3357: oGetParam 1
3359: oPushResult
3360: oCall 3186
3362: oPop 1
3364: oGetParam 1
3366: oPushResult
3367: oCall 3651
3369: oPop 1
3371: oGetParam 1
3373: oPushResult
3374: oCall 3186
3376: oPop 1
3378: oCall 7217
3380: oTypeSNodeType
3381: oChoice 3395
3383: oEmit 39
3385: oJumpForward 3408
3387: oEmit 45
3389: oJumpForward 3408
3391: oError 16
3393: oJumpForward 3408
3395: Choice Lookup Table
          25   3391
          24   3391
          26   3387
          22   3383
          21   3383
3406: oError 17
3408: oTypeSPop
3409: oGetGlobal 5
3411: oPushResult
3412: oTypeSPush
3413: oPop 1
3415: oJumpForward 3648
3417: oGetParam 1
3419: oPushResult
3420: oCall 3186
3422: oPop 1
3424: oGetParam 1
3426: oPushResult
3427: oCall 3651
3429: oPop 1
3431: oGetParam 1
3433: oPushResult
3434: oCall 3186
3436: oPop 1
3438: oCall 7217
3440: oTypeSNodeType
3441: oChoice 3451
3443: oEmit 41
3445: oJumpForward 3462
3447: oError 16
3449: oJumpForward 3462
3451: Choice Lookup Table
          25   3447
          24   3447
          22   3443
          21   3443
3460: oError 17
3462: oTypeSPop
3463: oGetGlobal 5
3465: oPushResult
3466: oTypeSPush
3467: oPop 1
3469: oJumpForward 3648
3471: oGetParam 1
3473: oPushResult
3474: oCall 3186
3476: oPop 1
3478: oGetParam 1
3480: oPushResult
3481: oCall 3651
3483: oPop 1
3485: oGetParam 1
3487: oPushResult
3488: oCall 3186
3490: oPop 1
3492: oCall 7217
3494: oTypeSNodeType
3495: oChoice 3505
3497: oEmit 40
3499: oJumpForward 3516
3501: oError 16
3503: oJumpForward 3516
3505: Choice Lookup Table
          25   3501
          24   3501
          22   3497
          21   3497
3514: oError 17
3516: oTypeSPop
3517: oGetGlobal 5
3519: oPushResult
3520: oTypeSPush
3521: oPop 1
3523: oJumpForward 3648
3525: oGetParam 1
3527: oPushResult
3528: oCall 3186
3530: oPop 1
3532: oGetParam 1
3534: oPushResult
3535: oCall 3651
3537: oPop 1
3539: oGetParam 1
3541: oPushResult
3542: oCall 3186
3544: oPop 1
3546: oCall 7217
3548: oTypeSNodeType
3549: oChoice 3559
3551: oEmit 43
3553: oJumpForward 3570
3555: oError 16
3557: oJumpForward 3570
3559: Choice Lookup Table
          25   3555
          24   3555
          22   3551
          21   3551
3568: oError 17
3570: oTypeSPop
3571: oGetGlobal 5
3573: oPushResult
3574: oTypeSPush
3575: oPop 1
3577: oJumpForward 3648
3579: oGetParam 1
3581: oPushResult
3582: oCall 3186
3584: oPop 1
3586: oGetParam 1
3588: oPushResult
3589: oCall 3651
3591: oPop 1
3593: oGetParam 1
3595: oPushResult
3596: oCall 3186
3598: oPop 1
3600: oCall 7217
3602: oTypeSNodeType
3603: oChoice 3613
3605: oEmit 42
3607: oJumpForward 3624
3609: oError 16
3611: oJumpForward 3624
3613: Choice Lookup Table
          25   3609
          24   3609
          22   3605
          21   3605
3622: oError 17
3624: oTypeSPop
3625: oGetGlobal 5
3627: oPushResult
3628: oTypeSPush
3629: oPop 1
3631: oJumpForward 3648
3633: Choice Lookup Table
          10   3579
           9   3525
           8   3471
           7   3417
           6   3357
           5   3297
3646: oJumpForward 3650
3648: oJumpBack 3295
3650: oReturn
3651: oLocalSpace 1
3653: oGetAddrLocal 1
3655: oPushResult
3656: oSetResult 0
3658: oAssign
3659: oGetParam 1
3661: oPushResult
3662: oCall 3831
3664: oPop 1
3666: oInputChoice 3799
3668: oTypeSNodeType
3669: oChoice 3740
3671: oGetLocal 1
3673: oPushResult
3674: oSetResult 0
3676: oPushResult
3677: equal_label
3678: oPop 2
3680: oChoice 3689
3682: oGetAddrLocal 1
3684: oPushResult
3685: oLabelNew
3686: oAssign
3687: oJumpForward 3692
3689: Choice Lookup Table
           1   3682
3692: oEmit 53
3694: oGetLocal 1
3696: oPushResult
3697: oEmitLabel
3698: oPop 1
3700: oJumpForward 3747
3702: oGetParam 1
3704: oPushResult
3705: oCall 3255
3707: oPop 1
3709: oGetLocal 1
3711: oPushResult
3712: oSetResult 0
3714: oPushResult
3715: equal_label
3716: oPop 2
3718: oChoice 3727
3720: oGetAddrLocal 1
3722: oPushResult
3723: oLabelNew
3724: oAssign
3725: oJumpForward 3730
3727: Choice Lookup Table
           1   3720
3730: oEmit 53
3732: oGetLocal 1
3734: oPushResult
3735: oEmitLabel
3736: oPop 1
3738: oJumpForward 3747
3740: Choice Lookup Table
          22   3702
          23   3671
3745: oError 8
3747: oTypeSPop
3748: oEmit 56
3750: oGetFromParam 1
3752: oPushResult
3753: oEmitLabel
3754: oPop 1
3756: oGetParam 1
3758: oPushResult
3759: oSetResult 0
3761: oAssign
3762: oGetParam 1
3764: oPushResult
3765: oCall 3831
3767: oPop 1
3769: oTypeSNodeType
3770: oChoice 3783
3772: oJumpForward 3790
3774: oGetParam 1
3776: oPushResult
3777: oCall 3255
3779: oPop 1
3781: oJumpForward 3790
3783: Choice Lookup Table
          22   3774
          23   3772
3788: oError 8
3790: oTypeSPop
3791: oGetGlobal 6
3793: oPushResult
3794: oTypeSPush
3795: oPop 1
3797: oJumpForward 3804
3799: Choice Lookup Table
          52   3668
3802: oJumpForward 3806
3804: oJumpBack 3666
3806: oGetLocal 1
3808: oPushResult
3809: oSetResult 0
3811: oPushResult
3812: equal_label
3813: oPop 2
3815: oChoice 3827
3817: oEmit 56
3819: oGetLocal 1
3821: oPushResult
3822: oEmitLabel
3823: oPop 1
3825: oJumpForward 3830
3827: Choice Lookup Table
           0   3817
3830: oReturn
3831: oLocalSpace 2
3833: oGetAddrLocal 1
3835: oPushResult
3836: oSetResult 0
3838: oAssign
3839: oGetParam 1
3841: oPushResult
3842: oCall 3969
3844: oPop 1
3846: oInputChoice 3961
3848: oTypeSNodeType
3849: oChoice 3862
3851: oJumpForward 3869
3853: oGetParam 1
3855: oPushResult
3856: oCall 3255
3858: oPop 1
3860: oJumpForward 3869
3862: Choice Lookup Table
          22   3853
          23   3851
3867: oError 8
3869: oTypeSPop
3870: oGetLocal 1
3872: oPushResult
3873: oSetResult 0
3875: oPushResult
3876: equal_label
3877: oPop 2
3879: oChoice 3908
3881: oGetAddrLocal 1
3883: oPushResult
3884: oLabelNew
3885: oAssign
3886: oEmit 57
3888: oGetFromParam 1
3890: oPushResult
3891: oEmitLabel
3892: oPop 1
3894: oGetLocal 1
3896: oPushResult
3897: oEmitLabel
3898: oPop 1
3900: oGetParam 1
3902: oPushResult
3903: oGetLocal 1
3905: oAssign
3906: oJumpForward 3911
3908: Choice Lookup Table
           1   3881
3911: oGetAddrLocal 2
3913: oPushResult
3914: oSetResult 0
3916: oAssign
3917: oGetAddrLocal 2
3919: oPushResult
3920: oCall 3969
3922: oPop 1
3924: oTypeSNodeType
3925: oChoice 3938
3927: oJumpForward 3945
3929: oGetAddrLocal 2
3931: oPushResult
3932: oCall 3255
3934: oPop 1
3936: oJumpForward 3945
3938: Choice Lookup Table
          22   3929
          23   3927
3943: oError 8
3945: oEmit 57
3947: oGetLocal 2
3949: oPushResult
3950: oEmitLabel
3951: oPop 1
3953: oGetLocal 1
3955: oPushResult
3956: oEmitLabel
3957: oPop 1
3959: oJumpForward 3966
3961: Choice Lookup Table
          51   3848
3964: oJumpForward 3968
3966: oJumpBack 3846
3968: oReturn
3969: oLocalSpace 1
3971: oInputChoice 4025
3973: oGetAddrLocal 1
3975: oPushResult
3976: oSetResult 0
3978: oAssign
3979: oGetAddrLocal 1
3981: oPushResult
3982: oCall 3969
3984: oPop 1
3986: oTypeSNodeType
3987: oChoice 4016
3989: oGetParam 1
3991: oPushResult
3992: oLabelNew
3993: oAssign
3994: oEmit 53
3996: oGetFromParam 1
3998: oPushResult
3999: oEmitLabel
4000: oPop 1
4002: oEmit 56
4004: oGetLocal 1
4006: oPushResult
4007: oEmitLabel
4008: oPop 1
4010: oJumpForward 4023
4012: oEmit 37
4014: oJumpForward 4023
4016: Choice Lookup Table
          22   4012
          23   3989
4021: oError 8
4023: oJumpForward 4035
4025: Choice Lookup Table
          53   3973
4028: oGetParam 1
4030: oPushResult
4031: oCall 4036
4033: oPop 1
4035: oReturn
4036: oLocalSpace 0
4038: oGetParam 1
4040: oPushResult
4041: oCall 4087
4043: oPop 1
4045: oInputChoice 4077
4047: oCall 7243
4049: oGetParam 1
4051: oPushResult
4052: oCall 4087
4054: oPop 1
4056: oCall 7257
4058: oEmit 34
4060: oJumpForward 4084
4062: oCall 7243
4064: oGetParam 1
4066: oPushResult
4067: oCall 4087
4069: oPop 1
4071: oCall 7257
4073: oEmit 35
4075: oJumpForward 4084
4077: Choice Lookup Table
          24   4062
          23   4047
4082: oJumpForward 4086
4084: oJumpBack 4045
4086: oReturn
4087: oLocalSpace 0
4089: oGetParam 1
4091: oPushResult
4092: oCall 4138
4094: oPop 1
4096: oInputChoice 4128
4098: oCall 7243
4100: oGetParam 1
4102: oPushResult
4103: oCall 4138
4105: oPop 1
4107: oCall 7257
4109: oEmit 31
4111: oJumpForward 4135
4113: oCall 7243
4115: oGetParam 1
4117: oPushResult
4118: oCall 4138
4120: oPop 1
4122: oCall 7257
4124: oEmit 32
4126: oJumpForward 4135
4128: Choice Lookup Table
          22   4113
          21   4098
4133: oJumpForward 4137
4135: oJumpBack 4096
4137: oReturn
4138: oLocalSpace 0
4140: oInputChoice 4166
4142: oGetParam 1
4144: oPushResult
4145: oCall 4179
4147: oPop 1
4149: oCall 7257
4151: oJumpForward 4178
4153: oGetParam 1
4155: oPushResult
4156: oCall 4179
4158: oPop 1
4160: oCall 7257
4162: oEmit 36
4164: oJumpForward 4178
4166: Choice Lookup Table
          24   4153
          23   4142
4171: oGetParam 1
4173: oPushResult
4174: oCall 4179
4176: oPop 1
4178: oReturn
4179: oLocalSpace 6
4181: oInputChoice 4367
4183: oEmit 15
4185: TOKEN_VALUE
4186: oPushResult
4187: oEmitInt
4188: oPop 1
4190: oGetGlobal 4
4192: oPushResult
4193: oTypeSPush
4194: oPop 1
4196: oJumpForward 4386
4198: oGetParam 1
4200: oPushResult
4201: oCall 3286
4203: oPop 1
4205: oInput 14
4207: oJumpForward 4386
4209: oGetAddrLocal 1
4211: oPushResult
4212: CURRENT_STRLIT
4213: oPushResult
4214: oStringAllocLit
4215: oPop 1
4217: oAssign
4218: oEmit 16
4220: oGetLocal 1
4222: oPushResult
4223: oEmitInt
4224: oPop 1
4226: oGetGlobal 8
4228: oPushResult
4229: oTypeSPush
4230: oPop 1
4232: oJumpForward 4386
4234: oGetAddrLocal 2
4236: oPushResult
4237: oScopeFindRequire
4238: oAssign
4239: oGetLocal 2
4241: oPushResult
4242: oNodeType
4243: oPop 1
4245: oChoice 4307
4247: oGetLocal 2
4249: oPushResult
4250: oCall 5539
4252: oPop 1
4254: oJumpForward 4326
4256: oGetAddrLocal 3
4258: oPushResult
4259: oGetLocal 2
4261: oPushResult
4262: oSetResult 20
4264: oPushResult
4265: oNodeGet
4266: oPop 2
4268: oAssign
4269: oGetLocal 3
4271: oPushResult
4272: oTypeSPush
4273: oPop 1
4275: oTypeSNodeType
4276: oChoice 4289
4278: oEmit 15
4280: oGetLocal 2
4282: oPushResult
4283: oCall 7494
4285: oPop 1
4287: oJumpForward 4296
4289: Choice Lookup Table
          22   4278
          21   4278
4294: oError 16
4296: oJumpForward 4326
4298: oGetLocal 2
4300: oPushResult
4301: oCall 4387
4303: oPop 1
4305: oJumpForward 4326
4307: Choice Lookup Table
          18   4298
          16   4298
          15   4298
          12   4256
          11   4247
4318: oError 6
4320: oGetGlobal 4
4322: oPushResult
4323: oTypeSPush
4324: oPop 1
4326: oJumpForward 4386
4328: oInput 0
4330: oGetAddrLocal 4
4332: oPushResult
4333: oScopeFindRequire
4334: oAssign
4335: oGetLocal 4
4337: oPushResult
4338: oCall 6486
4340: oPop 1
4342: oGetAddrLocal 5
4344: oPushResult
4345: oTypeSTop
4346: oAssign
4347: oTypeSPop
4348: oGetAddrLocal 6
4350: oPushResult
4351: oGetLocal 5
4353: oPushResult
4354: oCall 7359
4356: oPop 1
4358: oAssign
4359: oGetLocal 6
4361: oPushResult
4362: oTypeSPush
4363: oPop 1
4365: oJumpForward 4386
4367: Choice Lookup Table
          18   4328
           0   4234
           2   4209
          13   4198
           1   4183
4378: oError 6
4380: oGetGlobal 4
4382: oPushResult
4383: oTypeSPush
4384: oPop 1
4386: oReturn
4387: oLocalSpace 2
4389: oGetAddrLocal 1
4391: oPushResult
4392: oGetParam 1
4394: oPushResult
4395: oSetResult 20
4397: oPushResult
4398: oNodeGet
4399: oPop 2
4401: oAssign
4402: oGetAddrLocal 2
4404: oPushResult
4405: oGetParam 1
4407: oPushResult
4408: oCall 7199
4410: oPop 1
4412: oAssign
4413: oGetLocal 1
4415: oPushResult
4416: oTypeSPush
4417: oPop 1
4419: oTypeSNodeType
4420: oChoice 4937
4422: oGetParam 1
4424: oPushResult
4425: oNodeType
4426: oPop 1
4428: oChoice 4574
4430: oEmit 0
4432: oGetParam 1
4434: oPushResult
4435: oCall 7494
4437: oPop 1
4439: oJumpForward 4582
4441: oGetLocal 2
4443: oPushResult
4444: equal_zero
4445: oPop 1
4447: oChoice 4460
4449: oEmit 3
4451: oGetParam 1
4453: oPushResult
4454: oCall 7494
4456: oPop 1
4458: oJumpForward 4478
4460: Choice Lookup Table
           1   4449
4463: oEmit 9
4465: oGetLocal 2
4467: oPushResult
4468: oEmitInt
4469: oPop 1
4471: oGetParam 1
4473: oPushResult
4474: oCall 7494
4476: oPop 1
4478: oJumpForward 4582
4480: oGetParam 1
4482: oPushResult
4483: oSetResult 31
4485: oPushResult
4486: oNodeGetBoolean
4487: oPop 2
4489: oChoice 4532
4491: oGetLocal 2
4493: oPushResult
4494: equal_zero
4495: oPop 1
4497: oChoice 4510
4499: oEmit 8
4501: oGetParam 1
4503: oPushResult
4504: oCall 7494
4506: oPop 1
4508: oJumpForward 4528
4510: Choice Lookup Table
           1   4499
4513: oEmit 14
4515: oGetLocal 2
4517: oPushResult
4518: oEmitInt
4519: oPop 1
4521: oGetParam 1
4523: oPushResult
4524: oCall 7494
4526: oPop 1
4528: oEmit 22
4530: oJumpForward 4572
4532: Choice Lookup Table
           1   4491
4535: oGetLocal 2
4537: oPushResult
4538: equal_zero
4539: oPop 1
4541: oChoice 4554
4543: oEmit 6
4545: oGetParam 1
4547: oPushResult
4548: oCall 7494
4550: oPop 1
4552: oJumpForward 4572
4554: Choice Lookup Table
           1   4543
4557: oEmit 12
4559: oGetLocal 2
4561: oPushResult
4562: oEmitInt
4563: oPop 1
4565: oGetParam 1
4567: oPushResult
4568: oCall 7494
4570: oPop 1
4572: oJumpForward 4582
4574: Choice Lookup Table
          18   4480
          16   4441
          15   4430
4581: oEndChoice
4582: oJumpForward 5112
4584: oGetParam 1
4586: oPushResult
4587: oNodeType
4588: oPop 1
4590: oChoice 4736
4592: oEmit 1
4594: oGetParam 1
4596: oPushResult
4597: oCall 7494
4599: oPop 1
4601: oJumpForward 4744
4603: oGetLocal 2
4605: oPushResult
4606: equal_zero
4607: oPop 1
4609: oChoice 4622
4611: oEmit 4
4613: oGetParam 1
4615: oPushResult
4616: oCall 7494
4618: oPop 1
4620: oJumpForward 4640
4622: Choice Lookup Table
           1   4611
4625: oEmit 10
4627: oGetLocal 2
4629: oPushResult
4630: oEmitInt
4631: oPop 1
4633: oGetParam 1
4635: oPushResult
4636: oCall 7494
4638: oPop 1
4640: oJumpForward 4744
4642: oGetParam 1
4644: oPushResult
4645: oSetResult 31
4647: oPushResult
4648: oNodeGetBoolean
4649: oPop 2
4651: oChoice 4694
4653: oGetLocal 2
4655: oPushResult
4656: equal_zero
4657: oPop 1
4659: oChoice 4672
4661: oEmit 8
4663: oGetParam 1
4665: oPushResult
4666: oCall 7494
4668: oPop 1
4670: oJumpForward 4690
4672: Choice Lookup Table
           1   4661
4675: oEmit 14
4677: oGetLocal 2
4679: oPushResult
4680: oEmitInt
4681: oPop 1
4683: oGetParam 1
4685: oPushResult
4686: oCall 7494
4688: oPop 1
4690: oEmit 23
4692: oJumpForward 4734
4694: Choice Lookup Table
           1   4653
4697: oGetLocal 2
4699: oPushResult
4700: equal_zero
4701: oPop 1
4703: oChoice 4716
4705: oEmit 7
4707: oGetParam 1
4709: oPushResult
4710: oCall 7494
4712: oPop 1
4714: oJumpForward 4734
4716: Choice Lookup Table
           1   4705
4719: oEmit 13
4721: oGetLocal 2
4723: oPushResult
4724: oEmitInt
4725: oPop 1
4727: oGetParam 1
4729: oPushResult
4730: oCall 7494
4732: oPop 1
4734: oJumpForward 4744
4736: Choice Lookup Table
          18   4642
          16   4603
          15   4592
4743: oEndChoice
4744: oJumpForward 5112
4746: oError 16
4748: oJumpForward 5112
4750: oGetParam 1
4752: oPushResult
4753: oNodeType
4754: oPop 1
4756: oChoice 4902
4758: oEmit 2
4760: oGetParam 1
4762: oPushResult
4763: oCall 7494
4765: oPop 1
4767: oJumpForward 4910
4769: oGetLocal 2
4771: oPushResult
4772: equal_zero
4773: oPop 1
4775: oChoice 4788
4777: oEmit 5
4779: oGetParam 1
4781: oPushResult
4782: oCall 7494
4784: oPop 1
4786: oJumpForward 4806
4788: Choice Lookup Table
           1   4777
4791: oEmit 11
4793: oGetLocal 2
4795: oPushResult
4796: oEmitInt
4797: oPop 1
4799: oGetParam 1
4801: oPushResult
4802: oCall 7494
4804: oPop 1
4806: oJumpForward 4910
4808: oGetParam 1
4810: oPushResult
4811: oSetResult 31
4813: oPushResult
4814: oNodeGetBoolean
4815: oPop 2
4817: oChoice 4860
4819: oGetLocal 2
4821: oPushResult
4822: equal_zero
4823: oPop 1
4825: oChoice 4838
4827: oEmit 8
4829: oGetParam 1
4831: oPushResult
4832: oCall 7494
4834: oPop 1
4836: oJumpForward 4856
4838: Choice Lookup Table
           1   4827
4841: oEmit 14
4843: oGetLocal 2
4845: oPushResult
4846: oEmitInt
4847: oPop 1
4849: oGetParam 1
4851: oPushResult
4852: oCall 7494
4854: oPop 1
4856: oEmit 24
4858: oJumpForward 4900
4860: Choice Lookup Table
           1   4819
4863: oGetLocal 2
4865: oPushResult
4866: equal_zero
4867: oPop 1
4869: oChoice 4882
4871: oEmit 8
4873: oGetParam 1
4875: oPushResult
4876: oCall 7494
4878: oPop 1
4880: oJumpForward 4900
4882: Choice Lookup Table
           1   4871
4885: oEmit 14
4887: oGetLocal 2
4889: oPushResult
4890: oEmitInt
4891: oPop 1
4893: oGetParam 1
4895: oPushResult
4896: oCall 7494
4898: oPop 1
4900: oJumpForward 4910
4902: Choice Lookup Table
          18   4808
          16   4769
          15   4758
4909: oEndChoice
4910: oInputChoice 4932
4912: oTypeSPop
4913: oGetLocal 1
4915: oPushResult
4916: oSetResult 33
4918: oPushResult
4919: oNodeGet
4920: oPop 2
4922: oPushResult
4923: oTypeSPush
4924: oPop 1
4926: oCall 5148
4928: oCall 5113
4930: oJumpForward 4935
4932: Choice Lookup Table
          17   4912
4935: oJumpForward 5112
4937: Choice Lookup Table
          26   4750
          20   4746
          25   4746
          24   4746
          22   4584
          21   4422
4950: oGetParam 1
4952: oPushResult
4953: oNodeType
4954: oPop 1
4956: oChoice 5100
4958: oEmit 16
4960: oGetParam 1
4962: oPushResult
4963: oCall 7494
4965: oPop 1
4967: oJumpForward 5108
4969: oGetLocal 2
4971: oPushResult
4972: equal_zero
4973: oPop 1
4975: oChoice 4988
4977: oEmit 17
4979: oGetParam 1
4981: oPushResult
4982: oCall 7494
4984: oPop 1
4986: oJumpForward 5006
4988: Choice Lookup Table
           1   4977
4991: oEmit 20
4993: oGetLocal 2
4995: oPushResult
4996: oEmitInt
4997: oPop 1
4999: oGetParam 1
5001: oPushResult
5002: oCall 7494
5004: oPop 1
5006: oJumpForward 5108
5008: oGetParam 1
5010: oPushResult
5011: oSetResult 31
5013: oPushResult
5014: oNodeGetBoolean
5015: oPop 2
5017: oChoice 5058
5019: oGetLocal 2
5021: oPushResult
5022: equal_zero
5023: oPop 1
5025: oChoice 5038
5027: oEmit 8
5029: oGetParam 1
5031: oPushResult
5032: oCall 7494
5034: oPop 1
5036: oJumpForward 5056
5038: Choice Lookup Table
           1   5027
5041: oEmit 14
5043: oGetLocal 2
5045: oPushResult
5046: oEmitInt
5047: oPop 1
5049: oGetParam 1
5051: oPushResult
5052: oCall 7494
5054: oPop 1
5056: oJumpForward 5098
5058: Choice Lookup Table
           1   5019
5061: oGetLocal 2
5063: oPushResult
5064: equal_zero
5065: oPop 1
5067: oChoice 5080
5069: oEmit 18
5071: oGetParam 1
5073: oPushResult
5074: oCall 7494
5076: oPop 1
5078: oJumpForward 5098
5080: Choice Lookup Table
           1   5069
5083: oEmit 21
5085: oGetLocal 2
5087: oPushResult
5088: oEmitInt
5089: oPop 1
5091: oGetParam 1
5093: oPushResult
5094: oCall 7494
5096: oPop 1
5098: oJumpForward 5108
5100: Choice Lookup Table
          18   5008
          16   4969
          15   4958
5107: oEndChoice
5108: oCall 5148
5110: oCall 5113
5112: oReturn
5113: oLocalSpace 0
5115: oTypeSNodeType
5116: oChoice 5134
5118: oEmit 22
5120: oJumpForward 5147
5122: oEmit 23
5124: oJumpForward 5147
5126: oError 16
5128: oJumpForward 5147
5130: oEmit 24
5132: oJumpForward 5147
5134: Choice Lookup Table
          26   5130
          20   5126
          25   5126
          24   5126
          22   5122
          21   5118
5147: oReturn
5148: oLocalSpace 0
5150: oInputChoice 5164
5152: oCall 5176
5154: oJumpForward 5173
5156: oCall 5319
5158: oJumpForward 5173
5160: oCall 5417
5162: oJumpForward 5173
5164: Choice Lookup Table
          17   5160
          19   5156
          15   5152
5171: oJumpForward 5175
5173: oJumpBack 5150
5175: oReturn
5176: oLocalSpace 3
5178: oTypeSNodeType
5179: oChoice 5183
5181: oJumpForward 5188
5183: Choice Lookup Table
          27   5181
5186: oError 10
5188: oTypeSNodeType
5189: oChoice 5193
5191: oJumpForward 5198
5193: Choice Lookup Table
          27   5191
5196: oError 13
5198: oGetAddrLocal 1
5200: oPushResult
5201: oTypeSTop
5202: oPushResult
5203: oSetResult 34
5205: oPushResult
5206: oNodeGet
5207: oPop 2
5209: oPushResult
5210: oCall 7443
5212: oPop 1
5214: oAssign
5215: oGetAddrLocal 2
5217: oPushResult
5218: oTypeSTop
5219: oPushResult
5220: oSetResult 33
5222: oPushResult
5223: oNodeGet
5224: oPop 2
5226: oAssign
5227: oTypeSPop
5228: oGetLocal 2
5230: oPushResult
5231: oTypeSPush
5232: oPop 1
5234: oCall 3125
5236: oCall 7243
5238: oGetLocal 1
5240: oPushResult
5241: equal_zero
5242: oPop 1
5244: oChoice 5258
5246: oEmit 15
5248: oGetLocal 1
5250: oPushResult
5251: oEmitInt
5252: oPop 1
5254: oEmit 35
5256: oJumpForward 5261
5258: Choice Lookup Table
           0   5246
5261: oGetAddrLocal 3
5263: oPushResult
5264: oGetLocal 2
5266: oPushResult
5267: oSetResult 16
5269: oPushResult
5270: oNodeGetInt
5271: oPop 2
5273: oAssign
5274: oGetLocal 3
5276: oPushResult
5277: oSetResult 1
5279: oPushResult
5280: equal
5281: oPop 2
5283: oChoice 5297
5285: oEmit 15
5287: oGetLocal 3
5289: oPushResult
5290: oEmitInt
5291: oPop 1
5293: oEmit 31
5295: oJumpForward 5300
5297: Choice Lookup Table
           0   5285
5300: oEmit 33
5302: oInputChoice 5310
5304: oJumpForward 5318
5306: oJumpForward 5316
5308: oJumpForward 5316
5310: Choice Lookup Table
          12   5308
          16   5304
5315: oEndChoice
5316: oJumpBack 5188
5318: oReturn
5319: oLocalSpace 2
5321: oTypeSNodeType
5322: oChoice 5326
5324: oJumpForward 5331
5326: Choice Lookup Table
          29   5324
5329: oError 11
5331: oTypeSTop
5332: oPushResult
5333: oSetResult 37
5335: oPushResult
5336: oNodeGet
5337: oPop 2
5339: oPushResult
5340: oScopeEnter
5341: oPop 1
5343: oInput 0
5345: oGetAddrLocal 1
5347: oPushResult
5348: oScopeFindRequire
5349: oAssign
5350: oGetLocal 1
5352: oPushResult
5353: oNodeType
5354: oPop 1
5356: oChoice 5360
5358: oJumpForward 5365
5360: Choice Lookup Table
          17   5358
5363: oError 12
5365: oScopeEnd
5366: oGetAddrLocal 2
5368: oPushResult
5369: oGetLocal 1
5371: oPushResult
5372: oSetResult 21
5374: oPushResult
5375: oNodeGetInt
5376: oPop 2
5378: oAssign
5379: oGetLocal 2
5381: oPushResult
5382: equal_zero
5383: oPop 1
5385: oChoice 5399
5387: oEmit 15
5389: oGetLocal 2
5391: oPushResult
5392: oEmitInt
5393: oPop 1
5395: oEmit 33
5397: oJumpForward 5402
5399: Choice Lookup Table
           0   5387
5402: oTypeSPop
5403: oGetLocal 1
5405: oPushResult
5406: oSetResult 20
5408: oPushResult
5409: oNodeGet
5410: oPop 2
5412: oPushResult
5413: oTypeSPush
5414: oPop 1
5416: oReturn
5417: oLocalSpace 1
5419: oTypeSNodeType
5420: oChoice 5424
5422: oJumpForward 5429
5424: Choice Lookup Table
          26   5422
5427: oError 9
5429: oEmit 24
5431: oGetAddrLocal 1
5433: oPushResult
5434: oTypeSTop
5435: oAssign
5436: oTypeSPop
5437: oGetLocal 1
5439: oPushResult
5440: oSetResult 33
5442: oPushResult
5443: oNodeGet
5444: oPop 2
5446: oPushResult
5447: oTypeSPush
5448: oPop 1
5450: oReturn
5451: oLocalSpace 0
5453: oCall 7217
5455: oReturn
5456: oLocalSpace 2
5458: oGetAddrLocal 2
5460: oPushResult
5461: oGetParam 1
5463: oPushResult
5464: oSetResult 25
5466: oPushResult
5467: oNodeGetString
5468: oPop 2
5470: oAssign
5471: oGetLocal 2
5473: oPushResult
5474: oSetResult 0
5476: oPushResult
5477: equal_string
5478: oPop 2
5480: oChoice 5517
5482: oGetAddrLocal 1
5484: oPushResult
5485: oGetParam 1
5487: oPushResult
5488: oSetResult 4
5490: oPushResult
5491: oNodeGetInt
5492: oPop 2
5494: oPushResult
5495: ID_STRING
5496: oPop 1
5498: oPushResult
5499: oStringAllocLit
5500: oPop 1
5502: oAssign
5503: oJumpForward 5523
5505: oGetAddrLocal 1
5507: oPushResult
5508: oGetLocal 2
5510: oPushResult
5511: oStringAllocLit
5512: oPop 1
5514: oAssign
5515: oJumpForward 5523
5517: Choice Lookup Table
           0   5505
           1   5482
5522: oEndChoice
5523: oEmit 58
5525: oGetParam 1
5527: oPushResult
5528: oCall 7494
5530: oPop 1
5532: oGetLocal 1
5534: oPushResult
5535: oEmitInt
5536: oPop 1
5538: oReturn
5539: oLocalSpace 10
5541: oGetParam 1
5543: oPushResult
5544: oSetResult 24
5546: oPushResult
5547: oNodeGetBoolean
5548: oPop 2
5550: oChoice 5577
5552: oGetParam 1
5554: oPushResult
5555: oSetResult 27
5557: oPushResult
5558: oNodeGetBoolean
5559: oPop 2
5561: oChoice 5572
5563: oGetParam 1
5565: oPushResult
5566: oCall 5456
5568: oPop 1
5570: oJumpForward 5575
5572: Choice Lookup Table
           0   5563
5575: oJumpForward 5580
5577: Choice Lookup Table
           1   5552
5580: oGetParam 1
5582: oPushResult
5583: oSetResult 27
5585: oPushResult
5586: oSetResult 1
5588: oPushResult
5589: oNodeSetBoolean
5590: oPop 3
5592: oGetAddrLocal 1
5594: oPushResult
5595: oGetParam 1
5597: oPushResult
5598: oSetResult 26
5600: oPushResult
5601: oNodeGetBoolean
5602: oPop 2
5604: oAssign
5605: oGetAddrLocal 4
5607: oPushResult
5608: oGetParam 1
5610: oPushResult
5611: oNodeType
5612: oPop 1
5614: oPushResult
5615: oSetResult 11
5617: oPushResult
5618: equal_node_type
5619: oPop 2
5621: oAssign
5622: oGetLocal 4
5624: oChoice 5651
5626: oGetAddrLocal 2
5628: oPushResult
5629: oGetParam 1
5631: oPushResult
5632: oSetResult 20
5634: oPushResult
5635: oNodeGet
5636: oPop 2
5638: oAssign
5639: oGetAddrLocal 3
5641: oPushResult
5642: oGetLocal 2
5644: oPushResult
5645: oScopeAllocType
5646: oPop 1
5648: oAssign
5649: oJumpForward 5654
5651: Choice Lookup Table
           1   5626
5654: oGetAddrLocal 5
5656: oPushResult
5657: oGetParam 1
5659: oPushResult
5660: oSetResult 22
5662: oPushResult
5663: oNodeGet
5664: oPop 2
5666: oAssign
5667: oGetAddrLocal 6
5669: oPushResult
5670: oGetLocal 5
5672: oPushResult
5673: oSetResult 16
5675: oPushResult
5676: oNodeGetInt
5677: oPop 2
5679: oAssign
5680: oGetLocal 1
5682: oChoice 5704
5684: oEmit 47
5686: oGetLocal 6
5688: oPushResult
5689: oEmitInt
5690: oPop 1
5692: oJumpForward 5710
5694: oEmit 46
5696: oGetLocal 6
5698: oPushResult
5699: oEmitInt
5700: oPop 1
5702: oJumpForward 5710
5704: Choice Lookup Table
           0   5694
           1   5684
5709: oEndChoice
5710: oGetParam 1
5712: oPushResult
5713: oCall 7179
5715: oPop 1
5717: oPushResult
5718: oSetResult 0
5720: oPushResult
5721: greater
5722: oPop 2
5724: oChoice 5757
5726: oEmit 19
5728: oSetResult 0
5730: oPushResult
5731: oEmitInt
5732: oPop 1
5734: oEmit 20
5736: oGetParam 1
5738: oPushResult
5739: oCall 7199
5741: oPop 1
5743: oPushResult
5744: oEmitInt
5745: oPop 1
5747: oSetResult 0
5749: oPushResult
5750: oEmitInt
5751: oPop 1
5753: oEmit 27
5755: oJumpForward 5760
5757: Choice Lookup Table
           1   5726
5760: oGetAddrLocal 7
5762: oPushResult
5763: oGetLocal 5
5765: oPushResult
5766: oSetResult 15
5768: oPushResult
5769: oNodeGetIter
5770: oPop 2
5772: oAssign
5773: oGetAddrLocal 8
5775: oPushResult
5776: oGetLocal 7
5778: oPushResult
5779: oNodeIterValue
5780: oPop 1
5782: oAssign
5783: oInputChoice 5962
5785: oGetLocal 8
5787: oPushResult
5788: oNodeNull
5789: oPop 1
5791: oChoice 5797
5793: oJumpForward 5958
5795: oJumpForward 5800
5797: Choice Lookup Table
           1   5793
5800: oGetAddrLocal 9
5802: oPushResult
5803: oGetLocal 8
5805: oPushResult
5806: oSetResult 21
5808: oPushResult
5809: oNodeGetInt
5810: oPop 2
5812: oAssign
5813: oEmit 19
5815: oGetLocal 9
5817: oPushResult
5818: oEmitInt
5819: oPop 1
5821: oGetLocal 8
5823: oPushResult
5824: oSetResult 20
5826: oPushResult
5827: oNodeGet
5828: oPop 2
5830: oPushResult
5831: oTypeSPush
5832: oPop 1
5834: oGetLocal 8
5836: oPushResult
5837: oSetResult 31
5839: oPushResult
5840: oNodeGetBoolean
5841: oPop 2
5843: oChoice 5911
5845: oCall 6450
5847: oCall 7217
5849: oEmit 27
5851: oJumpForward 5917
5853: oCall 3125
5855: oCall 5451
5857: oTypeSNodeType
5858: oChoice 5876
5860: oEmit 25
5862: oJumpForward 5909
5864: oEmit 26
5866: oJumpForward 5909
5868: oError 16
5870: oJumpForward 5909
5872: oEmit 27
5874: oJumpForward 5909
5876: Choice Lookup Table
          26   5872
          20   5868
          25   5868
          24   5868
          22   5864
          21   5860
5889: oGetAddrLocal 10
5891: oPushResult
5892: oTypeSTop
5893: oPushResult
5894: oSetResult 16
5896: oPushResult
5897: oNodeGetInt
5898: oPop 2
5900: oAssign
5901: oEmit 28
5903: oGetLocal 10
5905: oPushResult
5906: oEmitInt
5907: oPop 1
5909: oJumpForward 5917
5911: Choice Lookup Table
           0   5853
           1   5845
5916: oEndChoice
5917: oTypeSPop
5918: oGetAddrLocal 7
5920: oPushResult
5921: oNodeIterNext
5922: oPop 1
5924: oGetAddrLocal 8
5926: oPushResult
5927: oGetLocal 7
5929: oPushResult
5930: oNodeIterValue
5931: oPop 1
5933: oAssign
5934: oGetLocal 8
5936: oPushResult
5937: oNodeNull
5938: oPop 1
5940: oChoice 5948
5942: oJumpForward 5958
5944: oJumpForward 5954
5946: oJumpForward 5954
5948: Choice Lookup Table
           0   5946
           1   5942
5953: oEndChoice
5954: oInput 12
5956: oJumpBack 5785
5958: oInput 14
5960: oJumpForward 5965
5962: Choice Lookup Table
          13   5785
5965: oGetLocal 8
5967: oPushResult
5968: oNodeNull
5969: oPop 1
5971: oChoice 5977
5973: oError 15
5975: oJumpForward 5980
5977: Choice Lookup Table
           0   5973
5980: oGetLocal 4
5982: oChoice 6011
5984: oEmit 19
5986: oGetParam 1
5988: oPushResult
5989: oSetResult 30
5991: oPushResult
5992: oNodeGetInt
5993: oPop 2
5995: oPushResult
5996: oEmitInt
5997: oPop 1
5999: oEmit 17
6001: oGetLocal 3
6003: oPushResult
6004: oEmitInt
6005: oPop 1
6007: oEmit 27
6009: oJumpForward 6014
6011: Choice Lookup Table
           1   5984
6014: oGetLocal 1
6016: oChoice 6040
6018: oEmit 50
6020: oGetParam 1
6022: oPushResult
6023: oCall 7494
6025: oPop 1
6027: oJumpForward 6046
6029: oEmit 49
6031: oGetParam 1
6033: oPushResult
6034: oCall 7494
6036: oPop 1
6038: oJumpForward 6046
6040: Choice Lookup Table
           0   6029
           1   6018
6045: oEndChoice
6046: oGetLocal 4
6048: oChoice 6116
6050: oGetLocal 2
6052: oPushResult
6053: oTypeSPush
6054: oPop 1
6056: oTypeSNodeType
6057: oChoice 6093
6059: oEmit 3
6061: oGetLocal 3
6063: oPushResult
6064: oEmitInt
6065: oPop 1
6067: oJumpForward 6114
6069: oEmit 4
6071: oGetLocal 3
6073: oPushResult
6074: oEmitInt
6075: oPop 1
6077: oJumpForward 6114
6079: oError 16
6081: oJumpForward 6114
6083: oEmit 5
6085: oGetLocal 3
6087: oPushResult
6088: oEmitInt
6089: oPop 1
6091: oJumpForward 6114
6093: Choice Lookup Table
          26   6083
          20   6079
          25   6079
          24   6079
          22   6069
          21   6059
6106: oEmit 17
6108: oGetLocal 3
6110: oPushResult
6111: oEmitInt
6112: oPop 1
6114: oJumpForward 6119
6116: Choice Lookup Table
           1   6050
6119: oEmit 48
6121: oGetLocal 6
6123: oPushResult
6124: oEmitInt
6125: oPop 1
6127: oReturn
6128: oLocalSpace 0
6130: oInputChoice 6180
6132: oCall 7087
6134: oJumpForward 6205
6136: oCall 7094
6138: oJumpForward 6205
6140: oCall 7161
6142: oJumpForward 6205
6144: oCall 7164
6146: oJumpForward 6205
6148: oCall 6627
6150: oJumpForward 6205
6152: oCall 6947
6154: oJumpForward 6205
6156: oCall 6693
6158: oJumpForward 6205
6160: oCall 6867
6162: oJumpForward 6205
6164: oCall 7032
6166: oJumpForward 6205
6168: oCall 7000
6170: oJumpForward 6205
6172: oCall 7064
6174: oJumpForward 6205
6176: oCall 6206
6178: oJumpForward 6205
6180: Choice Lookup Table
           0   6176
          33   6172
          49   6168
          50   6164
          47   6160
          42   6156
          46   6152
          39   6148
          63   6144
          62   6140
          61   6136
          60   6132
6205: oReturn
6206: oLocalSpace 1
6208: oGetAddrLocal 1
6210: oPushResult
6211: oScopeFindRequire
6212: oAssign
6213: oGetLocal 1
6215: oPushResult
6216: oNodeType
6217: oPop 1
6219: oChoice 6248
6221: oGetLocal 1
6223: oPushResult
6224: oCall 5539
6226: oPop 1
6228: oJumpForward 6261
6230: oGetLocal 1
6232: oPushResult
6233: oCall 6262
6235: oPop 1
6237: oJumpForward 6261
6239: oGetLocal 1
6241: oPushResult
6242: oCall 6336
6244: oPop 1
6246: oJumpForward 6261
6248: Choice Lookup Table
          11   6239
          18   6230
          16   6230
          15   6230
          10   6221
6259: oError 0
6261: oReturn
6262: oLocalSpace 0
6264: oGetParam 1
6266: oPushResult
6267: oCall 6486
6269: oPop 1
6271: oInput 3
6273: oCall 3125
6275: oCall 7217
6277: oCall 6280
6279: oReturn
6280: oLocalSpace 1
6282: oTypeSNodeType
6283: oChoice 6301
6285: oEmit 25
6287: oJumpForward 6334
6289: oEmit 26
6291: oJumpForward 6334
6293: oError 16
6295: oJumpForward 6334
6297: oEmit 27
6299: oJumpForward 6334
6301: Choice Lookup Table
          26   6297
          20   6293
          25   6293
          24   6293
          22   6289
          21   6285
6314: oGetAddrLocal 1
6316: oPushResult
6317: oTypeSTop
6318: oPushResult
6319: oSetResult 16
6321: oPushResult
6322: oNodeGetInt
6323: oPop 2
6325: oAssign
6326: oEmit 28
6328: oGetLocal 1
6330: oPushResult
6331: oEmitInt
6332: oPop 1
6334: oTypeSPop
6335: oReturn
6336: oLocalSpace 1
6338: oGetParam 1
6340: oPushResult
6341: oSetResult 6
6343: oPushResult
6344: oNodeGet
6345: oPop 2
6347: oPushResult
6348: oScopeCurrent
6349: oPushResult
6350: oNodeEqual
6351: oPop 2
6353: oChoice 6359
6355: oError 20
6357: oJumpForward 6362
6359: Choice Lookup Table
           0   6355
6362: oEmit 8
6364: oGetParam 1
6366: oPushResult
6367: oSetResult 30
6369: oPushResult
6370: oNodeGetInt
6371: oPop 2
6373: oPushResult
6374: oEmitInt
6375: oPop 1
6377: oGetParam 1
6379: oPushResult
6380: oSetResult 20
6382: oPushResult
6383: oNodeGet
6384: oPop 2
6386: oPushResult
6387: oTypeSPush
6388: oPop 1
6390: oInput 3
6392: oCall 3125
6394: oCall 7217
6396: oTypeSNodeType
6397: oChoice 6415
6399: oEmit 25
6401: oJumpForward 6448
6403: oEmit 26
6405: oJumpForward 6448
6407: oError 16
6409: oJumpForward 6448
6411: oEmit 27
6413: oJumpForward 6448
6415: Choice Lookup Table
          26   6411
          20   6407
          25   6407
          24   6407
          22   6403
          21   6399
6428: oGetAddrLocal 1
6430: oPushResult
6431: oTypeSTop
6432: oPushResult
6433: oSetResult 16
6435: oPushResult
6436: oNodeGetInt
6437: oPop 2
6439: oAssign
6440: oEmit 28
6442: oGetLocal 1
6444: oPushResult
6445: oEmitInt
6446: oPop 1
6448: oTypeSPop
6449: oReturn
6450: oLocalSpace 1
6452: oInput 0
6454: oGetAddrLocal 1
6456: oPushResult
6457: oScopeFindRequire
6458: oAssign
6459: oGetLocal 1
6461: oPushResult
6462: oNodeType
6463: oPop 1
6465: oChoice 6469
6467: oJumpForward 6478
6469: Choice Lookup Table
          18   6467
          16   6467
          15   6467
6476: oError 4
6478: oGetLocal 1
6480: oPushResult
6481: oCall 6486
6483: oPop 1
6485: oReturn
6486: oLocalSpace 0
6488: oGetParam 1
6490: oPushResult
6491: oNodeType
6492: oPop 1
6494: oChoice 6554
6496: oEmit 16
6498: oGetParam 1
6500: oPushResult
6501: oCall 7494
6503: oPop 1
6505: oJumpForward 6563
6507: oEmit 17
6509: oGetParam 1
6511: oPushResult
6512: oCall 7494
6514: oPop 1
6516: oJumpForward 6563
6518: oGetParam 1
6520: oPushResult
6521: oSetResult 31
6523: oPushResult
6524: oNodeGetBoolean
6525: oPop 2
6527: oChoice 6540
6529: oEmit 8
6531: oGetParam 1
6533: oPushResult
6534: oCall 7494
6536: oPop 1
6538: oJumpForward 6552
6540: Choice Lookup Table
           1   6529
6543: oEmit 18
6545: oGetParam 1
6547: oPushResult
6548: oCall 7494
6550: oPop 1
6552: oJumpForward 6563
6554: Choice Lookup Table
          18   6518
          16   6507
          15   6496
6561: oError 4
6563: oGetParam 1
6565: oPushResult
6566: oSetResult 20
6568: oPushResult
6569: oNodeGet
6570: oPop 2
6572: oPushResult
6573: oTypeSPush
6574: oPop 1
6576: oCall 5148
6578: oReturn
6579: oLocalSpace 0
6581: oGetParam 1
6583: oPushResult
6584: oCall 6486
6586: oPop 1
6588: oCall 7243
6590: oGetParam 1
6592: oPushResult
6593: oCall 4387
6595: oPop 1
6597: oTypeSPop
6598: oEmit 29
6600: oEmit 25
6602: oReturn
6603: oLocalSpace 0
6605: oGetParam 1
6607: oPushResult
6608: oCall 6486
6610: oPop 1
6612: oCall 7243
6614: oGetParam 1
6616: oPushResult
6617: oCall 4387
6619: oPop 1
6621: oTypeSPop
6622: oEmit 30
6624: oEmit 25
6626: oReturn
6627: oLocalSpace 2
6629: oGetAddrLocal 1
6631: oPushResult
6632: oSetResult 0
6634: oAssign
6635: oGetAddrLocal 1
6637: oPushResult
6638: oCall 3148
6640: oPop 1
6642: oInput 40
6644: oCall 6128
6646: oInputChoice 6681
6648: oGetAddrLocal 2
6650: oPushResult
6651: oLabelNew
6652: oAssign
6653: oEmit 53
6655: oGetLocal 2
6657: oPushResult
6658: oEmitLabel
6659: oPop 1
6661: oEmit 56
6663: oGetLocal 1
6665: oPushResult
6666: oEmitLabel
6667: oPop 1
6669: oCall 6128
6671: oEmit 56
6673: oGetLocal 2
6675: oPushResult
6676: oEmitLabel
6677: oPop 1
6679: oJumpForward 6692
6681: Choice Lookup Table
          41   6648
6684: oEmit 56
6686: oGetLocal 1
6688: oPushResult
6689: oEmitLabel
6690: oPop 1
6692: oReturn
6693: oLocalSpace 4
6695: oInput 0
6697: oGetAddrLocal 1
6699: oPushResult
6700: oScopeFindRequire
6701: oAssign
6702: oGetLocal 1
6704: oPushResult
6705: oCall 6486
6707: oPop 1
6709: oCall 7243
6711: oInput 3
6713: oCall 3125
6715: oCall 7243
6717: oEmit 25
6719: oGetAddrLocal 2
6721: oPushResult
6722: oLabelNew
6723: oAssign
6724: oGetAddrLocal 3
6726: oPushResult
6727: oLabelNew
6728: oAssign
6729: oEmit 53
6731: oGetLocal 3
6733: oPushResult
6734: oEmitLabel
6735: oPop 1
6737: oGetAddrLocal 4
6739: oPushResult
6740: oLabelNew
6741: oAssign
6742: oEmit 56
6744: oGetLocal 4
6746: oPushResult
6747: oEmitLabel
6748: oPop 1
6750: oInputChoice 6830
6752: oGetLocal 1
6754: oPushResult
6755: oCall 6579
6757: oPop 1
6759: oEmit 56
6761: oGetLocal 3
6763: oPushResult
6764: oEmitLabel
6765: oPop 1
6767: oGetLocal 1
6769: oPushResult
6770: oCall 4387
6772: oPop 1
6774: oTypeSPop
6775: oCall 3125
6777: oCall 7243
6779: oEmit 40
6781: oEmit 54
6783: oGetLocal 2
6785: oPushResult
6786: oEmitLabel
6787: oPop 1
6789: oJumpForward 6836
6791: oGetLocal 1
6793: oPushResult
6794: oCall 6603
6796: oPop 1
6798: oEmit 56
6800: oGetLocal 3
6802: oPushResult
6803: oEmitLabel
6804: oPop 1
6806: oGetLocal 1
6808: oPushResult
6809: oCall 4387
6811: oPop 1
6813: oTypeSPop
6814: oCall 3125
6816: oCall 7243
6818: oEmit 41
6820: oEmit 54
6822: oGetLocal 2
6824: oPushResult
6825: oEmitLabel
6826: oPop 1
6828: oJumpForward 6836
6830: Choice Lookup Table
          44   6791
          43   6752
6835: oEndChoice
6836: oGetLocal 4
6838: oPushResult
6839: oGetLocal 2
6841: oPushResult
6842: oLoopPush
6843: oPop 2
6845: oInput 45
6847: oCall 6128
6849: oEmit 53
6851: oGetLocal 4
6853: oPushResult
6854: oEmitLabel
6855: oPop 1
6857: oEmit 56
6859: oGetLocal 2
6861: oPushResult
6862: oEmitLabel
6863: oPop 1
6865: oLoopPop
6866: oReturn
6867: oLocalSpace 3
6869: oGetAddrLocal 1
6871: oPushResult
6872: oLabelNew
6873: oAssign
6874: oEmit 56
6876: oGetLocal 1
6878: oPushResult
6879: oEmitLabel
6880: oPop 1
6882: oGetAddrLocal 2
6884: oPushResult
6885: oLabelNew
6886: oAssign
6887: oGetLocal 1
6889: oPushResult
6890: oGetLocal 2
6892: oPushResult
6893: oLoopPush
6894: oPop 2
6896: oCall 6128
6898: oInputChoice 6929
6900: oCall 6128
6902: oJumpForward 6935
6904: oGetAddrLocal 3
6906: oPushResult
6907: oCall 3148
6909: oPop 1
6911: oEmit 57
6913: oGetLocal 3
6915: oPushResult
6916: oEmitLabel
6917: oPop 1
6919: oGetLocal 1
6921: oPushResult
6922: oEmitLabel
6923: oPop 1
6925: oJumpForward 6937
6927: oJumpForward 6935
6929: Choice Lookup Table
          48   6904
           4   6900
6934: oEndChoice
6935: oJumpBack 6898
6937: oEmit 56
6939: oGetLocal 2
6941: oPushResult
6942: oEmitLabel
6943: oPop 1
6945: oLoopPop
6946: oReturn
6947: oLocalSpace 2
6949: oGetAddrLocal 1
6951: oPushResult
6952: oLabelNew
6953: oAssign
6954: oEmit 56
6956: oGetLocal 1
6958: oPushResult
6959: oEmitLabel
6960: oPop 1
6962: oGetAddrLocal 2
6964: oPushResult
6965: oCall 3148
6967: oPop 1
6969: oGetLocal 1
6971: oPushResult
6972: oGetLocal 2
6974: oPushResult
6975: oLoopPush
6976: oPop 2
6978: oInput 45
6980: oCall 6128
6982: oEmit 53
6984: oGetLocal 1
6986: oPushResult
6987: oEmitLabel
6988: oPop 1
6990: oEmit 56
6992: oGetLocal 2
6994: oPushResult
6995: oEmitLabel
6996: oPop 1
6998: oLoopPop
6999: oReturn
7000: oLocalSpace 0
7002: oLoopContinueLabel
7003: oPushResult
7004: oSetResult 0
7006: oPushResult
7007: equal_label
7008: oPop 2
7010: oChoice 7025
7012: oError 18
7014: oJumpForward 7031
7016: oEmit 53
7018: oLoopContinueLabel
7019: oPushResult
7020: oEmitLabel
7021: oPop 1
7023: oJumpForward 7031
7025: Choice Lookup Table
           0   7016
           1   7012
7030: oEndChoice
7031: oReturn
7032: oLocalSpace 0
7034: oLoopBreakLabel
7035: oPushResult
7036: oSetResult 0
7038: oPushResult
7039: equal_label
7040: oPop 2
7042: oChoice 7057
7044: oError 18
7046: oJumpForward 7063
7048: oEmit 53
7050: oLoopBreakLabel
7051: oPushResult
7052: oEmitLabel
7053: oPop 1
7055: oJumpForward 7063
7057: Choice Lookup Table
           0   7048
           1   7044
7062: oEndChoice
7063: oReturn
7064: oLocalSpace 0
7066: oCall 6128
7068: oInputChoice 7078
7070: oCall 6128
7072: oJumpForward 7084
7074: oJumpForward 7086
7076: oJumpForward 7084
7078: Choice Lookup Table
          34   7074
           4   7070
7083: oEndChoice
7084: oJumpBack 7068
7086: oReturn
7087: oLocalSpace 0
7089: oCall 7094
7091: oEmit 63
7093: oReturn
7094: oLocalSpace 0
7096: oInputChoice 7157
7098: oCall 3125
7100: oTypeSNodeType
7101: oChoice 7123
7103: oEmit 59
7105: oJumpForward 7138
7107: oEmit 60
7109: oJumpForward 7138
7111: oEmit 61
7113: oJumpForward 7138
7115: oError 16
7117: oJumpForward 7138
7119: oEmit 62
7121: oJumpForward 7138
7123: Choice Lookup Table
          26   7119
          20   7115
          24   7115
          25   7111
          22   7107
          21   7103
7136: oError 17
7138: oTypeSPop
7139: oInputChoice 7147
7141: oJumpForward 7155
7143: oJumpForward 7153
7145: oJumpForward 7153
7147: Choice Lookup Table
          12   7145
          14   7141
7152: oEndChoice
7153: oJumpBack 7098
7155: oJumpForward 7160
7157: Choice Lookup Table
          13   7098
7160: oReturn
7161: oLocalSpace 0
7163: oReturn
7164: oLocalSpace 0
7166: oReturn
7167: oLocalSpace 0
7169: oScopeCurrent
7170: oPushResult
7171: oSetResult 14
7173: oPushResult
7174: oNodeGetInt
7175: oPop 2
7177: oReturn
7178: oReturn
7179: oLocalSpace 0
7181: oGetParam 1
7183: oPushResult
7184: oSetResult 19
7186: oPushResult
7187: oNodeGet
7188: oPop 2
7190: oPushResult
7191: oSetResult 14
7193: oPushResult
7194: oNodeGetInt
7195: oPop 2
7197: oReturn
7198: oReturn
7199: oLocalSpace 0
7201: oCall 7167
7203: oPushResult
7204: oGetParam 1
7206: oPushResult
7207: oCall 7179
7209: oPop 1
7211: oPushResult
7212: subtract
7213: oPop 2
7215: oReturn
7216: oReturn
7217: oLocalSpace 1
7219: oGetAddrLocal 1
7221: oPushResult
7222: oTypeSNodeType
7223: oAssign
7224: oTypeSPop
7225: oGetLocal 1
7227: oPushResult
7228: oTypeSNodeType
7229: oPushResult
7230: equal_node_type
7231: oPop 2
7233: oChoice 7239
7235: oError 14
7237: oJumpForward 7242
7239: Choice Lookup Table
           0   7235
7242: oReturn
7243: oLocalSpace 0
7245: oTypeSNodeType
7246: oChoice 7250
7248: oJumpForward 7255
7250: Choice Lookup Table
          21   7248
7253: oError 7
7255: oTypeSPop
7256: oReturn
7257: oLocalSpace 0
7259: oTypeSNodeType
7260: oChoice 7264
7262: oJumpForward 7269
7264: Choice Lookup Table
          21   7262
7267: oError 7
7269: oReturn
7270: oLocalSpace 0
7272: oTypeSNodeType
7273: oChoice 7277
7275: oJumpForward 7282
7277: Choice Lookup Table
          22   7275
7280: oError 8
7282: oTypeSPop
7283: oReturn
7284: oLocalSpace 0
7286: oTypeSNodeType
7287: oChoice 7291
7289: oJumpForward 7296
7291: Choice Lookup Table
          22   7289
7294: oError 8
7296: oReturn
7297: oLocalSpace 1
7299: oGetAddrLocal 1
7301: oPushResult
7302: oGetParam 2
7304: oPushResult
7305: oNodeNew
7306: oPop 1
7308: oAssign
7309: oGetLocal 1
7311: oPushResult
7312: oSetResult 16
7314: oPushResult
7315: oGetParam 1
7317: oPushResult
7318: oNodeSetInt
7319: oPop 3
7321: oGetLocal 1
7323: oPushResult
7324: oTypeAdd
7325: oPop 1
7327: oGetLocal 1
7329: oReturn
7330: oReturn
7331: oLocalSpace 1
7333: oGetAddrLocal 1
7335: oPushResult
7336: oGetParam 3
7338: oPushResult
7339: oNodeNew
7340: oPop 1
7342: oAssign
7343: oGetLocal 1
7345: oPushResult
7346: oSetResult 4
7348: oPushResult
7349: oGetParam 1
7351: oPushResult
7352: oNodeSetInt
7353: oPop 3
7355: oGetLocal 1
7357: oReturn
7358: oReturn
7359: oLocalSpace 1
7361: oGetAddrLocal 1
7363: oPushResult
7364: oGetParam 1
7366: oPushResult
7367: oSetResult 32
7369: oPushResult
7370: oNodeGet
7371: oPop 2
7373: oAssign
7374: oGetLocal 1
7376: oPushResult
7377: oNodeNull
7378: oPop 1
7380: oChoice 7436
7382: oGetAddrLocal 1
7384: oPushResult
7385: oSetResult 26
7387: oPushResult
7388: oNodeNew
7389: oPop 1
7391: oAssign
7392: oGetLocal 1
7394: oPushResult
7395: oSetResult 33
7397: oPushResult
7398: oGetParam 1
7400: oPushResult
7401: oNodeSet
7402: oPop 3
7404: oGetLocal 1
7406: oPushResult
7407: oSetResult 16
7409: oPushResult
7410: oSetResult 8
7412: oPushResult
7413: oNodeSetInt
7414: oPop 3
7416: oGetLocal 1
7418: oPushResult
7419: oTypeAdd
7420: oPop 1
7422: oGetParam 1
7424: oPushResult
7425: oSetResult 32
7427: oPushResult
7428: oGetLocal 1
7430: oPushResult
7431: oNodeSet
7432: oPop 3
7434: oJumpForward 7439
7436: Choice Lookup Table
           1   7382
7439: oGetLocal 1
7441: oReturn
7442: oReturn
7443: oLocalSpace 0
7445: oGetParam 1
7447: oPushResult
7448: oNodeType
7449: oPop 1
7451: oChoice 7479
7453: oMININT
7454: oReturn
7455: oJumpForward 7493
7457: oSetResult 0
7459: oReturn
7460: oJumpForward 7493
7462: oSetResult 0
7464: oReturn
7465: oJumpForward 7493
7467: oGetParam 1
7469: oPushResult
7470: oSetResult 35
7472: oPushResult
7473: oNodeGetInt
7474: oPop 2
7476: oReturn
7477: oJumpForward 7493
7479: Choice Lookup Table
          28   7467
          24   7462
          22   7457
          21   7453
7488: oError 3
7490: oSetResult 0
7492: oReturn
7493: oReturn
7494: oLocalSpace 0
7496: oGetParam 1
7498: oPushResult
7499: oSetResult 21
7501: oPushResult
7502: oNodeGetInt
7503: oPop 2
7505: oPushResult
7506: oEmitInt
7507: oPop 1
7509: oReturn
7510: oLocalSpace 1
7512: oGetAddrGlobal 3
7514: oPushResult
7515: oSetResult 20
7517: oPushResult
7518: oSetResult 4
7520: oPushResult
7521: oCall 7297
7523: oPop 2
7525: oAssign
7526: oGetAddrGlobal 4
7528: oPushResult
7529: oSetResult 21
7531: oPushResult
7532: oSetResult 4
7534: oPushResult
7535: oCall 7297
7537: oPop 2
7539: oAssign
7540: oGetAddrGlobal 5
7542: oPushResult
7543: oSetResult 22
7545: oPushResult
7546: oSetResult 1
7548: oPushResult
7549: oCall 7297
7551: oPop 2
7553: oAssign
7554: oGetAddrGlobal 6
7556: oPushResult
7557: oSetResult 23
7559: oPushResult
7560: oSetResult 1
7562: oPushResult
7563: oCall 7297
7565: oPop 2
7567: oAssign
7568: oGetAddrGlobal 7
7570: oPushResult
7571: oSetResult 24
7573: oPushResult
7574: oSetResult 1
7576: oPushResult
7577: oCall 7297
7579: oPop 2
7581: oAssign
7582: oGetAddrGlobal 8
7584: oPushResult
7585: oSetResult 25
7587: oPushResult
7588: oSetResult 256
7590: oPushResult
7591: oCall 7297
7593: oPop 2
7595: oAssign
7596: oGetAddrLocal 1
7598: oPushResult
7599: oSetResult 13
7601: oPushResult
7602: oSetResult 5
7604: oPushResult
7605: oIdAdd_File
7606: oPushResult
7607: oCall 7331
7609: oPop 3
7611: oAssign
7612: oGetLocal 1
7614: oPushResult
7615: oSetResult 20
7617: oPushResult
7618: oGetGlobal 3
7620: oPushResult
7621: oNodeSet
7622: oPop 3
7624: oGetLocal 1
7626: oPushResult
7627: oScopeDeclare
7628: oPop 1
7630: oGetAddrLocal 1
7632: oPushResult
7633: oSetResult 13
7635: oPushResult
7636: oSetResult 5
7638: oPushResult
7639: oIdAdd_Integer
7640: oPushResult
7641: oCall 7331
7643: oPop 3
7645: oAssign
7646: oGetLocal 1
7648: oPushResult
7649: oSetResult 20
7651: oPushResult
7652: oGetGlobal 4
7654: oPushResult
7655: oNodeSet
7656: oPop 3
7658: oGetLocal 1
7660: oPushResult
7661: oScopeDeclare
7662: oPop 1
7664: oGetAddrLocal 1
7666: oPushResult
7667: oSetResult 13
7669: oPushResult
7670: oSetResult 5
7672: oPushResult
7673: oIdAdd_Boolean
7674: oPushResult
7675: oCall 7331
7677: oPop 3
7679: oAssign
7680: oGetLocal 1
7682: oPushResult
7683: oSetResult 20
7685: oPushResult
7686: oGetGlobal 5
7688: oPushResult
7689: oNodeSet
7690: oPop 3
7692: oGetLocal 1
7694: oPushResult
7695: oScopeDeclare
7696: oPop 1
7698: oGetAddrLocal 1
7700: oPushResult
7701: oSetResult 13
7703: oPushResult
7704: oSetResult 5
7706: oPushResult
7707: oIdAdd_Char
7708: oPushResult
7709: oCall 7331
7711: oPop 3
7713: oAssign
7714: oGetLocal 1
7716: oPushResult
7717: oSetResult 20
7719: oPushResult
7720: oGetGlobal 7
7722: oPushResult
7723: oNodeSet
7724: oPop 3
7726: oGetLocal 1
7728: oPushResult
7729: oScopeDeclare
7730: oPop 1
7732: oGetAddrLocal 1
7734: oPushResult
7735: oSetResult 13
7737: oPushResult
7738: oSetResult 5
7740: oPushResult
7741: oIdAdd_String
7742: oPushResult
7743: oCall 7331
7745: oPop 3
7747: oAssign
7748: oGetLocal 1
7750: oPushResult
7751: oSetResult 20
7753: oPushResult
7754: oGetGlobal 8
7756: oPushResult
7757: oNodeSet
7758: oPop 3
7760: oGetLocal 1
7762: oPushResult
7763: oScopeDeclare
7764: oPop 1
7766: oGetAddrLocal 1
7768: oPushResult
7769: oSetResult 12
7771: oPushResult
7772: oSetResult 4
7774: oPushResult
7775: oIdAdd_True
7776: oPushResult
7777: oCall 7331
7779: oPop 3
7781: oAssign
7782: oGetLocal 1
7784: oPushResult
7785: oSetResult 20
7787: oPushResult
7788: oGetGlobal 5
7790: oPushResult
7791: oNodeSet
7792: oPop 3
7794: oGetLocal 1
7796: oPushResult
7797: oSetResult 21
7799: oPushResult
7800: oSetResult 1
7802: oPushResult
7803: oNodeSetInt
7804: oPop 3
7806: oGetLocal 1
7808: oPushResult
7809: oScopeDeclare
7810: oPop 1
7812: oGetAddrLocal 1
7814: oPushResult
7815: oSetResult 12
7817: oPushResult
7818: oSetResult 4
7820: oPushResult
7821: oIdAdd_False
7822: oPushResult
7823: oCall 7331
7825: oPop 3
7827: oAssign
7828: oGetLocal 1
7830: oPushResult
7831: oSetResult 20
7833: oPushResult
7834: oGetGlobal 5
7836: oPushResult
7837: oNodeSet
7838: oPop 3
7840: oGetLocal 1
7842: oPushResult
7843: oSetResult 21
7845: oPushResult
7846: oSetResult 0
7848: oPushResult
7849: oNodeSetInt
7850: oPop 3
7852: oGetLocal 1
7854: oPushResult
7855: oScopeDeclare
7856: oPop 1
7858: oReturn
