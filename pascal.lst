   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tCastItoD         % convert int32_t to double
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tGreaterD         % double comparisions.  (equality uses EqualP, at least for now)
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueIntToDouble
      
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
      
   2:    oValueNegateD               % operations on double values
   2:    oValueEqualD
   2:    oValueNotEqualD
   2:    oValueLessD
   2:    oValueGreaterD
   2:    oValueLessEqualD
   2:    oValueGreaterEqualD
      
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
      
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
      
   2:    oValueAddD
   2:    oValueSubD
   2:    oValueMultD
   2:    oValueDivD
      
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nDoubleType :
2586:          decl = @newIdent( nConstDouble, id )
2600:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2611:       | nStrLitType :
2613:          decl = @newIdent( nConstStr, id )
2627:          oNodeSetString( decl, qValueStr, oValueTopString )
2638:       | * :  #eNotAllowed
2661:    ]
2661:    oValuePop
2662:    oNodeSet( decl, qType, oTypeSTop )
2673:    oTypeSPop
2674:    oScopeDeclare( decl )
2680:    ';'
2683:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2683: TypedConstDecl:
2685:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2698:    Node theType
2698:    @TypeRef( theType )
2705:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2717:    [ oNodeType( theType )
2724:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2725:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2725:          '='
      
2727:          oTypeSPush( theType )
2733:          @ConstExpr
2735:          @ConstCoerceType
      
2737:          oNodeSetInt( decl, qValue, oValueTop )
2748:          oValuePop
2749:          oTypeSPop
2750:          oScopeDeclare( decl )
2756:          ';'
      
2758:       | nShortStringType, nFileType :
2760:          #eNotImplemented
      
2762:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2764:          oScopeEnter( globalScope )
2770:          int addr = oScopeAllocType( theType )
2780:          oScopeEnd
2781:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2792:          oNodeSetInt( decl, qValue, addr )
2804:          '='
2806:          @TypedConstInit( theType, addr )
2816:          oCodePop
2817:          oScopeDeclare( decl )
2823:          ';'
2825:    ]
2852:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2852: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2854:    [ oNodeType( theType )
2861:       | nArrayType :
2862:          Node baseType = oNodeGet( theType, qBaseType )
2875:          Node indexType = oNodeGet( theType, qIndexType )
2888:          int low = @OrdinalLow( indexType )
2899:          int high = @OrdinalHigh( indexType )
2910:          int elementSize = oNodeGetInt( baseType, qSize )
      
2923:          '('
               % Loop over elements
2925:          int i = low
2931:          {
2931:             @TypedConstInit( baseType, addr )
2941:             [ equal( i, high )
2951:                | true : >
2954:                | false :
2956:             ]
2964:             ','
2966:             addr = add( addr, elementSize )
2979:             inc( i )
2985:          }
2987:          ')'
      
2989:       | nRecordType :
2991:          '('
2993:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3006:          {
3006:             [
3006:                | pIdent :
3008:                | * :  >
3015:             ]
3015:             Node field = oScopeFindRequireInScope( fieldScope )
3025:             ':'
3027:             Node fieldType = oNodeGet( field, qType )
3040:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3060:             @TypedConstInit( fieldType, fieldAddr )
3070:             [
3070:                | ';' :
3072:                | * :  >
3079:             ]
3079:          }
3081:          ')'
      
3083:       | nBooleanType, nByteType, nCharType:
3085:          .tPushAddrGlobal  oEmitInt( addr )
3093:          oTypeSPush( theType )
3099:          @ConstExpr
3101:          @ConstCoerceType
3103:          .tPushConstI  oEmitInt( oValueTop )
3110:          oValuePop
3111:          oTypeSPop
3112:          .tAssignB
      
3114:       | nIntegerType, nEnumType:
3116:          .tPushAddrGlobal  oEmitInt( addr )
3124:          oTypeSPush( theType )
3130:          @ConstExpr
3132:          @ConstCoerceType
3134:          .tPushConstI  oEmitInt( oValueTop )
3141:          oValuePop
3142:          oTypeSPop
3143:          .tAssignI
      
3145:       | nDoubleType:
3147:          #eNotImplemented
      
3149:       | nPointerType, nUniversalPointerType :
3151:          .tPushAddrGlobal  oEmitInt( addr )
3159:          oTypeSPush( theType )
3165:          @ConstExpr
3167:          @ConstCoerceType
3169:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3176:          oValuePop
3177:          oTypeSPop
3178:          .tAssignP
      
3180:       | nShortStringType, nFileType :
3182:          #eNotImplemented
3184:    ]
3213:    ;
      
      
3213: TypeDecl:
3215:    {[
3215:       | pIdent :
3217:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3230:          '='
3232:          Node theType
3232:          @TypeRef( theType )
3239:          oNodeSet( decl, qType, theType )
3251:          oScopeDeclare( decl )
3257:          ';'
3259:       | * :
3264:          >
3266:    ]};
      
3269: VarDecl( node_type varNodeType ):
3271:    {[
3271:       | pIdent :
3273:          NodeVec decls = oNodeVecNew
3278:          Node decl
3278:          {
3278:             decl = @newIdent( varNodeType, LAST_ID )
3291:             oNodeVecAppend( decls, decl )
3300:             [
3300:                | ',' :
3302:                   pIdent
3304:                | * :
3309:                   >
3311:             ]
3311:          }
3313:          ':'
3315:          Node theType
3315:          @TypeRef( theType )
      
3322:          int i = 0
3328:          {[ equal( i, oNodeVecSize( decls ) )
3342:             | false :
3343:                decl = oNodeVecElement( decls, i )
3356:                oNodeSet( decl, qType, theType )
3368:                oScopeDeclareAlloc( decl )
3374:                inc( i )
3380:             | * :
3385:               >
3387:          ]}
      
               % optional initialization
3389:          [
3389:             | '=' :
3391:                [ oNodeVecSize( decls )
3398:                   | 1 :
3399:                   | * :  #eOnlyOneVarCanBeInitialized
3406:                ]
      
                     % we need an initCode stream for this scope
3406:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3416:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3422:                boolean changedScope = false
3428:                [ equal_zero( @ScopeLevel )
3435:                   | true : oScopeEnter( initScope )
3442:                            changedScope = true
3448:                   | * :
3453:                ]
                     % generate assignment in initCode stream
3453:                @LValueVar( decl, true )
3463:                @Expr
3465:                @CoerceType
3467:                @Assign
3469:                [ changedScope
3472:                   | true : oScopeEnd
3474:                   | * :
3479:                ]
3479:                oCodePop
                   
3480:             | * :
3485:          ]
      
3485:          oNodeVecDelete( decls )
3491:          ';'
3493:       | * :
3498:          >
3500:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3503: LabelDecl:
3505:    {
3505:       Node decl
3505:       [
3505:          | pIdent :
3507:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3509:             oChangeIntLitToLabelIdent
3510:       ]
3518:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3531:       Label label = oLabelNew
3536:       oNodeSetLabel( decl, qValue, label )
3548:       oScopeDeclare( decl )
3554:       [
3554:          | ',' :
3556:          | * :
3561:             >
3563:       ]
3563:    }
3565:    ';'
3568:    ;
3568: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3568: ConstExpr:
3570:    @ConstBoolExpr
3572:    {[
3572:       | '=' :
3574:          @ConstBoolTerm
3576:          @ConstCoerceTypePair
3578:          [ oTypeSNodeType
3580:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3589:             | nDoubleType :   oValueEqualD
3592:             | * :             oValueEqual
3600:          ]
3600:          oTypeSPop  oTypeSPush( BooleanType )
3607:       | '<>' :
3609:          @ConstBoolExpr
3611:          @ConstCoerceTypePair
3613:          [ oTypeSNodeType
3615:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3624:             | nDoubleType :   oValueNotEqualD
3627:             | * :             oValueNotEqual
3635:          ]
3635:          oTypeSPop  oTypeSPush( BooleanType )
3642:       | '<' :
3644:          @ConstBoolExpr
3646:          @ConstCoerceTypePair
3648:          [ oTypeSNodeType
3650:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3659:             | nDoubleType :   oValueLessD
3662:             | * :             oValueLess
3670:          ]
3670:          oTypeSPop  oTypeSPush( BooleanType )
3677:       | '>' :
3679:          @ConstBoolExpr
3681:          @ConstCoerceTypePair
3683:          [ oTypeSNodeType
3685:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3694:             | nDoubleType :   oValueGreaterD
3697:             | * :             oValueGreater
3705:          ]
3705:          oTypeSPop  oTypeSPush( BooleanType )
3712:       | '<=' :
3714:          @ConstBoolExpr
3716:          @ConstCoerceTypePair
3718:          [ oTypeSNodeType
3720:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3729:             | nDoubleType :   oValueLessEqualD
3732:             | * :             oValueLessEqual
3740:          ]
3740:          oTypeSPop  oTypeSPush( BooleanType )
3747:       | '>=' :
3749:          @ConstBoolExpr
3751:          @ConstCoerceTypePair
3753:          [ oTypeSNodeType
3755:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3764:             | nDoubleType :   oValueGreaterEqualD
3767:             | * :             oValueGreaterEqual
3775:          ]
3775:          oTypeSPop  oTypeSPush( BooleanType )
3782:       | * :  >
3799:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3802: ConstExprAllowTypeName:
3804:    boolean oldAllowTypeName = flagExprAllowTypeName
3810:    flagExprAllowTypeName = true
3816:    @ConstExpr
3818:    flagExprAllowTypeName = oldAllowTypeName
3825:    ;
      
      
3825: ConstBoolExpr:
3827:    @ConstBoolTerm
3829:    {[
3829:       | pOr :
3831:          @ConstRequireBool
3833:          @ConstBoolTerm
3835:          @ConstRequireBoolPop
3837:          oValueOr
3838:       | * :  >
3845:    ]};
      
      
3848: ConstBoolTerm:
3850:    @ConstBoolFactor
3852:    {[
3852:       | pAnd :
3854:          @ConstRequireBool
3856:          @ConstBoolFactor
3858:          @ConstRequireBoolPop
3860:          oValueAnd
3861:       | * :  >
3868:    ]};
      
      
3871: ConstBoolFactor:
3873:    [
3873:       | pNot :
3875:          @ConstBoolFactor
3877:          @ConstRequireBool
3879:          oValueNot
3880:       | * :
3885:          @ConstArithExpr
3887:    ];
      
      
3888: ConstArithExpr:
3890:    @ConstTerm
3892:    {[
3892:       | '+' :
3894:          @ConstTerm
3896:          @ConstCoerceTypePair
3898:          [ oTypeSNodeType
3900:             | nStrLitType :   oValueStringConcat
3902:             | nDoubleType :   oValueAddD
3905:             | * :             oValueAdd
3913:          ]
3913:       | '-' :
3915:          @ConstTerm
3917:          @ConstCoerceTypePair
3919:          [ oTypeSNodeType
3921:             | nStrLitType :   #eNotAllowed
3924:             | nDoubleType :   oValueSubD
3927:             | * :             oValueSub
3935:          ]
3935:       | * :  >
3944:    ]};
      
      
3947: ConstTerm:
3949:    @ConstFactor
3951:    {[
3951:       | pTimes :
3953:          @ConstFactor
3955:          @ConstCoerceTypePair
3957:          [ oTypeSNodeType
3959:             | nStrLitType :   #eNotAllowed
3962:             | nDoubleType :   oValueMultD
3965:             | * :             oValueMult
3973:          ]
3973:       | pDivide :
3975:          @ConstFactor
3977:          @ConstCoerceTypePair
3979:          [ oTypeSNodeType
3981:             | nStrLitType :   #eNotAllowed
3984:             | nDoubleType :   oValueDivD
3987:             | * :             oValueDiv
3995:          ]
3995:       | * :  >
4004:    ]};
      
      
4007: ConstFactor:
4009:    [
4009:       | pPlus :
4011:          @ConstPrimary
4013:       | pMinus :
4015:          @ConstPrimary
4017:          [ oTypeSNodeType
4019:             | nStrLitType :   #eNotAllowed
4022:             | nDoubleType :   oValueNegateD
4025:             | * :             oValueNegate
4033:          ]
4033:       | * :
4040:          @ConstPrimary
4042:    ];
      
      
4043: ConstPrimary:
4045:    [
4045:       | pIntLit :
4047:          oValuePush( TOKEN_VALUE )
4052:          oTypeSPush( IntegerType )
4058:       | pCharLit :
4060:          oValuePush( TOKEN_VALUE )
4065:          oTypeSPush( CharType )
4071:       | pDoubleLit :
4073:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4078:          oTypeSPush( DoubleType )
4084:       | pStrLit :
4086:          oValuePushString( CURRENT_STRLIT )
4091:          oTypeSPush( StrLitType )
4097:       | '(' :
4099:          @ConstExpr
4101:          ')'
4103:       | pIdent :
4105:          Node decl = oScopeFindRequire
4110:          @ResolveUnitRef( decl )
4117:          [ oNodeType( decl )
4124:             | nBuiltInFunc :
4125:                @ConstBuiltInFunc( decl )
4132:             | nConst :
4134:                oValuePush( oNodeGetInt( decl, qValue ) )
4147:                oTypeSPush( oNodeGet( decl, qType ) )
4160:             | nConstStr :
4162:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4175:                oTypeSPush( oNodeGet( decl, qType ) )
4188:             | nEnumValue :
4190:                oValuePush( oNodeGetInt( decl, qValue ) )
4203:                oTypeSPush( oNodeGet( decl, qType ) )
4216:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4218:                oTypeSPush( oNodeGet( decl, qType ) )
4231:                [
4231:                   | '(' :
                           % Type cast
4233:                      @ConstExpr
4235:                      ')'
4237:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4239:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4244:                      [ flagExprAllowTypeName
4247:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4248:                            oValuePush( 0 )
4254:                         | * :   #eTypeNameNotAllowedHere
4261:                      ]
4261:                ]
      
4261:             | * :
4274:                #eNotConst
4276:                oValuePush( 0 )
4282:                oTypeSPush( IntegerType )
4288:          ]
4288:       | '@' :
4290:          #eNotImplemented
4292:          oValuePush( 0 )
4298:          oTypeSPush( UniversalPointerType )
4304:       | * :
4321:          #eNotConst
4323:          oValuePush( 0 )
4329:          oTypeSPush( IntegerType )
4335:    ];
      
4336: ConstRequireBoolPop:
4338:    [ oTypeSNodeType
4340:       | nBooleanType :
4341:       | * :          #eNotBoolean
4348:    ]
4348:    oTypeSPop;
      
      
4350: ConstRequireBool:
4352:    [ oTypeSNodeType
4354:       | nBooleanType :
4355:       | * :          #eNotBoolean
4362:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4363: ConstMatchTypes:
4365:    node_type nt = oTypeSNodeType
4370:    oTypeSPop
4371:    [ equal_node_type( nt, oTypeSNodeType )
4380:       | false :
               % Some implicit conversion is allowed even here
4381:          [ oTypeSNodeType
4383:             | nPointerType :
4384:                [ nt
4387:                   | nUniversalPointerType :  >>
4389:                   | * :
4394:                ]
4394:             | nUniversalPointerType :
4396:                [ nt
4399:                   | nPointerType :  >>
4401:                   | * :
4406:                ]
4406:             | nStrLitType :
4408:                [ nt
4411:                   | nCharType :
4412:                      oValueCharToString
4413:                      >>
4414:                   | * :
4419:                ]
4419:             | nCharType :
4421:                [ nt
4424:                   | nStrLitType :
4425:                      oValueSwap
4426:                      oValueCharToString
4427:                      oValueSwap
4428:                      oTypeSPop
4429:                      oTypeSPush( StrLitType )
4435:                      >>
4436:                   | * :
4441:                ]
4441:             | * :
4452:          ]
4452:          #eTypeMismatch
4454:       | * :
4459:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4460: ConstCoerceType:
4462:    node_type nt = oTypeSNodeType
4467:    oTypeSPop
4468:    [ equal_node_type( nt, oTypeSNodeType )
4477:       | false :
               % Can we implicitly convert the value to the desired type?
4478:          [ oTypeSNodeType
4480:             | nIntegerType :
4481:                [ nt
4484:                   | nByteType :  >>
4486:                   | * :
4491:                ]
4491:             | nByteType :
4493:                [ nt
4496:                   | nIntegerType :  >>
4498:                   | * :
4503:                ]
4503:             | nPointerType :
4505:                [ nt
4508:                   | nUniversalPointerType :  >>
4510:                   | * :
4515:                ]
4515:             | nUniversalPointerType :
4517:                [ nt
4520:                   | nPointerType :  >>
4522:                   | * :
4527:                ]
4527:             | nStrLitType :
4529:                [ nt
4532:                   | nCharType :
4533:                      oValueCharToString
4534:                      >>
4535:                   | * :
4540:                ]
4540:             | nShortStringType :
4542:                [ nt
4545:                   | nStrLitType :  >>
4547:                   | nCharType :
4549:                      oValueCharToString
4550:                      >>
4551:                   | * :
4558:                ]
4558:             | * :
4573:          ]
4573:          #eTypeMismatch
4575:       | * :
4580:    ];
      
      
      % The value stack contains two const values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that botrh types are flexible.
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.
      % Leave both values on the value stack, and the single common type on the type stack.
      %
4581: ConstCoerceTypePair:
         % TO DO.  For now, require the types to match
4583:    @ConstMatchTypes
4586:    ;
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4586: ConstCastType:
4588:    node_type nt = oTypeSNodeType
4593:    oTypeSPop
4594:    [ equal_node_type( nt, oTypeSNodeType )
4603:       | false :
               % Can we cast the value to the desired type?
4604:          [ oTypeSNodeType
4606:             | nIntegerType, nEnumType :
4607:                [ nt
4610:                   | nByteType, nCharType, nBooleanType :  >>
4612:                   | nIntegerType, nEnumType :  >>
                        % fpc does not allow explicit cast of double to integer.
                        % User must call trunc() / round().
4615:                   | * :
4628:                ]
4628:             | nByteType, nCharType, nBooleanType :
4630:                [ nt
4633:                   | nByteType, nCharType, nBooleanType :  >>
4635:                   | nIntegerType, nEnumType :  >>
4638:                   | * :
4651:                ]
4651:             | nDoubleType :
4653:                [ nt
4656:                   | nByteType, nCharType, nBooleanType, nIntegerType, nEnumType :
4657:                      oValueIntToDouble
4658:                      >>
4659:                   | nDoubleType :  >>
4662:                   | * :
4677:                ]
4677:             | nPointerType :
4679:                [ nt
4682:                   | nUniversalPointerType :  >>
4684:                   | * :
4689:                ]
4689:             | nUniversalPointerType :
4691:                [ nt
4694:                   | nPointerType :  >>
4696:                   | * :
4701:                ]
4701:             | nStrLitType :
4703:                [ nt
4706:                   | nCharType :
4707:                      oValueCharToString
4708:                      >>
4709:                   | * :
4714:                ]
4714:             | nShortStringType :
4716:                [ nt
4719:                   | nStrLitType :  >>
4721:                   | nCharType :
4723:                      oValueCharToString
4724:                      >>
4725:                   | * :
4732:                ]
4732:             | * :
4755:          ]
4755:          #eTypeMismatch
4757:       | * :
4762:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4763: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4765:    [ oNodeEqual( method, BuiltIn_Ord )
4775:       | true :
4776:          '('
4778:          @ConstExpr
4780:          ')'
4782:          [ oTypeSNodeType
4784:             | nIntegerType, nEnumType :
4785:             | nBooleanType, nByteType, nCharType :
4787:             | * :  #eTypeMismatch
4802:          ]
4802:          oTypeSPop
4803:          oTypeSPush( IntegerType )
4809:          ')'
4811:          >>
4812:       | * :
4817:    ]
      
         % Chr(x)
4817:    [ oNodeEqual( method, BuiltIn_Chr )
4827:       | true :
4828:          '('
4830:          @ConstExpr
4832:          ')'
4834:          [ oTypeSNodeType
4836:             | nIntegerType :
4837:             | nByteType :
4839:             | * :  #eTypeMismatch
4848:          ]
4848:          oTypeSPop
4849:          oTypeSPush( CharType )
4855:          ')'
4857:          >>
4858:       | * :
4863:    ]
      
         % Pred(x)
4863:    [ oNodeEqual( method, BuiltIn_Pred )
4873:       | true :
4874:          '('
4876:          @ConstExpr
4878:          [ oTypeSNodeType
4880:             | nEnumType :
4881:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4890:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4893:                   | * :
4898:                ]
4898:             | * :  #eTypeMismatch
4905:          ]
4905:          oValuePush( 1 )  oValueSub
4912:          ')'
4914:          >>
4915:       | * :
4920:    ]
      
         % Succ(x)
4920:    [ oNodeEqual( method, BuiltIn_Succ )
4930:       | true :
4931:          '('
4933:          @ConstExpr
4935:          [ oTypeSNodeType
4937:             | nEnumType :
4938:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4947:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4950:                   | * :
4955:                ]
4955:             | * :  #eTypeMismatch
4962:          ]
4962:          oValuePush( 1 )  oValueAdd
4969:          ')'
4971:          >>
4972:       | * :
4977:    ]
      
         % Sizeof(x)
4977:    [ oNodeEqual( method, BuiltIn_Sizeof )
4987:       | true :
4988:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4990:          @ConstExprAllowTypeName
4992:          oValuePop
4993:          Node theType = oTypeSTop
4998:          oTypeSPop
4999:          oValuePush( oNodeGetInt( theType, qSize ) )
5012:          oTypeSPush( IntegerType )
5018:          ')'
5020:          >>
5021:       | * :
5026:    ]
      
5026:    #eNotImplemented
5029:    ;
      
      
5029: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5029: Expr:
5031:    Label falseLabel = labelNull
      
5037:    @ExprAllowFlow( falseLabel )
5044:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
5052: ExprAllowTypeName:
5054:    boolean oldAllowTypeName = flagExprAllowTypeName
5060:    flagExprAllowTypeName = true
5066:    @Expr
5068:    flagExprAllowTypeName = oldAllowTypeName
5075:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5075: BooleanExprControlFlow( out Label falseLabel ):
5077:    @ExprAllowFlow( falseLabel )
5084:    [ oTypeSNodeType
5086:       | nBooleanFlowType :
5087:       | nBooleanType :
               % convert value to control flow
5089:          falseLabel = oLabelNew
5094:          .tJumpFalse  oEmitLabel( falseLabel )
5102:       | * :
5109:          #eNotBoolean
5111:    ]
5111:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5113: FlowToVal( inout Label falseLabel ):
5115:    [ oTypeSNodeType
5117:       | nBooleanFlowType :
5118:          Label doneLabel = oLabelNew
5123:          .tPushConstI  oEmitInt( 1 )
5131:          .tJump  oEmitLabel( doneLabel )
5139:          .tLabel  oEmitLabel( falseLabel )
5147:          .tPushConstI  oEmitInt( 0 )
5155:          .tLabel  oEmitLabel( doneLabel )
5163:          oTypeSPop
5164:          oTypeSPush( BooleanType )
5170:          falseLabel = labelNull
5176:       | * :
5181:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5182: ValToFlow( out Label falseLabel ):
5184:    [ oTypeSNodeType
5186:       | nBooleanType :
5187:          falseLabel = oLabelNew
5192:          .tJumpFalse  oEmitLabel( falseLabel )
5200:          oTypeSPop
5201:          oTypeSPush( BooleanFlowType )
5207:       | * :
5212:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5213: ExprAllowFlow( out Label falseLabel ):
5215:    @BoolExprAllowFlow( falseLabel )
5222:    {[
5222:       | '=' :
5224:          @FlowToVal( falseLabel )
5231:          @PromoteToIntOptional
5233:          @BoolExprAllowFlow( falseLabel )
5240:          @FlowToVal( falseLabel )
5247:          @PromoteToIntOptional
5249:          @CoerceTypePair
5251:          [ oTypeSNodeType
5253:             | nBooleanType, nCharType :     .tEqualB
5256:             | nIntegerType, nEnumType :     .tEqualI
5260:             | nDoubleType :                 .tEqualP
                        % Note: Assuming nDoubleType can use .tEqualP, just matching bits.
                        %  If not, it would also put into doubt memcmp of record values.
5264:             | nPointerType, nUniversalPointerType :    .tEqualP
5268:             | nShortStringType, nStrLitType :
5270:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5282:             | * :                           #eNotAllowed
5305:          ]
5305:          oTypeSPop
5306:          oTypeSPush( BooleanType )
      
5312:       | '<>' :
5314:          @FlowToVal( falseLabel )
5321:          @PromoteToIntOptional
5323:          @BoolExprAllowFlow( falseLabel )
5330:          @FlowToVal( falseLabel )
5337:          @PromoteToIntOptional
5339:          @CoerceTypePair
5341:          [ oTypeSNodeType
5343:             | nBooleanType, nCharType :     .tNotEqualB
5346:             | nIntegerType, nEnumType :     .tNotEqualI
5350:             | nDoubleType :                 .tNotEqualP
5354:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5358:             | nShortStringType, nStrLitType :
5360:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5372:             | * :                           #eNotAllowed
5395:          ]
5395:          oTypeSPop
5396:          oTypeSPush( BooleanType )
      
5402:       | '<' :
5404:          @FlowToVal( falseLabel )
5411:          @PromoteToIntOptional
5413:          @BoolExprAllowFlow( falseLabel )
5420:          @FlowToVal( falseLabel )
5427:          @PromoteToIntOptional
5429:          @CoerceTypePair
5431:          [ oTypeSNodeType
5433:             | nBooleanType, nCharType :     .tLessB
5436:             | nIntegerType, nEnumType :     .tLessI
5440:             | nDoubleType :                 .tLessD
5444:             | nPointerType, nUniversalPointerType :   .tLessP
5448:             | nShortStringType, nStrLitType :
5450:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5462:             | * :                           #eNotAllowed
5485:          ]
5485:          oTypeSPop
5486:          oTypeSPush( BooleanType )
      
5492:       | '>' :
5494:          @FlowToVal( falseLabel )
5501:          @PromoteToIntOptional
5503:          @BoolExprAllowFlow( falseLabel )
5510:          @FlowToVal( falseLabel )
5517:          @PromoteToIntOptional
5519:          @CoerceTypePair
5521:          [ oTypeSNodeType
5523:             | nBooleanType, nCharType :     .tGreaterB
5526:             | nIntegerType, nEnumType :     .tGreaterI
5530:             | nDoubleType :                 .tGreaterD
5534:             | nPointerType, nUniversalPointerType :   .tGreaterP
5538:             | nShortStringType, nStrLitType :
5540:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5552:             | * :                           #eNotAllowed
5575:          ]
5575:          oTypeSPop
5576:          oTypeSPush( BooleanType )
      
5582:       | '<=' :
5584:          @FlowToVal( falseLabel )
5591:          @PromoteToIntOptional
5593:          @BoolExprAllowFlow( falseLabel )
5600:          @FlowToVal( falseLabel )
5607:          @PromoteToIntOptional
5609:          @CoerceTypePair
5611:          [ oTypeSNodeType
5613:             | nBooleanType, nCharType :     .tLessEqualB
5616:             | nIntegerType, nEnumType :     .tLessEqualI
5620:             | nDoubleType :                 .tLessEqualD
5624:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5628:             | nShortStringType, nStrLitType :
5630:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5642:             | * :                           #eNotAllowed
5665:          ]
5665:          oTypeSPop
5666:          oTypeSPush( BooleanType )
      
5672:       | '>=' :
5674:          @FlowToVal( falseLabel )
5681:          @PromoteToIntOptional
5683:          @BoolExprAllowFlow( falseLabel )
5690:          @FlowToVal( falseLabel )
5697:          @PromoteToIntOptional
5699:          @CoerceTypePair
5701:          [ oTypeSNodeType
5703:             | nBooleanType, nCharType :     .tGreaterEqualB
5706:             | nIntegerType, nEnumType :     .tGreaterEqualI
5710:             | nDoubleType :                 .tGreaterEqualD
5714:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5718:             | nShortStringType, nStrLitType :
5720:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5732:             | * :                           #eNotAllowed
5755:          ]
5755:          oTypeSPop
5756:          oTypeSPush( BooleanType )
      
5762:       | * :
5777:          >
5779:    ]};
      
      
5782: BoolExprAllowFlow( out Label falseLabel ):
5784:    Label trueLabel = labelNull
      
5790:    @BoolTermAllowFlow( falseLabel )
5797:    {[
5797:       | pOr :
5799:          [ oTypeSNodeType
5801:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5802:                [ equal_label( trueLabel, labelNull )
5812:                   | true :  trueLabel = oLabelNew
5818:                   | * :
5823:                ]
5823:                .tJump  oEmitLabel( trueLabel )
5831:             | nBooleanType :
5833:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5840:                [ equal_label( trueLabel, labelNull )
5850:                   | true :  trueLabel = oLabelNew
5856:                   | * :
5861:                ]
5861:                .tJump  oEmitLabel( trueLabel )
5869:             | * : #eNotBoolean
5878:          ]
5878:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5879:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5887:          falseLabel = labelNull
5893:          @BoolTermAllowFlow( falseLabel )
      
5900:          [ oTypeSNodeType
5902:             | nBooleanFlowType :
5903:             | nBooleanType :
5905:                @ValToFlow( falseLabel )
5912:             | * : #eNotBoolean
5921:          ]
      
5921:          oTypeSPop
5922:          oTypeSPush( BooleanFlowType )
      
5928:       | * :
5933:          >
5935:    ]}
      
         % any short-circuit trues jump here to the end
5937:    [ equal_label( trueLabel, labelNull )
5947:       | false :
5948:          .tLabel  oEmitLabel( trueLabel )
5956:       | * :
5961:    ]
5962:    ;
      
      
5962: BoolTermAllowFlow( out Label falseLabel ):
5964:    Label overallFalseLabel = labelNull
      
5970:    @BoolFactorAllowFlow( falseLabel )
5977:    {[
5977:       | pAnd :
5979:          [ oTypeSNodeType
5981:             | nBooleanFlowType :
5982:             | nBooleanType :
5984:                @ValToFlow( falseLabel )
5991:             | * :
5998:                #eNotBoolean
6000:          ]
6000:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6001:          [ equal_label( overallFalseLabel, labelNull )
6011:             | true :
6012:                overallFalseLabel = oLabelNew
6017:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6031:                falseLabel = overallFalseLabel
6037:             | * :
6042:          ]
      
6042:          Label factorFalseLabel = labelNull
6048:          @BoolFactorAllowFlow( factorFalseLabel )
      
6055:          [ oTypeSNodeType
6057:             | nBooleanFlowType :
6058:             | nBooleanType :
6060:                @ValToFlow( factorFalseLabel )
6067:             | * : #eNotBoolean
6076:          ]
6076:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6090:       | * :
6095:          >
6097:    ]};
      
      
6100: BoolFactorAllowFlow( out Label falseLabel ):
6102:    [
6102:       | pNot :
6104:          Label factorFalseLabel = labelNull
      
6110:          @BoolFactorAllowFlow( factorFalseLabel )
6117:          [ oTypeSNodeType
6119:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6120:                falseLabel = oLabelNew
6125:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6133:                .tLabel  oEmitLabel( factorFalseLabel )
      
6141:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6143:                .tNot
      
6145:             | * : #eNotBoolean
6154:          ]
      
6154:       | * :
6159:          @ArithExprAllowFlow( falseLabel )
6166:    ];
      
      
6167: ArithExprAllowFlow( out Label falseLabel ):
6169:    boolean first = true
6175:    int tempStrOffset
      
6175:    @TermAllowFlow( falseLabel )
6182:    {[
6182:       | '+' :
6184:          [ oTypeSNodeType
6186:             | nIntegerType, nByteType :
6187:                @PromoteToIntPop
6189:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6196:                [ oTypeSNodeType
6198:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6199:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6201:                      @PointerAddition
6203:                   | nDoubleType :
                           % int + double
                           % int type was already popped above; leave double on type stack
6205:                      .tSwap
6207:                      .tCastItoD
6209:                      .tAddD
6211:                   | * :
6220:                      @PromoteToInt
6222:                      .tAddI
6224:                ]
      
6224:             | nDoubleType :
6226:                @TermAllowFlow( falseLabel )
6233:                @PromoteToDoublePop
6235:                .tAddD
      
6237:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6239:                [ first
6242:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6243:                             tempStrOffset = @MoveIntoTempShortString
6249:                             first = false
6255:                   | * :
6260:                ]
6260:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6267:                [ oTypeSNodeType
6269:                   | nShortStringType, nStrLitType :
6270:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6272:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6280:                      oTypeSPush( ShortStringType )
6286:                   | nCharType :
6288:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6290:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6298:                      oTypeSPush( ShortStringType )
6304:                   | * :
6313:                      #eTypeMismatch
6315:                      oTypeSPop
6316:                ]
      
6316:             | nPointerType, nUniversalPointerType :
6318:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6325:                @PromoteToIntPop
6327:                @PointerAddition
      
6329:             | * :
6348:                #eNotAllowed
6350:          ]
      
6350:       | '-' :
6352:          [ oTypeSNodeType
6354:             | nIntegerType, nByteType :
6355:                @PromoteToIntPop
6357:                @TermAllowFlow( falseLabel )
      
6364:                [ oTypeSNodeType
6366:                   | nDoubleType :
                           % int - double
                           % int type was already popped above; leave double on type stack
6367:                      .tSwap
6369:                      .tCastItoD
6371:                      .tSwap
6373:                      .tSubD
6375:                   | * :
6380:                      @PromoteToInt
6382:                      .tSubI
6384:                ]
      
6384:             | nDoubleType :
6386:                @TermAllowFlow( falseLabel )
6393:                @PromoteToDoublePop
6395:                .tSubD
      
6397:             | nPointerType, nUniversalPointerType :
6399:                @TermAllowFlow( falseLabel )
6406:                [ oTypeSNodeType
6408:                   | nIntegerType, nByteType :
6409:                      @PromoteToIntPop
6411:                      @PointerSubInt
6413:                   | nPointerType, nUniversalPointerType :
6415:                      @MatchTypes
6417:                      @PointerSubPointer
6419:                   | * :
6430:                      #eNotAllowed
6432:                ]
      
6432:             | * :  #eNotAllowed
      
6447:          ]
6447:       | * :
6454:          >
6456:    ]};
      
      
6459: TermAllowFlow( out Label falseLabel ):
6461:    @FactorAllowFlow( falseLabel )
6468:    {[
6468:       | '*' :
6470:          [ oTypeSNodeType
6472:             | nIntegerType, nByteType :
6473:                @PromoteToIntPop
6475:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6482:                [ oTypeSNodeType
6484:                   | nDoubleType :
                           % int * double
                           % int type was already popped above; leave double on type stack
6485:                      .tSwap
6487:                      .tCastItoD
6489:                      .tMultD
6491:                   | * :
6496:                      @PromoteToInt
6498:                      .tMultI
6500:                ]
      
6500:             | nDoubleType :
6502:                @FactorAllowFlow( falseLabel )
6509:                @PromoteToDoublePop
6511:                .tMultD
      
6513:             | * :
6522:                #eNotAllowed
6524:          ]
      
6524:       | '/' :
6526:          [ oTypeSNodeType
6528:             | nIntegerType, nByteType :
6529:                @PromoteToIntPop
6531:                @FactorAllowFlow( falseLabel )
6538:                [ oTypeSNodeType
6540:                   | nDoubleType :
                           % int / double
                           % int type was already popped above; leave double on type stack
6541:                      .tSwap
6543:                      .tCastItoD
6545:                      .tSwap
6547:                      .tDivD
6549:                   | * :
6554:                      @PromoteToInt
6556:                      .tDivI
6558:                ]
      
6558:             | nDoubleType :
6560:                @FactorAllowFlow( falseLabel )
6567:                @PromoteToDoublePop
6569:                .tDivD
      
6571:             | * :
6580:                #eNotAllowed
6582:          ]
      
6582:       | * :
6589:          >
6591:    ]};
      
      
6594: FactorAllowFlow( out Label falseLabel ):
6596:    [
6596:       | '+' :
6598:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6605:          [ oTypeSNodeType
6607:             | nIntegerType, nByteType :
6608:             | nDoubleType :
6610:             | * :
6619:                #eNotAllowed
6621:          ]
6621:       | '-' :
6623:          @PrimaryAllowFlow( falseLabel )
6630:          [ oTypeSNodeType
6632:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6633:                @PromoteToInt
6635:                .tNegI
6637:             | nDoubleType :
6639:                .tNegD
6641:             | * :
6650:                #eNotAllowed
6652:          ]
6652:       | * :
6659:          @PrimaryAllowFlow( falseLabel )
6666:    ];
      
      
6667: PrimaryAllowFlow( out Label falseLabel ):
6669:    [
6669:       | pIntLit :
6671:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6678:          oTypeSPush( IntegerType )
      
6684:       | pCharLit :
6686:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6693:          oTypeSPush( CharType )
      
6699:       | pDoubleLit :
6701:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6708:          oTypeSPush( DoubleType )
      
6714:       | '(' :
6716:          @ExprAllowFlow( falseLabel )
6723:          ')'
      
6725:       | pStrLit :
6727:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6736:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6744:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6750:          @LValueIndexes
               % get final value of dereferencing, if any
6752:          @FetchVar
      
6754:       | pIdent :
6756:          Node decl = oScopeFindRequire
6761:          @ResolveUnitRef( decl )
6768:          Node theType
      
6768:          [ oNodeType( decl )
6775:             | nFunc :
6776:                @Call( decl )
      
6783:             | nBuiltInFunc :
6785:                @CallBuiltInFunc( decl )
      
6792:             | nConst, nEnumValue :
6794:                theType = oNodeGet( decl, qType )
6807:                oTypeSPush( theType )
6813:                [ oTypeSNodeType
6815:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6816:                      .tPushConstI @EmitValue( decl )
6825:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6827:                      .tPushConstI @EmitValue( decl )
6836:                   | * :
6853:                      #eNotImplemented
6855:                ]
      
6855:             | nConstDouble :
6857:                theType = oNodeGet( decl, qType )
6870:                oTypeSPush( theType )
6876:                [ oTypeSNodeType
6878:                   | nDoubleType :
6879:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6894:                   | * :
6899:                      #eNotImplemented
6901:                ]
                     
6901:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6903:                int addr = oNodeGetInt( decl, qValue )
6916:                [ equal_zero( addr )
6923:                   | true :
6924:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6941:                      oNodeSetInt( decl, qValue, addr )
6953:                   | * :
6958:                ]
6958:                .tPushAddrGlobal oEmitInt( addr )
6966:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6972:                @LValueIndexes
                     % get final value of dereferencing, if any
6974:                @FetchVar
      
6976:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6978:                @VarExpr( decl )
      
6985:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6987:                oTypeSPush( oNodeGet( decl, qType ) )
7000:                [
7000:                   | '(' : 
                           % Type cast
7002:                      @Expr
7004:                      ')'
7006:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
7008:                      [ oTypeSNodeType
7010:                         | nPointerType, nUniversalPointerType :
7011:                            [
7011:                               | '^' :             % dereferenced
7013:                                  oTypeSPop
7014:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
7027:                                  @LValueIndexes
7029:                                  @FetchVar
7031:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
7033:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
7035:                                  @LValueIndexes
7037:                                  @FetchVar
7039:                               | * :               % just ptr value alone
7046:                            ]
      
7046:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
7048:                            @LValueIndexes
                                 % get final value, if no longer compound
7050:                            @FetchVar
      
7052:                         | *:
7065:                      ]
      
7065:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
7070:                      [ flagExprAllowTypeName
7073:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
7074:                            .tPushConstI  oEmitInt( 0 )
7082:                         | * :    #eTypeNameNotAllowedHere
7089:                      ]
7089:                ]
      
7089:             | * :
7114:                #eNotValue
7116:                oTypeSPush( IntegerType )
7122:          ]
      
7122:       | '@' :        % @var -- pointer to var
7124:          pIdent
      
7126:          Node decl = oScopeFindRequire
7131:          @ResolveUnitRef( decl )
7138:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
7138:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7148:          theType = oTypeSTop
7153:          oTypeSPop
7154:          Node ptrType = @PointerTypeTo( theType )
7165:          oTypeSPush( ptrType )
      
7171:       | * :
7188:          #eNotValue
7190:          oTypeSPush( IntegerType )
7196:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7197: VarExpr( Node decl ):
7199:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7212:    int uplevels = @DeclUpLevels( decl )
      
7223:    oTypeSPush( theType )
7229:    [ oTypeSNodeType
7231:       | nIntegerType, nEnumType :
7232:          [ oNodeType( decl )
7239:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7249:             | nLocalVar :
7251:                [ equal_zero( uplevels )
7258:                   | true :  .tPushLocalI  @EmitValue( decl )
7268:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7288:                ]
7288:             | nParam :
7290:                [ oNodeGetBoolean( decl, qInOut )
7300:                   | true :    % VAR param points to the var.  Auto dereference.
7301:                      [ equal_zero( uplevels )
7308:                         | true :  .tPushParamP  @EmitValue( decl )
7318:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7338:                      ]
7338:                      .tFetchI
7340:                   | * :
7345:                      [ equal_zero( uplevels )
7352:                         | true :  .tPushParamI  @EmitValue( decl )
7362:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7382:                      ]
7382:                ]
7382:          ]
      
7394:       | nBooleanType, nByteType, nCharType :
7396:          [ oNodeType( decl )
7403:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7413:             | nLocalVar :
7415:                [ equal_zero( uplevels )
7422:                   | true :  .tPushLocalB  @EmitValue( decl )
7432:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7452:                ]
7452:             | nParam :
7454:                [ oNodeGetBoolean( decl, qInOut )
7464:                   | true :    % VAR param points to the var.  Auto dereference.
7465:                      [ equal_zero( uplevels )
7472:                         | true :  .tPushParamP  @EmitValue( decl )
7482:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7502:                      ]
7502:                      .tFetchB
7504:                   | * :
7509:                      [ equal_zero( uplevels )
7516:                         | true :  .tPushParamB  @EmitValue( decl )
7526:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7546:                      ]
7546:                ]
7546:          ]
      
7558:       | nFileType :
7560:          #eNotImplemented
      
7562:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7564:          [ oNodeType( decl )
7571:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7581:             | nLocalVar :
7583:                [ equal_zero( uplevels )
7590:                   | true :  .tPushLocalP  @EmitValue( decl )
7600:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7620:                ]
7620:             | nParam :
7622:                [ oNodeGetBoolean( decl, qInOut )
7632:                   | true :    % VAR param points to the var.  Auto dereference.
7633:                      [ equal_zero( uplevels )
7640:                         | true :  .tPushParamP  @EmitValue( decl )
7650:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7670:                      ]
7670:                      .tFetchP
7672:                   | * :
7677:                      [ equal_zero( uplevels )
7684:                         | true :  .tPushParamP  @EmitValue( decl )
7694:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7714:                      ]
7714:                ]               
7714:          ]
7726:          [
7726:             | '^' :             % dereferenced
7728:                oTypeSPop
7729:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7742:                @LValueIndexes
7744:                @FetchVar
7746:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7748:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7750:                @LValueIndexes
7752:                @FetchVar
7754:             | * :               % just ptr value alone
7761:          ]
      
7761:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7763:          [ oNodeType( decl )
7770:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7780:             | nLocalVar :
7782:                [ equal_zero( uplevels )
7789:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7799:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7819:                ]
7819:             | nParam :
7821:                [ oNodeGetBoolean( decl, qInOut )
7831:                   | true :    % VAR param points to the var.  Auto dereference.
7832:                      [ equal_zero( uplevels )
7839:                         | true :  .tPushParamP  @EmitValue( decl )
7849:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7869:                      ]
7869:                   | * :
7874:                      [ equal_zero( uplevels )
7881:                         | true :  .tPushAddrParam  @EmitValue( decl )
7891:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7911:                      ]
7911:                ]
7911:          ]
               % modify addr for subscripts, field references, etc
7923:          @LValueIndexes
               % get final value
7925:          @FetchVar
7927:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7956: FetchVar:
7958:    [ oTypeSNodeType
7960:       | nIntegerType, nEnumType :  .tFetchI
7963:       | nBooleanType, nByteType, nCharType :  .tFetchB
7967:       | nFileType :   #eNotImplemented
7971:       | nPointerType :             .tFetchP
7975:       | nUniversalPointerType :    #eCantDereference
7979:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7981:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8010: LValueIndexes:
8012:    {[
8012:       | '[' :
8014:          [ oTypeSNodeType
8016:             | nArrayType :    @ArraySubscripts
8019:             | nPointerType :  @PointerArraySubscript
8023:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8027:             | * :             #eNotArray
8040:          ]
8040:       | '.' :       @RecordFieldRef
8044:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8048:       | * :         >
8059:    ]};
      
      
8062: ArraySubscripts:
8064:    [ oTypeSNodeType
8066:       | nArrayType :
8067:       | * :       #eNotArray
8074:    ]
8074:    {
8074:       [ oTypeSNodeType
8076:          | nArrayType :
8077:          | * :    #eTooManySubscripts
8084:       ]
      
            % low subscript of this dimension
8084:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8101:       Node baseType
8101:       baseType = oNodeGet( oTypeSTop, qBaseType )
8113:       oTypeSPop
8114:       oTypeSPush( baseType )
      
8120:       @Expr
8122:       @RequireIntPop
            % adjust for low subscript
8124:       [ equal_zero( low )
8131:          | false :
8132:             .tPushConstI oEmitInt( low ) .tSubI
8142:          | * :
8147:       ]
      
            % multiply by element size
8147:       int size = oNodeGetInt( baseType, qSize )
8160:       [ equal( size, 1 )
8170:          | false :
8171:             .tPushConstI oEmitInt( size ) .tMultI
8181:          | * :
8186:       ]
      
            % update start address
8186:       .tAddPI
8188:       [
8188:          | ']' :  >
8192:          | ',' :
8194:       ]
8202:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8205: PointerArraySubscript:
8207:    [ oTypeSNodeType
8209:       | nPointerType :
8210:       | * :    #eCantDereference
8217:    ]
         % replace type stack with base type
8217:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8229:    oTypeSPop
8230:    oTypeSPush( baseType )
         
8236:    @Expr
8238:    @RequireIntPop
         % multiply by element size
8240:    int size = oNodeGetInt( baseType, qSize )
8253:    [ equal( size, 1 )
8263:       | false :
8264:          .tPushConstI  oEmitInt( size )  .tMultI
8274:       | * :
8279:    ]
         % update start address
8279:    .tAddPI
8281:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8284: ShortStringArraySubscript:
8286:    [ oTypeSNodeType
8288:       | nStrLitType, nShortStringType :
8289:       | * :    #eCantDereference
8298:    ]
8298:    oTypeSPop
8299:    oTypeSPush( CharType )
8305:    @Expr
8307:    @RequireIntPop
8309:    .tAddPI
8311:    ']';
      
      
8314: RecordFieldRef:
8316:    [ oTypeSNodeType
8318:       | nRecordType :
8319:       | * :    #eNotRecord
8326:    ]
8326:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8338:    pIdent
8340:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8345:    [ oNodeType( field )
8352:       | nRecordField :
8353:       | * :   #eNotRecordField
8360:    ]
8360:    oScopeEnd
8361:    int offset = oNodeGetInt( field, qValue )
8374:    [ equal_zero( offset )
8381:       | false :
8382:          .tPushConstI oEmitInt( offset ) .tAddPI
8392:       | * :
8397:    ]
      
         % replace the type on the type stack, with the field type
8397:    oTypeSPop
8398:    oTypeSPush( oNodeGet( field, qType ) )
8412:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8412: PointerAddition:
8414:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8426:    int elementSize = oNodeGetInt( elementType, qSize )
8439:    [ equal( elementSize, 1 )
8449:       | false :
8450:          .tPushConstI  oEmitInt( elementSize )
8458:          .tMultI
8460:       | * :
8465:    ]
8465:    .tAddPI
8468:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8468: PointerSubInt:
8470:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8482:    int elementSize = oNodeGetInt( elementType, qSize )
8495:    [ equal( elementSize, 1 )
8505:       | false :
8506:          .tPushConstI  oEmitInt( elementSize )
8514:          .tMultI
8516:       | * :
8521:    ]
8521:    .tSubPI
8524:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8524: PointerSubPointer:
8526:    .tSubP
8528:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8540:    int elementSize = oNodeGetInt( elementType, qSize )
8553:    [ equal( elementSize, 1 )
8563:       | false :
8564:          .tPushConstI  oEmitInt( elementSize )
8572:          .tDivI
8574:       | * :
8579:    ]
8579:    oTypeSPop
8580:    oTypeSPush( IntegerType )
8587:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8587: PointerDeref:
8589:    [ oTypeSNodeType
8591:       | nPointerType :
8592:       | nUniversalPointerType :   #eCantDereference
8596:       | * :       #eNotPointer
8605:    ]
8605:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8607:    Node theType = oTypeSTop
8612:    oTypeSPop
8613:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8627:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8627: CoerceType:
8629:    node_type nt = oTypeSNodeType
8634:    Node given = oTypeSTop
8639:    oTypeSPop
8640:    [ equal_node_type( nt, oTypeSNodeType )
8649:       | false :
               % Can we implicitly convert the value to the desired type?
8650:          [ oTypeSNodeType
8652:             | nIntegerType :
8653:                [ nt
8656:                   | nByteType :   .tCastBtoI  >>
8660:                   | * :
8665:                ]
8665:             | nByteType :
8667:                [ nt
8670:                   | nIntegerType :   .tCastItoB  >>
8674:                   | * :
8679:                ]
8679:             | nDoubleType :
8681:                [ nt
8684:                   | nIntegerType :   .tCastItoD  >>
8688:                   | * :
8693:                ]
8693:             | nPointerType :
8695:                [ nt
8698:                   | nUniversalPointerType :  >>
8700:                   | nStrLitType :
8702:                      [ equal_node( oTypeSTop, PCharType )
8711:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8712:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8723:                         | * :
8728:                      ]
8728:                   | * :
8735:                ]
8735:             | nUniversalPointerType :
8737:                [ nt
8740:                   | nPointerType :  >>
8742:                   | * :
8747:                ]
8747:             | nShortStringType :
8749:                [ nt
8752:                   | nStrLitType :  >>
8754:                   | nCharType :
                           % Store char as a temp ShortString.
8756:                      oTypeSPush( CharType )
8762:                      int tempOffset = @MoveIntoTempShortString
8768:                      oTypeSPop
8769:                      >>
8770:                   | * :
8777:                ]
8777:             | * :
8792:          ]
8792:          #eTypeMismatch
8794:       | * :
8799:    ];
      
      
      % The expr stack contains two values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that both types are flexible
      % (unlike CoerceType, where only the top type is flexible).
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.  
      % Leave both values on the expr stack, and the single common type on the type stack. 
      %
8800: CoerceTypePair:
8802:    node_type right_nt = oTypeSNodeType
8807:    Node right = oTypeSTop
8812:    oTypeSPop
8813:    node_type left_nt = oTypeSNodeType
8818:    Node left = oTypeSTop
      
         % Start with assumption that we'll keep left type
8823:    [ equal_node_type( left_nt, right_nt )
8833:       | true :
               % TO DO: BUG: in some cases, need to validate base types match (e.g. enum types, ptr types)
8834:          >>
8835:       | * :
8840:    ]
8840:    [ left_nt
8843:       | nIntegerType :
8844:          [ right_nt
8847:             | nByteType :     .tCastBtoI  >>
8851:             | * :
8856:          ]
8856:       | nDoubleType :
8858:          [ right_nt
8861:             | nByteType :     .tCastBtoI  .tCastItoD  >>
8867:             | nIntegerType :  .tCastItoD  >>
8872:             | * :
8879:          ]
8879:       | nPointerType :
8881:          [ right_nt
8884:             | nUniversalPointerType :   >>
8886:             | * :
8891:          ]
8891:       | nShortStringType :
8893:          [ right_nt
8896:             | nStrLitType :  >>
8898:             | nCharType :
                     % Store char as a temp ShortString
8900:                oTypeSPush( CharType )
8906:                int tempOffset = @MoveIntoTempShortString
8912:                oTypeSPop
8913:                >>
8914:             | * :
8921:          ]
8921:       | * :
8932:    ]  
      
         % See if we can coerce left to right type.
         % If so remember we need to replace the type on the type stack.
8932:    [ right_nt
8935:       | nIntegerType :
8936:          [ left_nt
8939:             | nByteType :
8940:                .tSwap  .tCastBtoI  .tSwap
8946:                oTypeSPop  oTypeSPush( right )
8953:                >>
8954:             | * :
8959:          ]
8959:       | nDoubleType :
8961:          [ left_nt
8964:             | nByteType :
8965:                .tSwap  .tCastBtoI  .tCastItoD  .tSwap
8973:                oTypeSPop  oTypeSPush( right )
8980:                >>
8981:             | nIntegerType :
8983:                .tSwap  .tCastItoD  .tSwap
8989:                oTypeSPop  oTypeSPush( right )
8996:                >>
8997:             | * :
9004:          ]
9004:       | nPointerType :
9006:          [ left_nt
9009:             | nUniversalPointerType :
                     % TO DO: does fpc inherit right type here?
                     %  or stay with left.
9010:                oTypeSPop  oTypeSPush( right )
9017:                >>
9018:             | * :
9023:          ]
9023:       | nShortStringType :
9025:          [ left_nt
9028:             | nStrLitType :
9029:                oTypeSPop  oTypeSPush( right )
9036:                >>
9037:             | nCharType :
9039:                .tSwap
                     % Store char as a temp ShortString
9041:                oTypeSPush( CharType )
9047:                int tempOffset = @MoveIntoTempShortString
9053:                oTypeSPop
9054:                .tSwap
9056:                oTypeSPop  oTypeSPush( right )
9063:                >>
9064:             | * :
9071:          ]
9071:       | * :
9082:    ]
9082:    #eTypeMismatch
9085:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
9085: CastType:
9087:    node_type nt = oTypeSNodeType
9092:    oTypeSPop
9093:    [ equal_node_type( nt, oTypeSNodeType )
9102:       | false :
               % Can we cast the value to the desired type?
9103:          [ oTypeSNodeType
9105:             | nIntegerType, nEnumType :
9106:                [ nt
9109:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
9113:                   | nIntegerType, nEnumType :   >>
9116:                   | * :
9129:                ]
9129:             | nByteType, nCharType, nBooleanType :
9131:                [ nt
9134:                   | nByteType, nCharType, nBooleanType :   >>
9136:                   | nIntegerType, nEnumType :   .tCastItoB  >>
9141:                   | * :
9154:                ]
9154:             | nPointerType :
9156:                [ nt
9159:                   | nUniversalPointerType :  >>
9161:                   | nStrLitType :
9163:                      [ equal_node( oTypeSTop, PCharType )
9172:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
9173:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
9184:                         | * :
9189:                      ]
9189:                   | * :
9196:                ]
9196:             | nUniversalPointerType :
9198:                [ nt
9201:                   | nPointerType :  >>
9203:                   | * :
9208:                ]
9208:             | nShortStringType :
9210:                [ nt
9213:                   | nStrLitType :  >>
9215:                   | nCharType :
                           % Store char as a temp ShortString.
9217:                      oTypeSPush( CharType )
9223:                      int tempOffset = @MoveIntoTempShortString
9229:                      oTypeSPop
9230:                      >>
9231:                   | * :
9238:                ]
9238:             | * :
9257:          ]
9257:          #eTypeMismatch
9259:       | * :
9264:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
      % This is used when passing a variable to a VAR parameter, so essentially no coercion
      % can be allowed.  The called method will interact with the actual variable using the
      % formal parameter type, so they must agree.
      %
      % TO DO: BUG: I'm not confirming that enum types are the same type!
      %     Only that they are both enums!
      %     Probably same flaw with record & array types.
      %     Not enough to compare only the node type.
      %
9265: MatchTypes:
9267:    node_type nt = oTypeSNodeType
9272:    oTypeSPop
9273:    [ equal_node_type( nt, oTypeSNodeType )
9282:       | false :
               % Some very minor implicit conversion is allowed even here,
               % but must not affect the value size.
9283:          [ oTypeSNodeType
9285:             | nPointerType :
9286:                [ nt
9289:                   | nUniversalPointerType :  >>
9291:                   | * :
9296:                ]
9296:             | nUniversalPointerType :
9298:                [ nt
9301:                   | nPointerType :  >>
9303:                   | * :
9308:                ]
9308:             | * :
9315:          ]
9315:          #eTypeMismatch
9317:       | * :
9322:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9323: RequireIntPop:
9325:    [ oTypeSNodeType
9327:       | nIntegerType :
9328:       | * :          #eNotInteger
9335:    ]
9335:    oTypeSPop;
      
9337: RequireInt:
9339:    [ oTypeSNodeType
9341:       | nIntegerType :
9342:       | * :          #eNotInteger
9349:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9350: PromoteToIntPop:
9352:    [ oTypeSNodeType
9354:       | nIntegerType :
9355:       | nByteType :        .tCastBtoI
9359:       | * :                #eNotInteger
9368:    ]
9368:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9370: PromoteToInt:
9372:    [ oTypeSNodeType
9374:       | nIntegerType :
9375:       | nByteType :        .tCastBtoI
9379:                            oTypeSPop
9380:                            oTypeSPush( IntegerType )
9386:       | * :                #eNotInteger
9395:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9396: PromoteToIntOptional:
9398:    [ oTypeSNodeType
9400:       | nByteType :        .tCastBtoI
9403:                            oTypeSPop
9404:                            oTypeSPush( IntegerType )
9410:       | * :
9415:    ];
      
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
9416: PromoteToDoublePop:
9418:    [ oTypeSNodeType
9420:       | nDoubleType :
9421:       | nIntegerType :     .tCastItoD
9425:                            oTypeSPop
9426:                            oTypeSPush( DoubleType )
9432:       | nByteType :        .tCastBtoI
9436:                            .tCastItoD
9438:                            oTypeSPop
9439:                            oTypeSPush( DoubleType )
9445:       | * :                #eNotDouble
9456:    ]
9456:    oTypeSPop;
      
      
9458: RequireBoolPop:
9460:    [ oTypeSNodeType
9462:       | nBooleanType :
9463:       | * :          #eNotBoolean
9470:    ]
9470:    oTypeSPop;
      
9472: RequireBool:
9474:    [ oTypeSNodeType
9476:       | nBooleanType :
9477:       | * :          #eNotBoolean
9484:    ];
      
      
9485: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
9485: Statement:
9487:    [
9487:       | pWriteln :     @WritelnStmt
9491:       | pWrite :       @WriteStmt
9495:       | pReadln :      @ReadlnStmt
9499:       | pRead :        @ReadStmt
9503:       | pIf :          @IfStmt
9507:       | pWhile :       @WhileStmt
9511:       | pFor :         @ForStmt
9515:       | pRepeat :      @RepeatStmt
9519:       | pBreak :       @BreakStmt
9523:       | pContinue :    @ContinueStmt
9527:       | pBegin :       @BeginStmt
9531:       | pIdent :       @LabelOrAssignOrCallStmt
9535:       | pCase :        @CaseStmt
9539:       | pGoto :        @GotoStmt
9543:       | pIntLit :      % should be an integer label
9545:                        oChangeIntLitToLabelIdent
9546:                        @LabelOrAssignOrCallStmt
9548:       | * :            % null statement : don't accept any tokens
9581:    ];
      
      
9582: LabelOrAssignOrCallStmt:
9584:    Node decl = oScopeFindRequire
9589:    @ResolveUnitRef( decl )
9596:    [ oNodeType( decl )
9603:       | nLabel :                          @LabelDefinition( decl )
9611:                                           @Statement
9613:       | nProc :                           @Call( decl )
9622:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9624:                                           @AssignStmt( decl )
9631:       | nFunc :                           @AssignResultStmt( decl )
9640:       | * :                               #eBadStatement
9659:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9660: LabelDefinition( Node decl ):
9662:    [ oNodeGetBoolean( decl, qDefined )
9672:       | true :  #eAlreadyDefined
9675:       | * :
9680:    ]
9680:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9695:    oNodeSetBoolean( decl, qDefined, true )
9707:    ':'
9710:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9710: AssignStmt( Node decl ):
9712:    @LValueFromDecl( decl, true )
9722:    ':=' 
9724:    @Expr
9726:    @CoerceType
9728:    @Assign
9731:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9731: Assign:
9733:    [ oTypeSNodeType
9735:       | nIntegerType, nEnumType :  .tAssignI
9738:       | nBooleanType, nByteType, nCharType :  .tAssignB
9742:       | nDoubleType :  .tAssignD
9746:       | nFileType :   #eNotImplemented
9750:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9754:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9756:           int size = oNodeGetInt( oTypeSTop, qSize )
9768:           .tCopy  oEmitInt( size )    % multi-word copy
9776:    ]
9804:    oTypeSPop
9806:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9806: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9808:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9824:       | false :   #eNotCurrentFunction
9827:       | * :
9832:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9832:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9847:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9860:    ':='
9862:    @Expr
9864:    @CoerceType
9866:    [ oTypeSNodeType
9868:       | nIntegerType, nEnumType : .tAssignI
9871:       | nBooleanType, nByteType, nCharType :  .tAssignB
9875:       | nDoubleType :  .tAssignD
9879:       | nFileType :   #eNotImplemented
9883:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9887:       | nArrayType, nRecordType, nShortStringType :
9889:           int size = oNodeGetInt( oTypeSTop, qSize )
9901:           .tCopy  oEmitInt( size )    % multi-word copy
9909:    ]
9937:    oTypeSPop
9939:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9939: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9941:    pIdent
9943:    Node decl = oScopeFindRequire
9948:    @ResolveUnitRef( decl )
9955:    @LValueFromDecl( decl, writeable )
9966:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9966: LValueFromDecl( Node decl, boolean writeable ):
9968:    [ oNodeType( decl )
9975:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9976:          @LValueVar( decl, writeable )
      
9986:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9988:          oTypeSPush( oNodeGet( decl, qType ) )
10001:          '('
10003:          @LValueExpr( writeable )
10010:          ')'
10012:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
10014:          [ oTypeSNodeType
10016:             | nPointerType :
10017:                [
10017:                   | '[' :
                           % dereference the pointer var first
10019:                      .tFetchP
10021:                      @PointerArraySubscript
10023:                   | * :
10028:                ]
10028:             | * :
10033:          ]
               % additional subscripts, if any
10033:          @LValueIndexes
       
10035:       | * :  #eNotVar
10050:    ]
10051:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
10051: LValueCastType:
10053:    node_type nt = oTypeSNodeType
10058:    oTypeSPop
10059:    [ equal_node_type( nt, oTypeSNodeType )
10068:       | false :
               % Can we cast the value to the desired type?
10069:          [ oTypeSNodeType
10071:             | nIntegerType, nEnumType :
10072:                [ nt
10075:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
10079:                   | nIntegerType, nEnumType :   >>
10082:                   | * :
10095:                ]
10095:             | nByteType, nCharType, nBooleanType :
10097:                [ nt
10100:                   | nByteType, nCharType, nBooleanType :   >>
10102:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
10107:                   | * :
10120:                ]
10120:             | nPointerType :
10122:                [ nt
10125:                   | nUniversalPointerType :  >>
10127:                   | * :
10132:                ]
10132:             | nUniversalPointerType :
10134:                [ nt
10137:                   | nPointerType :  >>
10139:                   | * :
10144:                ]
10144:             | nShortStringType :
10146:                [ nt
10149:                   | nStrLitType :  >>
10151:                   | * :
10156:                ]
10156:             | * :
10175:          ]
10175:          #eTypeMismatch
10177:       | * :
10182:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
10183: LValueVar( Node decl, boolean writeable ):
10185:    [ oNodeType( decl )
10192:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
10202:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
10213:       | nParam :
10215:          [ oNodeGetBoolean( decl, qInOut )
10225:             | true :   % VAR param points to variable.  No dereference.
10226:                        .tPushParamP @EmitValue( decl )
10235:             | * :      .tPushAddrParam @EmitValue( decl )
10249:          ]
10249:       | nTypedConst :
10251:          [ writeable
10254:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10264:             | * :      #eNotVar
10271:          ]
10271:       | * :            #eNotVar
10284:    ]
      
10284:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10297:    [ oTypeSNodeType
10299:       | nPointerType :
10300:          [
10300:             | '[' :
                     % dereference the pointer var first
10302:                .tFetchP
10304:                @PointerArraySubscript
10306:             | * :
10311:          ]
10311:       | * :
10316:    ]
         % additional subscripts, if any
10316:    @LValueIndexes
10319:    ;
      
      
10319: IncVar( Node decl ):
10321:    @LValueVar( decl, true )
10331:    @RequireIntPop
10333:    @VarExpr( decl )
10340:    oTypeSPop
10341:    .tIncI
10343:    .tAssignI;
      
10346: DecVar( Node decl ):
10348:    @LValueVar( decl, true )
10358:    @RequireIntPop
10360:    @VarExpr( decl )
10367:    oTypeSPop
10368:    .tDecI
10370:    .tAssignI;
      
      
10373: IfStmt:
10375:    Label falseLabel = labelNull
      
10381:    @BooleanExprControlFlow( falseLabel )
10388:    pThen
10390:    @Statement
10392:    [
10392:       | pElse :
10394:          Label doneLabel = oLabelNew
      
10399:          .tJump  oEmitLabel( doneLabel )
10407:          .tLabel oEmitLabel( falseLabel )
10415:          @Statement
10417:          .tLabel oEmitLabel( doneLabel )
      
10425:       | * :
10430:          .tLabel oEmitLabel( falseLabel )
10438:    ];
      
      
10439: ForStmt:
10441:    pIdent
      
10443:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10448:    @LValueVar( decl, true )
10458:    @RequireIntPop
      
10460:    ':='
      
10462:    @Expr
10464:    @RequireIntPop
10466:    .tAssignI
      
10468:    Label breakLabel = oLabelNew
      
10473:    Label checkLabel = oLabelNew
10478:    .tJump  oEmitLabel( checkLabel )
      
10486:    Label continueLabel = oLabelNew
10491:    .tLabel  oEmitLabel( continueLabel )
10499:    [
10499:       | pTo :
10501:          @IncVar( decl )
10508:          .tLabel  oEmitLabel( checkLabel )
10516:          @VarExpr( decl )  oTypeSPop
10524:          @Expr
10526:          @RequireIntPop
10528:          .tGreaterI
10530:          .tJumpTrue  oEmitLabel( breakLabel )
10538:       | pDownto :
10540:          @DecVar( decl )
10547:          .tLabel  oEmitLabel( checkLabel )
10555:          @VarExpr( decl )  oTypeSPop
10563:          @Expr
10565:          @RequireIntPop
10567:          .tLessI
10569:          .tJumpTrue  oEmitLabel( breakLabel )
10577:    ]
10585:    oLoopPush( continueLabel, breakLabel )
10594:    pDo
10596:    @Statement
10598:    .tJump  oEmitLabel( continueLabel )
10606:    .tLabel  oEmitLabel( breakLabel )
10614:    oLoopPop;
      
      
10616: RepeatStmt:
10618:    Label continueLabel = oLabelNew
10623:    .tLabel  oEmitLabel( continueLabel )
      
10631:    Label breakLabel = oLabelNew
      
10636:    oLoopPush( continueLabel, breakLabel )
10645:    @Statement
10647:    {[
10647:       | ';' :
10649:          @Statement
10651:       | pUntil :
10653:          Label falseLabel
10653:          @BooleanExprControlFlow( falseLabel )
10660:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10674:          >
10676:    ]}
10686:    .tLabel  oEmitLabel( breakLabel )
10694:    oLoopPop;
      
      
10696: WhileStmt:
10698:    Label continueLabel = oLabelNew
10703:    .tLabel  oEmitLabel( continueLabel )
      
10711:    Label breakLabel
10711:    @BooleanExprControlFlow( breakLabel )
      
10718:    oLoopPush( continueLabel, breakLabel )
10727:    pDo
10729:    @Statement
10731:    .tJump  oEmitLabel( continueLabel )
10739:    .tLabel  oEmitLabel( breakLabel )
10747:    oLoopPop;
      
      
10749: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10751:    [ equal_label( oLoopContinueLabel, labelNull )
10760:       | true :
10761:          #eNotInALoop
10763:       | false :
10765:          .tJump  oEmitLabel( oLoopContinueLabel )
10772:    ];
      
      
10781: BreakStmt:
10783:    [ equal_label( oLoopBreakLabel, labelNull )
10792:       | true :
10793:          #eNotInALoop
10795:       | false :
10797:          .tJump  oEmitLabel( oLoopBreakLabel )
10804:    ];
      
      
10813: CaseStmt:
10815:    Code tableCode = oCodeNew
10820:    Label tableLabel = oLabelNew
10825:    Label doneLabel = oLabelNew
10830:    Label otherwiseLabel = doneLabel
10836:    boolean isString = false
      
10842:    @Expr
         % Leave the expr type on the type stack throughout case statement
10844:    [ oTypeSNodeType
10846:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10855:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10865:       | nShortStringType, nStrLitType :        isString = true
10873:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10881:       | * :     #eNotAllowed
10900:    ]
10900:    pOf
      
10902:    {
10902:       [
10902:          | pOtherwise, pElse :
10904:             otherwiseLabel = oLabelNew
10909:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10917:             {[
10917:                | pEnd :  >
10921:                | * :
10926:                   @Statement
10928:                   [
10928:                      | ';' :
10930:                      | * :   pEnd  >
10939:                   ]
10939:             ]}
10941:             >
      
10943:          | pEnd :
                  % Reached end with no otherwise clause
10945:             >
      
10947:          | * :
10956:             Label caseLabel = oLabelNew
10961:             oCodePush( tableCode )
10967:             {
10967:                @ConstExpr
10969:                @ConstCoerceType
10971:                int val
10971:                [ isString
10974:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10984:                   | false :   val = oValueTop
10991:                ]
10999:                oValuePop
11000:                [
11000:                   | '..' :  @ConstExpr
11004:                             @ConstCoerceType
11006:                             int highval
11006:                             [ isString
11009:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
11019:                                | false :  highval = oValueTop
11026:                             ]
11034:                             oValuePop
11035:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
11055:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
11074:                ]
11074:                [
11074:                   | ',' :
11076:                   | * :  >
11083:                ]
11083:             }
11085:             oCodePop
11086:             ':'
11088:             .tLabel  oEmitLabel( caseLabel )
11096:             @Statement
11098:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
11106:             [
11106:                | ';' :
11108:                | * :
11113:             ]
                  
11113:       ]
         
11113:    }
      
11115:    .tLabel  oEmitLabel( tableLabel )
11123:    oEmitCode( tableCode )
11129:    .tCaseEnd  oEmitLabel( otherwiseLabel )
11137:    .tLabel  oEmitLabel( doneLabel )
11145:    oTypeSPop
11147:    ;
      
      
11147: GotoStmt:
11149:    [
11149:       | pIdent :
11151:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
11153:          oChangeIntLitToLabelIdent
11154:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
11162:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
11171:    oNodeSetBoolean( decl, qUsed, true )
11183:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
11199:    ;
      
      
11199: BeginStmt:
11201:    @Statement
11203:    {[
11203:       | ';' :   @Statement
11207:       | pEnd :  >
11211:    ]};
      
      
11222: WritelnStmt:
11224:    @WriteStmt
11226:    .tWriteCR;
      
      
11229: WriteStmt:
11231:    [
11231:       | '(' :
11233:          {
11233:             @Expr
11235:             [ oTypeSNodeType
11237:                | nIntegerType :             .tWriteI
11240:                | nBooleanType :             .tWriteBool
11244:                | nByteType :                .tCastBtoI  .tWriteI
11250:                | nCharType :                .tWriteChar
11254:                | nDoubleType :              .tWriteD
11258:                | nShortStringType, nStrLitType :   .tWriteShortStr
11262:                | nFileType :                #eNotImplemented
11266:                | nEnumType :
                        % write name via table lookup
11268:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
11282:                   .tWriteEnum
11284:                | nPointerType :
11286:                   [ equal_node( oTypeSTop, PCharType )
11295:                      | true :               .tWritePChar
11298:                      | * :                  .tWriteP
11305:                   ]
11305:                | nUniversalPointerType :    .tWriteP
11309:                | * :                        #eNotAllowed
11336:             ]
11336:             oTypeSPop
11337:             [
11337:                | ')' : >
11341:                | ',' :
11343:             ]
11351:          }
11353:       | * :
11358:    ];
      
      
11359: ReadlnStmt:
11361:    @ReadStmt
11363:    .tReadCR;
      
      
11366: ReadStmt:
11368:    [
11368:       | '(' :
11370:          {
11370:             @LValueExpr( true )
11377:             [ oTypeSNodeType
11379:                | nIntegerType :      .tReadI
11382:                | nCharType :         .tReadChar
11386:                | nShortStringType :  
11388:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
11407:                    .tReadShortStr  oEmitInt( capacity )
11415:                | * :                 #eNotAllowed
11426:             ]
11426:             oTypeSPop
11427:             [
11427:                | ')' : >
11431:                | ',' :
11433:             ]
11441:          }
11443:       | * :
11448:    ];
11449: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
11449: MoveIntoTempShortString >> int:
11451:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
11461:    [ oTypeSNodeType
11463:       | nShortStringType, nStrLitType :
11464:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
11472:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
11474:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
11489:       | nCharType :
               % temp[0] = 1
11491:          .tPushAddrLocal  oEmitInt( tempOffset )
11499:          .tPushConstI  oEmitInt( 1 )
11507:          .tAssignB
               % temp[1] = value
11509:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11524:          .tSwap
11526:          .tAssignB
11528:       | * :   #eTypeMismatch
11539:    ]
11539:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11540:    .tPushAddrLocal  oEmitInt( tempOffset )
11548:    oTypeSPush( ShortStringType )
11554:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11558: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11560:    .tAllocActuals  oEmitInt( 16 )
11568:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11580:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11592:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11601:    .tFreeActuals  oEmitInt( 16 )
11609:    oTypeSPop
11610:    oTypeSPop
11612:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11612: ShortStringAppendChar:
         % Note at the moment I don't align params
11614:    .tAllocActuals  oEmitInt( 12 )
11622:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11634:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11646:    .tCall  @EmitValue( System_ShortStringAppendChar )
11655:    .tFreeActuals  oEmitInt( 12 )
11663:    oTypeSPop
11664:    oTypeSPop
11666:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11666: ShortStringCmp:
11668:    .tAllocActualsCdecl  oEmitInt( 24 )
11676:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11688:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11700:    int tempOffset = oScopeAllocType( IntegerType )
11710:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11728:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11737:    .tPushLocalI  oEmitInt( tempOffset )
11745:    .tFreeActuals  oEmitInt( 24 )
11753:    oTypeSPop
11754:    oTypeSPush( IntegerType )
11761:    ;
11761: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11761: Call( Node method ):
11763:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11775:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11788:    Node resultType
11788:    int tempOffset
      
11788:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11805:    [ isFunc
11808:       | true :
11809:          resultType = oNodeGet( method, qType )
11822:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11832:       | * :
11837:    ]
         
      
11837:    Node paramScope = oNodeGet( method, qParams )
11850:    int actualsSize = oNodeGetInt( paramScope, qSize )
11863:    [ cdecl
11866:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11875:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11885:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11893:    [ greater( @DeclLevel( method ), 0 )
11908:       | true :
11909:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11917:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11936:          .tAssignP
11938:       | * :
11943:    ]
      
      
11943:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11956:    Node param = oNodeIterValue( paramIter )
11966:    [
11966:       | '(' :
            
11968:          {
11968:             [ oNodeNull( param )
11975:                | true : >
11978:                | * :
11983:             ]
      
11983:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11996:             .tPushAddrActual oEmitInt( offset )
12004:             oTypeSPush( oNodeGet( param, qType ) )
      
12017:             [ oNodeGetBoolean( param, qInOut )
12027:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
12028:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
12035:                           @MatchTypes
      
12037:                           .tAssignP
      
12039:                | false :  @Expr
12043:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
12045:                           [ oTypeSNodeType
12047:                              | nIntegerType, nEnumType : .tAssignI
12050:                              | nBooleanType, nByteType, nCharType :  .tAssignB
12054:                              | nDoubleType :  .tAssignD
12058:                              | nFileType :   #eNotImplemented
12062:                              | nPointerType, nUniversalPointerType :  .tAssignP
12066:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
12068:                                  int size = oNodeGetInt( oTypeSTop, qSize )
12080:                                  .tCopy  oEmitInt( size )    % multi-word copy
12088:                           ]
12116:             ]
12124:             oTypeSPop
      
12125:             oNodeIterNext( paramIter )
12131:             param = oNodeIterValue( paramIter )
12141:             [ oNodeNull( param )
12148:                | true :  >
12151:                | false :
12153:             ]
      
12161:             ','
12163:          }
      
12165:          ')'
      
12167:       | * :
12172:    ]
      
12172:    [ oNodeNull( param )
12179:       | false :    #eMissingParameter
12182:       | * :
12187:    ]
      
12187:    [ isFunc
12190:       | true :
               % Pass result temp as an additional VAR parameter.
12191:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
12206:          .tPushAddrLocal  oEmitInt( tempOffset )
12214:          .tAssignP
12216:       | * :
12221:    ]
      
12221:    [ cdecl
12224:       | true :
12225:          .tCallCdecl  @EmitValue( method )
12234:       | false :
12236:          .tCall   @EmitValue( method )
12245:    ]
      
12253:    [ isFunc
12256:       | true :
               % push return value from temp
12257:          oTypeSPush( resultType )
      
12263:          [ oTypeSNodeType
12265:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
12274:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
12284:             | nFileType :  #eNotImplemented
12288:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
12298:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
12300:                                .tPushAddrLocal  oEmitInt( tempOffset )
12308:          ]
12334:       | * :
12339:    ]
         
12339:    .tFreeActuals  oEmitInt( actualsSize )
12348:    ;
      
      
      
      % Called on first use of an extern method
      %
12348: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
12350:    int strAddr
12350:    String externalName = oNodeGetString( method, qExternalName )
12363:    [ equal_string( externalName, stringNull )
12373:       | true :
12374:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
12395:       | false :
12397:          strAddr = oStringAllocLit( externalName )
12407:    ]
12415:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
12431:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
12431: CallBuiltInFunc( Node method ):
      
         % Ord(x)
12433:    [ oNodeEqual( method, BuiltIn_Ord )
12443:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
12444:          '('
12446:          @Expr
12448:          [ oTypeSNodeType
12450:             | nIntegerType, nEnumType :
12451:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
12455:             | * :  #eTypeMismatch
12470:          ]
12470:          oTypeSPop
12471:          oTypeSPush( IntegerType )
12477:          ')'
12479:          >>
12480:       | * :
12485:    ]
      
         % Chr(x)
12485:    [ oNodeEqual( method, BuiltIn_Chr )
12495:       | true :
               % parameter is integer
               % result is char
12496:          '('
12498:          @Expr
12500:          [ oTypeSNodeType
12502:             | nIntegerType :    .tCastItoB
12505:             | nByteType :
12507:             | * :  #eTypeMismatch
12516:          ]
12516:          oTypeSPop
12517:          oTypeSPush( CharType )
12523:          ')'
12525:          >>
12526:       | * :
12531:    ]
      
         % Pred(x)
12531:    [ oNodeEqual( method, BuiltIn_Pred )
12541:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12542:          '('
12544:          @Expr
12546:          [ oTypeSNodeType
12548:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12549:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12558:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12561:                   | * :
12566:                ]
12566:             | * :  #eTypeMismatch
12573:          ]
12573:          .tDecI
12575:          ')'
12577:          >>
12578:       | * :
12583:    ]
      
         % Succ(x)
12583:    [ oNodeEqual( method, BuiltIn_Succ )
12593:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12594:          '('
12596:          @Expr
12598:          [ oTypeSNodeType
12600:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12601:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12610:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12613:                   | * :
12618:                ]
12618:             | * :  #eTypeMismatch
12625:          ]
12625:          .tIncI
12627:          ')'
12629:          >>
12630:       | * :
12635:    ]
      
         % Sizeof(x)
12635:    [ oNodeEqual( method, BuiltIn_Sizeof )
12645:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12646:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12648:          Code dummyCode = oCodeNew
12653:          oCodePush( dummyCode )
12659:          @ExprAllowTypeName
12661:          oCodePop
12662:          oCodeDiscard( dummyCode )
12668:          Node theType = oTypeSTop
12673:          oTypeSPop
12674:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12689:          oTypeSPush( IntegerType )
12695:          ')'
12697:          >>
      
12698:       | * :
12703:    ]
      
12703:    #eNotImplemented
12706:    ;
      
12706: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12706: newType( node_type nt, int size ) >> Node:
12708:   Node node = oNodeNew( nt )
12718:   oNodeSetInt( node, qSize, size )
12730:   oTypeAdd( node )
12736:   >> node
12740:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12740: TypeRef( out Node resultType ):
12742:    [
12742:       | pIdent :           % previously named type (including intrinsics)
12744:          Node decl = oScopeFindRequire
12749:          @ResolveUnitRef( decl )
12756:          [ oNodeType( decl )
12763:             | nTypeDecl :
12764:                resultType = oNodeGet( decl, qType )
12777:             | * :
12782:                #eNotType
12784:                resultType = IntegerType
12790:          ]
         
12790:       | pArray :
12792:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12794:          NodeVec dimensions = oNodeVecNew
      
12799:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12799:             Node subrange = oNodeNew( nSubrangeType )
      
12809:             @ConstExpr
12811:             oNodeSetInt( subrange, qLow, oValueTop )
12822:             oValuePop
12823:             '..'
12825:             @ConstExpr
12827:             oNodeSetInt( subrange, qHigh, oValueTop )
12838:             oValuePop
      
12839:             @ConstMatchTypes
12841:             oNodeSet( subrange, qBaseType, oTypeSTop )
12852:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12870:             oTypeSPop
12871:             oTypeAdd( subrange )
      
12877:             Node a = oNodeNew( nArrayType )
12887:             oNodeSet( a, qIndexType, subrange )
      
12899:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12908:             [
12908:                | ']' : >
12912:                | ',' :
12914:             ]
12922:          }
      
12924:          pOf
12926:          Node baseType
12926:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12933:          int dim = oNodeVecSize( dimensions )
      
12943:          {
12943:              dec(dim)
      
12949:              Node a = oNodeVecElement( dimensions, dim )
      
12962:              oNodeSet( a, qBaseType, baseType )
12974:              Node subrange = oNodeGet( a, qIndexType )
12987:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
13014:              inc( width )
13020:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
13046:              oTypeAdd( a )
13052:              baseType = a
      
13058:              [ equal_zero(dim)
13065:                  | true:  >
13068:                  | *:
13073:              ]
13073:          }
      
13075:          resultType = oNodeVecElement( dimensions, 0 )
13088:          oNodeVecDelete( dimensions )
      
13094:       | '^' :
13096:          Node theType
13096:          @TypeRef( theType )
13103:          resultType = @PointerTypeTo( theType )
      
13114:       | pRecord :
13116:          resultType = oNodeNew( nRecordType )
13126:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
13135:          @VarDecl( nRecordField )
      
13142:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
13154:          [ equal_zero( size )
13161:             | true : #eRecordEmpty
13164:             | * :
13169:          ]
      
13169:          pEnd
      
13171:          oNodeSet( resultType, qScope, oScopeCurrent )
13182:          oNodeSetInt( resultType, qSize, size )
13194:          oScopeEnd
13195:          oTypeAdd( resultType )
      
      
13201:       | '(' :
               % An enum type declaration.
13203:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
13210:       | pSet :
13212:          pOf
13214:          Node theType
13214:          @TypeRef( theType )
13221:          #eNotImplemented
13223:       | * :       % this works for cases except where expr starts with an id
13238:          @ConstExpr '..' @ConstExpr
13244:          @ConstMatchTypes
13246:          #eNotImplemented
13248:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
13249: EnumTypeRef( out Node resultType ):
      
13251:    resultType = oNodeNew( nEnumType )
13261:    int value = 0
13267:    int numValues = 0
13273:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
13279:    Node outerScope = oScopeCurrent
13284:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
13293:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
13293:       pIdent
13295:       Node decl = @newIdent( nEnumValue, LAST_ID )
13308:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
13321:       oNodeSet( decl, qType, resultType )
13333:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
13345:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
13358:       oNodeSetInt( decl, qNameOffset, nameOffset )
13370:       oNodeSetInt( decl2, qNameOffset, nameOffset )
13382:       [
13382:          | '=', ':=' :
13384:             oTypeSPush( IntegerType )
13390:             @ConstExpr
13392:             @ConstCoerceType
13394:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
13395:             [ equal_zero( numValues )
13402:                | false :
13403:                   [ greater( oValueTop, value )
13412:                      | false :   #eEnumValueNotAscending
13415:                      | * :
13420:                   ]
13420:                | * :
13425:             ]
13425:             [ equal( value, oValueTop )
13434:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
13435:                   oNodeSetBoolean( resultType, qHasGap, true )
13447:                | * :
13452:             ]
13452:             value = oValueTop
13457:             oValuePop
13458:          | * :
13465:       ]
13465:       oNodeSetInt( decl, qValue, value )
13477:       oNodeSetInt( decl2, qValue, value )
13489:       oScopeDeclare( decl )
      
13495:       oScopeEnter( outerScope )
13501:       oScopeDeclare( decl2 )
13507:       oScopeEnd
      
13508:       inc( value )
13514:       inc( numValues )
13520:       [
13520:          | ',' :
13522:          | * :    >
13529:       ]
13529:    }
13531:    ')'
      
13533:    oNodeSet( resultType, qScope, oScopeCurrent )
13544:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13556:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13557:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13568:    oScopeEnter( globalScope )
13574:    int size = multiply( add( numValues, 1 ), 16 )
13594:    int addr = oScopeAlloc( size, 8 )
13607:    oScopeEnd
13608:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13620:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13640:    {
13640:       Node enumValue = oNodeIterValue( it )
13650:       [ oNodeNull( enumValue )
13657:          | true :  >
13660:          | * :
13665:       ]
13665:       .tPushAddrGlobal  oEmitInt( addr )
13673:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13688:       .tAssignI
13690:       addr = add( addr, 8 )
13703:       .tPushAddrGlobal  oEmitInt( addr )
13711:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13726:       .tAssignP
13728:       addr = add( addr, 8 )
13741:       oNodeIterNext( it )
13747:    }
         % final table entry
13749:    .tPushAddrGlobal  oEmitInt( addr )
13757:    .tPushConstI  oEmitInt( 0 )
13765:    .tAssignI
13767:    addr = add( addr, 8 )
13780:    .tPushAddrGlobal  oEmitInt( addr )
13788:    .tPushConstI  oEmitInt( 0 )
13796:    .tAssignP
13798:    addr = add( addr, 8 )
13811:    oCodePop
      
13812:    oTypeAdd( resultType )
13819:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13819: PointerTypeTo( Node theType ) >> Node:
13821:    Node ptrType = oNodeGet( theType, qPointerType )
13834:    [ oNodeNull( ptrType )
13841:       | true :
13842:          ptrType = oNodeNew( nPointerType )
13852:          oNodeSet( ptrType, qBaseType, theType )
13864:          oNodeSetInt( ptrType, qSize, 8 )
13876:          oTypeAdd( ptrType )
13882:          oNodeSet( theType, qPointerType, ptrType )
13894:       | * :
13899:    ]
13899:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13903: OrdinalLow( Node theType ) >> int:
13905:    [ oNodeType( theType )
13912:       | nIntegerType :  >> oMININT
13915:       | nBooleanType :  >> 0
13920:       | nCharType :     >> 0
13925:       | nEnumType :
13927:          Node enumScope = oNodeGet( theType, qScope )
13940:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13957:          >> oNodeGetInt( first, qValue )
13967:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13979:       | * :             #eNotOrdinalType
13994:                         >> 0
13997:    ];
      
      
      % Return the high value of an ordinal type
      %
13998: OrdinalHigh( Node theType ) >> int:
14000:    [ oNodeType( theType )
14007:       | nIntegerType :  >> oMAXINT
14010:       | nBooleanType :  >> 1
14015:       | nCharType :     >> 255
14020:       | nEnumType :
14022:          Node enumScope = oNodeGet( theType, qScope )
14035:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
14052:          >> oNodeGetInt( last, qValue )
14062:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
14074:       | * :             #eNotOrdinalType
14089:                         >> 0
14092:    ];
      
      
      
14093: Program:
14095:    Node t
      
14095:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
14100:    oScopeBegin( 0, allocGlobal )
14109:    Node rootScope = oScopeCurrent
      
14114:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
14116:    .tEnter  oEmitInt( 0 )
14124:    Label mainLabel = oLabelNew
      
14129:    .tAllocActuals  oEmitInt( 0 )
14137:    .tCall  oEmitLabel( mainLabel )
14145:    .tFreeActuals  oEmitInt( 0 )
14153:    .tReturn
      
14155:    pProgram
14157:    pIdent
      
14159:    Node program = oNodeNew( nProgram )
14169:    oNodeSetInt( program, qIdent, LAST_ID )
14180:    oNodeSet( workspace, qProgram, program )
      
      
14192:    [
14192:       | '(' :
14194:          pIdent      % input, output files
      
14196:          t = @newIdent( nVar, LAST_ID )
14209:          oNodeSet( t, qType, FileType )
14221:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
14227:          ','
14229:          pIdent
      
14231:          t = @newIdent( nVar, LAST_ID )
14244:          oNodeSet( t, qType, FileType )
14256:          oScopeDeclareAlloc( t )
      
14262:          ')'
14264:       | * :
14269:    ]
14269:    ';'
      
14271:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
14278:    [
14278:       | pUses :  @UsesClause( program )
14287:       | * :
14292:    ]
14292:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
14299:    oScopeBegin( 0, allocGlobal )
14308:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
14313:    oScopeBegin( 0, allocDown )
14322:    oNodeSet( oScopeCurrent, qExtends, globalScope )
14333:    initScope = oScopeCurrent
14338:    oNodeSet( program, qMainRoutineScope, initScope )
14350:    oScopeEnd
      
14351:    @BlockDecls( nGlobalVar )
      
      
14358:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
14364:    boolean isMain = true
14370:    @BlockStmt( mainLabel, globalScope, isMain )
      
14383:    oScopeEnd   % main routine scope
      
14384:    '.'
14386:    @CheckForUndefinedLabels
14388:    oScopeEnd   % global scope
14389:    @EndUsedUnits( program )   % used units scopes
14397:    ;
      
      
      
      
14397: Block( node_type varNodeType, Label labelForBody ):
14399:    @BlockDecls( varNodeType )
14406:    @BlockStmt( labelForBody, oScopeCurrent, false )
14418:    @CheckForUndefinedLabels
14421:    ;
      
      
14421: BlockDecls( node_type varNodeType ):
14423:    {[
14423:       | pConst :     @ConstDecl
14427:       | pType :      @TypeDecl
14431:       | pVar :       @VarDecl( varNodeType )
14440:       | pLabel :     @LabelDecl
14444:       | pProcedure : @ProcDecl
14448:       | pFunction :  @FuncDecl
14452:       | * :          >
14469:    ]}
14471:    @CheckForUndefinedMethods
14474:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
14474: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
14477:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
14477: CheckForUndefinedLabels:
14479:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
14491:    {
14491:       Node decl = oNodeIterValue( it )
14501:       [ oNodeNull( decl )
14508:          | false :
14509:          | * :  >
14516:       ]
14516:       [ oNodeType( decl )
14523:          | nLabel :
14524:             [ oNodeGetBoolean( decl, qDefined )
14534:                | false :
14535:                   [ oNodeGetBoolean( decl, qUsed )
14545:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14548:                      | * :
14553:                   ]
14553:                | * :
14558:             ]
14558:          | * :
14563:       ]
14563:       oNodeIterNext( it )
14569:    }
14572:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14572: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14574:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14582:    int patchLS
14582:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14591:    [ isMain
14594:       | true :  @InitializeUnits
14597:       | * :
14602:    ]
      
         % insert any code for initialization of this scope's variables
14602:    Code initCode = oNodeGetCode( varScope, qInitCode )
14615:    oEmitCode( initCode )
14621:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14633:    @Statement
      
14635:    [ isMain
14638:       | true :  @FinalizeUnits
14641:       | * :
14646:    ]
      
14646:    .tReturn
      
14648:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14660:    oPatch( patchLS, localSpace )
14670:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14670: GetOrCreateInitCode( Node scope ) >> Code:
14672:    Code initCode = oNodeGetCode( scope, qInitCode )
14685:    [ equal_code( initCode, codeNull )
14695:       | true :
14696:          initCode = oCodeNew
14701:          oNodeSetCode( scope, qInitCode, initCode )
14713:       | * :
14718:    ]
14718:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14722: ScopeLevel >> int:
14724:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14734: DeclLevel( Node decl ) >> int:
14736:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14754: DeclUpLevels( Node decl ) >> int:
14756:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14772: newIdent( node_type nt, int id ) >> Node:
14774:   Node t = oNodeNew( nt )
14784:   oNodeSetInt( t, qIdent, id )
14796:   >> t
14800:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14800: EmitValue( Node decl ):
14802:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14816: DeclareBuiltInFunc( int id ) >> Node:
14818:    Node decl = @newIdent( nBuiltInFunc, id )
14832:    oScopeDeclare( decl )
14838:    >> decl;
      
      
14842: installBuiltIns:
      
         % initialize some other globals too
14844:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14850:    mysystemId = oId_mysystem
      
         % install built-in types
14855:    FileType = @newType( nFileType, 4 )
14869:    IntegerType = @newType( nIntegerType, 4 )
14883:    BooleanType = @newType( nBooleanType, 1 )
14897:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14911:    CharType = @newType( nCharType, 1 )
14925:    PCharType = @PointerTypeTo( CharType )
14936:    ByteType = @newType( nByteType, 1 )
14950:    SingleType = @newType( nSingleType, 4 )
14964:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14978:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14992:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
15004:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
15018:    ShortStringType = @newType( nShortStringType, 256 )
15032:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
15044:    Node t
      
15044:    t = @newIdent( nTypeDecl, oId_File )
15057:    oNodeSet( t, qType, FileType )
15069:    oScopeDeclare( t )
      
15075:    t = @newIdent( nTypeDecl, oId_Integer )
15088:    oNodeSet( t, qType, IntegerType )
15100:    oScopeDeclare( t )
      
15106:    t = @newIdent( nTypeDecl, oId_Boolean )
15119:    oNodeSet( t, qType, BooleanType )
15131:    oScopeDeclare( t )
      
15137:    t = @newIdent( nTypeDecl, oId_Char )
15150:    oNodeSet( t, qType, CharType )
15162:    oScopeDeclare( t )
      
15168:    t = @newIdent( nTypeDecl, oId_Byte )
15181:    oNodeSet( t, qType, ByteType )
15193:    oScopeDeclare( t )
      
15199:    t = @newIdent( nTypeDecl, oId_Single )
15212:    oNodeSet( t, qType, SingleType )
15224:    oScopeDeclare( t )
      
15230:    t = @newIdent( nTypeDecl, oId_Double )
15243:    oNodeSet( t, qType, DoubleType )
15255:    oScopeDeclare( t )
      
15261:    t = @newIdent( nTypeDecl, oId_Pointer )
15274:    oNodeSet( t, qType, UniversalPointerType )
15286:    oScopeDeclare( t )
      
15292:    t = @newIdent( nTypeDecl, oId_ShortString )
15305:    oNodeSet( t, qType, ShortStringType )
15317:    oScopeDeclare( t )
      
         % Built-in constants
      
15323:    t = @newIdent( nConst, oId_True )
15336:    oNodeSet( t, qType, BooleanType )
15348:    oNodeSetInt( t, qValue, 1 )
15360:    oScopeDeclare( t )
      
15366:    t = @newIdent( nConst, oId_False )
15379:    oNodeSet( t, qType, BooleanType )
15391:    oNodeSetInt( t, qValue, 0 )
15403:    oScopeDeclare( t )
      
15409:    t = @newIdent( nConst, oId_Nil )
15422:    oNodeSet( t, qType, UniversalPointerType )
15434:    oNodeSetInt( t, qValue, 0 )
15446:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
15452:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
15462:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
15472:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
15482:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
15492:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
15503:    ;
      
15503: end
      
15503: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 14093
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 26
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 25
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3213
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3269
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 14421
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 89
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 79
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 107
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 9485
1083: oInputChoice 1089
1085: oCall 9485
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 78
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 89
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 79
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 107
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 9485
1177: oInputChoice 1183
1179: oCall 9485
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 78
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 73
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 76
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 75
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 73
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 76
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 75
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14734
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 12348
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14772
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 22
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 22
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 14722
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13819
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 23
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 14397
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14772
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 22
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 22
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 14722
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13819
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 12740
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13819
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 23
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 14397
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 25
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14772
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 35
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 12740
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13819
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2683
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3568
2556: oTypeSNodeType
2557: oChoice 2640
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14772
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2661
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 19
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14772
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 34
2605: oPushResult
2606: oValueTopDouble
2607: oPushResult
2608: oNodeSetDouble
2609: oPop 3
2611: oJumpForward 2661
2613: oGetAddrLocal 2
2615: oPushResult
2616: oSetResult 18
2618: oPushResult
2619: oGetLocal 1
2621: oPushResult
2622: oCall 14772
2624: oPop 2
2626: oAssign
2627: oGetLocal 2
2629: oPushResult
2630: oSetResult 33
2632: oPushResult
2633: oValueTopString
2634: oPushResult
2635: oNodeSetString
2636: oPop 3
2638: oJumpForward 2661
2640: Choice Lookup Table
          42   2613
          33   2586
          38   2559
          37   2559
          44   2559
          31   2559
          36   2559
          30   2559
          34   2559
2659: oError 18
2661: oValuePop
2662: oGetLocal 2
2664: oPushResult
2665: oSetResult 21
2667: oPushResult
2668: oTypeSTop
2669: oPushResult
2670: oNodeSet
2671: oPop 3
2673: oTypeSPop
2674: oGetLocal 2
2676: oPushResult
2677: oScopeDeclare
2678: oPop 1
2680: oInput 6
2682: oReturn
2683: oLocalSpace 3
2685: oGetAddrLocal 1
2687: oPushResult
2688: oSetResult 26
2690: oPushResult
2691: LAST_ID
2692: oPushResult
2693: oCall 14772
2695: oPop 2
2697: oAssign
2698: oGetAddrLocal 2
2700: oPushResult
2701: oCall 12740
2703: oPop 1
2705: oGetLocal 1
2707: oPushResult
2708: oSetResult 21
2710: oPushResult
2711: oGetLocal 2
2713: oPushResult
2714: oNodeSet
2715: oPop 3
2717: oGetLocal 2
2719: oPushResult
2720: oNodeType
2721: oPop 1
2723: oChoice 2827
2725: oInput 7
2727: oGetLocal 2
2729: oPushResult
2730: oTypeSPush
2731: oPop 1
2733: oCall 3568
2735: oCall 4460
2737: oGetLocal 1
2739: oPushResult
2740: oSetResult 22
2742: oPushResult
2743: oValueTop
2744: oPushResult
2745: oNodeSetInt
2746: oPop 3
2748: oValuePop
2749: oTypeSPop
2750: oGetLocal 1
2752: oPushResult
2753: oScopeDeclare
2754: oPop 1
2756: oInput 6
2758: oJumpForward 2851
2760: oError 17
2762: oJumpForward 2851
2764: oGetGlobal 2
2766: oPushResult
2767: oScopeEnter
2768: oPop 1
2770: oGetAddrLocal 3
2772: oPushResult
2773: oGetLocal 2
2775: oPushResult
2776: oScopeAllocType
2777: oPop 1
2779: oAssign
2780: oScopeEnd
2781: oGetGlobal 2
2783: oPushResult
2784: oCall 14670
2786: oPop 1
2788: oPushResult
2789: oCodePush
2790: oPop 1
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oGetLocal 3
2800: oPushResult
2801: oNodeSetInt
2802: oPop 3
2804: oInput 7
2806: oGetLocal 2
2808: oPushResult
2809: oGetLocal 3
2811: oPushResult
2812: oCall 2852
2814: oPop 2
2816: oCodePop
2817: oGetLocal 1
2819: oPushResult
2820: oScopeDeclare
2821: oPop 1
2823: oInput 6
2825: oJumpForward 2851
2827: Choice Lookup Table
          41   2764
          39   2764
          29   2760
          43   2760
          38   2725
          37   2725
          44   2725
          31   2725
          36   2725
          30   2725
          34   2725
2850: oEndChoice
2851: oReturn
2852: oLocalSpace 10
2854: oGetParam 2
2856: oPushResult
2857: oNodeType
2858: oPop 1
2860: oChoice 3186
2862: oGetAddrLocal 1
2864: oPushResult
2865: oGetParam 2
2867: oPushResult
2868: oSetResult 38
2870: oPushResult
2871: oNodeGet
2872: oPop 2
2874: oAssign
2875: oGetAddrLocal 2
2877: oPushResult
2878: oGetParam 2
2880: oPushResult
2881: oSetResult 39
2883: oPushResult
2884: oNodeGet
2885: oPop 2
2887: oAssign
2888: oGetAddrLocal 3
2890: oPushResult
2891: oGetLocal 2
2893: oPushResult
2894: oCall 13903
2896: oPop 1
2898: oAssign
2899: oGetAddrLocal 4
2901: oPushResult
2902: oGetLocal 2
2904: oPushResult
2905: oCall 13998
2907: oPop 1
2909: oAssign
2910: oGetAddrLocal 5
2912: oPushResult
2913: oGetLocal 1
2915: oPushResult
2916: oSetResult 17
2918: oPushResult
2919: oNodeGetInt
2920: oPop 2
2922: oAssign
2923: oInput 15
2925: oGetAddrLocal 6
2927: oPushResult
2928: oGetLocal 3
2930: oAssign
2931: oGetLocal 1
2933: oPushResult
2934: oGetParam 1
2936: oPushResult
2937: oCall 2852
2939: oPop 2
2941: oGetLocal 6
2943: oPushResult
2944: oGetLocal 4
2946: oPushResult
2947: equal
2948: oPop 2
2950: oChoice 2958
2952: oJumpForward 2987
2954: oJumpForward 2964
2956: oJumpForward 2964
2958: Choice Lookup Table
           0   2956
           1   2952
2963: oEndChoice
2964: oInput 14
2966: oGetAddrParam 1
2968: oPushResult
2969: oGetParam 1
2971: oPushResult
2972: oGetLocal 5
2974: oPushResult
2975: add
2976: oPop 2
2978: oAssign
2979: oGetAddrLocal 6
2981: oPushResult
2982: inc
2983: oPop 1
2985: oJumpBack 2931
2987: oInput 16
2989: oJumpForward 3212
2991: oInput 15
2993: oGetAddrLocal 7
2995: oPushResult
2996: oGetParam 2
2998: oPushResult
2999: oSetResult 42
3001: oPushResult
3002: oNodeGet
3003: oPop 2
3005: oAssign
3006: oInputChoice 3010
3008: oJumpForward 3015
3010: Choice Lookup Table
           0   3008
3013: oJumpForward 3081
3015: oGetAddrLocal 8
3017: oPushResult
3018: oGetLocal 7
3020: oPushResult
3021: oScopeFindRequireInScope
3022: oPop 1
3024: oAssign
3025: oInput 13
3027: oGetAddrLocal 9
3029: oPushResult
3030: oGetLocal 8
3032: oPushResult
3033: oSetResult 21
3035: oPushResult
3036: oNodeGet
3037: oPop 2
3039: oAssign
3040: oGetAddrLocal 10
3042: oPushResult
3043: oGetParam 1
3045: oPushResult
3046: oGetLocal 8
3048: oPushResult
3049: oSetResult 22
3051: oPushResult
3052: oNodeGetInt
3053: oPop 2
3055: oPushResult
3056: add
3057: oPop 2
3059: oAssign
3060: oGetLocal 9
3062: oPushResult
3063: oGetLocal 10
3065: oPushResult
3066: oCall 2852
3068: oPop 2
3070: oInputChoice 3074
3072: oJumpForward 3079
3074: Choice Lookup Table
           6   3072
3077: oJumpForward 3081
3079: oJumpBack 3006
3081: oInput 16
3083: oJumpForward 3212
3085: oEmit 17
3087: oGetParam 1
3089: oPushResult
3090: oEmitInt
3091: oPop 1
3093: oGetParam 2
3095: oPushResult
3096: oTypeSPush
3097: oPop 1
3099: oCall 3568
3101: oCall 4460
3103: oEmit 15
3105: oValueTop
3106: oPushResult
3107: oEmitInt
3108: oPop 1
3110: oValuePop
3111: oTypeSPop
3112: oEmit 28
3114: oJumpForward 3212
3116: oEmit 17
3118: oGetParam 1
3120: oPushResult
3121: oEmitInt
3122: oPop 1
3124: oGetParam 2
3126: oPushResult
3127: oTypeSPush
3128: oPop 1
3130: oCall 3568
3132: oCall 4460
3134: oEmit 15
3136: oValueTop
3137: oPushResult
3138: oEmitInt
3139: oPop 1
3141: oValuePop
3142: oTypeSPop
3143: oEmit 27
3145: oJumpForward 3212
3147: oError 17
3149: oJumpForward 3212
3151: oEmit 17
3153: oGetParam 1
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oGetParam 2
3161: oPushResult
3162: oTypeSPush
3163: oPop 1
3165: oCall 3568
3167: oCall 4460
3169: oEmit 15
3171: oValueTop
3172: oPushResult
3173: oEmitInt
3174: oPop 1
3176: oValuePop
3177: oTypeSPop
3178: oEmit 29
3180: oJumpForward 3212
3182: oError 17
3184: oJumpForward 3212
3186: Choice Lookup Table
          29   3182
          43   3182
          38   3151
          37   3151
          33   3147
          44   3116
          31   3116
          36   3085
          30   3085
          34   3085
          41   2991
          39   2862
3211: oEndChoice
3212: oReturn
3213: oLocalSpace 2
3215: oInputChoice 3261
3217: oGetAddrLocal 1
3219: oPushResult
3220: oSetResult 20
3222: oPushResult
3223: LAST_ID
3224: oPushResult
3225: oCall 14772
3227: oPop 2
3229: oAssign
3230: oInput 7
3232: oGetAddrLocal 2
3234: oPushResult
3235: oCall 12740
3237: oPop 1
3239: oGetLocal 1
3241: oPushResult
3242: oSetResult 21
3244: oPushResult
3245: oGetLocal 2
3247: oPushResult
3248: oNodeSet
3249: oPop 3
3251: oGetLocal 1
3253: oPushResult
3254: oScopeDeclare
3255: oPop 1
3257: oInput 6
3259: oJumpForward 3266
3261: Choice Lookup Table
           0   3217
3264: oJumpForward 3268
3266: oJumpBack 3215
3268: oReturn
3269: oLocalSpace 6
3271: oInputChoice 3495
3273: oGetAddrLocal 1
3275: oPushResult
3276: oNodeVecNew
3277: oAssign
3278: oGetAddrLocal 2
3280: oPushResult
3281: oGetParam 1
3283: oPushResult
3284: LAST_ID
3285: oPushResult
3286: oCall 14772
3288: oPop 2
3290: oAssign
3291: oGetLocal 1
3293: oPushResult
3294: oGetLocal 2
3296: oPushResult
3297: oNodeVecAppend
3298: oPop 2
3300: oInputChoice 3306
3302: oInput 0
3304: oJumpForward 3311
3306: Choice Lookup Table
          14   3302
3309: oJumpForward 3313
3311: oJumpBack 3278
3313: oInput 13
3315: oGetAddrLocal 3
3317: oPushResult
3318: oCall 12740
3320: oPop 1
3322: oGetAddrLocal 4
3324: oPushResult
3325: oSetResult 0
3327: oAssign
3328: oGetLocal 4
3330: oPushResult
3331: oGetLocal 1
3333: oPushResult
3334: oNodeVecSize
3335: oPop 1
3337: oPushResult
3338: equal
3339: oPop 2
3341: oChoice 3382
3343: oGetAddrLocal 2
3345: oPushResult
3346: oGetLocal 1
3348: oPushResult
3349: oGetLocal 4
3351: oPushResult
3352: oNodeVecElement
3353: oPop 2
3355: oAssign
3356: oGetLocal 2
3358: oPushResult
3359: oSetResult 21
3361: oPushResult
3362: oGetLocal 3
3364: oPushResult
3365: oNodeSet
3366: oPop 3
3368: oGetLocal 2
3370: oPushResult
3371: oScopeDeclareAlloc
3372: oPop 1
3374: oGetAddrLocal 4
3376: oPushResult
3377: inc
3378: oPop 1
3380: oJumpForward 3387
3382: Choice Lookup Table
           0   3343
3385: oJumpForward 3389
3387: oJumpBack 3328
3389: oInputChoice 3482
3391: oGetLocal 1
3393: oPushResult
3394: oNodeVecSize
3395: oPop 1
3397: oChoice 3401
3399: oJumpForward 3406
3401: Choice Lookup Table
           1   3399
3404: oError 23
3406: oGetAddrLocal 5
3408: oPushResult
3409: oScopeCurrent
3410: oPushResult
3411: oCall 14670
3413: oPop 1
3415: oAssign
3416: oGetLocal 5
3418: oPushResult
3419: oCodePush
3420: oPop 1
3422: oGetAddrLocal 6
3424: oPushResult
3425: oSetResult 0
3427: oAssign
3428: oCall 14722
3430: oPushResult
3431: equal_zero
3432: oPop 1
3434: oChoice 3450
3436: oGetGlobal 3
3438: oPushResult
3439: oScopeEnter
3440: oPop 1
3442: oGetAddrLocal 6
3444: oPushResult
3445: oSetResult 1
3447: oAssign
3448: oJumpForward 3453
3450: Choice Lookup Table
           1   3436
3453: oGetLocal 2
3455: oPushResult
3456: oSetResult 1
3458: oPushResult
3459: oCall 10183
3461: oPop 2
3463: oCall 5029
3465: oCall 8627
3467: oCall 9731
3469: oGetLocal 6
3471: oChoice 3476
3473: oScopeEnd
3474: oJumpForward 3479
3476: Choice Lookup Table
           1   3473
3479: oCodePop
3480: oJumpForward 3485
3482: Choice Lookup Table
           7   3391
3485: oGetLocal 1
3487: oPushResult
3488: oNodeVecDelete
3489: oPop 1
3491: oInput 6
3493: oJumpForward 3500
3495: Choice Lookup Table
           0   3273
3498: oJumpForward 3502
3500: oJumpBack 3271
3502: oReturn
3503: oLocalSpace 2
3505: oInputChoice 3512
3507: oJumpForward 3518
3509: oChangeIntLitToLabelIdent
3510: oJumpForward 3518
3512: Choice Lookup Table
           1   3509
           0   3507
3517: oEndChoice
3518: oGetAddrLocal 1
3520: oPushResult
3521: oSetResult 27
3523: oPushResult
3524: LAST_ID
3525: oPushResult
3526: oCall 14772
3528: oPop 2
3530: oAssign
3531: oGetAddrLocal 2
3533: oPushResult
3534: oLabelNew
3535: oAssign
3536: oGetLocal 1
3538: oPushResult
3539: oSetResult 22
3541: oPushResult
3542: oGetLocal 2
3544: oPushResult
3545: oNodeSetLabel
3546: oPop 3
3548: oGetLocal 1
3550: oPushResult
3551: oScopeDeclare
3552: oPop 1
3554: oInputChoice 3558
3556: oJumpForward 3563
3558: Choice Lookup Table
          14   3556
3561: oJumpForward 3565
3563: oJumpBack 3505
3565: oInput 6
3567: oReturn
3568: oLocalSpace 0
3570: oCall 3825
3572: oInputChoice 3784
3574: oCall 3848
3576: oCall 4581
3578: oTypeSNodeType
3579: oChoice 3594
3581: oValueStringCmp
3582: oSetResult 0
3584: oPushResult
3585: oValuePush
3586: oPop 1
3588: oValueEqual
3589: oJumpForward 3600
3591: oValueEqualD
3592: oJumpForward 3600
3594: Choice Lookup Table
          33   3591
          42   3581
3599: oValueEqual
3600: oTypeSPop
3601: oGetGlobal 7
3603: oPushResult
3604: oTypeSPush
3605: oPop 1
3607: oJumpForward 3799
3609: oCall 3825
3611: oCall 4581
3613: oTypeSNodeType
3614: oChoice 3629
3616: oValueStringCmp
3617: oSetResult 0
3619: oPushResult
3620: oValuePush
3621: oPop 1
3623: oValueNotEqual
3624: oJumpForward 3635
3626: oValueNotEqualD
3627: oJumpForward 3635
3629: Choice Lookup Table
          33   3626
          42   3616
3634: oValueNotEqual
3635: oTypeSPop
3636: oGetGlobal 7
3638: oPushResult
3639: oTypeSPush
3640: oPop 1
3642: oJumpForward 3799
3644: oCall 3825
3646: oCall 4581
3648: oTypeSNodeType
3649: oChoice 3664
3651: oValueStringCmp
3652: oSetResult 0
3654: oPushResult
3655: oValuePush
3656: oPop 1
3658: oValueLess
3659: oJumpForward 3670
3661: oValueLessD
3662: oJumpForward 3670
3664: Choice Lookup Table
          33   3661
          42   3651
3669: oValueLess
3670: oTypeSPop
3671: oGetGlobal 7
3673: oPushResult
3674: oTypeSPush
3675: oPop 1
3677: oJumpForward 3799
3679: oCall 3825
3681: oCall 4581
3683: oTypeSNodeType
3684: oChoice 3699
3686: oValueStringCmp
3687: oSetResult 0
3689: oPushResult
3690: oValuePush
3691: oPop 1
3693: oValueGreater
3694: oJumpForward 3705
3696: oValueGreaterD
3697: oJumpForward 3705
3699: Choice Lookup Table
          33   3696
          42   3686
3704: oValueGreater
3705: oTypeSPop
3706: oGetGlobal 7
3708: oPushResult
3709: oTypeSPush
3710: oPop 1
3712: oJumpForward 3799
3714: oCall 3825
3716: oCall 4581
3718: oTypeSNodeType
3719: oChoice 3734
3721: oValueStringCmp
3722: oSetResult 0
3724: oPushResult
3725: oValuePush
3726: oPop 1
3728: oValueLessEqual
3729: oJumpForward 3740
3731: oValueLessEqualD
3732: oJumpForward 3740
3734: Choice Lookup Table
          33   3731
          42   3721
3739: oValueLessEqual
3740: oTypeSPop
3741: oGetGlobal 7
3743: oPushResult
3744: oTypeSPush
3745: oPop 1
3747: oJumpForward 3799
3749: oCall 3825
3751: oCall 4581
3753: oTypeSNodeType
3754: oChoice 3769
3756: oValueStringCmp
3757: oSetResult 0
3759: oPushResult
3760: oValuePush
3761: oPop 1
3763: oValueGreaterEqual
3764: oJumpForward 3775
3766: oValueGreaterEqualD
3767: oJumpForward 3775
3769: Choice Lookup Table
          33   3766
          42   3756
3774: oValueGreaterEqual
3775: oTypeSPop
3776: oGetGlobal 7
3778: oPushResult
3779: oTypeSPush
3780: oPop 1
3782: oJumpForward 3799
3784: Choice Lookup Table
          12   3749
          11   3714
          10   3679
           9   3644
           8   3609
           7   3574
3797: oJumpForward 3801
3799: oJumpBack 3572
3801: oReturn
3802: oLocalSpace 1
3804: oGetAddrLocal 1
3806: oPushResult
3807: oGetGlobal 25
3809: oAssign
3810: oGetAddrGlobal 25
3812: oPushResult
3813: oSetResult 1
3815: oAssign
3816: oCall 3568
3818: oGetAddrGlobal 25
3820: oPushResult
3821: oGetLocal 1
3823: oAssign
3824: oReturn
3825: oLocalSpace 0
3827: oCall 3848
3829: oInputChoice 3840
3831: oCall 4350
3833: oCall 3848
3835: oCall 4336
3837: oValueOr
3838: oJumpForward 3845
3840: Choice Lookup Table
          58   3831
3843: oJumpForward 3847
3845: oJumpBack 3829
3847: oReturn
3848: oLocalSpace 0
3850: oCall 3871
3852: oInputChoice 3863
3854: oCall 4350
3856: oCall 3871
3858: oCall 4336
3860: oValueAnd
3861: oJumpForward 3868
3863: Choice Lookup Table
          57   3854
3866: oJumpForward 3870
3868: oJumpBack 3852
3870: oReturn
3871: oLocalSpace 0
3873: oInputChoice 3882
3875: oCall 3871
3877: oCall 4350
3879: oValueNot
3880: oJumpForward 3887
3882: Choice Lookup Table
          59   3875
3885: oCall 3888
3887: oReturn
3888: oLocalSpace 0
3890: oCall 3947
3892: oInputChoice 3937
3894: oCall 3947
3896: oCall 4581
3898: oTypeSNodeType
3899: oChoice 3907
3901: oValueStringConcat
3902: oJumpForward 3913
3904: oValueAddD
3905: oJumpForward 3913
3907: Choice Lookup Table
          33   3904
          42   3901
3912: oValueAdd
3913: oJumpForward 3944
3915: oCall 3947
3917: oCall 4581
3919: oTypeSNodeType
3920: oChoice 3929
3922: oError 18
3924: oJumpForward 3935
3926: oValueSubD
3927: oJumpForward 3935
3929: Choice Lookup Table
          33   3926
          42   3922
3934: oValueSub
3935: oJumpForward 3944
3937: Choice Lookup Table
          26   3915
          25   3894
3942: oJumpForward 3946
3944: oJumpBack 3892
3946: oReturn
3947: oLocalSpace 0
3949: oCall 4007
3951: oInputChoice 3997
3953: oCall 4007
3955: oCall 4581
3957: oTypeSNodeType
3958: oChoice 3967
3960: oError 18
3962: oJumpForward 3973
3964: oValueMultD
3965: oJumpForward 3973
3967: Choice Lookup Table
          33   3964
          42   3960
3972: oValueMult
3973: oJumpForward 4004
3975: oCall 4007
3977: oCall 4581
3979: oTypeSNodeType
3980: oChoice 3989
3982: oError 18
3984: oJumpForward 3995
3986: oValueDivD
3987: oJumpForward 3995
3989: Choice Lookup Table
          33   3986
          42   3982
3994: oValueDiv
3995: oJumpForward 4004
3997: Choice Lookup Table
          24   3975
          23   3953
4002: oJumpForward 4006
4004: oJumpBack 3951
4006: oReturn
4007: oLocalSpace 0
4009: oInputChoice 4035
4011: oCall 4043
4013: oJumpForward 4042
4015: oCall 4043
4017: oTypeSNodeType
4018: oChoice 4027
4020: oError 18
4022: oJumpForward 4033
4024: oValueNegateD
4025: oJumpForward 4033
4027: Choice Lookup Table
          33   4024
          42   4020
4032: oValueNegate
4033: oJumpForward 4042
4035: Choice Lookup Table
          26   4015
          25   4011
4040: oCall 4043
4042: oReturn
4043: oLocalSpace 1
4045: oInputChoice 4306
4047: TOKEN_VALUE
4048: oPushResult
4049: oValuePush
4050: oPop 1
4052: oGetGlobal 6
4054: oPushResult
4055: oTypeSPush
4056: oPop 1
4058: oJumpForward 4335
4060: TOKEN_VALUE
4061: oPushResult
4062: oValuePush
4063: oPop 1
4065: oGetGlobal 9
4067: oPushResult
4068: oTypeSPush
4069: oPop 1
4071: oJumpForward 4335
4073: TOKEN_VALUE_DOUBLE
4074: oPushResult
4075: oValuePushDouble
4076: oPop 1
4078: oGetGlobal 13
4080: oPushResult
4081: oTypeSPush
4082: oPop 1
4084: oJumpForward 4335
4086: CURRENT_STRLIT
4087: oPushResult
4088: oValuePushString
4089: oPop 1
4091: oGetGlobal 15
4093: oPushResult
4094: oTypeSPush
4095: oPop 1
4097: oJumpForward 4335
4099: oCall 3568
4101: oInput 16
4103: oJumpForward 4335
4105: oGetAddrLocal 1
4107: oPushResult
4108: oScopeFindRequire
4109: oAssign
4110: oGetAddrLocal 1
4112: oPushResult
4113: oCall 244
4115: oPop 1
4117: oGetLocal 1
4119: oPushResult
4120: oNodeType
4121: oPop 1
4123: oChoice 4263
4125: oGetLocal 1
4127: oPushResult
4128: oCall 4763
4130: oPop 1
4132: oJumpForward 4288
4134: oGetLocal 1
4136: oPushResult
4137: oSetResult 22
4139: oPushResult
4140: oNodeGetInt
4141: oPop 2
4143: oPushResult
4144: oValuePush
4145: oPop 1
4147: oGetLocal 1
4149: oPushResult
4150: oSetResult 21
4152: oPushResult
4153: oNodeGet
4154: oPop 2
4156: oPushResult
4157: oTypeSPush
4158: oPop 1
4160: oJumpForward 4288
4162: oGetLocal 1
4164: oPushResult
4165: oSetResult 33
4167: oPushResult
4168: oNodeGetString
4169: oPop 2
4171: oPushResult
4172: oValuePushString
4173: oPop 1
4175: oGetLocal 1
4177: oPushResult
4178: oSetResult 21
4180: oPushResult
4181: oNodeGet
4182: oPop 2
4184: oPushResult
4185: oTypeSPush
4186: oPop 1
4188: oJumpForward 4288
4190: oGetLocal 1
4192: oPushResult
4193: oSetResult 22
4195: oPushResult
4196: oNodeGetInt
4197: oPop 2
4199: oPushResult
4200: oValuePush
4201: oPop 1
4203: oGetLocal 1
4205: oPushResult
4206: oSetResult 21
4208: oPushResult
4209: oNodeGet
4210: oPop 2
4212: oPushResult
4213: oTypeSPush
4214: oPop 1
4216: oJumpForward 4288
4218: oGetLocal 1
4220: oPushResult
4221: oSetResult 21
4223: oPushResult
4224: oNodeGet
4225: oPop 2
4227: oPushResult
4228: oTypeSPush
4229: oPop 1
4231: oInputChoice 4241
4233: oCall 3568
4235: oInput 16
4237: oCall 4586
4239: oJumpForward 4261
4241: Choice Lookup Table
          15   4233
4244: oGetGlobal 25
4246: oChoice 4256
4248: oSetResult 0
4250: oPushResult
4251: oValuePush
4252: oPop 1
4254: oJumpForward 4261
4256: Choice Lookup Table
           1   4248
4259: oError 32
4261: oJumpForward 4288
4263: Choice Lookup Table
          20   4218
          17   4190
          18   4162
          16   4134
          14   4125
4274: oError 1
4276: oSetResult 0
4278: oPushResult
4279: oValuePush
4280: oPop 1
4282: oGetGlobal 6
4284: oPushResult
4285: oTypeSPush
4286: oPop 1
4288: oJumpForward 4335
4290: oError 17
4292: oSetResult 0
4294: oPushResult
4295: oValuePush
4296: oPop 1
4298: oGetGlobal 14
4300: oPushResult
4301: oTypeSPush
4302: oPop 1
4304: oJumpForward 4335
4306: Choice Lookup Table
          20   4290
           0   4105
          15   4099
           3   4086
           2   4073
           4   4060
           1   4047
4321: oError 1
4323: oSetResult 0
4325: oPushResult
4326: oValuePush
4327: oPop 1
4329: oGetGlobal 6
4331: oPushResult
4332: oTypeSPush
4333: oPop 1
4335: oReturn
4336: oLocalSpace 0
4338: oTypeSNodeType
4339: oChoice 4343
4341: oJumpForward 4348
4343: Choice Lookup Table
          34   4341
4346: oError 8
4348: oTypeSPop
4349: oReturn
4350: oLocalSpace 0
4352: oTypeSNodeType
4353: oChoice 4357
4355: oJumpForward 4362
4357: Choice Lookup Table
          34   4355
4360: oError 8
4362: oReturn
4363: oLocalSpace 1
4365: oGetAddrLocal 1
4367: oPushResult
4368: oTypeSNodeType
4369: oAssign
4370: oTypeSPop
4371: oGetLocal 1
4373: oPushResult
4374: oTypeSNodeType
4375: oPushResult
4376: equal_node_type
4377: oPop 2
4379: oChoice 4456
4381: oTypeSNodeType
4382: oChoice 4443
4384: oGetLocal 1
4386: oChoice 4391
4388: oReturn
4389: oJumpForward 4394
4391: Choice Lookup Table
          38   4388
4394: oJumpForward 4452
4396: oGetLocal 1
4398: oChoice 4403
4400: oReturn
4401: oJumpForward 4406
4403: Choice Lookup Table
          37   4400
4406: oJumpForward 4452
4408: oGetLocal 1
4410: oChoice 4416
4412: oValueCharToString
4413: oReturn
4414: oJumpForward 4419
4416: Choice Lookup Table
          36   4412
4419: oJumpForward 4452
4421: oGetLocal 1
4423: oChoice 4438
4425: oValueSwap
4426: oValueCharToString
4427: oValueSwap
4428: oTypeSPop
4429: oGetGlobal 15
4431: oPushResult
4432: oTypeSPush
4433: oPop 1
4435: oReturn
4436: oJumpForward 4441
4438: Choice Lookup Table
          42   4425
4441: oJumpForward 4452
4443: Choice Lookup Table
          36   4421
          42   4408
          38   4396
          37   4384
4452: oError 15
4454: oJumpForward 4459
4456: Choice Lookup Table
           0   4381
4459: oReturn
4460: oLocalSpace 1
4462: oGetAddrLocal 1
4464: oPushResult
4465: oTypeSNodeType
4466: oAssign
4467: oTypeSPop
4468: oGetLocal 1
4470: oPushResult
4471: oTypeSNodeType
4472: oPushResult
4473: equal_node_type
4474: oPop 2
4476: oChoice 4577
4478: oTypeSNodeType
4479: oChoice 4560
4481: oGetLocal 1
4483: oChoice 4488
4485: oReturn
4486: oJumpForward 4491
4488: Choice Lookup Table
          30   4485
4491: oJumpForward 4573
4493: oGetLocal 1
4495: oChoice 4500
4497: oReturn
4498: oJumpForward 4503
4500: Choice Lookup Table
          31   4497
4503: oJumpForward 4573
4505: oGetLocal 1
4507: oChoice 4512
4509: oReturn
4510: oJumpForward 4515
4512: Choice Lookup Table
          38   4509
4515: oJumpForward 4573
4517: oGetLocal 1
4519: oChoice 4524
4521: oReturn
4522: oJumpForward 4527
4524: Choice Lookup Table
          37   4521
4527: oJumpForward 4573
4529: oGetLocal 1
4531: oChoice 4537
4533: oValueCharToString
4534: oReturn
4535: oJumpForward 4540
4537: Choice Lookup Table
          36   4533
4540: oJumpForward 4573
4542: oGetLocal 1
4544: oChoice 4553
4546: oReturn
4547: oJumpForward 4558
4549: oValueCharToString
4550: oReturn
4551: oJumpForward 4558
4553: Choice Lookup Table
          36   4549
          42   4546
4558: oJumpForward 4573
4560: Choice Lookup Table
          43   4542
          42   4529
          38   4517
          37   4505
          30   4493
          31   4481
4573: oError 15
4575: oJumpForward 4580
4577: Choice Lookup Table
           0   4478
4580: oReturn
4581: oLocalSpace 0
4583: oCall 4363
4585: oReturn
4586: oLocalSpace 1
4588: oGetAddrLocal 1
4590: oPushResult
4591: oTypeSNodeType
4592: oAssign
4593: oTypeSPop
4594: oGetLocal 1
4596: oPushResult
4597: oTypeSNodeType
4598: oPushResult
4599: equal_node_type
4600: oPop 2
4602: oChoice 4759
4604: oTypeSNodeType
4605: oChoice 4734
4607: oGetLocal 1
4609: oChoice 4617
4611: oReturn
4612: oJumpForward 4628
4614: oReturn
4615: oJumpForward 4628
4617: Choice Lookup Table
          44   4614
          31   4614
          34   4611
          36   4611
          30   4611
4628: oJumpForward 4755
4630: oGetLocal 1
4632: oChoice 4640
4634: oReturn
4635: oJumpForward 4651
4637: oReturn
4638: oJumpForward 4651
4640: Choice Lookup Table
          44   4637
          31   4637
          34   4634
          36   4634
          30   4634
4651: oJumpForward 4755
4653: oGetLocal 1
4655: oChoice 4664
4657: oValueIntToDouble
4658: oReturn
4659: oJumpForward 4677
4661: oReturn
4662: oJumpForward 4677
4664: Choice Lookup Table
          33   4661
          44   4657
          31   4657
          34   4657
          36   4657
          30   4657
4677: oJumpForward 4755
4679: oGetLocal 1
4681: oChoice 4686
4683: oReturn
4684: oJumpForward 4689
4686: Choice Lookup Table
          38   4683
4689: oJumpForward 4755
4691: oGetLocal 1
4693: oChoice 4698
4695: oReturn
4696: oJumpForward 4701
4698: Choice Lookup Table
          37   4695
4701: oJumpForward 4755
4703: oGetLocal 1
4705: oChoice 4711
4707: oValueCharToString
4708: oReturn
4709: oJumpForward 4714
4711: Choice Lookup Table
          36   4707
4714: oJumpForward 4755
4716: oGetLocal 1
4718: oChoice 4727
4720: oReturn
4721: oJumpForward 4732
4723: oValueCharToString
4724: oReturn
4725: oJumpForward 4732
4727: Choice Lookup Table
          36   4723
          42   4720
4732: oJumpForward 4755
4734: Choice Lookup Table
          43   4716
          42   4703
          38   4691
          37   4679
          33   4653
          34   4630
          36   4630
          30   4630
          44   4607
          31   4607
4755: oError 15
4757: oJumpForward 4762
4759: Choice Lookup Table
           0   4604
4762: oReturn
4763: oLocalSpace 1
4765: oGetParam 1
4767: oPushResult
4768: oGetGlobal 17
4770: oPushResult
4771: oNodeEqual
4772: oPop 2
4774: oChoice 4814
4776: oInput 15
4778: oCall 3568
4780: oInput 16
4782: oTypeSNodeType
4783: oChoice 4789
4785: oJumpForward 4802
4787: oJumpForward 4802
4789: Choice Lookup Table
          36   4787
          30   4787
          34   4787
          44   4785
          31   4785
4800: oError 15
4802: oTypeSPop
4803: oGetGlobal 6
4805: oPushResult
4806: oTypeSPush
4807: oPop 1
4809: oInput 16
4811: oReturn
4812: oJumpForward 4817
4814: Choice Lookup Table
           1   4776
4817: oGetParam 1
4819: oPushResult
4820: oGetGlobal 18
4822: oPushResult
4823: oNodeEqual
4824: oPop 2
4826: oChoice 4860
4828: oInput 15
4830: oCall 3568
4832: oInput 16
4834: oTypeSNodeType
4835: oChoice 4841
4837: oJumpForward 4848
4839: oJumpForward 4848
4841: Choice Lookup Table
          30   4839
          31   4837
4846: oError 15
4848: oTypeSPop
4849: oGetGlobal 9
4851: oPushResult
4852: oTypeSPush
4853: oPop 1
4855: oInput 16
4857: oReturn
4858: oJumpForward 4863
4860: Choice Lookup Table
           1   4828
4863: oGetParam 1
4865: oPushResult
4866: oGetGlobal 19
4868: oPushResult
4869: oNodeEqual
4870: oPop 2
4872: oChoice 4917
4874: oInput 15
4876: oCall 3568
4878: oTypeSNodeType
4879: oChoice 4900
4881: oTypeSTop
4882: oPushResult
4883: oSetResult 45
4885: oPushResult
4886: oNodeGetBoolean
4887: oPop 2
4889: oChoice 4895
4891: oError 29
4893: oJumpForward 4898
4895: Choice Lookup Table
           1   4891
4898: oJumpForward 4905
4900: Choice Lookup Table
          44   4881
4903: oError 15
4905: oSetResult 1
4907: oPushResult
4908: oValuePush
4909: oPop 1
4911: oValueSub
4912: oInput 16
4914: oReturn
4915: oJumpForward 4920
4917: Choice Lookup Table
           1   4874
4920: oGetParam 1
4922: oPushResult
4923: oGetGlobal 20
4925: oPushResult
4926: oNodeEqual
4927: oPop 2
4929: oChoice 4974
4931: oInput 15
4933: oCall 3568
4935: oTypeSNodeType
4936: oChoice 4957
4938: oTypeSTop
4939: oPushResult
4940: oSetResult 45
4942: oPushResult
4943: oNodeGetBoolean
4944: oPop 2
4946: oChoice 4952
4948: oError 29
4950: oJumpForward 4955
4952: Choice Lookup Table
           1   4948
4955: oJumpForward 4962
4957: Choice Lookup Table
          44   4938
4960: oError 15
4962: oSetResult 1
4964: oPushResult
4965: oValuePush
4966: oPop 1
4968: oValueAdd
4969: oInput 16
4971: oReturn
4972: oJumpForward 4977
4974: Choice Lookup Table
           1   4931
4977: oGetParam 1
4979: oPushResult
4980: oGetGlobal 21
4982: oPushResult
4983: oNodeEqual
4984: oPop 2
4986: oChoice 5023
4988: oInput 15
4990: oCall 3802
4992: oValuePop
4993: oGetAddrLocal 1
4995: oPushResult
4996: oTypeSTop
4997: oAssign
4998: oTypeSPop
4999: oGetLocal 1
5001: oPushResult
5002: oSetResult 17
5004: oPushResult
5005: oNodeGetInt
5006: oPop 2
5008: oPushResult
5009: oValuePush
5010: oPop 1
5012: oGetGlobal 6
5014: oPushResult
5015: oTypeSPush
5016: oPop 1
5018: oInput 16
5020: oReturn
5021: oJumpForward 5026
5023: Choice Lookup Table
           1   4988
5026: oError 17
5028: oReturn
5029: oLocalSpace 1
5031: oGetAddrLocal 1
5033: oPushResult
5034: oSetResult 0
5036: oAssign
5037: oGetAddrLocal 1
5039: oPushResult
5040: oCall 5213
5042: oPop 1
5044: oGetAddrLocal 1
5046: oPushResult
5047: oCall 5113
5049: oPop 1
5051: oReturn
5052: oLocalSpace 1
5054: oGetAddrLocal 1
5056: oPushResult
5057: oGetGlobal 25
5059: oAssign
5060: oGetAddrGlobal 25
5062: oPushResult
5063: oSetResult 1
5065: oAssign
5066: oCall 5029
5068: oGetAddrGlobal 25
5070: oPushResult
5071: oGetLocal 1
5073: oAssign
5074: oReturn
5075: oLocalSpace 0
5077: oGetParam 1
5079: oPushResult
5080: oCall 5213
5082: oPop 1
5084: oTypeSNodeType
5085: oChoice 5104
5087: oJumpForward 5111
5089: oGetParam 1
5091: oPushResult
5092: oLabelNew
5093: oAssign
5094: oEmit 82
5096: oGetFromParam 1
5098: oPushResult
5099: oEmitLabel
5100: oPop 1
5102: oJumpForward 5111
5104: Choice Lookup Table
          34   5089
          35   5087
5109: oError 8
5111: oTypeSPop
5112: oReturn
5113: oLocalSpace 1
5115: oTypeSNodeType
5116: oChoice 5178
5118: oGetAddrLocal 1
5120: oPushResult
5121: oLabelNew
5122: oAssign
5123: oEmit 15
5125: oSetResult 1
5127: oPushResult
5128: oEmitInt
5129: oPop 1
5131: oEmit 80
5133: oGetLocal 1
5135: oPushResult
5136: oEmitLabel
5137: oPop 1
5139: oEmit 89
5141: oGetFromParam 1
5143: oPushResult
5144: oEmitLabel
5145: oPop 1
5147: oEmit 15
5149: oSetResult 0
5151: oPushResult
5152: oEmitInt
5153: oPop 1
5155: oEmit 89
5157: oGetLocal 1
5159: oPushResult
5160: oEmitLabel
5161: oPop 1
5163: oTypeSPop
5164: oGetGlobal 7
5166: oPushResult
5167: oTypeSPush
5168: oPop 1
5170: oGetParam 1
5172: oPushResult
5173: oSetResult 0
5175: oAssign
5176: oJumpForward 5181
5178: Choice Lookup Table
          35   5118
5181: oReturn
5182: oLocalSpace 0
5184: oTypeSNodeType
5185: oChoice 5209
5187: oGetParam 1
5189: oPushResult
5190: oLabelNew
5191: oAssign
5192: oEmit 82
5194: oGetFromParam 1
5196: oPushResult
5197: oEmitLabel
5198: oPop 1
5200: oTypeSPop
5201: oGetGlobal 8
5203: oPushResult
5204: oTypeSPush
5205: oPop 1
5207: oJumpForward 5212
5209: Choice Lookup Table
          34   5187
5212: oReturn
5213: oLocalSpace 0
5215: oGetParam 1
5217: oPushResult
5218: oCall 5782
5220: oPop 1
5222: oInputChoice 5764
5224: oGetParam 1
5226: oPushResult
5227: oCall 5113
5229: oPop 1
5231: oCall 9396
5233: oGetParam 1
5235: oPushResult
5236: oCall 5782
5238: oPop 1
5240: oGetParam 1
5242: oPushResult
5243: oCall 5113
5245: oPop 1
5247: oCall 9396
5249: oCall 8800
5251: oTypeSNodeType
5252: oChoice 5284
5254: oEmit 51
5256: oJumpForward 5305
5258: oEmit 57
5260: oJumpForward 5305
5262: oEmit 63
5264: oJumpForward 5305
5266: oEmit 63
5268: oJumpForward 5305
5270: oCall 11666
5272: oEmit 15
5274: oSetResult 0
5276: oPushResult
5277: oEmitInt
5278: oPop 1
5280: oEmit 57
5282: oJumpForward 5305
5284: Choice Lookup Table
          42   5270
          43   5270
          38   5266
          37   5266
          33   5262
          44   5258
          31   5258
          36   5254
          34   5254
5303: oError 18
5305: oTypeSPop
5306: oGetGlobal 7
5308: oPushResult
5309: oTypeSPush
5310: oPop 1
5312: oJumpForward 5779
5314: oGetParam 1
5316: oPushResult
5317: oCall 5113
5319: oPop 1
5321: oCall 9396
5323: oGetParam 1
5325: oPushResult
5326: oCall 5782
5328: oPop 1
5330: oGetParam 1
5332: oPushResult
5333: oCall 5113
5335: oPop 1
5337: oCall 9396
5339: oCall 8800
5341: oTypeSNodeType
5342: oChoice 5374
5344: oEmit 52
5346: oJumpForward 5395
5348: oEmit 58
5350: oJumpForward 5395
5352: oEmit 64
5354: oJumpForward 5395
5356: oEmit 64
5358: oJumpForward 5395
5360: oCall 11666
5362: oEmit 15
5364: oSetResult 0
5366: oPushResult
5367: oEmitInt
5368: oPop 1
5370: oEmit 58
5372: oJumpForward 5395
5374: Choice Lookup Table
          42   5360
          43   5360
          38   5356
          37   5356
          33   5352
          44   5348
          31   5348
          36   5344
          34   5344
5393: oError 18
5395: oTypeSPop
5396: oGetGlobal 7
5398: oPushResult
5399: oTypeSPush
5400: oPop 1
5402: oJumpForward 5779
5404: oGetParam 1
5406: oPushResult
5407: oCall 5113
5409: oPop 1
5411: oCall 9396
5413: oGetParam 1
5415: oPushResult
5416: oCall 5782
5418: oPop 1
5420: oGetParam 1
5422: oPushResult
5423: oCall 5113
5425: oPop 1
5427: oCall 9396
5429: oCall 8800
5431: oTypeSNodeType
5432: oChoice 5464
5434: oEmit 54
5436: oJumpForward 5485
5438: oEmit 60
5440: oJumpForward 5485
5442: oEmit 70
5444: oJumpForward 5485
5446: oEmit 66
5448: oJumpForward 5485
5450: oCall 11666
5452: oEmit 15
5454: oSetResult 0
5456: oPushResult
5457: oEmitInt
5458: oPop 1
5460: oEmit 60
5462: oJumpForward 5485
5464: Choice Lookup Table
          42   5450
          43   5450
          38   5446
          37   5446
          33   5442
          44   5438
          31   5438
          36   5434
          34   5434
5483: oError 18
5485: oTypeSPop
5486: oGetGlobal 7
5488: oPushResult
5489: oTypeSPush
5490: oPop 1
5492: oJumpForward 5779
5494: oGetParam 1
5496: oPushResult
5497: oCall 5113
5499: oPop 1
5501: oCall 9396
5503: oGetParam 1
5505: oPushResult
5506: oCall 5782
5508: oPop 1
5510: oGetParam 1
5512: oPushResult
5513: oCall 5113
5515: oPop 1
5517: oCall 9396
5519: oCall 8800
5521: oTypeSNodeType
5522: oChoice 5554
5524: oEmit 53
5526: oJumpForward 5575
5528: oEmit 59
5530: oJumpForward 5575
5532: oEmit 69
5534: oJumpForward 5575
5536: oEmit 65
5538: oJumpForward 5575
5540: oCall 11666
5542: oEmit 15
5544: oSetResult 0
5546: oPushResult
5547: oEmitInt
5548: oPop 1
5550: oEmit 59
5552: oJumpForward 5575
5554: Choice Lookup Table
          42   5540
          43   5540
          38   5536
          37   5536
          33   5532
          44   5528
          31   5528
          36   5524
          34   5524
5573: oError 18
5575: oTypeSPop
5576: oGetGlobal 7
5578: oPushResult
5579: oTypeSPush
5580: oPop 1
5582: oJumpForward 5779
5584: oGetParam 1
5586: oPushResult
5587: oCall 5113
5589: oPop 1
5591: oCall 9396
5593: oGetParam 1
5595: oPushResult
5596: oCall 5782
5598: oPop 1
5600: oGetParam 1
5602: oPushResult
5603: oCall 5113
5605: oPop 1
5607: oCall 9396
5609: oCall 8800
5611: oTypeSNodeType
5612: oChoice 5644
5614: oEmit 56
5616: oJumpForward 5665
5618: oEmit 62
5620: oJumpForward 5665
5622: oEmit 72
5624: oJumpForward 5665
5626: oEmit 68
5628: oJumpForward 5665
5630: oCall 11666
5632: oEmit 15
5634: oSetResult 0
5636: oPushResult
5637: oEmitInt
5638: oPop 1
5640: oEmit 62
5642: oJumpForward 5665
5644: Choice Lookup Table
          42   5630
          43   5630
          38   5626
          37   5626
          33   5622
          44   5618
          31   5618
          36   5614
          34   5614
5663: oError 18
5665: oTypeSPop
5666: oGetGlobal 7
5668: oPushResult
5669: oTypeSPush
5670: oPop 1
5672: oJumpForward 5779
5674: oGetParam 1
5676: oPushResult
5677: oCall 5113
5679: oPop 1
5681: oCall 9396
5683: oGetParam 1
5685: oPushResult
5686: oCall 5782
5688: oPop 1
5690: oGetParam 1
5692: oPushResult
5693: oCall 5113
5695: oPop 1
5697: oCall 9396
5699: oCall 8800
5701: oTypeSNodeType
5702: oChoice 5734
5704: oEmit 55
5706: oJumpForward 5755
5708: oEmit 61
5710: oJumpForward 5755
5712: oEmit 71
5714: oJumpForward 5755
5716: oEmit 67
5718: oJumpForward 5755
5720: oCall 11666
5722: oEmit 15
5724: oSetResult 0
5726: oPushResult
5727: oEmitInt
5728: oPop 1
5730: oEmit 61
5732: oJumpForward 5755
5734: Choice Lookup Table
          42   5720
          43   5720
          38   5716
          37   5716
          33   5712
          44   5708
          31   5708
          36   5704
          34   5704
5753: oError 18
5755: oTypeSPop
5756: oGetGlobal 7
5758: oPushResult
5759: oTypeSPush
5760: oPop 1
5762: oJumpForward 5779
5764: Choice Lookup Table
          12   5674
          11   5584
          10   5494
           9   5404
           8   5314
           7   5224
5777: oJumpForward 5781
5779: oJumpBack 5222
5781: oReturn
5782: oLocalSpace 1
5784: oGetAddrLocal 1
5786: oPushResult
5787: oSetResult 0
5789: oAssign
5790: oGetParam 1
5792: oPushResult
5793: oCall 5962
5795: oPop 1
5797: oInputChoice 5930
5799: oTypeSNodeType
5800: oChoice 5871
5802: oGetLocal 1
5804: oPushResult
5805: oSetResult 0
5807: oPushResult
5808: equal_label
5809: oPop 2
5811: oChoice 5820
5813: oGetAddrLocal 1
5815: oPushResult
5816: oLabelNew
5817: oAssign
5818: oJumpForward 5823
5820: Choice Lookup Table
           1   5813
5823: oEmit 80
5825: oGetLocal 1
5827: oPushResult
5828: oEmitLabel
5829: oPop 1
5831: oJumpForward 5878
5833: oGetParam 1
5835: oPushResult
5836: oCall 5182
5838: oPop 1
5840: oGetLocal 1
5842: oPushResult
5843: oSetResult 0
5845: oPushResult
5846: equal_label
5847: oPop 2
5849: oChoice 5858
5851: oGetAddrLocal 1
5853: oPushResult
5854: oLabelNew
5855: oAssign
5856: oJumpForward 5861
5858: Choice Lookup Table
           1   5851
5861: oEmit 80
5863: oGetLocal 1
5865: oPushResult
5866: oEmitLabel
5867: oPop 1
5869: oJumpForward 5878
5871: Choice Lookup Table
          34   5833
          35   5802
5876: oError 8
5878: oTypeSPop
5879: oEmit 89
5881: oGetFromParam 1
5883: oPushResult
5884: oEmitLabel
5885: oPop 1
5887: oGetParam 1
5889: oPushResult
5890: oSetResult 0
5892: oAssign
5893: oGetParam 1
5895: oPushResult
5896: oCall 5962
5898: oPop 1
5900: oTypeSNodeType
5901: oChoice 5914
5903: oJumpForward 5921
5905: oGetParam 1
5907: oPushResult
5908: oCall 5182
5910: oPop 1
5912: oJumpForward 5921
5914: Choice Lookup Table
          34   5905
          35   5903
5919: oError 8
5921: oTypeSPop
5922: oGetGlobal 8
5924: oPushResult
5925: oTypeSPush
5926: oPop 1
5928: oJumpForward 5935
5930: Choice Lookup Table
          58   5799
5933: oJumpForward 5937
5935: oJumpBack 5797
5937: oGetLocal 1
5939: oPushResult
5940: oSetResult 0
5942: oPushResult
5943: equal_label
5944: oPop 2
5946: oChoice 5958
5948: oEmit 89
5950: oGetLocal 1
5952: oPushResult
5953: oEmitLabel
5954: oPop 1
5956: oJumpForward 5961
5958: Choice Lookup Table
           0   5948
5961: oReturn
5962: oLocalSpace 2
5964: oGetAddrLocal 1
5966: oPushResult
5967: oSetResult 0
5969: oAssign
5970: oGetParam 1
5972: oPushResult
5973: oCall 6100
5975: oPop 1
5977: oInputChoice 6092
5979: oTypeSNodeType
5980: oChoice 5993
5982: oJumpForward 6000
5984: oGetParam 1
5986: oPushResult
5987: oCall 5182
5989: oPop 1
5991: oJumpForward 6000
5993: Choice Lookup Table
          34   5984
          35   5982
5998: oError 8
6000: oTypeSPop
6001: oGetLocal 1
6003: oPushResult
6004: oSetResult 0
6006: oPushResult
6007: equal_label
6008: oPop 2
6010: oChoice 6039
6012: oGetAddrLocal 1
6014: oPushResult
6015: oLabelNew
6016: oAssign
6017: oEmit 90
6019: oGetFromParam 1
6021: oPushResult
6022: oEmitLabel
6023: oPop 1
6025: oGetLocal 1
6027: oPushResult
6028: oEmitLabel
6029: oPop 1
6031: oGetParam 1
6033: oPushResult
6034: oGetLocal 1
6036: oAssign
6037: oJumpForward 6042
6039: Choice Lookup Table
           1   6012
6042: oGetAddrLocal 2
6044: oPushResult
6045: oSetResult 0
6047: oAssign
6048: oGetAddrLocal 2
6050: oPushResult
6051: oCall 6100
6053: oPop 1
6055: oTypeSNodeType
6056: oChoice 6069
6058: oJumpForward 6076
6060: oGetAddrLocal 2
6062: oPushResult
6063: oCall 5182
6065: oPop 1
6067: oJumpForward 6076
6069: Choice Lookup Table
          34   6060
          35   6058
6074: oError 8
6076: oEmit 90
6078: oGetLocal 2
6080: oPushResult
6081: oEmitLabel
6082: oPop 1
6084: oGetLocal 1
6086: oPushResult
6087: oEmitLabel
6088: oPop 1
6090: oJumpForward 6097
6092: Choice Lookup Table
          57   5979
6095: oJumpForward 6099
6097: oJumpBack 5977
6099: oReturn
6100: oLocalSpace 1
6102: oInputChoice 6156
6104: oGetAddrLocal 1
6106: oPushResult
6107: oSetResult 0
6109: oAssign
6110: oGetAddrLocal 1
6112: oPushResult
6113: oCall 6100
6115: oPop 1
6117: oTypeSNodeType
6118: oChoice 6147
6120: oGetParam 1
6122: oPushResult
6123: oLabelNew
6124: oAssign
6125: oEmit 80
6127: oGetFromParam 1
6129: oPushResult
6130: oEmitLabel
6131: oPop 1
6133: oEmit 89
6135: oGetLocal 1
6137: oPushResult
6138: oEmitLabel
6139: oPop 1
6141: oJumpForward 6154
6143: oEmit 50
6145: oJumpForward 6154
6147: Choice Lookup Table
          34   6143
          35   6120
6152: oError 8
6154: oJumpForward 6166
6156: Choice Lookup Table
          59   6104
6159: oGetParam 1
6161: oPushResult
6162: oCall 6167
6164: oPop 1
6166: oReturn
6167: oLocalSpace 2
6169: oGetAddrLocal 1
6171: oPushResult
6172: oSetResult 1
6174: oAssign
6175: oGetParam 1
6177: oPushResult
6178: oCall 6459
6180: oPop 1
6182: oInputChoice 6449
6184: oTypeSNodeType
6185: oChoice 6331
6187: oCall 9350
6189: oGetParam 1
6191: oPushResult
6192: oCall 6459
6194: oPop 1
6196: oTypeSNodeType
6197: oChoice 6213
6199: oEmit 23
6201: oCall 8412
6203: oJumpForward 6224
6205: oEmit 23
6207: oEmit 34
6209: oEmit 47
6211: oJumpForward 6224
6213: Choice Lookup Table
          33   6205
          38   6199
          37   6199
6220: oCall 9370
6222: oEmit 40
6224: oJumpForward 6350
6226: oGetParam 1
6228: oPushResult
6229: oCall 6459
6231: oPop 1
6233: oCall 9416
6235: oEmit 47
6237: oJumpForward 6350
6239: oGetLocal 1
6241: oChoice 6257
6243: oGetAddrLocal 2
6245: oPushResult
6246: oCall 11449
6248: oAssign
6249: oGetAddrLocal 1
6251: oPushResult
6252: oSetResult 0
6254: oAssign
6255: oJumpForward 6260
6257: Choice Lookup Table
           1   6243
6260: oGetParam 1
6262: oPushResult
6263: oCall 6459
6265: oPop 1
6267: oTypeSNodeType
6268: oChoice 6306
6270: oCall 11558
6272: oEmit 18
6274: oGetLocal 2
6276: oPushResult
6277: oEmitInt
6278: oPop 1
6280: oGetGlobal 16
6282: oPushResult
6283: oTypeSPush
6284: oPop 1
6286: oJumpForward 6316
6288: oCall 11612
6290: oEmit 18
6292: oGetLocal 2
6294: oPushResult
6295: oEmitInt
6296: oPop 1
6298: oGetGlobal 16
6300: oPushResult
6301: oTypeSPush
6302: oPop 1
6304: oJumpForward 6316
6306: Choice Lookup Table
          36   6288
          42   6270
          43   6270
6313: oError 15
6315: oTypeSPop
6316: oJumpForward 6350
6318: oGetParam 1
6320: oPushResult
6321: oCall 6459
6323: oPop 1
6325: oCall 9350
6327: oCall 8412
6329: oJumpForward 6350
6331: Choice Lookup Table
          38   6318
          37   6318
          36   6239
          42   6239
          43   6239
          33   6226
          30   6187
          31   6187
6348: oError 18
6350: oJumpForward 6456
6352: oTypeSNodeType
6353: oChoice 6434
6355: oCall 9350
6357: oGetParam 1
6359: oPushResult
6360: oCall 6459
6362: oPop 1
6364: oTypeSNodeType
6365: oChoice 6377
6367: oEmit 23
6369: oEmit 34
6371: oEmit 23
6373: oEmit 48
6375: oJumpForward 6384
6377: Choice Lookup Table
          33   6367
6380: oCall 9370
6382: oEmit 43
6384: oJumpForward 6447
6386: oGetParam 1
6388: oPushResult
6389: oCall 6459
6391: oPop 1
6393: oCall 9416
6395: oEmit 48
6397: oJumpForward 6447
6399: oGetParam 1
6401: oPushResult
6402: oCall 6459
6404: oPop 1
6406: oTypeSNodeType
6407: oChoice 6421
6409: oCall 9350
6411: oCall 8468
6413: oJumpForward 6432
6415: oCall 9265
6417: oCall 8524
6419: oJumpForward 6432
6421: Choice Lookup Table
          38   6415
          37   6415
          30   6409
          31   6409
6430: oError 18
6432: oJumpForward 6447
6434: Choice Lookup Table
          38   6399
          37   6399
          33   6386
          30   6355
          31   6355
6445: oError 18
6447: oJumpForward 6456
6449: Choice Lookup Table
          26   6352
          25   6184
6454: oJumpForward 6458
6456: oJumpBack 6182
6458: oReturn
6459: oLocalSpace 0
6461: oGetParam 1
6463: oPushResult
6464: oCall 6594
6466: oPop 1
6468: oInputChoice 6584
6470: oTypeSNodeType
6471: oChoice 6515
6473: oCall 9350
6475: oGetParam 1
6477: oPushResult
6478: oCall 6594
6480: oPop 1
6482: oTypeSNodeType
6483: oChoice 6493
6485: oEmit 23
6487: oEmit 34
6489: oEmit 45
6491: oJumpForward 6500
6493: Choice Lookup Table
          33   6485
6496: oCall 9370
6498: oEmit 37
6500: oJumpForward 6524
6502: oGetParam 1
6504: oPushResult
6505: oCall 6594
6507: oPop 1
6509: oCall 9416
6511: oEmit 45
6513: oJumpForward 6524
6515: Choice Lookup Table
          33   6502
          30   6473
          31   6473
6522: oError 18
6524: oJumpForward 6591
6526: oTypeSNodeType
6527: oChoice 6573
6529: oCall 9350
6531: oGetParam 1
6533: oPushResult
6534: oCall 6594
6536: oPop 1
6538: oTypeSNodeType
6539: oChoice 6551
6541: oEmit 23
6543: oEmit 34
6545: oEmit 23
6547: oEmit 46
6549: oJumpForward 6558
6551: Choice Lookup Table
          33   6541
6554: oCall 9370
6556: oEmit 38
6558: oJumpForward 6582
6560: oGetParam 1
6562: oPushResult
6563: oCall 6594
6565: oPop 1
6567: oCall 9416
6569: oEmit 46
6571: oJumpForward 6582
6573: Choice Lookup Table
          33   6560
          30   6529
          31   6529
6580: oError 18
6582: oJumpForward 6591
6584: Choice Lookup Table
          24   6526
          23   6470
6589: oJumpForward 6593
6591: oJumpBack 6468
6593: oReturn
6594: oLocalSpace 0
6596: oInputChoice 6654
6598: oGetParam 1
6600: oPushResult
6601: oCall 6667
6603: oPop 1
6605: oTypeSNodeType
6606: oChoice 6612
6608: oJumpForward 6621
6610: oJumpForward 6621
6612: Choice Lookup Table
          33   6610
          30   6608
          31   6608
6619: oError 18
6621: oJumpForward 6666
6623: oGetParam 1
6625: oPushResult
6626: oCall 6667
6628: oPop 1
6630: oTypeSNodeType
6631: oChoice 6643
6633: oCall 9370
6635: oEmit 44
6637: oJumpForward 6652
6639: oEmit 49
6641: oJumpForward 6652
6643: Choice Lookup Table
          33   6639
          30   6633
          31   6633
6650: oError 18
6652: oJumpForward 6666
6654: Choice Lookup Table
          26   6623
          25   6598
6659: oGetParam 1
6661: oPushResult
6662: oCall 6667
6664: oPop 1
6666: oReturn
6667: oLocalSpace 7
6669: oInputChoice 7173
6671: oEmit 15
6673: TOKEN_VALUE
6674: oPushResult
6675: oEmitInt
6676: oPop 1
6678: oGetGlobal 6
6680: oPushResult
6681: oTypeSPush
6682: oPop 1
6684: oJumpForward 7196
6686: oEmit 15
6688: TOKEN_VALUE
6689: oPushResult
6690: oEmitInt
6691: oPop 1
6693: oGetGlobal 9
6695: oPushResult
6696: oTypeSPush
6697: oPop 1
6699: oJumpForward 7196
6701: oEmit 16
6703: TOKEN_VALUE_DOUBLE
6704: oPushResult
6705: oEmitDouble
6706: oPop 1
6708: oGetGlobal 13
6710: oPushResult
6711: oTypeSPush
6712: oPop 1
6714: oJumpForward 7196
6716: oGetParam 1
6718: oPushResult
6719: oCall 5213
6721: oPop 1
6723: oInput 16
6725: oJumpForward 7196
6727: oGetAddrLocal 1
6729: oPushResult
6730: CURRENT_STRLIT
6731: oPushResult
6732: oStringAllocShortStringLit
6733: oPop 1
6735: oAssign
6736: oEmit 17
6738: oGetLocal 1
6740: oPushResult
6741: oEmitInt
6742: oPop 1
6744: oGetGlobal 15
6746: oPushResult
6747: oTypeSPush
6748: oPop 1
6750: oCall 8010
6752: oCall 7956
6754: oJumpForward 7196
6756: oGetAddrLocal 2
6758: oPushResult
6759: oScopeFindRequire
6760: oAssign
6761: oGetAddrLocal 2
6763: oPushResult
6764: oCall 244
6766: oPop 1
6768: oGetLocal 2
6770: oPushResult
6771: oNodeType
6772: oPop 1
6774: oChoice 7091
6776: oGetLocal 2
6778: oPushResult
6779: oCall 11761
6781: oPop 1
6783: oJumpForward 7122
6785: oGetLocal 2
6787: oPushResult
6788: oCall 12431
6790: oPop 1
6792: oJumpForward 7122
6794: oGetAddrLocal 3
6796: oPushResult
6797: oGetLocal 2
6799: oPushResult
6800: oSetResult 21
6802: oPushResult
6803: oNodeGet
6804: oPop 2
6806: oAssign
6807: oGetLocal 3
6809: oPushResult
6810: oTypeSPush
6811: oPop 1
6813: oTypeSNodeType
6814: oChoice 6838
6816: oEmit 15
6818: oGetLocal 2
6820: oPushResult
6821: oCall 14800
6823: oPop 1
6825: oJumpForward 6855
6827: oEmit 15
6829: oGetLocal 2
6831: oPushResult
6832: oCall 14800
6834: oPop 1
6836: oJumpForward 6855
6838: Choice Lookup Table
          38   6827
          37   6827
          30   6816
          36   6816
          34   6816
          44   6816
          31   6816
6853: oError 17
6855: oJumpForward 7122
6857: oGetAddrLocal 3
6859: oPushResult
6860: oGetLocal 2
6862: oPushResult
6863: oSetResult 21
6865: oPushResult
6866: oNodeGet
6867: oPop 2
6869: oAssign
6870: oGetLocal 3
6872: oPushResult
6873: oTypeSPush
6874: oPop 1
6876: oTypeSNodeType
6877: oChoice 6896
6879: oEmit 16
6881: oGetLocal 2
6883: oPushResult
6884: oSetResult 34
6886: oPushResult
6887: oNodeGetDouble
6888: oPop 2
6890: oPushResult
6891: oEmitDouble
6892: oPop 1
6894: oJumpForward 6901
6896: Choice Lookup Table
          33   6879
6899: oError 17
6901: oJumpForward 7122
6903: oGetAddrLocal 4
6905: oPushResult
6906: oGetLocal 2
6908: oPushResult
6909: oSetResult 22
6911: oPushResult
6912: oNodeGetInt
6913: oPop 2
6915: oAssign
6916: oGetLocal 4
6918: oPushResult
6919: equal_zero
6920: oPop 1
6922: oChoice 6955
6924: oGetAddrLocal 4
6926: oPushResult
6927: oGetLocal 2
6929: oPushResult
6930: oSetResult 33
6932: oPushResult
6933: oNodeGetString
6934: oPop 2
6936: oPushResult
6937: oStringAllocShortStringLit
6938: oPop 1
6940: oAssign
6941: oGetLocal 2
6943: oPushResult
6944: oSetResult 22
6946: oPushResult
6947: oGetLocal 4
6949: oPushResult
6950: oNodeSetInt
6951: oPop 3
6953: oJumpForward 6958
6955: Choice Lookup Table
           1   6924
6958: oEmit 17
6960: oGetLocal 4
6962: oPushResult
6963: oEmitInt
6964: oPop 1
6966: oGetGlobal 15
6968: oPushResult
6969: oTypeSPush
6970: oPop 1
6972: oCall 8010
6974: oCall 7956
6976: oJumpForward 7122
6978: oGetLocal 2
6980: oPushResult
6981: oCall 7197
6983: oPop 1
6985: oJumpForward 7122
6987: oGetLocal 2
6989: oPushResult
6990: oSetResult 21
6992: oPushResult
6993: oNodeGet
6994: oPop 2
6996: oPushResult
6997: oTypeSPush
6998: oPop 1
7000: oInputChoice 7067
7002: oCall 5029
7004: oInput 16
7006: oCall 9085
7008: oTypeSNodeType
7009: oChoice 7054
7011: oInputChoice 7041
7013: oTypeSPop
7014: oGetLocal 3
7016: oPushResult
7017: oSetResult 38
7019: oPushResult
7020: oNodeGet
7021: oPop 2
7023: oPushResult
7024: oTypeSPush
7025: oPop 1
7027: oCall 8010
7029: oCall 7956
7031: oJumpForward 7046
7033: oCall 8205
7035: oCall 8010
7037: oCall 7956
7039: oJumpForward 7046
7041: Choice Lookup Table
          17   7033
          19   7013
7046: oJumpForward 7065
7048: oCall 8010
7050: oCall 7956
7052: oJumpForward 7065
7054: Choice Lookup Table
          43   7048
          41   7048
          39   7048
          38   7011
          37   7011
7065: oJumpForward 7089
7067: Choice Lookup Table
          15   7002
7070: oGetGlobal 25
7072: oChoice 7084
7074: oEmit 15
7076: oSetResult 0
7078: oPushResult
7079: oEmitInt
7080: oPop 1
7082: oJumpForward 7089
7084: Choice Lookup Table
           1   7074
7087: oError 32
7089: oJumpForward 7122
7091: Choice Lookup Table
          20   6987
          26   6978
          25   6978
          23   6978
          22   6978
          18   6903
          19   6857
          17   6794
          16   6794
          14   6785
          13   6776
7114: oError 6
7116: oGetGlobal 6
7118: oPushResult
7119: oTypeSPush
7120: oPop 1
7122: oJumpForward 7196
7124: oInput 0
7126: oGetAddrLocal 5
7128: oPushResult
7129: oScopeFindRequire
7130: oAssign
7131: oGetAddrLocal 5
7133: oPushResult
7134: oCall 244
7136: oPop 1
7138: oGetLocal 5
7140: oPushResult
7141: oSetResult 0
7143: oPushResult
7144: oCall 9966
7146: oPop 2
7148: oGetAddrLocal 6
7150: oPushResult
7151: oTypeSTop
7152: oAssign
7153: oTypeSPop
7154: oGetAddrLocal 7
7156: oPushResult
7157: oGetLocal 6
7159: oPushResult
7160: oCall 13819
7162: oPop 1
7164: oAssign
7165: oGetLocal 7
7167: oPushResult
7168: oTypeSPush
7169: oPop 1
7171: oJumpForward 7196
7173: Choice Lookup Table
          20   7124
           0   6756
           3   6727
          15   6716
           2   6701
           4   6686
           1   6671
7188: oError 6
7190: oGetGlobal 6
7192: oPushResult
7193: oTypeSPush
7194: oPop 1
7196: oReturn
7197: oLocalSpace 2
7199: oGetAddrLocal 1
7201: oPushResult
7202: oGetParam 1
7204: oPushResult
7205: oSetResult 21
7207: oPushResult
7208: oNodeGet
7209: oPop 2
7211: oAssign
7212: oGetAddrLocal 2
7214: oPushResult
7215: oGetParam 1
7217: oPushResult
7218: oCall 14754
7220: oPop 1
7222: oAssign
7223: oGetLocal 1
7225: oPushResult
7226: oTypeSPush
7227: oPop 1
7229: oTypeSNodeType
7230: oChoice 7929
7232: oGetParam 1
7234: oPushResult
7235: oNodeType
7236: oPop 1
7238: oChoice 7384
7240: oEmit 0
7242: oGetParam 1
7244: oPushResult
7245: oCall 14800
7247: oPop 1
7249: oJumpForward 7394
7251: oGetLocal 2
7253: oPushResult
7254: equal_zero
7255: oPop 1
7257: oChoice 7270
7259: oEmit 3
7261: oGetParam 1
7263: oPushResult
7264: oCall 14800
7266: oPop 1
7268: oJumpForward 7288
7270: Choice Lookup Table
           1   7259
7273: oEmit 9
7275: oGetLocal 2
7277: oPushResult
7278: oEmitInt
7279: oPop 1
7281: oGetParam 1
7283: oPushResult
7284: oCall 14800
7286: oPop 1
7288: oJumpForward 7394
7290: oGetParam 1
7292: oPushResult
7293: oSetResult 35
7295: oPushResult
7296: oNodeGetBoolean
7297: oPop 2
7299: oChoice 7342
7301: oGetLocal 2
7303: oPushResult
7304: equal_zero
7305: oPop 1
7307: oChoice 7320
7309: oEmit 8
7311: oGetParam 1
7313: oPushResult
7314: oCall 14800
7316: oPop 1
7318: oJumpForward 7338
7320: Choice Lookup Table
           1   7309
7323: oEmit 14
7325: oGetLocal 2
7327: oPushResult
7328: oEmitInt
7329: oPop 1
7331: oGetParam 1
7333: oPushResult
7334: oCall 14800
7336: oPop 1
7338: oEmit 24
7340: oJumpForward 7382
7342: Choice Lookup Table
           1   7301
7345: oGetLocal 2
7347: oPushResult
7348: equal_zero
7349: oPop 1
7351: oChoice 7364
7353: oEmit 6
7355: oGetParam 1
7357: oPushResult
7358: oCall 14800
7360: oPop 1
7362: oJumpForward 7382
7364: Choice Lookup Table
           1   7353
7367: oEmit 12
7369: oGetLocal 2
7371: oPushResult
7372: oEmitInt
7373: oPop 1
7375: oGetParam 1
7377: oPushResult
7378: oCall 14800
7380: oPop 1
7382: oJumpForward 7394
7384: Choice Lookup Table
          25   7290
          23   7251
          26   7240
          22   7240
7393: oEndChoice
7394: oJumpForward 7955
7396: oGetParam 1
7398: oPushResult
7399: oNodeType
7400: oPop 1
7402: oChoice 7548
7404: oEmit 1
7406: oGetParam 1
7408: oPushResult
7409: oCall 14800
7411: oPop 1
7413: oJumpForward 7558
7415: oGetLocal 2
7417: oPushResult
7418: equal_zero
7419: oPop 1
7421: oChoice 7434
7423: oEmit 4
7425: oGetParam 1
7427: oPushResult
7428: oCall 14800
7430: oPop 1
7432: oJumpForward 7452
7434: Choice Lookup Table
           1   7423
7437: oEmit 10
7439: oGetLocal 2
7441: oPushResult
7442: oEmitInt
7443: oPop 1
7445: oGetParam 1
7447: oPushResult
7448: oCall 14800
7450: oPop 1
7452: oJumpForward 7558
7454: oGetParam 1
7456: oPushResult
7457: oSetResult 35
7459: oPushResult
7460: oNodeGetBoolean
7461: oPop 2
7463: oChoice 7506
7465: oGetLocal 2
7467: oPushResult
7468: equal_zero
7469: oPop 1
7471: oChoice 7484
7473: oEmit 8
7475: oGetParam 1
7477: oPushResult
7478: oCall 14800
7480: oPop 1
7482: oJumpForward 7502
7484: Choice Lookup Table
           1   7473
7487: oEmit 14
7489: oGetLocal 2
7491: oPushResult
7492: oEmitInt
7493: oPop 1
7495: oGetParam 1
7497: oPushResult
7498: oCall 14800
7500: oPop 1
7502: oEmit 25
7504: oJumpForward 7546
7506: Choice Lookup Table
           1   7465
7509: oGetLocal 2
7511: oPushResult
7512: equal_zero
7513: oPop 1
7515: oChoice 7528
7517: oEmit 7
7519: oGetParam 1
7521: oPushResult
7522: oCall 14800
7524: oPop 1
7526: oJumpForward 7546
7528: Choice Lookup Table
           1   7517
7531: oEmit 13
7533: oGetLocal 2
7535: oPushResult
7536: oEmitInt
7537: oPop 1
7539: oGetParam 1
7541: oPushResult
7542: oCall 14800
7544: oPop 1
7546: oJumpForward 7558
7548: Choice Lookup Table
          25   7454
          23   7415
          26   7404
          22   7404
7557: oEndChoice
7558: oJumpForward 7955
7560: oError 17
7562: oJumpForward 7955
7564: oGetParam 1
7566: oPushResult
7567: oNodeType
7568: oPop 1
7570: oChoice 7716
7572: oEmit 2
7574: oGetParam 1
7576: oPushResult
7577: oCall 14800
7579: oPop 1
7581: oJumpForward 7726
7583: oGetLocal 2
7585: oPushResult
7586: equal_zero
7587: oPop 1
7589: oChoice 7602
7591: oEmit 5
7593: oGetParam 1
7595: oPushResult
7596: oCall 14800
7598: oPop 1
7600: oJumpForward 7620
7602: Choice Lookup Table
           1   7591
7605: oEmit 11
7607: oGetLocal 2
7609: oPushResult
7610: oEmitInt
7611: oPop 1
7613: oGetParam 1
7615: oPushResult
7616: oCall 14800
7618: oPop 1
7620: oJumpForward 7726
7622: oGetParam 1
7624: oPushResult
7625: oSetResult 35
7627: oPushResult
7628: oNodeGetBoolean
7629: oPop 2
7631: oChoice 7674
7633: oGetLocal 2
7635: oPushResult
7636: equal_zero
7637: oPop 1
7639: oChoice 7652
7641: oEmit 8
7643: oGetParam 1
7645: oPushResult
7646: oCall 14800
7648: oPop 1
7650: oJumpForward 7670
7652: Choice Lookup Table
           1   7641
7655: oEmit 14
7657: oGetLocal 2
7659: oPushResult
7660: oEmitInt
7661: oPop 1
7663: oGetParam 1
7665: oPushResult
7666: oCall 14800
7668: oPop 1
7670: oEmit 26
7672: oJumpForward 7714
7674: Choice Lookup Table
           1   7633
7677: oGetLocal 2
7679: oPushResult
7680: equal_zero
7681: oPop 1
7683: oChoice 7696
7685: oEmit 8
7687: oGetParam 1
7689: oPushResult
7690: oCall 14800
7692: oPop 1
7694: oJumpForward 7714
7696: Choice Lookup Table
           1   7685
7699: oEmit 14
7701: oGetLocal 2
7703: oPushResult
7704: oEmitInt
7705: oPop 1
7707: oGetParam 1
7709: oPushResult
7710: oCall 14800
7712: oPop 1
7714: oJumpForward 7726
7716: Choice Lookup Table
          25   7622
          23   7583
          26   7572
          22   7572
7725: oEndChoice
7726: oInputChoice 7756
7728: oTypeSPop
7729: oGetLocal 1
7731: oPushResult
7732: oSetResult 38
7734: oPushResult
7735: oNodeGet
7736: oPop 2
7738: oPushResult
7739: oTypeSPush
7740: oPop 1
7742: oCall 8010
7744: oCall 7956
7746: oJumpForward 7761
7748: oCall 8205
7750: oCall 8010
7752: oCall 7956
7754: oJumpForward 7761
7756: Choice Lookup Table
          17   7748
          19   7728
7761: oJumpForward 7955
7763: oGetParam 1
7765: oPushResult
7766: oNodeType
7767: oPop 1
7769: oChoice 7913
7771: oEmit 17
7773: oGetParam 1
7775: oPushResult
7776: oCall 14800
7778: oPop 1
7780: oJumpForward 7923
7782: oGetLocal 2
7784: oPushResult
7785: equal_zero
7786: oPop 1
7788: oChoice 7801
7790: oEmit 18
7792: oGetParam 1
7794: oPushResult
7795: oCall 14800
7797: oPop 1
7799: oJumpForward 7819
7801: Choice Lookup Table
           1   7790
7804: oEmit 21
7806: oGetLocal 2
7808: oPushResult
7809: oEmitInt
7810: oPop 1
7812: oGetParam 1
7814: oPushResult
7815: oCall 14800
7817: oPop 1
7819: oJumpForward 7923
7821: oGetParam 1
7823: oPushResult
7824: oSetResult 35
7826: oPushResult
7827: oNodeGetBoolean
7828: oPop 2
7830: oChoice 7871
7832: oGetLocal 2
7834: oPushResult
7835: equal_zero
7836: oPop 1
7838: oChoice 7851
7840: oEmit 8
7842: oGetParam 1
7844: oPushResult
7845: oCall 14800
7847: oPop 1
7849: oJumpForward 7869
7851: Choice Lookup Table
           1   7840
7854: oEmit 14
7856: oGetLocal 2
7858: oPushResult
7859: oEmitInt
7860: oPop 1
7862: oGetParam 1
7864: oPushResult
7865: oCall 14800
7867: oPop 1
7869: oJumpForward 7911
7871: Choice Lookup Table
           1   7832
7874: oGetLocal 2
7876: oPushResult
7877: equal_zero
7878: oPop 1
7880: oChoice 7893
7882: oEmit 19
7884: oGetParam 1
7886: oPushResult
7887: oCall 14800
7889: oPop 1
7891: oJumpForward 7911
7893: Choice Lookup Table
           1   7882
7896: oEmit 22
7898: oGetLocal 2
7900: oPushResult
7901: oEmitInt
7902: oPop 1
7904: oGetParam 1
7906: oPushResult
7907: oCall 14800
7909: oPop 1
7911: oJumpForward 7923
7913: Choice Lookup Table
          25   7821
          23   7782
          26   7771
          22   7771
7922: oEndChoice
7923: oCall 8010
7925: oCall 7956
7927: oJumpForward 7955
7929: Choice Lookup Table
          43   7763
          41   7763
          39   7763
          33   7564
          38   7564
          37   7564
          29   7560
          36   7396
          30   7396
          34   7396
          44   7232
          31   7232
7954: oEndChoice
7955: oReturn
7956: oLocalSpace 0
7958: oTypeSNodeType
7959: oChoice 7983
7961: oEmit 24
7963: oJumpForward 8009
7965: oEmit 25
7967: oJumpForward 8009
7969: oError 17
7971: oJumpForward 8009
7973: oEmit 26
7975: oJumpForward 8009
7977: oError 30
7979: oJumpForward 8009
7981: oJumpForward 8009
7983: Choice Lookup Table
          43   7981
          42   7981
          41   7981
          39   7981
          38   7977
          37   7973
          29   7969
          36   7965
          30   7965
          34   7965
          44   7961
          31   7961
8008: oEndChoice
8009: oReturn
8010: oLocalSpace 0
8012: oInputChoice 8050
8014: oTypeSNodeType
8015: oChoice 8029
8017: oCall 8062
8019: oJumpForward 8040
8021: oCall 8205
8023: oJumpForward 8040
8025: oCall 8284
8027: oJumpForward 8040
8029: Choice Lookup Table
          43   8025
          42   8025
          37   8021
          39   8017
8038: oError 11
8040: oJumpForward 8059
8042: oCall 8314
8044: oJumpForward 8059
8046: oCall 8587
8048: oJumpForward 8059
8050: Choice Lookup Table
          19   8046
          21   8042
          17   8014
8057: oJumpForward 8061
8059: oJumpBack 8012
8061: oReturn
8062: oLocalSpace 3
8064: oTypeSNodeType
8065: oChoice 8069
8067: oJumpForward 8074
8069: Choice Lookup Table
          39   8067
8072: oError 11
8074: oTypeSNodeType
8075: oChoice 8079
8077: oJumpForward 8084
8079: Choice Lookup Table
          39   8077
8082: oError 14
8084: oGetAddrLocal 1
8086: oPushResult
8087: oTypeSTop
8088: oPushResult
8089: oSetResult 39
8091: oPushResult
8092: oNodeGet
8093: oPop 2
8095: oPushResult
8096: oCall 13903
8098: oPop 1
8100: oAssign
8101: oGetAddrLocal 2
8103: oPushResult
8104: oTypeSTop
8105: oPushResult
8106: oSetResult 38
8108: oPushResult
8109: oNodeGet
8110: oPop 2
8112: oAssign
8113: oTypeSPop
8114: oGetLocal 2
8116: oPushResult
8117: oTypeSPush
8118: oPop 1
8120: oCall 5029
8122: oCall 9323
8124: oGetLocal 1
8126: oPushResult
8127: equal_zero
8128: oPop 1
8130: oChoice 8144
8132: oEmit 15
8134: oGetLocal 1
8136: oPushResult
8137: oEmitInt
8138: oPop 1
8140: oEmit 43
8142: oJumpForward 8147
8144: Choice Lookup Table
           0   8132
8147: oGetAddrLocal 3
8149: oPushResult
8150: oGetLocal 2
8152: oPushResult
8153: oSetResult 17
8155: oPushResult
8156: oNodeGetInt
8157: oPop 2
8159: oAssign
8160: oGetLocal 3
8162: oPushResult
8163: oSetResult 1
8165: oPushResult
8166: equal
8167: oPop 2
8169: oChoice 8183
8171: oEmit 15
8173: oGetLocal 3
8175: oPushResult
8176: oEmitInt
8177: oPop 1
8179: oEmit 37
8181: oJumpForward 8186
8183: Choice Lookup Table
           0   8171
8186: oEmit 39
8188: oInputChoice 8196
8190: oJumpForward 8204
8192: oJumpForward 8202
8194: oJumpForward 8202
8196: Choice Lookup Table
          14   8194
          18   8190
8201: oEndChoice
8202: oJumpBack 8074
8204: oReturn
8205: oLocalSpace 2
8207: oTypeSNodeType
8208: oChoice 8212
8210: oJumpForward 8217
8212: Choice Lookup Table
          37   8210
8215: oError 30
8217: oGetAddrLocal 1
8219: oPushResult
8220: oTypeSTop
8221: oPushResult
8222: oSetResult 38
8224: oPushResult
8225: oNodeGet
8226: oPop 2
8228: oAssign
8229: oTypeSPop
8230: oGetLocal 1
8232: oPushResult
8233: oTypeSPush
8234: oPop 1
8236: oCall 5029
8238: oCall 9323
8240: oGetAddrLocal 2
8242: oPushResult
8243: oGetLocal 1
8245: oPushResult
8246: oSetResult 17
8248: oPushResult
8249: oNodeGetInt
8250: oPop 2
8252: oAssign
8253: oGetLocal 2
8255: oPushResult
8256: oSetResult 1
8258: oPushResult
8259: equal
8260: oPop 2
8262: oChoice 8276
8264: oEmit 15
8266: oGetLocal 2
8268: oPushResult
8269: oEmitInt
8270: oPop 1
8272: oEmit 37
8274: oJumpForward 8279
8276: Choice Lookup Table
           0   8264
8279: oEmit 39
8281: oInput 18
8283: oReturn
8284: oLocalSpace 0
8286: oTypeSNodeType
8287: oChoice 8291
8289: oJumpForward 8298
8291: Choice Lookup Table
          43   8289
          42   8289
8296: oError 30
8298: oTypeSPop
8299: oGetGlobal 9
8301: oPushResult
8302: oTypeSPush
8303: oPop 1
8305: oCall 5029
8307: oCall 9323
8309: oEmit 39
8311: oInput 18
8313: oReturn
8314: oLocalSpace 2
8316: oTypeSNodeType
8317: oChoice 8321
8319: oJumpForward 8326
8321: Choice Lookup Table
          41   8319
8324: oError 12
8326: oTypeSTop
8327: oPushResult
8328: oSetResult 42
8330: oPushResult
8331: oNodeGet
8332: oPop 2
8334: oPushResult
8335: oScopeEnter
8336: oPop 1
8338: oInput 0
8340: oGetAddrLocal 1
8342: oPushResult
8343: oScopeFindRequire
8344: oAssign
8345: oGetLocal 1
8347: oPushResult
8348: oNodeType
8349: oPop 1
8351: oChoice 8355
8353: oJumpForward 8360
8355: Choice Lookup Table
          24   8353
8358: oError 13
8360: oScopeEnd
8361: oGetAddrLocal 2
8363: oPushResult
8364: oGetLocal 1
8366: oPushResult
8367: oSetResult 22
8369: oPushResult
8370: oNodeGetInt
8371: oPop 2
8373: oAssign
8374: oGetLocal 2
8376: oPushResult
8377: equal_zero
8378: oPop 1
8380: oChoice 8394
8382: oEmit 15
8384: oGetLocal 2
8386: oPushResult
8387: oEmitInt
8388: oPop 1
8390: oEmit 39
8392: oJumpForward 8397
8394: Choice Lookup Table
           0   8382
8397: oTypeSPop
8398: oGetLocal 1
8400: oPushResult
8401: oSetResult 21
8403: oPushResult
8404: oNodeGet
8405: oPop 2
8407: oPushResult
8408: oTypeSPush
8409: oPop 1
8411: oReturn
8412: oLocalSpace 2
8414: oGetAddrLocal 1
8416: oPushResult
8417: oTypeSTop
8418: oPushResult
8419: oSetResult 38
8421: oPushResult
8422: oNodeGet
8423: oPop 2
8425: oAssign
8426: oGetAddrLocal 2
8428: oPushResult
8429: oGetLocal 1
8431: oPushResult
8432: oSetResult 17
8434: oPushResult
8435: oNodeGetInt
8436: oPop 2
8438: oAssign
8439: oGetLocal 2
8441: oPushResult
8442: oSetResult 1
8444: oPushResult
8445: equal
8446: oPop 2
8448: oChoice 8462
8450: oEmit 15
8452: oGetLocal 2
8454: oPushResult
8455: oEmitInt
8456: oPop 1
8458: oEmit 37
8460: oJumpForward 8465
8462: Choice Lookup Table
           0   8450
8465: oEmit 39
8467: oReturn
8468: oLocalSpace 2
8470: oGetAddrLocal 1
8472: oPushResult
8473: oTypeSTop
8474: oPushResult
8475: oSetResult 38
8477: oPushResult
8478: oNodeGet
8479: oPop 2
8481: oAssign
8482: oGetAddrLocal 2
8484: oPushResult
8485: oGetLocal 1
8487: oPushResult
8488: oSetResult 17
8490: oPushResult
8491: oNodeGetInt
8492: oPop 2
8494: oAssign
8495: oGetLocal 2
8497: oPushResult
8498: oSetResult 1
8500: oPushResult
8501: equal
8502: oPop 2
8504: oChoice 8518
8506: oEmit 15
8508: oGetLocal 2
8510: oPushResult
8511: oEmitInt
8512: oPop 1
8514: oEmit 37
8516: oJumpForward 8521
8518: Choice Lookup Table
           0   8506
8521: oEmit 42
8523: oReturn
8524: oLocalSpace 2
8526: oEmit 41
8528: oGetAddrLocal 1
8530: oPushResult
8531: oTypeSTop
8532: oPushResult
8533: oSetResult 38
8535: oPushResult
8536: oNodeGet
8537: oPop 2
8539: oAssign
8540: oGetAddrLocal 2
8542: oPushResult
8543: oGetLocal 1
8545: oPushResult
8546: oSetResult 17
8548: oPushResult
8549: oNodeGetInt
8550: oPop 2
8552: oAssign
8553: oGetLocal 2
8555: oPushResult
8556: oSetResult 1
8558: oPushResult
8559: equal
8560: oPop 2
8562: oChoice 8576
8564: oEmit 15
8566: oGetLocal 2
8568: oPushResult
8569: oEmitInt
8570: oPop 1
8572: oEmit 38
8574: oJumpForward 8579
8576: Choice Lookup Table
           0   8564
8579: oTypeSPop
8580: oGetGlobal 6
8582: oPushResult
8583: oTypeSPush
8584: oPop 1
8586: oReturn
8587: oLocalSpace 1
8589: oTypeSNodeType
8590: oChoice 8598
8592: oJumpForward 8605
8594: oError 30
8596: oJumpForward 8605
8598: Choice Lookup Table
          38   8594
          37   8592
8603: oError 10
8605: oEmit 26
8607: oGetAddrLocal 1
8609: oPushResult
8610: oTypeSTop
8611: oAssign
8612: oTypeSPop
8613: oGetLocal 1
8615: oPushResult
8616: oSetResult 38
8618: oPushResult
8619: oNodeGet
8620: oPop 2
8622: oPushResult
8623: oTypeSPush
8624: oPop 1
8626: oReturn
8627: oLocalSpace 3
8629: oGetAddrLocal 1
8631: oPushResult
8632: oTypeSNodeType
8633: oAssign
8634: oGetAddrLocal 2
8636: oPushResult
8637: oTypeSTop
8638: oAssign
8639: oTypeSPop
8640: oGetLocal 1
8642: oPushResult
8643: oTypeSNodeType
8644: oPushResult
8645: equal_node_type
8646: oPop 2
8648: oChoice 8796
8650: oTypeSNodeType
8651: oChoice 8779
8653: oGetLocal 1
8655: oChoice 8662
8657: oEmit 32
8659: oReturn
8660: oJumpForward 8665
8662: Choice Lookup Table
          30   8657
8665: oJumpForward 8792
8667: oGetLocal 1
8669: oChoice 8676
8671: oEmit 33
8673: oReturn
8674: oJumpForward 8679
8676: Choice Lookup Table
          31   8671
8679: oJumpForward 8792
8681: oGetLocal 1
8683: oChoice 8690
8685: oEmit 34
8687: oReturn
8688: oJumpForward 8693
8690: Choice Lookup Table
          31   8685
8693: oJumpForward 8792
8695: oGetLocal 1
8697: oChoice 8730
8699: oReturn
8700: oJumpForward 8735
8702: oTypeSTop
8703: oPushResult
8704: oGetGlobal 10
8706: oPushResult
8707: equal_node
8708: oPop 2
8710: oChoice 8725
8712: oEmit 15
8714: oSetResult 1
8716: oPushResult
8717: oEmitInt
8718: oPop 1
8720: oEmit 39
8722: oReturn
8723: oJumpForward 8728
8725: Choice Lookup Table
           1   8712
8728: oJumpForward 8735
8730: Choice Lookup Table
          42   8702
          38   8699
8735: oJumpForward 8792
8737: oGetLocal 1
8739: oChoice 8744
8741: oReturn
8742: oJumpForward 8747
8744: Choice Lookup Table
          37   8741
8747: oJumpForward 8792
8749: oGetLocal 1
8751: oChoice 8772
8753: oReturn
8754: oJumpForward 8777
8756: oGetGlobal 9
8758: oPushResult
8759: oTypeSPush
8760: oPop 1
8762: oGetAddrLocal 3
8764: oPushResult
8765: oCall 11449
8767: oAssign
8768: oTypeSPop
8769: oReturn
8770: oJumpForward 8777
8772: Choice Lookup Table
          36   8756
          42   8753
8777: oJumpForward 8792
8779: Choice Lookup Table
          43   8749
          38   8737
          37   8695
          33   8681
          30   8667
          31   8653
8792: oError 15
8794: oJumpForward 8799
8796: Choice Lookup Table
           0   8650
8799: oReturn
8800: oLocalSpace 6
8802: oGetAddrLocal 1
8804: oPushResult
8805: oTypeSNodeType
8806: oAssign
8807: oGetAddrLocal 2
8809: oPushResult
8810: oTypeSTop
8811: oAssign
8812: oTypeSPop
8813: oGetAddrLocal 3
8815: oPushResult
8816: oTypeSNodeType
8817: oAssign
8818: oGetAddrLocal 4
8820: oPushResult
8821: oTypeSTop
8822: oAssign
8823: oGetLocal 3
8825: oPushResult
8826: oGetLocal 1
8828: oPushResult
8829: equal_node_type
8830: oPop 2
8832: oChoice 8837
8834: oReturn
8835: oJumpForward 8840
8837: Choice Lookup Table
           1   8834
8840: oGetLocal 3
8842: oChoice 8923
8844: oGetLocal 1
8846: oChoice 8853
8848: oEmit 32
8850: oReturn
8851: oJumpForward 8856
8853: Choice Lookup Table
          30   8848
8856: oJumpForward 8932
8858: oGetLocal 1
8860: oChoice 8874
8862: oEmit 32
8864: oEmit 34
8866: oReturn
8867: oJumpForward 8879
8869: oEmit 34
8871: oReturn
8872: oJumpForward 8879
8874: Choice Lookup Table
          31   8869
          30   8862
8879: oJumpForward 8932
8881: oGetLocal 1
8883: oChoice 8888
8885: oReturn
8886: oJumpForward 8891
8888: Choice Lookup Table
          38   8885
8891: oJumpForward 8932
8893: oGetLocal 1
8895: oChoice 8916
8897: oReturn
8898: oJumpForward 8921
8900: oGetGlobal 9
8902: oPushResult
8903: oTypeSPush
8904: oPop 1
8906: oGetAddrLocal 5
8908: oPushResult
8909: oCall 11449
8911: oAssign
8912: oTypeSPop
8913: oReturn
8914: oJumpForward 8921
8916: Choice Lookup Table
          36   8900
          42   8897
8921: oJumpForward 8932
8923: Choice Lookup Table
          43   8893
          37   8881
          33   8858
          31   8844
8932: oGetLocal 1
8934: oChoice 9073
8936: oGetLocal 3
8938: oChoice 8956
8940: oEmit 23
8942: oEmit 32
8944: oEmit 23
8946: oTypeSPop
8947: oGetLocal 2
8949: oPushResult
8950: oTypeSPush
8951: oPop 1
8953: oReturn
8954: oJumpForward 8959
8956: Choice Lookup Table
          30   8940
8959: oJumpForward 9082
8961: oGetLocal 3
8963: oChoice 8999
8965: oEmit 23
8967: oEmit 32
8969: oEmit 34
8971: oEmit 23
8973: oTypeSPop
8974: oGetLocal 2
8976: oPushResult
8977: oTypeSPush
8978: oPop 1
8980: oReturn
8981: oJumpForward 9004
8983: oEmit 23
8985: oEmit 34
8987: oEmit 23
8989: oTypeSPop
8990: oGetLocal 2
8992: oPushResult
8993: oTypeSPush
8994: oPop 1
8996: oReturn
8997: oJumpForward 9004
8999: Choice Lookup Table
          31   8983
          30   8965
9004: oJumpForward 9082
9006: oGetLocal 3
9008: oChoice 9020
9010: oTypeSPop
9011: oGetLocal 2
9013: oPushResult
9014: oTypeSPush
9015: oPop 1
9017: oReturn
9018: oJumpForward 9023
9020: Choice Lookup Table
          38   9010
9023: oJumpForward 9082
9025: oGetLocal 3
9027: oChoice 9066
9029: oTypeSPop
9030: oGetLocal 2
9032: oPushResult
9033: oTypeSPush
9034: oPop 1
9036: oReturn
9037: oJumpForward 9071
9039: oEmit 23
9041: oGetGlobal 9
9043: oPushResult
9044: oTypeSPush
9045: oPop 1
9047: oGetAddrLocal 6
9049: oPushResult
9050: oCall 11449
9052: oAssign
9053: oTypeSPop
9054: oEmit 23
9056: oTypeSPop
9057: oGetLocal 2
9059: oPushResult
9060: oTypeSPush
9061: oPop 1
9063: oReturn
9064: oJumpForward 9071
9066: Choice Lookup Table
          36   9039
          42   9029
9071: oJumpForward 9082
9073: Choice Lookup Table
          43   9025
          37   9006
          33   8961
          31   8936
9082: oError 15
9084: oReturn
9085: oLocalSpace 2
9087: oGetAddrLocal 1
9089: oPushResult
9090: oTypeSNodeType
9091: oAssign
9092: oTypeSPop
9093: oGetLocal 1
9095: oPushResult
9096: oTypeSNodeType
9097: oPushResult
9098: equal_node_type
9099: oPop 2
9101: oChoice 9261
9103: oTypeSNodeType
9104: oChoice 9240
9106: oGetLocal 1
9108: oChoice 9118
9110: oEmit 32
9112: oReturn
9113: oJumpForward 9129
9115: oReturn
9116: oJumpForward 9129
9118: Choice Lookup Table
          44   9115
          31   9115
          34   9110
          36   9110
          30   9110
9129: oJumpForward 9257
9131: oGetLocal 1
9133: oChoice 9143
9135: oReturn
9136: oJumpForward 9154
9138: oEmit 33
9140: oReturn
9141: oJumpForward 9154
9143: Choice Lookup Table
          44   9138
          31   9138
          34   9135
          36   9135
          30   9135
9154: oJumpForward 9257
9156: oGetLocal 1
9158: oChoice 9191
9160: oReturn
9161: oJumpForward 9196
9163: oTypeSTop
9164: oPushResult
9165: oGetGlobal 10
9167: oPushResult
9168: equal_node
9169: oPop 2
9171: oChoice 9186
9173: oEmit 15
9175: oSetResult 1
9177: oPushResult
9178: oEmitInt
9179: oPop 1
9181: oEmit 39
9183: oReturn
9184: oJumpForward 9189
9186: Choice Lookup Table
           1   9173
9189: oJumpForward 9196
9191: Choice Lookup Table
          42   9163
          38   9160
9196: oJumpForward 9257
9198: oGetLocal 1
9200: oChoice 9205
9202: oReturn
9203: oJumpForward 9208
9205: Choice Lookup Table
          37   9202
9208: oJumpForward 9257
9210: oGetLocal 1
9212: oChoice 9233
9214: oReturn
9215: oJumpForward 9238
9217: oGetGlobal 9
9219: oPushResult
9220: oTypeSPush
9221: oPop 1
9223: oGetAddrLocal 2
9225: oPushResult
9226: oCall 11449
9228: oAssign
9229: oTypeSPop
9230: oReturn
9231: oJumpForward 9238
9233: Choice Lookup Table
          36   9217
          42   9214
9238: oJumpForward 9257
9240: Choice Lookup Table
          43   9210
          38   9198
          37   9156
          34   9131
          36   9131
          30   9131
          44   9106
          31   9106
9257: oError 15
9259: oJumpForward 9264
9261: Choice Lookup Table
           0   9103
9264: oReturn
9265: oLocalSpace 1
9267: oGetAddrLocal 1
9269: oPushResult
9270: oTypeSNodeType
9271: oAssign
9272: oTypeSPop
9273: oGetLocal 1
9275: oPushResult
9276: oTypeSNodeType
9277: oPushResult
9278: equal_node_type
9279: oPop 2
9281: oChoice 9319
9283: oTypeSNodeType
9284: oChoice 9310
9286: oGetLocal 1
9288: oChoice 9293
9290: oReturn
9291: oJumpForward 9296
9293: Choice Lookup Table
          38   9290
9296: oJumpForward 9315
9298: oGetLocal 1
9300: oChoice 9305
9302: oReturn
9303: oJumpForward 9308
9305: Choice Lookup Table
          37   9302
9308: oJumpForward 9315
9310: Choice Lookup Table
          38   9298
          37   9286
9315: oError 15
9317: oJumpForward 9322
9319: Choice Lookup Table
           0   9283
9322: oReturn
9323: oLocalSpace 0
9325: oTypeSNodeType
9326: oChoice 9330
9328: oJumpForward 9335
9330: Choice Lookup Table
          31   9328
9333: oError 7
9335: oTypeSPop
9336: oReturn
9337: oLocalSpace 0
9339: oTypeSNodeType
9340: oChoice 9344
9342: oJumpForward 9349
9344: Choice Lookup Table
          31   9342
9347: oError 7
9349: oReturn
9350: oLocalSpace 0
9352: oTypeSNodeType
9353: oChoice 9361
9355: oJumpForward 9368
9357: oEmit 32
9359: oJumpForward 9368
9361: Choice Lookup Table
          30   9357
          31   9355
9366: oError 7
9368: oTypeSPop
9369: oReturn
9370: oLocalSpace 0
9372: oTypeSNodeType
9373: oChoice 9388
9375: oJumpForward 9395
9377: oEmit 32
9379: oTypeSPop
9380: oGetGlobal 6
9382: oPushResult
9383: oTypeSPush
9384: oPop 1
9386: oJumpForward 9395
9388: Choice Lookup Table
          30   9377
          31   9375
9393: oError 7
9395: oReturn
9396: oLocalSpace 0
9398: oTypeSNodeType
9399: oChoice 9412
9401: oEmit 32
9403: oTypeSPop
9404: oGetGlobal 6
9406: oPushResult
9407: oTypeSPush
9408: oPop 1
9410: oJumpForward 9415
9412: Choice Lookup Table
          30   9401
9415: oReturn
9416: oLocalSpace 0
9418: oTypeSNodeType
9419: oChoice 9447
9421: oJumpForward 9456
9423: oEmit 34
9425: oTypeSPop
9426: oGetGlobal 13
9428: oPushResult
9429: oTypeSPush
9430: oPop 1
9432: oJumpForward 9456
9434: oEmit 32
9436: oEmit 34
9438: oTypeSPop
9439: oGetGlobal 13
9441: oPushResult
9442: oTypeSPush
9443: oPop 1
9445: oJumpForward 9456
9447: Choice Lookup Table
          30   9434
          31   9423
          33   9421
9454: oError 9
9456: oTypeSPop
9457: oReturn
9458: oLocalSpace 0
9460: oTypeSNodeType
9461: oChoice 9465
9463: oJumpForward 9470
9465: Choice Lookup Table
          34   9463
9468: oError 8
9470: oTypeSPop
9471: oReturn
9472: oLocalSpace 0
9474: oTypeSNodeType
9475: oChoice 9479
9477: oJumpForward 9484
9479: Choice Lookup Table
          34   9477
9482: oError 8
9484: oReturn
9485: oLocalSpace 0
9487: oInputChoice 9550
9489: oCall 11222
9491: oJumpForward 9581
9493: oCall 11229
9495: oJumpForward 9581
9497: oCall 11359
9499: oJumpForward 9581
9501: oCall 11366
9503: oJumpForward 9581
9505: oCall 10373
9507: oJumpForward 9581
9509: oCall 10696
9511: oJumpForward 9581
9513: oCall 10439
9515: oJumpForward 9581
9517: oCall 10616
9519: oJumpForward 9581
9521: oCall 10781
9523: oJumpForward 9581
9525: oCall 10749
9527: oJumpForward 9581
9529: oCall 11199
9531: oJumpForward 9581
9533: oCall 9582
9535: oJumpForward 9581
9537: oCall 10813
9539: oJumpForward 9581
9541: oCall 11147
9543: oJumpForward 9581
9545: oChangeIntLitToLabelIdent
9546: oCall 9582
9548: oJumpForward 9581
9550: Choice Lookup Table
           1   9545
          56   9541
          54   9537
           0   9533
          36   9529
          52   9525
          53   9521
          50   9517
          45   9513
          49   9509
          42   9505
          69   9501
          68   9497
          67   9493
          66   9489
9581: oReturn
9582: oLocalSpace 1
9584: oGetAddrLocal 1
9586: oPushResult
9587: oScopeFindRequire
9588: oAssign
9589: oGetAddrLocal 1
9591: oPushResult
9592: oCall 244
9594: oPop 1
9596: oGetLocal 1
9598: oPushResult
9599: oNodeType
9600: oPop 1
9602: oChoice 9642
9604: oGetLocal 1
9606: oPushResult
9607: oCall 9660
9609: oPop 1
9611: oCall 9485
9613: oJumpForward 9659
9615: oGetLocal 1
9617: oPushResult
9618: oCall 11761
9620: oPop 1
9622: oJumpForward 9659
9624: oGetLocal 1
9626: oPushResult
9627: oCall 9710
9629: oPop 1
9631: oJumpForward 9659
9633: oGetLocal 1
9635: oPushResult
9636: oCall 9806
9638: oPop 1
9640: oJumpForward 9659
9642: Choice Lookup Table
          13   9633
          20   9624
          25   9624
          23   9624
          22   9624
          12   9615
          27   9604
9657: oError 0
9659: oReturn
9660: oLocalSpace 0
9662: oGetParam 1
9664: oPushResult
9665: oSetResult 36
9667: oPushResult
9668: oNodeGetBoolean
9669: oPop 2
9671: oChoice 9677
9673: oError 22
9675: oJumpForward 9680
9677: Choice Lookup Table
           1   9673
9680: oEmit 89
9682: oGetParam 1
9684: oPushResult
9685: oSetResult 22
9687: oPushResult
9688: oNodeGetLabel
9689: oPop 2
9691: oPushResult
9692: oEmitLabel
9693: oPop 1
9695: oGetParam 1
9697: oPushResult
9698: oSetResult 36
9700: oPushResult
9701: oSetResult 1
9703: oPushResult
9704: oNodeSetBoolean
9705: oPop 3
9707: oInput 13
9709: oReturn
9710: oLocalSpace 0
9712: oGetParam 1
9714: oPushResult
9715: oSetResult 1
9717: oPushResult
9718: oCall 9966
9720: oPop 2
9722: oInput 5
9724: oCall 5029
9726: oCall 8627
9728: oCall 9731
9730: oReturn
9731: oLocalSpace 1
9733: oTypeSNodeType
9734: oChoice 9778
9736: oEmit 27
9738: oJumpForward 9804
9740: oEmit 28
9742: oJumpForward 9804
9744: oEmit 30
9746: oJumpForward 9804
9748: oError 17
9750: oJumpForward 9804
9752: oEmit 29
9754: oJumpForward 9804
9756: oGetAddrLocal 1
9758: oPushResult
9759: oTypeSTop
9760: oPushResult
9761: oSetResult 17
9763: oPushResult
9764: oNodeGetInt
9765: oPop 2
9767: oAssign
9768: oEmit 31
9770: oGetLocal 1
9772: oPushResult
9773: oEmitInt
9774: oPop 1
9776: oJumpForward 9804
9778: Choice Lookup Table
          43   9756
          41   9756
          39   9756
          38   9752
          37   9752
          29   9748
          33   9744
          36   9740
          30   9740
          34   9740
          44   9736
          31   9736
9803: oEndChoice
9804: oTypeSPop
9805: oReturn
9806: oLocalSpace 1
9808: oGetParam 1
9810: oPushResult
9811: oSetResult 6
9813: oPushResult
9814: oNodeGet
9815: oPop 2
9817: oPushResult
9818: oScopeCurrent
9819: oPushResult
9820: oNodeEqual
9821: oPop 2
9823: oChoice 9829
9825: oError 21
9827: oJumpForward 9832
9829: Choice Lookup Table
           0   9825
9832: oEmit 8
9834: oGetParam 1
9836: oPushResult
9837: oSetResult 31
9839: oPushResult
9840: oNodeGetInt
9841: oPop 2
9843: oPushResult
9844: oEmitInt
9845: oPop 1
9847: oGetParam 1
9849: oPushResult
9850: oSetResult 21
9852: oPushResult
9853: oNodeGet
9854: oPop 2
9856: oPushResult
9857: oTypeSPush
9858: oPop 1
9860: oInput 5
9862: oCall 5029
9864: oCall 8627
9866: oTypeSNodeType
9867: oChoice 9911
9869: oEmit 27
9871: oJumpForward 9937
9873: oEmit 28
9875: oJumpForward 9937
9877: oEmit 30
9879: oJumpForward 9937
9881: oError 17
9883: oJumpForward 9937
9885: oEmit 29
9887: oJumpForward 9937
9889: oGetAddrLocal 1
9891: oPushResult
9892: oTypeSTop
9893: oPushResult
9894: oSetResult 17
9896: oPushResult
9897: oNodeGetInt
9898: oPop 2
9900: oAssign
9901: oEmit 31
9903: oGetLocal 1
9905: oPushResult
9906: oEmitInt
9907: oPop 1
9909: oJumpForward 9937
9911: Choice Lookup Table
          43   9889
          41   9889
          39   9889
          38   9885
          37   9885
          29   9881
          33   9877
          36   9873
          30   9873
          34   9873
          44   9869
          31   9869
9936: oEndChoice
9937: oTypeSPop
9938: oReturn
9939: oLocalSpace 1
9941: oInput 0
9943: oGetAddrLocal 1
9945: oPushResult
9946: oScopeFindRequire
9947: oAssign
9948: oGetAddrLocal 1
9950: oPushResult
9951: oCall 244
9953: oPop 1
9955: oGetLocal 1
9957: oPushResult
9958: oGetParam 1
9960: oPushResult
9961: oCall 9966
9963: oPop 2
9965: oReturn
9966: oLocalSpace 0
9968: oGetParam 2
9970: oPushResult
9971: oNodeType
9972: oPop 1
9974: oChoice 10037
9976: oGetParam 2
9978: oPushResult
9979: oGetParam 1
9981: oPushResult
9982: oCall 10183
9984: oPop 2
9986: oJumpForward 10050
9988: oGetParam 2
9990: oPushResult
9991: oSetResult 21
9993: oPushResult
9994: oNodeGet
9995: oPop 2
9997: oPushResult
9998: oTypeSPush
9999: oPop 1
10001: oInput 15
10003: oGetParam 1
10005: oPushResult
10006: oCall 9939
10008: oPop 1
10010: oInput 16
10012: oCall 10051
10014: oTypeSNodeType
10015: oChoice 10030
10017: oInputChoice 10025
10019: oEmit 26
10021: oCall 8205
10023: oJumpForward 10028
10025: Choice Lookup Table
          17   10019
10028: oJumpForward 10033
10030: Choice Lookup Table
          37   10017
10033: oCall 8010
10035: oJumpForward 10050
10037: Choice Lookup Table
          20   9988
          26   9976
          25   9976
          23   9976
          22   9976
10048: oError 4
10050: oReturn
10051: oLocalSpace 1
10053: oGetAddrLocal 1
10055: oPushResult
10056: oTypeSNodeType
10057: oAssign
10058: oTypeSPop
10059: oGetLocal 1
10061: oPushResult
10062: oTypeSNodeType
10063: oPushResult
10064: equal_node_type
10065: oPop 2
10067: oChoice 10179
10069: oTypeSNodeType
10070: oChoice 10158
10072: oGetLocal 1
10074: oChoice 10084
10076: oError 31
10078: oReturn
10079: oJumpForward 10095
10081: oReturn
10082: oJumpForward 10095
10084: Choice Lookup Table
          44   10081
          31   10081
          34   10076
          36   10076
          30   10076
10095: oJumpForward 10175
10097: oGetLocal 1
10099: oChoice 10109
10101: oReturn
10102: oJumpForward 10120
10104: oError 31
10106: oReturn
10107: oJumpForward 10120
10109: Choice Lookup Table
          44   10104
          31   10104
          34   10101
          36   10101
          30   10101
10120: oJumpForward 10175
10122: oGetLocal 1
10124: oChoice 10129
10126: oReturn
10127: oJumpForward 10132
10129: Choice Lookup Table
          38   10126
10132: oJumpForward 10175
10134: oGetLocal 1
10136: oChoice 10141
10138: oReturn
10139: oJumpForward 10144
10141: Choice Lookup Table
          37   10138
10144: oJumpForward 10175
10146: oGetLocal 1
10148: oChoice 10153
10150: oReturn
10151: oJumpForward 10156
10153: Choice Lookup Table
          42   10150
10156: oJumpForward 10175
10158: Choice Lookup Table
          43   10146
          38   10134
          37   10122
          34   10097
          36   10097
          30   10097
          44   10072
          31   10072
10175: oError 15
10177: oJumpForward 10182
10179: Choice Lookup Table
           0   10069
10182: oReturn
10183: oLocalSpace 0
10185: oGetParam 2
10187: oPushResult
10188: oNodeType
10189: oPop 1
10191: oChoice 10273
10193: oEmit 17
10195: oGetParam 2
10197: oPushResult
10198: oCall 14800
10200: oPop 1
10202: oJumpForward 10284
10204: oEmit 18
10206: oGetParam 2
10208: oPushResult
10209: oCall 14800
10211: oPop 1
10213: oJumpForward 10284
10215: oGetParam 2
10217: oPushResult
10218: oSetResult 35
10220: oPushResult
10221: oNodeGetBoolean
10222: oPop 2
10224: oChoice 10237
10226: oEmit 8
10228: oGetParam 2
10230: oPushResult
10231: oCall 14800
10233: oPop 1
10235: oJumpForward 10249
10237: Choice Lookup Table
           1   10226
10240: oEmit 19
10242: oGetParam 2
10244: oPushResult
10245: oCall 14800
10247: oPop 1
10249: oJumpForward 10284
10251: oGetParam 1
10253: oChoice 10266
10255: oEmit 17
10257: oGetParam 2
10259: oPushResult
10260: oCall 14800
10262: oPop 1
10264: oJumpForward 10271
10266: Choice Lookup Table
           0   10255
10269: oError 4
10271: oJumpForward 10284
10273: Choice Lookup Table
          26   10251
          25   10215
          23   10204
          22   10193
10282: oError 4
10284: oGetParam 2
10286: oPushResult
10287: oSetResult 21
10289: oPushResult
10290: oNodeGet
10291: oPop 2
10293: oPushResult
10294: oTypeSPush
10295: oPop 1
10297: oTypeSNodeType
10298: oChoice 10313
10300: oInputChoice 10308
10302: oEmit 26
10304: oCall 8205
10306: oJumpForward 10311
10308: Choice Lookup Table
          17   10302
10311: oJumpForward 10316
10313: Choice Lookup Table
          37   10300
10316: oCall 8010
10318: oReturn
10319: oLocalSpace 0
10321: oGetParam 1
10323: oPushResult
10324: oSetResult 1
10326: oPushResult
10327: oCall 10183
10329: oPop 2
10331: oCall 9323
10333: oGetParam 1
10335: oPushResult
10336: oCall 7197
10338: oPop 1
10340: oTypeSPop
10341: oEmit 35
10343: oEmit 27
10345: oReturn
10346: oLocalSpace 0
10348: oGetParam 1
10350: oPushResult
10351: oSetResult 1
10353: oPushResult
10354: oCall 10183
10356: oPop 2
10358: oCall 9323
10360: oGetParam 1
10362: oPushResult
10363: oCall 7197
10365: oPop 1
10367: oTypeSPop
10368: oEmit 36
10370: oEmit 27
10372: oReturn
10373: oLocalSpace 2
10375: oGetAddrLocal 1
10377: oPushResult
10378: oSetResult 0
10380: oAssign
10381: oGetAddrLocal 1
10383: oPushResult
10384: oCall 5075
10386: oPop 1
10388: oInput 43
10390: oCall 9485
10392: oInputChoice 10427
10394: oGetAddrLocal 2
10396: oPushResult
10397: oLabelNew
10398: oAssign
10399: oEmit 80
10401: oGetLocal 2
10403: oPushResult
10404: oEmitLabel
10405: oPop 1
10407: oEmit 89
10409: oGetLocal 1
10411: oPushResult
10412: oEmitLabel
10413: oPop 1
10415: oCall 9485
10417: oEmit 89
10419: oGetLocal 2
10421: oPushResult
10422: oEmitLabel
10423: oPop 1
10425: oJumpForward 10438
10427: Choice Lookup Table
          44   10394
10430: oEmit 89
10432: oGetLocal 1
10434: oPushResult
10435: oEmitLabel
10436: oPop 1
10438: oReturn
10439: oLocalSpace 4
10441: oInput 0
10443: oGetAddrLocal 1
10445: oPushResult
10446: oScopeFindRequire
10447: oAssign
10448: oGetLocal 1
10450: oPushResult
10451: oSetResult 1
10453: oPushResult
10454: oCall 10183
10456: oPop 2
10458: oCall 9323
10460: oInput 5
10462: oCall 5029
10464: oCall 9323
10466: oEmit 27
10468: oGetAddrLocal 2
10470: oPushResult
10471: oLabelNew
10472: oAssign
10473: oGetAddrLocal 3
10475: oPushResult
10476: oLabelNew
10477: oAssign
10478: oEmit 80
10480: oGetLocal 3
10482: oPushResult
10483: oEmitLabel
10484: oPop 1
10486: oGetAddrLocal 4
10488: oPushResult
10489: oLabelNew
10490: oAssign
10491: oEmit 89
10493: oGetLocal 4
10495: oPushResult
10496: oEmitLabel
10497: oPop 1
10499: oInputChoice 10579
10501: oGetLocal 1
10503: oPushResult
10504: oCall 10319
10506: oPop 1
10508: oEmit 89
10510: oGetLocal 3
10512: oPushResult
10513: oEmitLabel
10514: oPop 1
10516: oGetLocal 1
10518: oPushResult
10519: oCall 7197
10521: oPop 1
10523: oTypeSPop
10524: oCall 5029
10526: oCall 9323
10528: oEmit 59
10530: oEmit 81
10532: oGetLocal 2
10534: oPushResult
10535: oEmitLabel
10536: oPop 1
10538: oJumpForward 10585
10540: oGetLocal 1
10542: oPushResult
10543: oCall 10346
10545: oPop 1
10547: oEmit 89
10549: oGetLocal 3
10551: oPushResult
10552: oEmitLabel
10553: oPop 1
10555: oGetLocal 1
10557: oPushResult
10558: oCall 7197
10560: oPop 1
10562: oTypeSPop
10563: oCall 5029
10565: oCall 9323
10567: oEmit 60
10569: oEmit 81
10571: oGetLocal 2
10573: oPushResult
10574: oEmitLabel
10575: oPop 1
10577: oJumpForward 10585
10579: Choice Lookup Table
          47   10540
          46   10501
10584: oEndChoice
10585: oGetLocal 4
10587: oPushResult
10588: oGetLocal 2
10590: oPushResult
10591: oLoopPush
10592: oPop 2
10594: oInput 48
10596: oCall 9485
10598: oEmit 80
10600: oGetLocal 4
10602: oPushResult
10603: oEmitLabel
10604: oPop 1
10606: oEmit 89
10608: oGetLocal 2
10610: oPushResult
10611: oEmitLabel
10612: oPop 1
10614: oLoopPop
10615: oReturn
10616: oLocalSpace 3
10618: oGetAddrLocal 1
10620: oPushResult
10621: oLabelNew
10622: oAssign
10623: oEmit 89
10625: oGetLocal 1
10627: oPushResult
10628: oEmitLabel
10629: oPop 1
10631: oGetAddrLocal 2
10633: oPushResult
10634: oLabelNew
10635: oAssign
10636: oGetLocal 1
10638: oPushResult
10639: oGetLocal 2
10641: oPushResult
10642: oLoopPush
10643: oPop 2
10645: oCall 9485
10647: oInputChoice 10678
10649: oCall 9485
10651: oJumpForward 10684
10653: oGetAddrLocal 3
10655: oPushResult
10656: oCall 5075
10658: oPop 1
10660: oEmit 90
10662: oGetLocal 3
10664: oPushResult
10665: oEmitLabel
10666: oPop 1
10668: oGetLocal 1
10670: oPushResult
10671: oEmitLabel
10672: oPop 1
10674: oJumpForward 10686
10676: oJumpForward 10684
10678: Choice Lookup Table
          51   10653
           6   10649
10683: oEndChoice
10684: oJumpBack 10647
10686: oEmit 89
10688: oGetLocal 2
10690: oPushResult
10691: oEmitLabel
10692: oPop 1
10694: oLoopPop
10695: oReturn
10696: oLocalSpace 2
10698: oGetAddrLocal 1
10700: oPushResult
10701: oLabelNew
10702: oAssign
10703: oEmit 89
10705: oGetLocal 1
10707: oPushResult
10708: oEmitLabel
10709: oPop 1
10711: oGetAddrLocal 2
10713: oPushResult
10714: oCall 5075
10716: oPop 1
10718: oGetLocal 1
10720: oPushResult
10721: oGetLocal 2
10723: oPushResult
10724: oLoopPush
10725: oPop 2
10727: oInput 48
10729: oCall 9485
10731: oEmit 80
10733: oGetLocal 1
10735: oPushResult
10736: oEmitLabel
10737: oPop 1
10739: oEmit 89
10741: oGetLocal 2
10743: oPushResult
10744: oEmitLabel
10745: oPop 1
10747: oLoopPop
10748: oReturn
10749: oLocalSpace 0
10751: oLoopContinueLabel
10752: oPushResult
10753: oSetResult 0
10755: oPushResult
10756: equal_label
10757: oPop 2
10759: oChoice 10774
10761: oError 19
10763: oJumpForward 10780
10765: oEmit 80
10767: oLoopContinueLabel
10768: oPushResult
10769: oEmitLabel
10770: oPop 1
10772: oJumpForward 10780
10774: Choice Lookup Table
           0   10765
           1   10761
10779: oEndChoice
10780: oReturn
10781: oLocalSpace 0
10783: oLoopBreakLabel
10784: oPushResult
10785: oSetResult 0
10787: oPushResult
10788: equal_label
10789: oPop 2
10791: oChoice 10806
10793: oError 19
10795: oJumpForward 10812
10797: oEmit 80
10799: oLoopBreakLabel
10800: oPushResult
10801: oEmitLabel
10802: oPop 1
10804: oJumpForward 10812
10806: Choice Lookup Table
           0   10797
           1   10793
10811: oEndChoice
10812: oReturn
10813: oLocalSpace 8
10815: oGetAddrLocal 1
10817: oPushResult
10818: oCodeNew
10819: oAssign
10820: oGetAddrLocal 2
10822: oPushResult
10823: oLabelNew
10824: oAssign
10825: oGetAddrLocal 3
10827: oPushResult
10828: oLabelNew
10829: oAssign
10830: oGetAddrLocal 4
10832: oPushResult
10833: oGetLocal 3
10835: oAssign
10836: oGetAddrLocal 5
10838: oPushResult
10839: oSetResult 0
10841: oAssign
10842: oCall 5029
10844: oTypeSNodeType
10845: oChoice 10883
10847: oEmit 83
10849: oGetLocal 2
10851: oPushResult
10852: oEmitLabel
10853: oPop 1
10855: oJumpForward 10900
10857: oEmit 84
10859: oGetLocal 2
10861: oPushResult
10862: oEmitLabel
10863: oPop 1
10865: oJumpForward 10900
10867: oGetAddrLocal 5
10869: oPushResult
10870: oSetResult 1
10872: oAssign
10873: oEmit 85
10875: oGetLocal 2
10877: oPushResult
10878: oEmitLabel
10879: oPop 1
10881: oJumpForward 10900
10883: Choice Lookup Table
          42   10867
          43   10867
          44   10857
          31   10857
          36   10847
          30   10847
          34   10847
10898: oError 18
10900: oInput 41
10902: oInputChoice 10949
10904: oGetAddrLocal 4
10906: oPushResult
10907: oLabelNew
10908: oAssign
10909: oEmit 89
10911: oGetLocal 4
10913: oPushResult
10914: oEmitLabel
10915: oPop 1
10917: oInputChoice 10923
10919: oJumpForward 10941
10921: oJumpForward 10939
10923: Choice Lookup Table
          37   10919
10926: oCall 9485
10928: oInputChoice 10932
10930: oJumpForward 10939
10932: Choice Lookup Table
           6   10930
10935: oInput 37
10937: oJumpForward 10941
10939: oJumpBack 10917
10941: oJumpForward 11115
10943: oJumpForward 11113
10945: oJumpForward 11115
10947: oJumpForward 11113
10949: Choice Lookup Table
          37   10945
          44   10904
          55   10904
10956: oGetAddrLocal 6
10958: oPushResult
10959: oLabelNew
10960: oAssign
10961: oGetLocal 1
10963: oPushResult
10964: oCodePush
10965: oPop 1
10967: oCall 3568
10969: oCall 4460
10971: oGetLocal 5
10973: oChoice 10993
10975: oGetAddrLocal 7
10977: oPushResult
10978: oValueTopString
10979: oPushResult
10980: oStringAllocShortStringLit
10981: oPop 1
10983: oAssign
10984: oJumpForward 10999
10986: oGetAddrLocal 7
10988: oPushResult
10989: oValueTop
10990: oAssign
10991: oJumpForward 10999
10993: Choice Lookup Table
           0   10986
           1   10975
10998: oEndChoice
10999: oValuePop
11000: oInputChoice 11057
11002: oCall 3568
11004: oCall 4460
11006: oGetLocal 5
11008: oChoice 11028
11010: oGetAddrLocal 8
11012: oPushResult
11013: oValueTopString
11014: oPushResult
11015: oStringAllocShortStringLit
11016: oPop 1
11018: oAssign
11019: oJumpForward 11034
11021: oGetAddrLocal 8
11023: oPushResult
11024: oValueTop
11025: oAssign
11026: oJumpForward 11034
11028: Choice Lookup Table
           0   11021
           1   11010
11033: oEndChoice
11034: oValuePop
11035: oEmit 87
11037: oGetLocal 7
11039: oPushResult
11040: oEmitInt
11041: oPop 1
11043: oGetLocal 8
11045: oPushResult
11046: oEmitInt
11047: oPop 1
11049: oGetLocal 6
11051: oPushResult
11052: oEmitLabel
11053: oPop 1
11055: oJumpForward 11074
11057: Choice Lookup Table
          22   11002
11060: oEmit 86
11062: oGetLocal 7
11064: oPushResult
11065: oEmitInt
11066: oPop 1
11068: oGetLocal 6
11070: oPushResult
11071: oEmitLabel
11072: oPop 1
11074: oInputChoice 11078
11076: oJumpForward 11083
11078: Choice Lookup Table
          14   11076
11081: oJumpForward 11085
11083: oJumpBack 10967
11085: oCodePop
11086: oInput 13
11088: oEmit 89
11090: oGetLocal 6
11092: oPushResult
11093: oEmitLabel
11094: oPop 1
11096: oCall 9485
11098: oEmit 80
11100: oGetLocal 3
11102: oPushResult
11103: oEmitLabel
11104: oPop 1
11106: oInputChoice 11110
11108: oJumpForward 11113
11110: Choice Lookup Table
           6   11108
11113: oJumpBack 10902
11115: oEmit 89
11117: oGetLocal 2
11119: oPushResult
11120: oEmitLabel
11121: oPop 1
11123: oGetLocal 1
11125: oPushResult
11126: oEmitCode
11127: oPop 1
11129: oEmit 88
11131: oGetLocal 4
11133: oPushResult
11134: oEmitLabel
11135: oPop 1
11137: oEmit 89
11139: oGetLocal 3
11141: oPushResult
11142: oEmitLabel
11143: oPop 1
11145: oTypeSPop
11146: oReturn
11147: oLocalSpace 1
11149: oInputChoice 11156
11151: oJumpForward 11162
11153: oChangeIntLitToLabelIdent
11154: oJumpForward 11162
11156: Choice Lookup Table
           1   11153
           0   11151
11161: oEndChoice
11162: oGetAddrLocal 1
11164: oPushResult
11165: oScopeCurrent
11166: oPushResult
11167: oScopeFindRequireInScope
11168: oPop 1
11170: oAssign
11171: oGetLocal 1
11173: oPushResult
11174: oSetResult 28
11176: oPushResult
11177: oSetResult 1
11179: oPushResult
11180: oNodeSetBoolean
11181: oPop 3
11183: oEmit 80
11185: oGetLocal 1
11187: oPushResult
11188: oSetResult 22
11190: oPushResult
11191: oNodeGetLabel
11192: oPop 2
11194: oPushResult
11195: oEmitLabel
11196: oPop 1
11198: oReturn
11199: oLocalSpace 0
11201: oCall 9485
11203: oInputChoice 11213
11205: oCall 9485
11207: oJumpForward 11219
11209: oJumpForward 11221
11211: oJumpForward 11219
11213: Choice Lookup Table
          37   11209
           6   11205
11218: oEndChoice
11219: oJumpBack 11203
11221: oReturn
11222: oLocalSpace 0
11224: oCall 11229
11226: oEmit 100
11228: oReturn
11229: oLocalSpace 0
11231: oInputChoice 11355
11233: oCall 5029
11235: oTypeSNodeType
11236: oChoice 11311
11238: oEmit 92
11240: oJumpForward 11336
11242: oEmit 93
11244: oJumpForward 11336
11246: oEmit 32
11248: oEmit 92
11250: oJumpForward 11336
11252: oEmit 94
11254: oJumpForward 11336
11256: oEmit 99
11258: oJumpForward 11336
11260: oEmit 95
11262: oJumpForward 11336
11264: oError 17
11266: oJumpForward 11336
11268: oEmit 17
11270: oTypeSTop
11271: oPushResult
11272: oSetResult 44
11274: oPushResult
11275: oNodeGetInt
11276: oPop 2
11278: oPushResult
11279: oEmitInt
11280: oPop 1
11282: oEmit 98
11284: oJumpForward 11336
11286: oTypeSTop
11287: oPushResult
11288: oGetGlobal 10
11290: oPushResult
11291: equal_node
11292: oPop 2
11294: oChoice 11300
11296: oEmit 96
11298: oJumpForward 11305
11300: Choice Lookup Table
           1   11296
11303: oEmit 97
11305: oJumpForward 11336
11307: oEmit 97
11309: oJumpForward 11336
11311: Choice Lookup Table
          38   11307
          37   11286
          44   11268
          29   11264
          42   11260
          43   11260
          33   11256
          36   11252
          30   11246
          34   11242
          31   11238
11334: oError 18
11336: oTypeSPop
11337: oInputChoice 11345
11339: oJumpForward 11353
11341: oJumpForward 11351
11343: oJumpForward 11351
11345: Choice Lookup Table
          14   11343
          16   11339
11350: oEndChoice
11351: oJumpBack 11233
11353: oJumpForward 11358
11355: Choice Lookup Table
          15   11233
11358: oReturn
11359: oLocalSpace 0
11361: oCall 11366
11363: oEmit 104
11365: oReturn
11366: oLocalSpace 1
11368: oInputChoice 11445
11370: oSetResult 1
11372: oPushResult
11373: oCall 9939
11375: oPop 1
11377: oTypeSNodeType
11378: oChoice 11417
11380: oEmit 101
11382: oJumpForward 11426
11384: oEmit 102
11386: oJumpForward 11426
11388: oGetAddrLocal 1
11390: oPushResult
11391: oTypeSTop
11392: oPushResult
11393: oSetResult 17
11395: oPushResult
11396: oNodeGetInt
11397: oPop 2
11399: oPushResult
11400: oSetResult 1
11402: oPushResult
11403: subtract
11404: oPop 2
11406: oAssign
11407: oEmit 103
11409: oGetLocal 1
11411: oPushResult
11412: oEmitInt
11413: oPop 1
11415: oJumpForward 11426
11417: Choice Lookup Table
          43   11388
          36   11384
          31   11380
11424: oError 18
11426: oTypeSPop
11427: oInputChoice 11435
11429: oJumpForward 11443
11431: oJumpForward 11441
11433: oJumpForward 11441
11435: Choice Lookup Table
          14   11433
          16   11429
11440: oEndChoice
11441: oJumpBack 11370
11443: oJumpForward 11448
11445: Choice Lookup Table
          15   11370
11448: oReturn
11449: oLocalSpace 1
11451: oGetAddrLocal 1
11453: oPushResult
11454: oGetGlobal 16
11456: oPushResult
11457: oScopeAllocType
11458: oPop 1
11460: oAssign
11461: oTypeSNodeType
11462: oChoice 11530
11464: oEmit 18
11466: oGetLocal 1
11468: oPushResult
11469: oEmitInt
11470: oPop 1
11472: oEmit 23
11474: oEmit 31
11476: oGetGlobal 16
11478: oPushResult
11479: oSetResult 17
11481: oPushResult
11482: oNodeGetInt
11483: oPop 2
11485: oPushResult
11486: oEmitInt
11487: oPop 1
11489: oJumpForward 11539
11491: oEmit 18
11493: oGetLocal 1
11495: oPushResult
11496: oEmitInt
11497: oPop 1
11499: oEmit 15
11501: oSetResult 1
11503: oPushResult
11504: oEmitInt
11505: oPop 1
11507: oEmit 28
11509: oEmit 18
11511: oGetLocal 1
11513: oPushResult
11514: oSetResult 1
11516: oPushResult
11517: add
11518: oPop 2
11520: oPushResult
11521: oEmitInt
11522: oPop 1
11524: oEmit 23
11526: oEmit 28
11528: oJumpForward 11539
11530: Choice Lookup Table
          36   11491
          42   11464
          43   11464
11537: oError 15
11539: oTypeSPop
11540: oEmit 18
11542: oGetLocal 1
11544: oPushResult
11545: oEmitInt
11546: oPop 1
11548: oGetGlobal 16
11550: oPushResult
11551: oTypeSPush
11552: oPop 1
11554: oGetLocal 1
11556: oReturn
11557: oReturn
11558: oLocalSpace 0
11560: oEmit 73
11562: oSetResult 16
11564: oPushResult
11565: oEmitInt
11566: oPop 1
11568: oEmit 20
11570: oSetResult 8
11572: oPushResult
11573: oEmitInt
11574: oPop 1
11576: oEmit 23
11578: oEmit 29
11580: oEmit 20
11582: oSetResult 0
11584: oPushResult
11585: oEmitInt
11586: oPop 1
11588: oEmit 23
11590: oEmit 29
11592: oEmit 76
11594: oGetGlobal 22
11596: oPushResult
11597: oCall 14800
11599: oPop 1
11601: oEmit 75
11603: oSetResult 16
11605: oPushResult
11606: oEmitInt
11607: oPop 1
11609: oTypeSPop
11610: oTypeSPop
11611: oReturn
11612: oLocalSpace 0
11614: oEmit 73
11616: oSetResult 12
11618: oPushResult
11619: oEmitInt
11620: oPop 1
11622: oEmit 20
11624: oSetResult 8
11626: oPushResult
11627: oEmitInt
11628: oPop 1
11630: oEmit 23
11632: oEmit 28
11634: oEmit 20
11636: oSetResult 0
11638: oPushResult
11639: oEmitInt
11640: oPop 1
11642: oEmit 23
11644: oEmit 29
11646: oEmit 76
11648: oGetGlobal 23
11650: oPushResult
11651: oCall 14800
11653: oPop 1
11655: oEmit 75
11657: oSetResult 12
11659: oPushResult
11660: oEmitInt
11661: oPop 1
11663: oTypeSPop
11664: oTypeSPop
11665: oReturn
11666: oLocalSpace 1
11668: oEmit 74
11670: oSetResult 24
11672: oPushResult
11673: oEmitInt
11674: oPop 1
11676: oEmit 20
11678: oSetResult 8
11680: oPushResult
11681: oEmitInt
11682: oPop 1
11684: oEmit 23
11686: oEmit 29
11688: oEmit 20
11690: oSetResult 0
11692: oPushResult
11693: oEmitInt
11694: oPop 1
11696: oEmit 23
11698: oEmit 29
11700: oGetAddrLocal 1
11702: oPushResult
11703: oGetGlobal 6
11705: oPushResult
11706: oScopeAllocType
11707: oPop 1
11709: oAssign
11710: oEmit 20
11712: oSetResult 16
11714: oPushResult
11715: oEmitInt
11716: oPop 1
11718: oEmit 18
11720: oGetLocal 1
11722: oPushResult
11723: oEmitInt
11724: oPop 1
11726: oEmit 29
11728: oEmit 77
11730: oGetGlobal 24
11732: oPushResult
11733: oCall 14800
11735: oPop 1
11737: oEmit 3
11739: oGetLocal 1
11741: oPushResult
11742: oEmitInt
11743: oPop 1
11745: oEmit 75
11747: oSetResult 24
11749: oPushResult
11750: oEmitInt
11751: oPop 1
11753: oTypeSPop
11754: oGetGlobal 6
11756: oPushResult
11757: oTypeSPush
11758: oPop 1
11760: oReturn
11761: oLocalSpace 10
11763: oGetParam 1
11765: oPushResult
11766: oSetResult 28
11768: oPushResult
11769: oSetResult 1
11771: oPushResult
11772: oNodeSetBoolean
11773: oPop 3
11775: oGetAddrLocal 1
11777: oPushResult
11778: oGetParam 1
11780: oPushResult
11781: oSetResult 27
11783: oPushResult
11784: oNodeGetBoolean
11785: oPop 2
11787: oAssign
11788: oGetAddrLocal 4
11790: oPushResult
11791: oGetParam 1
11793: oPushResult
11794: oNodeType
11795: oPop 1
11797: oPushResult
11798: oSetResult 13
11800: oPushResult
11801: equal_node_type
11802: oPop 2
11804: oAssign
11805: oGetLocal 4
11807: oChoice 11834
11809: oGetAddrLocal 2
11811: oPushResult
11812: oGetParam 1
11814: oPushResult
11815: oSetResult 21
11817: oPushResult
11818: oNodeGet
11819: oPop 2
11821: oAssign
11822: oGetAddrLocal 3
11824: oPushResult
11825: oGetLocal 2
11827: oPushResult
11828: oScopeAllocType
11829: oPop 1
11831: oAssign
11832: oJumpForward 11837
11834: Choice Lookup Table
           1   11809
11837: oGetAddrLocal 5
11839: oPushResult
11840: oGetParam 1
11842: oPushResult
11843: oSetResult 23
11845: oPushResult
11846: oNodeGet
11847: oPop 2
11849: oAssign
11850: oGetAddrLocal 6
11852: oPushResult
11853: oGetLocal 5
11855: oPushResult
11856: oSetResult 17
11858: oPushResult
11859: oNodeGetInt
11860: oPop 2
11862: oAssign
11863: oGetLocal 1
11865: oChoice 11887
11867: oEmit 74
11869: oGetLocal 6
11871: oPushResult
11872: oEmitInt
11873: oPop 1
11875: oJumpForward 11893
11877: oEmit 73
11879: oGetLocal 6
11881: oPushResult
11882: oEmitInt
11883: oPop 1
11885: oJumpForward 11893
11887: Choice Lookup Table
           0   11877
           1   11867
11892: oEndChoice
11893: oGetParam 1
11895: oPushResult
11896: oCall 14734
11898: oPop 1
11900: oPushResult
11901: oSetResult 0
11903: oPushResult
11904: greater
11905: oPop 2
11907: oChoice 11940
11909: oEmit 20
11911: oSetResult 0
11913: oPushResult
11914: oEmitInt
11915: oPop 1
11917: oEmit 21
11919: oGetParam 1
11921: oPushResult
11922: oCall 14754
11924: oPop 1
11926: oPushResult
11927: oEmitInt
11928: oPop 1
11930: oSetResult 0
11932: oPushResult
11933: oEmitInt
11934: oPop 1
11936: oEmit 29
11938: oJumpForward 11943
11940: Choice Lookup Table
           1   11909
11943: oGetAddrLocal 7
11945: oPushResult
11946: oGetLocal 5
11948: oPushResult
11949: oSetResult 15
11951: oPushResult
11952: oNodeGetIter
11953: oPop 2
11955: oAssign
11956: oGetAddrLocal 8
11958: oPushResult
11959: oGetLocal 7
11961: oPushResult
11962: oNodeIterValue
11963: oPop 1
11965: oAssign
11966: oInputChoice 12169
11968: oGetLocal 8
11970: oPushResult
11971: oNodeNull
11972: oPop 1
11974: oChoice 11980
11976: oJumpForward 12165
11978: oJumpForward 11983
11980: Choice Lookup Table
           1   11976
11983: oGetAddrLocal 9
11985: oPushResult
11986: oGetLocal 8
11988: oPushResult
11989: oSetResult 22
11991: oPushResult
11992: oNodeGetInt
11993: oPop 2
11995: oAssign
11996: oEmit 20
11998: oGetLocal 9
12000: oPushResult
12001: oEmitInt
12002: oPop 1
12004: oGetLocal 8
12006: oPushResult
12007: oSetResult 21
12009: oPushResult
12010: oNodeGet
12011: oPop 2
12013: oPushResult
12014: oTypeSPush
12015: oPop 1
12017: oGetLocal 8
12019: oPushResult
12020: oSetResult 35
12022: oPushResult
12023: oNodeGetBoolean
12024: oPop 2
12026: oChoice 12118
12028: oSetResult 1
12030: oPushResult
12031: oCall 9939
12033: oPop 1
12035: oCall 9265
12037: oEmit 29
12039: oJumpForward 12124
12041: oCall 5029
12043: oCall 8627
12045: oTypeSNodeType
12046: oChoice 12090
12048: oEmit 27
12050: oJumpForward 12116
12052: oEmit 28
12054: oJumpForward 12116
12056: oEmit 30
12058: oJumpForward 12116
12060: oError 17
12062: oJumpForward 12116
12064: oEmit 29
12066: oJumpForward 12116
12068: oGetAddrLocal 10
12070: oPushResult
12071: oTypeSTop
12072: oPushResult
12073: oSetResult 17
12075: oPushResult
12076: oNodeGetInt
12077: oPop 2
12079: oAssign
12080: oEmit 31
12082: oGetLocal 10
12084: oPushResult
12085: oEmitInt
12086: oPop 1
12088: oJumpForward 12116
12090: Choice Lookup Table
          43   12068
          41   12068
          39   12068
          38   12064
          37   12064
          29   12060
          33   12056
          36   12052
          30   12052
          34   12052
          44   12048
          31   12048
12115: oEndChoice
12116: oJumpForward 12124
12118: Choice Lookup Table
           0   12041
           1   12028
12123: oEndChoice
12124: oTypeSPop
12125: oGetAddrLocal 7
12127: oPushResult
12128: oNodeIterNext
12129: oPop 1
12131: oGetAddrLocal 8
12133: oPushResult
12134: oGetLocal 7
12136: oPushResult
12137: oNodeIterValue
12138: oPop 1
12140: oAssign
12141: oGetLocal 8
12143: oPushResult
12144: oNodeNull
12145: oPop 1
12147: oChoice 12155
12149: oJumpForward 12165
12151: oJumpForward 12161
12153: oJumpForward 12161
12155: Choice Lookup Table
           0   12153
           1   12149
12160: oEndChoice
12161: oInput 14
12163: oJumpBack 11968
12165: oInput 16
12167: oJumpForward 12172
12169: Choice Lookup Table
          15   11968
12172: oGetLocal 8
12174: oPushResult
12175: oNodeNull
12176: oPop 1
12178: oChoice 12184
12180: oError 16
12182: oJumpForward 12187
12184: Choice Lookup Table
           0   12180
12187: oGetLocal 4
12189: oChoice 12218
12191: oEmit 20
12193: oGetParam 1
12195: oPushResult
12196: oSetResult 31
12198: oPushResult
12199: oNodeGetInt
12200: oPop 2
12202: oPushResult
12203: oEmitInt
12204: oPop 1
12206: oEmit 18
12208: oGetLocal 3
12210: oPushResult
12211: oEmitInt
12212: oPop 1
12214: oEmit 29
12216: oJumpForward 12221
12218: Choice Lookup Table
           1   12191
12221: oGetLocal 1
12223: oChoice 12247
12225: oEmit 77
12227: oGetParam 1
12229: oPushResult
12230: oCall 14800
12232: oPop 1
12234: oJumpForward 12253
12236: oEmit 76
12238: oGetParam 1
12240: oPushResult
12241: oCall 14800
12243: oPop 1
12245: oJumpForward 12253
12247: Choice Lookup Table
           0   12236
           1   12225
12252: oEndChoice
12253: oGetLocal 4
12255: oChoice 12336
12257: oGetLocal 2
12259: oPushResult
12260: oTypeSPush
12261: oPop 1
12263: oTypeSNodeType
12264: oChoice 12310
12266: oEmit 3
12268: oGetLocal 3
12270: oPushResult
12271: oEmitInt
12272: oPop 1
12274: oJumpForward 12334
12276: oEmit 4
12278: oGetLocal 3
12280: oPushResult
12281: oEmitInt
12282: oPop 1
12284: oJumpForward 12334
12286: oError 17
12288: oJumpForward 12334
12290: oEmit 5
12292: oGetLocal 3
12294: oPushResult
12295: oEmitInt
12296: oPop 1
12298: oJumpForward 12334
12300: oEmit 18
12302: oGetLocal 3
12304: oPushResult
12305: oEmitInt
12306: oPop 1
12308: oJumpForward 12334
12310: Choice Lookup Table
          43   12300
          41   12300
          39   12300
          38   12290
          37   12290
          29   12286
          36   12276
          30   12276
          34   12276
          44   12266
          31   12266
12333: oEndChoice
12334: oJumpForward 12339
12336: Choice Lookup Table
           1   12257
12339: oEmit 75
12341: oGetLocal 6
12343: oPushResult
12344: oEmitInt
12345: oPop 1
12347: oReturn
12348: oLocalSpace 2
12350: oGetAddrLocal 2
12352: oPushResult
12353: oGetParam 1
12355: oPushResult
12356: oSetResult 26
12358: oPushResult
12359: oNodeGetString
12360: oPop 2
12362: oAssign
12363: oGetLocal 2
12365: oPushResult
12366: oSetResult 0
12368: oPushResult
12369: equal_string
12370: oPop 2
12372: oChoice 12409
12374: oGetAddrLocal 1
12376: oPushResult
12377: oGetParam 1
12379: oPushResult
12380: oSetResult 4
12382: oPushResult
12383: oNodeGetInt
12384: oPop 2
12386: oPushResult
12387: ID_STRING
12388: oPop 1
12390: oPushResult
12391: oStringAllocLit
12392: oPop 1
12394: oAssign
12395: oJumpForward 12415
12397: oGetAddrLocal 1
12399: oPushResult
12400: oGetLocal 2
12402: oPushResult
12403: oStringAllocLit
12404: oPop 1
12406: oAssign
12407: oJumpForward 12415
12409: Choice Lookup Table
           0   12397
           1   12374
12414: oEndChoice
12415: oEmit 91
12417: oGetParam 1
12419: oPushResult
12420: oCall 14800
12422: oPop 1
12424: oGetLocal 1
12426: oPushResult
12427: oEmitInt
12428: oPop 1
12430: oReturn
12431: oLocalSpace 2
12433: oGetParam 1
12435: oPushResult
12436: oGetGlobal 17
12438: oPushResult
12439: oNodeEqual
12440: oPop 2
12442: oChoice 12482
12444: oInput 15
12446: oCall 5029
12448: oTypeSNodeType
12449: oChoice 12457
12451: oJumpForward 12470
12453: oEmit 32
12455: oJumpForward 12470
12457: Choice Lookup Table
          36   12453
          30   12453
          34   12453
          44   12451
          31   12451
12468: oError 15
12470: oTypeSPop
12471: oGetGlobal 6
12473: oPushResult
12474: oTypeSPush
12475: oPop 1
12477: oInput 16
12479: oReturn
12480: oJumpForward 12485
12482: Choice Lookup Table
           1   12444
12485: oGetParam 1
12487: oPushResult
12488: oGetGlobal 18
12490: oPushResult
12491: oNodeEqual
12492: oPop 2
12494: oChoice 12528
12496: oInput 15
12498: oCall 5029
12500: oTypeSNodeType
12501: oChoice 12509
12503: oEmit 33
12505: oJumpForward 12516
12507: oJumpForward 12516
12509: Choice Lookup Table
          30   12507
          31   12503
12514: oError 15
12516: oTypeSPop
12517: oGetGlobal 9
12519: oPushResult
12520: oTypeSPush
12521: oPop 1
12523: oInput 16
12525: oReturn
12526: oJumpForward 12531
12528: Choice Lookup Table
           1   12496
12531: oGetParam 1
12533: oPushResult
12534: oGetGlobal 19
12536: oPushResult
12537: oNodeEqual
12538: oPop 2
12540: oChoice 12580
12542: oInput 15
12544: oCall 5029
12546: oTypeSNodeType
12547: oChoice 12568
12549: oTypeSTop
12550: oPushResult
12551: oSetResult 45
12553: oPushResult
12554: oNodeGetBoolean
12555: oPop 2
12557: oChoice 12563
12559: oError 29
12561: oJumpForward 12566
12563: Choice Lookup Table
           1   12559
12566: oJumpForward 12573
12568: Choice Lookup Table
          44   12549
12571: oError 15
12573: oEmit 36
12575: oInput 16
12577: oReturn
12578: oJumpForward 12583
12580: Choice Lookup Table
           1   12542
12583: oGetParam 1
12585: oPushResult
12586: oGetGlobal 20
12588: oPushResult
12589: oNodeEqual
12590: oPop 2
12592: oChoice 12632
12594: oInput 15
12596: oCall 5029
12598: oTypeSNodeType
12599: oChoice 12620
12601: oTypeSTop
12602: oPushResult
12603: oSetResult 45
12605: oPushResult
12606: oNodeGetBoolean
12607: oPop 2
12609: oChoice 12615
12611: oError 29
12613: oJumpForward 12618
12615: Choice Lookup Table
           1   12611
12618: oJumpForward 12625
12620: Choice Lookup Table
          44   12601
12623: oError 15
12625: oEmit 35
12627: oInput 16
12629: oReturn
12630: oJumpForward 12635
12632: Choice Lookup Table
           1   12594
12635: oGetParam 1
12637: oPushResult
12638: oGetGlobal 21
12640: oPushResult
12641: oNodeEqual
12642: oPop 2
12644: oChoice 12700
12646: oInput 15
12648: oGetAddrLocal 1
12650: oPushResult
12651: oCodeNew
12652: oAssign
12653: oGetLocal 1
12655: oPushResult
12656: oCodePush
12657: oPop 1
12659: oCall 5052
12661: oCodePop
12662: oGetLocal 1
12664: oPushResult
12665: oCodeDiscard
12666: oPop 1
12668: oGetAddrLocal 2
12670: oPushResult
12671: oTypeSTop
12672: oAssign
12673: oTypeSPop
12674: oEmit 15
12676: oGetLocal 2
12678: oPushResult
12679: oSetResult 17
12681: oPushResult
12682: oNodeGetInt
12683: oPop 2
12685: oPushResult
12686: oEmitInt
12687: oPop 1
12689: oGetGlobal 6
12691: oPushResult
12692: oTypeSPush
12693: oPop 1
12695: oInput 16
12697: oReturn
12698: oJumpForward 12703
12700: Choice Lookup Table
           1   12646
12703: oError 17
12705: oReturn
12706: oLocalSpace 1
12708: oGetAddrLocal 1
12710: oPushResult
12711: oGetParam 2
12713: oPushResult
12714: oNodeNew
12715: oPop 1
12717: oAssign
12718: oGetLocal 1
12720: oPushResult
12721: oSetResult 17
12723: oPushResult
12724: oGetParam 1
12726: oPushResult
12727: oNodeSetInt
12728: oPop 3
12730: oGetLocal 1
12732: oPushResult
12733: oTypeAdd
12734: oPop 1
12736: oGetLocal 1
12738: oReturn
12739: oReturn
12740: oLocalSpace 12
12742: oInputChoice 13225
12744: oGetAddrLocal 1
12746: oPushResult
12747: oScopeFindRequire
12748: oAssign
12749: oGetAddrLocal 1
12751: oPushResult
12752: oCall 244
12754: oPop 1
12756: oGetLocal 1
12758: oPushResult
12759: oNodeType
12760: oPop 1
12762: oChoice 12779
12764: oGetParam 1
12766: oPushResult
12767: oGetLocal 1
12769: oPushResult
12770: oSetResult 21
12772: oPushResult
12773: oNodeGet
12774: oPop 2
12776: oAssign
12777: oJumpForward 12790
12779: Choice Lookup Table
          20   12764
12782: oError 2
12784: oGetParam 1
12786: oPushResult
12787: oGetGlobal 6
12789: oAssign
12790: oJumpForward 13248
12792: oInput 17
12794: oGetAddrLocal 2
12796: oPushResult
12797: oNodeVecNew
12798: oAssign
12799: oGetAddrLocal 3
12801: oPushResult
12802: oSetResult 40
12804: oPushResult
12805: oNodeNew
12806: oPop 1
12808: oAssign
12809: oCall 3568
12811: oGetLocal 3
12813: oPushResult
12814: oSetResult 40
12816: oPushResult
12817: oValueTop
12818: oPushResult
12819: oNodeSetInt
12820: oPop 3
12822: oValuePop
12823: oInput 22
12825: oCall 3568
12827: oGetLocal 3
12829: oPushResult
12830: oSetResult 41
12832: oPushResult
12833: oValueTop
12834: oPushResult
12835: oNodeSetInt
12836: oPop 3
12838: oValuePop
12839: oCall 4363
12841: oGetLocal 3
12843: oPushResult
12844: oSetResult 38
12846: oPushResult
12847: oTypeSTop
12848: oPushResult
12849: oNodeSet
12850: oPop 3
12852: oGetLocal 3
12854: oPushResult
12855: oSetResult 17
12857: oPushResult
12858: oTypeSTop
12859: oPushResult
12860: oSetResult 17
12862: oPushResult
12863: oNodeGetInt
12864: oPop 2
12866: oPushResult
12867: oNodeSetInt
12868: oPop 3
12870: oTypeSPop
12871: oGetLocal 3
12873: oPushResult
12874: oTypeAdd
12875: oPop 1
12877: oGetAddrLocal 4
12879: oPushResult
12880: oSetResult 39
12882: oPushResult
12883: oNodeNew
12884: oPop 1
12886: oAssign
12887: oGetLocal 4
12889: oPushResult
12890: oSetResult 39
12892: oPushResult
12893: oGetLocal 3
12895: oPushResult
12896: oNodeSet
12897: oPop 3
12899: oGetLocal 2
12901: oPushResult
12902: oGetLocal 4
12904: oPushResult
12905: oNodeVecAppend
12906: oPop 2
12908: oInputChoice 12916
12910: oJumpForward 12924
12912: oJumpForward 12922
12914: oJumpForward 12922
12916: Choice Lookup Table
          14   12914
          18   12910
12921: oEndChoice
12922: oJumpBack 12799
12924: oInput 41
12926: oGetAddrLocal 5
12928: oPushResult
12929: oCall 12740
12931: oPop 1
12933: oGetAddrLocal 6
12935: oPushResult
12936: oGetLocal 2
12938: oPushResult
12939: oNodeVecSize
12940: oPop 1
12942: oAssign
12943: oGetAddrLocal 6
12945: oPushResult
12946: dec
12947: oPop 1
12949: oGetAddrLocal 7
12951: oPushResult
12952: oGetLocal 2
12954: oPushResult
12955: oGetLocal 6
12957: oPushResult
12958: oNodeVecElement
12959: oPop 2
12961: oAssign
12962: oGetLocal 7
12964: oPushResult
12965: oSetResult 38
12967: oPushResult
12968: oGetLocal 5
12970: oPushResult
12971: oNodeSet
12972: oPop 3
12974: oGetAddrLocal 8
12976: oPushResult
12977: oGetLocal 7
12979: oPushResult
12980: oSetResult 39
12982: oPushResult
12983: oNodeGet
12984: oPop 2
12986: oAssign
12987: oGetAddrLocal 9
12989: oPushResult
12990: oGetLocal 8
12992: oPushResult
12993: oSetResult 41
12995: oPushResult
12996: oNodeGetInt
12997: oPop 2
12999: oPushResult
13000: oGetLocal 8
13002: oPushResult
13003: oSetResult 40
13005: oPushResult
13006: oNodeGetInt
13007: oPop 2
13009: oPushResult
13010: subtract
13011: oPop 2
13013: oAssign
13014: oGetAddrLocal 9
13016: oPushResult
13017: inc
13018: oPop 1
13020: oGetLocal 7
13022: oPushResult
13023: oSetResult 17
13025: oPushResult
13026: oGetLocal 9
13028: oPushResult
13029: oGetLocal 5
13031: oPushResult
13032: oSetResult 17
13034: oPushResult
13035: oNodeGetInt
13036: oPop 2
13038: oPushResult
13039: multiply
13040: oPop 2
13042: oPushResult
13043: oNodeSetInt
13044: oPop 3
13046: oGetLocal 7
13048: oPushResult
13049: oTypeAdd
13050: oPop 1
13052: oGetAddrLocal 5
13054: oPushResult
13055: oGetLocal 7
13057: oAssign
13058: oGetLocal 6
13060: oPushResult
13061: equal_zero
13062: oPop 1
13064: oChoice 13070
13066: oJumpForward 13075
13068: oJumpForward 13073
13070: Choice Lookup Table
           1   13066
13073: oJumpBack 12943
13075: oGetParam 1
13077: oPushResult
13078: oGetLocal 2
13080: oPushResult
13081: oSetResult 0
13083: oPushResult
13084: oNodeVecElement
13085: oPop 2
13087: oAssign
13088: oGetLocal 2
13090: oPushResult
13091: oNodeVecDelete
13092: oPop 1
13094: oJumpForward 13248
13096: oGetAddrLocal 10
13098: oPushResult
13099: oCall 12740
13101: oPop 1
13103: oGetParam 1
13105: oPushResult
13106: oGetLocal 10
13108: oPushResult
13109: oCall 13819
13111: oPop 1
13113: oAssign
13114: oJumpForward 13248
13116: oGetParam 1
13118: oPushResult
13119: oSetResult 41
13121: oPushResult
13122: oNodeNew
13123: oPop 1
13125: oAssign
13126: oSetResult -1
13128: oPushResult
13129: oSetResult 2
13131: oPushResult
13132: oScopeBegin
13133: oPop 2
13135: oSetResult 24
13137: oPushResult
13138: oCall 3269
13140: oPop 1
13142: oGetAddrLocal 11
13144: oPushResult
13145: oScopeCurrent
13146: oPushResult
13147: oSetResult 17
13149: oPushResult
13150: oNodeGetInt
13151: oPop 2
13153: oAssign
13154: oGetLocal 11
13156: oPushResult
13157: equal_zero
13158: oPop 1
13160: oChoice 13166
13162: oError 20
13164: oJumpForward 13169
13166: Choice Lookup Table
           1   13162
13169: oInput 37
13171: oGetFromParam 1
13173: oPushResult
13174: oSetResult 42
13176: oPushResult
13177: oScopeCurrent
13178: oPushResult
13179: oNodeSet
13180: oPop 3
13182: oGetFromParam 1
13184: oPushResult
13185: oSetResult 17
13187: oPushResult
13188: oGetLocal 11
13190: oPushResult
13191: oNodeSetInt
13192: oPop 3
13194: oScopeEnd
13195: oGetFromParam 1
13197: oPushResult
13198: oTypeAdd
13199: oPop 1
13201: oJumpForward 13248
13203: oGetParam 1
13205: oPushResult
13206: oCall 13249
13208: oPop 1
13210: oJumpForward 13248
13212: oInput 41
13214: oGetAddrLocal 12
13216: oPushResult
13217: oCall 12740
13219: oPop 1
13221: oError 17
13223: oJumpForward 13248
13225: Choice Lookup Table
          40   13212
          15   13203
          39   13116
          19   13096
          38   12792
           0   12744
13238: oCall 3568
13240: oInput 22
13242: oCall 3568
13244: oCall 4363
13246: oError 17
13248: oReturn
13249: oLocalSpace 11
13251: oGetParam 1
13253: oPushResult
13254: oSetResult 44
13256: oPushResult
13257: oNodeNew
13258: oPop 1
13260: oAssign
13261: oGetAddrLocal 1
13263: oPushResult
13264: oSetResult 0
13266: oAssign
13267: oGetAddrLocal 2
13269: oPushResult
13270: oSetResult 0
13272: oAssign
13273: oGetAddrLocal 3
13275: oPushResult
13276: oSetResult 1
13278: oAssign
13279: oGetAddrLocal 4
13281: oPushResult
13282: oScopeCurrent
13283: oAssign
13284: oSetResult -1
13286: oPushResult
13287: oSetResult 2
13289: oPushResult
13290: oScopeBegin
13291: oPop 2
13293: oInput 0
13295: oGetAddrLocal 5
13297: oPushResult
13298: oSetResult 17
13300: oPushResult
13301: LAST_ID
13302: oPushResult
13303: oCall 14772
13305: oPop 2
13307: oAssign
13308: oGetAddrLocal 6
13310: oPushResult
13311: oSetResult 17
13313: oPushResult
13314: LAST_ID
13315: oPushResult
13316: oCall 14772
13318: oPop 2
13320: oAssign
13321: oGetLocal 5
13323: oPushResult
13324: oSetResult 21
13326: oPushResult
13327: oGetFromParam 1
13329: oPushResult
13330: oNodeSet
13331: oPop 3
13333: oGetLocal 6
13335: oPushResult
13336: oSetResult 21
13338: oPushResult
13339: oGetFromParam 1
13341: oPushResult
13342: oNodeSet
13343: oPop 3
13345: oGetAddrLocal 7
13347: oPushResult
13348: LAST_ID
13349: oPushResult
13350: ID_STRING
13351: oPop 1
13353: oPushResult
13354: oStringAllocLit
13355: oPop 1
13357: oAssign
13358: oGetLocal 5
13360: oPushResult
13361: oSetResult 32
13363: oPushResult
13364: oGetLocal 7
13366: oPushResult
13367: oNodeSetInt
13368: oPop 3
13370: oGetLocal 6
13372: oPushResult
13373: oSetResult 32
13375: oPushResult
13376: oGetLocal 7
13378: oPushResult
13379: oNodeSetInt
13380: oPop 3
13382: oInputChoice 13460
13384: oGetGlobal 6
13386: oPushResult
13387: oTypeSPush
13388: oPop 1
13390: oCall 3568
13392: oCall 4460
13394: oTypeSPop
13395: oGetLocal 2
13397: oPushResult
13398: equal_zero
13399: oPop 1
13401: oChoice 13422
13403: oValueTop
13404: oPushResult
13405: oGetLocal 1
13407: oPushResult
13408: greater
13409: oPop 2
13411: oChoice 13417
13413: oError 27
13415: oJumpForward 13420
13417: Choice Lookup Table
           0   13413
13420: oJumpForward 13425
13422: Choice Lookup Table
           0   13403
13425: oGetLocal 1
13427: oPushResult
13428: oValueTop
13429: oPushResult
13430: equal
13431: oPop 2
13433: oChoice 13449
13435: oGetFromParam 1
13437: oPushResult
13438: oSetResult 45
13440: oPushResult
13441: oSetResult 1
13443: oPushResult
13444: oNodeSetBoolean
13445: oPop 3
13447: oJumpForward 13452
13449: Choice Lookup Table
           0   13435
13452: oGetAddrLocal 1
13454: oPushResult
13455: oValueTop
13456: oAssign
13457: oValuePop
13458: oJumpForward 13465
13460: Choice Lookup Table
           5   13384
           7   13384
13465: oGetLocal 5
13467: oPushResult
13468: oSetResult 22
13470: oPushResult
13471: oGetLocal 1
13473: oPushResult
13474: oNodeSetInt
13475: oPop 3
13477: oGetLocal 6
13479: oPushResult
13480: oSetResult 22
13482: oPushResult
13483: oGetLocal 1
13485: oPushResult
13486: oNodeSetInt
13487: oPop 3
13489: oGetLocal 5
13491: oPushResult
13492: oScopeDeclare
13493: oPop 1
13495: oGetLocal 4
13497: oPushResult
13498: oScopeEnter
13499: oPop 1
13501: oGetLocal 6
13503: oPushResult
13504: oScopeDeclare
13505: oPop 1
13507: oScopeEnd
13508: oGetAddrLocal 1
13510: oPushResult
13511: inc
13512: oPop 1
13514: oGetAddrLocal 2
13516: oPushResult
13517: inc
13518: oPop 1
13520: oInputChoice 13524
13522: oJumpForward 13529
13524: Choice Lookup Table
          14   13522
13527: oJumpForward 13531
13529: oJumpBack 13293
13531: oInput 16
13533: oGetFromParam 1
13535: oPushResult
13536: oSetResult 42
13538: oPushResult
13539: oScopeCurrent
13540: oPushResult
13541: oNodeSet
13542: oPop 3
13544: oGetFromParam 1
13546: oPushResult
13547: oSetResult 17
13549: oPushResult
13550: oSetResult 4
13552: oPushResult
13553: oNodeSetInt
13554: oPop 3
13556: oScopeEnd
13557: oGetGlobal 2
13559: oPushResult
13560: oCall 14670
13562: oPop 1
13564: oPushResult
13565: oCodePush
13566: oPop 1
13568: oGetGlobal 2
13570: oPushResult
13571: oScopeEnter
13572: oPop 1
13574: oGetAddrLocal 8
13576: oPushResult
13577: oGetLocal 2
13579: oPushResult
13580: oSetResult 1
13582: oPushResult
13583: add
13584: oPop 2
13586: oPushResult
13587: oSetResult 16
13589: oPushResult
13590: multiply
13591: oPop 2
13593: oAssign
13594: oGetAddrLocal 9
13596: oPushResult
13597: oGetLocal 8
13599: oPushResult
13600: oSetResult 8
13602: oPushResult
13603: oScopeAlloc
13604: oPop 2
13606: oAssign
13607: oScopeEnd
13608: oGetFromParam 1
13610: oPushResult
13611: oSetResult 44
13613: oPushResult
13614: oGetLocal 9
13616: oPushResult
13617: oNodeSetInt
13618: oPop 3
13620: oGetAddrLocal 10
13622: oPushResult
13623: oGetFromParam 1
13625: oPushResult
13626: oSetResult 42
13628: oPushResult
13629: oNodeGet
13630: oPop 2
13632: oPushResult
13633: oSetResult 15
13635: oPushResult
13636: oNodeGetIter
13637: oPop 2
13639: oAssign
13640: oGetAddrLocal 11
13642: oPushResult
13643: oGetLocal 10
13645: oPushResult
13646: oNodeIterValue
13647: oPop 1
13649: oAssign
13650: oGetLocal 11
13652: oPushResult
13653: oNodeNull
13654: oPop 1
13656: oChoice 13662
13658: oJumpForward 13749
13660: oJumpForward 13665
13662: Choice Lookup Table
           1   13658
13665: oEmit 17
13667: oGetLocal 9
13669: oPushResult
13670: oEmitInt
13671: oPop 1
13673: oEmit 15
13675: oGetLocal 11
13677: oPushResult
13678: oSetResult 22
13680: oPushResult
13681: oNodeGetInt
13682: oPop 2
13684: oPushResult
13685: oEmitInt
13686: oPop 1
13688: oEmit 27
13690: oGetAddrLocal 9
13692: oPushResult
13693: oGetLocal 9
13695: oPushResult
13696: oSetResult 8
13698: oPushResult
13699: add
13700: oPop 2
13702: oAssign
13703: oEmit 17
13705: oGetLocal 9
13707: oPushResult
13708: oEmitInt
13709: oPop 1
13711: oEmit 17
13713: oGetLocal 11
13715: oPushResult
13716: oSetResult 32
13718: oPushResult
13719: oNodeGetInt
13720: oPop 2
13722: oPushResult
13723: oEmitInt
13724: oPop 1
13726: oEmit 29
13728: oGetAddrLocal 9
13730: oPushResult
13731: oGetLocal 9
13733: oPushResult
13734: oSetResult 8
13736: oPushResult
13737: add
13738: oPop 2
13740: oAssign
13741: oGetAddrLocal 10
13743: oPushResult
13744: oNodeIterNext
13745: oPop 1
13747: oJumpBack 13640
13749: oEmit 17
13751: oGetLocal 9
13753: oPushResult
13754: oEmitInt
13755: oPop 1
13757: oEmit 15
13759: oSetResult 0
13761: oPushResult
13762: oEmitInt
13763: oPop 1
13765: oEmit 27
13767: oGetAddrLocal 9
13769: oPushResult
13770: oGetLocal 9
13772: oPushResult
13773: oSetResult 8
13775: oPushResult
13776: add
13777: oPop 2
13779: oAssign
13780: oEmit 17
13782: oGetLocal 9
13784: oPushResult
13785: oEmitInt
13786: oPop 1
13788: oEmit 15
13790: oSetResult 0
13792: oPushResult
13793: oEmitInt
13794: oPop 1
13796: oEmit 29
13798: oGetAddrLocal 9
13800: oPushResult
13801: oGetLocal 9
13803: oPushResult
13804: oSetResult 8
13806: oPushResult
13807: add
13808: oPop 2
13810: oAssign
13811: oCodePop
13812: oGetFromParam 1
13814: oPushResult
13815: oTypeAdd
13816: oPop 1
13818: oReturn
13819: oLocalSpace 1
13821: oGetAddrLocal 1
13823: oPushResult
13824: oGetParam 1
13826: oPushResult
13827: oSetResult 37
13829: oPushResult
13830: oNodeGet
13831: oPop 2
13833: oAssign
13834: oGetLocal 1
13836: oPushResult
13837: oNodeNull
13838: oPop 1
13840: oChoice 13896
13842: oGetAddrLocal 1
13844: oPushResult
13845: oSetResult 37
13847: oPushResult
13848: oNodeNew
13849: oPop 1
13851: oAssign
13852: oGetLocal 1
13854: oPushResult
13855: oSetResult 38
13857: oPushResult
13858: oGetParam 1
13860: oPushResult
13861: oNodeSet
13862: oPop 3
13864: oGetLocal 1
13866: oPushResult
13867: oSetResult 17
13869: oPushResult
13870: oSetResult 8
13872: oPushResult
13873: oNodeSetInt
13874: oPop 3
13876: oGetLocal 1
13878: oPushResult
13879: oTypeAdd
13880: oPop 1
13882: oGetParam 1
13884: oPushResult
13885: oSetResult 37
13887: oPushResult
13888: oGetLocal 1
13890: oPushResult
13891: oNodeSet
13892: oPop 3
13894: oJumpForward 13899
13896: Choice Lookup Table
           1   13842
13899: oGetLocal 1
13901: oReturn
13902: oReturn
13903: oLocalSpace 2
13905: oGetParam 1
13907: oPushResult
13908: oNodeType
13909: oPop 1
13911: oChoice 13981
13913: oMININT
13914: oReturn
13915: oJumpForward 13997
13917: oSetResult 0
13919: oReturn
13920: oJumpForward 13997
13922: oSetResult 0
13924: oReturn
13925: oJumpForward 13997
13927: oGetAddrLocal 1
13929: oPushResult
13930: oGetParam 1
13932: oPushResult
13933: oSetResult 42
13935: oPushResult
13936: oNodeGet
13937: oPop 2
13939: oAssign
13940: oGetAddrLocal 2
13942: oPushResult
13943: oGetLocal 1
13945: oPushResult
13946: oSetResult 15
13948: oPushResult
13949: oNodeGetIter
13950: oPop 2
13952: oPushResult
13953: oNodeIterValue
13954: oPop 1
13956: oAssign
13957: oGetLocal 2
13959: oPushResult
13960: oSetResult 22
13962: oPushResult
13963: oNodeGetInt
13964: oPop 2
13966: oReturn
13967: oJumpForward 13997
13969: oGetParam 1
13971: oPushResult
13972: oSetResult 40
13974: oPushResult
13975: oNodeGetInt
13976: oPop 2
13978: oReturn
13979: oJumpForward 13997
13981: Choice Lookup Table
          40   13969
          44   13927
          36   13922
          34   13917
          31   13913
13992: oError 3
13994: oSetResult 0
13996: oReturn
13997: oReturn
13998: oLocalSpace 2
14000: oGetParam 1
14002: oPushResult
14003: oNodeType
14004: oPop 1
14006: oChoice 14076
14008: oMAXINT
14009: oReturn
14010: oJumpForward 14092
14012: oSetResult 1
14014: oReturn
14015: oJumpForward 14092
14017: oSetResult 255
14019: oReturn
14020: oJumpForward 14092
14022: oGetAddrLocal 1
14024: oPushResult
14025: oGetParam 1
14027: oPushResult
14028: oSetResult 42
14030: oPushResult
14031: oNodeGet
14032: oPop 2
14034: oAssign
14035: oGetAddrLocal 2
14037: oPushResult
14038: oGetLocal 1
14040: oPushResult
14041: oSetResult 15
14043: oPushResult
14044: oNodeGetIterLast
14045: oPop 2
14047: oPushResult
14048: oNodeIterValue
14049: oPop 1
14051: oAssign
14052: oGetLocal 2
14054: oPushResult
14055: oSetResult 22
14057: oPushResult
14058: oNodeGetInt
14059: oPop 2
14061: oReturn
14062: oJumpForward 14092
14064: oGetParam 1
14066: oPushResult
14067: oSetResult 41
14069: oPushResult
14070: oNodeGetInt
14071: oPop 2
14073: oReturn
14074: oJumpForward 14092
14076: Choice Lookup Table
          40   14064
          44   14022
          36   14017
          34   14012
          31   14008
14087: oError 3
14089: oSetResult 0
14091: oReturn
14092: oReturn
14093: oLocalSpace 5
14095: oGetAddrGlobal 1
14097: oPushResult
14098: oWorkspaceNew
14099: oAssign
14100: oSetResult 0
14102: oPushResult
14103: oSetResult 0
14105: oPushResult
14106: oScopeBegin
14107: oPop 2
14109: oGetAddrLocal 2
14111: oPushResult
14112: oScopeCurrent
14113: oAssign
14114: oCall 14842
14116: oEmit 79
14118: oSetResult 0
14120: oPushResult
14121: oEmitInt
14122: oPop 1
14124: oGetAddrLocal 3
14126: oPushResult
14127: oLabelNew
14128: oAssign
14129: oEmit 73
14131: oSetResult 0
14133: oPushResult
14134: oEmitInt
14135: oPop 1
14137: oEmit 76
14139: oGetLocal 3
14141: oPushResult
14142: oEmitLabel
14143: oPop 1
14145: oEmit 75
14147: oSetResult 0
14149: oPushResult
14150: oEmitInt
14151: oPop 1
14153: oEmit 78
14155: oInput 29
14157: oInput 0
14159: oGetAddrLocal 4
14161: oPushResult
14162: oSetResult 4
14164: oPushResult
14165: oNodeNew
14166: oPop 1
14168: oAssign
14169: oGetLocal 4
14171: oPushResult
14172: oSetResult 4
14174: oPushResult
14175: LAST_ID
14176: oPushResult
14177: oNodeSetInt
14178: oPop 3
14180: oGetGlobal 1
14182: oPushResult
14183: oSetResult 2
14185: oPushResult
14186: oGetLocal 4
14188: oPushResult
14189: oNodeSet
14190: oPop 3
14192: oInputChoice 14266
14194: oInput 0
14196: oGetAddrLocal 1
14198: oPushResult
14199: oSetResult 21
14201: oPushResult
14202: LAST_ID
14203: oPushResult
14204: oCall 14772
14206: oPop 2
14208: oAssign
14209: oGetLocal 1
14211: oPushResult
14212: oSetResult 21
14214: oPushResult
14215: oGetGlobal 5
14217: oPushResult
14218: oNodeSet
14219: oPop 3
14221: oGetLocal 1
14223: oPushResult
14224: oScopeDeclareAlloc
14225: oPop 1
14227: oInput 14
14229: oInput 0
14231: oGetAddrLocal 1
14233: oPushResult
14234: oSetResult 21
14236: oPushResult
14237: LAST_ID
14238: oPushResult
14239: oCall 14772
14241: oPop 2
14243: oAssign
14244: oGetLocal 1
14246: oPushResult
14247: oSetResult 21
14249: oPushResult
14250: oGetGlobal 5
14252: oPushResult
14253: oNodeSet
14254: oPop 3
14256: oGetLocal 1
14258: oPushResult
14259: oScopeDeclareAlloc
14260: oPop 1
14262: oInput 16
14264: oJumpForward 14269
14266: Choice Lookup Table
          15   14194
14269: oInput 6
14271: oGetLocal 4
14273: oPushResult
14274: oCall 34
14276: oPop 1
14278: oInputChoice 14289
14280: oGetLocal 4
14282: oPushResult
14283: oCall 7
14285: oPop 1
14287: oJumpForward 14292
14289: Choice Lookup Table
          60   14280
14292: oGetLocal 4
14294: oPushResult
14295: oCall 287
14297: oPop 1
14299: oSetResult 0
14301: oPushResult
14302: oSetResult 0
14304: oPushResult
14305: oScopeBegin
14306: oPop 2
14308: oGetAddrGlobal 2
14310: oPushResult
14311: oScopeCurrent
14312: oAssign
14313: oSetResult 0
14315: oPushResult
14316: oSetResult 1
14318: oPushResult
14319: oScopeBegin
14320: oPop 2
14322: oScopeCurrent
14323: oPushResult
14324: oSetResult 16
14326: oPushResult
14327: oGetGlobal 2
14329: oPushResult
14330: oNodeSet
14331: oPop 3
14333: oGetAddrGlobal 3
14335: oPushResult
14336: oScopeCurrent
14337: oAssign
14338: oGetLocal 4
14340: oPushResult
14341: oSetResult 7
14343: oPushResult
14344: oGetGlobal 3
14346: oPushResult
14347: oNodeSet
14348: oPop 3
14350: oScopeEnd
14351: oSetResult 22
14353: oPushResult
14354: oCall 14421
14356: oPop 1
14358: oGetGlobal 3
14360: oPushResult
14361: oScopeEnter
14362: oPop 1
14364: oGetAddrLocal 5
14366: oPushResult
14367: oSetResult 1
14369: oAssign
14370: oGetLocal 3
14372: oPushResult
14373: oGetGlobal 2
14375: oPushResult
14376: oGetLocal 5
14378: oPushResult
14379: oCall 14572
14381: oPop 3
14383: oScopeEnd
14384: oInput 21
14386: oCall 14477
14388: oScopeEnd
14389: oGetLocal 4
14391: oPushResult
14392: oCall 349
14394: oPop 1
14396: oReturn
14397: oLocalSpace 0
14399: oGetParam 2
14401: oPushResult
14402: oCall 14421
14404: oPop 1
14406: oGetParam 1
14408: oPushResult
14409: oScopeCurrent
14410: oPushResult
14411: oSetResult 0
14413: oPushResult
14414: oCall 14572
14416: oPop 3
14418: oCall 14477
14420: oReturn
14421: oLocalSpace 0
14423: oInputChoice 14454
14425: oCall 2520
14427: oJumpForward 14469
14429: oCall 3213
14431: oJumpForward 14469
14433: oGetParam 1
14435: oPushResult
14436: oCall 3269
14438: oPop 1
14440: oJumpForward 14469
14442: oCall 3503
14444: oJumpForward 14469
14446: oCall 1743
14448: oJumpForward 14469
14450: oCall 2178
14452: oJumpForward 14469
14454: Choice Lookup Table
          31   14450
          30   14446
          35   14442
          34   14433
          33   14429
          32   14425
14467: oJumpForward 14471
14469: oJumpBack 14423
14471: oCall 14474
14473: oReturn
14474: oLocalSpace 0
14476: oReturn
14477: oLocalSpace 2
14479: oGetAddrLocal 1
14481: oPushResult
14482: oScopeCurrent
14483: oPushResult
14484: oSetResult 15
14486: oPushResult
14487: oNodeGetIter
14488: oPop 2
14490: oAssign
14491: oGetAddrLocal 2
14493: oPushResult
14494: oGetLocal 1
14496: oPushResult
14497: oNodeIterValue
14498: oPop 1
14500: oAssign
14501: oGetLocal 2
14503: oPushResult
14504: oNodeNull
14505: oPop 1
14507: oChoice 14511
14509: oJumpForward 14516
14511: Choice Lookup Table
           0   14509
14514: oJumpForward 14571
14516: oGetLocal 2
14518: oPushResult
14519: oNodeType
14520: oPop 1
14522: oChoice 14560
14524: oGetLocal 2
14526: oPushResult
14527: oSetResult 36
14529: oPushResult
14530: oNodeGetBoolean
14531: oPop 2
14533: oChoice 14555
14535: oGetLocal 2
14537: oPushResult
14538: oSetResult 28
14540: oPushResult
14541: oNodeGetBoolean
14542: oPop 2
14544: oChoice 14550
14546: oError 28
14548: oJumpForward 14553
14550: Choice Lookup Table
           1   14546
14553: oJumpForward 14558
14555: Choice Lookup Table
           0   14535
14558: oJumpForward 14563
14560: Choice Lookup Table
          27   14524
14563: oGetAddrLocal 1
14565: oPushResult
14566: oNodeIterNext
14567: oPop 1
14569: oJumpBack 14491
14571: oReturn
14572: oLocalSpace 3
14574: oEmit 89
14576: oGetParam 3
14578: oPushResult
14579: oEmitLabel
14580: oPop 1
14582: oEmit 79
14584: oGetAddrLocal 1
14586: oPushResult
14587: Here
14588: oAssign
14589: oEmit 107
14591: oGetParam 1
14593: oChoice 14599
14595: oCall 1220
14597: oJumpForward 14602
14599: Choice Lookup Table
           1   14595
14602: oGetAddrLocal 2
14604: oPushResult
14605: oGetParam 2
14607: oPushResult
14608: oSetResult 19
14610: oPushResult
14611: oNodeGetCode
14612: oPop 2
14614: oAssign
14615: oGetLocal 2
14617: oPushResult
14618: oEmitCode
14619: oPop 1
14621: oGetParam 2
14623: oPushResult
14624: oSetResult 19
14626: oPushResult
14627: oSetResult 0
14629: oPushResult
14630: oNodeSetCode
14631: oPop 3
14633: oCall 9485
14635: oGetParam 1
14637: oChoice 14643
14639: oCall 1305
14641: oJumpForward 14646
14643: Choice Lookup Table
           1   14639
14646: oEmit 78
14648: oGetAddrLocal 3
14650: oPushResult
14651: oScopeCurrent
14652: oPushResult
14653: oSetResult 17
14655: oPushResult
14656: oNodeGetInt
14657: oPop 2
14659: oAssign
14660: oGetLocal 1
14662: oPushResult
14663: oGetLocal 3
14665: oPushResult
14666: oPatch
14667: oPop 2
14669: oReturn
14670: oLocalSpace 1
14672: oGetAddrLocal 1
14674: oPushResult
14675: oGetParam 1
14677: oPushResult
14678: oSetResult 19
14680: oPushResult
14681: oNodeGetCode
14682: oPop 2
14684: oAssign
14685: oGetLocal 1
14687: oPushResult
14688: oSetResult 0
14690: oPushResult
14691: equal_code
14692: oPop 2
14694: oChoice 14715
14696: oGetAddrLocal 1
14698: oPushResult
14699: oCodeNew
14700: oAssign
14701: oGetParam 1
14703: oPushResult
14704: oSetResult 19
14706: oPushResult
14707: oGetLocal 1
14709: oPushResult
14710: oNodeSetCode
14711: oPop 3
14713: oJumpForward 14718
14715: Choice Lookup Table
           1   14696
14718: oGetLocal 1
14720: oReturn
14721: oReturn
14722: oLocalSpace 0
14724: oScopeCurrent
14725: oPushResult
14726: oSetResult 14
14728: oPushResult
14729: oNodeGetInt
14730: oPop 2
14732: oReturn
14733: oReturn
14734: oLocalSpace 0
14736: oGetParam 1
14738: oPushResult
14739: oSetResult 20
14741: oPushResult
14742: oNodeGet
14743: oPop 2
14745: oPushResult
14746: oSetResult 14
14748: oPushResult
14749: oNodeGetInt
14750: oPop 2
14752: oReturn
14753: oReturn
14754: oLocalSpace 0
14756: oCall 14722
14758: oPushResult
14759: oGetParam 1
14761: oPushResult
14762: oCall 14734
14764: oPop 1
14766: oPushResult
14767: subtract
14768: oPop 2
14770: oReturn
14771: oReturn
14772: oLocalSpace 1
14774: oGetAddrLocal 1
14776: oPushResult
14777: oGetParam 2
14779: oPushResult
14780: oNodeNew
14781: oPop 1
14783: oAssign
14784: oGetLocal 1
14786: oPushResult
14787: oSetResult 4
14789: oPushResult
14790: oGetParam 1
14792: oPushResult
14793: oNodeSetInt
14794: oPop 3
14796: oGetLocal 1
14798: oReturn
14799: oReturn
14800: oLocalSpace 0
14802: oGetParam 1
14804: oPushResult
14805: oSetResult 22
14807: oPushResult
14808: oNodeGetInt
14809: oPop 2
14811: oPushResult
14812: oEmitInt
14813: oPop 1
14815: oReturn
14816: oLocalSpace 1
14818: oGetAddrLocal 1
14820: oPushResult
14821: oSetResult 14
14823: oPushResult
14824: oGetParam 1
14826: oPushResult
14827: oCall 14772
14829: oPop 2
14831: oAssign
14832: oGetLocal 1
14834: oPushResult
14835: oScopeDeclare
14836: oPop 1
14838: oGetLocal 1
14840: oReturn
14841: oReturn
14842: oLocalSpace 1
14844: oGetAddrGlobal 25
14846: oPushResult
14847: oSetResult 0
14849: oAssign
14850: oGetAddrGlobal 4
14852: oPushResult
14853: oId_mysystem
14854: oAssign
14855: oGetAddrGlobal 5
14857: oPushResult
14858: oSetResult 29
14860: oPushResult
14861: oSetResult 4
14863: oPushResult
14864: oCall 12706
14866: oPop 2
14868: oAssign
14869: oGetAddrGlobal 6
14871: oPushResult
14872: oSetResult 31
14874: oPushResult
14875: oSetResult 4
14877: oPushResult
14878: oCall 12706
14880: oPop 2
14882: oAssign
14883: oGetAddrGlobal 7
14885: oPushResult
14886: oSetResult 34
14888: oPushResult
14889: oSetResult 1
14891: oPushResult
14892: oCall 12706
14894: oPop 2
14896: oAssign
14897: oGetAddrGlobal 8
14899: oPushResult
14900: oSetResult 35
14902: oPushResult
14903: oSetResult 1
14905: oPushResult
14906: oCall 12706
14908: oPop 2
14910: oAssign
14911: oGetAddrGlobal 9
14913: oPushResult
14914: oSetResult 36
14916: oPushResult
14917: oSetResult 1
14919: oPushResult
14920: oCall 12706
14922: oPop 2
14924: oAssign
14925: oGetAddrGlobal 10
14927: oPushResult
14928: oGetGlobal 9
14930: oPushResult
14931: oCall 13819
14933: oPop 1
14935: oAssign
14936: oGetAddrGlobal 11
14938: oPushResult
14939: oSetResult 30
14941: oPushResult
14942: oSetResult 1
14944: oPushResult
14945: oCall 12706
14947: oPop 2
14949: oAssign
14950: oGetAddrGlobal 12
14952: oPushResult
14953: oSetResult 32
14955: oPushResult
14956: oSetResult 4
14958: oPushResult
14959: oCall 12706
14961: oPop 2
14963: oAssign
14964: oGetAddrGlobal 13
14966: oPushResult
14967: oSetResult 33
14969: oPushResult
14970: oSetResult 8
14972: oPushResult
14973: oCall 12706
14975: oPop 2
14977: oAssign
14978: oGetAddrGlobal 14
14980: oPushResult
14981: oSetResult 38
14983: oPushResult
14984: oSetResult 8
14986: oPushResult
14987: oCall 12706
14989: oPop 2
14991: oAssign
14992: oGetGlobal 14
14994: oPushResult
14995: oSetResult 38
14997: oPushResult
14998: oGetGlobal 11
15000: oPushResult
15001: oNodeSet
15002: oPop 3
15004: oGetAddrGlobal 15
15006: oPushResult
15007: oSetResult 42
15009: oPushResult
15010: oSetResult 256
15012: oPushResult
15013: oCall 12706
15015: oPop 2
15017: oAssign
15018: oGetAddrGlobal 16
15020: oPushResult
15021: oSetResult 43
15023: oPushResult
15024: oSetResult 256
15026: oPushResult
15027: oCall 12706
15029: oPop 2
15031: oAssign
15032: oGetGlobal 16
15034: oPushResult
15035: oSetResult 43
15037: oPushResult
15038: oSetResult 255
15040: oPushResult
15041: oNodeSetInt
15042: oPop 3
15044: oGetAddrLocal 1
15046: oPushResult
15047: oSetResult 20
15049: oPushResult
15050: oId_File
15051: oPushResult
15052: oCall 14772
15054: oPop 2
15056: oAssign
15057: oGetLocal 1
15059: oPushResult
15060: oSetResult 21
15062: oPushResult
15063: oGetGlobal 5
15065: oPushResult
15066: oNodeSet
15067: oPop 3
15069: oGetLocal 1
15071: oPushResult
15072: oScopeDeclare
15073: oPop 1
15075: oGetAddrLocal 1
15077: oPushResult
15078: oSetResult 20
15080: oPushResult
15081: oId_Integer
15082: oPushResult
15083: oCall 14772
15085: oPop 2
15087: oAssign
15088: oGetLocal 1
15090: oPushResult
15091: oSetResult 21
15093: oPushResult
15094: oGetGlobal 6
15096: oPushResult
15097: oNodeSet
15098: oPop 3
15100: oGetLocal 1
15102: oPushResult
15103: oScopeDeclare
15104: oPop 1
15106: oGetAddrLocal 1
15108: oPushResult
15109: oSetResult 20
15111: oPushResult
15112: oId_Boolean
15113: oPushResult
15114: oCall 14772
15116: oPop 2
15118: oAssign
15119: oGetLocal 1
15121: oPushResult
15122: oSetResult 21
15124: oPushResult
15125: oGetGlobal 7
15127: oPushResult
15128: oNodeSet
15129: oPop 3
15131: oGetLocal 1
15133: oPushResult
15134: oScopeDeclare
15135: oPop 1
15137: oGetAddrLocal 1
15139: oPushResult
15140: oSetResult 20
15142: oPushResult
15143: oId_Char
15144: oPushResult
15145: oCall 14772
15147: oPop 2
15149: oAssign
15150: oGetLocal 1
15152: oPushResult
15153: oSetResult 21
15155: oPushResult
15156: oGetGlobal 9
15158: oPushResult
15159: oNodeSet
15160: oPop 3
15162: oGetLocal 1
15164: oPushResult
15165: oScopeDeclare
15166: oPop 1
15168: oGetAddrLocal 1
15170: oPushResult
15171: oSetResult 20
15173: oPushResult
15174: oId_Byte
15175: oPushResult
15176: oCall 14772
15178: oPop 2
15180: oAssign
15181: oGetLocal 1
15183: oPushResult
15184: oSetResult 21
15186: oPushResult
15187: oGetGlobal 11
15189: oPushResult
15190: oNodeSet
15191: oPop 3
15193: oGetLocal 1
15195: oPushResult
15196: oScopeDeclare
15197: oPop 1
15199: oGetAddrLocal 1
15201: oPushResult
15202: oSetResult 20
15204: oPushResult
15205: oId_Single
15206: oPushResult
15207: oCall 14772
15209: oPop 2
15211: oAssign
15212: oGetLocal 1
15214: oPushResult
15215: oSetResult 21
15217: oPushResult
15218: oGetGlobal 12
15220: oPushResult
15221: oNodeSet
15222: oPop 3
15224: oGetLocal 1
15226: oPushResult
15227: oScopeDeclare
15228: oPop 1
15230: oGetAddrLocal 1
15232: oPushResult
15233: oSetResult 20
15235: oPushResult
15236: oId_Double
15237: oPushResult
15238: oCall 14772
15240: oPop 2
15242: oAssign
15243: oGetLocal 1
15245: oPushResult
15246: oSetResult 21
15248: oPushResult
15249: oGetGlobal 13
15251: oPushResult
15252: oNodeSet
15253: oPop 3
15255: oGetLocal 1
15257: oPushResult
15258: oScopeDeclare
15259: oPop 1
15261: oGetAddrLocal 1
15263: oPushResult
15264: oSetResult 20
15266: oPushResult
15267: oId_Pointer
15268: oPushResult
15269: oCall 14772
15271: oPop 2
15273: oAssign
15274: oGetLocal 1
15276: oPushResult
15277: oSetResult 21
15279: oPushResult
15280: oGetGlobal 14
15282: oPushResult
15283: oNodeSet
15284: oPop 3
15286: oGetLocal 1
15288: oPushResult
15289: oScopeDeclare
15290: oPop 1
15292: oGetAddrLocal 1
15294: oPushResult
15295: oSetResult 20
15297: oPushResult
15298: oId_ShortString
15299: oPushResult
15300: oCall 14772
15302: oPop 2
15304: oAssign
15305: oGetLocal 1
15307: oPushResult
15308: oSetResult 21
15310: oPushResult
15311: oGetGlobal 16
15313: oPushResult
15314: oNodeSet
15315: oPop 3
15317: oGetLocal 1
15319: oPushResult
15320: oScopeDeclare
15321: oPop 1
15323: oGetAddrLocal 1
15325: oPushResult
15326: oSetResult 16
15328: oPushResult
15329: oId_True
15330: oPushResult
15331: oCall 14772
15333: oPop 2
15335: oAssign
15336: oGetLocal 1
15338: oPushResult
15339: oSetResult 21
15341: oPushResult
15342: oGetGlobal 7
15344: oPushResult
15345: oNodeSet
15346: oPop 3
15348: oGetLocal 1
15350: oPushResult
15351: oSetResult 22
15353: oPushResult
15354: oSetResult 1
15356: oPushResult
15357: oNodeSetInt
15358: oPop 3
15360: oGetLocal 1
15362: oPushResult
15363: oScopeDeclare
15364: oPop 1
15366: oGetAddrLocal 1
15368: oPushResult
15369: oSetResult 16
15371: oPushResult
15372: oId_False
15373: oPushResult
15374: oCall 14772
15376: oPop 2
15378: oAssign
15379: oGetLocal 1
15381: oPushResult
15382: oSetResult 21
15384: oPushResult
15385: oGetGlobal 7
15387: oPushResult
15388: oNodeSet
15389: oPop 3
15391: oGetLocal 1
15393: oPushResult
15394: oSetResult 22
15396: oPushResult
15397: oSetResult 0
15399: oPushResult
15400: oNodeSetInt
15401: oPop 3
15403: oGetLocal 1
15405: oPushResult
15406: oScopeDeclare
15407: oPop 1
15409: oGetAddrLocal 1
15411: oPushResult
15412: oSetResult 16
15414: oPushResult
15415: oId_Nil
15416: oPushResult
15417: oCall 14772
15419: oPop 2
15421: oAssign
15422: oGetLocal 1
15424: oPushResult
15425: oSetResult 21
15427: oPushResult
15428: oGetGlobal 14
15430: oPushResult
15431: oNodeSet
15432: oPop 3
15434: oGetLocal 1
15436: oPushResult
15437: oSetResult 22
15439: oPushResult
15440: oSetResult 0
15442: oPushResult
15443: oNodeSetInt
15444: oPop 3
15446: oGetLocal 1
15448: oPushResult
15449: oScopeDeclare
15450: oPop 1
15452: oGetAddrGlobal 17
15454: oPushResult
15455: oId_Ord
15456: oPushResult
15457: oCall 14816
15459: oPop 1
15461: oAssign
15462: oGetAddrGlobal 18
15464: oPushResult
15465: oId_Chr
15466: oPushResult
15467: oCall 14816
15469: oPop 1
15471: oAssign
15472: oGetAddrGlobal 19
15474: oPushResult
15475: oId_Pred
15476: oPushResult
15477: oCall 14816
15479: oPop 1
15481: oAssign
15482: oGetAddrGlobal 20
15484: oPushResult
15485: oId_Succ
15486: oPushResult
15487: oCall 14816
15489: oPop 1
15491: oAssign
15492: oGetAddrGlobal 21
15494: oPushResult
15495: oId_Sizeof
15496: oPushResult
15497: oCall 14816
15499: oPop 1
15501: oAssign
15502: oReturn
