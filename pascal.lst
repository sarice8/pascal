   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nStrLitType :
2586:          decl = @newIdent( nConstStr, id )
2600:          oNodeSetString( decl, qValueStr, oValueTopString )
2611:       | * :  #eNotAllowed
2632:    ]
2632:    oValuePop
2633:    oNodeSet( decl, qType, oTypeSTop )
2644:    oTypeSPop
2645:    oScopeDeclare( decl )
2651:    ';'
2654:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2654: TypedConstDecl:
2656:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2669:    Node theType
2669:    @TypeRef( theType )
2676:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2688:    [ oNodeType( theType )
2695:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2696:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2696:          '='
      
2698:          oTypeSPush( theType )
2704:          @ConstExpr
2706:          @ConstCoerceType
      
2708:          oNodeSetInt( decl, qValue, oValueTop )
2719:          oValuePop
2720:          oTypeSPop
2721:          oScopeDeclare( decl )
2727:          ';'
      
2729:       | nShortStringType, nFileType :
2731:          #eNotImplemented
      
2733:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2735:          oScopeEnter( globalScope )
2741:          int addr = oScopeAllocType( theType )
2751:          oScopeEnd
2752:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2763:          oNodeSetInt( decl, qValue, addr )
2775:          '='
2777:          @TypedConstInit( theType, addr )
2787:          oCodePop
2788:          oScopeDeclare( decl )
2794:          ';'
2796:    ]
2823:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2823: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2825:    [ oNodeType( theType )
2832:       | nArrayType :
2833:          Node baseType = oNodeGet( theType, qBaseType )
2846:          Node indexType = oNodeGet( theType, qIndexType )
2859:          int low = @OrdinalLow( indexType )
2870:          int high = @OrdinalHigh( indexType )
2881:          int elementSize = oNodeGetInt( baseType, qSize )
      
2894:          '('
               % Loop over elements
2896:          int i = low
2902:          {
2902:             @TypedConstInit( baseType, addr )
2912:             [ equal( i, high )
2922:                | true : >
2925:                | false :
2927:             ]
2935:             ','
2937:             addr = add( addr, elementSize )
2950:             inc( i )
2956:          }
2958:          ')'
      
2960:       | nRecordType :
2962:          '('
2964:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2977:          {
2977:             [
2977:                | pIdent :
2979:                | * :  >
2986:             ]
2986:             Node field = oScopeFindRequireInScope( fieldScope )
2996:             ':'
2998:             Node fieldType = oNodeGet( field, qType )
3011:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3031:             @TypedConstInit( fieldType, fieldAddr )
3041:             [
3041:                | ';' :
3043:                | * :  >
3050:             ]
3050:          }
3052:          ')'
      
3054:       | nBooleanType, nByteType, nCharType:
3056:          .tPushAddrGlobal  oEmitInt( addr )
3064:          oTypeSPush( theType )
3070:          @ConstExpr
3072:          @ConstCoerceType
3074:          .tPushConstI  oEmitInt( oValueTop )
3081:          oValuePop
3082:          oTypeSPop
3083:          .tAssignB
      
3085:       | nIntegerType, nEnumType:
3087:          .tPushAddrGlobal  oEmitInt( addr )
3095:          oTypeSPush( theType )
3101:          @ConstExpr
3103:          @ConstCoerceType
3105:          .tPushConstI  oEmitInt( oValueTop )
3112:          oValuePop
3113:          oTypeSPop
3114:          .tAssignI
      
3116:       | nPointerType, nUniversalPointerType :
3118:          .tPushAddrGlobal  oEmitInt( addr )
3126:          oTypeSPush( theType )
3132:          @ConstExpr
3134:          @ConstCoerceType
3136:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3143:          oValuePop
3144:          oTypeSPop
3145:          .tAssignP
      
3147:       | nShortStringType, nFileType :
3149:          #eNotImplemented
3151:    ]
3178:    ;
      
      
3178: TypeDecl:
3180:    {[
3180:       | pIdent :
3182:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3195:          '='
3197:          Node theType
3197:          @TypeRef( theType )
3204:          oNodeSet( decl, qType, theType )
3216:          oScopeDeclare( decl )
3222:          ';'
3224:       | * :
3229:          >
3231:    ]};
      
3234: VarDecl( node_type varNodeType ):
3236:    {[
3236:       | pIdent :
3238:          NodeVec decls = oNodeVecNew
3243:          Node decl
3243:          {
3243:             decl = @newIdent( varNodeType, LAST_ID )
3256:             oNodeVecAppend( decls, decl )
3265:             [
3265:                | ',' :
3267:                   pIdent
3269:                | * :
3274:                   >
3276:             ]
3276:          }
3278:          ':'
3280:          Node theType
3280:          @TypeRef( theType )
      
3287:          int i = 0
3293:          {[ equal( i, oNodeVecSize( decls ) )
3307:             | false :
3308:                decl = oNodeVecElement( decls, i )
3321:                oNodeSet( decl, qType, theType )
3333:                oScopeDeclareAlloc( decl )
3339:                inc( i )
3345:             | * :
3350:               >
3352:          ]}
      
               % optional initialization
3354:          [
3354:             | '=' :
3356:                [ oNodeVecSize( decls )
3363:                   | 1 :
3364:                   | * :  #eOnlyOneVarCanBeInitialized
3371:                ]
      
                     % we need an initCode stream for this scope
3371:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3381:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3387:                boolean changedScope = false
3393:                [ equal_zero( @ScopeLevel )
3400:                   | true : oScopeEnter( initScope )
3407:                            changedScope = true
3413:                   | * :
3418:                ]
                     % generate assignment in initCode stream
3418:                @LValueVar( decl, true )
3428:                @Expr
3430:                @CoerceType
3432:                @Assign
3434:                [ changedScope
3437:                   | true : oScopeEnd
3439:                   | * :
3444:                ]
3444:                oCodePop
                   
3445:             | * :
3450:          ]
      
3450:          oNodeVecDelete( decls )
3456:          ';'
3458:       | * :
3463:          >
3465:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3468: LabelDecl:
3470:    {
3470:       Node decl
3470:       [
3470:          | pIdent :
3472:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3474:             oChangeIntLitToLabelIdent
3475:       ]
3483:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3496:       Label label = oLabelNew
3501:       oNodeSetLabel( decl, qValue, label )
3513:       oScopeDeclare( decl )
3519:       [
3519:          | ',' :
3521:          | * :
3526:             >
3528:       ]
3528:    }
3530:    ';'
3533:    ;
3533: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3533: ConstExpr:
3535:    @ConstBoolExpr
3537:    {[
3537:       | '=' :
3539:          @ConstBoolTerm
3541:          @ConstMatchTypes
3543:          [ oTypeSNodeType
3545:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3554:             | * :             oValueEqual
3560:          ]
3560:          oTypeSPop  oTypeSPush( BooleanType )
3567:       | '<>' :
3569:          @ConstBoolExpr
3571:          @ConstMatchTypes
3573:          [ oTypeSNodeType
3575:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3584:             | * :             oValueNotEqual
3590:          ]
3590:          oTypeSPop  oTypeSPush( BooleanType )
3597:       | '<' :
3599:          @ConstBoolExpr
3601:          @ConstMatchTypes
3603:          [ oTypeSNodeType
3605:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3614:             | * :             oValueLess
3620:          ]
3620:          oTypeSPop  oTypeSPush( BooleanType )
3627:       | '>' :
3629:          @ConstBoolExpr
3631:          @ConstMatchTypes
3633:          [ oTypeSNodeType
3635:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3644:             | * :             oValueGreater
3650:          ]
3650:          oTypeSPop  oTypeSPush( BooleanType )
3657:       | '<=' :
3659:          @ConstBoolExpr
3661:          @ConstMatchTypes
3663:          [ oTypeSNodeType
3665:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3674:             | * :             oValueLessEqual
3680:          ]
3680:          oTypeSPop  oTypeSPush( BooleanType )
3687:       | '>=' :
3689:          @ConstBoolExpr
3691:          @ConstMatchTypes
3693:          [ oTypeSNodeType
3695:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3704:             | * :             oValueGreaterEqual
3710:          ]
3710:          oTypeSPop  oTypeSPush( BooleanType )
3717:       | * :  >
3734:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3737: ConstExprAllowTypeName:
3739:    boolean oldAllowTypeName = flagExprAllowTypeName
3745:    flagExprAllowTypeName = true
3751:    @ConstExpr
3753:    flagExprAllowTypeName = oldAllowTypeName
3760:    ;
      
      
3760: ConstBoolExpr:
3762:    @ConstBoolTerm
3764:    {[
3764:       | pOr :
3766:          @ConstRequireBool
3768:          @ConstBoolTerm
3770:          @ConstRequireBoolPop
3772:          oValueOr
3773:       | * :  >
3780:    ]};
      
      
3783: ConstBoolTerm:
3785:    @ConstBoolFactor
3787:    {[
3787:       | pAnd :
3789:          @ConstRequireBool
3791:          @ConstBoolFactor
3793:          @ConstRequireBoolPop
3795:          oValueAnd
3796:       | * :  >
3803:    ]};
      
      
3806: ConstBoolFactor:
3808:    [
3808:       | pNot :
3810:          @ConstBoolFactor
3812:          @ConstRequireBool
3814:          oValueNot
3815:       | * :
3820:          @ConstArithExpr
3822:    ];
      
      
3823: ConstArithExpr:
3825:    @ConstTerm
3827:    {[
3827:       | '+' :
3829:          @ConstTerm
3831:          @ConstMatchTypes
3833:          [ oTypeSNodeType
3835:             | nStrLitType :   oValueStringConcat
3837:             | * :             oValueAdd
3843:          ]
3843:       | '-' :
3845:          @ConstTerm
3847:          @ConstMatchTypes
3849:          [ oTypeSNodeType
3851:             | nStrLitType :   #eNotAllowed
3854:             | * :             oValueSub
3860:          ]
3860:       | * :  >
3869:    ]};
      
      
3872: ConstTerm:
3874:    @ConstFactor
3876:    {[
3876:       | pTimes :
3878:          @ConstFactor
3880:          @ConstMatchTypes
3882:          [ oTypeSNodeType
3884:             | nStrLitType :   #eNotAllowed
3887:             | * :             oValueMult
3893:          ]
3893:       | pDivide :
3895:          @ConstFactor
3897:          @ConstMatchTypes
3899:          [ oTypeSNodeType
3901:             | nStrLitType :   #eNotAllowed
3904:             | * :             oValueDiv
3910:          ]
3910:       | * :  >
3919:    ]};
      
      
3922: ConstFactor:
3924:    [
3924:       | pPlus :
3926:          @ConstPrimary
3928:       | pMinus :
3930:          @ConstPrimary
3932:          oValueNegate
3933:       | * :
3940:          @ConstPrimary
3942:    ];
      
      
3943: ConstPrimary:
3945:    [
3945:       | pIntLit :
3947:          oValuePush( TOKEN_VALUE )
3952:          oTypeSPush( IntegerType )
3958:       | pCharLit :
3960:          oValuePush( TOKEN_VALUE )
3965:          oTypeSPush( CharType )
3971:       | pStrLit :
3973:          oValuePushString( CURRENT_STRLIT )
3978:          oTypeSPush( StrLitType )
3984:       | '(' :
3986:          @ConstExpr
3988:          ')'
3990:       | pIdent :
3992:          Node decl = oScopeFindRequire
3997:          @ResolveUnitRef( decl )
4004:          [ oNodeType( decl )
4011:             | nBuiltInFunc :
4012:                @ConstBuiltInFunc( decl )
4019:             | nConst :
4021:                oValuePush( oNodeGetInt( decl, qValue ) )
4034:                oTypeSPush( oNodeGet( decl, qType ) )
4047:             | nConstStr :
4049:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4062:                oTypeSPush( oNodeGet( decl, qType ) )
4075:             | nEnumValue :
4077:                oValuePush( oNodeGetInt( decl, qValue ) )
4090:                oTypeSPush( oNodeGet( decl, qType ) )
4103:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4105:                oTypeSPush( oNodeGet( decl, qType ) )
4118:                [
4118:                   | '(' :
                           % Type cast
4120:                      @ConstExpr
4122:                      ')'
4124:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4126:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4131:                      [ flagExprAllowTypeName
4134:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4135:                            oValuePush( 0 )
4141:                         | * :   #eTypeNameNotAllowedHere
4148:                      ]
4148:                ]
      
4148:             | * :
4161:                #eNotConst
4163:                oValuePush( 0 )
4169:                oTypeSPush( IntegerType )
4175:          ]
4175:       | '@' :
4177:          #eNotImplemented
4179:          oValuePush( 0 )
4185:          oTypeSPush( UniversalPointerType )
4191:       | * :
4206:          #eNotConst
4208:          oValuePush( 0 )
4214:          oTypeSPush( IntegerType )
4220:    ];
      
4221: ConstRequireBoolPop:
4223:    [ oTypeSNodeType
4225:       | nBooleanType :
4226:       | * :          #eNotBoolean
4233:    ]
4233:    oTypeSPop;
      
      
4235: ConstRequireBool:
4237:    [ oTypeSNodeType
4239:       | nBooleanType :
4240:       | * :          #eNotBoolean
4247:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4248: ConstMatchTypes:
4250:    node_type nt = oTypeSNodeType
4255:    oTypeSPop
4256:    [ equal_node_type( nt, oTypeSNodeType )
4265:       | false :
               % Some implicit conversion is allowed even here
4266:          [ oTypeSNodeType
4268:             | nPointerType :
4269:                [ nt
4272:                   | nUniversalPointerType :  >>
4274:                   | * :
4279:                ]
4279:             | nUniversalPointerType :
4281:                [ nt
4284:                   | nPointerType :  >>
4286:                   | * :
4291:                ]
4291:             | nStrLitType :
4293:                [ nt
4296:                   | nCharType :
4297:                      oValueCharToString
4298:                      >>
4299:                   | * :
4304:                ]
4304:             | nCharType :
4306:                [ nt
4309:                   | nStrLitType :
4310:                      oValueSwap
4311:                      oValueCharToString
4312:                      oValueSwap
4313:                      oTypeSPop
4314:                      oTypeSPush( StrLitType )
4320:                      >>
4321:                   | * :
4326:                ]
4326:             | * :
4337:          ]
4337:          #eTypeMismatch
4339:       | * :
4344:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4345: ConstCoerceType:
4347:    node_type nt = oTypeSNodeType
4352:    oTypeSPop
4353:    [ equal_node_type( nt, oTypeSNodeType )
4362:       | false :
               % Can we implicitly convert the value to the desired type?
4363:          [ oTypeSNodeType
4365:             | nIntegerType :
4366:                [ nt
4369:                   | nByteType :  >>
4371:                   | * :
4376:                ]
4376:             | nByteType :
4378:                [ nt
4381:                   | nIntegerType :  >>
4383:                   | * :
4388:                ]
4388:             | nPointerType :
4390:                [ nt
4393:                   | nUniversalPointerType :  >>
4395:                   | * :
4400:                ]
4400:             | nUniversalPointerType :
4402:                [ nt
4405:                   | nPointerType :  >>
4407:                   | * :
4412:                ]
4412:             | nStrLitType :
4414:                [ nt
4417:                   | nCharType :
4418:                      oValueCharToString
4419:                      >>
4420:                   | * :
4425:                ]
4425:             | nShortStringType :
4427:                [ nt
4430:                   | nStrLitType :  >>
4432:                   | nCharType :
4434:                      oValueCharToString
4435:                      >>
4436:                   | * :
4443:                ]
4443:             | * :
4458:          ]
4458:          #eTypeMismatch
4460:       | * :
4465:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4466: ConstCastType:
4468:    node_type nt = oTypeSNodeType
4473:    oTypeSPop
4474:    [ equal_node_type( nt, oTypeSNodeType )
4483:       | false :
               % Can we cast the value to the desired type?
4484:          [ oTypeSNodeType
4486:             | nIntegerType, nEnumType :
4487:                [ nt
4490:                   | nByteType, nCharType, nBooleanType :  >>
4492:                   | nIntegerType, nEnumType :  >>
4495:                   | * :
4508:                ]
4508:             | nByteType, nCharType, nBooleanType :
4510:                [ nt
4513:                   | nByteType, nCharType, nBooleanType :  >>
4515:                   | nIntegerType, nEnumType :  >>
4518:                   | * :
4531:                ]
4531:             | nPointerType :
4533:                [ nt
4536:                   | nUniversalPointerType :  >>
4538:                   | * :
4543:                ]
4543:             | nUniversalPointerType :
4545:                [ nt
4548:                   | nPointerType :  >>
4550:                   | * :
4555:                ]
4555:             | nStrLitType :
4557:                [ nt
4560:                   | nCharType :
4561:                      oValueCharToString
4562:                      >>
4563:                   | * :
4568:                ]
4568:             | nShortStringType :
4570:                [ nt
4573:                   | nStrLitType :  >>
4575:                   | nCharType :
4577:                      oValueCharToString
4578:                      >>
4579:                   | * :
4586:                ]
4586:             | * :
4607:          ]
4607:          #eTypeMismatch
4609:       | * :
4614:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4615: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4617:    [ oNodeEqual( method, BuiltIn_Ord )
4627:       | true :
4628:          '('
4630:          @ConstExpr
4632:          ')'
4634:          [ oTypeSNodeType
4636:             | nIntegerType, nEnumType :
4637:             | nBooleanType, nByteType, nCharType :
4639:             | * :  #eTypeMismatch
4654:          ]
4654:          oTypeSPop
4655:          oTypeSPush( IntegerType )
4661:          ')'
4663:          >>
4664:       | * :
4669:    ]
      
         % Chr(x)
4669:    [ oNodeEqual( method, BuiltIn_Chr )
4679:       | true :
4680:          '('
4682:          @ConstExpr
4684:          ')'
4686:          [ oTypeSNodeType
4688:             | nIntegerType :
4689:             | nByteType :
4691:             | * :  #eTypeMismatch
4700:          ]
4700:          oTypeSPop
4701:          oTypeSPush( CharType )
4707:          ')'
4709:          >>
4710:       | * :
4715:    ]
      
         % Pred(x)
4715:    [ oNodeEqual( method, BuiltIn_Pred )
4725:       | true :
4726:          '('
4728:          @ConstExpr
4730:          [ oTypeSNodeType
4732:             | nEnumType :
4733:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4742:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4745:                   | * :
4750:                ]
4750:             | * :  #eTypeMismatch
4757:          ]
4757:          oValuePush( 1 )  oValueSub
4764:          ')'
4766:          >>
4767:       | * :
4772:    ]
      
         % Succ(x)
4772:    [ oNodeEqual( method, BuiltIn_Succ )
4782:       | true :
4783:          '('
4785:          @ConstExpr
4787:          [ oTypeSNodeType
4789:             | nEnumType :
4790:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4799:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4802:                   | * :
4807:                ]
4807:             | * :  #eTypeMismatch
4814:          ]
4814:          oValuePush( 1 )  oValueAdd
4821:          ')'
4823:          >>
4824:       | * :
4829:    ]
      
         % Sizeof(x)
4829:    [ oNodeEqual( method, BuiltIn_Sizeof )
4839:       | true :
4840:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4842:          @ConstExprAllowTypeName
4844:          oValuePop
4845:          Node theType = oTypeSTop
4850:          oTypeSPop
4851:          oValuePush( oNodeGetInt( theType, qSize ) )
4864:          oTypeSPush( IntegerType )
4870:          ')'
4872:          >>
4873:       | * :
4878:    ]
      
4878:    #eNotImplemented
4881:    ;
      
      
4881: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4881: Expr:
4883:    Label falseLabel = labelNull
      
4889:    @ExprAllowFlow( falseLabel )
4896:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
4904: ExprAllowTypeName:
4906:    boolean oldAllowTypeName = flagExprAllowTypeName
4912:    flagExprAllowTypeName = true
4918:    @Expr
4920:    flagExprAllowTypeName = oldAllowTypeName
4927:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4927: BooleanExprControlFlow( out Label falseLabel ):
4929:    @ExprAllowFlow( falseLabel )
4936:    [ oTypeSNodeType
4938:       | nBooleanFlowType :
4939:       | nBooleanType :
               % convert value to control flow
4941:          falseLabel = oLabelNew
4946:          .tJumpFalse  oEmitLabel( falseLabel )
4954:       | * :
4961:          #eNotBoolean
4963:    ]
4963:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4965: FlowToVal( inout Label falseLabel ):
4967:    [ oTypeSNodeType
4969:       | nBooleanFlowType :
4970:          Label doneLabel = oLabelNew
4975:          .tPushConstI  oEmitInt( 1 )
4983:          .tJump  oEmitLabel( doneLabel )
4991:          .tLabel  oEmitLabel( falseLabel )
4999:          .tPushConstI  oEmitInt( 0 )
5007:          .tLabel  oEmitLabel( doneLabel )
5015:          oTypeSPop
5016:          oTypeSPush( BooleanType )
5022:          falseLabel = labelNull
5028:       | * :
5033:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5034: ValToFlow( out Label falseLabel ):
5036:    [ oTypeSNodeType
5038:       | nBooleanType :
5039:          falseLabel = oLabelNew
5044:          .tJumpFalse  oEmitLabel( falseLabel )
5052:          oTypeSPop
5053:          oTypeSPush( BooleanFlowType )
5059:       | * :
5064:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5065: ExprAllowFlow( out Label falseLabel ):
5067:    @BoolExprAllowFlow( falseLabel )
5074:    {[
5074:       | '=' :
5076:          @FlowToVal( falseLabel )
5083:          @PromoteToIntOptional
5085:          @BoolExprAllowFlow( falseLabel )
5092:          @FlowToVal( falseLabel )
5099:          @PromoteToIntOptional
5101:          @MatchTypes
5103:          [ oTypeSNodeType
5105:             | nBooleanType, nCharType :     .tEqualB
5108:             | nIntegerType, nEnumType :     .tEqualI
5112:             | nPointerType, nUniversalPointerType :    .tEqualP
5116:             | nShortStringType, nStrLitType :
5118:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5130:             | * :                           #eNotAllowed
5151:          ]
5151:          oTypeSPop
5152:          oTypeSPush( BooleanType )
      
5158:       | '<>' :
5160:          @FlowToVal( falseLabel )
5167:          @PromoteToIntOptional
5169:          @BoolExprAllowFlow( falseLabel )
5176:          @FlowToVal( falseLabel )
5183:          @PromoteToIntOptional
5185:          @MatchTypes
5187:          [ oTypeSNodeType
5189:             | nBooleanType, nCharType :     .tNotEqualB
5192:             | nIntegerType, nEnumType :     .tNotEqualI
5196:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5200:             | nShortStringType, nStrLitType :
5202:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5214:             | * :                           #eNotAllowed
5235:          ]
5235:          oTypeSPop
5236:          oTypeSPush( BooleanType )
      
5242:       | '<' :
5244:          @FlowToVal( falseLabel )
5251:          @PromoteToIntOptional
5253:          @BoolExprAllowFlow( falseLabel )
5260:          @FlowToVal( falseLabel )
5267:          @PromoteToIntOptional
5269:          @MatchTypes
5271:          [ oTypeSNodeType
5273:             | nBooleanType, nCharType :     .tLessB
5276:             | nIntegerType, nEnumType :     .tLessI
5280:             | nPointerType, nUniversalPointerType :   .tLessP
5284:             | nShortStringType, nStrLitType :
5286:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5298:             | * :                           #eNotAllowed
5319:          ]
5319:          oTypeSPop
5320:          oTypeSPush( BooleanType )
      
5326:       | '>' :
5328:          @FlowToVal( falseLabel )
5335:          @PromoteToIntOptional
5337:          @BoolExprAllowFlow( falseLabel )
5344:          @FlowToVal( falseLabel )
5351:          @PromoteToIntOptional
5353:          @MatchTypes
5355:          [ oTypeSNodeType
5357:             | nBooleanType, nCharType :     .tGreaterB
5360:             | nIntegerType, nEnumType :     .tGreaterI
5364:             | nPointerType, nUniversalPointerType :   .tGreaterP
5368:             | nShortStringType, nStrLitType :
5370:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5382:             | * :                           #eNotAllowed
5403:          ]
5403:          oTypeSPop
5404:          oTypeSPush( BooleanType )
      
5410:       | '<=' :
5412:          @FlowToVal( falseLabel )
5419:          @PromoteToIntOptional
5421:          @BoolExprAllowFlow( falseLabel )
5428:          @FlowToVal( falseLabel )
5435:          @PromoteToIntOptional
5437:          @MatchTypes
5439:          [ oTypeSNodeType
5441:             | nBooleanType, nCharType :     .tLessEqualB
5444:             | nIntegerType, nEnumType :     .tLessEqualI
5448:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5452:             | nShortStringType, nStrLitType :
5454:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5466:             | * :                           #eNotAllowed
5487:          ]
5487:          oTypeSPop
5488:          oTypeSPush( BooleanType )
      
5494:       | '>=' :
5496:          @FlowToVal( falseLabel )
5503:          @PromoteToIntOptional
5505:          @BoolExprAllowFlow( falseLabel )
5512:          @FlowToVal( falseLabel )
5519:          @PromoteToIntOptional
5521:          @MatchTypes
5523:          [ oTypeSNodeType
5525:             | nBooleanType, nCharType :     .tGreaterEqualB
5528:             | nIntegerType, nEnumType :     .tGreaterEqualI
5532:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5536:             | nShortStringType, nStrLitType :
5538:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5550:             | * :                           #eNotAllowed
5571:          ]
5571:          oTypeSPop
5572:          oTypeSPush( BooleanType )
      
5578:       | * :
5593:          >
5595:    ]};
      
      
5598: BoolExprAllowFlow( out Label falseLabel ):
5600:    Label trueLabel = labelNull
      
5606:    @BoolTermAllowFlow( falseLabel )
5613:    {[
5613:       | pOr :
5615:          [ oTypeSNodeType
5617:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5618:                [ equal_label( trueLabel, labelNull )
5628:                   | true :  trueLabel = oLabelNew
5634:                   | * :
5639:                ]
5639:                .tJump  oEmitLabel( trueLabel )
5647:             | nBooleanType :
5649:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5656:                [ equal_label( trueLabel, labelNull )
5666:                   | true :  trueLabel = oLabelNew
5672:                   | * :
5677:                ]
5677:                .tJump  oEmitLabel( trueLabel )
5685:             | * : #eNotBoolean
5694:          ]
5694:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5695:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5703:          falseLabel = labelNull
5709:          @BoolTermAllowFlow( falseLabel )
      
5716:          [ oTypeSNodeType
5718:             | nBooleanFlowType :
5719:             | nBooleanType :
5721:                @ValToFlow( falseLabel )
5728:             | * : #eNotBoolean
5737:          ]
      
5737:          oTypeSPop
5738:          oTypeSPush( BooleanFlowType )
      
5744:       | * :
5749:          >
5751:    ]}
      
         % any short-circuit trues jump here to the end
5753:    [ equal_label( trueLabel, labelNull )
5763:       | false :
5764:          .tLabel  oEmitLabel( trueLabel )
5772:       | * :
5777:    ]
5778:    ;
      
      
5778: BoolTermAllowFlow( out Label falseLabel ):
5780:    Label overallFalseLabel = labelNull
      
5786:    @BoolFactorAllowFlow( falseLabel )
5793:    {[
5793:       | pAnd :
5795:          [ oTypeSNodeType
5797:             | nBooleanFlowType :
5798:             | nBooleanType :
5800:                @ValToFlow( falseLabel )
5807:             | * :
5814:                #eNotBoolean
5816:          ]
5816:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5817:          [ equal_label( overallFalseLabel, labelNull )
5827:             | true :
5828:                overallFalseLabel = oLabelNew
5833:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5847:                falseLabel = overallFalseLabel
5853:             | * :
5858:          ]
      
5858:          Label factorFalseLabel = labelNull
5864:          @BoolFactorAllowFlow( factorFalseLabel )
      
5871:          [ oTypeSNodeType
5873:             | nBooleanFlowType :
5874:             | nBooleanType :
5876:                @ValToFlow( factorFalseLabel )
5883:             | * : #eNotBoolean
5892:          ]
5892:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5906:       | * :
5911:          >
5913:    ]};
      
      
5916: BoolFactorAllowFlow( out Label falseLabel ):
5918:    [
5918:       | pNot :
5920:          Label factorFalseLabel = labelNull
      
5926:          @BoolFactorAllowFlow( factorFalseLabel )
5933:          [ oTypeSNodeType
5935:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5936:                falseLabel = oLabelNew
5941:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5949:                .tLabel  oEmitLabel( factorFalseLabel )
      
5957:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5959:                .tNot
      
5961:             | * : #eNotBoolean
5970:          ]
      
5970:       | * :
5975:          @ArithExprAllowFlow( falseLabel )
5982:    ];
      
      
5983: ArithExprAllowFlow( out Label falseLabel ):
5985:    boolean first = true
5991:    int tempStrOffset
      
5991:    @TermAllowFlow( falseLabel )
5998:    {[
5998:       | '+' :
6000:          [ oTypeSNodeType
6002:             | nIntegerType, nByteType :
6003:                @PromoteToIntPop
6005:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6012:                [ oTypeSNodeType
6014:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6015:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6017:                      @PointerAddition
6019:                   | * :
6026:                      @PromoteToInt
6028:                      .tAddI
6030:                ]
      
6030:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6032:                [ first
6035:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6036:                             tempStrOffset = @MoveIntoTempShortString
6042:                             first = false
6048:                   | * :
6053:                ]
6053:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6060:                [ oTypeSNodeType
6062:                   | nShortStringType, nStrLitType :
6063:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6065:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6073:                      oTypeSPush( ShortStringType )
6079:                   | nCharType :
6081:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6083:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6091:                      oTypeSPush( ShortStringType )
6097:                   | * :
6106:                      #eTypeMismatch
6108:                      oTypeSPop
6109:                ]
      
6109:             | nPointerType, nUniversalPointerType :
6111:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6118:                @PromoteToIntPop
6120:                @PointerAddition
      
6122:             | * :
6139:                #eNotAllowed
6141:          ]
      
6141:       | '-' :
6143:          [ oTypeSNodeType
6145:             | nIntegerType, nByteType :
6146:                @PromoteToIntPop
6148:                @TermAllowFlow( falseLabel )
6155:                @PromoteToInt
6157:                .tSubI
      
6159:             | nPointerType, nUniversalPointerType :
6161:                @TermAllowFlow( falseLabel )
6168:                [ oTypeSNodeType
6170:                   | nIntegerType, nByteType :
6171:                      @PromoteToIntPop
6173:                      @PointerSubInt
6175:                   | nPointerType, nUniversalPointerType :
6177:                      @MatchTypes
6179:                      @PointerSubPointer
6181:                   | * :
6192:                      #eNotAllowed
6194:                ]
      
6194:             | * :  #eNotAllowed
      
6207:          ]
6207:       | * :
6214:          >
6216:    ]};
      
      
6219: TermAllowFlow( out Label falseLabel ):
6221:    @FactorAllowFlow( falseLabel )
6228:    {[
6228:       | pTimes :
6230:          @PromoteToIntPop
6232:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6239:          @PromoteToInt
6241:          .tMultI
6243:       | pDivide :
6245:          @PromoteToIntPop
6247:          @FactorAllowFlow( falseLabel )
6254:          @PromoteToInt
6256:          .tDivI
6258:       | * :
6265:          >
6267:    ]};
      
      
6270: FactorAllowFlow( out Label falseLabel ):
6272:    [
6272:       | pPlus :
6274:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6281:          @PromoteToInt
6283:       | pMinus :
6285:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6292:          @PromoteToInt
6294:          .tNegI
6296:       | * :
6303:          @PrimaryAllowFlow( falseLabel )
6310:    ];
      
      
6311: PrimaryAllowFlow( out Label falseLabel ):
6313:    [
6313:       | pIntLit :
6315:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6322:          oTypeSPush( IntegerType )
      
6328:       | pCharLit :
6330:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6337:          oTypeSPush( CharType )
      
6343:       | pDoubleLit :
6345:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6352:          oTypeSPush( DoubleType )
      
6358:       | '(' :
6360:          @ExprAllowFlow( falseLabel )
6367:          ')'
      
6369:       | pStrLit :
6371:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6380:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6388:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6394:          @LValueIndexes
               % get final value of dereferencing, if any
6396:          @FetchVar
      
6398:       | pIdent :
6400:          Node decl = oScopeFindRequire
6405:          @ResolveUnitRef( decl )
6412:          Node theType
      
6412:          [ oNodeType( decl )
6419:             | nFunc :
6420:                @Call( decl )
      
6427:             | nBuiltInFunc :
6429:                @CallBuiltInFunc( decl )
      
6436:             | nConst, nEnumValue :
6438:                theType = oNodeGet( decl, qType )
6451:                oTypeSPush( theType )
6457:                [ oTypeSNodeType
6459:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6460:                      .tPushConstI @EmitValue( decl )
6469:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6471:                      .tPushConstI @EmitValue( decl )
6480:                   | * :
6497:                      #eNotImplemented
6499:                ]
      
6499:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6501:                int addr = oNodeGetInt( decl, qValue )
6514:                [ equal_zero( addr )
6521:                   | true :
6522:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6539:                      oNodeSetInt( decl, qValue, addr )
6551:                   | * :
6556:                ]
6556:                .tPushAddrGlobal oEmitInt( addr )
6564:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6570:                @LValueIndexes
                     % get final value of dereferencing, if any
6572:                @FetchVar
      
6574:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6576:                @VarExpr( decl )
      
6583:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6585:                oTypeSPush( oNodeGet( decl, qType ) )
6598:                [
6598:                   | '(' : 
                           % Type cast
6600:                      @Expr
6602:                      ')'
6604:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
6606:                      [ oTypeSNodeType
6608:                         | nPointerType, nUniversalPointerType :
6609:                            [
6609:                               | '^' :             % dereferenced
6611:                                  oTypeSPop
6612:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
6625:                                  @LValueIndexes
6627:                                  @FetchVar
6629:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
6631:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
6633:                                  @LValueIndexes
6635:                                  @FetchVar
6637:                               | * :               % just ptr value alone
6644:                            ]
      
6644:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
6646:                            @LValueIndexes
                                 % get final value, if no longer compound
6648:                            @FetchVar
      
6650:                         | *:
6663:                      ]
      
6663:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
6668:                      [ flagExprAllowTypeName
6671:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
6672:                            .tPushConstI  oEmitInt( 0 )
6680:                         | * :    #eTypeNameNotAllowedHere
6687:                      ]
6687:                ]
      
6687:             | * :
6710:                #eNotValue
6712:                oTypeSPush( IntegerType )
6718:          ]
      
6718:       | '@' :        % @var -- pointer to var
6720:          pIdent
      
6722:          Node decl = oScopeFindRequire
6727:          @ResolveUnitRef( decl )
6734:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
6734:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6744:          theType = oTypeSTop
6749:          oTypeSPop
6750:          Node ptrType = @PointerTypeTo( theType )
6761:          oTypeSPush( ptrType )
      
6767:       | * :
6784:          #eNotValue
6786:          oTypeSPush( IntegerType )
6792:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6793: VarExpr( Node decl ):
6795:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6808:    int uplevels = @DeclUpLevels( decl )
      
6819:    oTypeSPush( theType )
6825:    [ oTypeSNodeType
6827:       | nIntegerType, nEnumType :
6828:          [ oNodeType( decl )
6835:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6845:             | nLocalVar :
6847:                [ equal_zero( uplevels )
6854:                   | true :  .tPushLocalI  @EmitValue( decl )
6864:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6884:                ]
6884:             | nParam :
6886:                [ oNodeGetBoolean( decl, qInOut )
6896:                   | true :    % VAR param points to the var.  Auto dereference.
6897:                      [ equal_zero( uplevels )
6904:                         | true :  .tPushParamP  @EmitValue( decl )
6914:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6934:                      ]
6934:                      .tFetchI
6936:                   | * :
6941:                      [ equal_zero( uplevels )
6948:                         | true :  .tPushParamI  @EmitValue( decl )
6958:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6978:                      ]
6978:                ]
6978:          ]
      
6990:       | nBooleanType, nByteType, nCharType :
6992:          [ oNodeType( decl )
6999:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7009:             | nLocalVar :
7011:                [ equal_zero( uplevels )
7018:                   | true :  .tPushLocalB  @EmitValue( decl )
7028:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7048:                ]
7048:             | nParam :
7050:                [ oNodeGetBoolean( decl, qInOut )
7060:                   | true :    % VAR param points to the var.  Auto dereference.
7061:                      [ equal_zero( uplevels )
7068:                         | true :  .tPushParamP  @EmitValue( decl )
7078:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7098:                      ]
7098:                      .tFetchB
7100:                   | * :
7105:                      [ equal_zero( uplevels )
7112:                         | true :  .tPushParamB  @EmitValue( decl )
7122:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7142:                      ]
7142:                ]
7142:          ]
      
7154:       | nFileType :
7156:          #eNotImplemented
      
7158:       | nPointerType, nUniversalPointerType :
7160:          [ oNodeType( decl )
7167:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7177:             | nLocalVar :
7179:                [ equal_zero( uplevels )
7186:                   | true :  .tPushLocalP  @EmitValue( decl )
7196:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7216:                ]
7216:             | nParam :
7218:                [ oNodeGetBoolean( decl, qInOut )
7228:                   | true :    % VAR param points to the var.  Auto dereference.
7229:                      [ equal_zero( uplevels )
7236:                         | true :  .tPushParamP  @EmitValue( decl )
7246:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7266:                      ]
7266:                      .tFetchP
7268:                   | * :
7273:                      [ equal_zero( uplevels )
7280:                         | true :  .tPushParamP  @EmitValue( decl )
7290:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7310:                      ]
7310:                ]               
7310:          ]
7322:          [
7322:             | '^' :             % dereferenced
7324:                oTypeSPop
7325:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7338:                @LValueIndexes
7340:                @FetchVar
7342:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7344:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7346:                @LValueIndexes
7348:                @FetchVar
7350:             | * :               % just ptr value alone
7357:          ]
      
7357:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7359:          [ oNodeType( decl )
7366:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7376:             | nLocalVar :
7378:                [ equal_zero( uplevels )
7385:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7395:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7415:                ]
7415:             | nParam :
7417:                [ oNodeGetBoolean( decl, qInOut )
7427:                   | true :    % VAR param points to the var.  Auto dereference.
7428:                      [ equal_zero( uplevels )
7435:                         | true :  .tPushParamP  @EmitValue( decl )
7445:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7465:                      ]
7465:                   | * :
7470:                      [ equal_zero( uplevels )
7477:                         | true :  .tPushAddrParam  @EmitValue( decl )
7487:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7507:                      ]
7507:                ]
7507:          ]
               % modify addr for subscripts, field references, etc
7519:          @LValueIndexes
               % get final value
7521:          @FetchVar
7523:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7550: FetchVar:
7552:    [ oTypeSNodeType
7554:       | nIntegerType, nEnumType :  .tFetchI
7557:       | nBooleanType, nByteType, nCharType :  .tFetchB
7561:       | nFileType :   #eNotImplemented
7565:       | nPointerType :             .tFetchP
7569:       | nUniversalPointerType :    #eCantDereference
7573:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7575:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7604: LValueIndexes:
7606:    {[
7606:       | '[' :
7608:          [ oTypeSNodeType
7610:             | nArrayType :    @ArraySubscripts
7613:             | nPointerType :  @PointerArraySubscript
7617:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7621:             | * :             #eNotArray
7634:          ]
7634:       | '.' :       @RecordFieldRef
7638:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7642:       | * :         >
7653:    ]};
      
      
7656: ArraySubscripts:
7658:    [ oTypeSNodeType
7660:       | nArrayType :
7661:       | * :       #eNotArray
7668:    ]
7668:    {
7668:       [ oTypeSNodeType
7670:          | nArrayType :
7671:          | * :    #eTooManySubscripts
7678:       ]
      
            % low subscript of this dimension
7678:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7695:       Node baseType
7695:       baseType = oNodeGet( oTypeSTop, qBaseType )
7707:       oTypeSPop
7708:       oTypeSPush( baseType )
      
7714:       @Expr
7716:       @RequireIntPop
            % adjust for low subscript
7718:       [ equal_zero( low )
7725:          | false :
7726:             .tPushConstI oEmitInt( low ) .tSubI
7736:          | * :
7741:       ]
      
            % multiply by element size
7741:       int size = oNodeGetInt( baseType, qSize )
7754:       [ equal( size, 1 )
7764:          | false :
7765:             .tPushConstI oEmitInt( size ) .tMultI
7775:          | * :
7780:       ]
      
            % update start address
7780:       .tAddPI
7782:       [
7782:          | ']' :  >
7786:          | ',' :
7788:       ]
7796:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7799: PointerArraySubscript:
7801:    [ oTypeSNodeType
7803:       | nPointerType :
7804:       | * :    #eCantDereference
7811:    ]
         % replace type stack with base type
7811:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7823:    oTypeSPop
7824:    oTypeSPush( baseType )
         
7830:    @Expr
7832:    @RequireIntPop
         % multiply by element size
7834:    int size = oNodeGetInt( baseType, qSize )
7847:    [ equal( size, 1 )
7857:       | false :
7858:          .tPushConstI  oEmitInt( size )  .tMultI
7868:       | * :
7873:    ]
         % update start address
7873:    .tAddPI
7875:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7878: ShortStringArraySubscript:
7880:    [ oTypeSNodeType
7882:       | nStrLitType, nShortStringType :
7883:       | * :    #eCantDereference
7892:    ]
7892:    oTypeSPop
7893:    oTypeSPush( CharType )
7899:    @Expr
7901:    @RequireIntPop
7903:    .tAddPI
7905:    ']';
      
      
7908: RecordFieldRef:
7910:    [ oTypeSNodeType
7912:       | nRecordType :
7913:       | * :    #eNotRecord
7920:    ]
7920:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7932:    pIdent
7934:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7939:    [ oNodeType( field )
7946:       | nRecordField :
7947:       | * :   #eNotRecordField
7954:    ]
7954:    oScopeEnd
7955:    int offset = oNodeGetInt( field, qValue )
7968:    [ equal_zero( offset )
7975:       | false :
7976:          .tPushConstI oEmitInt( offset ) .tAddPI
7986:       | * :
7991:    ]
      
         % replace the type on the type stack, with the field type
7991:    oTypeSPop
7992:    oTypeSPush( oNodeGet( field, qType ) )
8006:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8006: PointerAddition:
8008:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8020:    int elementSize = oNodeGetInt( elementType, qSize )
8033:    [ equal( elementSize, 1 )
8043:       | false :
8044:          .tPushConstI  oEmitInt( elementSize )
8052:          .tMultI
8054:       | * :
8059:    ]
8059:    .tAddPI
8062:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8062: PointerSubInt:
8064:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8076:    int elementSize = oNodeGetInt( elementType, qSize )
8089:    [ equal( elementSize, 1 )
8099:       | false :
8100:          .tPushConstI  oEmitInt( elementSize )
8108:          .tMultI
8110:       | * :
8115:    ]
8115:    .tSubPI
8118:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8118: PointerSubPointer:
8120:    .tSubP
8122:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8134:    int elementSize = oNodeGetInt( elementType, qSize )
8147:    [ equal( elementSize, 1 )
8157:       | false :
8158:          .tPushConstI  oEmitInt( elementSize )
8166:          .tDivI
8168:       | * :
8173:    ]
8173:    oTypeSPop
8174:    oTypeSPush( IntegerType )
8181:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8181: PointerDeref:
8183:    [ oTypeSNodeType
8185:       | nPointerType :
8186:       | nUniversalPointerType :   #eCantDereference
8190:       | * :       #eNotPointer
8199:    ]
8199:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8201:    Node theType = oTypeSTop
8206:    oTypeSPop
8207:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8221:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8221: CoerceType:
8223:    node_type nt = oTypeSNodeType
8228:    Node given = oTypeSTop
8233:    oTypeSPop
8234:    [ equal_node_type( nt, oTypeSNodeType )
8243:       | false :
               % Can we implicitly convert the value to the desired type?
8244:          [ oTypeSNodeType
8246:             | nIntegerType :
8247:                [ nt
8250:                   | nByteType :   .tCastBtoI  >>
8254:                   | * :
8259:                ]
8259:             | nByteType :
8261:                [ nt
8264:                   | nIntegerType :   .tCastItoB  >>
8268:                   | * :
8273:                ]
8273:             | nPointerType :
8275:                [ nt
8278:                   | nUniversalPointerType :  >>
8280:                   | nStrLitType :
8282:                      [ equal_node( oTypeSTop, PCharType )
8291:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8292:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8303:                         | * :
8308:                      ]
8308:                   | * :
8315:                ]
8315:             | nUniversalPointerType :
8317:                [ nt
8320:                   | nPointerType :  >>
8322:                   | * :
8327:                ]
8327:             | nShortStringType :
8329:                [ nt
8332:                   | nStrLitType :  >>
8334:                   | nCharType :
                           % Store char as a temp ShortString.
8336:                      oTypeSPush( CharType )
8342:                      int tempOffset = @MoveIntoTempShortString
8348:                      oTypeSPop
8349:                      >>
8350:                   | * :
8357:                ]
8357:             | * :
8370:          ]
8370:          #eTypeMismatch
8372:       | * :
8377:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8378: CastType:
8380:    node_type nt = oTypeSNodeType
8385:    oTypeSPop
8386:    [ equal_node_type( nt, oTypeSNodeType )
8395:       | false :
               % Can we cast the value to the desired type?
8396:          [ oTypeSNodeType
8398:             | nIntegerType, nEnumType :
8399:                [ nt
8402:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8406:                   | nIntegerType, nEnumType :   >>
8409:                   | * :
8422:                ]
8422:             | nByteType, nCharType, nBooleanType :
8424:                [ nt
8427:                   | nByteType, nCharType, nBooleanType :   >>
8429:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8434:                   | * :
8447:                ]
8447:             | nPointerType :
8449:                [ nt
8452:                   | nUniversalPointerType :  >>
8454:                   | nStrLitType :
8456:                      [ equal_node( oTypeSTop, PCharType )
8465:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8466:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8477:                         | * :
8482:                      ]
8482:                   | * :
8489:                ]
8489:             | nUniversalPointerType :
8491:                [ nt
8494:                   | nPointerType :  >>
8496:                   | * :
8501:                ]
8501:             | nShortStringType :
8503:                [ nt
8506:                   | nStrLitType :  >>
8508:                   | nCharType :
                           % Store char as a temp ShortString.
8510:                      oTypeSPush( CharType )
8516:                      int tempOffset = @MoveIntoTempShortString
8522:                      oTypeSPop
8523:                      >>
8524:                   | * :
8531:                ]
8531:             | * :
8550:          ]
8550:          #eTypeMismatch
8552:       | * :
8557:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8558: MatchTypes:
8560:    node_type nt = oTypeSNodeType
8565:    oTypeSPop
8566:    [ equal_node_type( nt, oTypeSNodeType )
8575:       | false :
               % Some implicit conversion is allowed even here
8576:          [ oTypeSNodeType
8578:             | nPointerType :
8579:                [ nt
8582:                   | nUniversalPointerType :  >>
8584:                   | * :
8589:                ]
8589:             | nUniversalPointerType :
8591:                [ nt
8594:                   | nPointerType :  >>
8596:                   | * :
8601:                ]
8601:             | * :
8608:          ]
8608:          #eTypeMismatch
8610:       | * :
8615:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8616: RequireIntPop:
8618:    [ oTypeSNodeType
8620:       | nIntegerType :
8621:       | * :          #eNotInteger
8628:    ]
8628:    oTypeSPop;
      
8630: RequireInt:
8632:    [ oTypeSNodeType
8634:       | nIntegerType :
8635:       | * :          #eNotInteger
8642:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
8643: PromoteToIntPop:
8645:    [ oTypeSNodeType
8647:       | nIntegerType :
8648:       | nByteType :        .tCastBtoI
8652:       | * :                #eNotInteger
8661:    ]
8661:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8663: PromoteToInt:
8665:    [ oTypeSNodeType
8667:       | nIntegerType :
8668:       | nByteType :        .tCastBtoI
8672:                            oTypeSPop
8673:                            oTypeSPush( IntegerType )
8679:       | * :                #eNotInteger
8688:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8689: PromoteToIntOptional:
8691:    [ oTypeSNodeType
8693:       | nByteType :        .tCastBtoI
8696:                            oTypeSPop
8697:                            oTypeSPush( IntegerType )
8703:       | * :
8708:    ];
      
      
8709: RequireBoolPop:
8711:    [ oTypeSNodeType
8713:       | nBooleanType :
8714:       | * :          #eNotBoolean
8721:    ]
8721:    oTypeSPop;
      
8723: RequireBool:
8725:    [ oTypeSNodeType
8727:       | nBooleanType :
8728:       | * :          #eNotBoolean
8735:    ];
      
      
8736: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8736: Statement:
8738:    [
8738:       | pWriteln :     @WritelnStmt
8742:       | pWrite :       @WriteStmt
8746:       | pReadln :      @ReadlnStmt
8750:       | pRead :        @ReadStmt
8754:       | pIf :          @IfStmt
8758:       | pWhile :       @WhileStmt
8762:       | pFor :         @ForStmt
8766:       | pRepeat :      @RepeatStmt
8770:       | pBreak :       @BreakStmt
8774:       | pContinue :    @ContinueStmt
8778:       | pBegin :       @BeginStmt
8782:       | pIdent :       @LabelOrAssignOrCallStmt
8786:       | pCase :        @CaseStmt
8790:       | pGoto :        @GotoStmt
8794:       | pIntLit :      % should be an integer label
8796:                        oChangeIntLitToLabelIdent
8797:                        @LabelOrAssignOrCallStmt
8799:       | * :            % null statement : don't accept any tokens
8832:    ];
      
      
8833: LabelOrAssignOrCallStmt:
8835:    Node decl = oScopeFindRequire
8840:    @ResolveUnitRef( decl )
8847:    [ oNodeType( decl )
8854:       | nLabel :                          @LabelDefinition( decl )
8862:                                           @Statement
8864:       | nProc :                           @Call( decl )
8873:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
8875:                                           @AssignStmt( decl )
8882:       | nFunc :                           @AssignResultStmt( decl )
8891:       | * :                               #eBadStatement
8910:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8911: LabelDefinition( Node decl ):
8913:    [ oNodeGetBoolean( decl, qDefined )
8923:       | true :  #eAlreadyDefined
8926:       | * :
8931:    ]
8931:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8946:    oNodeSetBoolean( decl, qDefined, true )
8958:    ':'
8961:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8961: AssignStmt( Node decl ):
8963:    @LValueFromDecl( decl, true )
8973:    ':=' 
8975:    @Expr
8977:    @CoerceType
8979:    @Assign
8982:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8982: Assign:
8984:    [ oTypeSNodeType
8986:       | nIntegerType, nEnumType :  .tAssignI
8989:       | nBooleanType, nByteType, nCharType :  .tAssignB
8993:       | nFileType :   #eNotImplemented
8997:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9001:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9003:           int size = oNodeGetInt( oTypeSTop, qSize )
9015:           .tCopy  oEmitInt( size )    % multi-word copy
9023:    ]
9049:    oTypeSPop
9051:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9051: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9053:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9069:       | false :   #eNotCurrentFunction
9072:       | * :
9077:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9077:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9092:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9105:    ':='
9107:    @Expr
9109:    @CoerceType
9111:    [ oTypeSNodeType
9113:       | nIntegerType, nEnumType : .tAssignI
9116:       | nBooleanType, nByteType, nCharType :  .tAssignB
9120:       | nFileType :   #eNotImplemented
9124:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9128:       | nArrayType, nRecordType, nShortStringType :
9130:           int size = oNodeGetInt( oTypeSTop, qSize )
9142:           .tCopy  oEmitInt( size )    % multi-word copy
9150:    ]
9176:    oTypeSPop
9178:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9178: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9180:    pIdent
9182:    Node decl = oScopeFindRequire
9187:    @ResolveUnitRef( decl )
9194:    @LValueFromDecl( decl, writeable )
9205:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9205: LValueFromDecl( Node decl, boolean writeable ):
9207:    [ oNodeType( decl )
9214:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9215:          @LValueVar( decl, writeable )
      
9225:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9227:          oTypeSPush( oNodeGet( decl, qType ) )
9240:          '('
9242:          @LValueExpr( writeable )
9249:          ')'
9251:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9253:          [ oTypeSNodeType
9255:             | nPointerType :
9256:                [
9256:                   | '[' :
                           % dereference the pointer var first
9258:                      .tFetchP
9260:                      @PointerArraySubscript
9262:                   | * :
9267:                ]
9267:             | * :
9272:          ]
               % additional subscripts, if any
9272:          @LValueIndexes
       
9274:       | * :  #eNotVar
9289:    ]
9290:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9290: LValueCastType:
9292:    node_type nt = oTypeSNodeType
9297:    oTypeSPop
9298:    [ equal_node_type( nt, oTypeSNodeType )
9307:       | false :
               % Can we cast the value to the desired type?
9308:          [ oTypeSNodeType
9310:             | nIntegerType, nEnumType :
9311:                [ nt
9314:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9318:                   | nIntegerType, nEnumType :   >>
9321:                   | * :
9334:                ]
9334:             | nByteType, nCharType, nBooleanType :
9336:                [ nt
9339:                   | nByteType, nCharType, nBooleanType :   >>
9341:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9346:                   | * :
9359:                ]
9359:             | nPointerType :
9361:                [ nt
9364:                   | nUniversalPointerType :  >>
9366:                   | * :
9371:                ]
9371:             | nUniversalPointerType :
9373:                [ nt
9376:                   | nPointerType :  >>
9378:                   | * :
9383:                ]
9383:             | nShortStringType :
9385:                [ nt
9388:                   | nStrLitType :  >>
9390:                   | * :
9395:                ]
9395:             | * :
9414:          ]
9414:          #eTypeMismatch
9416:       | * :
9421:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9422: LValueVar( Node decl, boolean writeable ):
9424:    [ oNodeType( decl )
9431:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9441:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9452:       | nParam :
9454:          [ oNodeGetBoolean( decl, qInOut )
9464:             | true :   % VAR param points to variable.  No dereference.
9465:                        .tPushParamP @EmitValue( decl )
9474:             | * :      .tPushAddrParam @EmitValue( decl )
9488:          ]
9488:       | nTypedConst :
9490:          [ writeable
9493:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9503:             | * :      #eNotVar
9510:          ]
9510:       | * :            #eNotVar
9523:    ]
      
9523:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9536:    [ oTypeSNodeType
9538:       | nPointerType :
9539:          [
9539:             | '[' :
                     % dereference the pointer var first
9541:                .tFetchP
9543:                @PointerArraySubscript
9545:             | * :
9550:          ]
9550:       | * :
9555:    ]
         % additional subscripts, if any
9555:    @LValueIndexes
9558:    ;
      
      
9558: IncVar( Node decl ):
9560:    @LValueVar( decl, true )
9570:    @RequireIntPop
9572:    @VarExpr( decl )
9579:    oTypeSPop
9580:    .tIncI
9582:    .tAssignI;
      
9585: DecVar( Node decl ):
9587:    @LValueVar( decl, true )
9597:    @RequireIntPop
9599:    @VarExpr( decl )
9606:    oTypeSPop
9607:    .tDecI
9609:    .tAssignI;
      
      
9612: IfStmt:
9614:    Label falseLabel = labelNull
      
9620:    @BooleanExprControlFlow( falseLabel )
9627:    pThen
9629:    @Statement
9631:    [
9631:       | pElse :
9633:          Label doneLabel = oLabelNew
      
9638:          .tJump  oEmitLabel( doneLabel )
9646:          .tLabel oEmitLabel( falseLabel )
9654:          @Statement
9656:          .tLabel oEmitLabel( doneLabel )
      
9664:       | * :
9669:          .tLabel oEmitLabel( falseLabel )
9677:    ];
      
      
9678: ForStmt:
9680:    pIdent
      
9682:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9687:    @LValueVar( decl, true )
9697:    @RequireIntPop
      
9699:    ':='
      
9701:    @Expr
9703:    @RequireIntPop
9705:    .tAssignI
      
9707:    Label breakLabel = oLabelNew
      
9712:    Label checkLabel = oLabelNew
9717:    .tJump  oEmitLabel( checkLabel )
      
9725:    Label continueLabel = oLabelNew
9730:    .tLabel  oEmitLabel( continueLabel )
9738:    [
9738:       | pTo :
9740:          @IncVar( decl )
9747:          .tLabel  oEmitLabel( checkLabel )
9755:          @VarExpr( decl )  oTypeSPop
9763:          @Expr
9765:          @RequireIntPop
9767:          .tGreaterI
9769:          .tJumpTrue  oEmitLabel( breakLabel )
9777:       | pDownto :
9779:          @DecVar( decl )
9786:          .tLabel  oEmitLabel( checkLabel )
9794:          @VarExpr( decl )  oTypeSPop
9802:          @Expr
9804:          @RequireIntPop
9806:          .tLessI
9808:          .tJumpTrue  oEmitLabel( breakLabel )
9816:    ]
9824:    oLoopPush( continueLabel, breakLabel )
9833:    pDo
9835:    @Statement
9837:    .tJump  oEmitLabel( continueLabel )
9845:    .tLabel  oEmitLabel( breakLabel )
9853:    oLoopPop;
      
      
9855: RepeatStmt:
9857:    Label continueLabel = oLabelNew
9862:    .tLabel  oEmitLabel( continueLabel )
      
9870:    Label breakLabel = oLabelNew
      
9875:    oLoopPush( continueLabel, breakLabel )
9884:    @Statement
9886:    {[
9886:       | ';' :
9888:          @Statement
9890:       | pUntil :
9892:          Label falseLabel
9892:          @BooleanExprControlFlow( falseLabel )
9899:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9913:          >
9915:    ]}
9925:    .tLabel  oEmitLabel( breakLabel )
9933:    oLoopPop;
      
      
9935: WhileStmt:
9937:    Label continueLabel = oLabelNew
9942:    .tLabel  oEmitLabel( continueLabel )
      
9950:    Label breakLabel
9950:    @BooleanExprControlFlow( breakLabel )
      
9957:    oLoopPush( continueLabel, breakLabel )
9966:    pDo
9968:    @Statement
9970:    .tJump  oEmitLabel( continueLabel )
9978:    .tLabel  oEmitLabel( breakLabel )
9986:    oLoopPop;
      
      
9988: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9990:    [ equal_label( oLoopContinueLabel, labelNull )
9999:       | true :
10000:          #eNotInALoop
10002:       | false :
10004:          .tJump  oEmitLabel( oLoopContinueLabel )
10011:    ];
      
      
10020: BreakStmt:
10022:    [ equal_label( oLoopBreakLabel, labelNull )
10031:       | true :
10032:          #eNotInALoop
10034:       | false :
10036:          .tJump  oEmitLabel( oLoopBreakLabel )
10043:    ];
      
      
10052: CaseStmt:
10054:    Code tableCode = oCodeNew
10059:    Label tableLabel = oLabelNew
10064:    Label doneLabel = oLabelNew
10069:    Label otherwiseLabel = doneLabel
10075:    boolean isString = false
      
10081:    @Expr
         % Leave the expr type on the type stack throughout case statement
10083:    [ oTypeSNodeType
10085:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10094:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10104:       | nShortStringType, nStrLitType :        isString = true
10112:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10120:       | * :     #eNotAllowed
10139:    ]
10139:    pOf
      
10141:    {
10141:       [
10141:          | pOtherwise, pElse :
10143:             otherwiseLabel = oLabelNew
10148:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10156:             {[
10156:                | pEnd :  >
10160:                | * :
10165:                   @Statement
10167:                   [
10167:                      | ';' :
10169:                      | * :   pEnd  >
10178:                   ]
10178:             ]}
10180:             >
      
10182:          | pEnd :
                  % Reached end with no otherwise clause
10184:             >
      
10186:          | * :
10195:             Label caseLabel = oLabelNew
10200:             oCodePush( tableCode )
10206:             {
10206:                @ConstExpr
10208:                @ConstCoerceType
10210:                int val
10210:                [ isString
10213:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10223:                   | false :   val = oValueTop
10230:                ]
10238:                oValuePop
10239:                [
10239:                   | '..' :  @ConstExpr
10243:                             @ConstCoerceType
10245:                             int highval
10245:                             [ isString
10248:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10258:                                | false :  highval = oValueTop
10265:                             ]
10273:                             oValuePop
10274:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10294:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10313:                ]
10313:                [
10313:                   | ',' :
10315:                   | * :  >
10322:                ]
10322:             }
10324:             oCodePop
10325:             ':'
10327:             .tLabel  oEmitLabel( caseLabel )
10335:             @Statement
10337:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10345:             [
10345:                | ';' :
10347:                | * :
10352:             ]
                  
10352:       ]
         
10352:    }
      
10354:    .tLabel  oEmitLabel( tableLabel )
10362:    oEmitCode( tableCode )
10368:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10376:    .tLabel  oEmitLabel( doneLabel )
10384:    oTypeSPop
10386:    ;
      
      
10386: GotoStmt:
10388:    [
10388:       | pIdent :
10390:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10392:          oChangeIntLitToLabelIdent
10393:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10401:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10410:    oNodeSetBoolean( decl, qUsed, true )
10422:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10438:    ;
      
      
10438: BeginStmt:
10440:    @Statement
10442:    {[
10442:       | ';' :   @Statement
10446:       | pEnd :  >
10450:    ]};
      
      
10461: WritelnStmt:
10463:    @WriteStmt
10465:    .tWriteCR;
      
      
10468: WriteStmt:
10470:    [
10470:       | '(' :
10472:          {
10472:             @Expr
10474:             [ oTypeSNodeType
10476:                | nIntegerType :             .tWriteI
10479:                | nBooleanType :             .tWriteBool
10483:                | nByteType :                .tCastBtoI  .tWriteI
10489:                | nCharType :                .tWriteChar
10493:                | nDoubleType :              .tWriteD
10497:                | nShortStringType, nStrLitType :   .tWriteShortStr
10501:                | nFileType :                #eNotImplemented
10505:                | nEnumType :
                        % write name via table lookup
10507:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10521:                   .tWriteEnum
10523:                | nPointerType :
10525:                   [ equal_node( oTypeSTop, PCharType )
10534:                      | true :               .tWritePChar
10537:                      | * :                  .tWriteP
10544:                   ]
10544:                | nUniversalPointerType :    .tWriteP
10548:                | * :                        #eNotAllowed
10575:             ]
10575:             oTypeSPop
10576:             [
10576:                | ')' : >
10580:                | ',' :
10582:             ]
10590:          }
10592:       | * :
10597:    ];
      
      
10598: ReadlnStmt:
10600:    @ReadStmt
10602:    .tReadCR;
      
      
10605: ReadStmt:
10607:    [
10607:       | '(' :
10609:          {
10609:             @LValueExpr( true )
10616:             [ oTypeSNodeType
10618:                | nIntegerType :      .tReadI
10621:                | nCharType :         .tReadChar
10625:                | nShortStringType :  
10627:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
10646:                    .tReadShortStr  oEmitInt( capacity )
10654:                | * :                 #eNotAllowed
10665:             ]
10665:             oTypeSPop
10666:             [
10666:                | ')' : >
10670:                | ',' :
10672:             ]
10680:          }
10682:       | * :
10687:    ];
10688: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
10688: MoveIntoTempShortString >> int:
10690:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
10700:    [ oTypeSNodeType
10702:       | nShortStringType, nStrLitType :
10703:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
10711:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
10713:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
10728:       | nCharType :
               % temp[0] = 1
10730:          .tPushAddrLocal  oEmitInt( tempOffset )
10738:          .tPushConstI  oEmitInt( 1 )
10746:          .tAssignB
               % temp[1] = value
10748:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
10763:          .tSwap
10765:          .tAssignB
10767:       | * :   #eTypeMismatch
10778:    ]
10778:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
10779:    .tPushAddrLocal  oEmitInt( tempOffset )
10787:    oTypeSPush( ShortStringType )
10793:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10797: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
10799:    .tAllocActuals  oEmitInt( 16 )
10807:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10819:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10831:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
10840:    .tFreeActuals  oEmitInt( 16 )
10848:    oTypeSPop
10849:    oTypeSPop
10851:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
10851: ShortStringAppendChar:
         % Note at the moment I don't align params
10853:    .tAllocActuals  oEmitInt( 12 )
10861:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
10873:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10885:    .tCall  @EmitValue( System_ShortStringAppendChar )
10894:    .tFreeActuals  oEmitInt( 12 )
10902:    oTypeSPop
10903:    oTypeSPop
10905:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
10905: ShortStringCmp:
10907:    .tAllocActualsCdecl  oEmitInt( 24 )
10915:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
10927:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
10939:    int tempOffset = oScopeAllocType( IntegerType )
10949:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
10967:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
10976:    .tPushLocalI  oEmitInt( tempOffset )
10984:    .tFreeActuals  oEmitInt( 24 )
10992:    oTypeSPop
10993:    oTypeSPush( IntegerType )
11000:    ;
11000: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11000: Call( Node method ):
11002:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11014:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11027:    Node resultType
11027:    int tempOffset
      
11027:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11044:    [ isFunc
11047:       | true :
11048:          resultType = oNodeGet( method, qType )
11061:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11071:       | * :
11076:    ]
         
      
11076:    Node paramScope = oNodeGet( method, qParams )
11089:    int actualsSize = oNodeGetInt( paramScope, qSize )
11102:    [ cdecl
11105:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11114:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11124:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11132:    [ greater( @DeclLevel( method ), 0 )
11147:       | true :
11148:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11156:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11175:          .tAssignP
11177:       | * :
11182:    ]
      
      
11182:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11195:    Node param = oNodeIterValue( paramIter )
11205:    [
11205:       | '(' :
            
11207:          {
11207:             [ oNodeNull( param )
11214:                | true : >
11217:                | * :
11222:             ]
      
11222:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11235:             .tPushAddrActual oEmitInt( offset )
11243:             oTypeSPush( oNodeGet( param, qType ) )
      
11256:             [ oNodeGetBoolean( param, qInOut )
11266:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11267:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11274:                           @MatchTypes
      
11276:                           .tAssignP
      
11278:                | false :  @Expr
11282:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11284:                           [ oTypeSNodeType
11286:                              | nIntegerType, nEnumType : .tAssignI
11289:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11293:                              | nFileType :   #eNotImplemented
11297:                              | nPointerType, nUniversalPointerType :  .tAssignP
11301:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11303:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11315:                                  .tCopy  oEmitInt( size )    % multi-word copy
11323:                           ]
11349:             ]
11357:             oTypeSPop
      
11358:             oNodeIterNext( paramIter )
11364:             param = oNodeIterValue( paramIter )
11374:             [ oNodeNull( param )
11381:                | true :  >
11384:                | false :
11386:             ]
      
11394:             ','
11396:          }
      
11398:          ')'
      
11400:       | * :
11405:    ]
      
11405:    [ oNodeNull( param )
11412:       | false :    #eMissingParameter
11415:       | * :
11420:    ]
      
11420:    [ isFunc
11423:       | true :
               % Pass result temp as an additional VAR parameter.
11424:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11439:          .tPushAddrLocal  oEmitInt( tempOffset )
11447:          .tAssignP
11449:       | * :
11454:    ]
      
11454:    [ cdecl
11457:       | true :
11458:          .tCallCdecl  @EmitValue( method )
11467:       | false :
11469:          .tCall   @EmitValue( method )
11478:    ]
      
11486:    [ isFunc
11489:       | true :
               % push return value from temp
11490:          oTypeSPush( resultType )
      
11496:          [ oTypeSNodeType
11498:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11507:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11517:             | nFileType :  #eNotImplemented
11521:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11531:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11533:                                .tPushAddrLocal  oEmitInt( tempOffset )
11541:          ]
11567:       | * :
11572:    ]
         
11572:    .tFreeActuals  oEmitInt( actualsSize )
11581:    ;
      
      
      
      % Called on first use of an extern method
      %
11581: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
11583:    int strAddr
11583:    String externalName = oNodeGetString( method, qExternalName )
11596:    [ equal_string( externalName, stringNull )
11606:       | true :
11607:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
11628:       | false :
11630:          strAddr = oStringAllocLit( externalName )
11640:    ]
11648:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
11664:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11664: CallBuiltInFunc( Node method ):
      
         % Ord(x)
11666:    [ oNodeEqual( method, BuiltIn_Ord )
11676:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
11677:          '('
11679:          @Expr
11681:          [ oTypeSNodeType
11683:             | nIntegerType, nEnumType :
11684:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
11688:             | * :  #eTypeMismatch
11703:          ]
11703:          oTypeSPop
11704:          oTypeSPush( IntegerType )
11710:          ')'
11712:          >>
11713:       | * :
11718:    ]
      
         % Chr(x)
11718:    [ oNodeEqual( method, BuiltIn_Chr )
11728:       | true :
               % parameter is integer
               % result is char
11729:          '('
11731:          @Expr
11733:          [ oTypeSNodeType
11735:             | nIntegerType :    .tCastItoB
11738:             | nByteType :
11740:             | * :  #eTypeMismatch
11749:          ]
11749:          oTypeSPop
11750:          oTypeSPush( CharType )
11756:          ')'
11758:          >>
11759:       | * :
11764:    ]
      
         % Pred(x)
11764:    [ oNodeEqual( method, BuiltIn_Pred )
11774:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11775:          '('
11777:          @Expr
11779:          [ oTypeSNodeType
11781:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11782:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11791:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11794:                   | * :
11799:                ]
11799:             | * :  #eTypeMismatch
11806:          ]
11806:          .tDecI
11808:          ')'
11810:          >>
11811:       | * :
11816:    ]
      
         % Succ(x)
11816:    [ oNodeEqual( method, BuiltIn_Succ )
11826:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
11827:          '('
11829:          @Expr
11831:          [ oTypeSNodeType
11833:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
11834:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
11843:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
11846:                   | * :
11851:                ]
11851:             | * :  #eTypeMismatch
11858:          ]
11858:          .tIncI
11860:          ')'
11862:          >>
11863:       | * :
11868:    ]
      
         % Sizeof(x)
11868:    [ oNodeEqual( method, BuiltIn_Sizeof )
11878:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
11879:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
11881:          Code dummyCode = oCodeNew
11886:          oCodePush( dummyCode )
11892:          @ExprAllowTypeName
11894:          oCodePop
11895:          oCodeDiscard( dummyCode )
11901:          Node theType = oTypeSTop
11906:          oTypeSPop
11907:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
11922:          oTypeSPush( IntegerType )
11928:          ')'
11930:          >>
      
11931:       | * :
11936:    ]
      
11936:    #eNotImplemented
11939:    ;
      
11939: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11939: newType( node_type nt, int size ) >> Node:
11941:   Node node = oNodeNew( nt )
11951:   oNodeSetInt( node, qSize, size )
11963:   oTypeAdd( node )
11969:   >> node
11973:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
11973: TypeRef( out Node resultType ):
11975:    [
11975:       | pIdent :           % previously named type (including intrinsics)
11977:          Node decl = oScopeFindRequire
11982:          @ResolveUnitRef( decl )
11989:          [ oNodeType( decl )
11996:             | nTypeDecl :
11997:                resultType = oNodeGet( decl, qType )
12010:             | * :
12015:                #eNotType
12017:                resultType = IntegerType
12023:          ]
         
12023:       | pArray :
12025:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12027:          NodeVec dimensions = oNodeVecNew
      
12032:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12032:             Node subrange = oNodeNew( nSubrangeType )
      
12042:             @ConstExpr
12044:             oNodeSetInt( subrange, qLow, oValueTop )
12055:             oValuePop
12056:             '..'
12058:             @ConstExpr
12060:             oNodeSetInt( subrange, qHigh, oValueTop )
12071:             oValuePop
      
12072:             @ConstMatchTypes
12074:             oNodeSet( subrange, qBaseType, oTypeSTop )
12085:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12103:             oTypeSPop
12104:             oTypeAdd( subrange )
      
12110:             Node a = oNodeNew( nArrayType )
12120:             oNodeSet( a, qIndexType, subrange )
      
12132:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12141:             [
12141:                | ']' : >
12145:                | ',' :
12147:             ]
12155:          }
      
12157:          pOf
12159:          Node baseType
12159:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12166:          int dim = oNodeVecSize( dimensions )
      
12176:          {
12176:              dec(dim)
      
12182:              Node a = oNodeVecElement( dimensions, dim )
      
12195:              oNodeSet( a, qBaseType, baseType )
12207:              Node subrange = oNodeGet( a, qIndexType )
12220:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12247:              inc( width )
12253:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12279:              oTypeAdd( a )
12285:              baseType = a
      
12291:              [ equal_zero(dim)
12298:                  | true:  >
12301:                  | *:
12306:              ]
12306:          }
      
12308:          resultType = oNodeVecElement( dimensions, 0 )
12321:          oNodeVecDelete( dimensions )
      
12327:       | '^' :
12329:          Node theType
12329:          @TypeRef( theType )
12336:          resultType = @PointerTypeTo( theType )
      
12347:       | pRecord :
12349:          resultType = oNodeNew( nRecordType )
12359:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12368:          @VarDecl( nRecordField )
      
12375:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12387:          [ equal_zero( size )
12394:             | true : #eRecordEmpty
12397:             | * :
12402:          ]
      
12402:          pEnd
      
12404:          oNodeSet( resultType, qScope, oScopeCurrent )
12415:          oNodeSetInt( resultType, qSize, size )
12427:          oScopeEnd
12428:          oTypeAdd( resultType )
      
      
12434:       | '(' :
               % An enum type declaration.
12436:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12443:       | pSet :
12445:          pOf
12447:          Node theType
12447:          @TypeRef( theType )
12454:          #eNotImplemented
12456:       | * :       % this works for cases except where expr starts with an id
12471:          @ConstExpr '..' @ConstExpr
12477:          @ConstMatchTypes
12479:          #eNotImplemented
12481:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12482: EnumTypeRef( out Node resultType ):
      
12484:    resultType = oNodeNew( nEnumType )
12494:    int value = 0
12500:    int numValues = 0
12506:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12512:    Node outerScope = oScopeCurrent
12517:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12526:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12526:       pIdent
12528:       Node decl = @newIdent( nEnumValue, LAST_ID )
12541:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12554:       oNodeSet( decl, qType, resultType )
12566:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
12578:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
12591:       oNodeSetInt( decl, qNameOffset, nameOffset )
12603:       oNodeSetInt( decl2, qNameOffset, nameOffset )
12615:       [
12615:          | '=', ':=' :
12617:             oTypeSPush( IntegerType )
12623:             @ConstExpr
12625:             @ConstCoerceType
12627:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
12628:             [ equal_zero( numValues )
12635:                | false :
12636:                   [ greater( oValueTop, value )
12645:                      | false :   #eEnumValueNotAscending
12648:                      | * :
12653:                   ]
12653:                | * :
12658:             ]
12658:             [ equal( value, oValueTop )
12667:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
12668:                   oNodeSetBoolean( resultType, qHasGap, true )
12680:                | * :
12685:             ]
12685:             value = oValueTop
12690:             oValuePop
12691:          | * :
12698:       ]
12698:       oNodeSetInt( decl, qValue, value )
12710:       oNodeSetInt( decl2, qValue, value )
12722:       oScopeDeclare( decl )
      
12728:       oScopeEnter( outerScope )
12734:       oScopeDeclare( decl2 )
12740:       oScopeEnd
      
12741:       inc( value )
12747:       inc( numValues )
12753:       [
12753:          | ',' :
12755:          | * :    >
12762:       ]
12762:    }
12764:    ')'
      
12766:    oNodeSet( resultType, qScope, oScopeCurrent )
12777:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
12789:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
12790:    oCodePush( @GetOrCreateInitCode( globalScope ) )
12801:    oScopeEnter( globalScope )
12807:    int size = multiply( add( numValues, 1 ), 16 )
12827:    int addr = oScopeAlloc( size, 8 )
12840:    oScopeEnd
12841:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
12853:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
12873:    {
12873:       Node enumValue = oNodeIterValue( it )
12883:       [ oNodeNull( enumValue )
12890:          | true :  >
12893:          | * :
12898:       ]
12898:       .tPushAddrGlobal  oEmitInt( addr )
12906:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
12921:       .tAssignI
12923:       addr = add( addr, 8 )
12936:       .tPushAddrGlobal  oEmitInt( addr )
12944:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
12959:       .tAssignP
12961:       addr = add( addr, 8 )
12974:       oNodeIterNext( it )
12980:    }
         % final table entry
12982:    .tPushAddrGlobal  oEmitInt( addr )
12990:    .tPushConstI  oEmitInt( 0 )
12998:    .tAssignI
13000:    addr = add( addr, 8 )
13013:    .tPushAddrGlobal  oEmitInt( addr )
13021:    .tPushConstI  oEmitInt( 0 )
13029:    .tAssignP
13031:    addr = add( addr, 8 )
13044:    oCodePop
      
13045:    oTypeAdd( resultType )
13052:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13052: PointerTypeTo( Node theType ) >> Node:
13054:    Node ptrType = oNodeGet( theType, qPointerType )
13067:    [ oNodeNull( ptrType )
13074:       | true :
13075:          ptrType = oNodeNew( nPointerType )
13085:          oNodeSet( ptrType, qBaseType, theType )
13097:          oNodeSetInt( ptrType, qSize, 8 )
13109:          oTypeAdd( ptrType )
13115:          oNodeSet( theType, qPointerType, ptrType )
13127:       | * :
13132:    ]
13132:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13136: OrdinalLow( Node theType ) >> int:
13138:    [ oNodeType( theType )
13145:       | nIntegerType :  >> oMININT
13148:       | nBooleanType :  >> 0
13153:       | nCharType :     >> 0
13158:       | nEnumType :
13160:          Node enumScope = oNodeGet( theType, qScope )
13173:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13190:          >> oNodeGetInt( first, qValue )
13200:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13212:       | * :             #eNotOrdinalType
13227:                         >> 0
13230:    ];
      
      
      % Return the high value of an ordinal type
      %
13231: OrdinalHigh( Node theType ) >> int:
13233:    [ oNodeType( theType )
13240:       | nIntegerType :  >> oMAXINT
13243:       | nBooleanType :  >> 1
13248:       | nCharType :     >> 255
13253:       | nEnumType :
13255:          Node enumScope = oNodeGet( theType, qScope )
13268:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13285:          >> oNodeGetInt( last, qValue )
13295:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13307:       | * :             #eNotOrdinalType
13322:                         >> 0
13325:    ];
      
      
      
13326: Program:
13328:    Node t
      
13328:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13333:    oScopeBegin( 0, allocGlobal )
13342:    Node rootScope = oScopeCurrent
      
13347:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13349:    .tEnter  oEmitInt( 0 )
13357:    Label mainLabel = oLabelNew
      
13362:    .tAllocActuals  oEmitInt( 0 )
13370:    .tCall  oEmitLabel( mainLabel )
13378:    .tFreeActuals  oEmitInt( 0 )
13386:    .tReturn
      
13388:    pProgram
13390:    pIdent
      
13392:    Node program = oNodeNew( nProgram )
13402:    oNodeSetInt( program, qIdent, LAST_ID )
13413:    oNodeSet( workspace, qProgram, program )
      
      
13425:    [
13425:       | '(' :
13427:          pIdent      % input, output files
      
13429:          t = @newIdent( nVar, LAST_ID )
13442:          oNodeSet( t, qType, FileType )
13454:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13460:          ','
13462:          pIdent
      
13464:          t = @newIdent( nVar, LAST_ID )
13477:          oNodeSet( t, qType, FileType )
13489:          oScopeDeclareAlloc( t )
      
13495:          ')'
13497:       | * :
13502:    ]
13502:    ';'
      
13504:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13511:    [
13511:       | pUses :  @UsesClause( program )
13520:       | * :
13525:    ]
13525:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13532:    oScopeBegin( 0, allocGlobal )
13541:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13546:    oScopeBegin( 0, allocDown )
13555:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13566:    initScope = oScopeCurrent
13571:    oNodeSet( program, qMainRoutineScope, initScope )
13583:    oScopeEnd
      
13584:    @BlockDecls( nGlobalVar )
      
      
13591:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
13597:    boolean isMain = true
13603:    @BlockStmt( mainLabel, globalScope, isMain )
      
13616:    oScopeEnd   % main routine scope
      
13617:    '.'
13619:    @CheckForUndefinedLabels
13621:    oScopeEnd   % global scope
13622:    @EndUsedUnits( program )   % used units scopes
13630:    ;
      
      
      
      
13630: Block( node_type varNodeType, Label labelForBody ):
13632:    @BlockDecls( varNodeType )
13639:    @BlockStmt( labelForBody, oScopeCurrent, false )
13651:    @CheckForUndefinedLabels
13654:    ;
      
      
13654: BlockDecls( node_type varNodeType ):
13656:    {[
13656:       | pConst :     @ConstDecl
13660:       | pType :      @TypeDecl
13664:       | pVar :       @VarDecl( varNodeType )
13673:       | pLabel :     @LabelDecl
13677:       | pProcedure : @ProcDecl
13681:       | pFunction :  @FuncDecl
13685:       | * :          >
13702:    ]}
13704:    @CheckForUndefinedMethods
13707:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
13707: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
13710:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
13710: CheckForUndefinedLabels:
13712:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
13724:    {
13724:       Node decl = oNodeIterValue( it )
13734:       [ oNodeNull( decl )
13741:          | false :
13742:          | * :  >
13749:       ]
13749:       [ oNodeType( decl )
13756:          | nLabel :
13757:             [ oNodeGetBoolean( decl, qDefined )
13767:                | false :
13768:                   [ oNodeGetBoolean( decl, qUsed )
13778:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
13781:                      | * :
13786:                   ]
13786:                | * :
13791:             ]
13791:          | * :
13796:       ]
13796:       oNodeIterNext( it )
13802:    }
13805:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
13805: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
13807:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
13815:    int patchLS
13815:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
13824:    [ isMain
13827:       | true :  @InitializeUnits
13830:       | * :
13835:    ]
      
         % insert any code for initialization of this scope's variables
13835:    Code initCode = oNodeGetCode( varScope, qInitCode )
13848:    oEmitCode( initCode )
13854:    oNodeSetCode( varScope, qInitCode, codeNull )
      
13866:    @Statement
      
13868:    [ isMain
13871:       | true :  @FinalizeUnits
13874:       | * :
13879:    ]
      
13879:    .tReturn
      
13881:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
13893:    oPatch( patchLS, localSpace )
13903:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
13903: GetOrCreateInitCode( Node scope ) >> Code:
13905:    Code initCode = oNodeGetCode( scope, qInitCode )
13918:    [ equal_code( initCode, codeNull )
13928:       | true :
13929:          initCode = oCodeNew
13934:          oNodeSetCode( scope, qInitCode, initCode )
13946:       | * :
13951:    ]
13951:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
13955: ScopeLevel >> int:
13957:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
13967: DeclLevel( Node decl ) >> int:
13969:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
13987: DeclUpLevels( Node decl ) >> int:
13989:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14005: newIdent( node_type nt, int id ) >> Node:
14007:   Node t = oNodeNew( nt )
14017:   oNodeSetInt( t, qIdent, id )
14029:   >> t
14033:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14033: EmitValue( Node decl ):
14035:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14049: DeclareBuiltInFunc( int id ) >> Node:
14051:    Node decl = @newIdent( nBuiltInFunc, id )
14065:    oScopeDeclare( decl )
14071:    >> decl;
      
      
14075: installBuiltIns:
      
         % initialize some other globals too
14077:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14083:    mysystemId = oId_mysystem
      
         % install built-in types
14088:    FileType = @newType( nFileType, 4 )
14102:    IntegerType = @newType( nIntegerType, 4 )
14116:    BooleanType = @newType( nBooleanType, 1 )
14130:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14144:    CharType = @newType( nCharType, 1 )
14158:    PCharType = @PointerTypeTo( CharType )
14169:    ByteType = @newType( nByteType, 1 )
14183:    SingleType = @newType( nSingleType, 4 )
14197:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14211:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14225:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14237:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14251:    ShortStringType = @newType( nShortStringType, 256 )
14265:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14277:    Node t
      
14277:    t = @newIdent( nTypeDecl, oId_File )
14290:    oNodeSet( t, qType, FileType )
14302:    oScopeDeclare( t )
      
14308:    t = @newIdent( nTypeDecl, oId_Integer )
14321:    oNodeSet( t, qType, IntegerType )
14333:    oScopeDeclare( t )
      
14339:    t = @newIdent( nTypeDecl, oId_Boolean )
14352:    oNodeSet( t, qType, BooleanType )
14364:    oScopeDeclare( t )
      
14370:    t = @newIdent( nTypeDecl, oId_Char )
14383:    oNodeSet( t, qType, CharType )
14395:    oScopeDeclare( t )
      
14401:    t = @newIdent( nTypeDecl, oId_Byte )
14414:    oNodeSet( t, qType, ByteType )
14426:    oScopeDeclare( t )
      
14432:    t = @newIdent( nTypeDecl, oId_Single )
14445:    oNodeSet( t, qType, SingleType )
14457:    oScopeDeclare( t )
      
14463:    t = @newIdent( nTypeDecl, oId_Double )
14476:    oNodeSet( t, qType, DoubleType )
14488:    oScopeDeclare( t )
      
14494:    t = @newIdent( nTypeDecl, oId_Pointer )
14507:    oNodeSet( t, qType, UniversalPointerType )
14519:    oScopeDeclare( t )
      
14525:    t = @newIdent( nTypeDecl, oId_ShortString )
14538:    oNodeSet( t, qType, ShortStringType )
14550:    oScopeDeclare( t )
      
         % Built-in constants
      
14556:    t = @newIdent( nConst, oId_True )
14569:    oNodeSet( t, qType, BooleanType )
14581:    oNodeSetInt( t, qValue, 1 )
14593:    oScopeDeclare( t )
      
14599:    t = @newIdent( nConst, oId_False )
14612:    oNodeSet( t, qType, BooleanType )
14624:    oNodeSetInt( t, qValue, 0 )
14636:    oScopeDeclare( t )
      
14642:    t = @newIdent( nConst, oId_Nil )
14655:    oNodeSet( t, qType, UniversalPointerType )
14667:    oNodeSetInt( t, qValue, 0 )
14679:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
14685:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
14695:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
14705:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
14715:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
14725:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
14736:    ;
      
14736: end
      
14736: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13326
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3178
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3234
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 13654
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 78
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 68
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 96
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8736
1083: oInputChoice 1089
1085: oCall 8736
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 67
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 78
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 68
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 96
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8736
1177: oInputChoice 1183
1179: oCall 8736
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 67
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 62
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 65
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 64
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 62
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 65
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 64
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 13967
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 11581
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14005
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 21
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 21
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 21
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 13955
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13052
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 22
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 13630
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14005
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 21
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 21
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 13955
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13052
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 11973
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13052
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 22
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 13630
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 24
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14005
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 34
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 11973
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13052
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2654
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3533
2556: oTypeSNodeType
2557: oChoice 2613
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14005
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2632
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 18
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14005
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 33
2605: oPushResult
2606: oValueTopString
2607: oPushResult
2608: oNodeSetString
2609: oPop 3
2611: oJumpForward 2632
2613: Choice Lookup Table
          41   2586
          37   2559
          36   2559
          43   2559
          30   2559
          35   2559
          29   2559
          33   2559
2630: oError 17
2632: oValuePop
2633: oGetLocal 2
2635: oPushResult
2636: oSetResult 21
2638: oPushResult
2639: oTypeSTop
2640: oPushResult
2641: oNodeSet
2642: oPop 3
2644: oTypeSPop
2645: oGetLocal 2
2647: oPushResult
2648: oScopeDeclare
2649: oPop 1
2651: oInput 6
2653: oReturn
2654: oLocalSpace 3
2656: oGetAddrLocal 1
2658: oPushResult
2659: oSetResult 25
2661: oPushResult
2662: LAST_ID
2663: oPushResult
2664: oCall 14005
2666: oPop 2
2668: oAssign
2669: oGetAddrLocal 2
2671: oPushResult
2672: oCall 11973
2674: oPop 1
2676: oGetLocal 1
2678: oPushResult
2679: oSetResult 21
2681: oPushResult
2682: oGetLocal 2
2684: oPushResult
2685: oNodeSet
2686: oPop 3
2688: oGetLocal 2
2690: oPushResult
2691: oNodeType
2692: oPop 1
2694: oChoice 2798
2696: oInput 7
2698: oGetLocal 2
2700: oPushResult
2701: oTypeSPush
2702: oPop 1
2704: oCall 3533
2706: oCall 4345
2708: oGetLocal 1
2710: oPushResult
2711: oSetResult 22
2713: oPushResult
2714: oValueTop
2715: oPushResult
2716: oNodeSetInt
2717: oPop 3
2719: oValuePop
2720: oTypeSPop
2721: oGetLocal 1
2723: oPushResult
2724: oScopeDeclare
2725: oPop 1
2727: oInput 6
2729: oJumpForward 2822
2731: oError 16
2733: oJumpForward 2822
2735: oGetGlobal 2
2737: oPushResult
2738: oScopeEnter
2739: oPop 1
2741: oGetAddrLocal 3
2743: oPushResult
2744: oGetLocal 2
2746: oPushResult
2747: oScopeAllocType
2748: oPop 1
2750: oAssign
2751: oScopeEnd
2752: oGetGlobal 2
2754: oPushResult
2755: oCall 13903
2757: oPop 1
2759: oPushResult
2760: oCodePush
2761: oPop 1
2763: oGetLocal 1
2765: oPushResult
2766: oSetResult 22
2768: oPushResult
2769: oGetLocal 3
2771: oPushResult
2772: oNodeSetInt
2773: oPop 3
2775: oInput 7
2777: oGetLocal 2
2779: oPushResult
2780: oGetLocal 3
2782: oPushResult
2783: oCall 2823
2785: oPop 2
2787: oCodePop
2788: oGetLocal 1
2790: oPushResult
2791: oScopeDeclare
2792: oPop 1
2794: oInput 6
2796: oJumpForward 2822
2798: Choice Lookup Table
          40   2735
          38   2735
          28   2731
          42   2731
          37   2696
          36   2696
          43   2696
          30   2696
          35   2696
          29   2696
          33   2696
2821: oEndChoice
2822: oReturn
2823: oLocalSpace 10
2825: oGetParam 2
2827: oPushResult
2828: oNodeType
2829: oPop 1
2831: oChoice 3153
2833: oGetAddrLocal 1
2835: oPushResult
2836: oGetParam 2
2838: oPushResult
2839: oSetResult 37
2841: oPushResult
2842: oNodeGet
2843: oPop 2
2845: oAssign
2846: oGetAddrLocal 2
2848: oPushResult
2849: oGetParam 2
2851: oPushResult
2852: oSetResult 38
2854: oPushResult
2855: oNodeGet
2856: oPop 2
2858: oAssign
2859: oGetAddrLocal 3
2861: oPushResult
2862: oGetLocal 2
2864: oPushResult
2865: oCall 13136
2867: oPop 1
2869: oAssign
2870: oGetAddrLocal 4
2872: oPushResult
2873: oGetLocal 2
2875: oPushResult
2876: oCall 13231
2878: oPop 1
2880: oAssign
2881: oGetAddrLocal 5
2883: oPushResult
2884: oGetLocal 1
2886: oPushResult
2887: oSetResult 17
2889: oPushResult
2890: oNodeGetInt
2891: oPop 2
2893: oAssign
2894: oInput 15
2896: oGetAddrLocal 6
2898: oPushResult
2899: oGetLocal 3
2901: oAssign
2902: oGetLocal 1
2904: oPushResult
2905: oGetParam 1
2907: oPushResult
2908: oCall 2823
2910: oPop 2
2912: oGetLocal 6
2914: oPushResult
2915: oGetLocal 4
2917: oPushResult
2918: equal
2919: oPop 2
2921: oChoice 2929
2923: oJumpForward 2958
2925: oJumpForward 2935
2927: oJumpForward 2935
2929: Choice Lookup Table
           0   2927
           1   2923
2934: oEndChoice
2935: oInput 14
2937: oGetAddrParam 1
2939: oPushResult
2940: oGetParam 1
2942: oPushResult
2943: oGetLocal 5
2945: oPushResult
2946: add
2947: oPop 2
2949: oAssign
2950: oGetAddrLocal 6
2952: oPushResult
2953: inc
2954: oPop 1
2956: oJumpBack 2902
2958: oInput 16
2960: oJumpForward 3177
2962: oInput 15
2964: oGetAddrLocal 7
2966: oPushResult
2967: oGetParam 2
2969: oPushResult
2970: oSetResult 41
2972: oPushResult
2973: oNodeGet
2974: oPop 2
2976: oAssign
2977: oInputChoice 2981
2979: oJumpForward 2986
2981: Choice Lookup Table
           0   2979
2984: oJumpForward 3052
2986: oGetAddrLocal 8
2988: oPushResult
2989: oGetLocal 7
2991: oPushResult
2992: oScopeFindRequireInScope
2993: oPop 1
2995: oAssign
2996: oInput 13
2998: oGetAddrLocal 9
3000: oPushResult
3001: oGetLocal 8
3003: oPushResult
3004: oSetResult 21
3006: oPushResult
3007: oNodeGet
3008: oPop 2
3010: oAssign
3011: oGetAddrLocal 10
3013: oPushResult
3014: oGetParam 1
3016: oPushResult
3017: oGetLocal 8
3019: oPushResult
3020: oSetResult 22
3022: oPushResult
3023: oNodeGetInt
3024: oPop 2
3026: oPushResult
3027: add
3028: oPop 2
3030: oAssign
3031: oGetLocal 9
3033: oPushResult
3034: oGetLocal 10
3036: oPushResult
3037: oCall 2823
3039: oPop 2
3041: oInputChoice 3045
3043: oJumpForward 3050
3045: Choice Lookup Table
           6   3043
3048: oJumpForward 3052
3050: oJumpBack 2977
3052: oInput 16
3054: oJumpForward 3177
3056: oEmit 17
3058: oGetParam 1
3060: oPushResult
3061: oEmitInt
3062: oPop 1
3064: oGetParam 2
3066: oPushResult
3067: oTypeSPush
3068: oPop 1
3070: oCall 3533
3072: oCall 4345
3074: oEmit 15
3076: oValueTop
3077: oPushResult
3078: oEmitInt
3079: oPop 1
3081: oValuePop
3082: oTypeSPop
3083: oEmit 28
3085: oJumpForward 3177
3087: oEmit 17
3089: oGetParam 1
3091: oPushResult
3092: oEmitInt
3093: oPop 1
3095: oGetParam 2
3097: oPushResult
3098: oTypeSPush
3099: oPop 1
3101: oCall 3533
3103: oCall 4345
3105: oEmit 15
3107: oValueTop
3108: oPushResult
3109: oEmitInt
3110: oPop 1
3112: oValuePop
3113: oTypeSPop
3114: oEmit 27
3116: oJumpForward 3177
3118: oEmit 17
3120: oGetParam 1
3122: oPushResult
3123: oEmitInt
3124: oPop 1
3126: oGetParam 2
3128: oPushResult
3129: oTypeSPush
3130: oPop 1
3132: oCall 3533
3134: oCall 4345
3136: oEmit 15
3138: oValueTop
3139: oPushResult
3140: oEmitInt
3141: oPop 1
3143: oValuePop
3144: oTypeSPop
3145: oEmit 29
3147: oJumpForward 3177
3149: oError 16
3151: oJumpForward 3177
3153: Choice Lookup Table
          28   3149
          42   3149
          37   3118
          36   3118
          43   3087
          30   3087
          35   3056
          29   3056
          33   3056
          40   2962
          38   2833
3176: oEndChoice
3177: oReturn
3178: oLocalSpace 2
3180: oInputChoice 3226
3182: oGetAddrLocal 1
3184: oPushResult
3185: oSetResult 19
3187: oPushResult
3188: LAST_ID
3189: oPushResult
3190: oCall 14005
3192: oPop 2
3194: oAssign
3195: oInput 7
3197: oGetAddrLocal 2
3199: oPushResult
3200: oCall 11973
3202: oPop 1
3204: oGetLocal 1
3206: oPushResult
3207: oSetResult 21
3209: oPushResult
3210: oGetLocal 2
3212: oPushResult
3213: oNodeSet
3214: oPop 3
3216: oGetLocal 1
3218: oPushResult
3219: oScopeDeclare
3220: oPop 1
3222: oInput 6
3224: oJumpForward 3231
3226: Choice Lookup Table
           0   3182
3229: oJumpForward 3233
3231: oJumpBack 3180
3233: oReturn
3234: oLocalSpace 6
3236: oInputChoice 3460
3238: oGetAddrLocal 1
3240: oPushResult
3241: oNodeVecNew
3242: oAssign
3243: oGetAddrLocal 2
3245: oPushResult
3246: oGetParam 1
3248: oPushResult
3249: LAST_ID
3250: oPushResult
3251: oCall 14005
3253: oPop 2
3255: oAssign
3256: oGetLocal 1
3258: oPushResult
3259: oGetLocal 2
3261: oPushResult
3262: oNodeVecAppend
3263: oPop 2
3265: oInputChoice 3271
3267: oInput 0
3269: oJumpForward 3276
3271: Choice Lookup Table
          14   3267
3274: oJumpForward 3278
3276: oJumpBack 3243
3278: oInput 13
3280: oGetAddrLocal 3
3282: oPushResult
3283: oCall 11973
3285: oPop 1
3287: oGetAddrLocal 4
3289: oPushResult
3290: oSetResult 0
3292: oAssign
3293: oGetLocal 4
3295: oPushResult
3296: oGetLocal 1
3298: oPushResult
3299: oNodeVecSize
3300: oPop 1
3302: oPushResult
3303: equal
3304: oPop 2
3306: oChoice 3347
3308: oGetAddrLocal 2
3310: oPushResult
3311: oGetLocal 1
3313: oPushResult
3314: oGetLocal 4
3316: oPushResult
3317: oNodeVecElement
3318: oPop 2
3320: oAssign
3321: oGetLocal 2
3323: oPushResult
3324: oSetResult 21
3326: oPushResult
3327: oGetLocal 3
3329: oPushResult
3330: oNodeSet
3331: oPop 3
3333: oGetLocal 2
3335: oPushResult
3336: oScopeDeclareAlloc
3337: oPop 1
3339: oGetAddrLocal 4
3341: oPushResult
3342: inc
3343: oPop 1
3345: oJumpForward 3352
3347: Choice Lookup Table
           0   3308
3350: oJumpForward 3354
3352: oJumpBack 3293
3354: oInputChoice 3447
3356: oGetLocal 1
3358: oPushResult
3359: oNodeVecSize
3360: oPop 1
3362: oChoice 3366
3364: oJumpForward 3371
3366: Choice Lookup Table
           1   3364
3369: oError 22
3371: oGetAddrLocal 5
3373: oPushResult
3374: oScopeCurrent
3375: oPushResult
3376: oCall 13903
3378: oPop 1
3380: oAssign
3381: oGetLocal 5
3383: oPushResult
3384: oCodePush
3385: oPop 1
3387: oGetAddrLocal 6
3389: oPushResult
3390: oSetResult 0
3392: oAssign
3393: oCall 13955
3395: oPushResult
3396: equal_zero
3397: oPop 1
3399: oChoice 3415
3401: oGetGlobal 3
3403: oPushResult
3404: oScopeEnter
3405: oPop 1
3407: oGetAddrLocal 6
3409: oPushResult
3410: oSetResult 1
3412: oAssign
3413: oJumpForward 3418
3415: Choice Lookup Table
           1   3401
3418: oGetLocal 2
3420: oPushResult
3421: oSetResult 1
3423: oPushResult
3424: oCall 9422
3426: oPop 2
3428: oCall 4881
3430: oCall 8221
3432: oCall 8982
3434: oGetLocal 6
3436: oChoice 3441
3438: oScopeEnd
3439: oJumpForward 3444
3441: Choice Lookup Table
           1   3438
3444: oCodePop
3445: oJumpForward 3450
3447: Choice Lookup Table
           7   3356
3450: oGetLocal 1
3452: oPushResult
3453: oNodeVecDelete
3454: oPop 1
3456: oInput 6
3458: oJumpForward 3465
3460: Choice Lookup Table
           0   3238
3463: oJumpForward 3467
3465: oJumpBack 3236
3467: oReturn
3468: oLocalSpace 2
3470: oInputChoice 3477
3472: oJumpForward 3483
3474: oChangeIntLitToLabelIdent
3475: oJumpForward 3483
3477: Choice Lookup Table
           1   3474
           0   3472
3482: oEndChoice
3483: oGetAddrLocal 1
3485: oPushResult
3486: oSetResult 26
3488: oPushResult
3489: LAST_ID
3490: oPushResult
3491: oCall 14005
3493: oPop 2
3495: oAssign
3496: oGetAddrLocal 2
3498: oPushResult
3499: oLabelNew
3500: oAssign
3501: oGetLocal 1
3503: oPushResult
3504: oSetResult 22
3506: oPushResult
3507: oGetLocal 2
3509: oPushResult
3510: oNodeSetLabel
3511: oPop 3
3513: oGetLocal 1
3515: oPushResult
3516: oScopeDeclare
3517: oPop 1
3519: oInputChoice 3523
3521: oJumpForward 3528
3523: Choice Lookup Table
          14   3521
3526: oJumpForward 3530
3528: oJumpBack 3470
3530: oInput 6
3532: oReturn
3533: oLocalSpace 0
3535: oCall 3760
3537: oInputChoice 3719
3539: oCall 3783
3541: oCall 4248
3543: oTypeSNodeType
3544: oChoice 3556
3546: oValueStringCmp
3547: oSetResult 0
3549: oPushResult
3550: oValuePush
3551: oPop 1
3553: oValueEqual
3554: oJumpForward 3560
3556: Choice Lookup Table
          41   3546
3559: oValueEqual
3560: oTypeSPop
3561: oGetGlobal 7
3563: oPushResult
3564: oTypeSPush
3565: oPop 1
3567: oJumpForward 3734
3569: oCall 3760
3571: oCall 4248
3573: oTypeSNodeType
3574: oChoice 3586
3576: oValueStringCmp
3577: oSetResult 0
3579: oPushResult
3580: oValuePush
3581: oPop 1
3583: oValueNotEqual
3584: oJumpForward 3590
3586: Choice Lookup Table
          41   3576
3589: oValueNotEqual
3590: oTypeSPop
3591: oGetGlobal 7
3593: oPushResult
3594: oTypeSPush
3595: oPop 1
3597: oJumpForward 3734
3599: oCall 3760
3601: oCall 4248
3603: oTypeSNodeType
3604: oChoice 3616
3606: oValueStringCmp
3607: oSetResult 0
3609: oPushResult
3610: oValuePush
3611: oPop 1
3613: oValueLess
3614: oJumpForward 3620
3616: Choice Lookup Table
          41   3606
3619: oValueLess
3620: oTypeSPop
3621: oGetGlobal 7
3623: oPushResult
3624: oTypeSPush
3625: oPop 1
3627: oJumpForward 3734
3629: oCall 3760
3631: oCall 4248
3633: oTypeSNodeType
3634: oChoice 3646
3636: oValueStringCmp
3637: oSetResult 0
3639: oPushResult
3640: oValuePush
3641: oPop 1
3643: oValueGreater
3644: oJumpForward 3650
3646: Choice Lookup Table
          41   3636
3649: oValueGreater
3650: oTypeSPop
3651: oGetGlobal 7
3653: oPushResult
3654: oTypeSPush
3655: oPop 1
3657: oJumpForward 3734
3659: oCall 3760
3661: oCall 4248
3663: oTypeSNodeType
3664: oChoice 3676
3666: oValueStringCmp
3667: oSetResult 0
3669: oPushResult
3670: oValuePush
3671: oPop 1
3673: oValueLessEqual
3674: oJumpForward 3680
3676: Choice Lookup Table
          41   3666
3679: oValueLessEqual
3680: oTypeSPop
3681: oGetGlobal 7
3683: oPushResult
3684: oTypeSPush
3685: oPop 1
3687: oJumpForward 3734
3689: oCall 3760
3691: oCall 4248
3693: oTypeSNodeType
3694: oChoice 3706
3696: oValueStringCmp
3697: oSetResult 0
3699: oPushResult
3700: oValuePush
3701: oPop 1
3703: oValueGreaterEqual
3704: oJumpForward 3710
3706: Choice Lookup Table
          41   3696
3709: oValueGreaterEqual
3710: oTypeSPop
3711: oGetGlobal 7
3713: oPushResult
3714: oTypeSPush
3715: oPop 1
3717: oJumpForward 3734
3719: Choice Lookup Table
          12   3689
          11   3659
          10   3629
           9   3599
           8   3569
           7   3539
3732: oJumpForward 3736
3734: oJumpBack 3537
3736: oReturn
3737: oLocalSpace 1
3739: oGetAddrLocal 1
3741: oPushResult
3742: oGetGlobal 25
3744: oAssign
3745: oGetAddrGlobal 25
3747: oPushResult
3748: oSetResult 1
3750: oAssign
3751: oCall 3533
3753: oGetAddrGlobal 25
3755: oPushResult
3756: oGetLocal 1
3758: oAssign
3759: oReturn
3760: oLocalSpace 0
3762: oCall 3783
3764: oInputChoice 3775
3766: oCall 4235
3768: oCall 3783
3770: oCall 4221
3772: oValueOr
3773: oJumpForward 3780
3775: Choice Lookup Table
          58   3766
3778: oJumpForward 3782
3780: oJumpBack 3764
3782: oReturn
3783: oLocalSpace 0
3785: oCall 3806
3787: oInputChoice 3798
3789: oCall 4235
3791: oCall 3806
3793: oCall 4221
3795: oValueAnd
3796: oJumpForward 3803
3798: Choice Lookup Table
          57   3789
3801: oJumpForward 3805
3803: oJumpBack 3787
3805: oReturn
3806: oLocalSpace 0
3808: oInputChoice 3817
3810: oCall 3806
3812: oCall 4235
3814: oValueNot
3815: oJumpForward 3822
3817: Choice Lookup Table
          59   3810
3820: oCall 3823
3822: oReturn
3823: oLocalSpace 0
3825: oCall 3872
3827: oInputChoice 3862
3829: oCall 3872
3831: oCall 4248
3833: oTypeSNodeType
3834: oChoice 3839
3836: oValueStringConcat
3837: oJumpForward 3843
3839: Choice Lookup Table
          41   3836
3842: oValueAdd
3843: oJumpForward 3869
3845: oCall 3872
3847: oCall 4248
3849: oTypeSNodeType
3850: oChoice 3856
3852: oError 17
3854: oJumpForward 3860
3856: Choice Lookup Table
          41   3852
3859: oValueSub
3860: oJumpForward 3869
3862: Choice Lookup Table
          26   3845
          25   3829
3867: oJumpForward 3871
3869: oJumpBack 3827
3871: oReturn
3872: oLocalSpace 0
3874: oCall 3922
3876: oInputChoice 3912
3878: oCall 3922
3880: oCall 4248
3882: oTypeSNodeType
3883: oChoice 3889
3885: oError 17
3887: oJumpForward 3893
3889: Choice Lookup Table
          41   3885
3892: oValueMult
3893: oJumpForward 3919
3895: oCall 3922
3897: oCall 4248
3899: oTypeSNodeType
3900: oChoice 3906
3902: oError 17
3904: oJumpForward 3910
3906: Choice Lookup Table
          41   3902
3909: oValueDiv
3910: oJumpForward 3919
3912: Choice Lookup Table
          24   3895
          23   3878
3917: oJumpForward 3921
3919: oJumpBack 3876
3921: oReturn
3922: oLocalSpace 0
3924: oInputChoice 3935
3926: oCall 3943
3928: oJumpForward 3942
3930: oCall 3943
3932: oValueNegate
3933: oJumpForward 3942
3935: Choice Lookup Table
          26   3930
          25   3926
3940: oCall 3943
3942: oReturn
3943: oLocalSpace 1
3945: oInputChoice 4193
3947: TOKEN_VALUE
3948: oPushResult
3949: oValuePush
3950: oPop 1
3952: oGetGlobal 6
3954: oPushResult
3955: oTypeSPush
3956: oPop 1
3958: oJumpForward 4220
3960: TOKEN_VALUE
3961: oPushResult
3962: oValuePush
3963: oPop 1
3965: oGetGlobal 9
3967: oPushResult
3968: oTypeSPush
3969: oPop 1
3971: oJumpForward 4220
3973: CURRENT_STRLIT
3974: oPushResult
3975: oValuePushString
3976: oPop 1
3978: oGetGlobal 15
3980: oPushResult
3981: oTypeSPush
3982: oPop 1
3984: oJumpForward 4220
3986: oCall 3533
3988: oInput 16
3990: oJumpForward 4220
3992: oGetAddrLocal 1
3994: oPushResult
3995: oScopeFindRequire
3996: oAssign
3997: oGetAddrLocal 1
3999: oPushResult
4000: oCall 244
4002: oPop 1
4004: oGetLocal 1
4006: oPushResult
4007: oNodeType
4008: oPop 1
4010: oChoice 4150
4012: oGetLocal 1
4014: oPushResult
4015: oCall 4615
4017: oPop 1
4019: oJumpForward 4175
4021: oGetLocal 1
4023: oPushResult
4024: oSetResult 22
4026: oPushResult
4027: oNodeGetInt
4028: oPop 2
4030: oPushResult
4031: oValuePush
4032: oPop 1
4034: oGetLocal 1
4036: oPushResult
4037: oSetResult 21
4039: oPushResult
4040: oNodeGet
4041: oPop 2
4043: oPushResult
4044: oTypeSPush
4045: oPop 1
4047: oJumpForward 4175
4049: oGetLocal 1
4051: oPushResult
4052: oSetResult 33
4054: oPushResult
4055: oNodeGetString
4056: oPop 2
4058: oPushResult
4059: oValuePushString
4060: oPop 1
4062: oGetLocal 1
4064: oPushResult
4065: oSetResult 21
4067: oPushResult
4068: oNodeGet
4069: oPop 2
4071: oPushResult
4072: oTypeSPush
4073: oPop 1
4075: oJumpForward 4175
4077: oGetLocal 1
4079: oPushResult
4080: oSetResult 22
4082: oPushResult
4083: oNodeGetInt
4084: oPop 2
4086: oPushResult
4087: oValuePush
4088: oPop 1
4090: oGetLocal 1
4092: oPushResult
4093: oSetResult 21
4095: oPushResult
4096: oNodeGet
4097: oPop 2
4099: oPushResult
4100: oTypeSPush
4101: oPop 1
4103: oJumpForward 4175
4105: oGetLocal 1
4107: oPushResult
4108: oSetResult 21
4110: oPushResult
4111: oNodeGet
4112: oPop 2
4114: oPushResult
4115: oTypeSPush
4116: oPop 1
4118: oInputChoice 4128
4120: oCall 3533
4122: oInput 16
4124: oCall 4466
4126: oJumpForward 4148
4128: Choice Lookup Table
          15   4120
4131: oGetGlobal 25
4133: oChoice 4143
4135: oSetResult 0
4137: oPushResult
4138: oValuePush
4139: oPop 1
4141: oJumpForward 4148
4143: Choice Lookup Table
           1   4135
4146: oError 31
4148: oJumpForward 4175
4150: Choice Lookup Table
          19   4105
          17   4077
          18   4049
          16   4021
          14   4012
4161: oError 1
4163: oSetResult 0
4165: oPushResult
4166: oValuePush
4167: oPop 1
4169: oGetGlobal 6
4171: oPushResult
4172: oTypeSPush
4173: oPop 1
4175: oJumpForward 4220
4177: oError 16
4179: oSetResult 0
4181: oPushResult
4182: oValuePush
4183: oPop 1
4185: oGetGlobal 14
4187: oPushResult
4188: oTypeSPush
4189: oPop 1
4191: oJumpForward 4220
4193: Choice Lookup Table
          20   4177
           0   3992
          15   3986
           3   3973
           4   3960
           1   3947
4206: oError 1
4208: oSetResult 0
4210: oPushResult
4211: oValuePush
4212: oPop 1
4214: oGetGlobal 6
4216: oPushResult
4217: oTypeSPush
4218: oPop 1
4220: oReturn
4221: oLocalSpace 0
4223: oTypeSNodeType
4224: oChoice 4228
4226: oJumpForward 4233
4228: Choice Lookup Table
          33   4226
4231: oError 8
4233: oTypeSPop
4234: oReturn
4235: oLocalSpace 0
4237: oTypeSNodeType
4238: oChoice 4242
4240: oJumpForward 4247
4242: Choice Lookup Table
          33   4240
4245: oError 8
4247: oReturn
4248: oLocalSpace 1
4250: oGetAddrLocal 1
4252: oPushResult
4253: oTypeSNodeType
4254: oAssign
4255: oTypeSPop
4256: oGetLocal 1
4258: oPushResult
4259: oTypeSNodeType
4260: oPushResult
4261: equal_node_type
4262: oPop 2
4264: oChoice 4341
4266: oTypeSNodeType
4267: oChoice 4328
4269: oGetLocal 1
4271: oChoice 4276
4273: oReturn
4274: oJumpForward 4279
4276: Choice Lookup Table
          37   4273
4279: oJumpForward 4337
4281: oGetLocal 1
4283: oChoice 4288
4285: oReturn
4286: oJumpForward 4291
4288: Choice Lookup Table
          36   4285
4291: oJumpForward 4337
4293: oGetLocal 1
4295: oChoice 4301
4297: oValueCharToString
4298: oReturn
4299: oJumpForward 4304
4301: Choice Lookup Table
          35   4297
4304: oJumpForward 4337
4306: oGetLocal 1
4308: oChoice 4323
4310: oValueSwap
4311: oValueCharToString
4312: oValueSwap
4313: oTypeSPop
4314: oGetGlobal 15
4316: oPushResult
4317: oTypeSPush
4318: oPop 1
4320: oReturn
4321: oJumpForward 4326
4323: Choice Lookup Table
          41   4310
4326: oJumpForward 4337
4328: Choice Lookup Table
          35   4306
          41   4293
          37   4281
          36   4269
4337: oError 14
4339: oJumpForward 4344
4341: Choice Lookup Table
           0   4266
4344: oReturn
4345: oLocalSpace 1
4347: oGetAddrLocal 1
4349: oPushResult
4350: oTypeSNodeType
4351: oAssign
4352: oTypeSPop
4353: oGetLocal 1
4355: oPushResult
4356: oTypeSNodeType
4357: oPushResult
4358: equal_node_type
4359: oPop 2
4361: oChoice 4462
4363: oTypeSNodeType
4364: oChoice 4445
4366: oGetLocal 1
4368: oChoice 4373
4370: oReturn
4371: oJumpForward 4376
4373: Choice Lookup Table
          29   4370
4376: oJumpForward 4458
4378: oGetLocal 1
4380: oChoice 4385
4382: oReturn
4383: oJumpForward 4388
4385: Choice Lookup Table
          30   4382
4388: oJumpForward 4458
4390: oGetLocal 1
4392: oChoice 4397
4394: oReturn
4395: oJumpForward 4400
4397: Choice Lookup Table
          37   4394
4400: oJumpForward 4458
4402: oGetLocal 1
4404: oChoice 4409
4406: oReturn
4407: oJumpForward 4412
4409: Choice Lookup Table
          36   4406
4412: oJumpForward 4458
4414: oGetLocal 1
4416: oChoice 4422
4418: oValueCharToString
4419: oReturn
4420: oJumpForward 4425
4422: Choice Lookup Table
          35   4418
4425: oJumpForward 4458
4427: oGetLocal 1
4429: oChoice 4438
4431: oReturn
4432: oJumpForward 4443
4434: oValueCharToString
4435: oReturn
4436: oJumpForward 4443
4438: Choice Lookup Table
          35   4434
          41   4431
4443: oJumpForward 4458
4445: Choice Lookup Table
          42   4427
          41   4414
          37   4402
          36   4390
          29   4378
          30   4366
4458: oError 14
4460: oJumpForward 4465
4462: Choice Lookup Table
           0   4363
4465: oReturn
4466: oLocalSpace 1
4468: oGetAddrLocal 1
4470: oPushResult
4471: oTypeSNodeType
4472: oAssign
4473: oTypeSPop
4474: oGetLocal 1
4476: oPushResult
4477: oTypeSNodeType
4478: oPushResult
4479: equal_node_type
4480: oPop 2
4482: oChoice 4611
4484: oTypeSNodeType
4485: oChoice 4588
4487: oGetLocal 1
4489: oChoice 4497
4491: oReturn
4492: oJumpForward 4508
4494: oReturn
4495: oJumpForward 4508
4497: Choice Lookup Table
          43   4494
          30   4494
          33   4491
          35   4491
          29   4491
4508: oJumpForward 4607
4510: oGetLocal 1
4512: oChoice 4520
4514: oReturn
4515: oJumpForward 4531
4517: oReturn
4518: oJumpForward 4531
4520: Choice Lookup Table
          43   4517
          30   4517
          33   4514
          35   4514
          29   4514
4531: oJumpForward 4607
4533: oGetLocal 1
4535: oChoice 4540
4537: oReturn
4538: oJumpForward 4543
4540: Choice Lookup Table
          37   4537
4543: oJumpForward 4607
4545: oGetLocal 1
4547: oChoice 4552
4549: oReturn
4550: oJumpForward 4555
4552: Choice Lookup Table
          36   4549
4555: oJumpForward 4607
4557: oGetLocal 1
4559: oChoice 4565
4561: oValueCharToString
4562: oReturn
4563: oJumpForward 4568
4565: Choice Lookup Table
          35   4561
4568: oJumpForward 4607
4570: oGetLocal 1
4572: oChoice 4581
4574: oReturn
4575: oJumpForward 4586
4577: oValueCharToString
4578: oReturn
4579: oJumpForward 4586
4581: Choice Lookup Table
          35   4577
          41   4574
4586: oJumpForward 4607
4588: Choice Lookup Table
          42   4570
          41   4557
          37   4545
          36   4533
          33   4510
          35   4510
          29   4510
          43   4487
          30   4487
4607: oError 14
4609: oJumpForward 4614
4611: Choice Lookup Table
           0   4484
4614: oReturn
4615: oLocalSpace 1
4617: oGetParam 1
4619: oPushResult
4620: oGetGlobal 17
4622: oPushResult
4623: oNodeEqual
4624: oPop 2
4626: oChoice 4666
4628: oInput 15
4630: oCall 3533
4632: oInput 16
4634: oTypeSNodeType
4635: oChoice 4641
4637: oJumpForward 4654
4639: oJumpForward 4654
4641: Choice Lookup Table
          35   4639
          29   4639
          33   4639
          43   4637
          30   4637
4652: oError 14
4654: oTypeSPop
4655: oGetGlobal 6
4657: oPushResult
4658: oTypeSPush
4659: oPop 1
4661: oInput 16
4663: oReturn
4664: oJumpForward 4669
4666: Choice Lookup Table
           1   4628
4669: oGetParam 1
4671: oPushResult
4672: oGetGlobal 18
4674: oPushResult
4675: oNodeEqual
4676: oPop 2
4678: oChoice 4712
4680: oInput 15
4682: oCall 3533
4684: oInput 16
4686: oTypeSNodeType
4687: oChoice 4693
4689: oJumpForward 4700
4691: oJumpForward 4700
4693: Choice Lookup Table
          29   4691
          30   4689
4698: oError 14
4700: oTypeSPop
4701: oGetGlobal 9
4703: oPushResult
4704: oTypeSPush
4705: oPop 1
4707: oInput 16
4709: oReturn
4710: oJumpForward 4715
4712: Choice Lookup Table
           1   4680
4715: oGetParam 1
4717: oPushResult
4718: oGetGlobal 19
4720: oPushResult
4721: oNodeEqual
4722: oPop 2
4724: oChoice 4769
4726: oInput 15
4728: oCall 3533
4730: oTypeSNodeType
4731: oChoice 4752
4733: oTypeSTop
4734: oPushResult
4735: oSetResult 44
4737: oPushResult
4738: oNodeGetBoolean
4739: oPop 2
4741: oChoice 4747
4743: oError 28
4745: oJumpForward 4750
4747: Choice Lookup Table
           1   4743
4750: oJumpForward 4757
4752: Choice Lookup Table
          43   4733
4755: oError 14
4757: oSetResult 1
4759: oPushResult
4760: oValuePush
4761: oPop 1
4763: oValueSub
4764: oInput 16
4766: oReturn
4767: oJumpForward 4772
4769: Choice Lookup Table
           1   4726
4772: oGetParam 1
4774: oPushResult
4775: oGetGlobal 20
4777: oPushResult
4778: oNodeEqual
4779: oPop 2
4781: oChoice 4826
4783: oInput 15
4785: oCall 3533
4787: oTypeSNodeType
4788: oChoice 4809
4790: oTypeSTop
4791: oPushResult
4792: oSetResult 44
4794: oPushResult
4795: oNodeGetBoolean
4796: oPop 2
4798: oChoice 4804
4800: oError 28
4802: oJumpForward 4807
4804: Choice Lookup Table
           1   4800
4807: oJumpForward 4814
4809: Choice Lookup Table
          43   4790
4812: oError 14
4814: oSetResult 1
4816: oPushResult
4817: oValuePush
4818: oPop 1
4820: oValueAdd
4821: oInput 16
4823: oReturn
4824: oJumpForward 4829
4826: Choice Lookup Table
           1   4783
4829: oGetParam 1
4831: oPushResult
4832: oGetGlobal 21
4834: oPushResult
4835: oNodeEqual
4836: oPop 2
4838: oChoice 4875
4840: oInput 15
4842: oCall 3737
4844: oValuePop
4845: oGetAddrLocal 1
4847: oPushResult
4848: oTypeSTop
4849: oAssign
4850: oTypeSPop
4851: oGetLocal 1
4853: oPushResult
4854: oSetResult 17
4856: oPushResult
4857: oNodeGetInt
4858: oPop 2
4860: oPushResult
4861: oValuePush
4862: oPop 1
4864: oGetGlobal 6
4866: oPushResult
4867: oTypeSPush
4868: oPop 1
4870: oInput 16
4872: oReturn
4873: oJumpForward 4878
4875: Choice Lookup Table
           1   4840
4878: oError 16
4880: oReturn
4881: oLocalSpace 1
4883: oGetAddrLocal 1
4885: oPushResult
4886: oSetResult 0
4888: oAssign
4889: oGetAddrLocal 1
4891: oPushResult
4892: oCall 5065
4894: oPop 1
4896: oGetAddrLocal 1
4898: oPushResult
4899: oCall 4965
4901: oPop 1
4903: oReturn
4904: oLocalSpace 1
4906: oGetAddrLocal 1
4908: oPushResult
4909: oGetGlobal 25
4911: oAssign
4912: oGetAddrGlobal 25
4914: oPushResult
4915: oSetResult 1
4917: oAssign
4918: oCall 4881
4920: oGetAddrGlobal 25
4922: oPushResult
4923: oGetLocal 1
4925: oAssign
4926: oReturn
4927: oLocalSpace 0
4929: oGetParam 1
4931: oPushResult
4932: oCall 5065
4934: oPop 1
4936: oTypeSNodeType
4937: oChoice 4956
4939: oJumpForward 4963
4941: oGetParam 1
4943: oPushResult
4944: oLabelNew
4945: oAssign
4946: oEmit 71
4948: oGetFromParam 1
4950: oPushResult
4951: oEmitLabel
4952: oPop 1
4954: oJumpForward 4963
4956: Choice Lookup Table
          33   4941
          34   4939
4961: oError 8
4963: oTypeSPop
4964: oReturn
4965: oLocalSpace 1
4967: oTypeSNodeType
4968: oChoice 5030
4970: oGetAddrLocal 1
4972: oPushResult
4973: oLabelNew
4974: oAssign
4975: oEmit 15
4977: oSetResult 1
4979: oPushResult
4980: oEmitInt
4981: oPop 1
4983: oEmit 69
4985: oGetLocal 1
4987: oPushResult
4988: oEmitLabel
4989: oPop 1
4991: oEmit 78
4993: oGetFromParam 1
4995: oPushResult
4996: oEmitLabel
4997: oPop 1
4999: oEmit 15
5001: oSetResult 0
5003: oPushResult
5004: oEmitInt
5005: oPop 1
5007: oEmit 78
5009: oGetLocal 1
5011: oPushResult
5012: oEmitLabel
5013: oPop 1
5015: oTypeSPop
5016: oGetGlobal 7
5018: oPushResult
5019: oTypeSPush
5020: oPop 1
5022: oGetParam 1
5024: oPushResult
5025: oSetResult 0
5027: oAssign
5028: oJumpForward 5033
5030: Choice Lookup Table
          34   4970
5033: oReturn
5034: oLocalSpace 0
5036: oTypeSNodeType
5037: oChoice 5061
5039: oGetParam 1
5041: oPushResult
5042: oLabelNew
5043: oAssign
5044: oEmit 71
5046: oGetFromParam 1
5048: oPushResult
5049: oEmitLabel
5050: oPop 1
5052: oTypeSPop
5053: oGetGlobal 8
5055: oPushResult
5056: oTypeSPush
5057: oPop 1
5059: oJumpForward 5064
5061: Choice Lookup Table
          33   5039
5064: oReturn
5065: oLocalSpace 0
5067: oGetParam 1
5069: oPushResult
5070: oCall 5598
5072: oPop 1
5074: oInputChoice 5580
5076: oGetParam 1
5078: oPushResult
5079: oCall 4965
5081: oPop 1
5083: oCall 8689
5085: oGetParam 1
5087: oPushResult
5088: oCall 5598
5090: oPop 1
5092: oGetParam 1
5094: oPushResult
5095: oCall 4965
5097: oPop 1
5099: oCall 8689
5101: oCall 8558
5103: oTypeSNodeType
5104: oChoice 5132
5106: oEmit 44
5108: oJumpForward 5151
5110: oEmit 50
5112: oJumpForward 5151
5114: oEmit 56
5116: oJumpForward 5151
5118: oCall 10905
5120: oEmit 15
5122: oSetResult 0
5124: oPushResult
5125: oEmitInt
5126: oPop 1
5128: oEmit 50
5130: oJumpForward 5151
5132: Choice Lookup Table
          41   5118
          42   5118
          37   5114
          36   5114
          43   5110
          30   5110
          35   5106
          33   5106
5149: oError 17
5151: oTypeSPop
5152: oGetGlobal 7
5154: oPushResult
5155: oTypeSPush
5156: oPop 1
5158: oJumpForward 5595
5160: oGetParam 1
5162: oPushResult
5163: oCall 4965
5165: oPop 1
5167: oCall 8689
5169: oGetParam 1
5171: oPushResult
5172: oCall 5598
5174: oPop 1
5176: oGetParam 1
5178: oPushResult
5179: oCall 4965
5181: oPop 1
5183: oCall 8689
5185: oCall 8558
5187: oTypeSNodeType
5188: oChoice 5216
5190: oEmit 45
5192: oJumpForward 5235
5194: oEmit 51
5196: oJumpForward 5235
5198: oEmit 57
5200: oJumpForward 5235
5202: oCall 10905
5204: oEmit 15
5206: oSetResult 0
5208: oPushResult
5209: oEmitInt
5210: oPop 1
5212: oEmit 51
5214: oJumpForward 5235
5216: Choice Lookup Table
          41   5202
          42   5202
          37   5198
          36   5198
          43   5194
          30   5194
          35   5190
          33   5190
5233: oError 17
5235: oTypeSPop
5236: oGetGlobal 7
5238: oPushResult
5239: oTypeSPush
5240: oPop 1
5242: oJumpForward 5595
5244: oGetParam 1
5246: oPushResult
5247: oCall 4965
5249: oPop 1
5251: oCall 8689
5253: oGetParam 1
5255: oPushResult
5256: oCall 5598
5258: oPop 1
5260: oGetParam 1
5262: oPushResult
5263: oCall 4965
5265: oPop 1
5267: oCall 8689
5269: oCall 8558
5271: oTypeSNodeType
5272: oChoice 5300
5274: oEmit 47
5276: oJumpForward 5319
5278: oEmit 53
5280: oJumpForward 5319
5282: oEmit 59
5284: oJumpForward 5319
5286: oCall 10905
5288: oEmit 15
5290: oSetResult 0
5292: oPushResult
5293: oEmitInt
5294: oPop 1
5296: oEmit 53
5298: oJumpForward 5319
5300: Choice Lookup Table
          41   5286
          42   5286
          37   5282
          36   5282
          43   5278
          30   5278
          35   5274
          33   5274
5317: oError 17
5319: oTypeSPop
5320: oGetGlobal 7
5322: oPushResult
5323: oTypeSPush
5324: oPop 1
5326: oJumpForward 5595
5328: oGetParam 1
5330: oPushResult
5331: oCall 4965
5333: oPop 1
5335: oCall 8689
5337: oGetParam 1
5339: oPushResult
5340: oCall 5598
5342: oPop 1
5344: oGetParam 1
5346: oPushResult
5347: oCall 4965
5349: oPop 1
5351: oCall 8689
5353: oCall 8558
5355: oTypeSNodeType
5356: oChoice 5384
5358: oEmit 46
5360: oJumpForward 5403
5362: oEmit 52
5364: oJumpForward 5403
5366: oEmit 58
5368: oJumpForward 5403
5370: oCall 10905
5372: oEmit 15
5374: oSetResult 0
5376: oPushResult
5377: oEmitInt
5378: oPop 1
5380: oEmit 52
5382: oJumpForward 5403
5384: Choice Lookup Table
          41   5370
          42   5370
          37   5366
          36   5366
          43   5362
          30   5362
          35   5358
          33   5358
5401: oError 17
5403: oTypeSPop
5404: oGetGlobal 7
5406: oPushResult
5407: oTypeSPush
5408: oPop 1
5410: oJumpForward 5595
5412: oGetParam 1
5414: oPushResult
5415: oCall 4965
5417: oPop 1
5419: oCall 8689
5421: oGetParam 1
5423: oPushResult
5424: oCall 5598
5426: oPop 1
5428: oGetParam 1
5430: oPushResult
5431: oCall 4965
5433: oPop 1
5435: oCall 8689
5437: oCall 8558
5439: oTypeSNodeType
5440: oChoice 5468
5442: oEmit 49
5444: oJumpForward 5487
5446: oEmit 55
5448: oJumpForward 5487
5450: oEmit 61
5452: oJumpForward 5487
5454: oCall 10905
5456: oEmit 15
5458: oSetResult 0
5460: oPushResult
5461: oEmitInt
5462: oPop 1
5464: oEmit 55
5466: oJumpForward 5487
5468: Choice Lookup Table
          41   5454
          42   5454
          37   5450
          36   5450
          43   5446
          30   5446
          35   5442
          33   5442
5485: oError 17
5487: oTypeSPop
5488: oGetGlobal 7
5490: oPushResult
5491: oTypeSPush
5492: oPop 1
5494: oJumpForward 5595
5496: oGetParam 1
5498: oPushResult
5499: oCall 4965
5501: oPop 1
5503: oCall 8689
5505: oGetParam 1
5507: oPushResult
5508: oCall 5598
5510: oPop 1
5512: oGetParam 1
5514: oPushResult
5515: oCall 4965
5517: oPop 1
5519: oCall 8689
5521: oCall 8558
5523: oTypeSNodeType
5524: oChoice 5552
5526: oEmit 48
5528: oJumpForward 5571
5530: oEmit 54
5532: oJumpForward 5571
5534: oEmit 60
5536: oJumpForward 5571
5538: oCall 10905
5540: oEmit 15
5542: oSetResult 0
5544: oPushResult
5545: oEmitInt
5546: oPop 1
5548: oEmit 54
5550: oJumpForward 5571
5552: Choice Lookup Table
          41   5538
          42   5538
          37   5534
          36   5534
          43   5530
          30   5530
          35   5526
          33   5526
5569: oError 17
5571: oTypeSPop
5572: oGetGlobal 7
5574: oPushResult
5575: oTypeSPush
5576: oPop 1
5578: oJumpForward 5595
5580: Choice Lookup Table
          12   5496
          11   5412
          10   5328
           9   5244
           8   5160
           7   5076
5593: oJumpForward 5597
5595: oJumpBack 5074
5597: oReturn
5598: oLocalSpace 1
5600: oGetAddrLocal 1
5602: oPushResult
5603: oSetResult 0
5605: oAssign
5606: oGetParam 1
5608: oPushResult
5609: oCall 5778
5611: oPop 1
5613: oInputChoice 5746
5615: oTypeSNodeType
5616: oChoice 5687
5618: oGetLocal 1
5620: oPushResult
5621: oSetResult 0
5623: oPushResult
5624: equal_label
5625: oPop 2
5627: oChoice 5636
5629: oGetAddrLocal 1
5631: oPushResult
5632: oLabelNew
5633: oAssign
5634: oJumpForward 5639
5636: Choice Lookup Table
           1   5629
5639: oEmit 69
5641: oGetLocal 1
5643: oPushResult
5644: oEmitLabel
5645: oPop 1
5647: oJumpForward 5694
5649: oGetParam 1
5651: oPushResult
5652: oCall 5034
5654: oPop 1
5656: oGetLocal 1
5658: oPushResult
5659: oSetResult 0
5661: oPushResult
5662: equal_label
5663: oPop 2
5665: oChoice 5674
5667: oGetAddrLocal 1
5669: oPushResult
5670: oLabelNew
5671: oAssign
5672: oJumpForward 5677
5674: Choice Lookup Table
           1   5667
5677: oEmit 69
5679: oGetLocal 1
5681: oPushResult
5682: oEmitLabel
5683: oPop 1
5685: oJumpForward 5694
5687: Choice Lookup Table
          33   5649
          34   5618
5692: oError 8
5694: oTypeSPop
5695: oEmit 78
5697: oGetFromParam 1
5699: oPushResult
5700: oEmitLabel
5701: oPop 1
5703: oGetParam 1
5705: oPushResult
5706: oSetResult 0
5708: oAssign
5709: oGetParam 1
5711: oPushResult
5712: oCall 5778
5714: oPop 1
5716: oTypeSNodeType
5717: oChoice 5730
5719: oJumpForward 5737
5721: oGetParam 1
5723: oPushResult
5724: oCall 5034
5726: oPop 1
5728: oJumpForward 5737
5730: Choice Lookup Table
          33   5721
          34   5719
5735: oError 8
5737: oTypeSPop
5738: oGetGlobal 8
5740: oPushResult
5741: oTypeSPush
5742: oPop 1
5744: oJumpForward 5751
5746: Choice Lookup Table
          58   5615
5749: oJumpForward 5753
5751: oJumpBack 5613
5753: oGetLocal 1
5755: oPushResult
5756: oSetResult 0
5758: oPushResult
5759: equal_label
5760: oPop 2
5762: oChoice 5774
5764: oEmit 78
5766: oGetLocal 1
5768: oPushResult
5769: oEmitLabel
5770: oPop 1
5772: oJumpForward 5777
5774: Choice Lookup Table
           0   5764
5777: oReturn
5778: oLocalSpace 2
5780: oGetAddrLocal 1
5782: oPushResult
5783: oSetResult 0
5785: oAssign
5786: oGetParam 1
5788: oPushResult
5789: oCall 5916
5791: oPop 1
5793: oInputChoice 5908
5795: oTypeSNodeType
5796: oChoice 5809
5798: oJumpForward 5816
5800: oGetParam 1
5802: oPushResult
5803: oCall 5034
5805: oPop 1
5807: oJumpForward 5816
5809: Choice Lookup Table
          33   5800
          34   5798
5814: oError 8
5816: oTypeSPop
5817: oGetLocal 1
5819: oPushResult
5820: oSetResult 0
5822: oPushResult
5823: equal_label
5824: oPop 2
5826: oChoice 5855
5828: oGetAddrLocal 1
5830: oPushResult
5831: oLabelNew
5832: oAssign
5833: oEmit 79
5835: oGetFromParam 1
5837: oPushResult
5838: oEmitLabel
5839: oPop 1
5841: oGetLocal 1
5843: oPushResult
5844: oEmitLabel
5845: oPop 1
5847: oGetParam 1
5849: oPushResult
5850: oGetLocal 1
5852: oAssign
5853: oJumpForward 5858
5855: Choice Lookup Table
           1   5828
5858: oGetAddrLocal 2
5860: oPushResult
5861: oSetResult 0
5863: oAssign
5864: oGetAddrLocal 2
5866: oPushResult
5867: oCall 5916
5869: oPop 1
5871: oTypeSNodeType
5872: oChoice 5885
5874: oJumpForward 5892
5876: oGetAddrLocal 2
5878: oPushResult
5879: oCall 5034
5881: oPop 1
5883: oJumpForward 5892
5885: Choice Lookup Table
          33   5876
          34   5874
5890: oError 8
5892: oEmit 79
5894: oGetLocal 2
5896: oPushResult
5897: oEmitLabel
5898: oPop 1
5900: oGetLocal 1
5902: oPushResult
5903: oEmitLabel
5904: oPop 1
5906: oJumpForward 5913
5908: Choice Lookup Table
          57   5795
5911: oJumpForward 5915
5913: oJumpBack 5793
5915: oReturn
5916: oLocalSpace 1
5918: oInputChoice 5972
5920: oGetAddrLocal 1
5922: oPushResult
5923: oSetResult 0
5925: oAssign
5926: oGetAddrLocal 1
5928: oPushResult
5929: oCall 5916
5931: oPop 1
5933: oTypeSNodeType
5934: oChoice 5963
5936: oGetParam 1
5938: oPushResult
5939: oLabelNew
5940: oAssign
5941: oEmit 69
5943: oGetFromParam 1
5945: oPushResult
5946: oEmitLabel
5947: oPop 1
5949: oEmit 78
5951: oGetLocal 1
5953: oPushResult
5954: oEmitLabel
5955: oPop 1
5957: oJumpForward 5970
5959: oEmit 43
5961: oJumpForward 5970
5963: Choice Lookup Table
          33   5959
          34   5936
5968: oError 8
5970: oJumpForward 5982
5972: Choice Lookup Table
          59   5920
5975: oGetParam 1
5977: oPushResult
5978: oCall 5983
5980: oPop 1
5982: oReturn
5983: oLocalSpace 2
5985: oGetAddrLocal 1
5987: oPushResult
5988: oSetResult 1
5990: oAssign
5991: oGetParam 1
5993: oPushResult
5994: oCall 6219
5996: oPop 1
5998: oInputChoice 6209
6000: oTypeSNodeType
6001: oChoice 6124
6003: oCall 8643
6005: oGetParam 1
6007: oPushResult
6008: oCall 6219
6010: oPop 1
6012: oTypeSNodeType
6013: oChoice 6021
6015: oEmit 23
6017: oCall 8006
6019: oJumpForward 6030
6021: Choice Lookup Table
          37   6015
          36   6015
6026: oCall 8663
6028: oEmit 38
6030: oJumpForward 6141
6032: oGetLocal 1
6034: oChoice 6050
6036: oGetAddrLocal 2
6038: oPushResult
6039: oCall 10688
6041: oAssign
6042: oGetAddrLocal 1
6044: oPushResult
6045: oSetResult 0
6047: oAssign
6048: oJumpForward 6053
6050: Choice Lookup Table
           1   6036
6053: oGetParam 1
6055: oPushResult
6056: oCall 6219
6058: oPop 1
6060: oTypeSNodeType
6061: oChoice 6099
6063: oCall 10797
6065: oEmit 18
6067: oGetLocal 2
6069: oPushResult
6070: oEmitInt
6071: oPop 1
6073: oGetGlobal 16
6075: oPushResult
6076: oTypeSPush
6077: oPop 1
6079: oJumpForward 6109
6081: oCall 10851
6083: oEmit 18
6085: oGetLocal 2
6087: oPushResult
6088: oEmitInt
6089: oPop 1
6091: oGetGlobal 16
6093: oPushResult
6094: oTypeSPush
6095: oPop 1
6097: oJumpForward 6109
6099: Choice Lookup Table
          35   6081
          41   6063
          42   6063
6106: oError 14
6108: oTypeSPop
6109: oJumpForward 6141
6111: oGetParam 1
6113: oPushResult
6114: oCall 6219
6116: oPop 1
6118: oCall 8643
6120: oCall 8006
6122: oJumpForward 6141
6124: Choice Lookup Table
          37   6111
          36   6111
          35   6032
          41   6032
          42   6032
          29   6003
          30   6003
6139: oError 17
6141: oJumpForward 6216
6143: oTypeSNodeType
6144: oChoice 6196
6146: oCall 8643
6148: oGetParam 1
6150: oPushResult
6151: oCall 6219
6153: oPop 1
6155: oCall 8663
6157: oEmit 41
6159: oJumpForward 6207
6161: oGetParam 1
6163: oPushResult
6164: oCall 6219
6166: oPop 1
6168: oTypeSNodeType
6169: oChoice 6183
6171: oCall 8643
6173: oCall 8062
6175: oJumpForward 6194
6177: oCall 8558
6179: oCall 8118
6181: oJumpForward 6194
6183: Choice Lookup Table
          37   6177
          36   6177
          29   6171
          30   6171
6192: oError 17
6194: oJumpForward 6207
6196: Choice Lookup Table
          37   6161
          36   6161
          29   6146
          30   6146
6205: oError 17
6207: oJumpForward 6216
6209: Choice Lookup Table
          26   6143
          25   6000
6214: oJumpForward 6218
6216: oJumpBack 5998
6218: oReturn
6219: oLocalSpace 0
6221: oGetParam 1
6223: oPushResult
6224: oCall 6270
6226: oPop 1
6228: oInputChoice 6260
6230: oCall 8643
6232: oGetParam 1
6234: oPushResult
6235: oCall 6270
6237: oPop 1
6239: oCall 8663
6241: oEmit 35
6243: oJumpForward 6267
6245: oCall 8643
6247: oGetParam 1
6249: oPushResult
6250: oCall 6270
6252: oPop 1
6254: oCall 8663
6256: oEmit 36
6258: oJumpForward 6267
6260: Choice Lookup Table
          24   6245
          23   6230
6265: oJumpForward 6269
6267: oJumpBack 6228
6269: oReturn
6270: oLocalSpace 0
6272: oInputChoice 6298
6274: oGetParam 1
6276: oPushResult
6277: oCall 6311
6279: oPop 1
6281: oCall 8663
6283: oJumpForward 6310
6285: oGetParam 1
6287: oPushResult
6288: oCall 6311
6290: oPop 1
6292: oCall 8663
6294: oEmit 42
6296: oJumpForward 6310
6298: Choice Lookup Table
          26   6285
          25   6274
6303: oGetParam 1
6305: oPushResult
6306: oCall 6311
6308: oPop 1
6310: oReturn
6311: oLocalSpace 7
6313: oInputChoice 6769
6315: oEmit 15
6317: TOKEN_VALUE
6318: oPushResult
6319: oEmitInt
6320: oPop 1
6322: oGetGlobal 6
6324: oPushResult
6325: oTypeSPush
6326: oPop 1
6328: oJumpForward 6792
6330: oEmit 15
6332: TOKEN_VALUE
6333: oPushResult
6334: oEmitInt
6335: oPop 1
6337: oGetGlobal 9
6339: oPushResult
6340: oTypeSPush
6341: oPop 1
6343: oJumpForward 6792
6345: oEmit 16
6347: TOKEN_VALUE_DOUBLE
6348: oPushResult
6349: oEmitDouble
6350: oPop 1
6352: oGetGlobal 13
6354: oPushResult
6355: oTypeSPush
6356: oPop 1
6358: oJumpForward 6792
6360: oGetParam 1
6362: oPushResult
6363: oCall 5065
6365: oPop 1
6367: oInput 16
6369: oJumpForward 6792
6371: oGetAddrLocal 1
6373: oPushResult
6374: CURRENT_STRLIT
6375: oPushResult
6376: oStringAllocShortStringLit
6377: oPop 1
6379: oAssign
6380: oEmit 17
6382: oGetLocal 1
6384: oPushResult
6385: oEmitInt
6386: oPop 1
6388: oGetGlobal 15
6390: oPushResult
6391: oTypeSPush
6392: oPop 1
6394: oCall 7604
6396: oCall 7550
6398: oJumpForward 6792
6400: oGetAddrLocal 2
6402: oPushResult
6403: oScopeFindRequire
6404: oAssign
6405: oGetAddrLocal 2
6407: oPushResult
6408: oCall 244
6410: oPop 1
6412: oGetLocal 2
6414: oPushResult
6415: oNodeType
6416: oPop 1
6418: oChoice 6689
6420: oGetLocal 2
6422: oPushResult
6423: oCall 11000
6425: oPop 1
6427: oJumpForward 6718
6429: oGetLocal 2
6431: oPushResult
6432: oCall 11664
6434: oPop 1
6436: oJumpForward 6718
6438: oGetAddrLocal 3
6440: oPushResult
6441: oGetLocal 2
6443: oPushResult
6444: oSetResult 21
6446: oPushResult
6447: oNodeGet
6448: oPop 2
6450: oAssign
6451: oGetLocal 3
6453: oPushResult
6454: oTypeSPush
6455: oPop 1
6457: oTypeSNodeType
6458: oChoice 6482
6460: oEmit 15
6462: oGetLocal 2
6464: oPushResult
6465: oCall 14033
6467: oPop 1
6469: oJumpForward 6499
6471: oEmit 15
6473: oGetLocal 2
6475: oPushResult
6476: oCall 14033
6478: oPop 1
6480: oJumpForward 6499
6482: Choice Lookup Table
          37   6471
          36   6471
          29   6460
          35   6460
          33   6460
          43   6460
          30   6460
6497: oError 16
6499: oJumpForward 6718
6501: oGetAddrLocal 4
6503: oPushResult
6504: oGetLocal 2
6506: oPushResult
6507: oSetResult 22
6509: oPushResult
6510: oNodeGetInt
6511: oPop 2
6513: oAssign
6514: oGetLocal 4
6516: oPushResult
6517: equal_zero
6518: oPop 1
6520: oChoice 6553
6522: oGetAddrLocal 4
6524: oPushResult
6525: oGetLocal 2
6527: oPushResult
6528: oSetResult 33
6530: oPushResult
6531: oNodeGetString
6532: oPop 2
6534: oPushResult
6535: oStringAllocShortStringLit
6536: oPop 1
6538: oAssign
6539: oGetLocal 2
6541: oPushResult
6542: oSetResult 22
6544: oPushResult
6545: oGetLocal 4
6547: oPushResult
6548: oNodeSetInt
6549: oPop 3
6551: oJumpForward 6556
6553: Choice Lookup Table
           1   6522
6556: oEmit 17
6558: oGetLocal 4
6560: oPushResult
6561: oEmitInt
6562: oPop 1
6564: oGetGlobal 15
6566: oPushResult
6567: oTypeSPush
6568: oPop 1
6570: oCall 7604
6572: oCall 7550
6574: oJumpForward 6718
6576: oGetLocal 2
6578: oPushResult
6579: oCall 6793
6581: oPop 1
6583: oJumpForward 6718
6585: oGetLocal 2
6587: oPushResult
6588: oSetResult 21
6590: oPushResult
6591: oNodeGet
6592: oPop 2
6594: oPushResult
6595: oTypeSPush
6596: oPop 1
6598: oInputChoice 6665
6600: oCall 4881
6602: oInput 16
6604: oCall 8378
6606: oTypeSNodeType
6607: oChoice 6652
6609: oInputChoice 6639
6611: oTypeSPop
6612: oGetLocal 3
6614: oPushResult
6615: oSetResult 37
6617: oPushResult
6618: oNodeGet
6619: oPop 2
6621: oPushResult
6622: oTypeSPush
6623: oPop 1
6625: oCall 7604
6627: oCall 7550
6629: oJumpForward 6644
6631: oCall 7799
6633: oCall 7604
6635: oCall 7550
6637: oJumpForward 6644
6639: Choice Lookup Table
          17   6631
          19   6611
6644: oJumpForward 6663
6646: oCall 7604
6648: oCall 7550
6650: oJumpForward 6663
6652: Choice Lookup Table
          42   6646
          40   6646
          38   6646
          37   6609
          36   6609
6663: oJumpForward 6687
6665: Choice Lookup Table
          15   6600
6668: oGetGlobal 25
6670: oChoice 6682
6672: oEmit 15
6674: oSetResult 0
6676: oPushResult
6677: oEmitInt
6678: oPop 1
6680: oJumpForward 6687
6682: Choice Lookup Table
           1   6672
6685: oError 31
6687: oJumpForward 6718
6689: Choice Lookup Table
          19   6585
          25   6576
          24   6576
          22   6576
          21   6576
          18   6501
          17   6438
          16   6438
          14   6429
          13   6420
6710: oError 6
6712: oGetGlobal 6
6714: oPushResult
6715: oTypeSPush
6716: oPop 1
6718: oJumpForward 6792
6720: oInput 0
6722: oGetAddrLocal 5
6724: oPushResult
6725: oScopeFindRequire
6726: oAssign
6727: oGetAddrLocal 5
6729: oPushResult
6730: oCall 244
6732: oPop 1
6734: oGetLocal 5
6736: oPushResult
6737: oSetResult 0
6739: oPushResult
6740: oCall 9205
6742: oPop 2
6744: oGetAddrLocal 6
6746: oPushResult
6747: oTypeSTop
6748: oAssign
6749: oTypeSPop
6750: oGetAddrLocal 7
6752: oPushResult
6753: oGetLocal 6
6755: oPushResult
6756: oCall 13052
6758: oPop 1
6760: oAssign
6761: oGetLocal 7
6763: oPushResult
6764: oTypeSPush
6765: oPop 1
6767: oJumpForward 6792
6769: Choice Lookup Table
          20   6720
           0   6400
           3   6371
          15   6360
           2   6345
           4   6330
           1   6315
6784: oError 6
6786: oGetGlobal 6
6788: oPushResult
6789: oTypeSPush
6790: oPop 1
6792: oReturn
6793: oLocalSpace 2
6795: oGetAddrLocal 1
6797: oPushResult
6798: oGetParam 1
6800: oPushResult
6801: oSetResult 21
6803: oPushResult
6804: oNodeGet
6805: oPop 2
6807: oAssign
6808: oGetAddrLocal 2
6810: oPushResult
6811: oGetParam 1
6813: oPushResult
6814: oCall 13987
6816: oPop 1
6818: oAssign
6819: oGetLocal 1
6821: oPushResult
6822: oTypeSPush
6823: oPop 1
6825: oTypeSNodeType
6826: oChoice 7525
6828: oGetParam 1
6830: oPushResult
6831: oNodeType
6832: oPop 1
6834: oChoice 6980
6836: oEmit 0
6838: oGetParam 1
6840: oPushResult
6841: oCall 14033
6843: oPop 1
6845: oJumpForward 6990
6847: oGetLocal 2
6849: oPushResult
6850: equal_zero
6851: oPop 1
6853: oChoice 6866
6855: oEmit 3
6857: oGetParam 1
6859: oPushResult
6860: oCall 14033
6862: oPop 1
6864: oJumpForward 6884
6866: Choice Lookup Table
           1   6855
6869: oEmit 9
6871: oGetLocal 2
6873: oPushResult
6874: oEmitInt
6875: oPop 1
6877: oGetParam 1
6879: oPushResult
6880: oCall 14033
6882: oPop 1
6884: oJumpForward 6990
6886: oGetParam 1
6888: oPushResult
6889: oSetResult 34
6891: oPushResult
6892: oNodeGetBoolean
6893: oPop 2
6895: oChoice 6938
6897: oGetLocal 2
6899: oPushResult
6900: equal_zero
6901: oPop 1
6903: oChoice 6916
6905: oEmit 8
6907: oGetParam 1
6909: oPushResult
6910: oCall 14033
6912: oPop 1
6914: oJumpForward 6934
6916: Choice Lookup Table
           1   6905
6919: oEmit 14
6921: oGetLocal 2
6923: oPushResult
6924: oEmitInt
6925: oPop 1
6927: oGetParam 1
6929: oPushResult
6930: oCall 14033
6932: oPop 1
6934: oEmit 24
6936: oJumpForward 6978
6938: Choice Lookup Table
           1   6897
6941: oGetLocal 2
6943: oPushResult
6944: equal_zero
6945: oPop 1
6947: oChoice 6960
6949: oEmit 6
6951: oGetParam 1
6953: oPushResult
6954: oCall 14033
6956: oPop 1
6958: oJumpForward 6978
6960: Choice Lookup Table
           1   6949
6963: oEmit 12
6965: oGetLocal 2
6967: oPushResult
6968: oEmitInt
6969: oPop 1
6971: oGetParam 1
6973: oPushResult
6974: oCall 14033
6976: oPop 1
6978: oJumpForward 6990
6980: Choice Lookup Table
          24   6886
          22   6847
          25   6836
          21   6836
6989: oEndChoice
6990: oJumpForward 7549
6992: oGetParam 1
6994: oPushResult
6995: oNodeType
6996: oPop 1
6998: oChoice 7144
7000: oEmit 1
7002: oGetParam 1
7004: oPushResult
7005: oCall 14033
7007: oPop 1
7009: oJumpForward 7154
7011: oGetLocal 2
7013: oPushResult
7014: equal_zero
7015: oPop 1
7017: oChoice 7030
7019: oEmit 4
7021: oGetParam 1
7023: oPushResult
7024: oCall 14033
7026: oPop 1
7028: oJumpForward 7048
7030: Choice Lookup Table
           1   7019
7033: oEmit 10
7035: oGetLocal 2
7037: oPushResult
7038: oEmitInt
7039: oPop 1
7041: oGetParam 1
7043: oPushResult
7044: oCall 14033
7046: oPop 1
7048: oJumpForward 7154
7050: oGetParam 1
7052: oPushResult
7053: oSetResult 34
7055: oPushResult
7056: oNodeGetBoolean
7057: oPop 2
7059: oChoice 7102
7061: oGetLocal 2
7063: oPushResult
7064: equal_zero
7065: oPop 1
7067: oChoice 7080
7069: oEmit 8
7071: oGetParam 1
7073: oPushResult
7074: oCall 14033
7076: oPop 1
7078: oJumpForward 7098
7080: Choice Lookup Table
           1   7069
7083: oEmit 14
7085: oGetLocal 2
7087: oPushResult
7088: oEmitInt
7089: oPop 1
7091: oGetParam 1
7093: oPushResult
7094: oCall 14033
7096: oPop 1
7098: oEmit 25
7100: oJumpForward 7142
7102: Choice Lookup Table
           1   7061
7105: oGetLocal 2
7107: oPushResult
7108: equal_zero
7109: oPop 1
7111: oChoice 7124
7113: oEmit 7
7115: oGetParam 1
7117: oPushResult
7118: oCall 14033
7120: oPop 1
7122: oJumpForward 7142
7124: Choice Lookup Table
           1   7113
7127: oEmit 13
7129: oGetLocal 2
7131: oPushResult
7132: oEmitInt
7133: oPop 1
7135: oGetParam 1
7137: oPushResult
7138: oCall 14033
7140: oPop 1
7142: oJumpForward 7154
7144: Choice Lookup Table
          24   7050
          22   7011
          25   7000
          21   7000
7153: oEndChoice
7154: oJumpForward 7549
7156: oError 16
7158: oJumpForward 7549
7160: oGetParam 1
7162: oPushResult
7163: oNodeType
7164: oPop 1
7166: oChoice 7312
7168: oEmit 2
7170: oGetParam 1
7172: oPushResult
7173: oCall 14033
7175: oPop 1
7177: oJumpForward 7322
7179: oGetLocal 2
7181: oPushResult
7182: equal_zero
7183: oPop 1
7185: oChoice 7198
7187: oEmit 5
7189: oGetParam 1
7191: oPushResult
7192: oCall 14033
7194: oPop 1
7196: oJumpForward 7216
7198: Choice Lookup Table
           1   7187
7201: oEmit 11
7203: oGetLocal 2
7205: oPushResult
7206: oEmitInt
7207: oPop 1
7209: oGetParam 1
7211: oPushResult
7212: oCall 14033
7214: oPop 1
7216: oJumpForward 7322
7218: oGetParam 1
7220: oPushResult
7221: oSetResult 34
7223: oPushResult
7224: oNodeGetBoolean
7225: oPop 2
7227: oChoice 7270
7229: oGetLocal 2
7231: oPushResult
7232: equal_zero
7233: oPop 1
7235: oChoice 7248
7237: oEmit 8
7239: oGetParam 1
7241: oPushResult
7242: oCall 14033
7244: oPop 1
7246: oJumpForward 7266
7248: Choice Lookup Table
           1   7237
7251: oEmit 14
7253: oGetLocal 2
7255: oPushResult
7256: oEmitInt
7257: oPop 1
7259: oGetParam 1
7261: oPushResult
7262: oCall 14033
7264: oPop 1
7266: oEmit 26
7268: oJumpForward 7310
7270: Choice Lookup Table
           1   7229
7273: oGetLocal 2
7275: oPushResult
7276: equal_zero
7277: oPop 1
7279: oChoice 7292
7281: oEmit 8
7283: oGetParam 1
7285: oPushResult
7286: oCall 14033
7288: oPop 1
7290: oJumpForward 7310
7292: Choice Lookup Table
           1   7281
7295: oEmit 14
7297: oGetLocal 2
7299: oPushResult
7300: oEmitInt
7301: oPop 1
7303: oGetParam 1
7305: oPushResult
7306: oCall 14033
7308: oPop 1
7310: oJumpForward 7322
7312: Choice Lookup Table
          24   7218
          22   7179
          25   7168
          21   7168
7321: oEndChoice
7322: oInputChoice 7352
7324: oTypeSPop
7325: oGetLocal 1
7327: oPushResult
7328: oSetResult 37
7330: oPushResult
7331: oNodeGet
7332: oPop 2
7334: oPushResult
7335: oTypeSPush
7336: oPop 1
7338: oCall 7604
7340: oCall 7550
7342: oJumpForward 7357
7344: oCall 7799
7346: oCall 7604
7348: oCall 7550
7350: oJumpForward 7357
7352: Choice Lookup Table
          17   7344
          19   7324
7357: oJumpForward 7549
7359: oGetParam 1
7361: oPushResult
7362: oNodeType
7363: oPop 1
7365: oChoice 7509
7367: oEmit 17
7369: oGetParam 1
7371: oPushResult
7372: oCall 14033
7374: oPop 1
7376: oJumpForward 7519
7378: oGetLocal 2
7380: oPushResult
7381: equal_zero
7382: oPop 1
7384: oChoice 7397
7386: oEmit 18
7388: oGetParam 1
7390: oPushResult
7391: oCall 14033
7393: oPop 1
7395: oJumpForward 7415
7397: Choice Lookup Table
           1   7386
7400: oEmit 21
7402: oGetLocal 2
7404: oPushResult
7405: oEmitInt
7406: oPop 1
7408: oGetParam 1
7410: oPushResult
7411: oCall 14033
7413: oPop 1
7415: oJumpForward 7519
7417: oGetParam 1
7419: oPushResult
7420: oSetResult 34
7422: oPushResult
7423: oNodeGetBoolean
7424: oPop 2
7426: oChoice 7467
7428: oGetLocal 2
7430: oPushResult
7431: equal_zero
7432: oPop 1
7434: oChoice 7447
7436: oEmit 8
7438: oGetParam 1
7440: oPushResult
7441: oCall 14033
7443: oPop 1
7445: oJumpForward 7465
7447: Choice Lookup Table
           1   7436
7450: oEmit 14
7452: oGetLocal 2
7454: oPushResult
7455: oEmitInt
7456: oPop 1
7458: oGetParam 1
7460: oPushResult
7461: oCall 14033
7463: oPop 1
7465: oJumpForward 7507
7467: Choice Lookup Table
           1   7428
7470: oGetLocal 2
7472: oPushResult
7473: equal_zero
7474: oPop 1
7476: oChoice 7489
7478: oEmit 19
7480: oGetParam 1
7482: oPushResult
7483: oCall 14033
7485: oPop 1
7487: oJumpForward 7507
7489: Choice Lookup Table
           1   7478
7492: oEmit 22
7494: oGetLocal 2
7496: oPushResult
7497: oEmitInt
7498: oPop 1
7500: oGetParam 1
7502: oPushResult
7503: oCall 14033
7505: oPop 1
7507: oJumpForward 7519
7509: Choice Lookup Table
          24   7417
          22   7378
          25   7367
          21   7367
7518: oEndChoice
7519: oCall 7604
7521: oCall 7550
7523: oJumpForward 7549
7525: Choice Lookup Table
          42   7359
          40   7359
          38   7359
          37   7160
          36   7160
          28   7156
          35   6992
          29   6992
          33   6992
          43   6828
          30   6828
7548: oEndChoice
7549: oReturn
7550: oLocalSpace 0
7552: oTypeSNodeType
7553: oChoice 7577
7555: oEmit 24
7557: oJumpForward 7603
7559: oEmit 25
7561: oJumpForward 7603
7563: oError 16
7565: oJumpForward 7603
7567: oEmit 26
7569: oJumpForward 7603
7571: oError 29
7573: oJumpForward 7603
7575: oJumpForward 7603
7577: Choice Lookup Table
          42   7575
          41   7575
          40   7575
          38   7575
          37   7571
          36   7567
          28   7563
          35   7559
          29   7559
          33   7559
          43   7555
          30   7555
7602: oEndChoice
7603: oReturn
7604: oLocalSpace 0
7606: oInputChoice 7644
7608: oTypeSNodeType
7609: oChoice 7623
7611: oCall 7656
7613: oJumpForward 7634
7615: oCall 7799
7617: oJumpForward 7634
7619: oCall 7878
7621: oJumpForward 7634
7623: Choice Lookup Table
          42   7619
          41   7619
          36   7615
          38   7611
7632: oError 10
7634: oJumpForward 7653
7636: oCall 7908
7638: oJumpForward 7653
7640: oCall 8181
7642: oJumpForward 7653
7644: Choice Lookup Table
          19   7640
          21   7636
          17   7608
7651: oJumpForward 7655
7653: oJumpBack 7606
7655: oReturn
7656: oLocalSpace 3
7658: oTypeSNodeType
7659: oChoice 7663
7661: oJumpForward 7668
7663: Choice Lookup Table
          38   7661
7666: oError 10
7668: oTypeSNodeType
7669: oChoice 7673
7671: oJumpForward 7678
7673: Choice Lookup Table
          38   7671
7676: oError 13
7678: oGetAddrLocal 1
7680: oPushResult
7681: oTypeSTop
7682: oPushResult
7683: oSetResult 38
7685: oPushResult
7686: oNodeGet
7687: oPop 2
7689: oPushResult
7690: oCall 13136
7692: oPop 1
7694: oAssign
7695: oGetAddrLocal 2
7697: oPushResult
7698: oTypeSTop
7699: oPushResult
7700: oSetResult 37
7702: oPushResult
7703: oNodeGet
7704: oPop 2
7706: oAssign
7707: oTypeSPop
7708: oGetLocal 2
7710: oPushResult
7711: oTypeSPush
7712: oPop 1
7714: oCall 4881
7716: oCall 8616
7718: oGetLocal 1
7720: oPushResult
7721: equal_zero
7722: oPop 1
7724: oChoice 7738
7726: oEmit 15
7728: oGetLocal 1
7730: oPushResult
7731: oEmitInt
7732: oPop 1
7734: oEmit 41
7736: oJumpForward 7741
7738: Choice Lookup Table
           0   7726
7741: oGetAddrLocal 3
7743: oPushResult
7744: oGetLocal 2
7746: oPushResult
7747: oSetResult 17
7749: oPushResult
7750: oNodeGetInt
7751: oPop 2
7753: oAssign
7754: oGetLocal 3
7756: oPushResult
7757: oSetResult 1
7759: oPushResult
7760: equal
7761: oPop 2
7763: oChoice 7777
7765: oEmit 15
7767: oGetLocal 3
7769: oPushResult
7770: oEmitInt
7771: oPop 1
7773: oEmit 35
7775: oJumpForward 7780
7777: Choice Lookup Table
           0   7765
7780: oEmit 37
7782: oInputChoice 7790
7784: oJumpForward 7798
7786: oJumpForward 7796
7788: oJumpForward 7796
7790: Choice Lookup Table
          14   7788
          18   7784
7795: oEndChoice
7796: oJumpBack 7668
7798: oReturn
7799: oLocalSpace 2
7801: oTypeSNodeType
7802: oChoice 7806
7804: oJumpForward 7811
7806: Choice Lookup Table
          36   7804
7809: oError 29
7811: oGetAddrLocal 1
7813: oPushResult
7814: oTypeSTop
7815: oPushResult
7816: oSetResult 37
7818: oPushResult
7819: oNodeGet
7820: oPop 2
7822: oAssign
7823: oTypeSPop
7824: oGetLocal 1
7826: oPushResult
7827: oTypeSPush
7828: oPop 1
7830: oCall 4881
7832: oCall 8616
7834: oGetAddrLocal 2
7836: oPushResult
7837: oGetLocal 1
7839: oPushResult
7840: oSetResult 17
7842: oPushResult
7843: oNodeGetInt
7844: oPop 2
7846: oAssign
7847: oGetLocal 2
7849: oPushResult
7850: oSetResult 1
7852: oPushResult
7853: equal
7854: oPop 2
7856: oChoice 7870
7858: oEmit 15
7860: oGetLocal 2
7862: oPushResult
7863: oEmitInt
7864: oPop 1
7866: oEmit 35
7868: oJumpForward 7873
7870: Choice Lookup Table
           0   7858
7873: oEmit 37
7875: oInput 18
7877: oReturn
7878: oLocalSpace 0
7880: oTypeSNodeType
7881: oChoice 7885
7883: oJumpForward 7892
7885: Choice Lookup Table
          42   7883
          41   7883
7890: oError 29
7892: oTypeSPop
7893: oGetGlobal 9
7895: oPushResult
7896: oTypeSPush
7897: oPop 1
7899: oCall 4881
7901: oCall 8616
7903: oEmit 37
7905: oInput 18
7907: oReturn
7908: oLocalSpace 2
7910: oTypeSNodeType
7911: oChoice 7915
7913: oJumpForward 7920
7915: Choice Lookup Table
          40   7913
7918: oError 11
7920: oTypeSTop
7921: oPushResult
7922: oSetResult 41
7924: oPushResult
7925: oNodeGet
7926: oPop 2
7928: oPushResult
7929: oScopeEnter
7930: oPop 1
7932: oInput 0
7934: oGetAddrLocal 1
7936: oPushResult
7937: oScopeFindRequire
7938: oAssign
7939: oGetLocal 1
7941: oPushResult
7942: oNodeType
7943: oPop 1
7945: oChoice 7949
7947: oJumpForward 7954
7949: Choice Lookup Table
          23   7947
7952: oError 12
7954: oScopeEnd
7955: oGetAddrLocal 2
7957: oPushResult
7958: oGetLocal 1
7960: oPushResult
7961: oSetResult 22
7963: oPushResult
7964: oNodeGetInt
7965: oPop 2
7967: oAssign
7968: oGetLocal 2
7970: oPushResult
7971: equal_zero
7972: oPop 1
7974: oChoice 7988
7976: oEmit 15
7978: oGetLocal 2
7980: oPushResult
7981: oEmitInt
7982: oPop 1
7984: oEmit 37
7986: oJumpForward 7991
7988: Choice Lookup Table
           0   7976
7991: oTypeSPop
7992: oGetLocal 1
7994: oPushResult
7995: oSetResult 21
7997: oPushResult
7998: oNodeGet
7999: oPop 2
8001: oPushResult
8002: oTypeSPush
8003: oPop 1
8005: oReturn
8006: oLocalSpace 2
8008: oGetAddrLocal 1
8010: oPushResult
8011: oTypeSTop
8012: oPushResult
8013: oSetResult 37
8015: oPushResult
8016: oNodeGet
8017: oPop 2
8019: oAssign
8020: oGetAddrLocal 2
8022: oPushResult
8023: oGetLocal 1
8025: oPushResult
8026: oSetResult 17
8028: oPushResult
8029: oNodeGetInt
8030: oPop 2
8032: oAssign
8033: oGetLocal 2
8035: oPushResult
8036: oSetResult 1
8038: oPushResult
8039: equal
8040: oPop 2
8042: oChoice 8056
8044: oEmit 15
8046: oGetLocal 2
8048: oPushResult
8049: oEmitInt
8050: oPop 1
8052: oEmit 35
8054: oJumpForward 8059
8056: Choice Lookup Table
           0   8044
8059: oEmit 37
8061: oReturn
8062: oLocalSpace 2
8064: oGetAddrLocal 1
8066: oPushResult
8067: oTypeSTop
8068: oPushResult
8069: oSetResult 37
8071: oPushResult
8072: oNodeGet
8073: oPop 2
8075: oAssign
8076: oGetAddrLocal 2
8078: oPushResult
8079: oGetLocal 1
8081: oPushResult
8082: oSetResult 17
8084: oPushResult
8085: oNodeGetInt
8086: oPop 2
8088: oAssign
8089: oGetLocal 2
8091: oPushResult
8092: oSetResult 1
8094: oPushResult
8095: equal
8096: oPop 2
8098: oChoice 8112
8100: oEmit 15
8102: oGetLocal 2
8104: oPushResult
8105: oEmitInt
8106: oPop 1
8108: oEmit 35
8110: oJumpForward 8115
8112: Choice Lookup Table
           0   8100
8115: oEmit 40
8117: oReturn
8118: oLocalSpace 2
8120: oEmit 39
8122: oGetAddrLocal 1
8124: oPushResult
8125: oTypeSTop
8126: oPushResult
8127: oSetResult 37
8129: oPushResult
8130: oNodeGet
8131: oPop 2
8133: oAssign
8134: oGetAddrLocal 2
8136: oPushResult
8137: oGetLocal 1
8139: oPushResult
8140: oSetResult 17
8142: oPushResult
8143: oNodeGetInt
8144: oPop 2
8146: oAssign
8147: oGetLocal 2
8149: oPushResult
8150: oSetResult 1
8152: oPushResult
8153: equal
8154: oPop 2
8156: oChoice 8170
8158: oEmit 15
8160: oGetLocal 2
8162: oPushResult
8163: oEmitInt
8164: oPop 1
8166: oEmit 36
8168: oJumpForward 8173
8170: Choice Lookup Table
           0   8158
8173: oTypeSPop
8174: oGetGlobal 6
8176: oPushResult
8177: oTypeSPush
8178: oPop 1
8180: oReturn
8181: oLocalSpace 1
8183: oTypeSNodeType
8184: oChoice 8192
8186: oJumpForward 8199
8188: oError 29
8190: oJumpForward 8199
8192: Choice Lookup Table
          37   8188
          36   8186
8197: oError 9
8199: oEmit 26
8201: oGetAddrLocal 1
8203: oPushResult
8204: oTypeSTop
8205: oAssign
8206: oTypeSPop
8207: oGetLocal 1
8209: oPushResult
8210: oSetResult 37
8212: oPushResult
8213: oNodeGet
8214: oPop 2
8216: oPushResult
8217: oTypeSPush
8218: oPop 1
8220: oReturn
8221: oLocalSpace 3
8223: oGetAddrLocal 1
8225: oPushResult
8226: oTypeSNodeType
8227: oAssign
8228: oGetAddrLocal 2
8230: oPushResult
8231: oTypeSTop
8232: oAssign
8233: oTypeSPop
8234: oGetLocal 1
8236: oPushResult
8237: oTypeSNodeType
8238: oPushResult
8239: equal_node_type
8240: oPop 2
8242: oChoice 8374
8244: oTypeSNodeType
8245: oChoice 8359
8247: oGetLocal 1
8249: oChoice 8256
8251: oEmit 31
8253: oReturn
8254: oJumpForward 8259
8256: Choice Lookup Table
          29   8251
8259: oJumpForward 8370
8261: oGetLocal 1
8263: oChoice 8270
8265: oEmit 32
8267: oReturn
8268: oJumpForward 8273
8270: Choice Lookup Table
          30   8265
8273: oJumpForward 8370
8275: oGetLocal 1
8277: oChoice 8310
8279: oReturn
8280: oJumpForward 8315
8282: oTypeSTop
8283: oPushResult
8284: oGetGlobal 10
8286: oPushResult
8287: equal_node
8288: oPop 2
8290: oChoice 8305
8292: oEmit 15
8294: oSetResult 1
8296: oPushResult
8297: oEmitInt
8298: oPop 1
8300: oEmit 37
8302: oReturn
8303: oJumpForward 8308
8305: Choice Lookup Table
           1   8292
8308: oJumpForward 8315
8310: Choice Lookup Table
          41   8282
          37   8279
8315: oJumpForward 8370
8317: oGetLocal 1
8319: oChoice 8324
8321: oReturn
8322: oJumpForward 8327
8324: Choice Lookup Table
          36   8321
8327: oJumpForward 8370
8329: oGetLocal 1
8331: oChoice 8352
8333: oReturn
8334: oJumpForward 8357
8336: oGetGlobal 9
8338: oPushResult
8339: oTypeSPush
8340: oPop 1
8342: oGetAddrLocal 3
8344: oPushResult
8345: oCall 10688
8347: oAssign
8348: oTypeSPop
8349: oReturn
8350: oJumpForward 8357
8352: Choice Lookup Table
          35   8336
          41   8333
8357: oJumpForward 8370
8359: Choice Lookup Table
          42   8329
          37   8317
          36   8275
          29   8261
          30   8247
8370: oError 14
8372: oJumpForward 8377
8374: Choice Lookup Table
           0   8244
8377: oReturn
8378: oLocalSpace 2
8380: oGetAddrLocal 1
8382: oPushResult
8383: oTypeSNodeType
8384: oAssign
8385: oTypeSPop
8386: oGetLocal 1
8388: oPushResult
8389: oTypeSNodeType
8390: oPushResult
8391: equal_node_type
8392: oPop 2
8394: oChoice 8554
8396: oTypeSNodeType
8397: oChoice 8533
8399: oGetLocal 1
8401: oChoice 8411
8403: oEmit 31
8405: oReturn
8406: oJumpForward 8422
8408: oReturn
8409: oJumpForward 8422
8411: Choice Lookup Table
          43   8408
          30   8408
          33   8403
          35   8403
          29   8403
8422: oJumpForward 8550
8424: oGetLocal 1
8426: oChoice 8436
8428: oReturn
8429: oJumpForward 8447
8431: oEmit 32
8433: oReturn
8434: oJumpForward 8447
8436: Choice Lookup Table
          43   8431
          30   8431
          33   8428
          35   8428
          29   8428
8447: oJumpForward 8550
8449: oGetLocal 1
8451: oChoice 8484
8453: oReturn
8454: oJumpForward 8489
8456: oTypeSTop
8457: oPushResult
8458: oGetGlobal 10
8460: oPushResult
8461: equal_node
8462: oPop 2
8464: oChoice 8479
8466: oEmit 15
8468: oSetResult 1
8470: oPushResult
8471: oEmitInt
8472: oPop 1
8474: oEmit 37
8476: oReturn
8477: oJumpForward 8482
8479: Choice Lookup Table
           1   8466
8482: oJumpForward 8489
8484: Choice Lookup Table
          41   8456
          37   8453
8489: oJumpForward 8550
8491: oGetLocal 1
8493: oChoice 8498
8495: oReturn
8496: oJumpForward 8501
8498: Choice Lookup Table
          36   8495
8501: oJumpForward 8550
8503: oGetLocal 1
8505: oChoice 8526
8507: oReturn
8508: oJumpForward 8531
8510: oGetGlobal 9
8512: oPushResult
8513: oTypeSPush
8514: oPop 1
8516: oGetAddrLocal 2
8518: oPushResult
8519: oCall 10688
8521: oAssign
8522: oTypeSPop
8523: oReturn
8524: oJumpForward 8531
8526: Choice Lookup Table
          35   8510
          41   8507
8531: oJumpForward 8550
8533: Choice Lookup Table
          42   8503
          37   8491
          36   8449
          33   8424
          35   8424
          29   8424
          43   8399
          30   8399
8550: oError 14
8552: oJumpForward 8557
8554: Choice Lookup Table
           0   8396
8557: oReturn
8558: oLocalSpace 1
8560: oGetAddrLocal 1
8562: oPushResult
8563: oTypeSNodeType
8564: oAssign
8565: oTypeSPop
8566: oGetLocal 1
8568: oPushResult
8569: oTypeSNodeType
8570: oPushResult
8571: equal_node_type
8572: oPop 2
8574: oChoice 8612
8576: oTypeSNodeType
8577: oChoice 8603
8579: oGetLocal 1
8581: oChoice 8586
8583: oReturn
8584: oJumpForward 8589
8586: Choice Lookup Table
          37   8583
8589: oJumpForward 8608
8591: oGetLocal 1
8593: oChoice 8598
8595: oReturn
8596: oJumpForward 8601
8598: Choice Lookup Table
          36   8595
8601: oJumpForward 8608
8603: Choice Lookup Table
          37   8591
          36   8579
8608: oError 14
8610: oJumpForward 8615
8612: Choice Lookup Table
           0   8576
8615: oReturn
8616: oLocalSpace 0
8618: oTypeSNodeType
8619: oChoice 8623
8621: oJumpForward 8628
8623: Choice Lookup Table
          30   8621
8626: oError 7
8628: oTypeSPop
8629: oReturn
8630: oLocalSpace 0
8632: oTypeSNodeType
8633: oChoice 8637
8635: oJumpForward 8642
8637: Choice Lookup Table
          30   8635
8640: oError 7
8642: oReturn
8643: oLocalSpace 0
8645: oTypeSNodeType
8646: oChoice 8654
8648: oJumpForward 8661
8650: oEmit 31
8652: oJumpForward 8661
8654: Choice Lookup Table
          29   8650
          30   8648
8659: oError 7
8661: oTypeSPop
8662: oReturn
8663: oLocalSpace 0
8665: oTypeSNodeType
8666: oChoice 8681
8668: oJumpForward 8688
8670: oEmit 31
8672: oTypeSPop
8673: oGetGlobal 6
8675: oPushResult
8676: oTypeSPush
8677: oPop 1
8679: oJumpForward 8688
8681: Choice Lookup Table
          29   8670
          30   8668
8686: oError 7
8688: oReturn
8689: oLocalSpace 0
8691: oTypeSNodeType
8692: oChoice 8705
8694: oEmit 31
8696: oTypeSPop
8697: oGetGlobal 6
8699: oPushResult
8700: oTypeSPush
8701: oPop 1
8703: oJumpForward 8708
8705: Choice Lookup Table
          29   8694
8708: oReturn
8709: oLocalSpace 0
8711: oTypeSNodeType
8712: oChoice 8716
8714: oJumpForward 8721
8716: Choice Lookup Table
          33   8714
8719: oError 8
8721: oTypeSPop
8722: oReturn
8723: oLocalSpace 0
8725: oTypeSNodeType
8726: oChoice 8730
8728: oJumpForward 8735
8730: Choice Lookup Table
          33   8728
8733: oError 8
8735: oReturn
8736: oLocalSpace 0
8738: oInputChoice 8801
8740: oCall 10461
8742: oJumpForward 8832
8744: oCall 10468
8746: oJumpForward 8832
8748: oCall 10598
8750: oJumpForward 8832
8752: oCall 10605
8754: oJumpForward 8832
8756: oCall 9612
8758: oJumpForward 8832
8760: oCall 9935
8762: oJumpForward 8832
8764: oCall 9678
8766: oJumpForward 8832
8768: oCall 9855
8770: oJumpForward 8832
8772: oCall 10020
8774: oJumpForward 8832
8776: oCall 9988
8778: oJumpForward 8832
8780: oCall 10438
8782: oJumpForward 8832
8784: oCall 8833
8786: oJumpForward 8832
8788: oCall 10052
8790: oJumpForward 8832
8792: oCall 10386
8794: oJumpForward 8832
8796: oChangeIntLitToLabelIdent
8797: oCall 8833
8799: oJumpForward 8832
8801: Choice Lookup Table
           1   8796
          56   8792
          54   8788
           0   8784
          36   8780
          52   8776
          53   8772
          50   8768
          45   8764
          49   8760
          42   8756
          69   8752
          68   8748
          67   8744
          66   8740
8832: oReturn
8833: oLocalSpace 1
8835: oGetAddrLocal 1
8837: oPushResult
8838: oScopeFindRequire
8839: oAssign
8840: oGetAddrLocal 1
8842: oPushResult
8843: oCall 244
8845: oPop 1
8847: oGetLocal 1
8849: oPushResult
8850: oNodeType
8851: oPop 1
8853: oChoice 8893
8855: oGetLocal 1
8857: oPushResult
8858: oCall 8911
8860: oPop 1
8862: oCall 8736
8864: oJumpForward 8910
8866: oGetLocal 1
8868: oPushResult
8869: oCall 11000
8871: oPop 1
8873: oJumpForward 8910
8875: oGetLocal 1
8877: oPushResult
8878: oCall 8961
8880: oPop 1
8882: oJumpForward 8910
8884: oGetLocal 1
8886: oPushResult
8887: oCall 9051
8889: oPop 1
8891: oJumpForward 8910
8893: Choice Lookup Table
          13   8884
          19   8875
          24   8875
          22   8875
          21   8875
          12   8866
          26   8855
8908: oError 0
8910: oReturn
8911: oLocalSpace 0
8913: oGetParam 1
8915: oPushResult
8916: oSetResult 35
8918: oPushResult
8919: oNodeGetBoolean
8920: oPop 2
8922: oChoice 8928
8924: oError 21
8926: oJumpForward 8931
8928: Choice Lookup Table
           1   8924
8931: oEmit 78
8933: oGetParam 1
8935: oPushResult
8936: oSetResult 22
8938: oPushResult
8939: oNodeGetLabel
8940: oPop 2
8942: oPushResult
8943: oEmitLabel
8944: oPop 1
8946: oGetParam 1
8948: oPushResult
8949: oSetResult 35
8951: oPushResult
8952: oSetResult 1
8954: oPushResult
8955: oNodeSetBoolean
8956: oPop 3
8958: oInput 13
8960: oReturn
8961: oLocalSpace 0
8963: oGetParam 1
8965: oPushResult
8966: oSetResult 1
8968: oPushResult
8969: oCall 9205
8971: oPop 2
8973: oInput 5
8975: oCall 4881
8977: oCall 8221
8979: oCall 8982
8981: oReturn
8982: oLocalSpace 1
8984: oTypeSNodeType
8985: oChoice 9025
8987: oEmit 27
8989: oJumpForward 9049
8991: oEmit 28
8993: oJumpForward 9049
8995: oError 16
8997: oJumpForward 9049
8999: oEmit 29
9001: oJumpForward 9049
9003: oGetAddrLocal 1
9005: oPushResult
9006: oTypeSTop
9007: oPushResult
9008: oSetResult 17
9010: oPushResult
9011: oNodeGetInt
9012: oPop 2
9014: oAssign
9015: oEmit 30
9017: oGetLocal 1
9019: oPushResult
9020: oEmitInt
9021: oPop 1
9023: oJumpForward 9049
9025: Choice Lookup Table
          42   9003
          40   9003
          38   9003
          37   8999
          36   8999
          28   8995
          35   8991
          29   8991
          33   8991
          43   8987
          30   8987
9048: oEndChoice
9049: oTypeSPop
9050: oReturn
9051: oLocalSpace 1
9053: oGetParam 1
9055: oPushResult
9056: oSetResult 6
9058: oPushResult
9059: oNodeGet
9060: oPop 2
9062: oPushResult
9063: oScopeCurrent
9064: oPushResult
9065: oNodeEqual
9066: oPop 2
9068: oChoice 9074
9070: oError 20
9072: oJumpForward 9077
9074: Choice Lookup Table
           0   9070
9077: oEmit 8
9079: oGetParam 1
9081: oPushResult
9082: oSetResult 31
9084: oPushResult
9085: oNodeGetInt
9086: oPop 2
9088: oPushResult
9089: oEmitInt
9090: oPop 1
9092: oGetParam 1
9094: oPushResult
9095: oSetResult 21
9097: oPushResult
9098: oNodeGet
9099: oPop 2
9101: oPushResult
9102: oTypeSPush
9103: oPop 1
9105: oInput 5
9107: oCall 4881
9109: oCall 8221
9111: oTypeSNodeType
9112: oChoice 9152
9114: oEmit 27
9116: oJumpForward 9176
9118: oEmit 28
9120: oJumpForward 9176
9122: oError 16
9124: oJumpForward 9176
9126: oEmit 29
9128: oJumpForward 9176
9130: oGetAddrLocal 1
9132: oPushResult
9133: oTypeSTop
9134: oPushResult
9135: oSetResult 17
9137: oPushResult
9138: oNodeGetInt
9139: oPop 2
9141: oAssign
9142: oEmit 30
9144: oGetLocal 1
9146: oPushResult
9147: oEmitInt
9148: oPop 1
9150: oJumpForward 9176
9152: Choice Lookup Table
          42   9130
          40   9130
          38   9130
          37   9126
          36   9126
          28   9122
          35   9118
          29   9118
          33   9118
          43   9114
          30   9114
9175: oEndChoice
9176: oTypeSPop
9177: oReturn
9178: oLocalSpace 1
9180: oInput 0
9182: oGetAddrLocal 1
9184: oPushResult
9185: oScopeFindRequire
9186: oAssign
9187: oGetAddrLocal 1
9189: oPushResult
9190: oCall 244
9192: oPop 1
9194: oGetLocal 1
9196: oPushResult
9197: oGetParam 1
9199: oPushResult
9200: oCall 9205
9202: oPop 2
9204: oReturn
9205: oLocalSpace 0
9207: oGetParam 2
9209: oPushResult
9210: oNodeType
9211: oPop 1
9213: oChoice 9276
9215: oGetParam 2
9217: oPushResult
9218: oGetParam 1
9220: oPushResult
9221: oCall 9422
9223: oPop 2
9225: oJumpForward 9289
9227: oGetParam 2
9229: oPushResult
9230: oSetResult 21
9232: oPushResult
9233: oNodeGet
9234: oPop 2
9236: oPushResult
9237: oTypeSPush
9238: oPop 1
9240: oInput 15
9242: oGetParam 1
9244: oPushResult
9245: oCall 9178
9247: oPop 1
9249: oInput 16
9251: oCall 9290
9253: oTypeSNodeType
9254: oChoice 9269
9256: oInputChoice 9264
9258: oEmit 26
9260: oCall 7799
9262: oJumpForward 9267
9264: Choice Lookup Table
          17   9258
9267: oJumpForward 9272
9269: Choice Lookup Table
          36   9256
9272: oCall 7604
9274: oJumpForward 9289
9276: Choice Lookup Table
          19   9227
          25   9215
          24   9215
          22   9215
          21   9215
9287: oError 4
9289: oReturn
9290: oLocalSpace 1
9292: oGetAddrLocal 1
9294: oPushResult
9295: oTypeSNodeType
9296: oAssign
9297: oTypeSPop
9298: oGetLocal 1
9300: oPushResult
9301: oTypeSNodeType
9302: oPushResult
9303: equal_node_type
9304: oPop 2
9306: oChoice 9418
9308: oTypeSNodeType
9309: oChoice 9397
9311: oGetLocal 1
9313: oChoice 9323
9315: oError 30
9317: oReturn
9318: oJumpForward 9334
9320: oReturn
9321: oJumpForward 9334
9323: Choice Lookup Table
          43   9320
          30   9320
          33   9315
          35   9315
          29   9315
9334: oJumpForward 9414
9336: oGetLocal 1
9338: oChoice 9348
9340: oReturn
9341: oJumpForward 9359
9343: oError 30
9345: oReturn
9346: oJumpForward 9359
9348: Choice Lookup Table
          43   9343
          30   9343
          33   9340
          35   9340
          29   9340
9359: oJumpForward 9414
9361: oGetLocal 1
9363: oChoice 9368
9365: oReturn
9366: oJumpForward 9371
9368: Choice Lookup Table
          37   9365
9371: oJumpForward 9414
9373: oGetLocal 1
9375: oChoice 9380
9377: oReturn
9378: oJumpForward 9383
9380: Choice Lookup Table
          36   9377
9383: oJumpForward 9414
9385: oGetLocal 1
9387: oChoice 9392
9389: oReturn
9390: oJumpForward 9395
9392: Choice Lookup Table
          41   9389
9395: oJumpForward 9414
9397: Choice Lookup Table
          42   9385
          37   9373
          36   9361
          33   9336
          35   9336
          29   9336
          43   9311
          30   9311
9414: oError 14
9416: oJumpForward 9421
9418: Choice Lookup Table
           0   9308
9421: oReturn
9422: oLocalSpace 0
9424: oGetParam 2
9426: oPushResult
9427: oNodeType
9428: oPop 1
9430: oChoice 9512
9432: oEmit 17
9434: oGetParam 2
9436: oPushResult
9437: oCall 14033
9439: oPop 1
9441: oJumpForward 9523
9443: oEmit 18
9445: oGetParam 2
9447: oPushResult
9448: oCall 14033
9450: oPop 1
9452: oJumpForward 9523
9454: oGetParam 2
9456: oPushResult
9457: oSetResult 34
9459: oPushResult
9460: oNodeGetBoolean
9461: oPop 2
9463: oChoice 9476
9465: oEmit 8
9467: oGetParam 2
9469: oPushResult
9470: oCall 14033
9472: oPop 1
9474: oJumpForward 9488
9476: Choice Lookup Table
           1   9465
9479: oEmit 19
9481: oGetParam 2
9483: oPushResult
9484: oCall 14033
9486: oPop 1
9488: oJumpForward 9523
9490: oGetParam 1
9492: oChoice 9505
9494: oEmit 17
9496: oGetParam 2
9498: oPushResult
9499: oCall 14033
9501: oPop 1
9503: oJumpForward 9510
9505: Choice Lookup Table
           0   9494
9508: oError 4
9510: oJumpForward 9523
9512: Choice Lookup Table
          25   9490
          24   9454
          22   9443
          21   9432
9521: oError 4
9523: oGetParam 2
9525: oPushResult
9526: oSetResult 21
9528: oPushResult
9529: oNodeGet
9530: oPop 2
9532: oPushResult
9533: oTypeSPush
9534: oPop 1
9536: oTypeSNodeType
9537: oChoice 9552
9539: oInputChoice 9547
9541: oEmit 26
9543: oCall 7799
9545: oJumpForward 9550
9547: Choice Lookup Table
          17   9541
9550: oJumpForward 9555
9552: Choice Lookup Table
          36   9539
9555: oCall 7604
9557: oReturn
9558: oLocalSpace 0
9560: oGetParam 1
9562: oPushResult
9563: oSetResult 1
9565: oPushResult
9566: oCall 9422
9568: oPop 2
9570: oCall 8616
9572: oGetParam 1
9574: oPushResult
9575: oCall 6793
9577: oPop 1
9579: oTypeSPop
9580: oEmit 33
9582: oEmit 27
9584: oReturn
9585: oLocalSpace 0
9587: oGetParam 1
9589: oPushResult
9590: oSetResult 1
9592: oPushResult
9593: oCall 9422
9595: oPop 2
9597: oCall 8616
9599: oGetParam 1
9601: oPushResult
9602: oCall 6793
9604: oPop 1
9606: oTypeSPop
9607: oEmit 34
9609: oEmit 27
9611: oReturn
9612: oLocalSpace 2
9614: oGetAddrLocal 1
9616: oPushResult
9617: oSetResult 0
9619: oAssign
9620: oGetAddrLocal 1
9622: oPushResult
9623: oCall 4927
9625: oPop 1
9627: oInput 43
9629: oCall 8736
9631: oInputChoice 9666
9633: oGetAddrLocal 2
9635: oPushResult
9636: oLabelNew
9637: oAssign
9638: oEmit 69
9640: oGetLocal 2
9642: oPushResult
9643: oEmitLabel
9644: oPop 1
9646: oEmit 78
9648: oGetLocal 1
9650: oPushResult
9651: oEmitLabel
9652: oPop 1
9654: oCall 8736
9656: oEmit 78
9658: oGetLocal 2
9660: oPushResult
9661: oEmitLabel
9662: oPop 1
9664: oJumpForward 9677
9666: Choice Lookup Table
          44   9633
9669: oEmit 78
9671: oGetLocal 1
9673: oPushResult
9674: oEmitLabel
9675: oPop 1
9677: oReturn
9678: oLocalSpace 4
9680: oInput 0
9682: oGetAddrLocal 1
9684: oPushResult
9685: oScopeFindRequire
9686: oAssign
9687: oGetLocal 1
9689: oPushResult
9690: oSetResult 1
9692: oPushResult
9693: oCall 9422
9695: oPop 2
9697: oCall 8616
9699: oInput 5
9701: oCall 4881
9703: oCall 8616
9705: oEmit 27
9707: oGetAddrLocal 2
9709: oPushResult
9710: oLabelNew
9711: oAssign
9712: oGetAddrLocal 3
9714: oPushResult
9715: oLabelNew
9716: oAssign
9717: oEmit 69
9719: oGetLocal 3
9721: oPushResult
9722: oEmitLabel
9723: oPop 1
9725: oGetAddrLocal 4
9727: oPushResult
9728: oLabelNew
9729: oAssign
9730: oEmit 78
9732: oGetLocal 4
9734: oPushResult
9735: oEmitLabel
9736: oPop 1
9738: oInputChoice 9818
9740: oGetLocal 1
9742: oPushResult
9743: oCall 9558
9745: oPop 1
9747: oEmit 78
9749: oGetLocal 3
9751: oPushResult
9752: oEmitLabel
9753: oPop 1
9755: oGetLocal 1
9757: oPushResult
9758: oCall 6793
9760: oPop 1
9762: oTypeSPop
9763: oCall 4881
9765: oCall 8616
9767: oEmit 52
9769: oEmit 70
9771: oGetLocal 2
9773: oPushResult
9774: oEmitLabel
9775: oPop 1
9777: oJumpForward 9824
9779: oGetLocal 1
9781: oPushResult
9782: oCall 9585
9784: oPop 1
9786: oEmit 78
9788: oGetLocal 3
9790: oPushResult
9791: oEmitLabel
9792: oPop 1
9794: oGetLocal 1
9796: oPushResult
9797: oCall 6793
9799: oPop 1
9801: oTypeSPop
9802: oCall 4881
9804: oCall 8616
9806: oEmit 53
9808: oEmit 70
9810: oGetLocal 2
9812: oPushResult
9813: oEmitLabel
9814: oPop 1
9816: oJumpForward 9824
9818: Choice Lookup Table
          47   9779
          46   9740
9823: oEndChoice
9824: oGetLocal 4
9826: oPushResult
9827: oGetLocal 2
9829: oPushResult
9830: oLoopPush
9831: oPop 2
9833: oInput 48
9835: oCall 8736
9837: oEmit 69
9839: oGetLocal 4
9841: oPushResult
9842: oEmitLabel
9843: oPop 1
9845: oEmit 78
9847: oGetLocal 2
9849: oPushResult
9850: oEmitLabel
9851: oPop 1
9853: oLoopPop
9854: oReturn
9855: oLocalSpace 3
9857: oGetAddrLocal 1
9859: oPushResult
9860: oLabelNew
9861: oAssign
9862: oEmit 78
9864: oGetLocal 1
9866: oPushResult
9867: oEmitLabel
9868: oPop 1
9870: oGetAddrLocal 2
9872: oPushResult
9873: oLabelNew
9874: oAssign
9875: oGetLocal 1
9877: oPushResult
9878: oGetLocal 2
9880: oPushResult
9881: oLoopPush
9882: oPop 2
9884: oCall 8736
9886: oInputChoice 9917
9888: oCall 8736
9890: oJumpForward 9923
9892: oGetAddrLocal 3
9894: oPushResult
9895: oCall 4927
9897: oPop 1
9899: oEmit 79
9901: oGetLocal 3
9903: oPushResult
9904: oEmitLabel
9905: oPop 1
9907: oGetLocal 1
9909: oPushResult
9910: oEmitLabel
9911: oPop 1
9913: oJumpForward 9925
9915: oJumpForward 9923
9917: Choice Lookup Table
          51   9892
           6   9888
9922: oEndChoice
9923: oJumpBack 9886
9925: oEmit 78
9927: oGetLocal 2
9929: oPushResult
9930: oEmitLabel
9931: oPop 1
9933: oLoopPop
9934: oReturn
9935: oLocalSpace 2
9937: oGetAddrLocal 1
9939: oPushResult
9940: oLabelNew
9941: oAssign
9942: oEmit 78
9944: oGetLocal 1
9946: oPushResult
9947: oEmitLabel
9948: oPop 1
9950: oGetAddrLocal 2
9952: oPushResult
9953: oCall 4927
9955: oPop 1
9957: oGetLocal 1
9959: oPushResult
9960: oGetLocal 2
9962: oPushResult
9963: oLoopPush
9964: oPop 2
9966: oInput 48
9968: oCall 8736
9970: oEmit 69
9972: oGetLocal 1
9974: oPushResult
9975: oEmitLabel
9976: oPop 1
9978: oEmit 78
9980: oGetLocal 2
9982: oPushResult
9983: oEmitLabel
9984: oPop 1
9986: oLoopPop
9987: oReturn
9988: oLocalSpace 0
9990: oLoopContinueLabel
9991: oPushResult
9992: oSetResult 0
9994: oPushResult
9995: equal_label
9996: oPop 2
9998: oChoice 10013
10000: oError 18
10002: oJumpForward 10019
10004: oEmit 69
10006: oLoopContinueLabel
10007: oPushResult
10008: oEmitLabel
10009: oPop 1
10011: oJumpForward 10019
10013: Choice Lookup Table
           0   10004
           1   10000
10018: oEndChoice
10019: oReturn
10020: oLocalSpace 0
10022: oLoopBreakLabel
10023: oPushResult
10024: oSetResult 0
10026: oPushResult
10027: equal_label
10028: oPop 2
10030: oChoice 10045
10032: oError 18
10034: oJumpForward 10051
10036: oEmit 69
10038: oLoopBreakLabel
10039: oPushResult
10040: oEmitLabel
10041: oPop 1
10043: oJumpForward 10051
10045: Choice Lookup Table
           0   10036
           1   10032
10050: oEndChoice
10051: oReturn
10052: oLocalSpace 8
10054: oGetAddrLocal 1
10056: oPushResult
10057: oCodeNew
10058: oAssign
10059: oGetAddrLocal 2
10061: oPushResult
10062: oLabelNew
10063: oAssign
10064: oGetAddrLocal 3
10066: oPushResult
10067: oLabelNew
10068: oAssign
10069: oGetAddrLocal 4
10071: oPushResult
10072: oGetLocal 3
10074: oAssign
10075: oGetAddrLocal 5
10077: oPushResult
10078: oSetResult 0
10080: oAssign
10081: oCall 4881
10083: oTypeSNodeType
10084: oChoice 10122
10086: oEmit 72
10088: oGetLocal 2
10090: oPushResult
10091: oEmitLabel
10092: oPop 1
10094: oJumpForward 10139
10096: oEmit 73
10098: oGetLocal 2
10100: oPushResult
10101: oEmitLabel
10102: oPop 1
10104: oJumpForward 10139
10106: oGetAddrLocal 5
10108: oPushResult
10109: oSetResult 1
10111: oAssign
10112: oEmit 74
10114: oGetLocal 2
10116: oPushResult
10117: oEmitLabel
10118: oPop 1
10120: oJumpForward 10139
10122: Choice Lookup Table
          41   10106
          42   10106
          43   10096
          30   10096
          35   10086
          29   10086
          33   10086
10137: oError 17
10139: oInput 41
10141: oInputChoice 10188
10143: oGetAddrLocal 4
10145: oPushResult
10146: oLabelNew
10147: oAssign
10148: oEmit 78
10150: oGetLocal 4
10152: oPushResult
10153: oEmitLabel
10154: oPop 1
10156: oInputChoice 10162
10158: oJumpForward 10180
10160: oJumpForward 10178
10162: Choice Lookup Table
          37   10158
10165: oCall 8736
10167: oInputChoice 10171
10169: oJumpForward 10178
10171: Choice Lookup Table
           6   10169
10174: oInput 37
10176: oJumpForward 10180
10178: oJumpBack 10156
10180: oJumpForward 10354
10182: oJumpForward 10352
10184: oJumpForward 10354
10186: oJumpForward 10352
10188: Choice Lookup Table
          37   10184
          44   10143
          55   10143
10195: oGetAddrLocal 6
10197: oPushResult
10198: oLabelNew
10199: oAssign
10200: oGetLocal 1
10202: oPushResult
10203: oCodePush
10204: oPop 1
10206: oCall 3533
10208: oCall 4345
10210: oGetLocal 5
10212: oChoice 10232
10214: oGetAddrLocal 7
10216: oPushResult
10217: oValueTopString
10218: oPushResult
10219: oStringAllocShortStringLit
10220: oPop 1
10222: oAssign
10223: oJumpForward 10238
10225: oGetAddrLocal 7
10227: oPushResult
10228: oValueTop
10229: oAssign
10230: oJumpForward 10238
10232: Choice Lookup Table
           0   10225
           1   10214
10237: oEndChoice
10238: oValuePop
10239: oInputChoice 10296
10241: oCall 3533
10243: oCall 4345
10245: oGetLocal 5
10247: oChoice 10267
10249: oGetAddrLocal 8
10251: oPushResult
10252: oValueTopString
10253: oPushResult
10254: oStringAllocShortStringLit
10255: oPop 1
10257: oAssign
10258: oJumpForward 10273
10260: oGetAddrLocal 8
10262: oPushResult
10263: oValueTop
10264: oAssign
10265: oJumpForward 10273
10267: Choice Lookup Table
           0   10260
           1   10249
10272: oEndChoice
10273: oValuePop
10274: oEmit 76
10276: oGetLocal 7
10278: oPushResult
10279: oEmitInt
10280: oPop 1
10282: oGetLocal 8
10284: oPushResult
10285: oEmitInt
10286: oPop 1
10288: oGetLocal 6
10290: oPushResult
10291: oEmitLabel
10292: oPop 1
10294: oJumpForward 10313
10296: Choice Lookup Table
          22   10241
10299: oEmit 75
10301: oGetLocal 7
10303: oPushResult
10304: oEmitInt
10305: oPop 1
10307: oGetLocal 6
10309: oPushResult
10310: oEmitLabel
10311: oPop 1
10313: oInputChoice 10317
10315: oJumpForward 10322
10317: Choice Lookup Table
          14   10315
10320: oJumpForward 10324
10322: oJumpBack 10206
10324: oCodePop
10325: oInput 13
10327: oEmit 78
10329: oGetLocal 6
10331: oPushResult
10332: oEmitLabel
10333: oPop 1
10335: oCall 8736
10337: oEmit 69
10339: oGetLocal 3
10341: oPushResult
10342: oEmitLabel
10343: oPop 1
10345: oInputChoice 10349
10347: oJumpForward 10352
10349: Choice Lookup Table
           6   10347
10352: oJumpBack 10141
10354: oEmit 78
10356: oGetLocal 2
10358: oPushResult
10359: oEmitLabel
10360: oPop 1
10362: oGetLocal 1
10364: oPushResult
10365: oEmitCode
10366: oPop 1
10368: oEmit 77
10370: oGetLocal 4
10372: oPushResult
10373: oEmitLabel
10374: oPop 1
10376: oEmit 78
10378: oGetLocal 3
10380: oPushResult
10381: oEmitLabel
10382: oPop 1
10384: oTypeSPop
10385: oReturn
10386: oLocalSpace 1
10388: oInputChoice 10395
10390: oJumpForward 10401
10392: oChangeIntLitToLabelIdent
10393: oJumpForward 10401
10395: Choice Lookup Table
           1   10392
           0   10390
10400: oEndChoice
10401: oGetAddrLocal 1
10403: oPushResult
10404: oScopeCurrent
10405: oPushResult
10406: oScopeFindRequireInScope
10407: oPop 1
10409: oAssign
10410: oGetLocal 1
10412: oPushResult
10413: oSetResult 28
10415: oPushResult
10416: oSetResult 1
10418: oPushResult
10419: oNodeSetBoolean
10420: oPop 3
10422: oEmit 69
10424: oGetLocal 1
10426: oPushResult
10427: oSetResult 22
10429: oPushResult
10430: oNodeGetLabel
10431: oPop 2
10433: oPushResult
10434: oEmitLabel
10435: oPop 1
10437: oReturn
10438: oLocalSpace 0
10440: oCall 8736
10442: oInputChoice 10452
10444: oCall 8736
10446: oJumpForward 10458
10448: oJumpForward 10460
10450: oJumpForward 10458
10452: Choice Lookup Table
          37   10448
           6   10444
10457: oEndChoice
10458: oJumpBack 10442
10460: oReturn
10461: oLocalSpace 0
10463: oCall 10468
10465: oEmit 89
10467: oReturn
10468: oLocalSpace 0
10470: oInputChoice 10594
10472: oCall 4881
10474: oTypeSNodeType
10475: oChoice 10550
10477: oEmit 81
10479: oJumpForward 10575
10481: oEmit 82
10483: oJumpForward 10575
10485: oEmit 31
10487: oEmit 81
10489: oJumpForward 10575
10491: oEmit 83
10493: oJumpForward 10575
10495: oEmit 88
10497: oJumpForward 10575
10499: oEmit 84
10501: oJumpForward 10575
10503: oError 16
10505: oJumpForward 10575
10507: oEmit 17
10509: oTypeSTop
10510: oPushResult
10511: oSetResult 43
10513: oPushResult
10514: oNodeGetInt
10515: oPop 2
10517: oPushResult
10518: oEmitInt
10519: oPop 1
10521: oEmit 87
10523: oJumpForward 10575
10525: oTypeSTop
10526: oPushResult
10527: oGetGlobal 10
10529: oPushResult
10530: equal_node
10531: oPop 2
10533: oChoice 10539
10535: oEmit 85
10537: oJumpForward 10544
10539: Choice Lookup Table
           1   10535
10542: oEmit 86
10544: oJumpForward 10575
10546: oEmit 86
10548: oJumpForward 10575
10550: Choice Lookup Table
          37   10546
          36   10525
          43   10507
          28   10503
          41   10499
          42   10499
          32   10495
          35   10491
          29   10485
          33   10481
          30   10477
10573: oError 17
10575: oTypeSPop
10576: oInputChoice 10584
10578: oJumpForward 10592
10580: oJumpForward 10590
10582: oJumpForward 10590
10584: Choice Lookup Table
          14   10582
          16   10578
10589: oEndChoice
10590: oJumpBack 10472
10592: oJumpForward 10597
10594: Choice Lookup Table
          15   10472
10597: oReturn
10598: oLocalSpace 0
10600: oCall 10605
10602: oEmit 93
10604: oReturn
10605: oLocalSpace 1
10607: oInputChoice 10684
10609: oSetResult 1
10611: oPushResult
10612: oCall 9178
10614: oPop 1
10616: oTypeSNodeType
10617: oChoice 10656
10619: oEmit 90
10621: oJumpForward 10665
10623: oEmit 91
10625: oJumpForward 10665
10627: oGetAddrLocal 1
10629: oPushResult
10630: oTypeSTop
10631: oPushResult
10632: oSetResult 17
10634: oPushResult
10635: oNodeGetInt
10636: oPop 2
10638: oPushResult
10639: oSetResult 1
10641: oPushResult
10642: subtract
10643: oPop 2
10645: oAssign
10646: oEmit 92
10648: oGetLocal 1
10650: oPushResult
10651: oEmitInt
10652: oPop 1
10654: oJumpForward 10665
10656: Choice Lookup Table
          42   10627
          35   10623
          30   10619
10663: oError 17
10665: oTypeSPop
10666: oInputChoice 10674
10668: oJumpForward 10682
10670: oJumpForward 10680
10672: oJumpForward 10680
10674: Choice Lookup Table
          14   10672
          16   10668
10679: oEndChoice
10680: oJumpBack 10609
10682: oJumpForward 10687
10684: Choice Lookup Table
          15   10609
10687: oReturn
10688: oLocalSpace 1
10690: oGetAddrLocal 1
10692: oPushResult
10693: oGetGlobal 16
10695: oPushResult
10696: oScopeAllocType
10697: oPop 1
10699: oAssign
10700: oTypeSNodeType
10701: oChoice 10769
10703: oEmit 18
10705: oGetLocal 1
10707: oPushResult
10708: oEmitInt
10709: oPop 1
10711: oEmit 23
10713: oEmit 30
10715: oGetGlobal 16
10717: oPushResult
10718: oSetResult 17
10720: oPushResult
10721: oNodeGetInt
10722: oPop 2
10724: oPushResult
10725: oEmitInt
10726: oPop 1
10728: oJumpForward 10778
10730: oEmit 18
10732: oGetLocal 1
10734: oPushResult
10735: oEmitInt
10736: oPop 1
10738: oEmit 15
10740: oSetResult 1
10742: oPushResult
10743: oEmitInt
10744: oPop 1
10746: oEmit 28
10748: oEmit 18
10750: oGetLocal 1
10752: oPushResult
10753: oSetResult 1
10755: oPushResult
10756: add
10757: oPop 2
10759: oPushResult
10760: oEmitInt
10761: oPop 1
10763: oEmit 23
10765: oEmit 28
10767: oJumpForward 10778
10769: Choice Lookup Table
          35   10730
          41   10703
          42   10703
10776: oError 14
10778: oTypeSPop
10779: oEmit 18
10781: oGetLocal 1
10783: oPushResult
10784: oEmitInt
10785: oPop 1
10787: oGetGlobal 16
10789: oPushResult
10790: oTypeSPush
10791: oPop 1
10793: oGetLocal 1
10795: oReturn
10796: oReturn
10797: oLocalSpace 0
10799: oEmit 62
10801: oSetResult 16
10803: oPushResult
10804: oEmitInt
10805: oPop 1
10807: oEmit 20
10809: oSetResult 8
10811: oPushResult
10812: oEmitInt
10813: oPop 1
10815: oEmit 23
10817: oEmit 29
10819: oEmit 20
10821: oSetResult 0
10823: oPushResult
10824: oEmitInt
10825: oPop 1
10827: oEmit 23
10829: oEmit 29
10831: oEmit 65
10833: oGetGlobal 22
10835: oPushResult
10836: oCall 14033
10838: oPop 1
10840: oEmit 64
10842: oSetResult 16
10844: oPushResult
10845: oEmitInt
10846: oPop 1
10848: oTypeSPop
10849: oTypeSPop
10850: oReturn
10851: oLocalSpace 0
10853: oEmit 62
10855: oSetResult 12
10857: oPushResult
10858: oEmitInt
10859: oPop 1
10861: oEmit 20
10863: oSetResult 8
10865: oPushResult
10866: oEmitInt
10867: oPop 1
10869: oEmit 23
10871: oEmit 28
10873: oEmit 20
10875: oSetResult 0
10877: oPushResult
10878: oEmitInt
10879: oPop 1
10881: oEmit 23
10883: oEmit 29
10885: oEmit 65
10887: oGetGlobal 23
10889: oPushResult
10890: oCall 14033
10892: oPop 1
10894: oEmit 64
10896: oSetResult 12
10898: oPushResult
10899: oEmitInt
10900: oPop 1
10902: oTypeSPop
10903: oTypeSPop
10904: oReturn
10905: oLocalSpace 1
10907: oEmit 63
10909: oSetResult 24
10911: oPushResult
10912: oEmitInt
10913: oPop 1
10915: oEmit 20
10917: oSetResult 8
10919: oPushResult
10920: oEmitInt
10921: oPop 1
10923: oEmit 23
10925: oEmit 29
10927: oEmit 20
10929: oSetResult 0
10931: oPushResult
10932: oEmitInt
10933: oPop 1
10935: oEmit 23
10937: oEmit 29
10939: oGetAddrLocal 1
10941: oPushResult
10942: oGetGlobal 6
10944: oPushResult
10945: oScopeAllocType
10946: oPop 1
10948: oAssign
10949: oEmit 20
10951: oSetResult 16
10953: oPushResult
10954: oEmitInt
10955: oPop 1
10957: oEmit 18
10959: oGetLocal 1
10961: oPushResult
10962: oEmitInt
10963: oPop 1
10965: oEmit 29
10967: oEmit 66
10969: oGetGlobal 24
10971: oPushResult
10972: oCall 14033
10974: oPop 1
10976: oEmit 3
10978: oGetLocal 1
10980: oPushResult
10981: oEmitInt
10982: oPop 1
10984: oEmit 64
10986: oSetResult 24
10988: oPushResult
10989: oEmitInt
10990: oPop 1
10992: oTypeSPop
10993: oGetGlobal 6
10995: oPushResult
10996: oTypeSPush
10997: oPop 1
10999: oReturn
11000: oLocalSpace 10
11002: oGetParam 1
11004: oPushResult
11005: oSetResult 28
11007: oPushResult
11008: oSetResult 1
11010: oPushResult
11011: oNodeSetBoolean
11012: oPop 3
11014: oGetAddrLocal 1
11016: oPushResult
11017: oGetParam 1
11019: oPushResult
11020: oSetResult 27
11022: oPushResult
11023: oNodeGetBoolean
11024: oPop 2
11026: oAssign
11027: oGetAddrLocal 4
11029: oPushResult
11030: oGetParam 1
11032: oPushResult
11033: oNodeType
11034: oPop 1
11036: oPushResult
11037: oSetResult 13
11039: oPushResult
11040: equal_node_type
11041: oPop 2
11043: oAssign
11044: oGetLocal 4
11046: oChoice 11073
11048: oGetAddrLocal 2
11050: oPushResult
11051: oGetParam 1
11053: oPushResult
11054: oSetResult 21
11056: oPushResult
11057: oNodeGet
11058: oPop 2
11060: oAssign
11061: oGetAddrLocal 3
11063: oPushResult
11064: oGetLocal 2
11066: oPushResult
11067: oScopeAllocType
11068: oPop 1
11070: oAssign
11071: oJumpForward 11076
11073: Choice Lookup Table
           1   11048
11076: oGetAddrLocal 5
11078: oPushResult
11079: oGetParam 1
11081: oPushResult
11082: oSetResult 23
11084: oPushResult
11085: oNodeGet
11086: oPop 2
11088: oAssign
11089: oGetAddrLocal 6
11091: oPushResult
11092: oGetLocal 5
11094: oPushResult
11095: oSetResult 17
11097: oPushResult
11098: oNodeGetInt
11099: oPop 2
11101: oAssign
11102: oGetLocal 1
11104: oChoice 11126
11106: oEmit 63
11108: oGetLocal 6
11110: oPushResult
11111: oEmitInt
11112: oPop 1
11114: oJumpForward 11132
11116: oEmit 62
11118: oGetLocal 6
11120: oPushResult
11121: oEmitInt
11122: oPop 1
11124: oJumpForward 11132
11126: Choice Lookup Table
           0   11116
           1   11106
11131: oEndChoice
11132: oGetParam 1
11134: oPushResult
11135: oCall 13967
11137: oPop 1
11139: oPushResult
11140: oSetResult 0
11142: oPushResult
11143: greater
11144: oPop 2
11146: oChoice 11179
11148: oEmit 20
11150: oSetResult 0
11152: oPushResult
11153: oEmitInt
11154: oPop 1
11156: oEmit 21
11158: oGetParam 1
11160: oPushResult
11161: oCall 13987
11163: oPop 1
11165: oPushResult
11166: oEmitInt
11167: oPop 1
11169: oSetResult 0
11171: oPushResult
11172: oEmitInt
11173: oPop 1
11175: oEmit 29
11177: oJumpForward 11182
11179: Choice Lookup Table
           1   11148
11182: oGetAddrLocal 7
11184: oPushResult
11185: oGetLocal 5
11187: oPushResult
11188: oSetResult 15
11190: oPushResult
11191: oNodeGetIter
11192: oPop 2
11194: oAssign
11195: oGetAddrLocal 8
11197: oPushResult
11198: oGetLocal 7
11200: oPushResult
11201: oNodeIterValue
11202: oPop 1
11204: oAssign
11205: oInputChoice 11402
11207: oGetLocal 8
11209: oPushResult
11210: oNodeNull
11211: oPop 1
11213: oChoice 11219
11215: oJumpForward 11398
11217: oJumpForward 11222
11219: Choice Lookup Table
           1   11215
11222: oGetAddrLocal 9
11224: oPushResult
11225: oGetLocal 8
11227: oPushResult
11228: oSetResult 22
11230: oPushResult
11231: oNodeGetInt
11232: oPop 2
11234: oAssign
11235: oEmit 20
11237: oGetLocal 9
11239: oPushResult
11240: oEmitInt
11241: oPop 1
11243: oGetLocal 8
11245: oPushResult
11246: oSetResult 21
11248: oPushResult
11249: oNodeGet
11250: oPop 2
11252: oPushResult
11253: oTypeSPush
11254: oPop 1
11256: oGetLocal 8
11258: oPushResult
11259: oSetResult 34
11261: oPushResult
11262: oNodeGetBoolean
11263: oPop 2
11265: oChoice 11351
11267: oSetResult 1
11269: oPushResult
11270: oCall 9178
11272: oPop 1
11274: oCall 8558
11276: oEmit 29
11278: oJumpForward 11357
11280: oCall 4881
11282: oCall 8221
11284: oTypeSNodeType
11285: oChoice 11325
11287: oEmit 27
11289: oJumpForward 11349
11291: oEmit 28
11293: oJumpForward 11349
11295: oError 16
11297: oJumpForward 11349
11299: oEmit 29
11301: oJumpForward 11349
11303: oGetAddrLocal 10
11305: oPushResult
11306: oTypeSTop
11307: oPushResult
11308: oSetResult 17
11310: oPushResult
11311: oNodeGetInt
11312: oPop 2
11314: oAssign
11315: oEmit 30
11317: oGetLocal 10
11319: oPushResult
11320: oEmitInt
11321: oPop 1
11323: oJumpForward 11349
11325: Choice Lookup Table
          42   11303
          40   11303
          38   11303
          37   11299
          36   11299
          28   11295
          35   11291
          29   11291
          33   11291
          43   11287
          30   11287
11348: oEndChoice
11349: oJumpForward 11357
11351: Choice Lookup Table
           0   11280
           1   11267
11356: oEndChoice
11357: oTypeSPop
11358: oGetAddrLocal 7
11360: oPushResult
11361: oNodeIterNext
11362: oPop 1
11364: oGetAddrLocal 8
11366: oPushResult
11367: oGetLocal 7
11369: oPushResult
11370: oNodeIterValue
11371: oPop 1
11373: oAssign
11374: oGetLocal 8
11376: oPushResult
11377: oNodeNull
11378: oPop 1
11380: oChoice 11388
11382: oJumpForward 11398
11384: oJumpForward 11394
11386: oJumpForward 11394
11388: Choice Lookup Table
           0   11386
           1   11382
11393: oEndChoice
11394: oInput 14
11396: oJumpBack 11207
11398: oInput 16
11400: oJumpForward 11405
11402: Choice Lookup Table
          15   11207
11405: oGetLocal 8
11407: oPushResult
11408: oNodeNull
11409: oPop 1
11411: oChoice 11417
11413: oError 15
11415: oJumpForward 11420
11417: Choice Lookup Table
           0   11413
11420: oGetLocal 4
11422: oChoice 11451
11424: oEmit 20
11426: oGetParam 1
11428: oPushResult
11429: oSetResult 31
11431: oPushResult
11432: oNodeGetInt
11433: oPop 2
11435: oPushResult
11436: oEmitInt
11437: oPop 1
11439: oEmit 18
11441: oGetLocal 3
11443: oPushResult
11444: oEmitInt
11445: oPop 1
11447: oEmit 29
11449: oJumpForward 11454
11451: Choice Lookup Table
           1   11424
11454: oGetLocal 1
11456: oChoice 11480
11458: oEmit 66
11460: oGetParam 1
11462: oPushResult
11463: oCall 14033
11465: oPop 1
11467: oJumpForward 11486
11469: oEmit 65
11471: oGetParam 1
11473: oPushResult
11474: oCall 14033
11476: oPop 1
11478: oJumpForward 11486
11480: Choice Lookup Table
           0   11469
           1   11458
11485: oEndChoice
11486: oGetLocal 4
11488: oChoice 11569
11490: oGetLocal 2
11492: oPushResult
11493: oTypeSPush
11494: oPop 1
11496: oTypeSNodeType
11497: oChoice 11543
11499: oEmit 3
11501: oGetLocal 3
11503: oPushResult
11504: oEmitInt
11505: oPop 1
11507: oJumpForward 11567
11509: oEmit 4
11511: oGetLocal 3
11513: oPushResult
11514: oEmitInt
11515: oPop 1
11517: oJumpForward 11567
11519: oError 16
11521: oJumpForward 11567
11523: oEmit 5
11525: oGetLocal 3
11527: oPushResult
11528: oEmitInt
11529: oPop 1
11531: oJumpForward 11567
11533: oEmit 18
11535: oGetLocal 3
11537: oPushResult
11538: oEmitInt
11539: oPop 1
11541: oJumpForward 11567
11543: Choice Lookup Table
          42   11533
          40   11533
          38   11533
          37   11523
          36   11523
          28   11519
          35   11509
          29   11509
          33   11509
          43   11499
          30   11499
11566: oEndChoice
11567: oJumpForward 11572
11569: Choice Lookup Table
           1   11490
11572: oEmit 64
11574: oGetLocal 6
11576: oPushResult
11577: oEmitInt
11578: oPop 1
11580: oReturn
11581: oLocalSpace 2
11583: oGetAddrLocal 2
11585: oPushResult
11586: oGetParam 1
11588: oPushResult
11589: oSetResult 26
11591: oPushResult
11592: oNodeGetString
11593: oPop 2
11595: oAssign
11596: oGetLocal 2
11598: oPushResult
11599: oSetResult 0
11601: oPushResult
11602: equal_string
11603: oPop 2
11605: oChoice 11642
11607: oGetAddrLocal 1
11609: oPushResult
11610: oGetParam 1
11612: oPushResult
11613: oSetResult 4
11615: oPushResult
11616: oNodeGetInt
11617: oPop 2
11619: oPushResult
11620: ID_STRING
11621: oPop 1
11623: oPushResult
11624: oStringAllocLit
11625: oPop 1
11627: oAssign
11628: oJumpForward 11648
11630: oGetAddrLocal 1
11632: oPushResult
11633: oGetLocal 2
11635: oPushResult
11636: oStringAllocLit
11637: oPop 1
11639: oAssign
11640: oJumpForward 11648
11642: Choice Lookup Table
           0   11630
           1   11607
11647: oEndChoice
11648: oEmit 80
11650: oGetParam 1
11652: oPushResult
11653: oCall 14033
11655: oPop 1
11657: oGetLocal 1
11659: oPushResult
11660: oEmitInt
11661: oPop 1
11663: oReturn
11664: oLocalSpace 2
11666: oGetParam 1
11668: oPushResult
11669: oGetGlobal 17
11671: oPushResult
11672: oNodeEqual
11673: oPop 2
11675: oChoice 11715
11677: oInput 15
11679: oCall 4881
11681: oTypeSNodeType
11682: oChoice 11690
11684: oJumpForward 11703
11686: oEmit 31
11688: oJumpForward 11703
11690: Choice Lookup Table
          35   11686
          29   11686
          33   11686
          43   11684
          30   11684
11701: oError 14
11703: oTypeSPop
11704: oGetGlobal 6
11706: oPushResult
11707: oTypeSPush
11708: oPop 1
11710: oInput 16
11712: oReturn
11713: oJumpForward 11718
11715: Choice Lookup Table
           1   11677
11718: oGetParam 1
11720: oPushResult
11721: oGetGlobal 18
11723: oPushResult
11724: oNodeEqual
11725: oPop 2
11727: oChoice 11761
11729: oInput 15
11731: oCall 4881
11733: oTypeSNodeType
11734: oChoice 11742
11736: oEmit 32
11738: oJumpForward 11749
11740: oJumpForward 11749
11742: Choice Lookup Table
          29   11740
          30   11736
11747: oError 14
11749: oTypeSPop
11750: oGetGlobal 9
11752: oPushResult
11753: oTypeSPush
11754: oPop 1
11756: oInput 16
11758: oReturn
11759: oJumpForward 11764
11761: Choice Lookup Table
           1   11729
11764: oGetParam 1
11766: oPushResult
11767: oGetGlobal 19
11769: oPushResult
11770: oNodeEqual
11771: oPop 2
11773: oChoice 11813
11775: oInput 15
11777: oCall 4881
11779: oTypeSNodeType
11780: oChoice 11801
11782: oTypeSTop
11783: oPushResult
11784: oSetResult 44
11786: oPushResult
11787: oNodeGetBoolean
11788: oPop 2
11790: oChoice 11796
11792: oError 28
11794: oJumpForward 11799
11796: Choice Lookup Table
           1   11792
11799: oJumpForward 11806
11801: Choice Lookup Table
          43   11782
11804: oError 14
11806: oEmit 34
11808: oInput 16
11810: oReturn
11811: oJumpForward 11816
11813: Choice Lookup Table
           1   11775
11816: oGetParam 1
11818: oPushResult
11819: oGetGlobal 20
11821: oPushResult
11822: oNodeEqual
11823: oPop 2
11825: oChoice 11865
11827: oInput 15
11829: oCall 4881
11831: oTypeSNodeType
11832: oChoice 11853
11834: oTypeSTop
11835: oPushResult
11836: oSetResult 44
11838: oPushResult
11839: oNodeGetBoolean
11840: oPop 2
11842: oChoice 11848
11844: oError 28
11846: oJumpForward 11851
11848: Choice Lookup Table
           1   11844
11851: oJumpForward 11858
11853: Choice Lookup Table
          43   11834
11856: oError 14
11858: oEmit 33
11860: oInput 16
11862: oReturn
11863: oJumpForward 11868
11865: Choice Lookup Table
           1   11827
11868: oGetParam 1
11870: oPushResult
11871: oGetGlobal 21
11873: oPushResult
11874: oNodeEqual
11875: oPop 2
11877: oChoice 11933
11879: oInput 15
11881: oGetAddrLocal 1
11883: oPushResult
11884: oCodeNew
11885: oAssign
11886: oGetLocal 1
11888: oPushResult
11889: oCodePush
11890: oPop 1
11892: oCall 4904
11894: oCodePop
11895: oGetLocal 1
11897: oPushResult
11898: oCodeDiscard
11899: oPop 1
11901: oGetAddrLocal 2
11903: oPushResult
11904: oTypeSTop
11905: oAssign
11906: oTypeSPop
11907: oEmit 15
11909: oGetLocal 2
11911: oPushResult
11912: oSetResult 17
11914: oPushResult
11915: oNodeGetInt
11916: oPop 2
11918: oPushResult
11919: oEmitInt
11920: oPop 1
11922: oGetGlobal 6
11924: oPushResult
11925: oTypeSPush
11926: oPop 1
11928: oInput 16
11930: oReturn
11931: oJumpForward 11936
11933: Choice Lookup Table
           1   11879
11936: oError 16
11938: oReturn
11939: oLocalSpace 1
11941: oGetAddrLocal 1
11943: oPushResult
11944: oGetParam 2
11946: oPushResult
11947: oNodeNew
11948: oPop 1
11950: oAssign
11951: oGetLocal 1
11953: oPushResult
11954: oSetResult 17
11956: oPushResult
11957: oGetParam 1
11959: oPushResult
11960: oNodeSetInt
11961: oPop 3
11963: oGetLocal 1
11965: oPushResult
11966: oTypeAdd
11967: oPop 1
11969: oGetLocal 1
11971: oReturn
11972: oReturn
11973: oLocalSpace 12
11975: oInputChoice 12458
11977: oGetAddrLocal 1
11979: oPushResult
11980: oScopeFindRequire
11981: oAssign
11982: oGetAddrLocal 1
11984: oPushResult
11985: oCall 244
11987: oPop 1
11989: oGetLocal 1
11991: oPushResult
11992: oNodeType
11993: oPop 1
11995: oChoice 12012
11997: oGetParam 1
11999: oPushResult
12000: oGetLocal 1
12002: oPushResult
12003: oSetResult 21
12005: oPushResult
12006: oNodeGet
12007: oPop 2
12009: oAssign
12010: oJumpForward 12023
12012: Choice Lookup Table
          19   11997
12015: oError 2
12017: oGetParam 1
12019: oPushResult
12020: oGetGlobal 6
12022: oAssign
12023: oJumpForward 12481
12025: oInput 17
12027: oGetAddrLocal 2
12029: oPushResult
12030: oNodeVecNew
12031: oAssign
12032: oGetAddrLocal 3
12034: oPushResult
12035: oSetResult 39
12037: oPushResult
12038: oNodeNew
12039: oPop 1
12041: oAssign
12042: oCall 3533
12044: oGetLocal 3
12046: oPushResult
12047: oSetResult 39
12049: oPushResult
12050: oValueTop
12051: oPushResult
12052: oNodeSetInt
12053: oPop 3
12055: oValuePop
12056: oInput 22
12058: oCall 3533
12060: oGetLocal 3
12062: oPushResult
12063: oSetResult 40
12065: oPushResult
12066: oValueTop
12067: oPushResult
12068: oNodeSetInt
12069: oPop 3
12071: oValuePop
12072: oCall 4248
12074: oGetLocal 3
12076: oPushResult
12077: oSetResult 37
12079: oPushResult
12080: oTypeSTop
12081: oPushResult
12082: oNodeSet
12083: oPop 3
12085: oGetLocal 3
12087: oPushResult
12088: oSetResult 17
12090: oPushResult
12091: oTypeSTop
12092: oPushResult
12093: oSetResult 17
12095: oPushResult
12096: oNodeGetInt
12097: oPop 2
12099: oPushResult
12100: oNodeSetInt
12101: oPop 3
12103: oTypeSPop
12104: oGetLocal 3
12106: oPushResult
12107: oTypeAdd
12108: oPop 1
12110: oGetAddrLocal 4
12112: oPushResult
12113: oSetResult 38
12115: oPushResult
12116: oNodeNew
12117: oPop 1
12119: oAssign
12120: oGetLocal 4
12122: oPushResult
12123: oSetResult 38
12125: oPushResult
12126: oGetLocal 3
12128: oPushResult
12129: oNodeSet
12130: oPop 3
12132: oGetLocal 2
12134: oPushResult
12135: oGetLocal 4
12137: oPushResult
12138: oNodeVecAppend
12139: oPop 2
12141: oInputChoice 12149
12143: oJumpForward 12157
12145: oJumpForward 12155
12147: oJumpForward 12155
12149: Choice Lookup Table
          14   12147
          18   12143
12154: oEndChoice
12155: oJumpBack 12032
12157: oInput 41
12159: oGetAddrLocal 5
12161: oPushResult
12162: oCall 11973
12164: oPop 1
12166: oGetAddrLocal 6
12168: oPushResult
12169: oGetLocal 2
12171: oPushResult
12172: oNodeVecSize
12173: oPop 1
12175: oAssign
12176: oGetAddrLocal 6
12178: oPushResult
12179: dec
12180: oPop 1
12182: oGetAddrLocal 7
12184: oPushResult
12185: oGetLocal 2
12187: oPushResult
12188: oGetLocal 6
12190: oPushResult
12191: oNodeVecElement
12192: oPop 2
12194: oAssign
12195: oGetLocal 7
12197: oPushResult
12198: oSetResult 37
12200: oPushResult
12201: oGetLocal 5
12203: oPushResult
12204: oNodeSet
12205: oPop 3
12207: oGetAddrLocal 8
12209: oPushResult
12210: oGetLocal 7
12212: oPushResult
12213: oSetResult 38
12215: oPushResult
12216: oNodeGet
12217: oPop 2
12219: oAssign
12220: oGetAddrLocal 9
12222: oPushResult
12223: oGetLocal 8
12225: oPushResult
12226: oSetResult 40
12228: oPushResult
12229: oNodeGetInt
12230: oPop 2
12232: oPushResult
12233: oGetLocal 8
12235: oPushResult
12236: oSetResult 39
12238: oPushResult
12239: oNodeGetInt
12240: oPop 2
12242: oPushResult
12243: subtract
12244: oPop 2
12246: oAssign
12247: oGetAddrLocal 9
12249: oPushResult
12250: inc
12251: oPop 1
12253: oGetLocal 7
12255: oPushResult
12256: oSetResult 17
12258: oPushResult
12259: oGetLocal 9
12261: oPushResult
12262: oGetLocal 5
12264: oPushResult
12265: oSetResult 17
12267: oPushResult
12268: oNodeGetInt
12269: oPop 2
12271: oPushResult
12272: multiply
12273: oPop 2
12275: oPushResult
12276: oNodeSetInt
12277: oPop 3
12279: oGetLocal 7
12281: oPushResult
12282: oTypeAdd
12283: oPop 1
12285: oGetAddrLocal 5
12287: oPushResult
12288: oGetLocal 7
12290: oAssign
12291: oGetLocal 6
12293: oPushResult
12294: equal_zero
12295: oPop 1
12297: oChoice 12303
12299: oJumpForward 12308
12301: oJumpForward 12306
12303: Choice Lookup Table
           1   12299
12306: oJumpBack 12176
12308: oGetParam 1
12310: oPushResult
12311: oGetLocal 2
12313: oPushResult
12314: oSetResult 0
12316: oPushResult
12317: oNodeVecElement
12318: oPop 2
12320: oAssign
12321: oGetLocal 2
12323: oPushResult
12324: oNodeVecDelete
12325: oPop 1
12327: oJumpForward 12481
12329: oGetAddrLocal 10
12331: oPushResult
12332: oCall 11973
12334: oPop 1
12336: oGetParam 1
12338: oPushResult
12339: oGetLocal 10
12341: oPushResult
12342: oCall 13052
12344: oPop 1
12346: oAssign
12347: oJumpForward 12481
12349: oGetParam 1
12351: oPushResult
12352: oSetResult 40
12354: oPushResult
12355: oNodeNew
12356: oPop 1
12358: oAssign
12359: oSetResult -1
12361: oPushResult
12362: oSetResult 2
12364: oPushResult
12365: oScopeBegin
12366: oPop 2
12368: oSetResult 23
12370: oPushResult
12371: oCall 3234
12373: oPop 1
12375: oGetAddrLocal 11
12377: oPushResult
12378: oScopeCurrent
12379: oPushResult
12380: oSetResult 17
12382: oPushResult
12383: oNodeGetInt
12384: oPop 2
12386: oAssign
12387: oGetLocal 11
12389: oPushResult
12390: equal_zero
12391: oPop 1
12393: oChoice 12399
12395: oError 19
12397: oJumpForward 12402
12399: Choice Lookup Table
           1   12395
12402: oInput 37
12404: oGetFromParam 1
12406: oPushResult
12407: oSetResult 41
12409: oPushResult
12410: oScopeCurrent
12411: oPushResult
12412: oNodeSet
12413: oPop 3
12415: oGetFromParam 1
12417: oPushResult
12418: oSetResult 17
12420: oPushResult
12421: oGetLocal 11
12423: oPushResult
12424: oNodeSetInt
12425: oPop 3
12427: oScopeEnd
12428: oGetFromParam 1
12430: oPushResult
12431: oTypeAdd
12432: oPop 1
12434: oJumpForward 12481
12436: oGetParam 1
12438: oPushResult
12439: oCall 12482
12441: oPop 1
12443: oJumpForward 12481
12445: oInput 41
12447: oGetAddrLocal 12
12449: oPushResult
12450: oCall 11973
12452: oPop 1
12454: oError 16
12456: oJumpForward 12481
12458: Choice Lookup Table
          40   12445
          15   12436
          39   12349
          19   12329
          38   12025
           0   11977
12471: oCall 3533
12473: oInput 22
12475: oCall 3533
12477: oCall 4248
12479: oError 16
12481: oReturn
12482: oLocalSpace 11
12484: oGetParam 1
12486: oPushResult
12487: oSetResult 43
12489: oPushResult
12490: oNodeNew
12491: oPop 1
12493: oAssign
12494: oGetAddrLocal 1
12496: oPushResult
12497: oSetResult 0
12499: oAssign
12500: oGetAddrLocal 2
12502: oPushResult
12503: oSetResult 0
12505: oAssign
12506: oGetAddrLocal 3
12508: oPushResult
12509: oSetResult 1
12511: oAssign
12512: oGetAddrLocal 4
12514: oPushResult
12515: oScopeCurrent
12516: oAssign
12517: oSetResult -1
12519: oPushResult
12520: oSetResult 2
12522: oPushResult
12523: oScopeBegin
12524: oPop 2
12526: oInput 0
12528: oGetAddrLocal 5
12530: oPushResult
12531: oSetResult 17
12533: oPushResult
12534: LAST_ID
12535: oPushResult
12536: oCall 14005
12538: oPop 2
12540: oAssign
12541: oGetAddrLocal 6
12543: oPushResult
12544: oSetResult 17
12546: oPushResult
12547: LAST_ID
12548: oPushResult
12549: oCall 14005
12551: oPop 2
12553: oAssign
12554: oGetLocal 5
12556: oPushResult
12557: oSetResult 21
12559: oPushResult
12560: oGetFromParam 1
12562: oPushResult
12563: oNodeSet
12564: oPop 3
12566: oGetLocal 6
12568: oPushResult
12569: oSetResult 21
12571: oPushResult
12572: oGetFromParam 1
12574: oPushResult
12575: oNodeSet
12576: oPop 3
12578: oGetAddrLocal 7
12580: oPushResult
12581: LAST_ID
12582: oPushResult
12583: ID_STRING
12584: oPop 1
12586: oPushResult
12587: oStringAllocLit
12588: oPop 1
12590: oAssign
12591: oGetLocal 5
12593: oPushResult
12594: oSetResult 32
12596: oPushResult
12597: oGetLocal 7
12599: oPushResult
12600: oNodeSetInt
12601: oPop 3
12603: oGetLocal 6
12605: oPushResult
12606: oSetResult 32
12608: oPushResult
12609: oGetLocal 7
12611: oPushResult
12612: oNodeSetInt
12613: oPop 3
12615: oInputChoice 12693
12617: oGetGlobal 6
12619: oPushResult
12620: oTypeSPush
12621: oPop 1
12623: oCall 3533
12625: oCall 4345
12627: oTypeSPop
12628: oGetLocal 2
12630: oPushResult
12631: equal_zero
12632: oPop 1
12634: oChoice 12655
12636: oValueTop
12637: oPushResult
12638: oGetLocal 1
12640: oPushResult
12641: greater
12642: oPop 2
12644: oChoice 12650
12646: oError 26
12648: oJumpForward 12653
12650: Choice Lookup Table
           0   12646
12653: oJumpForward 12658
12655: Choice Lookup Table
           0   12636
12658: oGetLocal 1
12660: oPushResult
12661: oValueTop
12662: oPushResult
12663: equal
12664: oPop 2
12666: oChoice 12682
12668: oGetFromParam 1
12670: oPushResult
12671: oSetResult 44
12673: oPushResult
12674: oSetResult 1
12676: oPushResult
12677: oNodeSetBoolean
12678: oPop 3
12680: oJumpForward 12685
12682: Choice Lookup Table
           0   12668
12685: oGetAddrLocal 1
12687: oPushResult
12688: oValueTop
12689: oAssign
12690: oValuePop
12691: oJumpForward 12698
12693: Choice Lookup Table
           5   12617
           7   12617
12698: oGetLocal 5
12700: oPushResult
12701: oSetResult 22
12703: oPushResult
12704: oGetLocal 1
12706: oPushResult
12707: oNodeSetInt
12708: oPop 3
12710: oGetLocal 6
12712: oPushResult
12713: oSetResult 22
12715: oPushResult
12716: oGetLocal 1
12718: oPushResult
12719: oNodeSetInt
12720: oPop 3
12722: oGetLocal 5
12724: oPushResult
12725: oScopeDeclare
12726: oPop 1
12728: oGetLocal 4
12730: oPushResult
12731: oScopeEnter
12732: oPop 1
12734: oGetLocal 6
12736: oPushResult
12737: oScopeDeclare
12738: oPop 1
12740: oScopeEnd
12741: oGetAddrLocal 1
12743: oPushResult
12744: inc
12745: oPop 1
12747: oGetAddrLocal 2
12749: oPushResult
12750: inc
12751: oPop 1
12753: oInputChoice 12757
12755: oJumpForward 12762
12757: Choice Lookup Table
          14   12755
12760: oJumpForward 12764
12762: oJumpBack 12526
12764: oInput 16
12766: oGetFromParam 1
12768: oPushResult
12769: oSetResult 41
12771: oPushResult
12772: oScopeCurrent
12773: oPushResult
12774: oNodeSet
12775: oPop 3
12777: oGetFromParam 1
12779: oPushResult
12780: oSetResult 17
12782: oPushResult
12783: oSetResult 4
12785: oPushResult
12786: oNodeSetInt
12787: oPop 3
12789: oScopeEnd
12790: oGetGlobal 2
12792: oPushResult
12793: oCall 13903
12795: oPop 1
12797: oPushResult
12798: oCodePush
12799: oPop 1
12801: oGetGlobal 2
12803: oPushResult
12804: oScopeEnter
12805: oPop 1
12807: oGetAddrLocal 8
12809: oPushResult
12810: oGetLocal 2
12812: oPushResult
12813: oSetResult 1
12815: oPushResult
12816: add
12817: oPop 2
12819: oPushResult
12820: oSetResult 16
12822: oPushResult
12823: multiply
12824: oPop 2
12826: oAssign
12827: oGetAddrLocal 9
12829: oPushResult
12830: oGetLocal 8
12832: oPushResult
12833: oSetResult 8
12835: oPushResult
12836: oScopeAlloc
12837: oPop 2
12839: oAssign
12840: oScopeEnd
12841: oGetFromParam 1
12843: oPushResult
12844: oSetResult 43
12846: oPushResult
12847: oGetLocal 9
12849: oPushResult
12850: oNodeSetInt
12851: oPop 3
12853: oGetAddrLocal 10
12855: oPushResult
12856: oGetFromParam 1
12858: oPushResult
12859: oSetResult 41
12861: oPushResult
12862: oNodeGet
12863: oPop 2
12865: oPushResult
12866: oSetResult 15
12868: oPushResult
12869: oNodeGetIter
12870: oPop 2
12872: oAssign
12873: oGetAddrLocal 11
12875: oPushResult
12876: oGetLocal 10
12878: oPushResult
12879: oNodeIterValue
12880: oPop 1
12882: oAssign
12883: oGetLocal 11
12885: oPushResult
12886: oNodeNull
12887: oPop 1
12889: oChoice 12895
12891: oJumpForward 12982
12893: oJumpForward 12898
12895: Choice Lookup Table
           1   12891
12898: oEmit 17
12900: oGetLocal 9
12902: oPushResult
12903: oEmitInt
12904: oPop 1
12906: oEmit 15
12908: oGetLocal 11
12910: oPushResult
12911: oSetResult 22
12913: oPushResult
12914: oNodeGetInt
12915: oPop 2
12917: oPushResult
12918: oEmitInt
12919: oPop 1
12921: oEmit 27
12923: oGetAddrLocal 9
12925: oPushResult
12926: oGetLocal 9
12928: oPushResult
12929: oSetResult 8
12931: oPushResult
12932: add
12933: oPop 2
12935: oAssign
12936: oEmit 17
12938: oGetLocal 9
12940: oPushResult
12941: oEmitInt
12942: oPop 1
12944: oEmit 17
12946: oGetLocal 11
12948: oPushResult
12949: oSetResult 32
12951: oPushResult
12952: oNodeGetInt
12953: oPop 2
12955: oPushResult
12956: oEmitInt
12957: oPop 1
12959: oEmit 29
12961: oGetAddrLocal 9
12963: oPushResult
12964: oGetLocal 9
12966: oPushResult
12967: oSetResult 8
12969: oPushResult
12970: add
12971: oPop 2
12973: oAssign
12974: oGetAddrLocal 10
12976: oPushResult
12977: oNodeIterNext
12978: oPop 1
12980: oJumpBack 12873
12982: oEmit 17
12984: oGetLocal 9
12986: oPushResult
12987: oEmitInt
12988: oPop 1
12990: oEmit 15
12992: oSetResult 0
12994: oPushResult
12995: oEmitInt
12996: oPop 1
12998: oEmit 27
13000: oGetAddrLocal 9
13002: oPushResult
13003: oGetLocal 9
13005: oPushResult
13006: oSetResult 8
13008: oPushResult
13009: add
13010: oPop 2
13012: oAssign
13013: oEmit 17
13015: oGetLocal 9
13017: oPushResult
13018: oEmitInt
13019: oPop 1
13021: oEmit 15
13023: oSetResult 0
13025: oPushResult
13026: oEmitInt
13027: oPop 1
13029: oEmit 29
13031: oGetAddrLocal 9
13033: oPushResult
13034: oGetLocal 9
13036: oPushResult
13037: oSetResult 8
13039: oPushResult
13040: add
13041: oPop 2
13043: oAssign
13044: oCodePop
13045: oGetFromParam 1
13047: oPushResult
13048: oTypeAdd
13049: oPop 1
13051: oReturn
13052: oLocalSpace 1
13054: oGetAddrLocal 1
13056: oPushResult
13057: oGetParam 1
13059: oPushResult
13060: oSetResult 36
13062: oPushResult
13063: oNodeGet
13064: oPop 2
13066: oAssign
13067: oGetLocal 1
13069: oPushResult
13070: oNodeNull
13071: oPop 1
13073: oChoice 13129
13075: oGetAddrLocal 1
13077: oPushResult
13078: oSetResult 36
13080: oPushResult
13081: oNodeNew
13082: oPop 1
13084: oAssign
13085: oGetLocal 1
13087: oPushResult
13088: oSetResult 37
13090: oPushResult
13091: oGetParam 1
13093: oPushResult
13094: oNodeSet
13095: oPop 3
13097: oGetLocal 1
13099: oPushResult
13100: oSetResult 17
13102: oPushResult
13103: oSetResult 8
13105: oPushResult
13106: oNodeSetInt
13107: oPop 3
13109: oGetLocal 1
13111: oPushResult
13112: oTypeAdd
13113: oPop 1
13115: oGetParam 1
13117: oPushResult
13118: oSetResult 36
13120: oPushResult
13121: oGetLocal 1
13123: oPushResult
13124: oNodeSet
13125: oPop 3
13127: oJumpForward 13132
13129: Choice Lookup Table
           1   13075
13132: oGetLocal 1
13134: oReturn
13135: oReturn
13136: oLocalSpace 2
13138: oGetParam 1
13140: oPushResult
13141: oNodeType
13142: oPop 1
13144: oChoice 13214
13146: oMININT
13147: oReturn
13148: oJumpForward 13230
13150: oSetResult 0
13152: oReturn
13153: oJumpForward 13230
13155: oSetResult 0
13157: oReturn
13158: oJumpForward 13230
13160: oGetAddrLocal 1
13162: oPushResult
13163: oGetParam 1
13165: oPushResult
13166: oSetResult 41
13168: oPushResult
13169: oNodeGet
13170: oPop 2
13172: oAssign
13173: oGetAddrLocal 2
13175: oPushResult
13176: oGetLocal 1
13178: oPushResult
13179: oSetResult 15
13181: oPushResult
13182: oNodeGetIter
13183: oPop 2
13185: oPushResult
13186: oNodeIterValue
13187: oPop 1
13189: oAssign
13190: oGetLocal 2
13192: oPushResult
13193: oSetResult 22
13195: oPushResult
13196: oNodeGetInt
13197: oPop 2
13199: oReturn
13200: oJumpForward 13230
13202: oGetParam 1
13204: oPushResult
13205: oSetResult 39
13207: oPushResult
13208: oNodeGetInt
13209: oPop 2
13211: oReturn
13212: oJumpForward 13230
13214: Choice Lookup Table
          39   13202
          43   13160
          35   13155
          33   13150
          30   13146
13225: oError 3
13227: oSetResult 0
13229: oReturn
13230: oReturn
13231: oLocalSpace 2
13233: oGetParam 1
13235: oPushResult
13236: oNodeType
13237: oPop 1
13239: oChoice 13309
13241: oMAXINT
13242: oReturn
13243: oJumpForward 13325
13245: oSetResult 1
13247: oReturn
13248: oJumpForward 13325
13250: oSetResult 255
13252: oReturn
13253: oJumpForward 13325
13255: oGetAddrLocal 1
13257: oPushResult
13258: oGetParam 1
13260: oPushResult
13261: oSetResult 41
13263: oPushResult
13264: oNodeGet
13265: oPop 2
13267: oAssign
13268: oGetAddrLocal 2
13270: oPushResult
13271: oGetLocal 1
13273: oPushResult
13274: oSetResult 15
13276: oPushResult
13277: oNodeGetIterLast
13278: oPop 2
13280: oPushResult
13281: oNodeIterValue
13282: oPop 1
13284: oAssign
13285: oGetLocal 2
13287: oPushResult
13288: oSetResult 22
13290: oPushResult
13291: oNodeGetInt
13292: oPop 2
13294: oReturn
13295: oJumpForward 13325
13297: oGetParam 1
13299: oPushResult
13300: oSetResult 40
13302: oPushResult
13303: oNodeGetInt
13304: oPop 2
13306: oReturn
13307: oJumpForward 13325
13309: Choice Lookup Table
          39   13297
          43   13255
          35   13250
          33   13245
          30   13241
13320: oError 3
13322: oSetResult 0
13324: oReturn
13325: oReturn
13326: oLocalSpace 5
13328: oGetAddrGlobal 1
13330: oPushResult
13331: oWorkspaceNew
13332: oAssign
13333: oSetResult 0
13335: oPushResult
13336: oSetResult 0
13338: oPushResult
13339: oScopeBegin
13340: oPop 2
13342: oGetAddrLocal 2
13344: oPushResult
13345: oScopeCurrent
13346: oAssign
13347: oCall 14075
13349: oEmit 68
13351: oSetResult 0
13353: oPushResult
13354: oEmitInt
13355: oPop 1
13357: oGetAddrLocal 3
13359: oPushResult
13360: oLabelNew
13361: oAssign
13362: oEmit 62
13364: oSetResult 0
13366: oPushResult
13367: oEmitInt
13368: oPop 1
13370: oEmit 65
13372: oGetLocal 3
13374: oPushResult
13375: oEmitLabel
13376: oPop 1
13378: oEmit 64
13380: oSetResult 0
13382: oPushResult
13383: oEmitInt
13384: oPop 1
13386: oEmit 67
13388: oInput 29
13390: oInput 0
13392: oGetAddrLocal 4
13394: oPushResult
13395: oSetResult 4
13397: oPushResult
13398: oNodeNew
13399: oPop 1
13401: oAssign
13402: oGetLocal 4
13404: oPushResult
13405: oSetResult 4
13407: oPushResult
13408: LAST_ID
13409: oPushResult
13410: oNodeSetInt
13411: oPop 3
13413: oGetGlobal 1
13415: oPushResult
13416: oSetResult 2
13418: oPushResult
13419: oGetLocal 4
13421: oPushResult
13422: oNodeSet
13423: oPop 3
13425: oInputChoice 13499
13427: oInput 0
13429: oGetAddrLocal 1
13431: oPushResult
13432: oSetResult 20
13434: oPushResult
13435: LAST_ID
13436: oPushResult
13437: oCall 14005
13439: oPop 2
13441: oAssign
13442: oGetLocal 1
13444: oPushResult
13445: oSetResult 21
13447: oPushResult
13448: oGetGlobal 5
13450: oPushResult
13451: oNodeSet
13452: oPop 3
13454: oGetLocal 1
13456: oPushResult
13457: oScopeDeclareAlloc
13458: oPop 1
13460: oInput 14
13462: oInput 0
13464: oGetAddrLocal 1
13466: oPushResult
13467: oSetResult 20
13469: oPushResult
13470: LAST_ID
13471: oPushResult
13472: oCall 14005
13474: oPop 2
13476: oAssign
13477: oGetLocal 1
13479: oPushResult
13480: oSetResult 21
13482: oPushResult
13483: oGetGlobal 5
13485: oPushResult
13486: oNodeSet
13487: oPop 3
13489: oGetLocal 1
13491: oPushResult
13492: oScopeDeclareAlloc
13493: oPop 1
13495: oInput 16
13497: oJumpForward 13502
13499: Choice Lookup Table
          15   13427
13502: oInput 6
13504: oGetLocal 4
13506: oPushResult
13507: oCall 34
13509: oPop 1
13511: oInputChoice 13522
13513: oGetLocal 4
13515: oPushResult
13516: oCall 7
13518: oPop 1
13520: oJumpForward 13525
13522: Choice Lookup Table
          60   13513
13525: oGetLocal 4
13527: oPushResult
13528: oCall 287
13530: oPop 1
13532: oSetResult 0
13534: oPushResult
13535: oSetResult 0
13537: oPushResult
13538: oScopeBegin
13539: oPop 2
13541: oGetAddrGlobal 2
13543: oPushResult
13544: oScopeCurrent
13545: oAssign
13546: oSetResult 0
13548: oPushResult
13549: oSetResult 1
13551: oPushResult
13552: oScopeBegin
13553: oPop 2
13555: oScopeCurrent
13556: oPushResult
13557: oSetResult 16
13559: oPushResult
13560: oGetGlobal 2
13562: oPushResult
13563: oNodeSet
13564: oPop 3
13566: oGetAddrGlobal 3
13568: oPushResult
13569: oScopeCurrent
13570: oAssign
13571: oGetLocal 4
13573: oPushResult
13574: oSetResult 7
13576: oPushResult
13577: oGetGlobal 3
13579: oPushResult
13580: oNodeSet
13581: oPop 3
13583: oScopeEnd
13584: oSetResult 21
13586: oPushResult
13587: oCall 13654
13589: oPop 1
13591: oGetGlobal 3
13593: oPushResult
13594: oScopeEnter
13595: oPop 1
13597: oGetAddrLocal 5
13599: oPushResult
13600: oSetResult 1
13602: oAssign
13603: oGetLocal 3
13605: oPushResult
13606: oGetGlobal 2
13608: oPushResult
13609: oGetLocal 5
13611: oPushResult
13612: oCall 13805
13614: oPop 3
13616: oScopeEnd
13617: oInput 21
13619: oCall 13710
13621: oScopeEnd
13622: oGetLocal 4
13624: oPushResult
13625: oCall 349
13627: oPop 1
13629: oReturn
13630: oLocalSpace 0
13632: oGetParam 2
13634: oPushResult
13635: oCall 13654
13637: oPop 1
13639: oGetParam 1
13641: oPushResult
13642: oScopeCurrent
13643: oPushResult
13644: oSetResult 0
13646: oPushResult
13647: oCall 13805
13649: oPop 3
13651: oCall 13710
13653: oReturn
13654: oLocalSpace 0
13656: oInputChoice 13687
13658: oCall 2520
13660: oJumpForward 13702
13662: oCall 3178
13664: oJumpForward 13702
13666: oGetParam 1
13668: oPushResult
13669: oCall 3234
13671: oPop 1
13673: oJumpForward 13702
13675: oCall 3468
13677: oJumpForward 13702
13679: oCall 1743
13681: oJumpForward 13702
13683: oCall 2178
13685: oJumpForward 13702
13687: Choice Lookup Table
          31   13683
          30   13679
          35   13675
          34   13666
          33   13662
          32   13658
13700: oJumpForward 13704
13702: oJumpBack 13656
13704: oCall 13707
13706: oReturn
13707: oLocalSpace 0
13709: oReturn
13710: oLocalSpace 2
13712: oGetAddrLocal 1
13714: oPushResult
13715: oScopeCurrent
13716: oPushResult
13717: oSetResult 15
13719: oPushResult
13720: oNodeGetIter
13721: oPop 2
13723: oAssign
13724: oGetAddrLocal 2
13726: oPushResult
13727: oGetLocal 1
13729: oPushResult
13730: oNodeIterValue
13731: oPop 1
13733: oAssign
13734: oGetLocal 2
13736: oPushResult
13737: oNodeNull
13738: oPop 1
13740: oChoice 13744
13742: oJumpForward 13749
13744: Choice Lookup Table
           0   13742
13747: oJumpForward 13804
13749: oGetLocal 2
13751: oPushResult
13752: oNodeType
13753: oPop 1
13755: oChoice 13793
13757: oGetLocal 2
13759: oPushResult
13760: oSetResult 35
13762: oPushResult
13763: oNodeGetBoolean
13764: oPop 2
13766: oChoice 13788
13768: oGetLocal 2
13770: oPushResult
13771: oSetResult 28
13773: oPushResult
13774: oNodeGetBoolean
13775: oPop 2
13777: oChoice 13783
13779: oError 27
13781: oJumpForward 13786
13783: Choice Lookup Table
           1   13779
13786: oJumpForward 13791
13788: Choice Lookup Table
           0   13768
13791: oJumpForward 13796
13793: Choice Lookup Table
          26   13757
13796: oGetAddrLocal 1
13798: oPushResult
13799: oNodeIterNext
13800: oPop 1
13802: oJumpBack 13724
13804: oReturn
13805: oLocalSpace 3
13807: oEmit 78
13809: oGetParam 3
13811: oPushResult
13812: oEmitLabel
13813: oPop 1
13815: oEmit 68
13817: oGetAddrLocal 1
13819: oPushResult
13820: Here
13821: oAssign
13822: oEmit 96
13824: oGetParam 1
13826: oChoice 13832
13828: oCall 1220
13830: oJumpForward 13835
13832: Choice Lookup Table
           1   13828
13835: oGetAddrLocal 2
13837: oPushResult
13838: oGetParam 2
13840: oPushResult
13841: oSetResult 19
13843: oPushResult
13844: oNodeGetCode
13845: oPop 2
13847: oAssign
13848: oGetLocal 2
13850: oPushResult
13851: oEmitCode
13852: oPop 1
13854: oGetParam 2
13856: oPushResult
13857: oSetResult 19
13859: oPushResult
13860: oSetResult 0
13862: oPushResult
13863: oNodeSetCode
13864: oPop 3
13866: oCall 8736
13868: oGetParam 1
13870: oChoice 13876
13872: oCall 1305
13874: oJumpForward 13879
13876: Choice Lookup Table
           1   13872
13879: oEmit 67
13881: oGetAddrLocal 3
13883: oPushResult
13884: oScopeCurrent
13885: oPushResult
13886: oSetResult 17
13888: oPushResult
13889: oNodeGetInt
13890: oPop 2
13892: oAssign
13893: oGetLocal 1
13895: oPushResult
13896: oGetLocal 3
13898: oPushResult
13899: oPatch
13900: oPop 2
13902: oReturn
13903: oLocalSpace 1
13905: oGetAddrLocal 1
13907: oPushResult
13908: oGetParam 1
13910: oPushResult
13911: oSetResult 19
13913: oPushResult
13914: oNodeGetCode
13915: oPop 2
13917: oAssign
13918: oGetLocal 1
13920: oPushResult
13921: oSetResult 0
13923: oPushResult
13924: equal_code
13925: oPop 2
13927: oChoice 13948
13929: oGetAddrLocal 1
13931: oPushResult
13932: oCodeNew
13933: oAssign
13934: oGetParam 1
13936: oPushResult
13937: oSetResult 19
13939: oPushResult
13940: oGetLocal 1
13942: oPushResult
13943: oNodeSetCode
13944: oPop 3
13946: oJumpForward 13951
13948: Choice Lookup Table
           1   13929
13951: oGetLocal 1
13953: oReturn
13954: oReturn
13955: oLocalSpace 0
13957: oScopeCurrent
13958: oPushResult
13959: oSetResult 14
13961: oPushResult
13962: oNodeGetInt
13963: oPop 2
13965: oReturn
13966: oReturn
13967: oLocalSpace 0
13969: oGetParam 1
13971: oPushResult
13972: oSetResult 20
13974: oPushResult
13975: oNodeGet
13976: oPop 2
13978: oPushResult
13979: oSetResult 14
13981: oPushResult
13982: oNodeGetInt
13983: oPop 2
13985: oReturn
13986: oReturn
13987: oLocalSpace 0
13989: oCall 13955
13991: oPushResult
13992: oGetParam 1
13994: oPushResult
13995: oCall 13967
13997: oPop 1
13999: oPushResult
14000: subtract
14001: oPop 2
14003: oReturn
14004: oReturn
14005: oLocalSpace 1
14007: oGetAddrLocal 1
14009: oPushResult
14010: oGetParam 2
14012: oPushResult
14013: oNodeNew
14014: oPop 1
14016: oAssign
14017: oGetLocal 1
14019: oPushResult
14020: oSetResult 4
14022: oPushResult
14023: oGetParam 1
14025: oPushResult
14026: oNodeSetInt
14027: oPop 3
14029: oGetLocal 1
14031: oReturn
14032: oReturn
14033: oLocalSpace 0
14035: oGetParam 1
14037: oPushResult
14038: oSetResult 22
14040: oPushResult
14041: oNodeGetInt
14042: oPop 2
14044: oPushResult
14045: oEmitInt
14046: oPop 1
14048: oReturn
14049: oLocalSpace 1
14051: oGetAddrLocal 1
14053: oPushResult
14054: oSetResult 14
14056: oPushResult
14057: oGetParam 1
14059: oPushResult
14060: oCall 14005
14062: oPop 2
14064: oAssign
14065: oGetLocal 1
14067: oPushResult
14068: oScopeDeclare
14069: oPop 1
14071: oGetLocal 1
14073: oReturn
14074: oReturn
14075: oLocalSpace 1
14077: oGetAddrGlobal 25
14079: oPushResult
14080: oSetResult 0
14082: oAssign
14083: oGetAddrGlobal 4
14085: oPushResult
14086: oId_mysystem
14087: oAssign
14088: oGetAddrGlobal 5
14090: oPushResult
14091: oSetResult 28
14093: oPushResult
14094: oSetResult 4
14096: oPushResult
14097: oCall 11939
14099: oPop 2
14101: oAssign
14102: oGetAddrGlobal 6
14104: oPushResult
14105: oSetResult 30
14107: oPushResult
14108: oSetResult 4
14110: oPushResult
14111: oCall 11939
14113: oPop 2
14115: oAssign
14116: oGetAddrGlobal 7
14118: oPushResult
14119: oSetResult 33
14121: oPushResult
14122: oSetResult 1
14124: oPushResult
14125: oCall 11939
14127: oPop 2
14129: oAssign
14130: oGetAddrGlobal 8
14132: oPushResult
14133: oSetResult 34
14135: oPushResult
14136: oSetResult 1
14138: oPushResult
14139: oCall 11939
14141: oPop 2
14143: oAssign
14144: oGetAddrGlobal 9
14146: oPushResult
14147: oSetResult 35
14149: oPushResult
14150: oSetResult 1
14152: oPushResult
14153: oCall 11939
14155: oPop 2
14157: oAssign
14158: oGetAddrGlobal 10
14160: oPushResult
14161: oGetGlobal 9
14163: oPushResult
14164: oCall 13052
14166: oPop 1
14168: oAssign
14169: oGetAddrGlobal 11
14171: oPushResult
14172: oSetResult 29
14174: oPushResult
14175: oSetResult 1
14177: oPushResult
14178: oCall 11939
14180: oPop 2
14182: oAssign
14183: oGetAddrGlobal 12
14185: oPushResult
14186: oSetResult 31
14188: oPushResult
14189: oSetResult 4
14191: oPushResult
14192: oCall 11939
14194: oPop 2
14196: oAssign
14197: oGetAddrGlobal 13
14199: oPushResult
14200: oSetResult 32
14202: oPushResult
14203: oSetResult 8
14205: oPushResult
14206: oCall 11939
14208: oPop 2
14210: oAssign
14211: oGetAddrGlobal 14
14213: oPushResult
14214: oSetResult 37
14216: oPushResult
14217: oSetResult 8
14219: oPushResult
14220: oCall 11939
14222: oPop 2
14224: oAssign
14225: oGetGlobal 14
14227: oPushResult
14228: oSetResult 37
14230: oPushResult
14231: oGetGlobal 11
14233: oPushResult
14234: oNodeSet
14235: oPop 3
14237: oGetAddrGlobal 15
14239: oPushResult
14240: oSetResult 41
14242: oPushResult
14243: oSetResult 256
14245: oPushResult
14246: oCall 11939
14248: oPop 2
14250: oAssign
14251: oGetAddrGlobal 16
14253: oPushResult
14254: oSetResult 42
14256: oPushResult
14257: oSetResult 256
14259: oPushResult
14260: oCall 11939
14262: oPop 2
14264: oAssign
14265: oGetGlobal 16
14267: oPushResult
14268: oSetResult 42
14270: oPushResult
14271: oSetResult 255
14273: oPushResult
14274: oNodeSetInt
14275: oPop 3
14277: oGetAddrLocal 1
14279: oPushResult
14280: oSetResult 19
14282: oPushResult
14283: oId_File
14284: oPushResult
14285: oCall 14005
14287: oPop 2
14289: oAssign
14290: oGetLocal 1
14292: oPushResult
14293: oSetResult 21
14295: oPushResult
14296: oGetGlobal 5
14298: oPushResult
14299: oNodeSet
14300: oPop 3
14302: oGetLocal 1
14304: oPushResult
14305: oScopeDeclare
14306: oPop 1
14308: oGetAddrLocal 1
14310: oPushResult
14311: oSetResult 19
14313: oPushResult
14314: oId_Integer
14315: oPushResult
14316: oCall 14005
14318: oPop 2
14320: oAssign
14321: oGetLocal 1
14323: oPushResult
14324: oSetResult 21
14326: oPushResult
14327: oGetGlobal 6
14329: oPushResult
14330: oNodeSet
14331: oPop 3
14333: oGetLocal 1
14335: oPushResult
14336: oScopeDeclare
14337: oPop 1
14339: oGetAddrLocal 1
14341: oPushResult
14342: oSetResult 19
14344: oPushResult
14345: oId_Boolean
14346: oPushResult
14347: oCall 14005
14349: oPop 2
14351: oAssign
14352: oGetLocal 1
14354: oPushResult
14355: oSetResult 21
14357: oPushResult
14358: oGetGlobal 7
14360: oPushResult
14361: oNodeSet
14362: oPop 3
14364: oGetLocal 1
14366: oPushResult
14367: oScopeDeclare
14368: oPop 1
14370: oGetAddrLocal 1
14372: oPushResult
14373: oSetResult 19
14375: oPushResult
14376: oId_Char
14377: oPushResult
14378: oCall 14005
14380: oPop 2
14382: oAssign
14383: oGetLocal 1
14385: oPushResult
14386: oSetResult 21
14388: oPushResult
14389: oGetGlobal 9
14391: oPushResult
14392: oNodeSet
14393: oPop 3
14395: oGetLocal 1
14397: oPushResult
14398: oScopeDeclare
14399: oPop 1
14401: oGetAddrLocal 1
14403: oPushResult
14404: oSetResult 19
14406: oPushResult
14407: oId_Byte
14408: oPushResult
14409: oCall 14005
14411: oPop 2
14413: oAssign
14414: oGetLocal 1
14416: oPushResult
14417: oSetResult 21
14419: oPushResult
14420: oGetGlobal 11
14422: oPushResult
14423: oNodeSet
14424: oPop 3
14426: oGetLocal 1
14428: oPushResult
14429: oScopeDeclare
14430: oPop 1
14432: oGetAddrLocal 1
14434: oPushResult
14435: oSetResult 19
14437: oPushResult
14438: oId_Single
14439: oPushResult
14440: oCall 14005
14442: oPop 2
14444: oAssign
14445: oGetLocal 1
14447: oPushResult
14448: oSetResult 21
14450: oPushResult
14451: oGetGlobal 12
14453: oPushResult
14454: oNodeSet
14455: oPop 3
14457: oGetLocal 1
14459: oPushResult
14460: oScopeDeclare
14461: oPop 1
14463: oGetAddrLocal 1
14465: oPushResult
14466: oSetResult 19
14468: oPushResult
14469: oId_Double
14470: oPushResult
14471: oCall 14005
14473: oPop 2
14475: oAssign
14476: oGetLocal 1
14478: oPushResult
14479: oSetResult 21
14481: oPushResult
14482: oGetGlobal 13
14484: oPushResult
14485: oNodeSet
14486: oPop 3
14488: oGetLocal 1
14490: oPushResult
14491: oScopeDeclare
14492: oPop 1
14494: oGetAddrLocal 1
14496: oPushResult
14497: oSetResult 19
14499: oPushResult
14500: oId_Pointer
14501: oPushResult
14502: oCall 14005
14504: oPop 2
14506: oAssign
14507: oGetLocal 1
14509: oPushResult
14510: oSetResult 21
14512: oPushResult
14513: oGetGlobal 14
14515: oPushResult
14516: oNodeSet
14517: oPop 3
14519: oGetLocal 1
14521: oPushResult
14522: oScopeDeclare
14523: oPop 1
14525: oGetAddrLocal 1
14527: oPushResult
14528: oSetResult 19
14530: oPushResult
14531: oId_ShortString
14532: oPushResult
14533: oCall 14005
14535: oPop 2
14537: oAssign
14538: oGetLocal 1
14540: oPushResult
14541: oSetResult 21
14543: oPushResult
14544: oGetGlobal 16
14546: oPushResult
14547: oNodeSet
14548: oPop 3
14550: oGetLocal 1
14552: oPushResult
14553: oScopeDeclare
14554: oPop 1
14556: oGetAddrLocal 1
14558: oPushResult
14559: oSetResult 16
14561: oPushResult
14562: oId_True
14563: oPushResult
14564: oCall 14005
14566: oPop 2
14568: oAssign
14569: oGetLocal 1
14571: oPushResult
14572: oSetResult 21
14574: oPushResult
14575: oGetGlobal 7
14577: oPushResult
14578: oNodeSet
14579: oPop 3
14581: oGetLocal 1
14583: oPushResult
14584: oSetResult 22
14586: oPushResult
14587: oSetResult 1
14589: oPushResult
14590: oNodeSetInt
14591: oPop 3
14593: oGetLocal 1
14595: oPushResult
14596: oScopeDeclare
14597: oPop 1
14599: oGetAddrLocal 1
14601: oPushResult
14602: oSetResult 16
14604: oPushResult
14605: oId_False
14606: oPushResult
14607: oCall 14005
14609: oPop 2
14611: oAssign
14612: oGetLocal 1
14614: oPushResult
14615: oSetResult 21
14617: oPushResult
14618: oGetGlobal 7
14620: oPushResult
14621: oNodeSet
14622: oPop 3
14624: oGetLocal 1
14626: oPushResult
14627: oSetResult 22
14629: oPushResult
14630: oSetResult 0
14632: oPushResult
14633: oNodeSetInt
14634: oPop 3
14636: oGetLocal 1
14638: oPushResult
14639: oScopeDeclare
14640: oPop 1
14642: oGetAddrLocal 1
14644: oPushResult
14645: oSetResult 16
14647: oPushResult
14648: oId_Nil
14649: oPushResult
14650: oCall 14005
14652: oPop 2
14654: oAssign
14655: oGetLocal 1
14657: oPushResult
14658: oSetResult 21
14660: oPushResult
14661: oGetGlobal 14
14663: oPushResult
14664: oNodeSet
14665: oPop 3
14667: oGetLocal 1
14669: oPushResult
14670: oSetResult 22
14672: oPushResult
14673: oSetResult 0
14675: oPushResult
14676: oNodeSetInt
14677: oPop 3
14679: oGetLocal 1
14681: oPushResult
14682: oScopeDeclare
14683: oPop 1
14685: oGetAddrGlobal 17
14687: oPushResult
14688: oId_Ord
14689: oPushResult
14690: oCall 14049
14692: oPop 1
14694: oAssign
14695: oGetAddrGlobal 18
14697: oPushResult
14698: oId_Chr
14699: oPushResult
14700: oCall 14049
14702: oPop 1
14704: oAssign
14705: oGetAddrGlobal 19
14707: oPushResult
14708: oId_Pred
14709: oPushResult
14710: oCall 14049
14712: oPop 1
14714: oAssign
14715: oGetAddrGlobal 20
14717: oPushResult
14718: oId_Succ
14719: oPushResult
14720: oCall 14049
14722: oPop 1
14724: oAssign
14725: oGetAddrGlobal 21
14727: oPushResult
14728: oId_Sizeof
14729: oPushResult
14730: oCall 14049
14732: oPop 1
14734: oAssign
14735: oReturn
