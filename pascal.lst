   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, kVar, LAST_ID )
 121:          oNodeSet( t, qType, FileType )
 133:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 139:          ','
 141:          pIdent
      
 143:          t = @newIdent( nVar, kVar, LAST_ID )
 159:          oNodeSet( t, qType, FileType )
 171:          oScopeDeclareAlloc( t )
      
 177:          ')'
 179:       | * :
 184:    ]
 184:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 186:    [
 186:       | pUses :  @UsesClause( program )
 195:       | * :
 200:    ]
 200:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
         % TO DO: I have a problem here.  I want separate scopes for visibility,
         %    but need to allocate global vars from a common offset counter,
         %    which I have in Scope currently.
         %    I need a way to share allocators.  Should only be necessary for global scopes.
         %    I could make global scope (with allocUp) a special case, and allocate from a
         %    global counter despite having separate Scopes.
         %    Or I could declare Scopes to "extend" another scope, meaning it shares the allocator.
 207:    oScopeBegin( 0, allocGlobal )
 216:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 221:    oScopeBegin( 0, allocDown )
 230:    initScope = oScopeCurrent
 235:    oNodeSet( program, qMainRoutineScope, initScope )
 247:    oScopeEnd
      
 248:    @BlockDecls( nGlobalVar )
      
      
 255:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 261:    boolean isMain = true
 267:    @BlockStmt( mainLabel, globalScope, isMain )
      
 280:    oScopeEnd   % main routine scope
      
 281:    '.'
 283:    oScopeEnd   % global scope
 284:    @EndUsedUnits( program )   % used units scopes
 292:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded)
      % and make the public portions of the named units visible to this program.
 292: UsesClause( Node user ):
 294:    {
 294:       pIdent
 296:       Node unit = @FindOrCompileUnit( LAST_ID )
 306:       [ equal_node( unit, Null )
 316:          | false :
 317:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % TO DO: put a declaration in the current scope, naming the unit and pointing to it.
                  %   This is to allow references to  <unit>.<identifier_in_unit>
                  %   Maybe something like nUsedUnit or nImportUnit
 329:          | * :
 334:       ]
 334:       [
 334:          | ',' :
 336:          | * :  >
 343:       ]
 343:    }   
 345:    ';'
 348:    ;
      
 348: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
 350:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 363:    {
 363:       Node unit = oNodeIterValue( unitIt )
 373:       [ oNodeNull( unit )
 380:          | false :
 381:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 394:          | * :
 399:             >
 401:       ]
 401:       oNodeIterNext( unitIt )
 407:    }
 410:    ;
      
 410: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 412:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 425:    {
 425:       Node unit = oNodeIterValue( unitIt )
 435:       [ oNodeNull( unit )
 442:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 443:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 459:                | true :
 460:                | false :  #eInternalScopeMismatch
 464:             ]
 472:             oScopeEnd
 473:          | * :
 478:             >
 480:       ]
 480:       oNodeIterNext( unitIt )
 486:    }
 489:    ;
      
      
 489: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 491:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 510:    [ equal_node( unit, Null )
 520:       | false :  >> unit
 524:       | * :
 529:    ]
      
         % If not, search for the source file on disk
 529:    boolean ok = oIncludeUnitFile( id )
 539:    [ ok
 542:       | false :  #eCantFindUnitFile  >> Null
 548:       | * :
 553:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 553:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 559:    oIncludeEnd
 560:    >> unit;
      
      
      
 564: Unit >> Node:
 566:    pUnit
 568:    pIdent
 570:    Node unit = oNodeNew( nUnit )
 580:    oNodeSetInt( unit, qIdent, LAST_ID )
 591:    oNodeAddLast( workspace, qUnits, unit )
 603:    ';'
 605:    [
 605:       | pUses :   @UsesClause( unit )
 614:       | * :
 619:    ]
 619:    @EnterUsedUnits( unit )
      
         % mandatory sections
      
         % NOTE, despite syntax diagrams, method headers in the interface may have 'external' clause.
         % Confirmed this looking at some units shipped with fpc.
 626:    pInterface
 628:    oScopeBegin( 0, allocGlobal )
 637:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 648:    oScopeBegin( 0, allocDown )
 657:    initScope = oScopeCurrent
 662:    oNodeSet( unit, qInitRoutineScope, initScope )
 674:    oScopeEnd
      
 675:    @UnitInterface( unit )
      
 682:    pImplementation
 684:    oScopeBegin( 0, allocGlobal )
 693:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 704:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 722:    @UnitImplementation( unit )
      
 729:    [
 729:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 741:       | * :                @UnitInitialization( unit, false )  % still need an implicit init routine
 756:    ]
 756:    [
 756:       | pFinalization :  @UnitFinalization( unit, true )
 768:       | * :              @UnitFinalization( unit, false )   % have an implicit final routine, may be handy later
 783:    ]
 783:    pEnd  '.'
 787:    oScopeEnd  % impl scope
 788:    oScopeEnd  % interface scope
 789:    @EndUsedUnits( unit )  % used units scopes
 796:    >> unit;
      
      
 800: UnitInterface( Node unit ):
 802:    {[
 802:       | pConst :     @ConstDecl
 806:       | pType :      @TypeDecl
 810:       | pVar :       @VarDecl( nGlobalVar )
      
 819:       | pProcedure :
 821:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface
 827:          [
 827:             | pExternal : @ExternalDecl( decl )
 836:             | * :
 841:          ]
      
 841:       | pFunction :
 843:          Node decl = @FuncHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface
 849:          [
 849:             | pExternal : @ExternalDecl( decl )
 858:             | * :
 863:          ]
      
 863:       | * :          >
 878:    ]}
 881:    ;
      
 881: UnitImplementation( Node unit ):
 883:    @BlockDecls( nGlobalVar )
 891:    ;
      
      
 891: UnitInitialization( Node unit, boolean hasStmts ):
 893:    Label label = oLabelNew
 898:    .tLabel  oEmitLabel( label )
 906:    oNodeSetLabel( unit, qInitLabel, label )
      
 918:    int patchLS
 918:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 927:    Node scope
 927:    Code initCode
      
 927:    scope = oNodeGet( unit, qPublicScope )
 940:    initCode = oNodeGetCode( scope, qInitCode )
 953:    oEmitCode( initCode )
 959:    oNodeSetCode( scope, qInitCode, codeNull )
      
 971:    scope = oNodeGet( unit, qPrivateScope )
 984:    initCode = oNodeGetCode( scope, qInitCode )
 997:    oEmitCode( initCode )
1003:    oNodeSetCode( scope, qInitCode, codeNull )
      
1015:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1028:    [ hasStmts
1031:       | true :     
1032:          @Statement
1034:          {[
1034:             | ';' :  @Statement
1038:             | * :    >
1045:          ]}
1047:       | * :
1052:    ]
      
1052:    .tReturn
      
1054:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1066:    oPatch( patchLS, localSpace )
1075:    oScopeEnd   % init routine scope, for temporaries
1077:    ;
      
      
1077: UnitFinalization( Node unit, boolean hasStmts ):
1079:    Label label = oLabelNew
1084:    .tLabel  oEmitLabel( label )
1092:    oNodeSetLabel( unit, qFinalLabel, label )
      
1104:    int patchLS
1104:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1113:    oScopeBegin( 0, allocDown )
      
1122:    [ hasStmts
1125:       | true :     
1126:          @Statement
1128:          {[
1128:             | ';' :  @Statement
1132:             | * :    >
1139:          ]}
1141:       | * :
1146:    ]
      
1146:    .tReturn
      
1148:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1160:    oPatch( patchLS, localSpace )
1169:    oScopeEnd   % final routine scope, for temporaries
1171:    ;
      
      
1171: Block( node_type varNodeType, Label labelForBody ):
1173:    @BlockDecls( varNodeType )
1180:    @BlockStmt( labelForBody, oScopeCurrent, false )
1193:    ;
      
      
1193: BlockDecls( node_type varNodeType ):
1195:    {[
1195:       | pConst :     @ConstDecl
1199:       | pType :      @TypeDecl
1203:       | pVar :       @VarDecl( varNodeType )
1212:       | pProcedure : @ProcDecl
1216:       | pFunction :  @FuncDecl
1220:       | * :          >
1235:    ]}
1237:    @CheckForUndefinedMethods
1240:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1240: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1243:    ;
      
      
1243: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1245:    NodeIter it = oNodeGetIter( workspace, qUnits )
1258:    {
1258:       Node unit = oNodeIterValue( it )
1268:       [ oNodeNull( unit )
1275:          | true :  >
1278:          | false :
1280:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1288:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1303:             .tFreeActuals  oEmitInt( 0 )
1311:             oNodeIterNext( it )
1317:       ]
1325:    };
      
      
1328: FinalizeUnits:
1330:    NodeIter it = oNodeGetIter( workspace, qUnits )
1343:    {
1343:       Node unit = oNodeIterValue( it )
1353:       [ oNodeNull( unit )
1360:          | true :  >
1363:          | false :
1365:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1373:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1388:             .tFreeActuals  oEmitInt( 0 )
1396:             oNodeIterNext( it )
1402:       ]
1410:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1413: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1415:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1423:    int patchLS
1423:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1432:    [ isMain
1435:       | true :  @InitializeUnits
1438:       | * :
1443:    ]
      
         % insert any code for initialization of this scope's variables
1443:    Code initCode = oNodeGetCode( varScope, qInitCode )
1456:    oEmitCode( initCode )
1462:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1474:    @Statement
      
1476:    [ isMain
1479:       | true :  @FinalizeUnits
1482:       | * :
1487:    ]
      
1487:    .tReturn
      
1489:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1501:    oPatch( patchLS, localSpace )
1511:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1511: MethodModifiers( Node decl ):
1513:    {[
1513:       | pCdecl :
1515:          oNodeSetBoolean( decl, qCdecl, true )
1527:          ';'
      
1529:       | * : >
1536:    ]}
1539:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1539: GetOrCreateInitCode >> Code:
1541:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1553:    [ equal_code( initCode, codeNull )
1563:       | true :
1564:          initCode = oCodeNew
1569:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1580:       | * :
1585:    ]
1585:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1589: ExternalDecl( Node decl ):
1591:    [ equal_zero( @DeclLevel( decl ) )
1603:       | false :  #eExternalMethodCannotBeNested
1606:       | * :
1611:    ]
1611:    oNodeSetBoolean( decl, qExternal, true )
1623:    [
1623:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1625:          [
1625:             | pName :
1627:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1629:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1640:             | * :
1645:          ]
1645:       | * :
1650:    ]
1651:    ;
      
      
1651: ProcHeaderDecl >> Node:
1653:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1655:    boolean redeclaring = false
1661:    Node decl = oScopeFindInCurrentScope
      
1666:    [ oNodeNull( decl )
1673:       | true :
               % first declaration
1674:          decl = @newIdent( nProc, kProc, LAST_ID )
1690:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1701:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1703:          redeclaring = true
1709:          [ oNodeGetBoolean( decl, qBodyDefined )
1719:             | true : #eAlreadyDefined
1722:             | * :
1727:          ]
1727:          [ oNodeGetBoolean( decl, qExternal )
1737:             | true : #eAlreadyDefined
1740:             | * :
1745:          ]
1745:          [ oNodeType( decl )
1752:             | nProc :
1753:             | * : #eAlreadyDefined   % wrong kind
1760:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1760:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1779:          oNodeSet( decl, qParams, Null )
1791:    ]
      
1799:    int level = @ScopeLevel
1805:    boolean nested = greater( level, 0 )
1818:    inc( level )
1824:    oScopeBegin( level, allocUp )
1833:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1838:    [ nested
1841:       | true :
1842:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1857:       | * :
1862:    ]
      
1862:    @FormalArgDecl
1864:    oNodeSet( decl, qParams, paramScope )
1876:    oScopeEnd
1877:    ';'
      
1879:    [ redeclaring
1882:       | false : oScopeDeclare( decl )
1889:       | true :  % TO DO: check that qParams is consistent with qOldParams
1891:    ]
      
1899:    @MethodModifiers( decl )
1906:    >> decl;
      
      
1910: ProcDecl:
1912:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1918:    [
1918:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1920:       | pExternal : @ExternalDecl( decl )
      
1929:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1936:          Node paramScope = oNodeGet( decl, qParams )
1949:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1955:          int level = oNodeGetInt( paramScope, qLevel )
1968:          oScopeBegin( level, allocDown )
1977:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1988:          Label label = oNodeGetLabel( decl, qValue )
2001:          @Block( nLocalVar, label )
2011:          oNodeSetBoolean( decl, qBodyDefined, true )
2023:          oScopeEnd
      
2024:          oScopeEnd  % paramScope
2025:    ]
2025:    ';';
      
      
      
2028: FuncHeaderDecl >> Node:
2030:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2032:    boolean redeclaring = false
2038:    Node decl = oScopeFindInCurrentScope
      
2043:    [ oNodeNull( decl )
2050:       | true :
               % first declaration
2051:          decl = @newIdent( nFunc, kFunc, LAST_ID )
2067:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2078:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2080:          redeclaring = true
2086:          [ oNodeGetBoolean( decl, qBodyDefined )
2096:             | true : #eAlreadyDefined
2099:             | * :
2104:          ]
2104:          [ oNodeType( decl )
2111:             | nFunc :
2112:             | * : #eAlreadyDefined   % wrong kind
2119:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2119:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2138:          oNodeSet( decl, qParams, Null )
2150:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2169:          oNodeSet( decl, qType, Null )
2181:    ]
      
2189:    int level = @ScopeLevel
2195:    boolean nested = greater( level, 0 )
2208:    inc( level )
2214:    oScopeBegin( level, allocUp )
2223:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2228:    [ nested
2231:       | true :
2232:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2247:       | * :
2252:    ]
      
2252:    @FormalArgDecl
2254:    oNodeSet( decl, qParams, paramScope )
      
2266:    ':'
      
2268:    Node theType
2268:    @TypeRef( theType )
2275:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2287:    Node ptrType = @PointerTypeTo( theType )
2298:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2314:    oScopeEnd
2315:    ';'
      
2317:    [ redeclaring
2320:       | false : oScopeDeclare( decl )
2327:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2329:    ]
      
2337:    @MethodModifiers( decl )
      
2344:    >> decl;
      
      
2348: FuncDecl:
2350:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2356:    [
2356:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2358:       | pExternal : @ExternalDecl( decl )
      
2367:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2374:          Node paramScope = oNodeGet( decl, qParams )
2387:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2393:          int level = oNodeGetInt( paramScope, qLevel )
2406:          oScopeBegin( level, allocDown )
2415:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2426:          Label label = oNodeGetLabel( decl, qValue )
2439:          @Block( nLocalVar, label )
2449:          oNodeSetBoolean( decl, qBodyDefined, true )
2461:          oScopeEnd
      
2462:          oScopeEnd  % paramScope
2463:    ]
2463:    ';';
      
      
2466: FormalArgDecl:
2468:    [
2468:       | '(' :
2470:          {
2470:             NodeVec decls = oNodeVecNew
2475:             Node decl
2475:             boolean isInOut = false
      
2481:             [
2481:                | pVar : isInOut = true
2489:                | * :
2494:             ]
      
2494:             {  pIdent
      
2496:                decl = @newIdent( nParam, kVar, LAST_ID )
2512:                oNodeSetBoolean( decl, qInOut, isInOut )
2524:                oNodeVecAppend( decls, decl )
      
2533:                [
2533:                   | ':' : >
2537:                   | ',' :
2539:                ]
2547:             }
      
2549:             Node theType
2549:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2556:             Node allocType
2556:             [ isInOut
2559:                | true :   allocType = @PointerTypeTo( theType )
2571:                | * :      allocType = theType
2582:             ]
      
2582:             int i = 0
2588:             {[ equal( i, oNodeVecSize( decls ) )
2602:                | false :
2603:                   decl = oNodeVecElement( decls, i )
      
2616:                   oNodeSet( decl, qType, theType )
2628:                   oScopeDeclare( decl )
2634:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2650:                   inc( i )
2656:                | * :
2661:                   >
2663:             ]}
      
2665:             oNodeVecDelete( decls )
      
2671:             [
2671:                | ')' : >
2675:                | ';' :
2677:             ]
2685:          }
2687:       | * :
2692:    ];
      
2693: ConstDecl:
2695:    {[
2695:       | pIdent :
2697:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2713:          '='
      
2715:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2717:          int val = oValueTop
2722:          oValuePop
2723:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2735:          oNodeSet( decl, qType, IntegerType )
      
2747:          oScopeDeclare( decl )
2753:          ';'
2755:       | * :
2760:          >
2762:    ]};
      
2765: TypeDecl:
2767:    {[
2767:       | pIdent :
2769:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2785:          '='
2787:          Node theType
2787:          @TypeRef( theType )
2794:          oNodeSet( decl, qType, theType )
2806:          oScopeDeclare( decl )
2812:          ';'
2814:       | * :
2819:          >
2821:    ]};
      
2824: VarDecl( node_type varNodeType ):
2826:    {[
2826:       | pIdent :
2828:          NodeVec decls = oNodeVecNew
2833:          Node decl
2833:          {
2833:             decl = @newIdent( varNodeType, kVar, LAST_ID )
2849:             oNodeVecAppend( decls, decl )
2858:             [
2858:                | ',' :
2860:                   pIdent
2862:                | * :
2867:                   >
2869:             ]
2869:          }
2871:          ':'
2873:          Node theType
2873:          @TypeRef( theType )
      
2880:          int i = 0
2886:          {[ equal( i, oNodeVecSize( decls ) )
2900:             | false :
2901:                decl = oNodeVecElement( decls, i )
2914:                oNodeSet( decl, qType, theType )
2926:                oScopeDeclareAlloc( decl )
2932:                inc( i )
2938:             | * :
2943:               >
2945:          ]}
      
               % optional initialization
2947:          [
2947:             | '=' :
2949:                [ oNodeVecSize( decls )
2956:                   | 1 :
2957:                   | * :  #eOnlyOneVarCanBeInitialized
2964:                ]
      
                     % we need an initCode stream for this scope
2964:                Code initCode = @GetOrCreateInitCode
2970:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
2976:                boolean changedScope = false
2982:                [ equal_zero( @ScopeLevel )
2989:                   | true : oScopeEnter( initScope )
2996:                            changedScope = true
3002:                   | * :
3007:                ]
                     % generate assignment in initCode stream
3007:                @LValueVar( decl )
3014:                @Expr
3016:                @MatchTypes
3018:                @Assign
3020:                [ changedScope
3023:                   | true : oScopeEnd
3025:                   | * :
3030:                ]
3030:                oCodePop
                   
3031:             | * :
3036:          ]
      
3036:          oNodeVecDelete( decls )
3042:          ';'
3044:       | * :
3049:          >
3051:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3054: TypeRef( out Node resultType ):
3056:    [
3056:       | pIdent :           % previously named type (including intrinsics)
3058:          Node decl = oScopeFindRequire
3063:          [ oNodeType( decl )
3070:            | nTypeDecl :
3071:                resultType = oNodeGet( decl, qType )
3084:            | * :
3089:                #eNotType
3091:                resultType = IntegerType
3097:          ]
         
3097:       | pArray :
3099:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3101:          NodeVec dimensions = oNodeVecNew
      
3106:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3106:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3116:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3128:             @ConstExpr
3130:             oNodeSetInt( subrange, qLow, oValueTop )
3141:             oValuePop
3142:             '..'
3144:             @ConstExpr
3146:             oNodeSetInt( subrange, qHigh, oValueTop )
3157:             oValuePop
3158:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3170:             oTypeAdd( subrange )
      
3176:             Node a = oNodeNew( nArrayType )
3186:             oNodeSet( a, qIndexType, subrange )
      
3198:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3207:             [
3207:                | ']' : >
3211:                | ',' :
3213:             ]
3221:          }
      
3223:          pOf
3225:          Node baseType
3225:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3232:          int dim = oNodeVecSize( dimensions )
      
3242:          {
3242:              dec(dim)
      
3248:              Node a = oNodeVecElement( dimensions, dim )
      
3261:              oNodeSet( a, qBaseType, baseType )
3273:              Node subrange = oNodeGet( a, qIndexType )
3286:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3313:              inc( width )
3319:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3345:              oTypeAdd( a )
3351:              baseType = a
      
3357:              [ equal_zero(dim)
3364:                  | true:  >
3367:                  | *:
3372:              ]
3372:          }
      
3374:          resultType = oNodeVecElement( dimensions, 0 )
3387:          oNodeVecDelete( dimensions )
      
3393:       | '^' :
3395:          Node theType
3395:          @TypeRef( theType )
3402:          resultType = @PointerTypeTo( theType )
      
3413:       | pRecord :
3415:          resultType = oNodeNew( nRecordType )
3425:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3434:          @VarDecl( nRecordField )
      
3441:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3453:          [ equal_zero( size )
3460:             | true : #eRecordEmpty
3463:             | * :
3468:          ]
      
3468:          pEnd
      
3470:          oNodeSet( resultType, qScope, oScopeCurrent )
3481:          oNodeSetInt( resultType, qSize, size )
3493:          oScopeEnd
3494:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3500:       | pSet :
3502:          pOf
3504:          Node theType
3504:          @TypeRef( theType )
3511:       | * :       % this works for cases except where expr starts with an id
3524:          @ConstExpr '..' @ConstExpr
3530:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3531: ConstExpr:
3533:    [
3533:       | pIntLit :
3535:          oValuePush( TOKEN_VALUE )
3540:       | pIdent :
3542:          Node decl = oScopeFindRequire
3547:          [ oNodeType( decl )
3554:             | nConst :
3555:                oValuePush( oNodeGetInt( decl, qValue ) )
3568:             | * :
3573:                #eNotConst
3575:                oValuePush( 0 )
3581:          ]
3581:       | pMinus :
3583:          @ConstExpr
3585:          oValueNegate
3586:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3597: Expr:
3599:    Label falseLabel = labelNull
      
3605:    @ExprAllowCF( falseLabel )
3612:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3620: BooleanExprControlFlow( out Label falseLabel ):
3622:    @ExprAllowCF( falseLabel )
3629:    [ oTypeSNodeType
3631:       | nBooleanCFType :
3632:       | nBooleanType :
               % convert value to control flow
3634:          falseLabel = oLabelNew
3639:          .tJumpFalse  oEmitLabel( falseLabel )
3647:       | * :
3654:          #eNotBoolean
3656:    ]
3656:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3658: CFToVal( inout Label falseLabel ):
3660:    [ oTypeSNodeType
3662:       | nBooleanCFType :
3663:          Label doneLabel = oLabelNew
3668:          .tPushConstI  oEmitInt( 1 )
3676:          .tJump  oEmitLabel( doneLabel )
3684:          .tLabel  oEmitLabel( falseLabel )
3692:          .tPushConstI  oEmitInt( 0 )
3700:          .tLabel  oEmitLabel( doneLabel )
3708:          oTypeSPop
3709:          oTypeSPush( BooleanType )
3715:          falseLabel = labelNull
3721:       | * :
3726:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3727: ValToCF( out Label falseLabel ):
3729:    [ oTypeSNodeType
3731:       | nBooleanType :
3732:          falseLabel = oLabelNew
3737:          .tJumpFalse  oEmitLabel( falseLabel )
3745:          oTypeSPop
3746:          oTypeSPush( BooleanCFType )
3752:       | * :
3757:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3758: ExprAllowCF( out Label falseLabel ):
3760:    @BoolExprAllowCF( falseLabel )
3767:    {[
3767:       | '=' :
3769:          @CFToVal( falseLabel )
3776:          @BoolExprAllowCF( falseLabel )
3783:          @CFToVal( falseLabel )
3790:          @MatchTypes
3792:          [ oTypeSNodeType
3794:             | nIntegerType, nBooleanType :  .tEqualI
3797:             | nPointerType :                .tEqualP
3801:             | nCharType, nStringType :      #eNotImplemented
3805:             | * :                           #eNotAllowed
3820:          ]
3820:          oTypeSPop
3821:          oTypeSPush( BooleanType )
      
3827:       | '<>' :
3829:          @CFToVal( falseLabel )
3836:          @BoolExprAllowCF( falseLabel )
3843:          @CFToVal( falseLabel )
3850:          @MatchTypes
3852:          [ oTypeSNodeType
3854:             | nIntegerType, nBooleanType :  .tNotEqualI
3857:             | nPointerType :                .tNotEqualP
3861:             | nCharType, nStringType :      #eNotImplemented
3865:             | * :                           #eNotAllowed
3880:          ]
3880:          oTypeSPop
3881:          oTypeSPush( BooleanType )
      
3887:       | '<' :
3889:          @CFToVal( falseLabel )
3896:          @BoolExprAllowCF( falseLabel )
3903:          @CFToVal( falseLabel )
3910:          @MatchTypes
3912:          [ oTypeSNodeType
3914:             | nIntegerType, nBooleanType :  .tLessI
3917:             | nCharType, nStringType :      #eNotImplemented
3921:             | * :                           #eNotAllowed
3934:          ]
3934:          oTypeSPop
3935:          oTypeSPush( BooleanType )
      
3941:       | '>' :
3943:          @CFToVal( falseLabel )
3950:          @BoolExprAllowCF( falseLabel )
3957:          @CFToVal( falseLabel )
3964:          @MatchTypes
3966:          [ oTypeSNodeType
3968:             | nIntegerType, nBooleanType :  .tGreaterI
3971:             | nCharType, nStringType :      #eNotImplemented
3975:             | * :                           #eNotAllowed
3988:          ]
3988:          oTypeSPop
3989:          oTypeSPush( BooleanType )
      
3995:       | '<=' :
3997:          @CFToVal( falseLabel )
4004:          @BoolExprAllowCF( falseLabel )
4011:          @CFToVal( falseLabel )
4018:          @MatchTypes
4020:          [ oTypeSNodeType
4022:             | nIntegerType, nBooleanType :  .tLessEqualI
4025:             | nCharType, nStringType :      #eNotImplemented
4029:             | * :                           #eNotAllowed
4042:          ]
4042:          oTypeSPop
4043:          oTypeSPush( BooleanType )
      
4049:       | '>=' :
4051:          @CFToVal( falseLabel )
4058:          @BoolExprAllowCF( falseLabel )
4065:          @CFToVal( falseLabel )
4072:          @MatchTypes
4074:          [ oTypeSNodeType
4076:             | nIntegerType, nBooleanType :  .tGreaterEqualI
4079:             | nCharType, nStringType :      #eNotImplemented
4083:             | * :                           #eNotAllowed
4096:          ]
4096:          oTypeSPop
4097:          oTypeSPush( BooleanType )
      
4103:       | * :
4118:          >
4120:    ]};
      
      
4123: BoolExprAllowCF( out Label falseLabel ):
4125:    Label trueLabel = labelNull
      
4131:    @BoolTermAllowCF( falseLabel )
4138:    {[
4138:       | pOr :
4140:          [ oTypeSNodeType
4142:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4143:                [ equal_label( trueLabel, labelNull )
4153:                   | true :  trueLabel = oLabelNew
4159:                   | * :
4164:                ]
4164:                .tJump  oEmitLabel( trueLabel )
4172:             | nBooleanType :
4174:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4181:                [ equal_label( trueLabel, labelNull )
4191:                   | true :  trueLabel = oLabelNew
4197:                   | * :
4202:                ]
4202:                .tJump  oEmitLabel( trueLabel )
4210:             | * : #eNotBoolean
4219:          ]
4219:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4220:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4228:          falseLabel = labelNull
4234:          @BoolTermAllowCF( falseLabel )
      
4241:          [ oTypeSNodeType
4243:             | nBooleanCFType :
4244:             | nBooleanType :
4246:                @ValToCF( falseLabel )
4253:             | * : #eNotBoolean
4262:          ]
      
4262:          oTypeSPop
4263:          oTypeSPush( BooleanCFType )
      
4269:       | * :
4274:          >
4276:    ]}
      
         % any short-circuit trues jump here to the end
4278:    [ equal_label( trueLabel, labelNull )
4288:       | false :
4289:          .tLabel  oEmitLabel( trueLabel )
4297:       | * :
4302:    ]
4303:    ;
      
      
4303: BoolTermAllowCF( out Label falseLabel ):
4305:    Label overallFalseLabel = labelNull
      
4311:    @BoolFactorAllowCF( falseLabel )
4318:    {[
4318:       | pAnd :
4320:          [ oTypeSNodeType
4322:             | nBooleanCFType :
4323:             | nBooleanType :
4325:                @ValToCF( falseLabel )
4332:             | * :
4339:                #eNotBoolean
4341:          ]
4341:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
4342:          [ equal_label( overallFalseLabel, labelNull )
4352:             | true :
4353:                overallFalseLabel = oLabelNew
4358:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
4372:                falseLabel = overallFalseLabel
4378:             | * :
4383:          ]
      
4383:          Label factorFalseLabel = labelNull
4389:          @BoolFactorAllowCF( factorFalseLabel )
      
4396:          [ oTypeSNodeType
4398:             | nBooleanCFType :
4399:             | nBooleanType :
4401:                @ValToCF( factorFalseLabel )
4408:             | * : #eNotBoolean
4417:          ]
4417:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
4431:       | * :
4436:          >
4438:    ]};
      
4441: BoolFactorAllowCF( out Label falseLabel ):
4443:    [
4443:       | pNot :
4445:          Label factorFalseLabel = labelNull
      
4451:          @BoolFactorAllowCF( factorFalseLabel )
4458:          [ oTypeSNodeType
4460:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4461:                falseLabel = oLabelNew
4466:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4474:                .tLabel  oEmitLabel( factorFalseLabel )
      
4482:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4484:                .tNot
      
4486:             | * : #eNotBoolean
4495:          ]
      
4495:       | * :
4500:          @ArithExprAllowCF( falseLabel )
4507:    ];
      
4508: ArithExprAllowCF( out Label falseLabel ):
4510:    @TermAllowCF( falseLabel )
4517:    {[
4517:       | pPlus :
4519:          @RequireIntPop
4521:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4528:          @RequireInt
4530:          .tAddI
4532:       | pMinus :
4534:          @RequireIntPop
4536:          @TermAllowCF( falseLabel )
4543:          @RequireInt
4545:          .tSubI
4547:       | * :
4554:          >
4556:    ]};
      
4559: TermAllowCF( out Label falseLabel ):
4561:    @FactorAllowCF( falseLabel )
4568:    {[
4568:       | pTimes :
4570:          @RequireIntPop
4572:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4579:          @RequireInt
4581:          .tMultI
4583:       | pDivide :
4585:          @RequireIntPop
4587:          @FactorAllowCF( falseLabel )
4594:          @RequireInt
4596:          .tDivI
4598:       | * :
4605:          >
4607:    ]};
      
4610: FactorAllowCF( out Label falseLabel ):
4612:    [
4612:       | pPlus :
4614:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4621:          @RequireInt
4623:       | pMinus :
4625:          @PrimaryAllowCF( falseLabel )
4632:          @RequireInt
4634:          .tNegI
4636:       | * :
4643:          @PrimaryAllowCF( falseLabel )
4650:    ];
      
4651: PrimaryAllowCF( out Label falseLabel ):
4653:    [
4653:       | pIntLit :
4655:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4662:          oTypeSPush( IntegerType )
      
4668:       | '(' :
4670:          @ExprAllowCF( falseLabel )
4677:          ')'
      
4679:       | pStrLit :
4681:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4690:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4698:          oTypeSPush( StringType )
      
4704:       | pIdent :
4706:          Node decl = oScopeFindRequire
4711:          Node theType
      
4711:          [ oNodeType( decl )
4718:             | nFunc :
      
4719:                @Call( decl )
      
4726:             | nConst :
4728:                theType = oNodeGet( decl, qType )
4741:                oTypeSPush( theType )
4747:                [ oTypeSNodeType
4749:                   | nIntegerType, nBooleanType :
4750:                      .tPushConstI @EmitValue( decl )
4759:                   | * :
4766:                      #eNotImplemented
4768:                ]
      
4768:             | nGlobalVar, nLocalVar, nParam :
4770:                @VarExpr( decl )
      
4777:             | * :
4790:                #eNotValue
4792:                oTypeSPush( IntegerType )
4798:          ]
      
4798:       | '@' :        % @var -- pointer to var
4800:          pIdent
      
4802:          Node decl = oScopeFindRequire
4807:          Node theType
      
4807:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
4814:          theType = oTypeSTop
4819:          oTypeSPop
4820:          Node ptrType = @PointerTypeTo( theType )
4831:          oTypeSPush( ptrType )
      
4837:       | * :
4850:          #eNotValue
4852:          oTypeSPush( IntegerType )
4858:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
4859: VarExpr( Node decl ):
4861:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
4874:    int uplevels = @DeclUpLevels( decl )
      
4885:    oTypeSPush( theType )
4891:    [ oTypeSNodeType
4893:       | nIntegerType :
4894:          [ oNodeType( decl )
4901:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
4911:             | nLocalVar :
4913:                [ equal_zero( uplevels )
4920:                   | true :  .tPushLocalI  @EmitValue( decl )
4930:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
4950:                ]
4950:             | nParam :
4952:                [ oNodeGetBoolean( decl, qInOut )
4962:                   | true :    % VAR param points to the var.  Auto dereference.
4963:                      [ equal_zero( uplevels )
4970:                         | true :  .tPushParamP  @EmitValue( decl )
4980:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5000:                      ]
5000:                      .tFetchI
5002:                   | * :
5007:                      [ equal_zero( uplevels )
5014:                         | true :  .tPushParamI  @EmitValue( decl )
5024:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5044:                      ]
5044:                ]
5044:          ]
      
5054:       | nBooleanType :
5056:          [ oNodeType( decl )
5063:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5073:             | nLocalVar :
5075:                [ equal_zero( uplevels )
5082:                   | true :  .tPushLocalB  @EmitValue( decl )
5092:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5112:                ]
5112:             | nParam :
5114:                [ oNodeGetBoolean( decl, qInOut )
5124:                   | true :    % VAR param points to the var.  Auto dereference.
5125:                      [ equal_zero( uplevels )
5132:                         | true :  .tPushParamP  @EmitValue( decl )
5142:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5162:                      ]
5162:                      .tFetchB
5164:                   | * :
5169:                      [ equal_zero( uplevels )
5176:                         | true :  .tPushParamB  @EmitValue( decl )
5186:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5206:                      ]
5206:                ]
5206:          ]
      
5216:       | nCharType, nStringType, nFileType :
5218:          #eNotImplemented
      
5220:       | nPointerType :
5222:          [ oNodeType( decl )
5229:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5239:             | nLocalVar :
5241:                [ equal_zero( uplevels )
5248:                   | true :  .tPushLocalP  @EmitValue( decl )
5258:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
5278:                ]
5278:             | nParam :
5280:                [ oNodeGetBoolean( decl, qInOut )
5290:                   | true :    % VAR param points to the var.  Auto dereference.
5291:                      [ equal_zero( uplevels )
5298:                         | true :  .tPushParamP  @EmitValue( decl )
5308:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5328:                      ]
5328:                      .tFetchP
5330:                   | * :
5335:                      [ equal_zero( uplevels )
5342:                         | true :  .tPushParamP  @EmitValue( decl )
5352:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5372:                      ]
5372:                ]
5372:          ]
5382:          [
5382:             | '^' :             % dereferenced
5384:                oTypeSPop
5385:                oTypeSPush( oNodeGet( theType, qBaseType ) )
5398:                @LValueIndexes
5400:                @FetchVar
5402:             | * :               % just ptr value alone
5407:          ]
      
5407:       | * :
               % compound type
               % first, push addr of start of var
5422:          [ oNodeType( decl )
5429:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5439:             | nLocalVar :
5441:                [ equal_zero( uplevels )
5448:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5458:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5478:                ]
5478:             | nParam :
5480:                [ oNodeGetBoolean( decl, qInOut )
5490:                   | true :    % VAR param points to the var.  Auto dereference.
5491:                      [ equal_zero( uplevels )
5498:                         | true :  .tPushParamP  @EmitValue( decl )
5508:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5528:                      ]
5528:                   | * :
5533:                      [ equal_zero( uplevels )
5540:                         | true :  .tPushAddrParam  @EmitValue( decl )
5550:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5570:                      ]
5570:                ]
5570:          ]
               % modify addr for subscripts, field references, etc
5580:          @LValueIndexes
               % get final value
5582:          @FetchVar
5584:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5585: FetchVar:
5587:    [ oTypeSNodeType
5589:       | nIntegerType :   .tFetchI
5592:       | nBooleanType :   .tFetchB
5596:       | nCharType, nStringType, nFileType : #eNotImplemented
5600:       | nPointerType :   .tFetchP
5604:       | * :              % compound type; leave as addr
5619:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5620: LValueIndexes:
5622:    {[
5622:       | '[' :       @ArraySubscripts
5626:       | '.' :       @RecordFieldRef
5630:       | '^' :       @PointerDeref
5634:       | * :         >
5645:    ]};
      
5648: ArraySubscripts:
5650:    [ oTypeSNodeType
5652:       | nArrayType :
5653:       | * :       #eNotArray
5660:    ]
5660:    {
5660:       [ oTypeSNodeType
5662:          | nArrayType :
5663:          | * :    #eTooManySubscripts
5670:       ]
      
            % low subscript of this dimension
5670:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5687:       Node baseType
5687:       baseType = oNodeGet( oTypeSTop, qBaseType )
5699:       oTypeSPop
5700:       oTypeSPush( baseType )
      
5706:       @Expr
5708:       @RequireIntPop
            % adjust for low subscript
5710:       [ equal_zero( low )
5717:          | false :
5718:             .tPushConstI oEmitInt( low ) .tSubI
5728:          | * :
5733:       ]
      
            % multiply by element size
5733:       int size = oNodeGetInt( baseType, qSize )
5746:       [ equal( size, 1 )
5756:          | false :
5757:             .tPushConstI oEmitInt( size ) .tMultI
5767:          | * :
5772:       ]
      
            % update start address
5772:       .tAddPI
5774:       [
5774:          | ']' :  >
5778:          | ',' :
5780:       ]
5788:    };
      
      
5791: RecordFieldRef:
5793:    [ oTypeSNodeType
5795:       | nRecordType :
5796:       | * :    #eNotRecord
5803:    ]
5803:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
5815:    pIdent
5817:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
5822:    [ oNodeType( field )
5829:       | nRecordField :
5830:       | * :   #eNotRecordField
5837:    ]
5837:    oScopeEnd
5838:    int offset = oNodeGetInt( field, qValue )
5851:    [ equal_zero( offset )
5858:       | false :
5859:          .tPushConstI oEmitInt( offset ) .tAddPI
5869:       | * :
5874:    ]
      
         % replace the type on the type stack, with the field type
5874:    oTypeSPop
5875:    oTypeSPush( oNodeGet( field, qType ) )
5889:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
5889: PointerDeref:
5891:    [ oTypeSNodeType
5893:       | nPointerType :
5894:       | * :       #eNotPointer
5901:    ]
5901:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
5903:    Node theType = oTypeSTop
5908:    oTypeSPop
5909:    oTypeSPush( oNodeGet( theType, qBaseType ) )
5923:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
5923: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
5925:    @MatchTypes
5928:    ;
      
      
      % Called on first use of an extern method
      %
5928: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
5930:    int strAddr
5930:    String externalName = oNodeGetString( method, qExternalName )
5943:    [ equal_string( externalName, stringNull )
5953:       | true :
5954:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
5975:       | false :
5977:          strAddr = oStringAllocLit( externalName )
5987:    ]
5995:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6011:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6011: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6013:    [ oNodeGetBoolean( method, qExternal )
6023:       | true :
6024:          [ oNodeGetBoolean( method, qCalled )
6034:             | false :
                     % define the extern label on first use
6035:                @DefineExternLabel( method )
6042:             | * :
6047:          ]
6047:      | * :
6052:    ]
6052:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6064:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6077:    Node resultType
6077:    int tempOffset
      
6077:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6094:    [ isFunc
6097:       | true :
6098:          resultType = oNodeGet( method, qType )
6111:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6121:       | * :
6126:    ]
         
      
6126:    Node paramScope = oNodeGet( method, qParams )
6139:    int actualsSize = oNodeGetInt( paramScope, qSize )
6152:    [ cdecl
6155:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6164:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6174:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6182:    [ greater( @DeclLevel( method ), 0 )
6197:       | true :
6198:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6206:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6225:          .tAssignP
6227:       | * :
6232:    ]
      
      
6232:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6245:    Node param = oNodeIterValue( paramIter )
6255:    [
6255:       | '(' :
            
6257:          {
6257:             [ oNodeNull( param )
6264:                | true : >
6267:                | * :
6272:             ]
      
6272:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
6285:             .tPushAddrActual oEmitInt( offset )
6293:             oTypeSPush( oNodeGet( param, qType ) )
      
6306:             [ oNodeGetBoolean( param, qInOut )
6316:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
6317:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
6319:                           @MatchTypes
      
6321:                           .tAssignP
      
6323:                | false :  @Expr
6327:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
6329:                           [ oTypeSNodeType
6331:                              | nIntegerType :            .tAssignI
6334:                              | nBooleanType :            .tAssignB
6338:                              | nCharType, nStringType, nFileType :   #eNotImplemented
6342:                              | nPointerType :            .tAssignP
6346:                              | * :
                                       % compound types: copy value into actuals space
6361:                                  int size = oNodeGetInt( oTypeSTop, qSize )
6373:                                  .tCopy  oEmitInt( size )    % multi-word copy
6381:                           ]
6381:             ]
6389:             oTypeSPop
      
6390:             oNodeIterNext( paramIter )
6396:             param = oNodeIterValue( paramIter )
6406:             [ oNodeNull( param )
6413:                | true :  >
6416:                | false :
6418:             ]
      
6426:             ','
6428:          }
      
6430:          ')'
      
6432:       | * :
6437:    ]
      
6437:    [ oNodeNull( param )
6444:       | false :    #eMissingParameter
6447:       | * :
6452:    ]
      
6452:    [ isFunc
6455:       | true :
               % Pass result temp as an additional VAR parameter.
6456:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6471:          .tPushAddrLocal  oEmitInt( tempOffset )
6479:          .tAssignP
6481:       | * :
6486:    ]
      
6486:    [ cdecl
6489:       | true :
6490:          .tCallCdecl  @EmitValue( method )
6499:       | false :
6501:          .tCall   @EmitValue( method )
6510:    ]
      
6518:    [ isFunc
6521:       | true :
               % push return value from temp
6522:          oTypeSPush( resultType )
      
6528:          [ oTypeSNodeType
6530:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6539:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6549:             | nCharType, nStringType, nFileType : #eNotImplemented
6553:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6563:             | * :              % compound type: push address
6578:                                .tPushAddrLocal  oEmitInt( tempOffset )
6586:          ]
6586:       | * :
6591:    ]
         
6591:    .tFreeActuals  oEmitInt( actualsSize )
6600:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6600: Statement:
6602:    [
6602:       | pWriteln :     @WritelnStmt
6606:       | pWrite :       @WriteStmt
6610:       | pReadln :      @ReadlnStmt
6614:       | pRead :        @ReadStmt
6618:       | pIf :          @IfStmt
6622:       | pWhile :       @WhileStmt
6626:       | pFor :         @ForStmt
6630:       | pRepeat :      @RepeatStmt
6634:       | pBreak :       @BreakStmt
6638:       | pContinue :    @ContinueStmt
6642:       | pBegin :       @BeginStmt
6646:       | pIdent :       @AssignOrCallStmt
6650:       | * :            % null statement : don't accept any tokens
6677:    ];
      
      
6678: AssignOrCallStmt:
6680:    Node decl = oScopeFindRequire
6685:    [ oNodeType( decl )
6692:       | nProc :                           @Call( decl )
6700:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6709:       | nFunc :                           @AssignResultStmt( decl )
6718:       | * :                               #eBadStatement
6733:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6734: AssignStmt( Node decl ):
      
6736:    @LValueVar( decl )
6743:    ':=' 
6745:    @Expr
6747:    @MatchTypes
6749:    @Assign
6752:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6752: Assign:
6754:    [ oTypeSNodeType
6756:       | nIntegerType :            .tAssignI
6759:       | nBooleanType :            .tAssignB
6763:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6767:       | nPointerType :            .tAssignP
6771:       | * :
6786:           int size = oNodeGetInt( oTypeSTop, qSize )
6798:           .tCopy  oEmitInt( size )    % multi-word copy
6806:    ]
6806:    oTypeSPop
6808:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
6808: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
6810:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
6826:       | false :   #eNotCurrentFunction
6829:       | * :
6834:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
6834:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
6849:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
6862:    ':='
6864:    @Expr
6866:    @MatchTypes
6868:    [ oTypeSNodeType
6870:       | nIntegerType :            .tAssignI
6873:       | nBooleanType :            .tAssignB
6877:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6881:       | nPointerType :            .tAssignP
6885:       | * :
6900:           int size = oNodeGetInt( oTypeSTop, qSize )
6912:           .tCopy  oEmitInt( size )    % multi-word copy
6920:    ]
6920:    oTypeSPop
6922:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
6922: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
6924:    pIdent
6926:    Node decl = oScopeFindRequire
6931:    [ oNodeType( decl )
6938:       | nGlobalVar, nLocalVar, nParam :
6939:       | * :  #eNotVar
6950:    ]
6950:    @LValueVar( decl )
6958:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
6958: LValueVar( Node decl ):
6960:    [ oNodeType( decl )
6967:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6977:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
6988:       | nParam :
6990:          [ oNodeGetBoolean( decl, qInOut )
7000:             | true :   % VAR param points to variable.  No dereference.
7001:                        .tPushParamP @EmitValue( decl )
7010:             | * :      .tPushAddrParam @EmitValue( decl )
7024:          ]
7024:       | * :            #eNotVar
7035:    ]
      
7035:    oTypeSPush( oNodeGet( decl, qType ) )
7048:    @LValueIndexes        % handle subscripts, if any
7051:    ;
      
      
7051: IncVar( Node decl ):
7053:    @LValueVar( decl )
7060:    @RequireIntPop
7062:    @VarExpr( decl )
7069:    oTypeSPop
7070:    .tIncI
7072:    .tAssignI;
      
7075: DecVar( Node decl ):
7077:    @LValueVar( decl )
7084:    @RequireIntPop
7086:    @VarExpr( decl )
7093:    oTypeSPop
7094:    .tDecI
7096:    .tAssignI;
      
      
7099: IfStmt:
7101:    Label falseLabel = labelNull
      
7107:    @BooleanExprControlFlow( falseLabel )
7114:    pThen
7116:    @Statement
7118:    [
7118:       | pElse :
7120:          Label doneLabel = oLabelNew
      
7125:          .tJump  oEmitLabel( doneLabel )
7133:          .tLabel oEmitLabel( falseLabel )
7141:          @Statement
7143:          .tLabel oEmitLabel( doneLabel )
      
7151:       | * :
7156:          .tLabel oEmitLabel( falseLabel )
7164:    ];
      
      
7165: ForStmt:
7167:    pIdent
      
7169:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
7174:    @LValueVar( decl )
7181:    @RequireIntPop
      
7183:    ':='
      
7185:    @Expr
7187:    @RequireIntPop
7189:    .tAssignI
      
7191:    Label breakLabel = oLabelNew
      
7196:    Label checkLabel = oLabelNew
7201:    .tJump  oEmitLabel( checkLabel )
      
7209:    Label continueLabel = oLabelNew
7214:    .tLabel  oEmitLabel( continueLabel )
7222:    [
7222:       | pTo :
7224:          @IncVar( decl )
7231:          .tLabel  oEmitLabel( checkLabel )
7239:          @VarExpr( decl )  oTypeSPop
7247:          @Expr
7249:          @RequireIntPop
7251:          .tGreaterI
7253:          .tJumpTrue  oEmitLabel( breakLabel )
7261:       | pDownto :
7263:          @DecVar( decl )
7270:          .tLabel  oEmitLabel( checkLabel )
7278:          @VarExpr( decl )  oTypeSPop
7286:          @Expr
7288:          @RequireIntPop
7290:          .tLessI
7292:          .tJumpTrue  oEmitLabel( breakLabel )
7300:    ]
7308:    oLoopPush( continueLabel, breakLabel )
7317:    pDo
7319:    @Statement
7321:    .tJump  oEmitLabel( continueLabel )
7329:    .tLabel  oEmitLabel( breakLabel )
7337:    oLoopPop;
      
      
7339: RepeatStmt:
7341:    Label continueLabel = oLabelNew
7346:    .tLabel  oEmitLabel( continueLabel )
      
7354:    Label breakLabel = oLabelNew
      
7359:    oLoopPush( continueLabel, breakLabel )
7368:    @Statement
7370:    {[
7370:       | ';' :
7372:          @Statement
7374:       | pUntil :
7376:          Label falseLabel
7376:          @BooleanExprControlFlow( falseLabel )
7383:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
7397:          >
7399:    ]}
7409:    .tLabel  oEmitLabel( breakLabel )
7417:    oLoopPop;
      
      
7419: WhileStmt:
7421:    Label continueLabel = oLabelNew
7426:    .tLabel  oEmitLabel( continueLabel )
      
7434:    Label breakLabel
7434:    @BooleanExprControlFlow( breakLabel )
      
7441:    oLoopPush( continueLabel, breakLabel )
7450:    pDo
7452:    @Statement
7454:    .tJump  oEmitLabel( continueLabel )
7462:    .tLabel  oEmitLabel( breakLabel )
7470:    oLoopPop;
      
      
7472: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7474:    [ equal_label( oLoopContinueLabel, labelNull )
7483:       | true :
7484:          #eNotInALoop
7486:       | false :
7488:          .tJump  oEmitLabel( oLoopContinueLabel )
7495:    ];
      
      
7504: BreakStmt:
7506:    [ equal_label( oLoopBreakLabel, labelNull )
7515:       | true :
7516:          #eNotInALoop
7518:       | false :
7520:          .tJump  oEmitLabel( oLoopBreakLabel )
7527:    ];
      
      
7536: BeginStmt:
7538:    @Statement
7540:    {[
7540:       | ';' :   @Statement
7544:       | pEnd :  >
7548:    ]};
      
      
7559: WritelnStmt:
7561:    @WriteStmt
7563:    .tWriteCR;
      
      
7566: WriteStmt:
7568:    [
7568:       | '(' :
7570:          {
7570:             @Expr
7572:             [ oTypeSNodeType
7574:                | nIntegerType :             .tWriteI
7577:                | nBooleanType :             .tWriteBool
7581:                | nStringType :              .tWriteStr
7585:                | nCharType, nFileType :     #eNotImplemented
7589:                | nPointerType :             .tWriteP
7593:                | * :                        #eNotAllowed
7610:             ]
7610:             oTypeSPop
7611:             [
7611:                | ')' : >
7615:                | ',' :
7617:             ]
7625:          }
7627:       | * :
7632:    ];
      
      
7633: ReadlnStmt:      % ***
         % TO DO
7636:    ;
      
7636: ReadStmt:
         % TO DO
7639:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7639: ScopeLevel >> int:
7641:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7651: DeclLevel( Node decl ) >> int:
7653:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7671: DeclUpLevels( Node decl ) >> int:
7673:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7689: MatchTypes:
7691:    node_type nt = oTypeSNodeType
7696:    oTypeSPop
7697:    [ equal_node_type( nt, oTypeSNodeType )
7706:       | false :
7707:          #eTypeMismatch
7709:       | * :
7714:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7715: RequireIntPop:
7717:    [ oTypeSNodeType
7719:       | nIntegerType :
7720:       | * :          #eNotInteger
7727:    ]
7727:    oTypeSPop;
      
7729: RequireInt:
7731:    [ oTypeSNodeType
7733:       | nIntegerType :
7734:       | * :          #eNotInteger
7741:    ];
      
7742: RequireBoolPop:
7744:    [ oTypeSNodeType
7746:       | nBooleanType :
7747:       | * :          #eNotBoolean
7754:    ]
7754:    oTypeSPop;
      
7756: RequireBool:
7758:    [ oTypeSNodeType
7760:       | nBooleanType :
7761:       | * :          #eNotBoolean
7768:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7769: newType( node_type nt, int size ) >> Node:
7771:   Node node = oNodeNew( nt )
7781:   oNodeSetInt( node, qSize, size )
7793:   oTypeAdd( node )
7799:   >> node
7803:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
7803: newIdent( node_type nt, kind k, int id ) >> Node:
7805:   Node t = oNodeNew( nt )
7815:   oNodeSetInt( t, qIdent, id )
7827:   >> t
7831:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
7831: PointerTypeTo( Node theType ) >> Node:
7833:    Node ptrType = oNodeGet( theType, qPointerType )
7846:    [ oNodeNull( ptrType )
7853:       | true :
7854:          ptrType = oNodeNew( nPointerType )
7864:          oNodeSet( ptrType, qBaseType, theType )
7876:          oNodeSetInt( ptrType, qSize, 8 )
7888:          oTypeAdd( ptrType )
7894:          oNodeSet( theType, qPointerType, ptrType )
7906:       | * :
7911:    ]
7911:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
7915: OrdinalLow( Node theType ) >> int:
7917:    [ oNodeType( theType )
7924:       | nIntegerType :  >> oMININT
7927:       | nBooleanType :  >> 0
7932:       | nCharType :     >> 0
7937:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
7949:       | * :             #eNotOrdinalType
7962:                         >> 0
7965:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
7966: EmitValue( Node decl ):
7968:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
7982: installBuiltIns:
      
         % install built-in types
7984:    FileType = @newType( nFileType, 4 )
7998:    IntegerType = @newType( nIntegerType, 4 )
8012:    BooleanType = @newType( nBooleanType, 1 )
8026:    BooleanCFType = @newType( nBooleanCFType, 1 )
8040:    CharType = @newType( nCharType, 1 )
8054:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8068:    Node t
      
8068:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
8084:    oNodeSet( t, qType, FileType )
8096:    oScopeDeclare( t )
      
8102:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
8118:    oNodeSet( t, qType, IntegerType )
8130:    oScopeDeclare( t )
      
8136:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
8152:    oNodeSet( t, qType, BooleanType )
8164:    oScopeDeclare( t )
      
8170:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
8186:    oNodeSet( t, qType, CharType )
8198:    oScopeDeclare( t )
      
8204:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
8220:    oNodeSet( t, qType, StringType )
8232:    oScopeDeclare( t )
      
         % Built-in constants
      
8238:    t = @newIdent( nConst, kConst, oIdAdd_True )
8254:    oNodeSet( t, qType, BooleanType )
8266:    oNodeSetInt( t, qValue, 1 )
8278:    oScopeDeclare( t )
      
8284:    t = @newIdent( nConst, kConst, oIdAdd_False )
8300:    oNodeSet( t, qType, BooleanType )
8312:    oNodeSetInt( t, qValue, 0 )
8324:    oScopeDeclare( t )
      
8331:    ;
      
8331: end
      
8331: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 6
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 7982
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 181
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 14
 110: oPushResult
 111: oSetResult 6
 113: oPushResult
 114: LAST_ID
 115: oPushResult
 116: oCall 7803
 118: oPop 3
 120: oAssign
 121: oGetLocal 1
 123: oPushResult
 124: oSetResult 20
 126: oPushResult
 127: oGetGlobal 3
 129: oPushResult
 130: oNodeSet
 131: oPop 3
 133: oGetLocal 1
 135: oPushResult
 136: oScopeDeclareAlloc
 137: oPop 1
 139: oInput 12
 141: oInput 0
 143: oGetAddrLocal 1
 145: oPushResult
 146: oSetResult 14
 148: oPushResult
 149: oSetResult 6
 151: oPushResult
 152: LAST_ID
 153: oPushResult
 154: oCall 7803
 156: oPop 3
 158: oAssign
 159: oGetLocal 1
 161: oPushResult
 162: oSetResult 20
 164: oPushResult
 165: oGetGlobal 3
 167: oPushResult
 168: oNodeSet
 169: oPop 3
 171: oGetLocal 1
 173: oPushResult
 174: oScopeDeclareAlloc
 175: oPop 1
 177: oInput 14
 179: oJumpForward 184
 181: Choice Lookup Table
          13    103
 184: oInput 4
 186: oInputChoice 197
 188: oGetLocal 4
 190: oPushResult
 191: oCall 292
 193: oPop 1
 195: oJumpForward 200
 197: Choice Lookup Table
          54    188
 200: oGetLocal 4
 202: oPushResult
 203: oCall 348
 205: oPop 1
 207: oSetResult 0
 209: oPushResult
 210: oSetResult 0
 212: oPushResult
 213: oScopeBegin
 214: oPop 2
 216: oGetAddrLocal 5
 218: oPushResult
 219: oScopeCurrent
 220: oAssign
 221: oSetResult 0
 223: oPushResult
 224: oSetResult 1
 226: oPushResult
 227: oScopeBegin
 228: oPop 2
 230: oGetAddrGlobal 2
 232: oPushResult
 233: oScopeCurrent
 234: oAssign
 235: oGetLocal 4
 237: oPushResult
 238: oSetResult 7
 240: oPushResult
 241: oGetGlobal 2
 243: oPushResult
 244: oNodeSet
 245: oPop 3
 247: oScopeEnd
 248: oSetResult 15
 250: oPushResult
 251: oCall 1193
 253: oPop 1
 255: oGetGlobal 2
 257: oPushResult
 258: oScopeEnter
 259: oPop 1
 261: oGetAddrLocal 6
 263: oPushResult
 264: oSetResult 1
 266: oAssign
 267: oGetLocal 3
 269: oPushResult
 270: oGetLocal 5
 272: oPushResult
 273: oGetLocal 6
 275: oPushResult
 276: oCall 1413
 278: oPop 3
 280: oScopeEnd
 281: oInput 19
 283: oScopeEnd
 284: oGetLocal 4
 286: oPushResult
 287: oCall 410
 289: oPop 1
 291: oReturn
 292: oLocalSpace 1
 294: oInput 0
 296: oGetAddrLocal 1
 298: oPushResult
 299: LAST_ID
 300: oPushResult
 301: oCall 489
 303: oPop 1
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oSetResult 0
 311: oPushResult
 312: equal_node
 313: oPop 2
 315: oChoice 331
 317: oGetParam 1
 319: oPushResult
 320: oSetResult 5
 322: oPushResult
 323: oGetLocal 1
 325: oPushResult
 326: oNodeAddLast
 327: oPop 3
 329: oJumpForward 334
 331: Choice Lookup Table
           0    317
 334: oInputChoice 338
 336: oJumpForward 343
 338: Choice Lookup Table
          12    336
 341: oJumpForward 345
 343: oJumpBack 294
 345: oInput 4
 347: oReturn
 348: oLocalSpace 2
 350: oGetAddrLocal 1
 352: oPushResult
 353: oGetParam 1
 355: oPushResult
 356: oSetResult 5
 358: oPushResult
 359: oNodeGetIter
 360: oPop 2
 362: oAssign
 363: oGetAddrLocal 2
 365: oPushResult
 366: oGetLocal 1
 368: oPushResult
 369: oNodeIterValue
 370: oPop 1
 372: oAssign
 373: oGetLocal 2
 375: oPushResult
 376: oNodeNull
 377: oPop 1
 379: oChoice 396
 381: oGetLocal 2
 383: oPushResult
 384: oSetResult 8
 386: oPushResult
 387: oNodeGet
 388: oPop 2
 390: oPushResult
 391: oScopeEnter
 392: oPop 1
 394: oJumpForward 401
 396: Choice Lookup Table
           0    381
 399: oJumpForward 409
 401: oGetAddrLocal 1
 403: oPushResult
 404: oNodeIterNext
 405: oPop 1
 407: oJumpBack 363
 409: oReturn
 410: oLocalSpace 2
 412: oGetAddrLocal 1
 414: oPushResult
 415: oGetParam 1
 417: oPushResult
 418: oSetResult 5
 420: oPushResult
 421: oNodeGetIter
 422: oPop 2
 424: oAssign
 425: oGetAddrLocal 2
 427: oPushResult
 428: oGetLocal 1
 430: oPushResult
 431: oNodeIterValue
 432: oPop 1
 434: oAssign
 435: oGetLocal 2
 437: oPushResult
 438: oNodeNull
 439: oPop 1
 441: oChoice 475
 443: oScopeCurrent
 444: oPushResult
 445: oGetLocal 2
 447: oPushResult
 448: oSetResult 8
 450: oPushResult
 451: oNodeGet
 452: oPop 2
 454: oPushResult
 455: oNodeEqual
 456: oPop 2
 458: oChoice 466
 460: oJumpForward 472
 462: oError 25
 464: oJumpForward 472
 466: Choice Lookup Table
           0    462
           1    460
 471: oEndChoice
 472: oScopeEnd
 473: oJumpForward 480
 475: Choice Lookup Table
           0    443
 478: oJumpForward 488
 480: oGetAddrLocal 1
 482: oPushResult
 483: oNodeIterNext
 484: oPop 1
 486: oJumpBack 425
 488: oReturn
 489: oLocalSpace 2
 491: oGetAddrLocal 1
 493: oPushResult
 494: oGetGlobal 1
 496: oPushResult
 497: oSetResult 1
 499: oPushResult
 500: oSetResult 4
 502: oPushResult
 503: oGetParam 1
 505: oPushResult
 506: oNodeFind
 507: oPop 4
 509: oAssign
 510: oGetLocal 1
 512: oPushResult
 513: oSetResult 0
 515: oPushResult
 516: equal_node
 517: oPop 2
 519: oChoice 526
 521: oGetLocal 1
 523: oReturn
 524: oJumpForward 529
 526: Choice Lookup Table
           0    521
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetParam 1
 534: oPushResult
 535: oIncludeUnitFile
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oChoice 550
 543: oError 24
 545: oSetResult 0
 547: oReturn
 548: oJumpForward 553
 550: Choice Lookup Table
           0    543
 553: oGetAddrLocal 1
 555: oPushResult
 556: oCall 564
 558: oAssign
 559: oIncludeEnd
 560: oGetLocal 1
 562: oReturn
 563: oReturn
 564: oLocalSpace 1
 566: oInput 55
 568: oInput 0
 570: oGetAddrLocal 1
 572: oPushResult
 573: oSetResult 5
 575: oPushResult
 576: oNodeNew
 577: oPop 1
 579: oAssign
 580: oGetLocal 1
 582: oPushResult
 583: oSetResult 4
 585: oPushResult
 586: LAST_ID
 587: oPushResult
 588: oNodeSetInt
 589: oPop 3
 591: oGetGlobal 1
 593: oPushResult
 594: oSetResult 1
 596: oPushResult
 597: oGetLocal 1
 599: oPushResult
 600: oNodeAddLast
 601: oPop 3
 603: oInput 4
 605: oInputChoice 616
 607: oGetLocal 1
 609: oPushResult
 610: oCall 292
 612: oPop 1
 614: oJumpForward 619
 616: Choice Lookup Table
          54    607
 619: oGetLocal 1
 621: oPushResult
 622: oCall 348
 624: oPop 1
 626: oInput 56
 628: oSetResult 0
 630: oPushResult
 631: oSetResult 0
 633: oPushResult
 634: oScopeBegin
 635: oPop 2
 637: oGetLocal 1
 639: oPushResult
 640: oSetResult 8
 642: oPushResult
 643: oScopeCurrent
 644: oPushResult
 645: oNodeSet
 646: oPop 3
 648: oSetResult 0
 650: oPushResult
 651: oSetResult 1
 653: oPushResult
 654: oScopeBegin
 655: oPop 2
 657: oGetAddrGlobal 2
 659: oPushResult
 660: oScopeCurrent
 661: oAssign
 662: oGetLocal 1
 664: oPushResult
 665: oSetResult 12
 667: oPushResult
 668: oGetGlobal 2
 670: oPushResult
 671: oNodeSet
 672: oPop 3
 674: oScopeEnd
 675: oGetLocal 1
 677: oPushResult
 678: oCall 800
 680: oPop 1
 682: oInput 57
 684: oSetResult 0
 686: oPushResult
 687: oSetResult 0
 689: oPushResult
 690: oScopeBegin
 691: oPop 2
 693: oGetLocal 1
 695: oPushResult
 696: oSetResult 9
 698: oPushResult
 699: oScopeCurrent
 700: oPushResult
 701: oNodeSet
 702: oPop 3
 704: oScopeCurrent
 705: oPushResult
 706: oSetResult 15
 708: oPushResult
 709: oGetLocal 1
 711: oPushResult
 712: oSetResult 8
 714: oPushResult
 715: oNodeGet
 716: oPop 2
 718: oPushResult
 719: oNodeSet
 720: oPop 3
 722: oGetLocal 1
 724: oPushResult
 725: oCall 881
 727: oPop 1
 729: oInputChoice 743
 731: oGetLocal 1
 733: oPushResult
 734: oSetResult 1
 736: oPushResult
 737: oCall 891
 739: oPop 2
 741: oJumpForward 756
 743: Choice Lookup Table
          58    731
 746: oGetLocal 1
 748: oPushResult
 749: oSetResult 0
 751: oPushResult
 752: oCall 891
 754: oPop 2
 756: oInputChoice 770
 758: oGetLocal 1
 760: oPushResult
 761: oSetResult 1
 763: oPushResult
 764: oCall 1077
 766: oPop 2
 768: oJumpForward 783
 770: Choice Lookup Table
          59    758
 773: oGetLocal 1
 775: oPushResult
 776: oSetResult 0
 778: oPushResult
 779: oCall 1077
 781: oPop 2
 783: oInput 34
 785: oInput 19
 787: oScopeEnd
 788: oScopeEnd
 789: oGetLocal 1
 791: oPushResult
 792: oCall 410
 794: oPop 1
 796: oGetLocal 1
 798: oReturn
 799: oReturn
 800: oLocalSpace 2
 802: oInputChoice 865
 804: oCall 2693
 806: oJumpForward 878
 808: oCall 2765
 810: oJumpForward 878
 812: oSetResult 15
 814: oPushResult
 815: oCall 2824
 817: oPop 1
 819: oJumpForward 878
 821: oGetAddrLocal 1
 823: oPushResult
 824: oCall 1651
 826: oAssign
 827: oInputChoice 838
 829: oGetLocal 1
 831: oPushResult
 832: oCall 1589
 834: oPop 1
 836: oJumpForward 841
 838: Choice Lookup Table
          65    829
 841: oJumpForward 878
 843: oGetAddrLocal 2
 845: oPushResult
 846: oCall 2028
 848: oAssign
 849: oInputChoice 860
 851: oGetLocal 2
 853: oPushResult
 854: oCall 1589
 856: oPop 1
 858: oJumpForward 863
 860: Choice Lookup Table
          65    851
 863: oJumpForward 878
 865: Choice Lookup Table
          29    843
          28    821
          32    812
          31    808
          30    804
 876: oJumpForward 880
 878: oJumpBack 802
 880: oReturn
 881: oLocalSpace 0
 883: oSetResult 15
 885: oPushResult
 886: oCall 1193
 888: oPop 1
 890: oReturn
 891: oLocalSpace 5
 893: oGetAddrLocal 1
 895: oPushResult
 896: oLabelNew
 897: oAssign
 898: oEmit 56
 900: oGetLocal 1
 902: oPushResult
 903: oEmitLabel
 904: oPop 1
 906: oGetParam 2
 908: oPushResult
 909: oSetResult 10
 911: oPushResult
 912: oGetLocal 1
 914: oPushResult
 915: oNodeSetLabel
 916: oPop 3
 918: oEmit 52
 920: oGetAddrLocal 2
 922: oPushResult
 923: Here
 924: oAssign
 925: oEmit 64
 927: oGetAddrLocal 3
 929: oPushResult
 930: oGetParam 2
 932: oPushResult
 933: oSetResult 8
 935: oPushResult
 936: oNodeGet
 937: oPop 2
 939: oAssign
 940: oGetAddrLocal 4
 942: oPushResult
 943: oGetLocal 3
 945: oPushResult
 946: oSetResult 18
 948: oPushResult
 949: oNodeGetCode
 950: oPop 2
 952: oAssign
 953: oGetLocal 4
 955: oPushResult
 956: oEmitCode
 957: oPop 1
 959: oGetLocal 3
 961: oPushResult
 962: oSetResult 18
 964: oPushResult
 965: oSetResult 0
 967: oPushResult
 968: oNodeSetCode
 969: oPop 3
 971: oGetAddrLocal 3
 973: oPushResult
 974: oGetParam 2
 976: oPushResult
 977: oSetResult 9
 979: oPushResult
 980: oNodeGet
 981: oPop 2
 983: oAssign
 984: oGetAddrLocal 4
 986: oPushResult
 987: oGetLocal 3
 989: oPushResult
 990: oSetResult 18
 992: oPushResult
 993: oNodeGetCode
 994: oPop 2
 996: oAssign
 997: oGetLocal 4
 999: oPushResult
1000: oEmitCode
1001: oPop 1
1003: oGetLocal 3
1005: oPushResult
1006: oSetResult 18
1008: oPushResult
1009: oSetResult 0
1011: oPushResult
1012: oNodeSetCode
1013: oPop 3
1015: oGetParam 2
1017: oPushResult
1018: oSetResult 12
1020: oPushResult
1021: oNodeGet
1022: oPop 2
1024: oPushResult
1025: oScopeEnter
1026: oPop 1
1028: oGetParam 1
1030: oChoice 1049
1032: oCall 6600
1034: oInputChoice 1040
1036: oCall 6600
1038: oJumpForward 1045
1040: Choice Lookup Table
           4   1036
1043: oJumpForward 1047
1045: oJumpBack 1034
1047: oJumpForward 1052
1049: Choice Lookup Table
           1   1032
1052: oEmit 51
1054: oGetAddrLocal 5
1056: oPushResult
1057: oScopeCurrent
1058: oPushResult
1059: oSetResult 16
1061: oPushResult
1062: oNodeGetInt
1063: oPop 2
1065: oAssign
1066: oGetLocal 2
1068: oPushResult
1069: oGetLocal 5
1071: oPushResult
1072: oPatch
1073: oPop 2
1075: oScopeEnd
1076: oReturn
1077: oLocalSpace 3
1079: oGetAddrLocal 1
1081: oPushResult
1082: oLabelNew
1083: oAssign
1084: oEmit 56
1086: oGetLocal 1
1088: oPushResult
1089: oEmitLabel
1090: oPop 1
1092: oGetParam 2
1094: oPushResult
1095: oSetResult 11
1097: oPushResult
1098: oGetLocal 1
1100: oPushResult
1101: oNodeSetLabel
1102: oPop 3
1104: oEmit 52
1106: oGetAddrLocal 2
1108: oPushResult
1109: Here
1110: oAssign
1111: oEmit 64
1113: oSetResult 0
1115: oPushResult
1116: oSetResult 1
1118: oPushResult
1119: oScopeBegin
1120: oPop 2
1122: oGetParam 1
1124: oChoice 1143
1126: oCall 6600
1128: oInputChoice 1134
1130: oCall 6600
1132: oJumpForward 1139
1134: Choice Lookup Table
           4   1130
1137: oJumpForward 1141
1139: oJumpBack 1128
1141: oJumpForward 1146
1143: Choice Lookup Table
           1   1126
1146: oEmit 51
1148: oGetAddrLocal 3
1150: oPushResult
1151: oScopeCurrent
1152: oPushResult
1153: oSetResult 16
1155: oPushResult
1156: oNodeGetInt
1157: oPop 2
1159: oAssign
1160: oGetLocal 2
1162: oPushResult
1163: oGetLocal 3
1165: oPushResult
1166: oPatch
1167: oPop 2
1169: oScopeEnd
1170: oReturn
1171: oLocalSpace 0
1173: oGetParam 2
1175: oPushResult
1176: oCall 1193
1178: oPop 1
1180: oGetParam 1
1182: oPushResult
1183: oScopeCurrent
1184: oPushResult
1185: oSetResult 0
1187: oPushResult
1188: oCall 1413
1190: oPop 3
1192: oReturn
1193: oLocalSpace 0
1195: oInputChoice 1222
1197: oCall 2693
1199: oJumpForward 1235
1201: oCall 2765
1203: oJumpForward 1235
1205: oGetParam 1
1207: oPushResult
1208: oCall 2824
1210: oPop 1
1212: oJumpForward 1235
1214: oCall 1910
1216: oJumpForward 1235
1218: oCall 2348
1220: oJumpForward 1235
1222: Choice Lookup Table
          29   1218
          28   1214
          32   1205
          31   1201
          30   1197
1233: oJumpForward 1237
1235: oJumpBack 1195
1237: oCall 1240
1239: oReturn
1240: oLocalSpace 0
1242: oReturn
1243: oLocalSpace 2
1245: oGetAddrLocal 1
1247: oPushResult
1248: oGetGlobal 1
1250: oPushResult
1251: oSetResult 1
1253: oPushResult
1254: oNodeGetIter
1255: oPop 2
1257: oAssign
1258: oGetAddrLocal 2
1260: oPushResult
1261: oGetLocal 1
1263: oPushResult
1264: oNodeIterValue
1265: oPop 1
1267: oAssign
1268: oGetLocal 2
1270: oPushResult
1271: oNodeNull
1272: oPop 1
1274: oChoice 1319
1276: oJumpForward 1327
1278: oJumpForward 1325
1280: oEmit 46
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oEmit 49
1290: oGetLocal 2
1292: oPushResult
1293: oSetResult 10
1295: oPushResult
1296: oNodeGetLabel
1297: oPop 2
1299: oPushResult
1300: oEmitLabel
1301: oPop 1
1303: oEmit 48
1305: oSetResult 0
1307: oPushResult
1308: oEmitInt
1309: oPop 1
1311: oGetAddrLocal 1
1313: oPushResult
1314: oNodeIterNext
1315: oPop 1
1317: oJumpForward 1325
1319: Choice Lookup Table
           0   1280
           1   1276
1324: oEndChoice
1325: oJumpBack 1258
1327: oReturn
1328: oLocalSpace 2
1330: oGetAddrLocal 1
1332: oPushResult
1333: oGetGlobal 1
1335: oPushResult
1336: oSetResult 1
1338: oPushResult
1339: oNodeGetIter
1340: oPop 2
1342: oAssign
1343: oGetAddrLocal 2
1345: oPushResult
1346: oGetLocal 1
1348: oPushResult
1349: oNodeIterValue
1350: oPop 1
1352: oAssign
1353: oGetLocal 2
1355: oPushResult
1356: oNodeNull
1357: oPop 1
1359: oChoice 1404
1361: oJumpForward 1412
1363: oJumpForward 1410
1365: oEmit 46
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oEmit 49
1375: oGetLocal 2
1377: oPushResult
1378: oSetResult 11
1380: oPushResult
1381: oNodeGetLabel
1382: oPop 2
1384: oPushResult
1385: oEmitLabel
1386: oPop 1
1388: oEmit 48
1390: oSetResult 0
1392: oPushResult
1393: oEmitInt
1394: oPop 1
1396: oGetAddrLocal 1
1398: oPushResult
1399: oNodeIterNext
1400: oPop 1
1402: oJumpForward 1410
1404: Choice Lookup Table
           0   1365
           1   1361
1409: oEndChoice
1410: oJumpBack 1343
1412: oReturn
1413: oLocalSpace 3
1415: oEmit 56
1417: oGetParam 3
1419: oPushResult
1420: oEmitLabel
1421: oPop 1
1423: oEmit 52
1425: oGetAddrLocal 1
1427: oPushResult
1428: Here
1429: oAssign
1430: oEmit 64
1432: oGetParam 1
1434: oChoice 1440
1436: oCall 1243
1438: oJumpForward 1443
1440: Choice Lookup Table
           1   1436
1443: oGetAddrLocal 2
1445: oPushResult
1446: oGetParam 2
1448: oPushResult
1449: oSetResult 18
1451: oPushResult
1452: oNodeGetCode
1453: oPop 2
1455: oAssign
1456: oGetLocal 2
1458: oPushResult
1459: oEmitCode
1460: oPop 1
1462: oGetParam 2
1464: oPushResult
1465: oSetResult 18
1467: oPushResult
1468: oSetResult 0
1470: oPushResult
1471: oNodeSetCode
1472: oPop 3
1474: oCall 6600
1476: oGetParam 1
1478: oChoice 1484
1480: oCall 1328
1482: oJumpForward 1487
1484: Choice Lookup Table
           1   1480
1487: oEmit 51
1489: oGetAddrLocal 3
1491: oPushResult
1492: oScopeCurrent
1493: oPushResult
1494: oSetResult 16
1496: oPushResult
1497: oNodeGetInt
1498: oPop 2
1500: oAssign
1501: oGetLocal 1
1503: oPushResult
1504: oGetLocal 3
1506: oPushResult
1507: oPatch
1508: oPop 2
1510: oReturn
1511: oLocalSpace 0
1513: oInputChoice 1531
1515: oGetParam 1
1517: oPushResult
1518: oSetResult 26
1520: oPushResult
1521: oSetResult 1
1523: oPushResult
1524: oNodeSetBoolean
1525: oPop 3
1527: oInput 4
1529: oJumpForward 1536
1531: Choice Lookup Table
          67   1515
1534: oJumpForward 1538
1536: oJumpBack 1513
1538: oReturn
1539: oLocalSpace 1
1541: oGetAddrLocal 1
1543: oPushResult
1544: oScopeCurrent
1545: oPushResult
1546: oSetResult 18
1548: oPushResult
1549: oNodeGetCode
1550: oPop 2
1552: oAssign
1553: oGetLocal 1
1555: oPushResult
1556: oSetResult 0
1558: oPushResult
1559: equal_code
1560: oPop 2
1562: oChoice 1582
1564: oGetAddrLocal 1
1566: oPushResult
1567: oCodeNew
1568: oAssign
1569: oScopeCurrent
1570: oPushResult
1571: oSetResult 18
1573: oPushResult
1574: oGetLocal 1
1576: oPushResult
1577: oNodeSetCode
1578: oPop 3
1580: oJumpForward 1585
1582: Choice Lookup Table
           1   1564
1585: oGetLocal 1
1587: oReturn
1588: oReturn
1589: oLocalSpace 0
1591: oGetParam 1
1593: oPushResult
1594: oCall 7651
1596: oPop 1
1598: oPushResult
1599: equal_zero
1600: oPop 1
1602: oChoice 1608
1604: oError 23
1606: oJumpForward 1611
1608: Choice Lookup Table
           0   1604
1611: oGetParam 1
1613: oPushResult
1614: oSetResult 24
1616: oPushResult
1617: oSetResult 1
1619: oPushResult
1620: oNodeSetBoolean
1621: oPop 3
1623: oInputChoice 1647
1625: oInputChoice 1642
1627: oInput 2
1629: oGetParam 1
1631: oPushResult
1632: oSetResult 25
1634: oPushResult
1635: CURRENT_STRLIT
1636: oPushResult
1637: oNodeSetString
1638: oPop 3
1640: oJumpForward 1645
1642: Choice Lookup Table
          66   1627
1645: oJumpForward 1650
1647: Choice Lookup Table
           2   1625
1650: oReturn
1651: oLocalSpace 6
1653: oInput 0
1655: oGetAddrLocal 1
1657: oPushResult
1658: oSetResult 0
1660: oAssign
1661: oGetAddrLocal 2
1663: oPushResult
1664: oScopeFindInCurrentScope
1665: oAssign
1666: oGetLocal 2
1668: oPushResult
1669: oNodeNull
1670: oPop 1
1672: oChoice 1793
1674: oGetAddrLocal 2
1676: oPushResult
1677: oSetResult 10
1679: oPushResult
1680: oSetResult 2
1682: oPushResult
1683: LAST_ID
1684: oPushResult
1685: oCall 7803
1687: oPop 3
1689: oAssign
1690: oGetLocal 2
1692: oPushResult
1693: oSetResult 21
1695: oPushResult
1696: oLabelNew
1697: oPushResult
1698: oNodeSetLabel
1699: oPop 3
1701: oJumpForward 1799
1703: oGetAddrLocal 1
1705: oPushResult
1706: oSetResult 1
1708: oAssign
1709: oGetLocal 2
1711: oPushResult
1712: oSetResult 23
1714: oPushResult
1715: oNodeGetBoolean
1716: oPop 2
1718: oChoice 1724
1720: oError 21
1722: oJumpForward 1727
1724: Choice Lookup Table
           1   1720
1727: oGetLocal 2
1729: oPushResult
1730: oSetResult 24
1732: oPushResult
1733: oNodeGetBoolean
1734: oPop 2
1736: oChoice 1742
1738: oError 21
1740: oJumpForward 1745
1742: Choice Lookup Table
           1   1738
1745: oGetLocal 2
1747: oPushResult
1748: oNodeType
1749: oPop 1
1751: oChoice 1755
1753: oJumpForward 1760
1755: Choice Lookup Table
          10   1753
1758: oError 21
1760: oGetLocal 2
1762: oPushResult
1763: oSetResult 28
1765: oPushResult
1766: oGetLocal 2
1768: oPushResult
1769: oSetResult 22
1771: oPushResult
1772: oNodeGet
1773: oPop 2
1775: oPushResult
1776: oNodeSet
1777: oPop 3
1779: oGetLocal 2
1781: oPushResult
1782: oSetResult 22
1784: oPushResult
1785: oSetResult 0
1787: oPushResult
1788: oNodeSet
1789: oPop 3
1791: oJumpForward 1799
1793: Choice Lookup Table
           0   1703
           1   1674
1798: oEndChoice
1799: oGetAddrLocal 3
1801: oPushResult
1802: oCall 7639
1804: oAssign
1805: oGetAddrLocal 4
1807: oPushResult
1808: oGetLocal 3
1810: oPushResult
1811: oSetResult 0
1813: oPushResult
1814: greater
1815: oPop 2
1817: oAssign
1818: oGetAddrLocal 3
1820: oPushResult
1821: inc
1822: oPop 1
1824: oGetLocal 3
1826: oPushResult
1827: oSetResult 2
1829: oPushResult
1830: oScopeBegin
1831: oPop 2
1833: oGetAddrLocal 5
1835: oPushResult
1836: oScopeCurrent
1837: oAssign
1838: oGetLocal 4
1840: oChoice 1859
1842: oGetAddrLocal 6
1844: oPushResult
1845: oGetGlobal 4
1847: oPushResult
1848: oCall 7831
1850: oPop 1
1852: oPushResult
1853: oScopeAllocType
1854: oPop 1
1856: oAssign
1857: oJumpForward 1862
1859: Choice Lookup Table
           1   1842
1862: oCall 2466
1864: oGetLocal 2
1866: oPushResult
1867: oSetResult 22
1869: oPushResult
1870: oGetLocal 5
1872: oPushResult
1873: oNodeSet
1874: oPop 3
1876: oScopeEnd
1877: oInput 4
1879: oGetLocal 1
1881: oChoice 1893
1883: oGetLocal 2
1885: oPushResult
1886: oScopeDeclare
1887: oPop 1
1889: oJumpForward 1899
1891: oJumpForward 1899
1893: Choice Lookup Table
           1   1891
           0   1883
1898: oEndChoice
1899: oGetLocal 2
1901: oPushResult
1902: oCall 1511
1904: oPop 1
1906: oGetLocal 2
1908: oReturn
1909: oReturn
1910: oLocalSpace 4
1912: oGetAddrLocal 1
1914: oPushResult
1915: oCall 1651
1917: oAssign
1918: oInputChoice 1931
1920: oJumpForward 2025
1922: oGetLocal 1
1924: oPushResult
1925: oCall 1589
1927: oPop 1
1929: oJumpForward 2025
1931: Choice Lookup Table
          65   1922
          64   1920
1936: oGetAddrLocal 2
1938: oPushResult
1939: oGetLocal 1
1941: oPushResult
1942: oSetResult 22
1944: oPushResult
1945: oNodeGet
1946: oPop 2
1948: oAssign
1949: oGetLocal 2
1951: oPushResult
1952: oScopeEnter
1953: oPop 1
1955: oGetAddrLocal 3
1957: oPushResult
1958: oGetLocal 2
1960: oPushResult
1961: oSetResult 13
1963: oPushResult
1964: oNodeGetInt
1965: oPop 2
1967: oAssign
1968: oGetLocal 3
1970: oPushResult
1971: oSetResult 1
1973: oPushResult
1974: oScopeBegin
1975: oPop 2
1977: oGetLocal 1
1979: oPushResult
1980: oSetResult 6
1982: oPushResult
1983: oScopeCurrent
1984: oPushResult
1985: oNodeSet
1986: oPop 3
1988: oGetAddrLocal 4
1990: oPushResult
1991: oGetLocal 1
1993: oPushResult
1994: oSetResult 21
1996: oPushResult
1997: oNodeGetLabel
1998: oPop 2
2000: oAssign
2001: oSetResult 16
2003: oPushResult
2004: oGetLocal 4
2006: oPushResult
2007: oCall 1171
2009: oPop 2
2011: oGetLocal 1
2013: oPushResult
2014: oSetResult 23
2016: oPushResult
2017: oSetResult 1
2019: oPushResult
2020: oNodeSetBoolean
2021: oPop 3
2023: oScopeEnd
2024: oScopeEnd
2025: oInput 4
2027: oReturn
2028: oLocalSpace 8
2030: oInput 0
2032: oGetAddrLocal 1
2034: oPushResult
2035: oSetResult 0
2037: oAssign
2038: oGetAddrLocal 2
2040: oPushResult
2041: oScopeFindInCurrentScope
2042: oAssign
2043: oGetLocal 2
2045: oPushResult
2046: oNodeNull
2047: oPop 1
2049: oChoice 2183
2051: oGetAddrLocal 2
2053: oPushResult
2054: oSetResult 11
2056: oPushResult
2057: oSetResult 3
2059: oPushResult
2060: LAST_ID
2061: oPushResult
2062: oCall 7803
2064: oPop 3
2066: oAssign
2067: oGetLocal 2
2069: oPushResult
2070: oSetResult 21
2072: oPushResult
2073: oLabelNew
2074: oPushResult
2075: oNodeSetLabel
2076: oPop 3
2078: oJumpForward 2189
2080: oGetAddrLocal 1
2082: oPushResult
2083: oSetResult 1
2085: oAssign
2086: oGetLocal 2
2088: oPushResult
2089: oSetResult 23
2091: oPushResult
2092: oNodeGetBoolean
2093: oPop 2
2095: oChoice 2101
2097: oError 21
2099: oJumpForward 2104
2101: Choice Lookup Table
           1   2097
2104: oGetLocal 2
2106: oPushResult
2107: oNodeType
2108: oPop 1
2110: oChoice 2114
2112: oJumpForward 2119
2114: Choice Lookup Table
          11   2112
2117: oError 21
2119: oGetLocal 2
2121: oPushResult
2122: oSetResult 28
2124: oPushResult
2125: oGetLocal 2
2127: oPushResult
2128: oSetResult 22
2130: oPushResult
2131: oNodeGet
2132: oPop 2
2134: oPushResult
2135: oNodeSet
2136: oPop 3
2138: oGetLocal 2
2140: oPushResult
2141: oSetResult 22
2143: oPushResult
2144: oSetResult 0
2146: oPushResult
2147: oNodeSet
2148: oPop 3
2150: oGetLocal 2
2152: oPushResult
2153: oSetResult 29
2155: oPushResult
2156: oGetLocal 2
2158: oPushResult
2159: oSetResult 20
2161: oPushResult
2162: oNodeGet
2163: oPop 2
2165: oPushResult
2166: oNodeSet
2167: oPop 3
2169: oGetLocal 2
2171: oPushResult
2172: oSetResult 20
2174: oPushResult
2175: oSetResult 0
2177: oPushResult
2178: oNodeSet
2179: oPop 3
2181: oJumpForward 2189
2183: Choice Lookup Table
           0   2080
           1   2051
2188: oEndChoice
2189: oGetAddrLocal 3
2191: oPushResult
2192: oCall 7639
2194: oAssign
2195: oGetAddrLocal 4
2197: oPushResult
2198: oGetLocal 3
2200: oPushResult
2201: oSetResult 0
2203: oPushResult
2204: greater
2205: oPop 2
2207: oAssign
2208: oGetAddrLocal 3
2210: oPushResult
2211: inc
2212: oPop 1
2214: oGetLocal 3
2216: oPushResult
2217: oSetResult 2
2219: oPushResult
2220: oScopeBegin
2221: oPop 2
2223: oGetAddrLocal 5
2225: oPushResult
2226: oScopeCurrent
2227: oAssign
2228: oGetLocal 4
2230: oChoice 2249
2232: oGetAddrLocal 6
2234: oPushResult
2235: oGetGlobal 4
2237: oPushResult
2238: oCall 7831
2240: oPop 1
2242: oPushResult
2243: oScopeAllocType
2244: oPop 1
2246: oAssign
2247: oJumpForward 2252
2249: Choice Lookup Table
           1   2232
2252: oCall 2466
2254: oGetLocal 2
2256: oPushResult
2257: oSetResult 22
2259: oPushResult
2260: oGetLocal 5
2262: oPushResult
2263: oNodeSet
2264: oPop 3
2266: oInput 11
2268: oGetAddrLocal 7
2270: oPushResult
2271: oCall 3054
2273: oPop 1
2275: oGetLocal 2
2277: oPushResult
2278: oSetResult 20
2280: oPushResult
2281: oGetLocal 7
2283: oPushResult
2284: oNodeSet
2285: oPop 3
2287: oGetAddrLocal 8
2289: oPushResult
2290: oGetLocal 7
2292: oPushResult
2293: oCall 7831
2295: oPop 1
2297: oAssign
2298: oGetLocal 2
2300: oPushResult
2301: oSetResult 30
2303: oPushResult
2304: oGetLocal 8
2306: oPushResult
2307: oScopeAllocType
2308: oPop 1
2310: oPushResult
2311: oNodeSetInt
2312: oPop 3
2314: oScopeEnd
2315: oInput 4
2317: oGetLocal 1
2319: oChoice 2331
2321: oGetLocal 2
2323: oPushResult
2324: oScopeDeclare
2325: oPop 1
2327: oJumpForward 2337
2329: oJumpForward 2337
2331: Choice Lookup Table
           1   2329
           0   2321
2336: oEndChoice
2337: oGetLocal 2
2339: oPushResult
2340: oCall 1511
2342: oPop 1
2344: oGetLocal 2
2346: oReturn
2347: oReturn
2348: oLocalSpace 4
2350: oGetAddrLocal 1
2352: oPushResult
2353: oCall 2028
2355: oAssign
2356: oInputChoice 2369
2358: oJumpForward 2463
2360: oGetLocal 1
2362: oPushResult
2363: oCall 1589
2365: oPop 1
2367: oJumpForward 2463
2369: Choice Lookup Table
          65   2360
          64   2358
2374: oGetAddrLocal 2
2376: oPushResult
2377: oGetLocal 1
2379: oPushResult
2380: oSetResult 22
2382: oPushResult
2383: oNodeGet
2384: oPop 2
2386: oAssign
2387: oGetLocal 2
2389: oPushResult
2390: oScopeEnter
2391: oPop 1
2393: oGetAddrLocal 3
2395: oPushResult
2396: oGetLocal 2
2398: oPushResult
2399: oSetResult 13
2401: oPushResult
2402: oNodeGetInt
2403: oPop 2
2405: oAssign
2406: oGetLocal 3
2408: oPushResult
2409: oSetResult 1
2411: oPushResult
2412: oScopeBegin
2413: oPop 2
2415: oGetLocal 1
2417: oPushResult
2418: oSetResult 6
2420: oPushResult
2421: oScopeCurrent
2422: oPushResult
2423: oNodeSet
2424: oPop 3
2426: oGetAddrLocal 4
2428: oPushResult
2429: oGetLocal 1
2431: oPushResult
2432: oSetResult 21
2434: oPushResult
2435: oNodeGetLabel
2436: oPop 2
2438: oAssign
2439: oSetResult 16
2441: oPushResult
2442: oGetLocal 4
2444: oPushResult
2445: oCall 1171
2447: oPop 2
2449: oGetLocal 1
2451: oPushResult
2452: oSetResult 23
2454: oPushResult
2455: oSetResult 1
2457: oPushResult
2458: oNodeSetBoolean
2459: oPop 3
2461: oScopeEnd
2462: oScopeEnd
2463: oInput 4
2465: oReturn
2466: oLocalSpace 6
2468: oInputChoice 2689
2470: oGetAddrLocal 1
2472: oPushResult
2473: oNodeVecNew
2474: oAssign
2475: oGetAddrLocal 3
2477: oPushResult
2478: oSetResult 0
2480: oAssign
2481: oInputChoice 2491
2483: oGetAddrLocal 3
2485: oPushResult
2486: oSetResult 1
2488: oAssign
2489: oJumpForward 2494
2491: Choice Lookup Table
          32   2483
2494: oInput 0
2496: oGetAddrLocal 2
2498: oPushResult
2499: oSetResult 18
2501: oPushResult
2502: oSetResult 6
2504: oPushResult
2505: LAST_ID
2506: oPushResult
2507: oCall 7803
2509: oPop 3
2511: oAssign
2512: oGetLocal 2
2514: oPushResult
2515: oSetResult 31
2517: oPushResult
2518: oGetLocal 3
2520: oPushResult
2521: oNodeSetBoolean
2522: oPop 3
2524: oGetLocal 1
2526: oPushResult
2527: oGetLocal 2
2529: oPushResult
2530: oNodeVecAppend
2531: oPop 2
2533: oInputChoice 2541
2535: oJumpForward 2549
2537: oJumpForward 2547
2539: oJumpForward 2547
2541: Choice Lookup Table
          12   2539
          11   2535
2546: oEndChoice
2547: oJumpBack 2494
2549: oGetAddrLocal 4
2551: oPushResult
2552: oCall 3054
2554: oPop 1
2556: oGetLocal 3
2558: oChoice 2573
2560: oGetAddrLocal 5
2562: oPushResult
2563: oGetLocal 4
2565: oPushResult
2566: oCall 7831
2568: oPop 1
2570: oAssign
2571: oJumpForward 2582
2573: Choice Lookup Table
           1   2560
2576: oGetAddrLocal 5
2578: oPushResult
2579: oGetLocal 4
2581: oAssign
2582: oGetAddrLocal 6
2584: oPushResult
2585: oSetResult 0
2587: oAssign
2588: oGetLocal 6
2590: oPushResult
2591: oGetLocal 1
2593: oPushResult
2594: oNodeVecSize
2595: oPop 1
2597: oPushResult
2598: equal
2599: oPop 2
2601: oChoice 2658
2603: oGetAddrLocal 2
2605: oPushResult
2606: oGetLocal 1
2608: oPushResult
2609: oGetLocal 6
2611: oPushResult
2612: oNodeVecElement
2613: oPop 2
2615: oAssign
2616: oGetLocal 2
2618: oPushResult
2619: oSetResult 20
2621: oPushResult
2622: oGetLocal 4
2624: oPushResult
2625: oNodeSet
2626: oPop 3
2628: oGetLocal 2
2630: oPushResult
2631: oScopeDeclare
2632: oPop 1
2634: oGetLocal 2
2636: oPushResult
2637: oSetResult 21
2639: oPushResult
2640: oGetLocal 5
2642: oPushResult
2643: oScopeAllocType
2644: oPop 1
2646: oPushResult
2647: oNodeSetInt
2648: oPop 3
2650: oGetAddrLocal 6
2652: oPushResult
2653: inc
2654: oPop 1
2656: oJumpForward 2663
2658: Choice Lookup Table
           0   2603
2661: oJumpForward 2665
2663: oJumpBack 2588
2665: oGetLocal 1
2667: oPushResult
2668: oNodeVecDelete
2669: oPop 1
2671: oInputChoice 2679
2673: oJumpForward 2687
2675: oJumpForward 2685
2677: oJumpForward 2685
2679: Choice Lookup Table
           4   2677
          14   2673
2684: oEndChoice
2685: oJumpBack 2470
2687: oJumpForward 2692
2689: Choice Lookup Table
          13   2470
2692: oReturn
2693: oLocalSpace 2
2695: oInputChoice 2757
2697: oGetAddrLocal 1
2699: oPushResult
2700: oSetResult 12
2702: oPushResult
2703: oSetResult 4
2705: oPushResult
2706: LAST_ID
2707: oPushResult
2708: oCall 7803
2710: oPop 3
2712: oAssign
2713: oInput 5
2715: oCall 3531
2717: oGetAddrLocal 2
2719: oPushResult
2720: oValueTop
2721: oAssign
2722: oValuePop
2723: oGetLocal 1
2725: oPushResult
2726: oSetResult 21
2728: oPushResult
2729: oGetLocal 2
2731: oPushResult
2732: oNodeSetInt
2733: oPop 3
2735: oGetLocal 1
2737: oPushResult
2738: oSetResult 20
2740: oPushResult
2741: oGetGlobal 4
2743: oPushResult
2744: oNodeSet
2745: oPop 3
2747: oGetLocal 1
2749: oPushResult
2750: oScopeDeclare
2751: oPop 1
2753: oInput 4
2755: oJumpForward 2762
2757: Choice Lookup Table
           0   2697
2760: oJumpForward 2764
2762: oJumpBack 2695
2764: oReturn
2765: oLocalSpace 2
2767: oInputChoice 2816
2769: oGetAddrLocal 1
2771: oPushResult
2772: oSetResult 13
2774: oPushResult
2775: oSetResult 5
2777: oPushResult
2778: LAST_ID
2779: oPushResult
2780: oCall 7803
2782: oPop 3
2784: oAssign
2785: oInput 5
2787: oGetAddrLocal 2
2789: oPushResult
2790: oCall 3054
2792: oPop 1
2794: oGetLocal 1
2796: oPushResult
2797: oSetResult 20
2799: oPushResult
2800: oGetLocal 2
2802: oPushResult
2803: oNodeSet
2804: oPop 3
2806: oGetLocal 1
2808: oPushResult
2809: oScopeDeclare
2810: oPop 1
2812: oInput 4
2814: oJumpForward 2821
2816: Choice Lookup Table
           0   2769
2819: oJumpForward 2823
2821: oJumpBack 2767
2823: oReturn
2824: oLocalSpace 6
2826: oInputChoice 3046
2828: oGetAddrLocal 1
2830: oPushResult
2831: oNodeVecNew
2832: oAssign
2833: oGetAddrLocal 2
2835: oPushResult
2836: oGetParam 1
2838: oPushResult
2839: oSetResult 6
2841: oPushResult
2842: LAST_ID
2843: oPushResult
2844: oCall 7803
2846: oPop 3
2848: oAssign
2849: oGetLocal 1
2851: oPushResult
2852: oGetLocal 2
2854: oPushResult
2855: oNodeVecAppend
2856: oPop 2
2858: oInputChoice 2864
2860: oInput 0
2862: oJumpForward 2869
2864: Choice Lookup Table
          12   2860
2867: oJumpForward 2871
2869: oJumpBack 2833
2871: oInput 11
2873: oGetAddrLocal 3
2875: oPushResult
2876: oCall 3054
2878: oPop 1
2880: oGetAddrLocal 4
2882: oPushResult
2883: oSetResult 0
2885: oAssign
2886: oGetLocal 4
2888: oPushResult
2889: oGetLocal 1
2891: oPushResult
2892: oNodeVecSize
2893: oPop 1
2895: oPushResult
2896: equal
2897: oPop 2
2899: oChoice 2940
2901: oGetAddrLocal 2
2903: oPushResult
2904: oGetLocal 1
2906: oPushResult
2907: oGetLocal 4
2909: oPushResult
2910: oNodeVecElement
2911: oPop 2
2913: oAssign
2914: oGetLocal 2
2916: oPushResult
2917: oSetResult 20
2919: oPushResult
2920: oGetLocal 3
2922: oPushResult
2923: oNodeSet
2924: oPop 3
2926: oGetLocal 2
2928: oPushResult
2929: oScopeDeclareAlloc
2930: oPop 1
2932: oGetAddrLocal 4
2934: oPushResult
2935: inc
2936: oPop 1
2938: oJumpForward 2945
2940: Choice Lookup Table
           0   2901
2943: oJumpForward 2947
2945: oJumpBack 2886
2947: oInputChoice 3033
2949: oGetLocal 1
2951: oPushResult
2952: oNodeVecSize
2953: oPop 1
2955: oChoice 2959
2957: oJumpForward 2964
2959: Choice Lookup Table
           1   2957
2962: oError 22
2964: oGetAddrLocal 5
2966: oPushResult
2967: oCall 1539
2969: oAssign
2970: oGetLocal 5
2972: oPushResult
2973: oCodePush
2974: oPop 1
2976: oGetAddrLocal 6
2978: oPushResult
2979: oSetResult 0
2981: oAssign
2982: oCall 7639
2984: oPushResult
2985: equal_zero
2986: oPop 1
2988: oChoice 3004
2990: oGetGlobal 2
2992: oPushResult
2993: oScopeEnter
2994: oPop 1
2996: oGetAddrLocal 6
2998: oPushResult
2999: oSetResult 1
3001: oAssign
3002: oJumpForward 3007
3004: Choice Lookup Table
           1   2990
3007: oGetLocal 2
3009: oPushResult
3010: oCall 6958
3012: oPop 1
3014: oCall 3597
3016: oCall 7689
3018: oCall 6752
3020: oGetLocal 6
3022: oChoice 3027
3024: oScopeEnd
3025: oJumpForward 3030
3027: Choice Lookup Table
           1   3024
3030: oCodePop
3031: oJumpForward 3036
3033: Choice Lookup Table
           5   2949
3036: oGetLocal 1
3038: oPushResult
3039: oNodeVecDelete
3040: oPop 1
3042: oInput 4
3044: oJumpForward 3051
3046: Choice Lookup Table
           0   2828
3049: oJumpForward 3053
3051: oJumpBack 2826
3053: oReturn
3054: oLocalSpace 12
3056: oInputChoice 3513
3058: oGetAddrLocal 1
3060: oPushResult
3061: oScopeFindRequire
3062: oAssign
3063: oGetLocal 1
3065: oPushResult
3066: oNodeType
3067: oPop 1
3069: oChoice 3086
3071: oGetParam 1
3073: oPushResult
3074: oGetLocal 1
3076: oPushResult
3077: oSetResult 20
3079: oPushResult
3080: oNodeGet
3081: oPop 2
3083: oAssign
3084: oJumpForward 3097
3086: Choice Lookup Table
          13   3071
3089: oError 2
3091: oGetParam 1
3093: oPushResult
3094: oGetGlobal 4
3096: oAssign
3097: oJumpForward 3530
3099: oInput 15
3101: oGetAddrLocal 2
3103: oPushResult
3104: oNodeVecNew
3105: oAssign
3106: oGetAddrLocal 3
3108: oPushResult
3109: oSetResult 28
3111: oPushResult
3112: oNodeNew
3113: oPop 1
3115: oAssign
3116: oGetLocal 3
3118: oPushResult
3119: oSetResult 33
3121: oPushResult
3122: oGetGlobal 4
3124: oPushResult
3125: oNodeSet
3126: oPop 3
3128: oCall 3531
3130: oGetLocal 3
3132: oPushResult
3133: oSetResult 35
3135: oPushResult
3136: oValueTop
3137: oPushResult
3138: oNodeSetInt
3139: oPop 3
3141: oValuePop
3142: oInput 20
3144: oCall 3531
3146: oGetLocal 3
3148: oPushResult
3149: oSetResult 36
3151: oPushResult
3152: oValueTop
3153: oPushResult
3154: oNodeSetInt
3155: oPop 3
3157: oValuePop
3158: oGetLocal 3
3160: oPushResult
3161: oSetResult 16
3163: oPushResult
3164: oSetResult 4
3166: oPushResult
3167: oNodeSetInt
3168: oPop 3
3170: oGetLocal 3
3172: oPushResult
3173: oTypeAdd
3174: oPop 1
3176: oGetAddrLocal 4
3178: oPushResult
3179: oSetResult 27
3181: oPushResult
3182: oNodeNew
3183: oPop 1
3185: oAssign
3186: oGetLocal 4
3188: oPushResult
3189: oSetResult 34
3191: oPushResult
3192: oGetLocal 3
3194: oPushResult
3195: oNodeSet
3196: oPop 3
3198: oGetLocal 2
3200: oPushResult
3201: oGetLocal 4
3203: oPushResult
3204: oNodeVecAppend
3205: oPop 2
3207: oInputChoice 3215
3209: oJumpForward 3223
3211: oJumpForward 3221
3213: oJumpForward 3221
3215: Choice Lookup Table
          12   3213
          16   3209
3220: oEndChoice
3221: oJumpBack 3106
3223: oInput 38
3225: oGetAddrLocal 5
3227: oPushResult
3228: oCall 3054
3230: oPop 1
3232: oGetAddrLocal 6
3234: oPushResult
3235: oGetLocal 2
3237: oPushResult
3238: oNodeVecSize
3239: oPop 1
3241: oAssign
3242: oGetAddrLocal 6
3244: oPushResult
3245: dec
3246: oPop 1
3248: oGetAddrLocal 7
3250: oPushResult
3251: oGetLocal 2
3253: oPushResult
3254: oGetLocal 6
3256: oPushResult
3257: oNodeVecElement
3258: oPop 2
3260: oAssign
3261: oGetLocal 7
3263: oPushResult
3264: oSetResult 33
3266: oPushResult
3267: oGetLocal 5
3269: oPushResult
3270: oNodeSet
3271: oPop 3
3273: oGetAddrLocal 8
3275: oPushResult
3276: oGetLocal 7
3278: oPushResult
3279: oSetResult 34
3281: oPushResult
3282: oNodeGet
3283: oPop 2
3285: oAssign
3286: oGetAddrLocal 9
3288: oPushResult
3289: oGetLocal 8
3291: oPushResult
3292: oSetResult 36
3294: oPushResult
3295: oNodeGetInt
3296: oPop 2
3298: oPushResult
3299: oGetLocal 8
3301: oPushResult
3302: oSetResult 35
3304: oPushResult
3305: oNodeGetInt
3306: oPop 2
3308: oPushResult
3309: subtract
3310: oPop 2
3312: oAssign
3313: oGetAddrLocal 9
3315: oPushResult
3316: inc
3317: oPop 1
3319: oGetLocal 7
3321: oPushResult
3322: oSetResult 16
3324: oPushResult
3325: oGetLocal 9
3327: oPushResult
3328: oGetLocal 5
3330: oPushResult
3331: oSetResult 16
3333: oPushResult
3334: oNodeGetInt
3335: oPop 2
3337: oPushResult
3338: multiply
3339: oPop 2
3341: oPushResult
3342: oNodeSetInt
3343: oPop 3
3345: oGetLocal 7
3347: oPushResult
3348: oTypeAdd
3349: oPop 1
3351: oGetAddrLocal 5
3353: oPushResult
3354: oGetLocal 7
3356: oAssign
3357: oGetLocal 6
3359: oPushResult
3360: equal_zero
3361: oPop 1
3363: oChoice 3369
3365: oJumpForward 3374
3367: oJumpForward 3372
3369: Choice Lookup Table
           1   3365
3372: oJumpBack 3242
3374: oGetParam 1
3376: oPushResult
3377: oGetLocal 2
3379: oPushResult
3380: oSetResult 0
3382: oPushResult
3383: oNodeVecElement
3384: oPop 2
3386: oAssign
3387: oGetLocal 2
3389: oPushResult
3390: oNodeVecDelete
3391: oPop 1
3393: oJumpForward 3530
3395: oGetAddrLocal 10
3397: oPushResult
3398: oCall 3054
3400: oPop 1
3402: oGetParam 1
3404: oPushResult
3405: oGetLocal 10
3407: oPushResult
3408: oCall 7831
3410: oPop 1
3412: oAssign
3413: oJumpForward 3530
3415: oGetParam 1
3417: oPushResult
3418: oSetResult 29
3420: oPushResult
3421: oNodeNew
3422: oPop 1
3424: oAssign
3425: oSetResult -1
3427: oPushResult
3428: oSetResult 2
3430: oPushResult
3431: oScopeBegin
3432: oPop 2
3434: oSetResult 17
3436: oPushResult
3437: oCall 2824
3439: oPop 1
3441: oGetAddrLocal 11
3443: oPushResult
3444: oScopeCurrent
3445: oPushResult
3446: oSetResult 16
3448: oPushResult
3449: oNodeGetInt
3450: oPop 2
3452: oAssign
3453: oGetLocal 11
3455: oPushResult
3456: equal_zero
3457: oPop 1
3459: oChoice 3465
3461: oError 19
3463: oJumpForward 3468
3465: Choice Lookup Table
           1   3461
3468: oInput 34
3470: oGetFromParam 1
3472: oPushResult
3473: oSetResult 37
3475: oPushResult
3476: oScopeCurrent
3477: oPushResult
3478: oNodeSet
3479: oPop 3
3481: oGetFromParam 1
3483: oPushResult
3484: oSetResult 16
3486: oPushResult
3487: oGetLocal 11
3489: oPushResult
3490: oNodeSetInt
3491: oPop 3
3493: oScopeEnd
3494: oGetFromParam 1
3496: oPushResult
3497: oTypeAdd
3498: oPop 1
3500: oJumpForward 3530
3502: oInput 38
3504: oGetAddrLocal 12
3506: oPushResult
3507: oCall 3054
3509: oPop 1
3511: oJumpForward 3530
3513: Choice Lookup Table
          37   3502
          36   3415
          17   3395
          35   3099
           0   3058
3524: oCall 3531
3526: oInput 20
3528: oCall 3531
3530: oReturn
3531: oLocalSpace 1
3533: oInputChoice 3588
3535: TOKEN_VALUE
3536: oPushResult
3537: oValuePush
3538: oPop 1
3540: oJumpForward 3596
3542: oGetAddrLocal 1
3544: oPushResult
3545: oScopeFindRequire
3546: oAssign
3547: oGetLocal 1
3549: oPushResult
3550: oNodeType
3551: oPop 1
3553: oChoice 3570
3555: oGetLocal 1
3557: oPushResult
3558: oSetResult 21
3560: oPushResult
3561: oNodeGetInt
3562: oPop 2
3564: oPushResult
3565: oValuePush
3566: oPop 1
3568: oJumpForward 3581
3570: Choice Lookup Table
          12   3555
3573: oError 1
3575: oSetResult 0
3577: oPushResult
3578: oValuePush
3579: oPop 1
3581: oJumpForward 3596
3583: oCall 3531
3585: oValueNegate
3586: oJumpForward 3596
3588: Choice Lookup Table
          24   3583
           0   3542
           1   3535
3595: oEndChoice
3596: oReturn
3597: oLocalSpace 1
3599: oGetAddrLocal 1
3601: oPushResult
3602: oSetResult 0
3604: oAssign
3605: oGetAddrLocal 1
3607: oPushResult
3608: oCall 3758
3610: oPop 1
3612: oGetAddrLocal 1
3614: oPushResult
3615: oCall 3658
3617: oPop 1
3619: oReturn
3620: oLocalSpace 0
3622: oGetParam 1
3624: oPushResult
3625: oCall 3758
3627: oPop 1
3629: oTypeSNodeType
3630: oChoice 3649
3632: oJumpForward 3656
3634: oGetParam 1
3636: oPushResult
3637: oLabelNew
3638: oAssign
3639: oEmit 55
3641: oGetFromParam 1
3643: oPushResult
3644: oEmitLabel
3645: oPop 1
3647: oJumpForward 3656
3649: Choice Lookup Table
          22   3634
          23   3632
3654: oError 8
3656: oTypeSPop
3657: oReturn
3658: oLocalSpace 1
3660: oTypeSNodeType
3661: oChoice 3723
3663: oGetAddrLocal 1
3665: oPushResult
3666: oLabelNew
3667: oAssign
3668: oEmit 15
3670: oSetResult 1
3672: oPushResult
3673: oEmitInt
3674: oPop 1
3676: oEmit 53
3678: oGetLocal 1
3680: oPushResult
3681: oEmitLabel
3682: oPop 1
3684: oEmit 56
3686: oGetFromParam 1
3688: oPushResult
3689: oEmitLabel
3690: oPop 1
3692: oEmit 15
3694: oSetResult 0
3696: oPushResult
3697: oEmitInt
3698: oPop 1
3700: oEmit 56
3702: oGetLocal 1
3704: oPushResult
3705: oEmitLabel
3706: oPop 1
3708: oTypeSPop
3709: oGetGlobal 5
3711: oPushResult
3712: oTypeSPush
3713: oPop 1
3715: oGetParam 1
3717: oPushResult
3718: oSetResult 0
3720: oAssign
3721: oJumpForward 3726
3723: Choice Lookup Table
          23   3663
3726: oReturn
3727: oLocalSpace 0
3729: oTypeSNodeType
3730: oChoice 3754
3732: oGetParam 1
3734: oPushResult
3735: oLabelNew
3736: oAssign
3737: oEmit 55
3739: oGetFromParam 1
3741: oPushResult
3742: oEmitLabel
3743: oPop 1
3745: oTypeSPop
3746: oGetGlobal 6
3748: oPushResult
3749: oTypeSPush
3750: oPop 1
3752: oJumpForward 3757
3754: Choice Lookup Table
          22   3732
3757: oReturn
3758: oLocalSpace 0
3760: oGetParam 1
3762: oPushResult
3763: oCall 4123
3765: oPop 1
3767: oInputChoice 4105
3769: oGetParam 1
3771: oPushResult
3772: oCall 3658
3774: oPop 1
3776: oGetParam 1
3778: oPushResult
3779: oCall 4123
3781: oPop 1
3783: oGetParam 1
3785: oPushResult
3786: oCall 3658
3788: oPop 1
3790: oCall 7689
3792: oTypeSNodeType
3793: oChoice 3807
3795: oEmit 38
3797: oJumpForward 3820
3799: oEmit 44
3801: oJumpForward 3820
3803: oError 16
3805: oJumpForward 3820
3807: Choice Lookup Table
          25   3803
          24   3803
          26   3799
          22   3795
          21   3795
3818: oError 17
3820: oTypeSPop
3821: oGetGlobal 5
3823: oPushResult
3824: oTypeSPush
3825: oPop 1
3827: oJumpForward 4120
3829: oGetParam 1
3831: oPushResult
3832: oCall 3658
3834: oPop 1
3836: oGetParam 1
3838: oPushResult
3839: oCall 4123
3841: oPop 1
3843: oGetParam 1
3845: oPushResult
3846: oCall 3658
3848: oPop 1
3850: oCall 7689
3852: oTypeSNodeType
3853: oChoice 3867
3855: oEmit 39
3857: oJumpForward 3880
3859: oEmit 45
3861: oJumpForward 3880
3863: oError 16
3865: oJumpForward 3880
3867: Choice Lookup Table
          25   3863
          24   3863
          26   3859
          22   3855
          21   3855
3878: oError 17
3880: oTypeSPop
3881: oGetGlobal 5
3883: oPushResult
3884: oTypeSPush
3885: oPop 1
3887: oJumpForward 4120
3889: oGetParam 1
3891: oPushResult
3892: oCall 3658
3894: oPop 1
3896: oGetParam 1
3898: oPushResult
3899: oCall 4123
3901: oPop 1
3903: oGetParam 1
3905: oPushResult
3906: oCall 3658
3908: oPop 1
3910: oCall 7689
3912: oTypeSNodeType
3913: oChoice 3923
3915: oEmit 41
3917: oJumpForward 3934
3919: oError 16
3921: oJumpForward 3934
3923: Choice Lookup Table
          25   3919
          24   3919
          22   3915
          21   3915
3932: oError 17
3934: oTypeSPop
3935: oGetGlobal 5
3937: oPushResult
3938: oTypeSPush
3939: oPop 1
3941: oJumpForward 4120
3943: oGetParam 1
3945: oPushResult
3946: oCall 3658
3948: oPop 1
3950: oGetParam 1
3952: oPushResult
3953: oCall 4123
3955: oPop 1
3957: oGetParam 1
3959: oPushResult
3960: oCall 3658
3962: oPop 1
3964: oCall 7689
3966: oTypeSNodeType
3967: oChoice 3977
3969: oEmit 40
3971: oJumpForward 3988
3973: oError 16
3975: oJumpForward 3988
3977: Choice Lookup Table
          25   3973
          24   3973
          22   3969
          21   3969
3986: oError 17
3988: oTypeSPop
3989: oGetGlobal 5
3991: oPushResult
3992: oTypeSPush
3993: oPop 1
3995: oJumpForward 4120
3997: oGetParam 1
3999: oPushResult
4000: oCall 3658
4002: oPop 1
4004: oGetParam 1
4006: oPushResult
4007: oCall 4123
4009: oPop 1
4011: oGetParam 1
4013: oPushResult
4014: oCall 3658
4016: oPop 1
4018: oCall 7689
4020: oTypeSNodeType
4021: oChoice 4031
4023: oEmit 43
4025: oJumpForward 4042
4027: oError 16
4029: oJumpForward 4042
4031: Choice Lookup Table
          25   4027
          24   4027
          22   4023
          21   4023
4040: oError 17
4042: oTypeSPop
4043: oGetGlobal 5
4045: oPushResult
4046: oTypeSPush
4047: oPop 1
4049: oJumpForward 4120
4051: oGetParam 1
4053: oPushResult
4054: oCall 3658
4056: oPop 1
4058: oGetParam 1
4060: oPushResult
4061: oCall 4123
4063: oPop 1
4065: oGetParam 1
4067: oPushResult
4068: oCall 3658
4070: oPop 1
4072: oCall 7689
4074: oTypeSNodeType
4075: oChoice 4085
4077: oEmit 42
4079: oJumpForward 4096
4081: oError 16
4083: oJumpForward 4096
4085: Choice Lookup Table
          25   4081
          24   4081
          22   4077
          21   4077
4094: oError 17
4096: oTypeSPop
4097: oGetGlobal 5
4099: oPushResult
4100: oTypeSPush
4101: oPop 1
4103: oJumpForward 4120
4105: Choice Lookup Table
          10   4051
           9   3997
           8   3943
           7   3889
           6   3829
           5   3769
4118: oJumpForward 4122
4120: oJumpBack 3767
4122: oReturn
4123: oLocalSpace 1
4125: oGetAddrLocal 1
4127: oPushResult
4128: oSetResult 0
4130: oAssign
4131: oGetParam 1
4133: oPushResult
4134: oCall 4303
4136: oPop 1
4138: oInputChoice 4271
4140: oTypeSNodeType
4141: oChoice 4212
4143: oGetLocal 1
4145: oPushResult
4146: oSetResult 0
4148: oPushResult
4149: equal_label
4150: oPop 2
4152: oChoice 4161
4154: oGetAddrLocal 1
4156: oPushResult
4157: oLabelNew
4158: oAssign
4159: oJumpForward 4164
4161: Choice Lookup Table
           1   4154
4164: oEmit 53
4166: oGetLocal 1
4168: oPushResult
4169: oEmitLabel
4170: oPop 1
4172: oJumpForward 4219
4174: oGetParam 1
4176: oPushResult
4177: oCall 3727
4179: oPop 1
4181: oGetLocal 1
4183: oPushResult
4184: oSetResult 0
4186: oPushResult
4187: equal_label
4188: oPop 2
4190: oChoice 4199
4192: oGetAddrLocal 1
4194: oPushResult
4195: oLabelNew
4196: oAssign
4197: oJumpForward 4202
4199: Choice Lookup Table
           1   4192
4202: oEmit 53
4204: oGetLocal 1
4206: oPushResult
4207: oEmitLabel
4208: oPop 1
4210: oJumpForward 4219
4212: Choice Lookup Table
          22   4174
          23   4143
4217: oError 8
4219: oTypeSPop
4220: oEmit 56
4222: oGetFromParam 1
4224: oPushResult
4225: oEmitLabel
4226: oPop 1
4228: oGetParam 1
4230: oPushResult
4231: oSetResult 0
4233: oAssign
4234: oGetParam 1
4236: oPushResult
4237: oCall 4303
4239: oPop 1
4241: oTypeSNodeType
4242: oChoice 4255
4244: oJumpForward 4262
4246: oGetParam 1
4248: oPushResult
4249: oCall 3727
4251: oPop 1
4253: oJumpForward 4262
4255: Choice Lookup Table
          22   4246
          23   4244
4260: oError 8
4262: oTypeSPop
4263: oGetGlobal 6
4265: oPushResult
4266: oTypeSPush
4267: oPop 1
4269: oJumpForward 4276
4271: Choice Lookup Table
          52   4140
4274: oJumpForward 4278
4276: oJumpBack 4138
4278: oGetLocal 1
4280: oPushResult
4281: oSetResult 0
4283: oPushResult
4284: equal_label
4285: oPop 2
4287: oChoice 4299
4289: oEmit 56
4291: oGetLocal 1
4293: oPushResult
4294: oEmitLabel
4295: oPop 1
4297: oJumpForward 4302
4299: Choice Lookup Table
           0   4289
4302: oReturn
4303: oLocalSpace 2
4305: oGetAddrLocal 1
4307: oPushResult
4308: oSetResult 0
4310: oAssign
4311: oGetParam 1
4313: oPushResult
4314: oCall 4441
4316: oPop 1
4318: oInputChoice 4433
4320: oTypeSNodeType
4321: oChoice 4334
4323: oJumpForward 4341
4325: oGetParam 1
4327: oPushResult
4328: oCall 3727
4330: oPop 1
4332: oJumpForward 4341
4334: Choice Lookup Table
          22   4325
          23   4323
4339: oError 8
4341: oTypeSPop
4342: oGetLocal 1
4344: oPushResult
4345: oSetResult 0
4347: oPushResult
4348: equal_label
4349: oPop 2
4351: oChoice 4380
4353: oGetAddrLocal 1
4355: oPushResult
4356: oLabelNew
4357: oAssign
4358: oEmit 57
4360: oGetFromParam 1
4362: oPushResult
4363: oEmitLabel
4364: oPop 1
4366: oGetLocal 1
4368: oPushResult
4369: oEmitLabel
4370: oPop 1
4372: oGetParam 1
4374: oPushResult
4375: oGetLocal 1
4377: oAssign
4378: oJumpForward 4383
4380: Choice Lookup Table
           1   4353
4383: oGetAddrLocal 2
4385: oPushResult
4386: oSetResult 0
4388: oAssign
4389: oGetAddrLocal 2
4391: oPushResult
4392: oCall 4441
4394: oPop 1
4396: oTypeSNodeType
4397: oChoice 4410
4399: oJumpForward 4417
4401: oGetAddrLocal 2
4403: oPushResult
4404: oCall 3727
4406: oPop 1
4408: oJumpForward 4417
4410: Choice Lookup Table
          22   4401
          23   4399
4415: oError 8
4417: oEmit 57
4419: oGetLocal 2
4421: oPushResult
4422: oEmitLabel
4423: oPop 1
4425: oGetLocal 1
4427: oPushResult
4428: oEmitLabel
4429: oPop 1
4431: oJumpForward 4438
4433: Choice Lookup Table
          51   4320
4436: oJumpForward 4440
4438: oJumpBack 4318
4440: oReturn
4441: oLocalSpace 1
4443: oInputChoice 4497
4445: oGetAddrLocal 1
4447: oPushResult
4448: oSetResult 0
4450: oAssign
4451: oGetAddrLocal 1
4453: oPushResult
4454: oCall 4441
4456: oPop 1
4458: oTypeSNodeType
4459: oChoice 4488
4461: oGetParam 1
4463: oPushResult
4464: oLabelNew
4465: oAssign
4466: oEmit 53
4468: oGetFromParam 1
4470: oPushResult
4471: oEmitLabel
4472: oPop 1
4474: oEmit 56
4476: oGetLocal 1
4478: oPushResult
4479: oEmitLabel
4480: oPop 1
4482: oJumpForward 4495
4484: oEmit 37
4486: oJumpForward 4495
4488: Choice Lookup Table
          22   4484
          23   4461
4493: oError 8
4495: oJumpForward 4507
4497: Choice Lookup Table
          53   4445
4500: oGetParam 1
4502: oPushResult
4503: oCall 4508
4505: oPop 1
4507: oReturn
4508: oLocalSpace 0
4510: oGetParam 1
4512: oPushResult
4513: oCall 4559
4515: oPop 1
4517: oInputChoice 4549
4519: oCall 7715
4521: oGetParam 1
4523: oPushResult
4524: oCall 4559
4526: oPop 1
4528: oCall 7729
4530: oEmit 34
4532: oJumpForward 4556
4534: oCall 7715
4536: oGetParam 1
4538: oPushResult
4539: oCall 4559
4541: oPop 1
4543: oCall 7729
4545: oEmit 35
4547: oJumpForward 4556
4549: Choice Lookup Table
          24   4534
          23   4519
4554: oJumpForward 4558
4556: oJumpBack 4517
4558: oReturn
4559: oLocalSpace 0
4561: oGetParam 1
4563: oPushResult
4564: oCall 4610
4566: oPop 1
4568: oInputChoice 4600
4570: oCall 7715
4572: oGetParam 1
4574: oPushResult
4575: oCall 4610
4577: oPop 1
4579: oCall 7729
4581: oEmit 31
4583: oJumpForward 4607
4585: oCall 7715
4587: oGetParam 1
4589: oPushResult
4590: oCall 4610
4592: oPop 1
4594: oCall 7729
4596: oEmit 32
4598: oJumpForward 4607
4600: Choice Lookup Table
          22   4585
          21   4570
4605: oJumpForward 4609
4607: oJumpBack 4568
4609: oReturn
4610: oLocalSpace 0
4612: oInputChoice 4638
4614: oGetParam 1
4616: oPushResult
4617: oCall 4651
4619: oPop 1
4621: oCall 7729
4623: oJumpForward 4650
4625: oGetParam 1
4627: oPushResult
4628: oCall 4651
4630: oPop 1
4632: oCall 7729
4634: oEmit 36
4636: oJumpForward 4650
4638: Choice Lookup Table
          24   4625
          23   4614
4643: oGetParam 1
4645: oPushResult
4646: oCall 4651
4648: oPop 1
4650: oReturn
4651: oLocalSpace 6
4653: oInputChoice 4839
4655: oEmit 15
4657: TOKEN_VALUE
4658: oPushResult
4659: oEmitInt
4660: oPop 1
4662: oGetGlobal 4
4664: oPushResult
4665: oTypeSPush
4666: oPop 1
4668: oJumpForward 4858
4670: oGetParam 1
4672: oPushResult
4673: oCall 3758
4675: oPop 1
4677: oInput 14
4679: oJumpForward 4858
4681: oGetAddrLocal 1
4683: oPushResult
4684: CURRENT_STRLIT
4685: oPushResult
4686: oStringAllocLit
4687: oPop 1
4689: oAssign
4690: oEmit 16
4692: oGetLocal 1
4694: oPushResult
4695: oEmitInt
4696: oPop 1
4698: oGetGlobal 8
4700: oPushResult
4701: oTypeSPush
4702: oPop 1
4704: oJumpForward 4858
4706: oGetAddrLocal 2
4708: oPushResult
4709: oScopeFindRequire
4710: oAssign
4711: oGetLocal 2
4713: oPushResult
4714: oNodeType
4715: oPop 1
4717: oChoice 4779
4719: oGetLocal 2
4721: oPushResult
4722: oCall 6011
4724: oPop 1
4726: oJumpForward 4798
4728: oGetAddrLocal 3
4730: oPushResult
4731: oGetLocal 2
4733: oPushResult
4734: oSetResult 20
4736: oPushResult
4737: oNodeGet
4738: oPop 2
4740: oAssign
4741: oGetLocal 3
4743: oPushResult
4744: oTypeSPush
4745: oPop 1
4747: oTypeSNodeType
4748: oChoice 4761
4750: oEmit 15
4752: oGetLocal 2
4754: oPushResult
4755: oCall 7966
4757: oPop 1
4759: oJumpForward 4768
4761: Choice Lookup Table
          22   4750
          21   4750
4766: oError 16
4768: oJumpForward 4798
4770: oGetLocal 2
4772: oPushResult
4773: oCall 4859
4775: oPop 1
4777: oJumpForward 4798
4779: Choice Lookup Table
          18   4770
          16   4770
          15   4770
          12   4728
          11   4719
4790: oError 6
4792: oGetGlobal 4
4794: oPushResult
4795: oTypeSPush
4796: oPop 1
4798: oJumpForward 4858
4800: oInput 0
4802: oGetAddrLocal 4
4804: oPushResult
4805: oScopeFindRequire
4806: oAssign
4807: oGetLocal 4
4809: oPushResult
4810: oCall 6958
4812: oPop 1
4814: oGetAddrLocal 5
4816: oPushResult
4817: oTypeSTop
4818: oAssign
4819: oTypeSPop
4820: oGetAddrLocal 6
4822: oPushResult
4823: oGetLocal 5
4825: oPushResult
4826: oCall 7831
4828: oPop 1
4830: oAssign
4831: oGetLocal 6
4833: oPushResult
4834: oTypeSPush
4835: oPop 1
4837: oJumpForward 4858
4839: Choice Lookup Table
          18   4800
           0   4706
           2   4681
          13   4670
           1   4655
4850: oError 6
4852: oGetGlobal 4
4854: oPushResult
4855: oTypeSPush
4856: oPop 1
4858: oReturn
4859: oLocalSpace 2
4861: oGetAddrLocal 1
4863: oPushResult
4864: oGetParam 1
4866: oPushResult
4867: oSetResult 20
4869: oPushResult
4870: oNodeGet
4871: oPop 2
4873: oAssign
4874: oGetAddrLocal 2
4876: oPushResult
4877: oGetParam 1
4879: oPushResult
4880: oCall 7671
4882: oPop 1
4884: oAssign
4885: oGetLocal 1
4887: oPushResult
4888: oTypeSPush
4889: oPop 1
4891: oTypeSNodeType
4892: oChoice 5409
4894: oGetParam 1
4896: oPushResult
4897: oNodeType
4898: oPop 1
4900: oChoice 5046
4902: oEmit 0
4904: oGetParam 1
4906: oPushResult
4907: oCall 7966
4909: oPop 1
4911: oJumpForward 5054
4913: oGetLocal 2
4915: oPushResult
4916: equal_zero
4917: oPop 1
4919: oChoice 4932
4921: oEmit 3
4923: oGetParam 1
4925: oPushResult
4926: oCall 7966
4928: oPop 1
4930: oJumpForward 4950
4932: Choice Lookup Table
           1   4921
4935: oEmit 9
4937: oGetLocal 2
4939: oPushResult
4940: oEmitInt
4941: oPop 1
4943: oGetParam 1
4945: oPushResult
4946: oCall 7966
4948: oPop 1
4950: oJumpForward 5054
4952: oGetParam 1
4954: oPushResult
4955: oSetResult 31
4957: oPushResult
4958: oNodeGetBoolean
4959: oPop 2
4961: oChoice 5004
4963: oGetLocal 2
4965: oPushResult
4966: equal_zero
4967: oPop 1
4969: oChoice 4982
4971: oEmit 8
4973: oGetParam 1
4975: oPushResult
4976: oCall 7966
4978: oPop 1
4980: oJumpForward 5000
4982: Choice Lookup Table
           1   4971
4985: oEmit 14
4987: oGetLocal 2
4989: oPushResult
4990: oEmitInt
4991: oPop 1
4993: oGetParam 1
4995: oPushResult
4996: oCall 7966
4998: oPop 1
5000: oEmit 22
5002: oJumpForward 5044
5004: Choice Lookup Table
           1   4963
5007: oGetLocal 2
5009: oPushResult
5010: equal_zero
5011: oPop 1
5013: oChoice 5026
5015: oEmit 6
5017: oGetParam 1
5019: oPushResult
5020: oCall 7966
5022: oPop 1
5024: oJumpForward 5044
5026: Choice Lookup Table
           1   5015
5029: oEmit 12
5031: oGetLocal 2
5033: oPushResult
5034: oEmitInt
5035: oPop 1
5037: oGetParam 1
5039: oPushResult
5040: oCall 7966
5042: oPop 1
5044: oJumpForward 5054
5046: Choice Lookup Table
          18   4952
          16   4913
          15   4902
5053: oEndChoice
5054: oJumpForward 5584
5056: oGetParam 1
5058: oPushResult
5059: oNodeType
5060: oPop 1
5062: oChoice 5208
5064: oEmit 1
5066: oGetParam 1
5068: oPushResult
5069: oCall 7966
5071: oPop 1
5073: oJumpForward 5216
5075: oGetLocal 2
5077: oPushResult
5078: equal_zero
5079: oPop 1
5081: oChoice 5094
5083: oEmit 4
5085: oGetParam 1
5087: oPushResult
5088: oCall 7966
5090: oPop 1
5092: oJumpForward 5112
5094: Choice Lookup Table
           1   5083
5097: oEmit 10
5099: oGetLocal 2
5101: oPushResult
5102: oEmitInt
5103: oPop 1
5105: oGetParam 1
5107: oPushResult
5108: oCall 7966
5110: oPop 1
5112: oJumpForward 5216
5114: oGetParam 1
5116: oPushResult
5117: oSetResult 31
5119: oPushResult
5120: oNodeGetBoolean
5121: oPop 2
5123: oChoice 5166
5125: oGetLocal 2
5127: oPushResult
5128: equal_zero
5129: oPop 1
5131: oChoice 5144
5133: oEmit 8
5135: oGetParam 1
5137: oPushResult
5138: oCall 7966
5140: oPop 1
5142: oJumpForward 5162
5144: Choice Lookup Table
           1   5133
5147: oEmit 14
5149: oGetLocal 2
5151: oPushResult
5152: oEmitInt
5153: oPop 1
5155: oGetParam 1
5157: oPushResult
5158: oCall 7966
5160: oPop 1
5162: oEmit 23
5164: oJumpForward 5206
5166: Choice Lookup Table
           1   5125
5169: oGetLocal 2
5171: oPushResult
5172: equal_zero
5173: oPop 1
5175: oChoice 5188
5177: oEmit 7
5179: oGetParam 1
5181: oPushResult
5182: oCall 7966
5184: oPop 1
5186: oJumpForward 5206
5188: Choice Lookup Table
           1   5177
5191: oEmit 13
5193: oGetLocal 2
5195: oPushResult
5196: oEmitInt
5197: oPop 1
5199: oGetParam 1
5201: oPushResult
5202: oCall 7966
5204: oPop 1
5206: oJumpForward 5216
5208: Choice Lookup Table
          18   5114
          16   5075
          15   5064
5215: oEndChoice
5216: oJumpForward 5584
5218: oError 16
5220: oJumpForward 5584
5222: oGetParam 1
5224: oPushResult
5225: oNodeType
5226: oPop 1
5228: oChoice 5374
5230: oEmit 2
5232: oGetParam 1
5234: oPushResult
5235: oCall 7966
5237: oPop 1
5239: oJumpForward 5382
5241: oGetLocal 2
5243: oPushResult
5244: equal_zero
5245: oPop 1
5247: oChoice 5260
5249: oEmit 5
5251: oGetParam 1
5253: oPushResult
5254: oCall 7966
5256: oPop 1
5258: oJumpForward 5278
5260: Choice Lookup Table
           1   5249
5263: oEmit 11
5265: oGetLocal 2
5267: oPushResult
5268: oEmitInt
5269: oPop 1
5271: oGetParam 1
5273: oPushResult
5274: oCall 7966
5276: oPop 1
5278: oJumpForward 5382
5280: oGetParam 1
5282: oPushResult
5283: oSetResult 31
5285: oPushResult
5286: oNodeGetBoolean
5287: oPop 2
5289: oChoice 5332
5291: oGetLocal 2
5293: oPushResult
5294: equal_zero
5295: oPop 1
5297: oChoice 5310
5299: oEmit 8
5301: oGetParam 1
5303: oPushResult
5304: oCall 7966
5306: oPop 1
5308: oJumpForward 5328
5310: Choice Lookup Table
           1   5299
5313: oEmit 14
5315: oGetLocal 2
5317: oPushResult
5318: oEmitInt
5319: oPop 1
5321: oGetParam 1
5323: oPushResult
5324: oCall 7966
5326: oPop 1
5328: oEmit 24
5330: oJumpForward 5372
5332: Choice Lookup Table
           1   5291
5335: oGetLocal 2
5337: oPushResult
5338: equal_zero
5339: oPop 1
5341: oChoice 5354
5343: oEmit 8
5345: oGetParam 1
5347: oPushResult
5348: oCall 7966
5350: oPop 1
5352: oJumpForward 5372
5354: Choice Lookup Table
           1   5343
5357: oEmit 14
5359: oGetLocal 2
5361: oPushResult
5362: oEmitInt
5363: oPop 1
5365: oGetParam 1
5367: oPushResult
5368: oCall 7966
5370: oPop 1
5372: oJumpForward 5382
5374: Choice Lookup Table
          18   5280
          16   5241
          15   5230
5381: oEndChoice
5382: oInputChoice 5404
5384: oTypeSPop
5385: oGetLocal 1
5387: oPushResult
5388: oSetResult 33
5390: oPushResult
5391: oNodeGet
5392: oPop 2
5394: oPushResult
5395: oTypeSPush
5396: oPop 1
5398: oCall 5620
5400: oCall 5585
5402: oJumpForward 5407
5404: Choice Lookup Table
          17   5384
5407: oJumpForward 5584
5409: Choice Lookup Table
          26   5222
          20   5218
          25   5218
          24   5218
          22   5056
          21   4894
5422: oGetParam 1
5424: oPushResult
5425: oNodeType
5426: oPop 1
5428: oChoice 5572
5430: oEmit 16
5432: oGetParam 1
5434: oPushResult
5435: oCall 7966
5437: oPop 1
5439: oJumpForward 5580
5441: oGetLocal 2
5443: oPushResult
5444: equal_zero
5445: oPop 1
5447: oChoice 5460
5449: oEmit 17
5451: oGetParam 1
5453: oPushResult
5454: oCall 7966
5456: oPop 1
5458: oJumpForward 5478
5460: Choice Lookup Table
           1   5449
5463: oEmit 20
5465: oGetLocal 2
5467: oPushResult
5468: oEmitInt
5469: oPop 1
5471: oGetParam 1
5473: oPushResult
5474: oCall 7966
5476: oPop 1
5478: oJumpForward 5580
5480: oGetParam 1
5482: oPushResult
5483: oSetResult 31
5485: oPushResult
5486: oNodeGetBoolean
5487: oPop 2
5489: oChoice 5530
5491: oGetLocal 2
5493: oPushResult
5494: equal_zero
5495: oPop 1
5497: oChoice 5510
5499: oEmit 8
5501: oGetParam 1
5503: oPushResult
5504: oCall 7966
5506: oPop 1
5508: oJumpForward 5528
5510: Choice Lookup Table
           1   5499
5513: oEmit 14
5515: oGetLocal 2
5517: oPushResult
5518: oEmitInt
5519: oPop 1
5521: oGetParam 1
5523: oPushResult
5524: oCall 7966
5526: oPop 1
5528: oJumpForward 5570
5530: Choice Lookup Table
           1   5491
5533: oGetLocal 2
5535: oPushResult
5536: equal_zero
5537: oPop 1
5539: oChoice 5552
5541: oEmit 18
5543: oGetParam 1
5545: oPushResult
5546: oCall 7966
5548: oPop 1
5550: oJumpForward 5570
5552: Choice Lookup Table
           1   5541
5555: oEmit 21
5557: oGetLocal 2
5559: oPushResult
5560: oEmitInt
5561: oPop 1
5563: oGetParam 1
5565: oPushResult
5566: oCall 7966
5568: oPop 1
5570: oJumpForward 5580
5572: Choice Lookup Table
          18   5480
          16   5441
          15   5430
5579: oEndChoice
5580: oCall 5620
5582: oCall 5585
5584: oReturn
5585: oLocalSpace 0
5587: oTypeSNodeType
5588: oChoice 5606
5590: oEmit 22
5592: oJumpForward 5619
5594: oEmit 23
5596: oJumpForward 5619
5598: oError 16
5600: oJumpForward 5619
5602: oEmit 24
5604: oJumpForward 5619
5606: Choice Lookup Table
          26   5602
          20   5598
          25   5598
          24   5598
          22   5594
          21   5590
5619: oReturn
5620: oLocalSpace 0
5622: oInputChoice 5636
5624: oCall 5648
5626: oJumpForward 5645
5628: oCall 5791
5630: oJumpForward 5645
5632: oCall 5889
5634: oJumpForward 5645
5636: Choice Lookup Table
          17   5632
          19   5628
          15   5624
5643: oJumpForward 5647
5645: oJumpBack 5622
5647: oReturn
5648: oLocalSpace 3
5650: oTypeSNodeType
5651: oChoice 5655
5653: oJumpForward 5660
5655: Choice Lookup Table
          27   5653
5658: oError 10
5660: oTypeSNodeType
5661: oChoice 5665
5663: oJumpForward 5670
5665: Choice Lookup Table
          27   5663
5668: oError 13
5670: oGetAddrLocal 1
5672: oPushResult
5673: oTypeSTop
5674: oPushResult
5675: oSetResult 34
5677: oPushResult
5678: oNodeGet
5679: oPop 2
5681: oPushResult
5682: oCall 7915
5684: oPop 1
5686: oAssign
5687: oGetAddrLocal 2
5689: oPushResult
5690: oTypeSTop
5691: oPushResult
5692: oSetResult 33
5694: oPushResult
5695: oNodeGet
5696: oPop 2
5698: oAssign
5699: oTypeSPop
5700: oGetLocal 2
5702: oPushResult
5703: oTypeSPush
5704: oPop 1
5706: oCall 3597
5708: oCall 7715
5710: oGetLocal 1
5712: oPushResult
5713: equal_zero
5714: oPop 1
5716: oChoice 5730
5718: oEmit 15
5720: oGetLocal 1
5722: oPushResult
5723: oEmitInt
5724: oPop 1
5726: oEmit 35
5728: oJumpForward 5733
5730: Choice Lookup Table
           0   5718
5733: oGetAddrLocal 3
5735: oPushResult
5736: oGetLocal 2
5738: oPushResult
5739: oSetResult 16
5741: oPushResult
5742: oNodeGetInt
5743: oPop 2
5745: oAssign
5746: oGetLocal 3
5748: oPushResult
5749: oSetResult 1
5751: oPushResult
5752: equal
5753: oPop 2
5755: oChoice 5769
5757: oEmit 15
5759: oGetLocal 3
5761: oPushResult
5762: oEmitInt
5763: oPop 1
5765: oEmit 31
5767: oJumpForward 5772
5769: Choice Lookup Table
           0   5757
5772: oEmit 33
5774: oInputChoice 5782
5776: oJumpForward 5790
5778: oJumpForward 5788
5780: oJumpForward 5788
5782: Choice Lookup Table
          12   5780
          16   5776
5787: oEndChoice
5788: oJumpBack 5660
5790: oReturn
5791: oLocalSpace 2
5793: oTypeSNodeType
5794: oChoice 5798
5796: oJumpForward 5803
5798: Choice Lookup Table
          29   5796
5801: oError 11
5803: oTypeSTop
5804: oPushResult
5805: oSetResult 37
5807: oPushResult
5808: oNodeGet
5809: oPop 2
5811: oPushResult
5812: oScopeEnter
5813: oPop 1
5815: oInput 0
5817: oGetAddrLocal 1
5819: oPushResult
5820: oScopeFindRequire
5821: oAssign
5822: oGetLocal 1
5824: oPushResult
5825: oNodeType
5826: oPop 1
5828: oChoice 5832
5830: oJumpForward 5837
5832: Choice Lookup Table
          17   5830
5835: oError 12
5837: oScopeEnd
5838: oGetAddrLocal 2
5840: oPushResult
5841: oGetLocal 1
5843: oPushResult
5844: oSetResult 21
5846: oPushResult
5847: oNodeGetInt
5848: oPop 2
5850: oAssign
5851: oGetLocal 2
5853: oPushResult
5854: equal_zero
5855: oPop 1
5857: oChoice 5871
5859: oEmit 15
5861: oGetLocal 2
5863: oPushResult
5864: oEmitInt
5865: oPop 1
5867: oEmit 33
5869: oJumpForward 5874
5871: Choice Lookup Table
           0   5859
5874: oTypeSPop
5875: oGetLocal 1
5877: oPushResult
5878: oSetResult 20
5880: oPushResult
5881: oNodeGet
5882: oPop 2
5884: oPushResult
5885: oTypeSPush
5886: oPop 1
5888: oReturn
5889: oLocalSpace 1
5891: oTypeSNodeType
5892: oChoice 5896
5894: oJumpForward 5901
5896: Choice Lookup Table
          26   5894
5899: oError 9
5901: oEmit 24
5903: oGetAddrLocal 1
5905: oPushResult
5906: oTypeSTop
5907: oAssign
5908: oTypeSPop
5909: oGetLocal 1
5911: oPushResult
5912: oSetResult 33
5914: oPushResult
5915: oNodeGet
5916: oPop 2
5918: oPushResult
5919: oTypeSPush
5920: oPop 1
5922: oReturn
5923: oLocalSpace 0
5925: oCall 7689
5927: oReturn
5928: oLocalSpace 2
5930: oGetAddrLocal 2
5932: oPushResult
5933: oGetParam 1
5935: oPushResult
5936: oSetResult 25
5938: oPushResult
5939: oNodeGetString
5940: oPop 2
5942: oAssign
5943: oGetLocal 2
5945: oPushResult
5946: oSetResult 0
5948: oPushResult
5949: equal_string
5950: oPop 2
5952: oChoice 5989
5954: oGetAddrLocal 1
5956: oPushResult
5957: oGetParam 1
5959: oPushResult
5960: oSetResult 4
5962: oPushResult
5963: oNodeGetInt
5964: oPop 2
5966: oPushResult
5967: ID_STRING
5968: oPop 1
5970: oPushResult
5971: oStringAllocLit
5972: oPop 1
5974: oAssign
5975: oJumpForward 5995
5977: oGetAddrLocal 1
5979: oPushResult
5980: oGetLocal 2
5982: oPushResult
5983: oStringAllocLit
5984: oPop 1
5986: oAssign
5987: oJumpForward 5995
5989: Choice Lookup Table
           0   5977
           1   5954
5994: oEndChoice
5995: oEmit 58
5997: oGetParam 1
5999: oPushResult
6000: oCall 7966
6002: oPop 1
6004: oGetLocal 1
6006: oPushResult
6007: oEmitInt
6008: oPop 1
6010: oReturn
6011: oLocalSpace 10
6013: oGetParam 1
6015: oPushResult
6016: oSetResult 24
6018: oPushResult
6019: oNodeGetBoolean
6020: oPop 2
6022: oChoice 6049
6024: oGetParam 1
6026: oPushResult
6027: oSetResult 27
6029: oPushResult
6030: oNodeGetBoolean
6031: oPop 2
6033: oChoice 6044
6035: oGetParam 1
6037: oPushResult
6038: oCall 5928
6040: oPop 1
6042: oJumpForward 6047
6044: Choice Lookup Table
           0   6035
6047: oJumpForward 6052
6049: Choice Lookup Table
           1   6024
6052: oGetParam 1
6054: oPushResult
6055: oSetResult 27
6057: oPushResult
6058: oSetResult 1
6060: oPushResult
6061: oNodeSetBoolean
6062: oPop 3
6064: oGetAddrLocal 1
6066: oPushResult
6067: oGetParam 1
6069: oPushResult
6070: oSetResult 26
6072: oPushResult
6073: oNodeGetBoolean
6074: oPop 2
6076: oAssign
6077: oGetAddrLocal 4
6079: oPushResult
6080: oGetParam 1
6082: oPushResult
6083: oNodeType
6084: oPop 1
6086: oPushResult
6087: oSetResult 11
6089: oPushResult
6090: equal_node_type
6091: oPop 2
6093: oAssign
6094: oGetLocal 4
6096: oChoice 6123
6098: oGetAddrLocal 2
6100: oPushResult
6101: oGetParam 1
6103: oPushResult
6104: oSetResult 20
6106: oPushResult
6107: oNodeGet
6108: oPop 2
6110: oAssign
6111: oGetAddrLocal 3
6113: oPushResult
6114: oGetLocal 2
6116: oPushResult
6117: oScopeAllocType
6118: oPop 1
6120: oAssign
6121: oJumpForward 6126
6123: Choice Lookup Table
           1   6098
6126: oGetAddrLocal 5
6128: oPushResult
6129: oGetParam 1
6131: oPushResult
6132: oSetResult 22
6134: oPushResult
6135: oNodeGet
6136: oPop 2
6138: oAssign
6139: oGetAddrLocal 6
6141: oPushResult
6142: oGetLocal 5
6144: oPushResult
6145: oSetResult 16
6147: oPushResult
6148: oNodeGetInt
6149: oPop 2
6151: oAssign
6152: oGetLocal 1
6154: oChoice 6176
6156: oEmit 47
6158: oGetLocal 6
6160: oPushResult
6161: oEmitInt
6162: oPop 1
6164: oJumpForward 6182
6166: oEmit 46
6168: oGetLocal 6
6170: oPushResult
6171: oEmitInt
6172: oPop 1
6174: oJumpForward 6182
6176: Choice Lookup Table
           0   6166
           1   6156
6181: oEndChoice
6182: oGetParam 1
6184: oPushResult
6185: oCall 7651
6187: oPop 1
6189: oPushResult
6190: oSetResult 0
6192: oPushResult
6193: greater
6194: oPop 2
6196: oChoice 6229
6198: oEmit 19
6200: oSetResult 0
6202: oPushResult
6203: oEmitInt
6204: oPop 1
6206: oEmit 20
6208: oGetParam 1
6210: oPushResult
6211: oCall 7671
6213: oPop 1
6215: oPushResult
6216: oEmitInt
6217: oPop 1
6219: oSetResult 0
6221: oPushResult
6222: oEmitInt
6223: oPop 1
6225: oEmit 27
6227: oJumpForward 6232
6229: Choice Lookup Table
           1   6198
6232: oGetAddrLocal 7
6234: oPushResult
6235: oGetLocal 5
6237: oPushResult
6238: oSetResult 14
6240: oPushResult
6241: oNodeGetIter
6242: oPop 2
6244: oAssign
6245: oGetAddrLocal 8
6247: oPushResult
6248: oGetLocal 7
6250: oPushResult
6251: oNodeIterValue
6252: oPop 1
6254: oAssign
6255: oInputChoice 6434
6257: oGetLocal 8
6259: oPushResult
6260: oNodeNull
6261: oPop 1
6263: oChoice 6269
6265: oJumpForward 6430
6267: oJumpForward 6272
6269: Choice Lookup Table
           1   6265
6272: oGetAddrLocal 9
6274: oPushResult
6275: oGetLocal 8
6277: oPushResult
6278: oSetResult 21
6280: oPushResult
6281: oNodeGetInt
6282: oPop 2
6284: oAssign
6285: oEmit 19
6287: oGetLocal 9
6289: oPushResult
6290: oEmitInt
6291: oPop 1
6293: oGetLocal 8
6295: oPushResult
6296: oSetResult 20
6298: oPushResult
6299: oNodeGet
6300: oPop 2
6302: oPushResult
6303: oTypeSPush
6304: oPop 1
6306: oGetLocal 8
6308: oPushResult
6309: oSetResult 31
6311: oPushResult
6312: oNodeGetBoolean
6313: oPop 2
6315: oChoice 6383
6317: oCall 6922
6319: oCall 7689
6321: oEmit 27
6323: oJumpForward 6389
6325: oCall 3597
6327: oCall 5923
6329: oTypeSNodeType
6330: oChoice 6348
6332: oEmit 25
6334: oJumpForward 6381
6336: oEmit 26
6338: oJumpForward 6381
6340: oError 16
6342: oJumpForward 6381
6344: oEmit 27
6346: oJumpForward 6381
6348: Choice Lookup Table
          26   6344
          20   6340
          25   6340
          24   6340
          22   6336
          21   6332
6361: oGetAddrLocal 10
6363: oPushResult
6364: oTypeSTop
6365: oPushResult
6366: oSetResult 16
6368: oPushResult
6369: oNodeGetInt
6370: oPop 2
6372: oAssign
6373: oEmit 28
6375: oGetLocal 10
6377: oPushResult
6378: oEmitInt
6379: oPop 1
6381: oJumpForward 6389
6383: Choice Lookup Table
           0   6325
           1   6317
6388: oEndChoice
6389: oTypeSPop
6390: oGetAddrLocal 7
6392: oPushResult
6393: oNodeIterNext
6394: oPop 1
6396: oGetAddrLocal 8
6398: oPushResult
6399: oGetLocal 7
6401: oPushResult
6402: oNodeIterValue
6403: oPop 1
6405: oAssign
6406: oGetLocal 8
6408: oPushResult
6409: oNodeNull
6410: oPop 1
6412: oChoice 6420
6414: oJumpForward 6430
6416: oJumpForward 6426
6418: oJumpForward 6426
6420: Choice Lookup Table
           0   6418
           1   6414
6425: oEndChoice
6426: oInput 12
6428: oJumpBack 6257
6430: oInput 14
6432: oJumpForward 6437
6434: Choice Lookup Table
          13   6257
6437: oGetLocal 8
6439: oPushResult
6440: oNodeNull
6441: oPop 1
6443: oChoice 6449
6445: oError 15
6447: oJumpForward 6452
6449: Choice Lookup Table
           0   6445
6452: oGetLocal 4
6454: oChoice 6483
6456: oEmit 19
6458: oGetParam 1
6460: oPushResult
6461: oSetResult 30
6463: oPushResult
6464: oNodeGetInt
6465: oPop 2
6467: oPushResult
6468: oEmitInt
6469: oPop 1
6471: oEmit 17
6473: oGetLocal 3
6475: oPushResult
6476: oEmitInt
6477: oPop 1
6479: oEmit 27
6481: oJumpForward 6486
6483: Choice Lookup Table
           1   6456
6486: oGetLocal 1
6488: oChoice 6512
6490: oEmit 50
6492: oGetParam 1
6494: oPushResult
6495: oCall 7966
6497: oPop 1
6499: oJumpForward 6518
6501: oEmit 49
6503: oGetParam 1
6505: oPushResult
6506: oCall 7966
6508: oPop 1
6510: oJumpForward 6518
6512: Choice Lookup Table
           0   6501
           1   6490
6517: oEndChoice
6518: oGetLocal 4
6520: oChoice 6588
6522: oGetLocal 2
6524: oPushResult
6525: oTypeSPush
6526: oPop 1
6528: oTypeSNodeType
6529: oChoice 6565
6531: oEmit 3
6533: oGetLocal 3
6535: oPushResult
6536: oEmitInt
6537: oPop 1
6539: oJumpForward 6586
6541: oEmit 4
6543: oGetLocal 3
6545: oPushResult
6546: oEmitInt
6547: oPop 1
6549: oJumpForward 6586
6551: oError 16
6553: oJumpForward 6586
6555: oEmit 5
6557: oGetLocal 3
6559: oPushResult
6560: oEmitInt
6561: oPop 1
6563: oJumpForward 6586
6565: Choice Lookup Table
          26   6555
          20   6551
          25   6551
          24   6551
          22   6541
          21   6531
6578: oEmit 17
6580: oGetLocal 3
6582: oPushResult
6583: oEmitInt
6584: oPop 1
6586: oJumpForward 6591
6588: Choice Lookup Table
           1   6522
6591: oEmit 48
6593: oGetLocal 6
6595: oPushResult
6596: oEmitInt
6597: oPop 1
6599: oReturn
6600: oLocalSpace 0
6602: oInputChoice 6652
6604: oCall 7559
6606: oJumpForward 6677
6608: oCall 7566
6610: oJumpForward 6677
6612: oCall 7633
6614: oJumpForward 6677
6616: oCall 7636
6618: oJumpForward 6677
6620: oCall 7099
6622: oJumpForward 6677
6624: oCall 7419
6626: oJumpForward 6677
6628: oCall 7165
6630: oJumpForward 6677
6632: oCall 7339
6634: oJumpForward 6677
6636: oCall 7504
6638: oJumpForward 6677
6640: oCall 7472
6642: oJumpForward 6677
6644: oCall 7536
6646: oJumpForward 6677
6648: oCall 6678
6650: oJumpForward 6677
6652: Choice Lookup Table
           0   6648
          33   6644
          49   6640
          50   6636
          47   6632
          42   6628
          46   6624
          39   6620
          63   6616
          62   6612
          61   6608
          60   6604
6677: oReturn
6678: oLocalSpace 1
6680: oGetAddrLocal 1
6682: oPushResult
6683: oScopeFindRequire
6684: oAssign
6685: oGetLocal 1
6687: oPushResult
6688: oNodeType
6689: oPop 1
6691: oChoice 6720
6693: oGetLocal 1
6695: oPushResult
6696: oCall 6011
6698: oPop 1
6700: oJumpForward 6733
6702: oGetLocal 1
6704: oPushResult
6705: oCall 6734
6707: oPop 1
6709: oJumpForward 6733
6711: oGetLocal 1
6713: oPushResult
6714: oCall 6808
6716: oPop 1
6718: oJumpForward 6733
6720: Choice Lookup Table
          11   6711
          18   6702
          16   6702
          15   6702
          10   6693
6731: oError 0
6733: oReturn
6734: oLocalSpace 0
6736: oGetParam 1
6738: oPushResult
6739: oCall 6958
6741: oPop 1
6743: oInput 3
6745: oCall 3597
6747: oCall 7689
6749: oCall 6752
6751: oReturn
6752: oLocalSpace 1
6754: oTypeSNodeType
6755: oChoice 6773
6757: oEmit 25
6759: oJumpForward 6806
6761: oEmit 26
6763: oJumpForward 6806
6765: oError 16
6767: oJumpForward 6806
6769: oEmit 27
6771: oJumpForward 6806
6773: Choice Lookup Table
          26   6769
          20   6765
          25   6765
          24   6765
          22   6761
          21   6757
6786: oGetAddrLocal 1
6788: oPushResult
6789: oTypeSTop
6790: oPushResult
6791: oSetResult 16
6793: oPushResult
6794: oNodeGetInt
6795: oPop 2
6797: oAssign
6798: oEmit 28
6800: oGetLocal 1
6802: oPushResult
6803: oEmitInt
6804: oPop 1
6806: oTypeSPop
6807: oReturn
6808: oLocalSpace 1
6810: oGetParam 1
6812: oPushResult
6813: oSetResult 6
6815: oPushResult
6816: oNodeGet
6817: oPop 2
6819: oPushResult
6820: oScopeCurrent
6821: oPushResult
6822: oNodeEqual
6823: oPop 2
6825: oChoice 6831
6827: oError 20
6829: oJumpForward 6834
6831: Choice Lookup Table
           0   6827
6834: oEmit 8
6836: oGetParam 1
6838: oPushResult
6839: oSetResult 30
6841: oPushResult
6842: oNodeGetInt
6843: oPop 2
6845: oPushResult
6846: oEmitInt
6847: oPop 1
6849: oGetParam 1
6851: oPushResult
6852: oSetResult 20
6854: oPushResult
6855: oNodeGet
6856: oPop 2
6858: oPushResult
6859: oTypeSPush
6860: oPop 1
6862: oInput 3
6864: oCall 3597
6866: oCall 7689
6868: oTypeSNodeType
6869: oChoice 6887
6871: oEmit 25
6873: oJumpForward 6920
6875: oEmit 26
6877: oJumpForward 6920
6879: oError 16
6881: oJumpForward 6920
6883: oEmit 27
6885: oJumpForward 6920
6887: Choice Lookup Table
          26   6883
          20   6879
          25   6879
          24   6879
          22   6875
          21   6871
6900: oGetAddrLocal 1
6902: oPushResult
6903: oTypeSTop
6904: oPushResult
6905: oSetResult 16
6907: oPushResult
6908: oNodeGetInt
6909: oPop 2
6911: oAssign
6912: oEmit 28
6914: oGetLocal 1
6916: oPushResult
6917: oEmitInt
6918: oPop 1
6920: oTypeSPop
6921: oReturn
6922: oLocalSpace 1
6924: oInput 0
6926: oGetAddrLocal 1
6928: oPushResult
6929: oScopeFindRequire
6930: oAssign
6931: oGetLocal 1
6933: oPushResult
6934: oNodeType
6935: oPop 1
6937: oChoice 6941
6939: oJumpForward 6950
6941: Choice Lookup Table
          18   6939
          16   6939
          15   6939
6948: oError 4
6950: oGetLocal 1
6952: oPushResult
6953: oCall 6958
6955: oPop 1
6957: oReturn
6958: oLocalSpace 0
6960: oGetParam 1
6962: oPushResult
6963: oNodeType
6964: oPop 1
6966: oChoice 7026
6968: oEmit 16
6970: oGetParam 1
6972: oPushResult
6973: oCall 7966
6975: oPop 1
6977: oJumpForward 7035
6979: oEmit 17
6981: oGetParam 1
6983: oPushResult
6984: oCall 7966
6986: oPop 1
6988: oJumpForward 7035
6990: oGetParam 1
6992: oPushResult
6993: oSetResult 31
6995: oPushResult
6996: oNodeGetBoolean
6997: oPop 2
6999: oChoice 7012
7001: oEmit 8
7003: oGetParam 1
7005: oPushResult
7006: oCall 7966
7008: oPop 1
7010: oJumpForward 7024
7012: Choice Lookup Table
           1   7001
7015: oEmit 18
7017: oGetParam 1
7019: oPushResult
7020: oCall 7966
7022: oPop 1
7024: oJumpForward 7035
7026: Choice Lookup Table
          18   6990
          16   6979
          15   6968
7033: oError 4
7035: oGetParam 1
7037: oPushResult
7038: oSetResult 20
7040: oPushResult
7041: oNodeGet
7042: oPop 2
7044: oPushResult
7045: oTypeSPush
7046: oPop 1
7048: oCall 5620
7050: oReturn
7051: oLocalSpace 0
7053: oGetParam 1
7055: oPushResult
7056: oCall 6958
7058: oPop 1
7060: oCall 7715
7062: oGetParam 1
7064: oPushResult
7065: oCall 4859
7067: oPop 1
7069: oTypeSPop
7070: oEmit 29
7072: oEmit 25
7074: oReturn
7075: oLocalSpace 0
7077: oGetParam 1
7079: oPushResult
7080: oCall 6958
7082: oPop 1
7084: oCall 7715
7086: oGetParam 1
7088: oPushResult
7089: oCall 4859
7091: oPop 1
7093: oTypeSPop
7094: oEmit 30
7096: oEmit 25
7098: oReturn
7099: oLocalSpace 2
7101: oGetAddrLocal 1
7103: oPushResult
7104: oSetResult 0
7106: oAssign
7107: oGetAddrLocal 1
7109: oPushResult
7110: oCall 3620
7112: oPop 1
7114: oInput 40
7116: oCall 6600
7118: oInputChoice 7153
7120: oGetAddrLocal 2
7122: oPushResult
7123: oLabelNew
7124: oAssign
7125: oEmit 53
7127: oGetLocal 2
7129: oPushResult
7130: oEmitLabel
7131: oPop 1
7133: oEmit 56
7135: oGetLocal 1
7137: oPushResult
7138: oEmitLabel
7139: oPop 1
7141: oCall 6600
7143: oEmit 56
7145: oGetLocal 2
7147: oPushResult
7148: oEmitLabel
7149: oPop 1
7151: oJumpForward 7164
7153: Choice Lookup Table
          41   7120
7156: oEmit 56
7158: oGetLocal 1
7160: oPushResult
7161: oEmitLabel
7162: oPop 1
7164: oReturn
7165: oLocalSpace 4
7167: oInput 0
7169: oGetAddrLocal 1
7171: oPushResult
7172: oScopeFindRequire
7173: oAssign
7174: oGetLocal 1
7176: oPushResult
7177: oCall 6958
7179: oPop 1
7181: oCall 7715
7183: oInput 3
7185: oCall 3597
7187: oCall 7715
7189: oEmit 25
7191: oGetAddrLocal 2
7193: oPushResult
7194: oLabelNew
7195: oAssign
7196: oGetAddrLocal 3
7198: oPushResult
7199: oLabelNew
7200: oAssign
7201: oEmit 53
7203: oGetLocal 3
7205: oPushResult
7206: oEmitLabel
7207: oPop 1
7209: oGetAddrLocal 4
7211: oPushResult
7212: oLabelNew
7213: oAssign
7214: oEmit 56
7216: oGetLocal 4
7218: oPushResult
7219: oEmitLabel
7220: oPop 1
7222: oInputChoice 7302
7224: oGetLocal 1
7226: oPushResult
7227: oCall 7051
7229: oPop 1
7231: oEmit 56
7233: oGetLocal 3
7235: oPushResult
7236: oEmitLabel
7237: oPop 1
7239: oGetLocal 1
7241: oPushResult
7242: oCall 4859
7244: oPop 1
7246: oTypeSPop
7247: oCall 3597
7249: oCall 7715
7251: oEmit 40
7253: oEmit 54
7255: oGetLocal 2
7257: oPushResult
7258: oEmitLabel
7259: oPop 1
7261: oJumpForward 7308
7263: oGetLocal 1
7265: oPushResult
7266: oCall 7075
7268: oPop 1
7270: oEmit 56
7272: oGetLocal 3
7274: oPushResult
7275: oEmitLabel
7276: oPop 1
7278: oGetLocal 1
7280: oPushResult
7281: oCall 4859
7283: oPop 1
7285: oTypeSPop
7286: oCall 3597
7288: oCall 7715
7290: oEmit 41
7292: oEmit 54
7294: oGetLocal 2
7296: oPushResult
7297: oEmitLabel
7298: oPop 1
7300: oJumpForward 7308
7302: Choice Lookup Table
          44   7263
          43   7224
7307: oEndChoice
7308: oGetLocal 4
7310: oPushResult
7311: oGetLocal 2
7313: oPushResult
7314: oLoopPush
7315: oPop 2
7317: oInput 45
7319: oCall 6600
7321: oEmit 53
7323: oGetLocal 4
7325: oPushResult
7326: oEmitLabel
7327: oPop 1
7329: oEmit 56
7331: oGetLocal 2
7333: oPushResult
7334: oEmitLabel
7335: oPop 1
7337: oLoopPop
7338: oReturn
7339: oLocalSpace 3
7341: oGetAddrLocal 1
7343: oPushResult
7344: oLabelNew
7345: oAssign
7346: oEmit 56
7348: oGetLocal 1
7350: oPushResult
7351: oEmitLabel
7352: oPop 1
7354: oGetAddrLocal 2
7356: oPushResult
7357: oLabelNew
7358: oAssign
7359: oGetLocal 1
7361: oPushResult
7362: oGetLocal 2
7364: oPushResult
7365: oLoopPush
7366: oPop 2
7368: oCall 6600
7370: oInputChoice 7401
7372: oCall 6600
7374: oJumpForward 7407
7376: oGetAddrLocal 3
7378: oPushResult
7379: oCall 3620
7381: oPop 1
7383: oEmit 57
7385: oGetLocal 3
7387: oPushResult
7388: oEmitLabel
7389: oPop 1
7391: oGetLocal 1
7393: oPushResult
7394: oEmitLabel
7395: oPop 1
7397: oJumpForward 7409
7399: oJumpForward 7407
7401: Choice Lookup Table
          48   7376
           4   7372
7406: oEndChoice
7407: oJumpBack 7370
7409: oEmit 56
7411: oGetLocal 2
7413: oPushResult
7414: oEmitLabel
7415: oPop 1
7417: oLoopPop
7418: oReturn
7419: oLocalSpace 2
7421: oGetAddrLocal 1
7423: oPushResult
7424: oLabelNew
7425: oAssign
7426: oEmit 56
7428: oGetLocal 1
7430: oPushResult
7431: oEmitLabel
7432: oPop 1
7434: oGetAddrLocal 2
7436: oPushResult
7437: oCall 3620
7439: oPop 1
7441: oGetLocal 1
7443: oPushResult
7444: oGetLocal 2
7446: oPushResult
7447: oLoopPush
7448: oPop 2
7450: oInput 45
7452: oCall 6600
7454: oEmit 53
7456: oGetLocal 1
7458: oPushResult
7459: oEmitLabel
7460: oPop 1
7462: oEmit 56
7464: oGetLocal 2
7466: oPushResult
7467: oEmitLabel
7468: oPop 1
7470: oLoopPop
7471: oReturn
7472: oLocalSpace 0
7474: oLoopContinueLabel
7475: oPushResult
7476: oSetResult 0
7478: oPushResult
7479: equal_label
7480: oPop 2
7482: oChoice 7497
7484: oError 18
7486: oJumpForward 7503
7488: oEmit 53
7490: oLoopContinueLabel
7491: oPushResult
7492: oEmitLabel
7493: oPop 1
7495: oJumpForward 7503
7497: Choice Lookup Table
           0   7488
           1   7484
7502: oEndChoice
7503: oReturn
7504: oLocalSpace 0
7506: oLoopBreakLabel
7507: oPushResult
7508: oSetResult 0
7510: oPushResult
7511: equal_label
7512: oPop 2
7514: oChoice 7529
7516: oError 18
7518: oJumpForward 7535
7520: oEmit 53
7522: oLoopBreakLabel
7523: oPushResult
7524: oEmitLabel
7525: oPop 1
7527: oJumpForward 7535
7529: Choice Lookup Table
           0   7520
           1   7516
7534: oEndChoice
7535: oReturn
7536: oLocalSpace 0
7538: oCall 6600
7540: oInputChoice 7550
7542: oCall 6600
7544: oJumpForward 7556
7546: oJumpForward 7558
7548: oJumpForward 7556
7550: Choice Lookup Table
          34   7546
           4   7542
7555: oEndChoice
7556: oJumpBack 7540
7558: oReturn
7559: oLocalSpace 0
7561: oCall 7566
7563: oEmit 63
7565: oReturn
7566: oLocalSpace 0
7568: oInputChoice 7629
7570: oCall 3597
7572: oTypeSNodeType
7573: oChoice 7595
7575: oEmit 59
7577: oJumpForward 7610
7579: oEmit 60
7581: oJumpForward 7610
7583: oEmit 61
7585: oJumpForward 7610
7587: oError 16
7589: oJumpForward 7610
7591: oEmit 62
7593: oJumpForward 7610
7595: Choice Lookup Table
          26   7591
          20   7587
          24   7587
          25   7583
          22   7579
          21   7575
7608: oError 17
7610: oTypeSPop
7611: oInputChoice 7619
7613: oJumpForward 7627
7615: oJumpForward 7625
7617: oJumpForward 7625
7619: Choice Lookup Table
          12   7617
          14   7613
7624: oEndChoice
7625: oJumpBack 7570
7627: oJumpForward 7632
7629: Choice Lookup Table
          13   7570
7632: oReturn
7633: oLocalSpace 0
7635: oReturn
7636: oLocalSpace 0
7638: oReturn
7639: oLocalSpace 0
7641: oScopeCurrent
7642: oPushResult
7643: oSetResult 13
7645: oPushResult
7646: oNodeGetInt
7647: oPop 2
7649: oReturn
7650: oReturn
7651: oLocalSpace 0
7653: oGetParam 1
7655: oPushResult
7656: oSetResult 19
7658: oPushResult
7659: oNodeGet
7660: oPop 2
7662: oPushResult
7663: oSetResult 13
7665: oPushResult
7666: oNodeGetInt
7667: oPop 2
7669: oReturn
7670: oReturn
7671: oLocalSpace 0
7673: oCall 7639
7675: oPushResult
7676: oGetParam 1
7678: oPushResult
7679: oCall 7651
7681: oPop 1
7683: oPushResult
7684: subtract
7685: oPop 2
7687: oReturn
7688: oReturn
7689: oLocalSpace 1
7691: oGetAddrLocal 1
7693: oPushResult
7694: oTypeSNodeType
7695: oAssign
7696: oTypeSPop
7697: oGetLocal 1
7699: oPushResult
7700: oTypeSNodeType
7701: oPushResult
7702: equal_node_type
7703: oPop 2
7705: oChoice 7711
7707: oError 14
7709: oJumpForward 7714
7711: Choice Lookup Table
           0   7707
7714: oReturn
7715: oLocalSpace 0
7717: oTypeSNodeType
7718: oChoice 7722
7720: oJumpForward 7727
7722: Choice Lookup Table
          21   7720
7725: oError 7
7727: oTypeSPop
7728: oReturn
7729: oLocalSpace 0
7731: oTypeSNodeType
7732: oChoice 7736
7734: oJumpForward 7741
7736: Choice Lookup Table
          21   7734
7739: oError 7
7741: oReturn
7742: oLocalSpace 0
7744: oTypeSNodeType
7745: oChoice 7749
7747: oJumpForward 7754
7749: Choice Lookup Table
          22   7747
7752: oError 8
7754: oTypeSPop
7755: oReturn
7756: oLocalSpace 0
7758: oTypeSNodeType
7759: oChoice 7763
7761: oJumpForward 7768
7763: Choice Lookup Table
          22   7761
7766: oError 8
7768: oReturn
7769: oLocalSpace 1
7771: oGetAddrLocal 1
7773: oPushResult
7774: oGetParam 2
7776: oPushResult
7777: oNodeNew
7778: oPop 1
7780: oAssign
7781: oGetLocal 1
7783: oPushResult
7784: oSetResult 16
7786: oPushResult
7787: oGetParam 1
7789: oPushResult
7790: oNodeSetInt
7791: oPop 3
7793: oGetLocal 1
7795: oPushResult
7796: oTypeAdd
7797: oPop 1
7799: oGetLocal 1
7801: oReturn
7802: oReturn
7803: oLocalSpace 1
7805: oGetAddrLocal 1
7807: oPushResult
7808: oGetParam 3
7810: oPushResult
7811: oNodeNew
7812: oPop 1
7814: oAssign
7815: oGetLocal 1
7817: oPushResult
7818: oSetResult 4
7820: oPushResult
7821: oGetParam 1
7823: oPushResult
7824: oNodeSetInt
7825: oPop 3
7827: oGetLocal 1
7829: oReturn
7830: oReturn
7831: oLocalSpace 1
7833: oGetAddrLocal 1
7835: oPushResult
7836: oGetParam 1
7838: oPushResult
7839: oSetResult 32
7841: oPushResult
7842: oNodeGet
7843: oPop 2
7845: oAssign
7846: oGetLocal 1
7848: oPushResult
7849: oNodeNull
7850: oPop 1
7852: oChoice 7908
7854: oGetAddrLocal 1
7856: oPushResult
7857: oSetResult 26
7859: oPushResult
7860: oNodeNew
7861: oPop 1
7863: oAssign
7864: oGetLocal 1
7866: oPushResult
7867: oSetResult 33
7869: oPushResult
7870: oGetParam 1
7872: oPushResult
7873: oNodeSet
7874: oPop 3
7876: oGetLocal 1
7878: oPushResult
7879: oSetResult 16
7881: oPushResult
7882: oSetResult 8
7884: oPushResult
7885: oNodeSetInt
7886: oPop 3
7888: oGetLocal 1
7890: oPushResult
7891: oTypeAdd
7892: oPop 1
7894: oGetParam 1
7896: oPushResult
7897: oSetResult 32
7899: oPushResult
7900: oGetLocal 1
7902: oPushResult
7903: oNodeSet
7904: oPop 3
7906: oJumpForward 7911
7908: Choice Lookup Table
           1   7854
7911: oGetLocal 1
7913: oReturn
7914: oReturn
7915: oLocalSpace 0
7917: oGetParam 1
7919: oPushResult
7920: oNodeType
7921: oPop 1
7923: oChoice 7951
7925: oMININT
7926: oReturn
7927: oJumpForward 7965
7929: oSetResult 0
7931: oReturn
7932: oJumpForward 7965
7934: oSetResult 0
7936: oReturn
7937: oJumpForward 7965
7939: oGetParam 1
7941: oPushResult
7942: oSetResult 35
7944: oPushResult
7945: oNodeGetInt
7946: oPop 2
7948: oReturn
7949: oJumpForward 7965
7951: Choice Lookup Table
          28   7939
          24   7934
          22   7929
          21   7925
7960: oError 3
7962: oSetResult 0
7964: oReturn
7965: oReturn
7966: oLocalSpace 0
7968: oGetParam 1
7970: oPushResult
7971: oSetResult 21
7973: oPushResult
7974: oNodeGetInt
7975: oPop 2
7977: oPushResult
7978: oEmitInt
7979: oPop 1
7981: oReturn
7982: oLocalSpace 1
7984: oGetAddrGlobal 3
7986: oPushResult
7987: oSetResult 20
7989: oPushResult
7990: oSetResult 4
7992: oPushResult
7993: oCall 7769
7995: oPop 2
7997: oAssign
7998: oGetAddrGlobal 4
8000: oPushResult
8001: oSetResult 21
8003: oPushResult
8004: oSetResult 4
8006: oPushResult
8007: oCall 7769
8009: oPop 2
8011: oAssign
8012: oGetAddrGlobal 5
8014: oPushResult
8015: oSetResult 22
8017: oPushResult
8018: oSetResult 1
8020: oPushResult
8021: oCall 7769
8023: oPop 2
8025: oAssign
8026: oGetAddrGlobal 6
8028: oPushResult
8029: oSetResult 23
8031: oPushResult
8032: oSetResult 1
8034: oPushResult
8035: oCall 7769
8037: oPop 2
8039: oAssign
8040: oGetAddrGlobal 7
8042: oPushResult
8043: oSetResult 24
8045: oPushResult
8046: oSetResult 1
8048: oPushResult
8049: oCall 7769
8051: oPop 2
8053: oAssign
8054: oGetAddrGlobal 8
8056: oPushResult
8057: oSetResult 25
8059: oPushResult
8060: oSetResult 256
8062: oPushResult
8063: oCall 7769
8065: oPop 2
8067: oAssign
8068: oGetAddrLocal 1
8070: oPushResult
8071: oSetResult 13
8073: oPushResult
8074: oSetResult 5
8076: oPushResult
8077: oIdAdd_File
8078: oPushResult
8079: oCall 7803
8081: oPop 3
8083: oAssign
8084: oGetLocal 1
8086: oPushResult
8087: oSetResult 20
8089: oPushResult
8090: oGetGlobal 3
8092: oPushResult
8093: oNodeSet
8094: oPop 3
8096: oGetLocal 1
8098: oPushResult
8099: oScopeDeclare
8100: oPop 1
8102: oGetAddrLocal 1
8104: oPushResult
8105: oSetResult 13
8107: oPushResult
8108: oSetResult 5
8110: oPushResult
8111: oIdAdd_Integer
8112: oPushResult
8113: oCall 7803
8115: oPop 3
8117: oAssign
8118: oGetLocal 1
8120: oPushResult
8121: oSetResult 20
8123: oPushResult
8124: oGetGlobal 4
8126: oPushResult
8127: oNodeSet
8128: oPop 3
8130: oGetLocal 1
8132: oPushResult
8133: oScopeDeclare
8134: oPop 1
8136: oGetAddrLocal 1
8138: oPushResult
8139: oSetResult 13
8141: oPushResult
8142: oSetResult 5
8144: oPushResult
8145: oIdAdd_Boolean
8146: oPushResult
8147: oCall 7803
8149: oPop 3
8151: oAssign
8152: oGetLocal 1
8154: oPushResult
8155: oSetResult 20
8157: oPushResult
8158: oGetGlobal 5
8160: oPushResult
8161: oNodeSet
8162: oPop 3
8164: oGetLocal 1
8166: oPushResult
8167: oScopeDeclare
8168: oPop 1
8170: oGetAddrLocal 1
8172: oPushResult
8173: oSetResult 13
8175: oPushResult
8176: oSetResult 5
8178: oPushResult
8179: oIdAdd_Char
8180: oPushResult
8181: oCall 7803
8183: oPop 3
8185: oAssign
8186: oGetLocal 1
8188: oPushResult
8189: oSetResult 20
8191: oPushResult
8192: oGetGlobal 7
8194: oPushResult
8195: oNodeSet
8196: oPop 3
8198: oGetLocal 1
8200: oPushResult
8201: oScopeDeclare
8202: oPop 1
8204: oGetAddrLocal 1
8206: oPushResult
8207: oSetResult 13
8209: oPushResult
8210: oSetResult 5
8212: oPushResult
8213: oIdAdd_String
8214: oPushResult
8215: oCall 7803
8217: oPop 3
8219: oAssign
8220: oGetLocal 1
8222: oPushResult
8223: oSetResult 20
8225: oPushResult
8226: oGetGlobal 8
8228: oPushResult
8229: oNodeSet
8230: oPop 3
8232: oGetLocal 1
8234: oPushResult
8235: oScopeDeclare
8236: oPop 1
8238: oGetAddrLocal 1
8240: oPushResult
8241: oSetResult 12
8243: oPushResult
8244: oSetResult 4
8246: oPushResult
8247: oIdAdd_True
8248: oPushResult
8249: oCall 7803
8251: oPop 3
8253: oAssign
8254: oGetLocal 1
8256: oPushResult
8257: oSetResult 20
8259: oPushResult
8260: oGetGlobal 5
8262: oPushResult
8263: oNodeSet
8264: oPop 3
8266: oGetLocal 1
8268: oPushResult
8269: oSetResult 21
8271: oPushResult
8272: oSetResult 1
8274: oPushResult
8275: oNodeSetInt
8276: oPop 3
8278: oGetLocal 1
8280: oPushResult
8281: oScopeDeclare
8282: oPop 1
8284: oGetAddrLocal 1
8286: oPushResult
8287: oSetResult 12
8289: oPushResult
8290: oSetResult 4
8292: oPushResult
8293: oIdAdd_False
8294: oPushResult
8295: oCall 7803
8297: oPop 3
8299: oAssign
8300: oGetLocal 1
8302: oPushResult
8303: oSetResult 20
8305: oPushResult
8306: oGetGlobal 5
8308: oPushResult
8309: oNodeSet
8310: oPop 3
8312: oGetLocal 1
8314: oPushResult
8315: oSetResult 21
8317: oPushResult
8318: oSetResult 0
8320: oPushResult
8321: oNodeSetInt
8322: oPop 3
8324: oGetLocal 1
8326: oPushResult
8327: oScopeDeclare
8328: oPop 1
8330: oReturn
