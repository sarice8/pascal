   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %
      %  *** WORKING ON : Records ***
      %    - fields allocated now, but need to calculate size of whole record
      %    - need to make ST a linked list structure for oSymPopLevelSaveType
      %      (note, this will mess up SD, and oSymLevelAnySyms)
      %    - references to records: currently pushes addr on stack. ok.
      %      Field selection '.' should push the fields on the SD, look up
      %      the next ident only in that level, add the offset if not 0,
      %      replace the current type with the field type, and continue
      %      (note, we're in fetch mode here, working with addresses on run stack
      %      just as with arrays).
      %
      %  *** WORKING ON : Procedures ***
      %    - formal args declared but not saved (see Records)
      %    - allocate args so the #'s match the stack (esp. re VAR flag)
      %    - pay attention to VAR flag
      %    - formal params are visible to body of proc, but requires special
      %      code to access non-global vars.
      %      i.e. in expressions, if var is found at SD level > 0, must take it
      %      off stack. (possibly with indirection).
      %      NOTE, VAR parameters are like pointer vars, with automatic deref ('^')
      %      Maybe this helps with the implementation.
      %    - Big choice: what is runtime environment of stack machine?
      %        Call stack with params, returns
      %        Expr stack used within a statement
      %        These can be the same if Expr stack always empty before/after an
      %        indivisible expression. (??)
      %
      %  NOTES
      %    1) During a loop, the top counter counts the number of 'exit'
      %       statements to be patched.
      %    2) During a loop, the top entry in the patchLoop stack is the addr
      %       of the start of the loop (used by 'cycle' to repeat the loop).
      %    3) The 'value' of a var symbol is its allocated address.
      %    4) References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    5) Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushIntVar       % push value of int var; addr follows
   2:    tPushBoolVar
   2:    tPushPtrVar
   2:    tPushAddr         % addr (of a var) follows
   2:    tFetchInt         % replace addr (on tos) of int var with contents
   2:    tFetchBool        %    "      "      "     " bool  "   "    "
   2:    tFetchPtr         %    "      "      "     " ptr   "   "    "   
   2:    tPushIntLit       % int lit follows (NOTE, used for BOOLEAN too)
   2:    tAssignInt        % assign value on tos to addr under it (pop both)
   2:    tAssignBool       %   "      "    "   "  "   "    "    "   "   "
   2:    tAssignPtr        % assign val WHOSE ADDR is on tos to addr under it (pop)
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncIntVar        % increment int var (addr follows)
   2:    tDecIntVar        % decrement int var (addr follows)
   2:    tMultiplyInt      % multiply top two integers (replacing with result)
   2:    tDivideInt
   2:    tAddInt
   2:    tSubtractInt
   2:    tNegateInt        % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualInt         % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualInt      %    NOTE, these all work for booleans too
   2:    tGreaterInt       % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessInt
   2:    tGreaterEqualInt
   2:    tLessEqualInt
   2:    tEqualPtr         % are the ptr vars whose addresses are top 2 equal?
   2:    tNotEqualPtr
   2:    tCall             % addr follows
   2:    tReturn
   2:    tJump             % addr follows
   2:    tJumpTrue         % addr follows  (pops top of stack, jumps if true)
   2:    tJumpFalse        % addr follows  (pops top of stack, jumps if false)
   2:    tPutInt           % for writeln : write integer on tos, pop
   2:    tPutBool          %  "     "    : write TRUE/FALSE, pop
   2:    tPutStr           %  "     "    : write string whose addr is on tos, pop
   2:    tPutPtr           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tPutCR            %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    tSymVal           % emit value of symbol looked-up with oSymLookup
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qParentScope
   2: 	qDecls
   2: 	qNextOffset
   2: 	qIdent
   2: 	qKind
   2: 	qType
   2: 	qParamType
   2: 	qValue
   2: 	qParams
   2: 	qChildScope
   2: 	qInOut
   2: 	qSize
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to parent scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node )                % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node )           % add declaration to current scope, and allocate space according to its type
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
   2: mechanism sym :                
      
         % symbol table
      
   2:    oSymPushLevel               % new lexical level
   2:    oSymPopLevel                % return to old lexical level
   2:    oSymPopLevelSaveType        % attach id's in lex level to the syms field
                                     %   of the type on top of the type stack
   2:    oSymLookup                  % lookup last id accepted (for use by
                                     %   other semantic operations...)
   2:    oSymChooseKind >> kind      % kind of symbol looked-up
   2:    oSymAddSPop                 % add id on symbol stack to symbol table
                                     %   (pop symbol stack)
   2:    oSymLevelAnySyms >> boolean % any symbols in top lexical level?
      
         % symbol stack
         % (used to construct entries for the symbol table,
         %       and to handle references to symbols)
      
   2:    oSymSPushId                 % push id# of last id accepted
   2:    oSymSSetKind(kind)          % set kind of top symbol (kVar, kType, etc)
                                     %   ... error if it was already set
   2:    oSymSSetValPop              % set val of sym on SS from val on VS (pop VS)
   2:    oSymSSetTypS                % set type of top symbol, from type on
                                     %   type stack (don't pop type stack)
   2:    oSymSSetParamTypS           % set param type of top symbol from type on TS
   2:    oSymSAllocate               % allocate data space for var, using size of
                                     %   type on type stack
   2:    ;
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePushToken             % push value of (int lit) token just read
   2:    oValuePushVal               % push val of symbol looked-up
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushSizeTS            % push size of type on type stack
   2:    oValuePushLowTS             % push low subscript of type on type stack
   2:    oValueNegate                % negate top value
   2:    oValueDifference            % pop 2, push (top - 2nd + 1)
   2:    oValueMultiply              % pop 2, push (top * 2nd)
   2:    oValueIsZero >> boolean     % is top value zero?
   2:    oValueIsOne >> boolean      % is top value one?
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
   2: mechanism typS :               % type stack
   2:    oTypSPushTyp                % push type# of sym looked-up (not root type)
   2:    oTypSPush(typ)              % push explicit type# (intrinsic)
   2:    oTypSPopPushBase            % replace top TS with type# of its base type
   2:    oTypSPopPushPtr             % replace top TS with its ptrType field
   2:    oTypSMatch >> boolean       % do top 2 types match? (pop both, push 1)
   2:    oTypSChoose >> typ          % return type on TS (not root type)
   2:    oTypSChoosePop >> typ       % return type on TS (not root type), pop it
   2:    oTypSChooseKind >> typ      % return kind (array,etc) of top type; no pop
   2:    oTypSChoosePtr >> typ       % return 'ptrType' field of type; no pop
   2:    oTypSSwap                   % swap top two TS entries
   2:    oTypSPop
      
   2:    oTypNew(typ)                % new TT entry, with type class (e.g. array)
                                     %   push typ# on TS, for use by following:
   2:    oTypSetSize                 % size field = VS (don't pop VS)
   2:    oTypAssignBasePop           % base of 2nd on TS := top of TS, pop TS
   2:    oTypAssignPtr               % ptrType of 2nd on TS := top of TS, no pop
   2: ;
      
   2: type patchStack:
   2:    patchLoop                   % addr of start of loop (repeat, while, for)
   2:    patchExit                   % addrs where jumps out of loop are
                                     %   (use count mechanism to count how many)
   2:    patchIf;                    % addr of jump around code in 'if' statement
      
   2: mechanism patch:               % note, creates absolute-address jumps
   2:    oPatchPushHere(patchStack)  % put current address on a patch stack
   2:    oPatchAnyEntries(patchStack) >> boolean     % anything in patch stack?
   2:    oPatchSwap(patchStack)      % swap top two entries
   2:    oPatchDup(patchStack)       % duplicate the top entry
   2:    oPatchPopFwd(patchStack)    % store here at x (x=top of stack), pop stack
   2:    oPatchPopBack(patchStack);  % emit x (so advance 'here'), pop stack
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
  12:    pProgram
  14:    pIdent
      
  16:    t = @newIdent( nProgram, kProgram, LAST_ID )
  32:    oScopeDeclare( t )
      
  38:    [
  38:       | '(' :
  40:          pIdent      % input, output files
      
  42:          t = @newIdent( nVar, kVar, LAST_ID )
  58:          oNodeSet( t, qType, FileType )
  70:          oScopeDeclareAlloc( t )
      
  76:          ','
  78:          pIdent
      
  80:          t = @newIdent( nVar, kVar, LAST_ID )
  96:          oNodeSet( t, qType, FileType )
 108:          oScopeDeclareAlloc( t )
      
 114:          ')'
 116:       | * :
 121:    ]
 121:    ';'
 123:    @Block( nGlobalVar )    % not including punctuation after body's 'end'
 130:    '.'
 132:    oScopeEnd
 134:    ;
      
 134: Block( node_type varNodeType ):
 136:    {[
 136:       | pConst :     @ConstDecl
 140:       | pType :      @TypeDecl
 144:       | pVar :       @VarDecl( varNodeType )
 153:       | pProcedure : @ProcDecl
 157:       | pFunction :  @FuncDecl
 161:       | * :          @Statement
 176:                      .tReturn
 178:                      >
 180:    ]};
      
 183: ProcDecl:
 185:    Node decl
      
 185:    pIdent
 187:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 203:    oScopeBegin
 204:    @FormalArgDecl
 206:    oNodeSet( decl, qParams, oScopeCurrent )
 217:    oScopeEnd
 218:    oScopeDeclare( decl )
 224:    ';'
      
 226:    oScopeBegin
 227:    @Block( nLocalVar )
 234:    oNodeSet( decl, qChildScope, oScopeCurrent )
 245:    oScopeEnd
 246:    ';';
      
 249: FuncDecl:
 251:    Node decl
 251:    Node theType
      
 251:    pIdent
 253:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 269:    oScopeBegin
 270:    @FormalArgDecl
 272:    oNodeSet( decl, qParams, oScopeCurrent )
 283:    oScopeEnd
 284:    oScopeDeclare( decl )
 290:    ':'
      
 292:    @TypeRef( theType )
 299:    oNodeSet( decl, qType, theType )
 311:    ';'
      
 313:    oScopeBegin
 314:    @Block( nLocalVar )
 321:    oNodeSet( decl, qChildScope, oScopeCurrent )
 332:    oScopeEnd
 333:    ';';
      
      
      % TO DO:
      %   This code is declaring params in the wrong order.
      %   Also ignoring var keyword.
      %   Also not using schema yet.
      %   Also should use a var instead of count stack.
      %
 336: FormalArgDecl:
 338:    [
 338:       | '(' :
 340:          {
 340:             NodeVec decls
 340:             decls = oNodeVecNew
 345:             Node decl
 345:             boolean isInOut
 345:             isInOut = false
      
 351:             [
 351:                | pVar : isInOut = true
 359:                | * :
 364:             ]
      
 364:             {  pIdent
      
 366:                decl = @newIdent( nParam, kVar, LAST_ID )
 382:                oNodeSetBoolean( decl, qInOut, isInOut )
 394:                oNodeVecAppend( decls, decl )
      
 403:                [
 403:                   | ':' : >
 407:                   | ',' :
 409:                ]
 417:             }
      
 419:             Node theType
 419:             @TypeRef( theType )
      
 426:             int i
 426:             i = 0
 432:             {[ equal( i, oNodeVecSize( decls ) )
 446:                | false :
 447:                   decl = oNodeVecElement( decls, i )
 460:                   oNodeSet( decl, qType, theType )
 472:                   oScopeDeclareAlloc( decl )
 478:                   inc( i )
 484:                | * :
 489:                   >
 491:             ]}
      
 493:             oNodeVecDelete( decls )
      
 499:             [
 499:                | ')' : >
 503:                | ';' :
 505:             ]
 513:          }
 515:       | * :
 520:    ];
      
 521: ConstDecl:
 523:    {[
 523:       | pIdent :
 525:          Node decl
 525:          decl = @newIdent( nConst, kConst, LAST_ID )
 541:          '='
      
 543:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 545:          int val
 545:          val = oValueTop
 550:          oValuePop
 551:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 563:          oNodeSet( decl, qType, IntegerType )
      
 575:          oScopeDeclare( decl )
 581:          ';'
 583:       | * :
 588:          >
 590:    ]};
      
 593: TypeDecl:
 595:    {[
 595:       | pIdent :
 597:          Node decl
 597:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 613:          '='
 615:          Node theType
 615:          @TypeRef( theType )
 622:          oNodeSet( decl, qType, theType )
 634:          oScopeDeclare( decl )
 640:          ';'
 642:       | * :
 647:          >
 649:    ]};
      
 652: VarDecl( node_type varNodeType ):
 654:    {[
 654:       | pIdent :
 656:          NodeVec decls
 656:          decls = oNodeVecNew
 661:          Node decl
 661:          {
 661:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 677:             oNodeVecAppend( decls, decl )
 686:             [
 686:                | ',' :
 688:                   pIdent
 690:                | * :
 695:                   >
 697:             ]
 697:          }
 699:          ':'
 701:          Node theType
 701:          @TypeRef( theType )
      
 708:          int i
 708:          i = 0
 714:          {[ equal( i, oNodeVecSize( decls ) )
 728:            | false :
 729:              decl = oNodeVecElement( decls, i )
 742:              oNodeSet( decl, qType, theType )
 754:              oScopeDeclareAlloc( decl )
 760:              inc( i )
 766:             | * :
 771:               >
 773:          ]}
      
 775:          oNodeVecDelete( decls )
 781:          ';'
 783:       | * :
 788:          >
 790:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
 793: TypeRef( out Node resultType ):
 795:    [
 795:       | pIdent :           % previously named type (including intrinsics)
 797:          Node decl
 797:          decl = oScopeFindRequire
 802:          [ oNodeType( decl )
 809:            | nTypeDecl :
 810:                resultType = oNodeGet( decl, qType )
 823:            | * :
 828:                #eNotType
 830:                resultType = IntegerType
 836:          ]
         
 836:       | pArray :
 838:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
 840:          NodeVec dimensions
 840:          dimensions = oNodeVecNew
      
 845:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
 845:             Node subrange
 845:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
 855:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
 867:             @ConstExpr
 869:             oNodeSetInt( subrange, qLow, oValueTop )
 880:             oValuePop
 881:             '..'
 883:             @ConstExpr
 885:             oNodeSetInt( subrange, qHigh, oValueTop )
 896:             oValuePop
 897:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
 909:             oTypeAdd( subrange )
      
 915:             Node a
 915:             a = oNodeNew( nArrayType )
 925:             oNodeSet( a, qIndexType, subrange )
      
 937:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
 946:             [
 946:                | ']' : >
 950:                | ',' :
 952:             ]
 960:          }
 962:          pOf
 964:          Node baseType
 964:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
 971:          int dim
 971:          dim = oNodeVecSize( dimensions )
 981:          {
 981:              dec(dim)
      
 987:              Node a
 987:              a = oNodeVecElement( dimensions, dim )
1000:              oNodeSet( a, qBaseType, baseType )
1012:              Node subrange
1012:              subrange = oNodeGet( a, qIndexType )
1025:              int width
1025:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1052:              inc( width )
1058:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1084:              oTypeAdd( a )
1090:              baseType = a
      
1096:              [ equal_zero(dim)
1103:                  | true:  >
1106:                  | *:
1111:              ]
1111:          }
      
1113:          resultType = oNodeVecElement( dimensions, 0 )
1126:          oNodeVecDelete( dimensions )
      
1132:       | '^' :
1134:          Node theType
1134:          @TypeRef( theType )
1141:          resultType = @PointerTypeTo( theType )
      
1152:       | pRecord :
1154:          resultType = oNodeNew( nRecordType )
1164:          oScopeBegin
      
1165:          @VarDecl( nRecordField )
      
1172:          int size
1172:          size = oNodeGetInt( oScopeCurrent, qNextOffset )
               % to do: padding
1184:          [ equal_zero( size )
1191:             | true : #eRecordEmpty
1194:             | * :
1199:          ]
      
1199:          pEnd
      
1201:          oNodeSet( resultType, qScope, oScopeCurrent )
1212:          oNodeSetInt( resultType, qSize, size )
1224:          oScopeEnd
1225:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1231:       | pSet :
1233:          pOf
1235:          Node theType
1235:          @TypeRef( theType )
1242:       | * :       % this works for cases except where expr starts with an id
1255:          @ConstExpr '..' @ConstExpr
1261:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1262: ConstExpr:
1264:    [
1264:       | pIntLit :
1266:          oValuePush( TOKEN_VALUE )
1271:       | pIdent :
1273:          Node decl
1273:          decl = oScopeFindRequire
1278:          [ oNodeType( decl )
1285:             | nConst :
1286:                oValuePush( oNodeGetInt( decl, qValue ) )
1299:             | * :
1304:                #eNotConst
1306:                oValuePush( 0 )
1312:          ]
1312:       | pMinus :
1314:          @ConstExpr
1316:          oValueNegate
1317:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1328: Expr:
1330:    @BoolExpr
1332:    {[
1332:       | '=' :
1334:          @BoolExpr
1336:          @MatchTypes
1338:          [ oTypeSNodeType
1340:             | nIntegerType, nBooleanType :  .tEqualInt
1343:             | nPointerType :                .tEqualPtr
1347:             | nCharType, nStringType :      #eNotImplemented
1351:             | * :                           #eNotAllowed
1366:          ]
1366:          oTypeSPop
1367:          oTypeSPush( BooleanType )
      
1373:       | '<>' :
1375:          @BoolExpr
1377:          @MatchTypes
1379:          [ oTypeSNodeType
1381:             | nIntegerType, nBooleanType :  .tNotEqualInt
1384:             | nPointerType :                .tNotEqualPtr
1388:             | nCharType, nStringType :      #eNotImplemented
1392:             | * :                           #eNotAllowed
1407:          ]
1407:          oTypeSPop
1408:          oTypeSPush( BooleanType )
      
1414:       | '<' :
1416:          @BoolExpr
1418:          @MatchTypes
1420:          [ oTypeSNodeType
1422:             | nIntegerType, nBooleanType :  .tLessInt
1425:             | nCharType, nStringType :      #eNotImplemented
1429:             | * :                           #eNotAllowed
1442:          ]
1442:          oTypeSPop
1443:          oTypeSPush( BooleanType )
      
1449:       | '>' :
1451:          @BoolExpr
1453:          @MatchTypes
1455:          [ oTypeSNodeType
1457:             | nIntegerType, nBooleanType :  .tGreaterInt
1460:             | nCharType, nStringType :      #eNotImplemented
1464:             | * :                           #eNotAllowed
1477:          ]
1477:          oTypeSPop
1478:          oTypeSPush( BooleanType )
      
1484:       | '<=' :
1486:          @BoolExpr
1488:          @MatchTypes
1490:          [ oTypeSNodeType
1492:             | nIntegerType, nBooleanType :  .tLessEqualInt
1495:             | nCharType, nStringType :      #eNotImplemented
1499:             | * :                           #eNotAllowed
1512:          ]
1512:          oTypeSPop
1513:          oTypeSPush( BooleanType )
      
1519:       | '>=' :
1521:          @BoolExpr
1523:          @MatchTypes
1525:          [ oTypeSNodeType
1527:             | nIntegerType, nBooleanType :  .tGreaterEqualInt
1530:             | nCharType, nStringType :      #eNotImplemented
1534:             | * :                           #eNotAllowed
1547:          ]
1547:          oTypeSPop
1548:          oTypeSPush( BooleanType )
      
1554:       | * :
1569:          >
1571:    ]};
      
1574: BoolExpr:
1576:    @BoolTerm
1578:    {[
1578:       | pOr :
1580:          @RequireBoolPop
1582:          @BoolTerm
1584:          @RequireBool
1586:          .tOr
1588:       | * :
1593:          >
1595:    ]};
      
1598: BoolTerm:
1600:    @BoolFactor
1602:    {[
1602:       | pAnd :
1604:          @RequireBoolPop
1606:          @BoolFactor
1608:          @RequireBool
1610:          .tAnd
1612:       | * :
1617:          >
1619:    ]};
      
1622: BoolFactor:
1624:    [
1624:       | pNot :
1626:          @ArithExpr
1628:          @RequireBool
1630:          .tNot
1632:       | * :
1637:          @ArithExpr
1639:    ];
      
1640: ArithExpr:
1642:    @Term
1644:    {[
1644:       | pPlus :
1646:          @RequireIntPop
1648:          @Term
1650:          @RequireInt
1652:          .tAddInt
1654:       | pMinus :
1656:          @RequireIntPop
1658:          @Term
1660:          @RequireInt
1662:          .tSubtractInt
1664:       | * :
1671:          >
1673:    ]};
      
1676: Term:
1678:    @Factor
1680:    {[
1680:       | pTimes :
1682:          @RequireIntPop
1684:          @Factor
1686:          @RequireInt
1688:          .tMultiplyInt
1690:       | pDivide :
1692:          @RequireIntPop
1694:          @Factor
1696:          @RequireInt
1698:          .tDivideInt
1700:       | * :
1707:          >
1709:    ]};
      
1712: Factor:
1714:    [
1714:       | pPlus :
1716:          @Primary
1718:          @RequireInt
1720:       | pMinus :
1722:          @Primary
1724:          @RequireInt
1726:          .tNegateInt
1728:       | * :
1735:          @Primary
1737:    ];
      
1738: Primary:
1740:    [
1740:       | pIntLit :
1742:          .tPushIntLit   oEmitInt( TOKEN_VALUE )
1749:          oTypeSPush( IntegerType )
      
1755:       | '(' :
1757:          @Expr
1759:          ')'
      
1761:       | pStrLit :
1763:          oStringAllocLit     % store, put addr on value stack
1764:          .tPushAddr  oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
1772:          oTypeSPush( StringType )
      
1778:       | pIdent :
1780:          Node decl
1780:          Node theType
1780:          decl = oScopeFindRequire
      
1785:          [ oNodeType( decl )
1792:             | nFunc :
1793:                [
1793:                   | '(' :
1795:                      {  @Expr
      
                              % TO DO: match type against param
                              % TO DO: push the expression onto the call stack e.g. iPush...
                              %  Meanwhile for now we are broken, leaving the value on the runtime value stack
1797:                         oTypeSPop
      
1798:                         [
1798:                           | ')' : >
1802:                           | ',' :
1804:                         ]
1812:                      }
1814:                   | * :
1819:                ]
1819:                .tCall  @EmitValue( decl )
1828:                oTypeSPush( oNodeGet( decl, qType ) )
      
1841:             | nConst :
1843:                theType = oNodeGet( decl, qType )
1856:                oTypeSPush( theType )
1862:                [ oTypeSNodeType
1864:                   | nIntegerType, nBooleanType :
1865:                      .tPushIntLit @EmitValue( decl )
1874:                   | * :
1881:                      #eNotImplemented
1883:                ]
      
1883:             | nGlobalVar :
1885:                theType = oNodeGet( decl, qType )
1898:                oTypeSPush( theType )
1904:                [ oTypeSNodeType
1906:                   | nIntegerType :
1907:                      .tPushIntVar @EmitValue( decl )
1916:                   | nBooleanType :
1918:                      .tPushBoolVar @EmitValue( decl )
1927:                   | nCharType, nStringType, nFileType :
1929:                      #eNotImplemented
1931:                   | nPointerType :
1933:                      .tPushPtrVar @EmitValue( decl )
1942:                      [
1942:                         | '^' :             % dereferenced
1944:                            oTypeSPop
1945:                            oTypeSPush( oNodeGet( theType, qBaseType ) )
1958:                            @LValue
1960:                            @FetchVar
1962:                         | * :               % just ptr value alone
1967:                      ]
1967:                   | * :                     % compound type
1982:                      .tPushAddr @EmitValue( decl )    % addr of start of var
1991:                      @LValue                % get final addr
1993:                      @FetchVar              % get final value
1995:                ]
      
1995:             | * :
2004:                #eNotValue
2006:                oTypeSPush( IntegerType )
2012:          ]
      
2012:       | '^' :        % ^var
2014:          pIdent
      
2016:          Node decl
2016:          Node theType
2016:          decl = oScopeFindRequire
2021:          theType = oNodeGet( decl, qType )
      
2034:          [ oNodeType( decl )
2041:             | nGlobalVar :
2042:                .tPushAddr @EmitValue( decl )
2051:                @LValue     % ptr value to expr stack
      
2053:                Node ptrType
2053:                ptrType = @PointerTypeTo( theType )
2064:                oTypeSPush( ptrType )
      
2070:             | nLocalVar, nParam : #eNotImplemented
2074:                oTypeSPush( IntegerType )
2080:             | * :
2089:                #eNotVar
2091:                oTypeSPush( IntegerType )
2097:          ]
      
2097:       | * :
2110:          #eNotValue
2112:          oTypeSPush( IntegerType )
2118:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2119: FetchVar:
2121:    [ oTypeSNodeType
2123:       | nIntegerType :   .tFetchInt
2126:       | nBooleanType :   .tFetchBool
2130:       | nCharType, nStringType, nFileType : #eNotImplemented
2134:       | nPointerType :   .tFetchPtr
2138:       | * :              % compound type; leave as addr
2153:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, etc, to get final addr on run stack, and final type
      % on type stack.
      
2154: LValue:
2156:    {[
2156:       | '[' :       @ArraySubscripts
2160:       | '.' :       #eNotImplemented
2164:       | '^' :       @PointerDeref
2168:       | * :         >
2179:    ]};
      
2182: ArraySubscripts:
2184:    [ oTypSChooseKind
2186:       | tyArray :
2187:       | * :       #eNotArray
2194:    ]
2194:    {
2194:       [ oTypSChooseKind
2196:          | tyArray :
2197:          | * :    #eTooManySubscripts
2204:       ]
2204:       oValuePushLowTS   % low subscript of this dimension
2205:       oTypSPopPushBase  % replace TS with next dimension, or OF type
2206:       @Expr
2208:       @RequireIntPop
2210:       [ oValueIsZero    % adjust for low subscript
2212:          | true :       oValuePop
2214:          | * :          .tPushIntLit oEmitInt( oValueTop ) .tSubtractInt oValuePop
2229:       ]
2229:       oValuePushSizeTS
2230:       [ oValueIsOne     % adjust for size of subtype
2232:          | true :       oValuePop
2234:          | * :          .tPushIntLit oEmitInt( oValueTop ) .tMultiplyInt oValuePop
2249:       ]
2249:       .tAddInt          % update start address
2251:       [
2251:          | ']' :  >
2255:          | ',' :
2257:       ]
2265:    };
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2268: PointerDeref:
2270:    [ oTypeSNodeType
2272:       | nPointerType :
2273:       | * :       #eNotPointer
2280:    ]
2280:    .tFetchPtr           % now addr on stack is addr of what we're pointing to
      
2282:    Node theType
2282:    theType = oTypeSTop
2287:    oTypeSPop
2288:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2302:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
2302: Statement:
2304:    [
2304:       | pWriteln :     @WritelnStmt
2308:       | pWrite :       @WriteStmt
2312:       | pReadln :      @ReadlnStmt
2316:       | pRead :        @ReadStmt
2320:       | pIf :          @IfStmt
2324:       | pWhile :       @WhileStmt
2328:       | pFor :         @ForStmt
2332:       | pRepeat :      @RepeatStmt
2336:       | pExit :        @ExitStmt
2340:       | pCycle :       @CycleStmt
2344:       | pBegin :       @BeginStmt
2348:       | pIdent :       @AssignOrCallStmt
2352:       | * :            % null statement : don't accept any tokens
2379:    ];
      
      
2380: AssignOrCallStmt:         % *** Call doesn't work yet ***
2382:    Node decl
2382:    decl = oScopeFindRequire
2387:    [ oNodeType( decl )    % can parse without semantic info
2394:       | nProc :           %    but this is easier
2395:          [
2395:             | '(' :
2397:                {  @Expr oTypSPop  % ignore type for now
2400:                   [
2400:                     | ')' : >
2404:                     | ',' :
2406:                   ]
2414:                }
2416:             | * :
2421:          ]
2421:          .tCall  @EmitValue( decl )
      
2430:       | nGlobalVar :
2432:          .tPushAddr @EmitValue( decl )
2441:          oTypeSPush( oNodeGet( decl, qType ) )
2454:          @LValue        % handle subscripts, if any
2456:          ':=' 
2458:          @Expr
2460:          @MatchTypes
2462:          [ oTypeSNodeType
2464:             | nIntegerType :            .tAssignInt
2467:             | nBooleanType :            .tAssignBool
2471:             | nCharType, nStringType, nFileType :   #eNotImplemented
      
                  % compound var assigns; addrs of src, dest on stack
2475:             | nPointerType :            .tAssignPtr
2479:             | * :
2494:                 int size
2494:                 size = oNodeGetInt( oTypeSTop, qSize )
2506:                 .tCopy  oEmitInt( size )    % multi-word copy
2514:          ]
2514:          oTypeSPop
      
2515:       | * :
2522:          #eBadStatement
2524:    ];
      
2525: IfStmt:
2527:    @Expr
2529:    @RequireBoolPop
2531:    pThen
2533:    .tJumpFalse
2535:    oPatchPushHere(patchIf)
2541:    .tSpace
2543:    @Statement
2545:    [
2545:       | pElse :
2547:          .tJump
2549:          oPatchPushHere(patchIf)
2555:          .tSpace
2557:          oPatchSwap(patchIf)
2563:          oPatchPopFwd(patchIf)
2569:          @Statement
2571:       | * :
2576:    ]
2576:    oPatchPopFwd(patchIf);
      
2583: ForStmt:
2585:    pIdent
2587:    oSymLookup
2588:    [ oSymChooseKind
2590:       | kVar :
2591:          oTypSPushTyp
2592:          @RequireIntPop
2594:       | * :        #eNotIntVar
2601:    ]
2601:    oValuePushVal                   % address of index var (keep on VS)
2602:    .tPushAddr oEmitInt( oValueTop )
2609:    ':='
2611:    @Expr
2613:    @RequireIntPop
2615:    .tAssignInt
2617:    .tJump oPatchPushHere(patchLoop) .tSpace
2627:    oPatchPushHere(patchLoop)
2633:    oPatchSwap(patchLoop)
2639:    [
2639:       | pTo :
2641:          .tIncIntVar oEmitInt( oValueTop )
2648:          oPatchPopFwd(patchLoop)
2654:          .tPushIntVar oEmitInt( oValueTop )
2661:          @Expr
2663:          @RequireIntPop
2665:          .tGreaterInt
2667:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2677:          oPatchSwap(patchLoop)
2683:       | pDownto :
2685:          .tDecIntVar oEmitInt( oValueTop )
2692:          oPatchPopFwd(patchLoop)
2698:          .tPushIntVar oEmitInt( oValueTop )
2705:          @Expr
2707:          @RequireIntPop
2709:          .tLessInt
2711:          .tJumpTrue oPatchPushHere(patchLoop) .tSpace
2721:          oPatchSwap(patchLoop)
2727:    ]
2735:    oCountPush(0)          % count 'exit' patches
2741:    pDo
2743:    @Statement
2745:    .tJump oPatchPopBack(patchLoop)
2753:    oValuePop
2754:    oPatchPopFwd(patchLoop)
2760:    @PatchExitsPop;
      
2763: RepeatStmt:
2765:    oPatchPushHere(patchLoop) % start of loop
2771:    oCountPush(0)          % count the 'exit' patches
2777:    @Statement
2779:    {[
2779:       | ';' :
2781:          @Statement
2783:       | pUntil :
2785:          @Expr
2787:          @RequireBoolPop
2789:          .tJumpFalse
2791:          oPatchPopBack(patchLoop)
2797:          @PatchExitsPop
2799:          >
2801:    ]};
      
2812: WhileStmt:
2814:    oPatchPushHere(patchLoop)    % start of loop
2820:    oCountPush(0)
2826:    @Expr
2828:    @RequireBoolPop
2830:    pDo
2832:    .tJumpFalse
2834:    oPatchPushHere(patchLoop)    % jump out
2840:    .tSpace
2842:    oPatchSwap(patchLoop)        % start on top
2848:    @Statement
2850:    .tJump
2852:    oPatchPopBack(patchLoop)
2858:    oPatchPopFwd(patchLoop)
2864:    @PatchExitsPop;
      
2867: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
2869:    [ oPatchAnyEntries(patchLoop)
2876:       | true :
2877:          .tJump
2879:          oPatchDup(patchLoop)  % addr of start
2885:          oPatchPopBack(patchLoop)
2891:       | * :
2896:          #eNotInALoop
2898:    ];
      
2899: ExitStmt:
2901:    [ oPatchAnyEntries(patchLoop)
2908:       | true :
2909:          .tJump
2911:          oPatchPushHere(patchExit)
2917:          .tSpace
2919:          oCountInc
2920:       | * :
2925:          #eNotInALoop
2927:    ];
      
2928: BeginStmt:
2930:    @Statement
2932:    {[
2932:       | ';' :   @Statement
2936:       | pEnd :  >
2940:    ]};
      
2951: WritelnStmt:
2953:    @WriteStmt
2955:    .tPutCR;
      
2958: WriteStmt:
2960:    [
2960:       | '(' :
2962:          {
2962:             @Expr
2964:             [ oTypSChoose
2966:                | tyInteger :                .tPutInt
2969:                | tyBoolean :                .tPutBool
2973:                | tyString :                 .tPutStr
2977:                | tyChar, tyFile :           #eNotImplemented
2981:                | * :                        % compound types
2994:                   [ oTypSChooseKind
2996:                      | tyPointer :          .tPutPtr
2999:                      | * :                  #eNotAllowed
3006:                   ]
3006:             ]
3006:             oTypSPop
3007:             [
3007:                | ')' : >
3011:                | ',' :
3013:             ]
3021:          }
3023:       | * :
3028:    ];
      
      
3029: ReadlnStmt:      % ***
3032:    ;
3032: ReadStmt:
3035:    ;
      
      % -------------------------------- Utilities -------------------------------
      
3035: PatchExitsPop:
3037:    {[ oCountIsZero
3039:       | false : oPatchPopFwd(patchExit)
3046:       | * :     >
3053:    ]}
3055:    oCountPop;
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
3057: MatchTypes:
3059:    node_type nt
3059:    nt = oTypeSNodeType
3064:    oTypeSPop
3065:    [ equal_node_type( nt, oTypeSNodeType )
3074:       | false :
3075:          #eTypeMismatch
3077:       | * :
3082:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
3083: RequireIntPop:
3085:    [ oTypeSNodeType
3087:       | nIntegerType :
3088:       | * :          #eNotInteger
3095:    ]
3095:    oTypeSPop;
      
3097: RequireInt:
3099:    [ oTypeSNodeType
3101:       | nIntegerType :
3102:       | * :          #eNotInteger
3109:    ];
      
3110: RequireBoolPop:
3112:    [ oTypeSNodeType
3114:       | nBooleanType :
3115:       | * :          #eNotBoolean
3122:    ]
3122:    oTypeSPop;
      
3124: RequireBool:
3126:    [ oTypeSNodeType
3128:       | nBooleanType :
3129:       | * :          #eNotBoolean
3136:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
3137: newType( node_type nt, int size ) >> Node:
3139:   Node node
3139:   node = oNodeNew( nt )
3149:   oNodeSetInt( node, qSize, size )
3161:   oTypeAdd( node )
3167:   >> node
3171:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
3171: newIdent( node_type nt, kind k, int id ) >> Node:
3173:   Node t
3173:   t = oNodeNew( nt )
3183:   oNodeSetKind( t, qKind, k )   % deprecated attribute
3195:   oNodeSetInt( t, qIdent, id )
3207:   >> t
3211:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
3211: PointerTypeTo( Node theType ) >> Node:
3213:    Node ptrType
3213:    ptrType = oNodeGet( theType, qPointerType )
3226:    [ oNodeNull( ptrType )
3233:       | true :
3234:          ptrType = oNodeNew( nPointerType )
3244:          oNodeSet( ptrType, qBaseType, theType )
3256:          oNodeSetInt( ptrType, qSize, 8 )
3268:          oTypeAdd( ptrType )
3274:          oNodeSet( theType, qPointerType, ptrType )
3286:       | * :
3291:    ]
3291:    >> ptrType;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
3295: EmitValue( Node decl ):
3297:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
3311: installBuiltIns:
      
         % install built-in types
3313:    FileType = @newType( nFileType, 4 )
3327:    IntegerType = @newType( nIntegerType, 4 )
3341:    BooleanType = @newType( nBooleanType, 1 )
3355:    CharType = @newType( nCharType, 1 )
3369:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
3383:    Node t
      
3383:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
3399:    oNodeSet( t, qType, FileType )
3411:    oScopeDeclare( t )
      
3417:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
3433:    oNodeSet( t, qType, IntegerType )
3445:    oScopeDeclare( t )
      
3451:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
3467:    oNodeSet( t, qType, BooleanType )
3479:    oScopeDeclare( t )
      
3485:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
3501:    oNodeSet( t, qType, CharType )
3513:    oScopeDeclare( t )
      
3519:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
3535:    oNodeSet( t, qType, StringType )
3547:    oScopeDeclare( t )
      
         % Built-in constants
      
3553:    t = @newIdent( nConst, kConst, oIdAdd_True )
3569:    oNodeSet( t, qType, BooleanType )
3581:    oNodeSetInt( t, qValue, 1 )
3593:    oScopeDeclare( t )
      
3599:    t = @newIdent( nConst, kConst, oIdAdd_False )
3615:    oNodeSet( t, qType, BooleanType )
3627:    oNodeSetInt( t, qValue, 0 )
3639:    oScopeDeclare( t )
      
3646:    ;
      
3646: end
      
3646: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 1
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 3311
  12: oInput 26
  14: oInput 0
  16: oGetAddrLocal 1
  18: oPushResult
  19: oSetResult 5
  21: oPushResult
  22: oSetResult 1
  24: oPushResult
  25: LAST_ID
  26: oPushResult
  27: oCall 3171
  29: oPop 3
  31: oAssign
  32: oGetLocal 1
  34: oPushResult
  35: oScopeDeclare
  36: oPop 1
  38: oInputChoice 118
  40: oInput 0
  42: oGetAddrLocal 1
  44: oPushResult
  45: oSetResult 10
  47: oPushResult
  48: oSetResult 6
  50: oPushResult
  51: LAST_ID
  52: oPushResult
  53: oCall 3171
  55: oPop 3
  57: oAssign
  58: oGetLocal 1
  60: oPushResult
  61: oSetResult 6
  63: oPushResult
  64: oGetGlobal 2
  66: oPushResult
  67: oNodeSet
  68: oPop 3
  70: oGetLocal 1
  72: oPushResult
  73: oScopeDeclareAlloc
  74: oPop 1
  76: oInput 12
  78: oInput 0
  80: oGetAddrLocal 1
  82: oPushResult
  83: oSetResult 10
  85: oPushResult
  86: oSetResult 6
  88: oPushResult
  89: LAST_ID
  90: oPushResult
  91: oCall 3171
  93: oPop 3
  95: oAssign
  96: oGetLocal 1
  98: oPushResult
  99: oSetResult 6
 101: oPushResult
 102: oGetGlobal 2
 104: oPushResult
 105: oNodeSet
 106: oPop 3
 108: oGetLocal 1
 110: oPushResult
 111: oScopeDeclareAlloc
 112: oPop 1
 114: oInput 14
 116: oJumpForward 121
 118: Choice Lookup Table
          13     40
 121: oInput 4
 123: oSetResult 11
 125: oPushResult
 126: oCall 134
 128: oPop 1
 130: oInput 18
 132: oScopeEnd
 133: oReturn
 134: oLocalSpace 0
 136: oInputChoice 163
 138: oCall 521
 140: oJumpForward 180
 142: oCall 593
 144: oJumpForward 180
 146: oGetParam 1
 148: oPushResult
 149: oCall 652
 151: oPop 1
 153: oJumpForward 180
 155: oCall 183
 157: oJumpForward 180
 159: oCall 249
 161: oJumpForward 180
 163: Choice Lookup Table
          28    159
          27    155
          31    146
          30    142
          29    138
 174: oCall 2302
 176: oEmit 31
 178: oJumpForward 182
 180: oJumpBack 136
 182: oReturn
 183: oLocalSpace 1
 185: oInput 0
 187: oGetAddrLocal 1
 189: oPushResult
 190: oSetResult 6
 192: oPushResult
 193: oSetResult 2
 195: oPushResult
 196: LAST_ID
 197: oPushResult
 198: oCall 3171
 200: oPop 3
 202: oAssign
 203: oScopeBegin
 204: oCall 336
 206: oGetLocal 1
 208: oPushResult
 209: oSetResult 9
 211: oPushResult
 212: oScopeCurrent
 213: oPushResult
 214: oNodeSet
 215: oPop 3
 217: oScopeEnd
 218: oGetLocal 1
 220: oPushResult
 221: oScopeDeclare
 222: oPop 1
 224: oInput 4
 226: oScopeBegin
 227: oSetResult 12
 229: oPushResult
 230: oCall 134
 232: oPop 1
 234: oGetLocal 1
 236: oPushResult
 237: oSetResult 10
 239: oPushResult
 240: oScopeCurrent
 241: oPushResult
 242: oNodeSet
 243: oPop 3
 245: oScopeEnd
 246: oInput 4
 248: oReturn
 249: oLocalSpace 2
 251: oInput 0
 253: oGetAddrLocal 1
 255: oPushResult
 256: oSetResult 7
 258: oPushResult
 259: oSetResult 3
 261: oPushResult
 262: LAST_ID
 263: oPushResult
 264: oCall 3171
 266: oPop 3
 268: oAssign
 269: oScopeBegin
 270: oCall 336
 272: oGetLocal 1
 274: oPushResult
 275: oSetResult 9
 277: oPushResult
 278: oScopeCurrent
 279: oPushResult
 280: oNodeSet
 281: oPop 3
 283: oScopeEnd
 284: oGetLocal 1
 286: oPushResult
 287: oScopeDeclare
 288: oPop 1
 290: oInput 11
 292: oGetAddrLocal 2
 294: oPushResult
 295: oCall 793
 297: oPop 1
 299: oGetLocal 1
 301: oPushResult
 302: oSetResult 6
 304: oPushResult
 305: oGetLocal 2
 307: oPushResult
 308: oNodeSet
 309: oPop 3
 311: oInput 4
 313: oScopeBegin
 314: oSetResult 12
 316: oPushResult
 317: oCall 134
 319: oPop 1
 321: oGetLocal 1
 323: oPushResult
 324: oSetResult 10
 326: oPushResult
 327: oScopeCurrent
 328: oPushResult
 329: oNodeSet
 330: oPop 3
 332: oScopeEnd
 333: oInput 4
 335: oReturn
 336: oLocalSpace 5
 338: oInputChoice 517
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeVecNew
 344: oAssign
 345: oGetAddrLocal 3
 347: oPushResult
 348: oSetResult 0
 350: oAssign
 351: oInputChoice 361
 353: oGetAddrLocal 3
 355: oPushResult
 356: oSetResult 1
 358: oAssign
 359: oJumpForward 364
 361: Choice Lookup Table
          31    353
 364: oInput 0
 366: oGetAddrLocal 2
 368: oPushResult
 369: oSetResult 14
 371: oPushResult
 372: oSetResult 6
 374: oPushResult
 375: LAST_ID
 376: oPushResult
 377: oCall 3171
 379: oPop 3
 381: oAssign
 382: oGetLocal 2
 384: oPushResult
 385: oSetResult 11
 387: oPushResult
 388: oGetLocal 3
 390: oPushResult
 391: oNodeSetBoolean
 392: oPop 3
 394: oGetLocal 1
 396: oPushResult
 397: oGetLocal 2
 399: oPushResult
 400: oNodeVecAppend
 401: oPop 2
 403: oInputChoice 411
 405: oJumpForward 419
 407: oJumpForward 417
 409: oJumpForward 417
 411: Choice Lookup Table
          12    409
          11    405
 416: oEndChoice
 417: oJumpBack 364
 419: oGetAddrLocal 4
 421: oPushResult
 422: oCall 793
 424: oPop 1
 426: oGetAddrLocal 5
 428: oPushResult
 429: oSetResult 0
 431: oAssign
 432: oGetLocal 5
 434: oPushResult
 435: oGetLocal 1
 437: oPushResult
 438: oNodeVecSize
 439: oPop 1
 441: oPushResult
 442: equal
 443: oPop 2
 445: oChoice 486
 447: oGetAddrLocal 2
 449: oPushResult
 450: oGetLocal 1
 452: oPushResult
 453: oGetLocal 5
 455: oPushResult
 456: oNodeVecElement
 457: oPop 2
 459: oAssign
 460: oGetLocal 2
 462: oPushResult
 463: oSetResult 6
 465: oPushResult
 466: oGetLocal 4
 468: oPushResult
 469: oNodeSet
 470: oPop 3
 472: oGetLocal 2
 474: oPushResult
 475: oScopeDeclareAlloc
 476: oPop 1
 478: oGetAddrLocal 5
 480: oPushResult
 481: inc
 482: oPop 1
 484: oJumpForward 491
 486: Choice Lookup Table
           0    447
 489: oJumpForward 493
 491: oJumpBack 432
 493: oGetLocal 1
 495: oPushResult
 496: oNodeVecDelete
 497: oPop 1
 499: oInputChoice 507
 501: oJumpForward 515
 503: oJumpForward 513
 505: oJumpForward 513
 507: Choice Lookup Table
           4    505
          14    501
 512: oEndChoice
 513: oJumpBack 340
 515: oJumpForward 520
 517: Choice Lookup Table
          13    340
 520: oReturn
 521: oLocalSpace 2
 523: oInputChoice 585
 525: oGetAddrLocal 1
 527: oPushResult
 528: oSetResult 8
 530: oPushResult
 531: oSetResult 4
 533: oPushResult
 534: LAST_ID
 535: oPushResult
 536: oCall 3171
 538: oPop 3
 540: oAssign
 541: oInput 5
 543: oCall 1262
 545: oGetAddrLocal 2
 547: oPushResult
 548: oValueTop
 549: oAssign
 550: oValuePop
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSetInt
 561: oPop 3
 563: oGetLocal 1
 565: oPushResult
 566: oSetResult 6
 568: oPushResult
 569: oGetGlobal 3
 571: oPushResult
 572: oNodeSet
 573: oPop 3
 575: oGetLocal 1
 577: oPushResult
 578: oScopeDeclare
 579: oPop 1
 581: oInput 4
 583: oJumpForward 590
 585: Choice Lookup Table
           0    525
 588: oJumpForward 592
 590: oJumpBack 523
 592: oReturn
 593: oLocalSpace 2
 595: oInputChoice 644
 597: oGetAddrLocal 1
 599: oPushResult
 600: oSetResult 9
 602: oPushResult
 603: oSetResult 5
 605: oPushResult
 606: LAST_ID
 607: oPushResult
 608: oCall 3171
 610: oPop 3
 612: oAssign
 613: oInput 5
 615: oGetAddrLocal 2
 617: oPushResult
 618: oCall 793
 620: oPop 1
 622: oGetLocal 1
 624: oPushResult
 625: oSetResult 6
 627: oPushResult
 628: oGetLocal 2
 630: oPushResult
 631: oNodeSet
 632: oPop 3
 634: oGetLocal 1
 636: oPushResult
 637: oScopeDeclare
 638: oPop 1
 640: oInput 4
 642: oJumpForward 649
 644: Choice Lookup Table
           0    597
 647: oJumpForward 651
 649: oJumpBack 595
 651: oReturn
 652: oLocalSpace 4
 654: oInputChoice 785
 656: oGetAddrLocal 1
 658: oPushResult
 659: oNodeVecNew
 660: oAssign
 661: oGetAddrLocal 2
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oSetResult 6
 669: oPushResult
 670: LAST_ID
 671: oPushResult
 672: oCall 3171
 674: oPop 3
 676: oAssign
 677: oGetLocal 1
 679: oPushResult
 680: oGetLocal 2
 682: oPushResult
 683: oNodeVecAppend
 684: oPop 2
 686: oInputChoice 692
 688: oInput 0
 690: oJumpForward 697
 692: Choice Lookup Table
          12    688
 695: oJumpForward 699
 697: oJumpBack 661
 699: oInput 11
 701: oGetAddrLocal 3
 703: oPushResult
 704: oCall 793
 706: oPop 1
 708: oGetAddrLocal 4
 710: oPushResult
 711: oSetResult 0
 713: oAssign
 714: oGetLocal 4
 716: oPushResult
 717: oGetLocal 1
 719: oPushResult
 720: oNodeVecSize
 721: oPop 1
 723: oPushResult
 724: equal
 725: oPop 2
 727: oChoice 768
 729: oGetAddrLocal 2
 731: oPushResult
 732: oGetLocal 1
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeVecElement
 739: oPop 2
 741: oAssign
 742: oGetLocal 2
 744: oPushResult
 745: oSetResult 6
 747: oPushResult
 748: oGetLocal 3
 750: oPushResult
 751: oNodeSet
 752: oPop 3
 754: oGetLocal 2
 756: oPushResult
 757: oScopeDeclareAlloc
 758: oPop 1
 760: oGetAddrLocal 4
 762: oPushResult
 763: inc
 764: oPop 1
 766: oJumpForward 773
 768: Choice Lookup Table
           0    729
 771: oJumpForward 775
 773: oJumpBack 714
 775: oGetLocal 1
 777: oPushResult
 778: oNodeVecDelete
 779: oPop 1
 781: oInput 4
 783: oJumpForward 790
 785: Choice Lookup Table
           0    656
 788: oJumpForward 792
 790: oJumpBack 654
 792: oReturn
 793: oLocalSpace 12
 795: oInputChoice 1244
 797: oGetAddrLocal 1
 799: oPushResult
 800: oScopeFindRequire
 801: oAssign
 802: oGetLocal 1
 804: oPushResult
 805: oNodeType
 806: oPop 1
 808: oChoice 825
 810: oGetParam 1
 812: oPushResult
 813: oGetLocal 1
 815: oPushResult
 816: oSetResult 6
 818: oPushResult
 819: oNodeGet
 820: oPop 2
 822: oAssign
 823: oJumpForward 836
 825: Choice Lookup Table
           9    810
 828: oError 2
 830: oGetParam 1
 832: oPushResult
 833: oGetGlobal 3
 835: oAssign
 836: oJumpForward 1261
 838: oInput 15
 840: oGetAddrLocal 2
 842: oPushResult
 843: oNodeVecNew
 844: oAssign
 845: oGetAddrLocal 3
 847: oPushResult
 848: oSetResult 23
 850: oPushResult
 851: oNodeNew
 852: oPop 1
 854: oAssign
 855: oGetLocal 3
 857: oPushResult
 858: oSetResult 14
 860: oPushResult
 861: oGetGlobal 3
 863: oPushResult
 864: oNodeSet
 865: oPop 3
 867: oCall 1262
 869: oGetLocal 3
 871: oPushResult
 872: oSetResult 16
 874: oPushResult
 875: oValueTop
 876: oPushResult
 877: oNodeSetInt
 878: oPop 3
 880: oValuePop
 881: oInput 19
 883: oCall 1262
 885: oGetLocal 3
 887: oPushResult
 888: oSetResult 17
 890: oPushResult
 891: oValueTop
 892: oPushResult
 893: oNodeSetInt
 894: oPop 3
 896: oValuePop
 897: oGetLocal 3
 899: oPushResult
 900: oSetResult 12
 902: oPushResult
 903: oSetResult 4
 905: oPushResult
 906: oNodeSetInt
 907: oPop 3
 909: oGetLocal 3
 911: oPushResult
 912: oTypeAdd
 913: oPop 1
 915: oGetAddrLocal 4
 917: oPushResult
 918: oSetResult 22
 920: oPushResult
 921: oNodeNew
 922: oPop 1
 924: oAssign
 925: oGetLocal 4
 927: oPushResult
 928: oSetResult 15
 930: oPushResult
 931: oGetLocal 3
 933: oPushResult
 934: oNodeSet
 935: oPop 3
 937: oGetLocal 2
 939: oPushResult
 940: oGetLocal 4
 942: oPushResult
 943: oNodeVecAppend
 944: oPop 2
 946: oInputChoice 954
 948: oJumpForward 962
 950: oJumpForward 960
 952: oJumpForward 960
 954: Choice Lookup Table
          12    952
          16    948
 959: oEndChoice
 960: oJumpBack 845
 962: oInput 37
 964: oGetAddrLocal 5
 966: oPushResult
 967: oCall 793
 969: oPop 1
 971: oGetAddrLocal 6
 973: oPushResult
 974: oGetLocal 2
 976: oPushResult
 977: oNodeVecSize
 978: oPop 1
 980: oAssign
 981: oGetAddrLocal 6
 983: oPushResult
 984: dec
 985: oPop 1
 987: oGetAddrLocal 4
 989: oPushResult
 990: oGetLocal 2
 992: oPushResult
 993: oGetLocal 6
 995: oPushResult
 996: oNodeVecElement
 997: oPop 2
 999: oAssign
1000: oGetLocal 4
1002: oPushResult
1003: oSetResult 14
1005: oPushResult
1006: oGetLocal 5
1008: oPushResult
1009: oNodeSet
1010: oPop 3
1012: oGetAddrLocal 3
1014: oPushResult
1015: oGetLocal 4
1017: oPushResult
1018: oSetResult 15
1020: oPushResult
1021: oNodeGet
1022: oPop 2
1024: oAssign
1025: oGetAddrLocal 9
1027: oPushResult
1028: oGetLocal 3
1030: oPushResult
1031: oSetResult 17
1033: oPushResult
1034: oNodeGetInt
1035: oPop 2
1037: oPushResult
1038: oGetLocal 3
1040: oPushResult
1041: oSetResult 16
1043: oPushResult
1044: oNodeGetInt
1045: oPop 2
1047: oPushResult
1048: subtract
1049: oPop 2
1051: oAssign
1052: oGetAddrLocal 9
1054: oPushResult
1055: inc
1056: oPop 1
1058: oGetLocal 4
1060: oPushResult
1061: oSetResult 12
1063: oPushResult
1064: oGetLocal 9
1066: oPushResult
1067: oGetLocal 5
1069: oPushResult
1070: oSetResult 12
1072: oPushResult
1073: oNodeGetInt
1074: oPop 2
1076: oPushResult
1077: multiply
1078: oPop 2
1080: oPushResult
1081: oNodeSetInt
1082: oPop 3
1084: oGetLocal 4
1086: oPushResult
1087: oTypeAdd
1088: oPop 1
1090: oGetAddrLocal 5
1092: oPushResult
1093: oGetLocal 4
1095: oAssign
1096: oGetLocal 6
1098: oPushResult
1099: equal_zero
1100: oPop 1
1102: oChoice 1108
1104: oJumpForward 1113
1106: oJumpForward 1111
1108: Choice Lookup Table
           1   1104
1111: oJumpBack 981
1113: oGetParam 1
1115: oPushResult
1116: oGetLocal 2
1118: oPushResult
1119: oSetResult 0
1121: oPushResult
1122: oNodeVecElement
1123: oPop 2
1125: oAssign
1126: oGetLocal 2
1128: oPushResult
1129: oNodeVecDelete
1130: oPop 1
1132: oJumpForward 1261
1134: oGetAddrLocal 10
1136: oPushResult
1137: oCall 793
1139: oPop 1
1141: oGetParam 1
1143: oPushResult
1144: oGetLocal 10
1146: oPushResult
1147: oCall 3211
1149: oPop 1
1151: oAssign
1152: oJumpForward 1261
1154: oGetParam 1
1156: oPushResult
1157: oSetResult 24
1159: oPushResult
1160: oNodeNew
1161: oPop 1
1163: oAssign
1164: oScopeBegin
1165: oSetResult 13
1167: oPushResult
1168: oCall 652
1170: oPop 1
1172: oGetAddrLocal 11
1174: oPushResult
1175: oScopeCurrent
1176: oPushResult
1177: oSetResult 3
1179: oPushResult
1180: oNodeGetInt
1181: oPop 2
1183: oAssign
1184: oGetLocal 11
1186: oPushResult
1187: equal_zero
1188: oPop 1
1190: oChoice 1196
1192: oError 15
1194: oJumpForward 1199
1196: Choice Lookup Table
           1   1192
1199: oInput 33
1201: oGetFromParam 1
1203: oPushResult
1204: oSetResult 18
1206: oPushResult
1207: oScopeCurrent
1208: oPushResult
1209: oNodeSet
1210: oPop 3
1212: oGetFromParam 1
1214: oPushResult
1215: oSetResult 12
1217: oPushResult
1218: oGetLocal 11
1220: oPushResult
1221: oNodeSetInt
1222: oPop 3
1224: oScopeEnd
1225: oGetFromParam 1
1227: oPushResult
1228: oTypeAdd
1229: oPop 1
1231: oJumpForward 1261
1233: oInput 37
1235: oGetAddrLocal 10
1237: oPushResult
1238: oCall 793
1240: oPop 1
1242: oJumpForward 1261
1244: Choice Lookup Table
          36   1233
          35   1154
          17   1134
          34    838
           0    797
1255: oCall 1262
1257: oInput 19
1259: oCall 1262
1261: oReturn
1262: oLocalSpace 1
1264: oInputChoice 1319
1266: TOKEN_VALUE
1267: oPushResult
1268: oValuePush
1269: oPop 1
1271: oJumpForward 1327
1273: oGetAddrLocal 1
1275: oPushResult
1276: oScopeFindRequire
1277: oAssign
1278: oGetLocal 1
1280: oPushResult
1281: oNodeType
1282: oPop 1
1284: oChoice 1301
1286: oGetLocal 1
1288: oPushResult
1289: oSetResult 8
1291: oPushResult
1292: oNodeGetInt
1293: oPop 2
1295: oPushResult
1296: oValuePush
1297: oPop 1
1299: oJumpForward 1312
1301: Choice Lookup Table
           8   1286
1304: oError 1
1306: oSetResult 0
1308: oPushResult
1309: oValuePush
1310: oPop 1
1312: oJumpForward 1327
1314: oCall 1262
1316: oValueNegate
1317: oJumpForward 1327
1319: Choice Lookup Table
          23   1314
           0   1273
           1   1266
1326: oEndChoice
1327: oReturn
1328: oLocalSpace 0
1330: oCall 1574
1332: oInputChoice 1556
1334: oCall 1574
1336: oCall 3057
1338: oTypeSNodeType
1339: oChoice 1353
1341: oEmit 22
1343: oJumpForward 1366
1345: oEmit 28
1347: oJumpForward 1366
1349: oError 12
1351: oJumpForward 1366
1353: Choice Lookup Table
          20   1349
          19   1349
          21   1345
          18   1341
          17   1341
1364: oError 13
1366: oTypeSPop
1367: oGetGlobal 4
1369: oPushResult
1370: oTypeSPush
1371: oPop 1
1373: oJumpForward 1571
1375: oCall 1574
1377: oCall 3057
1379: oTypeSNodeType
1380: oChoice 1394
1382: oEmit 23
1384: oJumpForward 1407
1386: oEmit 29
1388: oJumpForward 1407
1390: oError 12
1392: oJumpForward 1407
1394: Choice Lookup Table
          20   1390
          19   1390
          21   1386
          18   1382
          17   1382
1405: oError 13
1407: oTypeSPop
1408: oGetGlobal 4
1410: oPushResult
1411: oTypeSPush
1412: oPop 1
1414: oJumpForward 1571
1416: oCall 1574
1418: oCall 3057
1420: oTypeSNodeType
1421: oChoice 1431
1423: oEmit 25
1425: oJumpForward 1442
1427: oError 12
1429: oJumpForward 1442
1431: Choice Lookup Table
          20   1427
          19   1427
          18   1423
          17   1423
1440: oError 13
1442: oTypeSPop
1443: oGetGlobal 4
1445: oPushResult
1446: oTypeSPush
1447: oPop 1
1449: oJumpForward 1571
1451: oCall 1574
1453: oCall 3057
1455: oTypeSNodeType
1456: oChoice 1466
1458: oEmit 24
1460: oJumpForward 1477
1462: oError 12
1464: oJumpForward 1477
1466: Choice Lookup Table
          20   1462
          19   1462
          18   1458
          17   1458
1475: oError 13
1477: oTypeSPop
1478: oGetGlobal 4
1480: oPushResult
1481: oTypeSPush
1482: oPop 1
1484: oJumpForward 1571
1486: oCall 1574
1488: oCall 3057
1490: oTypeSNodeType
1491: oChoice 1501
1493: oEmit 27
1495: oJumpForward 1512
1497: oError 12
1499: oJumpForward 1512
1501: Choice Lookup Table
          20   1497
          19   1497
          18   1493
          17   1493
1510: oError 13
1512: oTypeSPop
1513: oGetGlobal 4
1515: oPushResult
1516: oTypeSPush
1517: oPop 1
1519: oJumpForward 1571
1521: oCall 1574
1523: oCall 3057
1525: oTypeSNodeType
1526: oChoice 1536
1528: oEmit 26
1530: oJumpForward 1547
1532: oError 12
1534: oJumpForward 1547
1536: Choice Lookup Table
          20   1532
          19   1532
          18   1528
          17   1528
1545: oError 13
1547: oTypeSPop
1548: oGetGlobal 4
1550: oPushResult
1551: oTypeSPush
1552: oPop 1
1554: oJumpForward 1571
1556: Choice Lookup Table
          10   1521
           9   1486
           8   1451
           7   1416
           6   1375
           5   1334
1569: oJumpForward 1573
1571: oJumpBack 1332
1573: oReturn
1574: oLocalSpace 0
1576: oCall 1598
1578: oInputChoice 1590
1580: oCall 3110
1582: oCall 1598
1584: oCall 3124
1586: oEmit 21
1588: oJumpForward 1595
1590: Choice Lookup Table
          52   1580
1593: oJumpForward 1597
1595: oJumpBack 1578
1597: oReturn
1598: oLocalSpace 0
1600: oCall 1622
1602: oInputChoice 1614
1604: oCall 3110
1606: oCall 1622
1608: oCall 3124
1610: oEmit 20
1612: oJumpForward 1619
1614: Choice Lookup Table
          51   1604
1617: oJumpForward 1621
1619: oJumpBack 1602
1621: oReturn
1622: oLocalSpace 0
1624: oInputChoice 1634
1626: oCall 1640
1628: oCall 3124
1630: oEmit 19
1632: oJumpForward 1639
1634: Choice Lookup Table
          53   1626
1637: oCall 1640
1639: oReturn
1640: oLocalSpace 0
1642: oCall 1676
1644: oInputChoice 1666
1646: oCall 3083
1648: oCall 1676
1650: oCall 3097
1652: oEmit 16
1654: oJumpForward 1673
1656: oCall 3083
1658: oCall 1676
1660: oCall 3097
1662: oEmit 17
1664: oJumpForward 1673
1666: Choice Lookup Table
          23   1656
          22   1646
1671: oJumpForward 1675
1673: oJumpBack 1644
1675: oReturn
1676: oLocalSpace 0
1678: oCall 1712
1680: oInputChoice 1702
1682: oCall 3083
1684: oCall 1712
1686: oCall 3097
1688: oEmit 14
1690: oJumpForward 1709
1692: oCall 3083
1694: oCall 1712
1696: oCall 3097
1698: oEmit 15
1700: oJumpForward 1709
1702: Choice Lookup Table
          21   1692
          20   1682
1707: oJumpForward 1711
1709: oJumpBack 1680
1711: oReturn
1712: oLocalSpace 0
1714: oInputChoice 1730
1716: oCall 1738
1718: oCall 3097
1720: oJumpForward 1737
1722: oCall 1738
1724: oCall 3097
1726: oEmit 18
1728: oJumpForward 1737
1730: Choice Lookup Table
          23   1722
          22   1716
1735: oCall 1738
1737: oReturn
1738: oLocalSpace 5
1740: oInputChoice 2099
1742: oEmit 7
1744: TOKEN_VALUE
1745: oPushResult
1746: oEmitInt
1747: oPop 1
1749: oGetGlobal 3
1751: oPushResult
1752: oTypeSPush
1753: oPop 1
1755: oJumpForward 2118
1757: oCall 1328
1759: oInput 14
1761: oJumpForward 2118
1763: oStringAllocLit
1764: oEmit 3
1766: oValueTop
1767: oPushResult
1768: oEmitInt
1769: oPop 1
1771: oValuePop
1772: oGetGlobal 6
1774: oPushResult
1775: oTypeSPush
1776: oPop 1
1778: oJumpForward 2118
1780: oGetAddrLocal 1
1782: oPushResult
1783: oScopeFindRequire
1784: oAssign
1785: oGetLocal 1
1787: oPushResult
1788: oNodeType
1789: oPop 1
1791: oChoice 1997
1793: oInputChoice 1816
1795: oCall 1328
1797: oTypeSPop
1798: oInputChoice 1806
1800: oJumpForward 1814
1802: oJumpForward 1812
1804: oJumpForward 1812
1806: Choice Lookup Table
          12   1804
          14   1800
1811: oEndChoice
1812: oJumpBack 1795
1814: oJumpForward 1819
1816: Choice Lookup Table
          13   1795
1819: oEmit 30
1821: oGetLocal 1
1823: oPushResult
1824: oCall 3295
1826: oPop 1
1828: oGetLocal 1
1830: oPushResult
1831: oSetResult 6
1833: oPushResult
1834: oNodeGet
1835: oPop 2
1837: oPushResult
1838: oTypeSPush
1839: oPop 1
1841: oJumpForward 2012
1843: oGetAddrLocal 2
1845: oPushResult
1846: oGetLocal 1
1848: oPushResult
1849: oSetResult 6
1851: oPushResult
1852: oNodeGet
1853: oPop 2
1855: oAssign
1856: oGetLocal 2
1858: oPushResult
1859: oTypeSPush
1860: oPop 1
1862: oTypeSNodeType
1863: oChoice 1876
1865: oEmit 7
1867: oGetLocal 1
1869: oPushResult
1870: oCall 3295
1872: oPop 1
1874: oJumpForward 1883
1876: Choice Lookup Table
          18   1865
          17   1865
1881: oError 12
1883: oJumpForward 2012
1885: oGetAddrLocal 2
1887: oPushResult
1888: oGetLocal 1
1890: oPushResult
1891: oSetResult 6
1893: oPushResult
1894: oNodeGet
1895: oPop 2
1897: oAssign
1898: oGetLocal 2
1900: oPushResult
1901: oTypeSPush
1902: oPop 1
1904: oTypeSNodeType
1905: oChoice 1969
1907: oEmit 0
1909: oGetLocal 1
1911: oPushResult
1912: oCall 3295
1914: oPop 1
1916: oJumpForward 1995
1918: oEmit 1
1920: oGetLocal 1
1922: oPushResult
1923: oCall 3295
1925: oPop 1
1927: oJumpForward 1995
1929: oError 12
1931: oJumpForward 1995
1933: oEmit 2
1935: oGetLocal 1
1937: oPushResult
1938: oCall 3295
1940: oPop 1
1942: oInputChoice 1964
1944: oTypeSPop
1945: oGetLocal 2
1947: oPushResult
1948: oSetResult 14
1950: oPushResult
1951: oNodeGet
1952: oPop 2
1954: oPushResult
1955: oTypeSPush
1956: oPop 1
1958: oCall 2154
1960: oCall 2119
1962: oJumpForward 1967
1964: Choice Lookup Table
          17   1944
1967: oJumpForward 1995
1969: Choice Lookup Table
          21   1933
          16   1929
          20   1929
          19   1929
          18   1918
          17   1907
1982: oEmit 3
1984: oGetLocal 1
1986: oPushResult
1987: oCall 3295
1989: oPop 1
1991: oCall 2154
1993: oCall 2119
1995: oJumpForward 2012
1997: Choice Lookup Table
          11   1885
           8   1843
           7   1793
2004: oError 5
2006: oGetGlobal 3
2008: oPushResult
2009: oTypeSPush
2010: oPop 1
2012: oJumpForward 2118
2014: oInput 0
2016: oGetAddrLocal 1
2018: oPushResult
2019: oScopeFindRequire
2020: oAssign
2021: oGetAddrLocal 2
2023: oPushResult
2024: oGetLocal 1
2026: oPushResult
2027: oSetResult 6
2029: oPushResult
2030: oNodeGet
2031: oPop 2
2033: oAssign
2034: oGetLocal 1
2036: oPushResult
2037: oNodeType
2038: oPop 1
2040: oChoice 2082
2042: oEmit 3
2044: oGetLocal 1
2046: oPushResult
2047: oCall 3295
2049: oPop 1
2051: oCall 2154
2053: oGetAddrLocal 5
2055: oPushResult
2056: oGetLocal 2
2058: oPushResult
2059: oCall 3211
2061: oPop 1
2063: oAssign
2064: oGetLocal 5
2066: oPushResult
2067: oTypeSPush
2068: oPop 1
2070: oJumpForward 2097
2072: oError 12
2074: oGetGlobal 3
2076: oPushResult
2077: oTypeSPush
2078: oPop 1
2080: oJumpForward 2097
2082: Choice Lookup Table
          14   2072
          12   2072
          11   2042
2089: oError 3
2091: oGetGlobal 3
2093: oPushResult
2094: oTypeSPush
2095: oPop 1
2097: oJumpForward 2118
2099: Choice Lookup Table
          17   2014
           0   1780
           2   1763
          13   1757
           1   1742
2110: oError 5
2112: oGetGlobal 3
2114: oPushResult
2115: oTypeSPush
2116: oPop 1
2118: oReturn
2119: oLocalSpace 0
2121: oTypeSNodeType
2122: oChoice 2140
2124: oEmit 4
2126: oJumpForward 2153
2128: oEmit 5
2130: oJumpForward 2153
2132: oError 12
2134: oJumpForward 2153
2136: oEmit 6
2138: oJumpForward 2153
2140: Choice Lookup Table
          21   2136
          16   2132
          20   2132
          19   2132
          18   2128
          17   2124
2153: oReturn
2154: oLocalSpace 0
2156: oInputChoice 2170
2158: oCall 2182
2160: oJumpForward 2179
2162: oError 12
2164: oJumpForward 2179
2166: oCall 2268
2168: oJumpForward 2179
2170: Choice Lookup Table
          17   2166
          18   2162
          15   2158
2177: oJumpForward 2181
2179: oJumpBack 2156
2181: oReturn
2182: oLocalSpace 0
2184: oTypSChooseKind
2185: oChoice 2189
2187: oJumpForward 2194
2189: Choice Lookup Table
           7   2187
2192: oError 9
2194: oTypSChooseKind
2195: oChoice 2199
2197: oJumpForward 2204
2199: Choice Lookup Table
           7   2197
2202: oError 10
2204: oValuePushLowTS
2205: oTypSPopPushBase
2206: oCall 1328
2208: oCall 3083
2210: oValueIsZero
2211: oChoice 2216
2213: oValuePop
2214: oJumpForward 2229
2216: Choice Lookup Table
           1   2213
2219: oEmit 7
2221: oValueTop
2222: oPushResult
2223: oEmitInt
2224: oPop 1
2226: oEmit 17
2228: oValuePop
2229: oValuePushSizeTS
2230: oValueIsOne
2231: oChoice 2236
2233: oValuePop
2234: oJumpForward 2249
2236: Choice Lookup Table
           1   2233
2239: oEmit 7
2241: oValueTop
2242: oPushResult
2243: oEmitInt
2244: oPop 1
2246: oEmit 14
2248: oValuePop
2249: oEmit 16
2251: oInputChoice 2259
2253: oJumpForward 2267
2255: oJumpForward 2265
2257: oJumpForward 2265
2259: Choice Lookup Table
          12   2257
          16   2253
2264: oEndChoice
2265: oJumpBack 2194
2267: oReturn
2268: oLocalSpace 1
2270: oTypeSNodeType
2271: oChoice 2275
2273: oJumpForward 2280
2275: Choice Lookup Table
          21   2273
2278: oError 8
2280: oEmit 6
2282: oGetAddrLocal 1
2284: oPushResult
2285: oTypeSTop
2286: oAssign
2287: oTypeSPop
2288: oGetLocal 1
2290: oPushResult
2291: oSetResult 14
2293: oPushResult
2294: oNodeGet
2295: oPop 2
2297: oPushResult
2298: oTypeSPush
2299: oPop 1
2301: oReturn
2302: oLocalSpace 0
2304: oInputChoice 2354
2306: oCall 2951
2308: oJumpForward 2379
2310: oCall 2958
2312: oJumpForward 2379
2314: oCall 3029
2316: oJumpForward 2379
2318: oCall 3032
2320: oJumpForward 2379
2322: oCall 2525
2324: oJumpForward 2379
2326: oCall 2812
2328: oJumpForward 2379
2330: oCall 2583
2332: oJumpForward 2379
2334: oCall 2763
2336: oJumpForward 2379
2338: oCall 2899
2340: oJumpForward 2379
2342: oCall 2867
2344: oJumpForward 2379
2346: oCall 2928
2348: oJumpForward 2379
2350: oCall 2380
2352: oJumpForward 2379
2354: Choice Lookup Table
           0   2350
          32   2346
          48   2342
          49   2338
          46   2334
          41   2330
          45   2326
          38   2322
          57   2318
          56   2314
          55   2310
          54   2306
2379: oReturn
2380: oLocalSpace 2
2382: oGetAddrLocal 1
2384: oPushResult
2385: oScopeFindRequire
2386: oAssign
2387: oGetLocal 1
2389: oPushResult
2390: oNodeType
2391: oPop 1
2393: oChoice 2517
2395: oInputChoice 2418
2397: oCall 1328
2399: oTypSPop
2400: oInputChoice 2408
2402: oJumpForward 2416
2404: oJumpForward 2414
2406: oJumpForward 2414
2408: Choice Lookup Table
          12   2406
          14   2402
2413: oEndChoice
2414: oJumpBack 2397
2416: oJumpForward 2421
2418: Choice Lookup Table
          13   2397
2421: oEmit 30
2423: oGetLocal 1
2425: oPushResult
2426: oCall 3295
2428: oPop 1
2430: oJumpForward 2524
2432: oEmit 3
2434: oGetLocal 1
2436: oPushResult
2437: oCall 3295
2439: oPop 1
2441: oGetLocal 1
2443: oPushResult
2444: oSetResult 6
2446: oPushResult
2447: oNodeGet
2448: oPop 2
2450: oPushResult
2451: oTypeSPush
2452: oPop 1
2454: oCall 2154
2456: oInput 3
2458: oCall 1328
2460: oCall 3057
2462: oTypeSNodeType
2463: oChoice 2481
2465: oEmit 8
2467: oJumpForward 2514
2469: oEmit 9
2471: oJumpForward 2514
2473: oError 12
2475: oJumpForward 2514
2477: oEmit 10
2479: oJumpForward 2514
2481: Choice Lookup Table
          21   2477
          16   2473
          20   2473
          19   2473
          18   2469
          17   2465
2494: oGetAddrLocal 2
2496: oPushResult
2497: oTypeSTop
2498: oPushResult
2499: oSetResult 12
2501: oPushResult
2502: oNodeGetInt
2503: oPop 2
2505: oAssign
2506: oEmit 11
2508: oGetLocal 2
2510: oPushResult
2511: oEmitInt
2512: oPop 1
2514: oTypeSPop
2515: oJumpForward 2524
2517: Choice Lookup Table
          11   2432
           6   2395
2522: oError 0
2524: oReturn
2525: oLocalSpace 0
2527: oCall 1328
2529: oCall 3110
2531: oInput 39
2533: oEmit 34
2535: oSetResult 2
2537: oPushResult
2538: oPatchPushHere
2539: oPop 1
2541: oEmit 40
2543: oCall 2302
2545: oInputChoice 2573
2547: oEmit 32
2549: oSetResult 2
2551: oPushResult
2552: oPatchPushHere
2553: oPop 1
2555: oEmit 40
2557: oSetResult 2
2559: oPushResult
2560: oPatchSwap
2561: oPop 1
2563: oSetResult 2
2565: oPushResult
2566: oPatchPopFwd
2567: oPop 1
2569: oCall 2302
2571: oJumpForward 2576
2573: Choice Lookup Table
          40   2547
2576: oSetResult 2
2578: oPushResult
2579: oPatchPopFwd
2580: oPop 1
2582: oReturn
2583: oLocalSpace 0
2585: oInput 0
2587: oSymLookup
2588: oSymChooseKind
2589: oChoice 2596
2591: oTypSPushTyp
2592: oCall 3083
2594: oJumpForward 2601
2596: Choice Lookup Table
           6   2591
2599: oError 4
2601: oValuePushVal
2602: oEmit 3
2604: oValueTop
2605: oPushResult
2606: oEmitInt
2607: oPop 1
2609: oInput 3
2611: oCall 1328
2613: oCall 3083
2615: oEmit 8
2617: oEmit 32
2619: oSetResult 0
2621: oPushResult
2622: oPatchPushHere
2623: oPop 1
2625: oEmit 40
2627: oSetResult 0
2629: oPushResult
2630: oPatchPushHere
2631: oPop 1
2633: oSetResult 0
2635: oPushResult
2636: oPatchSwap
2637: oPop 1
2639: oInputChoice 2729
2641: oEmit 12
2643: oValueTop
2644: oPushResult
2645: oEmitInt
2646: oPop 1
2648: oSetResult 0
2650: oPushResult
2651: oPatchPopFwd
2652: oPop 1
2654: oEmit 0
2656: oValueTop
2657: oPushResult
2658: oEmitInt
2659: oPop 1
2661: oCall 1328
2663: oCall 3083
2665: oEmit 24
2667: oEmit 33
2669: oSetResult 0
2671: oPushResult
2672: oPatchPushHere
2673: oPop 1
2675: oEmit 40
2677: oSetResult 0
2679: oPushResult
2680: oPatchSwap
2681: oPop 1
2683: oJumpForward 2735
2685: oEmit 13
2687: oValueTop
2688: oPushResult
2689: oEmitInt
2690: oPop 1
2692: oSetResult 0
2694: oPushResult
2695: oPatchPopFwd
2696: oPop 1
2698: oEmit 0
2700: oValueTop
2701: oPushResult
2702: oEmitInt
2703: oPop 1
2705: oCall 1328
2707: oCall 3083
2709: oEmit 25
2711: oEmit 33
2713: oSetResult 0
2715: oPushResult
2716: oPatchPushHere
2717: oPop 1
2719: oEmit 40
2721: oSetResult 0
2723: oPushResult
2724: oPatchSwap
2725: oPop 1
2727: oJumpForward 2735
2729: Choice Lookup Table
          43   2685
          42   2641
2734: oEndChoice
2735: oSetResult 0
2737: oPushResult
2738: oCountPush
2739: oPop 1
2741: oInput 44
2743: oCall 2302
2745: oEmit 32
2747: oSetResult 0
2749: oPushResult
2750: oPatchPopBack
2751: oPop 1
2753: oValuePop
2754: oSetResult 0
2756: oPushResult
2757: oPatchPopFwd
2758: oPop 1
2760: oCall 3035
2762: oReturn
2763: oLocalSpace 0
2765: oSetResult 0
2767: oPushResult
2768: oPatchPushHere
2769: oPop 1
2771: oSetResult 0
2773: oPushResult
2774: oCountPush
2775: oPop 1
2777: oCall 2302
2779: oInputChoice 2803
2781: oCall 2302
2783: oJumpForward 2809
2785: oCall 1328
2787: oCall 3110
2789: oEmit 34
2791: oSetResult 0
2793: oPushResult
2794: oPatchPopBack
2795: oPop 1
2797: oCall 3035
2799: oJumpForward 2811
2801: oJumpForward 2809
2803: Choice Lookup Table
          47   2785
           4   2781
2808: oEndChoice
2809: oJumpBack 2779
2811: oReturn
2812: oLocalSpace 0
2814: oSetResult 0
2816: oPushResult
2817: oPatchPushHere
2818: oPop 1
2820: oSetResult 0
2822: oPushResult
2823: oCountPush
2824: oPop 1
2826: oCall 1328
2828: oCall 3110
2830: oInput 44
2832: oEmit 34
2834: oSetResult 0
2836: oPushResult
2837: oPatchPushHere
2838: oPop 1
2840: oEmit 40
2842: oSetResult 0
2844: oPushResult
2845: oPatchSwap
2846: oPop 1
2848: oCall 2302
2850: oEmit 32
2852: oSetResult 0
2854: oPushResult
2855: oPatchPopBack
2856: oPop 1
2858: oSetResult 0
2860: oPushResult
2861: oPatchPopFwd
2862: oPop 1
2864: oCall 3035
2866: oReturn
2867: oLocalSpace 0
2869: oSetResult 0
2871: oPushResult
2872: oPatchAnyEntries
2873: oPop 1
2875: oChoice 2893
2877: oEmit 32
2879: oSetResult 0
2881: oPushResult
2882: oPatchDup
2883: oPop 1
2885: oSetResult 0
2887: oPushResult
2888: oPatchPopBack
2889: oPop 1
2891: oJumpForward 2898
2893: Choice Lookup Table
           1   2877
2896: oError 14
2898: oReturn
2899: oLocalSpace 0
2901: oSetResult 0
2903: oPushResult
2904: oPatchAnyEntries
2905: oPop 1
2907: oChoice 2922
2909: oEmit 32
2911: oSetResult 1
2913: oPushResult
2914: oPatchPushHere
2915: oPop 1
2917: oEmit 40
2919: oCountInc
2920: oJumpForward 2927
2922: Choice Lookup Table
           1   2909
2925: oError 14
2927: oReturn
2928: oLocalSpace 0
2930: oCall 2302
2932: oInputChoice 2942
2934: oCall 2302
2936: oJumpForward 2948
2938: oJumpForward 2950
2940: oJumpForward 2948
2942: Choice Lookup Table
          33   2938
           4   2934
2947: oEndChoice
2948: oJumpBack 2932
2950: oReturn
2951: oLocalSpace 0
2953: oCall 2958
2955: oEmit 39
2957: oReturn
2958: oLocalSpace 0
2960: oInputChoice 3025
2962: oCall 1328
2964: oTypSChoose
2965: oChoice 2983
2967: oEmit 35
2969: oJumpForward 3006
2971: oEmit 36
2973: oJumpForward 3006
2975: oEmit 37
2977: oJumpForward 3006
2979: oError 12
2981: oJumpForward 3006
2983: Choice Lookup Table
           5   2979
           3   2979
           4   2975
           2   2971
           1   2967
2994: oTypSChooseKind
2995: oChoice 3001
2997: oEmit 38
2999: oJumpForward 3006
3001: Choice Lookup Table
           6   2997
3004: oError 13
3006: oTypSPop
3007: oInputChoice 3015
3009: oJumpForward 3023
3011: oJumpForward 3021
3013: oJumpForward 3021
3015: Choice Lookup Table
          12   3013
          14   3009
3020: oEndChoice
3021: oJumpBack 2962
3023: oJumpForward 3028
3025: Choice Lookup Table
          13   2962
3028: oReturn
3029: oLocalSpace 0
3031: oReturn
3032: oLocalSpace 0
3034: oReturn
3035: oLocalSpace 0
3037: oCountIsZero
3038: oChoice 3048
3040: oSetResult 1
3042: oPushResult
3043: oPatchPopFwd
3044: oPop 1
3046: oJumpForward 3053
3048: Choice Lookup Table
           0   3040
3051: oJumpForward 3055
3053: oJumpBack 3037
3055: oCountPop
3056: oReturn
3057: oLocalSpace 1
3059: oGetAddrLocal 1
3061: oPushResult
3062: oTypeSNodeType
3063: oAssign
3064: oTypeSPop
3065: oGetLocal 1
3067: oPushResult
3068: oTypeSNodeType
3069: oPushResult
3070: equal_node_type
3071: oPop 2
3073: oChoice 3079
3075: oError 11
3077: oJumpForward 3082
3079: Choice Lookup Table
           0   3075
3082: oReturn
3083: oLocalSpace 0
3085: oTypeSNodeType
3086: oChoice 3090
3088: oJumpForward 3095
3090: Choice Lookup Table
          17   3088
3093: oError 6
3095: oTypeSPop
3096: oReturn
3097: oLocalSpace 0
3099: oTypeSNodeType
3100: oChoice 3104
3102: oJumpForward 3109
3104: Choice Lookup Table
          17   3102
3107: oError 6
3109: oReturn
3110: oLocalSpace 0
3112: oTypeSNodeType
3113: oChoice 3117
3115: oJumpForward 3122
3117: Choice Lookup Table
          18   3115
3120: oError 7
3122: oTypeSPop
3123: oReturn
3124: oLocalSpace 0
3126: oTypeSNodeType
3127: oChoice 3131
3129: oJumpForward 3136
3131: Choice Lookup Table
          18   3129
3134: oError 7
3136: oReturn
3137: oLocalSpace 1
3139: oGetAddrLocal 1
3141: oPushResult
3142: oGetParam 2
3144: oPushResult
3145: oNodeNew
3146: oPop 1
3148: oAssign
3149: oGetLocal 1
3151: oPushResult
3152: oSetResult 12
3154: oPushResult
3155: oGetParam 1
3157: oPushResult
3158: oNodeSetInt
3159: oPop 3
3161: oGetLocal 1
3163: oPushResult
3164: oTypeAdd
3165: oPop 1
3167: oGetLocal 1
3169: oReturn
3170: oReturn
3171: oLocalSpace 1
3173: oGetAddrLocal 1
3175: oPushResult
3176: oGetParam 3
3178: oPushResult
3179: oNodeNew
3180: oPop 1
3182: oAssign
3183: oGetLocal 1
3185: oPushResult
3186: oSetResult 5
3188: oPushResult
3189: oGetParam 2
3191: oPushResult
3192: oNodeSetKind
3193: oPop 3
3195: oGetLocal 1
3197: oPushResult
3198: oSetResult 4
3200: oPushResult
3201: oGetParam 1
3203: oPushResult
3204: oNodeSetInt
3205: oPop 3
3207: oGetLocal 1
3209: oReturn
3210: oReturn
3211: oLocalSpace 1
3213: oGetAddrLocal 1
3215: oPushResult
3216: oGetParam 1
3218: oPushResult
3219: oSetResult 13
3221: oPushResult
3222: oNodeGet
3223: oPop 2
3225: oAssign
3226: oGetLocal 1
3228: oPushResult
3229: oNodeNull
3230: oPop 1
3232: oChoice 3288
3234: oGetAddrLocal 1
3236: oPushResult
3237: oSetResult 21
3239: oPushResult
3240: oNodeNew
3241: oPop 1
3243: oAssign
3244: oGetLocal 1
3246: oPushResult
3247: oSetResult 14
3249: oPushResult
3250: oGetParam 1
3252: oPushResult
3253: oNodeSet
3254: oPop 3
3256: oGetLocal 1
3258: oPushResult
3259: oSetResult 12
3261: oPushResult
3262: oSetResult 8
3264: oPushResult
3265: oNodeSetInt
3266: oPop 3
3268: oGetLocal 1
3270: oPushResult
3271: oTypeAdd
3272: oPop 1
3274: oGetParam 1
3276: oPushResult
3277: oSetResult 13
3279: oPushResult
3280: oGetLocal 1
3282: oPushResult
3283: oNodeSet
3284: oPop 3
3286: oJumpForward 3291
3288: Choice Lookup Table
           1   3234
3291: oGetLocal 1
3293: oReturn
3294: oReturn
3295: oLocalSpace 0
3297: oGetParam 1
3299: oPushResult
3300: oSetResult 8
3302: oPushResult
3303: oNodeGetInt
3304: oPop 2
3306: oPushResult
3307: oEmitInt
3308: oPop 1
3310: oReturn
3311: oLocalSpace 1
3313: oGetAddrGlobal 2
3315: oPushResult
3316: oSetResult 16
3318: oPushResult
3319: oSetResult 4
3321: oPushResult
3322: oCall 3137
3324: oPop 2
3326: oAssign
3327: oGetAddrGlobal 3
3329: oPushResult
3330: oSetResult 17
3332: oPushResult
3333: oSetResult 4
3335: oPushResult
3336: oCall 3137
3338: oPop 2
3340: oAssign
3341: oGetAddrGlobal 4
3343: oPushResult
3344: oSetResult 18
3346: oPushResult
3347: oSetResult 1
3349: oPushResult
3350: oCall 3137
3352: oPop 2
3354: oAssign
3355: oGetAddrGlobal 5
3357: oPushResult
3358: oSetResult 19
3360: oPushResult
3361: oSetResult 1
3363: oPushResult
3364: oCall 3137
3366: oPop 2
3368: oAssign
3369: oGetAddrGlobal 6
3371: oPushResult
3372: oSetResult 20
3374: oPushResult
3375: oSetResult 256
3377: oPushResult
3378: oCall 3137
3380: oPop 2
3382: oAssign
3383: oGetAddrLocal 1
3385: oPushResult
3386: oSetResult 9
3388: oPushResult
3389: oSetResult 5
3391: oPushResult
3392: oIdAdd_File
3393: oPushResult
3394: oCall 3171
3396: oPop 3
3398: oAssign
3399: oGetLocal 1
3401: oPushResult
3402: oSetResult 6
3404: oPushResult
3405: oGetGlobal 2
3407: oPushResult
3408: oNodeSet
3409: oPop 3
3411: oGetLocal 1
3413: oPushResult
3414: oScopeDeclare
3415: oPop 1
3417: oGetAddrLocal 1
3419: oPushResult
3420: oSetResult 9
3422: oPushResult
3423: oSetResult 5
3425: oPushResult
3426: oIdAdd_Integer
3427: oPushResult
3428: oCall 3171
3430: oPop 3
3432: oAssign
3433: oGetLocal 1
3435: oPushResult
3436: oSetResult 6
3438: oPushResult
3439: oGetGlobal 3
3441: oPushResult
3442: oNodeSet
3443: oPop 3
3445: oGetLocal 1
3447: oPushResult
3448: oScopeDeclare
3449: oPop 1
3451: oGetAddrLocal 1
3453: oPushResult
3454: oSetResult 9
3456: oPushResult
3457: oSetResult 5
3459: oPushResult
3460: oIdAdd_Boolean
3461: oPushResult
3462: oCall 3171
3464: oPop 3
3466: oAssign
3467: oGetLocal 1
3469: oPushResult
3470: oSetResult 6
3472: oPushResult
3473: oGetGlobal 4
3475: oPushResult
3476: oNodeSet
3477: oPop 3
3479: oGetLocal 1
3481: oPushResult
3482: oScopeDeclare
3483: oPop 1
3485: oGetAddrLocal 1
3487: oPushResult
3488: oSetResult 9
3490: oPushResult
3491: oSetResult 5
3493: oPushResult
3494: oIdAdd_Char
3495: oPushResult
3496: oCall 3171
3498: oPop 3
3500: oAssign
3501: oGetLocal 1
3503: oPushResult
3504: oSetResult 6
3506: oPushResult
3507: oGetGlobal 5
3509: oPushResult
3510: oNodeSet
3511: oPop 3
3513: oGetLocal 1
3515: oPushResult
3516: oScopeDeclare
3517: oPop 1
3519: oGetAddrLocal 1
3521: oPushResult
3522: oSetResult 9
3524: oPushResult
3525: oSetResult 5
3527: oPushResult
3528: oIdAdd_String
3529: oPushResult
3530: oCall 3171
3532: oPop 3
3534: oAssign
3535: oGetLocal 1
3537: oPushResult
3538: oSetResult 6
3540: oPushResult
3541: oGetGlobal 6
3543: oPushResult
3544: oNodeSet
3545: oPop 3
3547: oGetLocal 1
3549: oPushResult
3550: oScopeDeclare
3551: oPop 1
3553: oGetAddrLocal 1
3555: oPushResult
3556: oSetResult 8
3558: oPushResult
3559: oSetResult 4
3561: oPushResult
3562: oIdAdd_True
3563: oPushResult
3564: oCall 3171
3566: oPop 3
3568: oAssign
3569: oGetLocal 1
3571: oPushResult
3572: oSetResult 6
3574: oPushResult
3575: oGetGlobal 4
3577: oPushResult
3578: oNodeSet
3579: oPop 3
3581: oGetLocal 1
3583: oPushResult
3584: oSetResult 8
3586: oPushResult
3587: oSetResult 1
3589: oPushResult
3590: oNodeSetInt
3591: oPop 3
3593: oGetLocal 1
3595: oPushResult
3596: oScopeDeclare
3597: oPop 1
3599: oGetAddrLocal 1
3601: oPushResult
3602: oSetResult 8
3604: oPushResult
3605: oSetResult 4
3607: oPushResult
3608: oIdAdd_False
3609: oPushResult
3610: oCall 3171
3612: oPop 3
3614: oAssign
3615: oGetLocal 1
3617: oPushResult
3618: oSetResult 6
3620: oPushResult
3621: oGetGlobal 4
3623: oPushResult
3624: oNodeSet
3625: oPop 3
3627: oGetLocal 1
3629: oPushResult
3630: oSetResult 8
3632: oPushResult
3633: oSetResult 0
3635: oPushResult
3636: oNodeSetInt
3637: oPop 3
3639: oGetLocal 1
3641: oPushResult
3642: oScopeDeclare
3643: oPop 1
3645: oReturn
