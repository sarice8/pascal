   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1480:    ;
      
      
1480: ProcHeaderDecl >> Node:
1482:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1484:    boolean redeclaring = false
1490:    Node decl = oScopeFindInCurrentScope
      
1495:    [ oNodeNull( decl )
1502:       | true :
               % first declaration
1503:          decl = @newIdent( nProc, LAST_ID )
1516:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1527:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1529:          redeclaring = true
1535:          [ oNodeGetBoolean( decl, qBodyDefined )
1545:             | true : #eAlreadyDefined
1548:             | * :
1553:          ]
1553:          [ oNodeGetBoolean( decl, qExternal )
1563:             | true : #eAlreadyDefined
1566:             | * :
1571:          ]
1571:          [ oNodeType( decl )
1578:             | nProc :
1579:             | * : #eAlreadyDefined   % wrong kind
1586:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1586:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1605:          oNodeSet( decl, qParams, Null )
1617:    ]
      
1625:    int level = @ScopeLevel
1631:    boolean nested = greater( level, 0 )
1644:    inc( level )
1650:    oScopeBegin( level, allocUp )
1659:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1664:    [ nested
1667:       | true :
1668:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1683:       | * :
1688:    ]
      
1688:    @FormalArgDecl
1690:    oNodeSet( decl, qParams, paramScope )
1702:    oScopeEnd
1703:    ';'
      
1705:    [ redeclaring
1708:       | false : oScopeDeclare( decl )
1715:       | true :  % TO DO: check that qParams is consistent with qOldParams
1717:    ]
      
1725:    @MethodModifiers( decl )
1732:    >> decl;
      
      
1736: ProcDecl:
1738:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1744:    [
1744:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1746:       | pExternal : @ExternalDecl( decl )
      
1755:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1762:          Node paramScope = oNodeGet( decl, qParams )
1775:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1781:          int level = oNodeGetInt( paramScope, qLevel )
1794:          oScopeBegin( level, allocDown )
1803:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1814:          Label label = oNodeGetLabel( decl, qValue )
1827:          @Block( nLocalVar, label )
1837:          oNodeSetBoolean( decl, qBodyDefined, true )
1849:          oScopeEnd
      
1850:          oScopeEnd  % paramScope
1851:    ]
1851:    ';';
      
      
      
1854: FuncHeaderDecl >> Node:
1856:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1858:    boolean redeclaring = false
1864:    Node decl = oScopeFindInCurrentScope
      
1869:    [ oNodeNull( decl )
1876:       | true :
               % first declaration
1877:          decl = @newIdent( nFunc, LAST_ID )
1890:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1901:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1903:          redeclaring = true
1909:          [ oNodeGetBoolean( decl, qBodyDefined )
1919:             | true : #eAlreadyDefined
1922:             | * :
1927:          ]
1927:          [ oNodeType( decl )
1934:             | nFunc :
1935:             | * : #eAlreadyDefined   % wrong kind
1942:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1942:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1961:          oNodeSet( decl, qParams, Null )
1973:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1992:          oNodeSet( decl, qType, Null )
2004:    ]
      
2012:    int level = @ScopeLevel
2018:    boolean nested = greater( level, 0 )
2031:    inc( level )
2037:    oScopeBegin( level, allocUp )
2046:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2051:    [ nested
2054:       | true :
2055:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2070:       | * :
2075:    ]
      
2075:    @FormalArgDecl
2077:    oNodeSet( decl, qParams, paramScope )
      
2089:    ':'
      
2091:    Node theType
2091:    @TypeRef( theType )
2098:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2110:    Node ptrType = @PointerTypeTo( theType )
2121:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2137:    oScopeEnd
2138:    ';'
      
2140:    [ redeclaring
2143:       | false : oScopeDeclare( decl )
2150:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2152:    ]
      
2160:    @MethodModifiers( decl )
      
2167:    >> decl;
      
      
2171: FuncDecl:
2173:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2179:    [
2179:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2181:       | pExternal : @ExternalDecl( decl )
      
2190:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2197:          Node paramScope = oNodeGet( decl, qParams )
2210:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2216:          int level = oNodeGetInt( paramScope, qLevel )
2229:          oScopeBegin( level, allocDown )
2238:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2249:          Label label = oNodeGetLabel( decl, qValue )
2262:          @Block( nLocalVar, label )
2272:          oNodeSetBoolean( decl, qBodyDefined, true )
2284:          oScopeEnd
      
2285:          oScopeEnd  % paramScope
2286:    ]
2286:    ';';
      
      
2289: FormalArgDecl:
2291:    [
2291:       | '(' :
2293:          {
2293:             NodeVec decls = oNodeVecNew
2298:             Node decl
2298:             boolean isInOut = false
      
2304:             [
2304:                | pVar : isInOut = true
2312:                | * :
2317:             ]
      
2317:             {  pIdent
      
2319:                decl = @newIdent( nParam, LAST_ID )
2332:                oNodeSetBoolean( decl, qInOut, isInOut )
2344:                oNodeVecAppend( decls, decl )
      
2353:                [
2353:                   | ':' : >
2357:                   | ',' :
2359:                ]
2367:             }
      
2369:             Node theType
2369:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2376:             Node allocType
2376:             [ isInOut
2379:                | true :   allocType = @PointerTypeTo( theType )
2391:                | * :      allocType = theType
2402:             ]
      
2402:             int i = 0
2408:             {[ equal( i, oNodeVecSize( decls ) )
2422:                | false :
2423:                   decl = oNodeVecElement( decls, i )
      
2436:                   oNodeSet( decl, qType, theType )
2448:                   oScopeDeclare( decl )
2454:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2470:                   inc( i )
2476:                | * :
2481:                   >
2483:             ]}
      
2485:             oNodeVecDelete( decls )
      
2491:             [
2491:                | ')' : >
2495:                | ';' :
2497:             ]
2505:          }
2507:       | * :
2512:    ];
      
      
2513: ConstDecl:
2515:    {[
2515:       | pIdent :
2517:          [
2517:             | ':' :
2519:                @TypedConstDecl
2521:             | * :
2526:                @TrueConstDecl
2528:          ]
2528:       | * :
2533:          >
2535:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2538: TrueConstDecl:
2540:    int id = LAST_ID
2545:    '='
      
2547:    @ConstExpr
      
2549:    Node decl
2549:    [ oTypeSNodeType
2551:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2552:         nPointerType, nUniversalPointerType :
2552:          decl = @newIdent( nConst, id )
2566:          oNodeSetInt( decl, qValue, oValueTop )
2577:       | nStrLitType :
2579:          decl = @newIdent( nConstStr, id )
2593:          oNodeSetString( decl, qValueStr, oValueTopString )
2604:       | * :  #eNotAllowed
2625:    ]
2625:    oValuePop
2626:    oNodeSet( decl, qType, oTypeSTop )
2637:    oTypeSPop
2638:    oScopeDeclare( decl )
2644:    ';'
2647:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2647: TypedConstDecl:
2649:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2662:    Node theType
2662:    @TypeRef( theType )
2669:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2681:    [ oNodeType( theType )
2688:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2689:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2689:          '='
      
2691:          oTypeSPush( theType )
2697:          @ConstExpr
2699:          @ConstCoerceType
      
2701:          oNodeSetInt( decl, qValue, oValueTop )
2712:          oValuePop
2713:          oTypeSPop
2714:          oScopeDeclare( decl )
2720:          ';'
      
2722:       | nShortStringType, nFileType :
2724:          #eNotImplemented
      
2726:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2728:          oScopeEnter( globalScope )
2734:          int addr = oScopeAllocType( theType )
2744:          oScopeEnd
2745:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2756:          oNodeSetInt( decl, qValue, addr )
2768:          '='
2770:          @TypedConstInit( theType, addr )
2780:          oCodePop
2781:          oScopeDeclare( decl )
2787:          ';'
2789:    ]
2816:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2816: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2818:    [ oNodeType( theType )
2825:       | nArrayType :
2826:          Node baseType = oNodeGet( theType, qBaseType )
2839:          Node indexType = oNodeGet( theType, qIndexType )
2852:          int low = @OrdinalLow( indexType )
2863:          int high = @OrdinalHigh( indexType )
2874:          int elementSize = oNodeGetInt( baseType, qSize )
      
2887:          '('
               % Loop over elements
2889:          int i = low
2895:          {
2895:             @TypedConstInit( baseType, addr )
2905:             [ equal( i, high )
2915:                | true : >
2918:                | false :
2920:             ]
2928:             ','
2930:             addr = add( addr, elementSize )
2943:             inc( i )
2949:          }
2951:          ')'
      
2953:       | nRecordType :
2955:          '('
2957:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
2970:          {
2970:             [
2970:                | pIdent :
2972:                | * :  >
2979:             ]
2979:             Node field = oScopeFindRequireInScope( fieldScope )
2989:             ':'
2991:             Node fieldType = oNodeGet( field, qType )
3004:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3024:             @TypedConstInit( fieldType, fieldAddr )
3034:             [
3034:                | ';' :
3036:                | * :  >
3043:             ]
3043:          }
3045:          ')'
      
3047:       | nBooleanType, nByteType, nCharType:
3049:          .tPushAddrGlobal  oEmitInt( addr )
3057:          oTypeSPush( theType )
3063:          @ConstExpr
3065:          @ConstCoerceType
3067:          .tPushConstI  oEmitInt( oValueTop )
3074:          oValuePop
3075:          oTypeSPop
3076:          .tAssignB
      
3078:       | nIntegerType, nEnumType:
3080:          .tPushAddrGlobal  oEmitInt( addr )
3088:          oTypeSPush( theType )
3094:          @ConstExpr
3096:          @ConstCoerceType
3098:          .tPushConstI  oEmitInt( oValueTop )
3105:          oValuePop
3106:          oTypeSPop
3107:          .tAssignI
      
3109:       | nPointerType, nUniversalPointerType :
3111:          .tPushAddrGlobal  oEmitInt( addr )
3119:          oTypeSPush( theType )
3125:          @ConstExpr
3127:          @ConstCoerceType
3129:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3136:          oValuePop
3137:          oTypeSPop
3138:          .tAssignP
      
3140:       | nShortStringType, nFileType :
3142:          #eNotImplemented
3144:    ]
3171:    ;
      
      
3171: TypeDecl:
3173:    {[
3173:       | pIdent :
3175:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3188:          '='
3190:          Node theType
3190:          @TypeRef( theType )
3197:          oNodeSet( decl, qType, theType )
3209:          oScopeDeclare( decl )
3215:          ';'
3217:       | * :
3222:          >
3224:    ]};
      
3227: VarDecl( node_type varNodeType ):
3229:    {[
3229:       | pIdent :
3231:          NodeVec decls = oNodeVecNew
3236:          Node decl
3236:          {
3236:             decl = @newIdent( varNodeType, LAST_ID )
3249:             oNodeVecAppend( decls, decl )
3258:             [
3258:                | ',' :
3260:                   pIdent
3262:                | * :
3267:                   >
3269:             ]
3269:          }
3271:          ':'
3273:          Node theType
3273:          @TypeRef( theType )
      
3280:          int i = 0
3286:          {[ equal( i, oNodeVecSize( decls ) )
3300:             | false :
3301:                decl = oNodeVecElement( decls, i )
3314:                oNodeSet( decl, qType, theType )
3326:                oScopeDeclareAlloc( decl )
3332:                inc( i )
3338:             | * :
3343:               >
3345:          ]}
      
               % optional initialization
3347:          [
3347:             | '=' :
3349:                [ oNodeVecSize( decls )
3356:                   | 1 :
3357:                   | * :  #eOnlyOneVarCanBeInitialized
3364:                ]
      
                     % we need an initCode stream for this scope
3364:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3374:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3380:                boolean changedScope = false
3386:                [ equal_zero( @ScopeLevel )
3393:                   | true : oScopeEnter( initScope )
3400:                            changedScope = true
3406:                   | * :
3411:                ]
                     % generate assignment in initCode stream
3411:                @LValueVar( decl, true )
3421:                @Expr
3423:                @CoerceType
3425:                @Assign
3427:                [ changedScope
3430:                   | true : oScopeEnd
3432:                   | * :
3437:                ]
3437:                oCodePop
                   
3438:             | * :
3443:          ]
      
3443:          oNodeVecDelete( decls )
3449:          ';'
3451:       | * :
3456:          >
3458:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3461: LabelDecl:
3463:    {
3463:       Node decl
3463:       [
3463:          | pIdent :
3465:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3467:             oChangeIntLitToLabelIdent
3468:       ]
3476:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3489:       Label label = oLabelNew
3494:       oNodeSetLabel( decl, qValue, label )
3506:       oScopeDeclare( decl )
3512:       [
3512:          | ',' :
3514:          | * :
3519:             >
3521:       ]
3521:    }
3523:    ';'
3526:    ;
3526: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3526: ConstExpr:
3528:    @ConstBoolExpr
3530:    {[
3530:       | '=' :
3532:          @ConstBoolTerm
3534:          @ConstMatchTypes
3536:          [ oTypeSNodeType
3538:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3547:             | * :             oValueEqual
3553:          ]
3553:          oTypeSPop  oTypeSPush( BooleanType )
3560:       | '<>' :
3562:          @ConstBoolExpr
3564:          @ConstMatchTypes
3566:          [ oTypeSNodeType
3568:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3577:             | * :             oValueNotEqual
3583:          ]
3583:          oTypeSPop  oTypeSPush( BooleanType )
3590:       | '<' :
3592:          @ConstBoolExpr
3594:          @ConstMatchTypes
3596:          [ oTypeSNodeType
3598:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3607:             | * :             oValueLess
3613:          ]
3613:          oTypeSPop  oTypeSPush( BooleanType )
3620:       | '>' :
3622:          @ConstBoolExpr
3624:          @ConstMatchTypes
3626:          [ oTypeSNodeType
3628:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3637:             | * :             oValueGreater
3643:          ]
3643:          oTypeSPop  oTypeSPush( BooleanType )
3650:       | '<=' :
3652:          @ConstBoolExpr
3654:          @ConstMatchTypes
3656:          [ oTypeSNodeType
3658:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3667:             | * :             oValueLessEqual
3673:          ]
3673:          oTypeSPop  oTypeSPush( BooleanType )
3680:       | '>=' :
3682:          @ConstBoolExpr
3684:          @ConstMatchTypes
3686:          [ oTypeSNodeType
3688:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3697:             | * :             oValueGreaterEqual
3703:          ]
3703:          oTypeSPop  oTypeSPush( BooleanType )
3710:       | * :  >
3727:    ]};
      
      
3730: ConstBoolExpr:
3732:    @ConstBoolTerm
3734:    {[
3734:       | pOr :
3736:          @ConstRequireBool
3738:          @ConstBoolTerm
3740:          @ConstRequireBoolPop
3742:          oValueOr
3743:       | * :  >
3750:    ]};
      
      
3753: ConstBoolTerm:
3755:    @ConstBoolFactor
3757:    {[
3757:       | pAnd :
3759:          @ConstRequireBool
3761:          @ConstBoolFactor
3763:          @ConstRequireBoolPop
3765:          oValueAnd
3766:       | * :  >
3773:    ]};
      
      
3776: ConstBoolFactor:
3778:    [
3778:       | pNot :
3780:          @ConstBoolFactor
3782:          @ConstRequireBool
3784:          oValueNot
3785:       | * :
3790:          @ConstArithExpr
3792:    ];
      
      
3793: ConstArithExpr:
3795:    @ConstTerm
3797:    {[
3797:       | '+' :
3799:          @ConstTerm
3801:          @ConstMatchTypes
3803:          [ oTypeSNodeType
3805:             | nStrLitType :   oValueStringConcat
3807:             | * :             oValueAdd
3813:          ]
3813:       | '-' :
3815:          @ConstTerm
3817:          @ConstMatchTypes
3819:          [ oTypeSNodeType
3821:             | nStrLitType :   #eNotAllowed
3824:             | * :             oValueSub
3830:          ]
3830:       | * :  >
3839:    ]};
      
      
3842: ConstTerm:
3844:    @ConstFactor
3846:    {[
3846:       | pTimes :
3848:          @ConstFactor
3850:          @ConstMatchTypes
3852:          [ oTypeSNodeType
3854:             | nStrLitType :   #eNotAllowed
3857:             | * :             oValueMult
3863:          ]
3863:       | pDivide :
3865:          @ConstFactor
3867:          @ConstMatchTypes
3869:          [ oTypeSNodeType
3871:             | nStrLitType :   #eNotAllowed
3874:             | * :             oValueDiv
3880:          ]
3880:       | * :  >
3889:    ]};
      
      
3892: ConstFactor:
3894:    [
3894:       | pPlus :
3896:          @ConstPrimary
3898:       | pMinus :
3900:          @ConstPrimary
3902:          oValueNegate
3903:       | * :
3910:          @ConstPrimary
3912:    ];
      
      
3913: ConstPrimary:
3915:    [
3915:       | pIntLit :
3917:          oValuePush( TOKEN_VALUE )
3922:          oTypeSPush( IntegerType )
3928:       | pCharLit :
3930:          oValuePush( TOKEN_VALUE )
3935:          oTypeSPush( CharType )
3941:       | pStrLit :
3943:          oValuePushString( CURRENT_STRLIT )
3948:          oTypeSPush( StrLitType )
3954:       | '(' :
3956:          @ConstExpr
3958:          ')'
3960:       | pIdent :
3962:          Node decl = oScopeFindRequire
3967:          @ResolveUnitRef( decl )
3974:          [ oNodeType( decl )
3981:             | nBuiltInFunc :
3982:                @ConstBuiltInFunc( decl )
3989:             | nConst :
3991:                oValuePush( oNodeGetInt( decl, qValue ) )
4004:                oTypeSPush( oNodeGet( decl, qType ) )
4017:             | nConstStr :
4019:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4032:                oTypeSPush( oNodeGet( decl, qType ) )
4045:             | nEnumValue :
4047:                oValuePush( oNodeGetInt( decl, qValue ) )
4060:                oTypeSPush( oNodeGet( decl, qType ) )
4073:             | * :
4084:                #eNotConst
4086:                oValuePush( 0 )
4092:                oTypeSPush( IntegerType )
4098:          ]
4098:       | '@' :
4100:          #eNotImplemented
4102:          oValuePush( 0 )
4108:          oTypeSPush( UniversalPointerType )
4114:       | * :
4129:          #eNotConst
4131:          oValuePush( 0 )
4137:          oTypeSPush( IntegerType )
4143:    ];
      
4144: ConstRequireBoolPop:
4146:    [ oTypeSNodeType
4148:       | nBooleanType :
4149:       | * :          #eNotBoolean
4156:    ]
4156:    oTypeSPop;
      
      
4158: ConstRequireBool:
4160:    [ oTypeSNodeType
4162:       | nBooleanType :
4163:       | * :          #eNotBoolean
4170:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4171: ConstMatchTypes:
4173:    node_type nt = oTypeSNodeType
4178:    oTypeSPop
4179:    [ equal_node_type( nt, oTypeSNodeType )
4188:       | false :
               % Some implicit conversion is allowed even here
4189:          [ oTypeSNodeType
4191:             | nPointerType :
4192:                [ nt
4195:                   | nUniversalPointerType :  >>
4197:                   | * :
4202:                ]
4202:             | nUniversalPointerType :
4204:                [ nt
4207:                   | nPointerType :  >>
4209:                   | * :
4214:                ]
4214:             | nStrLitType :
4216:                [ nt
4219:                   | nCharType :
4220:                      oValueCharToString
4221:                      >>
4222:                   | * :
4227:                ]
4227:             | nCharType :
4229:                [ nt
4232:                   | nStrLitType :
4233:                      oValueSwap
4234:                      oValueCharToString
4235:                      oValueSwap
4236:                      oTypeSPop
4237:                      oTypeSPush( StrLitType )
4243:                      >>
4244:                   | * :
4249:                ]
4249:             | * :
4260:          ]
4260:          #eTypeMismatch
4262:       | * :
4267:    ];
      
      
      % Given two constant values on the value stack, and two types on the type stack.
      % Perform any necessary implicit conversions so the second value is the type of the
      % value under it.  Pop the top type, leaving only the desired type.
      %
4268: ConstCoerceType:
4270:    node_type nt = oTypeSNodeType
4275:    oTypeSPop
4276:    [ equal_node_type( nt, oTypeSNodeType )
4285:       | false :
               % Some implicit conversion is allowed even here
4286:          [ oTypeSNodeType
4288:             | nPointerType :
4289:                [ nt
4292:                   | nUniversalPointerType :  >>
4294:                   | * :
4299:                ]
4299:             | nUniversalPointerType :
4301:                [ nt
4304:                   | nPointerType :  >>
4306:                   | * :
4311:                ]
4311:             | nStrLitType :
4313:                [ nt
4316:                   | nCharType :
4317:                      oValueCharToString
4318:                      >>
4319:                   | * :
4324:                ]
4324:             | * :
4333:          ]
4333:          #eTypeMismatch
4335:       | * :
4340:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4341: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4343:    [ oNodeEqual( method, BuiltIn_Ord )
4353:       | true :
4354:          '('
4356:          @ConstExpr
4358:          ')'
4360:          [ oTypeSNodeType
4362:             | nIntegerType, nEnumType :
4363:             | nBooleanType, nByteType, nCharType :
4365:             | * :  #eTypeMismatch
4380:          ]
4380:          oTypeSPop
4381:          oTypeSPush( IntegerType )
4387:          ')'
4389:          >>
4390:       | * :
4395:    ]
      
         % Chr(x)
4395:    [ oNodeEqual( method, BuiltIn_Chr )
4405:       | true :
4406:          '('
4408:          @ConstExpr
4410:          ')'
4412:          [ oTypeSNodeType
4414:             | nIntegerType :
4415:             | nByteType :
4417:             | * :  #eTypeMismatch
4426:          ]
4426:          oTypeSPop
4427:          oTypeSPush( CharType )
4433:          ')'
4435:          >>
4436:       | * :
4441:    ]
      
         % Pred(x)
4441:    [ oNodeEqual( method, BuiltIn_Pred )
4451:       | true :
4452:          '('
4454:          @ConstExpr
4456:          [ oTypeSNodeType
4458:             | nEnumType :
4459:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4468:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4471:                   | * :
4476:                ]
4476:             | * :  #eTypeMismatch
4483:          ]
4483:          oValuePush( 1 )  oValueSub
4490:          ')'
4492:          >>
4493:       | * :
4498:    ]
      
         % Succ(x)
4498:    [ oNodeEqual( method, BuiltIn_Succ )
4508:       | true :
4509:          '('
4511:          @ConstExpr
4513:          [ oTypeSNodeType
4515:             | nEnumType :
4516:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4525:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4528:                   | * :
4533:                ]
4533:             | * :  #eTypeMismatch
4540:          ]
4540:          oValuePush( 1 )  oValueAdd
4547:          ')'
4549:          >>
4550:       | * :
4555:    ]
      
4555:    #eNotImplemented
4558:    ;
      
      
4558: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4558: Expr:
4560:    Label falseLabel = labelNull
      
4566:    @ExprAllowFlow( falseLabel )
4573:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4581: BooleanExprControlFlow( out Label falseLabel ):
4583:    @ExprAllowFlow( falseLabel )
4590:    [ oTypeSNodeType
4592:       | nBooleanFlowType :
4593:       | nBooleanType :
               % convert value to control flow
4595:          falseLabel = oLabelNew
4600:          .tJumpFalse  oEmitLabel( falseLabel )
4608:       | * :
4615:          #eNotBoolean
4617:    ]
4617:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4619: FlowToVal( inout Label falseLabel ):
4621:    [ oTypeSNodeType
4623:       | nBooleanFlowType :
4624:          Label doneLabel = oLabelNew
4629:          .tPushConstI  oEmitInt( 1 )
4637:          .tJump  oEmitLabel( doneLabel )
4645:          .tLabel  oEmitLabel( falseLabel )
4653:          .tPushConstI  oEmitInt( 0 )
4661:          .tLabel  oEmitLabel( doneLabel )
4669:          oTypeSPop
4670:          oTypeSPush( BooleanType )
4676:          falseLabel = labelNull
4682:       | * :
4687:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4688: ValToFlow( out Label falseLabel ):
4690:    [ oTypeSNodeType
4692:       | nBooleanType :
4693:          falseLabel = oLabelNew
4698:          .tJumpFalse  oEmitLabel( falseLabel )
4706:          oTypeSPop
4707:          oTypeSPush( BooleanFlowType )
4713:       | * :
4718:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
4719: ExprAllowFlow( out Label falseLabel ):
4721:    @BoolExprAllowFlow( falseLabel )
4728:    {[
4728:       | '=' :
4730:          @FlowToVal( falseLabel )
4737:          @PromoteToIntOptional
4739:          @BoolExprAllowFlow( falseLabel )
4746:          @FlowToVal( falseLabel )
4753:          @PromoteToIntOptional
4755:          @MatchTypes
4757:          [ oTypeSNodeType
4759:             | nBooleanType, nCharType :     .tEqualB
4762:             | nIntegerType, nEnumType :     .tEqualI
4766:             | nPointerType, nUniversalPointerType :    .tEqualP
4770:             | nShortStringType, nStrLitType :
4772:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
4784:             | * :                           #eNotAllowed
4805:          ]
4805:          oTypeSPop
4806:          oTypeSPush( BooleanType )
      
4812:       | '<>' :
4814:          @FlowToVal( falseLabel )
4821:          @PromoteToIntOptional
4823:          @BoolExprAllowFlow( falseLabel )
4830:          @FlowToVal( falseLabel )
4837:          @PromoteToIntOptional
4839:          @MatchTypes
4841:          [ oTypeSNodeType
4843:             | nBooleanType, nCharType :     .tNotEqualB
4846:             | nIntegerType, nEnumType :     .tNotEqualI
4850:             | nPointerType, nUniversalPointerType :    .tNotEqualP
4854:             | nShortStringType, nStrLitType :
4856:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
4868:             | * :                           #eNotAllowed
4889:          ]
4889:          oTypeSPop
4890:          oTypeSPush( BooleanType )
      
4896:       | '<' :
4898:          @FlowToVal( falseLabel )
4905:          @PromoteToIntOptional
4907:          @BoolExprAllowFlow( falseLabel )
4914:          @FlowToVal( falseLabel )
4921:          @PromoteToIntOptional
4923:          @MatchTypes
4925:          [ oTypeSNodeType
4927:             | nBooleanType, nCharType :     .tLessB
4930:             | nIntegerType, nEnumType :     .tLessI
4934:             | nPointerType, nUniversalPointerType :   .tLessP
4938:             | nShortStringType, nStrLitType :
4940:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
4952:             | * :                           #eNotAllowed
4973:          ]
4973:          oTypeSPop
4974:          oTypeSPush( BooleanType )
      
4980:       | '>' :
4982:          @FlowToVal( falseLabel )
4989:          @PromoteToIntOptional
4991:          @BoolExprAllowFlow( falseLabel )
4998:          @FlowToVal( falseLabel )
5005:          @PromoteToIntOptional
5007:          @MatchTypes
5009:          [ oTypeSNodeType
5011:             | nBooleanType, nCharType :     .tGreaterB
5014:             | nIntegerType, nEnumType :     .tGreaterI
5018:             | nPointerType, nUniversalPointerType :   .tGreaterP
5022:             | nShortStringType, nStrLitType :
5024:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5036:             | * :                           #eNotAllowed
5057:          ]
5057:          oTypeSPop
5058:          oTypeSPush( BooleanType )
      
5064:       | '<=' :
5066:          @FlowToVal( falseLabel )
5073:          @PromoteToIntOptional
5075:          @BoolExprAllowFlow( falseLabel )
5082:          @FlowToVal( falseLabel )
5089:          @PromoteToIntOptional
5091:          @MatchTypes
5093:          [ oTypeSNodeType
5095:             | nBooleanType, nCharType :     .tLessEqualB
5098:             | nIntegerType, nEnumType :     .tLessEqualI
5102:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5106:             | nShortStringType, nStrLitType :
5108:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5120:             | * :                           #eNotAllowed
5141:          ]
5141:          oTypeSPop
5142:          oTypeSPush( BooleanType )
      
5148:       | '>=' :
5150:          @FlowToVal( falseLabel )
5157:          @PromoteToIntOptional
5159:          @BoolExprAllowFlow( falseLabel )
5166:          @FlowToVal( falseLabel )
5173:          @PromoteToIntOptional
5175:          @MatchTypes
5177:          [ oTypeSNodeType
5179:             | nBooleanType, nCharType :     .tGreaterEqualB
5182:             | nIntegerType, nEnumType :     .tGreaterEqualI
5186:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5190:             | nShortStringType, nStrLitType :
5192:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5204:             | * :                           #eNotAllowed
5225:          ]
5225:          oTypeSPop
5226:          oTypeSPush( BooleanType )
      
5232:       | * :
5247:          >
5249:    ]};
      
      
5252: BoolExprAllowFlow( out Label falseLabel ):
5254:    Label trueLabel = labelNull
      
5260:    @BoolTermAllowFlow( falseLabel )
5267:    {[
5267:       | pOr :
5269:          [ oTypeSNodeType
5271:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5272:                [ equal_label( trueLabel, labelNull )
5282:                   | true :  trueLabel = oLabelNew
5288:                   | * :
5293:                ]
5293:                .tJump  oEmitLabel( trueLabel )
5301:             | nBooleanType :
5303:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5310:                [ equal_label( trueLabel, labelNull )
5320:                   | true :  trueLabel = oLabelNew
5326:                   | * :
5331:                ]
5331:                .tJump  oEmitLabel( trueLabel )
5339:             | * : #eNotBoolean
5348:          ]
5348:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5349:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5357:          falseLabel = labelNull
5363:          @BoolTermAllowFlow( falseLabel )
      
5370:          [ oTypeSNodeType
5372:             | nBooleanFlowType :
5373:             | nBooleanType :
5375:                @ValToFlow( falseLabel )
5382:             | * : #eNotBoolean
5391:          ]
      
5391:          oTypeSPop
5392:          oTypeSPush( BooleanFlowType )
      
5398:       | * :
5403:          >
5405:    ]}
      
         % any short-circuit trues jump here to the end
5407:    [ equal_label( trueLabel, labelNull )
5417:       | false :
5418:          .tLabel  oEmitLabel( trueLabel )
5426:       | * :
5431:    ]
5432:    ;
      
      
5432: BoolTermAllowFlow( out Label falseLabel ):
5434:    Label overallFalseLabel = labelNull
      
5440:    @BoolFactorAllowFlow( falseLabel )
5447:    {[
5447:       | pAnd :
5449:          [ oTypeSNodeType
5451:             | nBooleanFlowType :
5452:             | nBooleanType :
5454:                @ValToFlow( falseLabel )
5461:             | * :
5468:                #eNotBoolean
5470:          ]
5470:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5471:          [ equal_label( overallFalseLabel, labelNull )
5481:             | true :
5482:                overallFalseLabel = oLabelNew
5487:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5501:                falseLabel = overallFalseLabel
5507:             | * :
5512:          ]
      
5512:          Label factorFalseLabel = labelNull
5518:          @BoolFactorAllowFlow( factorFalseLabel )
      
5525:          [ oTypeSNodeType
5527:             | nBooleanFlowType :
5528:             | nBooleanType :
5530:                @ValToFlow( factorFalseLabel )
5537:             | * : #eNotBoolean
5546:          ]
5546:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5560:       | * :
5565:          >
5567:    ]};
      
      
5570: BoolFactorAllowFlow( out Label falseLabel ):
5572:    [
5572:       | pNot :
5574:          Label factorFalseLabel = labelNull
      
5580:          @BoolFactorAllowFlow( factorFalseLabel )
5587:          [ oTypeSNodeType
5589:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
5590:                falseLabel = oLabelNew
5595:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5603:                .tLabel  oEmitLabel( factorFalseLabel )
      
5611:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5613:                .tNot
      
5615:             | * : #eNotBoolean
5624:          ]
      
5624:       | * :
5629:          @ArithExprAllowFlow( falseLabel )
5636:    ];
      
      
5637: ArithExprAllowFlow( out Label falseLabel ):
5639:    boolean first = true
5645:    int tempStrOffset
      
5645:    @TermAllowFlow( falseLabel )
5652:    {[
5652:       | '+' :
5654:          [ oTypeSNodeType
5656:             | nIntegerType, nByteType :
5657:                @PromoteToIntPop
5659:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
5666:                [ oTypeSNodeType
5668:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
5669:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
5671:                      @PointerAddition
5673:                   | * :
5680:                      @PromoteToInt
5682:                      .tAddI
5684:                ]
      
5684:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
5686:                [ first
5689:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
5690:                             tempStrOffset = @MoveIntoTempShortString
5696:                             first = false
5702:                   | * :
5707:                ]
5707:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5714:                [ oTypeSNodeType
5716:                   | nShortStringType, nStrLitType :
5717:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5719:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5727:                      oTypeSPush( ShortStringType )
5733:                   | nCharType :
5735:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
5737:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
5745:                      oTypeSPush( ShortStringType )
5751:                   | * :
5760:                      #eTypeMismatch
5762:                      oTypeSPop
5763:                ]
      
5763:             | nPointerType, nUniversalPointerType :
5765:                @TermAllowFlow( falseLabel )   % actually not allowing CF
5772:                @PromoteToIntPop
5774:                @PointerAddition
      
5776:             | * :
5793:                #eNotAllowed
5795:          ]
      
5795:       | '-' :
5797:          [ oTypeSNodeType
5799:             | nIntegerType, nByteType :
5800:                @PromoteToIntPop
5802:                @TermAllowFlow( falseLabel )
5809:                @PromoteToInt
5811:                .tSubI
      
5813:             | nPointerType, nUniversalPointerType :
5815:                @TermAllowFlow( falseLabel )
5822:                [ oTypeSNodeType
5824:                   | nIntegerType, nByteType :
5825:                      @PromoteToIntPop
5827:                      @PointerSubInt
5829:                   | nPointerType, nUniversalPointerType :
5831:                      @MatchTypes
5833:                      @PointerSubPointer
5835:                   | * :
5846:                      #eNotAllowed
5848:                ]
      
5848:             | * :  #eNotAllowed
      
5861:          ]
5861:       | * :
5868:          >
5870:    ]};
      
      
5873: TermAllowFlow( out Label falseLabel ):
5875:    @FactorAllowFlow( falseLabel )
5882:    {[
5882:       | pTimes :
5884:          @PromoteToIntPop
5886:          @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
5893:          @PromoteToInt
5895:          .tMultI
5897:       | pDivide :
5899:          @PromoteToIntPop
5901:          @FactorAllowFlow( falseLabel )
5908:          @PromoteToInt
5910:          .tDivI
5912:       | * :
5919:          >
5921:    ]};
      
      
5924: FactorAllowFlow( out Label falseLabel ):
5926:    [
5926:       | pPlus :
5928:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5935:          @PromoteToInt
5937:       | pMinus :
5939:          @PrimaryAllowFlow( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5946:          @PromoteToInt
5948:          .tNegI
5950:       | * :
5957:          @PrimaryAllowFlow( falseLabel )
5964:    ];
      
      
5965: PrimaryAllowFlow( out Label falseLabel ):
5967:    [
5967:       | pIntLit :
5969:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5976:          oTypeSPush( IntegerType )
      
5982:       | pCharLit :
5984:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5991:          oTypeSPush( CharType )
      
5997:       | '(' :
5999:          @ExprAllowFlow( falseLabel )
6006:          ')'
      
6008:       | pStrLit :
6010:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6019:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6027:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6033:          @LValueIndexes
               % get final value of dereferencing, if any
6035:          @FetchVar
      
6037:       | pIdent :
6039:          Node decl = oScopeFindRequire
6044:          @ResolveUnitRef( decl )
6051:          Node theType
      
6051:          [ oNodeType( decl )
6058:             | nFunc :
6059:                @Call( decl )
      
6066:             | nBuiltInFunc :
6068:                @CallBuiltInFunc( decl )
      
6075:             | nConst, nEnumValue :
6077:                theType = oNodeGet( decl, qType )
6090:                oTypeSPush( theType )
6096:                [ oTypeSNodeType
6098:                   | nIntegerType, nEnumType, nBooleanType :
6099:                      .tPushConstI @EmitValue( decl )
6108:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6110:                      .tPushConstI @EmitValue( decl )
6119:                   | * :
6132:                      #eNotImplemented
6134:                ]
      
6134:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6136:                int addr = oNodeGetInt( decl, qValue )
6149:                [ equal_zero( addr )
6156:                   | true :
6157:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6174:                      oNodeSetInt( decl, qValue, addr )
6186:                   | * :
6191:                ]
6191:                .tPushAddrGlobal oEmitInt( addr )
6199:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6205:                @LValueIndexes
                     % get final value of dereferencing, if any
6207:                @FetchVar
      
6209:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6211:                @VarExpr( decl )
      
6218:             | * :
6239:                #eNotValue
6241:                oTypeSPush( IntegerType )
6247:          ]
      
6247:       | '@' :        % @var -- pointer to var
6249:          pIdent
      
6251:          Node decl = oScopeFindRequire
6256:          @ResolveUnitRef( decl )
6263:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6263:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6273:          theType = oTypeSTop
6278:          oTypeSPop
6279:          Node ptrType = @PointerTypeTo( theType )
6290:          oTypeSPush( ptrType )
      
6296:       | * :
6311:          #eNotValue
6313:          oTypeSPush( IntegerType )
6319:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6320: VarExpr( Node decl ):
6322:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6335:    int uplevels = @DeclUpLevels( decl )
      
6346:    oTypeSPush( theType )
6352:    [ oTypeSNodeType
6354:       | nIntegerType, nEnumType :
6355:          [ oNodeType( decl )
6362:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6372:             | nLocalVar :
6374:                [ equal_zero( uplevels )
6381:                   | true :  .tPushLocalI  @EmitValue( decl )
6391:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6411:                ]
6411:             | nParam :
6413:                [ oNodeGetBoolean( decl, qInOut )
6423:                   | true :    % VAR param points to the var.  Auto dereference.
6424:                      [ equal_zero( uplevels )
6431:                         | true :  .tPushParamP  @EmitValue( decl )
6441:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6461:                      ]
6461:                      .tFetchI
6463:                   | * :
6468:                      [ equal_zero( uplevels )
6475:                         | true :  .tPushParamI  @EmitValue( decl )
6485:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6505:                      ]
6505:                ]
6505:          ]
      
6517:       | nBooleanType, nByteType, nCharType :
6519:          [ oNodeType( decl )
6526:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6536:             | nLocalVar :
6538:                [ equal_zero( uplevels )
6545:                   | true :  .tPushLocalB  @EmitValue( decl )
6555:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6575:                ]
6575:             | nParam :
6577:                [ oNodeGetBoolean( decl, qInOut )
6587:                   | true :    % VAR param points to the var.  Auto dereference.
6588:                      [ equal_zero( uplevels )
6595:                         | true :  .tPushParamP  @EmitValue( decl )
6605:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6625:                      ]
6625:                      .tFetchB
6627:                   | * :
6632:                      [ equal_zero( uplevels )
6639:                         | true :  .tPushParamB  @EmitValue( decl )
6649:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6669:                      ]
6669:                ]
6669:          ]
      
6681:       | nFileType :
6683:          #eNotImplemented
      
6685:       | nPointerType, nUniversalPointerType :
6687:          [ oNodeType( decl )
6694:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6704:             | nLocalVar :
6706:                [ equal_zero( uplevels )
6713:                   | true :  .tPushLocalP  @EmitValue( decl )
6723:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6743:                ]
6743:             | nParam :
6745:                [ oNodeGetBoolean( decl, qInOut )
6755:                   | true :    % VAR param points to the var.  Auto dereference.
6756:                      [ equal_zero( uplevels )
6763:                         | true :  .tPushParamP  @EmitValue( decl )
6773:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6793:                      ]
6793:                      .tFetchP
6795:                   | * :
6800:                      [ equal_zero( uplevels )
6807:                         | true :  .tPushParamP  @EmitValue( decl )
6817:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6837:                      ]
6837:                ]               
6837:          ]
6849:          [
6849:             | '^' :             % dereferenced
6851:                oTypeSPop
6852:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6865:                @LValueIndexes
6867:                @FetchVar
6869:             | '[' :             % dereferencing pointer like an array [0..] of baseType
6871:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
6873:                @LValueIndexes
6875:                @FetchVar
6877:             | * :               % just ptr value alone
6884:          ]
      
6884:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
6886:          [ oNodeType( decl )
6893:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
6903:             | nLocalVar :
6905:                [ equal_zero( uplevels )
6912:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6922:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6942:                ]
6942:             | nParam :
6944:                [ oNodeGetBoolean( decl, qInOut )
6954:                   | true :    % VAR param points to the var.  Auto dereference.
6955:                      [ equal_zero( uplevels )
6962:                         | true :  .tPushParamP  @EmitValue( decl )
6972:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6992:                      ]
6992:                   | * :
6997:                      [ equal_zero( uplevels )
7004:                         | true :  .tPushAddrParam  @EmitValue( decl )
7014:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7034:                      ]
7034:                ]
7034:          ]
               % modify addr for subscripts, field references, etc
7046:          @LValueIndexes
               % get final value
7048:          @FetchVar
7050:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7077: FetchVar:
7079:    [ oTypeSNodeType
7081:       | nIntegerType, nEnumType :  .tFetchI
7084:       | nBooleanType, nByteType, nCharType :  .tFetchB
7088:       | nFileType :   #eNotImplemented
7092:       | nPointerType :             .tFetchP
7096:       | nUniversalPointerType :    #eCantDereference
7100:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7102:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7131: LValueIndexes:
7133:    {[
7133:       | '[' :
7135:          [ oTypeSNodeType
7137:             | nArrayType :    @ArraySubscripts
7140:             | nPointerType :  @PointerArraySubscript
7144:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7148:             | * :             #eNotArray
7161:          ]
7161:       | '.' :       @RecordFieldRef
7165:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7169:       | * :         >
7180:    ]};
      
      
7183: ArraySubscripts:
7185:    [ oTypeSNodeType
7187:       | nArrayType :
7188:       | * :       #eNotArray
7195:    ]
7195:    {
7195:       [ oTypeSNodeType
7197:          | nArrayType :
7198:          | * :    #eTooManySubscripts
7205:       ]
      
            % low subscript of this dimension
7205:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7222:       Node baseType
7222:       baseType = oNodeGet( oTypeSTop, qBaseType )
7234:       oTypeSPop
7235:       oTypeSPush( baseType )
      
7241:       @Expr
7243:       @RequireIntPop
            % adjust for low subscript
7245:       [ equal_zero( low )
7252:          | false :
7253:             .tPushConstI oEmitInt( low ) .tSubI
7263:          | * :
7268:       ]
      
            % multiply by element size
7268:       int size = oNodeGetInt( baseType, qSize )
7281:       [ equal( size, 1 )
7291:          | false :
7292:             .tPushConstI oEmitInt( size ) .tMultI
7302:          | * :
7307:       ]
      
            % update start address
7307:       .tAddPI
7309:       [
7309:          | ']' :  >
7313:          | ',' :
7315:       ]
7323:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7326: PointerArraySubscript:
7328:    [ oTypeSNodeType
7330:       | nPointerType :
7331:       | * :    #eCantDereference
7338:    ]
         % replace type stack with base type
7338:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7350:    oTypeSPop
7351:    oTypeSPush( baseType )
         
7357:    @Expr
7359:    @RequireIntPop
         % multiply by element size
7361:    int size = oNodeGetInt( baseType, qSize )
7374:    [ equal( size, 1 )
7384:       | false :
7385:          .tPushConstI  oEmitInt( size )  .tMultI
7395:       | * :
7400:    ]
         % update start address
7400:    .tAddPI
7402:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7405: ShortStringArraySubscript:
7407:    [ oTypeSNodeType
7409:       | nStrLitType, nShortStringType :
7410:       | * :    #eCantDereference
7419:    ]
7419:    oTypeSPop
7420:    oTypeSPush( CharType )
7426:    @Expr
7428:    @RequireIntPop
7430:    .tAddPI
7432:    ']';
      
      
7435: RecordFieldRef:
7437:    [ oTypeSNodeType
7439:       | nRecordType :
7440:       | * :    #eNotRecord
7447:    ]
7447:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7459:    pIdent
7461:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7466:    [ oNodeType( field )
7473:       | nRecordField :
7474:       | * :   #eNotRecordField
7481:    ]
7481:    oScopeEnd
7482:    int offset = oNodeGetInt( field, qValue )
7495:    [ equal_zero( offset )
7502:       | false :
7503:          .tPushConstI oEmitInt( offset ) .tAddPI
7513:       | * :
7518:    ]
      
         % replace the type on the type stack, with the field type
7518:    oTypeSPop
7519:    oTypeSPush( oNodeGet( field, qType ) )
7533:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7533: PointerAddition:
7535:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7547:    int elementSize = oNodeGetInt( elementType, qSize )
7560:    [ equal( elementSize, 1 )
7570:       | false :
7571:          .tPushConstI  oEmitInt( elementSize )
7579:          .tMultI
7581:       | * :
7586:    ]
7586:    .tAddPI
7589:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7589: PointerSubInt:
7591:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7603:    int elementSize = oNodeGetInt( elementType, qSize )
7616:    [ equal( elementSize, 1 )
7626:       | false :
7627:          .tPushConstI  oEmitInt( elementSize )
7635:          .tMultI
7637:       | * :
7642:    ]
7642:    .tSubPI
7645:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
7645: PointerSubPointer:
7647:    .tSubP
7649:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
7661:    int elementSize = oNodeGetInt( elementType, qSize )
7674:    [ equal( elementSize, 1 )
7684:       | false :
7685:          .tPushConstI  oEmitInt( elementSize )
7693:          .tDivI
7695:       | * :
7700:    ]
7700:    oTypeSPop
7701:    oTypeSPush( IntegerType )
7708:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7708: PointerDeref:
7710:    [ oTypeSNodeType
7712:       | nPointerType :
7713:       | nUniversalPointerType :   #eCantDereference
7717:       | * :       #eNotPointer
7726:    ]
7726:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7728:    Node theType = oTypeSTop
7733:    oTypeSPop
7734:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7748:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7748: CoerceType:
7750:    node_type nt = oTypeSNodeType
7755:    oTypeSPop
7756:    [ equal_node_type( nt, oTypeSNodeType )
7765:       | false :
               % Can we implicitly convert the value to the desired type?
7766:          [ oTypeSNodeType
7768:             | nIntegerType :
7769:                [ nt
7772:                   | nByteType :   .tCastBtoI  >>
7776:                   | * :
7781:                ]
7781:             | nByteType :
7783:                [ nt
7786:                   | nIntegerType :   .tCastItoB  >>
7790:                   | * :
7795:                ]
7795:             | nPointerType :
7797:                [ nt
7800:                   | nUniversalPointerType :  >>
7802:                   | nStrLitType :
7804:                      [ equal_node( oTypeSTop, PCharType )
7813:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
7814:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
7825:                         | * :
7830:                      ]
7830:                   | * :
7837:                ]
7837:             | nUniversalPointerType :
7839:                [ nt
7842:                   | nPointerType :  >>
7844:                   | * :
7849:                ]
7849:             | nShortStringType :
7851:                [ nt
7854:                   | nStrLitType :  >>
7856:                   | nCharType :
                           % Store char as a temp ShortString.
7858:                      oTypeSPush( CharType )
7864:                      int tempOffset = @MoveIntoTempShortString
7870:                      oTypeSPop
7871:                      >>
7872:                   | * :
7879:                ]
7879:             | * :
7892:          ]
7892:          #eTypeMismatch
7894:       | * :
7899:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7900: MatchTypes:
7902:    node_type nt = oTypeSNodeType
7907:    oTypeSPop
7908:    [ equal_node_type( nt, oTypeSNodeType )
7917:       | false :
               % Some implicit conversion is allowed even here
7918:          [ oTypeSNodeType
7920:             | nPointerType :
7921:                [ nt
7924:                   | nUniversalPointerType :  >>
7926:                   | * :
7931:                ]
7931:             | nUniversalPointerType :
7933:                [ nt
7936:                   | nPointerType :  >>
7938:                   | * :
7943:                ]
7943:             | * :
7950:          ]
7950:          #eTypeMismatch
7952:       | * :
7957:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7958: RequireIntPop:
7960:    [ oTypeSNodeType
7962:       | nIntegerType :
7963:       | * :          #eNotInteger
7970:    ]
7970:    oTypeSPop;
      
7972: RequireInt:
7974:    [ oTypeSNodeType
7976:       | nIntegerType :
7977:       | * :          #eNotInteger
7984:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
7985: PromoteToIntPop:
7987:    [ oTypeSNodeType
7989:       | nIntegerType :
7990:       | nByteType :        .tCastBtoI
7994:       | * :                #eNotInteger
8003:    ]
8003:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
8005: PromoteToInt:
8007:    [ oTypeSNodeType
8009:       | nIntegerType :
8010:       | nByteType :        .tCastBtoI
8014:                            oTypeSPop
8015:                            oTypeSPush( IntegerType )
8021:       | * :                #eNotInteger
8030:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
8031: PromoteToIntOptional:
8033:    [ oTypeSNodeType
8035:       | nByteType :        .tCastBtoI
8038:                            oTypeSPop
8039:                            oTypeSPush( IntegerType )
8045:       | * :
8050:    ];
      
      
8051: RequireBoolPop:
8053:    [ oTypeSNodeType
8055:       | nBooleanType :
8056:       | * :          #eNotBoolean
8063:    ]
8063:    oTypeSPop;
      
8065: RequireBool:
8067:    [ oTypeSNodeType
8069:       | nBooleanType :
8070:       | * :          #eNotBoolean
8077:    ];
      
      
8078: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
8078: Statement:
8080:    [
8080:       | pWriteln :     @WritelnStmt
8084:       | pWrite :       @WriteStmt
8088:       | pReadln :      @ReadlnStmt
8092:       | pRead :        @ReadStmt
8096:       | pIf :          @IfStmt
8100:       | pWhile :       @WhileStmt
8104:       | pFor :         @ForStmt
8108:       | pRepeat :      @RepeatStmt
8112:       | pBreak :       @BreakStmt
8116:       | pContinue :    @ContinueStmt
8120:       | pBegin :       @BeginStmt
8124:       | pIdent :       @LabelOrAssignOrCallStmt
8128:       | pCase :        @CaseStmt
8132:       | pGoto :        @GotoStmt
8136:       | pIntLit :      % should be an integer label
8138:                        oChangeIntLitToLabelIdent
8139:                        @LabelOrAssignOrCallStmt
8141:       | * :            % null statement : don't accept any tokens
8174:    ];
      
      
8175: LabelOrAssignOrCallStmt:
8177:    Node decl = oScopeFindRequire
8182:    @ResolveUnitRef( decl )
8189:    [ oNodeType( decl )
8196:       | nLabel :                          @LabelDefinition( decl )
8204:                                           @Statement
8206:       | nProc :                           @Call( decl )
8215:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8224:       | nFunc :                           @AssignResultStmt( decl )
8233:       | * :                               #eBadStatement
8250:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8251: LabelDefinition( Node decl ):
8253:    [ oNodeGetBoolean( decl, qDefined )
8263:       | true :  #eAlreadyDefined
8266:       | * :
8271:    ]
8271:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8286:    oNodeSetBoolean( decl, qDefined, true )
8298:    ':'
8301:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8301: AssignStmt( Node decl ):
      
8303:    @LValueVar( decl, true )
8313:    ':=' 
8315:    @Expr
8317:    @CoerceType
8319:    @Assign
8322:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8322: Assign:
8324:    [ oTypeSNodeType
8326:       | nIntegerType, nEnumType :  .tAssignI
8329:       | nBooleanType, nByteType, nCharType :  .tAssignB
8333:       | nFileType :   #eNotImplemented
8337:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8341:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
8343:           int size = oNodeGetInt( oTypeSTop, qSize )
8355:           .tCopy  oEmitInt( size )    % multi-word copy
8363:    ]
8389:    oTypeSPop
8391:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8391: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8393:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8409:       | false :   #eNotCurrentFunction
8412:       | * :
8417:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8417:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8432:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8445:    ':='
8447:    @Expr
8449:    @CoerceType
8451:    [ oTypeSNodeType
8453:       | nIntegerType, nEnumType : .tAssignI
8456:       | nBooleanType, nByteType, nCharType :  .tAssignB
8460:       | nFileType :   #eNotImplemented
8464:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
8468:       | nArrayType, nRecordType, nShortStringType :
8470:           int size = oNodeGetInt( oTypeSTop, qSize )
8482:           .tCopy  oEmitInt( size )    % multi-word copy
8490:    ]
8516:    oTypeSPop
8518:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
8518: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8520:    pIdent
8522:    Node decl = oScopeFindRequire
8527:    @ResolveUnitRef( decl )
8534:    [ oNodeType( decl )
8541:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
8542:       | * :  #eNotVar
8555:    ]
8555:    @LValueVar( decl, writeable )
8566:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8566: LValueVar( Node decl, boolean writeable ):
8568:    [ oNodeType( decl )
8575:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8585:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8596:       | nParam :
8598:          [ oNodeGetBoolean( decl, qInOut )
8608:             | true :   % VAR param points to variable.  No dereference.
8609:                        .tPushParamP @EmitValue( decl )
8618:             | * :      .tPushAddrParam @EmitValue( decl )
8632:          ]
8632:       | nTypedConst :
8634:          [ writeable
8637:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
8647:             | * :      #eNotVar
8654:          ]
8654:       | * :            #eNotVar
8667:    ]
      
8667:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
8680:    [ oTypeSNodeType
8682:       | nPointerType :
8683:          [
8683:             | '[' :
                     % dereference the pointer var first
8685:                .tFetchP
8687:                @PointerArraySubscript
8689:             | * :
8694:          ]
8694:       | * :
8699:    ]
         % additional subscripts, if any
8699:    @LValueIndexes
8702:    ;
      
      
8702: IncVar( Node decl ):
8704:    @LValueVar( decl, true )
8714:    @RequireIntPop
8716:    @VarExpr( decl )
8723:    oTypeSPop
8724:    .tIncI
8726:    .tAssignI;
      
8729: DecVar( Node decl ):
8731:    @LValueVar( decl, true )
8741:    @RequireIntPop
8743:    @VarExpr( decl )
8750:    oTypeSPop
8751:    .tDecI
8753:    .tAssignI;
      
      
8756: IfStmt:
8758:    Label falseLabel = labelNull
      
8764:    @BooleanExprControlFlow( falseLabel )
8771:    pThen
8773:    @Statement
8775:    [
8775:       | pElse :
8777:          Label doneLabel = oLabelNew
      
8782:          .tJump  oEmitLabel( doneLabel )
8790:          .tLabel oEmitLabel( falseLabel )
8798:          @Statement
8800:          .tLabel oEmitLabel( doneLabel )
      
8808:       | * :
8813:          .tLabel oEmitLabel( falseLabel )
8821:    ];
      
      
8822: ForStmt:
8824:    pIdent
      
8826:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8831:    @LValueVar( decl, true )
8841:    @RequireIntPop
      
8843:    ':='
      
8845:    @Expr
8847:    @RequireIntPop
8849:    .tAssignI
      
8851:    Label breakLabel = oLabelNew
      
8856:    Label checkLabel = oLabelNew
8861:    .tJump  oEmitLabel( checkLabel )
      
8869:    Label continueLabel = oLabelNew
8874:    .tLabel  oEmitLabel( continueLabel )
8882:    [
8882:       | pTo :
8884:          @IncVar( decl )
8891:          .tLabel  oEmitLabel( checkLabel )
8899:          @VarExpr( decl )  oTypeSPop
8907:          @Expr
8909:          @RequireIntPop
8911:          .tGreaterI
8913:          .tJumpTrue  oEmitLabel( breakLabel )
8921:       | pDownto :
8923:          @DecVar( decl )
8930:          .tLabel  oEmitLabel( checkLabel )
8938:          @VarExpr( decl )  oTypeSPop
8946:          @Expr
8948:          @RequireIntPop
8950:          .tLessI
8952:          .tJumpTrue  oEmitLabel( breakLabel )
8960:    ]
8968:    oLoopPush( continueLabel, breakLabel )
8977:    pDo
8979:    @Statement
8981:    .tJump  oEmitLabel( continueLabel )
8989:    .tLabel  oEmitLabel( breakLabel )
8997:    oLoopPop;
      
      
8999: RepeatStmt:
9001:    Label continueLabel = oLabelNew
9006:    .tLabel  oEmitLabel( continueLabel )
      
9014:    Label breakLabel = oLabelNew
      
9019:    oLoopPush( continueLabel, breakLabel )
9028:    @Statement
9030:    {[
9030:       | ';' :
9032:          @Statement
9034:       | pUntil :
9036:          Label falseLabel
9036:          @BooleanExprControlFlow( falseLabel )
9043:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9057:          >
9059:    ]}
9069:    .tLabel  oEmitLabel( breakLabel )
9077:    oLoopPop;
      
      
9079: WhileStmt:
9081:    Label continueLabel = oLabelNew
9086:    .tLabel  oEmitLabel( continueLabel )
      
9094:    Label breakLabel
9094:    @BooleanExprControlFlow( breakLabel )
      
9101:    oLoopPush( continueLabel, breakLabel )
9110:    pDo
9112:    @Statement
9114:    .tJump  oEmitLabel( continueLabel )
9122:    .tLabel  oEmitLabel( breakLabel )
9130:    oLoopPop;
      
      
9132: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9134:    [ equal_label( oLoopContinueLabel, labelNull )
9143:       | true :
9144:          #eNotInALoop
9146:       | false :
9148:          .tJump  oEmitLabel( oLoopContinueLabel )
9155:    ];
      
      
9164: BreakStmt:
9166:    [ equal_label( oLoopBreakLabel, labelNull )
9175:       | true :
9176:          #eNotInALoop
9178:       | false :
9180:          .tJump  oEmitLabel( oLoopBreakLabel )
9187:    ];
      
      
9196: CaseStmt:
9198:    Code tableCode = oCodeNew
9203:    Label tableLabel = oLabelNew
9208:    Label doneLabel = oLabelNew
9213:    Label otherwiseLabel = doneLabel
      
9219:    @Expr
         % Leave the expr type on the type stack throughout case statement
9221:    [ oTypeSNodeType
9223:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
9232:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
9242:       | nShortStringType, nStrLitType :        #eNotImplemented
9246:       | * :     #eNotAllowed
9265:    ]
9265:    pOf
      
9267:    {
9267:       [
9267:          | pOtherwise, pElse :
9269:             otherwiseLabel = oLabelNew
9274:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
9282:             {[
9282:                | pEnd :  >
9286:                | * :
9291:                   @Statement
9293:                   [
9293:                      | ';' :
9295:                      | * :   pEnd  >
9304:                   ]
9304:             ]}
9306:             >
      
9308:          | pEnd :
                  % Reached end with no otherwise clause
9310:             >
      
9312:          | * :
9321:             Label caseLabel = oLabelNew
9326:             oCodePush( tableCode )
9332:             {
9332:                @ConstExpr
9334:                @ConstCoerceType
9336:                int val = oValueTop
9341:                oValuePop
9342:                [
9342:                   | '..' :  @ConstExpr
9346:                             @ConstCoerceType
9348:                             int highval = oValueTop
9353:                             oValuePop
9354:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
9374:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
9393:                ]
9393:                [
9393:                   | ',' :
9395:                   | * :  >
9402:                ]
9402:             }
9404:             oCodePop
9405:             ':'
9407:             .tLabel  oEmitLabel( caseLabel )
9415:             @Statement
9417:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
9425:             [
9425:                | ';' :
9427:                | * :
9432:             ]
                  
9432:       ]
         
9432:    }
      
9434:    .tLabel  oEmitLabel( tableLabel )
9442:    oEmitCode( tableCode )
9448:    .tCaseEnd  oEmitLabel( otherwiseLabel )
9456:    .tLabel  oEmitLabel( doneLabel )
9464:    oTypeSPop
9466:    ;
      
      
9466: GotoStmt:
9468:    [
9468:       | pIdent :
9470:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9472:          oChangeIntLitToLabelIdent
9473:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9481:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9490:    oNodeSetBoolean( decl, qUsed, true )
9502:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9518:    ;
      
      
9518: BeginStmt:
9520:    @Statement
9522:    {[
9522:       | ';' :   @Statement
9526:       | pEnd :  >
9530:    ]};
      
      
9541: WritelnStmt:
9543:    @WriteStmt
9545:    .tWriteCR;
      
      
9548: WriteStmt:
9550:    [
9550:       | '(' :
9552:          {
9552:             @Expr
9554:             [ oTypeSNodeType
9556:                | nIntegerType :             .tWriteI
9559:                | nBooleanType :             .tWriteBool
9563:                | nByteType :                .tCastBtoI  .tWriteI
9569:                | nCharType :                .tWriteChar
9573:                | nShortStringType, nStrLitType :   .tWriteShortStr
9577:                | nFileType :                #eNotImplemented
9581:                | nEnumType :
                        % write name via table lookup
9583:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9597:                   .tWriteEnum
9599:                | nPointerType :
9601:                   [ equal_node( oTypeSTop, PCharType )
9610:                      | true :               .tWritePChar
9613:                      | * :                  .tWriteP
9620:                   ]
9620:                | nUniversalPointerType :    .tWriteP
9624:                | * :                        #eNotAllowed
9649:             ]
9649:             oTypeSPop
9650:             [
9650:                | ')' : >
9654:                | ',' :
9656:             ]
9664:          }
9666:       | * :
9671:    ];
      
      
9672: ReadlnStmt:      % ***
         % TO DO
9675:    ;
      
9675: ReadStmt:
         % TO DO
9678:    ;
9678: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
9678: MoveIntoTempShortString >> int:
9680:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
9690:    [ oTypeSNodeType
9692:       | nShortStringType, nStrLitType :
9693:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
9701:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
9703:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
9718:       | nCharType :
               % temp[0] = 1
9720:          .tPushAddrLocal  oEmitInt( tempOffset )
9728:          .tPushConstI  oEmitInt( 1 )
9736:          .tAssignB
               % temp[1] = value
9738:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
9753:          .tSwap
9755:          .tAssignB
9757:       | * :   #eTypeMismatch
9768:    ]
9768:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
9769:    .tPushAddrLocal  oEmitInt( tempOffset )
9777:    oTypeSPush( ShortStringType )
9783:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9787: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
9789:    .tAllocActuals  oEmitInt( 16 )
9797:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9809:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9821:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
9830:    .tFreeActuals  oEmitInt( 16 )
9838:    oTypeSPop
9839:    oTypeSPop
9841:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
9841: ShortStringAppendChar:
         % Note at the moment I don't align params
9843:    .tAllocActuals  oEmitInt( 12 )
9851:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
9863:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9875:    .tCall  @EmitValue( System_ShortStringAppendChar )
9884:    .tFreeActuals  oEmitInt( 12 )
9892:    oTypeSPop
9893:    oTypeSPop
9895:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
9895: ShortStringCmp:
9897:    .tAllocActuals  oEmitInt( 24 )
9905:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
9917:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
9929:    int tempOffset = oScopeAllocType( IntegerType )
9939:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
9957:    .tCall  @EmitValue( System_ShortStringCmp )
9966:    .tPushLocalI  oEmitInt( tempOffset )
9974:    .tFreeActuals  oEmitInt( 24 )
9982:    oTypeSPop
9983:    oTypeSPush( IntegerType )
9990:    ;
9990: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9990: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
9992:    [ oNodeGetBoolean( method, qExternal )
10002:       | true :
10003:          [ oNodeGetBoolean( method, qUsed )
10013:             | false :
                     % define the extern label on first use
10014:                @DefineExternLabel( method )
10021:             | * :
10026:          ]
10026:      | * :
10031:    ]
10031:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
10043:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
10056:    Node resultType
10056:    int tempOffset
      
10056:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
10073:    [ isFunc
10076:       | true :
10077:          resultType = oNodeGet( method, qType )
10090:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
10100:       | * :
10105:    ]
         
      
10105:    Node paramScope = oNodeGet( method, qParams )
10118:    int actualsSize = oNodeGetInt( paramScope, qSize )
10131:    [ cdecl
10134:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
10143:       | false :  .tAllocActuals  oEmitInt( actualsSize )
10153:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
10161:    [ greater( @DeclLevel( method ), 0 )
10176:       | true :
10177:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
10185:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
10204:          .tAssignP
10206:       | * :
10211:    ]
      
      
10211:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
10224:    Node param = oNodeIterValue( paramIter )
10234:    [
10234:       | '(' :
            
10236:          {
10236:             [ oNodeNull( param )
10243:                | true : >
10246:                | * :
10251:             ]
      
10251:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
10264:             .tPushAddrActual oEmitInt( offset )
10272:             oTypeSPush( oNodeGet( param, qType ) )
      
10285:             [ oNodeGetBoolean( param, qInOut )
10295:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
10296:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
10303:                           @MatchTypes
      
10305:                           .tAssignP
      
10307:                | false :  @Expr
10311:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
10313:                           [ oTypeSNodeType
10315:                              | nIntegerType, nEnumType : .tAssignI
10318:                              | nBooleanType, nByteType, nCharType :  .tAssignB
10322:                              | nFileType :   #eNotImplemented
10326:                              | nPointerType, nUniversalPointerType :  .tAssignP
10330:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
10332:                                  int size = oNodeGetInt( oTypeSTop, qSize )
10344:                                  .tCopy  oEmitInt( size )    % multi-word copy
10352:                           ]
10378:             ]
10386:             oTypeSPop
      
10387:             oNodeIterNext( paramIter )
10393:             param = oNodeIterValue( paramIter )
10403:             [ oNodeNull( param )
10410:                | true :  >
10413:                | false :
10415:             ]
      
10423:             ','
10425:          }
      
10427:          ')'
      
10429:       | * :
10434:    ]
      
10434:    [ oNodeNull( param )
10441:       | false :    #eMissingParameter
10444:       | * :
10449:    ]
      
10449:    [ isFunc
10452:       | true :
               % Pass result temp as an additional VAR parameter.
10453:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
10468:          .tPushAddrLocal  oEmitInt( tempOffset )
10476:          .tAssignP
10478:       | * :
10483:    ]
      
10483:    [ cdecl
10486:       | true :
10487:          .tCallCdecl  @EmitValue( method )
10496:       | false :
10498:          .tCall   @EmitValue( method )
10507:    ]
      
10515:    [ isFunc
10518:       | true :
               % push return value from temp
10519:          oTypeSPush( resultType )
      
10525:          [ oTypeSNodeType
10527:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
10536:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
10546:             | nFileType :  #eNotImplemented
10550:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
10560:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
10562:                                .tPushAddrLocal  oEmitInt( tempOffset )
10570:          ]
10596:       | * :
10601:    ]
         
10601:    .tFreeActuals  oEmitInt( actualsSize )
10610:    ;
      
      
      
      % Called on first use of an extern method
      %
10610: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
10612:    int strAddr
10612:    String externalName = oNodeGetString( method, qExternalName )
10625:    [ equal_string( externalName, stringNull )
10635:       | true :
10636:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
10657:       | false :
10659:          strAddr = oStringAllocLit( externalName )
10669:    ]
10677:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
10693:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
10693: CallBuiltInFunc( Node method ):
      
         % Ord(x)
10695:    [ oNodeEqual( method, BuiltIn_Ord )
10705:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
10706:          '('
10708:          @Expr
10710:          [ oTypeSNodeType
10712:             | nIntegerType, nEnumType :
10713:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
10717:             | * :  #eTypeMismatch
10732:          ]
10732:          oTypeSPop
10733:          oTypeSPush( IntegerType )
10739:          ')'
10741:          >>
10742:       | * :
10747:    ]
      
         % Chr(x)
10747:    [ oNodeEqual( method, BuiltIn_Chr )
10757:       | true :
               % parameter is integer
               % result is char
10758:          '('
10760:          @Expr
10762:          [ oTypeSNodeType
10764:             | nIntegerType :    .tCastItoB
10767:             | nByteType :
10769:             | * :  #eTypeMismatch
10778:          ]
10778:          oTypeSPop
10779:          oTypeSPush( CharType )
10785:          ')'
10787:          >>
10788:       | * :
10793:    ]
      
         % Pred(x)
10793:    [ oNodeEqual( method, BuiltIn_Pred )
10803:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10804:          '('
10806:          @Expr
10808:          [ oTypeSNodeType
10810:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10811:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10820:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10823:                   | * :
10828:                ]
10828:             | * :  #eTypeMismatch
10835:          ]
10835:          .tDecI
10837:          ')'
10839:          >>
10840:       | * :
10845:    ]
      
         % Succ(x)
10845:    [ oNodeEqual( method, BuiltIn_Succ )
10855:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
10856:          '('
10858:          @Expr
10860:          [ oTypeSNodeType
10862:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
10863:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
10872:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
10875:                   | * :
10880:                ]
10880:             | * :  #eTypeMismatch
10887:          ]
10887:          .tIncI
10889:          ')'
10891:          >>
10892:       | * :
10897:    ]
      
10897:    #eNotImplemented
10900:    ;
      
10900: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10900: newType( node_type nt, int size ) >> Node:
10902:   Node node = oNodeNew( nt )
10912:   oNodeSetInt( node, qSize, size )
10924:   oTypeAdd( node )
10930:   >> node
10934:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
10934: TypeRef( out Node resultType ):
10936:    [
10936:       | pIdent :           % previously named type (including intrinsics)
10938:          Node decl = oScopeFindRequire
10943:          @ResolveUnitRef( decl )
10950:          [ oNodeType( decl )
10957:             | nTypeDecl :
10958:                resultType = oNodeGet( decl, qType )
10971:             | * :
10976:                #eNotType
10978:                resultType = IntegerType
10984:          ]
         
10984:       | pArray :
10986:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
10988:          NodeVec dimensions = oNodeVecNew
      
10993:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
10993:             Node subrange = oNodeNew( nSubrangeType )
      
11003:             @ConstExpr
11005:             oNodeSetInt( subrange, qLow, oValueTop )
11016:             oValuePop
11017:             '..'
11019:             @ConstExpr
11021:             oNodeSetInt( subrange, qHigh, oValueTop )
11032:             oValuePop
      
11033:             @ConstMatchTypes
11035:             oNodeSet( subrange, qBaseType, oTypeSTop )
11046:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
11064:             oTypeSPop
11065:             oTypeAdd( subrange )
      
11071:             Node a = oNodeNew( nArrayType )
11081:             oNodeSet( a, qIndexType, subrange )
      
11093:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
11102:             [
11102:                | ']' : >
11106:                | ',' :
11108:             ]
11116:          }
      
11118:          pOf
11120:          Node baseType
11120:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
11127:          int dim = oNodeVecSize( dimensions )
      
11137:          {
11137:              dec(dim)
      
11143:              Node a = oNodeVecElement( dimensions, dim )
      
11156:              oNodeSet( a, qBaseType, baseType )
11168:              Node subrange = oNodeGet( a, qIndexType )
11181:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
11208:              inc( width )
11214:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
11240:              oTypeAdd( a )
11246:              baseType = a
      
11252:              [ equal_zero(dim)
11259:                  | true:  >
11262:                  | *:
11267:              ]
11267:          }
      
11269:          resultType = oNodeVecElement( dimensions, 0 )
11282:          oNodeVecDelete( dimensions )
      
11288:       | '^' :
11290:          Node theType
11290:          @TypeRef( theType )
11297:          resultType = @PointerTypeTo( theType )
      
11308:       | pRecord :
11310:          resultType = oNodeNew( nRecordType )
11320:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
11329:          @VarDecl( nRecordField )
      
11336:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
11348:          [ equal_zero( size )
11355:             | true : #eRecordEmpty
11358:             | * :
11363:          ]
      
11363:          pEnd
      
11365:          oNodeSet( resultType, qScope, oScopeCurrent )
11376:          oNodeSetInt( resultType, qSize, size )
11388:          oScopeEnd
11389:          oTypeAdd( resultType )
      
      
11395:       | '(' :
               % An enum type declaration.
11397:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
11404:       | pSet :
11406:          pOf
11408:          Node theType
11408:          @TypeRef( theType )
11415:          #eNotImplemented
11417:       | * :       % this works for cases except where expr starts with an id
11432:          @ConstExpr '..' @ConstExpr
11438:          @ConstMatchTypes
11440:          #eNotImplemented
11442:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
11443: EnumTypeRef( out Node resultType ):
      
11445:    resultType = oNodeNew( nEnumType )
11455:    int value = 0
11461:    int numValues = 0
11467:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
11473:    Node outerScope = oScopeCurrent
11478:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
11487:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
11487:       pIdent
11489:       Node decl = @newIdent( nEnumValue, LAST_ID )
11502:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
11515:       oNodeSet( decl, qType, resultType )
11527:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
11539:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
11552:       oNodeSetInt( decl, qNameOffset, nameOffset )
11564:       oNodeSetInt( decl2, qNameOffset, nameOffset )
11576:       [
11576:          | '=', ':=' :
11578:             oTypeSPush( IntegerType )
11584:             @ConstExpr
11586:             @ConstCoerceType
11588:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
11589:             [ equal_zero( numValues )
11596:                | false :
11597:                   [ greater( oValueTop, value )
11606:                      | false :   #eEnumValueNotAscending
11609:                      | * :
11614:                   ]
11614:                | * :
11619:             ]
11619:             [ equal( value, oValueTop )
11628:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
11629:                   oNodeSetBoolean( resultType, qHasGap, true )
11641:                | * :
11646:             ]
11646:             value = oValueTop
11651:             oValuePop
11652:          | * :
11659:       ]
11659:       oNodeSetInt( decl, qValue, value )
11671:       oNodeSetInt( decl2, qValue, value )
11683:       oScopeDeclare( decl )
      
11689:       oScopeEnter( outerScope )
11695:       oScopeDeclare( decl2 )
11701:       oScopeEnd
      
11702:       inc( value )
11708:       inc( numValues )
11714:       [
11714:          | ',' :
11716:          | * :    >
11723:       ]
11723:    }
11725:    ')'
      
11727:    oNodeSet( resultType, qScope, oScopeCurrent )
11738:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
11750:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
11751:    oCodePush( @GetOrCreateInitCode( globalScope ) )
11762:    oScopeEnter( globalScope )
11768:    int size = multiply( add( numValues, 1 ), 16 )
11788:    int addr = oScopeAlloc( size, 8 )
11801:    oScopeEnd
11802:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
11814:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
11834:    {
11834:       Node enumValue = oNodeIterValue( it )
11844:       [ oNodeNull( enumValue )
11851:          | true :  >
11854:          | * :
11859:       ]
11859:       .tPushAddrGlobal  oEmitInt( addr )
11867:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
11882:       .tAssignI
11884:       addr = add( addr, 8 )
11897:       .tPushAddrGlobal  oEmitInt( addr )
11905:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
11920:       .tAssignP
11922:       addr = add( addr, 8 )
11935:       oNodeIterNext( it )
11941:    }
         % final table entry
11943:    .tPushAddrGlobal  oEmitInt( addr )
11951:    .tPushConstI  oEmitInt( 0 )
11959:    .tAssignI
11961:    addr = add( addr, 8 )
11974:    .tPushAddrGlobal  oEmitInt( addr )
11982:    .tPushConstI  oEmitInt( 0 )
11990:    .tAssignP
11992:    addr = add( addr, 8 )
12005:    oCodePop
      
12006:    oTypeAdd( resultType )
12013:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
12013: PointerTypeTo( Node theType ) >> Node:
12015:    Node ptrType = oNodeGet( theType, qPointerType )
12028:    [ oNodeNull( ptrType )
12035:       | true :
12036:          ptrType = oNodeNew( nPointerType )
12046:          oNodeSet( ptrType, qBaseType, theType )
12058:          oNodeSetInt( ptrType, qSize, 8 )
12070:          oTypeAdd( ptrType )
12076:          oNodeSet( theType, qPointerType, ptrType )
12088:       | * :
12093:    ]
12093:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
12097: OrdinalLow( Node theType ) >> int:
12099:    [ oNodeType( theType )
12106:       | nIntegerType :  >> oMININT
12109:       | nBooleanType :  >> 0
12114:       | nCharType :     >> 0
12119:       | nEnumType :
12121:          Node enumScope = oNodeGet( theType, qScope )
12134:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
12151:          >> oNodeGetInt( first, qValue )
12161:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
12173:       | * :             #eNotOrdinalType
12188:                         >> 0
12191:    ];
      
      
      % Return the high value of an ordinal type
      %
12192: OrdinalHigh( Node theType ) >> int:
12194:    [ oNodeType( theType )
12201:       | nIntegerType :  >> oMAXINT
12204:       | nBooleanType :  >> 1
12209:       | nCharType :     >> 255
12214:       | nEnumType :
12216:          Node enumScope = oNodeGet( theType, qScope )
12229:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
12246:          >> oNodeGetInt( last, qValue )
12256:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
12268:       | * :             #eNotOrdinalType
12283:                         >> 0
12286:    ];
      
      
      
12287: Program:
12289:    Node t
      
12289:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
12294:    oScopeBegin( 0, allocGlobal )
12303:    Node rootScope = oScopeCurrent
      
12308:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
12310:    .tEnter  oEmitInt( 0 )
12318:    Label mainLabel = oLabelNew
      
12323:    .tAllocActuals  oEmitInt( 0 )
12331:    .tCall  oEmitLabel( mainLabel )
12339:    .tFreeActuals  oEmitInt( 0 )
12347:    .tReturn
      
12349:    pProgram
12351:    pIdent
      
12353:    Node program = oNodeNew( nProgram )
12363:    oNodeSetInt( program, qIdent, LAST_ID )
12374:    oNodeSet( workspace, qProgram, program )
      
      
12386:    [
12386:       | '(' :
12388:          pIdent      % input, output files
      
12390:          t = @newIdent( nVar, LAST_ID )
12403:          oNodeSet( t, qType, FileType )
12415:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
12421:          ','
12423:          pIdent
      
12425:          t = @newIdent( nVar, LAST_ID )
12438:          oNodeSet( t, qType, FileType )
12450:          oScopeDeclareAlloc( t )
      
12456:          ')'
12458:       | * :
12463:    ]
12463:    ';'
      
12465:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
12472:    [
12472:       | pUses :  @UsesClause( program )
12481:       | * :
12486:    ]
12486:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
12493:    oScopeBegin( 0, allocGlobal )
12502:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
12507:    oScopeBegin( 0, allocDown )
12516:    oNodeSet( oScopeCurrent, qExtends, globalScope )
12527:    initScope = oScopeCurrent
12532:    oNodeSet( program, qMainRoutineScope, initScope )
12544:    oScopeEnd
      
12545:    @BlockDecls( nGlobalVar )
      
      
12552:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
12558:    boolean isMain = true
12564:    @BlockStmt( mainLabel, globalScope, isMain )
      
12577:    oScopeEnd   % main routine scope
      
12578:    '.'
12580:    @CheckForUndefinedLabels
12582:    oScopeEnd   % global scope
12583:    @EndUsedUnits( program )   % used units scopes
12591:    ;
      
      
      
      
12591: Block( node_type varNodeType, Label labelForBody ):
12593:    @BlockDecls( varNodeType )
12600:    @BlockStmt( labelForBody, oScopeCurrent, false )
12612:    @CheckForUndefinedLabels
12615:    ;
      
      
12615: BlockDecls( node_type varNodeType ):
12617:    {[
12617:       | pConst :     @ConstDecl
12621:       | pType :      @TypeDecl
12625:       | pVar :       @VarDecl( varNodeType )
12634:       | pLabel :     @LabelDecl
12638:       | pProcedure : @ProcDecl
12642:       | pFunction :  @FuncDecl
12646:       | * :          >
12663:    ]}
12665:    @CheckForUndefinedMethods
12668:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
12668: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
12671:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
12671: CheckForUndefinedLabels:
12673:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
12685:    {
12685:       Node decl = oNodeIterValue( it )
12695:       [ oNodeNull( decl )
12702:          | false :
12703:          | * :  >
12710:       ]
12710:       [ oNodeType( decl )
12717:          | nLabel :
12718:             [ oNodeGetBoolean( decl, qDefined )
12728:                | false :
12729:                   [ oNodeGetBoolean( decl, qUsed )
12739:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
12742:                      | * :
12747:                   ]
12747:                | * :
12752:             ]
12752:          | * :
12757:       ]
12757:       oNodeIterNext( it )
12763:    }
12766:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
12766: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
12768:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
12776:    int patchLS
12776:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
12785:    [ isMain
12788:       | true :  @InitializeUnits
12791:       | * :
12796:    ]
      
         % insert any code for initialization of this scope's variables
12796:    Code initCode = oNodeGetCode( varScope, qInitCode )
12809:    oEmitCode( initCode )
12815:    oNodeSetCode( varScope, qInitCode, codeNull )
      
12827:    @Statement
      
12829:    [ isMain
12832:       | true :  @FinalizeUnits
12835:       | * :
12840:    ]
      
12840:    .tReturn
      
12842:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
12854:    oPatch( patchLS, localSpace )
12864:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
12864: GetOrCreateInitCode( Node scope ) >> Code:
12866:    Code initCode = oNodeGetCode( scope, qInitCode )
12879:    [ equal_code( initCode, codeNull )
12889:       | true :
12890:          initCode = oCodeNew
12895:          oNodeSetCode( scope, qInitCode, initCode )
12907:       | * :
12912:    ]
12912:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
12916: ScopeLevel >> int:
12918:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
12928: DeclLevel( Node decl ) >> int:
12930:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
12948: DeclUpLevels( Node decl ) >> int:
12950:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
12966: newIdent( node_type nt, int id ) >> Node:
12968:   Node t = oNodeNew( nt )
12978:   oNodeSetInt( t, qIdent, id )
12990:   >> t
12994:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
12994: EmitValue( Node decl ):
12996:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
13010: DeclareBuiltInFunc( int id ) >> Node:
13012:    Node decl = @newIdent( nBuiltInFunc, id )
13026:    oScopeDeclare( decl )
13032:    >> decl;
      
      
13036: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
13038:    mysystemId = oId_mysystem
      
         % install built-in types
13043:    FileType = @newType( nFileType, 4 )
13057:    IntegerType = @newType( nIntegerType, 4 )
13071:    BooleanType = @newType( nBooleanType, 1 )
13085:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
13099:    CharType = @newType( nCharType, 1 )
13113:    PCharType = @PointerTypeTo( CharType )
13124:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
13138:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
13152:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
13164:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
13178:    ShortStringType = @newType( nShortStringType, 256 )
13192:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
13204:    Node t
      
13204:    t = @newIdent( nTypeDecl, oId_File )
13217:    oNodeSet( t, qType, FileType )
13229:    oScopeDeclare( t )
      
13235:    t = @newIdent( nTypeDecl, oId_Integer )
13248:    oNodeSet( t, qType, IntegerType )
13260:    oScopeDeclare( t )
      
13266:    t = @newIdent( nTypeDecl, oId_Boolean )
13279:    oNodeSet( t, qType, BooleanType )
13291:    oScopeDeclare( t )
      
13297:    t = @newIdent( nTypeDecl, oId_Char )
13310:    oNodeSet( t, qType, CharType )
13322:    oScopeDeclare( t )
      
13328:    t = @newIdent( nTypeDecl, oId_Byte )
13341:    oNodeSet( t, qType, ByteType )
13353:    oScopeDeclare( t )
      
13359:    t = @newIdent( nTypeDecl, oId_Pointer )
13372:    oNodeSet( t, qType, UniversalPointerType )
13384:    oScopeDeclare( t )
      
13390:    t = @newIdent( nTypeDecl, oId_ShortString )
13403:    oNodeSet( t, qType, ShortStringType )
13415:    oScopeDeclare( t )
      
         % Built-in constants
      
13421:    t = @newIdent( nConst, oId_True )
13434:    oNodeSet( t, qType, BooleanType )
13446:    oNodeSetInt( t, qValue, 1 )
13458:    oScopeDeclare( t )
      
13464:    t = @newIdent( nConst, oId_False )
13477:    oNodeSet( t, qType, BooleanType )
13489:    oNodeSetInt( t, qValue, 0 )
13501:    oScopeDeclare( t )
      
13507:    t = @newIdent( nConst, oId_Nil )
13520:    oNodeSet( t, qType, UniversalPointerType )
13532:    oNodeSetInt( t, qValue, 0 )
13544:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
13550:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
13560:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
13570:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
13580:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
13591:    ;
      
13591: end
      
13591: 

Generated code:

   0: oGlobalSpace 22
   2: oLocalSpace 0
   4: oCall 12287
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          13     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 5
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 19
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 20
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 21
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 20
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 25
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 24
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 60
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 5
 565: oInput 61
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          59    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 62
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          59    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          63    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          64    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 36
 804: oInput 20
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2513
 844: oJumpForward 920
 846: oCall 3171
 848: oJumpForward 920
 850: oSetResult 21
 852: oPushResult
 853: oCall 3227
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1480
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 5
 876: oJumpForward 881
 878: Choice Lookup Table
          70    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1854
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 5
 900: oJumpForward 905
 902: Choice Lookup Table
          70    891
 905: oJumpForward 920
 907: Choice Lookup Table
          30    883
          29    859
          33    850
          32    846
          31    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 21
 934: oPushResult
 935: oCall 12615
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 77
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 67
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 90
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 8078
1083: oInputChoice 1089
1085: oCall 8078
1087: oJumpForward 1094
1089: Choice Lookup Table
           5   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 66
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 77
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 67
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 90
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 8078
1177: oInputChoice 1183
1179: oCall 8078
1181: oJumpForward 1188
1183: Choice Lookup Table
           5   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 66
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 61
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 64
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 63
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 61
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 64
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 63
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 5
1408: oJumpForward 1415
1410: Choice Lookup Table
          72   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 12928
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 23
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 2
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          71   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           2   1454
1479: oReturn
1480: oLocalSpace 6
1482: oInput 0
1484: oGetAddrLocal 1
1486: oPushResult
1487: oSetResult 0
1489: oAssign
1490: oGetAddrLocal 2
1492: oPushResult
1493: oScopeFindInCurrentScope
1494: oAssign
1495: oGetLocal 2
1497: oPushResult
1498: oNodeNull
1499: oPop 1
1501: oChoice 1619
1503: oGetAddrLocal 2
1505: oPushResult
1506: oSetResult 12
1508: oPushResult
1509: LAST_ID
1510: oPushResult
1511: oCall 12966
1513: oPop 2
1515: oAssign
1516: oGetLocal 2
1518: oPushResult
1519: oSetResult 22
1521: oPushResult
1522: oLabelNew
1523: oPushResult
1524: oNodeSetLabel
1525: oPop 3
1527: oJumpForward 1625
1529: oGetAddrLocal 1
1531: oPushResult
1532: oSetResult 1
1534: oAssign
1535: oGetLocal 2
1537: oPushResult
1538: oSetResult 24
1540: oPushResult
1541: oNodeGetBoolean
1542: oPop 2
1544: oChoice 1550
1546: oError 21
1548: oJumpForward 1553
1550: Choice Lookup Table
           1   1546
1553: oGetLocal 2
1555: oPushResult
1556: oSetResult 25
1558: oPushResult
1559: oNodeGetBoolean
1560: oPop 2
1562: oChoice 1568
1564: oError 21
1566: oJumpForward 1571
1568: Choice Lookup Table
           1   1564
1571: oGetLocal 2
1573: oPushResult
1574: oNodeType
1575: oPop 1
1577: oChoice 1581
1579: oJumpForward 1586
1581: Choice Lookup Table
          12   1579
1584: oError 21
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 29
1591: oPushResult
1592: oGetLocal 2
1594: oPushResult
1595: oSetResult 23
1597: oPushResult
1598: oNodeGet
1599: oPop 2
1601: oPushResult
1602: oNodeSet
1603: oPop 3
1605: oGetLocal 2
1607: oPushResult
1608: oSetResult 23
1610: oPushResult
1611: oSetResult 0
1613: oPushResult
1614: oNodeSet
1615: oPop 3
1617: oJumpForward 1625
1619: Choice Lookup Table
           0   1529
           1   1503
1624: oEndChoice
1625: oGetAddrLocal 3
1627: oPushResult
1628: oCall 12916
1630: oAssign
1631: oGetAddrLocal 4
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oSetResult 0
1639: oPushResult
1640: greater
1641: oPop 2
1643: oAssign
1644: oGetAddrLocal 3
1646: oPushResult
1647: inc
1648: oPop 1
1650: oGetLocal 3
1652: oPushResult
1653: oSetResult 2
1655: oPushResult
1656: oScopeBegin
1657: oPop 2
1659: oGetAddrLocal 5
1661: oPushResult
1662: oScopeCurrent
1663: oAssign
1664: oGetLocal 4
1666: oChoice 1685
1668: oGetAddrLocal 6
1670: oPushResult
1671: oGetGlobal 6
1673: oPushResult
1674: oCall 12013
1676: oPop 1
1678: oPushResult
1679: oScopeAllocType
1680: oPop 1
1682: oAssign
1683: oJumpForward 1688
1685: Choice Lookup Table
           1   1668
1688: oCall 2289
1690: oGetLocal 2
1692: oPushResult
1693: oSetResult 23
1695: oPushResult
1696: oGetLocal 5
1698: oPushResult
1699: oNodeSet
1700: oPop 3
1702: oScopeEnd
1703: oInput 5
1705: oGetLocal 1
1707: oChoice 1719
1709: oGetLocal 2
1711: oPushResult
1712: oScopeDeclare
1713: oPop 1
1715: oJumpForward 1725
1717: oJumpForward 1725
1719: Choice Lookup Table
           1   1717
           0   1709
1724: oEndChoice
1725: oGetLocal 2
1727: oPushResult
1728: oCall 1390
1730: oPop 1
1732: oGetLocal 2
1734: oReturn
1735: oReturn
1736: oLocalSpace 4
1738: oGetAddrLocal 1
1740: oPushResult
1741: oCall 1480
1743: oAssign
1744: oInputChoice 1757
1746: oJumpForward 1851
1748: oGetLocal 1
1750: oPushResult
1751: oCall 1418
1753: oPop 1
1755: oJumpForward 1851
1757: Choice Lookup Table
          70   1748
          69   1746
1762: oGetAddrLocal 2
1764: oPushResult
1765: oGetLocal 1
1767: oPushResult
1768: oSetResult 23
1770: oPushResult
1771: oNodeGet
1772: oPop 2
1774: oAssign
1775: oGetLocal 2
1777: oPushResult
1778: oScopeEnter
1779: oPop 1
1781: oGetAddrLocal 3
1783: oPushResult
1784: oGetLocal 2
1786: oPushResult
1787: oSetResult 14
1789: oPushResult
1790: oNodeGetInt
1791: oPop 2
1793: oAssign
1794: oGetLocal 3
1796: oPushResult
1797: oSetResult 1
1799: oPushResult
1800: oScopeBegin
1801: oPop 2
1803: oGetLocal 1
1805: oPushResult
1806: oSetResult 6
1808: oPushResult
1809: oScopeCurrent
1810: oPushResult
1811: oNodeSet
1812: oPop 3
1814: oGetAddrLocal 4
1816: oPushResult
1817: oGetLocal 1
1819: oPushResult
1820: oSetResult 22
1822: oPushResult
1823: oNodeGetLabel
1824: oPop 2
1826: oAssign
1827: oSetResult 22
1829: oPushResult
1830: oGetLocal 4
1832: oPushResult
1833: oCall 12591
1835: oPop 2
1837: oGetLocal 1
1839: oPushResult
1840: oSetResult 24
1842: oPushResult
1843: oSetResult 1
1845: oPushResult
1846: oNodeSetBoolean
1847: oPop 3
1849: oScopeEnd
1850: oScopeEnd
1851: oInput 5
1853: oReturn
1854: oLocalSpace 8
1856: oInput 0
1858: oGetAddrLocal 1
1860: oPushResult
1861: oSetResult 0
1863: oAssign
1864: oGetAddrLocal 2
1866: oPushResult
1867: oScopeFindInCurrentScope
1868: oAssign
1869: oGetLocal 2
1871: oPushResult
1872: oNodeNull
1873: oPop 1
1875: oChoice 2006
1877: oGetAddrLocal 2
1879: oPushResult
1880: oSetResult 13
1882: oPushResult
1883: LAST_ID
1884: oPushResult
1885: oCall 12966
1887: oPop 2
1889: oAssign
1890: oGetLocal 2
1892: oPushResult
1893: oSetResult 22
1895: oPushResult
1896: oLabelNew
1897: oPushResult
1898: oNodeSetLabel
1899: oPop 3
1901: oJumpForward 2012
1903: oGetAddrLocal 1
1905: oPushResult
1906: oSetResult 1
1908: oAssign
1909: oGetLocal 2
1911: oPushResult
1912: oSetResult 24
1914: oPushResult
1915: oNodeGetBoolean
1916: oPop 2
1918: oChoice 1924
1920: oError 21
1922: oJumpForward 1927
1924: Choice Lookup Table
           1   1920
1927: oGetLocal 2
1929: oPushResult
1930: oNodeType
1931: oPop 1
1933: oChoice 1937
1935: oJumpForward 1942
1937: Choice Lookup Table
          13   1935
1940: oError 21
1942: oGetLocal 2
1944: oPushResult
1945: oSetResult 29
1947: oPushResult
1948: oGetLocal 2
1950: oPushResult
1951: oSetResult 23
1953: oPushResult
1954: oNodeGet
1955: oPop 2
1957: oPushResult
1958: oNodeSet
1959: oPop 3
1961: oGetLocal 2
1963: oPushResult
1964: oSetResult 23
1966: oPushResult
1967: oSetResult 0
1969: oPushResult
1970: oNodeSet
1971: oPop 3
1973: oGetLocal 2
1975: oPushResult
1976: oSetResult 30
1978: oPushResult
1979: oGetLocal 2
1981: oPushResult
1982: oSetResult 21
1984: oPushResult
1985: oNodeGet
1986: oPop 2
1988: oPushResult
1989: oNodeSet
1990: oPop 3
1992: oGetLocal 2
1994: oPushResult
1995: oSetResult 21
1997: oPushResult
1998: oSetResult 0
2000: oPushResult
2001: oNodeSet
2002: oPop 3
2004: oJumpForward 2012
2006: Choice Lookup Table
           0   1903
           1   1877
2011: oEndChoice
2012: oGetAddrLocal 3
2014: oPushResult
2015: oCall 12916
2017: oAssign
2018: oGetAddrLocal 4
2020: oPushResult
2021: oGetLocal 3
2023: oPushResult
2024: oSetResult 0
2026: oPushResult
2027: greater
2028: oPop 2
2030: oAssign
2031: oGetAddrLocal 3
2033: oPushResult
2034: inc
2035: oPop 1
2037: oGetLocal 3
2039: oPushResult
2040: oSetResult 2
2042: oPushResult
2043: oScopeBegin
2044: oPop 2
2046: oGetAddrLocal 5
2048: oPushResult
2049: oScopeCurrent
2050: oAssign
2051: oGetLocal 4
2053: oChoice 2072
2055: oGetAddrLocal 6
2057: oPushResult
2058: oGetGlobal 6
2060: oPushResult
2061: oCall 12013
2063: oPop 1
2065: oPushResult
2066: oScopeAllocType
2067: oPop 1
2069: oAssign
2070: oJumpForward 2075
2072: Choice Lookup Table
           1   2055
2075: oCall 2289
2077: oGetLocal 2
2079: oPushResult
2080: oSetResult 23
2082: oPushResult
2083: oGetLocal 5
2085: oPushResult
2086: oNodeSet
2087: oPop 3
2089: oInput 12
2091: oGetAddrLocal 7
2093: oPushResult
2094: oCall 10934
2096: oPop 1
2098: oGetLocal 2
2100: oPushResult
2101: oSetResult 21
2103: oPushResult
2104: oGetLocal 7
2106: oPushResult
2107: oNodeSet
2108: oPop 3
2110: oGetAddrLocal 8
2112: oPushResult
2113: oGetLocal 7
2115: oPushResult
2116: oCall 12013
2118: oPop 1
2120: oAssign
2121: oGetLocal 2
2123: oPushResult
2124: oSetResult 31
2126: oPushResult
2127: oGetLocal 8
2129: oPushResult
2130: oScopeAllocType
2131: oPop 1
2133: oPushResult
2134: oNodeSetInt
2135: oPop 3
2137: oScopeEnd
2138: oInput 5
2140: oGetLocal 1
2142: oChoice 2154
2144: oGetLocal 2
2146: oPushResult
2147: oScopeDeclare
2148: oPop 1
2150: oJumpForward 2160
2152: oJumpForward 2160
2154: Choice Lookup Table
           1   2152
           0   2144
2159: oEndChoice
2160: oGetLocal 2
2162: oPushResult
2163: oCall 1390
2165: oPop 1
2167: oGetLocal 2
2169: oReturn
2170: oReturn
2171: oLocalSpace 4
2173: oGetAddrLocal 1
2175: oPushResult
2176: oCall 1854
2178: oAssign
2179: oInputChoice 2192
2181: oJumpForward 2286
2183: oGetLocal 1
2185: oPushResult
2186: oCall 1418
2188: oPop 1
2190: oJumpForward 2286
2192: Choice Lookup Table
          70   2183
          69   2181
2197: oGetAddrLocal 2
2199: oPushResult
2200: oGetLocal 1
2202: oPushResult
2203: oSetResult 23
2205: oPushResult
2206: oNodeGet
2207: oPop 2
2209: oAssign
2210: oGetLocal 2
2212: oPushResult
2213: oScopeEnter
2214: oPop 1
2216: oGetAddrLocal 3
2218: oPushResult
2219: oGetLocal 2
2221: oPushResult
2222: oSetResult 14
2224: oPushResult
2225: oNodeGetInt
2226: oPop 2
2228: oAssign
2229: oGetLocal 3
2231: oPushResult
2232: oSetResult 1
2234: oPushResult
2235: oScopeBegin
2236: oPop 2
2238: oGetLocal 1
2240: oPushResult
2241: oSetResult 6
2243: oPushResult
2244: oScopeCurrent
2245: oPushResult
2246: oNodeSet
2247: oPop 3
2249: oGetAddrLocal 4
2251: oPushResult
2252: oGetLocal 1
2254: oPushResult
2255: oSetResult 22
2257: oPushResult
2258: oNodeGetLabel
2259: oPop 2
2261: oAssign
2262: oSetResult 22
2264: oPushResult
2265: oGetLocal 4
2267: oPushResult
2268: oCall 12591
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 24
2277: oPushResult
2278: oSetResult 1
2280: oPushResult
2281: oNodeSetBoolean
2282: oPop 3
2284: oScopeEnd
2285: oScopeEnd
2286: oInput 5
2288: oReturn
2289: oLocalSpace 6
2291: oInputChoice 2509
2293: oGetAddrLocal 1
2295: oPushResult
2296: oNodeVecNew
2297: oAssign
2298: oGetAddrLocal 3
2300: oPushResult
2301: oSetResult 0
2303: oAssign
2304: oInputChoice 2314
2306: oGetAddrLocal 3
2308: oPushResult
2309: oSetResult 1
2311: oAssign
2312: oJumpForward 2317
2314: Choice Lookup Table
          33   2306
2317: oInput 0
2319: oGetAddrLocal 2
2321: oPushResult
2322: oSetResult 24
2324: oPushResult
2325: LAST_ID
2326: oPushResult
2327: oCall 12966
2329: oPop 2
2331: oAssign
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 34
2337: oPushResult
2338: oGetLocal 3
2340: oPushResult
2341: oNodeSetBoolean
2342: oPop 3
2344: oGetLocal 1
2346: oPushResult
2347: oGetLocal 2
2349: oPushResult
2350: oNodeVecAppend
2351: oPop 2
2353: oInputChoice 2361
2355: oJumpForward 2369
2357: oJumpForward 2367
2359: oJumpForward 2367
2361: Choice Lookup Table
          13   2359
          12   2355
2366: oEndChoice
2367: oJumpBack 2317
2369: oGetAddrLocal 4
2371: oPushResult
2372: oCall 10934
2374: oPop 1
2376: oGetLocal 3
2378: oChoice 2393
2380: oGetAddrLocal 5
2382: oPushResult
2383: oGetLocal 4
2385: oPushResult
2386: oCall 12013
2388: oPop 1
2390: oAssign
2391: oJumpForward 2402
2393: Choice Lookup Table
           1   2380
2396: oGetAddrLocal 5
2398: oPushResult
2399: oGetLocal 4
2401: oAssign
2402: oGetAddrLocal 6
2404: oPushResult
2405: oSetResult 0
2407: oAssign
2408: oGetLocal 6
2410: oPushResult
2411: oGetLocal 1
2413: oPushResult
2414: oNodeVecSize
2415: oPop 1
2417: oPushResult
2418: equal
2419: oPop 2
2421: oChoice 2478
2423: oGetAddrLocal 2
2425: oPushResult
2426: oGetLocal 1
2428: oPushResult
2429: oGetLocal 6
2431: oPushResult
2432: oNodeVecElement
2433: oPop 2
2435: oAssign
2436: oGetLocal 2
2438: oPushResult
2439: oSetResult 21
2441: oPushResult
2442: oGetLocal 4
2444: oPushResult
2445: oNodeSet
2446: oPop 3
2448: oGetLocal 2
2450: oPushResult
2451: oScopeDeclare
2452: oPop 1
2454: oGetLocal 2
2456: oPushResult
2457: oSetResult 22
2459: oPushResult
2460: oGetLocal 5
2462: oPushResult
2463: oScopeAllocType
2464: oPop 1
2466: oPushResult
2467: oNodeSetInt
2468: oPop 3
2470: oGetAddrLocal 6
2472: oPushResult
2473: inc
2474: oPop 1
2476: oJumpForward 2483
2478: Choice Lookup Table
           0   2423
2481: oJumpForward 2485
2483: oJumpBack 2408
2485: oGetLocal 1
2487: oPushResult
2488: oNodeVecDelete
2489: oPop 1
2491: oInputChoice 2499
2493: oJumpForward 2507
2495: oJumpForward 2505
2497: oJumpForward 2505
2499: Choice Lookup Table
           5   2497
          15   2493
2504: oEndChoice
2505: oJumpBack 2293
2507: oJumpForward 2512
2509: Choice Lookup Table
          14   2293
2512: oReturn
2513: oLocalSpace 0
2515: oInputChoice 2530
2517: oInputChoice 2523
2519: oCall 2647
2521: oJumpForward 2528
2523: Choice Lookup Table
          12   2519
2526: oCall 2538
2528: oJumpForward 2535
2530: Choice Lookup Table
           0   2517
2533: oJumpForward 2537
2535: oJumpBack 2515
2537: oReturn
2538: oLocalSpace 2
2540: oGetAddrLocal 1
2542: oPushResult
2543: LAST_ID
2544: oAssign
2545: oInput 6
2547: oCall 3526
2549: oTypeSNodeType
2550: oChoice 2606
2552: oGetAddrLocal 2
2554: oPushResult
2555: oSetResult 16
2557: oPushResult
2558: oGetLocal 1
2560: oPushResult
2561: oCall 12966
2563: oPop 2
2565: oAssign
2566: oGetLocal 2
2568: oPushResult
2569: oSetResult 22
2571: oPushResult
2572: oValueTop
2573: oPushResult
2574: oNodeSetInt
2575: oPop 3
2577: oJumpForward 2625
2579: oGetAddrLocal 2
2581: oPushResult
2582: oSetResult 18
2584: oPushResult
2585: oGetLocal 1
2587: oPushResult
2588: oCall 12966
2590: oPop 2
2592: oAssign
2593: oGetLocal 2
2595: oPushResult
2596: oSetResult 33
2598: oPushResult
2599: oValueTopString
2600: oPushResult
2601: oNodeSetString
2602: oPop 3
2604: oJumpForward 2625
2606: Choice Lookup Table
          39   2579
          35   2552
          34   2552
          41   2552
          29   2552
          33   2552
          30   2552
          31   2552
2623: oError 17
2625: oValuePop
2626: oGetLocal 2
2628: oPushResult
2629: oSetResult 21
2631: oPushResult
2632: oTypeSTop
2633: oPushResult
2634: oNodeSet
2635: oPop 3
2637: oTypeSPop
2638: oGetLocal 2
2640: oPushResult
2641: oScopeDeclare
2642: oPop 1
2644: oInput 5
2646: oReturn
2647: oLocalSpace 3
2649: oGetAddrLocal 1
2651: oPushResult
2652: oSetResult 25
2654: oPushResult
2655: LAST_ID
2656: oPushResult
2657: oCall 12966
2659: oPop 2
2661: oAssign
2662: oGetAddrLocal 2
2664: oPushResult
2665: oCall 10934
2667: oPop 1
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 21
2674: oPushResult
2675: oGetLocal 2
2677: oPushResult
2678: oNodeSet
2679: oPop 3
2681: oGetLocal 2
2683: oPushResult
2684: oNodeType
2685: oPop 1
2687: oChoice 2791
2689: oInput 6
2691: oGetLocal 2
2693: oPushResult
2694: oTypeSPush
2695: oPop 1
2697: oCall 3526
2699: oCall 4268
2701: oGetLocal 1
2703: oPushResult
2704: oSetResult 22
2706: oPushResult
2707: oValueTop
2708: oPushResult
2709: oNodeSetInt
2710: oPop 3
2712: oValuePop
2713: oTypeSPop
2714: oGetLocal 1
2716: oPushResult
2717: oScopeDeclare
2718: oPop 1
2720: oInput 5
2722: oJumpForward 2815
2724: oError 16
2726: oJumpForward 2815
2728: oGetGlobal 2
2730: oPushResult
2731: oScopeEnter
2732: oPop 1
2734: oGetAddrLocal 3
2736: oPushResult
2737: oGetLocal 2
2739: oPushResult
2740: oScopeAllocType
2741: oPop 1
2743: oAssign
2744: oScopeEnd
2745: oGetGlobal 2
2747: oPushResult
2748: oCall 12864
2750: oPop 1
2752: oPushResult
2753: oCodePush
2754: oPop 1
2756: oGetLocal 1
2758: oPushResult
2759: oSetResult 22
2761: oPushResult
2762: oGetLocal 3
2764: oPushResult
2765: oNodeSetInt
2766: oPop 3
2768: oInput 6
2770: oGetLocal 2
2772: oPushResult
2773: oGetLocal 3
2775: oPushResult
2776: oCall 2816
2778: oPop 2
2780: oCodePop
2781: oGetLocal 1
2783: oPushResult
2784: oScopeDeclare
2785: oPop 1
2787: oInput 5
2789: oJumpForward 2815
2791: Choice Lookup Table
          38   2728
          36   2728
          28   2724
          40   2724
          35   2689
          34   2689
          41   2689
          29   2689
          33   2689
          30   2689
          31   2689
2814: oEndChoice
2815: oReturn
2816: oLocalSpace 10
2818: oGetParam 2
2820: oPushResult
2821: oNodeType
2822: oPop 1
2824: oChoice 3146
2826: oGetAddrLocal 1
2828: oPushResult
2829: oGetParam 2
2831: oPushResult
2832: oSetResult 37
2834: oPushResult
2835: oNodeGet
2836: oPop 2
2838: oAssign
2839: oGetAddrLocal 2
2841: oPushResult
2842: oGetParam 2
2844: oPushResult
2845: oSetResult 38
2847: oPushResult
2848: oNodeGet
2849: oPop 2
2851: oAssign
2852: oGetAddrLocal 3
2854: oPushResult
2855: oGetLocal 2
2857: oPushResult
2858: oCall 12097
2860: oPop 1
2862: oAssign
2863: oGetAddrLocal 4
2865: oPushResult
2866: oGetLocal 2
2868: oPushResult
2869: oCall 12192
2871: oPop 1
2873: oAssign
2874: oGetAddrLocal 5
2876: oPushResult
2877: oGetLocal 1
2879: oPushResult
2880: oSetResult 17
2882: oPushResult
2883: oNodeGetInt
2884: oPop 2
2886: oAssign
2887: oInput 14
2889: oGetAddrLocal 6
2891: oPushResult
2892: oGetLocal 3
2894: oAssign
2895: oGetLocal 1
2897: oPushResult
2898: oGetParam 1
2900: oPushResult
2901: oCall 2816
2903: oPop 2
2905: oGetLocal 6
2907: oPushResult
2908: oGetLocal 4
2910: oPushResult
2911: equal
2912: oPop 2
2914: oChoice 2922
2916: oJumpForward 2951
2918: oJumpForward 2928
2920: oJumpForward 2928
2922: Choice Lookup Table
           0   2920
           1   2916
2927: oEndChoice
2928: oInput 13
2930: oGetAddrParam 1
2932: oPushResult
2933: oGetParam 1
2935: oPushResult
2936: oGetLocal 5
2938: oPushResult
2939: add
2940: oPop 2
2942: oAssign
2943: oGetAddrLocal 6
2945: oPushResult
2946: inc
2947: oPop 1
2949: oJumpBack 2895
2951: oInput 15
2953: oJumpForward 3170
2955: oInput 14
2957: oGetAddrLocal 7
2959: oPushResult
2960: oGetParam 2
2962: oPushResult
2963: oSetResult 41
2965: oPushResult
2966: oNodeGet
2967: oPop 2
2969: oAssign
2970: oInputChoice 2974
2972: oJumpForward 2979
2974: Choice Lookup Table
           0   2972
2977: oJumpForward 3045
2979: oGetAddrLocal 8
2981: oPushResult
2982: oGetLocal 7
2984: oPushResult
2985: oScopeFindRequireInScope
2986: oPop 1
2988: oAssign
2989: oInput 12
2991: oGetAddrLocal 9
2993: oPushResult
2994: oGetLocal 8
2996: oPushResult
2997: oSetResult 21
2999: oPushResult
3000: oNodeGet
3001: oPop 2
3003: oAssign
3004: oGetAddrLocal 10
3006: oPushResult
3007: oGetParam 1
3009: oPushResult
3010: oGetLocal 8
3012: oPushResult
3013: oSetResult 22
3015: oPushResult
3016: oNodeGetInt
3017: oPop 2
3019: oPushResult
3020: add
3021: oPop 2
3023: oAssign
3024: oGetLocal 9
3026: oPushResult
3027: oGetLocal 10
3029: oPushResult
3030: oCall 2816
3032: oPop 2
3034: oInputChoice 3038
3036: oJumpForward 3043
3038: Choice Lookup Table
           5   3036
3041: oJumpForward 3045
3043: oJumpBack 2970
3045: oInput 15
3047: oJumpForward 3170
3049: oEmit 16
3051: oGetParam 1
3053: oPushResult
3054: oEmitInt
3055: oPop 1
3057: oGetParam 2
3059: oPushResult
3060: oTypeSPush
3061: oPop 1
3063: oCall 3526
3065: oCall 4268
3067: oEmit 15
3069: oValueTop
3070: oPushResult
3071: oEmitInt
3072: oPop 1
3074: oValuePop
3075: oTypeSPop
3076: oEmit 27
3078: oJumpForward 3170
3080: oEmit 16
3082: oGetParam 1
3084: oPushResult
3085: oEmitInt
3086: oPop 1
3088: oGetParam 2
3090: oPushResult
3091: oTypeSPush
3092: oPop 1
3094: oCall 3526
3096: oCall 4268
3098: oEmit 15
3100: oValueTop
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oValuePop
3106: oTypeSPop
3107: oEmit 26
3109: oJumpForward 3170
3111: oEmit 16
3113: oGetParam 1
3115: oPushResult
3116: oEmitInt
3117: oPop 1
3119: oGetParam 2
3121: oPushResult
3122: oTypeSPush
3123: oPop 1
3125: oCall 3526
3127: oCall 4268
3129: oEmit 15
3131: oValueTop
3132: oPushResult
3133: oEmitInt
3134: oPop 1
3136: oValuePop
3137: oTypeSPop
3138: oEmit 28
3140: oJumpForward 3170
3142: oError 16
3144: oJumpForward 3170
3146: Choice Lookup Table
          28   3142
          40   3142
          35   3111
          34   3111
          41   3080
          29   3080
          33   3049
          30   3049
          31   3049
          38   2955
          36   2826
3169: oEndChoice
3170: oReturn
3171: oLocalSpace 2
3173: oInputChoice 3219
3175: oGetAddrLocal 1
3177: oPushResult
3178: oSetResult 19
3180: oPushResult
3181: LAST_ID
3182: oPushResult
3183: oCall 12966
3185: oPop 2
3187: oAssign
3188: oInput 6
3190: oGetAddrLocal 2
3192: oPushResult
3193: oCall 10934
3195: oPop 1
3197: oGetLocal 1
3199: oPushResult
3200: oSetResult 21
3202: oPushResult
3203: oGetLocal 2
3205: oPushResult
3206: oNodeSet
3207: oPop 3
3209: oGetLocal 1
3211: oPushResult
3212: oScopeDeclare
3213: oPop 1
3215: oInput 5
3217: oJumpForward 3224
3219: Choice Lookup Table
           0   3175
3222: oJumpForward 3226
3224: oJumpBack 3173
3226: oReturn
3227: oLocalSpace 6
3229: oInputChoice 3453
3231: oGetAddrLocal 1
3233: oPushResult
3234: oNodeVecNew
3235: oAssign
3236: oGetAddrLocal 2
3238: oPushResult
3239: oGetParam 1
3241: oPushResult
3242: LAST_ID
3243: oPushResult
3244: oCall 12966
3246: oPop 2
3248: oAssign
3249: oGetLocal 1
3251: oPushResult
3252: oGetLocal 2
3254: oPushResult
3255: oNodeVecAppend
3256: oPop 2
3258: oInputChoice 3264
3260: oInput 0
3262: oJumpForward 3269
3264: Choice Lookup Table
          13   3260
3267: oJumpForward 3271
3269: oJumpBack 3236
3271: oInput 12
3273: oGetAddrLocal 3
3275: oPushResult
3276: oCall 10934
3278: oPop 1
3280: oGetAddrLocal 4
3282: oPushResult
3283: oSetResult 0
3285: oAssign
3286: oGetLocal 4
3288: oPushResult
3289: oGetLocal 1
3291: oPushResult
3292: oNodeVecSize
3293: oPop 1
3295: oPushResult
3296: equal
3297: oPop 2
3299: oChoice 3340
3301: oGetAddrLocal 2
3303: oPushResult
3304: oGetLocal 1
3306: oPushResult
3307: oGetLocal 4
3309: oPushResult
3310: oNodeVecElement
3311: oPop 2
3313: oAssign
3314: oGetLocal 2
3316: oPushResult
3317: oSetResult 21
3319: oPushResult
3320: oGetLocal 3
3322: oPushResult
3323: oNodeSet
3324: oPop 3
3326: oGetLocal 2
3328: oPushResult
3329: oScopeDeclareAlloc
3330: oPop 1
3332: oGetAddrLocal 4
3334: oPushResult
3335: inc
3336: oPop 1
3338: oJumpForward 3345
3340: Choice Lookup Table
           0   3301
3343: oJumpForward 3347
3345: oJumpBack 3286
3347: oInputChoice 3440
3349: oGetLocal 1
3351: oPushResult
3352: oNodeVecSize
3353: oPop 1
3355: oChoice 3359
3357: oJumpForward 3364
3359: Choice Lookup Table
           1   3357
3362: oError 22
3364: oGetAddrLocal 5
3366: oPushResult
3367: oScopeCurrent
3368: oPushResult
3369: oCall 12864
3371: oPop 1
3373: oAssign
3374: oGetLocal 5
3376: oPushResult
3377: oCodePush
3378: oPop 1
3380: oGetAddrLocal 6
3382: oPushResult
3383: oSetResult 0
3385: oAssign
3386: oCall 12916
3388: oPushResult
3389: equal_zero
3390: oPop 1
3392: oChoice 3408
3394: oGetGlobal 3
3396: oPushResult
3397: oScopeEnter
3398: oPop 1
3400: oGetAddrLocal 6
3402: oPushResult
3403: oSetResult 1
3405: oAssign
3406: oJumpForward 3411
3408: Choice Lookup Table
           1   3394
3411: oGetLocal 2
3413: oPushResult
3414: oSetResult 1
3416: oPushResult
3417: oCall 8566
3419: oPop 2
3421: oCall 4558
3423: oCall 7748
3425: oCall 8322
3427: oGetLocal 6
3429: oChoice 3434
3431: oScopeEnd
3432: oJumpForward 3437
3434: Choice Lookup Table
           1   3431
3437: oCodePop
3438: oJumpForward 3443
3440: Choice Lookup Table
           6   3349
3443: oGetLocal 1
3445: oPushResult
3446: oNodeVecDelete
3447: oPop 1
3449: oInput 5
3451: oJumpForward 3458
3453: Choice Lookup Table
           0   3231
3456: oJumpForward 3460
3458: oJumpBack 3229
3460: oReturn
3461: oLocalSpace 2
3463: oInputChoice 3470
3465: oJumpForward 3476
3467: oChangeIntLitToLabelIdent
3468: oJumpForward 3476
3470: Choice Lookup Table
           1   3467
           0   3465
3475: oEndChoice
3476: oGetAddrLocal 1
3478: oPushResult
3479: oSetResult 26
3481: oPushResult
3482: LAST_ID
3483: oPushResult
3484: oCall 12966
3486: oPop 2
3488: oAssign
3489: oGetAddrLocal 2
3491: oPushResult
3492: oLabelNew
3493: oAssign
3494: oGetLocal 1
3496: oPushResult
3497: oSetResult 22
3499: oPushResult
3500: oGetLocal 2
3502: oPushResult
3503: oNodeSetLabel
3504: oPop 3
3506: oGetLocal 1
3508: oPushResult
3509: oScopeDeclare
3510: oPop 1
3512: oInputChoice 3516
3514: oJumpForward 3521
3516: Choice Lookup Table
          13   3514
3519: oJumpForward 3523
3521: oJumpBack 3463
3523: oInput 5
3525: oReturn
3526: oLocalSpace 0
3528: oCall 3730
3530: oInputChoice 3712
3532: oCall 3753
3534: oCall 4171
3536: oTypeSNodeType
3537: oChoice 3549
3539: oValueStringCmp
3540: oSetResult 0
3542: oPushResult
3543: oValuePush
3544: oPop 1
3546: oValueEqual
3547: oJumpForward 3553
3549: Choice Lookup Table
          39   3539
3552: oValueEqual
3553: oTypeSPop
3554: oGetGlobal 7
3556: oPushResult
3557: oTypeSPush
3558: oPop 1
3560: oJumpForward 3727
3562: oCall 3730
3564: oCall 4171
3566: oTypeSNodeType
3567: oChoice 3579
3569: oValueStringCmp
3570: oSetResult 0
3572: oPushResult
3573: oValuePush
3574: oPop 1
3576: oValueNotEqual
3577: oJumpForward 3583
3579: Choice Lookup Table
          39   3569
3582: oValueNotEqual
3583: oTypeSPop
3584: oGetGlobal 7
3586: oPushResult
3587: oTypeSPush
3588: oPop 1
3590: oJumpForward 3727
3592: oCall 3730
3594: oCall 4171
3596: oTypeSNodeType
3597: oChoice 3609
3599: oValueStringCmp
3600: oSetResult 0
3602: oPushResult
3603: oValuePush
3604: oPop 1
3606: oValueLess
3607: oJumpForward 3613
3609: Choice Lookup Table
          39   3599
3612: oValueLess
3613: oTypeSPop
3614: oGetGlobal 7
3616: oPushResult
3617: oTypeSPush
3618: oPop 1
3620: oJumpForward 3727
3622: oCall 3730
3624: oCall 4171
3626: oTypeSNodeType
3627: oChoice 3639
3629: oValueStringCmp
3630: oSetResult 0
3632: oPushResult
3633: oValuePush
3634: oPop 1
3636: oValueGreater
3637: oJumpForward 3643
3639: Choice Lookup Table
          39   3629
3642: oValueGreater
3643: oTypeSPop
3644: oGetGlobal 7
3646: oPushResult
3647: oTypeSPush
3648: oPop 1
3650: oJumpForward 3727
3652: oCall 3730
3654: oCall 4171
3656: oTypeSNodeType
3657: oChoice 3669
3659: oValueStringCmp
3660: oSetResult 0
3662: oPushResult
3663: oValuePush
3664: oPop 1
3666: oValueLessEqual
3667: oJumpForward 3673
3669: Choice Lookup Table
          39   3659
3672: oValueLessEqual
3673: oTypeSPop
3674: oGetGlobal 7
3676: oPushResult
3677: oTypeSPush
3678: oPop 1
3680: oJumpForward 3727
3682: oCall 3730
3684: oCall 4171
3686: oTypeSNodeType
3687: oChoice 3699
3689: oValueStringCmp
3690: oSetResult 0
3692: oPushResult
3693: oValuePush
3694: oPop 1
3696: oValueGreaterEqual
3697: oJumpForward 3703
3699: Choice Lookup Table
          39   3689
3702: oValueGreaterEqual
3703: oTypeSPop
3704: oGetGlobal 7
3706: oPushResult
3707: oTypeSPush
3708: oPop 1
3710: oJumpForward 3727
3712: Choice Lookup Table
          11   3682
          10   3652
           9   3622
           8   3592
           7   3562
           6   3532
3725: oJumpForward 3729
3727: oJumpBack 3530
3729: oReturn
3730: oLocalSpace 0
3732: oCall 3753
3734: oInputChoice 3745
3736: oCall 4158
3738: oCall 3753
3740: oCall 4144
3742: oValueOr
3743: oJumpForward 3750
3745: Choice Lookup Table
          57   3736
3748: oJumpForward 3752
3750: oJumpBack 3734
3752: oReturn
3753: oLocalSpace 0
3755: oCall 3776
3757: oInputChoice 3768
3759: oCall 4158
3761: oCall 3776
3763: oCall 4144
3765: oValueAnd
3766: oJumpForward 3773
3768: Choice Lookup Table
          56   3759
3771: oJumpForward 3775
3773: oJumpBack 3757
3775: oReturn
3776: oLocalSpace 0
3778: oInputChoice 3787
3780: oCall 3776
3782: oCall 4158
3784: oValueNot
3785: oJumpForward 3792
3787: Choice Lookup Table
          58   3780
3790: oCall 3793
3792: oReturn
3793: oLocalSpace 0
3795: oCall 3842
3797: oInputChoice 3832
3799: oCall 3842
3801: oCall 4171
3803: oTypeSNodeType
3804: oChoice 3809
3806: oValueStringConcat
3807: oJumpForward 3813
3809: Choice Lookup Table
          39   3806
3812: oValueAdd
3813: oJumpForward 3839
3815: oCall 3842
3817: oCall 4171
3819: oTypeSNodeType
3820: oChoice 3826
3822: oError 17
3824: oJumpForward 3830
3826: Choice Lookup Table
          39   3822
3829: oValueSub
3830: oJumpForward 3839
3832: Choice Lookup Table
          25   3815
          24   3799
3837: oJumpForward 3841
3839: oJumpBack 3797
3841: oReturn
3842: oLocalSpace 0
3844: oCall 3892
3846: oInputChoice 3882
3848: oCall 3892
3850: oCall 4171
3852: oTypeSNodeType
3853: oChoice 3859
3855: oError 17
3857: oJumpForward 3863
3859: Choice Lookup Table
          39   3855
3862: oValueMult
3863: oJumpForward 3889
3865: oCall 3892
3867: oCall 4171
3869: oTypeSNodeType
3870: oChoice 3876
3872: oError 17
3874: oJumpForward 3880
3876: Choice Lookup Table
          39   3872
3879: oValueDiv
3880: oJumpForward 3889
3882: Choice Lookup Table
          23   3865
          22   3848
3887: oJumpForward 3891
3889: oJumpBack 3846
3891: oReturn
3892: oLocalSpace 0
3894: oInputChoice 3905
3896: oCall 3913
3898: oJumpForward 3912
3900: oCall 3913
3902: oValueNegate
3903: oJumpForward 3912
3905: Choice Lookup Table
          25   3900
          24   3896
3910: oCall 3913
3912: oReturn
3913: oLocalSpace 1
3915: oInputChoice 4116
3917: TOKEN_VALUE
3918: oPushResult
3919: oValuePush
3920: oPop 1
3922: oGetGlobal 6
3924: oPushResult
3925: oTypeSPush
3926: oPop 1
3928: oJumpForward 4143
3930: TOKEN_VALUE
3931: oPushResult
3932: oValuePush
3933: oPop 1
3935: oGetGlobal 9
3937: oPushResult
3938: oTypeSPush
3939: oPop 1
3941: oJumpForward 4143
3943: CURRENT_STRLIT
3944: oPushResult
3945: oValuePushString
3946: oPop 1
3948: oGetGlobal 13
3950: oPushResult
3951: oTypeSPush
3952: oPop 1
3954: oJumpForward 4143
3956: oCall 3526
3958: oInput 15
3960: oJumpForward 4143
3962: oGetAddrLocal 1
3964: oPushResult
3965: oScopeFindRequire
3966: oAssign
3967: oGetAddrLocal 1
3969: oPushResult
3970: oCall 244
3972: oPop 1
3974: oGetLocal 1
3976: oPushResult
3977: oNodeType
3978: oPop 1
3980: oChoice 4075
3982: oGetLocal 1
3984: oPushResult
3985: oCall 4341
3987: oPop 1
3989: oJumpForward 4098
3991: oGetLocal 1
3993: oPushResult
3994: oSetResult 22
3996: oPushResult
3997: oNodeGetInt
3998: oPop 2
4000: oPushResult
4001: oValuePush
4002: oPop 1
4004: oGetLocal 1
4006: oPushResult
4007: oSetResult 21
4009: oPushResult
4010: oNodeGet
4011: oPop 2
4013: oPushResult
4014: oTypeSPush
4015: oPop 1
4017: oJumpForward 4098
4019: oGetLocal 1
4021: oPushResult
4022: oSetResult 33
4024: oPushResult
4025: oNodeGetString
4026: oPop 2
4028: oPushResult
4029: oValuePushString
4030: oPop 1
4032: oGetLocal 1
4034: oPushResult
4035: oSetResult 21
4037: oPushResult
4038: oNodeGet
4039: oPop 2
4041: oPushResult
4042: oTypeSPush
4043: oPop 1
4045: oJumpForward 4098
4047: oGetLocal 1
4049: oPushResult
4050: oSetResult 22
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: oValuePush
4058: oPop 1
4060: oGetLocal 1
4062: oPushResult
4063: oSetResult 21
4065: oPushResult
4066: oNodeGet
4067: oPop 2
4069: oPushResult
4070: oTypeSPush
4071: oPop 1
4073: oJumpForward 4098
4075: Choice Lookup Table
          17   4047
          18   4019
          16   3991
          14   3982
4084: oError 1
4086: oSetResult 0
4088: oPushResult
4089: oValuePush
4090: oPop 1
4092: oGetGlobal 6
4094: oPushResult
4095: oTypeSPush
4096: oPop 1
4098: oJumpForward 4143
4100: oError 16
4102: oSetResult 0
4104: oPushResult
4105: oValuePush
4106: oPop 1
4108: oGetGlobal 12
4110: oPushResult
4111: oTypeSPush
4112: oPop 1
4114: oJumpForward 4143
4116: Choice Lookup Table
          19   4100
           0   3962
          14   3956
           2   3943
           3   3930
           1   3917
4129: oError 1
4131: oSetResult 0
4133: oPushResult
4134: oValuePush
4135: oPop 1
4137: oGetGlobal 6
4139: oPushResult
4140: oTypeSPush
4141: oPop 1
4143: oReturn
4144: oLocalSpace 0
4146: oTypeSNodeType
4147: oChoice 4151
4149: oJumpForward 4156
4151: Choice Lookup Table
          31   4149
4154: oError 8
4156: oTypeSPop
4157: oReturn
4158: oLocalSpace 0
4160: oTypeSNodeType
4161: oChoice 4165
4163: oJumpForward 4170
4165: Choice Lookup Table
          31   4163
4168: oError 8
4170: oReturn
4171: oLocalSpace 1
4173: oGetAddrLocal 1
4175: oPushResult
4176: oTypeSNodeType
4177: oAssign
4178: oTypeSPop
4179: oGetLocal 1
4181: oPushResult
4182: oTypeSNodeType
4183: oPushResult
4184: equal_node_type
4185: oPop 2
4187: oChoice 4264
4189: oTypeSNodeType
4190: oChoice 4251
4192: oGetLocal 1
4194: oChoice 4199
4196: oReturn
4197: oJumpForward 4202
4199: Choice Lookup Table
          35   4196
4202: oJumpForward 4260
4204: oGetLocal 1
4206: oChoice 4211
4208: oReturn
4209: oJumpForward 4214
4211: Choice Lookup Table
          34   4208
4214: oJumpForward 4260
4216: oGetLocal 1
4218: oChoice 4224
4220: oValueCharToString
4221: oReturn
4222: oJumpForward 4227
4224: Choice Lookup Table
          33   4220
4227: oJumpForward 4260
4229: oGetLocal 1
4231: oChoice 4246
4233: oValueSwap
4234: oValueCharToString
4235: oValueSwap
4236: oTypeSPop
4237: oGetGlobal 13
4239: oPushResult
4240: oTypeSPush
4241: oPop 1
4243: oReturn
4244: oJumpForward 4249
4246: Choice Lookup Table
          39   4233
4249: oJumpForward 4260
4251: Choice Lookup Table
          33   4229
          39   4216
          35   4204
          34   4192
4260: oError 14
4262: oJumpForward 4267
4264: Choice Lookup Table
           0   4189
4267: oReturn
4268: oLocalSpace 1
4270: oGetAddrLocal 1
4272: oPushResult
4273: oTypeSNodeType
4274: oAssign
4275: oTypeSPop
4276: oGetLocal 1
4278: oPushResult
4279: oTypeSNodeType
4280: oPushResult
4281: equal_node_type
4282: oPop 2
4284: oChoice 4337
4286: oTypeSNodeType
4287: oChoice 4326
4289: oGetLocal 1
4291: oChoice 4296
4293: oReturn
4294: oJumpForward 4299
4296: Choice Lookup Table
          35   4293
4299: oJumpForward 4333
4301: oGetLocal 1
4303: oChoice 4308
4305: oReturn
4306: oJumpForward 4311
4308: Choice Lookup Table
          34   4305
4311: oJumpForward 4333
4313: oGetLocal 1
4315: oChoice 4321
4317: oValueCharToString
4318: oReturn
4319: oJumpForward 4324
4321: Choice Lookup Table
          33   4317
4324: oJumpForward 4333
4326: Choice Lookup Table
          39   4313
          35   4301
          34   4289
4333: oError 14
4335: oJumpForward 4340
4337: Choice Lookup Table
           0   4286
4340: oReturn
4341: oLocalSpace 0
4343: oGetParam 1
4345: oPushResult
4346: oGetGlobal 15
4348: oPushResult
4349: oNodeEqual
4350: oPop 2
4352: oChoice 4392
4354: oInput 14
4356: oCall 3526
4358: oInput 15
4360: oTypeSNodeType
4361: oChoice 4367
4363: oJumpForward 4380
4365: oJumpForward 4380
4367: Choice Lookup Table
          33   4365
          30   4365
          31   4365
          41   4363
          29   4363
4378: oError 14
4380: oTypeSPop
4381: oGetGlobal 6
4383: oPushResult
4384: oTypeSPush
4385: oPop 1
4387: oInput 15
4389: oReturn
4390: oJumpForward 4395
4392: Choice Lookup Table
           1   4354
4395: oGetParam 1
4397: oPushResult
4398: oGetGlobal 16
4400: oPushResult
4401: oNodeEqual
4402: oPop 2
4404: oChoice 4438
4406: oInput 14
4408: oCall 3526
4410: oInput 15
4412: oTypeSNodeType
4413: oChoice 4419
4415: oJumpForward 4426
4417: oJumpForward 4426
4419: Choice Lookup Table
          30   4417
          29   4415
4424: oError 14
4426: oTypeSPop
4427: oGetGlobal 9
4429: oPushResult
4430: oTypeSPush
4431: oPop 1
4433: oInput 15
4435: oReturn
4436: oJumpForward 4441
4438: Choice Lookup Table
           1   4406
4441: oGetParam 1
4443: oPushResult
4444: oGetGlobal 17
4446: oPushResult
4447: oNodeEqual
4448: oPop 2
4450: oChoice 4495
4452: oInput 14
4454: oCall 3526
4456: oTypeSNodeType
4457: oChoice 4478
4459: oTypeSTop
4460: oPushResult
4461: oSetResult 44
4463: oPushResult
4464: oNodeGetBoolean
4465: oPop 2
4467: oChoice 4473
4469: oError 28
4471: oJumpForward 4476
4473: Choice Lookup Table
           1   4469
4476: oJumpForward 4483
4478: Choice Lookup Table
          41   4459
4481: oError 14
4483: oSetResult 1
4485: oPushResult
4486: oValuePush
4487: oPop 1
4489: oValueSub
4490: oInput 15
4492: oReturn
4493: oJumpForward 4498
4495: Choice Lookup Table
           1   4452
4498: oGetParam 1
4500: oPushResult
4501: oGetGlobal 18
4503: oPushResult
4504: oNodeEqual
4505: oPop 2
4507: oChoice 4552
4509: oInput 14
4511: oCall 3526
4513: oTypeSNodeType
4514: oChoice 4535
4516: oTypeSTop
4517: oPushResult
4518: oSetResult 44
4520: oPushResult
4521: oNodeGetBoolean
4522: oPop 2
4524: oChoice 4530
4526: oError 28
4528: oJumpForward 4533
4530: Choice Lookup Table
           1   4526
4533: oJumpForward 4540
4535: Choice Lookup Table
          41   4516
4538: oError 14
4540: oSetResult 1
4542: oPushResult
4543: oValuePush
4544: oPop 1
4546: oValueAdd
4547: oInput 15
4549: oReturn
4550: oJumpForward 4555
4552: Choice Lookup Table
           1   4509
4555: oError 16
4557: oReturn
4558: oLocalSpace 1
4560: oGetAddrLocal 1
4562: oPushResult
4563: oSetResult 0
4565: oAssign
4566: oGetAddrLocal 1
4568: oPushResult
4569: oCall 4719
4571: oPop 1
4573: oGetAddrLocal 1
4575: oPushResult
4576: oCall 4619
4578: oPop 1
4580: oReturn
4581: oLocalSpace 0
4583: oGetParam 1
4585: oPushResult
4586: oCall 4719
4588: oPop 1
4590: oTypeSNodeType
4591: oChoice 4610
4593: oJumpForward 4617
4595: oGetParam 1
4597: oPushResult
4598: oLabelNew
4599: oAssign
4600: oEmit 70
4602: oGetFromParam 1
4604: oPushResult
4605: oEmitLabel
4606: oPop 1
4608: oJumpForward 4617
4610: Choice Lookup Table
          31   4595
          32   4593
4615: oError 8
4617: oTypeSPop
4618: oReturn
4619: oLocalSpace 1
4621: oTypeSNodeType
4622: oChoice 4684
4624: oGetAddrLocal 1
4626: oPushResult
4627: oLabelNew
4628: oAssign
4629: oEmit 15
4631: oSetResult 1
4633: oPushResult
4634: oEmitInt
4635: oPop 1
4637: oEmit 68
4639: oGetLocal 1
4641: oPushResult
4642: oEmitLabel
4643: oPop 1
4645: oEmit 77
4647: oGetFromParam 1
4649: oPushResult
4650: oEmitLabel
4651: oPop 1
4653: oEmit 15
4655: oSetResult 0
4657: oPushResult
4658: oEmitInt
4659: oPop 1
4661: oEmit 77
4663: oGetLocal 1
4665: oPushResult
4666: oEmitLabel
4667: oPop 1
4669: oTypeSPop
4670: oGetGlobal 7
4672: oPushResult
4673: oTypeSPush
4674: oPop 1
4676: oGetParam 1
4678: oPushResult
4679: oSetResult 0
4681: oAssign
4682: oJumpForward 4687
4684: Choice Lookup Table
          32   4624
4687: oReturn
4688: oLocalSpace 0
4690: oTypeSNodeType
4691: oChoice 4715
4693: oGetParam 1
4695: oPushResult
4696: oLabelNew
4697: oAssign
4698: oEmit 70
4700: oGetFromParam 1
4702: oPushResult
4703: oEmitLabel
4704: oPop 1
4706: oTypeSPop
4707: oGetGlobal 8
4709: oPushResult
4710: oTypeSPush
4711: oPop 1
4713: oJumpForward 4718
4715: Choice Lookup Table
          31   4693
4718: oReturn
4719: oLocalSpace 0
4721: oGetParam 1
4723: oPushResult
4724: oCall 5252
4726: oPop 1
4728: oInputChoice 5234
4730: oGetParam 1
4732: oPushResult
4733: oCall 4619
4735: oPop 1
4737: oCall 8031
4739: oGetParam 1
4741: oPushResult
4742: oCall 5252
4744: oPop 1
4746: oGetParam 1
4748: oPushResult
4749: oCall 4619
4751: oPop 1
4753: oCall 8031
4755: oCall 7900
4757: oTypeSNodeType
4758: oChoice 4786
4760: oEmit 43
4762: oJumpForward 4805
4764: oEmit 49
4766: oJumpForward 4805
4768: oEmit 55
4770: oJumpForward 4805
4772: oCall 9895
4774: oEmit 15
4776: oSetResult 0
4778: oPushResult
4779: oEmitInt
4780: oPop 1
4782: oEmit 49
4784: oJumpForward 4805
4786: Choice Lookup Table
          39   4772
          40   4772
          35   4768
          34   4768
          41   4764
          29   4764
          33   4760
          31   4760
4803: oError 17
4805: oTypeSPop
4806: oGetGlobal 7
4808: oPushResult
4809: oTypeSPush
4810: oPop 1
4812: oJumpForward 5249
4814: oGetParam 1
4816: oPushResult
4817: oCall 4619
4819: oPop 1
4821: oCall 8031
4823: oGetParam 1
4825: oPushResult
4826: oCall 5252
4828: oPop 1
4830: oGetParam 1
4832: oPushResult
4833: oCall 4619
4835: oPop 1
4837: oCall 8031
4839: oCall 7900
4841: oTypeSNodeType
4842: oChoice 4870
4844: oEmit 44
4846: oJumpForward 4889
4848: oEmit 50
4850: oJumpForward 4889
4852: oEmit 56
4854: oJumpForward 4889
4856: oCall 9895
4858: oEmit 15
4860: oSetResult 0
4862: oPushResult
4863: oEmitInt
4864: oPop 1
4866: oEmit 50
4868: oJumpForward 4889
4870: Choice Lookup Table
          39   4856
          40   4856
          35   4852
          34   4852
          41   4848
          29   4848
          33   4844
          31   4844
4887: oError 17
4889: oTypeSPop
4890: oGetGlobal 7
4892: oPushResult
4893: oTypeSPush
4894: oPop 1
4896: oJumpForward 5249
4898: oGetParam 1
4900: oPushResult
4901: oCall 4619
4903: oPop 1
4905: oCall 8031
4907: oGetParam 1
4909: oPushResult
4910: oCall 5252
4912: oPop 1
4914: oGetParam 1
4916: oPushResult
4917: oCall 4619
4919: oPop 1
4921: oCall 8031
4923: oCall 7900
4925: oTypeSNodeType
4926: oChoice 4954
4928: oEmit 46
4930: oJumpForward 4973
4932: oEmit 52
4934: oJumpForward 4973
4936: oEmit 58
4938: oJumpForward 4973
4940: oCall 9895
4942: oEmit 15
4944: oSetResult 0
4946: oPushResult
4947: oEmitInt
4948: oPop 1
4950: oEmit 52
4952: oJumpForward 4973
4954: Choice Lookup Table
          39   4940
          40   4940
          35   4936
          34   4936
          41   4932
          29   4932
          33   4928
          31   4928
4971: oError 17
4973: oTypeSPop
4974: oGetGlobal 7
4976: oPushResult
4977: oTypeSPush
4978: oPop 1
4980: oJumpForward 5249
4982: oGetParam 1
4984: oPushResult
4985: oCall 4619
4987: oPop 1
4989: oCall 8031
4991: oGetParam 1
4993: oPushResult
4994: oCall 5252
4996: oPop 1
4998: oGetParam 1
5000: oPushResult
5001: oCall 4619
5003: oPop 1
5005: oCall 8031
5007: oCall 7900
5009: oTypeSNodeType
5010: oChoice 5038
5012: oEmit 45
5014: oJumpForward 5057
5016: oEmit 51
5018: oJumpForward 5057
5020: oEmit 57
5022: oJumpForward 5057
5024: oCall 9895
5026: oEmit 15
5028: oSetResult 0
5030: oPushResult
5031: oEmitInt
5032: oPop 1
5034: oEmit 51
5036: oJumpForward 5057
5038: Choice Lookup Table
          39   5024
          40   5024
          35   5020
          34   5020
          41   5016
          29   5016
          33   5012
          31   5012
5055: oError 17
5057: oTypeSPop
5058: oGetGlobal 7
5060: oPushResult
5061: oTypeSPush
5062: oPop 1
5064: oJumpForward 5249
5066: oGetParam 1
5068: oPushResult
5069: oCall 4619
5071: oPop 1
5073: oCall 8031
5075: oGetParam 1
5077: oPushResult
5078: oCall 5252
5080: oPop 1
5082: oGetParam 1
5084: oPushResult
5085: oCall 4619
5087: oPop 1
5089: oCall 8031
5091: oCall 7900
5093: oTypeSNodeType
5094: oChoice 5122
5096: oEmit 48
5098: oJumpForward 5141
5100: oEmit 54
5102: oJumpForward 5141
5104: oEmit 60
5106: oJumpForward 5141
5108: oCall 9895
5110: oEmit 15
5112: oSetResult 0
5114: oPushResult
5115: oEmitInt
5116: oPop 1
5118: oEmit 54
5120: oJumpForward 5141
5122: Choice Lookup Table
          39   5108
          40   5108
          35   5104
          34   5104
          41   5100
          29   5100
          33   5096
          31   5096
5139: oError 17
5141: oTypeSPop
5142: oGetGlobal 7
5144: oPushResult
5145: oTypeSPush
5146: oPop 1
5148: oJumpForward 5249
5150: oGetParam 1
5152: oPushResult
5153: oCall 4619
5155: oPop 1
5157: oCall 8031
5159: oGetParam 1
5161: oPushResult
5162: oCall 5252
5164: oPop 1
5166: oGetParam 1
5168: oPushResult
5169: oCall 4619
5171: oPop 1
5173: oCall 8031
5175: oCall 7900
5177: oTypeSNodeType
5178: oChoice 5206
5180: oEmit 47
5182: oJumpForward 5225
5184: oEmit 53
5186: oJumpForward 5225
5188: oEmit 59
5190: oJumpForward 5225
5192: oCall 9895
5194: oEmit 15
5196: oSetResult 0
5198: oPushResult
5199: oEmitInt
5200: oPop 1
5202: oEmit 53
5204: oJumpForward 5225
5206: Choice Lookup Table
          39   5192
          40   5192
          35   5188
          34   5188
          41   5184
          29   5184
          33   5180
          31   5180
5223: oError 17
5225: oTypeSPop
5226: oGetGlobal 7
5228: oPushResult
5229: oTypeSPush
5230: oPop 1
5232: oJumpForward 5249
5234: Choice Lookup Table
          11   5150
          10   5066
           9   4982
           8   4898
           7   4814
           6   4730
5247: oJumpForward 5251
5249: oJumpBack 4728
5251: oReturn
5252: oLocalSpace 1
5254: oGetAddrLocal 1
5256: oPushResult
5257: oSetResult 0
5259: oAssign
5260: oGetParam 1
5262: oPushResult
5263: oCall 5432
5265: oPop 1
5267: oInputChoice 5400
5269: oTypeSNodeType
5270: oChoice 5341
5272: oGetLocal 1
5274: oPushResult
5275: oSetResult 0
5277: oPushResult
5278: equal_label
5279: oPop 2
5281: oChoice 5290
5283: oGetAddrLocal 1
5285: oPushResult
5286: oLabelNew
5287: oAssign
5288: oJumpForward 5293
5290: Choice Lookup Table
           1   5283
5293: oEmit 68
5295: oGetLocal 1
5297: oPushResult
5298: oEmitLabel
5299: oPop 1
5301: oJumpForward 5348
5303: oGetParam 1
5305: oPushResult
5306: oCall 4688
5308: oPop 1
5310: oGetLocal 1
5312: oPushResult
5313: oSetResult 0
5315: oPushResult
5316: equal_label
5317: oPop 2
5319: oChoice 5328
5321: oGetAddrLocal 1
5323: oPushResult
5324: oLabelNew
5325: oAssign
5326: oJumpForward 5331
5328: Choice Lookup Table
           1   5321
5331: oEmit 68
5333: oGetLocal 1
5335: oPushResult
5336: oEmitLabel
5337: oPop 1
5339: oJumpForward 5348
5341: Choice Lookup Table
          31   5303
          32   5272
5346: oError 8
5348: oTypeSPop
5349: oEmit 77
5351: oGetFromParam 1
5353: oPushResult
5354: oEmitLabel
5355: oPop 1
5357: oGetParam 1
5359: oPushResult
5360: oSetResult 0
5362: oAssign
5363: oGetParam 1
5365: oPushResult
5366: oCall 5432
5368: oPop 1
5370: oTypeSNodeType
5371: oChoice 5384
5373: oJumpForward 5391
5375: oGetParam 1
5377: oPushResult
5378: oCall 4688
5380: oPop 1
5382: oJumpForward 5391
5384: Choice Lookup Table
          31   5375
          32   5373
5389: oError 8
5391: oTypeSPop
5392: oGetGlobal 8
5394: oPushResult
5395: oTypeSPush
5396: oPop 1
5398: oJumpForward 5405
5400: Choice Lookup Table
          57   5269
5403: oJumpForward 5407
5405: oJumpBack 5267
5407: oGetLocal 1
5409: oPushResult
5410: oSetResult 0
5412: oPushResult
5413: equal_label
5414: oPop 2
5416: oChoice 5428
5418: oEmit 77
5420: oGetLocal 1
5422: oPushResult
5423: oEmitLabel
5424: oPop 1
5426: oJumpForward 5431
5428: Choice Lookup Table
           0   5418
5431: oReturn
5432: oLocalSpace 2
5434: oGetAddrLocal 1
5436: oPushResult
5437: oSetResult 0
5439: oAssign
5440: oGetParam 1
5442: oPushResult
5443: oCall 5570
5445: oPop 1
5447: oInputChoice 5562
5449: oTypeSNodeType
5450: oChoice 5463
5452: oJumpForward 5470
5454: oGetParam 1
5456: oPushResult
5457: oCall 4688
5459: oPop 1
5461: oJumpForward 5470
5463: Choice Lookup Table
          31   5454
          32   5452
5468: oError 8
5470: oTypeSPop
5471: oGetLocal 1
5473: oPushResult
5474: oSetResult 0
5476: oPushResult
5477: equal_label
5478: oPop 2
5480: oChoice 5509
5482: oGetAddrLocal 1
5484: oPushResult
5485: oLabelNew
5486: oAssign
5487: oEmit 78
5489: oGetFromParam 1
5491: oPushResult
5492: oEmitLabel
5493: oPop 1
5495: oGetLocal 1
5497: oPushResult
5498: oEmitLabel
5499: oPop 1
5501: oGetParam 1
5503: oPushResult
5504: oGetLocal 1
5506: oAssign
5507: oJumpForward 5512
5509: Choice Lookup Table
           1   5482
5512: oGetAddrLocal 2
5514: oPushResult
5515: oSetResult 0
5517: oAssign
5518: oGetAddrLocal 2
5520: oPushResult
5521: oCall 5570
5523: oPop 1
5525: oTypeSNodeType
5526: oChoice 5539
5528: oJumpForward 5546
5530: oGetAddrLocal 2
5532: oPushResult
5533: oCall 4688
5535: oPop 1
5537: oJumpForward 5546
5539: Choice Lookup Table
          31   5530
          32   5528
5544: oError 8
5546: oEmit 78
5548: oGetLocal 2
5550: oPushResult
5551: oEmitLabel
5552: oPop 1
5554: oGetLocal 1
5556: oPushResult
5557: oEmitLabel
5558: oPop 1
5560: oJumpForward 5567
5562: Choice Lookup Table
          56   5449
5565: oJumpForward 5569
5567: oJumpBack 5447
5569: oReturn
5570: oLocalSpace 1
5572: oInputChoice 5626
5574: oGetAddrLocal 1
5576: oPushResult
5577: oSetResult 0
5579: oAssign
5580: oGetAddrLocal 1
5582: oPushResult
5583: oCall 5570
5585: oPop 1
5587: oTypeSNodeType
5588: oChoice 5617
5590: oGetParam 1
5592: oPushResult
5593: oLabelNew
5594: oAssign
5595: oEmit 68
5597: oGetFromParam 1
5599: oPushResult
5600: oEmitLabel
5601: oPop 1
5603: oEmit 77
5605: oGetLocal 1
5607: oPushResult
5608: oEmitLabel
5609: oPop 1
5611: oJumpForward 5624
5613: oEmit 42
5615: oJumpForward 5624
5617: Choice Lookup Table
          31   5613
          32   5590
5622: oError 8
5624: oJumpForward 5636
5626: Choice Lookup Table
          58   5574
5629: oGetParam 1
5631: oPushResult
5632: oCall 5637
5634: oPop 1
5636: oReturn
5637: oLocalSpace 2
5639: oGetAddrLocal 1
5641: oPushResult
5642: oSetResult 1
5644: oAssign
5645: oGetParam 1
5647: oPushResult
5648: oCall 5873
5650: oPop 1
5652: oInputChoice 5863
5654: oTypeSNodeType
5655: oChoice 5778
5657: oCall 7985
5659: oGetParam 1
5661: oPushResult
5662: oCall 5873
5664: oPop 1
5666: oTypeSNodeType
5667: oChoice 5675
5669: oEmit 22
5671: oCall 7533
5673: oJumpForward 5684
5675: Choice Lookup Table
          35   5669
          34   5669
5680: oCall 8005
5682: oEmit 37
5684: oJumpForward 5795
5686: oGetLocal 1
5688: oChoice 5704
5690: oGetAddrLocal 2
5692: oPushResult
5693: oCall 9678
5695: oAssign
5696: oGetAddrLocal 1
5698: oPushResult
5699: oSetResult 0
5701: oAssign
5702: oJumpForward 5707
5704: Choice Lookup Table
           1   5690
5707: oGetParam 1
5709: oPushResult
5710: oCall 5873
5712: oPop 1
5714: oTypeSNodeType
5715: oChoice 5753
5717: oCall 9787
5719: oEmit 17
5721: oGetLocal 2
5723: oPushResult
5724: oEmitInt
5725: oPop 1
5727: oGetGlobal 14
5729: oPushResult
5730: oTypeSPush
5731: oPop 1
5733: oJumpForward 5763
5735: oCall 9841
5737: oEmit 17
5739: oGetLocal 2
5741: oPushResult
5742: oEmitInt
5743: oPop 1
5745: oGetGlobal 14
5747: oPushResult
5748: oTypeSPush
5749: oPop 1
5751: oJumpForward 5763
5753: Choice Lookup Table
          33   5735
          39   5717
          40   5717
5760: oError 14
5762: oTypeSPop
5763: oJumpForward 5795
5765: oGetParam 1
5767: oPushResult
5768: oCall 5873
5770: oPop 1
5772: oCall 7985
5774: oCall 7533
5776: oJumpForward 5795
5778: Choice Lookup Table
          35   5765
          34   5765
          33   5686
          39   5686
          40   5686
          30   5657
          29   5657
5793: oError 17
5795: oJumpForward 5870
5797: oTypeSNodeType
5798: oChoice 5850
5800: oCall 7985
5802: oGetParam 1
5804: oPushResult
5805: oCall 5873
5807: oPop 1
5809: oCall 8005
5811: oEmit 40
5813: oJumpForward 5861
5815: oGetParam 1
5817: oPushResult
5818: oCall 5873
5820: oPop 1
5822: oTypeSNodeType
5823: oChoice 5837
5825: oCall 7985
5827: oCall 7589
5829: oJumpForward 5848
5831: oCall 7900
5833: oCall 7645
5835: oJumpForward 5848
5837: Choice Lookup Table
          35   5831
          34   5831
          30   5825
          29   5825
5846: oError 17
5848: oJumpForward 5861
5850: Choice Lookup Table
          35   5815
          34   5815
          30   5800
          29   5800
5859: oError 17
5861: oJumpForward 5870
5863: Choice Lookup Table
          25   5797
          24   5654
5868: oJumpForward 5872
5870: oJumpBack 5652
5872: oReturn
5873: oLocalSpace 0
5875: oGetParam 1
5877: oPushResult
5878: oCall 5924
5880: oPop 1
5882: oInputChoice 5914
5884: oCall 7985
5886: oGetParam 1
5888: oPushResult
5889: oCall 5924
5891: oPop 1
5893: oCall 8005
5895: oEmit 34
5897: oJumpForward 5921
5899: oCall 7985
5901: oGetParam 1
5903: oPushResult
5904: oCall 5924
5906: oPop 1
5908: oCall 8005
5910: oEmit 35
5912: oJumpForward 5921
5914: Choice Lookup Table
          23   5899
          22   5884
5919: oJumpForward 5923
5921: oJumpBack 5882
5923: oReturn
5924: oLocalSpace 0
5926: oInputChoice 5952
5928: oGetParam 1
5930: oPushResult
5931: oCall 5965
5933: oPop 1
5935: oCall 8005
5937: oJumpForward 5964
5939: oGetParam 1
5941: oPushResult
5942: oCall 5965
5944: oPop 1
5946: oCall 8005
5948: oEmit 41
5950: oJumpForward 5964
5952: Choice Lookup Table
          25   5939
          24   5928
5957: oGetParam 1
5959: oPushResult
5960: oCall 5965
5962: oPop 1
5964: oReturn
5965: oLocalSpace 7
5967: oInputChoice 6298
5969: oEmit 15
5971: TOKEN_VALUE
5972: oPushResult
5973: oEmitInt
5974: oPop 1
5976: oGetGlobal 6
5978: oPushResult
5979: oTypeSPush
5980: oPop 1
5982: oJumpForward 6319
5984: oEmit 15
5986: TOKEN_VALUE
5987: oPushResult
5988: oEmitInt
5989: oPop 1
5991: oGetGlobal 9
5993: oPushResult
5994: oTypeSPush
5995: oPop 1
5997: oJumpForward 6319
5999: oGetParam 1
6001: oPushResult
6002: oCall 4719
6004: oPop 1
6006: oInput 15
6008: oJumpForward 6319
6010: oGetAddrLocal 1
6012: oPushResult
6013: CURRENT_STRLIT
6014: oPushResult
6015: oStringAllocShortStringLit
6016: oPop 1
6018: oAssign
6019: oEmit 16
6021: oGetLocal 1
6023: oPushResult
6024: oEmitInt
6025: oPop 1
6027: oGetGlobal 13
6029: oPushResult
6030: oTypeSPush
6031: oPop 1
6033: oCall 7131
6035: oCall 7077
6037: oJumpForward 6319
6039: oGetAddrLocal 2
6041: oPushResult
6042: oScopeFindRequire
6043: oAssign
6044: oGetAddrLocal 2
6046: oPushResult
6047: oCall 244
6049: oPop 1
6051: oGetLocal 2
6053: oPushResult
6054: oNodeType
6055: oPop 1
6057: oChoice 6220
6059: oGetLocal 2
6061: oPushResult
6062: oCall 9990
6064: oPop 1
6066: oJumpForward 6247
6068: oGetLocal 2
6070: oPushResult
6071: oCall 10693
6073: oPop 1
6075: oJumpForward 6247
6077: oGetAddrLocal 3
6079: oPushResult
6080: oGetLocal 2
6082: oPushResult
6083: oSetResult 21
6085: oPushResult
6086: oNodeGet
6087: oPop 2
6089: oAssign
6090: oGetLocal 3
6092: oPushResult
6093: oTypeSPush
6094: oPop 1
6096: oTypeSNodeType
6097: oChoice 6121
6099: oEmit 15
6101: oGetLocal 2
6103: oPushResult
6104: oCall 12994
6106: oPop 1
6108: oJumpForward 6134
6110: oEmit 15
6112: oGetLocal 2
6114: oPushResult
6115: oCall 12994
6117: oPop 1
6119: oJumpForward 6134
6121: Choice Lookup Table
          35   6110
          34   6110
          31   6099
          41   6099
          29   6099
6132: oError 16
6134: oJumpForward 6247
6136: oGetAddrLocal 4
6138: oPushResult
6139: oGetLocal 2
6141: oPushResult
6142: oSetResult 22
6144: oPushResult
6145: oNodeGetInt
6146: oPop 2
6148: oAssign
6149: oGetLocal 4
6151: oPushResult
6152: equal_zero
6153: oPop 1
6155: oChoice 6188
6157: oGetAddrLocal 4
6159: oPushResult
6160: oGetLocal 2
6162: oPushResult
6163: oSetResult 33
6165: oPushResult
6166: oNodeGetString
6167: oPop 2
6169: oPushResult
6170: oStringAllocShortStringLit
6171: oPop 1
6173: oAssign
6174: oGetLocal 2
6176: oPushResult
6177: oSetResult 22
6179: oPushResult
6180: oGetLocal 4
6182: oPushResult
6183: oNodeSetInt
6184: oPop 3
6186: oJumpForward 6191
6188: Choice Lookup Table
           1   6157
6191: oEmit 16
6193: oGetLocal 4
6195: oPushResult
6196: oEmitInt
6197: oPop 1
6199: oGetGlobal 13
6201: oPushResult
6202: oTypeSPush
6203: oPop 1
6205: oCall 7131
6207: oCall 7077
6209: oJumpForward 6247
6211: oGetLocal 2
6213: oPushResult
6214: oCall 6320
6216: oPop 1
6218: oJumpForward 6247
6220: Choice Lookup Table
          25   6211
          24   6211
          22   6211
          21   6211
          18   6136
          17   6077
          16   6077
          14   6068
          13   6059
6239: oError 6
6241: oGetGlobal 6
6243: oPushResult
6244: oTypeSPush
6245: oPop 1
6247: oJumpForward 6319
6249: oInput 0
6251: oGetAddrLocal 5
6253: oPushResult
6254: oScopeFindRequire
6255: oAssign
6256: oGetAddrLocal 5
6258: oPushResult
6259: oCall 244
6261: oPop 1
6263: oGetLocal 5
6265: oPushResult
6266: oSetResult 0
6268: oPushResult
6269: oCall 8566
6271: oPop 2
6273: oGetAddrLocal 6
6275: oPushResult
6276: oTypeSTop
6277: oAssign
6278: oTypeSPop
6279: oGetAddrLocal 7
6281: oPushResult
6282: oGetLocal 6
6284: oPushResult
6285: oCall 12013
6287: oPop 1
6289: oAssign
6290: oGetLocal 7
6292: oPushResult
6293: oTypeSPush
6294: oPop 1
6296: oJumpForward 6319
6298: Choice Lookup Table
          19   6249
           0   6039
           2   6010
          14   5999
           3   5984
           1   5969
6311: oError 6
6313: oGetGlobal 6
6315: oPushResult
6316: oTypeSPush
6317: oPop 1
6319: oReturn
6320: oLocalSpace 2
6322: oGetAddrLocal 1
6324: oPushResult
6325: oGetParam 1
6327: oPushResult
6328: oSetResult 21
6330: oPushResult
6331: oNodeGet
6332: oPop 2
6334: oAssign
6335: oGetAddrLocal 2
6337: oPushResult
6338: oGetParam 1
6340: oPushResult
6341: oCall 12948
6343: oPop 1
6345: oAssign
6346: oGetLocal 1
6348: oPushResult
6349: oTypeSPush
6350: oPop 1
6352: oTypeSNodeType
6353: oChoice 7052
6355: oGetParam 1
6357: oPushResult
6358: oNodeType
6359: oPop 1
6361: oChoice 6507
6363: oEmit 0
6365: oGetParam 1
6367: oPushResult
6368: oCall 12994
6370: oPop 1
6372: oJumpForward 6517
6374: oGetLocal 2
6376: oPushResult
6377: equal_zero
6378: oPop 1
6380: oChoice 6393
6382: oEmit 3
6384: oGetParam 1
6386: oPushResult
6387: oCall 12994
6389: oPop 1
6391: oJumpForward 6411
6393: Choice Lookup Table
           1   6382
6396: oEmit 9
6398: oGetLocal 2
6400: oPushResult
6401: oEmitInt
6402: oPop 1
6404: oGetParam 1
6406: oPushResult
6407: oCall 12994
6409: oPop 1
6411: oJumpForward 6517
6413: oGetParam 1
6415: oPushResult
6416: oSetResult 34
6418: oPushResult
6419: oNodeGetBoolean
6420: oPop 2
6422: oChoice 6465
6424: oGetLocal 2
6426: oPushResult
6427: equal_zero
6428: oPop 1
6430: oChoice 6443
6432: oEmit 8
6434: oGetParam 1
6436: oPushResult
6437: oCall 12994
6439: oPop 1
6441: oJumpForward 6461
6443: Choice Lookup Table
           1   6432
6446: oEmit 14
6448: oGetLocal 2
6450: oPushResult
6451: oEmitInt
6452: oPop 1
6454: oGetParam 1
6456: oPushResult
6457: oCall 12994
6459: oPop 1
6461: oEmit 23
6463: oJumpForward 6505
6465: Choice Lookup Table
           1   6424
6468: oGetLocal 2
6470: oPushResult
6471: equal_zero
6472: oPop 1
6474: oChoice 6487
6476: oEmit 6
6478: oGetParam 1
6480: oPushResult
6481: oCall 12994
6483: oPop 1
6485: oJumpForward 6505
6487: Choice Lookup Table
           1   6476
6490: oEmit 12
6492: oGetLocal 2
6494: oPushResult
6495: oEmitInt
6496: oPop 1
6498: oGetParam 1
6500: oPushResult
6501: oCall 12994
6503: oPop 1
6505: oJumpForward 6517
6507: Choice Lookup Table
          24   6413
          22   6374
          25   6363
          21   6363
6516: oEndChoice
6517: oJumpForward 7076
6519: oGetParam 1
6521: oPushResult
6522: oNodeType
6523: oPop 1
6525: oChoice 6671
6527: oEmit 1
6529: oGetParam 1
6531: oPushResult
6532: oCall 12994
6534: oPop 1
6536: oJumpForward 6681
6538: oGetLocal 2
6540: oPushResult
6541: equal_zero
6542: oPop 1
6544: oChoice 6557
6546: oEmit 4
6548: oGetParam 1
6550: oPushResult
6551: oCall 12994
6553: oPop 1
6555: oJumpForward 6575
6557: Choice Lookup Table
           1   6546
6560: oEmit 10
6562: oGetLocal 2
6564: oPushResult
6565: oEmitInt
6566: oPop 1
6568: oGetParam 1
6570: oPushResult
6571: oCall 12994
6573: oPop 1
6575: oJumpForward 6681
6577: oGetParam 1
6579: oPushResult
6580: oSetResult 34
6582: oPushResult
6583: oNodeGetBoolean
6584: oPop 2
6586: oChoice 6629
6588: oGetLocal 2
6590: oPushResult
6591: equal_zero
6592: oPop 1
6594: oChoice 6607
6596: oEmit 8
6598: oGetParam 1
6600: oPushResult
6601: oCall 12994
6603: oPop 1
6605: oJumpForward 6625
6607: Choice Lookup Table
           1   6596
6610: oEmit 14
6612: oGetLocal 2
6614: oPushResult
6615: oEmitInt
6616: oPop 1
6618: oGetParam 1
6620: oPushResult
6621: oCall 12994
6623: oPop 1
6625: oEmit 24
6627: oJumpForward 6669
6629: Choice Lookup Table
           1   6588
6632: oGetLocal 2
6634: oPushResult
6635: equal_zero
6636: oPop 1
6638: oChoice 6651
6640: oEmit 7
6642: oGetParam 1
6644: oPushResult
6645: oCall 12994
6647: oPop 1
6649: oJumpForward 6669
6651: Choice Lookup Table
           1   6640
6654: oEmit 13
6656: oGetLocal 2
6658: oPushResult
6659: oEmitInt
6660: oPop 1
6662: oGetParam 1
6664: oPushResult
6665: oCall 12994
6667: oPop 1
6669: oJumpForward 6681
6671: Choice Lookup Table
          24   6577
          22   6538
          25   6527
          21   6527
6680: oEndChoice
6681: oJumpForward 7076
6683: oError 16
6685: oJumpForward 7076
6687: oGetParam 1
6689: oPushResult
6690: oNodeType
6691: oPop 1
6693: oChoice 6839
6695: oEmit 2
6697: oGetParam 1
6699: oPushResult
6700: oCall 12994
6702: oPop 1
6704: oJumpForward 6849
6706: oGetLocal 2
6708: oPushResult
6709: equal_zero
6710: oPop 1
6712: oChoice 6725
6714: oEmit 5
6716: oGetParam 1
6718: oPushResult
6719: oCall 12994
6721: oPop 1
6723: oJumpForward 6743
6725: Choice Lookup Table
           1   6714
6728: oEmit 11
6730: oGetLocal 2
6732: oPushResult
6733: oEmitInt
6734: oPop 1
6736: oGetParam 1
6738: oPushResult
6739: oCall 12994
6741: oPop 1
6743: oJumpForward 6849
6745: oGetParam 1
6747: oPushResult
6748: oSetResult 34
6750: oPushResult
6751: oNodeGetBoolean
6752: oPop 2
6754: oChoice 6797
6756: oGetLocal 2
6758: oPushResult
6759: equal_zero
6760: oPop 1
6762: oChoice 6775
6764: oEmit 8
6766: oGetParam 1
6768: oPushResult
6769: oCall 12994
6771: oPop 1
6773: oJumpForward 6793
6775: Choice Lookup Table
           1   6764
6778: oEmit 14
6780: oGetLocal 2
6782: oPushResult
6783: oEmitInt
6784: oPop 1
6786: oGetParam 1
6788: oPushResult
6789: oCall 12994
6791: oPop 1
6793: oEmit 25
6795: oJumpForward 6837
6797: Choice Lookup Table
           1   6756
6800: oGetLocal 2
6802: oPushResult
6803: equal_zero
6804: oPop 1
6806: oChoice 6819
6808: oEmit 8
6810: oGetParam 1
6812: oPushResult
6813: oCall 12994
6815: oPop 1
6817: oJumpForward 6837
6819: Choice Lookup Table
           1   6808
6822: oEmit 14
6824: oGetLocal 2
6826: oPushResult
6827: oEmitInt
6828: oPop 1
6830: oGetParam 1
6832: oPushResult
6833: oCall 12994
6835: oPop 1
6837: oJumpForward 6849
6839: Choice Lookup Table
          24   6745
          22   6706
          25   6695
          21   6695
6848: oEndChoice
6849: oInputChoice 6879
6851: oTypeSPop
6852: oGetLocal 1
6854: oPushResult
6855: oSetResult 37
6857: oPushResult
6858: oNodeGet
6859: oPop 2
6861: oPushResult
6862: oTypeSPush
6863: oPop 1
6865: oCall 7131
6867: oCall 7077
6869: oJumpForward 6884
6871: oCall 7326
6873: oCall 7131
6875: oCall 7077
6877: oJumpForward 6884
6879: Choice Lookup Table
          16   6871
          18   6851
6884: oJumpForward 7076
6886: oGetParam 1
6888: oPushResult
6889: oNodeType
6890: oPop 1
6892: oChoice 7036
6894: oEmit 16
6896: oGetParam 1
6898: oPushResult
6899: oCall 12994
6901: oPop 1
6903: oJumpForward 7046
6905: oGetLocal 2
6907: oPushResult
6908: equal_zero
6909: oPop 1
6911: oChoice 6924
6913: oEmit 17
6915: oGetParam 1
6917: oPushResult
6918: oCall 12994
6920: oPop 1
6922: oJumpForward 6942
6924: Choice Lookup Table
           1   6913
6927: oEmit 20
6929: oGetLocal 2
6931: oPushResult
6932: oEmitInt
6933: oPop 1
6935: oGetParam 1
6937: oPushResult
6938: oCall 12994
6940: oPop 1
6942: oJumpForward 7046
6944: oGetParam 1
6946: oPushResult
6947: oSetResult 34
6949: oPushResult
6950: oNodeGetBoolean
6951: oPop 2
6953: oChoice 6994
6955: oGetLocal 2
6957: oPushResult
6958: equal_zero
6959: oPop 1
6961: oChoice 6974
6963: oEmit 8
6965: oGetParam 1
6967: oPushResult
6968: oCall 12994
6970: oPop 1
6972: oJumpForward 6992
6974: Choice Lookup Table
           1   6963
6977: oEmit 14
6979: oGetLocal 2
6981: oPushResult
6982: oEmitInt
6983: oPop 1
6985: oGetParam 1
6987: oPushResult
6988: oCall 12994
6990: oPop 1
6992: oJumpForward 7034
6994: Choice Lookup Table
           1   6955
6997: oGetLocal 2
6999: oPushResult
7000: equal_zero
7001: oPop 1
7003: oChoice 7016
7005: oEmit 18
7007: oGetParam 1
7009: oPushResult
7010: oCall 12994
7012: oPop 1
7014: oJumpForward 7034
7016: Choice Lookup Table
           1   7005
7019: oEmit 21
7021: oGetLocal 2
7023: oPushResult
7024: oEmitInt
7025: oPop 1
7027: oGetParam 1
7029: oPushResult
7030: oCall 12994
7032: oPop 1
7034: oJumpForward 7046
7036: Choice Lookup Table
          24   6944
          22   6905
          25   6894
          21   6894
7045: oEndChoice
7046: oCall 7131
7048: oCall 7077
7050: oJumpForward 7076
7052: Choice Lookup Table
          40   6886
          38   6886
          36   6886
          35   6687
          34   6687
          28   6683
          33   6519
          30   6519
          31   6519
          41   6355
          29   6355
7075: oEndChoice
7076: oReturn
7077: oLocalSpace 0
7079: oTypeSNodeType
7080: oChoice 7104
7082: oEmit 23
7084: oJumpForward 7130
7086: oEmit 24
7088: oJumpForward 7130
7090: oError 16
7092: oJumpForward 7130
7094: oEmit 25
7096: oJumpForward 7130
7098: oError 29
7100: oJumpForward 7130
7102: oJumpForward 7130
7104: Choice Lookup Table
          40   7102
          39   7102
          38   7102
          36   7102
          35   7098
          34   7094
          28   7090
          33   7086
          30   7086
          31   7086
          41   7082
          29   7082
7129: oEndChoice
7130: oReturn
7131: oLocalSpace 0
7133: oInputChoice 7171
7135: oTypeSNodeType
7136: oChoice 7150
7138: oCall 7183
7140: oJumpForward 7161
7142: oCall 7326
7144: oJumpForward 7161
7146: oCall 7405
7148: oJumpForward 7161
7150: Choice Lookup Table
          40   7146
          39   7146
          34   7142
          36   7138
7159: oError 10
7161: oJumpForward 7180
7163: oCall 7435
7165: oJumpForward 7180
7167: oCall 7708
7169: oJumpForward 7180
7171: Choice Lookup Table
          18   7167
          20   7163
          16   7135
7178: oJumpForward 7182
7180: oJumpBack 7133
7182: oReturn
7183: oLocalSpace 3
7185: oTypeSNodeType
7186: oChoice 7190
7188: oJumpForward 7195
7190: Choice Lookup Table
          36   7188
7193: oError 10
7195: oTypeSNodeType
7196: oChoice 7200
7198: oJumpForward 7205
7200: Choice Lookup Table
          36   7198
7203: oError 13
7205: oGetAddrLocal 1
7207: oPushResult
7208: oTypeSTop
7209: oPushResult
7210: oSetResult 38
7212: oPushResult
7213: oNodeGet
7214: oPop 2
7216: oPushResult
7217: oCall 12097
7219: oPop 1
7221: oAssign
7222: oGetAddrLocal 2
7224: oPushResult
7225: oTypeSTop
7226: oPushResult
7227: oSetResult 37
7229: oPushResult
7230: oNodeGet
7231: oPop 2
7233: oAssign
7234: oTypeSPop
7235: oGetLocal 2
7237: oPushResult
7238: oTypeSPush
7239: oPop 1
7241: oCall 4558
7243: oCall 7958
7245: oGetLocal 1
7247: oPushResult
7248: equal_zero
7249: oPop 1
7251: oChoice 7265
7253: oEmit 15
7255: oGetLocal 1
7257: oPushResult
7258: oEmitInt
7259: oPop 1
7261: oEmit 40
7263: oJumpForward 7268
7265: Choice Lookup Table
           0   7253
7268: oGetAddrLocal 3
7270: oPushResult
7271: oGetLocal 2
7273: oPushResult
7274: oSetResult 17
7276: oPushResult
7277: oNodeGetInt
7278: oPop 2
7280: oAssign
7281: oGetLocal 3
7283: oPushResult
7284: oSetResult 1
7286: oPushResult
7287: equal
7288: oPop 2
7290: oChoice 7304
7292: oEmit 15
7294: oGetLocal 3
7296: oPushResult
7297: oEmitInt
7298: oPop 1
7300: oEmit 34
7302: oJumpForward 7307
7304: Choice Lookup Table
           0   7292
7307: oEmit 36
7309: oInputChoice 7317
7311: oJumpForward 7325
7313: oJumpForward 7323
7315: oJumpForward 7323
7317: Choice Lookup Table
          13   7315
          17   7311
7322: oEndChoice
7323: oJumpBack 7195
7325: oReturn
7326: oLocalSpace 2
7328: oTypeSNodeType
7329: oChoice 7333
7331: oJumpForward 7338
7333: Choice Lookup Table
          34   7331
7336: oError 29
7338: oGetAddrLocal 1
7340: oPushResult
7341: oTypeSTop
7342: oPushResult
7343: oSetResult 37
7345: oPushResult
7346: oNodeGet
7347: oPop 2
7349: oAssign
7350: oTypeSPop
7351: oGetLocal 1
7353: oPushResult
7354: oTypeSPush
7355: oPop 1
7357: oCall 4558
7359: oCall 7958
7361: oGetAddrLocal 2
7363: oPushResult
7364: oGetLocal 1
7366: oPushResult
7367: oSetResult 17
7369: oPushResult
7370: oNodeGetInt
7371: oPop 2
7373: oAssign
7374: oGetLocal 2
7376: oPushResult
7377: oSetResult 1
7379: oPushResult
7380: equal
7381: oPop 2
7383: oChoice 7397
7385: oEmit 15
7387: oGetLocal 2
7389: oPushResult
7390: oEmitInt
7391: oPop 1
7393: oEmit 34
7395: oJumpForward 7400
7397: Choice Lookup Table
           0   7385
7400: oEmit 36
7402: oInput 17
7404: oReturn
7405: oLocalSpace 0
7407: oTypeSNodeType
7408: oChoice 7412
7410: oJumpForward 7419
7412: Choice Lookup Table
          40   7410
          39   7410
7417: oError 29
7419: oTypeSPop
7420: oGetGlobal 9
7422: oPushResult
7423: oTypeSPush
7424: oPop 1
7426: oCall 4558
7428: oCall 7958
7430: oEmit 36
7432: oInput 17
7434: oReturn
7435: oLocalSpace 2
7437: oTypeSNodeType
7438: oChoice 7442
7440: oJumpForward 7447
7442: Choice Lookup Table
          38   7440
7445: oError 11
7447: oTypeSTop
7448: oPushResult
7449: oSetResult 41
7451: oPushResult
7452: oNodeGet
7453: oPop 2
7455: oPushResult
7456: oScopeEnter
7457: oPop 1
7459: oInput 0
7461: oGetAddrLocal 1
7463: oPushResult
7464: oScopeFindRequire
7465: oAssign
7466: oGetLocal 1
7468: oPushResult
7469: oNodeType
7470: oPop 1
7472: oChoice 7476
7474: oJumpForward 7481
7476: Choice Lookup Table
          23   7474
7479: oError 12
7481: oScopeEnd
7482: oGetAddrLocal 2
7484: oPushResult
7485: oGetLocal 1
7487: oPushResult
7488: oSetResult 22
7490: oPushResult
7491: oNodeGetInt
7492: oPop 2
7494: oAssign
7495: oGetLocal 2
7497: oPushResult
7498: equal_zero
7499: oPop 1
7501: oChoice 7515
7503: oEmit 15
7505: oGetLocal 2
7507: oPushResult
7508: oEmitInt
7509: oPop 1
7511: oEmit 36
7513: oJumpForward 7518
7515: Choice Lookup Table
           0   7503
7518: oTypeSPop
7519: oGetLocal 1
7521: oPushResult
7522: oSetResult 21
7524: oPushResult
7525: oNodeGet
7526: oPop 2
7528: oPushResult
7529: oTypeSPush
7530: oPop 1
7532: oReturn
7533: oLocalSpace 2
7535: oGetAddrLocal 1
7537: oPushResult
7538: oTypeSTop
7539: oPushResult
7540: oSetResult 37
7542: oPushResult
7543: oNodeGet
7544: oPop 2
7546: oAssign
7547: oGetAddrLocal 2
7549: oPushResult
7550: oGetLocal 1
7552: oPushResult
7553: oSetResult 17
7555: oPushResult
7556: oNodeGetInt
7557: oPop 2
7559: oAssign
7560: oGetLocal 2
7562: oPushResult
7563: oSetResult 1
7565: oPushResult
7566: equal
7567: oPop 2
7569: oChoice 7583
7571: oEmit 15
7573: oGetLocal 2
7575: oPushResult
7576: oEmitInt
7577: oPop 1
7579: oEmit 34
7581: oJumpForward 7586
7583: Choice Lookup Table
           0   7571
7586: oEmit 36
7588: oReturn
7589: oLocalSpace 2
7591: oGetAddrLocal 1
7593: oPushResult
7594: oTypeSTop
7595: oPushResult
7596: oSetResult 37
7598: oPushResult
7599: oNodeGet
7600: oPop 2
7602: oAssign
7603: oGetAddrLocal 2
7605: oPushResult
7606: oGetLocal 1
7608: oPushResult
7609: oSetResult 17
7611: oPushResult
7612: oNodeGetInt
7613: oPop 2
7615: oAssign
7616: oGetLocal 2
7618: oPushResult
7619: oSetResult 1
7621: oPushResult
7622: equal
7623: oPop 2
7625: oChoice 7639
7627: oEmit 15
7629: oGetLocal 2
7631: oPushResult
7632: oEmitInt
7633: oPop 1
7635: oEmit 34
7637: oJumpForward 7642
7639: Choice Lookup Table
           0   7627
7642: oEmit 39
7644: oReturn
7645: oLocalSpace 2
7647: oEmit 38
7649: oGetAddrLocal 1
7651: oPushResult
7652: oTypeSTop
7653: oPushResult
7654: oSetResult 37
7656: oPushResult
7657: oNodeGet
7658: oPop 2
7660: oAssign
7661: oGetAddrLocal 2
7663: oPushResult
7664: oGetLocal 1
7666: oPushResult
7667: oSetResult 17
7669: oPushResult
7670: oNodeGetInt
7671: oPop 2
7673: oAssign
7674: oGetLocal 2
7676: oPushResult
7677: oSetResult 1
7679: oPushResult
7680: equal
7681: oPop 2
7683: oChoice 7697
7685: oEmit 15
7687: oGetLocal 2
7689: oPushResult
7690: oEmitInt
7691: oPop 1
7693: oEmit 35
7695: oJumpForward 7700
7697: Choice Lookup Table
           0   7685
7700: oTypeSPop
7701: oGetGlobal 6
7703: oPushResult
7704: oTypeSPush
7705: oPop 1
7707: oReturn
7708: oLocalSpace 1
7710: oTypeSNodeType
7711: oChoice 7719
7713: oJumpForward 7726
7715: oError 29
7717: oJumpForward 7726
7719: Choice Lookup Table
          35   7715
          34   7713
7724: oError 9
7726: oEmit 25
7728: oGetAddrLocal 1
7730: oPushResult
7731: oTypeSTop
7732: oAssign
7733: oTypeSPop
7734: oGetLocal 1
7736: oPushResult
7737: oSetResult 37
7739: oPushResult
7740: oNodeGet
7741: oPop 2
7743: oPushResult
7744: oTypeSPush
7745: oPop 1
7747: oReturn
7748: oLocalSpace 2
7750: oGetAddrLocal 1
7752: oPushResult
7753: oTypeSNodeType
7754: oAssign
7755: oTypeSPop
7756: oGetLocal 1
7758: oPushResult
7759: oTypeSNodeType
7760: oPushResult
7761: equal_node_type
7762: oPop 2
7764: oChoice 7896
7766: oTypeSNodeType
7767: oChoice 7881
7769: oGetLocal 1
7771: oChoice 7778
7773: oEmit 30
7775: oReturn
7776: oJumpForward 7781
7778: Choice Lookup Table
          30   7773
7781: oJumpForward 7892
7783: oGetLocal 1
7785: oChoice 7792
7787: oEmit 31
7789: oReturn
7790: oJumpForward 7795
7792: Choice Lookup Table
          29   7787
7795: oJumpForward 7892
7797: oGetLocal 1
7799: oChoice 7832
7801: oReturn
7802: oJumpForward 7837
7804: oTypeSTop
7805: oPushResult
7806: oGetGlobal 10
7808: oPushResult
7809: equal_node
7810: oPop 2
7812: oChoice 7827
7814: oEmit 15
7816: oSetResult 1
7818: oPushResult
7819: oEmitInt
7820: oPop 1
7822: oEmit 36
7824: oReturn
7825: oJumpForward 7830
7827: Choice Lookup Table
           1   7814
7830: oJumpForward 7837
7832: Choice Lookup Table
          39   7804
          35   7801
7837: oJumpForward 7892
7839: oGetLocal 1
7841: oChoice 7846
7843: oReturn
7844: oJumpForward 7849
7846: Choice Lookup Table
          34   7843
7849: oJumpForward 7892
7851: oGetLocal 1
7853: oChoice 7874
7855: oReturn
7856: oJumpForward 7879
7858: oGetGlobal 9
7860: oPushResult
7861: oTypeSPush
7862: oPop 1
7864: oGetAddrLocal 2
7866: oPushResult
7867: oCall 9678
7869: oAssign
7870: oTypeSPop
7871: oReturn
7872: oJumpForward 7879
7874: Choice Lookup Table
          33   7858
          39   7855
7879: oJumpForward 7892
7881: Choice Lookup Table
          40   7851
          35   7839
          34   7797
          30   7783
          29   7769
7892: oError 14
7894: oJumpForward 7899
7896: Choice Lookup Table
           0   7766
7899: oReturn
7900: oLocalSpace 1
7902: oGetAddrLocal 1
7904: oPushResult
7905: oTypeSNodeType
7906: oAssign
7907: oTypeSPop
7908: oGetLocal 1
7910: oPushResult
7911: oTypeSNodeType
7912: oPushResult
7913: equal_node_type
7914: oPop 2
7916: oChoice 7954
7918: oTypeSNodeType
7919: oChoice 7945
7921: oGetLocal 1
7923: oChoice 7928
7925: oReturn
7926: oJumpForward 7931
7928: Choice Lookup Table
          35   7925
7931: oJumpForward 7950
7933: oGetLocal 1
7935: oChoice 7940
7937: oReturn
7938: oJumpForward 7943
7940: Choice Lookup Table
          34   7937
7943: oJumpForward 7950
7945: Choice Lookup Table
          35   7933
          34   7921
7950: oError 14
7952: oJumpForward 7957
7954: Choice Lookup Table
           0   7918
7957: oReturn
7958: oLocalSpace 0
7960: oTypeSNodeType
7961: oChoice 7965
7963: oJumpForward 7970
7965: Choice Lookup Table
          29   7963
7968: oError 7
7970: oTypeSPop
7971: oReturn
7972: oLocalSpace 0
7974: oTypeSNodeType
7975: oChoice 7979
7977: oJumpForward 7984
7979: Choice Lookup Table
          29   7977
7982: oError 7
7984: oReturn
7985: oLocalSpace 0
7987: oTypeSNodeType
7988: oChoice 7996
7990: oJumpForward 8003
7992: oEmit 30
7994: oJumpForward 8003
7996: Choice Lookup Table
          30   7992
          29   7990
8001: oError 7
8003: oTypeSPop
8004: oReturn
8005: oLocalSpace 0
8007: oTypeSNodeType
8008: oChoice 8023
8010: oJumpForward 8030
8012: oEmit 30
8014: oTypeSPop
8015: oGetGlobal 6
8017: oPushResult
8018: oTypeSPush
8019: oPop 1
8021: oJumpForward 8030
8023: Choice Lookup Table
          30   8012
          29   8010
8028: oError 7
8030: oReturn
8031: oLocalSpace 0
8033: oTypeSNodeType
8034: oChoice 8047
8036: oEmit 30
8038: oTypeSPop
8039: oGetGlobal 6
8041: oPushResult
8042: oTypeSPush
8043: oPop 1
8045: oJumpForward 8050
8047: Choice Lookup Table
          30   8036
8050: oReturn
8051: oLocalSpace 0
8053: oTypeSNodeType
8054: oChoice 8058
8056: oJumpForward 8063
8058: Choice Lookup Table
          31   8056
8061: oError 8
8063: oTypeSPop
8064: oReturn
8065: oLocalSpace 0
8067: oTypeSNodeType
8068: oChoice 8072
8070: oJumpForward 8077
8072: Choice Lookup Table
          31   8070
8075: oError 8
8077: oReturn
8078: oLocalSpace 0
8080: oInputChoice 8143
8082: oCall 9541
8084: oJumpForward 8174
8086: oCall 9548
8088: oJumpForward 8174
8090: oCall 9672
8092: oJumpForward 8174
8094: oCall 9675
8096: oJumpForward 8174
8098: oCall 8756
8100: oJumpForward 8174
8102: oCall 9079
8104: oJumpForward 8174
8106: oCall 8822
8108: oJumpForward 8174
8110: oCall 8999
8112: oJumpForward 8174
8114: oCall 9164
8116: oJumpForward 8174
8118: oCall 9132
8120: oJumpForward 8174
8122: oCall 9518
8124: oJumpForward 8174
8126: oCall 8175
8128: oJumpForward 8174
8130: oCall 9196
8132: oJumpForward 8174
8134: oCall 9466
8136: oJumpForward 8174
8138: oChangeIntLitToLabelIdent
8139: oCall 8175
8141: oJumpForward 8174
8143: Choice Lookup Table
           1   8138
          55   8134
          53   8130
           0   8126
          35   8122
          51   8118
          52   8114
          49   8110
          44   8106
          48   8102
          41   8098
          68   8094
          67   8090
          66   8086
          65   8082
8174: oReturn
8175: oLocalSpace 1
8177: oGetAddrLocal 1
8179: oPushResult
8180: oScopeFindRequire
8181: oAssign
8182: oGetAddrLocal 1
8184: oPushResult
8185: oCall 244
8187: oPop 1
8189: oGetLocal 1
8191: oPushResult
8192: oNodeType
8193: oPop 1
8195: oChoice 8235
8197: oGetLocal 1
8199: oPushResult
8200: oCall 8251
8202: oPop 1
8204: oCall 8078
8206: oJumpForward 8250
8208: oGetLocal 1
8210: oPushResult
8211: oCall 9990
8213: oPop 1
8215: oJumpForward 8250
8217: oGetLocal 1
8219: oPushResult
8220: oCall 8301
8222: oPop 1
8224: oJumpForward 8250
8226: oGetLocal 1
8228: oPushResult
8229: oCall 8391
8231: oPop 1
8233: oJumpForward 8250
8235: Choice Lookup Table
          13   8226
          24   8217
          22   8217
          21   8217
          12   8208
          26   8197
8248: oError 0
8250: oReturn
8251: oLocalSpace 0
8253: oGetParam 1
8255: oPushResult
8256: oSetResult 35
8258: oPushResult
8259: oNodeGetBoolean
8260: oPop 2
8262: oChoice 8268
8264: oError 21
8266: oJumpForward 8271
8268: Choice Lookup Table
           1   8264
8271: oEmit 77
8273: oGetParam 1
8275: oPushResult
8276: oSetResult 22
8278: oPushResult
8279: oNodeGetLabel
8280: oPop 2
8282: oPushResult
8283: oEmitLabel
8284: oPop 1
8286: oGetParam 1
8288: oPushResult
8289: oSetResult 35
8291: oPushResult
8292: oSetResult 1
8294: oPushResult
8295: oNodeSetBoolean
8296: oPop 3
8298: oInput 12
8300: oReturn
8301: oLocalSpace 0
8303: oGetParam 1
8305: oPushResult
8306: oSetResult 1
8308: oPushResult
8309: oCall 8566
8311: oPop 2
8313: oInput 4
8315: oCall 4558
8317: oCall 7748
8319: oCall 8322
8321: oReturn
8322: oLocalSpace 1
8324: oTypeSNodeType
8325: oChoice 8365
8327: oEmit 26
8329: oJumpForward 8389
8331: oEmit 27
8333: oJumpForward 8389
8335: oError 16
8337: oJumpForward 8389
8339: oEmit 28
8341: oJumpForward 8389
8343: oGetAddrLocal 1
8345: oPushResult
8346: oTypeSTop
8347: oPushResult
8348: oSetResult 17
8350: oPushResult
8351: oNodeGetInt
8352: oPop 2
8354: oAssign
8355: oEmit 29
8357: oGetLocal 1
8359: oPushResult
8360: oEmitInt
8361: oPop 1
8363: oJumpForward 8389
8365: Choice Lookup Table
          40   8343
          38   8343
          36   8343
          35   8339
          34   8339
          28   8335
          33   8331
          30   8331
          31   8331
          41   8327
          29   8327
8388: oEndChoice
8389: oTypeSPop
8390: oReturn
8391: oLocalSpace 1
8393: oGetParam 1
8395: oPushResult
8396: oSetResult 6
8398: oPushResult
8399: oNodeGet
8400: oPop 2
8402: oPushResult
8403: oScopeCurrent
8404: oPushResult
8405: oNodeEqual
8406: oPop 2
8408: oChoice 8414
8410: oError 20
8412: oJumpForward 8417
8414: Choice Lookup Table
           0   8410
8417: oEmit 8
8419: oGetParam 1
8421: oPushResult
8422: oSetResult 31
8424: oPushResult
8425: oNodeGetInt
8426: oPop 2
8428: oPushResult
8429: oEmitInt
8430: oPop 1
8432: oGetParam 1
8434: oPushResult
8435: oSetResult 21
8437: oPushResult
8438: oNodeGet
8439: oPop 2
8441: oPushResult
8442: oTypeSPush
8443: oPop 1
8445: oInput 4
8447: oCall 4558
8449: oCall 7748
8451: oTypeSNodeType
8452: oChoice 8492
8454: oEmit 26
8456: oJumpForward 8516
8458: oEmit 27
8460: oJumpForward 8516
8462: oError 16
8464: oJumpForward 8516
8466: oEmit 28
8468: oJumpForward 8516
8470: oGetAddrLocal 1
8472: oPushResult
8473: oTypeSTop
8474: oPushResult
8475: oSetResult 17
8477: oPushResult
8478: oNodeGetInt
8479: oPop 2
8481: oAssign
8482: oEmit 29
8484: oGetLocal 1
8486: oPushResult
8487: oEmitInt
8488: oPop 1
8490: oJumpForward 8516
8492: Choice Lookup Table
          40   8470
          38   8470
          36   8470
          35   8466
          34   8466
          28   8462
          33   8458
          30   8458
          31   8458
          41   8454
          29   8454
8515: oEndChoice
8516: oTypeSPop
8517: oReturn
8518: oLocalSpace 1
8520: oInput 0
8522: oGetAddrLocal 1
8524: oPushResult
8525: oScopeFindRequire
8526: oAssign
8527: oGetAddrLocal 1
8529: oPushResult
8530: oCall 244
8532: oPop 1
8534: oGetLocal 1
8536: oPushResult
8537: oNodeType
8538: oPop 1
8540: oChoice 8544
8542: oJumpForward 8555
8544: Choice Lookup Table
          25   8542
          24   8542
          22   8542
          21   8542
8553: oError 4
8555: oGetLocal 1
8557: oPushResult
8558: oGetParam 1
8560: oPushResult
8561: oCall 8566
8563: oPop 2
8565: oReturn
8566: oLocalSpace 0
8568: oGetParam 2
8570: oPushResult
8571: oNodeType
8572: oPop 1
8574: oChoice 8656
8576: oEmit 16
8578: oGetParam 2
8580: oPushResult
8581: oCall 12994
8583: oPop 1
8585: oJumpForward 8667
8587: oEmit 17
8589: oGetParam 2
8591: oPushResult
8592: oCall 12994
8594: oPop 1
8596: oJumpForward 8667
8598: oGetParam 2
8600: oPushResult
8601: oSetResult 34
8603: oPushResult
8604: oNodeGetBoolean
8605: oPop 2
8607: oChoice 8620
8609: oEmit 8
8611: oGetParam 2
8613: oPushResult
8614: oCall 12994
8616: oPop 1
8618: oJumpForward 8632
8620: Choice Lookup Table
           1   8609
8623: oEmit 18
8625: oGetParam 2
8627: oPushResult
8628: oCall 12994
8630: oPop 1
8632: oJumpForward 8667
8634: oGetParam 1
8636: oChoice 8649
8638: oEmit 16
8640: oGetParam 2
8642: oPushResult
8643: oCall 12994
8645: oPop 1
8647: oJumpForward 8654
8649: Choice Lookup Table
           0   8638
8652: oError 4
8654: oJumpForward 8667
8656: Choice Lookup Table
          25   8634
          24   8598
          22   8587
          21   8576
8665: oError 4
8667: oGetParam 2
8669: oPushResult
8670: oSetResult 21
8672: oPushResult
8673: oNodeGet
8674: oPop 2
8676: oPushResult
8677: oTypeSPush
8678: oPop 1
8680: oTypeSNodeType
8681: oChoice 8696
8683: oInputChoice 8691
8685: oEmit 25
8687: oCall 7326
8689: oJumpForward 8694
8691: Choice Lookup Table
          16   8685
8694: oJumpForward 8699
8696: Choice Lookup Table
          34   8683
8699: oCall 7131
8701: oReturn
8702: oLocalSpace 0
8704: oGetParam 1
8706: oPushResult
8707: oSetResult 1
8709: oPushResult
8710: oCall 8566
8712: oPop 2
8714: oCall 7958
8716: oGetParam 1
8718: oPushResult
8719: oCall 6320
8721: oPop 1
8723: oTypeSPop
8724: oEmit 32
8726: oEmit 26
8728: oReturn
8729: oLocalSpace 0
8731: oGetParam 1
8733: oPushResult
8734: oSetResult 1
8736: oPushResult
8737: oCall 8566
8739: oPop 2
8741: oCall 7958
8743: oGetParam 1
8745: oPushResult
8746: oCall 6320
8748: oPop 1
8750: oTypeSPop
8751: oEmit 33
8753: oEmit 26
8755: oReturn
8756: oLocalSpace 2
8758: oGetAddrLocal 1
8760: oPushResult
8761: oSetResult 0
8763: oAssign
8764: oGetAddrLocal 1
8766: oPushResult
8767: oCall 4581
8769: oPop 1
8771: oInput 42
8773: oCall 8078
8775: oInputChoice 8810
8777: oGetAddrLocal 2
8779: oPushResult
8780: oLabelNew
8781: oAssign
8782: oEmit 68
8784: oGetLocal 2
8786: oPushResult
8787: oEmitLabel
8788: oPop 1
8790: oEmit 77
8792: oGetLocal 1
8794: oPushResult
8795: oEmitLabel
8796: oPop 1
8798: oCall 8078
8800: oEmit 77
8802: oGetLocal 2
8804: oPushResult
8805: oEmitLabel
8806: oPop 1
8808: oJumpForward 8821
8810: Choice Lookup Table
          43   8777
8813: oEmit 77
8815: oGetLocal 1
8817: oPushResult
8818: oEmitLabel
8819: oPop 1
8821: oReturn
8822: oLocalSpace 4
8824: oInput 0
8826: oGetAddrLocal 1
8828: oPushResult
8829: oScopeFindRequire
8830: oAssign
8831: oGetLocal 1
8833: oPushResult
8834: oSetResult 1
8836: oPushResult
8837: oCall 8566
8839: oPop 2
8841: oCall 7958
8843: oInput 4
8845: oCall 4558
8847: oCall 7958
8849: oEmit 26
8851: oGetAddrLocal 2
8853: oPushResult
8854: oLabelNew
8855: oAssign
8856: oGetAddrLocal 3
8858: oPushResult
8859: oLabelNew
8860: oAssign
8861: oEmit 68
8863: oGetLocal 3
8865: oPushResult
8866: oEmitLabel
8867: oPop 1
8869: oGetAddrLocal 4
8871: oPushResult
8872: oLabelNew
8873: oAssign
8874: oEmit 77
8876: oGetLocal 4
8878: oPushResult
8879: oEmitLabel
8880: oPop 1
8882: oInputChoice 8962
8884: oGetLocal 1
8886: oPushResult
8887: oCall 8702
8889: oPop 1
8891: oEmit 77
8893: oGetLocal 3
8895: oPushResult
8896: oEmitLabel
8897: oPop 1
8899: oGetLocal 1
8901: oPushResult
8902: oCall 6320
8904: oPop 1
8906: oTypeSPop
8907: oCall 4558
8909: oCall 7958
8911: oEmit 51
8913: oEmit 69
8915: oGetLocal 2
8917: oPushResult
8918: oEmitLabel
8919: oPop 1
8921: oJumpForward 8968
8923: oGetLocal 1
8925: oPushResult
8926: oCall 8729
8928: oPop 1
8930: oEmit 77
8932: oGetLocal 3
8934: oPushResult
8935: oEmitLabel
8936: oPop 1
8938: oGetLocal 1
8940: oPushResult
8941: oCall 6320
8943: oPop 1
8945: oTypeSPop
8946: oCall 4558
8948: oCall 7958
8950: oEmit 52
8952: oEmit 69
8954: oGetLocal 2
8956: oPushResult
8957: oEmitLabel
8958: oPop 1
8960: oJumpForward 8968
8962: Choice Lookup Table
          46   8923
          45   8884
8967: oEndChoice
8968: oGetLocal 4
8970: oPushResult
8971: oGetLocal 2
8973: oPushResult
8974: oLoopPush
8975: oPop 2
8977: oInput 47
8979: oCall 8078
8981: oEmit 68
8983: oGetLocal 4
8985: oPushResult
8986: oEmitLabel
8987: oPop 1
8989: oEmit 77
8991: oGetLocal 2
8993: oPushResult
8994: oEmitLabel
8995: oPop 1
8997: oLoopPop
8998: oReturn
8999: oLocalSpace 3
9001: oGetAddrLocal 1
9003: oPushResult
9004: oLabelNew
9005: oAssign
9006: oEmit 77
9008: oGetLocal 1
9010: oPushResult
9011: oEmitLabel
9012: oPop 1
9014: oGetAddrLocal 2
9016: oPushResult
9017: oLabelNew
9018: oAssign
9019: oGetLocal 1
9021: oPushResult
9022: oGetLocal 2
9024: oPushResult
9025: oLoopPush
9026: oPop 2
9028: oCall 8078
9030: oInputChoice 9061
9032: oCall 8078
9034: oJumpForward 9067
9036: oGetAddrLocal 3
9038: oPushResult
9039: oCall 4581
9041: oPop 1
9043: oEmit 78
9045: oGetLocal 3
9047: oPushResult
9048: oEmitLabel
9049: oPop 1
9051: oGetLocal 1
9053: oPushResult
9054: oEmitLabel
9055: oPop 1
9057: oJumpForward 9069
9059: oJumpForward 9067
9061: Choice Lookup Table
          50   9036
           5   9032
9066: oEndChoice
9067: oJumpBack 9030
9069: oEmit 77
9071: oGetLocal 2
9073: oPushResult
9074: oEmitLabel
9075: oPop 1
9077: oLoopPop
9078: oReturn
9079: oLocalSpace 2
9081: oGetAddrLocal 1
9083: oPushResult
9084: oLabelNew
9085: oAssign
9086: oEmit 77
9088: oGetLocal 1
9090: oPushResult
9091: oEmitLabel
9092: oPop 1
9094: oGetAddrLocal 2
9096: oPushResult
9097: oCall 4581
9099: oPop 1
9101: oGetLocal 1
9103: oPushResult
9104: oGetLocal 2
9106: oPushResult
9107: oLoopPush
9108: oPop 2
9110: oInput 47
9112: oCall 8078
9114: oEmit 68
9116: oGetLocal 1
9118: oPushResult
9119: oEmitLabel
9120: oPop 1
9122: oEmit 77
9124: oGetLocal 2
9126: oPushResult
9127: oEmitLabel
9128: oPop 1
9130: oLoopPop
9131: oReturn
9132: oLocalSpace 0
9134: oLoopContinueLabel
9135: oPushResult
9136: oSetResult 0
9138: oPushResult
9139: equal_label
9140: oPop 2
9142: oChoice 9157
9144: oError 18
9146: oJumpForward 9163
9148: oEmit 68
9150: oLoopContinueLabel
9151: oPushResult
9152: oEmitLabel
9153: oPop 1
9155: oJumpForward 9163
9157: Choice Lookup Table
           0   9148
           1   9144
9162: oEndChoice
9163: oReturn
9164: oLocalSpace 0
9166: oLoopBreakLabel
9167: oPushResult
9168: oSetResult 0
9170: oPushResult
9171: equal_label
9172: oPop 2
9174: oChoice 9189
9176: oError 18
9178: oJumpForward 9195
9180: oEmit 68
9182: oLoopBreakLabel
9183: oPushResult
9184: oEmitLabel
9185: oPop 1
9187: oJumpForward 9195
9189: Choice Lookup Table
           0   9180
           1   9176
9194: oEndChoice
9195: oReturn
9196: oLocalSpace 7
9198: oGetAddrLocal 1
9200: oPushResult
9201: oCodeNew
9202: oAssign
9203: oGetAddrLocal 2
9205: oPushResult
9206: oLabelNew
9207: oAssign
9208: oGetAddrLocal 3
9210: oPushResult
9211: oLabelNew
9212: oAssign
9213: oGetAddrLocal 4
9215: oPushResult
9216: oGetLocal 3
9218: oAssign
9219: oCall 4558
9221: oTypeSNodeType
9222: oChoice 9248
9224: oEmit 71
9226: oGetLocal 2
9228: oPushResult
9229: oEmitLabel
9230: oPop 1
9232: oJumpForward 9265
9234: oEmit 72
9236: oGetLocal 2
9238: oPushResult
9239: oEmitLabel
9240: oPop 1
9242: oJumpForward 9265
9244: oError 16
9246: oJumpForward 9265
9248: Choice Lookup Table
          39   9244
          40   9244
          41   9234
          29   9234
          33   9224
          30   9224
          31   9224
9263: oError 17
9265: oInput 40
9267: oInputChoice 9314
9269: oGetAddrLocal 4
9271: oPushResult
9272: oLabelNew
9273: oAssign
9274: oEmit 77
9276: oGetLocal 4
9278: oPushResult
9279: oEmitLabel
9280: oPop 1
9282: oInputChoice 9288
9284: oJumpForward 9306
9286: oJumpForward 9304
9288: Choice Lookup Table
          36   9284
9291: oCall 8078
9293: oInputChoice 9297
9295: oJumpForward 9304
9297: Choice Lookup Table
           5   9295
9300: oInput 36
9302: oJumpForward 9306
9304: oJumpBack 9282
9306: oJumpForward 9434
9308: oJumpForward 9432
9310: oJumpForward 9434
9312: oJumpForward 9432
9314: Choice Lookup Table
          36   9310
          43   9269
          54   9269
9321: oGetAddrLocal 5
9323: oPushResult
9324: oLabelNew
9325: oAssign
9326: oGetLocal 1
9328: oPushResult
9329: oCodePush
9330: oPop 1
9332: oCall 3526
9334: oCall 4268
9336: oGetAddrLocal 6
9338: oPushResult
9339: oValueTop
9340: oAssign
9341: oValuePop
9342: oInputChoice 9376
9344: oCall 3526
9346: oCall 4268
9348: oGetAddrLocal 7
9350: oPushResult
9351: oValueTop
9352: oAssign
9353: oValuePop
9354: oEmit 75
9356: oGetLocal 6
9358: oPushResult
9359: oEmitInt
9360: oPop 1
9362: oGetLocal 7
9364: oPushResult
9365: oEmitInt
9366: oPop 1
9368: oGetLocal 5
9370: oPushResult
9371: oEmitLabel
9372: oPop 1
9374: oJumpForward 9393
9376: Choice Lookup Table
          21   9344
9379: oEmit 74
9381: oGetLocal 6
9383: oPushResult
9384: oEmitInt
9385: oPop 1
9387: oGetLocal 5
9389: oPushResult
9390: oEmitLabel
9391: oPop 1
9393: oInputChoice 9397
9395: oJumpForward 9402
9397: Choice Lookup Table
          13   9395
9400: oJumpForward 9404
9402: oJumpBack 9332
9404: oCodePop
9405: oInput 12
9407: oEmit 77
9409: oGetLocal 5
9411: oPushResult
9412: oEmitLabel
9413: oPop 1
9415: oCall 8078
9417: oEmit 68
9419: oGetLocal 3
9421: oPushResult
9422: oEmitLabel
9423: oPop 1
9425: oInputChoice 9429
9427: oJumpForward 9432
9429: Choice Lookup Table
           5   9427
9432: oJumpBack 9267
9434: oEmit 77
9436: oGetLocal 2
9438: oPushResult
9439: oEmitLabel
9440: oPop 1
9442: oGetLocal 1
9444: oPushResult
9445: oEmitCode
9446: oPop 1
9448: oEmit 76
9450: oGetLocal 4
9452: oPushResult
9453: oEmitLabel
9454: oPop 1
9456: oEmit 77
9458: oGetLocal 3
9460: oPushResult
9461: oEmitLabel
9462: oPop 1
9464: oTypeSPop
9465: oReturn
9466: oLocalSpace 1
9468: oInputChoice 9475
9470: oJumpForward 9481
9472: oChangeIntLitToLabelIdent
9473: oJumpForward 9481
9475: Choice Lookup Table
           1   9472
           0   9470
9480: oEndChoice
9481: oGetAddrLocal 1
9483: oPushResult
9484: oScopeCurrent
9485: oPushResult
9486: oScopeFindRequireInScope
9487: oPop 1
9489: oAssign
9490: oGetLocal 1
9492: oPushResult
9493: oSetResult 28
9495: oPushResult
9496: oSetResult 1
9498: oPushResult
9499: oNodeSetBoolean
9500: oPop 3
9502: oEmit 68
9504: oGetLocal 1
9506: oPushResult
9507: oSetResult 22
9509: oPushResult
9510: oNodeGetLabel
9511: oPop 2
9513: oPushResult
9514: oEmitLabel
9515: oPop 1
9517: oReturn
9518: oLocalSpace 0
9520: oCall 8078
9522: oInputChoice 9532
9524: oCall 8078
9526: oJumpForward 9538
9528: oJumpForward 9540
9530: oJumpForward 9538
9532: Choice Lookup Table
          36   9528
           5   9524
9537: oEndChoice
9538: oJumpBack 9522
9540: oReturn
9541: oLocalSpace 0
9543: oCall 9548
9545: oEmit 87
9547: oReturn
9548: oLocalSpace 0
9550: oInputChoice 9668
9552: oCall 4558
9554: oTypeSNodeType
9555: oChoice 9626
9557: oEmit 80
9559: oJumpForward 9649
9561: oEmit 81
9563: oJumpForward 9649
9565: oEmit 30
9567: oEmit 80
9569: oJumpForward 9649
9571: oEmit 82
9573: oJumpForward 9649
9575: oEmit 83
9577: oJumpForward 9649
9579: oError 16
9581: oJumpForward 9649
9583: oEmit 16
9585: oTypeSTop
9586: oPushResult
9587: oSetResult 43
9589: oPushResult
9590: oNodeGetInt
9591: oPop 2
9593: oPushResult
9594: oEmitInt
9595: oPop 1
9597: oEmit 86
9599: oJumpForward 9649
9601: oTypeSTop
9602: oPushResult
9603: oGetGlobal 10
9605: oPushResult
9606: equal_node
9607: oPop 2
9609: oChoice 9615
9611: oEmit 84
9613: oJumpForward 9620
9615: Choice Lookup Table
           1   9611
9618: oEmit 85
9620: oJumpForward 9649
9622: oEmit 85
9624: oJumpForward 9649
9626: Choice Lookup Table
          35   9622
          34   9601
          41   9583
          28   9579
          39   9575
          40   9575
          33   9571
          30   9565
          31   9561
          29   9557
9647: oError 17
9649: oTypeSPop
9650: oInputChoice 9658
9652: oJumpForward 9666
9654: oJumpForward 9664
9656: oJumpForward 9664
9658: Choice Lookup Table
          13   9656
          15   9652
9663: oEndChoice
9664: oJumpBack 9552
9666: oJumpForward 9671
9668: Choice Lookup Table
          14   9552
9671: oReturn
9672: oLocalSpace 0
9674: oReturn
9675: oLocalSpace 0
9677: oReturn
9678: oLocalSpace 1
9680: oGetAddrLocal 1
9682: oPushResult
9683: oGetGlobal 14
9685: oPushResult
9686: oScopeAllocType
9687: oPop 1
9689: oAssign
9690: oTypeSNodeType
9691: oChoice 9759
9693: oEmit 17
9695: oGetLocal 1
9697: oPushResult
9698: oEmitInt
9699: oPop 1
9701: oEmit 22
9703: oEmit 29
9705: oGetGlobal 14
9707: oPushResult
9708: oSetResult 17
9710: oPushResult
9711: oNodeGetInt
9712: oPop 2
9714: oPushResult
9715: oEmitInt
9716: oPop 1
9718: oJumpForward 9768
9720: oEmit 17
9722: oGetLocal 1
9724: oPushResult
9725: oEmitInt
9726: oPop 1
9728: oEmit 15
9730: oSetResult 1
9732: oPushResult
9733: oEmitInt
9734: oPop 1
9736: oEmit 27
9738: oEmit 17
9740: oGetLocal 1
9742: oPushResult
9743: oSetResult 1
9745: oPushResult
9746: add
9747: oPop 2
9749: oPushResult
9750: oEmitInt
9751: oPop 1
9753: oEmit 22
9755: oEmit 27
9757: oJumpForward 9768
9759: Choice Lookup Table
          33   9720
          39   9693
          40   9693
9766: oError 14
9768: oTypeSPop
9769: oEmit 17
9771: oGetLocal 1
9773: oPushResult
9774: oEmitInt
9775: oPop 1
9777: oGetGlobal 14
9779: oPushResult
9780: oTypeSPush
9781: oPop 1
9783: oGetLocal 1
9785: oReturn
9786: oReturn
9787: oLocalSpace 0
9789: oEmit 61
9791: oSetResult 16
9793: oPushResult
9794: oEmitInt
9795: oPop 1
9797: oEmit 19
9799: oSetResult 8
9801: oPushResult
9802: oEmitInt
9803: oPop 1
9805: oEmit 22
9807: oEmit 28
9809: oEmit 19
9811: oSetResult 0
9813: oPushResult
9814: oEmitInt
9815: oPop 1
9817: oEmit 22
9819: oEmit 28
9821: oEmit 64
9823: oGetGlobal 19
9825: oPushResult
9826: oCall 12994
9828: oPop 1
9830: oEmit 63
9832: oSetResult 16
9834: oPushResult
9835: oEmitInt
9836: oPop 1
9838: oTypeSPop
9839: oTypeSPop
9840: oReturn
9841: oLocalSpace 0
9843: oEmit 61
9845: oSetResult 12
9847: oPushResult
9848: oEmitInt
9849: oPop 1
9851: oEmit 19
9853: oSetResult 8
9855: oPushResult
9856: oEmitInt
9857: oPop 1
9859: oEmit 22
9861: oEmit 26
9863: oEmit 19
9865: oSetResult 0
9867: oPushResult
9868: oEmitInt
9869: oPop 1
9871: oEmit 22
9873: oEmit 28
9875: oEmit 64
9877: oGetGlobal 20
9879: oPushResult
9880: oCall 12994
9882: oPop 1
9884: oEmit 63
9886: oSetResult 12
9888: oPushResult
9889: oEmitInt
9890: oPop 1
9892: oTypeSPop
9893: oTypeSPop
9894: oReturn
9895: oLocalSpace 1
9897: oEmit 61
9899: oSetResult 24
9901: oPushResult
9902: oEmitInt
9903: oPop 1
9905: oEmit 19
9907: oSetResult 8
9909: oPushResult
9910: oEmitInt
9911: oPop 1
9913: oEmit 22
9915: oEmit 28
9917: oEmit 19
9919: oSetResult 0
9921: oPushResult
9922: oEmitInt
9923: oPop 1
9925: oEmit 22
9927: oEmit 28
9929: oGetAddrLocal 1
9931: oPushResult
9932: oGetGlobal 6
9934: oPushResult
9935: oScopeAllocType
9936: oPop 1
9938: oAssign
9939: oEmit 19
9941: oSetResult 16
9943: oPushResult
9944: oEmitInt
9945: oPop 1
9947: oEmit 17
9949: oGetLocal 1
9951: oPushResult
9952: oEmitInt
9953: oPop 1
9955: oEmit 28
9957: oEmit 64
9959: oGetGlobal 21
9961: oPushResult
9962: oCall 12994
9964: oPop 1
9966: oEmit 3
9968: oGetLocal 1
9970: oPushResult
9971: oEmitInt
9972: oPop 1
9974: oEmit 63
9976: oSetResult 24
9978: oPushResult
9979: oEmitInt
9980: oPop 1
9982: oTypeSPop
9983: oGetGlobal 6
9985: oPushResult
9986: oTypeSPush
9987: oPop 1
9989: oReturn
9990: oLocalSpace 10
9992: oGetParam 1
9994: oPushResult
9995: oSetResult 25
9997: oPushResult
9998: oNodeGetBoolean
9999: oPop 2
10001: oChoice 10028
10003: oGetParam 1
10005: oPushResult
10006: oSetResult 28
10008: oPushResult
10009: oNodeGetBoolean
10010: oPop 2
10012: oChoice 10023
10014: oGetParam 1
10016: oPushResult
10017: oCall 10610
10019: oPop 1
10021: oJumpForward 10026
10023: Choice Lookup Table
           0   10014
10026: oJumpForward 10031
10028: Choice Lookup Table
           1   10003
10031: oGetParam 1
10033: oPushResult
10034: oSetResult 28
10036: oPushResult
10037: oSetResult 1
10039: oPushResult
10040: oNodeSetBoolean
10041: oPop 3
10043: oGetAddrLocal 1
10045: oPushResult
10046: oGetParam 1
10048: oPushResult
10049: oSetResult 27
10051: oPushResult
10052: oNodeGetBoolean
10053: oPop 2
10055: oAssign
10056: oGetAddrLocal 4
10058: oPushResult
10059: oGetParam 1
10061: oPushResult
10062: oNodeType
10063: oPop 1
10065: oPushResult
10066: oSetResult 13
10068: oPushResult
10069: equal_node_type
10070: oPop 2
10072: oAssign
10073: oGetLocal 4
10075: oChoice 10102
10077: oGetAddrLocal 2
10079: oPushResult
10080: oGetParam 1
10082: oPushResult
10083: oSetResult 21
10085: oPushResult
10086: oNodeGet
10087: oPop 2
10089: oAssign
10090: oGetAddrLocal 3
10092: oPushResult
10093: oGetLocal 2
10095: oPushResult
10096: oScopeAllocType
10097: oPop 1
10099: oAssign
10100: oJumpForward 10105
10102: Choice Lookup Table
           1   10077
10105: oGetAddrLocal 5
10107: oPushResult
10108: oGetParam 1
10110: oPushResult
10111: oSetResult 23
10113: oPushResult
10114: oNodeGet
10115: oPop 2
10117: oAssign
10118: oGetAddrLocal 6
10120: oPushResult
10121: oGetLocal 5
10123: oPushResult
10124: oSetResult 17
10126: oPushResult
10127: oNodeGetInt
10128: oPop 2
10130: oAssign
10131: oGetLocal 1
10133: oChoice 10155
10135: oEmit 62
10137: oGetLocal 6
10139: oPushResult
10140: oEmitInt
10141: oPop 1
10143: oJumpForward 10161
10145: oEmit 61
10147: oGetLocal 6
10149: oPushResult
10150: oEmitInt
10151: oPop 1
10153: oJumpForward 10161
10155: Choice Lookup Table
           0   10145
           1   10135
10160: oEndChoice
10161: oGetParam 1
10163: oPushResult
10164: oCall 12928
10166: oPop 1
10168: oPushResult
10169: oSetResult 0
10171: oPushResult
10172: greater
10173: oPop 2
10175: oChoice 10208
10177: oEmit 19
10179: oSetResult 0
10181: oPushResult
10182: oEmitInt
10183: oPop 1
10185: oEmit 20
10187: oGetParam 1
10189: oPushResult
10190: oCall 12948
10192: oPop 1
10194: oPushResult
10195: oEmitInt
10196: oPop 1
10198: oSetResult 0
10200: oPushResult
10201: oEmitInt
10202: oPop 1
10204: oEmit 28
10206: oJumpForward 10211
10208: Choice Lookup Table
           1   10177
10211: oGetAddrLocal 7
10213: oPushResult
10214: oGetLocal 5
10216: oPushResult
10217: oSetResult 15
10219: oPushResult
10220: oNodeGetIter
10221: oPop 2
10223: oAssign
10224: oGetAddrLocal 8
10226: oPushResult
10227: oGetLocal 7
10229: oPushResult
10230: oNodeIterValue
10231: oPop 1
10233: oAssign
10234: oInputChoice 10431
10236: oGetLocal 8
10238: oPushResult
10239: oNodeNull
10240: oPop 1
10242: oChoice 10248
10244: oJumpForward 10427
10246: oJumpForward 10251
10248: Choice Lookup Table
           1   10244
10251: oGetAddrLocal 9
10253: oPushResult
10254: oGetLocal 8
10256: oPushResult
10257: oSetResult 22
10259: oPushResult
10260: oNodeGetInt
10261: oPop 2
10263: oAssign
10264: oEmit 19
10266: oGetLocal 9
10268: oPushResult
10269: oEmitInt
10270: oPop 1
10272: oGetLocal 8
10274: oPushResult
10275: oSetResult 21
10277: oPushResult
10278: oNodeGet
10279: oPop 2
10281: oPushResult
10282: oTypeSPush
10283: oPop 1
10285: oGetLocal 8
10287: oPushResult
10288: oSetResult 34
10290: oPushResult
10291: oNodeGetBoolean
10292: oPop 2
10294: oChoice 10380
10296: oSetResult 1
10298: oPushResult
10299: oCall 8518
10301: oPop 1
10303: oCall 7900
10305: oEmit 28
10307: oJumpForward 10386
10309: oCall 4558
10311: oCall 7748
10313: oTypeSNodeType
10314: oChoice 10354
10316: oEmit 26
10318: oJumpForward 10378
10320: oEmit 27
10322: oJumpForward 10378
10324: oError 16
10326: oJumpForward 10378
10328: oEmit 28
10330: oJumpForward 10378
10332: oGetAddrLocal 10
10334: oPushResult
10335: oTypeSTop
10336: oPushResult
10337: oSetResult 17
10339: oPushResult
10340: oNodeGetInt
10341: oPop 2
10343: oAssign
10344: oEmit 29
10346: oGetLocal 10
10348: oPushResult
10349: oEmitInt
10350: oPop 1
10352: oJumpForward 10378
10354: Choice Lookup Table
          40   10332
          38   10332
          36   10332
          35   10328
          34   10328
          28   10324
          33   10320
          30   10320
          31   10320
          41   10316
          29   10316
10377: oEndChoice
10378: oJumpForward 10386
10380: Choice Lookup Table
           0   10309
           1   10296
10385: oEndChoice
10386: oTypeSPop
10387: oGetAddrLocal 7
10389: oPushResult
10390: oNodeIterNext
10391: oPop 1
10393: oGetAddrLocal 8
10395: oPushResult
10396: oGetLocal 7
10398: oPushResult
10399: oNodeIterValue
10400: oPop 1
10402: oAssign
10403: oGetLocal 8
10405: oPushResult
10406: oNodeNull
10407: oPop 1
10409: oChoice 10417
10411: oJumpForward 10427
10413: oJumpForward 10423
10415: oJumpForward 10423
10417: Choice Lookup Table
           0   10415
           1   10411
10422: oEndChoice
10423: oInput 13
10425: oJumpBack 10236
10427: oInput 15
10429: oJumpForward 10434
10431: Choice Lookup Table
          14   10236
10434: oGetLocal 8
10436: oPushResult
10437: oNodeNull
10438: oPop 1
10440: oChoice 10446
10442: oError 15
10444: oJumpForward 10449
10446: Choice Lookup Table
           0   10442
10449: oGetLocal 4
10451: oChoice 10480
10453: oEmit 19
10455: oGetParam 1
10457: oPushResult
10458: oSetResult 31
10460: oPushResult
10461: oNodeGetInt
10462: oPop 2
10464: oPushResult
10465: oEmitInt
10466: oPop 1
10468: oEmit 17
10470: oGetLocal 3
10472: oPushResult
10473: oEmitInt
10474: oPop 1
10476: oEmit 28
10478: oJumpForward 10483
10480: Choice Lookup Table
           1   10453
10483: oGetLocal 1
10485: oChoice 10509
10487: oEmit 65
10489: oGetParam 1
10491: oPushResult
10492: oCall 12994
10494: oPop 1
10496: oJumpForward 10515
10498: oEmit 64
10500: oGetParam 1
10502: oPushResult
10503: oCall 12994
10505: oPop 1
10507: oJumpForward 10515
10509: Choice Lookup Table
           0   10498
           1   10487
10514: oEndChoice
10515: oGetLocal 4
10517: oChoice 10598
10519: oGetLocal 2
10521: oPushResult
10522: oTypeSPush
10523: oPop 1
10525: oTypeSNodeType
10526: oChoice 10572
10528: oEmit 3
10530: oGetLocal 3
10532: oPushResult
10533: oEmitInt
10534: oPop 1
10536: oJumpForward 10596
10538: oEmit 4
10540: oGetLocal 3
10542: oPushResult
10543: oEmitInt
10544: oPop 1
10546: oJumpForward 10596
10548: oError 16
10550: oJumpForward 10596
10552: oEmit 5
10554: oGetLocal 3
10556: oPushResult
10557: oEmitInt
10558: oPop 1
10560: oJumpForward 10596
10562: oEmit 17
10564: oGetLocal 3
10566: oPushResult
10567: oEmitInt
10568: oPop 1
10570: oJumpForward 10596
10572: Choice Lookup Table
          40   10562
          38   10562
          36   10562
          35   10552
          34   10552
          28   10548
          33   10538
          30   10538
          31   10538
          41   10528
          29   10528
10595: oEndChoice
10596: oJumpForward 10601
10598: Choice Lookup Table
           1   10519
10601: oEmit 63
10603: oGetLocal 6
10605: oPushResult
10606: oEmitInt
10607: oPop 1
10609: oReturn
10610: oLocalSpace 2
10612: oGetAddrLocal 2
10614: oPushResult
10615: oGetParam 1
10617: oPushResult
10618: oSetResult 26
10620: oPushResult
10621: oNodeGetString
10622: oPop 2
10624: oAssign
10625: oGetLocal 2
10627: oPushResult
10628: oSetResult 0
10630: oPushResult
10631: equal_string
10632: oPop 2
10634: oChoice 10671
10636: oGetAddrLocal 1
10638: oPushResult
10639: oGetParam 1
10641: oPushResult
10642: oSetResult 4
10644: oPushResult
10645: oNodeGetInt
10646: oPop 2
10648: oPushResult
10649: ID_STRING
10650: oPop 1
10652: oPushResult
10653: oStringAllocLit
10654: oPop 1
10656: oAssign
10657: oJumpForward 10677
10659: oGetAddrLocal 1
10661: oPushResult
10662: oGetLocal 2
10664: oPushResult
10665: oStringAllocLit
10666: oPop 1
10668: oAssign
10669: oJumpForward 10677
10671: Choice Lookup Table
           0   10659
           1   10636
10676: oEndChoice
10677: oEmit 79
10679: oGetParam 1
10681: oPushResult
10682: oCall 12994
10684: oPop 1
10686: oGetLocal 1
10688: oPushResult
10689: oEmitInt
10690: oPop 1
10692: oReturn
10693: oLocalSpace 0
10695: oGetParam 1
10697: oPushResult
10698: oGetGlobal 15
10700: oPushResult
10701: oNodeEqual
10702: oPop 2
10704: oChoice 10744
10706: oInput 14
10708: oCall 4558
10710: oTypeSNodeType
10711: oChoice 10719
10713: oJumpForward 10732
10715: oEmit 30
10717: oJumpForward 10732
10719: Choice Lookup Table
          33   10715
          30   10715
          31   10715
          41   10713
          29   10713
10730: oError 14
10732: oTypeSPop
10733: oGetGlobal 6
10735: oPushResult
10736: oTypeSPush
10737: oPop 1
10739: oInput 15
10741: oReturn
10742: oJumpForward 10747
10744: Choice Lookup Table
           1   10706
10747: oGetParam 1
10749: oPushResult
10750: oGetGlobal 16
10752: oPushResult
10753: oNodeEqual
10754: oPop 2
10756: oChoice 10790
10758: oInput 14
10760: oCall 4558
10762: oTypeSNodeType
10763: oChoice 10771
10765: oEmit 31
10767: oJumpForward 10778
10769: oJumpForward 10778
10771: Choice Lookup Table
          30   10769
          29   10765
10776: oError 14
10778: oTypeSPop
10779: oGetGlobal 9
10781: oPushResult
10782: oTypeSPush
10783: oPop 1
10785: oInput 15
10787: oReturn
10788: oJumpForward 10793
10790: Choice Lookup Table
           1   10758
10793: oGetParam 1
10795: oPushResult
10796: oGetGlobal 17
10798: oPushResult
10799: oNodeEqual
10800: oPop 2
10802: oChoice 10842
10804: oInput 14
10806: oCall 4558
10808: oTypeSNodeType
10809: oChoice 10830
10811: oTypeSTop
10812: oPushResult
10813: oSetResult 44
10815: oPushResult
10816: oNodeGetBoolean
10817: oPop 2
10819: oChoice 10825
10821: oError 28
10823: oJumpForward 10828
10825: Choice Lookup Table
           1   10821
10828: oJumpForward 10835
10830: Choice Lookup Table
          41   10811
10833: oError 14
10835: oEmit 33
10837: oInput 15
10839: oReturn
10840: oJumpForward 10845
10842: Choice Lookup Table
           1   10804
10845: oGetParam 1
10847: oPushResult
10848: oGetGlobal 18
10850: oPushResult
10851: oNodeEqual
10852: oPop 2
10854: oChoice 10894
10856: oInput 14
10858: oCall 4558
10860: oTypeSNodeType
10861: oChoice 10882
10863: oTypeSTop
10864: oPushResult
10865: oSetResult 44
10867: oPushResult
10868: oNodeGetBoolean
10869: oPop 2
10871: oChoice 10877
10873: oError 28
10875: oJumpForward 10880
10877: Choice Lookup Table
           1   10873
10880: oJumpForward 10887
10882: Choice Lookup Table
          41   10863
10885: oError 14
10887: oEmit 32
10889: oInput 15
10891: oReturn
10892: oJumpForward 10897
10894: Choice Lookup Table
           1   10856
10897: oError 16
10899: oReturn
10900: oLocalSpace 1
10902: oGetAddrLocal 1
10904: oPushResult
10905: oGetParam 2
10907: oPushResult
10908: oNodeNew
10909: oPop 1
10911: oAssign
10912: oGetLocal 1
10914: oPushResult
10915: oSetResult 17
10917: oPushResult
10918: oGetParam 1
10920: oPushResult
10921: oNodeSetInt
10922: oPop 3
10924: oGetLocal 1
10926: oPushResult
10927: oTypeAdd
10928: oPop 1
10930: oGetLocal 1
10932: oReturn
10933: oReturn
10934: oLocalSpace 12
10936: oInputChoice 11419
10938: oGetAddrLocal 1
10940: oPushResult
10941: oScopeFindRequire
10942: oAssign
10943: oGetAddrLocal 1
10945: oPushResult
10946: oCall 244
10948: oPop 1
10950: oGetLocal 1
10952: oPushResult
10953: oNodeType
10954: oPop 1
10956: oChoice 10973
10958: oGetParam 1
10960: oPushResult
10961: oGetLocal 1
10963: oPushResult
10964: oSetResult 21
10966: oPushResult
10967: oNodeGet
10968: oPop 2
10970: oAssign
10971: oJumpForward 10984
10973: Choice Lookup Table
          19   10958
10976: oError 2
10978: oGetParam 1
10980: oPushResult
10981: oGetGlobal 6
10983: oAssign
10984: oJumpForward 11442
10986: oInput 16
10988: oGetAddrLocal 2
10990: oPushResult
10991: oNodeVecNew
10992: oAssign
10993: oGetAddrLocal 3
10995: oPushResult
10996: oSetResult 37
10998: oPushResult
10999: oNodeNew
11000: oPop 1
11002: oAssign
11003: oCall 3526
11005: oGetLocal 3
11007: oPushResult
11008: oSetResult 39
11010: oPushResult
11011: oValueTop
11012: oPushResult
11013: oNodeSetInt
11014: oPop 3
11016: oValuePop
11017: oInput 21
11019: oCall 3526
11021: oGetLocal 3
11023: oPushResult
11024: oSetResult 40
11026: oPushResult
11027: oValueTop
11028: oPushResult
11029: oNodeSetInt
11030: oPop 3
11032: oValuePop
11033: oCall 4171
11035: oGetLocal 3
11037: oPushResult
11038: oSetResult 37
11040: oPushResult
11041: oTypeSTop
11042: oPushResult
11043: oNodeSet
11044: oPop 3
11046: oGetLocal 3
11048: oPushResult
11049: oSetResult 17
11051: oPushResult
11052: oTypeSTop
11053: oPushResult
11054: oSetResult 17
11056: oPushResult
11057: oNodeGetInt
11058: oPop 2
11060: oPushResult
11061: oNodeSetInt
11062: oPop 3
11064: oTypeSPop
11065: oGetLocal 3
11067: oPushResult
11068: oTypeAdd
11069: oPop 1
11071: oGetAddrLocal 4
11073: oPushResult
11074: oSetResult 36
11076: oPushResult
11077: oNodeNew
11078: oPop 1
11080: oAssign
11081: oGetLocal 4
11083: oPushResult
11084: oSetResult 38
11086: oPushResult
11087: oGetLocal 3
11089: oPushResult
11090: oNodeSet
11091: oPop 3
11093: oGetLocal 2
11095: oPushResult
11096: oGetLocal 4
11098: oPushResult
11099: oNodeVecAppend
11100: oPop 2
11102: oInputChoice 11110
11104: oJumpForward 11118
11106: oJumpForward 11116
11108: oJumpForward 11116
11110: Choice Lookup Table
          13   11108
          17   11104
11115: oEndChoice
11116: oJumpBack 10993
11118: oInput 40
11120: oGetAddrLocal 5
11122: oPushResult
11123: oCall 10934
11125: oPop 1
11127: oGetAddrLocal 6
11129: oPushResult
11130: oGetLocal 2
11132: oPushResult
11133: oNodeVecSize
11134: oPop 1
11136: oAssign
11137: oGetAddrLocal 6
11139: oPushResult
11140: dec
11141: oPop 1
11143: oGetAddrLocal 7
11145: oPushResult
11146: oGetLocal 2
11148: oPushResult
11149: oGetLocal 6
11151: oPushResult
11152: oNodeVecElement
11153: oPop 2
11155: oAssign
11156: oGetLocal 7
11158: oPushResult
11159: oSetResult 37
11161: oPushResult
11162: oGetLocal 5
11164: oPushResult
11165: oNodeSet
11166: oPop 3
11168: oGetAddrLocal 8
11170: oPushResult
11171: oGetLocal 7
11173: oPushResult
11174: oSetResult 38
11176: oPushResult
11177: oNodeGet
11178: oPop 2
11180: oAssign
11181: oGetAddrLocal 9
11183: oPushResult
11184: oGetLocal 8
11186: oPushResult
11187: oSetResult 40
11189: oPushResult
11190: oNodeGetInt
11191: oPop 2
11193: oPushResult
11194: oGetLocal 8
11196: oPushResult
11197: oSetResult 39
11199: oPushResult
11200: oNodeGetInt
11201: oPop 2
11203: oPushResult
11204: subtract
11205: oPop 2
11207: oAssign
11208: oGetAddrLocal 9
11210: oPushResult
11211: inc
11212: oPop 1
11214: oGetLocal 7
11216: oPushResult
11217: oSetResult 17
11219: oPushResult
11220: oGetLocal 9
11222: oPushResult
11223: oGetLocal 5
11225: oPushResult
11226: oSetResult 17
11228: oPushResult
11229: oNodeGetInt
11230: oPop 2
11232: oPushResult
11233: multiply
11234: oPop 2
11236: oPushResult
11237: oNodeSetInt
11238: oPop 3
11240: oGetLocal 7
11242: oPushResult
11243: oTypeAdd
11244: oPop 1
11246: oGetAddrLocal 5
11248: oPushResult
11249: oGetLocal 7
11251: oAssign
11252: oGetLocal 6
11254: oPushResult
11255: equal_zero
11256: oPop 1
11258: oChoice 11264
11260: oJumpForward 11269
11262: oJumpForward 11267
11264: Choice Lookup Table
           1   11260
11267: oJumpBack 11137
11269: oGetParam 1
11271: oPushResult
11272: oGetLocal 2
11274: oPushResult
11275: oSetResult 0
11277: oPushResult
11278: oNodeVecElement
11279: oPop 2
11281: oAssign
11282: oGetLocal 2
11284: oPushResult
11285: oNodeVecDelete
11286: oPop 1
11288: oJumpForward 11442
11290: oGetAddrLocal 10
11292: oPushResult
11293: oCall 10934
11295: oPop 1
11297: oGetParam 1
11299: oPushResult
11300: oGetLocal 10
11302: oPushResult
11303: oCall 12013
11305: oPop 1
11307: oAssign
11308: oJumpForward 11442
11310: oGetParam 1
11312: oPushResult
11313: oSetResult 38
11315: oPushResult
11316: oNodeNew
11317: oPop 1
11319: oAssign
11320: oSetResult -1
11322: oPushResult
11323: oSetResult 2
11325: oPushResult
11326: oScopeBegin
11327: oPop 2
11329: oSetResult 23
11331: oPushResult
11332: oCall 3227
11334: oPop 1
11336: oGetAddrLocal 11
11338: oPushResult
11339: oScopeCurrent
11340: oPushResult
11341: oSetResult 17
11343: oPushResult
11344: oNodeGetInt
11345: oPop 2
11347: oAssign
11348: oGetLocal 11
11350: oPushResult
11351: equal_zero
11352: oPop 1
11354: oChoice 11360
11356: oError 19
11358: oJumpForward 11363
11360: Choice Lookup Table
           1   11356
11363: oInput 36
11365: oGetFromParam 1
11367: oPushResult
11368: oSetResult 41
11370: oPushResult
11371: oScopeCurrent
11372: oPushResult
11373: oNodeSet
11374: oPop 3
11376: oGetFromParam 1
11378: oPushResult
11379: oSetResult 17
11381: oPushResult
11382: oGetLocal 11
11384: oPushResult
11385: oNodeSetInt
11386: oPop 3
11388: oScopeEnd
11389: oGetFromParam 1
11391: oPushResult
11392: oTypeAdd
11393: oPop 1
11395: oJumpForward 11442
11397: oGetParam 1
11399: oPushResult
11400: oCall 11443
11402: oPop 1
11404: oJumpForward 11442
11406: oInput 40
11408: oGetAddrLocal 12
11410: oPushResult
11411: oCall 10934
11413: oPop 1
11415: oError 16
11417: oJumpForward 11442
11419: Choice Lookup Table
          39   11406
          14   11397
          38   11310
          18   11290
          37   10986
           0   10938
11432: oCall 3526
11434: oInput 21
11436: oCall 3526
11438: oCall 4171
11440: oError 16
11442: oReturn
11443: oLocalSpace 11
11445: oGetParam 1
11447: oPushResult
11448: oSetResult 41
11450: oPushResult
11451: oNodeNew
11452: oPop 1
11454: oAssign
11455: oGetAddrLocal 1
11457: oPushResult
11458: oSetResult 0
11460: oAssign
11461: oGetAddrLocal 2
11463: oPushResult
11464: oSetResult 0
11466: oAssign
11467: oGetAddrLocal 3
11469: oPushResult
11470: oSetResult 1
11472: oAssign
11473: oGetAddrLocal 4
11475: oPushResult
11476: oScopeCurrent
11477: oAssign
11478: oSetResult -1
11480: oPushResult
11481: oSetResult 2
11483: oPushResult
11484: oScopeBegin
11485: oPop 2
11487: oInput 0
11489: oGetAddrLocal 5
11491: oPushResult
11492: oSetResult 17
11494: oPushResult
11495: LAST_ID
11496: oPushResult
11497: oCall 12966
11499: oPop 2
11501: oAssign
11502: oGetAddrLocal 6
11504: oPushResult
11505: oSetResult 17
11507: oPushResult
11508: LAST_ID
11509: oPushResult
11510: oCall 12966
11512: oPop 2
11514: oAssign
11515: oGetLocal 5
11517: oPushResult
11518: oSetResult 21
11520: oPushResult
11521: oGetFromParam 1
11523: oPushResult
11524: oNodeSet
11525: oPop 3
11527: oGetLocal 6
11529: oPushResult
11530: oSetResult 21
11532: oPushResult
11533: oGetFromParam 1
11535: oPushResult
11536: oNodeSet
11537: oPop 3
11539: oGetAddrLocal 7
11541: oPushResult
11542: LAST_ID
11543: oPushResult
11544: ID_STRING
11545: oPop 1
11547: oPushResult
11548: oStringAllocLit
11549: oPop 1
11551: oAssign
11552: oGetLocal 5
11554: oPushResult
11555: oSetResult 32
11557: oPushResult
11558: oGetLocal 7
11560: oPushResult
11561: oNodeSetInt
11562: oPop 3
11564: oGetLocal 6
11566: oPushResult
11567: oSetResult 32
11569: oPushResult
11570: oGetLocal 7
11572: oPushResult
11573: oNodeSetInt
11574: oPop 3
11576: oInputChoice 11654
11578: oGetGlobal 6
11580: oPushResult
11581: oTypeSPush
11582: oPop 1
11584: oCall 3526
11586: oCall 4268
11588: oTypeSPop
11589: oGetLocal 2
11591: oPushResult
11592: equal_zero
11593: oPop 1
11595: oChoice 11616
11597: oValueTop
11598: oPushResult
11599: oGetLocal 1
11601: oPushResult
11602: greater
11603: oPop 2
11605: oChoice 11611
11607: oError 26
11609: oJumpForward 11614
11611: Choice Lookup Table
           0   11607
11614: oJumpForward 11619
11616: Choice Lookup Table
           0   11597
11619: oGetLocal 1
11621: oPushResult
11622: oValueTop
11623: oPushResult
11624: equal
11625: oPop 2
11627: oChoice 11643
11629: oGetFromParam 1
11631: oPushResult
11632: oSetResult 44
11634: oPushResult
11635: oSetResult 1
11637: oPushResult
11638: oNodeSetBoolean
11639: oPop 3
11641: oJumpForward 11646
11643: Choice Lookup Table
           0   11629
11646: oGetAddrLocal 1
11648: oPushResult
11649: oValueTop
11650: oAssign
11651: oValuePop
11652: oJumpForward 11659
11654: Choice Lookup Table
           4   11578
           6   11578
11659: oGetLocal 5
11661: oPushResult
11662: oSetResult 22
11664: oPushResult
11665: oGetLocal 1
11667: oPushResult
11668: oNodeSetInt
11669: oPop 3
11671: oGetLocal 6
11673: oPushResult
11674: oSetResult 22
11676: oPushResult
11677: oGetLocal 1
11679: oPushResult
11680: oNodeSetInt
11681: oPop 3
11683: oGetLocal 5
11685: oPushResult
11686: oScopeDeclare
11687: oPop 1
11689: oGetLocal 4
11691: oPushResult
11692: oScopeEnter
11693: oPop 1
11695: oGetLocal 6
11697: oPushResult
11698: oScopeDeclare
11699: oPop 1
11701: oScopeEnd
11702: oGetAddrLocal 1
11704: oPushResult
11705: inc
11706: oPop 1
11708: oGetAddrLocal 2
11710: oPushResult
11711: inc
11712: oPop 1
11714: oInputChoice 11718
11716: oJumpForward 11723
11718: Choice Lookup Table
          13   11716
11721: oJumpForward 11725
11723: oJumpBack 11487
11725: oInput 15
11727: oGetFromParam 1
11729: oPushResult
11730: oSetResult 41
11732: oPushResult
11733: oScopeCurrent
11734: oPushResult
11735: oNodeSet
11736: oPop 3
11738: oGetFromParam 1
11740: oPushResult
11741: oSetResult 17
11743: oPushResult
11744: oSetResult 4
11746: oPushResult
11747: oNodeSetInt
11748: oPop 3
11750: oScopeEnd
11751: oGetGlobal 2
11753: oPushResult
11754: oCall 12864
11756: oPop 1
11758: oPushResult
11759: oCodePush
11760: oPop 1
11762: oGetGlobal 2
11764: oPushResult
11765: oScopeEnter
11766: oPop 1
11768: oGetAddrLocal 8
11770: oPushResult
11771: oGetLocal 2
11773: oPushResult
11774: oSetResult 1
11776: oPushResult
11777: add
11778: oPop 2
11780: oPushResult
11781: oSetResult 16
11783: oPushResult
11784: multiply
11785: oPop 2
11787: oAssign
11788: oGetAddrLocal 9
11790: oPushResult
11791: oGetLocal 8
11793: oPushResult
11794: oSetResult 8
11796: oPushResult
11797: oScopeAlloc
11798: oPop 2
11800: oAssign
11801: oScopeEnd
11802: oGetFromParam 1
11804: oPushResult
11805: oSetResult 43
11807: oPushResult
11808: oGetLocal 9
11810: oPushResult
11811: oNodeSetInt
11812: oPop 3
11814: oGetAddrLocal 10
11816: oPushResult
11817: oGetFromParam 1
11819: oPushResult
11820: oSetResult 41
11822: oPushResult
11823: oNodeGet
11824: oPop 2
11826: oPushResult
11827: oSetResult 15
11829: oPushResult
11830: oNodeGetIter
11831: oPop 2
11833: oAssign
11834: oGetAddrLocal 11
11836: oPushResult
11837: oGetLocal 10
11839: oPushResult
11840: oNodeIterValue
11841: oPop 1
11843: oAssign
11844: oGetLocal 11
11846: oPushResult
11847: oNodeNull
11848: oPop 1
11850: oChoice 11856
11852: oJumpForward 11943
11854: oJumpForward 11859
11856: Choice Lookup Table
           1   11852
11859: oEmit 16
11861: oGetLocal 9
11863: oPushResult
11864: oEmitInt
11865: oPop 1
11867: oEmit 15
11869: oGetLocal 11
11871: oPushResult
11872: oSetResult 22
11874: oPushResult
11875: oNodeGetInt
11876: oPop 2
11878: oPushResult
11879: oEmitInt
11880: oPop 1
11882: oEmit 26
11884: oGetAddrLocal 9
11886: oPushResult
11887: oGetLocal 9
11889: oPushResult
11890: oSetResult 8
11892: oPushResult
11893: add
11894: oPop 2
11896: oAssign
11897: oEmit 16
11899: oGetLocal 9
11901: oPushResult
11902: oEmitInt
11903: oPop 1
11905: oEmit 16
11907: oGetLocal 11
11909: oPushResult
11910: oSetResult 32
11912: oPushResult
11913: oNodeGetInt
11914: oPop 2
11916: oPushResult
11917: oEmitInt
11918: oPop 1
11920: oEmit 28
11922: oGetAddrLocal 9
11924: oPushResult
11925: oGetLocal 9
11927: oPushResult
11928: oSetResult 8
11930: oPushResult
11931: add
11932: oPop 2
11934: oAssign
11935: oGetAddrLocal 10
11937: oPushResult
11938: oNodeIterNext
11939: oPop 1
11941: oJumpBack 11834
11943: oEmit 16
11945: oGetLocal 9
11947: oPushResult
11948: oEmitInt
11949: oPop 1
11951: oEmit 15
11953: oSetResult 0
11955: oPushResult
11956: oEmitInt
11957: oPop 1
11959: oEmit 26
11961: oGetAddrLocal 9
11963: oPushResult
11964: oGetLocal 9
11966: oPushResult
11967: oSetResult 8
11969: oPushResult
11970: add
11971: oPop 2
11973: oAssign
11974: oEmit 16
11976: oGetLocal 9
11978: oPushResult
11979: oEmitInt
11980: oPop 1
11982: oEmit 15
11984: oSetResult 0
11986: oPushResult
11987: oEmitInt
11988: oPop 1
11990: oEmit 28
11992: oGetAddrLocal 9
11994: oPushResult
11995: oGetLocal 9
11997: oPushResult
11998: oSetResult 8
12000: oPushResult
12001: add
12002: oPop 2
12004: oAssign
12005: oCodePop
12006: oGetFromParam 1
12008: oPushResult
12009: oTypeAdd
12010: oPop 1
12012: oReturn
12013: oLocalSpace 1
12015: oGetAddrLocal 1
12017: oPushResult
12018: oGetParam 1
12020: oPushResult
12021: oSetResult 36
12023: oPushResult
12024: oNodeGet
12025: oPop 2
12027: oAssign
12028: oGetLocal 1
12030: oPushResult
12031: oNodeNull
12032: oPop 1
12034: oChoice 12090
12036: oGetAddrLocal 1
12038: oPushResult
12039: oSetResult 34
12041: oPushResult
12042: oNodeNew
12043: oPop 1
12045: oAssign
12046: oGetLocal 1
12048: oPushResult
12049: oSetResult 37
12051: oPushResult
12052: oGetParam 1
12054: oPushResult
12055: oNodeSet
12056: oPop 3
12058: oGetLocal 1
12060: oPushResult
12061: oSetResult 17
12063: oPushResult
12064: oSetResult 8
12066: oPushResult
12067: oNodeSetInt
12068: oPop 3
12070: oGetLocal 1
12072: oPushResult
12073: oTypeAdd
12074: oPop 1
12076: oGetParam 1
12078: oPushResult
12079: oSetResult 36
12081: oPushResult
12082: oGetLocal 1
12084: oPushResult
12085: oNodeSet
12086: oPop 3
12088: oJumpForward 12093
12090: Choice Lookup Table
           1   12036
12093: oGetLocal 1
12095: oReturn
12096: oReturn
12097: oLocalSpace 2
12099: oGetParam 1
12101: oPushResult
12102: oNodeType
12103: oPop 1
12105: oChoice 12175
12107: oMININT
12108: oReturn
12109: oJumpForward 12191
12111: oSetResult 0
12113: oReturn
12114: oJumpForward 12191
12116: oSetResult 0
12118: oReturn
12119: oJumpForward 12191
12121: oGetAddrLocal 1
12123: oPushResult
12124: oGetParam 1
12126: oPushResult
12127: oSetResult 41
12129: oPushResult
12130: oNodeGet
12131: oPop 2
12133: oAssign
12134: oGetAddrLocal 2
12136: oPushResult
12137: oGetLocal 1
12139: oPushResult
12140: oSetResult 15
12142: oPushResult
12143: oNodeGetIter
12144: oPop 2
12146: oPushResult
12147: oNodeIterValue
12148: oPop 1
12150: oAssign
12151: oGetLocal 2
12153: oPushResult
12154: oSetResult 22
12156: oPushResult
12157: oNodeGetInt
12158: oPop 2
12160: oReturn
12161: oJumpForward 12191
12163: oGetParam 1
12165: oPushResult
12166: oSetResult 39
12168: oPushResult
12169: oNodeGetInt
12170: oPop 2
12172: oReturn
12173: oJumpForward 12191
12175: Choice Lookup Table
          37   12163
          41   12121
          33   12116
          31   12111
          29   12107
12186: oError 3
12188: oSetResult 0
12190: oReturn
12191: oReturn
12192: oLocalSpace 2
12194: oGetParam 1
12196: oPushResult
12197: oNodeType
12198: oPop 1
12200: oChoice 12270
12202: oMAXINT
12203: oReturn
12204: oJumpForward 12286
12206: oSetResult 1
12208: oReturn
12209: oJumpForward 12286
12211: oSetResult 255
12213: oReturn
12214: oJumpForward 12286
12216: oGetAddrLocal 1
12218: oPushResult
12219: oGetParam 1
12221: oPushResult
12222: oSetResult 41
12224: oPushResult
12225: oNodeGet
12226: oPop 2
12228: oAssign
12229: oGetAddrLocal 2
12231: oPushResult
12232: oGetLocal 1
12234: oPushResult
12235: oSetResult 15
12237: oPushResult
12238: oNodeGetIterLast
12239: oPop 2
12241: oPushResult
12242: oNodeIterValue
12243: oPop 1
12245: oAssign
12246: oGetLocal 2
12248: oPushResult
12249: oSetResult 22
12251: oPushResult
12252: oNodeGetInt
12253: oPop 2
12255: oReturn
12256: oJumpForward 12286
12258: oGetParam 1
12260: oPushResult
12261: oSetResult 40
12263: oPushResult
12264: oNodeGetInt
12265: oPop 2
12267: oReturn
12268: oJumpForward 12286
12270: Choice Lookup Table
          37   12258
          41   12216
          33   12211
          31   12206
          29   12202
12281: oError 3
12283: oSetResult 0
12285: oReturn
12286: oReturn
12287: oLocalSpace 5
12289: oGetAddrGlobal 1
12291: oPushResult
12292: oWorkspaceNew
12293: oAssign
12294: oSetResult 0
12296: oPushResult
12297: oSetResult 0
12299: oPushResult
12300: oScopeBegin
12301: oPop 2
12303: oGetAddrLocal 2
12305: oPushResult
12306: oScopeCurrent
12307: oAssign
12308: oCall 13036
12310: oEmit 67
12312: oSetResult 0
12314: oPushResult
12315: oEmitInt
12316: oPop 1
12318: oGetAddrLocal 3
12320: oPushResult
12321: oLabelNew
12322: oAssign
12323: oEmit 61
12325: oSetResult 0
12327: oPushResult
12328: oEmitInt
12329: oPop 1
12331: oEmit 64
12333: oGetLocal 3
12335: oPushResult
12336: oEmitLabel
12337: oPop 1
12339: oEmit 63
12341: oSetResult 0
12343: oPushResult
12344: oEmitInt
12345: oPop 1
12347: oEmit 66
12349: oInput 28
12351: oInput 0
12353: oGetAddrLocal 4
12355: oPushResult
12356: oSetResult 4
12358: oPushResult
12359: oNodeNew
12360: oPop 1
12362: oAssign
12363: oGetLocal 4
12365: oPushResult
12366: oSetResult 4
12368: oPushResult
12369: LAST_ID
12370: oPushResult
12371: oNodeSetInt
12372: oPop 3
12374: oGetGlobal 1
12376: oPushResult
12377: oSetResult 2
12379: oPushResult
12380: oGetLocal 4
12382: oPushResult
12383: oNodeSet
12384: oPop 3
12386: oInputChoice 12460
12388: oInput 0
12390: oGetAddrLocal 1
12392: oPushResult
12393: oSetResult 20
12395: oPushResult
12396: LAST_ID
12397: oPushResult
12398: oCall 12966
12400: oPop 2
12402: oAssign
12403: oGetLocal 1
12405: oPushResult
12406: oSetResult 21
12408: oPushResult
12409: oGetGlobal 5
12411: oPushResult
12412: oNodeSet
12413: oPop 3
12415: oGetLocal 1
12417: oPushResult
12418: oScopeDeclareAlloc
12419: oPop 1
12421: oInput 13
12423: oInput 0
12425: oGetAddrLocal 1
12427: oPushResult
12428: oSetResult 20
12430: oPushResult
12431: LAST_ID
12432: oPushResult
12433: oCall 12966
12435: oPop 2
12437: oAssign
12438: oGetLocal 1
12440: oPushResult
12441: oSetResult 21
12443: oPushResult
12444: oGetGlobal 5
12446: oPushResult
12447: oNodeSet
12448: oPop 3
12450: oGetLocal 1
12452: oPushResult
12453: oScopeDeclareAlloc
12454: oPop 1
12456: oInput 15
12458: oJumpForward 12463
12460: Choice Lookup Table
          14   12388
12463: oInput 5
12465: oGetLocal 4
12467: oPushResult
12468: oCall 34
12470: oPop 1
12472: oInputChoice 12483
12474: oGetLocal 4
12476: oPushResult
12477: oCall 7
12479: oPop 1
12481: oJumpForward 12486
12483: Choice Lookup Table
          59   12474
12486: oGetLocal 4
12488: oPushResult
12489: oCall 287
12491: oPop 1
12493: oSetResult 0
12495: oPushResult
12496: oSetResult 0
12498: oPushResult
12499: oScopeBegin
12500: oPop 2
12502: oGetAddrGlobal 2
12504: oPushResult
12505: oScopeCurrent
12506: oAssign
12507: oSetResult 0
12509: oPushResult
12510: oSetResult 1
12512: oPushResult
12513: oScopeBegin
12514: oPop 2
12516: oScopeCurrent
12517: oPushResult
12518: oSetResult 16
12520: oPushResult
12521: oGetGlobal 2
12523: oPushResult
12524: oNodeSet
12525: oPop 3
12527: oGetAddrGlobal 3
12529: oPushResult
12530: oScopeCurrent
12531: oAssign
12532: oGetLocal 4
12534: oPushResult
12535: oSetResult 7
12537: oPushResult
12538: oGetGlobal 3
12540: oPushResult
12541: oNodeSet
12542: oPop 3
12544: oScopeEnd
12545: oSetResult 21
12547: oPushResult
12548: oCall 12615
12550: oPop 1
12552: oGetGlobal 3
12554: oPushResult
12555: oScopeEnter
12556: oPop 1
12558: oGetAddrLocal 5
12560: oPushResult
12561: oSetResult 1
12563: oAssign
12564: oGetLocal 3
12566: oPushResult
12567: oGetGlobal 2
12569: oPushResult
12570: oGetLocal 5
12572: oPushResult
12573: oCall 12766
12575: oPop 3
12577: oScopeEnd
12578: oInput 20
12580: oCall 12671
12582: oScopeEnd
12583: oGetLocal 4
12585: oPushResult
12586: oCall 349
12588: oPop 1
12590: oReturn
12591: oLocalSpace 0
12593: oGetParam 2
12595: oPushResult
12596: oCall 12615
12598: oPop 1
12600: oGetParam 1
12602: oPushResult
12603: oScopeCurrent
12604: oPushResult
12605: oSetResult 0
12607: oPushResult
12608: oCall 12766
12610: oPop 3
12612: oCall 12671
12614: oReturn
12615: oLocalSpace 0
12617: oInputChoice 12648
12619: oCall 2513
12621: oJumpForward 12663
12623: oCall 3171
12625: oJumpForward 12663
12627: oGetParam 1
12629: oPushResult
12630: oCall 3227
12632: oPop 1
12634: oJumpForward 12663
12636: oCall 3461
12638: oJumpForward 12663
12640: oCall 1736
12642: oJumpForward 12663
12644: oCall 2171
12646: oJumpForward 12663
12648: Choice Lookup Table
          30   12644
          29   12640
          34   12636
          33   12627
          32   12623
          31   12619
12661: oJumpForward 12665
12663: oJumpBack 12617
12665: oCall 12668
12667: oReturn
12668: oLocalSpace 0
12670: oReturn
12671: oLocalSpace 2
12673: oGetAddrLocal 1
12675: oPushResult
12676: oScopeCurrent
12677: oPushResult
12678: oSetResult 15
12680: oPushResult
12681: oNodeGetIter
12682: oPop 2
12684: oAssign
12685: oGetAddrLocal 2
12687: oPushResult
12688: oGetLocal 1
12690: oPushResult
12691: oNodeIterValue
12692: oPop 1
12694: oAssign
12695: oGetLocal 2
12697: oPushResult
12698: oNodeNull
12699: oPop 1
12701: oChoice 12705
12703: oJumpForward 12710
12705: Choice Lookup Table
           0   12703
12708: oJumpForward 12765
12710: oGetLocal 2
12712: oPushResult
12713: oNodeType
12714: oPop 1
12716: oChoice 12754
12718: oGetLocal 2
12720: oPushResult
12721: oSetResult 35
12723: oPushResult
12724: oNodeGetBoolean
12725: oPop 2
12727: oChoice 12749
12729: oGetLocal 2
12731: oPushResult
12732: oSetResult 28
12734: oPushResult
12735: oNodeGetBoolean
12736: oPop 2
12738: oChoice 12744
12740: oError 27
12742: oJumpForward 12747
12744: Choice Lookup Table
           1   12740
12747: oJumpForward 12752
12749: Choice Lookup Table
           0   12729
12752: oJumpForward 12757
12754: Choice Lookup Table
          26   12718
12757: oGetAddrLocal 1
12759: oPushResult
12760: oNodeIterNext
12761: oPop 1
12763: oJumpBack 12685
12765: oReturn
12766: oLocalSpace 3
12768: oEmit 77
12770: oGetParam 3
12772: oPushResult
12773: oEmitLabel
12774: oPop 1
12776: oEmit 67
12778: oGetAddrLocal 1
12780: oPushResult
12781: Here
12782: oAssign
12783: oEmit 90
12785: oGetParam 1
12787: oChoice 12793
12789: oCall 1220
12791: oJumpForward 12796
12793: Choice Lookup Table
           1   12789
12796: oGetAddrLocal 2
12798: oPushResult
12799: oGetParam 2
12801: oPushResult
12802: oSetResult 19
12804: oPushResult
12805: oNodeGetCode
12806: oPop 2
12808: oAssign
12809: oGetLocal 2
12811: oPushResult
12812: oEmitCode
12813: oPop 1
12815: oGetParam 2
12817: oPushResult
12818: oSetResult 19
12820: oPushResult
12821: oSetResult 0
12823: oPushResult
12824: oNodeSetCode
12825: oPop 3
12827: oCall 8078
12829: oGetParam 1
12831: oChoice 12837
12833: oCall 1305
12835: oJumpForward 12840
12837: Choice Lookup Table
           1   12833
12840: oEmit 66
12842: oGetAddrLocal 3
12844: oPushResult
12845: oScopeCurrent
12846: oPushResult
12847: oSetResult 17
12849: oPushResult
12850: oNodeGetInt
12851: oPop 2
12853: oAssign
12854: oGetLocal 1
12856: oPushResult
12857: oGetLocal 3
12859: oPushResult
12860: oPatch
12861: oPop 2
12863: oReturn
12864: oLocalSpace 1
12866: oGetAddrLocal 1
12868: oPushResult
12869: oGetParam 1
12871: oPushResult
12872: oSetResult 19
12874: oPushResult
12875: oNodeGetCode
12876: oPop 2
12878: oAssign
12879: oGetLocal 1
12881: oPushResult
12882: oSetResult 0
12884: oPushResult
12885: equal_code
12886: oPop 2
12888: oChoice 12909
12890: oGetAddrLocal 1
12892: oPushResult
12893: oCodeNew
12894: oAssign
12895: oGetParam 1
12897: oPushResult
12898: oSetResult 19
12900: oPushResult
12901: oGetLocal 1
12903: oPushResult
12904: oNodeSetCode
12905: oPop 3
12907: oJumpForward 12912
12909: Choice Lookup Table
           1   12890
12912: oGetLocal 1
12914: oReturn
12915: oReturn
12916: oLocalSpace 0
12918: oScopeCurrent
12919: oPushResult
12920: oSetResult 14
12922: oPushResult
12923: oNodeGetInt
12924: oPop 2
12926: oReturn
12927: oReturn
12928: oLocalSpace 0
12930: oGetParam 1
12932: oPushResult
12933: oSetResult 20
12935: oPushResult
12936: oNodeGet
12937: oPop 2
12939: oPushResult
12940: oSetResult 14
12942: oPushResult
12943: oNodeGetInt
12944: oPop 2
12946: oReturn
12947: oReturn
12948: oLocalSpace 0
12950: oCall 12916
12952: oPushResult
12953: oGetParam 1
12955: oPushResult
12956: oCall 12928
12958: oPop 1
12960: oPushResult
12961: subtract
12962: oPop 2
12964: oReturn
12965: oReturn
12966: oLocalSpace 1
12968: oGetAddrLocal 1
12970: oPushResult
12971: oGetParam 2
12973: oPushResult
12974: oNodeNew
12975: oPop 1
12977: oAssign
12978: oGetLocal 1
12980: oPushResult
12981: oSetResult 4
12983: oPushResult
12984: oGetParam 1
12986: oPushResult
12987: oNodeSetInt
12988: oPop 3
12990: oGetLocal 1
12992: oReturn
12993: oReturn
12994: oLocalSpace 0
12996: oGetParam 1
12998: oPushResult
12999: oSetResult 22
13001: oPushResult
13002: oNodeGetInt
13003: oPop 2
13005: oPushResult
13006: oEmitInt
13007: oPop 1
13009: oReturn
13010: oLocalSpace 1
13012: oGetAddrLocal 1
13014: oPushResult
13015: oSetResult 14
13017: oPushResult
13018: oGetParam 1
13020: oPushResult
13021: oCall 12966
13023: oPop 2
13025: oAssign
13026: oGetLocal 1
13028: oPushResult
13029: oScopeDeclare
13030: oPop 1
13032: oGetLocal 1
13034: oReturn
13035: oReturn
13036: oLocalSpace 1
13038: oGetAddrGlobal 4
13040: oPushResult
13041: oId_mysystem
13042: oAssign
13043: oGetAddrGlobal 5
13045: oPushResult
13046: oSetResult 28
13048: oPushResult
13049: oSetResult 4
13051: oPushResult
13052: oCall 10900
13054: oPop 2
13056: oAssign
13057: oGetAddrGlobal 6
13059: oPushResult
13060: oSetResult 29
13062: oPushResult
13063: oSetResult 4
13065: oPushResult
13066: oCall 10900
13068: oPop 2
13070: oAssign
13071: oGetAddrGlobal 7
13073: oPushResult
13074: oSetResult 31
13076: oPushResult
13077: oSetResult 1
13079: oPushResult
13080: oCall 10900
13082: oPop 2
13084: oAssign
13085: oGetAddrGlobal 8
13087: oPushResult
13088: oSetResult 32
13090: oPushResult
13091: oSetResult 1
13093: oPushResult
13094: oCall 10900
13096: oPop 2
13098: oAssign
13099: oGetAddrGlobal 9
13101: oPushResult
13102: oSetResult 33
13104: oPushResult
13105: oSetResult 1
13107: oPushResult
13108: oCall 10900
13110: oPop 2
13112: oAssign
13113: oGetAddrGlobal 10
13115: oPushResult
13116: oGetGlobal 9
13118: oPushResult
13119: oCall 12013
13121: oPop 1
13123: oAssign
13124: oGetAddrGlobal 11
13126: oPushResult
13127: oSetResult 30
13129: oPushResult
13130: oSetResult 1
13132: oPushResult
13133: oCall 10900
13135: oPop 2
13137: oAssign
13138: oGetAddrGlobal 12
13140: oPushResult
13141: oSetResult 35
13143: oPushResult
13144: oSetResult 8
13146: oPushResult
13147: oCall 10900
13149: oPop 2
13151: oAssign
13152: oGetGlobal 12
13154: oPushResult
13155: oSetResult 37
13157: oPushResult
13158: oGetGlobal 11
13160: oPushResult
13161: oNodeSet
13162: oPop 3
13164: oGetAddrGlobal 13
13166: oPushResult
13167: oSetResult 39
13169: oPushResult
13170: oSetResult 256
13172: oPushResult
13173: oCall 10900
13175: oPop 2
13177: oAssign
13178: oGetAddrGlobal 14
13180: oPushResult
13181: oSetResult 40
13183: oPushResult
13184: oSetResult 256
13186: oPushResult
13187: oCall 10900
13189: oPop 2
13191: oAssign
13192: oGetGlobal 14
13194: oPushResult
13195: oSetResult 42
13197: oPushResult
13198: oSetResult 255
13200: oPushResult
13201: oNodeSetInt
13202: oPop 3
13204: oGetAddrLocal 1
13206: oPushResult
13207: oSetResult 19
13209: oPushResult
13210: oId_File
13211: oPushResult
13212: oCall 12966
13214: oPop 2
13216: oAssign
13217: oGetLocal 1
13219: oPushResult
13220: oSetResult 21
13222: oPushResult
13223: oGetGlobal 5
13225: oPushResult
13226: oNodeSet
13227: oPop 3
13229: oGetLocal 1
13231: oPushResult
13232: oScopeDeclare
13233: oPop 1
13235: oGetAddrLocal 1
13237: oPushResult
13238: oSetResult 19
13240: oPushResult
13241: oId_Integer
13242: oPushResult
13243: oCall 12966
13245: oPop 2
13247: oAssign
13248: oGetLocal 1
13250: oPushResult
13251: oSetResult 21
13253: oPushResult
13254: oGetGlobal 6
13256: oPushResult
13257: oNodeSet
13258: oPop 3
13260: oGetLocal 1
13262: oPushResult
13263: oScopeDeclare
13264: oPop 1
13266: oGetAddrLocal 1
13268: oPushResult
13269: oSetResult 19
13271: oPushResult
13272: oId_Boolean
13273: oPushResult
13274: oCall 12966
13276: oPop 2
13278: oAssign
13279: oGetLocal 1
13281: oPushResult
13282: oSetResult 21
13284: oPushResult
13285: oGetGlobal 7
13287: oPushResult
13288: oNodeSet
13289: oPop 3
13291: oGetLocal 1
13293: oPushResult
13294: oScopeDeclare
13295: oPop 1
13297: oGetAddrLocal 1
13299: oPushResult
13300: oSetResult 19
13302: oPushResult
13303: oId_Char
13304: oPushResult
13305: oCall 12966
13307: oPop 2
13309: oAssign
13310: oGetLocal 1
13312: oPushResult
13313: oSetResult 21
13315: oPushResult
13316: oGetGlobal 9
13318: oPushResult
13319: oNodeSet
13320: oPop 3
13322: oGetLocal 1
13324: oPushResult
13325: oScopeDeclare
13326: oPop 1
13328: oGetAddrLocal 1
13330: oPushResult
13331: oSetResult 19
13333: oPushResult
13334: oId_Byte
13335: oPushResult
13336: oCall 12966
13338: oPop 2
13340: oAssign
13341: oGetLocal 1
13343: oPushResult
13344: oSetResult 21
13346: oPushResult
13347: oGetGlobal 11
13349: oPushResult
13350: oNodeSet
13351: oPop 3
13353: oGetLocal 1
13355: oPushResult
13356: oScopeDeclare
13357: oPop 1
13359: oGetAddrLocal 1
13361: oPushResult
13362: oSetResult 19
13364: oPushResult
13365: oId_Pointer
13366: oPushResult
13367: oCall 12966
13369: oPop 2
13371: oAssign
13372: oGetLocal 1
13374: oPushResult
13375: oSetResult 21
13377: oPushResult
13378: oGetGlobal 12
13380: oPushResult
13381: oNodeSet
13382: oPop 3
13384: oGetLocal 1
13386: oPushResult
13387: oScopeDeclare
13388: oPop 1
13390: oGetAddrLocal 1
13392: oPushResult
13393: oSetResult 19
13395: oPushResult
13396: oId_ShortString
13397: oPushResult
13398: oCall 12966
13400: oPop 2
13402: oAssign
13403: oGetLocal 1
13405: oPushResult
13406: oSetResult 21
13408: oPushResult
13409: oGetGlobal 14
13411: oPushResult
13412: oNodeSet
13413: oPop 3
13415: oGetLocal 1
13417: oPushResult
13418: oScopeDeclare
13419: oPop 1
13421: oGetAddrLocal 1
13423: oPushResult
13424: oSetResult 16
13426: oPushResult
13427: oId_True
13428: oPushResult
13429: oCall 12966
13431: oPop 2
13433: oAssign
13434: oGetLocal 1
13436: oPushResult
13437: oSetResult 21
13439: oPushResult
13440: oGetGlobal 7
13442: oPushResult
13443: oNodeSet
13444: oPop 3
13446: oGetLocal 1
13448: oPushResult
13449: oSetResult 22
13451: oPushResult
13452: oSetResult 1
13454: oPushResult
13455: oNodeSetInt
13456: oPop 3
13458: oGetLocal 1
13460: oPushResult
13461: oScopeDeclare
13462: oPop 1
13464: oGetAddrLocal 1
13466: oPushResult
13467: oSetResult 16
13469: oPushResult
13470: oId_False
13471: oPushResult
13472: oCall 12966
13474: oPop 2
13476: oAssign
13477: oGetLocal 1
13479: oPushResult
13480: oSetResult 21
13482: oPushResult
13483: oGetGlobal 7
13485: oPushResult
13486: oNodeSet
13487: oPop 3
13489: oGetLocal 1
13491: oPushResult
13492: oSetResult 22
13494: oPushResult
13495: oSetResult 0
13497: oPushResult
13498: oNodeSetInt
13499: oPop 3
13501: oGetLocal 1
13503: oPushResult
13504: oScopeDeclare
13505: oPop 1
13507: oGetAddrLocal 1
13509: oPushResult
13510: oSetResult 16
13512: oPushResult
13513: oId_Nil
13514: oPushResult
13515: oCall 12966
13517: oPop 2
13519: oAssign
13520: oGetLocal 1
13522: oPushResult
13523: oSetResult 21
13525: oPushResult
13526: oGetGlobal 12
13528: oPushResult
13529: oNodeSet
13530: oPop 3
13532: oGetLocal 1
13534: oPushResult
13535: oSetResult 22
13537: oPushResult
13538: oSetResult 0
13540: oPushResult
13541: oNodeSetInt
13542: oPop 3
13544: oGetLocal 1
13546: oPushResult
13547: oScopeDeclare
13548: oPop 1
13550: oGetAddrGlobal 15
13552: oPushResult
13553: oId_Ord
13554: oPushResult
13555: oCall 13010
13557: oPop 1
13559: oAssign
13560: oGetAddrGlobal 16
13562: oPushResult
13563: oId_Chr
13564: oPushResult
13565: oCall 13010
13567: oPop 1
13569: oAssign
13570: oGetAddrGlobal 17
13572: oPushResult
13573: oId_Pred
13574: oPushResult
13575: oCall 13010
13577: oPop 1
13579: oAssign
13580: oGetAddrGlobal 18
13582: oPushResult
13583: oId_Succ
13584: oPushResult
13585: oCall 13010
13587: oPop 1
13589: oAssign
13590: oReturn
