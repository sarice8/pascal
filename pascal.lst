   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 215:    oScopeBegin( 0, allocDown )
 224:    initScope = oScopeCurrent
 229:    oNodeSet( program, qMainRoutineScope, initScope )
 241:    oScopeEnd
      
 242:    @BlockDecls( nGlobalVar )
      
      
 249:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 255:    boolean isMain = true
 261:    @BlockStmt( mainLabel, globalScope, isMain )
      
 274:    oScopeEnd   % main routine scope
      
 275:    '.'
 277:    oScopeEnd   % global scope
 278:    @EndUsedUnits( program )   % used units scopes
 286:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 286: UsesClause( Node user ):
 288:    {
 288:       pIdent
 290:       Node unit = @FindOrCompileUnit( LAST_ID )
 300:       [ equal_node( unit, Null )
 310:          | false :
 311:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 323:             Node unitRef = oNodeNew( nUnitRef )
 333:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 352:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 371:             oScopeDeclare( unitRef )
 377:          | * :
 382:       ]
 382:       [
 382:          | ',' :
 384:          | * :  >
 391:       ]
 391:    }   
 393:    ';'
 396:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 396: ResolveUnitRef( inout Node decl ):
 398:    [ oNodeType( decl )
 405:       | nUnitRef :
 406:          Node scope = oNodeGet( decl, qPublicScope )
 419:          '.'
 421:          pIdent
 423:          decl = oScopeFindRequireInScope( scope )
 433:       | * :
 438:    ];
      
      
 439: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 441:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 454:    {
 454:       Node unit = oNodeIterValue( unitIt )
 464:       [ oNodeNull( unit )
 471:          | false :
 472:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 485:          | * :
 490:             >
 492:       ]
 492:       oNodeIterNext( unitIt )
 498:    }
 501:    ;
      
 501: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 503:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 516:    {
 516:       Node unit = oNodeIterValue( unitIt )
 526:       [ oNodeNull( unit )
 533:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 534:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 550:                | true :
 551:                | false :  #eInternalScopeMismatch
 555:             ]
 563:             oScopeEnd
 564:          | * :
 569:             >
 571:       ]
 571:       oNodeIterPrev( unitIt )
 577:    }
 580:    ;
      
      
 580: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 582:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 601:    [ equal_node( unit, Null )
 611:       | false :  >> unit
 615:       | * :
 620:    ]
      
         % If not, search for the source file on disk
 620:    boolean ok = oIncludeUnitFile( id )
 630:    [ ok
 633:       | false :  #eCantFindUnitFile  >> Null
 639:       | * :
 644:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 644:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 650:    oIncludeEnd
 651:    >> unit;
      
      
      
 655: Unit >> Node:
 657:    pUnit
 659:    pIdent
 661:    Node unit = oNodeNew( nUnit )
 671:    oNodeSetInt( unit, qIdent, LAST_ID )
 682:    Node unitImpl = oNodeNew( nUnitImpl )
 692:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 703:    oNodeSet( unit, qImpl, unitImpl )
 715:    ';'
      
         % mandatory sections
      
 717:    pInterface
 719:    [
 719:       | pUses :   @UsesClause( unit )
 728:       | * :
 733:    ]
 733:    @EnterUsedUnits( unit )
      
 740:    oScopeBegin( 0, allocGlobal )
 749:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 760:    oScopeBegin( 0, allocDown )
 769:    initScope = oScopeCurrent
 774:    oNodeSet( unit, qInitRoutineScope, initScope )
 786:    oScopeEnd
      
 787:    @UnitInterface( unit )
 794:    oScopeEnd  % interface scope
      
 795:    pImplementation
 797:    [
 797:       | pUses :   @UsesClause( unitImpl )
 806:       | * :
 811:    ]
 811:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 818:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
      
 831:    oScopeBegin( 0, allocGlobal )
 840:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 851:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 869:    @UnitImplementation( unit )
      
 876:    [
 876:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 888:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 903:    ]
 903:    [
 903:       | pFinalization :  @UnitFinalization( unit, true )
 915:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 930:    ]
 930:    pEnd  '.'
      
 934:    oScopeEnd  % impl scope
 935:    oScopeEnd  % interface scope
 936:    @EndUsedUnits( unitImpl )  % used units scopes
 943:    @EndUsedUnits( unit )
 950:    oNodeAddLast( workspace, qUnits, unit )
 962:    >> unit;
      
      
 966: UnitInterface( Node unit ):
 968:    {[
 968:       | pConst :     @ConstDecl
 972:       | pType :      @TypeDecl
 976:       | pVar :       @VarDecl( nGlobalVar )
      
 985:       | pProcedure :
 987:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 993:          [
 993:             | pExternal :
 995:                @ExternalDecl( decl )
1002:                ';'
1004:             | * :
1009:          ]
      
1009:       | pFunction :
1011:          Node decl = @FuncHeaderDecl
1017:          [
1017:             | pExternal :
1019:                @ExternalDecl( decl )
1026:                ';'
1028:             | * :
1033:          ]
      
1033:       | * :          >
1048:    ]}
1051:    ;
      
1051: UnitImplementation( Node unit ):
1053:    @BlockDecls( nGlobalVar )
1061:    ;
      
      
1061: UnitInitialization( Node unit, boolean hasStmts ):
1063:    Label label = oLabelNew
1068:    .tLabel  oEmitLabel( label )
1076:    oNodeSetLabel( unit, qInitLabel, label )
      
1088:    int patchLS
1088:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1097:    Node scope
1097:    Code initCode
      
1097:    scope = oNodeGet( unit, qPublicScope )
1110:    initCode = oNodeGetCode( scope, qInitCode )
1123:    oEmitCode( initCode )
1129:    oNodeSetCode( scope, qInitCode, codeNull )
      
1141:    scope = oNodeGet( unit, qPrivateScope )
1154:    initCode = oNodeGetCode( scope, qInitCode )
1167:    oEmitCode( initCode )
1173:    oNodeSetCode( scope, qInitCode, codeNull )
      
1185:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1198:    [ hasStmts
1201:       | true :     
1202:          @Statement
1204:          {[
1204:             | ';' :  @Statement
1208:             | * :    >
1215:          ]}
1217:       | * :
1222:    ]
      
1222:    .tReturn
      
1224:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1236:    oPatch( patchLS, localSpace )
1245:    oScopeEnd   % init routine scope, for temporaries
1247:    ;
      
      
1247: UnitFinalization( Node unit, boolean hasStmts ):
1249:    Label label = oLabelNew
1254:    .tLabel  oEmitLabel( label )
1262:    oNodeSetLabel( unit, qFinalLabel, label )
      
1274:    int patchLS
1274:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1283:    oScopeBegin( 0, allocDown )
      
1292:    [ hasStmts
1295:       | true :     
1296:          @Statement
1298:          {[
1298:             | ';' :  @Statement
1302:             | * :    >
1309:          ]}
1311:       | * :
1316:    ]
      
1316:    .tReturn
      
1318:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1330:    oPatch( patchLS, localSpace )
1339:    oScopeEnd   % final routine scope, for temporaries
1341:    ;
      
      
1341: Block( node_type varNodeType, Label labelForBody ):
1343:    @BlockDecls( varNodeType )
1350:    @BlockStmt( labelForBody, oScopeCurrent, false )
1363:    ;
      
      
1363: BlockDecls( node_type varNodeType ):
1365:    {[
1365:       | pConst :     @ConstDecl
1369:       | pType :      @TypeDecl
1373:       | pVar :       @VarDecl( varNodeType )
1382:       | pProcedure : @ProcDecl
1386:       | pFunction :  @FuncDecl
1390:       | * :          >
1405:    ]}
1407:    @CheckForUndefinedMethods
1410:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1410: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1413:    ;
      
      
1413: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1415:    NodeIter it = oNodeGetIter( workspace, qUnits )
1428:    {
1428:       Node unit = oNodeIterValue( it )
1438:       [ oNodeNull( unit )
1445:          | true :  >
1448:          | false :
1450:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1458:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1473:             .tFreeActuals  oEmitInt( 0 )
1481:             oNodeIterNext( it )
1487:       ]
1495:    };
      
      
1498: FinalizeUnits:
1500:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1513:    {
1513:       Node unit = oNodeIterValue( it )
1523:       [ oNodeNull( unit )
1530:          | true :  >
1533:          | false :
1535:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1543:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1558:             .tFreeActuals  oEmitInt( 0 )
1566:             oNodeIterPrev( it )
1572:       ]
1580:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1583: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1585:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1593:    int patchLS
1593:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1602:    [ isMain
1605:       | true :  @InitializeUnits
1608:       | * :
1613:    ]
      
         % insert any code for initialization of this scope's variables
1613:    Code initCode = oNodeGetCode( varScope, qInitCode )
1626:    oEmitCode( initCode )
1632:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1644:    @Statement
      
1646:    [ isMain
1649:       | true :  @FinalizeUnits
1652:       | * :
1657:    ]
      
1657:    .tReturn
      
1659:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1671:    oPatch( patchLS, localSpace )
1681:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1681: MethodModifiers( Node decl ):
1683:    {[
1683:       | pCdecl :
1685:          oNodeSetBoolean( decl, qCdecl, true )
1697:          ';'
      
1699:       | * : >
1706:    ]}
1709:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1709: GetOrCreateInitCode >> Code:
1711:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1723:    [ equal_code( initCode, codeNull )
1733:       | true :
1734:          initCode = oCodeNew
1739:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1750:       | * :
1755:    ]
1755:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1759: ExternalDecl( Node decl ):
1761:    [ equal_zero( @DeclLevel( decl ) )
1773:       | false :  #eExternalMethodCannotBeNested
1776:       | * :
1781:    ]
1781:    oNodeSetBoolean( decl, qExternal, true )
1793:    [
1793:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1795:          [
1795:             | pName :
1797:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1799:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1810:             | * :
1815:          ]
1815:       | * :
1820:    ]
1821:    ;
      
      
1821: ProcHeaderDecl >> Node:
1823:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1825:    boolean redeclaring = false
1831:    Node decl = oScopeFindInCurrentScope
      
1836:    [ oNodeNull( decl )
1843:       | true :
               % first declaration
1844:          decl = @newIdent( nProc, LAST_ID )
1857:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1868:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1870:          redeclaring = true
1876:          [ oNodeGetBoolean( decl, qBodyDefined )
1886:             | true : #eAlreadyDefined
1889:             | * :
1894:          ]
1894:          [ oNodeGetBoolean( decl, qExternal )
1904:             | true : #eAlreadyDefined
1907:             | * :
1912:          ]
1912:          [ oNodeType( decl )
1919:             | nProc :
1920:             | * : #eAlreadyDefined   % wrong kind
1927:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1927:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1946:          oNodeSet( decl, qParams, Null )
1958:    ]
      
1966:    int level = @ScopeLevel
1972:    boolean nested = greater( level, 0 )
1985:    inc( level )
1991:    oScopeBegin( level, allocUp )
2000:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2005:    [ nested
2008:       | true :
2009:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2024:       | * :
2029:    ]
      
2029:    @FormalArgDecl
2031:    oNodeSet( decl, qParams, paramScope )
2043:    oScopeEnd
2044:    ';'
      
2046:    [ redeclaring
2049:       | false : oScopeDeclare( decl )
2056:       | true :  % TO DO: check that qParams is consistent with qOldParams
2058:    ]
      
2066:    @MethodModifiers( decl )
2073:    >> decl;
      
      
2077: ProcDecl:
2079:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2085:    [
2085:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2087:       | pExternal : @ExternalDecl( decl )
      
2096:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2103:          Node paramScope = oNodeGet( decl, qParams )
2116:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2122:          int level = oNodeGetInt( paramScope, qLevel )
2135:          oScopeBegin( level, allocDown )
2144:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2155:          Label label = oNodeGetLabel( decl, qValue )
2168:          @Block( nLocalVar, label )
2178:          oNodeSetBoolean( decl, qBodyDefined, true )
2190:          oScopeEnd
      
2191:          oScopeEnd  % paramScope
2192:    ]
2192:    ';';
      
      
      
2195: FuncHeaderDecl >> Node:
2197:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2199:    boolean redeclaring = false
2205:    Node decl = oScopeFindInCurrentScope
      
2210:    [ oNodeNull( decl )
2217:       | true :
               % first declaration
2218:          decl = @newIdent( nFunc, LAST_ID )
2231:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2242:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2244:          redeclaring = true
2250:          [ oNodeGetBoolean( decl, qBodyDefined )
2260:             | true : #eAlreadyDefined
2263:             | * :
2268:          ]
2268:          [ oNodeType( decl )
2275:             | nFunc :
2276:             | * : #eAlreadyDefined   % wrong kind
2283:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2283:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2302:          oNodeSet( decl, qParams, Null )
2314:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2333:          oNodeSet( decl, qType, Null )
2345:    ]
      
2353:    int level = @ScopeLevel
2359:    boolean nested = greater( level, 0 )
2372:    inc( level )
2378:    oScopeBegin( level, allocUp )
2387:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2392:    [ nested
2395:       | true :
2396:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2411:       | * :
2416:    ]
      
2416:    @FormalArgDecl
2418:    oNodeSet( decl, qParams, paramScope )
      
2430:    ':'
      
2432:    Node theType
2432:    @TypeRef( theType )
2439:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2451:    Node ptrType = @PointerTypeTo( theType )
2462:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2478:    oScopeEnd
2479:    ';'
      
2481:    [ redeclaring
2484:       | false : oScopeDeclare( decl )
2491:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2493:    ]
      
2501:    @MethodModifiers( decl )
      
2508:    >> decl;
      
      
2512: FuncDecl:
2514:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2520:    [
2520:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2522:       | pExternal : @ExternalDecl( decl )
      
2531:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2538:          Node paramScope = oNodeGet( decl, qParams )
2551:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2557:          int level = oNodeGetInt( paramScope, qLevel )
2570:          oScopeBegin( level, allocDown )
2579:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2590:          Label label = oNodeGetLabel( decl, qValue )
2603:          @Block( nLocalVar, label )
2613:          oNodeSetBoolean( decl, qBodyDefined, true )
2625:          oScopeEnd
      
2626:          oScopeEnd  % paramScope
2627:    ]
2627:    ';';
      
      
2630: FormalArgDecl:
2632:    [
2632:       | '(' :
2634:          {
2634:             NodeVec decls = oNodeVecNew
2639:             Node decl
2639:             boolean isInOut = false
      
2645:             [
2645:                | pVar : isInOut = true
2653:                | * :
2658:             ]
      
2658:             {  pIdent
      
2660:                decl = @newIdent( nParam, LAST_ID )
2673:                oNodeSetBoolean( decl, qInOut, isInOut )
2685:                oNodeVecAppend( decls, decl )
      
2694:                [
2694:                   | ':' : >
2698:                   | ',' :
2700:                ]
2708:             }
      
2710:             Node theType
2710:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2717:             Node allocType
2717:             [ isInOut
2720:                | true :   allocType = @PointerTypeTo( theType )
2732:                | * :      allocType = theType
2743:             ]
      
2743:             int i = 0
2749:             {[ equal( i, oNodeVecSize( decls ) )
2763:                | false :
2764:                   decl = oNodeVecElement( decls, i )
      
2777:                   oNodeSet( decl, qType, theType )
2789:                   oScopeDeclare( decl )
2795:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2811:                   inc( i )
2817:                | * :
2822:                   >
2824:             ]}
      
2826:             oNodeVecDelete( decls )
      
2832:             [
2832:                | ')' : >
2836:                | ';' :
2838:             ]
2846:          }
2848:       | * :
2853:    ];
      
2854: ConstDecl:
2856:    {[
2856:       | pIdent :
2858:          Node decl = @newIdent( nConst, LAST_ID )
2871:          '='
      
2873:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2875:          int val = oValueTop
2880:          oValuePop
2881:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2893:          oNodeSet( decl, qType, IntegerType )
      
2905:          oScopeDeclare( decl )
2911:          ';'
2913:       | * :
2918:          >
2920:    ]};
      
2923: TypeDecl:
2925:    {[
2925:       | pIdent :
2927:          Node decl = @newIdent( nTypeDecl, LAST_ID )
2940:          '='
2942:          Node theType
2942:          @TypeRef( theType )
2949:          oNodeSet( decl, qType, theType )
2961:          oScopeDeclare( decl )
2967:          ';'
2969:       | * :
2974:          >
2976:    ]};
      
2979: VarDecl( node_type varNodeType ):
2981:    {[
2981:       | pIdent :
2983:          NodeVec decls = oNodeVecNew
2988:          Node decl
2988:          {
2988:             decl = @newIdent( varNodeType, LAST_ID )
3001:             oNodeVecAppend( decls, decl )
3010:             [
3010:                | ',' :
3012:                   pIdent
3014:                | * :
3019:                   >
3021:             ]
3021:          }
3023:          ':'
3025:          Node theType
3025:          @TypeRef( theType )
      
3032:          int i = 0
3038:          {[ equal( i, oNodeVecSize( decls ) )
3052:             | false :
3053:                decl = oNodeVecElement( decls, i )
3066:                oNodeSet( decl, qType, theType )
3078:                oScopeDeclareAlloc( decl )
3084:                inc( i )
3090:             | * :
3095:               >
3097:          ]}
      
               % optional initialization
3099:          [
3099:             | '=' :
3101:                [ oNodeVecSize( decls )
3108:                   | 1 :
3109:                   | * :  #eOnlyOneVarCanBeInitialized
3116:                ]
      
                     % we need an initCode stream for this scope
3116:                Code initCode = @GetOrCreateInitCode
3122:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3128:                boolean changedScope = false
3134:                [ equal_zero( @ScopeLevel )
3141:                   | true : oScopeEnter( initScope )
3148:                            changedScope = true
3154:                   | * :
3159:                ]
                     % generate assignment in initCode stream
3159:                @LValueVar( decl )
3166:                @Expr
3168:                @MatchTypes
3170:                @Assign
3172:                [ changedScope
3175:                   | true : oScopeEnd
3177:                   | * :
3182:                ]
3182:                oCodePop
                   
3183:             | * :
3188:          ]
      
3188:          oNodeVecDelete( decls )
3194:          ';'
3196:       | * :
3201:          >
3203:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3206: TypeRef( out Node resultType ):
3208:    [
3208:       | pIdent :           % previously named type (including intrinsics)
3210:          Node decl = oScopeFindRequire
3215:          @ResolveUnitRef( decl )
3222:          [ oNodeType( decl )
3229:             | nTypeDecl :
3230:                resultType = oNodeGet( decl, qType )
3243:             | * :
3248:                #eNotType
3250:                resultType = IntegerType
3256:          ]
         
3256:       | pArray :
3258:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3260:          NodeVec dimensions = oNodeVecNew
      
3265:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3265:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3275:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3287:             @ConstExpr
3289:             oNodeSetInt( subrange, qLow, oValueTop )
3300:             oValuePop
3301:             '..'
3303:             @ConstExpr
3305:             oNodeSetInt( subrange, qHigh, oValueTop )
3316:             oValuePop
3317:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3329:             oTypeAdd( subrange )
      
3335:             Node a = oNodeNew( nArrayType )
3345:             oNodeSet( a, qIndexType, subrange )
      
3357:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3366:             [
3366:                | ']' : >
3370:                | ',' :
3372:             ]
3380:          }
      
3382:          pOf
3384:          Node baseType
3384:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3391:          int dim = oNodeVecSize( dimensions )
      
3401:          {
3401:              dec(dim)
      
3407:              Node a = oNodeVecElement( dimensions, dim )
      
3420:              oNodeSet( a, qBaseType, baseType )
3432:              Node subrange = oNodeGet( a, qIndexType )
3445:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3472:              inc( width )
3478:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3504:              oTypeAdd( a )
3510:              baseType = a
      
3516:              [ equal_zero(dim)
3523:                  | true:  >
3526:                  | *:
3531:              ]
3531:          }
      
3533:          resultType = oNodeVecElement( dimensions, 0 )
3546:          oNodeVecDelete( dimensions )
      
3552:       | '^' :
3554:          Node theType
3554:          @TypeRef( theType )
3561:          resultType = @PointerTypeTo( theType )
      
3572:       | pRecord :
3574:          resultType = oNodeNew( nRecordType )
3584:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3593:          @VarDecl( nRecordField )
      
3600:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3612:          [ equal_zero( size )
3619:             | true : #eRecordEmpty
3622:             | * :
3627:          ]
      
3627:          pEnd
      
3629:          oNodeSet( resultType, qScope, oScopeCurrent )
3640:          oNodeSetInt( resultType, qSize, size )
3652:          oScopeEnd
3653:          oTypeAdd( resultType )
      
      
3659:       | '(' :
               % An enum type declaration.
3661:          resultType = oNodeNew( nEnumType )
3671:          int value = 0
3677:          boolean first = true
      
               % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
               % That will let programs use either <val> or <enumType>.<val>
3683:          Node outerScope = oScopeCurrent
3688:          oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
3697:          {
                  % TO DO: assert that name not already seen in this scope, i.e. this enum.
                  %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
                  %  It might be in some other higher/used scope.
3697:             pIdent
3699:             Node decl = @newIdent( nEnumValue, LAST_ID )
3712:             Node decl2 = @newIdent( nEnumValue, LAST_ID )
3725:             oNodeSet( decl, qType, resultType )
3737:             oNodeSet( decl2, qType, resultType )
3749:             [
3749:                | '=', ':=' :
3751:                   @ConstExpr
                        % value must be ascending
                        % this obviously doesn't apply to the first value
3753:                   [ first
3756:                      | false :
3757:                         [ greater( oValueTop, value )
3766:                            | false :   #eEnumValueNotAscending
3769:                            | * :
3774:                         ]
3774:                      | * :
3779:                   ]
3779:                   value = oValueTop
3784:                   oValuePop
3785:                | * :
3792:             ]
3792:             oNodeSetInt( decl, qValue, value )
3804:             oNodeSetInt( decl2, qValue, value )
3816:             oScopeDeclare( decl )
      
3822:             oScopeEnter( outerScope )
3828:             oScopeDeclare( decl2 )
3834:             oScopeEnd
      
3835:             inc( value )
3841:             first = false
3847:             [
3847:                | ',' :
3849:                | * :    >
3856:             ]
3856:          }
3858:          ')'
      
3860:          oNodeSet( resultType, qScope, oScopeCurrent )
3871:          oNodeSetInt( resultType, qSize, 4 )   % always integer sized
3883:          oScopeEnd
3884:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
3890:       | pSet :
3892:          pOf
3894:          Node theType
3894:          @TypeRef( theType )
3901:       | * :       % this works for cases except where expr starts with an id
3916:          @ConstExpr '..' @ConstExpr
3922:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3923: ConstExpr:
3925:    [
3925:       | pIntLit :
3927:          oValuePush( TOKEN_VALUE )
3932:       | pIdent :
3934:          Node decl = oScopeFindRequire
3939:          @ResolveUnitRef( decl )
3946:          [ oNodeType( decl )
3953:             | nConst :
3954:                oValuePush( oNodeGetInt( decl, qValue ) )
3967:             | * :
3972:                #eNotConst
3974:                oValuePush( 0 )
3980:          ]
3980:       | pMinus :
3982:          @ConstExpr
3984:          oValueNegate
3985:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3996: Expr:
3998:    Label falseLabel = labelNull
      
4004:    @ExprAllowCF( falseLabel )
4011:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4019: BooleanExprControlFlow( out Label falseLabel ):
4021:    @ExprAllowCF( falseLabel )
4028:    [ oTypeSNodeType
4030:       | nBooleanCFType :
4031:       | nBooleanType :
               % convert value to control flow
4033:          falseLabel = oLabelNew
4038:          .tJumpFalse  oEmitLabel( falseLabel )
4046:       | * :
4053:          #eNotBoolean
4055:    ]
4055:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4057: CFToVal( inout Label falseLabel ):
4059:    [ oTypeSNodeType
4061:       | nBooleanCFType :
4062:          Label doneLabel = oLabelNew
4067:          .tPushConstI  oEmitInt( 1 )
4075:          .tJump  oEmitLabel( doneLabel )
4083:          .tLabel  oEmitLabel( falseLabel )
4091:          .tPushConstI  oEmitInt( 0 )
4099:          .tLabel  oEmitLabel( doneLabel )
4107:          oTypeSPop
4108:          oTypeSPush( BooleanType )
4114:          falseLabel = labelNull
4120:       | * :
4125:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4126: ValToCF( out Label falseLabel ):
4128:    [ oTypeSNodeType
4130:       | nBooleanType :
4131:          falseLabel = oLabelNew
4136:          .tJumpFalse  oEmitLabel( falseLabel )
4144:          oTypeSPop
4145:          oTypeSPush( BooleanCFType )
4151:       | * :
4156:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
4157: ExprAllowCF( out Label falseLabel ):
4159:    @BoolExprAllowCF( falseLabel )
4166:    {[
4166:       | '=' :
4168:          @CFToVal( falseLabel )
4175:          @BoolExprAllowCF( falseLabel )
4182:          @CFToVal( falseLabel )
4189:          @MatchTypes
4191:          [ oTypeSNodeType
4193:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
4196:             | nPointerType :                .tEqualP
4200:             | nCharType, nStringType :      #eNotImplemented
4204:             | * :                           #eNotAllowed
4221:          ]
4221:          oTypeSPop
4222:          oTypeSPush( BooleanType )
      
4228:       | '<>' :
4230:          @CFToVal( falseLabel )
4237:          @BoolExprAllowCF( falseLabel )
4244:          @CFToVal( falseLabel )
4251:          @MatchTypes
4253:          [ oTypeSNodeType
4255:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
4258:             | nPointerType :                .tNotEqualP
4262:             | nCharType, nStringType :      #eNotImplemented
4266:             | * :                           #eNotAllowed
4283:          ]
4283:          oTypeSPop
4284:          oTypeSPush( BooleanType )
      
4290:       | '<' :
4292:          @CFToVal( falseLabel )
4299:          @BoolExprAllowCF( falseLabel )
4306:          @CFToVal( falseLabel )
4313:          @MatchTypes
4315:          [ oTypeSNodeType
4317:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
4320:             | nCharType, nStringType :      #eNotImplemented
4324:             | * :                           #eNotAllowed
4339:          ]
4339:          oTypeSPop
4340:          oTypeSPush( BooleanType )
      
4346:       | '>' :
4348:          @CFToVal( falseLabel )
4355:          @BoolExprAllowCF( falseLabel )
4362:          @CFToVal( falseLabel )
4369:          @MatchTypes
4371:          [ oTypeSNodeType
4373:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
4376:             | nCharType, nStringType :      #eNotImplemented
4380:             | * :                           #eNotAllowed
4395:          ]
4395:          oTypeSPop
4396:          oTypeSPush( BooleanType )
      
4402:       | '<=' :
4404:          @CFToVal( falseLabel )
4411:          @BoolExprAllowCF( falseLabel )
4418:          @CFToVal( falseLabel )
4425:          @MatchTypes
4427:          [ oTypeSNodeType
4429:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
4432:             | nCharType, nStringType :      #eNotImplemented
4436:             | * :                           #eNotAllowed
4451:          ]
4451:          oTypeSPop
4452:          oTypeSPush( BooleanType )
      
4458:       | '>=' :
4460:          @CFToVal( falseLabel )
4467:          @BoolExprAllowCF( falseLabel )
4474:          @CFToVal( falseLabel )
4481:          @MatchTypes
4483:          [ oTypeSNodeType
4485:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
4488:             | nCharType, nStringType :      #eNotImplemented
4492:             | * :                           #eNotAllowed
4507:          ]
4507:          oTypeSPop
4508:          oTypeSPush( BooleanType )
      
4514:       | * :
4529:          >
4531:    ]};
      
      
4534: BoolExprAllowCF( out Label falseLabel ):
4536:    Label trueLabel = labelNull
      
4542:    @BoolTermAllowCF( falseLabel )
4549:    {[
4549:       | pOr :
4551:          [ oTypeSNodeType
4553:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4554:                [ equal_label( trueLabel, labelNull )
4564:                   | true :  trueLabel = oLabelNew
4570:                   | * :
4575:                ]
4575:                .tJump  oEmitLabel( trueLabel )
4583:             | nBooleanType :
4585:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4592:                [ equal_label( trueLabel, labelNull )
4602:                   | true :  trueLabel = oLabelNew
4608:                   | * :
4613:                ]
4613:                .tJump  oEmitLabel( trueLabel )
4621:             | * : #eNotBoolean
4630:          ]
4630:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4631:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4639:          falseLabel = labelNull
4645:          @BoolTermAllowCF( falseLabel )
      
4652:          [ oTypeSNodeType
4654:             | nBooleanCFType :
4655:             | nBooleanType :
4657:                @ValToCF( falseLabel )
4664:             | * : #eNotBoolean
4673:          ]
      
4673:          oTypeSPop
4674:          oTypeSPush( BooleanCFType )
      
4680:       | * :
4685:          >
4687:    ]}
      
         % any short-circuit trues jump here to the end
4689:    [ equal_label( trueLabel, labelNull )
4699:       | false :
4700:          .tLabel  oEmitLabel( trueLabel )
4708:       | * :
4713:    ]
4714:    ;
      
      
4714: BoolTermAllowCF( out Label falseLabel ):
4716:    Label overallFalseLabel = labelNull
      
4722:    @BoolFactorAllowCF( falseLabel )
4729:    {[
4729:       | pAnd :
4731:          [ oTypeSNodeType
4733:             | nBooleanCFType :
4734:             | nBooleanType :
4736:                @ValToCF( falseLabel )
4743:             | * :
4750:                #eNotBoolean
4752:          ]
4752:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
4753:          [ equal_label( overallFalseLabel, labelNull )
4763:             | true :
4764:                overallFalseLabel = oLabelNew
4769:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
4783:                falseLabel = overallFalseLabel
4789:             | * :
4794:          ]
      
4794:          Label factorFalseLabel = labelNull
4800:          @BoolFactorAllowCF( factorFalseLabel )
      
4807:          [ oTypeSNodeType
4809:             | nBooleanCFType :
4810:             | nBooleanType :
4812:                @ValToCF( factorFalseLabel )
4819:             | * : #eNotBoolean
4828:          ]
4828:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
4842:       | * :
4847:          >
4849:    ]};
      
4852: BoolFactorAllowCF( out Label falseLabel ):
4854:    [
4854:       | pNot :
4856:          Label factorFalseLabel = labelNull
      
4862:          @BoolFactorAllowCF( factorFalseLabel )
4869:          [ oTypeSNodeType
4871:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4872:                falseLabel = oLabelNew
4877:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4885:                .tLabel  oEmitLabel( factorFalseLabel )
      
4893:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4895:                .tNot
      
4897:             | * : #eNotBoolean
4906:          ]
      
4906:       | * :
4911:          @ArithExprAllowCF( falseLabel )
4918:    ];
      
4919: ArithExprAllowCF( out Label falseLabel ):
4921:    @TermAllowCF( falseLabel )
4928:    {[
4928:       | pPlus :
4930:          @RequireIntPop
4932:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4939:          @RequireInt
4941:          .tAddI
4943:       | pMinus :
4945:          @RequireIntPop
4947:          @TermAllowCF( falseLabel )
4954:          @RequireInt
4956:          .tSubI
4958:       | * :
4965:          >
4967:    ]};
      
4970: TermAllowCF( out Label falseLabel ):
4972:    @FactorAllowCF( falseLabel )
4979:    {[
4979:       | pTimes :
4981:          @RequireIntPop
4983:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4990:          @RequireInt
4992:          .tMultI
4994:       | pDivide :
4996:          @RequireIntPop
4998:          @FactorAllowCF( falseLabel )
5005:          @RequireInt
5007:          .tDivI
5009:       | * :
5016:          >
5018:    ]};
      
5021: FactorAllowCF( out Label falseLabel ):
5023:    [
5023:       | pPlus :
5025:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5032:          @RequireInt
5034:       | pMinus :
5036:          @PrimaryAllowCF( falseLabel )
5043:          @RequireInt
5045:          .tNegI
5047:       | * :
5054:          @PrimaryAllowCF( falseLabel )
5061:    ];
      
5062: PrimaryAllowCF( out Label falseLabel ):
5064:    [
5064:       | pIntLit :
5066:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5073:          oTypeSPush( IntegerType )
      
5079:       | '(' :
5081:          @ExprAllowCF( falseLabel )
5088:          ')'
      
5090:       | pStrLit :
5092:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
5101:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
5109:          oTypeSPush( StringType )
      
5115:       | pIdent :
5117:          Node decl = oScopeFindRequire
5122:          @ResolveUnitRef( decl )
5129:          Node theType
      
5129:          [ oNodeType( decl )
5136:             | nFunc :
      
5137:                @Call( decl )
      
5144:             | nConst, nEnumValue :
5146:                theType = oNodeGet( decl, qType )
5159:                oTypeSPush( theType )
5165:                [ oTypeSNodeType
5167:                   | nIntegerType, nEnumType, nBooleanType :
5168:                      .tPushConstI @EmitValue( decl )
5177:                   | * :
5186:                      #eNotImplemented
5188:                ]
      
5188:             | nGlobalVar, nLocalVar, nParam :
5190:                @VarExpr( decl )
      
5197:             | * :
5212:                #eNotValue
5214:                oTypeSPush( IntegerType )
5220:          ]
      
5220:       | '@' :        % @var -- pointer to var
5222:          pIdent
      
5224:          Node decl = oScopeFindRequire
5229:          @ResolveUnitRef( decl )
5236:          Node theType
      
5236:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5243:          theType = oTypeSTop
5248:          oTypeSPop
5249:          Node ptrType = @PointerTypeTo( theType )
5260:          oTypeSPush( ptrType )
      
5266:       | * :
5279:          #eNotValue
5281:          oTypeSPush( IntegerType )
5287:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5288: VarExpr( Node decl ):
5290:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5303:    int uplevels = @DeclUpLevels( decl )
      
5314:    oTypeSPush( theType )
5320:    [ oTypeSNodeType
5322:       | nIntegerType, nEnumType :
5323:          [ oNodeType( decl )
5330:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
5340:             | nLocalVar :
5342:                [ equal_zero( uplevels )
5349:                   | true :  .tPushLocalI  @EmitValue( decl )
5359:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5379:                ]
5379:             | nParam :
5381:                [ oNodeGetBoolean( decl, qInOut )
5391:                   | true :    % VAR param points to the var.  Auto dereference.
5392:                      [ equal_zero( uplevels )
5399:                         | true :  .tPushParamP  @EmitValue( decl )
5409:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5429:                      ]
5429:                      .tFetchI
5431:                   | * :
5436:                      [ equal_zero( uplevels )
5443:                         | true :  .tPushParamI  @EmitValue( decl )
5453:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5473:                      ]
5473:                ]
5473:          ]
      
5483:       | nBooleanType :
5485:          [ oNodeType( decl )
5492:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5502:             | nLocalVar :
5504:                [ equal_zero( uplevels )
5511:                   | true :  .tPushLocalB  @EmitValue( decl )
5521:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5541:                ]
5541:             | nParam :
5543:                [ oNodeGetBoolean( decl, qInOut )
5553:                   | true :    % VAR param points to the var.  Auto dereference.
5554:                      [ equal_zero( uplevels )
5561:                         | true :  .tPushParamP  @EmitValue( decl )
5571:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5591:                      ]
5591:                      .tFetchB
5593:                   | * :
5598:                      [ equal_zero( uplevels )
5605:                         | true :  .tPushParamB  @EmitValue( decl )
5615:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5635:                      ]
5635:                ]
5635:          ]
      
5645:       | nCharType, nStringType, nFileType :
5647:          #eNotImplemented
      
5649:       | nPointerType :
5651:          [ oNodeType( decl )
5658:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5668:             | nLocalVar :
5670:                [ equal_zero( uplevels )
5677:                   | true :  .tPushLocalP  @EmitValue( decl )
5687:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
5707:                ]
5707:             | nParam :
5709:                [ oNodeGetBoolean( decl, qInOut )
5719:                   | true :    % VAR param points to the var.  Auto dereference.
5720:                      [ equal_zero( uplevels )
5727:                         | true :  .tPushParamP  @EmitValue( decl )
5737:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5757:                      ]
5757:                      .tFetchP
5759:                   | * :
5764:                      [ equal_zero( uplevels )
5771:                         | true :  .tPushParamP  @EmitValue( decl )
5781:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5801:                      ]
5801:                ]
5801:          ]
5811:          [
5811:             | '^' :             % dereferenced
5813:                oTypeSPop
5814:                oTypeSPush( oNodeGet( theType, qBaseType ) )
5827:                @LValueIndexes
5829:                @FetchVar
5831:             | * :               % just ptr value alone
5836:          ]
      
5836:       | * :
               % compound type
               % first, push addr of start of var
5853:          [ oNodeType( decl )
5860:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5870:             | nLocalVar :
5872:                [ equal_zero( uplevels )
5879:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5889:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5909:                ]
5909:             | nParam :
5911:                [ oNodeGetBoolean( decl, qInOut )
5921:                   | true :    % VAR param points to the var.  Auto dereference.
5922:                      [ equal_zero( uplevels )
5929:                         | true :  .tPushParamP  @EmitValue( decl )
5939:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5959:                      ]
5959:                   | * :
5964:                      [ equal_zero( uplevels )
5971:                         | true :  .tPushAddrParam  @EmitValue( decl )
5981:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6001:                      ]
6001:                ]
6001:          ]
               % modify addr for subscripts, field references, etc
6011:          @LValueIndexes
               % get final value
6013:          @FetchVar
6015:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
6016: FetchVar:
6018:    [ oTypeSNodeType
6020:       | nIntegerType, nEnumType :   .tFetchI
6023:       | nBooleanType :   .tFetchB
6027:       | nCharType, nStringType, nFileType : #eNotImplemented
6031:       | nPointerType :   .tFetchP
6035:       | * :              % compound type; leave as addr
6052:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
6053: LValueIndexes:
6055:    {[
6055:       | '[' :       @ArraySubscripts
6059:       | '.' :       @RecordFieldRef
6063:       | '^' :       @PointerDeref
6067:       | * :         >
6078:    ]};
      
6081: ArraySubscripts:
6083:    [ oTypeSNodeType
6085:       | nArrayType :
6086:       | * :       #eNotArray
6093:    ]
6093:    {
6093:       [ oTypeSNodeType
6095:          | nArrayType :
6096:          | * :    #eTooManySubscripts
6103:       ]
      
            % low subscript of this dimension
6103:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
6120:       Node baseType
6120:       baseType = oNodeGet( oTypeSTop, qBaseType )
6132:       oTypeSPop
6133:       oTypeSPush( baseType )
      
6139:       @Expr
6141:       @RequireIntPop
            % adjust for low subscript
6143:       [ equal_zero( low )
6150:          | false :
6151:             .tPushConstI oEmitInt( low ) .tSubI
6161:          | * :
6166:       ]
      
            % multiply by element size
6166:       int size = oNodeGetInt( baseType, qSize )
6179:       [ equal( size, 1 )
6189:          | false :
6190:             .tPushConstI oEmitInt( size ) .tMultI
6200:          | * :
6205:       ]
      
            % update start address
6205:       .tAddPI
6207:       [
6207:          | ']' :  >
6211:          | ',' :
6213:       ]
6221:    };
      
      
6224: RecordFieldRef:
6226:    [ oTypeSNodeType
6228:       | nRecordType :
6229:       | * :    #eNotRecord
6236:    ]
6236:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
6248:    pIdent
6250:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
6255:    [ oNodeType( field )
6262:       | nRecordField :
6263:       | * :   #eNotRecordField
6270:    ]
6270:    oScopeEnd
6271:    int offset = oNodeGetInt( field, qValue )
6284:    [ equal_zero( offset )
6291:       | false :
6292:          .tPushConstI oEmitInt( offset ) .tAddPI
6302:       | * :
6307:    ]
      
         % replace the type on the type stack, with the field type
6307:    oTypeSPop
6308:    oTypeSPush( oNodeGet( field, qType ) )
6322:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
6322: PointerDeref:
6324:    [ oTypeSNodeType
6326:       | nPointerType :
6327:       | * :       #eNotPointer
6334:    ]
6334:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
6336:    Node theType = oTypeSTop
6341:    oTypeSPop
6342:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6356:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6356: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
6358:    @MatchTypes
6361:    ;
      
      
      % Called on first use of an extern method
      %
6361: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
6363:    int strAddr
6363:    String externalName = oNodeGetString( method, qExternalName )
6376:    [ equal_string( externalName, stringNull )
6386:       | true :
6387:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
6408:       | false :
6410:          strAddr = oStringAllocLit( externalName )
6420:    ]
6428:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6444:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6444: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6446:    [ oNodeGetBoolean( method, qExternal )
6456:       | true :
6457:          [ oNodeGetBoolean( method, qCalled )
6467:             | false :
                     % define the extern label on first use
6468:                @DefineExternLabel( method )
6475:             | * :
6480:          ]
6480:      | * :
6485:    ]
6485:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6497:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6510:    Node resultType
6510:    int tempOffset
      
6510:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6527:    [ isFunc
6530:       | true :
6531:          resultType = oNodeGet( method, qType )
6544:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6554:       | * :
6559:    ]
         
      
6559:    Node paramScope = oNodeGet( method, qParams )
6572:    int actualsSize = oNodeGetInt( paramScope, qSize )
6585:    [ cdecl
6588:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6597:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6607:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6615:    [ greater( @DeclLevel( method ), 0 )
6630:       | true :
6631:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6639:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6658:          .tAssignP
6660:       | * :
6665:    ]
      
      
6665:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6678:    Node param = oNodeIterValue( paramIter )
6688:    [
6688:       | '(' :
            
6690:          {
6690:             [ oNodeNull( param )
6697:                | true : >
6700:                | * :
6705:             ]
      
6705:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
6718:             .tPushAddrActual oEmitInt( offset )
6726:             oTypeSPush( oNodeGet( param, qType ) )
      
6739:             [ oNodeGetBoolean( param, qInOut )
6749:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
6750:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
6752:                           @MatchTypes
      
6754:                           .tAssignP
      
6756:                | false :  @Expr
6760:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
6762:                           [ oTypeSNodeType
6764:                              | nIntegerType, nEnumType : .tAssignI
6767:                              | nBooleanType :            .tAssignB
6771:                              | nCharType, nStringType, nFileType :   #eNotImplemented
6775:                              | nPointerType :            .tAssignP
6779:                              | * :
                                       % compound types: copy value into actuals space
6796:                                  int size = oNodeGetInt( oTypeSTop, qSize )
6808:                                  .tCopy  oEmitInt( size )    % multi-word copy
6816:                           ]
6816:             ]
6824:             oTypeSPop
      
6825:             oNodeIterNext( paramIter )
6831:             param = oNodeIterValue( paramIter )
6841:             [ oNodeNull( param )
6848:                | true :  >
6851:                | false :
6853:             ]
      
6861:             ','
6863:          }
      
6865:          ')'
      
6867:       | * :
6872:    ]
      
6872:    [ oNodeNull( param )
6879:       | false :    #eMissingParameter
6882:       | * :
6887:    ]
      
6887:    [ isFunc
6890:       | true :
               % Pass result temp as an additional VAR parameter.
6891:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6906:          .tPushAddrLocal  oEmitInt( tempOffset )
6914:          .tAssignP
6916:       | * :
6921:    ]
      
6921:    [ cdecl
6924:       | true :
6925:          .tCallCdecl  @EmitValue( method )
6934:       | false :
6936:          .tCall   @EmitValue( method )
6945:    ]
      
6953:    [ isFunc
6956:       | true :
               % push return value from temp
6957:          oTypeSPush( resultType )
      
6963:          [ oTypeSNodeType
6965:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
6974:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6984:             | nCharType, nStringType, nFileType : #eNotImplemented
6988:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6998:             | * :              % compound type: push address
7015:                                .tPushAddrLocal  oEmitInt( tempOffset )
7023:          ]
7023:       | * :
7028:    ]
         
7028:    .tFreeActuals  oEmitInt( actualsSize )
7037:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
7037: Statement:
7039:    [
7039:       | pWriteln :     @WritelnStmt
7043:       | pWrite :       @WriteStmt
7047:       | pReadln :      @ReadlnStmt
7051:       | pRead :        @ReadStmt
7055:       | pIf :          @IfStmt
7059:       | pWhile :       @WhileStmt
7063:       | pFor :         @ForStmt
7067:       | pRepeat :      @RepeatStmt
7071:       | pBreak :       @BreakStmt
7075:       | pContinue :    @ContinueStmt
7079:       | pBegin :       @BeginStmt
7083:       | pIdent :       @AssignOrCallStmt
7087:       | * :            % null statement : don't accept any tokens
7114:    ];
      
      
7115: AssignOrCallStmt:
7117:    Node decl = oScopeFindRequire
7122:    @ResolveUnitRef( decl )
7129:    [ oNodeType( decl )
7136:       | nProc :                           @Call( decl )
7144:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
7153:       | nFunc :                           @AssignResultStmt( decl )
7162:       | * :                               #eBadStatement
7177:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
7178: AssignStmt( Node decl ):
      
7180:    @LValueVar( decl )
7187:    ':=' 
7189:    @Expr
7191:    @MatchTypes
7193:    @Assign
7196:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
7196: Assign:
7198:    [ oTypeSNodeType
7200:       | nIntegerType, nEnumType : .tAssignI
7203:       | nBooleanType :            .tAssignB
7207:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
7211:       | nPointerType :            .tAssignP
7215:       | * :
7232:           int size = oNodeGetInt( oTypeSTop, qSize )
7244:           .tCopy  oEmitInt( size )    % multi-word copy
7252:    ]
7252:    oTypeSPop
7254:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
7254: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
7256:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
7272:       | false :   #eNotCurrentFunction
7275:       | * :
7280:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
7280:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
7295:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
7308:    ':='
7310:    @Expr
7312:    @MatchTypes
7314:    [ oTypeSNodeType
7316:       | nIntegerType, nEnumType : .tAssignI
7319:       | nBooleanType :            .tAssignB
7323:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
7327:       | nPointerType :            .tAssignP
7331:       | * :
7348:           int size = oNodeGetInt( oTypeSTop, qSize )
7360:           .tCopy  oEmitInt( size )    % multi-word copy
7368:    ]
7368:    oTypeSPop
7370:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
7370: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
7372:    pIdent
7374:    Node decl = oScopeFindRequire
7379:    @ResolveUnitRef( decl )
7386:    [ oNodeType( decl )
7393:       | nGlobalVar, nLocalVar, nParam :
7394:       | * :  #eNotVar
7405:    ]
7405:    @LValueVar( decl )
7413:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
7413: LValueVar( Node decl ):
7415:    [ oNodeType( decl )
7422:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
7432:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
7443:       | nParam :
7445:          [ oNodeGetBoolean( decl, qInOut )
7455:             | true :   % VAR param points to variable.  No dereference.
7456:                        .tPushParamP @EmitValue( decl )
7465:             | * :      .tPushAddrParam @EmitValue( decl )
7479:          ]
7479:       | * :            #eNotVar
7490:    ]
      
7490:    oTypeSPush( oNodeGet( decl, qType ) )
7503:    @LValueIndexes        % handle subscripts, if any
7506:    ;
      
      
7506: IncVar( Node decl ):
7508:    @LValueVar( decl )
7515:    @RequireIntPop
7517:    @VarExpr( decl )
7524:    oTypeSPop
7525:    .tIncI
7527:    .tAssignI;
      
7530: DecVar( Node decl ):
7532:    @LValueVar( decl )
7539:    @RequireIntPop
7541:    @VarExpr( decl )
7548:    oTypeSPop
7549:    .tDecI
7551:    .tAssignI;
      
      
7554: IfStmt:
7556:    Label falseLabel = labelNull
      
7562:    @BooleanExprControlFlow( falseLabel )
7569:    pThen
7571:    @Statement
7573:    [
7573:       | pElse :
7575:          Label doneLabel = oLabelNew
      
7580:          .tJump  oEmitLabel( doneLabel )
7588:          .tLabel oEmitLabel( falseLabel )
7596:          @Statement
7598:          .tLabel oEmitLabel( doneLabel )
      
7606:       | * :
7611:          .tLabel oEmitLabel( falseLabel )
7619:    ];
      
      
7620: ForStmt:
7622:    pIdent
      
7624:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
7629:    @LValueVar( decl )
7636:    @RequireIntPop
      
7638:    ':='
      
7640:    @Expr
7642:    @RequireIntPop
7644:    .tAssignI
      
7646:    Label breakLabel = oLabelNew
      
7651:    Label checkLabel = oLabelNew
7656:    .tJump  oEmitLabel( checkLabel )
      
7664:    Label continueLabel = oLabelNew
7669:    .tLabel  oEmitLabel( continueLabel )
7677:    [
7677:       | pTo :
7679:          @IncVar( decl )
7686:          .tLabel  oEmitLabel( checkLabel )
7694:          @VarExpr( decl )  oTypeSPop
7702:          @Expr
7704:          @RequireIntPop
7706:          .tGreaterI
7708:          .tJumpTrue  oEmitLabel( breakLabel )
7716:       | pDownto :
7718:          @DecVar( decl )
7725:          .tLabel  oEmitLabel( checkLabel )
7733:          @VarExpr( decl )  oTypeSPop
7741:          @Expr
7743:          @RequireIntPop
7745:          .tLessI
7747:          .tJumpTrue  oEmitLabel( breakLabel )
7755:    ]
7763:    oLoopPush( continueLabel, breakLabel )
7772:    pDo
7774:    @Statement
7776:    .tJump  oEmitLabel( continueLabel )
7784:    .tLabel  oEmitLabel( breakLabel )
7792:    oLoopPop;
      
      
7794: RepeatStmt:
7796:    Label continueLabel = oLabelNew
7801:    .tLabel  oEmitLabel( continueLabel )
      
7809:    Label breakLabel = oLabelNew
      
7814:    oLoopPush( continueLabel, breakLabel )
7823:    @Statement
7825:    {[
7825:       | ';' :
7827:          @Statement
7829:       | pUntil :
7831:          Label falseLabel
7831:          @BooleanExprControlFlow( falseLabel )
7838:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
7852:          >
7854:    ]}
7864:    .tLabel  oEmitLabel( breakLabel )
7872:    oLoopPop;
      
      
7874: WhileStmt:
7876:    Label continueLabel = oLabelNew
7881:    .tLabel  oEmitLabel( continueLabel )
      
7889:    Label breakLabel
7889:    @BooleanExprControlFlow( breakLabel )
      
7896:    oLoopPush( continueLabel, breakLabel )
7905:    pDo
7907:    @Statement
7909:    .tJump  oEmitLabel( continueLabel )
7917:    .tLabel  oEmitLabel( breakLabel )
7925:    oLoopPop;
      
      
7927: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7929:    [ equal_label( oLoopContinueLabel, labelNull )
7938:       | true :
7939:          #eNotInALoop
7941:       | false :
7943:          .tJump  oEmitLabel( oLoopContinueLabel )
7950:    ];
      
      
7959: BreakStmt:
7961:    [ equal_label( oLoopBreakLabel, labelNull )
7970:       | true :
7971:          #eNotInALoop
7973:       | false :
7975:          .tJump  oEmitLabel( oLoopBreakLabel )
7982:    ];
      
      
7991: BeginStmt:
7993:    @Statement
7995:    {[
7995:       | ';' :   @Statement
7999:       | pEnd :  >
8003:    ]};
      
      
8014: WritelnStmt:
8016:    @WriteStmt
8018:    .tWriteCR;
      
      
8021: WriteStmt:
8023:    [
8023:       | '(' :
8025:          {
8025:             @Expr
8027:             [ oTypeSNodeType
8029:                | nIntegerType :             .tWriteI
8032:                | nBooleanType :             .tWriteBool
8036:                | nStringType :              .tWriteStr
8040:                | nCharType, nFileType :     #eNotImplemented
8044:                | nEnumType :
                        % TO DO: write value name via table lookup
8046:                   .tWriteI
8048:                | nPointerType :             .tWriteP
8052:                | * :                        #eNotAllowed
8071:             ]
8071:             oTypeSPop
8072:             [
8072:                | ')' : >
8076:                | ',' :
8078:             ]
8086:          }
8088:       | * :
8093:    ];
      
      
8094: ReadlnStmt:      % ***
         % TO DO
8097:    ;
      
8097: ReadStmt:
         % TO DO
8100:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
8100: ScopeLevel >> int:
8102:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
8112: DeclLevel( Node decl ) >> int:
8114:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
8132: DeclUpLevels( Node decl ) >> int:
8134:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8150: MatchTypes:
8152:    node_type nt = oTypeSNodeType
8157:    oTypeSPop
8158:    [ equal_node_type( nt, oTypeSNodeType )
8167:       | false :
8168:          #eTypeMismatch
8170:       | * :
8175:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8176: RequireIntPop:
8178:    [ oTypeSNodeType
8180:       | nIntegerType :
8181:       | * :          #eNotInteger
8188:    ]
8188:    oTypeSPop;
      
8190: RequireInt:
8192:    [ oTypeSNodeType
8194:       | nIntegerType :
8195:       | * :          #eNotInteger
8202:    ];
      
8203: RequireBoolPop:
8205:    [ oTypeSNodeType
8207:       | nBooleanType :
8208:       | * :          #eNotBoolean
8215:    ]
8215:    oTypeSPop;
      
8217: RequireBool:
8219:    [ oTypeSNodeType
8221:       | nBooleanType :
8222:       | * :          #eNotBoolean
8229:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
8230: newType( node_type nt, int size ) >> Node:
8232:   Node node = oNodeNew( nt )
8242:   oNodeSetInt( node, qSize, size )
8254:   oTypeAdd( node )
8260:   >> node
8264:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
8264: newIdent( node_type nt, int id ) >> Node:
8266:   Node t = oNodeNew( nt )
8276:   oNodeSetInt( t, qIdent, id )
8288:   >> t
8292:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
8292: PointerTypeTo( Node theType ) >> Node:
8294:    Node ptrType = oNodeGet( theType, qPointerType )
8307:    [ oNodeNull( ptrType )
8314:       | true :
8315:          ptrType = oNodeNew( nPointerType )
8325:          oNodeSet( ptrType, qBaseType, theType )
8337:          oNodeSetInt( ptrType, qSize, 8 )
8349:          oTypeAdd( ptrType )
8355:          oNodeSet( theType, qPointerType, ptrType )
8367:       | * :
8372:    ]
8372:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
8376: OrdinalLow( Node theType ) >> int:
8378:    [ oNodeType( theType )
8385:       | nIntegerType :  >> oMININT
8388:       | nBooleanType :  >> 0
8393:       | nCharType :     >> 0
8398:       | nEnumType :
8400:          Node enumScope = oNodeGet( theType, qScope )
8413:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
8430:          >> oNodeGetInt( first, qValue )
8440:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
8452:       | * :             #eNotOrdinalType
8467:                         >> 0
8470:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
8471: EmitValue( Node decl ):
8473:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
8487: installBuiltIns:
      
         % install built-in types
8489:    FileType = @newType( nFileType, 4 )
8503:    IntegerType = @newType( nIntegerType, 4 )
8517:    BooleanType = @newType( nBooleanType, 1 )
8531:    BooleanCFType = @newType( nBooleanCFType, 1 )
8545:    CharType = @newType( nCharType, 1 )
8559:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8573:    Node t
      
8573:    t = @newIdent( nTypeDecl, oIdAdd_File )
8586:    oNodeSet( t, qType, FileType )
8598:    oScopeDeclare( t )
      
8604:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
8617:    oNodeSet( t, qType, IntegerType )
8629:    oScopeDeclare( t )
      
8635:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
8648:    oNodeSet( t, qType, BooleanType )
8660:    oScopeDeclare( t )
      
8666:    t = @newIdent( nTypeDecl, oIdAdd_Char )
8679:    oNodeSet( t, qType, CharType )
8691:    oScopeDeclare( t )
      
8697:    t = @newIdent( nTypeDecl, oIdAdd_String )
8710:    oNodeSet( t, qType, StringType )
8722:    oScopeDeclare( t )
      
         % Built-in constants
      
8728:    t = @newIdent( nConst, oIdAdd_True )
8741:    oNodeSet( t, qType, BooleanType )
8753:    oNodeSetInt( t, qValue, 1 )
8765:    oScopeDeclare( t )
      
8771:    t = @newIdent( nConst, oIdAdd_False )
8784:    oNodeSet( t, qType, BooleanType )
8796:    oNodeSetInt( t, qValue, 0 )
8808:    oScopeDeclare( t )
      
8815:    ;
      
8815: end
      
8815: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 6
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 8487
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 17
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 8264
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 3
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 12
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 17
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 8264
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 3
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 14
 173: oJumpForward 178
 175: Choice Lookup Table
          13    103
 178: oInput 4
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 286
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          54    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 439
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrLocal 5
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oGetAddrGlobal 2
 226: oPushResult
 227: oScopeCurrent
 228: oAssign
 229: oGetLocal 4
 231: oPushResult
 232: oSetResult 7
 234: oPushResult
 235: oGetGlobal 2
 237: oPushResult
 238: oNodeSet
 239: oPop 3
 241: oScopeEnd
 242: oSetResult 18
 244: oPushResult
 245: oCall 1363
 247: oPop 1
 249: oGetGlobal 2
 251: oPushResult
 252: oScopeEnter
 253: oPop 1
 255: oGetAddrLocal 6
 257: oPushResult
 258: oSetResult 1
 260: oAssign
 261: oGetLocal 3
 263: oPushResult
 264: oGetLocal 5
 266: oPushResult
 267: oGetLocal 6
 269: oPushResult
 270: oCall 1583
 272: oPop 3
 274: oScopeEnd
 275: oInput 19
 277: oScopeEnd
 278: oGetLocal 4
 280: oPushResult
 281: oCall 501
 283: oPop 1
 285: oReturn
 286: oLocalSpace 2
 288: oInput 0
 290: oGetAddrLocal 1
 292: oPushResult
 293: LAST_ID
 294: oPushResult
 295: oCall 580
 297: oPop 1
 299: oAssign
 300: oGetLocal 1
 302: oPushResult
 303: oSetResult 0
 305: oPushResult
 306: equal_node
 307: oPop 2
 309: oChoice 379
 311: oGetParam 1
 313: oPushResult
 314: oSetResult 5
 316: oPushResult
 317: oGetLocal 1
 319: oPushResult
 320: oNodeAddLast
 321: oPop 3
 323: oGetAddrLocal 2
 325: oPushResult
 326: oSetResult 10
 328: oPushResult
 329: oNodeNew
 330: oPop 1
 332: oAssign
 333: oGetLocal 2
 335: oPushResult
 336: oSetResult 4
 338: oPushResult
 339: oGetLocal 1
 341: oPushResult
 342: oSetResult 4
 344: oPushResult
 345: oNodeGetInt
 346: oPop 2
 348: oPushResult
 349: oNodeSetInt
 350: oPop 3
 352: oGetLocal 2
 354: oPushResult
 355: oSetResult 9
 357: oPushResult
 358: oGetLocal 1
 360: oPushResult
 361: oSetResult 9
 363: oPushResult
 364: oNodeGet
 365: oPop 2
 367: oPushResult
 368: oNodeSet
 369: oPop 3
 371: oGetLocal 2
 373: oPushResult
 374: oScopeDeclare
 375: oPop 1
 377: oJumpForward 382
 379: Choice Lookup Table
           0    311
 382: oInputChoice 386
 384: oJumpForward 391
 386: Choice Lookup Table
          12    384
 389: oJumpForward 393
 391: oJumpBack 288
 393: oInput 4
 395: oReturn
 396: oLocalSpace 1
 398: oGetFromParam 1
 400: oPushResult
 401: oNodeType
 402: oPop 1
 404: oChoice 435
 406: oGetAddrLocal 1
 408: oPushResult
 409: oGetFromParam 1
 411: oPushResult
 412: oSetResult 9
 414: oPushResult
 415: oNodeGet
 416: oPop 2
 418: oAssign
 419: oInput 19
 421: oInput 0
 423: oGetParam 1
 425: oPushResult
 426: oGetLocal 1
 428: oPushResult
 429: oScopeFindRequireInScope
 430: oPop 1
 432: oAssign
 433: oJumpForward 438
 435: Choice Lookup Table
          10    406
 438: oReturn
 439: oLocalSpace 2
 441: oGetAddrLocal 1
 443: oPushResult
 444: oGetParam 1
 446: oPushResult
 447: oSetResult 5
 449: oPushResult
 450: oNodeGetIter
 451: oPop 2
 453: oAssign
 454: oGetAddrLocal 2
 456: oPushResult
 457: oGetLocal 1
 459: oPushResult
 460: oNodeIterValue
 461: oPop 1
 463: oAssign
 464: oGetLocal 2
 466: oPushResult
 467: oNodeNull
 468: oPop 1
 470: oChoice 487
 472: oGetLocal 2
 474: oPushResult
 475: oSetResult 9
 477: oPushResult
 478: oNodeGet
 479: oPop 2
 481: oPushResult
 482: oScopeEnter
 483: oPop 1
 485: oJumpForward 492
 487: Choice Lookup Table
           0    472
 490: oJumpForward 500
 492: oGetAddrLocal 1
 494: oPushResult
 495: oNodeIterNext
 496: oPop 1
 498: oJumpBack 454
 500: oReturn
 501: oLocalSpace 2
 503: oGetAddrLocal 1
 505: oPushResult
 506: oGetParam 1
 508: oPushResult
 509: oSetResult 5
 511: oPushResult
 512: oNodeGetIterLast
 513: oPop 2
 515: oAssign
 516: oGetAddrLocal 2
 518: oPushResult
 519: oGetLocal 1
 521: oPushResult
 522: oNodeIterValue
 523: oPop 1
 525: oAssign
 526: oGetLocal 2
 528: oPushResult
 529: oNodeNull
 530: oPop 1
 532: oChoice 566
 534: oScopeCurrent
 535: oPushResult
 536: oGetLocal 2
 538: oPushResult
 539: oSetResult 9
 541: oPushResult
 542: oNodeGet
 543: oPop 2
 545: oPushResult
 546: oNodeEqual
 547: oPop 2
 549: oChoice 557
 551: oJumpForward 563
 553: oError 25
 555: oJumpForward 563
 557: Choice Lookup Table
           0    553
           1    551
 562: oEndChoice
 563: oScopeEnd
 564: oJumpForward 571
 566: Choice Lookup Table
           0    534
 569: oJumpForward 579
 571: oGetAddrLocal 1
 573: oPushResult
 574: oNodeIterPrev
 575: oPop 1
 577: oJumpBack 516
 579: oReturn
 580: oLocalSpace 2
 582: oGetAddrLocal 1
 584: oPushResult
 585: oGetGlobal 1
 587: oPushResult
 588: oSetResult 1
 590: oPushResult
 591: oSetResult 4
 593: oPushResult
 594: oGetParam 1
 596: oPushResult
 597: oNodeFind
 598: oPop 4
 600: oAssign
 601: oGetLocal 1
 603: oPushResult
 604: oSetResult 0
 606: oPushResult
 607: equal_node
 608: oPop 2
 610: oChoice 617
 612: oGetLocal 1
 614: oReturn
 615: oJumpForward 620
 617: Choice Lookup Table
           0    612
 620: oGetAddrLocal 2
 622: oPushResult
 623: oGetParam 1
 625: oPushResult
 626: oIncludeUnitFile
 627: oPop 1
 629: oAssign
 630: oGetLocal 2
 632: oChoice 641
 634: oError 24
 636: oSetResult 0
 638: oReturn
 639: oJumpForward 644
 641: Choice Lookup Table
           0    634
 644: oGetAddrLocal 1
 646: oPushResult
 647: oCall 655
 649: oAssign
 650: oIncludeEnd
 651: oGetLocal 1
 653: oReturn
 654: oReturn
 655: oLocalSpace 2
 657: oInput 55
 659: oInput 0
 661: oGetAddrLocal 1
 663: oPushResult
 664: oSetResult 5
 666: oPushResult
 667: oNodeNew
 668: oPop 1
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 4
 676: oPushResult
 677: LAST_ID
 678: oPushResult
 679: oNodeSetInt
 680: oPop 3
 682: oGetAddrLocal 2
 684: oPushResult
 685: oSetResult 6
 687: oPushResult
 688: oNodeNew
 689: oPop 1
 691: oAssign
 692: oGetLocal 2
 694: oPushResult
 695: oSetResult 4
 697: oPushResult
 698: LAST_ID
 699: oPushResult
 700: oNodeSetInt
 701: oPop 3
 703: oGetLocal 1
 705: oPushResult
 706: oSetResult 8
 708: oPushResult
 709: oGetLocal 2
 711: oPushResult
 712: oNodeSet
 713: oPop 3
 715: oInput 4
 717: oInput 56
 719: oInputChoice 730
 721: oGetLocal 1
 723: oPushResult
 724: oCall 286
 726: oPop 1
 728: oJumpForward 733
 730: Choice Lookup Table
          54    721
 733: oGetLocal 1
 735: oPushResult
 736: oCall 439
 738: oPop 1
 740: oSetResult 0
 742: oPushResult
 743: oSetResult 0
 745: oPushResult
 746: oScopeBegin
 747: oPop 2
 749: oGetLocal 1
 751: oPushResult
 752: oSetResult 9
 754: oPushResult
 755: oScopeCurrent
 756: oPushResult
 757: oNodeSet
 758: oPop 3
 760: oSetResult 0
 762: oPushResult
 763: oSetResult 1
 765: oPushResult
 766: oScopeBegin
 767: oPop 2
 769: oGetAddrGlobal 2
 771: oPushResult
 772: oScopeCurrent
 773: oAssign
 774: oGetLocal 1
 776: oPushResult
 777: oSetResult 13
 779: oPushResult
 780: oGetGlobal 2
 782: oPushResult
 783: oNodeSet
 784: oPop 3
 786: oScopeEnd
 787: oGetLocal 1
 789: oPushResult
 790: oCall 966
 792: oPop 1
 794: oScopeEnd
 795: oInput 57
 797: oInputChoice 808
 799: oGetLocal 2
 801: oPushResult
 802: oCall 286
 804: oPop 1
 806: oJumpForward 811
 808: Choice Lookup Table
          54    799
 811: oGetLocal 2
 813: oPushResult
 814: oCall 439
 816: oPop 1
 818: oGetLocal 1
 820: oPushResult
 821: oSetResult 9
 823: oPushResult
 824: oNodeGet
 825: oPop 2
 827: oPushResult
 828: oScopeEnter
 829: oPop 1
 831: oSetResult 0
 833: oPushResult
 834: oSetResult 0
 836: oPushResult
 837: oScopeBegin
 838: oPop 2
 840: oGetLocal 1
 842: oPushResult
 843: oSetResult 10
 845: oPushResult
 846: oScopeCurrent
 847: oPushResult
 848: oNodeSet
 849: oPop 3
 851: oScopeCurrent
 852: oPushResult
 853: oSetResult 16
 855: oPushResult
 856: oGetLocal 1
 858: oPushResult
 859: oSetResult 9
 861: oPushResult
 862: oNodeGet
 863: oPop 2
 865: oPushResult
 866: oNodeSet
 867: oPop 3
 869: oGetLocal 1
 871: oPushResult
 872: oCall 1051
 874: oPop 1
 876: oInputChoice 890
 878: oGetLocal 1
 880: oPushResult
 881: oSetResult 1
 883: oPushResult
 884: oCall 1061
 886: oPop 2
 888: oJumpForward 903
 890: Choice Lookup Table
          58    878
 893: oGetLocal 1
 895: oPushResult
 896: oSetResult 0
 898: oPushResult
 899: oCall 1061
 901: oPop 2
 903: oInputChoice 917
 905: oGetLocal 1
 907: oPushResult
 908: oSetResult 1
 910: oPushResult
 911: oCall 1247
 913: oPop 2
 915: oJumpForward 930
 917: Choice Lookup Table
          59    905
 920: oGetLocal 1
 922: oPushResult
 923: oSetResult 0
 925: oPushResult
 926: oCall 1247
 928: oPop 2
 930: oInput 34
 932: oInput 19
 934: oScopeEnd
 935: oScopeEnd
 936: oGetLocal 2
 938: oPushResult
 939: oCall 501
 941: oPop 1
 943: oGetLocal 1
 945: oPushResult
 946: oCall 501
 948: oPop 1
 950: oGetGlobal 1
 952: oPushResult
 953: oSetResult 1
 955: oPushResult
 956: oGetLocal 1
 958: oPushResult
 959: oNodeAddLast
 960: oPop 3
 962: oGetLocal 1
 964: oReturn
 965: oReturn
 966: oLocalSpace 2
 968: oInputChoice 1035
 970: oCall 2854
 972: oJumpForward 1048
 974: oCall 2923
 976: oJumpForward 1048
 978: oSetResult 18
 980: oPushResult
 981: oCall 2979
 983: oPop 1
 985: oJumpForward 1048
 987: oGetAddrLocal 1
 989: oPushResult
 990: oCall 1821
 992: oAssign
 993: oInputChoice 1006
 995: oGetLocal 1
 997: oPushResult
 998: oCall 1759
1000: oPop 1
1002: oInput 4
1004: oJumpForward 1009
1006: Choice Lookup Table
          65    995
1009: oJumpForward 1048
1011: oGetAddrLocal 2
1013: oPushResult
1014: oCall 2195
1016: oAssign
1017: oInputChoice 1030
1019: oGetLocal 2
1021: oPushResult
1022: oCall 1759
1024: oPop 1
1026: oInput 4
1028: oJumpForward 1033
1030: Choice Lookup Table
          65   1019
1033: oJumpForward 1048
1035: Choice Lookup Table
          29   1011
          28    987
          32    978
          31    974
          30    970
1046: oJumpForward 1050
1048: oJumpBack 968
1050: oReturn
1051: oLocalSpace 0
1053: oSetResult 18
1055: oPushResult
1056: oCall 1363
1058: oPop 1
1060: oReturn
1061: oLocalSpace 5
1063: oGetAddrLocal 1
1065: oPushResult
1066: oLabelNew
1067: oAssign
1068: oEmit 56
1070: oGetLocal 1
1072: oPushResult
1073: oEmitLabel
1074: oPop 1
1076: oGetParam 2
1078: oPushResult
1079: oSetResult 11
1081: oPushResult
1082: oGetLocal 1
1084: oPushResult
1085: oNodeSetLabel
1086: oPop 3
1088: oEmit 52
1090: oGetAddrLocal 2
1092: oPushResult
1093: Here
1094: oAssign
1095: oEmit 64
1097: oGetAddrLocal 3
1099: oPushResult
1100: oGetParam 2
1102: oPushResult
1103: oSetResult 9
1105: oPushResult
1106: oNodeGet
1107: oPop 2
1109: oAssign
1110: oGetAddrLocal 4
1112: oPushResult
1113: oGetLocal 3
1115: oPushResult
1116: oSetResult 19
1118: oPushResult
1119: oNodeGetCode
1120: oPop 2
1122: oAssign
1123: oGetLocal 4
1125: oPushResult
1126: oEmitCode
1127: oPop 1
1129: oGetLocal 3
1131: oPushResult
1132: oSetResult 19
1134: oPushResult
1135: oSetResult 0
1137: oPushResult
1138: oNodeSetCode
1139: oPop 3
1141: oGetAddrLocal 3
1143: oPushResult
1144: oGetParam 2
1146: oPushResult
1147: oSetResult 10
1149: oPushResult
1150: oNodeGet
1151: oPop 2
1153: oAssign
1154: oGetAddrLocal 4
1156: oPushResult
1157: oGetLocal 3
1159: oPushResult
1160: oSetResult 19
1162: oPushResult
1163: oNodeGetCode
1164: oPop 2
1166: oAssign
1167: oGetLocal 4
1169: oPushResult
1170: oEmitCode
1171: oPop 1
1173: oGetLocal 3
1175: oPushResult
1176: oSetResult 19
1178: oPushResult
1179: oSetResult 0
1181: oPushResult
1182: oNodeSetCode
1183: oPop 3
1185: oGetParam 2
1187: oPushResult
1188: oSetResult 13
1190: oPushResult
1191: oNodeGet
1192: oPop 2
1194: oPushResult
1195: oScopeEnter
1196: oPop 1
1198: oGetParam 1
1200: oChoice 1219
1202: oCall 7037
1204: oInputChoice 1210
1206: oCall 7037
1208: oJumpForward 1215
1210: Choice Lookup Table
           4   1206
1213: oJumpForward 1217
1215: oJumpBack 1204
1217: oJumpForward 1222
1219: Choice Lookup Table
           1   1202
1222: oEmit 51
1224: oGetAddrLocal 5
1226: oPushResult
1227: oScopeCurrent
1228: oPushResult
1229: oSetResult 17
1231: oPushResult
1232: oNodeGetInt
1233: oPop 2
1235: oAssign
1236: oGetLocal 2
1238: oPushResult
1239: oGetLocal 5
1241: oPushResult
1242: oPatch
1243: oPop 2
1245: oScopeEnd
1246: oReturn
1247: oLocalSpace 3
1249: oGetAddrLocal 1
1251: oPushResult
1252: oLabelNew
1253: oAssign
1254: oEmit 56
1256: oGetLocal 1
1258: oPushResult
1259: oEmitLabel
1260: oPop 1
1262: oGetParam 2
1264: oPushResult
1265: oSetResult 12
1267: oPushResult
1268: oGetLocal 1
1270: oPushResult
1271: oNodeSetLabel
1272: oPop 3
1274: oEmit 52
1276: oGetAddrLocal 2
1278: oPushResult
1279: Here
1280: oAssign
1281: oEmit 64
1283: oSetResult 0
1285: oPushResult
1286: oSetResult 1
1288: oPushResult
1289: oScopeBegin
1290: oPop 2
1292: oGetParam 1
1294: oChoice 1313
1296: oCall 7037
1298: oInputChoice 1304
1300: oCall 7037
1302: oJumpForward 1309
1304: Choice Lookup Table
           4   1300
1307: oJumpForward 1311
1309: oJumpBack 1298
1311: oJumpForward 1316
1313: Choice Lookup Table
           1   1296
1316: oEmit 51
1318: oGetAddrLocal 3
1320: oPushResult
1321: oScopeCurrent
1322: oPushResult
1323: oSetResult 17
1325: oPushResult
1326: oNodeGetInt
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oGetLocal 3
1335: oPushResult
1336: oPatch
1337: oPop 2
1339: oScopeEnd
1340: oReturn
1341: oLocalSpace 0
1343: oGetParam 2
1345: oPushResult
1346: oCall 1363
1348: oPop 1
1350: oGetParam 1
1352: oPushResult
1353: oScopeCurrent
1354: oPushResult
1355: oSetResult 0
1357: oPushResult
1358: oCall 1583
1360: oPop 3
1362: oReturn
1363: oLocalSpace 0
1365: oInputChoice 1392
1367: oCall 2854
1369: oJumpForward 1405
1371: oCall 2923
1373: oJumpForward 1405
1375: oGetParam 1
1377: oPushResult
1378: oCall 2979
1380: oPop 1
1382: oJumpForward 1405
1384: oCall 2077
1386: oJumpForward 1405
1388: oCall 2512
1390: oJumpForward 1405
1392: Choice Lookup Table
          29   1388
          28   1384
          32   1375
          31   1371
          30   1367
1403: oJumpForward 1407
1405: oJumpBack 1365
1407: oCall 1410
1409: oReturn
1410: oLocalSpace 0
1412: oReturn
1413: oLocalSpace 2
1415: oGetAddrLocal 1
1417: oPushResult
1418: oGetGlobal 1
1420: oPushResult
1421: oSetResult 1
1423: oPushResult
1424: oNodeGetIter
1425: oPop 2
1427: oAssign
1428: oGetAddrLocal 2
1430: oPushResult
1431: oGetLocal 1
1433: oPushResult
1434: oNodeIterValue
1435: oPop 1
1437: oAssign
1438: oGetLocal 2
1440: oPushResult
1441: oNodeNull
1442: oPop 1
1444: oChoice 1489
1446: oJumpForward 1497
1448: oJumpForward 1495
1450: oEmit 46
1452: oSetResult 0
1454: oPushResult
1455: oEmitInt
1456: oPop 1
1458: oEmit 49
1460: oGetLocal 2
1462: oPushResult
1463: oSetResult 11
1465: oPushResult
1466: oNodeGetLabel
1467: oPop 2
1469: oPushResult
1470: oEmitLabel
1471: oPop 1
1473: oEmit 48
1475: oSetResult 0
1477: oPushResult
1478: oEmitInt
1479: oPop 1
1481: oGetAddrLocal 1
1483: oPushResult
1484: oNodeIterNext
1485: oPop 1
1487: oJumpForward 1495
1489: Choice Lookup Table
           0   1450
           1   1446
1494: oEndChoice
1495: oJumpBack 1428
1497: oReturn
1498: oLocalSpace 2
1500: oGetAddrLocal 1
1502: oPushResult
1503: oGetGlobal 1
1505: oPushResult
1506: oSetResult 1
1508: oPushResult
1509: oNodeGetIterLast
1510: oPop 2
1512: oAssign
1513: oGetAddrLocal 2
1515: oPushResult
1516: oGetLocal 1
1518: oPushResult
1519: oNodeIterValue
1520: oPop 1
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oNodeNull
1527: oPop 1
1529: oChoice 1574
1531: oJumpForward 1582
1533: oJumpForward 1580
1535: oEmit 46
1537: oSetResult 0
1539: oPushResult
1540: oEmitInt
1541: oPop 1
1543: oEmit 49
1545: oGetLocal 2
1547: oPushResult
1548: oSetResult 12
1550: oPushResult
1551: oNodeGetLabel
1552: oPop 2
1554: oPushResult
1555: oEmitLabel
1556: oPop 1
1558: oEmit 48
1560: oSetResult 0
1562: oPushResult
1563: oEmitInt
1564: oPop 1
1566: oGetAddrLocal 1
1568: oPushResult
1569: oNodeIterPrev
1570: oPop 1
1572: oJumpForward 1580
1574: Choice Lookup Table
           0   1535
           1   1531
1579: oEndChoice
1580: oJumpBack 1513
1582: oReturn
1583: oLocalSpace 3
1585: oEmit 56
1587: oGetParam 3
1589: oPushResult
1590: oEmitLabel
1591: oPop 1
1593: oEmit 52
1595: oGetAddrLocal 1
1597: oPushResult
1598: Here
1599: oAssign
1600: oEmit 64
1602: oGetParam 1
1604: oChoice 1610
1606: oCall 1413
1608: oJumpForward 1613
1610: Choice Lookup Table
           1   1606
1613: oGetAddrLocal 2
1615: oPushResult
1616: oGetParam 2
1618: oPushResult
1619: oSetResult 19
1621: oPushResult
1622: oNodeGetCode
1623: oPop 2
1625: oAssign
1626: oGetLocal 2
1628: oPushResult
1629: oEmitCode
1630: oPop 1
1632: oGetParam 2
1634: oPushResult
1635: oSetResult 19
1637: oPushResult
1638: oSetResult 0
1640: oPushResult
1641: oNodeSetCode
1642: oPop 3
1644: oCall 7037
1646: oGetParam 1
1648: oChoice 1654
1650: oCall 1498
1652: oJumpForward 1657
1654: Choice Lookup Table
           1   1650
1657: oEmit 51
1659: oGetAddrLocal 3
1661: oPushResult
1662: oScopeCurrent
1663: oPushResult
1664: oSetResult 17
1666: oPushResult
1667: oNodeGetInt
1668: oPop 2
1670: oAssign
1671: oGetLocal 1
1673: oPushResult
1674: oGetLocal 3
1676: oPushResult
1677: oPatch
1678: oPop 2
1680: oReturn
1681: oLocalSpace 0
1683: oInputChoice 1701
1685: oGetParam 1
1687: oPushResult
1688: oSetResult 27
1690: oPushResult
1691: oSetResult 1
1693: oPushResult
1694: oNodeSetBoolean
1695: oPop 3
1697: oInput 4
1699: oJumpForward 1706
1701: Choice Lookup Table
          67   1685
1704: oJumpForward 1708
1706: oJumpBack 1683
1708: oReturn
1709: oLocalSpace 1
1711: oGetAddrLocal 1
1713: oPushResult
1714: oScopeCurrent
1715: oPushResult
1716: oSetResult 19
1718: oPushResult
1719: oNodeGetCode
1720: oPop 2
1722: oAssign
1723: oGetLocal 1
1725: oPushResult
1726: oSetResult 0
1728: oPushResult
1729: equal_code
1730: oPop 2
1732: oChoice 1752
1734: oGetAddrLocal 1
1736: oPushResult
1737: oCodeNew
1738: oAssign
1739: oScopeCurrent
1740: oPushResult
1741: oSetResult 19
1743: oPushResult
1744: oGetLocal 1
1746: oPushResult
1747: oNodeSetCode
1748: oPop 3
1750: oJumpForward 1755
1752: Choice Lookup Table
           1   1734
1755: oGetLocal 1
1757: oReturn
1758: oReturn
1759: oLocalSpace 0
1761: oGetParam 1
1763: oPushResult
1764: oCall 8112
1766: oPop 1
1768: oPushResult
1769: equal_zero
1770: oPop 1
1772: oChoice 1778
1774: oError 23
1776: oJumpForward 1781
1778: Choice Lookup Table
           0   1774
1781: oGetParam 1
1783: oPushResult
1784: oSetResult 25
1786: oPushResult
1787: oSetResult 1
1789: oPushResult
1790: oNodeSetBoolean
1791: oPop 3
1793: oInputChoice 1817
1795: oInputChoice 1812
1797: oInput 2
1799: oGetParam 1
1801: oPushResult
1802: oSetResult 26
1804: oPushResult
1805: CURRENT_STRLIT
1806: oPushResult
1807: oNodeSetString
1808: oPop 3
1810: oJumpForward 1815
1812: Choice Lookup Table
          66   1797
1815: oJumpForward 1820
1817: Choice Lookup Table
           2   1795
1820: oReturn
1821: oLocalSpace 6
1823: oInput 0
1825: oGetAddrLocal 1
1827: oPushResult
1828: oSetResult 0
1830: oAssign
1831: oGetAddrLocal 2
1833: oPushResult
1834: oScopeFindInCurrentScope
1835: oAssign
1836: oGetLocal 2
1838: oPushResult
1839: oNodeNull
1840: oPop 1
1842: oChoice 1960
1844: oGetAddrLocal 2
1846: oPushResult
1847: oSetResult 12
1849: oPushResult
1850: LAST_ID
1851: oPushResult
1852: oCall 8264
1854: oPop 2
1856: oAssign
1857: oGetLocal 2
1859: oPushResult
1860: oSetResult 22
1862: oPushResult
1863: oLabelNew
1864: oPushResult
1865: oNodeSetLabel
1866: oPop 3
1868: oJumpForward 1966
1870: oGetAddrLocal 1
1872: oPushResult
1873: oSetResult 1
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oSetResult 24
1881: oPushResult
1882: oNodeGetBoolean
1883: oPop 2
1885: oChoice 1891
1887: oError 21
1889: oJumpForward 1894
1891: Choice Lookup Table
           1   1887
1894: oGetLocal 2
1896: oPushResult
1897: oSetResult 25
1899: oPushResult
1900: oNodeGetBoolean
1901: oPop 2
1903: oChoice 1909
1905: oError 21
1907: oJumpForward 1912
1909: Choice Lookup Table
           1   1905
1912: oGetLocal 2
1914: oPushResult
1915: oNodeType
1916: oPop 1
1918: oChoice 1922
1920: oJumpForward 1927
1922: Choice Lookup Table
          12   1920
1925: oError 21
1927: oGetLocal 2
1929: oPushResult
1930: oSetResult 29
1932: oPushResult
1933: oGetLocal 2
1935: oPushResult
1936: oSetResult 23
1938: oPushResult
1939: oNodeGet
1940: oPop 2
1942: oPushResult
1943: oNodeSet
1944: oPop 3
1946: oGetLocal 2
1948: oPushResult
1949: oSetResult 23
1951: oPushResult
1952: oSetResult 0
1954: oPushResult
1955: oNodeSet
1956: oPop 3
1958: oJumpForward 1966
1960: Choice Lookup Table
           0   1870
           1   1844
1965: oEndChoice
1966: oGetAddrLocal 3
1968: oPushResult
1969: oCall 8100
1971: oAssign
1972: oGetAddrLocal 4
1974: oPushResult
1975: oGetLocal 3
1977: oPushResult
1978: oSetResult 0
1980: oPushResult
1981: greater
1982: oPop 2
1984: oAssign
1985: oGetAddrLocal 3
1987: oPushResult
1988: inc
1989: oPop 1
1991: oGetLocal 3
1993: oPushResult
1994: oSetResult 2
1996: oPushResult
1997: oScopeBegin
1998: oPop 2
2000: oGetAddrLocal 5
2002: oPushResult
2003: oScopeCurrent
2004: oAssign
2005: oGetLocal 4
2007: oChoice 2026
2009: oGetAddrLocal 6
2011: oPushResult
2012: oGetGlobal 4
2014: oPushResult
2015: oCall 8292
2017: oPop 1
2019: oPushResult
2020: oScopeAllocType
2021: oPop 1
2023: oAssign
2024: oJumpForward 2029
2026: Choice Lookup Table
           1   2009
2029: oCall 2630
2031: oGetLocal 2
2033: oPushResult
2034: oSetResult 23
2036: oPushResult
2037: oGetLocal 5
2039: oPushResult
2040: oNodeSet
2041: oPop 3
2043: oScopeEnd
2044: oInput 4
2046: oGetLocal 1
2048: oChoice 2060
2050: oGetLocal 2
2052: oPushResult
2053: oScopeDeclare
2054: oPop 1
2056: oJumpForward 2066
2058: oJumpForward 2066
2060: Choice Lookup Table
           1   2058
           0   2050
2065: oEndChoice
2066: oGetLocal 2
2068: oPushResult
2069: oCall 1681
2071: oPop 1
2073: oGetLocal 2
2075: oReturn
2076: oReturn
2077: oLocalSpace 4
2079: oGetAddrLocal 1
2081: oPushResult
2082: oCall 1821
2084: oAssign
2085: oInputChoice 2098
2087: oJumpForward 2192
2089: oGetLocal 1
2091: oPushResult
2092: oCall 1759
2094: oPop 1
2096: oJumpForward 2192
2098: Choice Lookup Table
          65   2089
          64   2087
2103: oGetAddrLocal 2
2105: oPushResult
2106: oGetLocal 1
2108: oPushResult
2109: oSetResult 23
2111: oPushResult
2112: oNodeGet
2113: oPop 2
2115: oAssign
2116: oGetLocal 2
2118: oPushResult
2119: oScopeEnter
2120: oPop 1
2122: oGetAddrLocal 3
2124: oPushResult
2125: oGetLocal 2
2127: oPushResult
2128: oSetResult 14
2130: oPushResult
2131: oNodeGetInt
2132: oPop 2
2134: oAssign
2135: oGetLocal 3
2137: oPushResult
2138: oSetResult 1
2140: oPushResult
2141: oScopeBegin
2142: oPop 2
2144: oGetLocal 1
2146: oPushResult
2147: oSetResult 6
2149: oPushResult
2150: oScopeCurrent
2151: oPushResult
2152: oNodeSet
2153: oPop 3
2155: oGetAddrLocal 4
2157: oPushResult
2158: oGetLocal 1
2160: oPushResult
2161: oSetResult 22
2163: oPushResult
2164: oNodeGetLabel
2165: oPop 2
2167: oAssign
2168: oSetResult 19
2170: oPushResult
2171: oGetLocal 4
2173: oPushResult
2174: oCall 1341
2176: oPop 2
2178: oGetLocal 1
2180: oPushResult
2181: oSetResult 24
2183: oPushResult
2184: oSetResult 1
2186: oPushResult
2187: oNodeSetBoolean
2188: oPop 3
2190: oScopeEnd
2191: oScopeEnd
2192: oInput 4
2194: oReturn
2195: oLocalSpace 8
2197: oInput 0
2199: oGetAddrLocal 1
2201: oPushResult
2202: oSetResult 0
2204: oAssign
2205: oGetAddrLocal 2
2207: oPushResult
2208: oScopeFindInCurrentScope
2209: oAssign
2210: oGetLocal 2
2212: oPushResult
2213: oNodeNull
2214: oPop 1
2216: oChoice 2347
2218: oGetAddrLocal 2
2220: oPushResult
2221: oSetResult 13
2223: oPushResult
2224: LAST_ID
2225: oPushResult
2226: oCall 8264
2228: oPop 2
2230: oAssign
2231: oGetLocal 2
2233: oPushResult
2234: oSetResult 22
2236: oPushResult
2237: oLabelNew
2238: oPushResult
2239: oNodeSetLabel
2240: oPop 3
2242: oJumpForward 2353
2244: oGetAddrLocal 1
2246: oPushResult
2247: oSetResult 1
2249: oAssign
2250: oGetLocal 2
2252: oPushResult
2253: oSetResult 24
2255: oPushResult
2256: oNodeGetBoolean
2257: oPop 2
2259: oChoice 2265
2261: oError 21
2263: oJumpForward 2268
2265: Choice Lookup Table
           1   2261
2268: oGetLocal 2
2270: oPushResult
2271: oNodeType
2272: oPop 1
2274: oChoice 2278
2276: oJumpForward 2283
2278: Choice Lookup Table
          13   2276
2281: oError 21
2283: oGetLocal 2
2285: oPushResult
2286: oSetResult 29
2288: oPushResult
2289: oGetLocal 2
2291: oPushResult
2292: oSetResult 23
2294: oPushResult
2295: oNodeGet
2296: oPop 2
2298: oPushResult
2299: oNodeSet
2300: oPop 3
2302: oGetLocal 2
2304: oPushResult
2305: oSetResult 23
2307: oPushResult
2308: oSetResult 0
2310: oPushResult
2311: oNodeSet
2312: oPop 3
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 30
2319: oPushResult
2320: oGetLocal 2
2322: oPushResult
2323: oSetResult 21
2325: oPushResult
2326: oNodeGet
2327: oPop 2
2329: oPushResult
2330: oNodeSet
2331: oPop 3
2333: oGetLocal 2
2335: oPushResult
2336: oSetResult 21
2338: oPushResult
2339: oSetResult 0
2341: oPushResult
2342: oNodeSet
2343: oPop 3
2345: oJumpForward 2353
2347: Choice Lookup Table
           0   2244
           1   2218
2352: oEndChoice
2353: oGetAddrLocal 3
2355: oPushResult
2356: oCall 8100
2358: oAssign
2359: oGetAddrLocal 4
2361: oPushResult
2362: oGetLocal 3
2364: oPushResult
2365: oSetResult 0
2367: oPushResult
2368: greater
2369: oPop 2
2371: oAssign
2372: oGetAddrLocal 3
2374: oPushResult
2375: inc
2376: oPop 1
2378: oGetLocal 3
2380: oPushResult
2381: oSetResult 2
2383: oPushResult
2384: oScopeBegin
2385: oPop 2
2387: oGetAddrLocal 5
2389: oPushResult
2390: oScopeCurrent
2391: oAssign
2392: oGetLocal 4
2394: oChoice 2413
2396: oGetAddrLocal 6
2398: oPushResult
2399: oGetGlobal 4
2401: oPushResult
2402: oCall 8292
2404: oPop 1
2406: oPushResult
2407: oScopeAllocType
2408: oPop 1
2410: oAssign
2411: oJumpForward 2416
2413: Choice Lookup Table
           1   2396
2416: oCall 2630
2418: oGetLocal 2
2420: oPushResult
2421: oSetResult 23
2423: oPushResult
2424: oGetLocal 5
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oInput 11
2432: oGetAddrLocal 7
2434: oPushResult
2435: oCall 3206
2437: oPop 1
2439: oGetLocal 2
2441: oPushResult
2442: oSetResult 21
2444: oPushResult
2445: oGetLocal 7
2447: oPushResult
2448: oNodeSet
2449: oPop 3
2451: oGetAddrLocal 8
2453: oPushResult
2454: oGetLocal 7
2456: oPushResult
2457: oCall 8292
2459: oPop 1
2461: oAssign
2462: oGetLocal 2
2464: oPushResult
2465: oSetResult 31
2467: oPushResult
2468: oGetLocal 8
2470: oPushResult
2471: oScopeAllocType
2472: oPop 1
2474: oPushResult
2475: oNodeSetInt
2476: oPop 3
2478: oScopeEnd
2479: oInput 4
2481: oGetLocal 1
2483: oChoice 2495
2485: oGetLocal 2
2487: oPushResult
2488: oScopeDeclare
2489: oPop 1
2491: oJumpForward 2501
2493: oJumpForward 2501
2495: Choice Lookup Table
           1   2493
           0   2485
2500: oEndChoice
2501: oGetLocal 2
2503: oPushResult
2504: oCall 1681
2506: oPop 1
2508: oGetLocal 2
2510: oReturn
2511: oReturn
2512: oLocalSpace 4
2514: oGetAddrLocal 1
2516: oPushResult
2517: oCall 2195
2519: oAssign
2520: oInputChoice 2533
2522: oJumpForward 2627
2524: oGetLocal 1
2526: oPushResult
2527: oCall 1759
2529: oPop 1
2531: oJumpForward 2627
2533: Choice Lookup Table
          65   2524
          64   2522
2538: oGetAddrLocal 2
2540: oPushResult
2541: oGetLocal 1
2543: oPushResult
2544: oSetResult 23
2546: oPushResult
2547: oNodeGet
2548: oPop 2
2550: oAssign
2551: oGetLocal 2
2553: oPushResult
2554: oScopeEnter
2555: oPop 1
2557: oGetAddrLocal 3
2559: oPushResult
2560: oGetLocal 2
2562: oPushResult
2563: oSetResult 14
2565: oPushResult
2566: oNodeGetInt
2567: oPop 2
2569: oAssign
2570: oGetLocal 3
2572: oPushResult
2573: oSetResult 1
2575: oPushResult
2576: oScopeBegin
2577: oPop 2
2579: oGetLocal 1
2581: oPushResult
2582: oSetResult 6
2584: oPushResult
2585: oScopeCurrent
2586: oPushResult
2587: oNodeSet
2588: oPop 3
2590: oGetAddrLocal 4
2592: oPushResult
2593: oGetLocal 1
2595: oPushResult
2596: oSetResult 22
2598: oPushResult
2599: oNodeGetLabel
2600: oPop 2
2602: oAssign
2603: oSetResult 19
2605: oPushResult
2606: oGetLocal 4
2608: oPushResult
2609: oCall 1341
2611: oPop 2
2613: oGetLocal 1
2615: oPushResult
2616: oSetResult 24
2618: oPushResult
2619: oSetResult 1
2621: oPushResult
2622: oNodeSetBoolean
2623: oPop 3
2625: oScopeEnd
2626: oScopeEnd
2627: oInput 4
2629: oReturn
2630: oLocalSpace 6
2632: oInputChoice 2850
2634: oGetAddrLocal 1
2636: oPushResult
2637: oNodeVecNew
2638: oAssign
2639: oGetAddrLocal 3
2641: oPushResult
2642: oSetResult 0
2644: oAssign
2645: oInputChoice 2655
2647: oGetAddrLocal 3
2649: oPushResult
2650: oSetResult 1
2652: oAssign
2653: oJumpForward 2658
2655: Choice Lookup Table
          32   2647
2658: oInput 0
2660: oGetAddrLocal 2
2662: oPushResult
2663: oSetResult 21
2665: oPushResult
2666: LAST_ID
2667: oPushResult
2668: oCall 8264
2670: oPop 2
2672: oAssign
2673: oGetLocal 2
2675: oPushResult
2676: oSetResult 32
2678: oPushResult
2679: oGetLocal 3
2681: oPushResult
2682: oNodeSetBoolean
2683: oPop 3
2685: oGetLocal 1
2687: oPushResult
2688: oGetLocal 2
2690: oPushResult
2691: oNodeVecAppend
2692: oPop 2
2694: oInputChoice 2702
2696: oJumpForward 2710
2698: oJumpForward 2708
2700: oJumpForward 2708
2702: Choice Lookup Table
          12   2700
          11   2696
2707: oEndChoice
2708: oJumpBack 2658
2710: oGetAddrLocal 4
2712: oPushResult
2713: oCall 3206
2715: oPop 1
2717: oGetLocal 3
2719: oChoice 2734
2721: oGetAddrLocal 5
2723: oPushResult
2724: oGetLocal 4
2726: oPushResult
2727: oCall 8292
2729: oPop 1
2731: oAssign
2732: oJumpForward 2743
2734: Choice Lookup Table
           1   2721
2737: oGetAddrLocal 5
2739: oPushResult
2740: oGetLocal 4
2742: oAssign
2743: oGetAddrLocal 6
2745: oPushResult
2746: oSetResult 0
2748: oAssign
2749: oGetLocal 6
2751: oPushResult
2752: oGetLocal 1
2754: oPushResult
2755: oNodeVecSize
2756: oPop 1
2758: oPushResult
2759: equal
2760: oPop 2
2762: oChoice 2819
2764: oGetAddrLocal 2
2766: oPushResult
2767: oGetLocal 1
2769: oPushResult
2770: oGetLocal 6
2772: oPushResult
2773: oNodeVecElement
2774: oPop 2
2776: oAssign
2777: oGetLocal 2
2779: oPushResult
2780: oSetResult 21
2782: oPushResult
2783: oGetLocal 4
2785: oPushResult
2786: oNodeSet
2787: oPop 3
2789: oGetLocal 2
2791: oPushResult
2792: oScopeDeclare
2793: oPop 1
2795: oGetLocal 2
2797: oPushResult
2798: oSetResult 22
2800: oPushResult
2801: oGetLocal 5
2803: oPushResult
2804: oScopeAllocType
2805: oPop 1
2807: oPushResult
2808: oNodeSetInt
2809: oPop 3
2811: oGetAddrLocal 6
2813: oPushResult
2814: inc
2815: oPop 1
2817: oJumpForward 2824
2819: Choice Lookup Table
           0   2764
2822: oJumpForward 2826
2824: oJumpBack 2749
2826: oGetLocal 1
2828: oPushResult
2829: oNodeVecDelete
2830: oPop 1
2832: oInputChoice 2840
2834: oJumpForward 2848
2836: oJumpForward 2846
2838: oJumpForward 2846
2840: Choice Lookup Table
           4   2838
          14   2834
2845: oEndChoice
2846: oJumpBack 2634
2848: oJumpForward 2853
2850: Choice Lookup Table
          13   2634
2853: oReturn
2854: oLocalSpace 2
2856: oInputChoice 2915
2858: oGetAddrLocal 1
2860: oPushResult
2861: oSetResult 14
2863: oPushResult
2864: LAST_ID
2865: oPushResult
2866: oCall 8264
2868: oPop 2
2870: oAssign
2871: oInput 5
2873: oCall 3923
2875: oGetAddrLocal 2
2877: oPushResult
2878: oValueTop
2879: oAssign
2880: oValuePop
2881: oGetLocal 1
2883: oPushResult
2884: oSetResult 22
2886: oPushResult
2887: oGetLocal 2
2889: oPushResult
2890: oNodeSetInt
2891: oPop 3
2893: oGetLocal 1
2895: oPushResult
2896: oSetResult 21
2898: oPushResult
2899: oGetGlobal 4
2901: oPushResult
2902: oNodeSet
2903: oPop 3
2905: oGetLocal 1
2907: oPushResult
2908: oScopeDeclare
2909: oPop 1
2911: oInput 4
2913: oJumpForward 2920
2915: Choice Lookup Table
           0   2858
2918: oJumpForward 2922
2920: oJumpBack 2856
2922: oReturn
2923: oLocalSpace 2
2925: oInputChoice 2971
2927: oGetAddrLocal 1
2929: oPushResult
2930: oSetResult 16
2932: oPushResult
2933: LAST_ID
2934: oPushResult
2935: oCall 8264
2937: oPop 2
2939: oAssign
2940: oInput 5
2942: oGetAddrLocal 2
2944: oPushResult
2945: oCall 3206
2947: oPop 1
2949: oGetLocal 1
2951: oPushResult
2952: oSetResult 21
2954: oPushResult
2955: oGetLocal 2
2957: oPushResult
2958: oNodeSet
2959: oPop 3
2961: oGetLocal 1
2963: oPushResult
2964: oScopeDeclare
2965: oPop 1
2967: oInput 4
2969: oJumpForward 2976
2971: Choice Lookup Table
           0   2927
2974: oJumpForward 2978
2976: oJumpBack 2925
2978: oReturn
2979: oLocalSpace 6
2981: oInputChoice 3198
2983: oGetAddrLocal 1
2985: oPushResult
2986: oNodeVecNew
2987: oAssign
2988: oGetAddrLocal 2
2990: oPushResult
2991: oGetParam 1
2993: oPushResult
2994: LAST_ID
2995: oPushResult
2996: oCall 8264
2998: oPop 2
3000: oAssign
3001: oGetLocal 1
3003: oPushResult
3004: oGetLocal 2
3006: oPushResult
3007: oNodeVecAppend
3008: oPop 2
3010: oInputChoice 3016
3012: oInput 0
3014: oJumpForward 3021
3016: Choice Lookup Table
          12   3012
3019: oJumpForward 3023
3021: oJumpBack 2988
3023: oInput 11
3025: oGetAddrLocal 3
3027: oPushResult
3028: oCall 3206
3030: oPop 1
3032: oGetAddrLocal 4
3034: oPushResult
3035: oSetResult 0
3037: oAssign
3038: oGetLocal 4
3040: oPushResult
3041: oGetLocal 1
3043: oPushResult
3044: oNodeVecSize
3045: oPop 1
3047: oPushResult
3048: equal
3049: oPop 2
3051: oChoice 3092
3053: oGetAddrLocal 2
3055: oPushResult
3056: oGetLocal 1
3058: oPushResult
3059: oGetLocal 4
3061: oPushResult
3062: oNodeVecElement
3063: oPop 2
3065: oAssign
3066: oGetLocal 2
3068: oPushResult
3069: oSetResult 21
3071: oPushResult
3072: oGetLocal 3
3074: oPushResult
3075: oNodeSet
3076: oPop 3
3078: oGetLocal 2
3080: oPushResult
3081: oScopeDeclareAlloc
3082: oPop 1
3084: oGetAddrLocal 4
3086: oPushResult
3087: inc
3088: oPop 1
3090: oJumpForward 3097
3092: Choice Lookup Table
           0   3053
3095: oJumpForward 3099
3097: oJumpBack 3038
3099: oInputChoice 3185
3101: oGetLocal 1
3103: oPushResult
3104: oNodeVecSize
3105: oPop 1
3107: oChoice 3111
3109: oJumpForward 3116
3111: Choice Lookup Table
           1   3109
3114: oError 22
3116: oGetAddrLocal 5
3118: oPushResult
3119: oCall 1709
3121: oAssign
3122: oGetLocal 5
3124: oPushResult
3125: oCodePush
3126: oPop 1
3128: oGetAddrLocal 6
3130: oPushResult
3131: oSetResult 0
3133: oAssign
3134: oCall 8100
3136: oPushResult
3137: equal_zero
3138: oPop 1
3140: oChoice 3156
3142: oGetGlobal 2
3144: oPushResult
3145: oScopeEnter
3146: oPop 1
3148: oGetAddrLocal 6
3150: oPushResult
3151: oSetResult 1
3153: oAssign
3154: oJumpForward 3159
3156: Choice Lookup Table
           1   3142
3159: oGetLocal 2
3161: oPushResult
3162: oCall 7413
3164: oPop 1
3166: oCall 3996
3168: oCall 8150
3170: oCall 7196
3172: oGetLocal 6
3174: oChoice 3179
3176: oScopeEnd
3177: oJumpForward 3182
3179: Choice Lookup Table
           1   3176
3182: oCodePop
3183: oJumpForward 3188
3185: Choice Lookup Table
           5   3101
3188: oGetLocal 1
3190: oPushResult
3191: oNodeVecDelete
3192: oPop 1
3194: oInput 4
3196: oJumpForward 3203
3198: Choice Lookup Table
           0   2983
3201: oJumpForward 3205
3203: oJumpBack 2981
3205: oReturn
3206: oLocalSpace 17
3208: oInputChoice 3903
3210: oGetAddrLocal 1
3212: oPushResult
3213: oScopeFindRequire
3214: oAssign
3215: oGetAddrLocal 1
3217: oPushResult
3218: oCall 396
3220: oPop 1
3222: oGetLocal 1
3224: oPushResult
3225: oNodeType
3226: oPop 1
3228: oChoice 3245
3230: oGetParam 1
3232: oPushResult
3233: oGetLocal 1
3235: oPushResult
3236: oSetResult 21
3238: oPushResult
3239: oNodeGet
3240: oPop 2
3242: oAssign
3243: oJumpForward 3256
3245: Choice Lookup Table
          16   3230
3248: oError 2
3250: oGetParam 1
3252: oPushResult
3253: oGetGlobal 4
3255: oAssign
3256: oJumpForward 3922
3258: oInput 15
3260: oGetAddrLocal 2
3262: oPushResult
3263: oNodeVecNew
3264: oAssign
3265: oGetAddrLocal 3
3267: oPushResult
3268: oSetResult 31
3270: oPushResult
3271: oNodeNew
3272: oPop 1
3274: oAssign
3275: oGetLocal 3
3277: oPushResult
3278: oSetResult 34
3280: oPushResult
3281: oGetGlobal 4
3283: oPushResult
3284: oNodeSet
3285: oPop 3
3287: oCall 3923
3289: oGetLocal 3
3291: oPushResult
3292: oSetResult 36
3294: oPushResult
3295: oValueTop
3296: oPushResult
3297: oNodeSetInt
3298: oPop 3
3300: oValuePop
3301: oInput 20
3303: oCall 3923
3305: oGetLocal 3
3307: oPushResult
3308: oSetResult 37
3310: oPushResult
3311: oValueTop
3312: oPushResult
3313: oNodeSetInt
3314: oPop 3
3316: oValuePop
3317: oGetLocal 3
3319: oPushResult
3320: oSetResult 17
3322: oPushResult
3323: oSetResult 4
3325: oPushResult
3326: oNodeSetInt
3327: oPop 3
3329: oGetLocal 3
3331: oPushResult
3332: oTypeAdd
3333: oPop 1
3335: oGetAddrLocal 4
3337: oPushResult
3338: oSetResult 30
3340: oPushResult
3341: oNodeNew
3342: oPop 1
3344: oAssign
3345: oGetLocal 4
3347: oPushResult
3348: oSetResult 35
3350: oPushResult
3351: oGetLocal 3
3353: oPushResult
3354: oNodeSet
3355: oPop 3
3357: oGetLocal 2
3359: oPushResult
3360: oGetLocal 4
3362: oPushResult
3363: oNodeVecAppend
3364: oPop 2
3366: oInputChoice 3374
3368: oJumpForward 3382
3370: oJumpForward 3380
3372: oJumpForward 3380
3374: Choice Lookup Table
          12   3372
          16   3368
3379: oEndChoice
3380: oJumpBack 3265
3382: oInput 38
3384: oGetAddrLocal 5
3386: oPushResult
3387: oCall 3206
3389: oPop 1
3391: oGetAddrLocal 6
3393: oPushResult
3394: oGetLocal 2
3396: oPushResult
3397: oNodeVecSize
3398: oPop 1
3400: oAssign
3401: oGetAddrLocal 6
3403: oPushResult
3404: dec
3405: oPop 1
3407: oGetAddrLocal 7
3409: oPushResult
3410: oGetLocal 2
3412: oPushResult
3413: oGetLocal 6
3415: oPushResult
3416: oNodeVecElement
3417: oPop 2
3419: oAssign
3420: oGetLocal 7
3422: oPushResult
3423: oSetResult 34
3425: oPushResult
3426: oGetLocal 5
3428: oPushResult
3429: oNodeSet
3430: oPop 3
3432: oGetAddrLocal 8
3434: oPushResult
3435: oGetLocal 7
3437: oPushResult
3438: oSetResult 35
3440: oPushResult
3441: oNodeGet
3442: oPop 2
3444: oAssign
3445: oGetAddrLocal 9
3447: oPushResult
3448: oGetLocal 8
3450: oPushResult
3451: oSetResult 37
3453: oPushResult
3454: oNodeGetInt
3455: oPop 2
3457: oPushResult
3458: oGetLocal 8
3460: oPushResult
3461: oSetResult 36
3463: oPushResult
3464: oNodeGetInt
3465: oPop 2
3467: oPushResult
3468: subtract
3469: oPop 2
3471: oAssign
3472: oGetAddrLocal 9
3474: oPushResult
3475: inc
3476: oPop 1
3478: oGetLocal 7
3480: oPushResult
3481: oSetResult 17
3483: oPushResult
3484: oGetLocal 9
3486: oPushResult
3487: oGetLocal 5
3489: oPushResult
3490: oSetResult 17
3492: oPushResult
3493: oNodeGetInt
3494: oPop 2
3496: oPushResult
3497: multiply
3498: oPop 2
3500: oPushResult
3501: oNodeSetInt
3502: oPop 3
3504: oGetLocal 7
3506: oPushResult
3507: oTypeAdd
3508: oPop 1
3510: oGetAddrLocal 5
3512: oPushResult
3513: oGetLocal 7
3515: oAssign
3516: oGetLocal 6
3518: oPushResult
3519: equal_zero
3520: oPop 1
3522: oChoice 3528
3524: oJumpForward 3533
3526: oJumpForward 3531
3528: Choice Lookup Table
           1   3524
3531: oJumpBack 3401
3533: oGetParam 1
3535: oPushResult
3536: oGetLocal 2
3538: oPushResult
3539: oSetResult 0
3541: oPushResult
3542: oNodeVecElement
3543: oPop 2
3545: oAssign
3546: oGetLocal 2
3548: oPushResult
3549: oNodeVecDelete
3550: oPop 1
3552: oJumpForward 3922
3554: oGetAddrLocal 10
3556: oPushResult
3557: oCall 3206
3559: oPop 1
3561: oGetParam 1
3563: oPushResult
3564: oGetLocal 10
3566: oPushResult
3567: oCall 8292
3569: oPop 1
3571: oAssign
3572: oJumpForward 3922
3574: oGetParam 1
3576: oPushResult
3577: oSetResult 32
3579: oPushResult
3580: oNodeNew
3581: oPop 1
3583: oAssign
3584: oSetResult -1
3586: oPushResult
3587: oSetResult 2
3589: oPushResult
3590: oScopeBegin
3591: oPop 2
3593: oSetResult 20
3595: oPushResult
3596: oCall 2979
3598: oPop 1
3600: oGetAddrLocal 11
3602: oPushResult
3603: oScopeCurrent
3604: oPushResult
3605: oSetResult 17
3607: oPushResult
3608: oNodeGetInt
3609: oPop 2
3611: oAssign
3612: oGetLocal 11
3614: oPushResult
3615: equal_zero
3616: oPop 1
3618: oChoice 3624
3620: oError 19
3622: oJumpForward 3627
3624: Choice Lookup Table
           1   3620
3627: oInput 34
3629: oGetFromParam 1
3631: oPushResult
3632: oSetResult 38
3634: oPushResult
3635: oScopeCurrent
3636: oPushResult
3637: oNodeSet
3638: oPop 3
3640: oGetFromParam 1
3642: oPushResult
3643: oSetResult 17
3645: oPushResult
3646: oGetLocal 11
3648: oPushResult
3649: oNodeSetInt
3650: oPop 3
3652: oScopeEnd
3653: oGetFromParam 1
3655: oPushResult
3656: oTypeAdd
3657: oPop 1
3659: oJumpForward 3922
3661: oGetParam 1
3663: oPushResult
3664: oSetResult 33
3666: oPushResult
3667: oNodeNew
3668: oPop 1
3670: oAssign
3671: oGetAddrLocal 12
3673: oPushResult
3674: oSetResult 0
3676: oAssign
3677: oGetAddrLocal 13
3679: oPushResult
3680: oSetResult 1
3682: oAssign
3683: oGetAddrLocal 14
3685: oPushResult
3686: oScopeCurrent
3687: oAssign
3688: oSetResult -1
3690: oPushResult
3691: oSetResult 2
3693: oPushResult
3694: oScopeBegin
3695: oPop 2
3697: oInput 0
3699: oGetAddrLocal 15
3701: oPushResult
3702: oSetResult 15
3704: oPushResult
3705: LAST_ID
3706: oPushResult
3707: oCall 8264
3709: oPop 2
3711: oAssign
3712: oGetAddrLocal 16
3714: oPushResult
3715: oSetResult 15
3717: oPushResult
3718: LAST_ID
3719: oPushResult
3720: oCall 8264
3722: oPop 2
3724: oAssign
3725: oGetLocal 15
3727: oPushResult
3728: oSetResult 21
3730: oPushResult
3731: oGetFromParam 1
3733: oPushResult
3734: oNodeSet
3735: oPop 3
3737: oGetLocal 16
3739: oPushResult
3740: oSetResult 21
3742: oPushResult
3743: oGetFromParam 1
3745: oPushResult
3746: oNodeSet
3747: oPop 3
3749: oInputChoice 3787
3751: oCall 3923
3753: oGetLocal 13
3755: oChoice 3776
3757: oValueTop
3758: oPushResult
3759: oGetLocal 12
3761: oPushResult
3762: greater
3763: oPop 2
3765: oChoice 3771
3767: oError 26
3769: oJumpForward 3774
3771: Choice Lookup Table
           0   3767
3774: oJumpForward 3779
3776: Choice Lookup Table
           0   3757
3779: oGetAddrLocal 12
3781: oPushResult
3782: oValueTop
3783: oAssign
3784: oValuePop
3785: oJumpForward 3792
3787: Choice Lookup Table
           3   3751
           5   3751
3792: oGetLocal 15
3794: oPushResult
3795: oSetResult 22
3797: oPushResult
3798: oGetLocal 12
3800: oPushResult
3801: oNodeSetInt
3802: oPop 3
3804: oGetLocal 16
3806: oPushResult
3807: oSetResult 22
3809: oPushResult
3810: oGetLocal 12
3812: oPushResult
3813: oNodeSetInt
3814: oPop 3
3816: oGetLocal 15
3818: oPushResult
3819: oScopeDeclare
3820: oPop 1
3822: oGetLocal 14
3824: oPushResult
3825: oScopeEnter
3826: oPop 1
3828: oGetLocal 16
3830: oPushResult
3831: oScopeDeclare
3832: oPop 1
3834: oScopeEnd
3835: oGetAddrLocal 12
3837: oPushResult
3838: inc
3839: oPop 1
3841: oGetAddrLocal 13
3843: oPushResult
3844: oSetResult 0
3846: oAssign
3847: oInputChoice 3851
3849: oJumpForward 3856
3851: Choice Lookup Table
          12   3849
3854: oJumpForward 3858
3856: oJumpBack 3697
3858: oInput 14
3860: oGetFromParam 1
3862: oPushResult
3863: oSetResult 38
3865: oPushResult
3866: oScopeCurrent
3867: oPushResult
3868: oNodeSet
3869: oPop 3
3871: oGetFromParam 1
3873: oPushResult
3874: oSetResult 17
3876: oPushResult
3877: oSetResult 4
3879: oPushResult
3880: oNodeSetInt
3881: oPop 3
3883: oScopeEnd
3884: oGetFromParam 1
3886: oPushResult
3887: oTypeAdd
3888: oPop 1
3890: oJumpForward 3922
3892: oInput 38
3894: oGetAddrLocal 17
3896: oPushResult
3897: oCall 3206
3899: oPop 1
3901: oJumpForward 3922
3903: Choice Lookup Table
          37   3892
          13   3661
          36   3574
          17   3554
          35   3258
           0   3210
3916: oCall 3923
3918: oInput 20
3920: oCall 3923
3922: oReturn
3923: oLocalSpace 1
3925: oInputChoice 3987
3927: TOKEN_VALUE
3928: oPushResult
3929: oValuePush
3930: oPop 1
3932: oJumpForward 3995
3934: oGetAddrLocal 1
3936: oPushResult
3937: oScopeFindRequire
3938: oAssign
3939: oGetAddrLocal 1
3941: oPushResult
3942: oCall 396
3944: oPop 1
3946: oGetLocal 1
3948: oPushResult
3949: oNodeType
3950: oPop 1
3952: oChoice 3969
3954: oGetLocal 1
3956: oPushResult
3957: oSetResult 22
3959: oPushResult
3960: oNodeGetInt
3961: oPop 2
3963: oPushResult
3964: oValuePush
3965: oPop 1
3967: oJumpForward 3980
3969: Choice Lookup Table
          14   3954
3972: oError 1
3974: oSetResult 0
3976: oPushResult
3977: oValuePush
3978: oPop 1
3980: oJumpForward 3995
3982: oCall 3923
3984: oValueNegate
3985: oJumpForward 3995
3987: Choice Lookup Table
          24   3982
           0   3934
           1   3927
3994: oEndChoice
3995: oReturn
3996: oLocalSpace 1
3998: oGetAddrLocal 1
4000: oPushResult
4001: oSetResult 0
4003: oAssign
4004: oGetAddrLocal 1
4006: oPushResult
4007: oCall 4157
4009: oPop 1
4011: oGetAddrLocal 1
4013: oPushResult
4014: oCall 4057
4016: oPop 1
4018: oReturn
4019: oLocalSpace 0
4021: oGetParam 1
4023: oPushResult
4024: oCall 4157
4026: oPop 1
4028: oTypeSNodeType
4029: oChoice 4048
4031: oJumpForward 4055
4033: oGetParam 1
4035: oPushResult
4036: oLabelNew
4037: oAssign
4038: oEmit 55
4040: oGetFromParam 1
4042: oPushResult
4043: oEmitLabel
4044: oPop 1
4046: oJumpForward 4055
4048: Choice Lookup Table
          25   4033
          26   4031
4053: oError 8
4055: oTypeSPop
4056: oReturn
4057: oLocalSpace 1
4059: oTypeSNodeType
4060: oChoice 4122
4062: oGetAddrLocal 1
4064: oPushResult
4065: oLabelNew
4066: oAssign
4067: oEmit 15
4069: oSetResult 1
4071: oPushResult
4072: oEmitInt
4073: oPop 1
4075: oEmit 53
4077: oGetLocal 1
4079: oPushResult
4080: oEmitLabel
4081: oPop 1
4083: oEmit 56
4085: oGetFromParam 1
4087: oPushResult
4088: oEmitLabel
4089: oPop 1
4091: oEmit 15
4093: oSetResult 0
4095: oPushResult
4096: oEmitInt
4097: oPop 1
4099: oEmit 56
4101: oGetLocal 1
4103: oPushResult
4104: oEmitLabel
4105: oPop 1
4107: oTypeSPop
4108: oGetGlobal 5
4110: oPushResult
4111: oTypeSPush
4112: oPop 1
4114: oGetParam 1
4116: oPushResult
4117: oSetResult 0
4119: oAssign
4120: oJumpForward 4125
4122: Choice Lookup Table
          26   4062
4125: oReturn
4126: oLocalSpace 0
4128: oTypeSNodeType
4129: oChoice 4153
4131: oGetParam 1
4133: oPushResult
4134: oLabelNew
4135: oAssign
4136: oEmit 55
4138: oGetFromParam 1
4140: oPushResult
4141: oEmitLabel
4142: oPop 1
4144: oTypeSPop
4145: oGetGlobal 6
4147: oPushResult
4148: oTypeSPush
4149: oPop 1
4151: oJumpForward 4156
4153: Choice Lookup Table
          25   4131
4156: oReturn
4157: oLocalSpace 0
4159: oGetParam 1
4161: oPushResult
4162: oCall 4534
4164: oPop 1
4166: oInputChoice 4516
4168: oGetParam 1
4170: oPushResult
4171: oCall 4057
4173: oPop 1
4175: oGetParam 1
4177: oPushResult
4178: oCall 4534
4180: oPop 1
4182: oGetParam 1
4184: oPushResult
4185: oCall 4057
4187: oPop 1
4189: oCall 8150
4191: oTypeSNodeType
4192: oChoice 4206
4194: oEmit 38
4196: oJumpForward 4221
4198: oEmit 44
4200: oJumpForward 4221
4202: oError 16
4204: oJumpForward 4221
4206: Choice Lookup Table
          28   4202
          27   4202
          29   4198
          25   4194
          33   4194
          24   4194
4219: oError 17
4221: oTypeSPop
4222: oGetGlobal 5
4224: oPushResult
4225: oTypeSPush
4226: oPop 1
4228: oJumpForward 4531
4230: oGetParam 1
4232: oPushResult
4233: oCall 4057
4235: oPop 1
4237: oGetParam 1
4239: oPushResult
4240: oCall 4534
4242: oPop 1
4244: oGetParam 1
4246: oPushResult
4247: oCall 4057
4249: oPop 1
4251: oCall 8150
4253: oTypeSNodeType
4254: oChoice 4268
4256: oEmit 39
4258: oJumpForward 4283
4260: oEmit 45
4262: oJumpForward 4283
4264: oError 16
4266: oJumpForward 4283
4268: Choice Lookup Table
          28   4264
          27   4264
          29   4260
          25   4256
          33   4256
          24   4256
4281: oError 17
4283: oTypeSPop
4284: oGetGlobal 5
4286: oPushResult
4287: oTypeSPush
4288: oPop 1
4290: oJumpForward 4531
4292: oGetParam 1
4294: oPushResult
4295: oCall 4057
4297: oPop 1
4299: oGetParam 1
4301: oPushResult
4302: oCall 4534
4304: oPop 1
4306: oGetParam 1
4308: oPushResult
4309: oCall 4057
4311: oPop 1
4313: oCall 8150
4315: oTypeSNodeType
4316: oChoice 4326
4318: oEmit 41
4320: oJumpForward 4339
4322: oError 16
4324: oJumpForward 4339
4326: Choice Lookup Table
          28   4322
          27   4322
          25   4318
          33   4318
          24   4318
4337: oError 17
4339: oTypeSPop
4340: oGetGlobal 5
4342: oPushResult
4343: oTypeSPush
4344: oPop 1
4346: oJumpForward 4531
4348: oGetParam 1
4350: oPushResult
4351: oCall 4057
4353: oPop 1
4355: oGetParam 1
4357: oPushResult
4358: oCall 4534
4360: oPop 1
4362: oGetParam 1
4364: oPushResult
4365: oCall 4057
4367: oPop 1
4369: oCall 8150
4371: oTypeSNodeType
4372: oChoice 4382
4374: oEmit 40
4376: oJumpForward 4395
4378: oError 16
4380: oJumpForward 4395
4382: Choice Lookup Table
          28   4378
          27   4378
          25   4374
          33   4374
          24   4374
4393: oError 17
4395: oTypeSPop
4396: oGetGlobal 5
4398: oPushResult
4399: oTypeSPush
4400: oPop 1
4402: oJumpForward 4531
4404: oGetParam 1
4406: oPushResult
4407: oCall 4057
4409: oPop 1
4411: oGetParam 1
4413: oPushResult
4414: oCall 4534
4416: oPop 1
4418: oGetParam 1
4420: oPushResult
4421: oCall 4057
4423: oPop 1
4425: oCall 8150
4427: oTypeSNodeType
4428: oChoice 4438
4430: oEmit 43
4432: oJumpForward 4451
4434: oError 16
4436: oJumpForward 4451
4438: Choice Lookup Table
          28   4434
          27   4434
          25   4430
          33   4430
          24   4430
4449: oError 17
4451: oTypeSPop
4452: oGetGlobal 5
4454: oPushResult
4455: oTypeSPush
4456: oPop 1
4458: oJumpForward 4531
4460: oGetParam 1
4462: oPushResult
4463: oCall 4057
4465: oPop 1
4467: oGetParam 1
4469: oPushResult
4470: oCall 4534
4472: oPop 1
4474: oGetParam 1
4476: oPushResult
4477: oCall 4057
4479: oPop 1
4481: oCall 8150
4483: oTypeSNodeType
4484: oChoice 4494
4486: oEmit 42
4488: oJumpForward 4507
4490: oError 16
4492: oJumpForward 4507
4494: Choice Lookup Table
          28   4490
          27   4490
          25   4486
          33   4486
          24   4486
4505: oError 17
4507: oTypeSPop
4508: oGetGlobal 5
4510: oPushResult
4511: oTypeSPush
4512: oPop 1
4514: oJumpForward 4531
4516: Choice Lookup Table
          10   4460
           9   4404
           8   4348
           7   4292
           6   4230
           5   4168
4529: oJumpForward 4533
4531: oJumpBack 4166
4533: oReturn
4534: oLocalSpace 1
4536: oGetAddrLocal 1
4538: oPushResult
4539: oSetResult 0
4541: oAssign
4542: oGetParam 1
4544: oPushResult
4545: oCall 4714
4547: oPop 1
4549: oInputChoice 4682
4551: oTypeSNodeType
4552: oChoice 4623
4554: oGetLocal 1
4556: oPushResult
4557: oSetResult 0
4559: oPushResult
4560: equal_label
4561: oPop 2
4563: oChoice 4572
4565: oGetAddrLocal 1
4567: oPushResult
4568: oLabelNew
4569: oAssign
4570: oJumpForward 4575
4572: Choice Lookup Table
           1   4565
4575: oEmit 53
4577: oGetLocal 1
4579: oPushResult
4580: oEmitLabel
4581: oPop 1
4583: oJumpForward 4630
4585: oGetParam 1
4587: oPushResult
4588: oCall 4126
4590: oPop 1
4592: oGetLocal 1
4594: oPushResult
4595: oSetResult 0
4597: oPushResult
4598: equal_label
4599: oPop 2
4601: oChoice 4610
4603: oGetAddrLocal 1
4605: oPushResult
4606: oLabelNew
4607: oAssign
4608: oJumpForward 4613
4610: Choice Lookup Table
           1   4603
4613: oEmit 53
4615: oGetLocal 1
4617: oPushResult
4618: oEmitLabel
4619: oPop 1
4621: oJumpForward 4630
4623: Choice Lookup Table
          25   4585
          26   4554
4628: oError 8
4630: oTypeSPop
4631: oEmit 56
4633: oGetFromParam 1
4635: oPushResult
4636: oEmitLabel
4637: oPop 1
4639: oGetParam 1
4641: oPushResult
4642: oSetResult 0
4644: oAssign
4645: oGetParam 1
4647: oPushResult
4648: oCall 4714
4650: oPop 1
4652: oTypeSNodeType
4653: oChoice 4666
4655: oJumpForward 4673
4657: oGetParam 1
4659: oPushResult
4660: oCall 4126
4662: oPop 1
4664: oJumpForward 4673
4666: Choice Lookup Table
          25   4657
          26   4655
4671: oError 8
4673: oTypeSPop
4674: oGetGlobal 6
4676: oPushResult
4677: oTypeSPush
4678: oPop 1
4680: oJumpForward 4687
4682: Choice Lookup Table
          52   4551
4685: oJumpForward 4689
4687: oJumpBack 4549
4689: oGetLocal 1
4691: oPushResult
4692: oSetResult 0
4694: oPushResult
4695: equal_label
4696: oPop 2
4698: oChoice 4710
4700: oEmit 56
4702: oGetLocal 1
4704: oPushResult
4705: oEmitLabel
4706: oPop 1
4708: oJumpForward 4713
4710: Choice Lookup Table
           0   4700
4713: oReturn
4714: oLocalSpace 2
4716: oGetAddrLocal 1
4718: oPushResult
4719: oSetResult 0
4721: oAssign
4722: oGetParam 1
4724: oPushResult
4725: oCall 4852
4727: oPop 1
4729: oInputChoice 4844
4731: oTypeSNodeType
4732: oChoice 4745
4734: oJumpForward 4752
4736: oGetParam 1
4738: oPushResult
4739: oCall 4126
4741: oPop 1
4743: oJumpForward 4752
4745: Choice Lookup Table
          25   4736
          26   4734
4750: oError 8
4752: oTypeSPop
4753: oGetLocal 1
4755: oPushResult
4756: oSetResult 0
4758: oPushResult
4759: equal_label
4760: oPop 2
4762: oChoice 4791
4764: oGetAddrLocal 1
4766: oPushResult
4767: oLabelNew
4768: oAssign
4769: oEmit 57
4771: oGetFromParam 1
4773: oPushResult
4774: oEmitLabel
4775: oPop 1
4777: oGetLocal 1
4779: oPushResult
4780: oEmitLabel
4781: oPop 1
4783: oGetParam 1
4785: oPushResult
4786: oGetLocal 1
4788: oAssign
4789: oJumpForward 4794
4791: Choice Lookup Table
           1   4764
4794: oGetAddrLocal 2
4796: oPushResult
4797: oSetResult 0
4799: oAssign
4800: oGetAddrLocal 2
4802: oPushResult
4803: oCall 4852
4805: oPop 1
4807: oTypeSNodeType
4808: oChoice 4821
4810: oJumpForward 4828
4812: oGetAddrLocal 2
4814: oPushResult
4815: oCall 4126
4817: oPop 1
4819: oJumpForward 4828
4821: Choice Lookup Table
          25   4812
          26   4810
4826: oError 8
4828: oEmit 57
4830: oGetLocal 2
4832: oPushResult
4833: oEmitLabel
4834: oPop 1
4836: oGetLocal 1
4838: oPushResult
4839: oEmitLabel
4840: oPop 1
4842: oJumpForward 4849
4844: Choice Lookup Table
          51   4731
4847: oJumpForward 4851
4849: oJumpBack 4729
4851: oReturn
4852: oLocalSpace 1
4854: oInputChoice 4908
4856: oGetAddrLocal 1
4858: oPushResult
4859: oSetResult 0
4861: oAssign
4862: oGetAddrLocal 1
4864: oPushResult
4865: oCall 4852
4867: oPop 1
4869: oTypeSNodeType
4870: oChoice 4899
4872: oGetParam 1
4874: oPushResult
4875: oLabelNew
4876: oAssign
4877: oEmit 53
4879: oGetFromParam 1
4881: oPushResult
4882: oEmitLabel
4883: oPop 1
4885: oEmit 56
4887: oGetLocal 1
4889: oPushResult
4890: oEmitLabel
4891: oPop 1
4893: oJumpForward 4906
4895: oEmit 37
4897: oJumpForward 4906
4899: Choice Lookup Table
          25   4895
          26   4872
4904: oError 8
4906: oJumpForward 4918
4908: Choice Lookup Table
          53   4856
4911: oGetParam 1
4913: oPushResult
4914: oCall 4919
4916: oPop 1
4918: oReturn
4919: oLocalSpace 0
4921: oGetParam 1
4923: oPushResult
4924: oCall 4970
4926: oPop 1
4928: oInputChoice 4960
4930: oCall 8176
4932: oGetParam 1
4934: oPushResult
4935: oCall 4970
4937: oPop 1
4939: oCall 8190
4941: oEmit 34
4943: oJumpForward 4967
4945: oCall 8176
4947: oGetParam 1
4949: oPushResult
4950: oCall 4970
4952: oPop 1
4954: oCall 8190
4956: oEmit 35
4958: oJumpForward 4967
4960: Choice Lookup Table
          24   4945
          23   4930
4965: oJumpForward 4969
4967: oJumpBack 4928
4969: oReturn
4970: oLocalSpace 0
4972: oGetParam 1
4974: oPushResult
4975: oCall 5021
4977: oPop 1
4979: oInputChoice 5011
4981: oCall 8176
4983: oGetParam 1
4985: oPushResult
4986: oCall 5021
4988: oPop 1
4990: oCall 8190
4992: oEmit 31
4994: oJumpForward 5018
4996: oCall 8176
4998: oGetParam 1
5000: oPushResult
5001: oCall 5021
5003: oPop 1
5005: oCall 8190
5007: oEmit 32
5009: oJumpForward 5018
5011: Choice Lookup Table
          22   4996
          21   4981
5016: oJumpForward 5020
5018: oJumpBack 4979
5020: oReturn
5021: oLocalSpace 0
5023: oInputChoice 5049
5025: oGetParam 1
5027: oPushResult
5028: oCall 5062
5030: oPop 1
5032: oCall 8190
5034: oJumpForward 5061
5036: oGetParam 1
5038: oPushResult
5039: oCall 5062
5041: oPop 1
5043: oCall 8190
5045: oEmit 36
5047: oJumpForward 5061
5049: Choice Lookup Table
          24   5036
          23   5025
5054: oGetParam 1
5056: oPushResult
5057: oCall 5062
5059: oPop 1
5061: oReturn
5062: oLocalSpace 6
5064: oInputChoice 5268
5066: oEmit 15
5068: TOKEN_VALUE
5069: oPushResult
5070: oEmitInt
5071: oPop 1
5073: oGetGlobal 4
5075: oPushResult
5076: oTypeSPush
5077: oPop 1
5079: oJumpForward 5287
5081: oGetParam 1
5083: oPushResult
5084: oCall 4157
5086: oPop 1
5088: oInput 14
5090: oJumpForward 5287
5092: oGetAddrLocal 1
5094: oPushResult
5095: CURRENT_STRLIT
5096: oPushResult
5097: oStringAllocLit
5098: oPop 1
5100: oAssign
5101: oEmit 16
5103: oGetLocal 1
5105: oPushResult
5106: oEmitInt
5107: oPop 1
5109: oGetGlobal 8
5111: oPushResult
5112: oTypeSPush
5113: oPop 1
5115: oJumpForward 5287
5117: oGetAddrLocal 2
5119: oPushResult
5120: oScopeFindRequire
5121: oAssign
5122: oGetAddrLocal 2
5124: oPushResult
5125: oCall 396
5127: oPop 1
5129: oGetLocal 2
5131: oPushResult
5132: oNodeType
5133: oPop 1
5135: oChoice 5199
5137: oGetLocal 2
5139: oPushResult
5140: oCall 6444
5142: oPop 1
5144: oJumpForward 5220
5146: oGetAddrLocal 3
5148: oPushResult
5149: oGetLocal 2
5151: oPushResult
5152: oSetResult 21
5154: oPushResult
5155: oNodeGet
5156: oPop 2
5158: oAssign
5159: oGetLocal 3
5161: oPushResult
5162: oTypeSPush
5163: oPop 1
5165: oTypeSNodeType
5166: oChoice 5179
5168: oEmit 15
5170: oGetLocal 2
5172: oPushResult
5173: oCall 8471
5175: oPop 1
5177: oJumpForward 5188
5179: Choice Lookup Table
          25   5168
          33   5168
          24   5168
5186: oError 16
5188: oJumpForward 5220
5190: oGetLocal 2
5192: oPushResult
5193: oCall 5288
5195: oPop 1
5197: oJumpForward 5220
5199: Choice Lookup Table
          21   5190
          19   5190
          18   5190
          15   5146
          14   5146
          13   5137
5212: oError 6
5214: oGetGlobal 4
5216: oPushResult
5217: oTypeSPush
5218: oPop 1
5220: oJumpForward 5287
5222: oInput 0
5224: oGetAddrLocal 4
5226: oPushResult
5227: oScopeFindRequire
5228: oAssign
5229: oGetAddrLocal 4
5231: oPushResult
5232: oCall 396
5234: oPop 1
5236: oGetLocal 4
5238: oPushResult
5239: oCall 7413
5241: oPop 1
5243: oGetAddrLocal 5
5245: oPushResult
5246: oTypeSTop
5247: oAssign
5248: oTypeSPop
5249: oGetAddrLocal 6
5251: oPushResult
5252: oGetLocal 5
5254: oPushResult
5255: oCall 8292
5257: oPop 1
5259: oAssign
5260: oGetLocal 6
5262: oPushResult
5263: oTypeSPush
5264: oPop 1
5266: oJumpForward 5287
5268: Choice Lookup Table
          18   5222
           0   5117
           2   5092
          13   5081
           1   5066
5279: oError 6
5281: oGetGlobal 4
5283: oPushResult
5284: oTypeSPush
5285: oPop 1
5287: oReturn
5288: oLocalSpace 2
5290: oGetAddrLocal 1
5292: oPushResult
5293: oGetParam 1
5295: oPushResult
5296: oSetResult 21
5298: oPushResult
5299: oNodeGet
5300: oPop 2
5302: oAssign
5303: oGetAddrLocal 2
5305: oPushResult
5306: oGetParam 1
5308: oPushResult
5309: oCall 8132
5311: oPop 1
5313: oAssign
5314: oGetLocal 1
5316: oPushResult
5317: oTypeSPush
5318: oPop 1
5320: oTypeSNodeType
5321: oChoice 5838
5323: oGetParam 1
5325: oPushResult
5326: oNodeType
5327: oPop 1
5329: oChoice 5475
5331: oEmit 0
5333: oGetParam 1
5335: oPushResult
5336: oCall 8471
5338: oPop 1
5340: oJumpForward 5483
5342: oGetLocal 2
5344: oPushResult
5345: equal_zero
5346: oPop 1
5348: oChoice 5361
5350: oEmit 3
5352: oGetParam 1
5354: oPushResult
5355: oCall 8471
5357: oPop 1
5359: oJumpForward 5379
5361: Choice Lookup Table
           1   5350
5364: oEmit 9
5366: oGetLocal 2
5368: oPushResult
5369: oEmitInt
5370: oPop 1
5372: oGetParam 1
5374: oPushResult
5375: oCall 8471
5377: oPop 1
5379: oJumpForward 5483
5381: oGetParam 1
5383: oPushResult
5384: oSetResult 32
5386: oPushResult
5387: oNodeGetBoolean
5388: oPop 2
5390: oChoice 5433
5392: oGetLocal 2
5394: oPushResult
5395: equal_zero
5396: oPop 1
5398: oChoice 5411
5400: oEmit 8
5402: oGetParam 1
5404: oPushResult
5405: oCall 8471
5407: oPop 1
5409: oJumpForward 5429
5411: Choice Lookup Table
           1   5400
5414: oEmit 14
5416: oGetLocal 2
5418: oPushResult
5419: oEmitInt
5420: oPop 1
5422: oGetParam 1
5424: oPushResult
5425: oCall 8471
5427: oPop 1
5429: oEmit 22
5431: oJumpForward 5473
5433: Choice Lookup Table
           1   5392
5436: oGetLocal 2
5438: oPushResult
5439: equal_zero
5440: oPop 1
5442: oChoice 5455
5444: oEmit 6
5446: oGetParam 1
5448: oPushResult
5449: oCall 8471
5451: oPop 1
5453: oJumpForward 5473
5455: Choice Lookup Table
           1   5444
5458: oEmit 12
5460: oGetLocal 2
5462: oPushResult
5463: oEmitInt
5464: oPop 1
5466: oGetParam 1
5468: oPushResult
5469: oCall 8471
5471: oPop 1
5473: oJumpForward 5483
5475: Choice Lookup Table
          21   5381
          19   5342
          18   5331
5482: oEndChoice
5483: oJumpForward 6015
5485: oGetParam 1
5487: oPushResult
5488: oNodeType
5489: oPop 1
5491: oChoice 5637
5493: oEmit 1
5495: oGetParam 1
5497: oPushResult
5498: oCall 8471
5500: oPop 1
5502: oJumpForward 5645
5504: oGetLocal 2
5506: oPushResult
5507: equal_zero
5508: oPop 1
5510: oChoice 5523
5512: oEmit 4
5514: oGetParam 1
5516: oPushResult
5517: oCall 8471
5519: oPop 1
5521: oJumpForward 5541
5523: Choice Lookup Table
           1   5512
5526: oEmit 10
5528: oGetLocal 2
5530: oPushResult
5531: oEmitInt
5532: oPop 1
5534: oGetParam 1
5536: oPushResult
5537: oCall 8471
5539: oPop 1
5541: oJumpForward 5645
5543: oGetParam 1
5545: oPushResult
5546: oSetResult 32
5548: oPushResult
5549: oNodeGetBoolean
5550: oPop 2
5552: oChoice 5595
5554: oGetLocal 2
5556: oPushResult
5557: equal_zero
5558: oPop 1
5560: oChoice 5573
5562: oEmit 8
5564: oGetParam 1
5566: oPushResult
5567: oCall 8471
5569: oPop 1
5571: oJumpForward 5591
5573: Choice Lookup Table
           1   5562
5576: oEmit 14
5578: oGetLocal 2
5580: oPushResult
5581: oEmitInt
5582: oPop 1
5584: oGetParam 1
5586: oPushResult
5587: oCall 8471
5589: oPop 1
5591: oEmit 23
5593: oJumpForward 5635
5595: Choice Lookup Table
           1   5554
5598: oGetLocal 2
5600: oPushResult
5601: equal_zero
5602: oPop 1
5604: oChoice 5617
5606: oEmit 7
5608: oGetParam 1
5610: oPushResult
5611: oCall 8471
5613: oPop 1
5615: oJumpForward 5635
5617: Choice Lookup Table
           1   5606
5620: oEmit 13
5622: oGetLocal 2
5624: oPushResult
5625: oEmitInt
5626: oPop 1
5628: oGetParam 1
5630: oPushResult
5631: oCall 8471
5633: oPop 1
5635: oJumpForward 5645
5637: Choice Lookup Table
          21   5543
          19   5504
          18   5493
5644: oEndChoice
5645: oJumpForward 6015
5647: oError 16
5649: oJumpForward 6015
5651: oGetParam 1
5653: oPushResult
5654: oNodeType
5655: oPop 1
5657: oChoice 5803
5659: oEmit 2
5661: oGetParam 1
5663: oPushResult
5664: oCall 8471
5666: oPop 1
5668: oJumpForward 5811
5670: oGetLocal 2
5672: oPushResult
5673: equal_zero
5674: oPop 1
5676: oChoice 5689
5678: oEmit 5
5680: oGetParam 1
5682: oPushResult
5683: oCall 8471
5685: oPop 1
5687: oJumpForward 5707
5689: Choice Lookup Table
           1   5678
5692: oEmit 11
5694: oGetLocal 2
5696: oPushResult
5697: oEmitInt
5698: oPop 1
5700: oGetParam 1
5702: oPushResult
5703: oCall 8471
5705: oPop 1
5707: oJumpForward 5811
5709: oGetParam 1
5711: oPushResult
5712: oSetResult 32
5714: oPushResult
5715: oNodeGetBoolean
5716: oPop 2
5718: oChoice 5761
5720: oGetLocal 2
5722: oPushResult
5723: equal_zero
5724: oPop 1
5726: oChoice 5739
5728: oEmit 8
5730: oGetParam 1
5732: oPushResult
5733: oCall 8471
5735: oPop 1
5737: oJumpForward 5757
5739: Choice Lookup Table
           1   5728
5742: oEmit 14
5744: oGetLocal 2
5746: oPushResult
5747: oEmitInt
5748: oPop 1
5750: oGetParam 1
5752: oPushResult
5753: oCall 8471
5755: oPop 1
5757: oEmit 24
5759: oJumpForward 5801
5761: Choice Lookup Table
           1   5720
5764: oGetLocal 2
5766: oPushResult
5767: equal_zero
5768: oPop 1
5770: oChoice 5783
5772: oEmit 8
5774: oGetParam 1
5776: oPushResult
5777: oCall 8471
5779: oPop 1
5781: oJumpForward 5801
5783: Choice Lookup Table
           1   5772
5786: oEmit 14
5788: oGetLocal 2
5790: oPushResult
5791: oEmitInt
5792: oPop 1
5794: oGetParam 1
5796: oPushResult
5797: oCall 8471
5799: oPop 1
5801: oJumpForward 5811
5803: Choice Lookup Table
          21   5709
          19   5670
          18   5659
5810: oEndChoice
5811: oInputChoice 5833
5813: oTypeSPop
5814: oGetLocal 1
5816: oPushResult
5817: oSetResult 34
5819: oPushResult
5820: oNodeGet
5821: oPop 2
5823: oPushResult
5824: oTypeSPush
5825: oPop 1
5827: oCall 6053
5829: oCall 6016
5831: oJumpForward 5836
5833: Choice Lookup Table
          17   5813
5836: oJumpForward 6015
5838: Choice Lookup Table
          29   5651
          23   5647
          28   5647
          27   5647
          25   5485
          33   5323
          24   5323
5853: oGetParam 1
5855: oPushResult
5856: oNodeType
5857: oPop 1
5859: oChoice 6003
5861: oEmit 16
5863: oGetParam 1
5865: oPushResult
5866: oCall 8471
5868: oPop 1
5870: oJumpForward 6011
5872: oGetLocal 2
5874: oPushResult
5875: equal_zero
5876: oPop 1
5878: oChoice 5891
5880: oEmit 17
5882: oGetParam 1
5884: oPushResult
5885: oCall 8471
5887: oPop 1
5889: oJumpForward 5909
5891: Choice Lookup Table
           1   5880
5894: oEmit 20
5896: oGetLocal 2
5898: oPushResult
5899: oEmitInt
5900: oPop 1
5902: oGetParam 1
5904: oPushResult
5905: oCall 8471
5907: oPop 1
5909: oJumpForward 6011
5911: oGetParam 1
5913: oPushResult
5914: oSetResult 32
5916: oPushResult
5917: oNodeGetBoolean
5918: oPop 2
5920: oChoice 5961
5922: oGetLocal 2
5924: oPushResult
5925: equal_zero
5926: oPop 1
5928: oChoice 5941
5930: oEmit 8
5932: oGetParam 1
5934: oPushResult
5935: oCall 8471
5937: oPop 1
5939: oJumpForward 5959
5941: Choice Lookup Table
           1   5930
5944: oEmit 14
5946: oGetLocal 2
5948: oPushResult
5949: oEmitInt
5950: oPop 1
5952: oGetParam 1
5954: oPushResult
5955: oCall 8471
5957: oPop 1
5959: oJumpForward 6001
5961: Choice Lookup Table
           1   5922
5964: oGetLocal 2
5966: oPushResult
5967: equal_zero
5968: oPop 1
5970: oChoice 5983
5972: oEmit 18
5974: oGetParam 1
5976: oPushResult
5977: oCall 8471
5979: oPop 1
5981: oJumpForward 6001
5983: Choice Lookup Table
           1   5972
5986: oEmit 21
5988: oGetLocal 2
5990: oPushResult
5991: oEmitInt
5992: oPop 1
5994: oGetParam 1
5996: oPushResult
5997: oCall 8471
5999: oPop 1
6001: oJumpForward 6011
6003: Choice Lookup Table
          21   5911
          19   5872
          18   5861
6010: oEndChoice
6011: oCall 6053
6013: oCall 6016
6015: oReturn
6016: oLocalSpace 0
6018: oTypeSNodeType
6019: oChoice 6037
6021: oEmit 22
6023: oJumpForward 6052
6025: oEmit 23
6027: oJumpForward 6052
6029: oError 16
6031: oJumpForward 6052
6033: oEmit 24
6035: oJumpForward 6052
6037: Choice Lookup Table
          29   6033
          23   6029
          28   6029
          27   6029
          25   6025
          33   6021
          24   6021
6052: oReturn
6053: oLocalSpace 0
6055: oInputChoice 6069
6057: oCall 6081
6059: oJumpForward 6078
6061: oCall 6224
6063: oJumpForward 6078
6065: oCall 6322
6067: oJumpForward 6078
6069: Choice Lookup Table
          17   6065
          19   6061
          15   6057
6076: oJumpForward 6080
6078: oJumpBack 6055
6080: oReturn
6081: oLocalSpace 3
6083: oTypeSNodeType
6084: oChoice 6088
6086: oJumpForward 6093
6088: Choice Lookup Table
          30   6086
6091: oError 10
6093: oTypeSNodeType
6094: oChoice 6098
6096: oJumpForward 6103
6098: Choice Lookup Table
          30   6096
6101: oError 13
6103: oGetAddrLocal 1
6105: oPushResult
6106: oTypeSTop
6107: oPushResult
6108: oSetResult 35
6110: oPushResult
6111: oNodeGet
6112: oPop 2
6114: oPushResult
6115: oCall 8376
6117: oPop 1
6119: oAssign
6120: oGetAddrLocal 2
6122: oPushResult
6123: oTypeSTop
6124: oPushResult
6125: oSetResult 34
6127: oPushResult
6128: oNodeGet
6129: oPop 2
6131: oAssign
6132: oTypeSPop
6133: oGetLocal 2
6135: oPushResult
6136: oTypeSPush
6137: oPop 1
6139: oCall 3996
6141: oCall 8176
6143: oGetLocal 1
6145: oPushResult
6146: equal_zero
6147: oPop 1
6149: oChoice 6163
6151: oEmit 15
6153: oGetLocal 1
6155: oPushResult
6156: oEmitInt
6157: oPop 1
6159: oEmit 35
6161: oJumpForward 6166
6163: Choice Lookup Table
           0   6151
6166: oGetAddrLocal 3
6168: oPushResult
6169: oGetLocal 2
6171: oPushResult
6172: oSetResult 17
6174: oPushResult
6175: oNodeGetInt
6176: oPop 2
6178: oAssign
6179: oGetLocal 3
6181: oPushResult
6182: oSetResult 1
6184: oPushResult
6185: equal
6186: oPop 2
6188: oChoice 6202
6190: oEmit 15
6192: oGetLocal 3
6194: oPushResult
6195: oEmitInt
6196: oPop 1
6198: oEmit 31
6200: oJumpForward 6205
6202: Choice Lookup Table
           0   6190
6205: oEmit 33
6207: oInputChoice 6215
6209: oJumpForward 6223
6211: oJumpForward 6221
6213: oJumpForward 6221
6215: Choice Lookup Table
          12   6213
          16   6209
6220: oEndChoice
6221: oJumpBack 6093
6223: oReturn
6224: oLocalSpace 2
6226: oTypeSNodeType
6227: oChoice 6231
6229: oJumpForward 6236
6231: Choice Lookup Table
          32   6229
6234: oError 11
6236: oTypeSTop
6237: oPushResult
6238: oSetResult 38
6240: oPushResult
6241: oNodeGet
6242: oPop 2
6244: oPushResult
6245: oScopeEnter
6246: oPop 1
6248: oInput 0
6250: oGetAddrLocal 1
6252: oPushResult
6253: oScopeFindRequire
6254: oAssign
6255: oGetLocal 1
6257: oPushResult
6258: oNodeType
6259: oPop 1
6261: oChoice 6265
6263: oJumpForward 6270
6265: Choice Lookup Table
          20   6263
6268: oError 12
6270: oScopeEnd
6271: oGetAddrLocal 2
6273: oPushResult
6274: oGetLocal 1
6276: oPushResult
6277: oSetResult 22
6279: oPushResult
6280: oNodeGetInt
6281: oPop 2
6283: oAssign
6284: oGetLocal 2
6286: oPushResult
6287: equal_zero
6288: oPop 1
6290: oChoice 6304
6292: oEmit 15
6294: oGetLocal 2
6296: oPushResult
6297: oEmitInt
6298: oPop 1
6300: oEmit 33
6302: oJumpForward 6307
6304: Choice Lookup Table
           0   6292
6307: oTypeSPop
6308: oGetLocal 1
6310: oPushResult
6311: oSetResult 21
6313: oPushResult
6314: oNodeGet
6315: oPop 2
6317: oPushResult
6318: oTypeSPush
6319: oPop 1
6321: oReturn
6322: oLocalSpace 1
6324: oTypeSNodeType
6325: oChoice 6329
6327: oJumpForward 6334
6329: Choice Lookup Table
          29   6327
6332: oError 9
6334: oEmit 24
6336: oGetAddrLocal 1
6338: oPushResult
6339: oTypeSTop
6340: oAssign
6341: oTypeSPop
6342: oGetLocal 1
6344: oPushResult
6345: oSetResult 34
6347: oPushResult
6348: oNodeGet
6349: oPop 2
6351: oPushResult
6352: oTypeSPush
6353: oPop 1
6355: oReturn
6356: oLocalSpace 0
6358: oCall 8150
6360: oReturn
6361: oLocalSpace 2
6363: oGetAddrLocal 2
6365: oPushResult
6366: oGetParam 1
6368: oPushResult
6369: oSetResult 26
6371: oPushResult
6372: oNodeGetString
6373: oPop 2
6375: oAssign
6376: oGetLocal 2
6378: oPushResult
6379: oSetResult 0
6381: oPushResult
6382: equal_string
6383: oPop 2
6385: oChoice 6422
6387: oGetAddrLocal 1
6389: oPushResult
6390: oGetParam 1
6392: oPushResult
6393: oSetResult 4
6395: oPushResult
6396: oNodeGetInt
6397: oPop 2
6399: oPushResult
6400: ID_STRING
6401: oPop 1
6403: oPushResult
6404: oStringAllocLit
6405: oPop 1
6407: oAssign
6408: oJumpForward 6428
6410: oGetAddrLocal 1
6412: oPushResult
6413: oGetLocal 2
6415: oPushResult
6416: oStringAllocLit
6417: oPop 1
6419: oAssign
6420: oJumpForward 6428
6422: Choice Lookup Table
           0   6410
           1   6387
6427: oEndChoice
6428: oEmit 58
6430: oGetParam 1
6432: oPushResult
6433: oCall 8471
6435: oPop 1
6437: oGetLocal 1
6439: oPushResult
6440: oEmitInt
6441: oPop 1
6443: oReturn
6444: oLocalSpace 10
6446: oGetParam 1
6448: oPushResult
6449: oSetResult 25
6451: oPushResult
6452: oNodeGetBoolean
6453: oPop 2
6455: oChoice 6482
6457: oGetParam 1
6459: oPushResult
6460: oSetResult 28
6462: oPushResult
6463: oNodeGetBoolean
6464: oPop 2
6466: oChoice 6477
6468: oGetParam 1
6470: oPushResult
6471: oCall 6361
6473: oPop 1
6475: oJumpForward 6480
6477: Choice Lookup Table
           0   6468
6480: oJumpForward 6485
6482: Choice Lookup Table
           1   6457
6485: oGetParam 1
6487: oPushResult
6488: oSetResult 28
6490: oPushResult
6491: oSetResult 1
6493: oPushResult
6494: oNodeSetBoolean
6495: oPop 3
6497: oGetAddrLocal 1
6499: oPushResult
6500: oGetParam 1
6502: oPushResult
6503: oSetResult 27
6505: oPushResult
6506: oNodeGetBoolean
6507: oPop 2
6509: oAssign
6510: oGetAddrLocal 4
6512: oPushResult
6513: oGetParam 1
6515: oPushResult
6516: oNodeType
6517: oPop 1
6519: oPushResult
6520: oSetResult 13
6522: oPushResult
6523: equal_node_type
6524: oPop 2
6526: oAssign
6527: oGetLocal 4
6529: oChoice 6556
6531: oGetAddrLocal 2
6533: oPushResult
6534: oGetParam 1
6536: oPushResult
6537: oSetResult 21
6539: oPushResult
6540: oNodeGet
6541: oPop 2
6543: oAssign
6544: oGetAddrLocal 3
6546: oPushResult
6547: oGetLocal 2
6549: oPushResult
6550: oScopeAllocType
6551: oPop 1
6553: oAssign
6554: oJumpForward 6559
6556: Choice Lookup Table
           1   6531
6559: oGetAddrLocal 5
6561: oPushResult
6562: oGetParam 1
6564: oPushResult
6565: oSetResult 23
6567: oPushResult
6568: oNodeGet
6569: oPop 2
6571: oAssign
6572: oGetAddrLocal 6
6574: oPushResult
6575: oGetLocal 5
6577: oPushResult
6578: oSetResult 17
6580: oPushResult
6581: oNodeGetInt
6582: oPop 2
6584: oAssign
6585: oGetLocal 1
6587: oChoice 6609
6589: oEmit 47
6591: oGetLocal 6
6593: oPushResult
6594: oEmitInt
6595: oPop 1
6597: oJumpForward 6615
6599: oEmit 46
6601: oGetLocal 6
6603: oPushResult
6604: oEmitInt
6605: oPop 1
6607: oJumpForward 6615
6609: Choice Lookup Table
           0   6599
           1   6589
6614: oEndChoice
6615: oGetParam 1
6617: oPushResult
6618: oCall 8112
6620: oPop 1
6622: oPushResult
6623: oSetResult 0
6625: oPushResult
6626: greater
6627: oPop 2
6629: oChoice 6662
6631: oEmit 19
6633: oSetResult 0
6635: oPushResult
6636: oEmitInt
6637: oPop 1
6639: oEmit 20
6641: oGetParam 1
6643: oPushResult
6644: oCall 8132
6646: oPop 1
6648: oPushResult
6649: oEmitInt
6650: oPop 1
6652: oSetResult 0
6654: oPushResult
6655: oEmitInt
6656: oPop 1
6658: oEmit 27
6660: oJumpForward 6665
6662: Choice Lookup Table
           1   6631
6665: oGetAddrLocal 7
6667: oPushResult
6668: oGetLocal 5
6670: oPushResult
6671: oSetResult 15
6673: oPushResult
6674: oNodeGetIter
6675: oPop 2
6677: oAssign
6678: oGetAddrLocal 8
6680: oPushResult
6681: oGetLocal 7
6683: oPushResult
6684: oNodeIterValue
6685: oPop 1
6687: oAssign
6688: oInputChoice 6869
6690: oGetLocal 8
6692: oPushResult
6693: oNodeNull
6694: oPop 1
6696: oChoice 6702
6698: oJumpForward 6865
6700: oJumpForward 6705
6702: Choice Lookup Table
           1   6698
6705: oGetAddrLocal 9
6707: oPushResult
6708: oGetLocal 8
6710: oPushResult
6711: oSetResult 22
6713: oPushResult
6714: oNodeGetInt
6715: oPop 2
6717: oAssign
6718: oEmit 19
6720: oGetLocal 9
6722: oPushResult
6723: oEmitInt
6724: oPop 1
6726: oGetLocal 8
6728: oPushResult
6729: oSetResult 21
6731: oPushResult
6732: oNodeGet
6733: oPop 2
6735: oPushResult
6736: oTypeSPush
6737: oPop 1
6739: oGetLocal 8
6741: oPushResult
6742: oSetResult 32
6744: oPushResult
6745: oNodeGetBoolean
6746: oPop 2
6748: oChoice 6818
6750: oCall 7370
6752: oCall 8150
6754: oEmit 27
6756: oJumpForward 6824
6758: oCall 3996
6760: oCall 6356
6762: oTypeSNodeType
6763: oChoice 6781
6765: oEmit 25
6767: oJumpForward 6816
6769: oEmit 26
6771: oJumpForward 6816
6773: oError 16
6775: oJumpForward 6816
6777: oEmit 27
6779: oJumpForward 6816
6781: Choice Lookup Table
          29   6777
          23   6773
          28   6773
          27   6773
          25   6769
          33   6765
          24   6765
6796: oGetAddrLocal 10
6798: oPushResult
6799: oTypeSTop
6800: oPushResult
6801: oSetResult 17
6803: oPushResult
6804: oNodeGetInt
6805: oPop 2
6807: oAssign
6808: oEmit 28
6810: oGetLocal 10
6812: oPushResult
6813: oEmitInt
6814: oPop 1
6816: oJumpForward 6824
6818: Choice Lookup Table
           0   6758
           1   6750
6823: oEndChoice
6824: oTypeSPop
6825: oGetAddrLocal 7
6827: oPushResult
6828: oNodeIterNext
6829: oPop 1
6831: oGetAddrLocal 8
6833: oPushResult
6834: oGetLocal 7
6836: oPushResult
6837: oNodeIterValue
6838: oPop 1
6840: oAssign
6841: oGetLocal 8
6843: oPushResult
6844: oNodeNull
6845: oPop 1
6847: oChoice 6855
6849: oJumpForward 6865
6851: oJumpForward 6861
6853: oJumpForward 6861
6855: Choice Lookup Table
           0   6853
           1   6849
6860: oEndChoice
6861: oInput 12
6863: oJumpBack 6690
6865: oInput 14
6867: oJumpForward 6872
6869: Choice Lookup Table
          13   6690
6872: oGetLocal 8
6874: oPushResult
6875: oNodeNull
6876: oPop 1
6878: oChoice 6884
6880: oError 15
6882: oJumpForward 6887
6884: Choice Lookup Table
           0   6880
6887: oGetLocal 4
6889: oChoice 6918
6891: oEmit 19
6893: oGetParam 1
6895: oPushResult
6896: oSetResult 31
6898: oPushResult
6899: oNodeGetInt
6900: oPop 2
6902: oPushResult
6903: oEmitInt
6904: oPop 1
6906: oEmit 17
6908: oGetLocal 3
6910: oPushResult
6911: oEmitInt
6912: oPop 1
6914: oEmit 27
6916: oJumpForward 6921
6918: Choice Lookup Table
           1   6891
6921: oGetLocal 1
6923: oChoice 6947
6925: oEmit 50
6927: oGetParam 1
6929: oPushResult
6930: oCall 8471
6932: oPop 1
6934: oJumpForward 6953
6936: oEmit 49
6938: oGetParam 1
6940: oPushResult
6941: oCall 8471
6943: oPop 1
6945: oJumpForward 6953
6947: Choice Lookup Table
           0   6936
           1   6925
6952: oEndChoice
6953: oGetLocal 4
6955: oChoice 7025
6957: oGetLocal 2
6959: oPushResult
6960: oTypeSPush
6961: oPop 1
6963: oTypeSNodeType
6964: oChoice 7000
6966: oEmit 3
6968: oGetLocal 3
6970: oPushResult
6971: oEmitInt
6972: oPop 1
6974: oJumpForward 7023
6976: oEmit 4
6978: oGetLocal 3
6980: oPushResult
6981: oEmitInt
6982: oPop 1
6984: oJumpForward 7023
6986: oError 16
6988: oJumpForward 7023
6990: oEmit 5
6992: oGetLocal 3
6994: oPushResult
6995: oEmitInt
6996: oPop 1
6998: oJumpForward 7023
7000: Choice Lookup Table
          29   6990
          23   6986
          28   6986
          27   6986
          25   6976
          33   6966
          24   6966
7015: oEmit 17
7017: oGetLocal 3
7019: oPushResult
7020: oEmitInt
7021: oPop 1
7023: oJumpForward 7028
7025: Choice Lookup Table
           1   6957
7028: oEmit 48
7030: oGetLocal 6
7032: oPushResult
7033: oEmitInt
7034: oPop 1
7036: oReturn
7037: oLocalSpace 0
7039: oInputChoice 7089
7041: oCall 8014
7043: oJumpForward 7114
7045: oCall 8021
7047: oJumpForward 7114
7049: oCall 8094
7051: oJumpForward 7114
7053: oCall 8097
7055: oJumpForward 7114
7057: oCall 7554
7059: oJumpForward 7114
7061: oCall 7874
7063: oJumpForward 7114
7065: oCall 7620
7067: oJumpForward 7114
7069: oCall 7794
7071: oJumpForward 7114
7073: oCall 7959
7075: oJumpForward 7114
7077: oCall 7927
7079: oJumpForward 7114
7081: oCall 7991
7083: oJumpForward 7114
7085: oCall 7115
7087: oJumpForward 7114
7089: Choice Lookup Table
           0   7085
          33   7081
          49   7077
          50   7073
          47   7069
          42   7065
          46   7061
          39   7057
          63   7053
          62   7049
          61   7045
          60   7041
7114: oReturn
7115: oLocalSpace 1
7117: oGetAddrLocal 1
7119: oPushResult
7120: oScopeFindRequire
7121: oAssign
7122: oGetAddrLocal 1
7124: oPushResult
7125: oCall 396
7127: oPop 1
7129: oGetLocal 1
7131: oPushResult
7132: oNodeType
7133: oPop 1
7135: oChoice 7164
7137: oGetLocal 1
7139: oPushResult
7140: oCall 6444
7142: oPop 1
7144: oJumpForward 7177
7146: oGetLocal 1
7148: oPushResult
7149: oCall 7178
7151: oPop 1
7153: oJumpForward 7177
7155: oGetLocal 1
7157: oPushResult
7158: oCall 7254
7160: oPop 1
7162: oJumpForward 7177
7164: Choice Lookup Table
          13   7155
          21   7146
          19   7146
          18   7146
          12   7137
7175: oError 0
7177: oReturn
7178: oLocalSpace 0
7180: oGetParam 1
7182: oPushResult
7183: oCall 7413
7185: oPop 1
7187: oInput 3
7189: oCall 3996
7191: oCall 8150
7193: oCall 7196
7195: oReturn
7196: oLocalSpace 1
7198: oTypeSNodeType
7199: oChoice 7217
7201: oEmit 25
7203: oJumpForward 7252
7205: oEmit 26
7207: oJumpForward 7252
7209: oError 16
7211: oJumpForward 7252
7213: oEmit 27
7215: oJumpForward 7252
7217: Choice Lookup Table
          29   7213
          23   7209
          28   7209
          27   7209
          25   7205
          33   7201
          24   7201
7232: oGetAddrLocal 1
7234: oPushResult
7235: oTypeSTop
7236: oPushResult
7237: oSetResult 17
7239: oPushResult
7240: oNodeGetInt
7241: oPop 2
7243: oAssign
7244: oEmit 28
7246: oGetLocal 1
7248: oPushResult
7249: oEmitInt
7250: oPop 1
7252: oTypeSPop
7253: oReturn
7254: oLocalSpace 1
7256: oGetParam 1
7258: oPushResult
7259: oSetResult 6
7261: oPushResult
7262: oNodeGet
7263: oPop 2
7265: oPushResult
7266: oScopeCurrent
7267: oPushResult
7268: oNodeEqual
7269: oPop 2
7271: oChoice 7277
7273: oError 20
7275: oJumpForward 7280
7277: Choice Lookup Table
           0   7273
7280: oEmit 8
7282: oGetParam 1
7284: oPushResult
7285: oSetResult 31
7287: oPushResult
7288: oNodeGetInt
7289: oPop 2
7291: oPushResult
7292: oEmitInt
7293: oPop 1
7295: oGetParam 1
7297: oPushResult
7298: oSetResult 21
7300: oPushResult
7301: oNodeGet
7302: oPop 2
7304: oPushResult
7305: oTypeSPush
7306: oPop 1
7308: oInput 3
7310: oCall 3996
7312: oCall 8150
7314: oTypeSNodeType
7315: oChoice 7333
7317: oEmit 25
7319: oJumpForward 7368
7321: oEmit 26
7323: oJumpForward 7368
7325: oError 16
7327: oJumpForward 7368
7329: oEmit 27
7331: oJumpForward 7368
7333: Choice Lookup Table
          29   7329
          23   7325
          28   7325
          27   7325
          25   7321
          33   7317
          24   7317
7348: oGetAddrLocal 1
7350: oPushResult
7351: oTypeSTop
7352: oPushResult
7353: oSetResult 17
7355: oPushResult
7356: oNodeGetInt
7357: oPop 2
7359: oAssign
7360: oEmit 28
7362: oGetLocal 1
7364: oPushResult
7365: oEmitInt
7366: oPop 1
7368: oTypeSPop
7369: oReturn
7370: oLocalSpace 1
7372: oInput 0
7374: oGetAddrLocal 1
7376: oPushResult
7377: oScopeFindRequire
7378: oAssign
7379: oGetAddrLocal 1
7381: oPushResult
7382: oCall 396
7384: oPop 1
7386: oGetLocal 1
7388: oPushResult
7389: oNodeType
7390: oPop 1
7392: oChoice 7396
7394: oJumpForward 7405
7396: Choice Lookup Table
          21   7394
          19   7394
          18   7394
7403: oError 4
7405: oGetLocal 1
7407: oPushResult
7408: oCall 7413
7410: oPop 1
7412: oReturn
7413: oLocalSpace 0
7415: oGetParam 1
7417: oPushResult
7418: oNodeType
7419: oPop 1
7421: oChoice 7481
7423: oEmit 16
7425: oGetParam 1
7427: oPushResult
7428: oCall 8471
7430: oPop 1
7432: oJumpForward 7490
7434: oEmit 17
7436: oGetParam 1
7438: oPushResult
7439: oCall 8471
7441: oPop 1
7443: oJumpForward 7490
7445: oGetParam 1
7447: oPushResult
7448: oSetResult 32
7450: oPushResult
7451: oNodeGetBoolean
7452: oPop 2
7454: oChoice 7467
7456: oEmit 8
7458: oGetParam 1
7460: oPushResult
7461: oCall 8471
7463: oPop 1
7465: oJumpForward 7479
7467: Choice Lookup Table
           1   7456
7470: oEmit 18
7472: oGetParam 1
7474: oPushResult
7475: oCall 8471
7477: oPop 1
7479: oJumpForward 7490
7481: Choice Lookup Table
          21   7445
          19   7434
          18   7423
7488: oError 4
7490: oGetParam 1
7492: oPushResult
7493: oSetResult 21
7495: oPushResult
7496: oNodeGet
7497: oPop 2
7499: oPushResult
7500: oTypeSPush
7501: oPop 1
7503: oCall 6053
7505: oReturn
7506: oLocalSpace 0
7508: oGetParam 1
7510: oPushResult
7511: oCall 7413
7513: oPop 1
7515: oCall 8176
7517: oGetParam 1
7519: oPushResult
7520: oCall 5288
7522: oPop 1
7524: oTypeSPop
7525: oEmit 29
7527: oEmit 25
7529: oReturn
7530: oLocalSpace 0
7532: oGetParam 1
7534: oPushResult
7535: oCall 7413
7537: oPop 1
7539: oCall 8176
7541: oGetParam 1
7543: oPushResult
7544: oCall 5288
7546: oPop 1
7548: oTypeSPop
7549: oEmit 30
7551: oEmit 25
7553: oReturn
7554: oLocalSpace 2
7556: oGetAddrLocal 1
7558: oPushResult
7559: oSetResult 0
7561: oAssign
7562: oGetAddrLocal 1
7564: oPushResult
7565: oCall 4019
7567: oPop 1
7569: oInput 40
7571: oCall 7037
7573: oInputChoice 7608
7575: oGetAddrLocal 2
7577: oPushResult
7578: oLabelNew
7579: oAssign
7580: oEmit 53
7582: oGetLocal 2
7584: oPushResult
7585: oEmitLabel
7586: oPop 1
7588: oEmit 56
7590: oGetLocal 1
7592: oPushResult
7593: oEmitLabel
7594: oPop 1
7596: oCall 7037
7598: oEmit 56
7600: oGetLocal 2
7602: oPushResult
7603: oEmitLabel
7604: oPop 1
7606: oJumpForward 7619
7608: Choice Lookup Table
          41   7575
7611: oEmit 56
7613: oGetLocal 1
7615: oPushResult
7616: oEmitLabel
7617: oPop 1
7619: oReturn
7620: oLocalSpace 4
7622: oInput 0
7624: oGetAddrLocal 1
7626: oPushResult
7627: oScopeFindRequire
7628: oAssign
7629: oGetLocal 1
7631: oPushResult
7632: oCall 7413
7634: oPop 1
7636: oCall 8176
7638: oInput 3
7640: oCall 3996
7642: oCall 8176
7644: oEmit 25
7646: oGetAddrLocal 2
7648: oPushResult
7649: oLabelNew
7650: oAssign
7651: oGetAddrLocal 3
7653: oPushResult
7654: oLabelNew
7655: oAssign
7656: oEmit 53
7658: oGetLocal 3
7660: oPushResult
7661: oEmitLabel
7662: oPop 1
7664: oGetAddrLocal 4
7666: oPushResult
7667: oLabelNew
7668: oAssign
7669: oEmit 56
7671: oGetLocal 4
7673: oPushResult
7674: oEmitLabel
7675: oPop 1
7677: oInputChoice 7757
7679: oGetLocal 1
7681: oPushResult
7682: oCall 7506
7684: oPop 1
7686: oEmit 56
7688: oGetLocal 3
7690: oPushResult
7691: oEmitLabel
7692: oPop 1
7694: oGetLocal 1
7696: oPushResult
7697: oCall 5288
7699: oPop 1
7701: oTypeSPop
7702: oCall 3996
7704: oCall 8176
7706: oEmit 40
7708: oEmit 54
7710: oGetLocal 2
7712: oPushResult
7713: oEmitLabel
7714: oPop 1
7716: oJumpForward 7763
7718: oGetLocal 1
7720: oPushResult
7721: oCall 7530
7723: oPop 1
7725: oEmit 56
7727: oGetLocal 3
7729: oPushResult
7730: oEmitLabel
7731: oPop 1
7733: oGetLocal 1
7735: oPushResult
7736: oCall 5288
7738: oPop 1
7740: oTypeSPop
7741: oCall 3996
7743: oCall 8176
7745: oEmit 41
7747: oEmit 54
7749: oGetLocal 2
7751: oPushResult
7752: oEmitLabel
7753: oPop 1
7755: oJumpForward 7763
7757: Choice Lookup Table
          44   7718
          43   7679
7762: oEndChoice
7763: oGetLocal 4
7765: oPushResult
7766: oGetLocal 2
7768: oPushResult
7769: oLoopPush
7770: oPop 2
7772: oInput 45
7774: oCall 7037
7776: oEmit 53
7778: oGetLocal 4
7780: oPushResult
7781: oEmitLabel
7782: oPop 1
7784: oEmit 56
7786: oGetLocal 2
7788: oPushResult
7789: oEmitLabel
7790: oPop 1
7792: oLoopPop
7793: oReturn
7794: oLocalSpace 3
7796: oGetAddrLocal 1
7798: oPushResult
7799: oLabelNew
7800: oAssign
7801: oEmit 56
7803: oGetLocal 1
7805: oPushResult
7806: oEmitLabel
7807: oPop 1
7809: oGetAddrLocal 2
7811: oPushResult
7812: oLabelNew
7813: oAssign
7814: oGetLocal 1
7816: oPushResult
7817: oGetLocal 2
7819: oPushResult
7820: oLoopPush
7821: oPop 2
7823: oCall 7037
7825: oInputChoice 7856
7827: oCall 7037
7829: oJumpForward 7862
7831: oGetAddrLocal 3
7833: oPushResult
7834: oCall 4019
7836: oPop 1
7838: oEmit 57
7840: oGetLocal 3
7842: oPushResult
7843: oEmitLabel
7844: oPop 1
7846: oGetLocal 1
7848: oPushResult
7849: oEmitLabel
7850: oPop 1
7852: oJumpForward 7864
7854: oJumpForward 7862
7856: Choice Lookup Table
          48   7831
           4   7827
7861: oEndChoice
7862: oJumpBack 7825
7864: oEmit 56
7866: oGetLocal 2
7868: oPushResult
7869: oEmitLabel
7870: oPop 1
7872: oLoopPop
7873: oReturn
7874: oLocalSpace 2
7876: oGetAddrLocal 1
7878: oPushResult
7879: oLabelNew
7880: oAssign
7881: oEmit 56
7883: oGetLocal 1
7885: oPushResult
7886: oEmitLabel
7887: oPop 1
7889: oGetAddrLocal 2
7891: oPushResult
7892: oCall 4019
7894: oPop 1
7896: oGetLocal 1
7898: oPushResult
7899: oGetLocal 2
7901: oPushResult
7902: oLoopPush
7903: oPop 2
7905: oInput 45
7907: oCall 7037
7909: oEmit 53
7911: oGetLocal 1
7913: oPushResult
7914: oEmitLabel
7915: oPop 1
7917: oEmit 56
7919: oGetLocal 2
7921: oPushResult
7922: oEmitLabel
7923: oPop 1
7925: oLoopPop
7926: oReturn
7927: oLocalSpace 0
7929: oLoopContinueLabel
7930: oPushResult
7931: oSetResult 0
7933: oPushResult
7934: equal_label
7935: oPop 2
7937: oChoice 7952
7939: oError 18
7941: oJumpForward 7958
7943: oEmit 53
7945: oLoopContinueLabel
7946: oPushResult
7947: oEmitLabel
7948: oPop 1
7950: oJumpForward 7958
7952: Choice Lookup Table
           0   7943
           1   7939
7957: oEndChoice
7958: oReturn
7959: oLocalSpace 0
7961: oLoopBreakLabel
7962: oPushResult
7963: oSetResult 0
7965: oPushResult
7966: equal_label
7967: oPop 2
7969: oChoice 7984
7971: oError 18
7973: oJumpForward 7990
7975: oEmit 53
7977: oLoopBreakLabel
7978: oPushResult
7979: oEmitLabel
7980: oPop 1
7982: oJumpForward 7990
7984: Choice Lookup Table
           0   7975
           1   7971
7989: oEndChoice
7990: oReturn
7991: oLocalSpace 0
7993: oCall 7037
7995: oInputChoice 8005
7997: oCall 7037
7999: oJumpForward 8011
8001: oJumpForward 8013
8003: oJumpForward 8011
8005: Choice Lookup Table
          34   8001
           4   7997
8010: oEndChoice
8011: oJumpBack 7995
8013: oReturn
8014: oLocalSpace 0
8016: oCall 8021
8018: oEmit 63
8020: oReturn
8021: oLocalSpace 0
8023: oInputChoice 8090
8025: oCall 3996
8027: oTypeSNodeType
8028: oChoice 8054
8030: oEmit 59
8032: oJumpForward 8071
8034: oEmit 60
8036: oJumpForward 8071
8038: oEmit 61
8040: oJumpForward 8071
8042: oError 16
8044: oJumpForward 8071
8046: oEmit 59
8048: oJumpForward 8071
8050: oEmit 62
8052: oJumpForward 8071
8054: Choice Lookup Table
          29   8050
          33   8046
          23   8042
          27   8042
          28   8038
          25   8034
          24   8030
8069: oError 17
8071: oTypeSPop
8072: oInputChoice 8080
8074: oJumpForward 8088
8076: oJumpForward 8086
8078: oJumpForward 8086
8080: Choice Lookup Table
          12   8078
          14   8074
8085: oEndChoice
8086: oJumpBack 8025
8088: oJumpForward 8093
8090: Choice Lookup Table
          13   8025
8093: oReturn
8094: oLocalSpace 0
8096: oReturn
8097: oLocalSpace 0
8099: oReturn
8100: oLocalSpace 0
8102: oScopeCurrent
8103: oPushResult
8104: oSetResult 14
8106: oPushResult
8107: oNodeGetInt
8108: oPop 2
8110: oReturn
8111: oReturn
8112: oLocalSpace 0
8114: oGetParam 1
8116: oPushResult
8117: oSetResult 20
8119: oPushResult
8120: oNodeGet
8121: oPop 2
8123: oPushResult
8124: oSetResult 14
8126: oPushResult
8127: oNodeGetInt
8128: oPop 2
8130: oReturn
8131: oReturn
8132: oLocalSpace 0
8134: oCall 8100
8136: oPushResult
8137: oGetParam 1
8139: oPushResult
8140: oCall 8112
8142: oPop 1
8144: oPushResult
8145: subtract
8146: oPop 2
8148: oReturn
8149: oReturn
8150: oLocalSpace 1
8152: oGetAddrLocal 1
8154: oPushResult
8155: oTypeSNodeType
8156: oAssign
8157: oTypeSPop
8158: oGetLocal 1
8160: oPushResult
8161: oTypeSNodeType
8162: oPushResult
8163: equal_node_type
8164: oPop 2
8166: oChoice 8172
8168: oError 14
8170: oJumpForward 8175
8172: Choice Lookup Table
           0   8168
8175: oReturn
8176: oLocalSpace 0
8178: oTypeSNodeType
8179: oChoice 8183
8181: oJumpForward 8188
8183: Choice Lookup Table
          24   8181
8186: oError 7
8188: oTypeSPop
8189: oReturn
8190: oLocalSpace 0
8192: oTypeSNodeType
8193: oChoice 8197
8195: oJumpForward 8202
8197: Choice Lookup Table
          24   8195
8200: oError 7
8202: oReturn
8203: oLocalSpace 0
8205: oTypeSNodeType
8206: oChoice 8210
8208: oJumpForward 8215
8210: Choice Lookup Table
          25   8208
8213: oError 8
8215: oTypeSPop
8216: oReturn
8217: oLocalSpace 0
8219: oTypeSNodeType
8220: oChoice 8224
8222: oJumpForward 8229
8224: Choice Lookup Table
          25   8222
8227: oError 8
8229: oReturn
8230: oLocalSpace 1
8232: oGetAddrLocal 1
8234: oPushResult
8235: oGetParam 2
8237: oPushResult
8238: oNodeNew
8239: oPop 1
8241: oAssign
8242: oGetLocal 1
8244: oPushResult
8245: oSetResult 17
8247: oPushResult
8248: oGetParam 1
8250: oPushResult
8251: oNodeSetInt
8252: oPop 3
8254: oGetLocal 1
8256: oPushResult
8257: oTypeAdd
8258: oPop 1
8260: oGetLocal 1
8262: oReturn
8263: oReturn
8264: oLocalSpace 1
8266: oGetAddrLocal 1
8268: oPushResult
8269: oGetParam 2
8271: oPushResult
8272: oNodeNew
8273: oPop 1
8275: oAssign
8276: oGetLocal 1
8278: oPushResult
8279: oSetResult 4
8281: oPushResult
8282: oGetParam 1
8284: oPushResult
8285: oNodeSetInt
8286: oPop 3
8288: oGetLocal 1
8290: oReturn
8291: oReturn
8292: oLocalSpace 1
8294: oGetAddrLocal 1
8296: oPushResult
8297: oGetParam 1
8299: oPushResult
8300: oSetResult 33
8302: oPushResult
8303: oNodeGet
8304: oPop 2
8306: oAssign
8307: oGetLocal 1
8309: oPushResult
8310: oNodeNull
8311: oPop 1
8313: oChoice 8369
8315: oGetAddrLocal 1
8317: oPushResult
8318: oSetResult 29
8320: oPushResult
8321: oNodeNew
8322: oPop 1
8324: oAssign
8325: oGetLocal 1
8327: oPushResult
8328: oSetResult 34
8330: oPushResult
8331: oGetParam 1
8333: oPushResult
8334: oNodeSet
8335: oPop 3
8337: oGetLocal 1
8339: oPushResult
8340: oSetResult 17
8342: oPushResult
8343: oSetResult 8
8345: oPushResult
8346: oNodeSetInt
8347: oPop 3
8349: oGetLocal 1
8351: oPushResult
8352: oTypeAdd
8353: oPop 1
8355: oGetParam 1
8357: oPushResult
8358: oSetResult 33
8360: oPushResult
8361: oGetLocal 1
8363: oPushResult
8364: oNodeSet
8365: oPop 3
8367: oJumpForward 8372
8369: Choice Lookup Table
           1   8315
8372: oGetLocal 1
8374: oReturn
8375: oReturn
8376: oLocalSpace 2
8378: oGetParam 1
8380: oPushResult
8381: oNodeType
8382: oPop 1
8384: oChoice 8454
8386: oMININT
8387: oReturn
8388: oJumpForward 8470
8390: oSetResult 0
8392: oReturn
8393: oJumpForward 8470
8395: oSetResult 0
8397: oReturn
8398: oJumpForward 8470
8400: oGetAddrLocal 1
8402: oPushResult
8403: oGetParam 1
8405: oPushResult
8406: oSetResult 38
8408: oPushResult
8409: oNodeGet
8410: oPop 2
8412: oAssign
8413: oGetAddrLocal 2
8415: oPushResult
8416: oGetLocal 1
8418: oPushResult
8419: oSetResult 15
8421: oPushResult
8422: oNodeGetIter
8423: oPop 2
8425: oPushResult
8426: oNodeIterValue
8427: oPop 1
8429: oAssign
8430: oGetLocal 2
8432: oPushResult
8433: oSetResult 22
8435: oPushResult
8436: oNodeGetInt
8437: oPop 2
8439: oReturn
8440: oJumpForward 8470
8442: oGetParam 1
8444: oPushResult
8445: oSetResult 36
8447: oPushResult
8448: oNodeGetInt
8449: oPop 2
8451: oReturn
8452: oJumpForward 8470
8454: Choice Lookup Table
          31   8442
          33   8400
          27   8395
          25   8390
          24   8386
8465: oError 3
8467: oSetResult 0
8469: oReturn
8470: oReturn
8471: oLocalSpace 0
8473: oGetParam 1
8475: oPushResult
8476: oSetResult 22
8478: oPushResult
8479: oNodeGetInt
8480: oPop 2
8482: oPushResult
8483: oEmitInt
8484: oPop 1
8486: oReturn
8487: oLocalSpace 1
8489: oGetAddrGlobal 3
8491: oPushResult
8492: oSetResult 23
8494: oPushResult
8495: oSetResult 4
8497: oPushResult
8498: oCall 8230
8500: oPop 2
8502: oAssign
8503: oGetAddrGlobal 4
8505: oPushResult
8506: oSetResult 24
8508: oPushResult
8509: oSetResult 4
8511: oPushResult
8512: oCall 8230
8514: oPop 2
8516: oAssign
8517: oGetAddrGlobal 5
8519: oPushResult
8520: oSetResult 25
8522: oPushResult
8523: oSetResult 1
8525: oPushResult
8526: oCall 8230
8528: oPop 2
8530: oAssign
8531: oGetAddrGlobal 6
8533: oPushResult
8534: oSetResult 26
8536: oPushResult
8537: oSetResult 1
8539: oPushResult
8540: oCall 8230
8542: oPop 2
8544: oAssign
8545: oGetAddrGlobal 7
8547: oPushResult
8548: oSetResult 27
8550: oPushResult
8551: oSetResult 1
8553: oPushResult
8554: oCall 8230
8556: oPop 2
8558: oAssign
8559: oGetAddrGlobal 8
8561: oPushResult
8562: oSetResult 28
8564: oPushResult
8565: oSetResult 256
8567: oPushResult
8568: oCall 8230
8570: oPop 2
8572: oAssign
8573: oGetAddrLocal 1
8575: oPushResult
8576: oSetResult 16
8578: oPushResult
8579: oIdAdd_File
8580: oPushResult
8581: oCall 8264
8583: oPop 2
8585: oAssign
8586: oGetLocal 1
8588: oPushResult
8589: oSetResult 21
8591: oPushResult
8592: oGetGlobal 3
8594: oPushResult
8595: oNodeSet
8596: oPop 3
8598: oGetLocal 1
8600: oPushResult
8601: oScopeDeclare
8602: oPop 1
8604: oGetAddrLocal 1
8606: oPushResult
8607: oSetResult 16
8609: oPushResult
8610: oIdAdd_Integer
8611: oPushResult
8612: oCall 8264
8614: oPop 2
8616: oAssign
8617: oGetLocal 1
8619: oPushResult
8620: oSetResult 21
8622: oPushResult
8623: oGetGlobal 4
8625: oPushResult
8626: oNodeSet
8627: oPop 3
8629: oGetLocal 1
8631: oPushResult
8632: oScopeDeclare
8633: oPop 1
8635: oGetAddrLocal 1
8637: oPushResult
8638: oSetResult 16
8640: oPushResult
8641: oIdAdd_Boolean
8642: oPushResult
8643: oCall 8264
8645: oPop 2
8647: oAssign
8648: oGetLocal 1
8650: oPushResult
8651: oSetResult 21
8653: oPushResult
8654: oGetGlobal 5
8656: oPushResult
8657: oNodeSet
8658: oPop 3
8660: oGetLocal 1
8662: oPushResult
8663: oScopeDeclare
8664: oPop 1
8666: oGetAddrLocal 1
8668: oPushResult
8669: oSetResult 16
8671: oPushResult
8672: oIdAdd_Char
8673: oPushResult
8674: oCall 8264
8676: oPop 2
8678: oAssign
8679: oGetLocal 1
8681: oPushResult
8682: oSetResult 21
8684: oPushResult
8685: oGetGlobal 7
8687: oPushResult
8688: oNodeSet
8689: oPop 3
8691: oGetLocal 1
8693: oPushResult
8694: oScopeDeclare
8695: oPop 1
8697: oGetAddrLocal 1
8699: oPushResult
8700: oSetResult 16
8702: oPushResult
8703: oIdAdd_String
8704: oPushResult
8705: oCall 8264
8707: oPop 2
8709: oAssign
8710: oGetLocal 1
8712: oPushResult
8713: oSetResult 21
8715: oPushResult
8716: oGetGlobal 8
8718: oPushResult
8719: oNodeSet
8720: oPop 3
8722: oGetLocal 1
8724: oPushResult
8725: oScopeDeclare
8726: oPop 1
8728: oGetAddrLocal 1
8730: oPushResult
8731: oSetResult 14
8733: oPushResult
8734: oIdAdd_True
8735: oPushResult
8736: oCall 8264
8738: oPop 2
8740: oAssign
8741: oGetLocal 1
8743: oPushResult
8744: oSetResult 21
8746: oPushResult
8747: oGetGlobal 5
8749: oPushResult
8750: oNodeSet
8751: oPop 3
8753: oGetLocal 1
8755: oPushResult
8756: oSetResult 22
8758: oPushResult
8759: oSetResult 1
8761: oPushResult
8762: oNodeSetInt
8763: oPop 3
8765: oGetLocal 1
8767: oPushResult
8768: oScopeDeclare
8769: oPop 1
8771: oGetAddrLocal 1
8773: oPushResult
8774: oSetResult 14
8776: oPushResult
8777: oIdAdd_False
8778: oPushResult
8779: oCall 8264
8781: oPop 2
8783: oAssign
8784: oGetLocal 1
8786: oPushResult
8787: oSetResult 21
8789: oPushResult
8790: oGetGlobal 5
8792: oPushResult
8793: oNodeSet
8794: oPop 3
8796: oGetLocal 1
8798: oPushResult
8799: oSetResult 22
8801: oPushResult
8802: oSetResult 0
8804: oPushResult
8805: oNodeSetInt
8806: oPop 3
8808: oGetLocal 1
8810: oPushResult
8811: oScopeDeclare
8812: oPop 1
8814: oReturn
