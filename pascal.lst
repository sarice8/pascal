   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tCastItoD         % convert int32_t to double
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tGreaterD         % double comparisions.  (equality uses EqualP, at least for now)
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueIntToDouble
      
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
      
   2:    oValueNegateD               % operations on double values
   2:    oValueEqualD
   2:    oValueNotEqualD
   2:    oValueLessD
   2:    oValueGreaterD
   2:    oValueLessEqualD
   2:    oValueGreaterEqualD
      
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
      
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
      
   2:    oValueAddD
   2:    oValueSubD
   2:    oValueMultD
   2:    oValueDivD
      
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nDoubleType :
2586:          decl = @newIdent( nConstDouble, id )
2600:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2611:       | nStrLitType :
2613:          decl = @newIdent( nConstStr, id )
2627:          oNodeSetString( decl, qValueStr, oValueTopString )
2638:       | * :  #eNotAllowed
2661:    ]
2661:    oValuePop
2662:    oNodeSet( decl, qType, oTypeSTop )
2673:    oTypeSPop
2674:    oScopeDeclare( decl )
2680:    ';'
2683:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2683: TypedConstDecl:
2685:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2698:    Node theType
2698:    @TypeRef( theType )
2705:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2717:    [ oNodeType( theType )
2724:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2725:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2725:          '='
      
2727:          oTypeSPush( theType )
2733:          @ConstExpr
2735:          @ConstCoerceType
      
2737:          oNodeSetInt( decl, qValue, oValueTop )
2748:          oValuePop
2749:          oTypeSPop
2750:          oScopeDeclare( decl )
2756:          ';'
      
2758:       | nShortStringType, nFileType :
2760:          #eNotImplemented
      
2762:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2764:          oScopeEnter( globalScope )
2770:          int addr = oScopeAllocType( theType )
2780:          oScopeEnd
2781:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2792:          oNodeSetInt( decl, qValue, addr )
2804:          '='
2806:          @TypedConstInit( theType, addr )
2816:          oCodePop
2817:          oScopeDeclare( decl )
2823:          ';'
2825:    ]
2852:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2852: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2854:    [ oNodeType( theType )
2861:       | nArrayType :
2862:          Node baseType = oNodeGet( theType, qBaseType )
2875:          Node indexType = oNodeGet( theType, qIndexType )
2888:          int low = @OrdinalLow( indexType )
2899:          int high = @OrdinalHigh( indexType )
2910:          int elementSize = oNodeGetInt( baseType, qSize )
      
2923:          '('
               % Loop over elements
2925:          int i = low
2931:          {
2931:             @TypedConstInit( baseType, addr )
2941:             [ equal( i, high )
2951:                | true : >
2954:                | false :
2956:             ]
2964:             ','
2966:             addr = add( addr, elementSize )
2979:             inc( i )
2985:          }
2987:          ')'
      
2989:       | nRecordType :
2991:          '('
2993:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3006:          {
3006:             [
3006:                | pIdent :
3008:                | * :  >
3015:             ]
3015:             Node field = oScopeFindRequireInScope( fieldScope )
3025:             ':'
3027:             Node fieldType = oNodeGet( field, qType )
3040:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3060:             @TypedConstInit( fieldType, fieldAddr )
3070:             [
3070:                | ';' :
3072:                | * :  >
3079:             ]
3079:          }
3081:          ')'
      
3083:       | nBooleanType, nByteType, nCharType:
3085:          .tPushAddrGlobal  oEmitInt( addr )
3093:          oTypeSPush( theType )
3099:          @ConstExpr
3101:          @ConstCoerceType
3103:          .tPushConstI  oEmitInt( oValueTop )
3110:          oValuePop
3111:          oTypeSPop
3112:          .tAssignB
      
3114:       | nIntegerType, nEnumType:
3116:          .tPushAddrGlobal  oEmitInt( addr )
3124:          oTypeSPush( theType )
3130:          @ConstExpr
3132:          @ConstCoerceType
3134:          .tPushConstI  oEmitInt( oValueTop )
3141:          oValuePop
3142:          oTypeSPop
3143:          .tAssignI
      
3145:       | nDoubleType:
3147:          #eNotImplemented
      
3149:       | nPointerType, nUniversalPointerType :
3151:          .tPushAddrGlobal  oEmitInt( addr )
3159:          oTypeSPush( theType )
3165:          @ConstExpr
3167:          @ConstCoerceType
3169:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3176:          oValuePop
3177:          oTypeSPop
3178:          .tAssignP
      
3180:       | nShortStringType, nFileType :
3182:          #eNotImplemented
3184:    ]
3213:    ;
      
      
3213: TypeDecl:
3215:    {[
3215:       | pIdent :
3217:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3230:          '='
3232:          Node theType
3232:          @TypeRef( theType )
3239:          oNodeSet( decl, qType, theType )
3251:          oScopeDeclare( decl )
3257:          ';'
3259:       | * :
3264:          >
3266:    ]};
      
3269: VarDecl( node_type varNodeType ):
3271:    {[
3271:       | pIdent :
3273:          NodeVec decls = oNodeVecNew
3278:          Node decl
3278:          {
3278:             decl = @newIdent( varNodeType, LAST_ID )
3291:             oNodeVecAppend( decls, decl )
3300:             [
3300:                | ',' :
3302:                   pIdent
3304:                | * :
3309:                   >
3311:             ]
3311:          }
3313:          ':'
3315:          Node theType
3315:          @TypeRef( theType )
      
3322:          int i = 0
3328:          {[ equal( i, oNodeVecSize( decls ) )
3342:             | false :
3343:                decl = oNodeVecElement( decls, i )
3356:                oNodeSet( decl, qType, theType )
3368:                oScopeDeclareAlloc( decl )
3374:                inc( i )
3380:             | * :
3385:               >
3387:          ]}
      
               % optional initialization
3389:          [
3389:             | '=' :
3391:                [ oNodeVecSize( decls )
3398:                   | 1 :
3399:                   | * :  #eOnlyOneVarCanBeInitialized
3406:                ]
      
                     % we need an initCode stream for this scope
3406:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3416:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3422:                boolean changedScope = false
3428:                [ equal_zero( @ScopeLevel )
3435:                   | true : oScopeEnter( initScope )
3442:                            changedScope = true
3448:                   | * :
3453:                ]
                     % generate assignment in initCode stream
3453:                @LValueVar( decl, true )
3463:                @Expr
3465:                @CoerceType
3467:                @Assign
3469:                [ changedScope
3472:                   | true : oScopeEnd
3474:                   | * :
3479:                ]
3479:                oCodePop
                   
3480:             | * :
3485:          ]
      
3485:          oNodeVecDelete( decls )
3491:          ';'
3493:       | * :
3498:          >
3500:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3503: LabelDecl:
3505:    {
3505:       Node decl
3505:       [
3505:          | pIdent :
3507:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3509:             oChangeIntLitToLabelIdent
3510:       ]
3518:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3531:       Label label = oLabelNew
3536:       oNodeSetLabel( decl, qValue, label )
3548:       oScopeDeclare( decl )
3554:       [
3554:          | ',' :
3556:          | * :
3561:             >
3563:       ]
3563:    }
3565:    ';'
3568:    ;
3568: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3568: ConstExpr:
3570:    @ConstBoolExpr
3572:    {[
3572:       | '=' :
3574:          @ConstBoolTerm
3576:          @ConstMatchTypes
3578:          [ oTypeSNodeType
3580:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3589:             | nDoubleType :   oValueEqualD
3592:             | * :             oValueEqual
3600:          ]
3600:          oTypeSPop  oTypeSPush( BooleanType )
3607:       | '<>' :
3609:          @ConstBoolExpr
3611:          @ConstMatchTypes
3613:          [ oTypeSNodeType
3615:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3624:             | nDoubleType :   oValueNotEqualD
3627:             | * :             oValueNotEqual
3635:          ]
3635:          oTypeSPop  oTypeSPush( BooleanType )
3642:       | '<' :
3644:          @ConstBoolExpr
3646:          @ConstMatchTypes
3648:          [ oTypeSNodeType
3650:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3659:             | nDoubleType :   oValueLessD
3662:             | * :             oValueLess
3670:          ]
3670:          oTypeSPop  oTypeSPush( BooleanType )
3677:       | '>' :
3679:          @ConstBoolExpr
3681:          @ConstMatchTypes
3683:          [ oTypeSNodeType
3685:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3694:             | nDoubleType :   oValueGreaterD
3697:             | * :             oValueGreater
3705:          ]
3705:          oTypeSPop  oTypeSPush( BooleanType )
3712:       | '<=' :
3714:          @ConstBoolExpr
3716:          @ConstMatchTypes
3718:          [ oTypeSNodeType
3720:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3729:             | nDoubleType :   oValueLessEqualD
3732:             | * :             oValueLessEqual
3740:          ]
3740:          oTypeSPop  oTypeSPush( BooleanType )
3747:       | '>=' :
3749:          @ConstBoolExpr
3751:          @ConstMatchTypes
3753:          [ oTypeSNodeType
3755:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3764:             | nDoubleType :   oValueGreaterEqualD
3767:             | * :             oValueGreaterEqual
3775:          ]
3775:          oTypeSPop  oTypeSPush( BooleanType )
3782:       | * :  >
3799:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3802: ConstExprAllowTypeName:
3804:    boolean oldAllowTypeName = flagExprAllowTypeName
3810:    flagExprAllowTypeName = true
3816:    @ConstExpr
3818:    flagExprAllowTypeName = oldAllowTypeName
3825:    ;
      
      
3825: ConstBoolExpr:
3827:    @ConstBoolTerm
3829:    {[
3829:       | pOr :
3831:          @ConstRequireBool
3833:          @ConstBoolTerm
3835:          @ConstRequireBoolPop
3837:          oValueOr
3838:       | * :  >
3845:    ]};
      
      
3848: ConstBoolTerm:
3850:    @ConstBoolFactor
3852:    {[
3852:       | pAnd :
3854:          @ConstRequireBool
3856:          @ConstBoolFactor
3858:          @ConstRequireBoolPop
3860:          oValueAnd
3861:       | * :  >
3868:    ]};
      
      
3871: ConstBoolFactor:
3873:    [
3873:       | pNot :
3875:          @ConstBoolFactor
3877:          @ConstRequireBool
3879:          oValueNot
3880:       | * :
3885:          @ConstArithExpr
3887:    ];
      
      
3888: ConstArithExpr:
3890:    @ConstTerm
3892:    {[
3892:       | '+' :
3894:          @ConstTerm
3896:          @ConstMatchTypes
3898:          [ oTypeSNodeType
3900:             | nStrLitType :   oValueStringConcat
3902:             | nDoubleType :   oValueAddD
3905:             | * :             oValueAdd
3913:          ]
3913:       | '-' :
3915:          @ConstTerm
3917:          @ConstMatchTypes
3919:          [ oTypeSNodeType
3921:             | nStrLitType :   #eNotAllowed
3924:             | nDoubleType :   oValueSubD
3927:             | * :             oValueSub
3935:          ]
3935:       | * :  >
3944:    ]};
      
      
3947: ConstTerm:
3949:    @ConstFactor
3951:    {[
3951:       | pTimes :
3953:          @ConstFactor
3955:          @ConstMatchTypes
3957:          [ oTypeSNodeType
3959:             | nStrLitType :   #eNotAllowed
3962:             | nDoubleType :   oValueMultD
3965:             | * :             oValueMult
3973:          ]
3973:       | pDivide :
3975:          @ConstFactor
3977:          @ConstMatchTypes
3979:          [ oTypeSNodeType
3981:             | nStrLitType :   #eNotAllowed
3984:             | nDoubleType :   oValueDivD
3987:             | * :             oValueDiv
3995:          ]
3995:       | * :  >
4004:    ]};
      
      
4007: ConstFactor:
4009:    [
4009:       | pPlus :
4011:          @ConstPrimary
4013:       | pMinus :
4015:          @ConstPrimary
4017:          [ oTypeSNodeType
4019:             | nStrLitType :   #eNotAllowed
4022:             | nDoubleType :   oValueNegateD
4025:             | * :             oValueNegate
4033:          ]
4033:       | * :
4040:          @ConstPrimary
4042:    ];
      
      
4043: ConstPrimary:
4045:    [
4045:       | pIntLit :
4047:          oValuePush( TOKEN_VALUE )
4052:          oTypeSPush( IntegerType )
4058:       | pCharLit :
4060:          oValuePush( TOKEN_VALUE )
4065:          oTypeSPush( CharType )
4071:       | pDoubleLit :
4073:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4078:          oTypeSPush( DoubleType )
4084:       | pStrLit :
4086:          oValuePushString( CURRENT_STRLIT )
4091:          oTypeSPush( StrLitType )
4097:       | '(' :
4099:          @ConstExpr
4101:          ')'
4103:       | pIdent :
4105:          Node decl = oScopeFindRequire
4110:          @ResolveUnitRef( decl )
4117:          [ oNodeType( decl )
4124:             | nBuiltInFunc :
4125:                @ConstBuiltInFunc( decl )
4132:             | nConst :
4134:                oValuePush( oNodeGetInt( decl, qValue ) )
4147:                oTypeSPush( oNodeGet( decl, qType ) )
4160:             | nConstStr :
4162:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4175:                oTypeSPush( oNodeGet( decl, qType ) )
4188:             | nEnumValue :
4190:                oValuePush( oNodeGetInt( decl, qValue ) )
4203:                oTypeSPush( oNodeGet( decl, qType ) )
4216:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4218:                oTypeSPush( oNodeGet( decl, qType ) )
4231:                [
4231:                   | '(' :
                           % Type cast
4233:                      @ConstExpr
4235:                      ')'
4237:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4239:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4244:                      [ flagExprAllowTypeName
4247:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4248:                            oValuePush( 0 )
4254:                         | * :   #eTypeNameNotAllowedHere
4261:                      ]
4261:                ]
      
4261:             | * :
4274:                #eNotConst
4276:                oValuePush( 0 )
4282:                oTypeSPush( IntegerType )
4288:          ]
4288:       | '@' :
4290:          #eNotImplemented
4292:          oValuePush( 0 )
4298:          oTypeSPush( UniversalPointerType )
4304:       | * :
4321:          #eNotConst
4323:          oValuePush( 0 )
4329:          oTypeSPush( IntegerType )
4335:    ];
      
4336: ConstRequireBoolPop:
4338:    [ oTypeSNodeType
4340:       | nBooleanType :
4341:       | * :          #eNotBoolean
4348:    ]
4348:    oTypeSPop;
      
      
4350: ConstRequireBool:
4352:    [ oTypeSNodeType
4354:       | nBooleanType :
4355:       | * :          #eNotBoolean
4362:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4363: ConstMatchTypes:
4365:    node_type nt = oTypeSNodeType
4370:    oTypeSPop
4371:    [ equal_node_type( nt, oTypeSNodeType )
4380:       | false :
               % Some implicit conversion is allowed even here
4381:          [ oTypeSNodeType
4383:             | nPointerType :
4384:                [ nt
4387:                   | nUniversalPointerType :  >>
4389:                   | * :
4394:                ]
4394:             | nUniversalPointerType :
4396:                [ nt
4399:                   | nPointerType :  >>
4401:                   | * :
4406:                ]
4406:             | nStrLitType :
4408:                [ nt
4411:                   | nCharType :
4412:                      oValueCharToString
4413:                      >>
4414:                   | * :
4419:                ]
4419:             | nCharType :
4421:                [ nt
4424:                   | nStrLitType :
4425:                      oValueSwap
4426:                      oValueCharToString
4427:                      oValueSwap
4428:                      oTypeSPop
4429:                      oTypeSPush( StrLitType )
4435:                      >>
4436:                   | * :
4441:                ]
4441:             | * :
4452:          ]
4452:          #eTypeMismatch
4454:       | * :
4459:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4460: ConstCoerceType:
4462:    node_type nt = oTypeSNodeType
4467:    oTypeSPop
4468:    [ equal_node_type( nt, oTypeSNodeType )
4477:       | false :
               % Can we implicitly convert the value to the desired type?
4478:          [ oTypeSNodeType
4480:             | nIntegerType :
4481:                [ nt
4484:                   | nByteType :  >>
4486:                   | * :
4491:                ]
4491:             | nByteType :
4493:                [ nt
4496:                   | nIntegerType :  >>
4498:                   | * :
4503:                ]
4503:             | nPointerType :
4505:                [ nt
4508:                   | nUniversalPointerType :  >>
4510:                   | * :
4515:                ]
4515:             | nUniversalPointerType :
4517:                [ nt
4520:                   | nPointerType :  >>
4522:                   | * :
4527:                ]
4527:             | nStrLitType :
4529:                [ nt
4532:                   | nCharType :
4533:                      oValueCharToString
4534:                      >>
4535:                   | * :
4540:                ]
4540:             | nShortStringType :
4542:                [ nt
4545:                   | nStrLitType :  >>
4547:                   | nCharType :
4549:                      oValueCharToString
4550:                      >>
4551:                   | * :
4558:                ]
4558:             | * :
4573:          ]
4573:          #eTypeMismatch
4575:       | * :
4580:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4581: ConstCastType:
4583:    node_type nt = oTypeSNodeType
4588:    oTypeSPop
4589:    [ equal_node_type( nt, oTypeSNodeType )
4598:       | false :
               % Can we cast the value to the desired type?
4599:          [ oTypeSNodeType
4601:             | nIntegerType, nEnumType :
4602:                [ nt
4605:                   | nByteType, nCharType, nBooleanType :  >>
4607:                   | nIntegerType, nEnumType :  >>
                        % fpc does not allow explicit cast of double to integer.
                        % User must call trunc() / round().
4610:                   | * :
4623:                ]
4623:             | nByteType, nCharType, nBooleanType :
4625:                [ nt
4628:                   | nByteType, nCharType, nBooleanType :  >>
4630:                   | nIntegerType, nEnumType :  >>
4633:                   | * :
4646:                ]
4646:             | nDoubleType :
4648:                [ nt
4651:                   | nByteType, nCharType, nBooleanType, nIntegerType, nEnumType :
4652:                      oValueIntToDouble
4653:                      >>
4654:                   | nDoubleType :  >>
4657:                   | * :
4672:                ]
4672:             | nPointerType :
4674:                [ nt
4677:                   | nUniversalPointerType :  >>
4679:                   | * :
4684:                ]
4684:             | nUniversalPointerType :
4686:                [ nt
4689:                   | nPointerType :  >>
4691:                   | * :
4696:                ]
4696:             | nStrLitType :
4698:                [ nt
4701:                   | nCharType :
4702:                      oValueCharToString
4703:                      >>
4704:                   | * :
4709:                ]
4709:             | nShortStringType :
4711:                [ nt
4714:                   | nStrLitType :  >>
4716:                   | nCharType :
4718:                      oValueCharToString
4719:                      >>
4720:                   | * :
4727:                ]
4727:             | * :
4750:          ]
4750:          #eTypeMismatch
4752:       | * :
4757:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4758: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4760:    [ oNodeEqual( method, BuiltIn_Ord )
4770:       | true :
4771:          '('
4773:          @ConstExpr
4775:          ')'
4777:          [ oTypeSNodeType
4779:             | nIntegerType, nEnumType :
4780:             | nBooleanType, nByteType, nCharType :
4782:             | * :  #eTypeMismatch
4797:          ]
4797:          oTypeSPop
4798:          oTypeSPush( IntegerType )
4804:          ')'
4806:          >>
4807:       | * :
4812:    ]
      
         % Chr(x)
4812:    [ oNodeEqual( method, BuiltIn_Chr )
4822:       | true :
4823:          '('
4825:          @ConstExpr
4827:          ')'
4829:          [ oTypeSNodeType
4831:             | nIntegerType :
4832:             | nByteType :
4834:             | * :  #eTypeMismatch
4843:          ]
4843:          oTypeSPop
4844:          oTypeSPush( CharType )
4850:          ')'
4852:          >>
4853:       | * :
4858:    ]
      
         % Pred(x)
4858:    [ oNodeEqual( method, BuiltIn_Pred )
4868:       | true :
4869:          '('
4871:          @ConstExpr
4873:          [ oTypeSNodeType
4875:             | nEnumType :
4876:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4885:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4888:                   | * :
4893:                ]
4893:             | * :  #eTypeMismatch
4900:          ]
4900:          oValuePush( 1 )  oValueSub
4907:          ')'
4909:          >>
4910:       | * :
4915:    ]
      
         % Succ(x)
4915:    [ oNodeEqual( method, BuiltIn_Succ )
4925:       | true :
4926:          '('
4928:          @ConstExpr
4930:          [ oTypeSNodeType
4932:             | nEnumType :
4933:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4942:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4945:                   | * :
4950:                ]
4950:             | * :  #eTypeMismatch
4957:          ]
4957:          oValuePush( 1 )  oValueAdd
4964:          ')'
4966:          >>
4967:       | * :
4972:    ]
      
         % Sizeof(x)
4972:    [ oNodeEqual( method, BuiltIn_Sizeof )
4982:       | true :
4983:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4985:          @ConstExprAllowTypeName
4987:          oValuePop
4988:          Node theType = oTypeSTop
4993:          oTypeSPop
4994:          oValuePush( oNodeGetInt( theType, qSize ) )
5007:          oTypeSPush( IntegerType )
5013:          ')'
5015:          >>
5016:       | * :
5021:    ]
      
5021:    #eNotImplemented
5024:    ;
      
      
5024: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5024: Expr:
5026:    Label falseLabel = labelNull
      
5032:    @ExprAllowFlow( falseLabel )
5039:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
5047: ExprAllowTypeName:
5049:    boolean oldAllowTypeName = flagExprAllowTypeName
5055:    flagExprAllowTypeName = true
5061:    @Expr
5063:    flagExprAllowTypeName = oldAllowTypeName
5070:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5070: BooleanExprControlFlow( out Label falseLabel ):
5072:    @ExprAllowFlow( falseLabel )
5079:    [ oTypeSNodeType
5081:       | nBooleanFlowType :
5082:       | nBooleanType :
               % convert value to control flow
5084:          falseLabel = oLabelNew
5089:          .tJumpFalse  oEmitLabel( falseLabel )
5097:       | * :
5104:          #eNotBoolean
5106:    ]
5106:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5108: FlowToVal( inout Label falseLabel ):
5110:    [ oTypeSNodeType
5112:       | nBooleanFlowType :
5113:          Label doneLabel = oLabelNew
5118:          .tPushConstI  oEmitInt( 1 )
5126:          .tJump  oEmitLabel( doneLabel )
5134:          .tLabel  oEmitLabel( falseLabel )
5142:          .tPushConstI  oEmitInt( 0 )
5150:          .tLabel  oEmitLabel( doneLabel )
5158:          oTypeSPop
5159:          oTypeSPush( BooleanType )
5165:          falseLabel = labelNull
5171:       | * :
5176:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5177: ValToFlow( out Label falseLabel ):
5179:    [ oTypeSNodeType
5181:       | nBooleanType :
5182:          falseLabel = oLabelNew
5187:          .tJumpFalse  oEmitLabel( falseLabel )
5195:          oTypeSPop
5196:          oTypeSPush( BooleanFlowType )
5202:       | * :
5207:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5208: ExprAllowFlow( out Label falseLabel ):
5210:    @BoolExprAllowFlow( falseLabel )
5217:    {[
5217:       | '=' :
5219:          @FlowToVal( falseLabel )
5226:          @PromoteToIntOptional
5228:          @BoolExprAllowFlow( falseLabel )
5235:          @FlowToVal( falseLabel )
5242:          @PromoteToIntOptional
5244:          @CoerceTypePair
5246:          [ oTypeSNodeType
5248:             | nBooleanType, nCharType :     .tEqualB
5251:             | nIntegerType, nEnumType :     .tEqualI
5255:             | nDoubleType :                 .tEqualP
                        % Note: Assuming nDoubleType can use .tEqualP, just matching bits.
                        %  If not, it would also put into doubt memcmp of record values.
5259:             | nPointerType, nUniversalPointerType :    .tEqualP
5263:             | nShortStringType, nStrLitType :
5265:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5277:             | * :                           #eNotAllowed
5300:          ]
5300:          oTypeSPop
5301:          oTypeSPush( BooleanType )
      
5307:       | '<>' :
5309:          @FlowToVal( falseLabel )
5316:          @PromoteToIntOptional
5318:          @BoolExprAllowFlow( falseLabel )
5325:          @FlowToVal( falseLabel )
5332:          @PromoteToIntOptional
5334:          @CoerceTypePair
5336:          [ oTypeSNodeType
5338:             | nBooleanType, nCharType :     .tNotEqualB
5341:             | nIntegerType, nEnumType :     .tNotEqualI
5345:             | nDoubleType :                 .tNotEqualP
5349:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5353:             | nShortStringType, nStrLitType :
5355:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5367:             | * :                           #eNotAllowed
5390:          ]
5390:          oTypeSPop
5391:          oTypeSPush( BooleanType )
      
5397:       | '<' :
5399:          @FlowToVal( falseLabel )
5406:          @PromoteToIntOptional
5408:          @BoolExprAllowFlow( falseLabel )
5415:          @FlowToVal( falseLabel )
5422:          @PromoteToIntOptional
5424:          @CoerceTypePair
5426:          [ oTypeSNodeType
5428:             | nBooleanType, nCharType :     .tLessB
5431:             | nIntegerType, nEnumType :     .tLessI
5435:             | nDoubleType :                 .tLessD
5439:             | nPointerType, nUniversalPointerType :   .tLessP
5443:             | nShortStringType, nStrLitType :
5445:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5457:             | * :                           #eNotAllowed
5480:          ]
5480:          oTypeSPop
5481:          oTypeSPush( BooleanType )
      
5487:       | '>' :
5489:          @FlowToVal( falseLabel )
5496:          @PromoteToIntOptional
5498:          @BoolExprAllowFlow( falseLabel )
5505:          @FlowToVal( falseLabel )
5512:          @PromoteToIntOptional
5514:          @CoerceTypePair
5516:          [ oTypeSNodeType
5518:             | nBooleanType, nCharType :     .tGreaterB
5521:             | nIntegerType, nEnumType :     .tGreaterI
5525:             | nDoubleType :                 .tGreaterD
5529:             | nPointerType, nUniversalPointerType :   .tGreaterP
5533:             | nShortStringType, nStrLitType :
5535:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5547:             | * :                           #eNotAllowed
5570:          ]
5570:          oTypeSPop
5571:          oTypeSPush( BooleanType )
      
5577:       | '<=' :
5579:          @FlowToVal( falseLabel )
5586:          @PromoteToIntOptional
5588:          @BoolExprAllowFlow( falseLabel )
5595:          @FlowToVal( falseLabel )
5602:          @PromoteToIntOptional
5604:          @CoerceTypePair
5606:          [ oTypeSNodeType
5608:             | nBooleanType, nCharType :     .tLessEqualB
5611:             | nIntegerType, nEnumType :     .tLessEqualI
5615:             | nDoubleType :                 .tLessEqualD
5619:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5623:             | nShortStringType, nStrLitType :
5625:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5637:             | * :                           #eNotAllowed
5660:          ]
5660:          oTypeSPop
5661:          oTypeSPush( BooleanType )
      
5667:       | '>=' :
5669:          @FlowToVal( falseLabel )
5676:          @PromoteToIntOptional
5678:          @BoolExprAllowFlow( falseLabel )
5685:          @FlowToVal( falseLabel )
5692:          @PromoteToIntOptional
5694:          @CoerceTypePair
5696:          [ oTypeSNodeType
5698:             | nBooleanType, nCharType :     .tGreaterEqualB
5701:             | nIntegerType, nEnumType :     .tGreaterEqualI
5705:             | nDoubleType :                 .tGreaterEqualD
5709:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5713:             | nShortStringType, nStrLitType :
5715:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5727:             | * :                           #eNotAllowed
5750:          ]
5750:          oTypeSPop
5751:          oTypeSPush( BooleanType )
      
5757:       | * :
5772:          >
5774:    ]};
      
      
5777: BoolExprAllowFlow( out Label falseLabel ):
5779:    Label trueLabel = labelNull
      
5785:    @BoolTermAllowFlow( falseLabel )
5792:    {[
5792:       | pOr :
5794:          [ oTypeSNodeType
5796:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5797:                [ equal_label( trueLabel, labelNull )
5807:                   | true :  trueLabel = oLabelNew
5813:                   | * :
5818:                ]
5818:                .tJump  oEmitLabel( trueLabel )
5826:             | nBooleanType :
5828:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5835:                [ equal_label( trueLabel, labelNull )
5845:                   | true :  trueLabel = oLabelNew
5851:                   | * :
5856:                ]
5856:                .tJump  oEmitLabel( trueLabel )
5864:             | * : #eNotBoolean
5873:          ]
5873:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5874:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5882:          falseLabel = labelNull
5888:          @BoolTermAllowFlow( falseLabel )
      
5895:          [ oTypeSNodeType
5897:             | nBooleanFlowType :
5898:             | nBooleanType :
5900:                @ValToFlow( falseLabel )
5907:             | * : #eNotBoolean
5916:          ]
      
5916:          oTypeSPop
5917:          oTypeSPush( BooleanFlowType )
      
5923:       | * :
5928:          >
5930:    ]}
      
         % any short-circuit trues jump here to the end
5932:    [ equal_label( trueLabel, labelNull )
5942:       | false :
5943:          .tLabel  oEmitLabel( trueLabel )
5951:       | * :
5956:    ]
5957:    ;
      
      
5957: BoolTermAllowFlow( out Label falseLabel ):
5959:    Label overallFalseLabel = labelNull
      
5965:    @BoolFactorAllowFlow( falseLabel )
5972:    {[
5972:       | pAnd :
5974:          [ oTypeSNodeType
5976:             | nBooleanFlowType :
5977:             | nBooleanType :
5979:                @ValToFlow( falseLabel )
5986:             | * :
5993:                #eNotBoolean
5995:          ]
5995:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5996:          [ equal_label( overallFalseLabel, labelNull )
6006:             | true :
6007:                overallFalseLabel = oLabelNew
6012:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6026:                falseLabel = overallFalseLabel
6032:             | * :
6037:          ]
      
6037:          Label factorFalseLabel = labelNull
6043:          @BoolFactorAllowFlow( factorFalseLabel )
      
6050:          [ oTypeSNodeType
6052:             | nBooleanFlowType :
6053:             | nBooleanType :
6055:                @ValToFlow( factorFalseLabel )
6062:             | * : #eNotBoolean
6071:          ]
6071:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6085:       | * :
6090:          >
6092:    ]};
      
      
6095: BoolFactorAllowFlow( out Label falseLabel ):
6097:    [
6097:       | pNot :
6099:          Label factorFalseLabel = labelNull
      
6105:          @BoolFactorAllowFlow( factorFalseLabel )
6112:          [ oTypeSNodeType
6114:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6115:                falseLabel = oLabelNew
6120:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6128:                .tLabel  oEmitLabel( factorFalseLabel )
      
6136:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6138:                .tNot
      
6140:             | * : #eNotBoolean
6149:          ]
      
6149:       | * :
6154:          @ArithExprAllowFlow( falseLabel )
6161:    ];
      
      
6162: ArithExprAllowFlow( out Label falseLabel ):
6164:    boolean first = true
6170:    int tempStrOffset
      
6170:    @TermAllowFlow( falseLabel )
6177:    {[
6177:       | '+' :
6179:          [ oTypeSNodeType
6181:             | nIntegerType, nByteType :
6182:                @PromoteToIntPop
6184:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6191:                [ oTypeSNodeType
6193:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6194:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6196:                      @PointerAddition
6198:                   | nDoubleType :
                           % int + double
                           % int type was already popped above; leave double on type stack
6200:                      .tSwap
6202:                      .tCastItoD
6204:                      .tAddD
6206:                   | * :
6215:                      @PromoteToInt
6217:                      .tAddI
6219:                ]
      
6219:             | nDoubleType :
6221:                @TermAllowFlow( falseLabel )
6228:                @PromoteToDoublePop
6230:                .tAddD
      
6232:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6234:                [ first
6237:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6238:                             tempStrOffset = @MoveIntoTempShortString
6244:                             first = false
6250:                   | * :
6255:                ]
6255:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6262:                [ oTypeSNodeType
6264:                   | nShortStringType, nStrLitType :
6265:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6267:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6275:                      oTypeSPush( ShortStringType )
6281:                   | nCharType :
6283:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6285:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6293:                      oTypeSPush( ShortStringType )
6299:                   | * :
6308:                      #eTypeMismatch
6310:                      oTypeSPop
6311:                ]
      
6311:             | nPointerType, nUniversalPointerType :
6313:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6320:                @PromoteToIntPop
6322:                @PointerAddition
      
6324:             | * :
6343:                #eNotAllowed
6345:          ]
      
6345:       | '-' :
6347:          [ oTypeSNodeType
6349:             | nIntegerType, nByteType :
6350:                @PromoteToIntPop
6352:                @TermAllowFlow( falseLabel )
      
6359:                [ oTypeSNodeType
6361:                   | nDoubleType :
                           % int - double
                           % int type was already popped above; leave double on type stack
6362:                      .tSwap
6364:                      .tCastItoD
6366:                      .tSwap
6368:                      .tSubD
6370:                   | * :
6375:                      @PromoteToInt
6377:                      .tSubI
6379:                ]
      
6379:             | nDoubleType :
6381:                @TermAllowFlow( falseLabel )
6388:                @PromoteToDoublePop
6390:                .tSubD
      
6392:             | nPointerType, nUniversalPointerType :
6394:                @TermAllowFlow( falseLabel )
6401:                [ oTypeSNodeType
6403:                   | nIntegerType, nByteType :
6404:                      @PromoteToIntPop
6406:                      @PointerSubInt
6408:                   | nPointerType, nUniversalPointerType :
6410:                      @MatchTypes
6412:                      @PointerSubPointer
6414:                   | * :
6425:                      #eNotAllowed
6427:                ]
      
6427:             | * :  #eNotAllowed
      
6442:          ]
6442:       | * :
6449:          >
6451:    ]};
      
      
6454: TermAllowFlow( out Label falseLabel ):
6456:    @FactorAllowFlow( falseLabel )
6463:    {[
6463:       | '*' :
6465:          [ oTypeSNodeType
6467:             | nIntegerType, nByteType :
6468:                @PromoteToIntPop
6470:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6477:                [ oTypeSNodeType
6479:                   | nDoubleType :
                           % int * double
                           % int type was already popped above; leave double on type stack
6480:                      .tSwap
6482:                      .tCastItoD
6484:                      .tMultD
6486:                   | * :
6491:                      @PromoteToInt
6493:                      .tMultI
6495:                ]
      
6495:             | nDoubleType :
6497:                @FactorAllowFlow( falseLabel )
6504:                @PromoteToDoublePop
6506:                .tMultD
      
6508:             | * :
6517:                #eNotAllowed
6519:          ]
      
6519:       | '/' :
6521:          [ oTypeSNodeType
6523:             | nIntegerType, nByteType :
6524:                @PromoteToIntPop
6526:                @FactorAllowFlow( falseLabel )
6533:                [ oTypeSNodeType
6535:                   | nDoubleType :
                           % int / double
                           % int type was already popped above; leave double on type stack
6536:                      .tSwap
6538:                      .tCastItoD
6540:                      .tSwap
6542:                      .tDivD
6544:                   | * :
6549:                      @PromoteToInt
6551:                      .tDivI
6553:                ]
      
6553:             | nDoubleType :
6555:                @FactorAllowFlow( falseLabel )
6562:                @PromoteToDoublePop
6564:                .tDivD
      
6566:             | * :
6575:                #eNotAllowed
6577:          ]
      
6577:       | * :
6584:          >
6586:    ]};
      
      
6589: FactorAllowFlow( out Label falseLabel ):
6591:    [
6591:       | '+' :
6593:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6600:          [ oTypeSNodeType
6602:             | nIntegerType, nByteType :
6603:             | nDoubleType :
6605:             | * :
6614:                #eNotAllowed
6616:          ]
6616:       | '-' :
6618:          @PrimaryAllowFlow( falseLabel )
6625:          [ oTypeSNodeType
6627:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6628:                @PromoteToInt
6630:                .tNegI
6632:             | nDoubleType :
6634:                .tNegD
6636:             | * :
6645:                #eNotAllowed
6647:          ]
6647:       | * :
6654:          @PrimaryAllowFlow( falseLabel )
6661:    ];
      
      
6662: PrimaryAllowFlow( out Label falseLabel ):
6664:    [
6664:       | pIntLit :
6666:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6673:          oTypeSPush( IntegerType )
      
6679:       | pCharLit :
6681:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6688:          oTypeSPush( CharType )
      
6694:       | pDoubleLit :
6696:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6703:          oTypeSPush( DoubleType )
      
6709:       | '(' :
6711:          @ExprAllowFlow( falseLabel )
6718:          ')'
      
6720:       | pStrLit :
6722:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6731:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6739:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6745:          @LValueIndexes
               % get final value of dereferencing, if any
6747:          @FetchVar
      
6749:       | pIdent :
6751:          Node decl = oScopeFindRequire
6756:          @ResolveUnitRef( decl )
6763:          Node theType
      
6763:          [ oNodeType( decl )
6770:             | nFunc :
6771:                @Call( decl )
      
6778:             | nBuiltInFunc :
6780:                @CallBuiltInFunc( decl )
      
6787:             | nConst, nEnumValue :
6789:                theType = oNodeGet( decl, qType )
6802:                oTypeSPush( theType )
6808:                [ oTypeSNodeType
6810:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6811:                      .tPushConstI @EmitValue( decl )
6820:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6822:                      .tPushConstI @EmitValue( decl )
6831:                   | * :
6848:                      #eNotImplemented
6850:                ]
      
6850:             | nConstDouble :
6852:                theType = oNodeGet( decl, qType )
6865:                oTypeSPush( theType )
6871:                [ oTypeSNodeType
6873:                   | nDoubleType :
6874:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6889:                   | * :
6894:                      #eNotImplemented
6896:                ]
                     
6896:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6898:                int addr = oNodeGetInt( decl, qValue )
6911:                [ equal_zero( addr )
6918:                   | true :
6919:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6936:                      oNodeSetInt( decl, qValue, addr )
6948:                   | * :
6953:                ]
6953:                .tPushAddrGlobal oEmitInt( addr )
6961:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6967:                @LValueIndexes
                     % get final value of dereferencing, if any
6969:                @FetchVar
      
6971:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6973:                @VarExpr( decl )
      
6980:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6982:                oTypeSPush( oNodeGet( decl, qType ) )
6995:                [
6995:                   | '(' : 
                           % Type cast
6997:                      @Expr
6999:                      ')'
7001:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
7003:                      [ oTypeSNodeType
7005:                         | nPointerType, nUniversalPointerType :
7006:                            [
7006:                               | '^' :             % dereferenced
7008:                                  oTypeSPop
7009:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
7022:                                  @LValueIndexes
7024:                                  @FetchVar
7026:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
7028:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
7030:                                  @LValueIndexes
7032:                                  @FetchVar
7034:                               | * :               % just ptr value alone
7041:                            ]
      
7041:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
7043:                            @LValueIndexes
                                 % get final value, if no longer compound
7045:                            @FetchVar
      
7047:                         | *:
7060:                      ]
      
7060:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
7065:                      [ flagExprAllowTypeName
7068:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
7069:                            .tPushConstI  oEmitInt( 0 )
7077:                         | * :    #eTypeNameNotAllowedHere
7084:                      ]
7084:                ]
      
7084:             | * :
7109:                #eNotValue
7111:                oTypeSPush( IntegerType )
7117:          ]
      
7117:       | '@' :        % @var -- pointer to var
7119:          pIdent
      
7121:          Node decl = oScopeFindRequire
7126:          @ResolveUnitRef( decl )
7133:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
7133:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7143:          theType = oTypeSTop
7148:          oTypeSPop
7149:          Node ptrType = @PointerTypeTo( theType )
7160:          oTypeSPush( ptrType )
      
7166:       | * :
7183:          #eNotValue
7185:          oTypeSPush( IntegerType )
7191:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7192: VarExpr( Node decl ):
7194:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7207:    int uplevels = @DeclUpLevels( decl )
      
7218:    oTypeSPush( theType )
7224:    [ oTypeSNodeType
7226:       | nIntegerType, nEnumType :
7227:          [ oNodeType( decl )
7234:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7244:             | nLocalVar :
7246:                [ equal_zero( uplevels )
7253:                   | true :  .tPushLocalI  @EmitValue( decl )
7263:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7283:                ]
7283:             | nParam :
7285:                [ oNodeGetBoolean( decl, qInOut )
7295:                   | true :    % VAR param points to the var.  Auto dereference.
7296:                      [ equal_zero( uplevels )
7303:                         | true :  .tPushParamP  @EmitValue( decl )
7313:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7333:                      ]
7333:                      .tFetchI
7335:                   | * :
7340:                      [ equal_zero( uplevels )
7347:                         | true :  .tPushParamI  @EmitValue( decl )
7357:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7377:                      ]
7377:                ]
7377:          ]
      
7389:       | nBooleanType, nByteType, nCharType :
7391:          [ oNodeType( decl )
7398:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7408:             | nLocalVar :
7410:                [ equal_zero( uplevels )
7417:                   | true :  .tPushLocalB  @EmitValue( decl )
7427:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7447:                ]
7447:             | nParam :
7449:                [ oNodeGetBoolean( decl, qInOut )
7459:                   | true :    % VAR param points to the var.  Auto dereference.
7460:                      [ equal_zero( uplevels )
7467:                         | true :  .tPushParamP  @EmitValue( decl )
7477:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7497:                      ]
7497:                      .tFetchB
7499:                   | * :
7504:                      [ equal_zero( uplevels )
7511:                         | true :  .tPushParamB  @EmitValue( decl )
7521:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7541:                      ]
7541:                ]
7541:          ]
      
7553:       | nFileType :
7555:          #eNotImplemented
      
7557:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7559:          [ oNodeType( decl )
7566:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7576:             | nLocalVar :
7578:                [ equal_zero( uplevels )
7585:                   | true :  .tPushLocalP  @EmitValue( decl )
7595:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7615:                ]
7615:             | nParam :
7617:                [ oNodeGetBoolean( decl, qInOut )
7627:                   | true :    % VAR param points to the var.  Auto dereference.
7628:                      [ equal_zero( uplevels )
7635:                         | true :  .tPushParamP  @EmitValue( decl )
7645:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7665:                      ]
7665:                      .tFetchP
7667:                   | * :
7672:                      [ equal_zero( uplevels )
7679:                         | true :  .tPushParamP  @EmitValue( decl )
7689:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7709:                      ]
7709:                ]               
7709:          ]
7721:          [
7721:             | '^' :             % dereferenced
7723:                oTypeSPop
7724:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7737:                @LValueIndexes
7739:                @FetchVar
7741:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7743:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7745:                @LValueIndexes
7747:                @FetchVar
7749:             | * :               % just ptr value alone
7756:          ]
      
7756:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7758:          [ oNodeType( decl )
7765:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7775:             | nLocalVar :
7777:                [ equal_zero( uplevels )
7784:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7794:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7814:                ]
7814:             | nParam :
7816:                [ oNodeGetBoolean( decl, qInOut )
7826:                   | true :    % VAR param points to the var.  Auto dereference.
7827:                      [ equal_zero( uplevels )
7834:                         | true :  .tPushParamP  @EmitValue( decl )
7844:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7864:                      ]
7864:                   | * :
7869:                      [ equal_zero( uplevels )
7876:                         | true :  .tPushAddrParam  @EmitValue( decl )
7886:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7906:                      ]
7906:                ]
7906:          ]
               % modify addr for subscripts, field references, etc
7918:          @LValueIndexes
               % get final value
7920:          @FetchVar
7922:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7951: FetchVar:
7953:    [ oTypeSNodeType
7955:       | nIntegerType, nEnumType :  .tFetchI
7958:       | nBooleanType, nByteType, nCharType :  .tFetchB
7962:       | nFileType :   #eNotImplemented
7966:       | nPointerType :             .tFetchP
7970:       | nUniversalPointerType :    #eCantDereference
7974:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7976:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
8005: LValueIndexes:
8007:    {[
8007:       | '[' :
8009:          [ oTypeSNodeType
8011:             | nArrayType :    @ArraySubscripts
8014:             | nPointerType :  @PointerArraySubscript
8018:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
8022:             | * :             #eNotArray
8035:          ]
8035:       | '.' :       @RecordFieldRef
8039:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8043:       | * :         >
8054:    ]};
      
      
8057: ArraySubscripts:
8059:    [ oTypeSNodeType
8061:       | nArrayType :
8062:       | * :       #eNotArray
8069:    ]
8069:    {
8069:       [ oTypeSNodeType
8071:          | nArrayType :
8072:          | * :    #eTooManySubscripts
8079:       ]
      
            % low subscript of this dimension
8079:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8096:       Node baseType
8096:       baseType = oNodeGet( oTypeSTop, qBaseType )
8108:       oTypeSPop
8109:       oTypeSPush( baseType )
      
8115:       @Expr
8117:       @RequireIntPop
            % adjust for low subscript
8119:       [ equal_zero( low )
8126:          | false :
8127:             .tPushConstI oEmitInt( low ) .tSubI
8137:          | * :
8142:       ]
      
            % multiply by element size
8142:       int size = oNodeGetInt( baseType, qSize )
8155:       [ equal( size, 1 )
8165:          | false :
8166:             .tPushConstI oEmitInt( size ) .tMultI
8176:          | * :
8181:       ]
      
            % update start address
8181:       .tAddPI
8183:       [
8183:          | ']' :  >
8187:          | ',' :
8189:       ]
8197:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8200: PointerArraySubscript:
8202:    [ oTypeSNodeType
8204:       | nPointerType :
8205:       | * :    #eCantDereference
8212:    ]
         % replace type stack with base type
8212:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8224:    oTypeSPop
8225:    oTypeSPush( baseType )
         
8231:    @Expr
8233:    @RequireIntPop
         % multiply by element size
8235:    int size = oNodeGetInt( baseType, qSize )
8248:    [ equal( size, 1 )
8258:       | false :
8259:          .tPushConstI  oEmitInt( size )  .tMultI
8269:       | * :
8274:    ]
         % update start address
8274:    .tAddPI
8276:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8279: ShortStringArraySubscript:
8281:    [ oTypeSNodeType
8283:       | nStrLitType, nShortStringType :
8284:       | * :    #eCantDereference
8293:    ]
8293:    oTypeSPop
8294:    oTypeSPush( CharType )
8300:    @Expr
8302:    @RequireIntPop
8304:    .tAddPI
8306:    ']';
      
      
8309: RecordFieldRef:
8311:    [ oTypeSNodeType
8313:       | nRecordType :
8314:       | * :    #eNotRecord
8321:    ]
8321:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8333:    pIdent
8335:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8340:    [ oNodeType( field )
8347:       | nRecordField :
8348:       | * :   #eNotRecordField
8355:    ]
8355:    oScopeEnd
8356:    int offset = oNodeGetInt( field, qValue )
8369:    [ equal_zero( offset )
8376:       | false :
8377:          .tPushConstI oEmitInt( offset ) .tAddPI
8387:       | * :
8392:    ]
      
         % replace the type on the type stack, with the field type
8392:    oTypeSPop
8393:    oTypeSPush( oNodeGet( field, qType ) )
8407:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8407: PointerAddition:
8409:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8421:    int elementSize = oNodeGetInt( elementType, qSize )
8434:    [ equal( elementSize, 1 )
8444:       | false :
8445:          .tPushConstI  oEmitInt( elementSize )
8453:          .tMultI
8455:       | * :
8460:    ]
8460:    .tAddPI
8463:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8463: PointerSubInt:
8465:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8477:    int elementSize = oNodeGetInt( elementType, qSize )
8490:    [ equal( elementSize, 1 )
8500:       | false :
8501:          .tPushConstI  oEmitInt( elementSize )
8509:          .tMultI
8511:       | * :
8516:    ]
8516:    .tSubPI
8519:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8519: PointerSubPointer:
8521:    .tSubP
8523:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8535:    int elementSize = oNodeGetInt( elementType, qSize )
8548:    [ equal( elementSize, 1 )
8558:       | false :
8559:          .tPushConstI  oEmitInt( elementSize )
8567:          .tDivI
8569:       | * :
8574:    ]
8574:    oTypeSPop
8575:    oTypeSPush( IntegerType )
8582:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8582: PointerDeref:
8584:    [ oTypeSNodeType
8586:       | nPointerType :
8587:       | nUniversalPointerType :   #eCantDereference
8591:       | * :       #eNotPointer
8600:    ]
8600:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8602:    Node theType = oTypeSTop
8607:    oTypeSPop
8608:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8622:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8622: CoerceType:
8624:    node_type nt = oTypeSNodeType
8629:    Node given = oTypeSTop
8634:    oTypeSPop
8635:    [ equal_node_type( nt, oTypeSNodeType )
8644:       | false :
               % Can we implicitly convert the value to the desired type?
8645:          [ oTypeSNodeType
8647:             | nIntegerType :
8648:                [ nt
8651:                   | nByteType :   .tCastBtoI  >>
8655:                   | * :
8660:                ]
8660:             | nByteType :
8662:                [ nt
8665:                   | nIntegerType :   .tCastItoB  >>
8669:                   | * :
8674:                ]
8674:             | nPointerType :
8676:                [ nt
8679:                   | nUniversalPointerType :  >>
8681:                   | nStrLitType :
8683:                      [ equal_node( oTypeSTop, PCharType )
8692:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8693:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8704:                         | * :
8709:                      ]
8709:                   | * :
8716:                ]
8716:             | nUniversalPointerType :
8718:                [ nt
8721:                   | nPointerType :  >>
8723:                   | * :
8728:                ]
8728:             | nShortStringType :
8730:                [ nt
8733:                   | nStrLitType :  >>
8735:                   | nCharType :
                           % Store char as a temp ShortString.
8737:                      oTypeSPush( CharType )
8743:                      int tempOffset = @MoveIntoTempShortString
8749:                      oTypeSPop
8750:                      >>
8751:                   | * :
8758:                ]
8758:             | * :
8771:          ]
8771:          #eTypeMismatch
8773:       | * :
8778:    ];
      
      
      % The expr stack contains two values, and their two types are on the type stack.
      % Typically these are two arguments of an operator; the key is that both types are flexible
      % (unlike CoerceType, where only the top type is flexible).
      % Coerce one type to match the other.  Generally the smaller type is coerced to the larger.  
      % Leave both values on the expr stack, and the single common type on the type stack. 
      %
8779: CoerceTypePair:
         % TO DO.  For now, require that the types match.
8781:    @MatchTypes
8784:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8784: CastType:
8786:    node_type nt = oTypeSNodeType
8791:    oTypeSPop
8792:    [ equal_node_type( nt, oTypeSNodeType )
8801:       | false :
               % Can we cast the value to the desired type?
8802:          [ oTypeSNodeType
8804:             | nIntegerType, nEnumType :
8805:                [ nt
8808:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8812:                   | nIntegerType, nEnumType :   >>
8815:                   | * :
8828:                ]
8828:             | nByteType, nCharType, nBooleanType :
8830:                [ nt
8833:                   | nByteType, nCharType, nBooleanType :   >>
8835:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8840:                   | * :
8853:                ]
8853:             | nPointerType :
8855:                [ nt
8858:                   | nUniversalPointerType :  >>
8860:                   | nStrLitType :
8862:                      [ equal_node( oTypeSTop, PCharType )
8871:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8872:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8883:                         | * :
8888:                      ]
8888:                   | * :
8895:                ]
8895:             | nUniversalPointerType :
8897:                [ nt
8900:                   | nPointerType :  >>
8902:                   | * :
8907:                ]
8907:             | nShortStringType :
8909:                [ nt
8912:                   | nStrLitType :  >>
8914:                   | nCharType :
                           % Store char as a temp ShortString.
8916:                      oTypeSPush( CharType )
8922:                      int tempOffset = @MoveIntoTempShortString
8928:                      oTypeSPop
8929:                      >>
8930:                   | * :
8937:                ]
8937:             | * :
8956:          ]
8956:          #eTypeMismatch
8958:       | * :
8963:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
      % This is used when passing a variable to a VAR parameter, so essentially no coercion
      % can be allowed.  The called method will interact with the actual variable using the
      % formal parameter type, so they must agree.
      %
8964: MatchTypes:
8966:    node_type nt = oTypeSNodeType
8971:    oTypeSPop
8972:    [ equal_node_type( nt, oTypeSNodeType )
8981:       | false :
               % Some very minor implicit conversion is allowed even here,
               % but must not affect the value size.
8982:          [ oTypeSNodeType
8984:             | nPointerType :
8985:                [ nt
8988:                   | nUniversalPointerType :  >>
8990:                   | * :
8995:                ]
8995:             | nUniversalPointerType :
8997:                [ nt
9000:                   | nPointerType :  >>
9002:                   | * :
9007:                ]
9007:             | * :
9014:          ]
9014:          #eTypeMismatch
9016:       | * :
9021:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9022: RequireIntPop:
9024:    [ oTypeSNodeType
9026:       | nIntegerType :
9027:       | * :          #eNotInteger
9034:    ]
9034:    oTypeSPop;
      
9036: RequireInt:
9038:    [ oTypeSNodeType
9040:       | nIntegerType :
9041:       | * :          #eNotInteger
9048:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9049: PromoteToIntPop:
9051:    [ oTypeSNodeType
9053:       | nIntegerType :
9054:       | nByteType :        .tCastBtoI
9058:       | * :                #eNotInteger
9067:    ]
9067:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9069: PromoteToInt:
9071:    [ oTypeSNodeType
9073:       | nIntegerType :
9074:       | nByteType :        .tCastBtoI
9078:                            oTypeSPop
9079:                            oTypeSPush( IntegerType )
9085:       | * :                #eNotInteger
9094:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9095: PromoteToIntOptional:
9097:    [ oTypeSNodeType
9099:       | nByteType :        .tCastBtoI
9102:                            oTypeSPop
9103:                            oTypeSPush( IntegerType )
9109:       | * :
9114:    ];
      
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
9115: PromoteToDoublePop:
9117:    [ oTypeSNodeType
9119:       | nDoubleType :
9120:       | nIntegerType :     .tCastItoD
9124:                            oTypeSPop
9125:                            oTypeSPush( DoubleType )
9131:       | nByteType :        .tCastBtoI
9135:                            .tCastItoD
9137:                            oTypeSPop
9138:                            oTypeSPush( DoubleType )
9144:       | * :                #eNotDouble
9155:    ]
9155:    oTypeSPop;
      
      
9157: RequireBoolPop:
9159:    [ oTypeSNodeType
9161:       | nBooleanType :
9162:       | * :          #eNotBoolean
9169:    ]
9169:    oTypeSPop;
      
9171: RequireBool:
9173:    [ oTypeSNodeType
9175:       | nBooleanType :
9176:       | * :          #eNotBoolean
9183:    ];
      
      
9184: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
9184: Statement:
9186:    [
9186:       | pWriteln :     @WritelnStmt
9190:       | pWrite :       @WriteStmt
9194:       | pReadln :      @ReadlnStmt
9198:       | pRead :        @ReadStmt
9202:       | pIf :          @IfStmt
9206:       | pWhile :       @WhileStmt
9210:       | pFor :         @ForStmt
9214:       | pRepeat :      @RepeatStmt
9218:       | pBreak :       @BreakStmt
9222:       | pContinue :    @ContinueStmt
9226:       | pBegin :       @BeginStmt
9230:       | pIdent :       @LabelOrAssignOrCallStmt
9234:       | pCase :        @CaseStmt
9238:       | pGoto :        @GotoStmt
9242:       | pIntLit :      % should be an integer label
9244:                        oChangeIntLitToLabelIdent
9245:                        @LabelOrAssignOrCallStmt
9247:       | * :            % null statement : don't accept any tokens
9280:    ];
      
      
9281: LabelOrAssignOrCallStmt:
9283:    Node decl = oScopeFindRequire
9288:    @ResolveUnitRef( decl )
9295:    [ oNodeType( decl )
9302:       | nLabel :                          @LabelDefinition( decl )
9310:                                           @Statement
9312:       | nProc :                           @Call( decl )
9321:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9323:                                           @AssignStmt( decl )
9330:       | nFunc :                           @AssignResultStmt( decl )
9339:       | * :                               #eBadStatement
9358:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9359: LabelDefinition( Node decl ):
9361:    [ oNodeGetBoolean( decl, qDefined )
9371:       | true :  #eAlreadyDefined
9374:       | * :
9379:    ]
9379:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9394:    oNodeSetBoolean( decl, qDefined, true )
9406:    ':'
9409:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9409: AssignStmt( Node decl ):
9411:    @LValueFromDecl( decl, true )
9421:    ':=' 
9423:    @Expr
9425:    @CoerceType
9427:    @Assign
9430:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9430: Assign:
9432:    [ oTypeSNodeType
9434:       | nIntegerType, nEnumType :  .tAssignI
9437:       | nBooleanType, nByteType, nCharType :  .tAssignB
9441:       | nDoubleType :  .tAssignD
9445:       | nFileType :   #eNotImplemented
9449:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9453:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9455:           int size = oNodeGetInt( oTypeSTop, qSize )
9467:           .tCopy  oEmitInt( size )    % multi-word copy
9475:    ]
9503:    oTypeSPop
9505:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9505: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9507:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9523:       | false :   #eNotCurrentFunction
9526:       | * :
9531:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9531:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9546:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9559:    ':='
9561:    @Expr
9563:    @CoerceType
9565:    [ oTypeSNodeType
9567:       | nIntegerType, nEnumType : .tAssignI
9570:       | nBooleanType, nByteType, nCharType :  .tAssignB
9574:       | nDoubleType :  .tAssignD
9578:       | nFileType :   #eNotImplemented
9582:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9586:       | nArrayType, nRecordType, nShortStringType :
9588:           int size = oNodeGetInt( oTypeSTop, qSize )
9600:           .tCopy  oEmitInt( size )    % multi-word copy
9608:    ]
9636:    oTypeSPop
9638:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9638: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9640:    pIdent
9642:    Node decl = oScopeFindRequire
9647:    @ResolveUnitRef( decl )
9654:    @LValueFromDecl( decl, writeable )
9665:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9665: LValueFromDecl( Node decl, boolean writeable ):
9667:    [ oNodeType( decl )
9674:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9675:          @LValueVar( decl, writeable )
      
9685:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9687:          oTypeSPush( oNodeGet( decl, qType ) )
9700:          '('
9702:          @LValueExpr( writeable )
9709:          ')'
9711:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9713:          [ oTypeSNodeType
9715:             | nPointerType :
9716:                [
9716:                   | '[' :
                           % dereference the pointer var first
9718:                      .tFetchP
9720:                      @PointerArraySubscript
9722:                   | * :
9727:                ]
9727:             | * :
9732:          ]
               % additional subscripts, if any
9732:          @LValueIndexes
       
9734:       | * :  #eNotVar
9749:    ]
9750:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9750: LValueCastType:
9752:    node_type nt = oTypeSNodeType
9757:    oTypeSPop
9758:    [ equal_node_type( nt, oTypeSNodeType )
9767:       | false :
               % Can we cast the value to the desired type?
9768:          [ oTypeSNodeType
9770:             | nIntegerType, nEnumType :
9771:                [ nt
9774:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9778:                   | nIntegerType, nEnumType :   >>
9781:                   | * :
9794:                ]
9794:             | nByteType, nCharType, nBooleanType :
9796:                [ nt
9799:                   | nByteType, nCharType, nBooleanType :   >>
9801:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9806:                   | * :
9819:                ]
9819:             | nPointerType :
9821:                [ nt
9824:                   | nUniversalPointerType :  >>
9826:                   | * :
9831:                ]
9831:             | nUniversalPointerType :
9833:                [ nt
9836:                   | nPointerType :  >>
9838:                   | * :
9843:                ]
9843:             | nShortStringType :
9845:                [ nt
9848:                   | nStrLitType :  >>
9850:                   | * :
9855:                ]
9855:             | * :
9874:          ]
9874:          #eTypeMismatch
9876:       | * :
9881:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9882: LValueVar( Node decl, boolean writeable ):
9884:    [ oNodeType( decl )
9891:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9901:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9912:       | nParam :
9914:          [ oNodeGetBoolean( decl, qInOut )
9924:             | true :   % VAR param points to variable.  No dereference.
9925:                        .tPushParamP @EmitValue( decl )
9934:             | * :      .tPushAddrParam @EmitValue( decl )
9948:          ]
9948:       | nTypedConst :
9950:          [ writeable
9953:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9963:             | * :      #eNotVar
9970:          ]
9970:       | * :            #eNotVar
9983:    ]
      
9983:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9996:    [ oTypeSNodeType
9998:       | nPointerType :
9999:          [
9999:             | '[' :
                     % dereference the pointer var first
10001:                .tFetchP
10003:                @PointerArraySubscript
10005:             | * :
10010:          ]
10010:       | * :
10015:    ]
         % additional subscripts, if any
10015:    @LValueIndexes
10018:    ;
      
      
10018: IncVar( Node decl ):
10020:    @LValueVar( decl, true )
10030:    @RequireIntPop
10032:    @VarExpr( decl )
10039:    oTypeSPop
10040:    .tIncI
10042:    .tAssignI;
      
10045: DecVar( Node decl ):
10047:    @LValueVar( decl, true )
10057:    @RequireIntPop
10059:    @VarExpr( decl )
10066:    oTypeSPop
10067:    .tDecI
10069:    .tAssignI;
      
      
10072: IfStmt:
10074:    Label falseLabel = labelNull
      
10080:    @BooleanExprControlFlow( falseLabel )
10087:    pThen
10089:    @Statement
10091:    [
10091:       | pElse :
10093:          Label doneLabel = oLabelNew
      
10098:          .tJump  oEmitLabel( doneLabel )
10106:          .tLabel oEmitLabel( falseLabel )
10114:          @Statement
10116:          .tLabel oEmitLabel( doneLabel )
      
10124:       | * :
10129:          .tLabel oEmitLabel( falseLabel )
10137:    ];
      
      
10138: ForStmt:
10140:    pIdent
      
10142:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10147:    @LValueVar( decl, true )
10157:    @RequireIntPop
      
10159:    ':='
      
10161:    @Expr
10163:    @RequireIntPop
10165:    .tAssignI
      
10167:    Label breakLabel = oLabelNew
      
10172:    Label checkLabel = oLabelNew
10177:    .tJump  oEmitLabel( checkLabel )
      
10185:    Label continueLabel = oLabelNew
10190:    .tLabel  oEmitLabel( continueLabel )
10198:    [
10198:       | pTo :
10200:          @IncVar( decl )
10207:          .tLabel  oEmitLabel( checkLabel )
10215:          @VarExpr( decl )  oTypeSPop
10223:          @Expr
10225:          @RequireIntPop
10227:          .tGreaterI
10229:          .tJumpTrue  oEmitLabel( breakLabel )
10237:       | pDownto :
10239:          @DecVar( decl )
10246:          .tLabel  oEmitLabel( checkLabel )
10254:          @VarExpr( decl )  oTypeSPop
10262:          @Expr
10264:          @RequireIntPop
10266:          .tLessI
10268:          .tJumpTrue  oEmitLabel( breakLabel )
10276:    ]
10284:    oLoopPush( continueLabel, breakLabel )
10293:    pDo
10295:    @Statement
10297:    .tJump  oEmitLabel( continueLabel )
10305:    .tLabel  oEmitLabel( breakLabel )
10313:    oLoopPop;
      
      
10315: RepeatStmt:
10317:    Label continueLabel = oLabelNew
10322:    .tLabel  oEmitLabel( continueLabel )
      
10330:    Label breakLabel = oLabelNew
      
10335:    oLoopPush( continueLabel, breakLabel )
10344:    @Statement
10346:    {[
10346:       | ';' :
10348:          @Statement
10350:       | pUntil :
10352:          Label falseLabel
10352:          @BooleanExprControlFlow( falseLabel )
10359:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10373:          >
10375:    ]}
10385:    .tLabel  oEmitLabel( breakLabel )
10393:    oLoopPop;
      
      
10395: WhileStmt:
10397:    Label continueLabel = oLabelNew
10402:    .tLabel  oEmitLabel( continueLabel )
      
10410:    Label breakLabel
10410:    @BooleanExprControlFlow( breakLabel )
      
10417:    oLoopPush( continueLabel, breakLabel )
10426:    pDo
10428:    @Statement
10430:    .tJump  oEmitLabel( continueLabel )
10438:    .tLabel  oEmitLabel( breakLabel )
10446:    oLoopPop;
      
      
10448: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10450:    [ equal_label( oLoopContinueLabel, labelNull )
10459:       | true :
10460:          #eNotInALoop
10462:       | false :
10464:          .tJump  oEmitLabel( oLoopContinueLabel )
10471:    ];
      
      
10480: BreakStmt:
10482:    [ equal_label( oLoopBreakLabel, labelNull )
10491:       | true :
10492:          #eNotInALoop
10494:       | false :
10496:          .tJump  oEmitLabel( oLoopBreakLabel )
10503:    ];
      
      
10512: CaseStmt:
10514:    Code tableCode = oCodeNew
10519:    Label tableLabel = oLabelNew
10524:    Label doneLabel = oLabelNew
10529:    Label otherwiseLabel = doneLabel
10535:    boolean isString = false
      
10541:    @Expr
         % Leave the expr type on the type stack throughout case statement
10543:    [ oTypeSNodeType
10545:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10554:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10564:       | nShortStringType, nStrLitType :        isString = true
10572:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10580:       | * :     #eNotAllowed
10599:    ]
10599:    pOf
      
10601:    {
10601:       [
10601:          | pOtherwise, pElse :
10603:             otherwiseLabel = oLabelNew
10608:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10616:             {[
10616:                | pEnd :  >
10620:                | * :
10625:                   @Statement
10627:                   [
10627:                      | ';' :
10629:                      | * :   pEnd  >
10638:                   ]
10638:             ]}
10640:             >
      
10642:          | pEnd :
                  % Reached end with no otherwise clause
10644:             >
      
10646:          | * :
10655:             Label caseLabel = oLabelNew
10660:             oCodePush( tableCode )
10666:             {
10666:                @ConstExpr
10668:                @ConstCoerceType
10670:                int val
10670:                [ isString
10673:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10683:                   | false :   val = oValueTop
10690:                ]
10698:                oValuePop
10699:                [
10699:                   | '..' :  @ConstExpr
10703:                             @ConstCoerceType
10705:                             int highval
10705:                             [ isString
10708:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10718:                                | false :  highval = oValueTop
10725:                             ]
10733:                             oValuePop
10734:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10754:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10773:                ]
10773:                [
10773:                   | ',' :
10775:                   | * :  >
10782:                ]
10782:             }
10784:             oCodePop
10785:             ':'
10787:             .tLabel  oEmitLabel( caseLabel )
10795:             @Statement
10797:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10805:             [
10805:                | ';' :
10807:                | * :
10812:             ]
                  
10812:       ]
         
10812:    }
      
10814:    .tLabel  oEmitLabel( tableLabel )
10822:    oEmitCode( tableCode )
10828:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10836:    .tLabel  oEmitLabel( doneLabel )
10844:    oTypeSPop
10846:    ;
      
      
10846: GotoStmt:
10848:    [
10848:       | pIdent :
10850:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10852:          oChangeIntLitToLabelIdent
10853:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10861:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10870:    oNodeSetBoolean( decl, qUsed, true )
10882:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10898:    ;
      
      
10898: BeginStmt:
10900:    @Statement
10902:    {[
10902:       | ';' :   @Statement
10906:       | pEnd :  >
10910:    ]};
      
      
10921: WritelnStmt:
10923:    @WriteStmt
10925:    .tWriteCR;
      
      
10928: WriteStmt:
10930:    [
10930:       | '(' :
10932:          {
10932:             @Expr
10934:             [ oTypeSNodeType
10936:                | nIntegerType :             .tWriteI
10939:                | nBooleanType :             .tWriteBool
10943:                | nByteType :                .tCastBtoI  .tWriteI
10949:                | nCharType :                .tWriteChar
10953:                | nDoubleType :              .tWriteD
10957:                | nShortStringType, nStrLitType :   .tWriteShortStr
10961:                | nFileType :                #eNotImplemented
10965:                | nEnumType :
                        % write name via table lookup
10967:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10981:                   .tWriteEnum
10983:                | nPointerType :
10985:                   [ equal_node( oTypeSTop, PCharType )
10994:                      | true :               .tWritePChar
10997:                      | * :                  .tWriteP
11004:                   ]
11004:                | nUniversalPointerType :    .tWriteP
11008:                | * :                        #eNotAllowed
11035:             ]
11035:             oTypeSPop
11036:             [
11036:                | ')' : >
11040:                | ',' :
11042:             ]
11050:          }
11052:       | * :
11057:    ];
      
      
11058: ReadlnStmt:
11060:    @ReadStmt
11062:    .tReadCR;
      
      
11065: ReadStmt:
11067:    [
11067:       | '(' :
11069:          {
11069:             @LValueExpr( true )
11076:             [ oTypeSNodeType
11078:                | nIntegerType :      .tReadI
11081:                | nCharType :         .tReadChar
11085:                | nShortStringType :  
11087:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
11106:                    .tReadShortStr  oEmitInt( capacity )
11114:                | * :                 #eNotAllowed
11125:             ]
11125:             oTypeSPop
11126:             [
11126:                | ')' : >
11130:                | ',' :
11132:             ]
11140:          }
11142:       | * :
11147:    ];
11148: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
11148: MoveIntoTempShortString >> int:
11150:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
11160:    [ oTypeSNodeType
11162:       | nShortStringType, nStrLitType :
11163:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
11171:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
11173:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
11188:       | nCharType :
               % temp[0] = 1
11190:          .tPushAddrLocal  oEmitInt( tempOffset )
11198:          .tPushConstI  oEmitInt( 1 )
11206:          .tAssignB
               % temp[1] = value
11208:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11223:          .tSwap
11225:          .tAssignB
11227:       | * :   #eTypeMismatch
11238:    ]
11238:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11239:    .tPushAddrLocal  oEmitInt( tempOffset )
11247:    oTypeSPush( ShortStringType )
11253:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11257: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11259:    .tAllocActuals  oEmitInt( 16 )
11267:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11279:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11291:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11300:    .tFreeActuals  oEmitInt( 16 )
11308:    oTypeSPop
11309:    oTypeSPop
11311:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11311: ShortStringAppendChar:
         % Note at the moment I don't align params
11313:    .tAllocActuals  oEmitInt( 12 )
11321:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11333:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11345:    .tCall  @EmitValue( System_ShortStringAppendChar )
11354:    .tFreeActuals  oEmitInt( 12 )
11362:    oTypeSPop
11363:    oTypeSPop
11365:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11365: ShortStringCmp:
11367:    .tAllocActualsCdecl  oEmitInt( 24 )
11375:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11387:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11399:    int tempOffset = oScopeAllocType( IntegerType )
11409:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11427:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11436:    .tPushLocalI  oEmitInt( tempOffset )
11444:    .tFreeActuals  oEmitInt( 24 )
11452:    oTypeSPop
11453:    oTypeSPush( IntegerType )
11460:    ;
11460: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11460: Call( Node method ):
11462:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11474:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11487:    Node resultType
11487:    int tempOffset
      
11487:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11504:    [ isFunc
11507:       | true :
11508:          resultType = oNodeGet( method, qType )
11521:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11531:       | * :
11536:    ]
         
      
11536:    Node paramScope = oNodeGet( method, qParams )
11549:    int actualsSize = oNodeGetInt( paramScope, qSize )
11562:    [ cdecl
11565:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11574:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11584:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11592:    [ greater( @DeclLevel( method ), 0 )
11607:       | true :
11608:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11616:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11635:          .tAssignP
11637:       | * :
11642:    ]
      
      
11642:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11655:    Node param = oNodeIterValue( paramIter )
11665:    [
11665:       | '(' :
            
11667:          {
11667:             [ oNodeNull( param )
11674:                | true : >
11677:                | * :
11682:             ]
      
11682:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11695:             .tPushAddrActual oEmitInt( offset )
11703:             oTypeSPush( oNodeGet( param, qType ) )
      
11716:             [ oNodeGetBoolean( param, qInOut )
11726:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11727:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11734:                           @MatchTypes
      
11736:                           .tAssignP
      
11738:                | false :  @Expr
11742:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11744:                           [ oTypeSNodeType
11746:                              | nIntegerType, nEnumType : .tAssignI
11749:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11753:                              | nDoubleType :  .tAssignD
11757:                              | nFileType :   #eNotImplemented
11761:                              | nPointerType, nUniversalPointerType :  .tAssignP
11765:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11767:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11779:                                  .tCopy  oEmitInt( size )    % multi-word copy
11787:                           ]
11815:             ]
11823:             oTypeSPop
      
11824:             oNodeIterNext( paramIter )
11830:             param = oNodeIterValue( paramIter )
11840:             [ oNodeNull( param )
11847:                | true :  >
11850:                | false :
11852:             ]
      
11860:             ','
11862:          }
      
11864:          ')'
      
11866:       | * :
11871:    ]
      
11871:    [ oNodeNull( param )
11878:       | false :    #eMissingParameter
11881:       | * :
11886:    ]
      
11886:    [ isFunc
11889:       | true :
               % Pass result temp as an additional VAR parameter.
11890:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11905:          .tPushAddrLocal  oEmitInt( tempOffset )
11913:          .tAssignP
11915:       | * :
11920:    ]
      
11920:    [ cdecl
11923:       | true :
11924:          .tCallCdecl  @EmitValue( method )
11933:       | false :
11935:          .tCall   @EmitValue( method )
11944:    ]
      
11952:    [ isFunc
11955:       | true :
               % push return value from temp
11956:          oTypeSPush( resultType )
      
11962:          [ oTypeSNodeType
11964:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11973:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11983:             | nFileType :  #eNotImplemented
11987:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11997:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11999:                                .tPushAddrLocal  oEmitInt( tempOffset )
12007:          ]
12033:       | * :
12038:    ]
         
12038:    .tFreeActuals  oEmitInt( actualsSize )
12047:    ;
      
      
      
      % Called on first use of an extern method
      %
12047: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
12049:    int strAddr
12049:    String externalName = oNodeGetString( method, qExternalName )
12062:    [ equal_string( externalName, stringNull )
12072:       | true :
12073:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
12094:       | false :
12096:          strAddr = oStringAllocLit( externalName )
12106:    ]
12114:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
12130:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
12130: CallBuiltInFunc( Node method ):
      
         % Ord(x)
12132:    [ oNodeEqual( method, BuiltIn_Ord )
12142:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
12143:          '('
12145:          @Expr
12147:          [ oTypeSNodeType
12149:             | nIntegerType, nEnumType :
12150:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
12154:             | * :  #eTypeMismatch
12169:          ]
12169:          oTypeSPop
12170:          oTypeSPush( IntegerType )
12176:          ')'
12178:          >>
12179:       | * :
12184:    ]
      
         % Chr(x)
12184:    [ oNodeEqual( method, BuiltIn_Chr )
12194:       | true :
               % parameter is integer
               % result is char
12195:          '('
12197:          @Expr
12199:          [ oTypeSNodeType
12201:             | nIntegerType :    .tCastItoB
12204:             | nByteType :
12206:             | * :  #eTypeMismatch
12215:          ]
12215:          oTypeSPop
12216:          oTypeSPush( CharType )
12222:          ')'
12224:          >>
12225:       | * :
12230:    ]
      
         % Pred(x)
12230:    [ oNodeEqual( method, BuiltIn_Pred )
12240:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12241:          '('
12243:          @Expr
12245:          [ oTypeSNodeType
12247:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12248:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12257:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12260:                   | * :
12265:                ]
12265:             | * :  #eTypeMismatch
12272:          ]
12272:          .tDecI
12274:          ')'
12276:          >>
12277:       | * :
12282:    ]
      
         % Succ(x)
12282:    [ oNodeEqual( method, BuiltIn_Succ )
12292:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12293:          '('
12295:          @Expr
12297:          [ oTypeSNodeType
12299:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12300:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12309:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12312:                   | * :
12317:                ]
12317:             | * :  #eTypeMismatch
12324:          ]
12324:          .tIncI
12326:          ')'
12328:          >>
12329:       | * :
12334:    ]
      
         % Sizeof(x)
12334:    [ oNodeEqual( method, BuiltIn_Sizeof )
12344:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12345:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12347:          Code dummyCode = oCodeNew
12352:          oCodePush( dummyCode )
12358:          @ExprAllowTypeName
12360:          oCodePop
12361:          oCodeDiscard( dummyCode )
12367:          Node theType = oTypeSTop
12372:          oTypeSPop
12373:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12388:          oTypeSPush( IntegerType )
12394:          ')'
12396:          >>
      
12397:       | * :
12402:    ]
      
12402:    #eNotImplemented
12405:    ;
      
12405: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12405: newType( node_type nt, int size ) >> Node:
12407:   Node node = oNodeNew( nt )
12417:   oNodeSetInt( node, qSize, size )
12429:   oTypeAdd( node )
12435:   >> node
12439:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12439: TypeRef( out Node resultType ):
12441:    [
12441:       | pIdent :           % previously named type (including intrinsics)
12443:          Node decl = oScopeFindRequire
12448:          @ResolveUnitRef( decl )
12455:          [ oNodeType( decl )
12462:             | nTypeDecl :
12463:                resultType = oNodeGet( decl, qType )
12476:             | * :
12481:                #eNotType
12483:                resultType = IntegerType
12489:          ]
         
12489:       | pArray :
12491:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12493:          NodeVec dimensions = oNodeVecNew
      
12498:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12498:             Node subrange = oNodeNew( nSubrangeType )
      
12508:             @ConstExpr
12510:             oNodeSetInt( subrange, qLow, oValueTop )
12521:             oValuePop
12522:             '..'
12524:             @ConstExpr
12526:             oNodeSetInt( subrange, qHigh, oValueTop )
12537:             oValuePop
      
12538:             @ConstMatchTypes
12540:             oNodeSet( subrange, qBaseType, oTypeSTop )
12551:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12569:             oTypeSPop
12570:             oTypeAdd( subrange )
      
12576:             Node a = oNodeNew( nArrayType )
12586:             oNodeSet( a, qIndexType, subrange )
      
12598:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12607:             [
12607:                | ']' : >
12611:                | ',' :
12613:             ]
12621:          }
      
12623:          pOf
12625:          Node baseType
12625:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12632:          int dim = oNodeVecSize( dimensions )
      
12642:          {
12642:              dec(dim)
      
12648:              Node a = oNodeVecElement( dimensions, dim )
      
12661:              oNodeSet( a, qBaseType, baseType )
12673:              Node subrange = oNodeGet( a, qIndexType )
12686:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12713:              inc( width )
12719:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12745:              oTypeAdd( a )
12751:              baseType = a
      
12757:              [ equal_zero(dim)
12764:                  | true:  >
12767:                  | *:
12772:              ]
12772:          }
      
12774:          resultType = oNodeVecElement( dimensions, 0 )
12787:          oNodeVecDelete( dimensions )
      
12793:       | '^' :
12795:          Node theType
12795:          @TypeRef( theType )
12802:          resultType = @PointerTypeTo( theType )
      
12813:       | pRecord :
12815:          resultType = oNodeNew( nRecordType )
12825:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12834:          @VarDecl( nRecordField )
      
12841:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12853:          [ equal_zero( size )
12860:             | true : #eRecordEmpty
12863:             | * :
12868:          ]
      
12868:          pEnd
      
12870:          oNodeSet( resultType, qScope, oScopeCurrent )
12881:          oNodeSetInt( resultType, qSize, size )
12893:          oScopeEnd
12894:          oTypeAdd( resultType )
      
      
12900:       | '(' :
               % An enum type declaration.
12902:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12909:       | pSet :
12911:          pOf
12913:          Node theType
12913:          @TypeRef( theType )
12920:          #eNotImplemented
12922:       | * :       % this works for cases except where expr starts with an id
12937:          @ConstExpr '..' @ConstExpr
12943:          @ConstMatchTypes
12945:          #eNotImplemented
12947:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12948: EnumTypeRef( out Node resultType ):
      
12950:    resultType = oNodeNew( nEnumType )
12960:    int value = 0
12966:    int numValues = 0
12972:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12978:    Node outerScope = oScopeCurrent
12983:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12992:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12992:       pIdent
12994:       Node decl = @newIdent( nEnumValue, LAST_ID )
13007:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
13020:       oNodeSet( decl, qType, resultType )
13032:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
13044:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
13057:       oNodeSetInt( decl, qNameOffset, nameOffset )
13069:       oNodeSetInt( decl2, qNameOffset, nameOffset )
13081:       [
13081:          | '=', ':=' :
13083:             oTypeSPush( IntegerType )
13089:             @ConstExpr
13091:             @ConstCoerceType
13093:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
13094:             [ equal_zero( numValues )
13101:                | false :
13102:                   [ greater( oValueTop, value )
13111:                      | false :   #eEnumValueNotAscending
13114:                      | * :
13119:                   ]
13119:                | * :
13124:             ]
13124:             [ equal( value, oValueTop )
13133:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
13134:                   oNodeSetBoolean( resultType, qHasGap, true )
13146:                | * :
13151:             ]
13151:             value = oValueTop
13156:             oValuePop
13157:          | * :
13164:       ]
13164:       oNodeSetInt( decl, qValue, value )
13176:       oNodeSetInt( decl2, qValue, value )
13188:       oScopeDeclare( decl )
      
13194:       oScopeEnter( outerScope )
13200:       oScopeDeclare( decl2 )
13206:       oScopeEnd
      
13207:       inc( value )
13213:       inc( numValues )
13219:       [
13219:          | ',' :
13221:          | * :    >
13228:       ]
13228:    }
13230:    ')'
      
13232:    oNodeSet( resultType, qScope, oScopeCurrent )
13243:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13255:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13256:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13267:    oScopeEnter( globalScope )
13273:    int size = multiply( add( numValues, 1 ), 16 )
13293:    int addr = oScopeAlloc( size, 8 )
13306:    oScopeEnd
13307:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13319:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13339:    {
13339:       Node enumValue = oNodeIterValue( it )
13349:       [ oNodeNull( enumValue )
13356:          | true :  >
13359:          | * :
13364:       ]
13364:       .tPushAddrGlobal  oEmitInt( addr )
13372:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13387:       .tAssignI
13389:       addr = add( addr, 8 )
13402:       .tPushAddrGlobal  oEmitInt( addr )
13410:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13425:       .tAssignP
13427:       addr = add( addr, 8 )
13440:       oNodeIterNext( it )
13446:    }
         % final table entry
13448:    .tPushAddrGlobal  oEmitInt( addr )
13456:    .tPushConstI  oEmitInt( 0 )
13464:    .tAssignI
13466:    addr = add( addr, 8 )
13479:    .tPushAddrGlobal  oEmitInt( addr )
13487:    .tPushConstI  oEmitInt( 0 )
13495:    .tAssignP
13497:    addr = add( addr, 8 )
13510:    oCodePop
      
13511:    oTypeAdd( resultType )
13518:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13518: PointerTypeTo( Node theType ) >> Node:
13520:    Node ptrType = oNodeGet( theType, qPointerType )
13533:    [ oNodeNull( ptrType )
13540:       | true :
13541:          ptrType = oNodeNew( nPointerType )
13551:          oNodeSet( ptrType, qBaseType, theType )
13563:          oNodeSetInt( ptrType, qSize, 8 )
13575:          oTypeAdd( ptrType )
13581:          oNodeSet( theType, qPointerType, ptrType )
13593:       | * :
13598:    ]
13598:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13602: OrdinalLow( Node theType ) >> int:
13604:    [ oNodeType( theType )
13611:       | nIntegerType :  >> oMININT
13614:       | nBooleanType :  >> 0
13619:       | nCharType :     >> 0
13624:       | nEnumType :
13626:          Node enumScope = oNodeGet( theType, qScope )
13639:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13656:          >> oNodeGetInt( first, qValue )
13666:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13678:       | * :             #eNotOrdinalType
13693:                         >> 0
13696:    ];
      
      
      % Return the high value of an ordinal type
      %
13697: OrdinalHigh( Node theType ) >> int:
13699:    [ oNodeType( theType )
13706:       | nIntegerType :  >> oMAXINT
13709:       | nBooleanType :  >> 1
13714:       | nCharType :     >> 255
13719:       | nEnumType :
13721:          Node enumScope = oNodeGet( theType, qScope )
13734:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13751:          >> oNodeGetInt( last, qValue )
13761:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13773:       | * :             #eNotOrdinalType
13788:                         >> 0
13791:    ];
      
      
      
13792: Program:
13794:    Node t
      
13794:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13799:    oScopeBegin( 0, allocGlobal )
13808:    Node rootScope = oScopeCurrent
      
13813:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13815:    .tEnter  oEmitInt( 0 )
13823:    Label mainLabel = oLabelNew
      
13828:    .tAllocActuals  oEmitInt( 0 )
13836:    .tCall  oEmitLabel( mainLabel )
13844:    .tFreeActuals  oEmitInt( 0 )
13852:    .tReturn
      
13854:    pProgram
13856:    pIdent
      
13858:    Node program = oNodeNew( nProgram )
13868:    oNodeSetInt( program, qIdent, LAST_ID )
13879:    oNodeSet( workspace, qProgram, program )
      
      
13891:    [
13891:       | '(' :
13893:          pIdent      % input, output files
      
13895:          t = @newIdent( nVar, LAST_ID )
13908:          oNodeSet( t, qType, FileType )
13920:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13926:          ','
13928:          pIdent
      
13930:          t = @newIdent( nVar, LAST_ID )
13943:          oNodeSet( t, qType, FileType )
13955:          oScopeDeclareAlloc( t )
      
13961:          ')'
13963:       | * :
13968:    ]
13968:    ';'
      
13970:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13977:    [
13977:       | pUses :  @UsesClause( program )
13986:       | * :
13991:    ]
13991:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13998:    oScopeBegin( 0, allocGlobal )
14007:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
14012:    oScopeBegin( 0, allocDown )
14021:    oNodeSet( oScopeCurrent, qExtends, globalScope )
14032:    initScope = oScopeCurrent
14037:    oNodeSet( program, qMainRoutineScope, initScope )
14049:    oScopeEnd
      
14050:    @BlockDecls( nGlobalVar )
      
      
14057:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
14063:    boolean isMain = true
14069:    @BlockStmt( mainLabel, globalScope, isMain )
      
14082:    oScopeEnd   % main routine scope
      
14083:    '.'
14085:    @CheckForUndefinedLabels
14087:    oScopeEnd   % global scope
14088:    @EndUsedUnits( program )   % used units scopes
14096:    ;
      
      
      
      
14096: Block( node_type varNodeType, Label labelForBody ):
14098:    @BlockDecls( varNodeType )
14105:    @BlockStmt( labelForBody, oScopeCurrent, false )
14117:    @CheckForUndefinedLabels
14120:    ;
      
      
14120: BlockDecls( node_type varNodeType ):
14122:    {[
14122:       | pConst :     @ConstDecl
14126:       | pType :      @TypeDecl
14130:       | pVar :       @VarDecl( varNodeType )
14139:       | pLabel :     @LabelDecl
14143:       | pProcedure : @ProcDecl
14147:       | pFunction :  @FuncDecl
14151:       | * :          >
14168:    ]}
14170:    @CheckForUndefinedMethods
14173:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
14173: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
14176:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
14176: CheckForUndefinedLabels:
14178:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
14190:    {
14190:       Node decl = oNodeIterValue( it )
14200:       [ oNodeNull( decl )
14207:          | false :
14208:          | * :  >
14215:       ]
14215:       [ oNodeType( decl )
14222:          | nLabel :
14223:             [ oNodeGetBoolean( decl, qDefined )
14233:                | false :
14234:                   [ oNodeGetBoolean( decl, qUsed )
14244:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14247:                      | * :
14252:                   ]
14252:                | * :
14257:             ]
14257:          | * :
14262:       ]
14262:       oNodeIterNext( it )
14268:    }
14271:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14271: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14273:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14281:    int patchLS
14281:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14290:    [ isMain
14293:       | true :  @InitializeUnits
14296:       | * :
14301:    ]
      
         % insert any code for initialization of this scope's variables
14301:    Code initCode = oNodeGetCode( varScope, qInitCode )
14314:    oEmitCode( initCode )
14320:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14332:    @Statement
      
14334:    [ isMain
14337:       | true :  @FinalizeUnits
14340:       | * :
14345:    ]
      
14345:    .tReturn
      
14347:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14359:    oPatch( patchLS, localSpace )
14369:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14369: GetOrCreateInitCode( Node scope ) >> Code:
14371:    Code initCode = oNodeGetCode( scope, qInitCode )
14384:    [ equal_code( initCode, codeNull )
14394:       | true :
14395:          initCode = oCodeNew
14400:          oNodeSetCode( scope, qInitCode, initCode )
14412:       | * :
14417:    ]
14417:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14421: ScopeLevel >> int:
14423:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14433: DeclLevel( Node decl ) >> int:
14435:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14453: DeclUpLevels( Node decl ) >> int:
14455:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14471: newIdent( node_type nt, int id ) >> Node:
14473:   Node t = oNodeNew( nt )
14483:   oNodeSetInt( t, qIdent, id )
14495:   >> t
14499:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14499: EmitValue( Node decl ):
14501:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14515: DeclareBuiltInFunc( int id ) >> Node:
14517:    Node decl = @newIdent( nBuiltInFunc, id )
14531:    oScopeDeclare( decl )
14537:    >> decl;
      
      
14541: installBuiltIns:
      
         % initialize some other globals too
14543:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14549:    mysystemId = oId_mysystem
      
         % install built-in types
14554:    FileType = @newType( nFileType, 4 )
14568:    IntegerType = @newType( nIntegerType, 4 )
14582:    BooleanType = @newType( nBooleanType, 1 )
14596:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14610:    CharType = @newType( nCharType, 1 )
14624:    PCharType = @PointerTypeTo( CharType )
14635:    ByteType = @newType( nByteType, 1 )
14649:    SingleType = @newType( nSingleType, 4 )
14663:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14677:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14691:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14703:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14717:    ShortStringType = @newType( nShortStringType, 256 )
14731:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14743:    Node t
      
14743:    t = @newIdent( nTypeDecl, oId_File )
14756:    oNodeSet( t, qType, FileType )
14768:    oScopeDeclare( t )
      
14774:    t = @newIdent( nTypeDecl, oId_Integer )
14787:    oNodeSet( t, qType, IntegerType )
14799:    oScopeDeclare( t )
      
14805:    t = @newIdent( nTypeDecl, oId_Boolean )
14818:    oNodeSet( t, qType, BooleanType )
14830:    oScopeDeclare( t )
      
14836:    t = @newIdent( nTypeDecl, oId_Char )
14849:    oNodeSet( t, qType, CharType )
14861:    oScopeDeclare( t )
      
14867:    t = @newIdent( nTypeDecl, oId_Byte )
14880:    oNodeSet( t, qType, ByteType )
14892:    oScopeDeclare( t )
      
14898:    t = @newIdent( nTypeDecl, oId_Single )
14911:    oNodeSet( t, qType, SingleType )
14923:    oScopeDeclare( t )
      
14929:    t = @newIdent( nTypeDecl, oId_Double )
14942:    oNodeSet( t, qType, DoubleType )
14954:    oScopeDeclare( t )
      
14960:    t = @newIdent( nTypeDecl, oId_Pointer )
14973:    oNodeSet( t, qType, UniversalPointerType )
14985:    oScopeDeclare( t )
      
14991:    t = @newIdent( nTypeDecl, oId_ShortString )
15004:    oNodeSet( t, qType, ShortStringType )
15016:    oScopeDeclare( t )
      
         % Built-in constants
      
15022:    t = @newIdent( nConst, oId_True )
15035:    oNodeSet( t, qType, BooleanType )
15047:    oNodeSetInt( t, qValue, 1 )
15059:    oScopeDeclare( t )
      
15065:    t = @newIdent( nConst, oId_False )
15078:    oNodeSet( t, qType, BooleanType )
15090:    oNodeSetInt( t, qValue, 0 )
15102:    oScopeDeclare( t )
      
15108:    t = @newIdent( nConst, oId_Nil )
15121:    oNodeSet( t, qType, UniversalPointerType )
15133:    oNodeSetInt( t, qValue, 0 )
15145:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
15151:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
15161:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
15171:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
15181:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
15191:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
15202:    ;
      
15202: end
      
15202: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13792
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 26
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 25
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3213
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3269
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 14120
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 89
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 79
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 107
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 9184
1083: oInputChoice 1089
1085: oCall 9184
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 78
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 89
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 79
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 107
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 9184
1177: oInputChoice 1183
1179: oCall 9184
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 78
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 73
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 76
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 75
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 73
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 76
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 75
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14433
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 12047
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14471
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 22
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 22
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 14421
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13518
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 23
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 14096
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14471
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 22
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 22
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 14421
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13518
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 12439
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13518
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 23
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 14096
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 25
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14471
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 35
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 12439
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13518
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2683
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3568
2556: oTypeSNodeType
2557: oChoice 2640
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14471
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2661
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 19
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14471
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 34
2605: oPushResult
2606: oValueTopDouble
2607: oPushResult
2608: oNodeSetDouble
2609: oPop 3
2611: oJumpForward 2661
2613: oGetAddrLocal 2
2615: oPushResult
2616: oSetResult 18
2618: oPushResult
2619: oGetLocal 1
2621: oPushResult
2622: oCall 14471
2624: oPop 2
2626: oAssign
2627: oGetLocal 2
2629: oPushResult
2630: oSetResult 33
2632: oPushResult
2633: oValueTopString
2634: oPushResult
2635: oNodeSetString
2636: oPop 3
2638: oJumpForward 2661
2640: Choice Lookup Table
          42   2613
          33   2586
          38   2559
          37   2559
          44   2559
          31   2559
          36   2559
          30   2559
          34   2559
2659: oError 18
2661: oValuePop
2662: oGetLocal 2
2664: oPushResult
2665: oSetResult 21
2667: oPushResult
2668: oTypeSTop
2669: oPushResult
2670: oNodeSet
2671: oPop 3
2673: oTypeSPop
2674: oGetLocal 2
2676: oPushResult
2677: oScopeDeclare
2678: oPop 1
2680: oInput 6
2682: oReturn
2683: oLocalSpace 3
2685: oGetAddrLocal 1
2687: oPushResult
2688: oSetResult 26
2690: oPushResult
2691: LAST_ID
2692: oPushResult
2693: oCall 14471
2695: oPop 2
2697: oAssign
2698: oGetAddrLocal 2
2700: oPushResult
2701: oCall 12439
2703: oPop 1
2705: oGetLocal 1
2707: oPushResult
2708: oSetResult 21
2710: oPushResult
2711: oGetLocal 2
2713: oPushResult
2714: oNodeSet
2715: oPop 3
2717: oGetLocal 2
2719: oPushResult
2720: oNodeType
2721: oPop 1
2723: oChoice 2827
2725: oInput 7
2727: oGetLocal 2
2729: oPushResult
2730: oTypeSPush
2731: oPop 1
2733: oCall 3568
2735: oCall 4460
2737: oGetLocal 1
2739: oPushResult
2740: oSetResult 22
2742: oPushResult
2743: oValueTop
2744: oPushResult
2745: oNodeSetInt
2746: oPop 3
2748: oValuePop
2749: oTypeSPop
2750: oGetLocal 1
2752: oPushResult
2753: oScopeDeclare
2754: oPop 1
2756: oInput 6
2758: oJumpForward 2851
2760: oError 17
2762: oJumpForward 2851
2764: oGetGlobal 2
2766: oPushResult
2767: oScopeEnter
2768: oPop 1
2770: oGetAddrLocal 3
2772: oPushResult
2773: oGetLocal 2
2775: oPushResult
2776: oScopeAllocType
2777: oPop 1
2779: oAssign
2780: oScopeEnd
2781: oGetGlobal 2
2783: oPushResult
2784: oCall 14369
2786: oPop 1
2788: oPushResult
2789: oCodePush
2790: oPop 1
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oGetLocal 3
2800: oPushResult
2801: oNodeSetInt
2802: oPop 3
2804: oInput 7
2806: oGetLocal 2
2808: oPushResult
2809: oGetLocal 3
2811: oPushResult
2812: oCall 2852
2814: oPop 2
2816: oCodePop
2817: oGetLocal 1
2819: oPushResult
2820: oScopeDeclare
2821: oPop 1
2823: oInput 6
2825: oJumpForward 2851
2827: Choice Lookup Table
          41   2764
          39   2764
          29   2760
          43   2760
          38   2725
          37   2725
          44   2725
          31   2725
          36   2725
          30   2725
          34   2725
2850: oEndChoice
2851: oReturn
2852: oLocalSpace 10
2854: oGetParam 2
2856: oPushResult
2857: oNodeType
2858: oPop 1
2860: oChoice 3186
2862: oGetAddrLocal 1
2864: oPushResult
2865: oGetParam 2
2867: oPushResult
2868: oSetResult 38
2870: oPushResult
2871: oNodeGet
2872: oPop 2
2874: oAssign
2875: oGetAddrLocal 2
2877: oPushResult
2878: oGetParam 2
2880: oPushResult
2881: oSetResult 39
2883: oPushResult
2884: oNodeGet
2885: oPop 2
2887: oAssign
2888: oGetAddrLocal 3
2890: oPushResult
2891: oGetLocal 2
2893: oPushResult
2894: oCall 13602
2896: oPop 1
2898: oAssign
2899: oGetAddrLocal 4
2901: oPushResult
2902: oGetLocal 2
2904: oPushResult
2905: oCall 13697
2907: oPop 1
2909: oAssign
2910: oGetAddrLocal 5
2912: oPushResult
2913: oGetLocal 1
2915: oPushResult
2916: oSetResult 17
2918: oPushResult
2919: oNodeGetInt
2920: oPop 2
2922: oAssign
2923: oInput 15
2925: oGetAddrLocal 6
2927: oPushResult
2928: oGetLocal 3
2930: oAssign
2931: oGetLocal 1
2933: oPushResult
2934: oGetParam 1
2936: oPushResult
2937: oCall 2852
2939: oPop 2
2941: oGetLocal 6
2943: oPushResult
2944: oGetLocal 4
2946: oPushResult
2947: equal
2948: oPop 2
2950: oChoice 2958
2952: oJumpForward 2987
2954: oJumpForward 2964
2956: oJumpForward 2964
2958: Choice Lookup Table
           0   2956
           1   2952
2963: oEndChoice
2964: oInput 14
2966: oGetAddrParam 1
2968: oPushResult
2969: oGetParam 1
2971: oPushResult
2972: oGetLocal 5
2974: oPushResult
2975: add
2976: oPop 2
2978: oAssign
2979: oGetAddrLocal 6
2981: oPushResult
2982: inc
2983: oPop 1
2985: oJumpBack 2931
2987: oInput 16
2989: oJumpForward 3212
2991: oInput 15
2993: oGetAddrLocal 7
2995: oPushResult
2996: oGetParam 2
2998: oPushResult
2999: oSetResult 42
3001: oPushResult
3002: oNodeGet
3003: oPop 2
3005: oAssign
3006: oInputChoice 3010
3008: oJumpForward 3015
3010: Choice Lookup Table
           0   3008
3013: oJumpForward 3081
3015: oGetAddrLocal 8
3017: oPushResult
3018: oGetLocal 7
3020: oPushResult
3021: oScopeFindRequireInScope
3022: oPop 1
3024: oAssign
3025: oInput 13
3027: oGetAddrLocal 9
3029: oPushResult
3030: oGetLocal 8
3032: oPushResult
3033: oSetResult 21
3035: oPushResult
3036: oNodeGet
3037: oPop 2
3039: oAssign
3040: oGetAddrLocal 10
3042: oPushResult
3043: oGetParam 1
3045: oPushResult
3046: oGetLocal 8
3048: oPushResult
3049: oSetResult 22
3051: oPushResult
3052: oNodeGetInt
3053: oPop 2
3055: oPushResult
3056: add
3057: oPop 2
3059: oAssign
3060: oGetLocal 9
3062: oPushResult
3063: oGetLocal 10
3065: oPushResult
3066: oCall 2852
3068: oPop 2
3070: oInputChoice 3074
3072: oJumpForward 3079
3074: Choice Lookup Table
           6   3072
3077: oJumpForward 3081
3079: oJumpBack 3006
3081: oInput 16
3083: oJumpForward 3212
3085: oEmit 17
3087: oGetParam 1
3089: oPushResult
3090: oEmitInt
3091: oPop 1
3093: oGetParam 2
3095: oPushResult
3096: oTypeSPush
3097: oPop 1
3099: oCall 3568
3101: oCall 4460
3103: oEmit 15
3105: oValueTop
3106: oPushResult
3107: oEmitInt
3108: oPop 1
3110: oValuePop
3111: oTypeSPop
3112: oEmit 28
3114: oJumpForward 3212
3116: oEmit 17
3118: oGetParam 1
3120: oPushResult
3121: oEmitInt
3122: oPop 1
3124: oGetParam 2
3126: oPushResult
3127: oTypeSPush
3128: oPop 1
3130: oCall 3568
3132: oCall 4460
3134: oEmit 15
3136: oValueTop
3137: oPushResult
3138: oEmitInt
3139: oPop 1
3141: oValuePop
3142: oTypeSPop
3143: oEmit 27
3145: oJumpForward 3212
3147: oError 17
3149: oJumpForward 3212
3151: oEmit 17
3153: oGetParam 1
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oGetParam 2
3161: oPushResult
3162: oTypeSPush
3163: oPop 1
3165: oCall 3568
3167: oCall 4460
3169: oEmit 15
3171: oValueTop
3172: oPushResult
3173: oEmitInt
3174: oPop 1
3176: oValuePop
3177: oTypeSPop
3178: oEmit 29
3180: oJumpForward 3212
3182: oError 17
3184: oJumpForward 3212
3186: Choice Lookup Table
          29   3182
          43   3182
          38   3151
          37   3151
          33   3147
          44   3116
          31   3116
          36   3085
          30   3085
          34   3085
          41   2991
          39   2862
3211: oEndChoice
3212: oReturn
3213: oLocalSpace 2
3215: oInputChoice 3261
3217: oGetAddrLocal 1
3219: oPushResult
3220: oSetResult 20
3222: oPushResult
3223: LAST_ID
3224: oPushResult
3225: oCall 14471
3227: oPop 2
3229: oAssign
3230: oInput 7
3232: oGetAddrLocal 2
3234: oPushResult
3235: oCall 12439
3237: oPop 1
3239: oGetLocal 1
3241: oPushResult
3242: oSetResult 21
3244: oPushResult
3245: oGetLocal 2
3247: oPushResult
3248: oNodeSet
3249: oPop 3
3251: oGetLocal 1
3253: oPushResult
3254: oScopeDeclare
3255: oPop 1
3257: oInput 6
3259: oJumpForward 3266
3261: Choice Lookup Table
           0   3217
3264: oJumpForward 3268
3266: oJumpBack 3215
3268: oReturn
3269: oLocalSpace 6
3271: oInputChoice 3495
3273: oGetAddrLocal 1
3275: oPushResult
3276: oNodeVecNew
3277: oAssign
3278: oGetAddrLocal 2
3280: oPushResult
3281: oGetParam 1
3283: oPushResult
3284: LAST_ID
3285: oPushResult
3286: oCall 14471
3288: oPop 2
3290: oAssign
3291: oGetLocal 1
3293: oPushResult
3294: oGetLocal 2
3296: oPushResult
3297: oNodeVecAppend
3298: oPop 2
3300: oInputChoice 3306
3302: oInput 0
3304: oJumpForward 3311
3306: Choice Lookup Table
          14   3302
3309: oJumpForward 3313
3311: oJumpBack 3278
3313: oInput 13
3315: oGetAddrLocal 3
3317: oPushResult
3318: oCall 12439
3320: oPop 1
3322: oGetAddrLocal 4
3324: oPushResult
3325: oSetResult 0
3327: oAssign
3328: oGetLocal 4
3330: oPushResult
3331: oGetLocal 1
3333: oPushResult
3334: oNodeVecSize
3335: oPop 1
3337: oPushResult
3338: equal
3339: oPop 2
3341: oChoice 3382
3343: oGetAddrLocal 2
3345: oPushResult
3346: oGetLocal 1
3348: oPushResult
3349: oGetLocal 4
3351: oPushResult
3352: oNodeVecElement
3353: oPop 2
3355: oAssign
3356: oGetLocal 2
3358: oPushResult
3359: oSetResult 21
3361: oPushResult
3362: oGetLocal 3
3364: oPushResult
3365: oNodeSet
3366: oPop 3
3368: oGetLocal 2
3370: oPushResult
3371: oScopeDeclareAlloc
3372: oPop 1
3374: oGetAddrLocal 4
3376: oPushResult
3377: inc
3378: oPop 1
3380: oJumpForward 3387
3382: Choice Lookup Table
           0   3343
3385: oJumpForward 3389
3387: oJumpBack 3328
3389: oInputChoice 3482
3391: oGetLocal 1
3393: oPushResult
3394: oNodeVecSize
3395: oPop 1
3397: oChoice 3401
3399: oJumpForward 3406
3401: Choice Lookup Table
           1   3399
3404: oError 23
3406: oGetAddrLocal 5
3408: oPushResult
3409: oScopeCurrent
3410: oPushResult
3411: oCall 14369
3413: oPop 1
3415: oAssign
3416: oGetLocal 5
3418: oPushResult
3419: oCodePush
3420: oPop 1
3422: oGetAddrLocal 6
3424: oPushResult
3425: oSetResult 0
3427: oAssign
3428: oCall 14421
3430: oPushResult
3431: equal_zero
3432: oPop 1
3434: oChoice 3450
3436: oGetGlobal 3
3438: oPushResult
3439: oScopeEnter
3440: oPop 1
3442: oGetAddrLocal 6
3444: oPushResult
3445: oSetResult 1
3447: oAssign
3448: oJumpForward 3453
3450: Choice Lookup Table
           1   3436
3453: oGetLocal 2
3455: oPushResult
3456: oSetResult 1
3458: oPushResult
3459: oCall 9882
3461: oPop 2
3463: oCall 5024
3465: oCall 8622
3467: oCall 9430
3469: oGetLocal 6
3471: oChoice 3476
3473: oScopeEnd
3474: oJumpForward 3479
3476: Choice Lookup Table
           1   3473
3479: oCodePop
3480: oJumpForward 3485
3482: Choice Lookup Table
           7   3391
3485: oGetLocal 1
3487: oPushResult
3488: oNodeVecDelete
3489: oPop 1
3491: oInput 6
3493: oJumpForward 3500
3495: Choice Lookup Table
           0   3273
3498: oJumpForward 3502
3500: oJumpBack 3271
3502: oReturn
3503: oLocalSpace 2
3505: oInputChoice 3512
3507: oJumpForward 3518
3509: oChangeIntLitToLabelIdent
3510: oJumpForward 3518
3512: Choice Lookup Table
           1   3509
           0   3507
3517: oEndChoice
3518: oGetAddrLocal 1
3520: oPushResult
3521: oSetResult 27
3523: oPushResult
3524: LAST_ID
3525: oPushResult
3526: oCall 14471
3528: oPop 2
3530: oAssign
3531: oGetAddrLocal 2
3533: oPushResult
3534: oLabelNew
3535: oAssign
3536: oGetLocal 1
3538: oPushResult
3539: oSetResult 22
3541: oPushResult
3542: oGetLocal 2
3544: oPushResult
3545: oNodeSetLabel
3546: oPop 3
3548: oGetLocal 1
3550: oPushResult
3551: oScopeDeclare
3552: oPop 1
3554: oInputChoice 3558
3556: oJumpForward 3563
3558: Choice Lookup Table
          14   3556
3561: oJumpForward 3565
3563: oJumpBack 3505
3565: oInput 6
3567: oReturn
3568: oLocalSpace 0
3570: oCall 3825
3572: oInputChoice 3784
3574: oCall 3848
3576: oCall 4363
3578: oTypeSNodeType
3579: oChoice 3594
3581: oValueStringCmp
3582: oSetResult 0
3584: oPushResult
3585: oValuePush
3586: oPop 1
3588: oValueEqual
3589: oJumpForward 3600
3591: oValueEqualD
3592: oJumpForward 3600
3594: Choice Lookup Table
          33   3591
          42   3581
3599: oValueEqual
3600: oTypeSPop
3601: oGetGlobal 7
3603: oPushResult
3604: oTypeSPush
3605: oPop 1
3607: oJumpForward 3799
3609: oCall 3825
3611: oCall 4363
3613: oTypeSNodeType
3614: oChoice 3629
3616: oValueStringCmp
3617: oSetResult 0
3619: oPushResult
3620: oValuePush
3621: oPop 1
3623: oValueNotEqual
3624: oJumpForward 3635
3626: oValueNotEqualD
3627: oJumpForward 3635
3629: Choice Lookup Table
          33   3626
          42   3616
3634: oValueNotEqual
3635: oTypeSPop
3636: oGetGlobal 7
3638: oPushResult
3639: oTypeSPush
3640: oPop 1
3642: oJumpForward 3799
3644: oCall 3825
3646: oCall 4363
3648: oTypeSNodeType
3649: oChoice 3664
3651: oValueStringCmp
3652: oSetResult 0
3654: oPushResult
3655: oValuePush
3656: oPop 1
3658: oValueLess
3659: oJumpForward 3670
3661: oValueLessD
3662: oJumpForward 3670
3664: Choice Lookup Table
          33   3661
          42   3651
3669: oValueLess
3670: oTypeSPop
3671: oGetGlobal 7
3673: oPushResult
3674: oTypeSPush
3675: oPop 1
3677: oJumpForward 3799
3679: oCall 3825
3681: oCall 4363
3683: oTypeSNodeType
3684: oChoice 3699
3686: oValueStringCmp
3687: oSetResult 0
3689: oPushResult
3690: oValuePush
3691: oPop 1
3693: oValueGreater
3694: oJumpForward 3705
3696: oValueGreaterD
3697: oJumpForward 3705
3699: Choice Lookup Table
          33   3696
          42   3686
3704: oValueGreater
3705: oTypeSPop
3706: oGetGlobal 7
3708: oPushResult
3709: oTypeSPush
3710: oPop 1
3712: oJumpForward 3799
3714: oCall 3825
3716: oCall 4363
3718: oTypeSNodeType
3719: oChoice 3734
3721: oValueStringCmp
3722: oSetResult 0
3724: oPushResult
3725: oValuePush
3726: oPop 1
3728: oValueLessEqual
3729: oJumpForward 3740
3731: oValueLessEqualD
3732: oJumpForward 3740
3734: Choice Lookup Table
          33   3731
          42   3721
3739: oValueLessEqual
3740: oTypeSPop
3741: oGetGlobal 7
3743: oPushResult
3744: oTypeSPush
3745: oPop 1
3747: oJumpForward 3799
3749: oCall 3825
3751: oCall 4363
3753: oTypeSNodeType
3754: oChoice 3769
3756: oValueStringCmp
3757: oSetResult 0
3759: oPushResult
3760: oValuePush
3761: oPop 1
3763: oValueGreaterEqual
3764: oJumpForward 3775
3766: oValueGreaterEqualD
3767: oJumpForward 3775
3769: Choice Lookup Table
          33   3766
          42   3756
3774: oValueGreaterEqual
3775: oTypeSPop
3776: oGetGlobal 7
3778: oPushResult
3779: oTypeSPush
3780: oPop 1
3782: oJumpForward 3799
3784: Choice Lookup Table
          12   3749
          11   3714
          10   3679
           9   3644
           8   3609
           7   3574
3797: oJumpForward 3801
3799: oJumpBack 3572
3801: oReturn
3802: oLocalSpace 1
3804: oGetAddrLocal 1
3806: oPushResult
3807: oGetGlobal 25
3809: oAssign
3810: oGetAddrGlobal 25
3812: oPushResult
3813: oSetResult 1
3815: oAssign
3816: oCall 3568
3818: oGetAddrGlobal 25
3820: oPushResult
3821: oGetLocal 1
3823: oAssign
3824: oReturn
3825: oLocalSpace 0
3827: oCall 3848
3829: oInputChoice 3840
3831: oCall 4350
3833: oCall 3848
3835: oCall 4336
3837: oValueOr
3838: oJumpForward 3845
3840: Choice Lookup Table
          58   3831
3843: oJumpForward 3847
3845: oJumpBack 3829
3847: oReturn
3848: oLocalSpace 0
3850: oCall 3871
3852: oInputChoice 3863
3854: oCall 4350
3856: oCall 3871
3858: oCall 4336
3860: oValueAnd
3861: oJumpForward 3868
3863: Choice Lookup Table
          57   3854
3866: oJumpForward 3870
3868: oJumpBack 3852
3870: oReturn
3871: oLocalSpace 0
3873: oInputChoice 3882
3875: oCall 3871
3877: oCall 4350
3879: oValueNot
3880: oJumpForward 3887
3882: Choice Lookup Table
          59   3875
3885: oCall 3888
3887: oReturn
3888: oLocalSpace 0
3890: oCall 3947
3892: oInputChoice 3937
3894: oCall 3947
3896: oCall 4363
3898: oTypeSNodeType
3899: oChoice 3907
3901: oValueStringConcat
3902: oJumpForward 3913
3904: oValueAddD
3905: oJumpForward 3913
3907: Choice Lookup Table
          33   3904
          42   3901
3912: oValueAdd
3913: oJumpForward 3944
3915: oCall 3947
3917: oCall 4363
3919: oTypeSNodeType
3920: oChoice 3929
3922: oError 18
3924: oJumpForward 3935
3926: oValueSubD
3927: oJumpForward 3935
3929: Choice Lookup Table
          33   3926
          42   3922
3934: oValueSub
3935: oJumpForward 3944
3937: Choice Lookup Table
          26   3915
          25   3894
3942: oJumpForward 3946
3944: oJumpBack 3892
3946: oReturn
3947: oLocalSpace 0
3949: oCall 4007
3951: oInputChoice 3997
3953: oCall 4007
3955: oCall 4363
3957: oTypeSNodeType
3958: oChoice 3967
3960: oError 18
3962: oJumpForward 3973
3964: oValueMultD
3965: oJumpForward 3973
3967: Choice Lookup Table
          33   3964
          42   3960
3972: oValueMult
3973: oJumpForward 4004
3975: oCall 4007
3977: oCall 4363
3979: oTypeSNodeType
3980: oChoice 3989
3982: oError 18
3984: oJumpForward 3995
3986: oValueDivD
3987: oJumpForward 3995
3989: Choice Lookup Table
          33   3986
          42   3982
3994: oValueDiv
3995: oJumpForward 4004
3997: Choice Lookup Table
          24   3975
          23   3953
4002: oJumpForward 4006
4004: oJumpBack 3951
4006: oReturn
4007: oLocalSpace 0
4009: oInputChoice 4035
4011: oCall 4043
4013: oJumpForward 4042
4015: oCall 4043
4017: oTypeSNodeType
4018: oChoice 4027
4020: oError 18
4022: oJumpForward 4033
4024: oValueNegateD
4025: oJumpForward 4033
4027: Choice Lookup Table
          33   4024
          42   4020
4032: oValueNegate
4033: oJumpForward 4042
4035: Choice Lookup Table
          26   4015
          25   4011
4040: oCall 4043
4042: oReturn
4043: oLocalSpace 1
4045: oInputChoice 4306
4047: TOKEN_VALUE
4048: oPushResult
4049: oValuePush
4050: oPop 1
4052: oGetGlobal 6
4054: oPushResult
4055: oTypeSPush
4056: oPop 1
4058: oJumpForward 4335
4060: TOKEN_VALUE
4061: oPushResult
4062: oValuePush
4063: oPop 1
4065: oGetGlobal 9
4067: oPushResult
4068: oTypeSPush
4069: oPop 1
4071: oJumpForward 4335
4073: TOKEN_VALUE_DOUBLE
4074: oPushResult
4075: oValuePushDouble
4076: oPop 1
4078: oGetGlobal 13
4080: oPushResult
4081: oTypeSPush
4082: oPop 1
4084: oJumpForward 4335
4086: CURRENT_STRLIT
4087: oPushResult
4088: oValuePushString
4089: oPop 1
4091: oGetGlobal 15
4093: oPushResult
4094: oTypeSPush
4095: oPop 1
4097: oJumpForward 4335
4099: oCall 3568
4101: oInput 16
4103: oJumpForward 4335
4105: oGetAddrLocal 1
4107: oPushResult
4108: oScopeFindRequire
4109: oAssign
4110: oGetAddrLocal 1
4112: oPushResult
4113: oCall 244
4115: oPop 1
4117: oGetLocal 1
4119: oPushResult
4120: oNodeType
4121: oPop 1
4123: oChoice 4263
4125: oGetLocal 1
4127: oPushResult
4128: oCall 4758
4130: oPop 1
4132: oJumpForward 4288
4134: oGetLocal 1
4136: oPushResult
4137: oSetResult 22
4139: oPushResult
4140: oNodeGetInt
4141: oPop 2
4143: oPushResult
4144: oValuePush
4145: oPop 1
4147: oGetLocal 1
4149: oPushResult
4150: oSetResult 21
4152: oPushResult
4153: oNodeGet
4154: oPop 2
4156: oPushResult
4157: oTypeSPush
4158: oPop 1
4160: oJumpForward 4288
4162: oGetLocal 1
4164: oPushResult
4165: oSetResult 33
4167: oPushResult
4168: oNodeGetString
4169: oPop 2
4171: oPushResult
4172: oValuePushString
4173: oPop 1
4175: oGetLocal 1
4177: oPushResult
4178: oSetResult 21
4180: oPushResult
4181: oNodeGet
4182: oPop 2
4184: oPushResult
4185: oTypeSPush
4186: oPop 1
4188: oJumpForward 4288
4190: oGetLocal 1
4192: oPushResult
4193: oSetResult 22
4195: oPushResult
4196: oNodeGetInt
4197: oPop 2
4199: oPushResult
4200: oValuePush
4201: oPop 1
4203: oGetLocal 1
4205: oPushResult
4206: oSetResult 21
4208: oPushResult
4209: oNodeGet
4210: oPop 2
4212: oPushResult
4213: oTypeSPush
4214: oPop 1
4216: oJumpForward 4288
4218: oGetLocal 1
4220: oPushResult
4221: oSetResult 21
4223: oPushResult
4224: oNodeGet
4225: oPop 2
4227: oPushResult
4228: oTypeSPush
4229: oPop 1
4231: oInputChoice 4241
4233: oCall 3568
4235: oInput 16
4237: oCall 4581
4239: oJumpForward 4261
4241: Choice Lookup Table
          15   4233
4244: oGetGlobal 25
4246: oChoice 4256
4248: oSetResult 0
4250: oPushResult
4251: oValuePush
4252: oPop 1
4254: oJumpForward 4261
4256: Choice Lookup Table
           1   4248
4259: oError 32
4261: oJumpForward 4288
4263: Choice Lookup Table
          20   4218
          17   4190
          18   4162
          16   4134
          14   4125
4274: oError 1
4276: oSetResult 0
4278: oPushResult
4279: oValuePush
4280: oPop 1
4282: oGetGlobal 6
4284: oPushResult
4285: oTypeSPush
4286: oPop 1
4288: oJumpForward 4335
4290: oError 17
4292: oSetResult 0
4294: oPushResult
4295: oValuePush
4296: oPop 1
4298: oGetGlobal 14
4300: oPushResult
4301: oTypeSPush
4302: oPop 1
4304: oJumpForward 4335
4306: Choice Lookup Table
          20   4290
           0   4105
          15   4099
           3   4086
           2   4073
           4   4060
           1   4047
4321: oError 1
4323: oSetResult 0
4325: oPushResult
4326: oValuePush
4327: oPop 1
4329: oGetGlobal 6
4331: oPushResult
4332: oTypeSPush
4333: oPop 1
4335: oReturn
4336: oLocalSpace 0
4338: oTypeSNodeType
4339: oChoice 4343
4341: oJumpForward 4348
4343: Choice Lookup Table
          34   4341
4346: oError 8
4348: oTypeSPop
4349: oReturn
4350: oLocalSpace 0
4352: oTypeSNodeType
4353: oChoice 4357
4355: oJumpForward 4362
4357: Choice Lookup Table
          34   4355
4360: oError 8
4362: oReturn
4363: oLocalSpace 1
4365: oGetAddrLocal 1
4367: oPushResult
4368: oTypeSNodeType
4369: oAssign
4370: oTypeSPop
4371: oGetLocal 1
4373: oPushResult
4374: oTypeSNodeType
4375: oPushResult
4376: equal_node_type
4377: oPop 2
4379: oChoice 4456
4381: oTypeSNodeType
4382: oChoice 4443
4384: oGetLocal 1
4386: oChoice 4391
4388: oReturn
4389: oJumpForward 4394
4391: Choice Lookup Table
          38   4388
4394: oJumpForward 4452
4396: oGetLocal 1
4398: oChoice 4403
4400: oReturn
4401: oJumpForward 4406
4403: Choice Lookup Table
          37   4400
4406: oJumpForward 4452
4408: oGetLocal 1
4410: oChoice 4416
4412: oValueCharToString
4413: oReturn
4414: oJumpForward 4419
4416: Choice Lookup Table
          36   4412
4419: oJumpForward 4452
4421: oGetLocal 1
4423: oChoice 4438
4425: oValueSwap
4426: oValueCharToString
4427: oValueSwap
4428: oTypeSPop
4429: oGetGlobal 15
4431: oPushResult
4432: oTypeSPush
4433: oPop 1
4435: oReturn
4436: oJumpForward 4441
4438: Choice Lookup Table
          42   4425
4441: oJumpForward 4452
4443: Choice Lookup Table
          36   4421
          42   4408
          38   4396
          37   4384
4452: oError 15
4454: oJumpForward 4459
4456: Choice Lookup Table
           0   4381
4459: oReturn
4460: oLocalSpace 1
4462: oGetAddrLocal 1
4464: oPushResult
4465: oTypeSNodeType
4466: oAssign
4467: oTypeSPop
4468: oGetLocal 1
4470: oPushResult
4471: oTypeSNodeType
4472: oPushResult
4473: equal_node_type
4474: oPop 2
4476: oChoice 4577
4478: oTypeSNodeType
4479: oChoice 4560
4481: oGetLocal 1
4483: oChoice 4488
4485: oReturn
4486: oJumpForward 4491
4488: Choice Lookup Table
          30   4485
4491: oJumpForward 4573
4493: oGetLocal 1
4495: oChoice 4500
4497: oReturn
4498: oJumpForward 4503
4500: Choice Lookup Table
          31   4497
4503: oJumpForward 4573
4505: oGetLocal 1
4507: oChoice 4512
4509: oReturn
4510: oJumpForward 4515
4512: Choice Lookup Table
          38   4509
4515: oJumpForward 4573
4517: oGetLocal 1
4519: oChoice 4524
4521: oReturn
4522: oJumpForward 4527
4524: Choice Lookup Table
          37   4521
4527: oJumpForward 4573
4529: oGetLocal 1
4531: oChoice 4537
4533: oValueCharToString
4534: oReturn
4535: oJumpForward 4540
4537: Choice Lookup Table
          36   4533
4540: oJumpForward 4573
4542: oGetLocal 1
4544: oChoice 4553
4546: oReturn
4547: oJumpForward 4558
4549: oValueCharToString
4550: oReturn
4551: oJumpForward 4558
4553: Choice Lookup Table
          36   4549
          42   4546
4558: oJumpForward 4573
4560: Choice Lookup Table
          43   4542
          42   4529
          38   4517
          37   4505
          30   4493
          31   4481
4573: oError 15
4575: oJumpForward 4580
4577: Choice Lookup Table
           0   4478
4580: oReturn
4581: oLocalSpace 1
4583: oGetAddrLocal 1
4585: oPushResult
4586: oTypeSNodeType
4587: oAssign
4588: oTypeSPop
4589: oGetLocal 1
4591: oPushResult
4592: oTypeSNodeType
4593: oPushResult
4594: equal_node_type
4595: oPop 2
4597: oChoice 4754
4599: oTypeSNodeType
4600: oChoice 4729
4602: oGetLocal 1
4604: oChoice 4612
4606: oReturn
4607: oJumpForward 4623
4609: oReturn
4610: oJumpForward 4623
4612: Choice Lookup Table
          44   4609
          31   4609
          34   4606
          36   4606
          30   4606
4623: oJumpForward 4750
4625: oGetLocal 1
4627: oChoice 4635
4629: oReturn
4630: oJumpForward 4646
4632: oReturn
4633: oJumpForward 4646
4635: Choice Lookup Table
          44   4632
          31   4632
          34   4629
          36   4629
          30   4629
4646: oJumpForward 4750
4648: oGetLocal 1
4650: oChoice 4659
4652: oValueIntToDouble
4653: oReturn
4654: oJumpForward 4672
4656: oReturn
4657: oJumpForward 4672
4659: Choice Lookup Table
          33   4656
          44   4652
          31   4652
          34   4652
          36   4652
          30   4652
4672: oJumpForward 4750
4674: oGetLocal 1
4676: oChoice 4681
4678: oReturn
4679: oJumpForward 4684
4681: Choice Lookup Table
          38   4678
4684: oJumpForward 4750
4686: oGetLocal 1
4688: oChoice 4693
4690: oReturn
4691: oJumpForward 4696
4693: Choice Lookup Table
          37   4690
4696: oJumpForward 4750
4698: oGetLocal 1
4700: oChoice 4706
4702: oValueCharToString
4703: oReturn
4704: oJumpForward 4709
4706: Choice Lookup Table
          36   4702
4709: oJumpForward 4750
4711: oGetLocal 1
4713: oChoice 4722
4715: oReturn
4716: oJumpForward 4727
4718: oValueCharToString
4719: oReturn
4720: oJumpForward 4727
4722: Choice Lookup Table
          36   4718
          42   4715
4727: oJumpForward 4750
4729: Choice Lookup Table
          43   4711
          42   4698
          38   4686
          37   4674
          33   4648
          34   4625
          36   4625
          30   4625
          44   4602
          31   4602
4750: oError 15
4752: oJumpForward 4757
4754: Choice Lookup Table
           0   4599
4757: oReturn
4758: oLocalSpace 1
4760: oGetParam 1
4762: oPushResult
4763: oGetGlobal 17
4765: oPushResult
4766: oNodeEqual
4767: oPop 2
4769: oChoice 4809
4771: oInput 15
4773: oCall 3568
4775: oInput 16
4777: oTypeSNodeType
4778: oChoice 4784
4780: oJumpForward 4797
4782: oJumpForward 4797
4784: Choice Lookup Table
          36   4782
          30   4782
          34   4782
          44   4780
          31   4780
4795: oError 15
4797: oTypeSPop
4798: oGetGlobal 6
4800: oPushResult
4801: oTypeSPush
4802: oPop 1
4804: oInput 16
4806: oReturn
4807: oJumpForward 4812
4809: Choice Lookup Table
           1   4771
4812: oGetParam 1
4814: oPushResult
4815: oGetGlobal 18
4817: oPushResult
4818: oNodeEqual
4819: oPop 2
4821: oChoice 4855
4823: oInput 15
4825: oCall 3568
4827: oInput 16
4829: oTypeSNodeType
4830: oChoice 4836
4832: oJumpForward 4843
4834: oJumpForward 4843
4836: Choice Lookup Table
          30   4834
          31   4832
4841: oError 15
4843: oTypeSPop
4844: oGetGlobal 9
4846: oPushResult
4847: oTypeSPush
4848: oPop 1
4850: oInput 16
4852: oReturn
4853: oJumpForward 4858
4855: Choice Lookup Table
           1   4823
4858: oGetParam 1
4860: oPushResult
4861: oGetGlobal 19
4863: oPushResult
4864: oNodeEqual
4865: oPop 2
4867: oChoice 4912
4869: oInput 15
4871: oCall 3568
4873: oTypeSNodeType
4874: oChoice 4895
4876: oTypeSTop
4877: oPushResult
4878: oSetResult 45
4880: oPushResult
4881: oNodeGetBoolean
4882: oPop 2
4884: oChoice 4890
4886: oError 29
4888: oJumpForward 4893
4890: Choice Lookup Table
           1   4886
4893: oJumpForward 4900
4895: Choice Lookup Table
          44   4876
4898: oError 15
4900: oSetResult 1
4902: oPushResult
4903: oValuePush
4904: oPop 1
4906: oValueSub
4907: oInput 16
4909: oReturn
4910: oJumpForward 4915
4912: Choice Lookup Table
           1   4869
4915: oGetParam 1
4917: oPushResult
4918: oGetGlobal 20
4920: oPushResult
4921: oNodeEqual
4922: oPop 2
4924: oChoice 4969
4926: oInput 15
4928: oCall 3568
4930: oTypeSNodeType
4931: oChoice 4952
4933: oTypeSTop
4934: oPushResult
4935: oSetResult 45
4937: oPushResult
4938: oNodeGetBoolean
4939: oPop 2
4941: oChoice 4947
4943: oError 29
4945: oJumpForward 4950
4947: Choice Lookup Table
           1   4943
4950: oJumpForward 4957
4952: Choice Lookup Table
          44   4933
4955: oError 15
4957: oSetResult 1
4959: oPushResult
4960: oValuePush
4961: oPop 1
4963: oValueAdd
4964: oInput 16
4966: oReturn
4967: oJumpForward 4972
4969: Choice Lookup Table
           1   4926
4972: oGetParam 1
4974: oPushResult
4975: oGetGlobal 21
4977: oPushResult
4978: oNodeEqual
4979: oPop 2
4981: oChoice 5018
4983: oInput 15
4985: oCall 3802
4987: oValuePop
4988: oGetAddrLocal 1
4990: oPushResult
4991: oTypeSTop
4992: oAssign
4993: oTypeSPop
4994: oGetLocal 1
4996: oPushResult
4997: oSetResult 17
4999: oPushResult
5000: oNodeGetInt
5001: oPop 2
5003: oPushResult
5004: oValuePush
5005: oPop 1
5007: oGetGlobal 6
5009: oPushResult
5010: oTypeSPush
5011: oPop 1
5013: oInput 16
5015: oReturn
5016: oJumpForward 5021
5018: Choice Lookup Table
           1   4983
5021: oError 17
5023: oReturn
5024: oLocalSpace 1
5026: oGetAddrLocal 1
5028: oPushResult
5029: oSetResult 0
5031: oAssign
5032: oGetAddrLocal 1
5034: oPushResult
5035: oCall 5208
5037: oPop 1
5039: oGetAddrLocal 1
5041: oPushResult
5042: oCall 5108
5044: oPop 1
5046: oReturn
5047: oLocalSpace 1
5049: oGetAddrLocal 1
5051: oPushResult
5052: oGetGlobal 25
5054: oAssign
5055: oGetAddrGlobal 25
5057: oPushResult
5058: oSetResult 1
5060: oAssign
5061: oCall 5024
5063: oGetAddrGlobal 25
5065: oPushResult
5066: oGetLocal 1
5068: oAssign
5069: oReturn
5070: oLocalSpace 0
5072: oGetParam 1
5074: oPushResult
5075: oCall 5208
5077: oPop 1
5079: oTypeSNodeType
5080: oChoice 5099
5082: oJumpForward 5106
5084: oGetParam 1
5086: oPushResult
5087: oLabelNew
5088: oAssign
5089: oEmit 82
5091: oGetFromParam 1
5093: oPushResult
5094: oEmitLabel
5095: oPop 1
5097: oJumpForward 5106
5099: Choice Lookup Table
          34   5084
          35   5082
5104: oError 8
5106: oTypeSPop
5107: oReturn
5108: oLocalSpace 1
5110: oTypeSNodeType
5111: oChoice 5173
5113: oGetAddrLocal 1
5115: oPushResult
5116: oLabelNew
5117: oAssign
5118: oEmit 15
5120: oSetResult 1
5122: oPushResult
5123: oEmitInt
5124: oPop 1
5126: oEmit 80
5128: oGetLocal 1
5130: oPushResult
5131: oEmitLabel
5132: oPop 1
5134: oEmit 89
5136: oGetFromParam 1
5138: oPushResult
5139: oEmitLabel
5140: oPop 1
5142: oEmit 15
5144: oSetResult 0
5146: oPushResult
5147: oEmitInt
5148: oPop 1
5150: oEmit 89
5152: oGetLocal 1
5154: oPushResult
5155: oEmitLabel
5156: oPop 1
5158: oTypeSPop
5159: oGetGlobal 7
5161: oPushResult
5162: oTypeSPush
5163: oPop 1
5165: oGetParam 1
5167: oPushResult
5168: oSetResult 0
5170: oAssign
5171: oJumpForward 5176
5173: Choice Lookup Table
          35   5113
5176: oReturn
5177: oLocalSpace 0
5179: oTypeSNodeType
5180: oChoice 5204
5182: oGetParam 1
5184: oPushResult
5185: oLabelNew
5186: oAssign
5187: oEmit 82
5189: oGetFromParam 1
5191: oPushResult
5192: oEmitLabel
5193: oPop 1
5195: oTypeSPop
5196: oGetGlobal 8
5198: oPushResult
5199: oTypeSPush
5200: oPop 1
5202: oJumpForward 5207
5204: Choice Lookup Table
          34   5182
5207: oReturn
5208: oLocalSpace 0
5210: oGetParam 1
5212: oPushResult
5213: oCall 5777
5215: oPop 1
5217: oInputChoice 5759
5219: oGetParam 1
5221: oPushResult
5222: oCall 5108
5224: oPop 1
5226: oCall 9095
5228: oGetParam 1
5230: oPushResult
5231: oCall 5777
5233: oPop 1
5235: oGetParam 1
5237: oPushResult
5238: oCall 5108
5240: oPop 1
5242: oCall 9095
5244: oCall 8779
5246: oTypeSNodeType
5247: oChoice 5279
5249: oEmit 51
5251: oJumpForward 5300
5253: oEmit 57
5255: oJumpForward 5300
5257: oEmit 63
5259: oJumpForward 5300
5261: oEmit 63
5263: oJumpForward 5300
5265: oCall 11365
5267: oEmit 15
5269: oSetResult 0
5271: oPushResult
5272: oEmitInt
5273: oPop 1
5275: oEmit 57
5277: oJumpForward 5300
5279: Choice Lookup Table
          42   5265
          43   5265
          38   5261
          37   5261
          33   5257
          44   5253
          31   5253
          36   5249
          34   5249
5298: oError 18
5300: oTypeSPop
5301: oGetGlobal 7
5303: oPushResult
5304: oTypeSPush
5305: oPop 1
5307: oJumpForward 5774
5309: oGetParam 1
5311: oPushResult
5312: oCall 5108
5314: oPop 1
5316: oCall 9095
5318: oGetParam 1
5320: oPushResult
5321: oCall 5777
5323: oPop 1
5325: oGetParam 1
5327: oPushResult
5328: oCall 5108
5330: oPop 1
5332: oCall 9095
5334: oCall 8779
5336: oTypeSNodeType
5337: oChoice 5369
5339: oEmit 52
5341: oJumpForward 5390
5343: oEmit 58
5345: oJumpForward 5390
5347: oEmit 64
5349: oJumpForward 5390
5351: oEmit 64
5353: oJumpForward 5390
5355: oCall 11365
5357: oEmit 15
5359: oSetResult 0
5361: oPushResult
5362: oEmitInt
5363: oPop 1
5365: oEmit 58
5367: oJumpForward 5390
5369: Choice Lookup Table
          42   5355
          43   5355
          38   5351
          37   5351
          33   5347
          44   5343
          31   5343
          36   5339
          34   5339
5388: oError 18
5390: oTypeSPop
5391: oGetGlobal 7
5393: oPushResult
5394: oTypeSPush
5395: oPop 1
5397: oJumpForward 5774
5399: oGetParam 1
5401: oPushResult
5402: oCall 5108
5404: oPop 1
5406: oCall 9095
5408: oGetParam 1
5410: oPushResult
5411: oCall 5777
5413: oPop 1
5415: oGetParam 1
5417: oPushResult
5418: oCall 5108
5420: oPop 1
5422: oCall 9095
5424: oCall 8779
5426: oTypeSNodeType
5427: oChoice 5459
5429: oEmit 54
5431: oJumpForward 5480
5433: oEmit 60
5435: oJumpForward 5480
5437: oEmit 70
5439: oJumpForward 5480
5441: oEmit 66
5443: oJumpForward 5480
5445: oCall 11365
5447: oEmit 15
5449: oSetResult 0
5451: oPushResult
5452: oEmitInt
5453: oPop 1
5455: oEmit 60
5457: oJumpForward 5480
5459: Choice Lookup Table
          42   5445
          43   5445
          38   5441
          37   5441
          33   5437
          44   5433
          31   5433
          36   5429
          34   5429
5478: oError 18
5480: oTypeSPop
5481: oGetGlobal 7
5483: oPushResult
5484: oTypeSPush
5485: oPop 1
5487: oJumpForward 5774
5489: oGetParam 1
5491: oPushResult
5492: oCall 5108
5494: oPop 1
5496: oCall 9095
5498: oGetParam 1
5500: oPushResult
5501: oCall 5777
5503: oPop 1
5505: oGetParam 1
5507: oPushResult
5508: oCall 5108
5510: oPop 1
5512: oCall 9095
5514: oCall 8779
5516: oTypeSNodeType
5517: oChoice 5549
5519: oEmit 53
5521: oJumpForward 5570
5523: oEmit 59
5525: oJumpForward 5570
5527: oEmit 69
5529: oJumpForward 5570
5531: oEmit 65
5533: oJumpForward 5570
5535: oCall 11365
5537: oEmit 15
5539: oSetResult 0
5541: oPushResult
5542: oEmitInt
5543: oPop 1
5545: oEmit 59
5547: oJumpForward 5570
5549: Choice Lookup Table
          42   5535
          43   5535
          38   5531
          37   5531
          33   5527
          44   5523
          31   5523
          36   5519
          34   5519
5568: oError 18
5570: oTypeSPop
5571: oGetGlobal 7
5573: oPushResult
5574: oTypeSPush
5575: oPop 1
5577: oJumpForward 5774
5579: oGetParam 1
5581: oPushResult
5582: oCall 5108
5584: oPop 1
5586: oCall 9095
5588: oGetParam 1
5590: oPushResult
5591: oCall 5777
5593: oPop 1
5595: oGetParam 1
5597: oPushResult
5598: oCall 5108
5600: oPop 1
5602: oCall 9095
5604: oCall 8779
5606: oTypeSNodeType
5607: oChoice 5639
5609: oEmit 56
5611: oJumpForward 5660
5613: oEmit 62
5615: oJumpForward 5660
5617: oEmit 72
5619: oJumpForward 5660
5621: oEmit 68
5623: oJumpForward 5660
5625: oCall 11365
5627: oEmit 15
5629: oSetResult 0
5631: oPushResult
5632: oEmitInt
5633: oPop 1
5635: oEmit 62
5637: oJumpForward 5660
5639: Choice Lookup Table
          42   5625
          43   5625
          38   5621
          37   5621
          33   5617
          44   5613
          31   5613
          36   5609
          34   5609
5658: oError 18
5660: oTypeSPop
5661: oGetGlobal 7
5663: oPushResult
5664: oTypeSPush
5665: oPop 1
5667: oJumpForward 5774
5669: oGetParam 1
5671: oPushResult
5672: oCall 5108
5674: oPop 1
5676: oCall 9095
5678: oGetParam 1
5680: oPushResult
5681: oCall 5777
5683: oPop 1
5685: oGetParam 1
5687: oPushResult
5688: oCall 5108
5690: oPop 1
5692: oCall 9095
5694: oCall 8779
5696: oTypeSNodeType
5697: oChoice 5729
5699: oEmit 55
5701: oJumpForward 5750
5703: oEmit 61
5705: oJumpForward 5750
5707: oEmit 71
5709: oJumpForward 5750
5711: oEmit 67
5713: oJumpForward 5750
5715: oCall 11365
5717: oEmit 15
5719: oSetResult 0
5721: oPushResult
5722: oEmitInt
5723: oPop 1
5725: oEmit 61
5727: oJumpForward 5750
5729: Choice Lookup Table
          42   5715
          43   5715
          38   5711
          37   5711
          33   5707
          44   5703
          31   5703
          36   5699
          34   5699
5748: oError 18
5750: oTypeSPop
5751: oGetGlobal 7
5753: oPushResult
5754: oTypeSPush
5755: oPop 1
5757: oJumpForward 5774
5759: Choice Lookup Table
          12   5669
          11   5579
          10   5489
           9   5399
           8   5309
           7   5219
5772: oJumpForward 5776
5774: oJumpBack 5217
5776: oReturn
5777: oLocalSpace 1
5779: oGetAddrLocal 1
5781: oPushResult
5782: oSetResult 0
5784: oAssign
5785: oGetParam 1
5787: oPushResult
5788: oCall 5957
5790: oPop 1
5792: oInputChoice 5925
5794: oTypeSNodeType
5795: oChoice 5866
5797: oGetLocal 1
5799: oPushResult
5800: oSetResult 0
5802: oPushResult
5803: equal_label
5804: oPop 2
5806: oChoice 5815
5808: oGetAddrLocal 1
5810: oPushResult
5811: oLabelNew
5812: oAssign
5813: oJumpForward 5818
5815: Choice Lookup Table
           1   5808
5818: oEmit 80
5820: oGetLocal 1
5822: oPushResult
5823: oEmitLabel
5824: oPop 1
5826: oJumpForward 5873
5828: oGetParam 1
5830: oPushResult
5831: oCall 5177
5833: oPop 1
5835: oGetLocal 1
5837: oPushResult
5838: oSetResult 0
5840: oPushResult
5841: equal_label
5842: oPop 2
5844: oChoice 5853
5846: oGetAddrLocal 1
5848: oPushResult
5849: oLabelNew
5850: oAssign
5851: oJumpForward 5856
5853: Choice Lookup Table
           1   5846
5856: oEmit 80
5858: oGetLocal 1
5860: oPushResult
5861: oEmitLabel
5862: oPop 1
5864: oJumpForward 5873
5866: Choice Lookup Table
          34   5828
          35   5797
5871: oError 8
5873: oTypeSPop
5874: oEmit 89
5876: oGetFromParam 1
5878: oPushResult
5879: oEmitLabel
5880: oPop 1
5882: oGetParam 1
5884: oPushResult
5885: oSetResult 0
5887: oAssign
5888: oGetParam 1
5890: oPushResult
5891: oCall 5957
5893: oPop 1
5895: oTypeSNodeType
5896: oChoice 5909
5898: oJumpForward 5916
5900: oGetParam 1
5902: oPushResult
5903: oCall 5177
5905: oPop 1
5907: oJumpForward 5916
5909: Choice Lookup Table
          34   5900
          35   5898
5914: oError 8
5916: oTypeSPop
5917: oGetGlobal 8
5919: oPushResult
5920: oTypeSPush
5921: oPop 1
5923: oJumpForward 5930
5925: Choice Lookup Table
          58   5794
5928: oJumpForward 5932
5930: oJumpBack 5792
5932: oGetLocal 1
5934: oPushResult
5935: oSetResult 0
5937: oPushResult
5938: equal_label
5939: oPop 2
5941: oChoice 5953
5943: oEmit 89
5945: oGetLocal 1
5947: oPushResult
5948: oEmitLabel
5949: oPop 1
5951: oJumpForward 5956
5953: Choice Lookup Table
           0   5943
5956: oReturn
5957: oLocalSpace 2
5959: oGetAddrLocal 1
5961: oPushResult
5962: oSetResult 0
5964: oAssign
5965: oGetParam 1
5967: oPushResult
5968: oCall 6095
5970: oPop 1
5972: oInputChoice 6087
5974: oTypeSNodeType
5975: oChoice 5988
5977: oJumpForward 5995
5979: oGetParam 1
5981: oPushResult
5982: oCall 5177
5984: oPop 1
5986: oJumpForward 5995
5988: Choice Lookup Table
          34   5979
          35   5977
5993: oError 8
5995: oTypeSPop
5996: oGetLocal 1
5998: oPushResult
5999: oSetResult 0
6001: oPushResult
6002: equal_label
6003: oPop 2
6005: oChoice 6034
6007: oGetAddrLocal 1
6009: oPushResult
6010: oLabelNew
6011: oAssign
6012: oEmit 90
6014: oGetFromParam 1
6016: oPushResult
6017: oEmitLabel
6018: oPop 1
6020: oGetLocal 1
6022: oPushResult
6023: oEmitLabel
6024: oPop 1
6026: oGetParam 1
6028: oPushResult
6029: oGetLocal 1
6031: oAssign
6032: oJumpForward 6037
6034: Choice Lookup Table
           1   6007
6037: oGetAddrLocal 2
6039: oPushResult
6040: oSetResult 0
6042: oAssign
6043: oGetAddrLocal 2
6045: oPushResult
6046: oCall 6095
6048: oPop 1
6050: oTypeSNodeType
6051: oChoice 6064
6053: oJumpForward 6071
6055: oGetAddrLocal 2
6057: oPushResult
6058: oCall 5177
6060: oPop 1
6062: oJumpForward 6071
6064: Choice Lookup Table
          34   6055
          35   6053
6069: oError 8
6071: oEmit 90
6073: oGetLocal 2
6075: oPushResult
6076: oEmitLabel
6077: oPop 1
6079: oGetLocal 1
6081: oPushResult
6082: oEmitLabel
6083: oPop 1
6085: oJumpForward 6092
6087: Choice Lookup Table
          57   5974
6090: oJumpForward 6094
6092: oJumpBack 5972
6094: oReturn
6095: oLocalSpace 1
6097: oInputChoice 6151
6099: oGetAddrLocal 1
6101: oPushResult
6102: oSetResult 0
6104: oAssign
6105: oGetAddrLocal 1
6107: oPushResult
6108: oCall 6095
6110: oPop 1
6112: oTypeSNodeType
6113: oChoice 6142
6115: oGetParam 1
6117: oPushResult
6118: oLabelNew
6119: oAssign
6120: oEmit 80
6122: oGetFromParam 1
6124: oPushResult
6125: oEmitLabel
6126: oPop 1
6128: oEmit 89
6130: oGetLocal 1
6132: oPushResult
6133: oEmitLabel
6134: oPop 1
6136: oJumpForward 6149
6138: oEmit 50
6140: oJumpForward 6149
6142: Choice Lookup Table
          34   6138
          35   6115
6147: oError 8
6149: oJumpForward 6161
6151: Choice Lookup Table
          59   6099
6154: oGetParam 1
6156: oPushResult
6157: oCall 6162
6159: oPop 1
6161: oReturn
6162: oLocalSpace 2
6164: oGetAddrLocal 1
6166: oPushResult
6167: oSetResult 1
6169: oAssign
6170: oGetParam 1
6172: oPushResult
6173: oCall 6454
6175: oPop 1
6177: oInputChoice 6444
6179: oTypeSNodeType
6180: oChoice 6326
6182: oCall 9049
6184: oGetParam 1
6186: oPushResult
6187: oCall 6454
6189: oPop 1
6191: oTypeSNodeType
6192: oChoice 6208
6194: oEmit 23
6196: oCall 8407
6198: oJumpForward 6219
6200: oEmit 23
6202: oEmit 34
6204: oEmit 47
6206: oJumpForward 6219
6208: Choice Lookup Table
          33   6200
          38   6194
          37   6194
6215: oCall 9069
6217: oEmit 40
6219: oJumpForward 6345
6221: oGetParam 1
6223: oPushResult
6224: oCall 6454
6226: oPop 1
6228: oCall 9115
6230: oEmit 47
6232: oJumpForward 6345
6234: oGetLocal 1
6236: oChoice 6252
6238: oGetAddrLocal 2
6240: oPushResult
6241: oCall 11148
6243: oAssign
6244: oGetAddrLocal 1
6246: oPushResult
6247: oSetResult 0
6249: oAssign
6250: oJumpForward 6255
6252: Choice Lookup Table
           1   6238
6255: oGetParam 1
6257: oPushResult
6258: oCall 6454
6260: oPop 1
6262: oTypeSNodeType
6263: oChoice 6301
6265: oCall 11257
6267: oEmit 18
6269: oGetLocal 2
6271: oPushResult
6272: oEmitInt
6273: oPop 1
6275: oGetGlobal 16
6277: oPushResult
6278: oTypeSPush
6279: oPop 1
6281: oJumpForward 6311
6283: oCall 11311
6285: oEmit 18
6287: oGetLocal 2
6289: oPushResult
6290: oEmitInt
6291: oPop 1
6293: oGetGlobal 16
6295: oPushResult
6296: oTypeSPush
6297: oPop 1
6299: oJumpForward 6311
6301: Choice Lookup Table
          36   6283
          42   6265
          43   6265
6308: oError 15
6310: oTypeSPop
6311: oJumpForward 6345
6313: oGetParam 1
6315: oPushResult
6316: oCall 6454
6318: oPop 1
6320: oCall 9049
6322: oCall 8407
6324: oJumpForward 6345
6326: Choice Lookup Table
          38   6313
          37   6313
          36   6234
          42   6234
          43   6234
          33   6221
          30   6182
          31   6182
6343: oError 18
6345: oJumpForward 6451
6347: oTypeSNodeType
6348: oChoice 6429
6350: oCall 9049
6352: oGetParam 1
6354: oPushResult
6355: oCall 6454
6357: oPop 1
6359: oTypeSNodeType
6360: oChoice 6372
6362: oEmit 23
6364: oEmit 34
6366: oEmit 23
6368: oEmit 48
6370: oJumpForward 6379
6372: Choice Lookup Table
          33   6362
6375: oCall 9069
6377: oEmit 43
6379: oJumpForward 6442
6381: oGetParam 1
6383: oPushResult
6384: oCall 6454
6386: oPop 1
6388: oCall 9115
6390: oEmit 48
6392: oJumpForward 6442
6394: oGetParam 1
6396: oPushResult
6397: oCall 6454
6399: oPop 1
6401: oTypeSNodeType
6402: oChoice 6416
6404: oCall 9049
6406: oCall 8463
6408: oJumpForward 6427
6410: oCall 8964
6412: oCall 8519
6414: oJumpForward 6427
6416: Choice Lookup Table
          38   6410
          37   6410
          30   6404
          31   6404
6425: oError 18
6427: oJumpForward 6442
6429: Choice Lookup Table
          38   6394
          37   6394
          33   6381
          30   6350
          31   6350
6440: oError 18
6442: oJumpForward 6451
6444: Choice Lookup Table
          26   6347
          25   6179
6449: oJumpForward 6453
6451: oJumpBack 6177
6453: oReturn
6454: oLocalSpace 0
6456: oGetParam 1
6458: oPushResult
6459: oCall 6589
6461: oPop 1
6463: oInputChoice 6579
6465: oTypeSNodeType
6466: oChoice 6510
6468: oCall 9049
6470: oGetParam 1
6472: oPushResult
6473: oCall 6589
6475: oPop 1
6477: oTypeSNodeType
6478: oChoice 6488
6480: oEmit 23
6482: oEmit 34
6484: oEmit 45
6486: oJumpForward 6495
6488: Choice Lookup Table
          33   6480
6491: oCall 9069
6493: oEmit 37
6495: oJumpForward 6519
6497: oGetParam 1
6499: oPushResult
6500: oCall 6589
6502: oPop 1
6504: oCall 9115
6506: oEmit 45
6508: oJumpForward 6519
6510: Choice Lookup Table
          33   6497
          30   6468
          31   6468
6517: oError 18
6519: oJumpForward 6586
6521: oTypeSNodeType
6522: oChoice 6568
6524: oCall 9049
6526: oGetParam 1
6528: oPushResult
6529: oCall 6589
6531: oPop 1
6533: oTypeSNodeType
6534: oChoice 6546
6536: oEmit 23
6538: oEmit 34
6540: oEmit 23
6542: oEmit 46
6544: oJumpForward 6553
6546: Choice Lookup Table
          33   6536
6549: oCall 9069
6551: oEmit 38
6553: oJumpForward 6577
6555: oGetParam 1
6557: oPushResult
6558: oCall 6589
6560: oPop 1
6562: oCall 9115
6564: oEmit 46
6566: oJumpForward 6577
6568: Choice Lookup Table
          33   6555
          30   6524
          31   6524
6575: oError 18
6577: oJumpForward 6586
6579: Choice Lookup Table
          24   6521
          23   6465
6584: oJumpForward 6588
6586: oJumpBack 6463
6588: oReturn
6589: oLocalSpace 0
6591: oInputChoice 6649
6593: oGetParam 1
6595: oPushResult
6596: oCall 6662
6598: oPop 1
6600: oTypeSNodeType
6601: oChoice 6607
6603: oJumpForward 6616
6605: oJumpForward 6616
6607: Choice Lookup Table
          33   6605
          30   6603
          31   6603
6614: oError 18
6616: oJumpForward 6661
6618: oGetParam 1
6620: oPushResult
6621: oCall 6662
6623: oPop 1
6625: oTypeSNodeType
6626: oChoice 6638
6628: oCall 9069
6630: oEmit 44
6632: oJumpForward 6647
6634: oEmit 49
6636: oJumpForward 6647
6638: Choice Lookup Table
          33   6634
          30   6628
          31   6628
6645: oError 18
6647: oJumpForward 6661
6649: Choice Lookup Table
          26   6618
          25   6593
6654: oGetParam 1
6656: oPushResult
6657: oCall 6662
6659: oPop 1
6661: oReturn
6662: oLocalSpace 7
6664: oInputChoice 7168
6666: oEmit 15
6668: TOKEN_VALUE
6669: oPushResult
6670: oEmitInt
6671: oPop 1
6673: oGetGlobal 6
6675: oPushResult
6676: oTypeSPush
6677: oPop 1
6679: oJumpForward 7191
6681: oEmit 15
6683: TOKEN_VALUE
6684: oPushResult
6685: oEmitInt
6686: oPop 1
6688: oGetGlobal 9
6690: oPushResult
6691: oTypeSPush
6692: oPop 1
6694: oJumpForward 7191
6696: oEmit 16
6698: TOKEN_VALUE_DOUBLE
6699: oPushResult
6700: oEmitDouble
6701: oPop 1
6703: oGetGlobal 13
6705: oPushResult
6706: oTypeSPush
6707: oPop 1
6709: oJumpForward 7191
6711: oGetParam 1
6713: oPushResult
6714: oCall 5208
6716: oPop 1
6718: oInput 16
6720: oJumpForward 7191
6722: oGetAddrLocal 1
6724: oPushResult
6725: CURRENT_STRLIT
6726: oPushResult
6727: oStringAllocShortStringLit
6728: oPop 1
6730: oAssign
6731: oEmit 17
6733: oGetLocal 1
6735: oPushResult
6736: oEmitInt
6737: oPop 1
6739: oGetGlobal 15
6741: oPushResult
6742: oTypeSPush
6743: oPop 1
6745: oCall 8005
6747: oCall 7951
6749: oJumpForward 7191
6751: oGetAddrLocal 2
6753: oPushResult
6754: oScopeFindRequire
6755: oAssign
6756: oGetAddrLocal 2
6758: oPushResult
6759: oCall 244
6761: oPop 1
6763: oGetLocal 2
6765: oPushResult
6766: oNodeType
6767: oPop 1
6769: oChoice 7086
6771: oGetLocal 2
6773: oPushResult
6774: oCall 11460
6776: oPop 1
6778: oJumpForward 7117
6780: oGetLocal 2
6782: oPushResult
6783: oCall 12130
6785: oPop 1
6787: oJumpForward 7117
6789: oGetAddrLocal 3
6791: oPushResult
6792: oGetLocal 2
6794: oPushResult
6795: oSetResult 21
6797: oPushResult
6798: oNodeGet
6799: oPop 2
6801: oAssign
6802: oGetLocal 3
6804: oPushResult
6805: oTypeSPush
6806: oPop 1
6808: oTypeSNodeType
6809: oChoice 6833
6811: oEmit 15
6813: oGetLocal 2
6815: oPushResult
6816: oCall 14499
6818: oPop 1
6820: oJumpForward 6850
6822: oEmit 15
6824: oGetLocal 2
6826: oPushResult
6827: oCall 14499
6829: oPop 1
6831: oJumpForward 6850
6833: Choice Lookup Table
          38   6822
          37   6822
          30   6811
          36   6811
          34   6811
          44   6811
          31   6811
6848: oError 17
6850: oJumpForward 7117
6852: oGetAddrLocal 3
6854: oPushResult
6855: oGetLocal 2
6857: oPushResult
6858: oSetResult 21
6860: oPushResult
6861: oNodeGet
6862: oPop 2
6864: oAssign
6865: oGetLocal 3
6867: oPushResult
6868: oTypeSPush
6869: oPop 1
6871: oTypeSNodeType
6872: oChoice 6891
6874: oEmit 16
6876: oGetLocal 2
6878: oPushResult
6879: oSetResult 34
6881: oPushResult
6882: oNodeGetDouble
6883: oPop 2
6885: oPushResult
6886: oEmitDouble
6887: oPop 1
6889: oJumpForward 6896
6891: Choice Lookup Table
          33   6874
6894: oError 17
6896: oJumpForward 7117
6898: oGetAddrLocal 4
6900: oPushResult
6901: oGetLocal 2
6903: oPushResult
6904: oSetResult 22
6906: oPushResult
6907: oNodeGetInt
6908: oPop 2
6910: oAssign
6911: oGetLocal 4
6913: oPushResult
6914: equal_zero
6915: oPop 1
6917: oChoice 6950
6919: oGetAddrLocal 4
6921: oPushResult
6922: oGetLocal 2
6924: oPushResult
6925: oSetResult 33
6927: oPushResult
6928: oNodeGetString
6929: oPop 2
6931: oPushResult
6932: oStringAllocShortStringLit
6933: oPop 1
6935: oAssign
6936: oGetLocal 2
6938: oPushResult
6939: oSetResult 22
6941: oPushResult
6942: oGetLocal 4
6944: oPushResult
6945: oNodeSetInt
6946: oPop 3
6948: oJumpForward 6953
6950: Choice Lookup Table
           1   6919
6953: oEmit 17
6955: oGetLocal 4
6957: oPushResult
6958: oEmitInt
6959: oPop 1
6961: oGetGlobal 15
6963: oPushResult
6964: oTypeSPush
6965: oPop 1
6967: oCall 8005
6969: oCall 7951
6971: oJumpForward 7117
6973: oGetLocal 2
6975: oPushResult
6976: oCall 7192
6978: oPop 1
6980: oJumpForward 7117
6982: oGetLocal 2
6984: oPushResult
6985: oSetResult 21
6987: oPushResult
6988: oNodeGet
6989: oPop 2
6991: oPushResult
6992: oTypeSPush
6993: oPop 1
6995: oInputChoice 7062
6997: oCall 5024
6999: oInput 16
7001: oCall 8784
7003: oTypeSNodeType
7004: oChoice 7049
7006: oInputChoice 7036
7008: oTypeSPop
7009: oGetLocal 3
7011: oPushResult
7012: oSetResult 38
7014: oPushResult
7015: oNodeGet
7016: oPop 2
7018: oPushResult
7019: oTypeSPush
7020: oPop 1
7022: oCall 8005
7024: oCall 7951
7026: oJumpForward 7041
7028: oCall 8200
7030: oCall 8005
7032: oCall 7951
7034: oJumpForward 7041
7036: Choice Lookup Table
          17   7028
          19   7008
7041: oJumpForward 7060
7043: oCall 8005
7045: oCall 7951
7047: oJumpForward 7060
7049: Choice Lookup Table
          43   7043
          41   7043
          39   7043
          38   7006
          37   7006
7060: oJumpForward 7084
7062: Choice Lookup Table
          15   6997
7065: oGetGlobal 25
7067: oChoice 7079
7069: oEmit 15
7071: oSetResult 0
7073: oPushResult
7074: oEmitInt
7075: oPop 1
7077: oJumpForward 7084
7079: Choice Lookup Table
           1   7069
7082: oError 32
7084: oJumpForward 7117
7086: Choice Lookup Table
          20   6982
          26   6973
          25   6973
          23   6973
          22   6973
          18   6898
          19   6852
          17   6789
          16   6789
          14   6780
          13   6771
7109: oError 6
7111: oGetGlobal 6
7113: oPushResult
7114: oTypeSPush
7115: oPop 1
7117: oJumpForward 7191
7119: oInput 0
7121: oGetAddrLocal 5
7123: oPushResult
7124: oScopeFindRequire
7125: oAssign
7126: oGetAddrLocal 5
7128: oPushResult
7129: oCall 244
7131: oPop 1
7133: oGetLocal 5
7135: oPushResult
7136: oSetResult 0
7138: oPushResult
7139: oCall 9665
7141: oPop 2
7143: oGetAddrLocal 6
7145: oPushResult
7146: oTypeSTop
7147: oAssign
7148: oTypeSPop
7149: oGetAddrLocal 7
7151: oPushResult
7152: oGetLocal 6
7154: oPushResult
7155: oCall 13518
7157: oPop 1
7159: oAssign
7160: oGetLocal 7
7162: oPushResult
7163: oTypeSPush
7164: oPop 1
7166: oJumpForward 7191
7168: Choice Lookup Table
          20   7119
           0   6751
           3   6722
          15   6711
           2   6696
           4   6681
           1   6666
7183: oError 6
7185: oGetGlobal 6
7187: oPushResult
7188: oTypeSPush
7189: oPop 1
7191: oReturn
7192: oLocalSpace 2
7194: oGetAddrLocal 1
7196: oPushResult
7197: oGetParam 1
7199: oPushResult
7200: oSetResult 21
7202: oPushResult
7203: oNodeGet
7204: oPop 2
7206: oAssign
7207: oGetAddrLocal 2
7209: oPushResult
7210: oGetParam 1
7212: oPushResult
7213: oCall 14453
7215: oPop 1
7217: oAssign
7218: oGetLocal 1
7220: oPushResult
7221: oTypeSPush
7222: oPop 1
7224: oTypeSNodeType
7225: oChoice 7924
7227: oGetParam 1
7229: oPushResult
7230: oNodeType
7231: oPop 1
7233: oChoice 7379
7235: oEmit 0
7237: oGetParam 1
7239: oPushResult
7240: oCall 14499
7242: oPop 1
7244: oJumpForward 7389
7246: oGetLocal 2
7248: oPushResult
7249: equal_zero
7250: oPop 1
7252: oChoice 7265
7254: oEmit 3
7256: oGetParam 1
7258: oPushResult
7259: oCall 14499
7261: oPop 1
7263: oJumpForward 7283
7265: Choice Lookup Table
           1   7254
7268: oEmit 9
7270: oGetLocal 2
7272: oPushResult
7273: oEmitInt
7274: oPop 1
7276: oGetParam 1
7278: oPushResult
7279: oCall 14499
7281: oPop 1
7283: oJumpForward 7389
7285: oGetParam 1
7287: oPushResult
7288: oSetResult 35
7290: oPushResult
7291: oNodeGetBoolean
7292: oPop 2
7294: oChoice 7337
7296: oGetLocal 2
7298: oPushResult
7299: equal_zero
7300: oPop 1
7302: oChoice 7315
7304: oEmit 8
7306: oGetParam 1
7308: oPushResult
7309: oCall 14499
7311: oPop 1
7313: oJumpForward 7333
7315: Choice Lookup Table
           1   7304
7318: oEmit 14
7320: oGetLocal 2
7322: oPushResult
7323: oEmitInt
7324: oPop 1
7326: oGetParam 1
7328: oPushResult
7329: oCall 14499
7331: oPop 1
7333: oEmit 24
7335: oJumpForward 7377
7337: Choice Lookup Table
           1   7296
7340: oGetLocal 2
7342: oPushResult
7343: equal_zero
7344: oPop 1
7346: oChoice 7359
7348: oEmit 6
7350: oGetParam 1
7352: oPushResult
7353: oCall 14499
7355: oPop 1
7357: oJumpForward 7377
7359: Choice Lookup Table
           1   7348
7362: oEmit 12
7364: oGetLocal 2
7366: oPushResult
7367: oEmitInt
7368: oPop 1
7370: oGetParam 1
7372: oPushResult
7373: oCall 14499
7375: oPop 1
7377: oJumpForward 7389
7379: Choice Lookup Table
          25   7285
          23   7246
          26   7235
          22   7235
7388: oEndChoice
7389: oJumpForward 7950
7391: oGetParam 1
7393: oPushResult
7394: oNodeType
7395: oPop 1
7397: oChoice 7543
7399: oEmit 1
7401: oGetParam 1
7403: oPushResult
7404: oCall 14499
7406: oPop 1
7408: oJumpForward 7553
7410: oGetLocal 2
7412: oPushResult
7413: equal_zero
7414: oPop 1
7416: oChoice 7429
7418: oEmit 4
7420: oGetParam 1
7422: oPushResult
7423: oCall 14499
7425: oPop 1
7427: oJumpForward 7447
7429: Choice Lookup Table
           1   7418
7432: oEmit 10
7434: oGetLocal 2
7436: oPushResult
7437: oEmitInt
7438: oPop 1
7440: oGetParam 1
7442: oPushResult
7443: oCall 14499
7445: oPop 1
7447: oJumpForward 7553
7449: oGetParam 1
7451: oPushResult
7452: oSetResult 35
7454: oPushResult
7455: oNodeGetBoolean
7456: oPop 2
7458: oChoice 7501
7460: oGetLocal 2
7462: oPushResult
7463: equal_zero
7464: oPop 1
7466: oChoice 7479
7468: oEmit 8
7470: oGetParam 1
7472: oPushResult
7473: oCall 14499
7475: oPop 1
7477: oJumpForward 7497
7479: Choice Lookup Table
           1   7468
7482: oEmit 14
7484: oGetLocal 2
7486: oPushResult
7487: oEmitInt
7488: oPop 1
7490: oGetParam 1
7492: oPushResult
7493: oCall 14499
7495: oPop 1
7497: oEmit 25
7499: oJumpForward 7541
7501: Choice Lookup Table
           1   7460
7504: oGetLocal 2
7506: oPushResult
7507: equal_zero
7508: oPop 1
7510: oChoice 7523
7512: oEmit 7
7514: oGetParam 1
7516: oPushResult
7517: oCall 14499
7519: oPop 1
7521: oJumpForward 7541
7523: Choice Lookup Table
           1   7512
7526: oEmit 13
7528: oGetLocal 2
7530: oPushResult
7531: oEmitInt
7532: oPop 1
7534: oGetParam 1
7536: oPushResult
7537: oCall 14499
7539: oPop 1
7541: oJumpForward 7553
7543: Choice Lookup Table
          25   7449
          23   7410
          26   7399
          22   7399
7552: oEndChoice
7553: oJumpForward 7950
7555: oError 17
7557: oJumpForward 7950
7559: oGetParam 1
7561: oPushResult
7562: oNodeType
7563: oPop 1
7565: oChoice 7711
7567: oEmit 2
7569: oGetParam 1
7571: oPushResult
7572: oCall 14499
7574: oPop 1
7576: oJumpForward 7721
7578: oGetLocal 2
7580: oPushResult
7581: equal_zero
7582: oPop 1
7584: oChoice 7597
7586: oEmit 5
7588: oGetParam 1
7590: oPushResult
7591: oCall 14499
7593: oPop 1
7595: oJumpForward 7615
7597: Choice Lookup Table
           1   7586
7600: oEmit 11
7602: oGetLocal 2
7604: oPushResult
7605: oEmitInt
7606: oPop 1
7608: oGetParam 1
7610: oPushResult
7611: oCall 14499
7613: oPop 1
7615: oJumpForward 7721
7617: oGetParam 1
7619: oPushResult
7620: oSetResult 35
7622: oPushResult
7623: oNodeGetBoolean
7624: oPop 2
7626: oChoice 7669
7628: oGetLocal 2
7630: oPushResult
7631: equal_zero
7632: oPop 1
7634: oChoice 7647
7636: oEmit 8
7638: oGetParam 1
7640: oPushResult
7641: oCall 14499
7643: oPop 1
7645: oJumpForward 7665
7647: Choice Lookup Table
           1   7636
7650: oEmit 14
7652: oGetLocal 2
7654: oPushResult
7655: oEmitInt
7656: oPop 1
7658: oGetParam 1
7660: oPushResult
7661: oCall 14499
7663: oPop 1
7665: oEmit 26
7667: oJumpForward 7709
7669: Choice Lookup Table
           1   7628
7672: oGetLocal 2
7674: oPushResult
7675: equal_zero
7676: oPop 1
7678: oChoice 7691
7680: oEmit 8
7682: oGetParam 1
7684: oPushResult
7685: oCall 14499
7687: oPop 1
7689: oJumpForward 7709
7691: Choice Lookup Table
           1   7680
7694: oEmit 14
7696: oGetLocal 2
7698: oPushResult
7699: oEmitInt
7700: oPop 1
7702: oGetParam 1
7704: oPushResult
7705: oCall 14499
7707: oPop 1
7709: oJumpForward 7721
7711: Choice Lookup Table
          25   7617
          23   7578
          26   7567
          22   7567
7720: oEndChoice
7721: oInputChoice 7751
7723: oTypeSPop
7724: oGetLocal 1
7726: oPushResult
7727: oSetResult 38
7729: oPushResult
7730: oNodeGet
7731: oPop 2
7733: oPushResult
7734: oTypeSPush
7735: oPop 1
7737: oCall 8005
7739: oCall 7951
7741: oJumpForward 7756
7743: oCall 8200
7745: oCall 8005
7747: oCall 7951
7749: oJumpForward 7756
7751: Choice Lookup Table
          17   7743
          19   7723
7756: oJumpForward 7950
7758: oGetParam 1
7760: oPushResult
7761: oNodeType
7762: oPop 1
7764: oChoice 7908
7766: oEmit 17
7768: oGetParam 1
7770: oPushResult
7771: oCall 14499
7773: oPop 1
7775: oJumpForward 7918
7777: oGetLocal 2
7779: oPushResult
7780: equal_zero
7781: oPop 1
7783: oChoice 7796
7785: oEmit 18
7787: oGetParam 1
7789: oPushResult
7790: oCall 14499
7792: oPop 1
7794: oJumpForward 7814
7796: Choice Lookup Table
           1   7785
7799: oEmit 21
7801: oGetLocal 2
7803: oPushResult
7804: oEmitInt
7805: oPop 1
7807: oGetParam 1
7809: oPushResult
7810: oCall 14499
7812: oPop 1
7814: oJumpForward 7918
7816: oGetParam 1
7818: oPushResult
7819: oSetResult 35
7821: oPushResult
7822: oNodeGetBoolean
7823: oPop 2
7825: oChoice 7866
7827: oGetLocal 2
7829: oPushResult
7830: equal_zero
7831: oPop 1
7833: oChoice 7846
7835: oEmit 8
7837: oGetParam 1
7839: oPushResult
7840: oCall 14499
7842: oPop 1
7844: oJumpForward 7864
7846: Choice Lookup Table
           1   7835
7849: oEmit 14
7851: oGetLocal 2
7853: oPushResult
7854: oEmitInt
7855: oPop 1
7857: oGetParam 1
7859: oPushResult
7860: oCall 14499
7862: oPop 1
7864: oJumpForward 7906
7866: Choice Lookup Table
           1   7827
7869: oGetLocal 2
7871: oPushResult
7872: equal_zero
7873: oPop 1
7875: oChoice 7888
7877: oEmit 19
7879: oGetParam 1
7881: oPushResult
7882: oCall 14499
7884: oPop 1
7886: oJumpForward 7906
7888: Choice Lookup Table
           1   7877
7891: oEmit 22
7893: oGetLocal 2
7895: oPushResult
7896: oEmitInt
7897: oPop 1
7899: oGetParam 1
7901: oPushResult
7902: oCall 14499
7904: oPop 1
7906: oJumpForward 7918
7908: Choice Lookup Table
          25   7816
          23   7777
          26   7766
          22   7766
7917: oEndChoice
7918: oCall 8005
7920: oCall 7951
7922: oJumpForward 7950
7924: Choice Lookup Table
          43   7758
          41   7758
          39   7758
          33   7559
          38   7559
          37   7559
          29   7555
          36   7391
          30   7391
          34   7391
          44   7227
          31   7227
7949: oEndChoice
7950: oReturn
7951: oLocalSpace 0
7953: oTypeSNodeType
7954: oChoice 7978
7956: oEmit 24
7958: oJumpForward 8004
7960: oEmit 25
7962: oJumpForward 8004
7964: oError 17
7966: oJumpForward 8004
7968: oEmit 26
7970: oJumpForward 8004
7972: oError 30
7974: oJumpForward 8004
7976: oJumpForward 8004
7978: Choice Lookup Table
          43   7976
          42   7976
          41   7976
          39   7976
          38   7972
          37   7968
          29   7964
          36   7960
          30   7960
          34   7960
          44   7956
          31   7956
8003: oEndChoice
8004: oReturn
8005: oLocalSpace 0
8007: oInputChoice 8045
8009: oTypeSNodeType
8010: oChoice 8024
8012: oCall 8057
8014: oJumpForward 8035
8016: oCall 8200
8018: oJumpForward 8035
8020: oCall 8279
8022: oJumpForward 8035
8024: Choice Lookup Table
          43   8020
          42   8020
          37   8016
          39   8012
8033: oError 11
8035: oJumpForward 8054
8037: oCall 8309
8039: oJumpForward 8054
8041: oCall 8582
8043: oJumpForward 8054
8045: Choice Lookup Table
          19   8041
          21   8037
          17   8009
8052: oJumpForward 8056
8054: oJumpBack 8007
8056: oReturn
8057: oLocalSpace 3
8059: oTypeSNodeType
8060: oChoice 8064
8062: oJumpForward 8069
8064: Choice Lookup Table
          39   8062
8067: oError 11
8069: oTypeSNodeType
8070: oChoice 8074
8072: oJumpForward 8079
8074: Choice Lookup Table
          39   8072
8077: oError 14
8079: oGetAddrLocal 1
8081: oPushResult
8082: oTypeSTop
8083: oPushResult
8084: oSetResult 39
8086: oPushResult
8087: oNodeGet
8088: oPop 2
8090: oPushResult
8091: oCall 13602
8093: oPop 1
8095: oAssign
8096: oGetAddrLocal 2
8098: oPushResult
8099: oTypeSTop
8100: oPushResult
8101: oSetResult 38
8103: oPushResult
8104: oNodeGet
8105: oPop 2
8107: oAssign
8108: oTypeSPop
8109: oGetLocal 2
8111: oPushResult
8112: oTypeSPush
8113: oPop 1
8115: oCall 5024
8117: oCall 9022
8119: oGetLocal 1
8121: oPushResult
8122: equal_zero
8123: oPop 1
8125: oChoice 8139
8127: oEmit 15
8129: oGetLocal 1
8131: oPushResult
8132: oEmitInt
8133: oPop 1
8135: oEmit 43
8137: oJumpForward 8142
8139: Choice Lookup Table
           0   8127
8142: oGetAddrLocal 3
8144: oPushResult
8145: oGetLocal 2
8147: oPushResult
8148: oSetResult 17
8150: oPushResult
8151: oNodeGetInt
8152: oPop 2
8154: oAssign
8155: oGetLocal 3
8157: oPushResult
8158: oSetResult 1
8160: oPushResult
8161: equal
8162: oPop 2
8164: oChoice 8178
8166: oEmit 15
8168: oGetLocal 3
8170: oPushResult
8171: oEmitInt
8172: oPop 1
8174: oEmit 37
8176: oJumpForward 8181
8178: Choice Lookup Table
           0   8166
8181: oEmit 39
8183: oInputChoice 8191
8185: oJumpForward 8199
8187: oJumpForward 8197
8189: oJumpForward 8197
8191: Choice Lookup Table
          14   8189
          18   8185
8196: oEndChoice
8197: oJumpBack 8069
8199: oReturn
8200: oLocalSpace 2
8202: oTypeSNodeType
8203: oChoice 8207
8205: oJumpForward 8212
8207: Choice Lookup Table
          37   8205
8210: oError 30
8212: oGetAddrLocal 1
8214: oPushResult
8215: oTypeSTop
8216: oPushResult
8217: oSetResult 38
8219: oPushResult
8220: oNodeGet
8221: oPop 2
8223: oAssign
8224: oTypeSPop
8225: oGetLocal 1
8227: oPushResult
8228: oTypeSPush
8229: oPop 1
8231: oCall 5024
8233: oCall 9022
8235: oGetAddrLocal 2
8237: oPushResult
8238: oGetLocal 1
8240: oPushResult
8241: oSetResult 17
8243: oPushResult
8244: oNodeGetInt
8245: oPop 2
8247: oAssign
8248: oGetLocal 2
8250: oPushResult
8251: oSetResult 1
8253: oPushResult
8254: equal
8255: oPop 2
8257: oChoice 8271
8259: oEmit 15
8261: oGetLocal 2
8263: oPushResult
8264: oEmitInt
8265: oPop 1
8267: oEmit 37
8269: oJumpForward 8274
8271: Choice Lookup Table
           0   8259
8274: oEmit 39
8276: oInput 18
8278: oReturn
8279: oLocalSpace 0
8281: oTypeSNodeType
8282: oChoice 8286
8284: oJumpForward 8293
8286: Choice Lookup Table
          43   8284
          42   8284
8291: oError 30
8293: oTypeSPop
8294: oGetGlobal 9
8296: oPushResult
8297: oTypeSPush
8298: oPop 1
8300: oCall 5024
8302: oCall 9022
8304: oEmit 39
8306: oInput 18
8308: oReturn
8309: oLocalSpace 2
8311: oTypeSNodeType
8312: oChoice 8316
8314: oJumpForward 8321
8316: Choice Lookup Table
          41   8314
8319: oError 12
8321: oTypeSTop
8322: oPushResult
8323: oSetResult 42
8325: oPushResult
8326: oNodeGet
8327: oPop 2
8329: oPushResult
8330: oScopeEnter
8331: oPop 1
8333: oInput 0
8335: oGetAddrLocal 1
8337: oPushResult
8338: oScopeFindRequire
8339: oAssign
8340: oGetLocal 1
8342: oPushResult
8343: oNodeType
8344: oPop 1
8346: oChoice 8350
8348: oJumpForward 8355
8350: Choice Lookup Table
          24   8348
8353: oError 13
8355: oScopeEnd
8356: oGetAddrLocal 2
8358: oPushResult
8359: oGetLocal 1
8361: oPushResult
8362: oSetResult 22
8364: oPushResult
8365: oNodeGetInt
8366: oPop 2
8368: oAssign
8369: oGetLocal 2
8371: oPushResult
8372: equal_zero
8373: oPop 1
8375: oChoice 8389
8377: oEmit 15
8379: oGetLocal 2
8381: oPushResult
8382: oEmitInt
8383: oPop 1
8385: oEmit 39
8387: oJumpForward 8392
8389: Choice Lookup Table
           0   8377
8392: oTypeSPop
8393: oGetLocal 1
8395: oPushResult
8396: oSetResult 21
8398: oPushResult
8399: oNodeGet
8400: oPop 2
8402: oPushResult
8403: oTypeSPush
8404: oPop 1
8406: oReturn
8407: oLocalSpace 2
8409: oGetAddrLocal 1
8411: oPushResult
8412: oTypeSTop
8413: oPushResult
8414: oSetResult 38
8416: oPushResult
8417: oNodeGet
8418: oPop 2
8420: oAssign
8421: oGetAddrLocal 2
8423: oPushResult
8424: oGetLocal 1
8426: oPushResult
8427: oSetResult 17
8429: oPushResult
8430: oNodeGetInt
8431: oPop 2
8433: oAssign
8434: oGetLocal 2
8436: oPushResult
8437: oSetResult 1
8439: oPushResult
8440: equal
8441: oPop 2
8443: oChoice 8457
8445: oEmit 15
8447: oGetLocal 2
8449: oPushResult
8450: oEmitInt
8451: oPop 1
8453: oEmit 37
8455: oJumpForward 8460
8457: Choice Lookup Table
           0   8445
8460: oEmit 39
8462: oReturn
8463: oLocalSpace 2
8465: oGetAddrLocal 1
8467: oPushResult
8468: oTypeSTop
8469: oPushResult
8470: oSetResult 38
8472: oPushResult
8473: oNodeGet
8474: oPop 2
8476: oAssign
8477: oGetAddrLocal 2
8479: oPushResult
8480: oGetLocal 1
8482: oPushResult
8483: oSetResult 17
8485: oPushResult
8486: oNodeGetInt
8487: oPop 2
8489: oAssign
8490: oGetLocal 2
8492: oPushResult
8493: oSetResult 1
8495: oPushResult
8496: equal
8497: oPop 2
8499: oChoice 8513
8501: oEmit 15
8503: oGetLocal 2
8505: oPushResult
8506: oEmitInt
8507: oPop 1
8509: oEmit 37
8511: oJumpForward 8516
8513: Choice Lookup Table
           0   8501
8516: oEmit 42
8518: oReturn
8519: oLocalSpace 2
8521: oEmit 41
8523: oGetAddrLocal 1
8525: oPushResult
8526: oTypeSTop
8527: oPushResult
8528: oSetResult 38
8530: oPushResult
8531: oNodeGet
8532: oPop 2
8534: oAssign
8535: oGetAddrLocal 2
8537: oPushResult
8538: oGetLocal 1
8540: oPushResult
8541: oSetResult 17
8543: oPushResult
8544: oNodeGetInt
8545: oPop 2
8547: oAssign
8548: oGetLocal 2
8550: oPushResult
8551: oSetResult 1
8553: oPushResult
8554: equal
8555: oPop 2
8557: oChoice 8571
8559: oEmit 15
8561: oGetLocal 2
8563: oPushResult
8564: oEmitInt
8565: oPop 1
8567: oEmit 38
8569: oJumpForward 8574
8571: Choice Lookup Table
           0   8559
8574: oTypeSPop
8575: oGetGlobal 6
8577: oPushResult
8578: oTypeSPush
8579: oPop 1
8581: oReturn
8582: oLocalSpace 1
8584: oTypeSNodeType
8585: oChoice 8593
8587: oJumpForward 8600
8589: oError 30
8591: oJumpForward 8600
8593: Choice Lookup Table
          38   8589
          37   8587
8598: oError 10
8600: oEmit 26
8602: oGetAddrLocal 1
8604: oPushResult
8605: oTypeSTop
8606: oAssign
8607: oTypeSPop
8608: oGetLocal 1
8610: oPushResult
8611: oSetResult 38
8613: oPushResult
8614: oNodeGet
8615: oPop 2
8617: oPushResult
8618: oTypeSPush
8619: oPop 1
8621: oReturn
8622: oLocalSpace 3
8624: oGetAddrLocal 1
8626: oPushResult
8627: oTypeSNodeType
8628: oAssign
8629: oGetAddrLocal 2
8631: oPushResult
8632: oTypeSTop
8633: oAssign
8634: oTypeSPop
8635: oGetLocal 1
8637: oPushResult
8638: oTypeSNodeType
8639: oPushResult
8640: equal_node_type
8641: oPop 2
8643: oChoice 8775
8645: oTypeSNodeType
8646: oChoice 8760
8648: oGetLocal 1
8650: oChoice 8657
8652: oEmit 32
8654: oReturn
8655: oJumpForward 8660
8657: Choice Lookup Table
          30   8652
8660: oJumpForward 8771
8662: oGetLocal 1
8664: oChoice 8671
8666: oEmit 33
8668: oReturn
8669: oJumpForward 8674
8671: Choice Lookup Table
          31   8666
8674: oJumpForward 8771
8676: oGetLocal 1
8678: oChoice 8711
8680: oReturn
8681: oJumpForward 8716
8683: oTypeSTop
8684: oPushResult
8685: oGetGlobal 10
8687: oPushResult
8688: equal_node
8689: oPop 2
8691: oChoice 8706
8693: oEmit 15
8695: oSetResult 1
8697: oPushResult
8698: oEmitInt
8699: oPop 1
8701: oEmit 39
8703: oReturn
8704: oJumpForward 8709
8706: Choice Lookup Table
           1   8693
8709: oJumpForward 8716
8711: Choice Lookup Table
          42   8683
          38   8680
8716: oJumpForward 8771
8718: oGetLocal 1
8720: oChoice 8725
8722: oReturn
8723: oJumpForward 8728
8725: Choice Lookup Table
          37   8722
8728: oJumpForward 8771
8730: oGetLocal 1
8732: oChoice 8753
8734: oReturn
8735: oJumpForward 8758
8737: oGetGlobal 9
8739: oPushResult
8740: oTypeSPush
8741: oPop 1
8743: oGetAddrLocal 3
8745: oPushResult
8746: oCall 11148
8748: oAssign
8749: oTypeSPop
8750: oReturn
8751: oJumpForward 8758
8753: Choice Lookup Table
          36   8737
          42   8734
8758: oJumpForward 8771
8760: Choice Lookup Table
          43   8730
          38   8718
          37   8676
          30   8662
          31   8648
8771: oError 15
8773: oJumpForward 8778
8775: Choice Lookup Table
           0   8645
8778: oReturn
8779: oLocalSpace 0
8781: oCall 8964
8783: oReturn
8784: oLocalSpace 2
8786: oGetAddrLocal 1
8788: oPushResult
8789: oTypeSNodeType
8790: oAssign
8791: oTypeSPop
8792: oGetLocal 1
8794: oPushResult
8795: oTypeSNodeType
8796: oPushResult
8797: equal_node_type
8798: oPop 2
8800: oChoice 8960
8802: oTypeSNodeType
8803: oChoice 8939
8805: oGetLocal 1
8807: oChoice 8817
8809: oEmit 32
8811: oReturn
8812: oJumpForward 8828
8814: oReturn
8815: oJumpForward 8828
8817: Choice Lookup Table
          44   8814
          31   8814
          34   8809
          36   8809
          30   8809
8828: oJumpForward 8956
8830: oGetLocal 1
8832: oChoice 8842
8834: oReturn
8835: oJumpForward 8853
8837: oEmit 33
8839: oReturn
8840: oJumpForward 8853
8842: Choice Lookup Table
          44   8837
          31   8837
          34   8834
          36   8834
          30   8834
8853: oJumpForward 8956
8855: oGetLocal 1
8857: oChoice 8890
8859: oReturn
8860: oJumpForward 8895
8862: oTypeSTop
8863: oPushResult
8864: oGetGlobal 10
8866: oPushResult
8867: equal_node
8868: oPop 2
8870: oChoice 8885
8872: oEmit 15
8874: oSetResult 1
8876: oPushResult
8877: oEmitInt
8878: oPop 1
8880: oEmit 39
8882: oReturn
8883: oJumpForward 8888
8885: Choice Lookup Table
           1   8872
8888: oJumpForward 8895
8890: Choice Lookup Table
          42   8862
          38   8859
8895: oJumpForward 8956
8897: oGetLocal 1
8899: oChoice 8904
8901: oReturn
8902: oJumpForward 8907
8904: Choice Lookup Table
          37   8901
8907: oJumpForward 8956
8909: oGetLocal 1
8911: oChoice 8932
8913: oReturn
8914: oJumpForward 8937
8916: oGetGlobal 9
8918: oPushResult
8919: oTypeSPush
8920: oPop 1
8922: oGetAddrLocal 2
8924: oPushResult
8925: oCall 11148
8927: oAssign
8928: oTypeSPop
8929: oReturn
8930: oJumpForward 8937
8932: Choice Lookup Table
          36   8916
          42   8913
8937: oJumpForward 8956
8939: Choice Lookup Table
          43   8909
          38   8897
          37   8855
          34   8830
          36   8830
          30   8830
          44   8805
          31   8805
8956: oError 15
8958: oJumpForward 8963
8960: Choice Lookup Table
           0   8802
8963: oReturn
8964: oLocalSpace 1
8966: oGetAddrLocal 1
8968: oPushResult
8969: oTypeSNodeType
8970: oAssign
8971: oTypeSPop
8972: oGetLocal 1
8974: oPushResult
8975: oTypeSNodeType
8976: oPushResult
8977: equal_node_type
8978: oPop 2
8980: oChoice 9018
8982: oTypeSNodeType
8983: oChoice 9009
8985: oGetLocal 1
8987: oChoice 8992
8989: oReturn
8990: oJumpForward 8995
8992: Choice Lookup Table
          38   8989
8995: oJumpForward 9014
8997: oGetLocal 1
8999: oChoice 9004
9001: oReturn
9002: oJumpForward 9007
9004: Choice Lookup Table
          37   9001
9007: oJumpForward 9014
9009: Choice Lookup Table
          38   8997
          37   8985
9014: oError 15
9016: oJumpForward 9021
9018: Choice Lookup Table
           0   8982
9021: oReturn
9022: oLocalSpace 0
9024: oTypeSNodeType
9025: oChoice 9029
9027: oJumpForward 9034
9029: Choice Lookup Table
          31   9027
9032: oError 7
9034: oTypeSPop
9035: oReturn
9036: oLocalSpace 0
9038: oTypeSNodeType
9039: oChoice 9043
9041: oJumpForward 9048
9043: Choice Lookup Table
          31   9041
9046: oError 7
9048: oReturn
9049: oLocalSpace 0
9051: oTypeSNodeType
9052: oChoice 9060
9054: oJumpForward 9067
9056: oEmit 32
9058: oJumpForward 9067
9060: Choice Lookup Table
          30   9056
          31   9054
9065: oError 7
9067: oTypeSPop
9068: oReturn
9069: oLocalSpace 0
9071: oTypeSNodeType
9072: oChoice 9087
9074: oJumpForward 9094
9076: oEmit 32
9078: oTypeSPop
9079: oGetGlobal 6
9081: oPushResult
9082: oTypeSPush
9083: oPop 1
9085: oJumpForward 9094
9087: Choice Lookup Table
          30   9076
          31   9074
9092: oError 7
9094: oReturn
9095: oLocalSpace 0
9097: oTypeSNodeType
9098: oChoice 9111
9100: oEmit 32
9102: oTypeSPop
9103: oGetGlobal 6
9105: oPushResult
9106: oTypeSPush
9107: oPop 1
9109: oJumpForward 9114
9111: Choice Lookup Table
          30   9100
9114: oReturn
9115: oLocalSpace 0
9117: oTypeSNodeType
9118: oChoice 9146
9120: oJumpForward 9155
9122: oEmit 34
9124: oTypeSPop
9125: oGetGlobal 13
9127: oPushResult
9128: oTypeSPush
9129: oPop 1
9131: oJumpForward 9155
9133: oEmit 32
9135: oEmit 34
9137: oTypeSPop
9138: oGetGlobal 13
9140: oPushResult
9141: oTypeSPush
9142: oPop 1
9144: oJumpForward 9155
9146: Choice Lookup Table
          30   9133
          31   9122
          33   9120
9153: oError 9
9155: oTypeSPop
9156: oReturn
9157: oLocalSpace 0
9159: oTypeSNodeType
9160: oChoice 9164
9162: oJumpForward 9169
9164: Choice Lookup Table
          34   9162
9167: oError 8
9169: oTypeSPop
9170: oReturn
9171: oLocalSpace 0
9173: oTypeSNodeType
9174: oChoice 9178
9176: oJumpForward 9183
9178: Choice Lookup Table
          34   9176
9181: oError 8
9183: oReturn
9184: oLocalSpace 0
9186: oInputChoice 9249
9188: oCall 10921
9190: oJumpForward 9280
9192: oCall 10928
9194: oJumpForward 9280
9196: oCall 11058
9198: oJumpForward 9280
9200: oCall 11065
9202: oJumpForward 9280
9204: oCall 10072
9206: oJumpForward 9280
9208: oCall 10395
9210: oJumpForward 9280
9212: oCall 10138
9214: oJumpForward 9280
9216: oCall 10315
9218: oJumpForward 9280
9220: oCall 10480
9222: oJumpForward 9280
9224: oCall 10448
9226: oJumpForward 9280
9228: oCall 10898
9230: oJumpForward 9280
9232: oCall 9281
9234: oJumpForward 9280
9236: oCall 10512
9238: oJumpForward 9280
9240: oCall 10846
9242: oJumpForward 9280
9244: oChangeIntLitToLabelIdent
9245: oCall 9281
9247: oJumpForward 9280
9249: Choice Lookup Table
           1   9244
          56   9240
          54   9236
           0   9232
          36   9228
          52   9224
          53   9220
          50   9216
          45   9212
          49   9208
          42   9204
          69   9200
          68   9196
          67   9192
          66   9188
9280: oReturn
9281: oLocalSpace 1
9283: oGetAddrLocal 1
9285: oPushResult
9286: oScopeFindRequire
9287: oAssign
9288: oGetAddrLocal 1
9290: oPushResult
9291: oCall 244
9293: oPop 1
9295: oGetLocal 1
9297: oPushResult
9298: oNodeType
9299: oPop 1
9301: oChoice 9341
9303: oGetLocal 1
9305: oPushResult
9306: oCall 9359
9308: oPop 1
9310: oCall 9184
9312: oJumpForward 9358
9314: oGetLocal 1
9316: oPushResult
9317: oCall 11460
9319: oPop 1
9321: oJumpForward 9358
9323: oGetLocal 1
9325: oPushResult
9326: oCall 9409
9328: oPop 1
9330: oJumpForward 9358
9332: oGetLocal 1
9334: oPushResult
9335: oCall 9505
9337: oPop 1
9339: oJumpForward 9358
9341: Choice Lookup Table
          13   9332
          20   9323
          25   9323
          23   9323
          22   9323
          12   9314
          27   9303
9356: oError 0
9358: oReturn
9359: oLocalSpace 0
9361: oGetParam 1
9363: oPushResult
9364: oSetResult 36
9366: oPushResult
9367: oNodeGetBoolean
9368: oPop 2
9370: oChoice 9376
9372: oError 22
9374: oJumpForward 9379
9376: Choice Lookup Table
           1   9372
9379: oEmit 89
9381: oGetParam 1
9383: oPushResult
9384: oSetResult 22
9386: oPushResult
9387: oNodeGetLabel
9388: oPop 2
9390: oPushResult
9391: oEmitLabel
9392: oPop 1
9394: oGetParam 1
9396: oPushResult
9397: oSetResult 36
9399: oPushResult
9400: oSetResult 1
9402: oPushResult
9403: oNodeSetBoolean
9404: oPop 3
9406: oInput 13
9408: oReturn
9409: oLocalSpace 0
9411: oGetParam 1
9413: oPushResult
9414: oSetResult 1
9416: oPushResult
9417: oCall 9665
9419: oPop 2
9421: oInput 5
9423: oCall 5024
9425: oCall 8622
9427: oCall 9430
9429: oReturn
9430: oLocalSpace 1
9432: oTypeSNodeType
9433: oChoice 9477
9435: oEmit 27
9437: oJumpForward 9503
9439: oEmit 28
9441: oJumpForward 9503
9443: oEmit 30
9445: oJumpForward 9503
9447: oError 17
9449: oJumpForward 9503
9451: oEmit 29
9453: oJumpForward 9503
9455: oGetAddrLocal 1
9457: oPushResult
9458: oTypeSTop
9459: oPushResult
9460: oSetResult 17
9462: oPushResult
9463: oNodeGetInt
9464: oPop 2
9466: oAssign
9467: oEmit 31
9469: oGetLocal 1
9471: oPushResult
9472: oEmitInt
9473: oPop 1
9475: oJumpForward 9503
9477: Choice Lookup Table
          43   9455
          41   9455
          39   9455
          38   9451
          37   9451
          29   9447
          33   9443
          36   9439
          30   9439
          34   9439
          44   9435
          31   9435
9502: oEndChoice
9503: oTypeSPop
9504: oReturn
9505: oLocalSpace 1
9507: oGetParam 1
9509: oPushResult
9510: oSetResult 6
9512: oPushResult
9513: oNodeGet
9514: oPop 2
9516: oPushResult
9517: oScopeCurrent
9518: oPushResult
9519: oNodeEqual
9520: oPop 2
9522: oChoice 9528
9524: oError 21
9526: oJumpForward 9531
9528: Choice Lookup Table
           0   9524
9531: oEmit 8
9533: oGetParam 1
9535: oPushResult
9536: oSetResult 31
9538: oPushResult
9539: oNodeGetInt
9540: oPop 2
9542: oPushResult
9543: oEmitInt
9544: oPop 1
9546: oGetParam 1
9548: oPushResult
9549: oSetResult 21
9551: oPushResult
9552: oNodeGet
9553: oPop 2
9555: oPushResult
9556: oTypeSPush
9557: oPop 1
9559: oInput 5
9561: oCall 5024
9563: oCall 8622
9565: oTypeSNodeType
9566: oChoice 9610
9568: oEmit 27
9570: oJumpForward 9636
9572: oEmit 28
9574: oJumpForward 9636
9576: oEmit 30
9578: oJumpForward 9636
9580: oError 17
9582: oJumpForward 9636
9584: oEmit 29
9586: oJumpForward 9636
9588: oGetAddrLocal 1
9590: oPushResult
9591: oTypeSTop
9592: oPushResult
9593: oSetResult 17
9595: oPushResult
9596: oNodeGetInt
9597: oPop 2
9599: oAssign
9600: oEmit 31
9602: oGetLocal 1
9604: oPushResult
9605: oEmitInt
9606: oPop 1
9608: oJumpForward 9636
9610: Choice Lookup Table
          43   9588
          41   9588
          39   9588
          38   9584
          37   9584
          29   9580
          33   9576
          36   9572
          30   9572
          34   9572
          44   9568
          31   9568
9635: oEndChoice
9636: oTypeSPop
9637: oReturn
9638: oLocalSpace 1
9640: oInput 0
9642: oGetAddrLocal 1
9644: oPushResult
9645: oScopeFindRequire
9646: oAssign
9647: oGetAddrLocal 1
9649: oPushResult
9650: oCall 244
9652: oPop 1
9654: oGetLocal 1
9656: oPushResult
9657: oGetParam 1
9659: oPushResult
9660: oCall 9665
9662: oPop 2
9664: oReturn
9665: oLocalSpace 0
9667: oGetParam 2
9669: oPushResult
9670: oNodeType
9671: oPop 1
9673: oChoice 9736
9675: oGetParam 2
9677: oPushResult
9678: oGetParam 1
9680: oPushResult
9681: oCall 9882
9683: oPop 2
9685: oJumpForward 9749
9687: oGetParam 2
9689: oPushResult
9690: oSetResult 21
9692: oPushResult
9693: oNodeGet
9694: oPop 2
9696: oPushResult
9697: oTypeSPush
9698: oPop 1
9700: oInput 15
9702: oGetParam 1
9704: oPushResult
9705: oCall 9638
9707: oPop 1
9709: oInput 16
9711: oCall 9750
9713: oTypeSNodeType
9714: oChoice 9729
9716: oInputChoice 9724
9718: oEmit 26
9720: oCall 8200
9722: oJumpForward 9727
9724: Choice Lookup Table
          17   9718
9727: oJumpForward 9732
9729: Choice Lookup Table
          37   9716
9732: oCall 8005
9734: oJumpForward 9749
9736: Choice Lookup Table
          20   9687
          26   9675
          25   9675
          23   9675
          22   9675
9747: oError 4
9749: oReturn
9750: oLocalSpace 1
9752: oGetAddrLocal 1
9754: oPushResult
9755: oTypeSNodeType
9756: oAssign
9757: oTypeSPop
9758: oGetLocal 1
9760: oPushResult
9761: oTypeSNodeType
9762: oPushResult
9763: equal_node_type
9764: oPop 2
9766: oChoice 9878
9768: oTypeSNodeType
9769: oChoice 9857
9771: oGetLocal 1
9773: oChoice 9783
9775: oError 31
9777: oReturn
9778: oJumpForward 9794
9780: oReturn
9781: oJumpForward 9794
9783: Choice Lookup Table
          44   9780
          31   9780
          34   9775
          36   9775
          30   9775
9794: oJumpForward 9874
9796: oGetLocal 1
9798: oChoice 9808
9800: oReturn
9801: oJumpForward 9819
9803: oError 31
9805: oReturn
9806: oJumpForward 9819
9808: Choice Lookup Table
          44   9803
          31   9803
          34   9800
          36   9800
          30   9800
9819: oJumpForward 9874
9821: oGetLocal 1
9823: oChoice 9828
9825: oReturn
9826: oJumpForward 9831
9828: Choice Lookup Table
          38   9825
9831: oJumpForward 9874
9833: oGetLocal 1
9835: oChoice 9840
9837: oReturn
9838: oJumpForward 9843
9840: Choice Lookup Table
          37   9837
9843: oJumpForward 9874
9845: oGetLocal 1
9847: oChoice 9852
9849: oReturn
9850: oJumpForward 9855
9852: Choice Lookup Table
          42   9849
9855: oJumpForward 9874
9857: Choice Lookup Table
          43   9845
          38   9833
          37   9821
          34   9796
          36   9796
          30   9796
          44   9771
          31   9771
9874: oError 15
9876: oJumpForward 9881
9878: Choice Lookup Table
           0   9768
9881: oReturn
9882: oLocalSpace 0
9884: oGetParam 2
9886: oPushResult
9887: oNodeType
9888: oPop 1
9890: oChoice 9972
9892: oEmit 17
9894: oGetParam 2
9896: oPushResult
9897: oCall 14499
9899: oPop 1
9901: oJumpForward 9983
9903: oEmit 18
9905: oGetParam 2
9907: oPushResult
9908: oCall 14499
9910: oPop 1
9912: oJumpForward 9983
9914: oGetParam 2
9916: oPushResult
9917: oSetResult 35
9919: oPushResult
9920: oNodeGetBoolean
9921: oPop 2
9923: oChoice 9936
9925: oEmit 8
9927: oGetParam 2
9929: oPushResult
9930: oCall 14499
9932: oPop 1
9934: oJumpForward 9948
9936: Choice Lookup Table
           1   9925
9939: oEmit 19
9941: oGetParam 2
9943: oPushResult
9944: oCall 14499
9946: oPop 1
9948: oJumpForward 9983
9950: oGetParam 1
9952: oChoice 9965
9954: oEmit 17
9956: oGetParam 2
9958: oPushResult
9959: oCall 14499
9961: oPop 1
9963: oJumpForward 9970
9965: Choice Lookup Table
           0   9954
9968: oError 4
9970: oJumpForward 9983
9972: Choice Lookup Table
          26   9950
          25   9914
          23   9903
          22   9892
9981: oError 4
9983: oGetParam 2
9985: oPushResult
9986: oSetResult 21
9988: oPushResult
9989: oNodeGet
9990: oPop 2
9992: oPushResult
9993: oTypeSPush
9994: oPop 1
9996: oTypeSNodeType
9997: oChoice 10012
9999: oInputChoice 10007
10001: oEmit 26
10003: oCall 8200
10005: oJumpForward 10010
10007: Choice Lookup Table
          17   10001
10010: oJumpForward 10015
10012: Choice Lookup Table
          37   9999
10015: oCall 8005
10017: oReturn
10018: oLocalSpace 0
10020: oGetParam 1
10022: oPushResult
10023: oSetResult 1
10025: oPushResult
10026: oCall 9882
10028: oPop 2
10030: oCall 9022
10032: oGetParam 1
10034: oPushResult
10035: oCall 7192
10037: oPop 1
10039: oTypeSPop
10040: oEmit 35
10042: oEmit 27
10044: oReturn
10045: oLocalSpace 0
10047: oGetParam 1
10049: oPushResult
10050: oSetResult 1
10052: oPushResult
10053: oCall 9882
10055: oPop 2
10057: oCall 9022
10059: oGetParam 1
10061: oPushResult
10062: oCall 7192
10064: oPop 1
10066: oTypeSPop
10067: oEmit 36
10069: oEmit 27
10071: oReturn
10072: oLocalSpace 2
10074: oGetAddrLocal 1
10076: oPushResult
10077: oSetResult 0
10079: oAssign
10080: oGetAddrLocal 1
10082: oPushResult
10083: oCall 5070
10085: oPop 1
10087: oInput 43
10089: oCall 9184
10091: oInputChoice 10126
10093: oGetAddrLocal 2
10095: oPushResult
10096: oLabelNew
10097: oAssign
10098: oEmit 80
10100: oGetLocal 2
10102: oPushResult
10103: oEmitLabel
10104: oPop 1
10106: oEmit 89
10108: oGetLocal 1
10110: oPushResult
10111: oEmitLabel
10112: oPop 1
10114: oCall 9184
10116: oEmit 89
10118: oGetLocal 2
10120: oPushResult
10121: oEmitLabel
10122: oPop 1
10124: oJumpForward 10137
10126: Choice Lookup Table
          44   10093
10129: oEmit 89
10131: oGetLocal 1
10133: oPushResult
10134: oEmitLabel
10135: oPop 1
10137: oReturn
10138: oLocalSpace 4
10140: oInput 0
10142: oGetAddrLocal 1
10144: oPushResult
10145: oScopeFindRequire
10146: oAssign
10147: oGetLocal 1
10149: oPushResult
10150: oSetResult 1
10152: oPushResult
10153: oCall 9882
10155: oPop 2
10157: oCall 9022
10159: oInput 5
10161: oCall 5024
10163: oCall 9022
10165: oEmit 27
10167: oGetAddrLocal 2
10169: oPushResult
10170: oLabelNew
10171: oAssign
10172: oGetAddrLocal 3
10174: oPushResult
10175: oLabelNew
10176: oAssign
10177: oEmit 80
10179: oGetLocal 3
10181: oPushResult
10182: oEmitLabel
10183: oPop 1
10185: oGetAddrLocal 4
10187: oPushResult
10188: oLabelNew
10189: oAssign
10190: oEmit 89
10192: oGetLocal 4
10194: oPushResult
10195: oEmitLabel
10196: oPop 1
10198: oInputChoice 10278
10200: oGetLocal 1
10202: oPushResult
10203: oCall 10018
10205: oPop 1
10207: oEmit 89
10209: oGetLocal 3
10211: oPushResult
10212: oEmitLabel
10213: oPop 1
10215: oGetLocal 1
10217: oPushResult
10218: oCall 7192
10220: oPop 1
10222: oTypeSPop
10223: oCall 5024
10225: oCall 9022
10227: oEmit 59
10229: oEmit 81
10231: oGetLocal 2
10233: oPushResult
10234: oEmitLabel
10235: oPop 1
10237: oJumpForward 10284
10239: oGetLocal 1
10241: oPushResult
10242: oCall 10045
10244: oPop 1
10246: oEmit 89
10248: oGetLocal 3
10250: oPushResult
10251: oEmitLabel
10252: oPop 1
10254: oGetLocal 1
10256: oPushResult
10257: oCall 7192
10259: oPop 1
10261: oTypeSPop
10262: oCall 5024
10264: oCall 9022
10266: oEmit 60
10268: oEmit 81
10270: oGetLocal 2
10272: oPushResult
10273: oEmitLabel
10274: oPop 1
10276: oJumpForward 10284
10278: Choice Lookup Table
          47   10239
          46   10200
10283: oEndChoice
10284: oGetLocal 4
10286: oPushResult
10287: oGetLocal 2
10289: oPushResult
10290: oLoopPush
10291: oPop 2
10293: oInput 48
10295: oCall 9184
10297: oEmit 80
10299: oGetLocal 4
10301: oPushResult
10302: oEmitLabel
10303: oPop 1
10305: oEmit 89
10307: oGetLocal 2
10309: oPushResult
10310: oEmitLabel
10311: oPop 1
10313: oLoopPop
10314: oReturn
10315: oLocalSpace 3
10317: oGetAddrLocal 1
10319: oPushResult
10320: oLabelNew
10321: oAssign
10322: oEmit 89
10324: oGetLocal 1
10326: oPushResult
10327: oEmitLabel
10328: oPop 1
10330: oGetAddrLocal 2
10332: oPushResult
10333: oLabelNew
10334: oAssign
10335: oGetLocal 1
10337: oPushResult
10338: oGetLocal 2
10340: oPushResult
10341: oLoopPush
10342: oPop 2
10344: oCall 9184
10346: oInputChoice 10377
10348: oCall 9184
10350: oJumpForward 10383
10352: oGetAddrLocal 3
10354: oPushResult
10355: oCall 5070
10357: oPop 1
10359: oEmit 90
10361: oGetLocal 3
10363: oPushResult
10364: oEmitLabel
10365: oPop 1
10367: oGetLocal 1
10369: oPushResult
10370: oEmitLabel
10371: oPop 1
10373: oJumpForward 10385
10375: oJumpForward 10383
10377: Choice Lookup Table
          51   10352
           6   10348
10382: oEndChoice
10383: oJumpBack 10346
10385: oEmit 89
10387: oGetLocal 2
10389: oPushResult
10390: oEmitLabel
10391: oPop 1
10393: oLoopPop
10394: oReturn
10395: oLocalSpace 2
10397: oGetAddrLocal 1
10399: oPushResult
10400: oLabelNew
10401: oAssign
10402: oEmit 89
10404: oGetLocal 1
10406: oPushResult
10407: oEmitLabel
10408: oPop 1
10410: oGetAddrLocal 2
10412: oPushResult
10413: oCall 5070
10415: oPop 1
10417: oGetLocal 1
10419: oPushResult
10420: oGetLocal 2
10422: oPushResult
10423: oLoopPush
10424: oPop 2
10426: oInput 48
10428: oCall 9184
10430: oEmit 80
10432: oGetLocal 1
10434: oPushResult
10435: oEmitLabel
10436: oPop 1
10438: oEmit 89
10440: oGetLocal 2
10442: oPushResult
10443: oEmitLabel
10444: oPop 1
10446: oLoopPop
10447: oReturn
10448: oLocalSpace 0
10450: oLoopContinueLabel
10451: oPushResult
10452: oSetResult 0
10454: oPushResult
10455: equal_label
10456: oPop 2
10458: oChoice 10473
10460: oError 19
10462: oJumpForward 10479
10464: oEmit 80
10466: oLoopContinueLabel
10467: oPushResult
10468: oEmitLabel
10469: oPop 1
10471: oJumpForward 10479
10473: Choice Lookup Table
           0   10464
           1   10460
10478: oEndChoice
10479: oReturn
10480: oLocalSpace 0
10482: oLoopBreakLabel
10483: oPushResult
10484: oSetResult 0
10486: oPushResult
10487: equal_label
10488: oPop 2
10490: oChoice 10505
10492: oError 19
10494: oJumpForward 10511
10496: oEmit 80
10498: oLoopBreakLabel
10499: oPushResult
10500: oEmitLabel
10501: oPop 1
10503: oJumpForward 10511
10505: Choice Lookup Table
           0   10496
           1   10492
10510: oEndChoice
10511: oReturn
10512: oLocalSpace 8
10514: oGetAddrLocal 1
10516: oPushResult
10517: oCodeNew
10518: oAssign
10519: oGetAddrLocal 2
10521: oPushResult
10522: oLabelNew
10523: oAssign
10524: oGetAddrLocal 3
10526: oPushResult
10527: oLabelNew
10528: oAssign
10529: oGetAddrLocal 4
10531: oPushResult
10532: oGetLocal 3
10534: oAssign
10535: oGetAddrLocal 5
10537: oPushResult
10538: oSetResult 0
10540: oAssign
10541: oCall 5024
10543: oTypeSNodeType
10544: oChoice 10582
10546: oEmit 83
10548: oGetLocal 2
10550: oPushResult
10551: oEmitLabel
10552: oPop 1
10554: oJumpForward 10599
10556: oEmit 84
10558: oGetLocal 2
10560: oPushResult
10561: oEmitLabel
10562: oPop 1
10564: oJumpForward 10599
10566: oGetAddrLocal 5
10568: oPushResult
10569: oSetResult 1
10571: oAssign
10572: oEmit 85
10574: oGetLocal 2
10576: oPushResult
10577: oEmitLabel
10578: oPop 1
10580: oJumpForward 10599
10582: Choice Lookup Table
          42   10566
          43   10566
          44   10556
          31   10556
          36   10546
          30   10546
          34   10546
10597: oError 18
10599: oInput 41
10601: oInputChoice 10648
10603: oGetAddrLocal 4
10605: oPushResult
10606: oLabelNew
10607: oAssign
10608: oEmit 89
10610: oGetLocal 4
10612: oPushResult
10613: oEmitLabel
10614: oPop 1
10616: oInputChoice 10622
10618: oJumpForward 10640
10620: oJumpForward 10638
10622: Choice Lookup Table
          37   10618
10625: oCall 9184
10627: oInputChoice 10631
10629: oJumpForward 10638
10631: Choice Lookup Table
           6   10629
10634: oInput 37
10636: oJumpForward 10640
10638: oJumpBack 10616
10640: oJumpForward 10814
10642: oJumpForward 10812
10644: oJumpForward 10814
10646: oJumpForward 10812
10648: Choice Lookup Table
          37   10644
          44   10603
          55   10603
10655: oGetAddrLocal 6
10657: oPushResult
10658: oLabelNew
10659: oAssign
10660: oGetLocal 1
10662: oPushResult
10663: oCodePush
10664: oPop 1
10666: oCall 3568
10668: oCall 4460
10670: oGetLocal 5
10672: oChoice 10692
10674: oGetAddrLocal 7
10676: oPushResult
10677: oValueTopString
10678: oPushResult
10679: oStringAllocShortStringLit
10680: oPop 1
10682: oAssign
10683: oJumpForward 10698
10685: oGetAddrLocal 7
10687: oPushResult
10688: oValueTop
10689: oAssign
10690: oJumpForward 10698
10692: Choice Lookup Table
           0   10685
           1   10674
10697: oEndChoice
10698: oValuePop
10699: oInputChoice 10756
10701: oCall 3568
10703: oCall 4460
10705: oGetLocal 5
10707: oChoice 10727
10709: oGetAddrLocal 8
10711: oPushResult
10712: oValueTopString
10713: oPushResult
10714: oStringAllocShortStringLit
10715: oPop 1
10717: oAssign
10718: oJumpForward 10733
10720: oGetAddrLocal 8
10722: oPushResult
10723: oValueTop
10724: oAssign
10725: oJumpForward 10733
10727: Choice Lookup Table
           0   10720
           1   10709
10732: oEndChoice
10733: oValuePop
10734: oEmit 87
10736: oGetLocal 7
10738: oPushResult
10739: oEmitInt
10740: oPop 1
10742: oGetLocal 8
10744: oPushResult
10745: oEmitInt
10746: oPop 1
10748: oGetLocal 6
10750: oPushResult
10751: oEmitLabel
10752: oPop 1
10754: oJumpForward 10773
10756: Choice Lookup Table
          22   10701
10759: oEmit 86
10761: oGetLocal 7
10763: oPushResult
10764: oEmitInt
10765: oPop 1
10767: oGetLocal 6
10769: oPushResult
10770: oEmitLabel
10771: oPop 1
10773: oInputChoice 10777
10775: oJumpForward 10782
10777: Choice Lookup Table
          14   10775
10780: oJumpForward 10784
10782: oJumpBack 10666
10784: oCodePop
10785: oInput 13
10787: oEmit 89
10789: oGetLocal 6
10791: oPushResult
10792: oEmitLabel
10793: oPop 1
10795: oCall 9184
10797: oEmit 80
10799: oGetLocal 3
10801: oPushResult
10802: oEmitLabel
10803: oPop 1
10805: oInputChoice 10809
10807: oJumpForward 10812
10809: Choice Lookup Table
           6   10807
10812: oJumpBack 10601
10814: oEmit 89
10816: oGetLocal 2
10818: oPushResult
10819: oEmitLabel
10820: oPop 1
10822: oGetLocal 1
10824: oPushResult
10825: oEmitCode
10826: oPop 1
10828: oEmit 88
10830: oGetLocal 4
10832: oPushResult
10833: oEmitLabel
10834: oPop 1
10836: oEmit 89
10838: oGetLocal 3
10840: oPushResult
10841: oEmitLabel
10842: oPop 1
10844: oTypeSPop
10845: oReturn
10846: oLocalSpace 1
10848: oInputChoice 10855
10850: oJumpForward 10861
10852: oChangeIntLitToLabelIdent
10853: oJumpForward 10861
10855: Choice Lookup Table
           1   10852
           0   10850
10860: oEndChoice
10861: oGetAddrLocal 1
10863: oPushResult
10864: oScopeCurrent
10865: oPushResult
10866: oScopeFindRequireInScope
10867: oPop 1
10869: oAssign
10870: oGetLocal 1
10872: oPushResult
10873: oSetResult 28
10875: oPushResult
10876: oSetResult 1
10878: oPushResult
10879: oNodeSetBoolean
10880: oPop 3
10882: oEmit 80
10884: oGetLocal 1
10886: oPushResult
10887: oSetResult 22
10889: oPushResult
10890: oNodeGetLabel
10891: oPop 2
10893: oPushResult
10894: oEmitLabel
10895: oPop 1
10897: oReturn
10898: oLocalSpace 0
10900: oCall 9184
10902: oInputChoice 10912
10904: oCall 9184
10906: oJumpForward 10918
10908: oJumpForward 10920
10910: oJumpForward 10918
10912: Choice Lookup Table
          37   10908
           6   10904
10917: oEndChoice
10918: oJumpBack 10902
10920: oReturn
10921: oLocalSpace 0
10923: oCall 10928
10925: oEmit 100
10927: oReturn
10928: oLocalSpace 0
10930: oInputChoice 11054
10932: oCall 5024
10934: oTypeSNodeType
10935: oChoice 11010
10937: oEmit 92
10939: oJumpForward 11035
10941: oEmit 93
10943: oJumpForward 11035
10945: oEmit 32
10947: oEmit 92
10949: oJumpForward 11035
10951: oEmit 94
10953: oJumpForward 11035
10955: oEmit 99
10957: oJumpForward 11035
10959: oEmit 95
10961: oJumpForward 11035
10963: oError 17
10965: oJumpForward 11035
10967: oEmit 17
10969: oTypeSTop
10970: oPushResult
10971: oSetResult 44
10973: oPushResult
10974: oNodeGetInt
10975: oPop 2
10977: oPushResult
10978: oEmitInt
10979: oPop 1
10981: oEmit 98
10983: oJumpForward 11035
10985: oTypeSTop
10986: oPushResult
10987: oGetGlobal 10
10989: oPushResult
10990: equal_node
10991: oPop 2
10993: oChoice 10999
10995: oEmit 96
10997: oJumpForward 11004
10999: Choice Lookup Table
           1   10995
11002: oEmit 97
11004: oJumpForward 11035
11006: oEmit 97
11008: oJumpForward 11035
11010: Choice Lookup Table
          38   11006
          37   10985
          44   10967
          29   10963
          42   10959
          43   10959
          33   10955
          36   10951
          30   10945
          34   10941
          31   10937
11033: oError 18
11035: oTypeSPop
11036: oInputChoice 11044
11038: oJumpForward 11052
11040: oJumpForward 11050
11042: oJumpForward 11050
11044: Choice Lookup Table
          14   11042
          16   11038
11049: oEndChoice
11050: oJumpBack 10932
11052: oJumpForward 11057
11054: Choice Lookup Table
          15   10932
11057: oReturn
11058: oLocalSpace 0
11060: oCall 11065
11062: oEmit 104
11064: oReturn
11065: oLocalSpace 1
11067: oInputChoice 11144
11069: oSetResult 1
11071: oPushResult
11072: oCall 9638
11074: oPop 1
11076: oTypeSNodeType
11077: oChoice 11116
11079: oEmit 101
11081: oJumpForward 11125
11083: oEmit 102
11085: oJumpForward 11125
11087: oGetAddrLocal 1
11089: oPushResult
11090: oTypeSTop
11091: oPushResult
11092: oSetResult 17
11094: oPushResult
11095: oNodeGetInt
11096: oPop 2
11098: oPushResult
11099: oSetResult 1
11101: oPushResult
11102: subtract
11103: oPop 2
11105: oAssign
11106: oEmit 103
11108: oGetLocal 1
11110: oPushResult
11111: oEmitInt
11112: oPop 1
11114: oJumpForward 11125
11116: Choice Lookup Table
          43   11087
          36   11083
          31   11079
11123: oError 18
11125: oTypeSPop
11126: oInputChoice 11134
11128: oJumpForward 11142
11130: oJumpForward 11140
11132: oJumpForward 11140
11134: Choice Lookup Table
          14   11132
          16   11128
11139: oEndChoice
11140: oJumpBack 11069
11142: oJumpForward 11147
11144: Choice Lookup Table
          15   11069
11147: oReturn
11148: oLocalSpace 1
11150: oGetAddrLocal 1
11152: oPushResult
11153: oGetGlobal 16
11155: oPushResult
11156: oScopeAllocType
11157: oPop 1
11159: oAssign
11160: oTypeSNodeType
11161: oChoice 11229
11163: oEmit 18
11165: oGetLocal 1
11167: oPushResult
11168: oEmitInt
11169: oPop 1
11171: oEmit 23
11173: oEmit 31
11175: oGetGlobal 16
11177: oPushResult
11178: oSetResult 17
11180: oPushResult
11181: oNodeGetInt
11182: oPop 2
11184: oPushResult
11185: oEmitInt
11186: oPop 1
11188: oJumpForward 11238
11190: oEmit 18
11192: oGetLocal 1
11194: oPushResult
11195: oEmitInt
11196: oPop 1
11198: oEmit 15
11200: oSetResult 1
11202: oPushResult
11203: oEmitInt
11204: oPop 1
11206: oEmit 28
11208: oEmit 18
11210: oGetLocal 1
11212: oPushResult
11213: oSetResult 1
11215: oPushResult
11216: add
11217: oPop 2
11219: oPushResult
11220: oEmitInt
11221: oPop 1
11223: oEmit 23
11225: oEmit 28
11227: oJumpForward 11238
11229: Choice Lookup Table
          36   11190
          42   11163
          43   11163
11236: oError 15
11238: oTypeSPop
11239: oEmit 18
11241: oGetLocal 1
11243: oPushResult
11244: oEmitInt
11245: oPop 1
11247: oGetGlobal 16
11249: oPushResult
11250: oTypeSPush
11251: oPop 1
11253: oGetLocal 1
11255: oReturn
11256: oReturn
11257: oLocalSpace 0
11259: oEmit 73
11261: oSetResult 16
11263: oPushResult
11264: oEmitInt
11265: oPop 1
11267: oEmit 20
11269: oSetResult 8
11271: oPushResult
11272: oEmitInt
11273: oPop 1
11275: oEmit 23
11277: oEmit 29
11279: oEmit 20
11281: oSetResult 0
11283: oPushResult
11284: oEmitInt
11285: oPop 1
11287: oEmit 23
11289: oEmit 29
11291: oEmit 76
11293: oGetGlobal 22
11295: oPushResult
11296: oCall 14499
11298: oPop 1
11300: oEmit 75
11302: oSetResult 16
11304: oPushResult
11305: oEmitInt
11306: oPop 1
11308: oTypeSPop
11309: oTypeSPop
11310: oReturn
11311: oLocalSpace 0
11313: oEmit 73
11315: oSetResult 12
11317: oPushResult
11318: oEmitInt
11319: oPop 1
11321: oEmit 20
11323: oSetResult 8
11325: oPushResult
11326: oEmitInt
11327: oPop 1
11329: oEmit 23
11331: oEmit 28
11333: oEmit 20
11335: oSetResult 0
11337: oPushResult
11338: oEmitInt
11339: oPop 1
11341: oEmit 23
11343: oEmit 29
11345: oEmit 76
11347: oGetGlobal 23
11349: oPushResult
11350: oCall 14499
11352: oPop 1
11354: oEmit 75
11356: oSetResult 12
11358: oPushResult
11359: oEmitInt
11360: oPop 1
11362: oTypeSPop
11363: oTypeSPop
11364: oReturn
11365: oLocalSpace 1
11367: oEmit 74
11369: oSetResult 24
11371: oPushResult
11372: oEmitInt
11373: oPop 1
11375: oEmit 20
11377: oSetResult 8
11379: oPushResult
11380: oEmitInt
11381: oPop 1
11383: oEmit 23
11385: oEmit 29
11387: oEmit 20
11389: oSetResult 0
11391: oPushResult
11392: oEmitInt
11393: oPop 1
11395: oEmit 23
11397: oEmit 29
11399: oGetAddrLocal 1
11401: oPushResult
11402: oGetGlobal 6
11404: oPushResult
11405: oScopeAllocType
11406: oPop 1
11408: oAssign
11409: oEmit 20
11411: oSetResult 16
11413: oPushResult
11414: oEmitInt
11415: oPop 1
11417: oEmit 18
11419: oGetLocal 1
11421: oPushResult
11422: oEmitInt
11423: oPop 1
11425: oEmit 29
11427: oEmit 77
11429: oGetGlobal 24
11431: oPushResult
11432: oCall 14499
11434: oPop 1
11436: oEmit 3
11438: oGetLocal 1
11440: oPushResult
11441: oEmitInt
11442: oPop 1
11444: oEmit 75
11446: oSetResult 24
11448: oPushResult
11449: oEmitInt
11450: oPop 1
11452: oTypeSPop
11453: oGetGlobal 6
11455: oPushResult
11456: oTypeSPush
11457: oPop 1
11459: oReturn
11460: oLocalSpace 10
11462: oGetParam 1
11464: oPushResult
11465: oSetResult 28
11467: oPushResult
11468: oSetResult 1
11470: oPushResult
11471: oNodeSetBoolean
11472: oPop 3
11474: oGetAddrLocal 1
11476: oPushResult
11477: oGetParam 1
11479: oPushResult
11480: oSetResult 27
11482: oPushResult
11483: oNodeGetBoolean
11484: oPop 2
11486: oAssign
11487: oGetAddrLocal 4
11489: oPushResult
11490: oGetParam 1
11492: oPushResult
11493: oNodeType
11494: oPop 1
11496: oPushResult
11497: oSetResult 13
11499: oPushResult
11500: equal_node_type
11501: oPop 2
11503: oAssign
11504: oGetLocal 4
11506: oChoice 11533
11508: oGetAddrLocal 2
11510: oPushResult
11511: oGetParam 1
11513: oPushResult
11514: oSetResult 21
11516: oPushResult
11517: oNodeGet
11518: oPop 2
11520: oAssign
11521: oGetAddrLocal 3
11523: oPushResult
11524: oGetLocal 2
11526: oPushResult
11527: oScopeAllocType
11528: oPop 1
11530: oAssign
11531: oJumpForward 11536
11533: Choice Lookup Table
           1   11508
11536: oGetAddrLocal 5
11538: oPushResult
11539: oGetParam 1
11541: oPushResult
11542: oSetResult 23
11544: oPushResult
11545: oNodeGet
11546: oPop 2
11548: oAssign
11549: oGetAddrLocal 6
11551: oPushResult
11552: oGetLocal 5
11554: oPushResult
11555: oSetResult 17
11557: oPushResult
11558: oNodeGetInt
11559: oPop 2
11561: oAssign
11562: oGetLocal 1
11564: oChoice 11586
11566: oEmit 74
11568: oGetLocal 6
11570: oPushResult
11571: oEmitInt
11572: oPop 1
11574: oJumpForward 11592
11576: oEmit 73
11578: oGetLocal 6
11580: oPushResult
11581: oEmitInt
11582: oPop 1
11584: oJumpForward 11592
11586: Choice Lookup Table
           0   11576
           1   11566
11591: oEndChoice
11592: oGetParam 1
11594: oPushResult
11595: oCall 14433
11597: oPop 1
11599: oPushResult
11600: oSetResult 0
11602: oPushResult
11603: greater
11604: oPop 2
11606: oChoice 11639
11608: oEmit 20
11610: oSetResult 0
11612: oPushResult
11613: oEmitInt
11614: oPop 1
11616: oEmit 21
11618: oGetParam 1
11620: oPushResult
11621: oCall 14453
11623: oPop 1
11625: oPushResult
11626: oEmitInt
11627: oPop 1
11629: oSetResult 0
11631: oPushResult
11632: oEmitInt
11633: oPop 1
11635: oEmit 29
11637: oJumpForward 11642
11639: Choice Lookup Table
           1   11608
11642: oGetAddrLocal 7
11644: oPushResult
11645: oGetLocal 5
11647: oPushResult
11648: oSetResult 15
11650: oPushResult
11651: oNodeGetIter
11652: oPop 2
11654: oAssign
11655: oGetAddrLocal 8
11657: oPushResult
11658: oGetLocal 7
11660: oPushResult
11661: oNodeIterValue
11662: oPop 1
11664: oAssign
11665: oInputChoice 11868
11667: oGetLocal 8
11669: oPushResult
11670: oNodeNull
11671: oPop 1
11673: oChoice 11679
11675: oJumpForward 11864
11677: oJumpForward 11682
11679: Choice Lookup Table
           1   11675
11682: oGetAddrLocal 9
11684: oPushResult
11685: oGetLocal 8
11687: oPushResult
11688: oSetResult 22
11690: oPushResult
11691: oNodeGetInt
11692: oPop 2
11694: oAssign
11695: oEmit 20
11697: oGetLocal 9
11699: oPushResult
11700: oEmitInt
11701: oPop 1
11703: oGetLocal 8
11705: oPushResult
11706: oSetResult 21
11708: oPushResult
11709: oNodeGet
11710: oPop 2
11712: oPushResult
11713: oTypeSPush
11714: oPop 1
11716: oGetLocal 8
11718: oPushResult
11719: oSetResult 35
11721: oPushResult
11722: oNodeGetBoolean
11723: oPop 2
11725: oChoice 11817
11727: oSetResult 1
11729: oPushResult
11730: oCall 9638
11732: oPop 1
11734: oCall 8964
11736: oEmit 29
11738: oJumpForward 11823
11740: oCall 5024
11742: oCall 8622
11744: oTypeSNodeType
11745: oChoice 11789
11747: oEmit 27
11749: oJumpForward 11815
11751: oEmit 28
11753: oJumpForward 11815
11755: oEmit 30
11757: oJumpForward 11815
11759: oError 17
11761: oJumpForward 11815
11763: oEmit 29
11765: oJumpForward 11815
11767: oGetAddrLocal 10
11769: oPushResult
11770: oTypeSTop
11771: oPushResult
11772: oSetResult 17
11774: oPushResult
11775: oNodeGetInt
11776: oPop 2
11778: oAssign
11779: oEmit 31
11781: oGetLocal 10
11783: oPushResult
11784: oEmitInt
11785: oPop 1
11787: oJumpForward 11815
11789: Choice Lookup Table
          43   11767
          41   11767
          39   11767
          38   11763
          37   11763
          29   11759
          33   11755
          36   11751
          30   11751
          34   11751
          44   11747
          31   11747
11814: oEndChoice
11815: oJumpForward 11823
11817: Choice Lookup Table
           0   11740
           1   11727
11822: oEndChoice
11823: oTypeSPop
11824: oGetAddrLocal 7
11826: oPushResult
11827: oNodeIterNext
11828: oPop 1
11830: oGetAddrLocal 8
11832: oPushResult
11833: oGetLocal 7
11835: oPushResult
11836: oNodeIterValue
11837: oPop 1
11839: oAssign
11840: oGetLocal 8
11842: oPushResult
11843: oNodeNull
11844: oPop 1
11846: oChoice 11854
11848: oJumpForward 11864
11850: oJumpForward 11860
11852: oJumpForward 11860
11854: Choice Lookup Table
           0   11852
           1   11848
11859: oEndChoice
11860: oInput 14
11862: oJumpBack 11667
11864: oInput 16
11866: oJumpForward 11871
11868: Choice Lookup Table
          15   11667
11871: oGetLocal 8
11873: oPushResult
11874: oNodeNull
11875: oPop 1
11877: oChoice 11883
11879: oError 16
11881: oJumpForward 11886
11883: Choice Lookup Table
           0   11879
11886: oGetLocal 4
11888: oChoice 11917
11890: oEmit 20
11892: oGetParam 1
11894: oPushResult
11895: oSetResult 31
11897: oPushResult
11898: oNodeGetInt
11899: oPop 2
11901: oPushResult
11902: oEmitInt
11903: oPop 1
11905: oEmit 18
11907: oGetLocal 3
11909: oPushResult
11910: oEmitInt
11911: oPop 1
11913: oEmit 29
11915: oJumpForward 11920
11917: Choice Lookup Table
           1   11890
11920: oGetLocal 1
11922: oChoice 11946
11924: oEmit 77
11926: oGetParam 1
11928: oPushResult
11929: oCall 14499
11931: oPop 1
11933: oJumpForward 11952
11935: oEmit 76
11937: oGetParam 1
11939: oPushResult
11940: oCall 14499
11942: oPop 1
11944: oJumpForward 11952
11946: Choice Lookup Table
           0   11935
           1   11924
11951: oEndChoice
11952: oGetLocal 4
11954: oChoice 12035
11956: oGetLocal 2
11958: oPushResult
11959: oTypeSPush
11960: oPop 1
11962: oTypeSNodeType
11963: oChoice 12009
11965: oEmit 3
11967: oGetLocal 3
11969: oPushResult
11970: oEmitInt
11971: oPop 1
11973: oJumpForward 12033
11975: oEmit 4
11977: oGetLocal 3
11979: oPushResult
11980: oEmitInt
11981: oPop 1
11983: oJumpForward 12033
11985: oError 17
11987: oJumpForward 12033
11989: oEmit 5
11991: oGetLocal 3
11993: oPushResult
11994: oEmitInt
11995: oPop 1
11997: oJumpForward 12033
11999: oEmit 18
12001: oGetLocal 3
12003: oPushResult
12004: oEmitInt
12005: oPop 1
12007: oJumpForward 12033
12009: Choice Lookup Table
          43   11999
          41   11999
          39   11999
          38   11989
          37   11989
          29   11985
          36   11975
          30   11975
          34   11975
          44   11965
          31   11965
12032: oEndChoice
12033: oJumpForward 12038
12035: Choice Lookup Table
           1   11956
12038: oEmit 75
12040: oGetLocal 6
12042: oPushResult
12043: oEmitInt
12044: oPop 1
12046: oReturn
12047: oLocalSpace 2
12049: oGetAddrLocal 2
12051: oPushResult
12052: oGetParam 1
12054: oPushResult
12055: oSetResult 26
12057: oPushResult
12058: oNodeGetString
12059: oPop 2
12061: oAssign
12062: oGetLocal 2
12064: oPushResult
12065: oSetResult 0
12067: oPushResult
12068: equal_string
12069: oPop 2
12071: oChoice 12108
12073: oGetAddrLocal 1
12075: oPushResult
12076: oGetParam 1
12078: oPushResult
12079: oSetResult 4
12081: oPushResult
12082: oNodeGetInt
12083: oPop 2
12085: oPushResult
12086: ID_STRING
12087: oPop 1
12089: oPushResult
12090: oStringAllocLit
12091: oPop 1
12093: oAssign
12094: oJumpForward 12114
12096: oGetAddrLocal 1
12098: oPushResult
12099: oGetLocal 2
12101: oPushResult
12102: oStringAllocLit
12103: oPop 1
12105: oAssign
12106: oJumpForward 12114
12108: Choice Lookup Table
           0   12096
           1   12073
12113: oEndChoice
12114: oEmit 91
12116: oGetParam 1
12118: oPushResult
12119: oCall 14499
12121: oPop 1
12123: oGetLocal 1
12125: oPushResult
12126: oEmitInt
12127: oPop 1
12129: oReturn
12130: oLocalSpace 2
12132: oGetParam 1
12134: oPushResult
12135: oGetGlobal 17
12137: oPushResult
12138: oNodeEqual
12139: oPop 2
12141: oChoice 12181
12143: oInput 15
12145: oCall 5024
12147: oTypeSNodeType
12148: oChoice 12156
12150: oJumpForward 12169
12152: oEmit 32
12154: oJumpForward 12169
12156: Choice Lookup Table
          36   12152
          30   12152
          34   12152
          44   12150
          31   12150
12167: oError 15
12169: oTypeSPop
12170: oGetGlobal 6
12172: oPushResult
12173: oTypeSPush
12174: oPop 1
12176: oInput 16
12178: oReturn
12179: oJumpForward 12184
12181: Choice Lookup Table
           1   12143
12184: oGetParam 1
12186: oPushResult
12187: oGetGlobal 18
12189: oPushResult
12190: oNodeEqual
12191: oPop 2
12193: oChoice 12227
12195: oInput 15
12197: oCall 5024
12199: oTypeSNodeType
12200: oChoice 12208
12202: oEmit 33
12204: oJumpForward 12215
12206: oJumpForward 12215
12208: Choice Lookup Table
          30   12206
          31   12202
12213: oError 15
12215: oTypeSPop
12216: oGetGlobal 9
12218: oPushResult
12219: oTypeSPush
12220: oPop 1
12222: oInput 16
12224: oReturn
12225: oJumpForward 12230
12227: Choice Lookup Table
           1   12195
12230: oGetParam 1
12232: oPushResult
12233: oGetGlobal 19
12235: oPushResult
12236: oNodeEqual
12237: oPop 2
12239: oChoice 12279
12241: oInput 15
12243: oCall 5024
12245: oTypeSNodeType
12246: oChoice 12267
12248: oTypeSTop
12249: oPushResult
12250: oSetResult 45
12252: oPushResult
12253: oNodeGetBoolean
12254: oPop 2
12256: oChoice 12262
12258: oError 29
12260: oJumpForward 12265
12262: Choice Lookup Table
           1   12258
12265: oJumpForward 12272
12267: Choice Lookup Table
          44   12248
12270: oError 15
12272: oEmit 36
12274: oInput 16
12276: oReturn
12277: oJumpForward 12282
12279: Choice Lookup Table
           1   12241
12282: oGetParam 1
12284: oPushResult
12285: oGetGlobal 20
12287: oPushResult
12288: oNodeEqual
12289: oPop 2
12291: oChoice 12331
12293: oInput 15
12295: oCall 5024
12297: oTypeSNodeType
12298: oChoice 12319
12300: oTypeSTop
12301: oPushResult
12302: oSetResult 45
12304: oPushResult
12305: oNodeGetBoolean
12306: oPop 2
12308: oChoice 12314
12310: oError 29
12312: oJumpForward 12317
12314: Choice Lookup Table
           1   12310
12317: oJumpForward 12324
12319: Choice Lookup Table
          44   12300
12322: oError 15
12324: oEmit 35
12326: oInput 16
12328: oReturn
12329: oJumpForward 12334
12331: Choice Lookup Table
           1   12293
12334: oGetParam 1
12336: oPushResult
12337: oGetGlobal 21
12339: oPushResult
12340: oNodeEqual
12341: oPop 2
12343: oChoice 12399
12345: oInput 15
12347: oGetAddrLocal 1
12349: oPushResult
12350: oCodeNew
12351: oAssign
12352: oGetLocal 1
12354: oPushResult
12355: oCodePush
12356: oPop 1
12358: oCall 5047
12360: oCodePop
12361: oGetLocal 1
12363: oPushResult
12364: oCodeDiscard
12365: oPop 1
12367: oGetAddrLocal 2
12369: oPushResult
12370: oTypeSTop
12371: oAssign
12372: oTypeSPop
12373: oEmit 15
12375: oGetLocal 2
12377: oPushResult
12378: oSetResult 17
12380: oPushResult
12381: oNodeGetInt
12382: oPop 2
12384: oPushResult
12385: oEmitInt
12386: oPop 1
12388: oGetGlobal 6
12390: oPushResult
12391: oTypeSPush
12392: oPop 1
12394: oInput 16
12396: oReturn
12397: oJumpForward 12402
12399: Choice Lookup Table
           1   12345
12402: oError 17
12404: oReturn
12405: oLocalSpace 1
12407: oGetAddrLocal 1
12409: oPushResult
12410: oGetParam 2
12412: oPushResult
12413: oNodeNew
12414: oPop 1
12416: oAssign
12417: oGetLocal 1
12419: oPushResult
12420: oSetResult 17
12422: oPushResult
12423: oGetParam 1
12425: oPushResult
12426: oNodeSetInt
12427: oPop 3
12429: oGetLocal 1
12431: oPushResult
12432: oTypeAdd
12433: oPop 1
12435: oGetLocal 1
12437: oReturn
12438: oReturn
12439: oLocalSpace 12
12441: oInputChoice 12924
12443: oGetAddrLocal 1
12445: oPushResult
12446: oScopeFindRequire
12447: oAssign
12448: oGetAddrLocal 1
12450: oPushResult
12451: oCall 244
12453: oPop 1
12455: oGetLocal 1
12457: oPushResult
12458: oNodeType
12459: oPop 1
12461: oChoice 12478
12463: oGetParam 1
12465: oPushResult
12466: oGetLocal 1
12468: oPushResult
12469: oSetResult 21
12471: oPushResult
12472: oNodeGet
12473: oPop 2
12475: oAssign
12476: oJumpForward 12489
12478: Choice Lookup Table
          20   12463
12481: oError 2
12483: oGetParam 1
12485: oPushResult
12486: oGetGlobal 6
12488: oAssign
12489: oJumpForward 12947
12491: oInput 17
12493: oGetAddrLocal 2
12495: oPushResult
12496: oNodeVecNew
12497: oAssign
12498: oGetAddrLocal 3
12500: oPushResult
12501: oSetResult 40
12503: oPushResult
12504: oNodeNew
12505: oPop 1
12507: oAssign
12508: oCall 3568
12510: oGetLocal 3
12512: oPushResult
12513: oSetResult 40
12515: oPushResult
12516: oValueTop
12517: oPushResult
12518: oNodeSetInt
12519: oPop 3
12521: oValuePop
12522: oInput 22
12524: oCall 3568
12526: oGetLocal 3
12528: oPushResult
12529: oSetResult 41
12531: oPushResult
12532: oValueTop
12533: oPushResult
12534: oNodeSetInt
12535: oPop 3
12537: oValuePop
12538: oCall 4363
12540: oGetLocal 3
12542: oPushResult
12543: oSetResult 38
12545: oPushResult
12546: oTypeSTop
12547: oPushResult
12548: oNodeSet
12549: oPop 3
12551: oGetLocal 3
12553: oPushResult
12554: oSetResult 17
12556: oPushResult
12557: oTypeSTop
12558: oPushResult
12559: oSetResult 17
12561: oPushResult
12562: oNodeGetInt
12563: oPop 2
12565: oPushResult
12566: oNodeSetInt
12567: oPop 3
12569: oTypeSPop
12570: oGetLocal 3
12572: oPushResult
12573: oTypeAdd
12574: oPop 1
12576: oGetAddrLocal 4
12578: oPushResult
12579: oSetResult 39
12581: oPushResult
12582: oNodeNew
12583: oPop 1
12585: oAssign
12586: oGetLocal 4
12588: oPushResult
12589: oSetResult 39
12591: oPushResult
12592: oGetLocal 3
12594: oPushResult
12595: oNodeSet
12596: oPop 3
12598: oGetLocal 2
12600: oPushResult
12601: oGetLocal 4
12603: oPushResult
12604: oNodeVecAppend
12605: oPop 2
12607: oInputChoice 12615
12609: oJumpForward 12623
12611: oJumpForward 12621
12613: oJumpForward 12621
12615: Choice Lookup Table
          14   12613
          18   12609
12620: oEndChoice
12621: oJumpBack 12498
12623: oInput 41
12625: oGetAddrLocal 5
12627: oPushResult
12628: oCall 12439
12630: oPop 1
12632: oGetAddrLocal 6
12634: oPushResult
12635: oGetLocal 2
12637: oPushResult
12638: oNodeVecSize
12639: oPop 1
12641: oAssign
12642: oGetAddrLocal 6
12644: oPushResult
12645: dec
12646: oPop 1
12648: oGetAddrLocal 7
12650: oPushResult
12651: oGetLocal 2
12653: oPushResult
12654: oGetLocal 6
12656: oPushResult
12657: oNodeVecElement
12658: oPop 2
12660: oAssign
12661: oGetLocal 7
12663: oPushResult
12664: oSetResult 38
12666: oPushResult
12667: oGetLocal 5
12669: oPushResult
12670: oNodeSet
12671: oPop 3
12673: oGetAddrLocal 8
12675: oPushResult
12676: oGetLocal 7
12678: oPushResult
12679: oSetResult 39
12681: oPushResult
12682: oNodeGet
12683: oPop 2
12685: oAssign
12686: oGetAddrLocal 9
12688: oPushResult
12689: oGetLocal 8
12691: oPushResult
12692: oSetResult 41
12694: oPushResult
12695: oNodeGetInt
12696: oPop 2
12698: oPushResult
12699: oGetLocal 8
12701: oPushResult
12702: oSetResult 40
12704: oPushResult
12705: oNodeGetInt
12706: oPop 2
12708: oPushResult
12709: subtract
12710: oPop 2
12712: oAssign
12713: oGetAddrLocal 9
12715: oPushResult
12716: inc
12717: oPop 1
12719: oGetLocal 7
12721: oPushResult
12722: oSetResult 17
12724: oPushResult
12725: oGetLocal 9
12727: oPushResult
12728: oGetLocal 5
12730: oPushResult
12731: oSetResult 17
12733: oPushResult
12734: oNodeGetInt
12735: oPop 2
12737: oPushResult
12738: multiply
12739: oPop 2
12741: oPushResult
12742: oNodeSetInt
12743: oPop 3
12745: oGetLocal 7
12747: oPushResult
12748: oTypeAdd
12749: oPop 1
12751: oGetAddrLocal 5
12753: oPushResult
12754: oGetLocal 7
12756: oAssign
12757: oGetLocal 6
12759: oPushResult
12760: equal_zero
12761: oPop 1
12763: oChoice 12769
12765: oJumpForward 12774
12767: oJumpForward 12772
12769: Choice Lookup Table
           1   12765
12772: oJumpBack 12642
12774: oGetParam 1
12776: oPushResult
12777: oGetLocal 2
12779: oPushResult
12780: oSetResult 0
12782: oPushResult
12783: oNodeVecElement
12784: oPop 2
12786: oAssign
12787: oGetLocal 2
12789: oPushResult
12790: oNodeVecDelete
12791: oPop 1
12793: oJumpForward 12947
12795: oGetAddrLocal 10
12797: oPushResult
12798: oCall 12439
12800: oPop 1
12802: oGetParam 1
12804: oPushResult
12805: oGetLocal 10
12807: oPushResult
12808: oCall 13518
12810: oPop 1
12812: oAssign
12813: oJumpForward 12947
12815: oGetParam 1
12817: oPushResult
12818: oSetResult 41
12820: oPushResult
12821: oNodeNew
12822: oPop 1
12824: oAssign
12825: oSetResult -1
12827: oPushResult
12828: oSetResult 2
12830: oPushResult
12831: oScopeBegin
12832: oPop 2
12834: oSetResult 24
12836: oPushResult
12837: oCall 3269
12839: oPop 1
12841: oGetAddrLocal 11
12843: oPushResult
12844: oScopeCurrent
12845: oPushResult
12846: oSetResult 17
12848: oPushResult
12849: oNodeGetInt
12850: oPop 2
12852: oAssign
12853: oGetLocal 11
12855: oPushResult
12856: equal_zero
12857: oPop 1
12859: oChoice 12865
12861: oError 20
12863: oJumpForward 12868
12865: Choice Lookup Table
           1   12861
12868: oInput 37
12870: oGetFromParam 1
12872: oPushResult
12873: oSetResult 42
12875: oPushResult
12876: oScopeCurrent
12877: oPushResult
12878: oNodeSet
12879: oPop 3
12881: oGetFromParam 1
12883: oPushResult
12884: oSetResult 17
12886: oPushResult
12887: oGetLocal 11
12889: oPushResult
12890: oNodeSetInt
12891: oPop 3
12893: oScopeEnd
12894: oGetFromParam 1
12896: oPushResult
12897: oTypeAdd
12898: oPop 1
12900: oJumpForward 12947
12902: oGetParam 1
12904: oPushResult
12905: oCall 12948
12907: oPop 1
12909: oJumpForward 12947
12911: oInput 41
12913: oGetAddrLocal 12
12915: oPushResult
12916: oCall 12439
12918: oPop 1
12920: oError 17
12922: oJumpForward 12947
12924: Choice Lookup Table
          40   12911
          15   12902
          39   12815
          19   12795
          38   12491
           0   12443
12937: oCall 3568
12939: oInput 22
12941: oCall 3568
12943: oCall 4363
12945: oError 17
12947: oReturn
12948: oLocalSpace 11
12950: oGetParam 1
12952: oPushResult
12953: oSetResult 44
12955: oPushResult
12956: oNodeNew
12957: oPop 1
12959: oAssign
12960: oGetAddrLocal 1
12962: oPushResult
12963: oSetResult 0
12965: oAssign
12966: oGetAddrLocal 2
12968: oPushResult
12969: oSetResult 0
12971: oAssign
12972: oGetAddrLocal 3
12974: oPushResult
12975: oSetResult 1
12977: oAssign
12978: oGetAddrLocal 4
12980: oPushResult
12981: oScopeCurrent
12982: oAssign
12983: oSetResult -1
12985: oPushResult
12986: oSetResult 2
12988: oPushResult
12989: oScopeBegin
12990: oPop 2
12992: oInput 0
12994: oGetAddrLocal 5
12996: oPushResult
12997: oSetResult 17
12999: oPushResult
13000: LAST_ID
13001: oPushResult
13002: oCall 14471
13004: oPop 2
13006: oAssign
13007: oGetAddrLocal 6
13009: oPushResult
13010: oSetResult 17
13012: oPushResult
13013: LAST_ID
13014: oPushResult
13015: oCall 14471
13017: oPop 2
13019: oAssign
13020: oGetLocal 5
13022: oPushResult
13023: oSetResult 21
13025: oPushResult
13026: oGetFromParam 1
13028: oPushResult
13029: oNodeSet
13030: oPop 3
13032: oGetLocal 6
13034: oPushResult
13035: oSetResult 21
13037: oPushResult
13038: oGetFromParam 1
13040: oPushResult
13041: oNodeSet
13042: oPop 3
13044: oGetAddrLocal 7
13046: oPushResult
13047: LAST_ID
13048: oPushResult
13049: ID_STRING
13050: oPop 1
13052: oPushResult
13053: oStringAllocLit
13054: oPop 1
13056: oAssign
13057: oGetLocal 5
13059: oPushResult
13060: oSetResult 32
13062: oPushResult
13063: oGetLocal 7
13065: oPushResult
13066: oNodeSetInt
13067: oPop 3
13069: oGetLocal 6
13071: oPushResult
13072: oSetResult 32
13074: oPushResult
13075: oGetLocal 7
13077: oPushResult
13078: oNodeSetInt
13079: oPop 3
13081: oInputChoice 13159
13083: oGetGlobal 6
13085: oPushResult
13086: oTypeSPush
13087: oPop 1
13089: oCall 3568
13091: oCall 4460
13093: oTypeSPop
13094: oGetLocal 2
13096: oPushResult
13097: equal_zero
13098: oPop 1
13100: oChoice 13121
13102: oValueTop
13103: oPushResult
13104: oGetLocal 1
13106: oPushResult
13107: greater
13108: oPop 2
13110: oChoice 13116
13112: oError 27
13114: oJumpForward 13119
13116: Choice Lookup Table
           0   13112
13119: oJumpForward 13124
13121: Choice Lookup Table
           0   13102
13124: oGetLocal 1
13126: oPushResult
13127: oValueTop
13128: oPushResult
13129: equal
13130: oPop 2
13132: oChoice 13148
13134: oGetFromParam 1
13136: oPushResult
13137: oSetResult 45
13139: oPushResult
13140: oSetResult 1
13142: oPushResult
13143: oNodeSetBoolean
13144: oPop 3
13146: oJumpForward 13151
13148: Choice Lookup Table
           0   13134
13151: oGetAddrLocal 1
13153: oPushResult
13154: oValueTop
13155: oAssign
13156: oValuePop
13157: oJumpForward 13164
13159: Choice Lookup Table
           5   13083
           7   13083
13164: oGetLocal 5
13166: oPushResult
13167: oSetResult 22
13169: oPushResult
13170: oGetLocal 1
13172: oPushResult
13173: oNodeSetInt
13174: oPop 3
13176: oGetLocal 6
13178: oPushResult
13179: oSetResult 22
13181: oPushResult
13182: oGetLocal 1
13184: oPushResult
13185: oNodeSetInt
13186: oPop 3
13188: oGetLocal 5
13190: oPushResult
13191: oScopeDeclare
13192: oPop 1
13194: oGetLocal 4
13196: oPushResult
13197: oScopeEnter
13198: oPop 1
13200: oGetLocal 6
13202: oPushResult
13203: oScopeDeclare
13204: oPop 1
13206: oScopeEnd
13207: oGetAddrLocal 1
13209: oPushResult
13210: inc
13211: oPop 1
13213: oGetAddrLocal 2
13215: oPushResult
13216: inc
13217: oPop 1
13219: oInputChoice 13223
13221: oJumpForward 13228
13223: Choice Lookup Table
          14   13221
13226: oJumpForward 13230
13228: oJumpBack 12992
13230: oInput 16
13232: oGetFromParam 1
13234: oPushResult
13235: oSetResult 42
13237: oPushResult
13238: oScopeCurrent
13239: oPushResult
13240: oNodeSet
13241: oPop 3
13243: oGetFromParam 1
13245: oPushResult
13246: oSetResult 17
13248: oPushResult
13249: oSetResult 4
13251: oPushResult
13252: oNodeSetInt
13253: oPop 3
13255: oScopeEnd
13256: oGetGlobal 2
13258: oPushResult
13259: oCall 14369
13261: oPop 1
13263: oPushResult
13264: oCodePush
13265: oPop 1
13267: oGetGlobal 2
13269: oPushResult
13270: oScopeEnter
13271: oPop 1
13273: oGetAddrLocal 8
13275: oPushResult
13276: oGetLocal 2
13278: oPushResult
13279: oSetResult 1
13281: oPushResult
13282: add
13283: oPop 2
13285: oPushResult
13286: oSetResult 16
13288: oPushResult
13289: multiply
13290: oPop 2
13292: oAssign
13293: oGetAddrLocal 9
13295: oPushResult
13296: oGetLocal 8
13298: oPushResult
13299: oSetResult 8
13301: oPushResult
13302: oScopeAlloc
13303: oPop 2
13305: oAssign
13306: oScopeEnd
13307: oGetFromParam 1
13309: oPushResult
13310: oSetResult 44
13312: oPushResult
13313: oGetLocal 9
13315: oPushResult
13316: oNodeSetInt
13317: oPop 3
13319: oGetAddrLocal 10
13321: oPushResult
13322: oGetFromParam 1
13324: oPushResult
13325: oSetResult 42
13327: oPushResult
13328: oNodeGet
13329: oPop 2
13331: oPushResult
13332: oSetResult 15
13334: oPushResult
13335: oNodeGetIter
13336: oPop 2
13338: oAssign
13339: oGetAddrLocal 11
13341: oPushResult
13342: oGetLocal 10
13344: oPushResult
13345: oNodeIterValue
13346: oPop 1
13348: oAssign
13349: oGetLocal 11
13351: oPushResult
13352: oNodeNull
13353: oPop 1
13355: oChoice 13361
13357: oJumpForward 13448
13359: oJumpForward 13364
13361: Choice Lookup Table
           1   13357
13364: oEmit 17
13366: oGetLocal 9
13368: oPushResult
13369: oEmitInt
13370: oPop 1
13372: oEmit 15
13374: oGetLocal 11
13376: oPushResult
13377: oSetResult 22
13379: oPushResult
13380: oNodeGetInt
13381: oPop 2
13383: oPushResult
13384: oEmitInt
13385: oPop 1
13387: oEmit 27
13389: oGetAddrLocal 9
13391: oPushResult
13392: oGetLocal 9
13394: oPushResult
13395: oSetResult 8
13397: oPushResult
13398: add
13399: oPop 2
13401: oAssign
13402: oEmit 17
13404: oGetLocal 9
13406: oPushResult
13407: oEmitInt
13408: oPop 1
13410: oEmit 17
13412: oGetLocal 11
13414: oPushResult
13415: oSetResult 32
13417: oPushResult
13418: oNodeGetInt
13419: oPop 2
13421: oPushResult
13422: oEmitInt
13423: oPop 1
13425: oEmit 29
13427: oGetAddrLocal 9
13429: oPushResult
13430: oGetLocal 9
13432: oPushResult
13433: oSetResult 8
13435: oPushResult
13436: add
13437: oPop 2
13439: oAssign
13440: oGetAddrLocal 10
13442: oPushResult
13443: oNodeIterNext
13444: oPop 1
13446: oJumpBack 13339
13448: oEmit 17
13450: oGetLocal 9
13452: oPushResult
13453: oEmitInt
13454: oPop 1
13456: oEmit 15
13458: oSetResult 0
13460: oPushResult
13461: oEmitInt
13462: oPop 1
13464: oEmit 27
13466: oGetAddrLocal 9
13468: oPushResult
13469: oGetLocal 9
13471: oPushResult
13472: oSetResult 8
13474: oPushResult
13475: add
13476: oPop 2
13478: oAssign
13479: oEmit 17
13481: oGetLocal 9
13483: oPushResult
13484: oEmitInt
13485: oPop 1
13487: oEmit 15
13489: oSetResult 0
13491: oPushResult
13492: oEmitInt
13493: oPop 1
13495: oEmit 29
13497: oGetAddrLocal 9
13499: oPushResult
13500: oGetLocal 9
13502: oPushResult
13503: oSetResult 8
13505: oPushResult
13506: add
13507: oPop 2
13509: oAssign
13510: oCodePop
13511: oGetFromParam 1
13513: oPushResult
13514: oTypeAdd
13515: oPop 1
13517: oReturn
13518: oLocalSpace 1
13520: oGetAddrLocal 1
13522: oPushResult
13523: oGetParam 1
13525: oPushResult
13526: oSetResult 37
13528: oPushResult
13529: oNodeGet
13530: oPop 2
13532: oAssign
13533: oGetLocal 1
13535: oPushResult
13536: oNodeNull
13537: oPop 1
13539: oChoice 13595
13541: oGetAddrLocal 1
13543: oPushResult
13544: oSetResult 37
13546: oPushResult
13547: oNodeNew
13548: oPop 1
13550: oAssign
13551: oGetLocal 1
13553: oPushResult
13554: oSetResult 38
13556: oPushResult
13557: oGetParam 1
13559: oPushResult
13560: oNodeSet
13561: oPop 3
13563: oGetLocal 1
13565: oPushResult
13566: oSetResult 17
13568: oPushResult
13569: oSetResult 8
13571: oPushResult
13572: oNodeSetInt
13573: oPop 3
13575: oGetLocal 1
13577: oPushResult
13578: oTypeAdd
13579: oPop 1
13581: oGetParam 1
13583: oPushResult
13584: oSetResult 37
13586: oPushResult
13587: oGetLocal 1
13589: oPushResult
13590: oNodeSet
13591: oPop 3
13593: oJumpForward 13598
13595: Choice Lookup Table
           1   13541
13598: oGetLocal 1
13600: oReturn
13601: oReturn
13602: oLocalSpace 2
13604: oGetParam 1
13606: oPushResult
13607: oNodeType
13608: oPop 1
13610: oChoice 13680
13612: oMININT
13613: oReturn
13614: oJumpForward 13696
13616: oSetResult 0
13618: oReturn
13619: oJumpForward 13696
13621: oSetResult 0
13623: oReturn
13624: oJumpForward 13696
13626: oGetAddrLocal 1
13628: oPushResult
13629: oGetParam 1
13631: oPushResult
13632: oSetResult 42
13634: oPushResult
13635: oNodeGet
13636: oPop 2
13638: oAssign
13639: oGetAddrLocal 2
13641: oPushResult
13642: oGetLocal 1
13644: oPushResult
13645: oSetResult 15
13647: oPushResult
13648: oNodeGetIter
13649: oPop 2
13651: oPushResult
13652: oNodeIterValue
13653: oPop 1
13655: oAssign
13656: oGetLocal 2
13658: oPushResult
13659: oSetResult 22
13661: oPushResult
13662: oNodeGetInt
13663: oPop 2
13665: oReturn
13666: oJumpForward 13696
13668: oGetParam 1
13670: oPushResult
13671: oSetResult 40
13673: oPushResult
13674: oNodeGetInt
13675: oPop 2
13677: oReturn
13678: oJumpForward 13696
13680: Choice Lookup Table
          40   13668
          44   13626
          36   13621
          34   13616
          31   13612
13691: oError 3
13693: oSetResult 0
13695: oReturn
13696: oReturn
13697: oLocalSpace 2
13699: oGetParam 1
13701: oPushResult
13702: oNodeType
13703: oPop 1
13705: oChoice 13775
13707: oMAXINT
13708: oReturn
13709: oJumpForward 13791
13711: oSetResult 1
13713: oReturn
13714: oJumpForward 13791
13716: oSetResult 255
13718: oReturn
13719: oJumpForward 13791
13721: oGetAddrLocal 1
13723: oPushResult
13724: oGetParam 1
13726: oPushResult
13727: oSetResult 42
13729: oPushResult
13730: oNodeGet
13731: oPop 2
13733: oAssign
13734: oGetAddrLocal 2
13736: oPushResult
13737: oGetLocal 1
13739: oPushResult
13740: oSetResult 15
13742: oPushResult
13743: oNodeGetIterLast
13744: oPop 2
13746: oPushResult
13747: oNodeIterValue
13748: oPop 1
13750: oAssign
13751: oGetLocal 2
13753: oPushResult
13754: oSetResult 22
13756: oPushResult
13757: oNodeGetInt
13758: oPop 2
13760: oReturn
13761: oJumpForward 13791
13763: oGetParam 1
13765: oPushResult
13766: oSetResult 41
13768: oPushResult
13769: oNodeGetInt
13770: oPop 2
13772: oReturn
13773: oJumpForward 13791
13775: Choice Lookup Table
          40   13763
          44   13721
          36   13716
          34   13711
          31   13707
13786: oError 3
13788: oSetResult 0
13790: oReturn
13791: oReturn
13792: oLocalSpace 5
13794: oGetAddrGlobal 1
13796: oPushResult
13797: oWorkspaceNew
13798: oAssign
13799: oSetResult 0
13801: oPushResult
13802: oSetResult 0
13804: oPushResult
13805: oScopeBegin
13806: oPop 2
13808: oGetAddrLocal 2
13810: oPushResult
13811: oScopeCurrent
13812: oAssign
13813: oCall 14541
13815: oEmit 79
13817: oSetResult 0
13819: oPushResult
13820: oEmitInt
13821: oPop 1
13823: oGetAddrLocal 3
13825: oPushResult
13826: oLabelNew
13827: oAssign
13828: oEmit 73
13830: oSetResult 0
13832: oPushResult
13833: oEmitInt
13834: oPop 1
13836: oEmit 76
13838: oGetLocal 3
13840: oPushResult
13841: oEmitLabel
13842: oPop 1
13844: oEmit 75
13846: oSetResult 0
13848: oPushResult
13849: oEmitInt
13850: oPop 1
13852: oEmit 78
13854: oInput 29
13856: oInput 0
13858: oGetAddrLocal 4
13860: oPushResult
13861: oSetResult 4
13863: oPushResult
13864: oNodeNew
13865: oPop 1
13867: oAssign
13868: oGetLocal 4
13870: oPushResult
13871: oSetResult 4
13873: oPushResult
13874: LAST_ID
13875: oPushResult
13876: oNodeSetInt
13877: oPop 3
13879: oGetGlobal 1
13881: oPushResult
13882: oSetResult 2
13884: oPushResult
13885: oGetLocal 4
13887: oPushResult
13888: oNodeSet
13889: oPop 3
13891: oInputChoice 13965
13893: oInput 0
13895: oGetAddrLocal 1
13897: oPushResult
13898: oSetResult 21
13900: oPushResult
13901: LAST_ID
13902: oPushResult
13903: oCall 14471
13905: oPop 2
13907: oAssign
13908: oGetLocal 1
13910: oPushResult
13911: oSetResult 21
13913: oPushResult
13914: oGetGlobal 5
13916: oPushResult
13917: oNodeSet
13918: oPop 3
13920: oGetLocal 1
13922: oPushResult
13923: oScopeDeclareAlloc
13924: oPop 1
13926: oInput 14
13928: oInput 0
13930: oGetAddrLocal 1
13932: oPushResult
13933: oSetResult 21
13935: oPushResult
13936: LAST_ID
13937: oPushResult
13938: oCall 14471
13940: oPop 2
13942: oAssign
13943: oGetLocal 1
13945: oPushResult
13946: oSetResult 21
13948: oPushResult
13949: oGetGlobal 5
13951: oPushResult
13952: oNodeSet
13953: oPop 3
13955: oGetLocal 1
13957: oPushResult
13958: oScopeDeclareAlloc
13959: oPop 1
13961: oInput 16
13963: oJumpForward 13968
13965: Choice Lookup Table
          15   13893
13968: oInput 6
13970: oGetLocal 4
13972: oPushResult
13973: oCall 34
13975: oPop 1
13977: oInputChoice 13988
13979: oGetLocal 4
13981: oPushResult
13982: oCall 7
13984: oPop 1
13986: oJumpForward 13991
13988: Choice Lookup Table
          60   13979
13991: oGetLocal 4
13993: oPushResult
13994: oCall 287
13996: oPop 1
13998: oSetResult 0
14000: oPushResult
14001: oSetResult 0
14003: oPushResult
14004: oScopeBegin
14005: oPop 2
14007: oGetAddrGlobal 2
14009: oPushResult
14010: oScopeCurrent
14011: oAssign
14012: oSetResult 0
14014: oPushResult
14015: oSetResult 1
14017: oPushResult
14018: oScopeBegin
14019: oPop 2
14021: oScopeCurrent
14022: oPushResult
14023: oSetResult 16
14025: oPushResult
14026: oGetGlobal 2
14028: oPushResult
14029: oNodeSet
14030: oPop 3
14032: oGetAddrGlobal 3
14034: oPushResult
14035: oScopeCurrent
14036: oAssign
14037: oGetLocal 4
14039: oPushResult
14040: oSetResult 7
14042: oPushResult
14043: oGetGlobal 3
14045: oPushResult
14046: oNodeSet
14047: oPop 3
14049: oScopeEnd
14050: oSetResult 22
14052: oPushResult
14053: oCall 14120
14055: oPop 1
14057: oGetGlobal 3
14059: oPushResult
14060: oScopeEnter
14061: oPop 1
14063: oGetAddrLocal 5
14065: oPushResult
14066: oSetResult 1
14068: oAssign
14069: oGetLocal 3
14071: oPushResult
14072: oGetGlobal 2
14074: oPushResult
14075: oGetLocal 5
14077: oPushResult
14078: oCall 14271
14080: oPop 3
14082: oScopeEnd
14083: oInput 21
14085: oCall 14176
14087: oScopeEnd
14088: oGetLocal 4
14090: oPushResult
14091: oCall 349
14093: oPop 1
14095: oReturn
14096: oLocalSpace 0
14098: oGetParam 2
14100: oPushResult
14101: oCall 14120
14103: oPop 1
14105: oGetParam 1
14107: oPushResult
14108: oScopeCurrent
14109: oPushResult
14110: oSetResult 0
14112: oPushResult
14113: oCall 14271
14115: oPop 3
14117: oCall 14176
14119: oReturn
14120: oLocalSpace 0
14122: oInputChoice 14153
14124: oCall 2520
14126: oJumpForward 14168
14128: oCall 3213
14130: oJumpForward 14168
14132: oGetParam 1
14134: oPushResult
14135: oCall 3269
14137: oPop 1
14139: oJumpForward 14168
14141: oCall 3503
14143: oJumpForward 14168
14145: oCall 1743
14147: oJumpForward 14168
14149: oCall 2178
14151: oJumpForward 14168
14153: Choice Lookup Table
          31   14149
          30   14145
          35   14141
          34   14132
          33   14128
          32   14124
14166: oJumpForward 14170
14168: oJumpBack 14122
14170: oCall 14173
14172: oReturn
14173: oLocalSpace 0
14175: oReturn
14176: oLocalSpace 2
14178: oGetAddrLocal 1
14180: oPushResult
14181: oScopeCurrent
14182: oPushResult
14183: oSetResult 15
14185: oPushResult
14186: oNodeGetIter
14187: oPop 2
14189: oAssign
14190: oGetAddrLocal 2
14192: oPushResult
14193: oGetLocal 1
14195: oPushResult
14196: oNodeIterValue
14197: oPop 1
14199: oAssign
14200: oGetLocal 2
14202: oPushResult
14203: oNodeNull
14204: oPop 1
14206: oChoice 14210
14208: oJumpForward 14215
14210: Choice Lookup Table
           0   14208
14213: oJumpForward 14270
14215: oGetLocal 2
14217: oPushResult
14218: oNodeType
14219: oPop 1
14221: oChoice 14259
14223: oGetLocal 2
14225: oPushResult
14226: oSetResult 36
14228: oPushResult
14229: oNodeGetBoolean
14230: oPop 2
14232: oChoice 14254
14234: oGetLocal 2
14236: oPushResult
14237: oSetResult 28
14239: oPushResult
14240: oNodeGetBoolean
14241: oPop 2
14243: oChoice 14249
14245: oError 28
14247: oJumpForward 14252
14249: Choice Lookup Table
           1   14245
14252: oJumpForward 14257
14254: Choice Lookup Table
           0   14234
14257: oJumpForward 14262
14259: Choice Lookup Table
          27   14223
14262: oGetAddrLocal 1
14264: oPushResult
14265: oNodeIterNext
14266: oPop 1
14268: oJumpBack 14190
14270: oReturn
14271: oLocalSpace 3
14273: oEmit 89
14275: oGetParam 3
14277: oPushResult
14278: oEmitLabel
14279: oPop 1
14281: oEmit 79
14283: oGetAddrLocal 1
14285: oPushResult
14286: Here
14287: oAssign
14288: oEmit 107
14290: oGetParam 1
14292: oChoice 14298
14294: oCall 1220
14296: oJumpForward 14301
14298: Choice Lookup Table
           1   14294
14301: oGetAddrLocal 2
14303: oPushResult
14304: oGetParam 2
14306: oPushResult
14307: oSetResult 19
14309: oPushResult
14310: oNodeGetCode
14311: oPop 2
14313: oAssign
14314: oGetLocal 2
14316: oPushResult
14317: oEmitCode
14318: oPop 1
14320: oGetParam 2
14322: oPushResult
14323: oSetResult 19
14325: oPushResult
14326: oSetResult 0
14328: oPushResult
14329: oNodeSetCode
14330: oPop 3
14332: oCall 9184
14334: oGetParam 1
14336: oChoice 14342
14338: oCall 1305
14340: oJumpForward 14345
14342: Choice Lookup Table
           1   14338
14345: oEmit 78
14347: oGetAddrLocal 3
14349: oPushResult
14350: oScopeCurrent
14351: oPushResult
14352: oSetResult 17
14354: oPushResult
14355: oNodeGetInt
14356: oPop 2
14358: oAssign
14359: oGetLocal 1
14361: oPushResult
14362: oGetLocal 3
14364: oPushResult
14365: oPatch
14366: oPop 2
14368: oReturn
14369: oLocalSpace 1
14371: oGetAddrLocal 1
14373: oPushResult
14374: oGetParam 1
14376: oPushResult
14377: oSetResult 19
14379: oPushResult
14380: oNodeGetCode
14381: oPop 2
14383: oAssign
14384: oGetLocal 1
14386: oPushResult
14387: oSetResult 0
14389: oPushResult
14390: equal_code
14391: oPop 2
14393: oChoice 14414
14395: oGetAddrLocal 1
14397: oPushResult
14398: oCodeNew
14399: oAssign
14400: oGetParam 1
14402: oPushResult
14403: oSetResult 19
14405: oPushResult
14406: oGetLocal 1
14408: oPushResult
14409: oNodeSetCode
14410: oPop 3
14412: oJumpForward 14417
14414: Choice Lookup Table
           1   14395
14417: oGetLocal 1
14419: oReturn
14420: oReturn
14421: oLocalSpace 0
14423: oScopeCurrent
14424: oPushResult
14425: oSetResult 14
14427: oPushResult
14428: oNodeGetInt
14429: oPop 2
14431: oReturn
14432: oReturn
14433: oLocalSpace 0
14435: oGetParam 1
14437: oPushResult
14438: oSetResult 20
14440: oPushResult
14441: oNodeGet
14442: oPop 2
14444: oPushResult
14445: oSetResult 14
14447: oPushResult
14448: oNodeGetInt
14449: oPop 2
14451: oReturn
14452: oReturn
14453: oLocalSpace 0
14455: oCall 14421
14457: oPushResult
14458: oGetParam 1
14460: oPushResult
14461: oCall 14433
14463: oPop 1
14465: oPushResult
14466: subtract
14467: oPop 2
14469: oReturn
14470: oReturn
14471: oLocalSpace 1
14473: oGetAddrLocal 1
14475: oPushResult
14476: oGetParam 2
14478: oPushResult
14479: oNodeNew
14480: oPop 1
14482: oAssign
14483: oGetLocal 1
14485: oPushResult
14486: oSetResult 4
14488: oPushResult
14489: oGetParam 1
14491: oPushResult
14492: oNodeSetInt
14493: oPop 3
14495: oGetLocal 1
14497: oReturn
14498: oReturn
14499: oLocalSpace 0
14501: oGetParam 1
14503: oPushResult
14504: oSetResult 22
14506: oPushResult
14507: oNodeGetInt
14508: oPop 2
14510: oPushResult
14511: oEmitInt
14512: oPop 1
14514: oReturn
14515: oLocalSpace 1
14517: oGetAddrLocal 1
14519: oPushResult
14520: oSetResult 14
14522: oPushResult
14523: oGetParam 1
14525: oPushResult
14526: oCall 14471
14528: oPop 2
14530: oAssign
14531: oGetLocal 1
14533: oPushResult
14534: oScopeDeclare
14535: oPop 1
14537: oGetLocal 1
14539: oReturn
14540: oReturn
14541: oLocalSpace 1
14543: oGetAddrGlobal 25
14545: oPushResult
14546: oSetResult 0
14548: oAssign
14549: oGetAddrGlobal 4
14551: oPushResult
14552: oId_mysystem
14553: oAssign
14554: oGetAddrGlobal 5
14556: oPushResult
14557: oSetResult 29
14559: oPushResult
14560: oSetResult 4
14562: oPushResult
14563: oCall 12405
14565: oPop 2
14567: oAssign
14568: oGetAddrGlobal 6
14570: oPushResult
14571: oSetResult 31
14573: oPushResult
14574: oSetResult 4
14576: oPushResult
14577: oCall 12405
14579: oPop 2
14581: oAssign
14582: oGetAddrGlobal 7
14584: oPushResult
14585: oSetResult 34
14587: oPushResult
14588: oSetResult 1
14590: oPushResult
14591: oCall 12405
14593: oPop 2
14595: oAssign
14596: oGetAddrGlobal 8
14598: oPushResult
14599: oSetResult 35
14601: oPushResult
14602: oSetResult 1
14604: oPushResult
14605: oCall 12405
14607: oPop 2
14609: oAssign
14610: oGetAddrGlobal 9
14612: oPushResult
14613: oSetResult 36
14615: oPushResult
14616: oSetResult 1
14618: oPushResult
14619: oCall 12405
14621: oPop 2
14623: oAssign
14624: oGetAddrGlobal 10
14626: oPushResult
14627: oGetGlobal 9
14629: oPushResult
14630: oCall 13518
14632: oPop 1
14634: oAssign
14635: oGetAddrGlobal 11
14637: oPushResult
14638: oSetResult 30
14640: oPushResult
14641: oSetResult 1
14643: oPushResult
14644: oCall 12405
14646: oPop 2
14648: oAssign
14649: oGetAddrGlobal 12
14651: oPushResult
14652: oSetResult 32
14654: oPushResult
14655: oSetResult 4
14657: oPushResult
14658: oCall 12405
14660: oPop 2
14662: oAssign
14663: oGetAddrGlobal 13
14665: oPushResult
14666: oSetResult 33
14668: oPushResult
14669: oSetResult 8
14671: oPushResult
14672: oCall 12405
14674: oPop 2
14676: oAssign
14677: oGetAddrGlobal 14
14679: oPushResult
14680: oSetResult 38
14682: oPushResult
14683: oSetResult 8
14685: oPushResult
14686: oCall 12405
14688: oPop 2
14690: oAssign
14691: oGetGlobal 14
14693: oPushResult
14694: oSetResult 38
14696: oPushResult
14697: oGetGlobal 11
14699: oPushResult
14700: oNodeSet
14701: oPop 3
14703: oGetAddrGlobal 15
14705: oPushResult
14706: oSetResult 42
14708: oPushResult
14709: oSetResult 256
14711: oPushResult
14712: oCall 12405
14714: oPop 2
14716: oAssign
14717: oGetAddrGlobal 16
14719: oPushResult
14720: oSetResult 43
14722: oPushResult
14723: oSetResult 256
14725: oPushResult
14726: oCall 12405
14728: oPop 2
14730: oAssign
14731: oGetGlobal 16
14733: oPushResult
14734: oSetResult 43
14736: oPushResult
14737: oSetResult 255
14739: oPushResult
14740: oNodeSetInt
14741: oPop 3
14743: oGetAddrLocal 1
14745: oPushResult
14746: oSetResult 20
14748: oPushResult
14749: oId_File
14750: oPushResult
14751: oCall 14471
14753: oPop 2
14755: oAssign
14756: oGetLocal 1
14758: oPushResult
14759: oSetResult 21
14761: oPushResult
14762: oGetGlobal 5
14764: oPushResult
14765: oNodeSet
14766: oPop 3
14768: oGetLocal 1
14770: oPushResult
14771: oScopeDeclare
14772: oPop 1
14774: oGetAddrLocal 1
14776: oPushResult
14777: oSetResult 20
14779: oPushResult
14780: oId_Integer
14781: oPushResult
14782: oCall 14471
14784: oPop 2
14786: oAssign
14787: oGetLocal 1
14789: oPushResult
14790: oSetResult 21
14792: oPushResult
14793: oGetGlobal 6
14795: oPushResult
14796: oNodeSet
14797: oPop 3
14799: oGetLocal 1
14801: oPushResult
14802: oScopeDeclare
14803: oPop 1
14805: oGetAddrLocal 1
14807: oPushResult
14808: oSetResult 20
14810: oPushResult
14811: oId_Boolean
14812: oPushResult
14813: oCall 14471
14815: oPop 2
14817: oAssign
14818: oGetLocal 1
14820: oPushResult
14821: oSetResult 21
14823: oPushResult
14824: oGetGlobal 7
14826: oPushResult
14827: oNodeSet
14828: oPop 3
14830: oGetLocal 1
14832: oPushResult
14833: oScopeDeclare
14834: oPop 1
14836: oGetAddrLocal 1
14838: oPushResult
14839: oSetResult 20
14841: oPushResult
14842: oId_Char
14843: oPushResult
14844: oCall 14471
14846: oPop 2
14848: oAssign
14849: oGetLocal 1
14851: oPushResult
14852: oSetResult 21
14854: oPushResult
14855: oGetGlobal 9
14857: oPushResult
14858: oNodeSet
14859: oPop 3
14861: oGetLocal 1
14863: oPushResult
14864: oScopeDeclare
14865: oPop 1
14867: oGetAddrLocal 1
14869: oPushResult
14870: oSetResult 20
14872: oPushResult
14873: oId_Byte
14874: oPushResult
14875: oCall 14471
14877: oPop 2
14879: oAssign
14880: oGetLocal 1
14882: oPushResult
14883: oSetResult 21
14885: oPushResult
14886: oGetGlobal 11
14888: oPushResult
14889: oNodeSet
14890: oPop 3
14892: oGetLocal 1
14894: oPushResult
14895: oScopeDeclare
14896: oPop 1
14898: oGetAddrLocal 1
14900: oPushResult
14901: oSetResult 20
14903: oPushResult
14904: oId_Single
14905: oPushResult
14906: oCall 14471
14908: oPop 2
14910: oAssign
14911: oGetLocal 1
14913: oPushResult
14914: oSetResult 21
14916: oPushResult
14917: oGetGlobal 12
14919: oPushResult
14920: oNodeSet
14921: oPop 3
14923: oGetLocal 1
14925: oPushResult
14926: oScopeDeclare
14927: oPop 1
14929: oGetAddrLocal 1
14931: oPushResult
14932: oSetResult 20
14934: oPushResult
14935: oId_Double
14936: oPushResult
14937: oCall 14471
14939: oPop 2
14941: oAssign
14942: oGetLocal 1
14944: oPushResult
14945: oSetResult 21
14947: oPushResult
14948: oGetGlobal 13
14950: oPushResult
14951: oNodeSet
14952: oPop 3
14954: oGetLocal 1
14956: oPushResult
14957: oScopeDeclare
14958: oPop 1
14960: oGetAddrLocal 1
14962: oPushResult
14963: oSetResult 20
14965: oPushResult
14966: oId_Pointer
14967: oPushResult
14968: oCall 14471
14970: oPop 2
14972: oAssign
14973: oGetLocal 1
14975: oPushResult
14976: oSetResult 21
14978: oPushResult
14979: oGetGlobal 14
14981: oPushResult
14982: oNodeSet
14983: oPop 3
14985: oGetLocal 1
14987: oPushResult
14988: oScopeDeclare
14989: oPop 1
14991: oGetAddrLocal 1
14993: oPushResult
14994: oSetResult 20
14996: oPushResult
14997: oId_ShortString
14998: oPushResult
14999: oCall 14471
15001: oPop 2
15003: oAssign
15004: oGetLocal 1
15006: oPushResult
15007: oSetResult 21
15009: oPushResult
15010: oGetGlobal 16
15012: oPushResult
15013: oNodeSet
15014: oPop 3
15016: oGetLocal 1
15018: oPushResult
15019: oScopeDeclare
15020: oPop 1
15022: oGetAddrLocal 1
15024: oPushResult
15025: oSetResult 16
15027: oPushResult
15028: oId_True
15029: oPushResult
15030: oCall 14471
15032: oPop 2
15034: oAssign
15035: oGetLocal 1
15037: oPushResult
15038: oSetResult 21
15040: oPushResult
15041: oGetGlobal 7
15043: oPushResult
15044: oNodeSet
15045: oPop 3
15047: oGetLocal 1
15049: oPushResult
15050: oSetResult 22
15052: oPushResult
15053: oSetResult 1
15055: oPushResult
15056: oNodeSetInt
15057: oPop 3
15059: oGetLocal 1
15061: oPushResult
15062: oScopeDeclare
15063: oPop 1
15065: oGetAddrLocal 1
15067: oPushResult
15068: oSetResult 16
15070: oPushResult
15071: oId_False
15072: oPushResult
15073: oCall 14471
15075: oPop 2
15077: oAssign
15078: oGetLocal 1
15080: oPushResult
15081: oSetResult 21
15083: oPushResult
15084: oGetGlobal 7
15086: oPushResult
15087: oNodeSet
15088: oPop 3
15090: oGetLocal 1
15092: oPushResult
15093: oSetResult 22
15095: oPushResult
15096: oSetResult 0
15098: oPushResult
15099: oNodeSetInt
15100: oPop 3
15102: oGetLocal 1
15104: oPushResult
15105: oScopeDeclare
15106: oPop 1
15108: oGetAddrLocal 1
15110: oPushResult
15111: oSetResult 16
15113: oPushResult
15114: oId_Nil
15115: oPushResult
15116: oCall 14471
15118: oPop 2
15120: oAssign
15121: oGetLocal 1
15123: oPushResult
15124: oSetResult 21
15126: oPushResult
15127: oGetGlobal 14
15129: oPushResult
15130: oNodeSet
15131: oPop 3
15133: oGetLocal 1
15135: oPushResult
15136: oSetResult 22
15138: oPushResult
15139: oSetResult 0
15141: oPushResult
15142: oNodeSetInt
15143: oPop 3
15145: oGetLocal 1
15147: oPushResult
15148: oScopeDeclare
15149: oPop 1
15151: oGetAddrGlobal 17
15153: oPushResult
15154: oId_Ord
15155: oPushResult
15156: oCall 14515
15158: oPop 1
15160: oAssign
15161: oGetAddrGlobal 18
15163: oPushResult
15164: oId_Chr
15165: oPushResult
15166: oCall 14515
15168: oPop 1
15170: oAssign
15171: oGetAddrGlobal 19
15173: oPushResult
15174: oId_Pred
15175: oPushResult
15176: oCall 14515
15178: oPop 1
15180: oAssign
15181: oGetAddrGlobal 20
15183: oPushResult
15184: oId_Succ
15185: oPushResult
15186: oCall 14515
15188: oPop 1
15190: oAssign
15191: oGetAddrGlobal 21
15193: oPushResult
15194: oId_Sizeof
15195: oPushResult
15196: oCall 14515
15198: oPop 1
15200: oAssign
15201: oReturn
