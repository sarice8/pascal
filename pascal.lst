   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_mysystem >> int
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    ByteType
   2: Node    StringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 370: Uses( int id, Node user ):
 372:    Node unit = @FindOrCompileUnit( id )
 383:    [ equal_node( unit, Null )
 393:       | false :
 394:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 406:          Node unitRef = oNodeNew( nUnitRef )
 416:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 435:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 454:          oScopeDeclare( unitRef )
 460:       | * :
 465:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 466: ResolveUnitRef( inout Node decl ):
 468:    [ oNodeType( decl )
 475:       | nUnitRef :
 476:          Node scope = oNodeGet( decl, qPublicScope )
 489:          '.'
 491:          pIdent
 493:          decl = oScopeFindRequireInScope( scope )
 503:       | * :
 508:    ];
      
      
 509: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 511:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 524:    {
 524:       Node unit = oNodeIterValue( unitIt )
 534:       [ oNodeNull( unit )
 541:          | false :
 542:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 555:          | * :
 560:             >
 562:       ]
 562:       oNodeIterNext( unitIt )
 568:    }
 571:    ;
      
 571: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 573:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 586:    {
 586:       Node unit = oNodeIterValue( unitIt )
 596:       [ oNodeNull( unit )
 603:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 604:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 620:                | true :
 621:                | false :  #eInternalScopeMismatch
 625:             ]
 633:             oScopeEnd
 634:          | * :
 639:             >
 641:       ]
 641:       oNodeIterPrev( unitIt )
 647:    }
 650:    ;
      
      
 650: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 652:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 671:    [ equal_node( unit, Null )
 681:       | false :  >> unit
 685:       | * :
 690:    ]
      
         % If not, search for the source file on disk
 690:    boolean ok = oIncludeUnitFile( id )
 700:    [ ok
 703:       | false :  #eCantFindUnitFile  >> Null
 709:       | * :
 714:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 714:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 720:    oIncludeEnd
 721:    >> unit;
      
      
      
 725: Unit >> Node:
 727:    pUnit
 729:    pIdent
 731:    Node unit = oNodeNew( nUnit )
 741:    oNodeSetInt( unit, qIdent, LAST_ID )
 752:    Node unitImpl = oNodeNew( nUnitImpl )
 762:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 773:    oNodeSet( unit, qImpl, unitImpl )
 785:    ';'
      
         % mandatory sections
      
 787:    pInterface
 789:    @UsesMySystem( unit )
 796:    [
 796:       | pUses :   @UsesClause( unit )
 805:       | * :
 810:    ]
 810:    @EnterUsedUnits( unit )
      
 817:    oScopeBegin( 0, allocGlobal )
 826:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 837:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 842:    oScopeBegin( 0, allocDown )
 851:    initScope = oScopeCurrent
 856:    oNodeSet( unit, qInitRoutineScope, initScope )
 868:    oScopeEnd
      
 869:    @UnitInterface( unit )
 876:    oScopeEnd  % interface scope
      
 877:    pImplementation
 879:    @UsesMySystem( unitImpl )
 886:    [
 886:       | pUses :   @UsesClause( unitImpl )
 895:       | * :
 900:    ]
 900:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 907:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 920:    oScopeBegin( 0, allocGlobal )
 929:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 940:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 958:    globalScope = oScopeCurrent
 963:    @UnitImplementation( unit )
      
 970:    [
 970:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 982:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 997:    ]
 997:    [
 997:       | pFinalization :  @UnitFinalization( unit, true )
1009:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1024:    ]
1024:    pEnd  '.'
      
1028:    oScopeEnd  % impl scope
1029:    oScopeEnd  % interface scope
1030:    @EndUsedUnits( unitImpl )  % used units scopes
1037:    @EndUsedUnits( unit )
1044:    oNodeAddLast( workspace, qUnits, unit )
1056:    >> unit;
      
      
1060: UnitInterface( Node unit ):
1062:    {[
1062:       | pConst :     @ConstDecl
1066:       | pType :      @TypeDecl
1070:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1079:       | pProcedure :
1081:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1087:          [
1087:             | pExternal :
1089:                @ExternalDecl( decl )
1096:                ';'
1098:             | * :
1103:          ]
      
1103:       | pFunction :
1105:          Node decl = @FuncHeaderDecl
1111:          [
1111:             | pExternal :
1113:                @ExternalDecl( decl )
1120:                ';'
1122:             | * :
1127:          ]
      
1127:       | * :          >
1142:    ]}
1145:    ;
      
1145: UnitImplementation( Node unit ):
1147:    @BlockDecls( nGlobalVar )
1155:    ;
      
      
1155: UnitInitialization( Node unit, boolean hasStmts ):
1157:    Label label = oLabelNew
1162:    .tLabel  oEmitLabel( label )
1170:    oNodeSetLabel( unit, qInitLabel, label )
      
1182:    int patchLS
1182:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1191:    Node scope
1191:    Code initCode
      
1191:    scope = oNodeGet( unit, qPublicScope )
1204:    initCode = oNodeGetCode( scope, qInitCode )
1217:    oEmitCode( initCode )
1223:    oNodeSetCode( scope, qInitCode, codeNull )
      
1235:    scope = oNodeGet( unit, qPrivateScope )
1248:    initCode = oNodeGetCode( scope, qInitCode )
1261:    oEmitCode( initCode )
1267:    oNodeSetCode( scope, qInitCode, codeNull )
      
1279:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1292:    [ hasStmts
1295:       | true :     
1296:          @Statement
1298:          {[
1298:             | ';' :  @Statement
1302:             | * :    >
1309:          ]}
1311:       | * :
1316:    ]
      
1316:    .tReturn
      
1318:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1330:    oPatch( patchLS, localSpace )
1339:    oScopeEnd   % init routine scope, for temporaries
1341:    ;
      
      
1341: UnitFinalization( Node unit, boolean hasStmts ):
1343:    Label label = oLabelNew
1348:    .tLabel  oEmitLabel( label )
1356:    oNodeSetLabel( unit, qFinalLabel, label )
      
1368:    int patchLS
1368:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1377:    oScopeBegin( 0, allocDown )
      
1386:    [ hasStmts
1389:       | true :     
1390:          @Statement
1392:          {[
1392:             | ';' :  @Statement
1396:             | * :    >
1403:          ]}
1405:       | * :
1410:    ]
      
1410:    .tReturn
      
1412:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1424:    oPatch( patchLS, localSpace )
1433:    oScopeEnd   % final routine scope, for temporaries
1435:    ;
      
      
1435: Block( node_type varNodeType, Label labelForBody ):
1437:    @BlockDecls( varNodeType )
1444:    @BlockStmt( labelForBody, oScopeCurrent, false )
1456:    @CheckForUndefinedLabels
1459:    ;
      
      
1459: BlockDecls( node_type varNodeType ):
1461:    {[
1461:       | pConst :     @ConstDecl
1465:       | pType :      @TypeDecl
1469:       | pVar :       @VarDecl( varNodeType )
1478:       | pLabel :     @LabelDecl
1482:       | pProcedure : @ProcDecl
1486:       | pFunction :  @FuncDecl
1490:       | * :          >
1507:    ]}
1509:    @CheckForUndefinedMethods
1512:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1512: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1515:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1515: CheckForUndefinedLabels:
1517:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1529:    {
1529:       Node decl = oNodeIterValue( it )
1539:       [ oNodeNull( decl )
1546:          | false :
1547:          | * :  >
1554:       ]
1554:       [ oNodeType( decl )
1561:          | nLabel :
1562:             [ oNodeGetBoolean( decl, qDefined )
1572:                | false :
1573:                   [ oNodeGetBoolean( decl, qUsed )
1583:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1586:                      | * :
1591:                   ]
1591:                | * :
1596:             ]
1596:          | * :
1601:       ]
1601:       oNodeIterNext( it )
1607:    }
1610:    ;
      
      
1610: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1612:    NodeIter it = oNodeGetIter( workspace, qUnits )
1625:    {
1625:       Node unit = oNodeIterValue( it )
1635:       [ oNodeNull( unit )
1642:          | true :  >
1645:          | false :
1647:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1655:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1670:             .tFreeActuals  oEmitInt( 0 )
1678:             oNodeIterNext( it )
1684:       ]
1692:    };
      
      
1695: FinalizeUnits:
1697:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1710:    {
1710:       Node unit = oNodeIterValue( it )
1720:       [ oNodeNull( unit )
1727:          | true :  >
1730:          | false :
1732:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1740:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1755:             .tFreeActuals  oEmitInt( 0 )
1763:             oNodeIterPrev( it )
1769:       ]
1777:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1780: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1782:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1790:    int patchLS
1790:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1799:    [ isMain
1802:       | true :  @InitializeUnits
1805:       | * :
1810:    ]
      
         % insert any code for initialization of this scope's variables
1810:    Code initCode = oNodeGetCode( varScope, qInitCode )
1823:    oEmitCode( initCode )
1829:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1841:    @Statement
      
1843:    [ isMain
1846:       | true :  @FinalizeUnits
1849:       | * :
1854:    ]
      
1854:    .tReturn
      
1856:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1868:    oPatch( patchLS, localSpace )
1878:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1878: MethodModifiers( Node decl ):
1880:    {[
1880:       | pCdecl :
1882:          oNodeSetBoolean( decl, qCdecl, true )
1894:          ';'
      
1896:       | * : >
1903:    ]}
1906:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1906: GetOrCreateInitCode( Node scope ) >> Code:
1908:    Code initCode = oNodeGetCode( scope, qInitCode )
1921:    [ equal_code( initCode, codeNull )
1931:       | true :
1932:          initCode = oCodeNew
1937:          oNodeSetCode( scope, qInitCode, initCode )
1949:       | * :
1954:    ]
1954:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1958: ExternalDecl( Node decl ):
1960:    [ equal_zero( @DeclLevel( decl ) )
1972:       | false :  #eExternalMethodCannotBeNested
1975:       | * :
1980:    ]
1980:    oNodeSetBoolean( decl, qExternal, true )
1992:    [
1992:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1994:          [
1994:             | pName :
1996:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1998:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2009:             | * :
2014:          ]
2014:       | * :
2019:    ]
2020:    ;
      
      
2020: ProcHeaderDecl >> Node:
2022:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2024:    boolean redeclaring = false
2030:    Node decl = oScopeFindInCurrentScope
      
2035:    [ oNodeNull( decl )
2042:       | true :
               % first declaration
2043:          decl = @newIdent( nProc, LAST_ID )
2056:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2067:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2069:          redeclaring = true
2075:          [ oNodeGetBoolean( decl, qBodyDefined )
2085:             | true : #eAlreadyDefined
2088:             | * :
2093:          ]
2093:          [ oNodeGetBoolean( decl, qExternal )
2103:             | true : #eAlreadyDefined
2106:             | * :
2111:          ]
2111:          [ oNodeType( decl )
2118:             | nProc :
2119:             | * : #eAlreadyDefined   % wrong kind
2126:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2126:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2145:          oNodeSet( decl, qParams, Null )
2157:    ]
      
2165:    int level = @ScopeLevel
2171:    boolean nested = greater( level, 0 )
2184:    inc( level )
2190:    oScopeBegin( level, allocUp )
2199:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2204:    [ nested
2207:       | true :
2208:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2223:       | * :
2228:    ]
      
2228:    @FormalArgDecl
2230:    oNodeSet( decl, qParams, paramScope )
2242:    oScopeEnd
2243:    ';'
      
2245:    [ redeclaring
2248:       | false : oScopeDeclare( decl )
2255:       | true :  % TO DO: check that qParams is consistent with qOldParams
2257:    ]
      
2265:    @MethodModifiers( decl )
2272:    >> decl;
      
      
2276: ProcDecl:
2278:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2284:    [
2284:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2286:       | pExternal : @ExternalDecl( decl )
      
2295:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2302:          Node paramScope = oNodeGet( decl, qParams )
2315:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2321:          int level = oNodeGetInt( paramScope, qLevel )
2334:          oScopeBegin( level, allocDown )
2343:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2354:          Label label = oNodeGetLabel( decl, qValue )
2367:          @Block( nLocalVar, label )
2377:          oNodeSetBoolean( decl, qBodyDefined, true )
2389:          oScopeEnd
      
2390:          oScopeEnd  % paramScope
2391:    ]
2391:    ';';
      
      
      
2394: FuncHeaderDecl >> Node:
2396:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2398:    boolean redeclaring = false
2404:    Node decl = oScopeFindInCurrentScope
      
2409:    [ oNodeNull( decl )
2416:       | true :
               % first declaration
2417:          decl = @newIdent( nFunc, LAST_ID )
2430:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2441:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2443:          redeclaring = true
2449:          [ oNodeGetBoolean( decl, qBodyDefined )
2459:             | true : #eAlreadyDefined
2462:             | * :
2467:          ]
2467:          [ oNodeType( decl )
2474:             | nFunc :
2475:             | * : #eAlreadyDefined   % wrong kind
2482:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2482:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2501:          oNodeSet( decl, qParams, Null )
2513:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2532:          oNodeSet( decl, qType, Null )
2544:    ]
      
2552:    int level = @ScopeLevel
2558:    boolean nested = greater( level, 0 )
2571:    inc( level )
2577:    oScopeBegin( level, allocUp )
2586:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2591:    [ nested
2594:       | true :
2595:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2610:       | * :
2615:    ]
      
2615:    @FormalArgDecl
2617:    oNodeSet( decl, qParams, paramScope )
      
2629:    ':'
      
2631:    Node theType
2631:    @TypeRef( theType )
2638:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2650:    Node ptrType = @PointerTypeTo( theType )
2661:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2677:    oScopeEnd
2678:    ';'
      
2680:    [ redeclaring
2683:       | false : oScopeDeclare( decl )
2690:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2692:    ]
      
2700:    @MethodModifiers( decl )
      
2707:    >> decl;
      
      
2711: FuncDecl:
2713:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2719:    [
2719:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2721:       | pExternal : @ExternalDecl( decl )
      
2730:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2737:          Node paramScope = oNodeGet( decl, qParams )
2750:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2756:          int level = oNodeGetInt( paramScope, qLevel )
2769:          oScopeBegin( level, allocDown )
2778:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2789:          Label label = oNodeGetLabel( decl, qValue )
2802:          @Block( nLocalVar, label )
2812:          oNodeSetBoolean( decl, qBodyDefined, true )
2824:          oScopeEnd
      
2825:          oScopeEnd  % paramScope
2826:    ]
2826:    ';';
      
      
2829: FormalArgDecl:
2831:    [
2831:       | '(' :
2833:          {
2833:             NodeVec decls = oNodeVecNew
2838:             Node decl
2838:             boolean isInOut = false
      
2844:             [
2844:                | pVar : isInOut = true
2852:                | * :
2857:             ]
      
2857:             {  pIdent
      
2859:                decl = @newIdent( nParam, LAST_ID )
2872:                oNodeSetBoolean( decl, qInOut, isInOut )
2884:                oNodeVecAppend( decls, decl )
      
2893:                [
2893:                   | ':' : >
2897:                   | ',' :
2899:                ]
2907:             }
      
2909:             Node theType
2909:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2916:             Node allocType
2916:             [ isInOut
2919:                | true :   allocType = @PointerTypeTo( theType )
2931:                | * :      allocType = theType
2942:             ]
      
2942:             int i = 0
2948:             {[ equal( i, oNodeVecSize( decls ) )
2962:                | false :
2963:                   decl = oNodeVecElement( decls, i )
      
2976:                   oNodeSet( decl, qType, theType )
2988:                   oScopeDeclare( decl )
2994:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3010:                   inc( i )
3016:                | * :
3021:                   >
3023:             ]}
      
3025:             oNodeVecDelete( decls )
      
3031:             [
3031:                | ')' : >
3035:                | ';' :
3037:             ]
3045:          }
3047:       | * :
3052:    ];
      
      
3053: ConstDecl:
3055:    {[
3055:       | pIdent :
3057:          [
3057:             | ':' :
3059:                @TypedConstDecl
3061:             | * :
3066:                @UntypedConstDecl
3068:          ]
3068:       | * :
3073:          >
3075:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3078: UntypedConstDecl:
3080:    Node decl = @newIdent( nConst, LAST_ID )
3093:    '='
      
3095:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3097:    int val = oValueTop
3102:    oValuePop
3103:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3115:    oNodeSet( decl, qType, IntegerType )
      
3127:    oScopeDeclare( decl )
3133:    ';'
3136:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3136: TypedConstDecl:
3138:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3151:    Node theType
3151:    @TypeRef( theType )
3158:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3170:    [ oNodeType( theType )
3177:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3178:          '='
      
3180:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3182:          int val = oValueTop
3187:          oValuePop
3188:          oNodeSetInt( decl, qValue, val )
3200:          oScopeDeclare( decl )
3206:          ';'
      
3208:       | nStringType, nFileType, nPointerType :
3210:          #eNotImplemented
      
3212:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3214:          oScopeEnter( globalScope )
3220:          int addr = oScopeAllocType( theType )
3230:          oScopeEnd
3231:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3242:          oNodeSetInt( decl, qValue, addr )
3254:          '='
3256:          @TypedConstInit( theType, addr )
3266:          oCodePop
3267:          oScopeDeclare( decl )
3273:          ';'
3275:    ]
3300:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3300: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3302:    [ oNodeType( theType )
3309:       | nArrayType :
3310:          Node baseType = oNodeGet( theType, qBaseType )
3323:          Node indexType = oNodeGet( theType, qIndexType )
3336:          int low = @OrdinalLow( indexType )
3347:          int high = @OrdinalHigh( indexType )
3358:          int elementSize = oNodeGetInt( baseType, qSize )
      
3371:          '('
               % Loop over elements
3373:          int i = low
3379:          {
3379:             @TypedConstInit( baseType, addr )
3389:             [ equal( i, high )
3399:                | true : >
3402:                | false :
3404:             ]
3412:             ','
3414:             addr = add( addr, elementSize )
3427:             inc( i )
3433:          }
3435:          ')'
      
3437:       | nRecordType :
3439:          '('
3441:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3454:          {
3454:             [
3454:                | pIdent :
3456:                | * :  >
3463:             ]
3463:             Node field = oScopeFindRequireInScope( fieldScope )
3473:             ':'
3475:             Node fieldType = oNodeGet( field, qType )
3488:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3508:             @TypedConstInit( fieldType, fieldAddr )
3518:             [
3518:                | ';' :
3520:                | * :  >
3527:             ]
3527:          }
3529:          ')'
      
3531:       | nBooleanType, nByteType, nCharType:
3533:          .tPushAddrGlobal  oEmitInt( addr )
3541:          @ConstExpr
3543:          .tPushConstI  oEmitInt( oValueTop )
3550:          oValuePop
3551:          .tAssignB
      
3553:       | nIntegerType, nEnumType:
3555:          .tPushAddrGlobal  oEmitInt( addr )
3563:          @ConstExpr
3565:          .tPushConstI  oEmitInt( oValueTop )
3572:          oValuePop
3573:          .tAssignI
      
3575:       | nStringType, nFileType, nPointerType :
3577:          #eNotImplemented
3579:    ]
3604:    ;
      
      
3604: TypeDecl:
3606:    {[
3606:       | pIdent :
3608:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3621:          '='
3623:          Node theType
3623:          @TypeRef( theType )
3630:          oNodeSet( decl, qType, theType )
3642:          oScopeDeclare( decl )
3648:          ';'
3650:       | * :
3655:          >
3657:    ]};
      
3660: VarDecl( node_type varNodeType ):
3662:    {[
3662:       | pIdent :
3664:          NodeVec decls = oNodeVecNew
3669:          Node decl
3669:          {
3669:             decl = @newIdent( varNodeType, LAST_ID )
3682:             oNodeVecAppend( decls, decl )
3691:             [
3691:                | ',' :
3693:                   pIdent
3695:                | * :
3700:                   >
3702:             ]
3702:          }
3704:          ':'
3706:          Node theType
3706:          @TypeRef( theType )
      
3713:          int i = 0
3719:          {[ equal( i, oNodeVecSize( decls ) )
3733:             | false :
3734:                decl = oNodeVecElement( decls, i )
3747:                oNodeSet( decl, qType, theType )
3759:                oScopeDeclareAlloc( decl )
3765:                inc( i )
3771:             | * :
3776:               >
3778:          ]}
      
               % optional initialization
3780:          [
3780:             | '=' :
3782:                [ oNodeVecSize( decls )
3789:                   | 1 :
3790:                   | * :  #eOnlyOneVarCanBeInitialized
3797:                ]
      
                     % we need an initCode stream for this scope
3797:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3807:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3813:                boolean changedScope = false
3819:                [ equal_zero( @ScopeLevel )
3826:                   | true : oScopeEnter( initScope )
3833:                            changedScope = true
3839:                   | * :
3844:                ]
                     % generate assignment in initCode stream
3844:                @LValueVar( decl, true )
3854:                @Expr
3856:                @MatchTypes
3858:                @Assign
3860:                [ changedScope
3863:                   | true : oScopeEnd
3865:                   | * :
3870:                ]
3870:                oCodePop
                   
3871:             | * :
3876:          ]
      
3876:          oNodeVecDelete( decls )
3882:          ';'
3884:       | * :
3889:          >
3891:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3894: LabelDecl:
3896:    {
3896:       Node decl
3896:       [
3896:          | pIdent :
3898:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3900:             oChangeIntLitToLabelIdent
3901:       ]
3909:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3922:       Label label = oLabelNew
3927:       oNodeSetLabel( decl, qValue, label )
3939:       oScopeDeclare( decl )
3945:       [
3945:          | ',' :
3947:          | * :
3952:             >
3954:       ]
3954:    }
3956:    ';'
3959:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3959: TypeRef( out Node resultType ):
3961:    [
3961:       | pIdent :           % previously named type (including intrinsics)
3963:          Node decl = oScopeFindRequire
3968:          @ResolveUnitRef( decl )
3975:          [ oNodeType( decl )
3982:             | nTypeDecl :
3983:                resultType = oNodeGet( decl, qType )
3996:             | * :
4001:                #eNotType
4003:                resultType = IntegerType
4009:          ]
         
4009:       | pArray :
4011:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4013:          NodeVec dimensions = oNodeVecNew
      
4018:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4018:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4028:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4040:             @ConstExpr
4042:             oNodeSetInt( subrange, qLow, oValueTop )
4053:             oValuePop
4054:             '..'
4056:             @ConstExpr
4058:             oNodeSetInt( subrange, qHigh, oValueTop )
4069:             oValuePop
4070:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4082:             oTypeAdd( subrange )
      
4088:             Node a = oNodeNew( nArrayType )
4098:             oNodeSet( a, qIndexType, subrange )
      
4110:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4119:             [
4119:                | ']' : >
4123:                | ',' :
4125:             ]
4133:          }
      
4135:          pOf
4137:          Node baseType
4137:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4144:          int dim = oNodeVecSize( dimensions )
      
4154:          {
4154:              dec(dim)
      
4160:              Node a = oNodeVecElement( dimensions, dim )
      
4173:              oNodeSet( a, qBaseType, baseType )
4185:              Node subrange = oNodeGet( a, qIndexType )
4198:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4225:              inc( width )
4231:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4257:              oTypeAdd( a )
4263:              baseType = a
      
4269:              [ equal_zero(dim)
4276:                  | true:  >
4279:                  | *:
4284:              ]
4284:          }
      
4286:          resultType = oNodeVecElement( dimensions, 0 )
4299:          oNodeVecDelete( dimensions )
      
4305:       | '^' :
4307:          Node theType
4307:          @TypeRef( theType )
4314:          resultType = @PointerTypeTo( theType )
      
4325:       | pRecord :
4327:          resultType = oNodeNew( nRecordType )
4337:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4346:          @VarDecl( nRecordField )
      
4353:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4365:          [ equal_zero( size )
4372:             | true : #eRecordEmpty
4375:             | * :
4380:          ]
      
4380:          pEnd
      
4382:          oNodeSet( resultType, qScope, oScopeCurrent )
4393:          oNodeSetInt( resultType, qSize, size )
4405:          oScopeEnd
4406:          oTypeAdd( resultType )
      
      
4412:       | '(' :
               % An enum type declaration.
4414:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4421:       | pSet :
4423:          pOf
4425:          Node theType
4425:          @TypeRef( theType )
4432:       | * :       % this works for cases except where expr starts with an id
4447:          @ConstExpr '..' @ConstExpr
4453:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4454: EnumTypeRef( out Node resultType ):
      
4456:    resultType = oNodeNew( nEnumType )
4466:    int value = 0
4472:    int numValues = 0
4478:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4484:    Node outerScope = oScopeCurrent
4489:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4498:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4498:       pIdent
4500:       Node decl = @newIdent( nEnumValue, LAST_ID )
4513:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4526:       oNodeSet( decl, qType, resultType )
4538:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4550:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4563:       oNodeSetInt( decl, qNameOffset, nameOffset )
4575:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4587:       [
4587:          | '=', ':=' :
4589:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4591:             [ equal_zero( numValues )
4598:                | false :
4599:                   [ greater( oValueTop, value )
4608:                      | false :   #eEnumValueNotAscending
4611:                      | * :
4616:                   ]
4616:                | * :
4621:             ]
4621:             [ equal( value, oValueTop )
4630:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4631:                   oNodeSetBoolean( resultType, qHasGap, true )
4643:                | * :
4648:             ]
4648:             value = oValueTop
4653:             oValuePop
4654:          | * :
4661:       ]
4661:       oNodeSetInt( decl, qValue, value )
4673:       oNodeSetInt( decl2, qValue, value )
4685:       oScopeDeclare( decl )
      
4691:       oScopeEnter( outerScope )
4697:       oScopeDeclare( decl2 )
4703:       oScopeEnd
      
4704:       inc( value )
4710:       inc( numValues )
4716:       [
4716:          | ',' :
4718:          | * :    >
4725:       ]
4725:    }
4727:    ')'
      
4729:    oNodeSet( resultType, qScope, oScopeCurrent )
4740:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4752:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4753:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4764:    oScopeEnter( globalScope )
4770:    int size = multiply( add( numValues, 1 ), 16 )
4790:    int addr = oScopeAlloc( size, 8 )
4803:    oScopeEnd
4804:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4816:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4836:    {
4836:       Node enumValue = oNodeIterValue( it )
4846:       [ oNodeNull( enumValue )
4853:          | true :  >
4856:          | * :
4861:       ]
4861:       .tPushAddrGlobal  oEmitInt( addr )
4869:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4884:       .tAssignI
4886:       addr = add( addr, 8 )
4899:       .tPushAddrGlobal  oEmitInt( addr )
4907:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4922:       .tAssignP
4924:       addr = add( addr, 8 )
4937:       oNodeIterNext( it )
4943:    }
         % final table entry
4945:    .tPushAddrGlobal  oEmitInt( addr )
4953:    .tPushConstI  oEmitInt( 0 )
4961:    .tAssignI
4963:    addr = add( addr, 8 )
4976:    .tPushAddrGlobal  oEmitInt( addr )
4984:    .tPushConstI  oEmitInt( 0 )
4992:    .tAssignP
4994:    addr = add( addr, 8 )
5007:    oCodePop
      
5008:    oTypeAdd( resultType )
5015:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
5015: ConstExpr:
5017:    [
5017:       | pIntLit :
5019:          oValuePush( TOKEN_VALUE )
5024:       | pIdent :
5026:          Node decl = oScopeFindRequire
5031:          @ResolveUnitRef( decl )
5038:          [ oNodeType( decl )
5045:             | nConst :
5046:                oValuePush( oNodeGetInt( decl, qValue ) )
5059:             | * :
5064:                #eNotConst
5066:                oValuePush( 0 )
5072:          ]
5072:       | pMinus :
5074:          @ConstExpr
5076:          oValueNegate
5077:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5088: Expr:
5090:    Label falseLabel = labelNull
      
5096:    @ExprAllowCF( falseLabel )
5103:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5111: BooleanExprControlFlow( out Label falseLabel ):
5113:    @ExprAllowCF( falseLabel )
5120:    [ oTypeSNodeType
5122:       | nBooleanCFType :
5123:       | nBooleanType :
               % convert value to control flow
5125:          falseLabel = oLabelNew
5130:          .tJumpFalse  oEmitLabel( falseLabel )
5138:       | * :
5145:          #eNotBoolean
5147:    ]
5147:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5149: CFToVal( inout Label falseLabel ):
5151:    [ oTypeSNodeType
5153:       | nBooleanCFType :
5154:          Label doneLabel = oLabelNew
5159:          .tPushConstI  oEmitInt( 1 )
5167:          .tJump  oEmitLabel( doneLabel )
5175:          .tLabel  oEmitLabel( falseLabel )
5183:          .tPushConstI  oEmitInt( 0 )
5191:          .tLabel  oEmitLabel( doneLabel )
5199:          oTypeSPop
5200:          oTypeSPush( BooleanType )
5206:          falseLabel = labelNull
5212:       | * :
5217:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5218: ValToCF( out Label falseLabel ):
5220:    [ oTypeSNodeType
5222:       | nBooleanType :
5223:          falseLabel = oLabelNew
5228:          .tJumpFalse  oEmitLabel( falseLabel )
5236:          oTypeSPop
5237:          oTypeSPush( BooleanCFType )
5243:       | * :
5248:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5249: ExprAllowCF( out Label falseLabel ):
5251:    @BoolExprAllowCF( falseLabel )
5258:    {[
5258:       | '=' :
5260:          @CFToVal( falseLabel )
5267:          @PromoteToIntOptional
5269:          @BoolExprAllowCF( falseLabel )
5276:          @CFToVal( falseLabel )
5283:          @PromoteToIntOptional
5285:          @MatchTypes
5287:          [ oTypeSNodeType
5289:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
5292:             | nPointerType :                .tEqualP
5296:             | nCharType, nStringType :      #eNotImplemented
5300:             | * :                           #eNotAllowed
5317:          ]
5317:          oTypeSPop
5318:          oTypeSPush( BooleanType )
      
5324:       | '<>' :
5326:          @CFToVal( falseLabel )
5333:          @PromoteToIntOptional
5335:          @BoolExprAllowCF( falseLabel )
5342:          @CFToVal( falseLabel )
5349:          @PromoteToIntOptional
5351:          @MatchTypes
5353:          [ oTypeSNodeType
5355:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
5358:             | nPointerType :                .tNotEqualP
5362:             | nCharType, nStringType :      #eNotImplemented
5366:             | * :                           #eNotAllowed
5383:          ]
5383:          oTypeSPop
5384:          oTypeSPush( BooleanType )
      
5390:       | '<' :
5392:          @CFToVal( falseLabel )
5399:          @PromoteToIntOptional
5401:          @BoolExprAllowCF( falseLabel )
5408:          @CFToVal( falseLabel )
5415:          @PromoteToIntOptional
5417:          @MatchTypes
5419:          [ oTypeSNodeType
5421:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
5424:             | nCharType, nStringType :      #eNotImplemented
5428:             | * :                           #eNotAllowed
5443:          ]
5443:          oTypeSPop
5444:          oTypeSPush( BooleanType )
      
5450:       | '>' :
5452:          @CFToVal( falseLabel )
5459:          @PromoteToIntOptional
5461:          @BoolExprAllowCF( falseLabel )
5468:          @CFToVal( falseLabel )
5475:          @PromoteToIntOptional
5477:          @MatchTypes
5479:          [ oTypeSNodeType
5481:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
5484:             | nCharType, nStringType :      #eNotImplemented
5488:             | * :                           #eNotAllowed
5503:          ]
5503:          oTypeSPop
5504:          oTypeSPush( BooleanType )
      
5510:       | '<=' :
5512:          @CFToVal( falseLabel )
5519:          @PromoteToIntOptional
5521:          @BoolExprAllowCF( falseLabel )
5528:          @CFToVal( falseLabel )
5535:          @PromoteToIntOptional
5537:          @MatchTypes
5539:          [ oTypeSNodeType
5541:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
5544:             | nCharType, nStringType :      #eNotImplemented
5548:             | * :                           #eNotAllowed
5563:          ]
5563:          oTypeSPop
5564:          oTypeSPush( BooleanType )
      
5570:       | '>=' :
5572:          @CFToVal( falseLabel )
5579:          @PromoteToIntOptional
5581:          @BoolExprAllowCF( falseLabel )
5588:          @CFToVal( falseLabel )
5595:          @PromoteToIntOptional
5597:          @MatchTypes
5599:          [ oTypeSNodeType
5601:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
5604:             | nCharType, nStringType :      #eNotImplemented
5608:             | * :                           #eNotAllowed
5623:          ]
5623:          oTypeSPop
5624:          oTypeSPush( BooleanType )
      
5630:       | * :
5645:          >
5647:    ]};
      
      
5650: BoolExprAllowCF( out Label falseLabel ):
5652:    Label trueLabel = labelNull
      
5658:    @BoolTermAllowCF( falseLabel )
5665:    {[
5665:       | pOr :
5667:          [ oTypeSNodeType
5669:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5670:                [ equal_label( trueLabel, labelNull )
5680:                   | true :  trueLabel = oLabelNew
5686:                   | * :
5691:                ]
5691:                .tJump  oEmitLabel( trueLabel )
5699:             | nBooleanType :
5701:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5708:                [ equal_label( trueLabel, labelNull )
5718:                   | true :  trueLabel = oLabelNew
5724:                   | * :
5729:                ]
5729:                .tJump  oEmitLabel( trueLabel )
5737:             | * : #eNotBoolean
5746:          ]
5746:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5747:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5755:          falseLabel = labelNull
5761:          @BoolTermAllowCF( falseLabel )
      
5768:          [ oTypeSNodeType
5770:             | nBooleanCFType :
5771:             | nBooleanType :
5773:                @ValToCF( falseLabel )
5780:             | * : #eNotBoolean
5789:          ]
      
5789:          oTypeSPop
5790:          oTypeSPush( BooleanCFType )
      
5796:       | * :
5801:          >
5803:    ]}
      
         % any short-circuit trues jump here to the end
5805:    [ equal_label( trueLabel, labelNull )
5815:       | false :
5816:          .tLabel  oEmitLabel( trueLabel )
5824:       | * :
5829:    ]
5830:    ;
      
      
5830: BoolTermAllowCF( out Label falseLabel ):
5832:    Label overallFalseLabel = labelNull
      
5838:    @BoolFactorAllowCF( falseLabel )
5845:    {[
5845:       | pAnd :
5847:          [ oTypeSNodeType
5849:             | nBooleanCFType :
5850:             | nBooleanType :
5852:                @ValToCF( falseLabel )
5859:             | * :
5866:                #eNotBoolean
5868:          ]
5868:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5869:          [ equal_label( overallFalseLabel, labelNull )
5879:             | true :
5880:                overallFalseLabel = oLabelNew
5885:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5899:                falseLabel = overallFalseLabel
5905:             | * :
5910:          ]
      
5910:          Label factorFalseLabel = labelNull
5916:          @BoolFactorAllowCF( factorFalseLabel )
      
5923:          [ oTypeSNodeType
5925:             | nBooleanCFType :
5926:             | nBooleanType :
5928:                @ValToCF( factorFalseLabel )
5935:             | * : #eNotBoolean
5944:          ]
5944:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5958:       | * :
5963:          >
5965:    ]};
      
5968: BoolFactorAllowCF( out Label falseLabel ):
5970:    [
5970:       | pNot :
5972:          Label factorFalseLabel = labelNull
      
5978:          @BoolFactorAllowCF( factorFalseLabel )
5985:          [ oTypeSNodeType
5987:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5988:                falseLabel = oLabelNew
5993:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6001:                .tLabel  oEmitLabel( factorFalseLabel )
      
6009:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6011:                .tNot
      
6013:             | * : #eNotBoolean
6022:          ]
      
6022:       | * :
6027:          @ArithExprAllowCF( falseLabel )
6034:    ];
      
6035: ArithExprAllowCF( out Label falseLabel ):
6037:    @TermAllowCF( falseLabel )
6044:    {[
6044:       | '+' :
6046:          [ oTypeSNodeType
6048:             | nIntegerType, nByteType :
6049:                @PromoteToIntPop
6051:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6058:                @PromoteToInt
6060:                .tAddI
6062:             | nStringType, nCharType :
                     % String concatenation
6064:                #eNotImplemented
6066:             | nPointerType :
6068:                Node elementType = oNodeGet( oTypeSTop, qBaseType )
6080:                int elementSize = oNodeGetInt( elementType, qSize )
6093:                @TermAllowCF( falseLabel )  % actually not allowing CF
6100:                @PromoteToIntPop
6102:                [ equal( elementSize, 1 )
6112:                   | false :
6113:                      .tPushConstI  oEmitInt( elementSize )
6121:                      .tMultI
6123:                   | * :
6128:                ]
6128:                .tAddPI
6130:             | * :
6143:                #eNotAllowed
6145:          ]
      
6145:       | '-' :
               % TO DO: pointer arithmetic, as above
      
6147:          @PromoteToIntPop
6149:          @TermAllowCF( falseLabel )
6156:          @PromoteToInt
6158:          .tSubI
6160:       | * :
6167:          >
6169:    ]};
      
6172: TermAllowCF( out Label falseLabel ):
6174:    @FactorAllowCF( falseLabel )
6181:    {[
6181:       | pTimes :
6183:          @PromoteToIntPop
6185:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6192:          @PromoteToInt
6194:          .tMultI
6196:       | pDivide :
6198:          @PromoteToIntPop
6200:          @FactorAllowCF( falseLabel )
6207:          @PromoteToInt
6209:          .tDivI
6211:       | * :
6218:          >
6220:    ]};
      
6223: FactorAllowCF( out Label falseLabel ):
6225:    [
6225:       | pPlus :
6227:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6234:          @PromoteToInt
6236:       | pMinus :
6238:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6245:          @PromoteToInt
6247:          .tNegI
6249:       | * :
6256:          @PrimaryAllowCF( falseLabel )
6263:    ];
      
6264: PrimaryAllowCF( out Label falseLabel ):
6266:    [
6266:       | pIntLit :
6268:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6275:          oTypeSPush( IntegerType )
      
6281:       | pCharLit :
6283:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6290:          oTypeSPush( CharType )
      
6296:       | '(' :
6298:          @ExprAllowCF( falseLabel )
6305:          ')'
      
6307:       | pStrLit :
6309:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
6318:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
6326:          oTypeSPush( StringType )
      
6332:       | pIdent :
6334:          Node decl = oScopeFindRequire
6339:          @ResolveUnitRef( decl )
6346:          Node theType
      
6346:          [ oNodeType( decl )
6353:             | nFunc :
6354:                @Call( decl )
      
6361:             | nBuiltInFunc :
6363:                @CallBuiltInFunc( decl )
      
6370:             | nConst, nEnumValue :
6372:                theType = oNodeGet( decl, qType )
6385:                oTypeSPush( theType )
6391:                [ oTypeSNodeType
6393:                   | nIntegerType, nEnumType, nBooleanType :
6394:                      .tPushConstI @EmitValue( decl )
6403:                   | * :
6412:                      #eNotImplemented
6414:                ]
      
6414:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6416:                @VarExpr( decl )
      
6423:             | * :
6442:                #eNotValue
6444:                oTypeSPush( IntegerType )
6450:          ]
      
6450:       | '@' :        % @var -- pointer to var
6452:          pIdent
      
6454:          Node decl = oScopeFindRequire
6459:          @ResolveUnitRef( decl )
6466:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6466:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6476:          theType = oTypeSTop
6481:          oTypeSPop
6482:          Node ptrType = @PointerTypeTo( theType )
6493:          oTypeSPush( ptrType )
      
6499:       | * :
6514:          #eNotValue
6516:          oTypeSPush( IntegerType )
6522:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6523: VarExpr( Node decl ):
6525:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6538:    int uplevels = @DeclUpLevels( decl )
      
6549:    oTypeSPush( theType )
6555:    [ oTypeSNodeType
6557:       | nIntegerType, nEnumType :
6558:          [ oNodeType( decl )
6565:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6575:             | nLocalVar :
6577:                [ equal_zero( uplevels )
6584:                   | true :  .tPushLocalI  @EmitValue( decl )
6594:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6614:                ]
6614:             | nParam :
6616:                [ oNodeGetBoolean( decl, qInOut )
6626:                   | true :    % VAR param points to the var.  Auto dereference.
6627:                      [ equal_zero( uplevels )
6634:                         | true :  .tPushParamP  @EmitValue( decl )
6644:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6664:                      ]
6664:                      .tFetchI
6666:                   | * :
6671:                      [ equal_zero( uplevels )
6678:                         | true :  .tPushParamI  @EmitValue( decl )
6688:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6708:                      ]
6708:                ]
6708:          ]
      
6720:       | nBooleanType, nByteType, nCharType :
6722:          [ oNodeType( decl )
6729:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6739:             | nLocalVar :
6741:                [ equal_zero( uplevels )
6748:                   | true :  .tPushLocalB  @EmitValue( decl )
6758:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6778:                ]
6778:             | nParam :
6780:                [ oNodeGetBoolean( decl, qInOut )
6790:                   | true :    % VAR param points to the var.  Auto dereference.
6791:                      [ equal_zero( uplevels )
6798:                         | true :  .tPushParamP  @EmitValue( decl )
6808:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6828:                      ]
6828:                      .tFetchB
6830:                   | * :
6835:                      [ equal_zero( uplevels )
6842:                         | true :  .tPushParamB  @EmitValue( decl )
6852:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6872:                      ]
6872:                ]
6872:          ]
      
6884:       | nStringType, nFileType :
6886:          #eNotImplemented
      
6888:       | nPointerType :
6890:          [ oNodeType( decl )
6897:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6907:             | nLocalVar :
6909:                [ equal_zero( uplevels )
6916:                   | true :  .tPushLocalP  @EmitValue( decl )
6926:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6946:                ]
6946:             | nParam :
6948:                [ oNodeGetBoolean( decl, qInOut )
6958:                   | true :    % VAR param points to the var.  Auto dereference.
6959:                      [ equal_zero( uplevels )
6966:                         | true :  .tPushParamP  @EmitValue( decl )
6976:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6996:                      ]
6996:                      .tFetchP
6998:                   | * :
7003:                      [ equal_zero( uplevels )
7010:                         | true :  .tPushParamP  @EmitValue( decl )
7020:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7040:                      ]
7040:                ]
7040:          ]
7052:          [
7052:             | '^' :             % dereferenced
7054:                oTypeSPop
7055:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7068:                @LValueIndexes
7070:                @FetchVar
7072:             | * :               % just ptr value alone
7077:          ]
      
7077:       | nArrayType, nRecordType :
               % compound type
               % first, push addr of start of var
7079:          [ oNodeType( decl )
7086:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7096:             | nLocalVar :
7098:                [ equal_zero( uplevels )
7105:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7115:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7135:                ]
7135:             | nParam :
7137:                [ oNodeGetBoolean( decl, qInOut )
7147:                   | true :    % VAR param points to the var.  Auto dereference.
7148:                      [ equal_zero( uplevels )
7155:                         | true :  .tPushParamP  @EmitValue( decl )
7165:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7185:                      ]
7185:                   | * :
7190:                      [ equal_zero( uplevels )
7197:                         | true :  .tPushAddrParam  @EmitValue( decl )
7207:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7227:                      ]
7227:                ]
7227:          ]
               % modify addr for subscripts, field references, etc
7239:          @LValueIndexes
               % get final value
7241:          @FetchVar
7243:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7268: FetchVar:
7270:    [ oTypeSNodeType
7272:       | nIntegerType, nEnumType :  .tFetchI
7275:       | nBooleanType, nByteType, nCharType :  .tFetchB
7279:       | nStringType, nFileType :   #eNotImplemented
7283:       | nPointerType :             .tFetchP
7287:       | nArrayType, nRecordType :  % compound type; leave as addr
7289:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7314: LValueIndexes:
7316:    {[
7316:       | '[' :       @ArraySubscripts
7320:       | '.' :       @RecordFieldRef
7324:       | '^' :       @PointerDeref
7328:       | * :         >
7339:    ]};
      
7342: ArraySubscripts:
7344:    [ oTypeSNodeType
7346:       | nArrayType :
7347:       | * :       #eNotArray
7354:    ]
7354:    {
7354:       [ oTypeSNodeType
7356:          | nArrayType :
7357:          | * :    #eTooManySubscripts
7364:       ]
      
            % low subscript of this dimension
7364:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7381:       Node baseType
7381:       baseType = oNodeGet( oTypeSTop, qBaseType )
7393:       oTypeSPop
7394:       oTypeSPush( baseType )
      
7400:       @Expr
7402:       @RequireIntPop
            % adjust for low subscript
7404:       [ equal_zero( low )
7411:          | false :
7412:             .tPushConstI oEmitInt( low ) .tSubI
7422:          | * :
7427:       ]
      
            % multiply by element size
7427:       int size = oNodeGetInt( baseType, qSize )
7440:       [ equal( size, 1 )
7450:          | false :
7451:             .tPushConstI oEmitInt( size ) .tMultI
7461:          | * :
7466:       ]
      
            % update start address
7466:       .tAddPI
7468:       [
7468:          | ']' :  >
7472:          | ',' :
7474:       ]
7482:    };
      
      
7485: RecordFieldRef:
7487:    [ oTypeSNodeType
7489:       | nRecordType :
7490:       | * :    #eNotRecord
7497:    ]
7497:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7509:    pIdent
7511:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7516:    [ oNodeType( field )
7523:       | nRecordField :
7524:       | * :   #eNotRecordField
7531:    ]
7531:    oScopeEnd
7532:    int offset = oNodeGetInt( field, qValue )
7545:    [ equal_zero( offset )
7552:       | false :
7553:          .tPushConstI oEmitInt( offset ) .tAddPI
7563:       | * :
7568:    ]
      
         % replace the type on the type stack, with the field type
7568:    oTypeSPop
7569:    oTypeSPush( oNodeGet( field, qType ) )
7583:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7583: PointerDeref:
7585:    [ oTypeSNodeType
7587:       | nPointerType :
7588:       | * :       #eNotPointer
7595:    ]
7595:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7597:    Node theType = oTypeSTop
7602:    oTypeSPop
7603:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7617:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7617: CoerceType:
7619:    node_type nt = oTypeSNodeType
7624:    oTypeSPop
7625:    [ equal_node_type( nt, oTypeSNodeType )
7634:       | false :
               % Can we implicitly convert the value to the desired type?
7635:          [ oTypeSNodeType
7637:             | nIntegerType :
7638:                [ nt
7641:                   | nByteType :   .tCastBtoI  >>
7645:                   | * :
7650:                ]
7650:             | nByteType :
7652:                [ nt
7655:                   | nIntegerType :   .tCastItoB  >>
7659:                   | * :
7664:                ]
7664:             | * :
7671:          ]
7671:          #eTypeMismatch
7673:       | * :
7678:    ];
      
      
      % Called on first use of an extern method
      %
7679: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7681:    int strAddr
7681:    String externalName = oNodeGetString( method, qExternalName )
7694:    [ equal_string( externalName, stringNull )
7704:       | true :
7705:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7726:       | false :
7728:          strAddr = oStringAllocLit( externalName )
7738:    ]
7746:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
7762:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7762: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
7764:    [ oNodeGetBoolean( method, qExternal )
7774:       | true :
7775:          [ oNodeGetBoolean( method, qUsed )
7785:             | false :
                     % define the extern label on first use
7786:                @DefineExternLabel( method )
7793:             | * :
7798:          ]
7798:      | * :
7803:    ]
7803:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
7815:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
7828:    Node resultType
7828:    int tempOffset
      
7828:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
7845:    [ isFunc
7848:       | true :
7849:          resultType = oNodeGet( method, qType )
7862:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
7872:       | * :
7877:    ]
         
      
7877:    Node paramScope = oNodeGet( method, qParams )
7890:    int actualsSize = oNodeGetInt( paramScope, qSize )
7903:    [ cdecl
7906:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
7915:       | false :  .tAllocActuals  oEmitInt( actualsSize )
7925:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
7933:    [ greater( @DeclLevel( method ), 0 )
7948:       | true :
7949:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
7957:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
7976:          .tAssignP
7978:       | * :
7983:    ]
      
      
7983:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
7996:    Node param = oNodeIterValue( paramIter )
8006:    [
8006:       | '(' :
            
8008:          {
8008:             [ oNodeNull( param )
8015:                | true : >
8018:                | * :
8023:             ]
      
8023:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
8036:             .tPushAddrActual oEmitInt( offset )
8044:             oTypeSPush( oNodeGet( param, qType ) )
      
8057:             [ oNodeGetBoolean( param, qInOut )
8067:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
8068:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
8075:                           @MatchTypes
      
8077:                           .tAssignP
      
8079:                | false :  @Expr
8083:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
8085:                           [ oTypeSNodeType
8087:                              | nIntegerType, nEnumType : .tAssignI
8090:                              | nBooleanType, nByteType, nCharType :  .tAssignB
8094:                              | nStringType, nFileType :   #eNotImplemented
8098:                              | nPointerType :            .tAssignP
8102:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
8104:                                  int size = oNodeGetInt( oTypeSTop, qSize )
8116:                                  .tCopy  oEmitInt( size )    % multi-word copy
8124:                           ]
8148:             ]
8156:             oTypeSPop
      
8157:             oNodeIterNext( paramIter )
8163:             param = oNodeIterValue( paramIter )
8173:             [ oNodeNull( param )
8180:                | true :  >
8183:                | false :
8185:             ]
      
8193:             ','
8195:          }
      
8197:          ')'
      
8199:       | * :
8204:    ]
      
8204:    [ oNodeNull( param )
8211:       | false :    #eMissingParameter
8214:       | * :
8219:    ]
      
8219:    [ isFunc
8222:       | true :
               % Pass result temp as an additional VAR parameter.
8223:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
8238:          .tPushAddrLocal  oEmitInt( tempOffset )
8246:          .tAssignP
8248:       | * :
8253:    ]
      
8253:    [ cdecl
8256:       | true :
8257:          .tCallCdecl  @EmitValue( method )
8266:       | false :
8268:          .tCall   @EmitValue( method )
8277:    ]
      
8285:    [ isFunc
8288:       | true :
               % push return value from temp
8289:          oTypeSPush( resultType )
      
8295:          [ oTypeSNodeType
8297:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8306:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8316:             | nStringType, nFileType :  #eNotImplemented
8320:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8330:             | nArrayType, nRecordType :   % compound type: push address
8332:                                .tPushAddrLocal  oEmitInt( tempOffset )
8340:          ]
8364:       | * :
8369:    ]
         
8369:    .tFreeActuals  oEmitInt( actualsSize )
8378:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8378: CallBuiltInFunc( Node method ):
      
         % Ord(x)
8380:    [ oNodeEqual( method, BuiltIn_Ord )
8390:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
8391:          '('
8393:          @Expr
8395:          [ oTypeSNodeType
8397:             | nIntegerType, nEnumType :
8398:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
8402:             | * :  #eTypeMismatch
8417:          ]
8417:          oTypeSPop
8418:          oTypeSPush( IntegerType )
8424:          ')'
8426:          >>
8427:       | * :
8432:    ]
      
         % Chr(x)
8432:    [ oNodeEqual( method, BuiltIn_Chr )
8442:       | true :
               % parameter is integer
               % result is char
8443:          '('
8445:          @Expr
8447:          [ oTypeSNodeType
8449:             | nIntegerType :    .tCastItoB
8452:             | nByteType :
8454:             | * :  #eTypeMismatch
8463:          ]
8463:          oTypeSPop
8464:          oTypeSPush( CharType )
8470:          ')'
8472:          >>
8473:       | * :
8478:    ]
      
         % Pred(x)
8478:    [ oNodeEqual( method, BuiltIn_Pred )
8488:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8489:          '('
8491:          @Expr
8493:          [ oTypeSNodeType
8495:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8496:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8505:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8508:                   | * :
8513:                ]
8513:             | * :  #eTypeMismatch
8520:          ]
8520:          .tDecI
8522:          ')'
8524:          >>
8525:       | * :
8530:    ]
      
         % Succ(x)
8530:    [ oNodeEqual( method, BuiltIn_Succ )
8540:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8541:          '('
8543:          @Expr
8545:          [ oTypeSNodeType
8547:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8548:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8557:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8560:                   | * :
8565:                ]
8565:             | * :  #eTypeMismatch
8572:          ]
8572:          .tIncI
8574:          ')'
8576:          >>
8577:       | * :
8582:    ]
      
8582:    #eNotImplemented
8585:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
8585: Statement:
8587:    [
8587:       | pWriteln :     @WritelnStmt
8591:       | pWrite :       @WriteStmt
8595:       | pReadln :      @ReadlnStmt
8599:       | pRead :        @ReadStmt
8603:       | pIf :          @IfStmt
8607:       | pWhile :       @WhileStmt
8611:       | pFor :         @ForStmt
8615:       | pRepeat :      @RepeatStmt
8619:       | pBreak :       @BreakStmt
8623:       | pContinue :    @ContinueStmt
8627:       | pBegin :       @BeginStmt
8631:       | pIdent :       @LabelOrAssignOrCallStmt
8635:       | pGoto :        @GotoStmt
8639:       | pIntLit :      % should be an integer label
8641:                        oChangeIntLitToLabelIdent
8642:                        @LabelOrAssignOrCallStmt
8644:       | * :            % null statement : don't accept any tokens
8675:    ];
      
      
8676: LabelOrAssignOrCallStmt:
8678:    Node decl = oScopeFindRequire
8683:    @ResolveUnitRef( decl )
8690:    [ oNodeType( decl )
8697:       | nLabel :                          @LabelDefinition( decl )
8705:                                           @Statement
8707:       | nProc :                           @Call( decl )
8716:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8725:       | nFunc :                           @AssignResultStmt( decl )
8734:       | * :                               #eBadStatement
8751:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8752: LabelDefinition( Node decl ):
8754:    [ oNodeGetBoolean( decl, qDefined )
8764:       | true :  #eAlreadyDefined
8767:       | * :
8772:    ]
8772:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8787:    oNodeSetBoolean( decl, qDefined, true )
8799:    ':'
8802:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8802: AssignStmt( Node decl ):
      
8804:    @LValueVar( decl, true )
8814:    ':=' 
8816:    @Expr
8818:    @CoerceType
8820:    @Assign
8823:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8823: Assign:
8825:    [ oTypeSNodeType
8827:       | nIntegerType, nEnumType :  .tAssignI
8830:       | nBooleanType, nByteType, nCharType :  .tAssignB
8834:       | nStringType, nFileType :   #eNotImplemented
8838:       | nPointerType :             .tAssignP
            % compound var assigns; addrs of src, dest on stack
8842:       | nArrayType, nRecordType :
8844:           int size = oNodeGetInt( oTypeSTop, qSize )
8856:           .tCopy  oEmitInt( size )    % multi-word copy
8864:    ]
8888:    oTypeSPop
8890:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8890: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8892:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8908:       | false :   #eNotCurrentFunction
8911:       | * :
8916:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8916:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8931:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8944:    ':='
8946:    @Expr
8948:    @CoerceType
8950:    [ oTypeSNodeType
8952:       | nIntegerType, nEnumType : .tAssignI
8955:       | nBooleanType, nByteType, nCharType :  .tAssignB
8959:       | nStringType, nFileType :   #eNotImplemented
8963:       | nPointerType :            .tAssignP
            % compound var assigns; addrs of src, dest on stack
8967:       | nArrayType, nRecordType :
8969:           int size = oNodeGetInt( oTypeSTop, qSize )
8981:           .tCopy  oEmitInt( size )    % multi-word copy
8989:    ]
9013:    oTypeSPop
9015:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9015: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
9017:    pIdent
9019:    Node decl = oScopeFindRequire
9024:    @ResolveUnitRef( decl )
9031:    [ oNodeType( decl )
9038:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9039:       | * :  #eNotVar
9052:    ]
9052:    @LValueVar( decl, writeable )
9063:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9063: LValueVar( Node decl, boolean writeable ):
9065:    [ oNodeType( decl )
9072:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9082:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9093:       | nParam :
9095:          [ oNodeGetBoolean( decl, qInOut )
9105:             | true :   % VAR param points to variable.  No dereference.
9106:                        .tPushParamP @EmitValue( decl )
9115:             | * :      .tPushAddrParam @EmitValue( decl )
9129:          ]
9129:       | nTypedConst :
9131:          [ writeable
9134:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9144:             | * :      #eNotVar
9151:          ]
9151:       | * :            #eNotVar
9164:    ]
      
9164:    oTypeSPush( oNodeGet( decl, qType ) )
9177:    @LValueIndexes        % handle subscripts, if any
9180:    ;
      
      
9180: IncVar( Node decl ):
9182:    @LValueVar( decl, true )
9192:    @RequireIntPop
9194:    @VarExpr( decl )
9201:    oTypeSPop
9202:    .tIncI
9204:    .tAssignI;
      
9207: DecVar( Node decl ):
9209:    @LValueVar( decl, true )
9219:    @RequireIntPop
9221:    @VarExpr( decl )
9228:    oTypeSPop
9229:    .tDecI
9231:    .tAssignI;
      
      
9234: IfStmt:
9236:    Label falseLabel = labelNull
      
9242:    @BooleanExprControlFlow( falseLabel )
9249:    pThen
9251:    @Statement
9253:    [
9253:       | pElse :
9255:          Label doneLabel = oLabelNew
      
9260:          .tJump  oEmitLabel( doneLabel )
9268:          .tLabel oEmitLabel( falseLabel )
9276:          @Statement
9278:          .tLabel oEmitLabel( doneLabel )
      
9286:       | * :
9291:          .tLabel oEmitLabel( falseLabel )
9299:    ];
      
      
9300: ForStmt:
9302:    pIdent
      
9304:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9309:    @LValueVar( decl, true )
9319:    @RequireIntPop
      
9321:    ':='
      
9323:    @Expr
9325:    @RequireIntPop
9327:    .tAssignI
      
9329:    Label breakLabel = oLabelNew
      
9334:    Label checkLabel = oLabelNew
9339:    .tJump  oEmitLabel( checkLabel )
      
9347:    Label continueLabel = oLabelNew
9352:    .tLabel  oEmitLabel( continueLabel )
9360:    [
9360:       | pTo :
9362:          @IncVar( decl )
9369:          .tLabel  oEmitLabel( checkLabel )
9377:          @VarExpr( decl )  oTypeSPop
9385:          @Expr
9387:          @RequireIntPop
9389:          .tGreaterI
9391:          .tJumpTrue  oEmitLabel( breakLabel )
9399:       | pDownto :
9401:          @DecVar( decl )
9408:          .tLabel  oEmitLabel( checkLabel )
9416:          @VarExpr( decl )  oTypeSPop
9424:          @Expr
9426:          @RequireIntPop
9428:          .tLessI
9430:          .tJumpTrue  oEmitLabel( breakLabel )
9438:    ]
9446:    oLoopPush( continueLabel, breakLabel )
9455:    pDo
9457:    @Statement
9459:    .tJump  oEmitLabel( continueLabel )
9467:    .tLabel  oEmitLabel( breakLabel )
9475:    oLoopPop;
      
      
9477: RepeatStmt:
9479:    Label continueLabel = oLabelNew
9484:    .tLabel  oEmitLabel( continueLabel )
      
9492:    Label breakLabel = oLabelNew
      
9497:    oLoopPush( continueLabel, breakLabel )
9506:    @Statement
9508:    {[
9508:       | ';' :
9510:          @Statement
9512:       | pUntil :
9514:          Label falseLabel
9514:          @BooleanExprControlFlow( falseLabel )
9521:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9535:          >
9537:    ]}
9547:    .tLabel  oEmitLabel( breakLabel )
9555:    oLoopPop;
      
      
9557: WhileStmt:
9559:    Label continueLabel = oLabelNew
9564:    .tLabel  oEmitLabel( continueLabel )
      
9572:    Label breakLabel
9572:    @BooleanExprControlFlow( breakLabel )
      
9579:    oLoopPush( continueLabel, breakLabel )
9588:    pDo
9590:    @Statement
9592:    .tJump  oEmitLabel( continueLabel )
9600:    .tLabel  oEmitLabel( breakLabel )
9608:    oLoopPop;
      
      
9610: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9612:    [ equal_label( oLoopContinueLabel, labelNull )
9621:       | true :
9622:          #eNotInALoop
9624:       | false :
9626:          .tJump  oEmitLabel( oLoopContinueLabel )
9633:    ];
      
      
9642: BreakStmt:
9644:    [ equal_label( oLoopBreakLabel, labelNull )
9653:       | true :
9654:          #eNotInALoop
9656:       | false :
9658:          .tJump  oEmitLabel( oLoopBreakLabel )
9665:    ];
      
      
9674: GotoStmt:
9676:    [
9676:       | pIdent :
9678:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9680:          oChangeIntLitToLabelIdent
9681:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9689:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9698:    oNodeSetBoolean( decl, qUsed, true )
9710:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9726:    ;
      
      
9726: BeginStmt:
9728:    @Statement
9730:    {[
9730:       | ';' :   @Statement
9734:       | pEnd :  >
9738:    ]};
      
      
9749: WritelnStmt:
9751:    @WriteStmt
9753:    .tWriteCR;
      
      
9756: WriteStmt:
9758:    [
9758:       | '(' :
9760:          {
9760:             @Expr
9762:             [ oTypeSNodeType
9764:                | nIntegerType :             .tWriteI
9767:                | nBooleanType :             .tWriteBool
9771:                | nByteType :                .tCastBtoI  .tWriteI
9777:                | nCharType :                .tWriteChar
9781:                | nStringType :              .tWriteStr
9785:                | nFileType :                #eNotImplemented
9789:                | nEnumType :
                        % write name via table lookup
9791:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9805:                   .tWriteEnum
9807:                | nPointerType :             .tWriteP
9811:                | * :                        #eNotAllowed
9832:             ]
9832:             oTypeSPop
9833:             [
9833:                | ')' : >
9837:                | ',' :
9839:             ]
9847:          }
9849:       | * :
9854:    ];
      
      
9855: ReadlnStmt:      % ***
         % TO DO
9858:    ;
      
9858: ReadStmt:
         % TO DO
9861:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
9861: ScopeLevel >> int:
9863:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
9873: DeclLevel( Node decl ) >> int:
9875:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
9893: DeclUpLevels( Node decl ) >> int:
9895:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
9911: MatchTypes:
9913:    node_type nt = oTypeSNodeType
9918:    oTypeSPop
9919:    [ equal_node_type( nt, oTypeSNodeType )
9928:       | false :
9929:          #eTypeMismatch
9931:       | * :
9936:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9937: RequireIntPop:
9939:    [ oTypeSNodeType
9941:       | nIntegerType :
9942:       | * :          #eNotInteger
9949:    ]
9949:    oTypeSPop;
      
9951: RequireInt:
9953:    [ oTypeSNodeType
9955:       | nIntegerType :
9956:       | * :          #eNotInteger
9963:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9964: PromoteToIntPop:
9966:    [ oTypeSNodeType
9968:       | nIntegerType :
9969:       | nByteType :        .tCastBtoI
9973:       | * :                #eNotInteger
9982:    ]
9982:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9984: PromoteToInt:
9986:    [ oTypeSNodeType
9988:       | nIntegerType :
9989:       | nByteType :        .tCastBtoI
9993:                            oTypeSPop
9994:                            oTypeSPush( IntegerType )
10000:       | * :                #eNotInteger
10009:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
10010: PromoteToIntOptional:
10012:    [ oTypeSNodeType
10014:       | nByteType :        .tCastBtoI
10017:                            oTypeSPop
10018:                            oTypeSPush( IntegerType )
10024:       | * :
10029:    ];
      
      
      
      
10030: RequireBoolPop:
10032:    [ oTypeSNodeType
10034:       | nBooleanType :
10035:       | * :          #eNotBoolean
10042:    ]
10042:    oTypeSPop;
      
10044: RequireBool:
10046:    [ oTypeSNodeType
10048:       | nBooleanType :
10049:       | * :          #eNotBoolean
10056:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10057: newType( node_type nt, int size ) >> Node:
10059:   Node node = oNodeNew( nt )
10069:   oNodeSetInt( node, qSize, size )
10081:   oTypeAdd( node )
10087:   >> node
10091:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
10091: newIdent( node_type nt, int id ) >> Node:
10093:   Node t = oNodeNew( nt )
10103:   oNodeSetInt( t, qIdent, id )
10115:   >> t
10119:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
10119: PointerTypeTo( Node theType ) >> Node:
10121:    Node ptrType = oNodeGet( theType, qPointerType )
10134:    [ oNodeNull( ptrType )
10141:       | true :
10142:          ptrType = oNodeNew( nPointerType )
10152:          oNodeSet( ptrType, qBaseType, theType )
10164:          oNodeSetInt( ptrType, qSize, 8 )
10176:          oTypeAdd( ptrType )
10182:          oNodeSet( theType, qPointerType, ptrType )
10194:       | * :
10199:    ]
10199:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
10203: OrdinalLow( Node theType ) >> int:
10205:    [ oNodeType( theType )
10212:       | nIntegerType :  >> oMININT
10215:       | nBooleanType :  >> 0
10220:       | nCharType :     >> 0
10225:       | nEnumType :
10227:          Node enumScope = oNodeGet( theType, qScope )
10240:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
10257:          >> oNodeGetInt( first, qValue )
10267:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
10279:       | * :             #eNotOrdinalType
10294:                         >> 0
10297:    ];
      
      
      % Return the high value of an ordinal type
      %
10298: OrdinalHigh( Node theType ) >> int:
10300:    [ oNodeType( theType )
10307:       | nIntegerType :  >> oMAXINT
10310:       | nBooleanType :  >> 1
10315:       | nCharType :     >> 255
10320:       | nEnumType :
10322:          Node enumScope = oNodeGet( theType, qScope )
10335:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
10352:          >> oNodeGetInt( last, qValue )
10362:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
10374:       | * :             #eNotOrdinalType
10389:                         >> 0
10392:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
10393: EmitValue( Node decl ):
10395:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
10409: DeclareBuiltInFunc( int id ) >> Node:
10411:    Node decl = @newIdent( nBuiltInFunc, id )
10425:    oScopeDeclare( decl )
10431:    >> decl;
      
      
10435: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
10437:    mysystemId = oIdAdd_mysystem
      
         % install built-in types
10442:    FileType = @newType( nFileType, 4 )
10456:    IntegerType = @newType( nIntegerType, 4 )
10470:    BooleanType = @newType( nBooleanType, 1 )
10484:    BooleanCFType = @newType( nBooleanCFType, 1 )
10498:    CharType = @newType( nCharType, 1 )
10512:    ByteType = @newType( nByteType, 1 )
10526:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
10540:    Node t
      
10540:    t = @newIdent( nTypeDecl, oIdAdd_File )
10553:    oNodeSet( t, qType, FileType )
10565:    oScopeDeclare( t )
      
10571:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
10584:    oNodeSet( t, qType, IntegerType )
10596:    oScopeDeclare( t )
      
10602:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
10615:    oNodeSet( t, qType, BooleanType )
10627:    oScopeDeclare( t )
      
10633:    t = @newIdent( nTypeDecl, oIdAdd_Char )
10646:    oNodeSet( t, qType, CharType )
10658:    oScopeDeclare( t )
      
10664:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
10677:    oNodeSet( t, qType, ByteType )
10689:    oScopeDeclare( t )
      
10695:    t = @newIdent( nTypeDecl, oIdAdd_String )
10708:    oNodeSet( t, qType, StringType )
10720:    oScopeDeclare( t )
      
         % Built-in constants
      
10726:    t = @newIdent( nConst, oIdAdd_True )
10739:    oNodeSet( t, qType, BooleanType )
10751:    oNodeSetInt( t, qValue, 1 )
10763:    oScopeDeclare( t )
      
10769:    t = @newIdent( nConst, oIdAdd_False )
10782:    oNodeSet( t, qType, BooleanType )
10794:    oNodeSetInt( t, qValue, 0 )
10806:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
10812:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
10822:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
10832:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
10842:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
10853:    ;
      
10853: end
      
10853: 

Generated code:

   0: oGlobalSpace 16
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 10435
  25: oEmit 54
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 48
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 51
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 50
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 53
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 10091
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 10091
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          57    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 509
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1459
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1780
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1515
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 571
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 370
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 370
 367: oPop 2
 369: oReturn
 370: oLocalSpace 2
 372: oGetAddrLocal 1
 374: oPushResult
 375: oGetParam 2
 377: oPushResult
 378: oCall 650
 380: oPop 1
 382: oAssign
 383: oGetLocal 1
 385: oPushResult
 386: oSetResult 0
 388: oPushResult
 389: equal_node
 390: oPop 2
 392: oChoice 462
 394: oGetParam 1
 396: oPushResult
 397: oSetResult 5
 399: oPushResult
 400: oGetLocal 1
 402: oPushResult
 403: oNodeAddLast
 404: oPop 3
 406: oGetAddrLocal 2
 408: oPushResult
 409: oSetResult 10
 411: oPushResult
 412: oNodeNew
 413: oPop 1
 415: oAssign
 416: oGetLocal 2
 418: oPushResult
 419: oSetResult 4
 421: oPushResult
 422: oGetLocal 1
 424: oPushResult
 425: oSetResult 4
 427: oPushResult
 428: oNodeGetInt
 429: oPop 2
 431: oPushResult
 432: oNodeSetInt
 433: oPop 3
 435: oGetLocal 2
 437: oPushResult
 438: oSetResult 9
 440: oPushResult
 441: oGetLocal 1
 443: oPushResult
 444: oSetResult 9
 446: oPushResult
 447: oNodeGet
 448: oPop 2
 450: oPushResult
 451: oNodeSet
 452: oPop 3
 454: oGetLocal 2
 456: oPushResult
 457: oScopeDeclare
 458: oPop 1
 460: oJumpForward 465
 462: Choice Lookup Table
           0    394
 465: oReturn
 466: oLocalSpace 1
 468: oGetFromParam 1
 470: oPushResult
 471: oNodeType
 472: oPop 1
 474: oChoice 505
 476: oGetAddrLocal 1
 478: oPushResult
 479: oGetFromParam 1
 481: oPushResult
 482: oSetResult 9
 484: oPushResult
 485: oNodeGet
 486: oPop 2
 488: oAssign
 489: oInput 20
 491: oInput 0
 493: oGetParam 1
 495: oPushResult
 496: oGetLocal 1
 498: oPushResult
 499: oScopeFindRequireInScope
 500: oPop 1
 502: oAssign
 503: oJumpForward 508
 505: Choice Lookup Table
          10    476
 508: oReturn
 509: oLocalSpace 2
 511: oGetAddrLocal 1
 513: oPushResult
 514: oGetParam 1
 516: oPushResult
 517: oSetResult 5
 519: oPushResult
 520: oNodeGetIter
 521: oPop 2
 523: oAssign
 524: oGetAddrLocal 2
 526: oPushResult
 527: oGetLocal 1
 529: oPushResult
 530: oNodeIterValue
 531: oPop 1
 533: oAssign
 534: oGetLocal 2
 536: oPushResult
 537: oNodeNull
 538: oPop 1
 540: oChoice 557
 542: oGetLocal 2
 544: oPushResult
 545: oSetResult 9
 547: oPushResult
 548: oNodeGet
 549: oPop 2
 551: oPushResult
 552: oScopeEnter
 553: oPop 1
 555: oJumpForward 562
 557: Choice Lookup Table
           0    542
 560: oJumpForward 570
 562: oGetAddrLocal 1
 564: oPushResult
 565: oNodeIterNext
 566: oPop 1
 568: oJumpBack 524
 570: oReturn
 571: oLocalSpace 2
 573: oGetAddrLocal 1
 575: oPushResult
 576: oGetParam 1
 578: oPushResult
 579: oSetResult 5
 581: oPushResult
 582: oNodeGetIterLast
 583: oPop 2
 585: oAssign
 586: oGetAddrLocal 2
 588: oPushResult
 589: oGetLocal 1
 591: oPushResult
 592: oNodeIterValue
 593: oPop 1
 595: oAssign
 596: oGetLocal 2
 598: oPushResult
 599: oNodeNull
 600: oPop 1
 602: oChoice 636
 604: oScopeCurrent
 605: oPushResult
 606: oGetLocal 2
 608: oPushResult
 609: oSetResult 9
 611: oPushResult
 612: oNodeGet
 613: oPop 2
 615: oPushResult
 616: oNodeEqual
 617: oPop 2
 619: oChoice 627
 621: oJumpForward 633
 623: oError 25
 625: oJumpForward 633
 627: Choice Lookup Table
           0    623
           1    621
 632: oEndChoice
 633: oScopeEnd
 634: oJumpForward 641
 636: Choice Lookup Table
           0    604
 639: oJumpForward 649
 641: oGetAddrLocal 1
 643: oPushResult
 644: oNodeIterPrev
 645: oPop 1
 647: oJumpBack 586
 649: oReturn
 650: oLocalSpace 2
 652: oGetAddrLocal 1
 654: oPushResult
 655: oGetGlobal 1
 657: oPushResult
 658: oSetResult 1
 660: oPushResult
 661: oSetResult 4
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oNodeFind
 668: oPop 4
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 0
 676: oPushResult
 677: equal_node
 678: oPop 2
 680: oChoice 687
 682: oGetLocal 1
 684: oReturn
 685: oJumpForward 690
 687: Choice Lookup Table
           0    682
 690: oGetAddrLocal 2
 692: oPushResult
 693: oGetParam 1
 695: oPushResult
 696: oIncludeUnitFile
 697: oPop 1
 699: oAssign
 700: oGetLocal 2
 702: oChoice 711
 704: oError 24
 706: oSetResult 0
 708: oReturn
 709: oJumpForward 714
 711: Choice Lookup Table
           0    704
 714: oGetAddrLocal 1
 716: oPushResult
 717: oCall 725
 719: oAssign
 720: oIncludeEnd
 721: oGetLocal 1
 723: oReturn
 724: oReturn
 725: oLocalSpace 2
 727: oInput 58
 729: oInput 0
 731: oGetAddrLocal 1
 733: oPushResult
 734: oSetResult 5
 736: oPushResult
 737: oNodeNew
 738: oPop 1
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oSetResult 4
 746: oPushResult
 747: LAST_ID
 748: oPushResult
 749: oNodeSetInt
 750: oPop 3
 752: oGetAddrLocal 2
 754: oPushResult
 755: oSetResult 6
 757: oPushResult
 758: oNodeNew
 759: oPop 1
 761: oAssign
 762: oGetLocal 2
 764: oPushResult
 765: oSetResult 4
 767: oPushResult
 768: LAST_ID
 769: oPushResult
 770: oNodeSetInt
 771: oPop 3
 773: oGetLocal 1
 775: oPushResult
 776: oSetResult 8
 778: oPushResult
 779: oGetLocal 2
 781: oPushResult
 782: oNodeSet
 783: oPop 3
 785: oInput 5
 787: oInput 59
 789: oGetLocal 1
 791: oPushResult
 792: oCall 333
 794: oPop 1
 796: oInputChoice 807
 798: oGetLocal 1
 800: oPushResult
 801: oCall 306
 803: oPop 1
 805: oJumpForward 810
 807: Choice Lookup Table
          57    798
 810: oGetLocal 1
 812: oPushResult
 813: oCall 509
 815: oPop 1
 817: oSetResult 0
 819: oPushResult
 820: oSetResult 0
 822: oPushResult
 823: oScopeBegin
 824: oPop 2
 826: oGetLocal 1
 828: oPushResult
 829: oSetResult 9
 831: oPushResult
 832: oScopeCurrent
 833: oPushResult
 834: oNodeSet
 835: oPop 3
 837: oGetAddrGlobal 2
 839: oPushResult
 840: oScopeCurrent
 841: oAssign
 842: oSetResult 0
 844: oPushResult
 845: oSetResult 1
 847: oPushResult
 848: oScopeBegin
 849: oPop 2
 851: oGetAddrGlobal 3
 853: oPushResult
 854: oScopeCurrent
 855: oAssign
 856: oGetLocal 1
 858: oPushResult
 859: oSetResult 13
 861: oPushResult
 862: oGetGlobal 3
 864: oPushResult
 865: oNodeSet
 866: oPop 3
 868: oScopeEnd
 869: oGetLocal 1
 871: oPushResult
 872: oCall 1060
 874: oPop 1
 876: oScopeEnd
 877: oInput 60
 879: oGetLocal 2
 881: oPushResult
 882: oCall 333
 884: oPop 1
 886: oInputChoice 897
 888: oGetLocal 2
 890: oPushResult
 891: oCall 306
 893: oPop 1
 895: oJumpForward 900
 897: Choice Lookup Table
          57    888
 900: oGetLocal 2
 902: oPushResult
 903: oCall 509
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 9
 912: oPushResult
 913: oNodeGet
 914: oPop 2
 916: oPushResult
 917: oScopeEnter
 918: oPop 1
 920: oSetResult 0
 922: oPushResult
 923: oSetResult 0
 925: oPushResult
 926: oScopeBegin
 927: oPop 2
 929: oGetLocal 1
 931: oPushResult
 932: oSetResult 10
 934: oPushResult
 935: oScopeCurrent
 936: oPushResult
 937: oNodeSet
 938: oPop 3
 940: oScopeCurrent
 941: oPushResult
 942: oSetResult 16
 944: oPushResult
 945: oGetLocal 1
 947: oPushResult
 948: oSetResult 9
 950: oPushResult
 951: oNodeGet
 952: oPop 2
 954: oPushResult
 955: oNodeSet
 956: oPop 3
 958: oGetAddrGlobal 2
 960: oPushResult
 961: oScopeCurrent
 962: oAssign
 963: oGetLocal 1
 965: oPushResult
 966: oCall 1145
 968: oPop 1
 970: oInputChoice 984
 972: oGetLocal 1
 974: oPushResult
 975: oSetResult 1
 977: oPushResult
 978: oCall 1155
 980: oPop 2
 982: oJumpForward 997
 984: Choice Lookup Table
          61    972
 987: oGetLocal 1
 989: oPushResult
 990: oSetResult 0
 992: oPushResult
 993: oCall 1155
 995: oPop 2
 997: oInputChoice 1011
 999: oGetLocal 1
1001: oPushResult
1002: oSetResult 1
1004: oPushResult
1005: oCall 1341
1007: oPop 2
1009: oJumpForward 1024
1011: Choice Lookup Table
          62    999
1014: oGetLocal 1
1016: oPushResult
1017: oSetResult 0
1019: oPushResult
1020: oCall 1341
1022: oPop 2
1024: oInput 36
1026: oInput 20
1028: oScopeEnd
1029: oScopeEnd
1030: oGetLocal 2
1032: oPushResult
1033: oCall 571
1035: oPop 1
1037: oGetLocal 1
1039: oPushResult
1040: oCall 571
1042: oPop 1
1044: oGetGlobal 1
1046: oPushResult
1047: oSetResult 1
1049: oPushResult
1050: oGetLocal 1
1052: oPushResult
1053: oNodeAddLast
1054: oPop 3
1056: oGetLocal 1
1058: oReturn
1059: oReturn
1060: oLocalSpace 2
1062: oInputChoice 1129
1064: oCall 3053
1066: oJumpForward 1142
1068: oCall 3604
1070: oJumpForward 1142
1072: oSetResult 20
1074: oPushResult
1075: oCall 3660
1077: oPop 1
1079: oJumpForward 1142
1081: oGetAddrLocal 1
1083: oPushResult
1084: oCall 2020
1086: oAssign
1087: oInputChoice 1100
1089: oGetLocal 1
1091: oPushResult
1092: oCall 1958
1094: oPop 1
1096: oInput 5
1098: oJumpForward 1103
1100: Choice Lookup Table
          68   1089
1103: oJumpForward 1142
1105: oGetAddrLocal 2
1107: oPushResult
1108: oCall 2394
1110: oAssign
1111: oInputChoice 1124
1113: oGetLocal 2
1115: oPushResult
1116: oCall 1958
1118: oPop 1
1120: oInput 5
1122: oJumpForward 1127
1124: Choice Lookup Table
          68   1113
1127: oJumpForward 1142
1129: Choice Lookup Table
          30   1105
          29   1081
          33   1072
          32   1068
          31   1064
1140: oJumpForward 1144
1142: oJumpBack 1062
1144: oReturn
1145: oLocalSpace 0
1147: oSetResult 20
1149: oPushResult
1150: oCall 1459
1152: oPop 1
1154: oReturn
1155: oLocalSpace 5
1157: oGetAddrLocal 1
1159: oPushResult
1160: oLabelNew
1161: oAssign
1162: oEmit 58
1164: oGetLocal 1
1166: oPushResult
1167: oEmitLabel
1168: oPop 1
1170: oGetParam 2
1172: oPushResult
1173: oSetResult 11
1175: oPushResult
1176: oGetLocal 1
1178: oPushResult
1179: oNodeSetLabel
1180: oPop 3
1182: oEmit 54
1184: oGetAddrLocal 2
1186: oPushResult
1187: Here
1188: oAssign
1189: oEmit 68
1191: oGetAddrLocal 3
1193: oPushResult
1194: oGetParam 2
1196: oPushResult
1197: oSetResult 9
1199: oPushResult
1200: oNodeGet
1201: oPop 2
1203: oAssign
1204: oGetAddrLocal 4
1206: oPushResult
1207: oGetLocal 3
1209: oPushResult
1210: oSetResult 19
1212: oPushResult
1213: oNodeGetCode
1214: oPop 2
1216: oAssign
1217: oGetLocal 4
1219: oPushResult
1220: oEmitCode
1221: oPop 1
1223: oGetLocal 3
1225: oPushResult
1226: oSetResult 19
1228: oPushResult
1229: oSetResult 0
1231: oPushResult
1232: oNodeSetCode
1233: oPop 3
1235: oGetAddrLocal 3
1237: oPushResult
1238: oGetParam 2
1240: oPushResult
1241: oSetResult 10
1243: oPushResult
1244: oNodeGet
1245: oPop 2
1247: oAssign
1248: oGetAddrLocal 4
1250: oPushResult
1251: oGetLocal 3
1253: oPushResult
1254: oSetResult 19
1256: oPushResult
1257: oNodeGetCode
1258: oPop 2
1260: oAssign
1261: oGetLocal 4
1263: oPushResult
1264: oEmitCode
1265: oPop 1
1267: oGetLocal 3
1269: oPushResult
1270: oSetResult 19
1272: oPushResult
1273: oSetResult 0
1275: oPushResult
1276: oNodeSetCode
1277: oPop 3
1279: oGetParam 2
1281: oPushResult
1282: oSetResult 13
1284: oPushResult
1285: oNodeGet
1286: oPop 2
1288: oPushResult
1289: oScopeEnter
1290: oPop 1
1292: oGetParam 1
1294: oChoice 1313
1296: oCall 8585
1298: oInputChoice 1304
1300: oCall 8585
1302: oJumpForward 1309
1304: Choice Lookup Table
           5   1300
1307: oJumpForward 1311
1309: oJumpBack 1298
1311: oJumpForward 1316
1313: Choice Lookup Table
           1   1296
1316: oEmit 53
1318: oGetAddrLocal 5
1320: oPushResult
1321: oScopeCurrent
1322: oPushResult
1323: oSetResult 17
1325: oPushResult
1326: oNodeGetInt
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oGetLocal 5
1335: oPushResult
1336: oPatch
1337: oPop 2
1339: oScopeEnd
1340: oReturn
1341: oLocalSpace 3
1343: oGetAddrLocal 1
1345: oPushResult
1346: oLabelNew
1347: oAssign
1348: oEmit 58
1350: oGetLocal 1
1352: oPushResult
1353: oEmitLabel
1354: oPop 1
1356: oGetParam 2
1358: oPushResult
1359: oSetResult 12
1361: oPushResult
1362: oGetLocal 1
1364: oPushResult
1365: oNodeSetLabel
1366: oPop 3
1368: oEmit 54
1370: oGetAddrLocal 2
1372: oPushResult
1373: Here
1374: oAssign
1375: oEmit 68
1377: oSetResult 0
1379: oPushResult
1380: oSetResult 1
1382: oPushResult
1383: oScopeBegin
1384: oPop 2
1386: oGetParam 1
1388: oChoice 1407
1390: oCall 8585
1392: oInputChoice 1398
1394: oCall 8585
1396: oJumpForward 1403
1398: Choice Lookup Table
           5   1394
1401: oJumpForward 1405
1403: oJumpBack 1392
1405: oJumpForward 1410
1407: Choice Lookup Table
           1   1390
1410: oEmit 53
1412: oGetAddrLocal 3
1414: oPushResult
1415: oScopeCurrent
1416: oPushResult
1417: oSetResult 17
1419: oPushResult
1420: oNodeGetInt
1421: oPop 2
1423: oAssign
1424: oGetLocal 2
1426: oPushResult
1427: oGetLocal 3
1429: oPushResult
1430: oPatch
1431: oPop 2
1433: oScopeEnd
1434: oReturn
1435: oLocalSpace 0
1437: oGetParam 2
1439: oPushResult
1440: oCall 1459
1442: oPop 1
1444: oGetParam 1
1446: oPushResult
1447: oScopeCurrent
1448: oPushResult
1449: oSetResult 0
1451: oPushResult
1452: oCall 1780
1454: oPop 3
1456: oCall 1515
1458: oReturn
1459: oLocalSpace 0
1461: oInputChoice 1492
1463: oCall 3053
1465: oJumpForward 1507
1467: oCall 3604
1469: oJumpForward 1507
1471: oGetParam 1
1473: oPushResult
1474: oCall 3660
1476: oPop 1
1478: oJumpForward 1507
1480: oCall 3894
1482: oJumpForward 1507
1484: oCall 2276
1486: oJumpForward 1507
1488: oCall 2711
1490: oJumpForward 1507
1492: Choice Lookup Table
          30   1488
          29   1484
          34   1480
          33   1471
          32   1467
          31   1463
1505: oJumpForward 1509
1507: oJumpBack 1461
1509: oCall 1512
1511: oReturn
1512: oLocalSpace 0
1514: oReturn
1515: oLocalSpace 2
1517: oGetAddrLocal 1
1519: oPushResult
1520: oScopeCurrent
1521: oPushResult
1522: oSetResult 15
1524: oPushResult
1525: oNodeGetIter
1526: oPop 2
1528: oAssign
1529: oGetAddrLocal 2
1531: oPushResult
1532: oGetLocal 1
1534: oPushResult
1535: oNodeIterValue
1536: oPop 1
1538: oAssign
1539: oGetLocal 2
1541: oPushResult
1542: oNodeNull
1543: oPop 1
1545: oChoice 1549
1547: oJumpForward 1554
1549: Choice Lookup Table
           0   1547
1552: oJumpForward 1609
1554: oGetLocal 2
1556: oPushResult
1557: oNodeType
1558: oPop 1
1560: oChoice 1598
1562: oGetLocal 2
1564: oPushResult
1565: oSetResult 34
1567: oPushResult
1568: oNodeGetBoolean
1569: oPop 2
1571: oChoice 1593
1573: oGetLocal 2
1575: oPushResult
1576: oSetResult 28
1578: oPushResult
1579: oNodeGetBoolean
1580: oPop 2
1582: oChoice 1588
1584: oError 27
1586: oJumpForward 1591
1588: Choice Lookup Table
           1   1584
1591: oJumpForward 1596
1593: Choice Lookup Table
           0   1573
1596: oJumpForward 1601
1598: Choice Lookup Table
          25   1562
1601: oGetAddrLocal 1
1603: oPushResult
1604: oNodeIterNext
1605: oPop 1
1607: oJumpBack 1529
1609: oReturn
1610: oLocalSpace 2
1612: oGetAddrLocal 1
1614: oPushResult
1615: oGetGlobal 1
1617: oPushResult
1618: oSetResult 1
1620: oPushResult
1621: oNodeGetIter
1622: oPop 2
1624: oAssign
1625: oGetAddrLocal 2
1627: oPushResult
1628: oGetLocal 1
1630: oPushResult
1631: oNodeIterValue
1632: oPop 1
1634: oAssign
1635: oGetLocal 2
1637: oPushResult
1638: oNodeNull
1639: oPop 1
1641: oChoice 1686
1643: oJumpForward 1694
1645: oJumpForward 1692
1647: oEmit 48
1649: oSetResult 0
1651: oPushResult
1652: oEmitInt
1653: oPop 1
1655: oEmit 51
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 11
1662: oPushResult
1663: oNodeGetLabel
1664: oPop 2
1666: oPushResult
1667: oEmitLabel
1668: oPop 1
1670: oEmit 50
1672: oSetResult 0
1674: oPushResult
1675: oEmitInt
1676: oPop 1
1678: oGetAddrLocal 1
1680: oPushResult
1681: oNodeIterNext
1682: oPop 1
1684: oJumpForward 1692
1686: Choice Lookup Table
           0   1647
           1   1643
1691: oEndChoice
1692: oJumpBack 1625
1694: oReturn
1695: oLocalSpace 2
1697: oGetAddrLocal 1
1699: oPushResult
1700: oGetGlobal 1
1702: oPushResult
1703: oSetResult 1
1705: oPushResult
1706: oNodeGetIterLast
1707: oPop 2
1709: oAssign
1710: oGetAddrLocal 2
1712: oPushResult
1713: oGetLocal 1
1715: oPushResult
1716: oNodeIterValue
1717: oPop 1
1719: oAssign
1720: oGetLocal 2
1722: oPushResult
1723: oNodeNull
1724: oPop 1
1726: oChoice 1771
1728: oJumpForward 1779
1730: oJumpForward 1777
1732: oEmit 48
1734: oSetResult 0
1736: oPushResult
1737: oEmitInt
1738: oPop 1
1740: oEmit 51
1742: oGetLocal 2
1744: oPushResult
1745: oSetResult 12
1747: oPushResult
1748: oNodeGetLabel
1749: oPop 2
1751: oPushResult
1752: oEmitLabel
1753: oPop 1
1755: oEmit 50
1757: oSetResult 0
1759: oPushResult
1760: oEmitInt
1761: oPop 1
1763: oGetAddrLocal 1
1765: oPushResult
1766: oNodeIterPrev
1767: oPop 1
1769: oJumpForward 1777
1771: Choice Lookup Table
           0   1732
           1   1728
1776: oEndChoice
1777: oJumpBack 1710
1779: oReturn
1780: oLocalSpace 3
1782: oEmit 58
1784: oGetParam 3
1786: oPushResult
1787: oEmitLabel
1788: oPop 1
1790: oEmit 54
1792: oGetAddrLocal 1
1794: oPushResult
1795: Here
1796: oAssign
1797: oEmit 68
1799: oGetParam 1
1801: oChoice 1807
1803: oCall 1610
1805: oJumpForward 1810
1807: Choice Lookup Table
           1   1803
1810: oGetAddrLocal 2
1812: oPushResult
1813: oGetParam 2
1815: oPushResult
1816: oSetResult 19
1818: oPushResult
1819: oNodeGetCode
1820: oPop 2
1822: oAssign
1823: oGetLocal 2
1825: oPushResult
1826: oEmitCode
1827: oPop 1
1829: oGetParam 2
1831: oPushResult
1832: oSetResult 19
1834: oPushResult
1835: oSetResult 0
1837: oPushResult
1838: oNodeSetCode
1839: oPop 3
1841: oCall 8585
1843: oGetParam 1
1845: oChoice 1851
1847: oCall 1695
1849: oJumpForward 1854
1851: Choice Lookup Table
           1   1847
1854: oEmit 53
1856: oGetAddrLocal 3
1858: oPushResult
1859: oScopeCurrent
1860: oPushResult
1861: oSetResult 17
1863: oPushResult
1864: oNodeGetInt
1865: oPop 2
1867: oAssign
1868: oGetLocal 1
1870: oPushResult
1871: oGetLocal 3
1873: oPushResult
1874: oPatch
1875: oPop 2
1877: oReturn
1878: oLocalSpace 0
1880: oInputChoice 1898
1882: oGetParam 1
1884: oPushResult
1885: oSetResult 27
1887: oPushResult
1888: oSetResult 1
1890: oPushResult
1891: oNodeSetBoolean
1892: oPop 3
1894: oInput 5
1896: oJumpForward 1903
1898: Choice Lookup Table
          70   1882
1901: oJumpForward 1905
1903: oJumpBack 1880
1905: oReturn
1906: oLocalSpace 1
1908: oGetAddrLocal 1
1910: oPushResult
1911: oGetParam 1
1913: oPushResult
1914: oSetResult 19
1916: oPushResult
1917: oNodeGetCode
1918: oPop 2
1920: oAssign
1921: oGetLocal 1
1923: oPushResult
1924: oSetResult 0
1926: oPushResult
1927: equal_code
1928: oPop 2
1930: oChoice 1951
1932: oGetAddrLocal 1
1934: oPushResult
1935: oCodeNew
1936: oAssign
1937: oGetParam 1
1939: oPushResult
1940: oSetResult 19
1942: oPushResult
1943: oGetLocal 1
1945: oPushResult
1946: oNodeSetCode
1947: oPop 3
1949: oJumpForward 1954
1951: Choice Lookup Table
           1   1932
1954: oGetLocal 1
1956: oReturn
1957: oReturn
1958: oLocalSpace 0
1960: oGetParam 1
1962: oPushResult
1963: oCall 9873
1965: oPop 1
1967: oPushResult
1968: equal_zero
1969: oPop 1
1971: oChoice 1977
1973: oError 23
1975: oJumpForward 1980
1977: Choice Lookup Table
           0   1973
1980: oGetParam 1
1982: oPushResult
1983: oSetResult 25
1985: oPushResult
1986: oSetResult 1
1988: oPushResult
1989: oNodeSetBoolean
1990: oPop 3
1992: oInputChoice 2016
1994: oInputChoice 2011
1996: oInput 2
1998: oGetParam 1
2000: oPushResult
2001: oSetResult 26
2003: oPushResult
2004: CURRENT_STRLIT
2005: oPushResult
2006: oNodeSetString
2007: oPop 3
2009: oJumpForward 2014
2011: Choice Lookup Table
          69   1996
2014: oJumpForward 2019
2016: Choice Lookup Table
           2   1994
2019: oReturn
2020: oLocalSpace 6
2022: oInput 0
2024: oGetAddrLocal 1
2026: oPushResult
2027: oSetResult 0
2029: oAssign
2030: oGetAddrLocal 2
2032: oPushResult
2033: oScopeFindInCurrentScope
2034: oAssign
2035: oGetLocal 2
2037: oPushResult
2038: oNodeNull
2039: oPop 1
2041: oChoice 2159
2043: oGetAddrLocal 2
2045: oPushResult
2046: oSetResult 12
2048: oPushResult
2049: LAST_ID
2050: oPushResult
2051: oCall 10091
2053: oPop 2
2055: oAssign
2056: oGetLocal 2
2058: oPushResult
2059: oSetResult 22
2061: oPushResult
2062: oLabelNew
2063: oPushResult
2064: oNodeSetLabel
2065: oPop 3
2067: oJumpForward 2165
2069: oGetAddrLocal 1
2071: oPushResult
2072: oSetResult 1
2074: oAssign
2075: oGetLocal 2
2077: oPushResult
2078: oSetResult 24
2080: oPushResult
2081: oNodeGetBoolean
2082: oPop 2
2084: oChoice 2090
2086: oError 21
2088: oJumpForward 2093
2090: Choice Lookup Table
           1   2086
2093: oGetLocal 2
2095: oPushResult
2096: oSetResult 25
2098: oPushResult
2099: oNodeGetBoolean
2100: oPop 2
2102: oChoice 2108
2104: oError 21
2106: oJumpForward 2111
2108: Choice Lookup Table
           1   2104
2111: oGetLocal 2
2113: oPushResult
2114: oNodeType
2115: oPop 1
2117: oChoice 2121
2119: oJumpForward 2126
2121: Choice Lookup Table
          12   2119
2124: oError 21
2126: oGetLocal 2
2128: oPushResult
2129: oSetResult 29
2131: oPushResult
2132: oGetLocal 2
2134: oPushResult
2135: oSetResult 23
2137: oPushResult
2138: oNodeGet
2139: oPop 2
2141: oPushResult
2142: oNodeSet
2143: oPop 3
2145: oGetLocal 2
2147: oPushResult
2148: oSetResult 23
2150: oPushResult
2151: oSetResult 0
2153: oPushResult
2154: oNodeSet
2155: oPop 3
2157: oJumpForward 2165
2159: Choice Lookup Table
           0   2069
           1   2043
2164: oEndChoice
2165: oGetAddrLocal 3
2167: oPushResult
2168: oCall 9861
2170: oAssign
2171: oGetAddrLocal 4
2173: oPushResult
2174: oGetLocal 3
2176: oPushResult
2177: oSetResult 0
2179: oPushResult
2180: greater
2181: oPop 2
2183: oAssign
2184: oGetAddrLocal 3
2186: oPushResult
2187: inc
2188: oPop 1
2190: oGetLocal 3
2192: oPushResult
2193: oSetResult 2
2195: oPushResult
2196: oScopeBegin
2197: oPop 2
2199: oGetAddrLocal 5
2201: oPushResult
2202: oScopeCurrent
2203: oAssign
2204: oGetLocal 4
2206: oChoice 2225
2208: oGetAddrLocal 6
2210: oPushResult
2211: oGetGlobal 6
2213: oPushResult
2214: oCall 10119
2216: oPop 1
2218: oPushResult
2219: oScopeAllocType
2220: oPop 1
2222: oAssign
2223: oJumpForward 2228
2225: Choice Lookup Table
           1   2208
2228: oCall 2829
2230: oGetLocal 2
2232: oPushResult
2233: oSetResult 23
2235: oPushResult
2236: oGetLocal 5
2238: oPushResult
2239: oNodeSet
2240: oPop 3
2242: oScopeEnd
2243: oInput 5
2245: oGetLocal 1
2247: oChoice 2259
2249: oGetLocal 2
2251: oPushResult
2252: oScopeDeclare
2253: oPop 1
2255: oJumpForward 2265
2257: oJumpForward 2265
2259: Choice Lookup Table
           1   2257
           0   2249
2264: oEndChoice
2265: oGetLocal 2
2267: oPushResult
2268: oCall 1878
2270: oPop 1
2272: oGetLocal 2
2274: oReturn
2275: oReturn
2276: oLocalSpace 4
2278: oGetAddrLocal 1
2280: oPushResult
2281: oCall 2020
2283: oAssign
2284: oInputChoice 2297
2286: oJumpForward 2391
2288: oGetLocal 1
2290: oPushResult
2291: oCall 1958
2293: oPop 1
2295: oJumpForward 2391
2297: Choice Lookup Table
          68   2288
          67   2286
2302: oGetAddrLocal 2
2304: oPushResult
2305: oGetLocal 1
2307: oPushResult
2308: oSetResult 23
2310: oPushResult
2311: oNodeGet
2312: oPop 2
2314: oAssign
2315: oGetLocal 2
2317: oPushResult
2318: oScopeEnter
2319: oPop 1
2321: oGetAddrLocal 3
2323: oPushResult
2324: oGetLocal 2
2326: oPushResult
2327: oSetResult 14
2329: oPushResult
2330: oNodeGetInt
2331: oPop 2
2333: oAssign
2334: oGetLocal 3
2336: oPushResult
2337: oSetResult 1
2339: oPushResult
2340: oScopeBegin
2341: oPop 2
2343: oGetLocal 1
2345: oPushResult
2346: oSetResult 6
2348: oPushResult
2349: oScopeCurrent
2350: oPushResult
2351: oNodeSet
2352: oPop 3
2354: oGetAddrLocal 4
2356: oPushResult
2357: oGetLocal 1
2359: oPushResult
2360: oSetResult 22
2362: oPushResult
2363: oNodeGetLabel
2364: oPop 2
2366: oAssign
2367: oSetResult 21
2369: oPushResult
2370: oGetLocal 4
2372: oPushResult
2373: oCall 1435
2375: oPop 2
2377: oGetLocal 1
2379: oPushResult
2380: oSetResult 24
2382: oPushResult
2383: oSetResult 1
2385: oPushResult
2386: oNodeSetBoolean
2387: oPop 3
2389: oScopeEnd
2390: oScopeEnd
2391: oInput 5
2393: oReturn
2394: oLocalSpace 8
2396: oInput 0
2398: oGetAddrLocal 1
2400: oPushResult
2401: oSetResult 0
2403: oAssign
2404: oGetAddrLocal 2
2406: oPushResult
2407: oScopeFindInCurrentScope
2408: oAssign
2409: oGetLocal 2
2411: oPushResult
2412: oNodeNull
2413: oPop 1
2415: oChoice 2546
2417: oGetAddrLocal 2
2419: oPushResult
2420: oSetResult 13
2422: oPushResult
2423: LAST_ID
2424: oPushResult
2425: oCall 10091
2427: oPop 2
2429: oAssign
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 22
2435: oPushResult
2436: oLabelNew
2437: oPushResult
2438: oNodeSetLabel
2439: oPop 3
2441: oJumpForward 2552
2443: oGetAddrLocal 1
2445: oPushResult
2446: oSetResult 1
2448: oAssign
2449: oGetLocal 2
2451: oPushResult
2452: oSetResult 24
2454: oPushResult
2455: oNodeGetBoolean
2456: oPop 2
2458: oChoice 2464
2460: oError 21
2462: oJumpForward 2467
2464: Choice Lookup Table
           1   2460
2467: oGetLocal 2
2469: oPushResult
2470: oNodeType
2471: oPop 1
2473: oChoice 2477
2475: oJumpForward 2482
2477: Choice Lookup Table
          13   2475
2480: oError 21
2482: oGetLocal 2
2484: oPushResult
2485: oSetResult 29
2487: oPushResult
2488: oGetLocal 2
2490: oPushResult
2491: oSetResult 23
2493: oPushResult
2494: oNodeGet
2495: oPop 2
2497: oPushResult
2498: oNodeSet
2499: oPop 3
2501: oGetLocal 2
2503: oPushResult
2504: oSetResult 23
2506: oPushResult
2507: oSetResult 0
2509: oPushResult
2510: oNodeSet
2511: oPop 3
2513: oGetLocal 2
2515: oPushResult
2516: oSetResult 30
2518: oPushResult
2519: oGetLocal 2
2521: oPushResult
2522: oSetResult 21
2524: oPushResult
2525: oNodeGet
2526: oPop 2
2528: oPushResult
2529: oNodeSet
2530: oPop 3
2532: oGetLocal 2
2534: oPushResult
2535: oSetResult 21
2537: oPushResult
2538: oSetResult 0
2540: oPushResult
2541: oNodeSet
2542: oPop 3
2544: oJumpForward 2552
2546: Choice Lookup Table
           0   2443
           1   2417
2551: oEndChoice
2552: oGetAddrLocal 3
2554: oPushResult
2555: oCall 9861
2557: oAssign
2558: oGetAddrLocal 4
2560: oPushResult
2561: oGetLocal 3
2563: oPushResult
2564: oSetResult 0
2566: oPushResult
2567: greater
2568: oPop 2
2570: oAssign
2571: oGetAddrLocal 3
2573: oPushResult
2574: inc
2575: oPop 1
2577: oGetLocal 3
2579: oPushResult
2580: oSetResult 2
2582: oPushResult
2583: oScopeBegin
2584: oPop 2
2586: oGetAddrLocal 5
2588: oPushResult
2589: oScopeCurrent
2590: oAssign
2591: oGetLocal 4
2593: oChoice 2612
2595: oGetAddrLocal 6
2597: oPushResult
2598: oGetGlobal 6
2600: oPushResult
2601: oCall 10119
2603: oPop 1
2605: oPushResult
2606: oScopeAllocType
2607: oPop 1
2609: oAssign
2610: oJumpForward 2615
2612: Choice Lookup Table
           1   2595
2615: oCall 2829
2617: oGetLocal 2
2619: oPushResult
2620: oSetResult 23
2622: oPushResult
2623: oGetLocal 5
2625: oPushResult
2626: oNodeSet
2627: oPop 3
2629: oInput 12
2631: oGetAddrLocal 7
2633: oPushResult
2634: oCall 3959
2636: oPop 1
2638: oGetLocal 2
2640: oPushResult
2641: oSetResult 21
2643: oPushResult
2644: oGetLocal 7
2646: oPushResult
2647: oNodeSet
2648: oPop 3
2650: oGetAddrLocal 8
2652: oPushResult
2653: oGetLocal 7
2655: oPushResult
2656: oCall 10119
2658: oPop 1
2660: oAssign
2661: oGetLocal 2
2663: oPushResult
2664: oSetResult 31
2666: oPushResult
2667: oGetLocal 8
2669: oPushResult
2670: oScopeAllocType
2671: oPop 1
2673: oPushResult
2674: oNodeSetInt
2675: oPop 3
2677: oScopeEnd
2678: oInput 5
2680: oGetLocal 1
2682: oChoice 2694
2684: oGetLocal 2
2686: oPushResult
2687: oScopeDeclare
2688: oPop 1
2690: oJumpForward 2700
2692: oJumpForward 2700
2694: Choice Lookup Table
           1   2692
           0   2684
2699: oEndChoice
2700: oGetLocal 2
2702: oPushResult
2703: oCall 1878
2705: oPop 1
2707: oGetLocal 2
2709: oReturn
2710: oReturn
2711: oLocalSpace 4
2713: oGetAddrLocal 1
2715: oPushResult
2716: oCall 2394
2718: oAssign
2719: oInputChoice 2732
2721: oJumpForward 2826
2723: oGetLocal 1
2725: oPushResult
2726: oCall 1958
2728: oPop 1
2730: oJumpForward 2826
2732: Choice Lookup Table
          68   2723
          67   2721
2737: oGetAddrLocal 2
2739: oPushResult
2740: oGetLocal 1
2742: oPushResult
2743: oSetResult 23
2745: oPushResult
2746: oNodeGet
2747: oPop 2
2749: oAssign
2750: oGetLocal 2
2752: oPushResult
2753: oScopeEnter
2754: oPop 1
2756: oGetAddrLocal 3
2758: oPushResult
2759: oGetLocal 2
2761: oPushResult
2762: oSetResult 14
2764: oPushResult
2765: oNodeGetInt
2766: oPop 2
2768: oAssign
2769: oGetLocal 3
2771: oPushResult
2772: oSetResult 1
2774: oPushResult
2775: oScopeBegin
2776: oPop 2
2778: oGetLocal 1
2780: oPushResult
2781: oSetResult 6
2783: oPushResult
2784: oScopeCurrent
2785: oPushResult
2786: oNodeSet
2787: oPop 3
2789: oGetAddrLocal 4
2791: oPushResult
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oNodeGetLabel
2799: oPop 2
2801: oAssign
2802: oSetResult 21
2804: oPushResult
2805: oGetLocal 4
2807: oPushResult
2808: oCall 1435
2810: oPop 2
2812: oGetLocal 1
2814: oPushResult
2815: oSetResult 24
2817: oPushResult
2818: oSetResult 1
2820: oPushResult
2821: oNodeSetBoolean
2822: oPop 3
2824: oScopeEnd
2825: oScopeEnd
2826: oInput 5
2828: oReturn
2829: oLocalSpace 6
2831: oInputChoice 3049
2833: oGetAddrLocal 1
2835: oPushResult
2836: oNodeVecNew
2837: oAssign
2838: oGetAddrLocal 3
2840: oPushResult
2841: oSetResult 0
2843: oAssign
2844: oInputChoice 2854
2846: oGetAddrLocal 3
2848: oPushResult
2849: oSetResult 1
2851: oAssign
2852: oJumpForward 2857
2854: Choice Lookup Table
          33   2846
2857: oInput 0
2859: oGetAddrLocal 2
2861: oPushResult
2862: oSetResult 23
2864: oPushResult
2865: LAST_ID
2866: oPushResult
2867: oCall 10091
2869: oPop 2
2871: oAssign
2872: oGetLocal 2
2874: oPushResult
2875: oSetResult 33
2877: oPushResult
2878: oGetLocal 3
2880: oPushResult
2881: oNodeSetBoolean
2882: oPop 3
2884: oGetLocal 1
2886: oPushResult
2887: oGetLocal 2
2889: oPushResult
2890: oNodeVecAppend
2891: oPop 2
2893: oInputChoice 2901
2895: oJumpForward 2909
2897: oJumpForward 2907
2899: oJumpForward 2907
2901: Choice Lookup Table
          13   2899
          12   2895
2906: oEndChoice
2907: oJumpBack 2857
2909: oGetAddrLocal 4
2911: oPushResult
2912: oCall 3959
2914: oPop 1
2916: oGetLocal 3
2918: oChoice 2933
2920: oGetAddrLocal 5
2922: oPushResult
2923: oGetLocal 4
2925: oPushResult
2926: oCall 10119
2928: oPop 1
2930: oAssign
2931: oJumpForward 2942
2933: Choice Lookup Table
           1   2920
2936: oGetAddrLocal 5
2938: oPushResult
2939: oGetLocal 4
2941: oAssign
2942: oGetAddrLocal 6
2944: oPushResult
2945: oSetResult 0
2947: oAssign
2948: oGetLocal 6
2950: oPushResult
2951: oGetLocal 1
2953: oPushResult
2954: oNodeVecSize
2955: oPop 1
2957: oPushResult
2958: equal
2959: oPop 2
2961: oChoice 3018
2963: oGetAddrLocal 2
2965: oPushResult
2966: oGetLocal 1
2968: oPushResult
2969: oGetLocal 6
2971: oPushResult
2972: oNodeVecElement
2973: oPop 2
2975: oAssign
2976: oGetLocal 2
2978: oPushResult
2979: oSetResult 21
2981: oPushResult
2982: oGetLocal 4
2984: oPushResult
2985: oNodeSet
2986: oPop 3
2988: oGetLocal 2
2990: oPushResult
2991: oScopeDeclare
2992: oPop 1
2994: oGetLocal 2
2996: oPushResult
2997: oSetResult 22
2999: oPushResult
3000: oGetLocal 5
3002: oPushResult
3003: oScopeAllocType
3004: oPop 1
3006: oPushResult
3007: oNodeSetInt
3008: oPop 3
3010: oGetAddrLocal 6
3012: oPushResult
3013: inc
3014: oPop 1
3016: oJumpForward 3023
3018: Choice Lookup Table
           0   2963
3021: oJumpForward 3025
3023: oJumpBack 2948
3025: oGetLocal 1
3027: oPushResult
3028: oNodeVecDelete
3029: oPop 1
3031: oInputChoice 3039
3033: oJumpForward 3047
3035: oJumpForward 3045
3037: oJumpForward 3045
3039: Choice Lookup Table
           5   3037
          15   3033
3044: oEndChoice
3045: oJumpBack 2833
3047: oJumpForward 3052
3049: Choice Lookup Table
          14   2833
3052: oReturn
3053: oLocalSpace 0
3055: oInputChoice 3070
3057: oInputChoice 3063
3059: oCall 3136
3061: oJumpForward 3068
3063: Choice Lookup Table
          12   3059
3066: oCall 3078
3068: oJumpForward 3075
3070: Choice Lookup Table
           0   3057
3073: oJumpForward 3077
3075: oJumpBack 3055
3077: oReturn
3078: oLocalSpace 2
3080: oGetAddrLocal 1
3082: oPushResult
3083: oSetResult 16
3085: oPushResult
3086: LAST_ID
3087: oPushResult
3088: oCall 10091
3090: oPop 2
3092: oAssign
3093: oInput 6
3095: oCall 5015
3097: oGetAddrLocal 2
3099: oPushResult
3100: oValueTop
3101: oAssign
3102: oValuePop
3103: oGetLocal 1
3105: oPushResult
3106: oSetResult 22
3108: oPushResult
3109: oGetLocal 2
3111: oPushResult
3112: oNodeSetInt
3113: oPop 3
3115: oGetLocal 1
3117: oPushResult
3118: oSetResult 21
3120: oPushResult
3121: oGetGlobal 6
3123: oPushResult
3124: oNodeSet
3125: oPop 3
3127: oGetLocal 1
3129: oPushResult
3130: oScopeDeclare
3131: oPop 1
3133: oInput 5
3135: oReturn
3136: oLocalSpace 4
3138: oGetAddrLocal 1
3140: oPushResult
3141: oSetResult 24
3143: oPushResult
3144: LAST_ID
3145: oPushResult
3146: oCall 10091
3148: oPop 2
3150: oAssign
3151: oGetAddrLocal 2
3153: oPushResult
3154: oCall 3959
3156: oPop 1
3158: oGetLocal 1
3160: oPushResult
3161: oSetResult 21
3163: oPushResult
3164: oGetLocal 2
3166: oPushResult
3167: oNodeSet
3168: oPop 3
3170: oGetLocal 2
3172: oPushResult
3173: oNodeType
3174: oPop 1
3176: oChoice 3277
3178: oInput 6
3180: oCall 5015
3182: oGetAddrLocal 3
3184: oPushResult
3185: oValueTop
3186: oAssign
3187: oValuePop
3188: oGetLocal 1
3190: oPushResult
3191: oSetResult 22
3193: oPushResult
3194: oGetLocal 3
3196: oPushResult
3197: oNodeSetInt
3198: oPop 3
3200: oGetLocal 1
3202: oPushResult
3203: oScopeDeclare
3204: oPop 1
3206: oInput 5
3208: oJumpForward 3299
3210: oError 16
3212: oJumpForward 3299
3214: oGetGlobal 2
3216: oPushResult
3217: oScopeEnter
3218: oPop 1
3220: oGetAddrLocal 4
3222: oPushResult
3223: oGetLocal 2
3225: oPushResult
3226: oScopeAllocType
3227: oPop 1
3229: oAssign
3230: oScopeEnd
3231: oGetGlobal 2
3233: oPushResult
3234: oCall 1906
3236: oPop 1
3238: oPushResult
3239: oCodePush
3240: oPop 1
3242: oGetLocal 1
3244: oPushResult
3245: oSetResult 22
3247: oPushResult
3248: oGetLocal 4
3250: oPushResult
3251: oNodeSetInt
3252: oPop 3
3254: oInput 6
3256: oGetLocal 2
3258: oPushResult
3259: oGetLocal 4
3261: oPushResult
3262: oCall 3300
3264: oPop 2
3266: oCodePop
3267: oGetLocal 1
3269: oPushResult
3270: oScopeDeclare
3271: oPop 1
3273: oInput 5
3275: oJumpForward 3299
3277: Choice Lookup Table
          37   3214
          35   3214
          34   3210
          27   3210
          33   3210
          38   3178
          28   3178
          32   3178
          29   3178
          30   3178
3298: oEndChoice
3299: oReturn
3300: oLocalSpace 10
3302: oGetParam 2
3304: oPushResult
3305: oNodeType
3306: oPop 1
3308: oChoice 3581
3310: oGetAddrLocal 1
3312: oPushResult
3313: oGetParam 2
3315: oPushResult
3316: oSetResult 36
3318: oPushResult
3319: oNodeGet
3320: oPop 2
3322: oAssign
3323: oGetAddrLocal 2
3325: oPushResult
3326: oGetParam 2
3328: oPushResult
3329: oSetResult 37
3331: oPushResult
3332: oNodeGet
3333: oPop 2
3335: oAssign
3336: oGetAddrLocal 3
3338: oPushResult
3339: oGetLocal 2
3341: oPushResult
3342: oCall 10203
3344: oPop 1
3346: oAssign
3347: oGetAddrLocal 4
3349: oPushResult
3350: oGetLocal 2
3352: oPushResult
3353: oCall 10298
3355: oPop 1
3357: oAssign
3358: oGetAddrLocal 5
3360: oPushResult
3361: oGetLocal 1
3363: oPushResult
3364: oSetResult 17
3366: oPushResult
3367: oNodeGetInt
3368: oPop 2
3370: oAssign
3371: oInput 14
3373: oGetAddrLocal 6
3375: oPushResult
3376: oGetLocal 3
3378: oAssign
3379: oGetLocal 1
3381: oPushResult
3382: oGetParam 1
3384: oPushResult
3385: oCall 3300
3387: oPop 2
3389: oGetLocal 6
3391: oPushResult
3392: oGetLocal 4
3394: oPushResult
3395: equal
3396: oPop 2
3398: oChoice 3406
3400: oJumpForward 3435
3402: oJumpForward 3412
3404: oJumpForward 3412
3406: Choice Lookup Table
           0   3404
           1   3400
3411: oEndChoice
3412: oInput 13
3414: oGetAddrParam 1
3416: oPushResult
3417: oGetParam 1
3419: oPushResult
3420: oGetLocal 5
3422: oPushResult
3423: add
3424: oPop 2
3426: oAssign
3427: oGetAddrLocal 6
3429: oPushResult
3430: inc
3431: oPop 1
3433: oJumpBack 3379
3435: oInput 15
3437: oJumpForward 3603
3439: oInput 14
3441: oGetAddrLocal 7
3443: oPushResult
3444: oGetParam 2
3446: oPushResult
3447: oSetResult 40
3449: oPushResult
3450: oNodeGet
3451: oPop 2
3453: oAssign
3454: oInputChoice 3458
3456: oJumpForward 3463
3458: Choice Lookup Table
           0   3456
3461: oJumpForward 3529
3463: oGetAddrLocal 8
3465: oPushResult
3466: oGetLocal 7
3468: oPushResult
3469: oScopeFindRequireInScope
3470: oPop 1
3472: oAssign
3473: oInput 12
3475: oGetAddrLocal 9
3477: oPushResult
3478: oGetLocal 8
3480: oPushResult
3481: oSetResult 21
3483: oPushResult
3484: oNodeGet
3485: oPop 2
3487: oAssign
3488: oGetAddrLocal 10
3490: oPushResult
3491: oGetParam 1
3493: oPushResult
3494: oGetLocal 8
3496: oPushResult
3497: oSetResult 22
3499: oPushResult
3500: oNodeGetInt
3501: oPop 2
3503: oPushResult
3504: add
3505: oPop 2
3507: oAssign
3508: oGetLocal 9
3510: oPushResult
3511: oGetLocal 10
3513: oPushResult
3514: oCall 3300
3516: oPop 2
3518: oInputChoice 3522
3520: oJumpForward 3527
3522: Choice Lookup Table
           5   3520
3525: oJumpForward 3529
3527: oJumpBack 3454
3529: oInput 15
3531: oJumpForward 3603
3533: oEmit 16
3535: oGetParam 1
3537: oPushResult
3538: oEmitInt
3539: oPop 1
3541: oCall 5015
3543: oEmit 15
3545: oValueTop
3546: oPushResult
3547: oEmitInt
3548: oPop 1
3550: oValuePop
3551: oEmit 26
3553: oJumpForward 3603
3555: oEmit 16
3557: oGetParam 1
3559: oPushResult
3560: oEmitInt
3561: oPop 1
3563: oCall 5015
3565: oEmit 15
3567: oValueTop
3568: oPushResult
3569: oEmitInt
3570: oPop 1
3572: oValuePop
3573: oEmit 25
3575: oJumpForward 3603
3577: oError 16
3579: oJumpForward 3603
3581: Choice Lookup Table
          34   3577
          27   3577
          33   3577
          38   3555
          28   3555
          32   3533
          29   3533
          30   3533
          37   3439
          35   3310
3602: oEndChoice
3603: oReturn
3604: oLocalSpace 2
3606: oInputChoice 3652
3608: oGetAddrLocal 1
3610: oPushResult
3611: oSetResult 18
3613: oPushResult
3614: LAST_ID
3615: oPushResult
3616: oCall 10091
3618: oPop 2
3620: oAssign
3621: oInput 6
3623: oGetAddrLocal 2
3625: oPushResult
3626: oCall 3959
3628: oPop 1
3630: oGetLocal 1
3632: oPushResult
3633: oSetResult 21
3635: oPushResult
3636: oGetLocal 2
3638: oPushResult
3639: oNodeSet
3640: oPop 3
3642: oGetLocal 1
3644: oPushResult
3645: oScopeDeclare
3646: oPop 1
3648: oInput 5
3650: oJumpForward 3657
3652: Choice Lookup Table
           0   3608
3655: oJumpForward 3659
3657: oJumpBack 3606
3659: oReturn
3660: oLocalSpace 6
3662: oInputChoice 3886
3664: oGetAddrLocal 1
3666: oPushResult
3667: oNodeVecNew
3668: oAssign
3669: oGetAddrLocal 2
3671: oPushResult
3672: oGetParam 1
3674: oPushResult
3675: LAST_ID
3676: oPushResult
3677: oCall 10091
3679: oPop 2
3681: oAssign
3682: oGetLocal 1
3684: oPushResult
3685: oGetLocal 2
3687: oPushResult
3688: oNodeVecAppend
3689: oPop 2
3691: oInputChoice 3697
3693: oInput 0
3695: oJumpForward 3702
3697: Choice Lookup Table
          13   3693
3700: oJumpForward 3704
3702: oJumpBack 3669
3704: oInput 12
3706: oGetAddrLocal 3
3708: oPushResult
3709: oCall 3959
3711: oPop 1
3713: oGetAddrLocal 4
3715: oPushResult
3716: oSetResult 0
3718: oAssign
3719: oGetLocal 4
3721: oPushResult
3722: oGetLocal 1
3724: oPushResult
3725: oNodeVecSize
3726: oPop 1
3728: oPushResult
3729: equal
3730: oPop 2
3732: oChoice 3773
3734: oGetAddrLocal 2
3736: oPushResult
3737: oGetLocal 1
3739: oPushResult
3740: oGetLocal 4
3742: oPushResult
3743: oNodeVecElement
3744: oPop 2
3746: oAssign
3747: oGetLocal 2
3749: oPushResult
3750: oSetResult 21
3752: oPushResult
3753: oGetLocal 3
3755: oPushResult
3756: oNodeSet
3757: oPop 3
3759: oGetLocal 2
3761: oPushResult
3762: oScopeDeclareAlloc
3763: oPop 1
3765: oGetAddrLocal 4
3767: oPushResult
3768: inc
3769: oPop 1
3771: oJumpForward 3778
3773: Choice Lookup Table
           0   3734
3776: oJumpForward 3780
3778: oJumpBack 3719
3780: oInputChoice 3873
3782: oGetLocal 1
3784: oPushResult
3785: oNodeVecSize
3786: oPop 1
3788: oChoice 3792
3790: oJumpForward 3797
3792: Choice Lookup Table
           1   3790
3795: oError 22
3797: oGetAddrLocal 5
3799: oPushResult
3800: oScopeCurrent
3801: oPushResult
3802: oCall 1906
3804: oPop 1
3806: oAssign
3807: oGetLocal 5
3809: oPushResult
3810: oCodePush
3811: oPop 1
3813: oGetAddrLocal 6
3815: oPushResult
3816: oSetResult 0
3818: oAssign
3819: oCall 9861
3821: oPushResult
3822: equal_zero
3823: oPop 1
3825: oChoice 3841
3827: oGetGlobal 3
3829: oPushResult
3830: oScopeEnter
3831: oPop 1
3833: oGetAddrLocal 6
3835: oPushResult
3836: oSetResult 1
3838: oAssign
3839: oJumpForward 3844
3841: Choice Lookup Table
           1   3827
3844: oGetLocal 2
3846: oPushResult
3847: oSetResult 1
3849: oPushResult
3850: oCall 9063
3852: oPop 2
3854: oCall 5088
3856: oCall 9911
3858: oCall 8823
3860: oGetLocal 6
3862: oChoice 3867
3864: oScopeEnd
3865: oJumpForward 3870
3867: Choice Lookup Table
           1   3864
3870: oCodePop
3871: oJumpForward 3876
3873: Choice Lookup Table
           6   3782
3876: oGetLocal 1
3878: oPushResult
3879: oNodeVecDelete
3880: oPop 1
3882: oInput 5
3884: oJumpForward 3891
3886: Choice Lookup Table
           0   3664
3889: oJumpForward 3893
3891: oJumpBack 3662
3893: oReturn
3894: oLocalSpace 2
3896: oInputChoice 3903
3898: oJumpForward 3909
3900: oChangeIntLitToLabelIdent
3901: oJumpForward 3909
3903: Choice Lookup Table
           1   3900
           0   3898
3908: oEndChoice
3909: oGetAddrLocal 1
3911: oPushResult
3912: oSetResult 25
3914: oPushResult
3915: LAST_ID
3916: oPushResult
3917: oCall 10091
3919: oPop 2
3921: oAssign
3922: oGetAddrLocal 2
3924: oPushResult
3925: oLabelNew
3926: oAssign
3927: oGetLocal 1
3929: oPushResult
3930: oSetResult 22
3932: oPushResult
3933: oGetLocal 2
3935: oPushResult
3936: oNodeSetLabel
3937: oPop 3
3939: oGetLocal 1
3941: oPushResult
3942: oScopeDeclare
3943: oPop 1
3945: oInputChoice 3949
3947: oJumpForward 3954
3949: Choice Lookup Table
          13   3947
3952: oJumpForward 3956
3954: oJumpBack 3896
3956: oInput 5
3958: oReturn
3959: oLocalSpace 12
3961: oInputChoice 4434
3963: oGetAddrLocal 1
3965: oPushResult
3966: oScopeFindRequire
3967: oAssign
3968: oGetAddrLocal 1
3970: oPushResult
3971: oCall 466
3973: oPop 1
3975: oGetLocal 1
3977: oPushResult
3978: oNodeType
3979: oPop 1
3981: oChoice 3998
3983: oGetParam 1
3985: oPushResult
3986: oGetLocal 1
3988: oPushResult
3989: oSetResult 21
3991: oPushResult
3992: oNodeGet
3993: oPop 2
3995: oAssign
3996: oJumpForward 4009
3998: Choice Lookup Table
          18   3983
4001: oError 2
4003: oGetParam 1
4005: oPushResult
4006: oGetGlobal 6
4008: oAssign
4009: oJumpForward 4453
4011: oInput 16
4013: oGetAddrLocal 2
4015: oPushResult
4016: oNodeVecNew
4017: oAssign
4018: oGetAddrLocal 3
4020: oPushResult
4021: oSetResult 36
4023: oPushResult
4024: oNodeNew
4025: oPop 1
4027: oAssign
4028: oGetLocal 3
4030: oPushResult
4031: oSetResult 36
4033: oPushResult
4034: oGetGlobal 6
4036: oPushResult
4037: oNodeSet
4038: oPop 3
4040: oCall 5015
4042: oGetLocal 3
4044: oPushResult
4045: oSetResult 38
4047: oPushResult
4048: oValueTop
4049: oPushResult
4050: oNodeSetInt
4051: oPop 3
4053: oValuePop
4054: oInput 21
4056: oCall 5015
4058: oGetLocal 3
4060: oPushResult
4061: oSetResult 39
4063: oPushResult
4064: oValueTop
4065: oPushResult
4066: oNodeSetInt
4067: oPop 3
4069: oValuePop
4070: oGetLocal 3
4072: oPushResult
4073: oSetResult 17
4075: oPushResult
4076: oSetResult 4
4078: oPushResult
4079: oNodeSetInt
4080: oPop 3
4082: oGetLocal 3
4084: oPushResult
4085: oTypeAdd
4086: oPop 1
4088: oGetAddrLocal 4
4090: oPushResult
4091: oSetResult 35
4093: oPushResult
4094: oNodeNew
4095: oPop 1
4097: oAssign
4098: oGetLocal 4
4100: oPushResult
4101: oSetResult 37
4103: oPushResult
4104: oGetLocal 3
4106: oPushResult
4107: oNodeSet
4108: oPop 3
4110: oGetLocal 2
4112: oPushResult
4113: oGetLocal 4
4115: oPushResult
4116: oNodeVecAppend
4117: oPop 2
4119: oInputChoice 4127
4121: oJumpForward 4135
4123: oJumpForward 4133
4125: oJumpForward 4133
4127: Choice Lookup Table
          13   4125
          17   4121
4132: oEndChoice
4133: oJumpBack 4018
4135: oInput 40
4137: oGetAddrLocal 5
4139: oPushResult
4140: oCall 3959
4142: oPop 1
4144: oGetAddrLocal 6
4146: oPushResult
4147: oGetLocal 2
4149: oPushResult
4150: oNodeVecSize
4151: oPop 1
4153: oAssign
4154: oGetAddrLocal 6
4156: oPushResult
4157: dec
4158: oPop 1
4160: oGetAddrLocal 7
4162: oPushResult
4163: oGetLocal 2
4165: oPushResult
4166: oGetLocal 6
4168: oPushResult
4169: oNodeVecElement
4170: oPop 2
4172: oAssign
4173: oGetLocal 7
4175: oPushResult
4176: oSetResult 36
4178: oPushResult
4179: oGetLocal 5
4181: oPushResult
4182: oNodeSet
4183: oPop 3
4185: oGetAddrLocal 8
4187: oPushResult
4188: oGetLocal 7
4190: oPushResult
4191: oSetResult 37
4193: oPushResult
4194: oNodeGet
4195: oPop 2
4197: oAssign
4198: oGetAddrLocal 9
4200: oPushResult
4201: oGetLocal 8
4203: oPushResult
4204: oSetResult 39
4206: oPushResult
4207: oNodeGetInt
4208: oPop 2
4210: oPushResult
4211: oGetLocal 8
4213: oPushResult
4214: oSetResult 38
4216: oPushResult
4217: oNodeGetInt
4218: oPop 2
4220: oPushResult
4221: subtract
4222: oPop 2
4224: oAssign
4225: oGetAddrLocal 9
4227: oPushResult
4228: inc
4229: oPop 1
4231: oGetLocal 7
4233: oPushResult
4234: oSetResult 17
4236: oPushResult
4237: oGetLocal 9
4239: oPushResult
4240: oGetLocal 5
4242: oPushResult
4243: oSetResult 17
4245: oPushResult
4246: oNodeGetInt
4247: oPop 2
4249: oPushResult
4250: multiply
4251: oPop 2
4253: oPushResult
4254: oNodeSetInt
4255: oPop 3
4257: oGetLocal 7
4259: oPushResult
4260: oTypeAdd
4261: oPop 1
4263: oGetAddrLocal 5
4265: oPushResult
4266: oGetLocal 7
4268: oAssign
4269: oGetLocal 6
4271: oPushResult
4272: equal_zero
4273: oPop 1
4275: oChoice 4281
4277: oJumpForward 4286
4279: oJumpForward 4284
4281: Choice Lookup Table
           1   4277
4284: oJumpBack 4154
4286: oGetParam 1
4288: oPushResult
4289: oGetLocal 2
4291: oPushResult
4292: oSetResult 0
4294: oPushResult
4295: oNodeVecElement
4296: oPop 2
4298: oAssign
4299: oGetLocal 2
4301: oPushResult
4302: oNodeVecDelete
4303: oPop 1
4305: oJumpForward 4453
4307: oGetAddrLocal 10
4309: oPushResult
4310: oCall 3959
4312: oPop 1
4314: oGetParam 1
4316: oPushResult
4317: oGetLocal 10
4319: oPushResult
4320: oCall 10119
4322: oPop 1
4324: oAssign
4325: oJumpForward 4453
4327: oGetParam 1
4329: oPushResult
4330: oSetResult 37
4332: oPushResult
4333: oNodeNew
4334: oPop 1
4336: oAssign
4337: oSetResult -1
4339: oPushResult
4340: oSetResult 2
4342: oPushResult
4343: oScopeBegin
4344: oPop 2
4346: oSetResult 22
4348: oPushResult
4349: oCall 3660
4351: oPop 1
4353: oGetAddrLocal 11
4355: oPushResult
4356: oScopeCurrent
4357: oPushResult
4358: oSetResult 17
4360: oPushResult
4361: oNodeGetInt
4362: oPop 2
4364: oAssign
4365: oGetLocal 11
4367: oPushResult
4368: equal_zero
4369: oPop 1
4371: oChoice 4377
4373: oError 19
4375: oJumpForward 4380
4377: Choice Lookup Table
           1   4373
4380: oInput 36
4382: oGetFromParam 1
4384: oPushResult
4385: oSetResult 40
4387: oPushResult
4388: oScopeCurrent
4389: oPushResult
4390: oNodeSet
4391: oPop 3
4393: oGetFromParam 1
4395: oPushResult
4396: oSetResult 17
4398: oPushResult
4399: oGetLocal 11
4401: oPushResult
4402: oNodeSetInt
4403: oPop 3
4405: oScopeEnd
4406: oGetFromParam 1
4408: oPushResult
4409: oTypeAdd
4410: oPop 1
4412: oJumpForward 4453
4414: oGetParam 1
4416: oPushResult
4417: oCall 4454
4419: oPop 1
4421: oJumpForward 4453
4423: oInput 40
4425: oGetAddrLocal 12
4427: oPushResult
4428: oCall 3959
4430: oPop 1
4432: oJumpForward 4453
4434: Choice Lookup Table
          39   4423
          14   4414
          38   4327
          18   4307
          37   4011
           0   3963
4447: oCall 5015
4449: oInput 21
4451: oCall 5015
4453: oReturn
4454: oLocalSpace 11
4456: oGetParam 1
4458: oPushResult
4459: oSetResult 38
4461: oPushResult
4462: oNodeNew
4463: oPop 1
4465: oAssign
4466: oGetAddrLocal 1
4468: oPushResult
4469: oSetResult 0
4471: oAssign
4472: oGetAddrLocal 2
4474: oPushResult
4475: oSetResult 0
4477: oAssign
4478: oGetAddrLocal 3
4480: oPushResult
4481: oSetResult 1
4483: oAssign
4484: oGetAddrLocal 4
4486: oPushResult
4487: oScopeCurrent
4488: oAssign
4489: oSetResult -1
4491: oPushResult
4492: oSetResult 2
4494: oPushResult
4495: oScopeBegin
4496: oPop 2
4498: oInput 0
4500: oGetAddrLocal 5
4502: oPushResult
4503: oSetResult 17
4505: oPushResult
4506: LAST_ID
4507: oPushResult
4508: oCall 10091
4510: oPop 2
4512: oAssign
4513: oGetAddrLocal 6
4515: oPushResult
4516: oSetResult 17
4518: oPushResult
4519: LAST_ID
4520: oPushResult
4521: oCall 10091
4523: oPop 2
4525: oAssign
4526: oGetLocal 5
4528: oPushResult
4529: oSetResult 21
4531: oPushResult
4532: oGetFromParam 1
4534: oPushResult
4535: oNodeSet
4536: oPop 3
4538: oGetLocal 6
4540: oPushResult
4541: oSetResult 21
4543: oPushResult
4544: oGetFromParam 1
4546: oPushResult
4547: oNodeSet
4548: oPop 3
4550: oGetAddrLocal 7
4552: oPushResult
4553: LAST_ID
4554: oPushResult
4555: ID_STRING
4556: oPop 1
4558: oPushResult
4559: oStringAllocLit
4560: oPop 1
4562: oAssign
4563: oGetLocal 5
4565: oPushResult
4566: oSetResult 32
4568: oPushResult
4569: oGetLocal 7
4571: oPushResult
4572: oNodeSetInt
4573: oPop 3
4575: oGetLocal 6
4577: oPushResult
4578: oSetResult 32
4580: oPushResult
4581: oGetLocal 7
4583: oPushResult
4584: oNodeSetInt
4585: oPop 3
4587: oInputChoice 4656
4589: oCall 5015
4591: oGetLocal 2
4593: oPushResult
4594: equal_zero
4595: oPop 1
4597: oChoice 4618
4599: oValueTop
4600: oPushResult
4601: oGetLocal 1
4603: oPushResult
4604: greater
4605: oPop 2
4607: oChoice 4613
4609: oError 26
4611: oJumpForward 4616
4613: Choice Lookup Table
           0   4609
4616: oJumpForward 4621
4618: Choice Lookup Table
           0   4599
4621: oGetLocal 1
4623: oPushResult
4624: oValueTop
4625: oPushResult
4626: equal
4627: oPop 2
4629: oChoice 4645
4631: oGetFromParam 1
4633: oPushResult
4634: oSetResult 42
4636: oPushResult
4637: oSetResult 1
4639: oPushResult
4640: oNodeSetBoolean
4641: oPop 3
4643: oJumpForward 4648
4645: Choice Lookup Table
           0   4631
4648: oGetAddrLocal 1
4650: oPushResult
4651: oValueTop
4652: oAssign
4653: oValuePop
4654: oJumpForward 4661
4656: Choice Lookup Table
           4   4589
           6   4589
4661: oGetLocal 5
4663: oPushResult
4664: oSetResult 22
4666: oPushResult
4667: oGetLocal 1
4669: oPushResult
4670: oNodeSetInt
4671: oPop 3
4673: oGetLocal 6
4675: oPushResult
4676: oSetResult 22
4678: oPushResult
4679: oGetLocal 1
4681: oPushResult
4682: oNodeSetInt
4683: oPop 3
4685: oGetLocal 5
4687: oPushResult
4688: oScopeDeclare
4689: oPop 1
4691: oGetLocal 4
4693: oPushResult
4694: oScopeEnter
4695: oPop 1
4697: oGetLocal 6
4699: oPushResult
4700: oScopeDeclare
4701: oPop 1
4703: oScopeEnd
4704: oGetAddrLocal 1
4706: oPushResult
4707: inc
4708: oPop 1
4710: oGetAddrLocal 2
4712: oPushResult
4713: inc
4714: oPop 1
4716: oInputChoice 4720
4718: oJumpForward 4725
4720: Choice Lookup Table
          13   4718
4723: oJumpForward 4727
4725: oJumpBack 4498
4727: oInput 15
4729: oGetFromParam 1
4731: oPushResult
4732: oSetResult 40
4734: oPushResult
4735: oScopeCurrent
4736: oPushResult
4737: oNodeSet
4738: oPop 3
4740: oGetFromParam 1
4742: oPushResult
4743: oSetResult 17
4745: oPushResult
4746: oSetResult 4
4748: oPushResult
4749: oNodeSetInt
4750: oPop 3
4752: oScopeEnd
4753: oGetGlobal 2
4755: oPushResult
4756: oCall 1906
4758: oPop 1
4760: oPushResult
4761: oCodePush
4762: oPop 1
4764: oGetGlobal 2
4766: oPushResult
4767: oScopeEnter
4768: oPop 1
4770: oGetAddrLocal 8
4772: oPushResult
4773: oGetLocal 2
4775: oPushResult
4776: oSetResult 1
4778: oPushResult
4779: add
4780: oPop 2
4782: oPushResult
4783: oSetResult 16
4785: oPushResult
4786: multiply
4787: oPop 2
4789: oAssign
4790: oGetAddrLocal 9
4792: oPushResult
4793: oGetLocal 8
4795: oPushResult
4796: oSetResult 8
4798: oPushResult
4799: oScopeAlloc
4800: oPop 2
4802: oAssign
4803: oScopeEnd
4804: oGetFromParam 1
4806: oPushResult
4807: oSetResult 41
4809: oPushResult
4810: oGetLocal 9
4812: oPushResult
4813: oNodeSetInt
4814: oPop 3
4816: oGetAddrLocal 10
4818: oPushResult
4819: oGetFromParam 1
4821: oPushResult
4822: oSetResult 40
4824: oPushResult
4825: oNodeGet
4826: oPop 2
4828: oPushResult
4829: oSetResult 15
4831: oPushResult
4832: oNodeGetIter
4833: oPop 2
4835: oAssign
4836: oGetAddrLocal 11
4838: oPushResult
4839: oGetLocal 10
4841: oPushResult
4842: oNodeIterValue
4843: oPop 1
4845: oAssign
4846: oGetLocal 11
4848: oPushResult
4849: oNodeNull
4850: oPop 1
4852: oChoice 4858
4854: oJumpForward 4945
4856: oJumpForward 4861
4858: Choice Lookup Table
           1   4854
4861: oEmit 16
4863: oGetLocal 9
4865: oPushResult
4866: oEmitInt
4867: oPop 1
4869: oEmit 15
4871: oGetLocal 11
4873: oPushResult
4874: oSetResult 22
4876: oPushResult
4877: oNodeGetInt
4878: oPop 2
4880: oPushResult
4881: oEmitInt
4882: oPop 1
4884: oEmit 25
4886: oGetAddrLocal 9
4888: oPushResult
4889: oGetLocal 9
4891: oPushResult
4892: oSetResult 8
4894: oPushResult
4895: add
4896: oPop 2
4898: oAssign
4899: oEmit 16
4901: oGetLocal 9
4903: oPushResult
4904: oEmitInt
4905: oPop 1
4907: oEmit 16
4909: oGetLocal 11
4911: oPushResult
4912: oSetResult 32
4914: oPushResult
4915: oNodeGetInt
4916: oPop 2
4918: oPushResult
4919: oEmitInt
4920: oPop 1
4922: oEmit 27
4924: oGetAddrLocal 9
4926: oPushResult
4927: oGetLocal 9
4929: oPushResult
4930: oSetResult 8
4932: oPushResult
4933: add
4934: oPop 2
4936: oAssign
4937: oGetAddrLocal 10
4939: oPushResult
4940: oNodeIterNext
4941: oPop 1
4943: oJumpBack 4836
4945: oEmit 16
4947: oGetLocal 9
4949: oPushResult
4950: oEmitInt
4951: oPop 1
4953: oEmit 15
4955: oSetResult 0
4957: oPushResult
4958: oEmitInt
4959: oPop 1
4961: oEmit 25
4963: oGetAddrLocal 9
4965: oPushResult
4966: oGetLocal 9
4968: oPushResult
4969: oSetResult 8
4971: oPushResult
4972: add
4973: oPop 2
4975: oAssign
4976: oEmit 16
4978: oGetLocal 9
4980: oPushResult
4981: oEmitInt
4982: oPop 1
4984: oEmit 15
4986: oSetResult 0
4988: oPushResult
4989: oEmitInt
4990: oPop 1
4992: oEmit 27
4994: oGetAddrLocal 9
4996: oPushResult
4997: oGetLocal 9
4999: oPushResult
5000: oSetResult 8
5002: oPushResult
5003: add
5004: oPop 2
5006: oAssign
5007: oCodePop
5008: oGetFromParam 1
5010: oPushResult
5011: oTypeAdd
5012: oPop 1
5014: oReturn
5015: oLocalSpace 1
5017: oInputChoice 5079
5019: TOKEN_VALUE
5020: oPushResult
5021: oValuePush
5022: oPop 1
5024: oJumpForward 5087
5026: oGetAddrLocal 1
5028: oPushResult
5029: oScopeFindRequire
5030: oAssign
5031: oGetAddrLocal 1
5033: oPushResult
5034: oCall 466
5036: oPop 1
5038: oGetLocal 1
5040: oPushResult
5041: oNodeType
5042: oPop 1
5044: oChoice 5061
5046: oGetLocal 1
5048: oPushResult
5049: oSetResult 22
5051: oPushResult
5052: oNodeGetInt
5053: oPop 2
5055: oPushResult
5056: oValuePush
5057: oPop 1
5059: oJumpForward 5072
5061: Choice Lookup Table
          16   5046
5064: oError 1
5066: oSetResult 0
5068: oPushResult
5069: oValuePush
5070: oPop 1
5072: oJumpForward 5087
5074: oCall 5015
5076: oValueNegate
5077: oJumpForward 5087
5079: Choice Lookup Table
          25   5074
           0   5026
           1   5019
5086: oEndChoice
5087: oReturn
5088: oLocalSpace 1
5090: oGetAddrLocal 1
5092: oPushResult
5093: oSetResult 0
5095: oAssign
5096: oGetAddrLocal 1
5098: oPushResult
5099: oCall 5249
5101: oPop 1
5103: oGetAddrLocal 1
5105: oPushResult
5106: oCall 5149
5108: oPop 1
5110: oReturn
5111: oLocalSpace 0
5113: oGetParam 1
5115: oPushResult
5116: oCall 5249
5118: oPop 1
5120: oTypeSNodeType
5121: oChoice 5140
5123: oJumpForward 5147
5125: oGetParam 1
5127: oPushResult
5128: oLabelNew
5129: oAssign
5130: oEmit 57
5132: oGetFromParam 1
5134: oPushResult
5135: oEmitLabel
5136: oPop 1
5138: oJumpForward 5147
5140: Choice Lookup Table
          30   5125
          31   5123
5145: oError 8
5147: oTypeSPop
5148: oReturn
5149: oLocalSpace 1
5151: oTypeSNodeType
5152: oChoice 5214
5154: oGetAddrLocal 1
5156: oPushResult
5157: oLabelNew
5158: oAssign
5159: oEmit 15
5161: oSetResult 1
5163: oPushResult
5164: oEmitInt
5165: oPop 1
5167: oEmit 55
5169: oGetLocal 1
5171: oPushResult
5172: oEmitLabel
5173: oPop 1
5175: oEmit 58
5177: oGetFromParam 1
5179: oPushResult
5180: oEmitLabel
5181: oPop 1
5183: oEmit 15
5185: oSetResult 0
5187: oPushResult
5188: oEmitInt
5189: oPop 1
5191: oEmit 58
5193: oGetLocal 1
5195: oPushResult
5196: oEmitLabel
5197: oPop 1
5199: oTypeSPop
5200: oGetGlobal 7
5202: oPushResult
5203: oTypeSPush
5204: oPop 1
5206: oGetParam 1
5208: oPushResult
5209: oSetResult 0
5211: oAssign
5212: oJumpForward 5217
5214: Choice Lookup Table
          31   5154
5217: oReturn
5218: oLocalSpace 0
5220: oTypeSNodeType
5221: oChoice 5245
5223: oGetParam 1
5225: oPushResult
5226: oLabelNew
5227: oAssign
5228: oEmit 57
5230: oGetFromParam 1
5232: oPushResult
5233: oEmitLabel
5234: oPop 1
5236: oTypeSPop
5237: oGetGlobal 8
5239: oPushResult
5240: oTypeSPush
5241: oPop 1
5243: oJumpForward 5248
5245: Choice Lookup Table
          30   5223
5248: oReturn
5249: oLocalSpace 0
5251: oGetParam 1
5253: oPushResult
5254: oCall 5650
5256: oPop 1
5258: oInputChoice 5632
5260: oGetParam 1
5262: oPushResult
5263: oCall 5149
5265: oPop 1
5267: oCall 10010
5269: oGetParam 1
5271: oPushResult
5272: oCall 5650
5274: oPop 1
5276: oGetParam 1
5278: oPushResult
5279: oCall 5149
5281: oPop 1
5283: oCall 10010
5285: oCall 9911
5287: oTypeSNodeType
5288: oChoice 5302
5290: oEmit 40
5292: oJumpForward 5317
5294: oEmit 46
5296: oJumpForward 5317
5298: oError 16
5300: oJumpForward 5317
5302: Choice Lookup Table
          33   5298
          32   5298
          34   5294
          30   5290
          38   5290
          28   5290
5315: oError 17
5317: oTypeSPop
5318: oGetGlobal 7
5320: oPushResult
5321: oTypeSPush
5322: oPop 1
5324: oJumpForward 5647
5326: oGetParam 1
5328: oPushResult
5329: oCall 5149
5331: oPop 1
5333: oCall 10010
5335: oGetParam 1
5337: oPushResult
5338: oCall 5650
5340: oPop 1
5342: oGetParam 1
5344: oPushResult
5345: oCall 5149
5347: oPop 1
5349: oCall 10010
5351: oCall 9911
5353: oTypeSNodeType
5354: oChoice 5368
5356: oEmit 41
5358: oJumpForward 5383
5360: oEmit 47
5362: oJumpForward 5383
5364: oError 16
5366: oJumpForward 5383
5368: Choice Lookup Table
          33   5364
          32   5364
          34   5360
          30   5356
          38   5356
          28   5356
5381: oError 17
5383: oTypeSPop
5384: oGetGlobal 7
5386: oPushResult
5387: oTypeSPush
5388: oPop 1
5390: oJumpForward 5647
5392: oGetParam 1
5394: oPushResult
5395: oCall 5149
5397: oPop 1
5399: oCall 10010
5401: oGetParam 1
5403: oPushResult
5404: oCall 5650
5406: oPop 1
5408: oGetParam 1
5410: oPushResult
5411: oCall 5149
5413: oPop 1
5415: oCall 10010
5417: oCall 9911
5419: oTypeSNodeType
5420: oChoice 5430
5422: oEmit 43
5424: oJumpForward 5443
5426: oError 16
5428: oJumpForward 5443
5430: Choice Lookup Table
          33   5426
          32   5426
          30   5422
          38   5422
          28   5422
5441: oError 17
5443: oTypeSPop
5444: oGetGlobal 7
5446: oPushResult
5447: oTypeSPush
5448: oPop 1
5450: oJumpForward 5647
5452: oGetParam 1
5454: oPushResult
5455: oCall 5149
5457: oPop 1
5459: oCall 10010
5461: oGetParam 1
5463: oPushResult
5464: oCall 5650
5466: oPop 1
5468: oGetParam 1
5470: oPushResult
5471: oCall 5149
5473: oPop 1
5475: oCall 10010
5477: oCall 9911
5479: oTypeSNodeType
5480: oChoice 5490
5482: oEmit 42
5484: oJumpForward 5503
5486: oError 16
5488: oJumpForward 5503
5490: Choice Lookup Table
          33   5486
          32   5486
          30   5482
          38   5482
          28   5482
5501: oError 17
5503: oTypeSPop
5504: oGetGlobal 7
5506: oPushResult
5507: oTypeSPush
5508: oPop 1
5510: oJumpForward 5647
5512: oGetParam 1
5514: oPushResult
5515: oCall 5149
5517: oPop 1
5519: oCall 10010
5521: oGetParam 1
5523: oPushResult
5524: oCall 5650
5526: oPop 1
5528: oGetParam 1
5530: oPushResult
5531: oCall 5149
5533: oPop 1
5535: oCall 10010
5537: oCall 9911
5539: oTypeSNodeType
5540: oChoice 5550
5542: oEmit 45
5544: oJumpForward 5563
5546: oError 16
5548: oJumpForward 5563
5550: Choice Lookup Table
          33   5546
          32   5546
          30   5542
          38   5542
          28   5542
5561: oError 17
5563: oTypeSPop
5564: oGetGlobal 7
5566: oPushResult
5567: oTypeSPush
5568: oPop 1
5570: oJumpForward 5647
5572: oGetParam 1
5574: oPushResult
5575: oCall 5149
5577: oPop 1
5579: oCall 10010
5581: oGetParam 1
5583: oPushResult
5584: oCall 5650
5586: oPop 1
5588: oGetParam 1
5590: oPushResult
5591: oCall 5149
5593: oPop 1
5595: oCall 10010
5597: oCall 9911
5599: oTypeSNodeType
5600: oChoice 5610
5602: oEmit 44
5604: oJumpForward 5623
5606: oError 16
5608: oJumpForward 5623
5610: Choice Lookup Table
          33   5606
          32   5606
          30   5602
          38   5602
          28   5602
5621: oError 17
5623: oTypeSPop
5624: oGetGlobal 7
5626: oPushResult
5627: oTypeSPush
5628: oPop 1
5630: oJumpForward 5647
5632: Choice Lookup Table
          11   5572
          10   5512
           9   5452
           8   5392
           7   5326
           6   5260
5645: oJumpForward 5649
5647: oJumpBack 5258
5649: oReturn
5650: oLocalSpace 1
5652: oGetAddrLocal 1
5654: oPushResult
5655: oSetResult 0
5657: oAssign
5658: oGetParam 1
5660: oPushResult
5661: oCall 5830
5663: oPop 1
5665: oInputChoice 5798
5667: oTypeSNodeType
5668: oChoice 5739
5670: oGetLocal 1
5672: oPushResult
5673: oSetResult 0
5675: oPushResult
5676: equal_label
5677: oPop 2
5679: oChoice 5688
5681: oGetAddrLocal 1
5683: oPushResult
5684: oLabelNew
5685: oAssign
5686: oJumpForward 5691
5688: Choice Lookup Table
           1   5681
5691: oEmit 55
5693: oGetLocal 1
5695: oPushResult
5696: oEmitLabel
5697: oPop 1
5699: oJumpForward 5746
5701: oGetParam 1
5703: oPushResult
5704: oCall 5218
5706: oPop 1
5708: oGetLocal 1
5710: oPushResult
5711: oSetResult 0
5713: oPushResult
5714: equal_label
5715: oPop 2
5717: oChoice 5726
5719: oGetAddrLocal 1
5721: oPushResult
5722: oLabelNew
5723: oAssign
5724: oJumpForward 5729
5726: Choice Lookup Table
           1   5719
5729: oEmit 55
5731: oGetLocal 1
5733: oPushResult
5734: oEmitLabel
5735: oPop 1
5737: oJumpForward 5746
5739: Choice Lookup Table
          30   5701
          31   5670
5744: oError 8
5746: oTypeSPop
5747: oEmit 58
5749: oGetFromParam 1
5751: oPushResult
5752: oEmitLabel
5753: oPop 1
5755: oGetParam 1
5757: oPushResult
5758: oSetResult 0
5760: oAssign
5761: oGetParam 1
5763: oPushResult
5764: oCall 5830
5766: oPop 1
5768: oTypeSNodeType
5769: oChoice 5782
5771: oJumpForward 5789
5773: oGetParam 1
5775: oPushResult
5776: oCall 5218
5778: oPop 1
5780: oJumpForward 5789
5782: Choice Lookup Table
          30   5773
          31   5771
5787: oError 8
5789: oTypeSPop
5790: oGetGlobal 8
5792: oPushResult
5793: oTypeSPush
5794: oPop 1
5796: oJumpForward 5803
5798: Choice Lookup Table
          55   5667
5801: oJumpForward 5805
5803: oJumpBack 5665
5805: oGetLocal 1
5807: oPushResult
5808: oSetResult 0
5810: oPushResult
5811: equal_label
5812: oPop 2
5814: oChoice 5826
5816: oEmit 58
5818: oGetLocal 1
5820: oPushResult
5821: oEmitLabel
5822: oPop 1
5824: oJumpForward 5829
5826: Choice Lookup Table
           0   5816
5829: oReturn
5830: oLocalSpace 2
5832: oGetAddrLocal 1
5834: oPushResult
5835: oSetResult 0
5837: oAssign
5838: oGetParam 1
5840: oPushResult
5841: oCall 5968
5843: oPop 1
5845: oInputChoice 5960
5847: oTypeSNodeType
5848: oChoice 5861
5850: oJumpForward 5868
5852: oGetParam 1
5854: oPushResult
5855: oCall 5218
5857: oPop 1
5859: oJumpForward 5868
5861: Choice Lookup Table
          30   5852
          31   5850
5866: oError 8
5868: oTypeSPop
5869: oGetLocal 1
5871: oPushResult
5872: oSetResult 0
5874: oPushResult
5875: equal_label
5876: oPop 2
5878: oChoice 5907
5880: oGetAddrLocal 1
5882: oPushResult
5883: oLabelNew
5884: oAssign
5885: oEmit 59
5887: oGetFromParam 1
5889: oPushResult
5890: oEmitLabel
5891: oPop 1
5893: oGetLocal 1
5895: oPushResult
5896: oEmitLabel
5897: oPop 1
5899: oGetParam 1
5901: oPushResult
5902: oGetLocal 1
5904: oAssign
5905: oJumpForward 5910
5907: Choice Lookup Table
           1   5880
5910: oGetAddrLocal 2
5912: oPushResult
5913: oSetResult 0
5915: oAssign
5916: oGetAddrLocal 2
5918: oPushResult
5919: oCall 5968
5921: oPop 1
5923: oTypeSNodeType
5924: oChoice 5937
5926: oJumpForward 5944
5928: oGetAddrLocal 2
5930: oPushResult
5931: oCall 5218
5933: oPop 1
5935: oJumpForward 5944
5937: Choice Lookup Table
          30   5928
          31   5926
5942: oError 8
5944: oEmit 59
5946: oGetLocal 2
5948: oPushResult
5949: oEmitLabel
5950: oPop 1
5952: oGetLocal 1
5954: oPushResult
5955: oEmitLabel
5956: oPop 1
5958: oJumpForward 5965
5960: Choice Lookup Table
          54   5847
5963: oJumpForward 5967
5965: oJumpBack 5845
5967: oReturn
5968: oLocalSpace 1
5970: oInputChoice 6024
5972: oGetAddrLocal 1
5974: oPushResult
5975: oSetResult 0
5977: oAssign
5978: oGetAddrLocal 1
5980: oPushResult
5981: oCall 5968
5983: oPop 1
5985: oTypeSNodeType
5986: oChoice 6015
5988: oGetParam 1
5990: oPushResult
5991: oLabelNew
5992: oAssign
5993: oEmit 55
5995: oGetFromParam 1
5997: oPushResult
5998: oEmitLabel
5999: oPop 1
6001: oEmit 58
6003: oGetLocal 1
6005: oPushResult
6006: oEmitLabel
6007: oPop 1
6009: oJumpForward 6022
6011: oEmit 39
6013: oJumpForward 6022
6015: Choice Lookup Table
          30   6011
          31   5988
6020: oError 8
6022: oJumpForward 6034
6024: Choice Lookup Table
          56   5972
6027: oGetParam 1
6029: oPushResult
6030: oCall 6035
6032: oPop 1
6034: oReturn
6035: oLocalSpace 2
6037: oGetParam 1
6039: oPushResult
6040: oCall 6172
6042: oPop 1
6044: oInputChoice 6162
6046: oTypeSNodeType
6047: oChoice 6132
6049: oCall 9964
6051: oGetParam 1
6053: oPushResult
6054: oCall 6172
6056: oPop 1
6058: oCall 9984
6060: oEmit 36
6062: oJumpForward 6145
6064: oError 16
6066: oJumpForward 6145
6068: oGetAddrLocal 1
6070: oPushResult
6071: oTypeSTop
6072: oPushResult
6073: oSetResult 36
6075: oPushResult
6076: oNodeGet
6077: oPop 2
6079: oAssign
6080: oGetAddrLocal 2
6082: oPushResult
6083: oGetLocal 1
6085: oPushResult
6086: oSetResult 17
6088: oPushResult
6089: oNodeGetInt
6090: oPop 2
6092: oAssign
6093: oGetParam 1
6095: oPushResult
6096: oCall 6172
6098: oPop 1
6100: oCall 9964
6102: oGetLocal 2
6104: oPushResult
6105: oSetResult 1
6107: oPushResult
6108: equal
6109: oPop 2
6111: oChoice 6125
6113: oEmit 15
6115: oGetLocal 2
6117: oPushResult
6118: oEmitInt
6119: oPop 1
6121: oEmit 33
6123: oJumpForward 6128
6125: Choice Lookup Table
           0   6113
6128: oEmit 35
6130: oJumpForward 6145
6132: Choice Lookup Table
          34   6068
          32   6064
          33   6064
          29   6049
          28   6049
6143: oError 17
6145: oJumpForward 6169
6147: oCall 9964
6149: oGetParam 1
6151: oPushResult
6152: oCall 6172
6154: oPop 1
6156: oCall 9984
6158: oEmit 37
6160: oJumpForward 6169
6162: Choice Lookup Table
          25   6147
          24   6046
6167: oJumpForward 6171
6169: oJumpBack 6044
6171: oReturn
6172: oLocalSpace 0
6174: oGetParam 1
6176: oPushResult
6177: oCall 6223
6179: oPop 1
6181: oInputChoice 6213
6183: oCall 9964
6185: oGetParam 1
6187: oPushResult
6188: oCall 6223
6190: oPop 1
6192: oCall 9984
6194: oEmit 33
6196: oJumpForward 6220
6198: oCall 9964
6200: oGetParam 1
6202: oPushResult
6203: oCall 6223
6205: oPop 1
6207: oCall 9984
6209: oEmit 34
6211: oJumpForward 6220
6213: Choice Lookup Table
          23   6198
          22   6183
6218: oJumpForward 6222
6220: oJumpBack 6181
6222: oReturn
6223: oLocalSpace 0
6225: oInputChoice 6251
6227: oGetParam 1
6229: oPushResult
6230: oCall 6264
6232: oPop 1
6234: oCall 9984
6236: oJumpForward 6263
6238: oGetParam 1
6240: oPushResult
6241: oCall 6264
6243: oPop 1
6245: oCall 9984
6247: oEmit 38
6249: oJumpForward 6263
6251: Choice Lookup Table
          25   6238
          24   6227
6256: oGetParam 1
6258: oPushResult
6259: oCall 6264
6261: oPop 1
6263: oReturn
6264: oLocalSpace 6
6266: oInputChoice 6501
6268: oEmit 15
6270: TOKEN_VALUE
6271: oPushResult
6272: oEmitInt
6273: oPop 1
6275: oGetGlobal 6
6277: oPushResult
6278: oTypeSPush
6279: oPop 1
6281: oJumpForward 6522
6283: oEmit 15
6285: TOKEN_VALUE
6286: oPushResult
6287: oEmitInt
6288: oPop 1
6290: oGetGlobal 9
6292: oPushResult
6293: oTypeSPush
6294: oPop 1
6296: oJumpForward 6522
6298: oGetParam 1
6300: oPushResult
6301: oCall 5249
6303: oPop 1
6305: oInput 15
6307: oJumpForward 6522
6309: oGetAddrLocal 1
6311: oPushResult
6312: CURRENT_STRLIT
6313: oPushResult
6314: oStringAllocLit
6315: oPop 1
6317: oAssign
6318: oEmit 16
6320: oGetLocal 1
6322: oPushResult
6323: oEmitInt
6324: oPop 1
6326: oGetGlobal 11
6328: oPushResult
6329: oTypeSPush
6330: oPop 1
6332: oJumpForward 6522
6334: oGetAddrLocal 2
6336: oPushResult
6337: oScopeFindRequire
6338: oAssign
6339: oGetAddrLocal 2
6341: oPushResult
6342: oCall 466
6344: oPop 1
6346: oGetLocal 2
6348: oPushResult
6349: oNodeType
6350: oPop 1
6352: oChoice 6425
6354: oGetLocal 2
6356: oPushResult
6357: oCall 7762
6359: oPop 1
6361: oJumpForward 6450
6363: oGetLocal 2
6365: oPushResult
6366: oCall 8378
6368: oPop 1
6370: oJumpForward 6450
6372: oGetAddrLocal 3
6374: oPushResult
6375: oGetLocal 2
6377: oPushResult
6378: oSetResult 21
6380: oPushResult
6381: oNodeGet
6382: oPop 2
6384: oAssign
6385: oGetLocal 3
6387: oPushResult
6388: oTypeSPush
6389: oPop 1
6391: oTypeSNodeType
6392: oChoice 6405
6394: oEmit 15
6396: oGetLocal 2
6398: oPushResult
6399: oCall 10393
6401: oPop 1
6403: oJumpForward 6414
6405: Choice Lookup Table
          30   6394
          38   6394
          28   6394
6412: oError 16
6414: oJumpForward 6450
6416: oGetLocal 2
6418: oPushResult
6419: oCall 6523
6421: oPop 1
6423: oJumpForward 6450
6425: Choice Lookup Table
          24   6416
          23   6416
          21   6416
          20   6416
          17   6372
          16   6372
          14   6363
          13   6354
6442: oError 6
6444: oGetGlobal 6
6446: oPushResult
6447: oTypeSPush
6448: oPop 1
6450: oJumpForward 6522
6452: oInput 0
6454: oGetAddrLocal 4
6456: oPushResult
6457: oScopeFindRequire
6458: oAssign
6459: oGetAddrLocal 4
6461: oPushResult
6462: oCall 466
6464: oPop 1
6466: oGetLocal 4
6468: oPushResult
6469: oSetResult 0
6471: oPushResult
6472: oCall 9063
6474: oPop 2
6476: oGetAddrLocal 5
6478: oPushResult
6479: oTypeSTop
6480: oAssign
6481: oTypeSPop
6482: oGetAddrLocal 6
6484: oPushResult
6485: oGetLocal 5
6487: oPushResult
6488: oCall 10119
6490: oPop 1
6492: oAssign
6493: oGetLocal 6
6495: oPushResult
6496: oTypeSPush
6497: oPop 1
6499: oJumpForward 6522
6501: Choice Lookup Table
          19   6452
           0   6334
           2   6309
          14   6298
           3   6283
           1   6268
6514: oError 6
6516: oGetGlobal 6
6518: oPushResult
6519: oTypeSPush
6520: oPop 1
6522: oReturn
6523: oLocalSpace 2
6525: oGetAddrLocal 1
6527: oPushResult
6528: oGetParam 1
6530: oPushResult
6531: oSetResult 21
6533: oPushResult
6534: oNodeGet
6535: oPop 2
6537: oAssign
6538: oGetAddrLocal 2
6540: oPushResult
6541: oGetParam 1
6543: oPushResult
6544: oCall 9893
6546: oPop 1
6548: oAssign
6549: oGetLocal 1
6551: oPushResult
6552: oTypeSPush
6553: oPop 1
6555: oTypeSNodeType
6556: oChoice 7245
6558: oGetParam 1
6560: oPushResult
6561: oNodeType
6562: oPop 1
6564: oChoice 6710
6566: oEmit 0
6568: oGetParam 1
6570: oPushResult
6571: oCall 10393
6573: oPop 1
6575: oJumpForward 6720
6577: oGetLocal 2
6579: oPushResult
6580: equal_zero
6581: oPop 1
6583: oChoice 6596
6585: oEmit 3
6587: oGetParam 1
6589: oPushResult
6590: oCall 10393
6592: oPop 1
6594: oJumpForward 6614
6596: Choice Lookup Table
           1   6585
6599: oEmit 9
6601: oGetLocal 2
6603: oPushResult
6604: oEmitInt
6605: oPop 1
6607: oGetParam 1
6609: oPushResult
6610: oCall 10393
6612: oPop 1
6614: oJumpForward 6720
6616: oGetParam 1
6618: oPushResult
6619: oSetResult 33
6621: oPushResult
6622: oNodeGetBoolean
6623: oPop 2
6625: oChoice 6668
6627: oGetLocal 2
6629: oPushResult
6630: equal_zero
6631: oPop 1
6633: oChoice 6646
6635: oEmit 8
6637: oGetParam 1
6639: oPushResult
6640: oCall 10393
6642: oPop 1
6644: oJumpForward 6664
6646: Choice Lookup Table
           1   6635
6649: oEmit 14
6651: oGetLocal 2
6653: oPushResult
6654: oEmitInt
6655: oPop 1
6657: oGetParam 1
6659: oPushResult
6660: oCall 10393
6662: oPop 1
6664: oEmit 22
6666: oJumpForward 6708
6668: Choice Lookup Table
           1   6627
6671: oGetLocal 2
6673: oPushResult
6674: equal_zero
6675: oPop 1
6677: oChoice 6690
6679: oEmit 6
6681: oGetParam 1
6683: oPushResult
6684: oCall 10393
6686: oPop 1
6688: oJumpForward 6708
6690: Choice Lookup Table
           1   6679
6693: oEmit 12
6695: oGetLocal 2
6697: oPushResult
6698: oEmitInt
6699: oPop 1
6701: oGetParam 1
6703: oPushResult
6704: oCall 10393
6706: oPop 1
6708: oJumpForward 6720
6710: Choice Lookup Table
          23   6616
          21   6577
          24   6566
          20   6566
6719: oEndChoice
6720: oJumpForward 7267
6722: oGetParam 1
6724: oPushResult
6725: oNodeType
6726: oPop 1
6728: oChoice 6874
6730: oEmit 1
6732: oGetParam 1
6734: oPushResult
6735: oCall 10393
6737: oPop 1
6739: oJumpForward 6884
6741: oGetLocal 2
6743: oPushResult
6744: equal_zero
6745: oPop 1
6747: oChoice 6760
6749: oEmit 4
6751: oGetParam 1
6753: oPushResult
6754: oCall 10393
6756: oPop 1
6758: oJumpForward 6778
6760: Choice Lookup Table
           1   6749
6763: oEmit 10
6765: oGetLocal 2
6767: oPushResult
6768: oEmitInt
6769: oPop 1
6771: oGetParam 1
6773: oPushResult
6774: oCall 10393
6776: oPop 1
6778: oJumpForward 6884
6780: oGetParam 1
6782: oPushResult
6783: oSetResult 33
6785: oPushResult
6786: oNodeGetBoolean
6787: oPop 2
6789: oChoice 6832
6791: oGetLocal 2
6793: oPushResult
6794: equal_zero
6795: oPop 1
6797: oChoice 6810
6799: oEmit 8
6801: oGetParam 1
6803: oPushResult
6804: oCall 10393
6806: oPop 1
6808: oJumpForward 6828
6810: Choice Lookup Table
           1   6799
6813: oEmit 14
6815: oGetLocal 2
6817: oPushResult
6818: oEmitInt
6819: oPop 1
6821: oGetParam 1
6823: oPushResult
6824: oCall 10393
6826: oPop 1
6828: oEmit 23
6830: oJumpForward 6872
6832: Choice Lookup Table
           1   6791
6835: oGetLocal 2
6837: oPushResult
6838: equal_zero
6839: oPop 1
6841: oChoice 6854
6843: oEmit 7
6845: oGetParam 1
6847: oPushResult
6848: oCall 10393
6850: oPop 1
6852: oJumpForward 6872
6854: Choice Lookup Table
           1   6843
6857: oEmit 13
6859: oGetLocal 2
6861: oPushResult
6862: oEmitInt
6863: oPop 1
6865: oGetParam 1
6867: oPushResult
6868: oCall 10393
6870: oPop 1
6872: oJumpForward 6884
6874: Choice Lookup Table
          23   6780
          21   6741
          24   6730
          20   6730
6883: oEndChoice
6884: oJumpForward 7267
6886: oError 16
6888: oJumpForward 7267
6890: oGetParam 1
6892: oPushResult
6893: oNodeType
6894: oPop 1
6896: oChoice 7042
6898: oEmit 2
6900: oGetParam 1
6902: oPushResult
6903: oCall 10393
6905: oPop 1
6907: oJumpForward 7052
6909: oGetLocal 2
6911: oPushResult
6912: equal_zero
6913: oPop 1
6915: oChoice 6928
6917: oEmit 5
6919: oGetParam 1
6921: oPushResult
6922: oCall 10393
6924: oPop 1
6926: oJumpForward 6946
6928: Choice Lookup Table
           1   6917
6931: oEmit 11
6933: oGetLocal 2
6935: oPushResult
6936: oEmitInt
6937: oPop 1
6939: oGetParam 1
6941: oPushResult
6942: oCall 10393
6944: oPop 1
6946: oJumpForward 7052
6948: oGetParam 1
6950: oPushResult
6951: oSetResult 33
6953: oPushResult
6954: oNodeGetBoolean
6955: oPop 2
6957: oChoice 7000
6959: oGetLocal 2
6961: oPushResult
6962: equal_zero
6963: oPop 1
6965: oChoice 6978
6967: oEmit 8
6969: oGetParam 1
6971: oPushResult
6972: oCall 10393
6974: oPop 1
6976: oJumpForward 6996
6978: Choice Lookup Table
           1   6967
6981: oEmit 14
6983: oGetLocal 2
6985: oPushResult
6986: oEmitInt
6987: oPop 1
6989: oGetParam 1
6991: oPushResult
6992: oCall 10393
6994: oPop 1
6996: oEmit 24
6998: oJumpForward 7040
7000: Choice Lookup Table
           1   6959
7003: oGetLocal 2
7005: oPushResult
7006: equal_zero
7007: oPop 1
7009: oChoice 7022
7011: oEmit 8
7013: oGetParam 1
7015: oPushResult
7016: oCall 10393
7018: oPop 1
7020: oJumpForward 7040
7022: Choice Lookup Table
           1   7011
7025: oEmit 14
7027: oGetLocal 2
7029: oPushResult
7030: oEmitInt
7031: oPop 1
7033: oGetParam 1
7035: oPushResult
7036: oCall 10393
7038: oPop 1
7040: oJumpForward 7052
7042: Choice Lookup Table
          23   6948
          21   6909
          24   6898
          20   6898
7051: oEndChoice
7052: oInputChoice 7074
7054: oTypeSPop
7055: oGetLocal 1
7057: oPushResult
7058: oSetResult 36
7060: oPushResult
7061: oNodeGet
7062: oPop 2
7064: oPushResult
7065: oTypeSPush
7066: oPop 1
7068: oCall 7314
7070: oCall 7268
7072: oJumpForward 7077
7074: Choice Lookup Table
          18   7054
7077: oJumpForward 7267
7079: oGetParam 1
7081: oPushResult
7082: oNodeType
7083: oPop 1
7085: oChoice 7229
7087: oEmit 16
7089: oGetParam 1
7091: oPushResult
7092: oCall 10393
7094: oPop 1
7096: oJumpForward 7239
7098: oGetLocal 2
7100: oPushResult
7101: equal_zero
7102: oPop 1
7104: oChoice 7117
7106: oEmit 17
7108: oGetParam 1
7110: oPushResult
7111: oCall 10393
7113: oPop 1
7115: oJumpForward 7135
7117: Choice Lookup Table
           1   7106
7120: oEmit 20
7122: oGetLocal 2
7124: oPushResult
7125: oEmitInt
7126: oPop 1
7128: oGetParam 1
7130: oPushResult
7131: oCall 10393
7133: oPop 1
7135: oJumpForward 7239
7137: oGetParam 1
7139: oPushResult
7140: oSetResult 33
7142: oPushResult
7143: oNodeGetBoolean
7144: oPop 2
7146: oChoice 7187
7148: oGetLocal 2
7150: oPushResult
7151: equal_zero
7152: oPop 1
7154: oChoice 7167
7156: oEmit 8
7158: oGetParam 1
7160: oPushResult
7161: oCall 10393
7163: oPop 1
7165: oJumpForward 7185
7167: Choice Lookup Table
           1   7156
7170: oEmit 14
7172: oGetLocal 2
7174: oPushResult
7175: oEmitInt
7176: oPop 1
7178: oGetParam 1
7180: oPushResult
7181: oCall 10393
7183: oPop 1
7185: oJumpForward 7227
7187: Choice Lookup Table
           1   7148
7190: oGetLocal 2
7192: oPushResult
7193: equal_zero
7194: oPop 1
7196: oChoice 7209
7198: oEmit 18
7200: oGetParam 1
7202: oPushResult
7203: oCall 10393
7205: oPop 1
7207: oJumpForward 7227
7209: Choice Lookup Table
           1   7198
7212: oEmit 21
7214: oGetLocal 2
7216: oPushResult
7217: oEmitInt
7218: oPop 1
7220: oGetParam 1
7222: oPushResult
7223: oCall 10393
7225: oPop 1
7227: oJumpForward 7239
7229: Choice Lookup Table
          23   7137
          21   7098
          24   7087
          20   7087
7238: oEndChoice
7239: oCall 7314
7241: oCall 7268
7243: oJumpForward 7267
7245: Choice Lookup Table
          37   7079
          35   7079
          34   6890
          27   6886
          33   6886
          32   6722
          29   6722
          30   6722
          38   6558
          28   6558
7266: oEndChoice
7267: oReturn
7268: oLocalSpace 0
7270: oTypeSNodeType
7271: oChoice 7291
7273: oEmit 22
7275: oJumpForward 7313
7277: oEmit 23
7279: oJumpForward 7313
7281: oError 16
7283: oJumpForward 7313
7285: oEmit 24
7287: oJumpForward 7313
7289: oJumpForward 7313
7291: Choice Lookup Table
          37   7289
          35   7289
          34   7285
          27   7281
          33   7281
          32   7277
          29   7277
          30   7277
          38   7273
          28   7273
7312: oEndChoice
7313: oReturn
7314: oLocalSpace 0
7316: oInputChoice 7330
7318: oCall 7342
7320: oJumpForward 7339
7322: oCall 7485
7324: oJumpForward 7339
7326: oCall 7583
7328: oJumpForward 7339
7330: Choice Lookup Table
          18   7326
          20   7322
          16   7318
7337: oJumpForward 7341
7339: oJumpBack 7316
7341: oReturn
7342: oLocalSpace 3
7344: oTypeSNodeType
7345: oChoice 7349
7347: oJumpForward 7354
7349: Choice Lookup Table
          35   7347
7352: oError 10
7354: oTypeSNodeType
7355: oChoice 7359
7357: oJumpForward 7364
7359: Choice Lookup Table
          35   7357
7362: oError 13
7364: oGetAddrLocal 1
7366: oPushResult
7367: oTypeSTop
7368: oPushResult
7369: oSetResult 37
7371: oPushResult
7372: oNodeGet
7373: oPop 2
7375: oPushResult
7376: oCall 10203
7378: oPop 1
7380: oAssign
7381: oGetAddrLocal 2
7383: oPushResult
7384: oTypeSTop
7385: oPushResult
7386: oSetResult 36
7388: oPushResult
7389: oNodeGet
7390: oPop 2
7392: oAssign
7393: oTypeSPop
7394: oGetLocal 2
7396: oPushResult
7397: oTypeSPush
7398: oPop 1
7400: oCall 5088
7402: oCall 9937
7404: oGetLocal 1
7406: oPushResult
7407: equal_zero
7408: oPop 1
7410: oChoice 7424
7412: oEmit 15
7414: oGetLocal 1
7416: oPushResult
7417: oEmitInt
7418: oPop 1
7420: oEmit 37
7422: oJumpForward 7427
7424: Choice Lookup Table
           0   7412
7427: oGetAddrLocal 3
7429: oPushResult
7430: oGetLocal 2
7432: oPushResult
7433: oSetResult 17
7435: oPushResult
7436: oNodeGetInt
7437: oPop 2
7439: oAssign
7440: oGetLocal 3
7442: oPushResult
7443: oSetResult 1
7445: oPushResult
7446: equal
7447: oPop 2
7449: oChoice 7463
7451: oEmit 15
7453: oGetLocal 3
7455: oPushResult
7456: oEmitInt
7457: oPop 1
7459: oEmit 33
7461: oJumpForward 7466
7463: Choice Lookup Table
           0   7451
7466: oEmit 35
7468: oInputChoice 7476
7470: oJumpForward 7484
7472: oJumpForward 7482
7474: oJumpForward 7482
7476: Choice Lookup Table
          13   7474
          17   7470
7481: oEndChoice
7482: oJumpBack 7354
7484: oReturn
7485: oLocalSpace 2
7487: oTypeSNodeType
7488: oChoice 7492
7490: oJumpForward 7497
7492: Choice Lookup Table
          37   7490
7495: oError 11
7497: oTypeSTop
7498: oPushResult
7499: oSetResult 40
7501: oPushResult
7502: oNodeGet
7503: oPop 2
7505: oPushResult
7506: oScopeEnter
7507: oPop 1
7509: oInput 0
7511: oGetAddrLocal 1
7513: oPushResult
7514: oScopeFindRequire
7515: oAssign
7516: oGetLocal 1
7518: oPushResult
7519: oNodeType
7520: oPop 1
7522: oChoice 7526
7524: oJumpForward 7531
7526: Choice Lookup Table
          22   7524
7529: oError 12
7531: oScopeEnd
7532: oGetAddrLocal 2
7534: oPushResult
7535: oGetLocal 1
7537: oPushResult
7538: oSetResult 22
7540: oPushResult
7541: oNodeGetInt
7542: oPop 2
7544: oAssign
7545: oGetLocal 2
7547: oPushResult
7548: equal_zero
7549: oPop 1
7551: oChoice 7565
7553: oEmit 15
7555: oGetLocal 2
7557: oPushResult
7558: oEmitInt
7559: oPop 1
7561: oEmit 35
7563: oJumpForward 7568
7565: Choice Lookup Table
           0   7553
7568: oTypeSPop
7569: oGetLocal 1
7571: oPushResult
7572: oSetResult 21
7574: oPushResult
7575: oNodeGet
7576: oPop 2
7578: oPushResult
7579: oTypeSPush
7580: oPop 1
7582: oReturn
7583: oLocalSpace 1
7585: oTypeSNodeType
7586: oChoice 7590
7588: oJumpForward 7595
7590: Choice Lookup Table
          34   7588
7593: oError 9
7595: oEmit 24
7597: oGetAddrLocal 1
7599: oPushResult
7600: oTypeSTop
7601: oAssign
7602: oTypeSPop
7603: oGetLocal 1
7605: oPushResult
7606: oSetResult 36
7608: oPushResult
7609: oNodeGet
7610: oPop 2
7612: oPushResult
7613: oTypeSPush
7614: oPop 1
7616: oReturn
7617: oLocalSpace 1
7619: oGetAddrLocal 1
7621: oPushResult
7622: oTypeSNodeType
7623: oAssign
7624: oTypeSPop
7625: oGetLocal 1
7627: oPushResult
7628: oTypeSNodeType
7629: oPushResult
7630: equal_node_type
7631: oPop 2
7633: oChoice 7675
7635: oTypeSNodeType
7636: oChoice 7666
7638: oGetLocal 1
7640: oChoice 7647
7642: oEmit 29
7644: oReturn
7645: oJumpForward 7650
7647: Choice Lookup Table
          29   7642
7650: oJumpForward 7671
7652: oGetLocal 1
7654: oChoice 7661
7656: oEmit 30
7658: oReturn
7659: oJumpForward 7664
7661: Choice Lookup Table
          28   7656
7664: oJumpForward 7671
7666: Choice Lookup Table
          29   7652
          28   7638
7671: oError 14
7673: oJumpForward 7678
7675: Choice Lookup Table
           0   7635
7678: oReturn
7679: oLocalSpace 2
7681: oGetAddrLocal 2
7683: oPushResult
7684: oGetParam 1
7686: oPushResult
7687: oSetResult 26
7689: oPushResult
7690: oNodeGetString
7691: oPop 2
7693: oAssign
7694: oGetLocal 2
7696: oPushResult
7697: oSetResult 0
7699: oPushResult
7700: equal_string
7701: oPop 2
7703: oChoice 7740
7705: oGetAddrLocal 1
7707: oPushResult
7708: oGetParam 1
7710: oPushResult
7711: oSetResult 4
7713: oPushResult
7714: oNodeGetInt
7715: oPop 2
7717: oPushResult
7718: ID_STRING
7719: oPop 1
7721: oPushResult
7722: oStringAllocLit
7723: oPop 1
7725: oAssign
7726: oJumpForward 7746
7728: oGetAddrLocal 1
7730: oPushResult
7731: oGetLocal 2
7733: oPushResult
7734: oStringAllocLit
7735: oPop 1
7737: oAssign
7738: oJumpForward 7746
7740: Choice Lookup Table
           0   7728
           1   7705
7745: oEndChoice
7746: oEmit 60
7748: oGetParam 1
7750: oPushResult
7751: oCall 10393
7753: oPop 1
7755: oGetLocal 1
7757: oPushResult
7758: oEmitInt
7759: oPop 1
7761: oReturn
7762: oLocalSpace 10
7764: oGetParam 1
7766: oPushResult
7767: oSetResult 25
7769: oPushResult
7770: oNodeGetBoolean
7771: oPop 2
7773: oChoice 7800
7775: oGetParam 1
7777: oPushResult
7778: oSetResult 28
7780: oPushResult
7781: oNodeGetBoolean
7782: oPop 2
7784: oChoice 7795
7786: oGetParam 1
7788: oPushResult
7789: oCall 7679
7791: oPop 1
7793: oJumpForward 7798
7795: Choice Lookup Table
           0   7786
7798: oJumpForward 7803
7800: Choice Lookup Table
           1   7775
7803: oGetParam 1
7805: oPushResult
7806: oSetResult 28
7808: oPushResult
7809: oSetResult 1
7811: oPushResult
7812: oNodeSetBoolean
7813: oPop 3
7815: oGetAddrLocal 1
7817: oPushResult
7818: oGetParam 1
7820: oPushResult
7821: oSetResult 27
7823: oPushResult
7824: oNodeGetBoolean
7825: oPop 2
7827: oAssign
7828: oGetAddrLocal 4
7830: oPushResult
7831: oGetParam 1
7833: oPushResult
7834: oNodeType
7835: oPop 1
7837: oPushResult
7838: oSetResult 13
7840: oPushResult
7841: equal_node_type
7842: oPop 2
7844: oAssign
7845: oGetLocal 4
7847: oChoice 7874
7849: oGetAddrLocal 2
7851: oPushResult
7852: oGetParam 1
7854: oPushResult
7855: oSetResult 21
7857: oPushResult
7858: oNodeGet
7859: oPop 2
7861: oAssign
7862: oGetAddrLocal 3
7864: oPushResult
7865: oGetLocal 2
7867: oPushResult
7868: oScopeAllocType
7869: oPop 1
7871: oAssign
7872: oJumpForward 7877
7874: Choice Lookup Table
           1   7849
7877: oGetAddrLocal 5
7879: oPushResult
7880: oGetParam 1
7882: oPushResult
7883: oSetResult 23
7885: oPushResult
7886: oNodeGet
7887: oPop 2
7889: oAssign
7890: oGetAddrLocal 6
7892: oPushResult
7893: oGetLocal 5
7895: oPushResult
7896: oSetResult 17
7898: oPushResult
7899: oNodeGetInt
7900: oPop 2
7902: oAssign
7903: oGetLocal 1
7905: oChoice 7927
7907: oEmit 49
7909: oGetLocal 6
7911: oPushResult
7912: oEmitInt
7913: oPop 1
7915: oJumpForward 7933
7917: oEmit 48
7919: oGetLocal 6
7921: oPushResult
7922: oEmitInt
7923: oPop 1
7925: oJumpForward 7933
7927: Choice Lookup Table
           0   7917
           1   7907
7932: oEndChoice
7933: oGetParam 1
7935: oPushResult
7936: oCall 9873
7938: oPop 1
7940: oPushResult
7941: oSetResult 0
7943: oPushResult
7944: greater
7945: oPop 2
7947: oChoice 7980
7949: oEmit 19
7951: oSetResult 0
7953: oPushResult
7954: oEmitInt
7955: oPop 1
7957: oEmit 20
7959: oGetParam 1
7961: oPushResult
7962: oCall 9893
7964: oPop 1
7966: oPushResult
7967: oEmitInt
7968: oPop 1
7970: oSetResult 0
7972: oPushResult
7973: oEmitInt
7974: oPop 1
7976: oEmit 27
7978: oJumpForward 7983
7980: Choice Lookup Table
           1   7949
7983: oGetAddrLocal 7
7985: oPushResult
7986: oGetLocal 5
7988: oPushResult
7989: oSetResult 15
7991: oPushResult
7992: oNodeGetIter
7993: oPop 2
7995: oAssign
7996: oGetAddrLocal 8
7998: oPushResult
7999: oGetLocal 7
8001: oPushResult
8002: oNodeIterValue
8003: oPop 1
8005: oAssign
8006: oInputChoice 8201
8008: oGetLocal 8
8010: oPushResult
8011: oNodeNull
8012: oPop 1
8014: oChoice 8020
8016: oJumpForward 8197
8018: oJumpForward 8023
8020: Choice Lookup Table
           1   8016
8023: oGetAddrLocal 9
8025: oPushResult
8026: oGetLocal 8
8028: oPushResult
8029: oSetResult 22
8031: oPushResult
8032: oNodeGetInt
8033: oPop 2
8035: oAssign
8036: oEmit 19
8038: oGetLocal 9
8040: oPushResult
8041: oEmitInt
8042: oPop 1
8044: oGetLocal 8
8046: oPushResult
8047: oSetResult 21
8049: oPushResult
8050: oNodeGet
8051: oPop 2
8053: oPushResult
8054: oTypeSPush
8055: oPop 1
8057: oGetLocal 8
8059: oPushResult
8060: oSetResult 33
8062: oPushResult
8063: oNodeGetBoolean
8064: oPop 2
8066: oChoice 8150
8068: oSetResult 1
8070: oPushResult
8071: oCall 9015
8073: oPop 1
8075: oCall 9911
8077: oEmit 27
8079: oJumpForward 8156
8081: oCall 5088
8083: oCall 7617
8085: oTypeSNodeType
8086: oChoice 8126
8088: oEmit 25
8090: oJumpForward 8148
8092: oEmit 26
8094: oJumpForward 8148
8096: oError 16
8098: oJumpForward 8148
8100: oEmit 27
8102: oJumpForward 8148
8104: oGetAddrLocal 10
8106: oPushResult
8107: oTypeSTop
8108: oPushResult
8109: oSetResult 17
8111: oPushResult
8112: oNodeGetInt
8113: oPop 2
8115: oAssign
8116: oEmit 28
8118: oGetLocal 10
8120: oPushResult
8121: oEmitInt
8122: oPop 1
8124: oJumpForward 8148
8126: Choice Lookup Table
          37   8104
          35   8104
          34   8100
          27   8096
          33   8096
          32   8092
          29   8092
          30   8092
          38   8088
          28   8088
8147: oEndChoice
8148: oJumpForward 8156
8150: Choice Lookup Table
           0   8081
           1   8068
8155: oEndChoice
8156: oTypeSPop
8157: oGetAddrLocal 7
8159: oPushResult
8160: oNodeIterNext
8161: oPop 1
8163: oGetAddrLocal 8
8165: oPushResult
8166: oGetLocal 7
8168: oPushResult
8169: oNodeIterValue
8170: oPop 1
8172: oAssign
8173: oGetLocal 8
8175: oPushResult
8176: oNodeNull
8177: oPop 1
8179: oChoice 8187
8181: oJumpForward 8197
8183: oJumpForward 8193
8185: oJumpForward 8193
8187: Choice Lookup Table
           0   8185
           1   8181
8192: oEndChoice
8193: oInput 13
8195: oJumpBack 8008
8197: oInput 15
8199: oJumpForward 8204
8201: Choice Lookup Table
          14   8008
8204: oGetLocal 8
8206: oPushResult
8207: oNodeNull
8208: oPop 1
8210: oChoice 8216
8212: oError 15
8214: oJumpForward 8219
8216: Choice Lookup Table
           0   8212
8219: oGetLocal 4
8221: oChoice 8250
8223: oEmit 19
8225: oGetParam 1
8227: oPushResult
8228: oSetResult 31
8230: oPushResult
8231: oNodeGetInt
8232: oPop 2
8234: oPushResult
8235: oEmitInt
8236: oPop 1
8238: oEmit 17
8240: oGetLocal 3
8242: oPushResult
8243: oEmitInt
8244: oPop 1
8246: oEmit 27
8248: oJumpForward 8253
8250: Choice Lookup Table
           1   8223
8253: oGetLocal 1
8255: oChoice 8279
8257: oEmit 52
8259: oGetParam 1
8261: oPushResult
8262: oCall 10393
8264: oPop 1
8266: oJumpForward 8285
8268: oEmit 51
8270: oGetParam 1
8272: oPushResult
8273: oCall 10393
8275: oPop 1
8277: oJumpForward 8285
8279: Choice Lookup Table
           0   8268
           1   8257
8284: oEndChoice
8285: oGetLocal 4
8287: oChoice 8366
8289: oGetLocal 2
8291: oPushResult
8292: oTypeSPush
8293: oPop 1
8295: oTypeSNodeType
8296: oChoice 8342
8298: oEmit 3
8300: oGetLocal 3
8302: oPushResult
8303: oEmitInt
8304: oPop 1
8306: oJumpForward 8364
8308: oEmit 4
8310: oGetLocal 3
8312: oPushResult
8313: oEmitInt
8314: oPop 1
8316: oJumpForward 8364
8318: oError 16
8320: oJumpForward 8364
8322: oEmit 5
8324: oGetLocal 3
8326: oPushResult
8327: oEmitInt
8328: oPop 1
8330: oJumpForward 8364
8332: oEmit 17
8334: oGetLocal 3
8336: oPushResult
8337: oEmitInt
8338: oPop 1
8340: oJumpForward 8364
8342: Choice Lookup Table
          37   8332
          35   8332
          34   8322
          27   8318
          33   8318
          32   8308
          29   8308
          30   8308
          38   8298
          28   8298
8363: oEndChoice
8364: oJumpForward 8369
8366: Choice Lookup Table
           1   8289
8369: oEmit 50
8371: oGetLocal 6
8373: oPushResult
8374: oEmitInt
8375: oPop 1
8377: oReturn
8378: oLocalSpace 0
8380: oGetParam 1
8382: oPushResult
8383: oGetGlobal 12
8385: oPushResult
8386: oNodeEqual
8387: oPop 2
8389: oChoice 8429
8391: oInput 14
8393: oCall 5088
8395: oTypeSNodeType
8396: oChoice 8404
8398: oJumpForward 8417
8400: oEmit 29
8402: oJumpForward 8417
8404: Choice Lookup Table
          32   8400
          29   8400
          30   8400
          38   8398
          28   8398
8415: oError 14
8417: oTypeSPop
8418: oGetGlobal 6
8420: oPushResult
8421: oTypeSPush
8422: oPop 1
8424: oInput 15
8426: oReturn
8427: oJumpForward 8432
8429: Choice Lookup Table
           1   8391
8432: oGetParam 1
8434: oPushResult
8435: oGetGlobal 13
8437: oPushResult
8438: oNodeEqual
8439: oPop 2
8441: oChoice 8475
8443: oInput 14
8445: oCall 5088
8447: oTypeSNodeType
8448: oChoice 8456
8450: oEmit 30
8452: oJumpForward 8463
8454: oJumpForward 8463
8456: Choice Lookup Table
          29   8454
          28   8450
8461: oError 14
8463: oTypeSPop
8464: oGetGlobal 9
8466: oPushResult
8467: oTypeSPush
8468: oPop 1
8470: oInput 15
8472: oReturn
8473: oJumpForward 8478
8475: Choice Lookup Table
           1   8443
8478: oGetParam 1
8480: oPushResult
8481: oGetGlobal 14
8483: oPushResult
8484: oNodeEqual
8485: oPop 2
8487: oChoice 8527
8489: oInput 14
8491: oCall 5088
8493: oTypeSNodeType
8494: oChoice 8515
8496: oTypeSTop
8497: oPushResult
8498: oSetResult 42
8500: oPushResult
8501: oNodeGetBoolean
8502: oPop 2
8504: oChoice 8510
8506: oError 28
8508: oJumpForward 8513
8510: Choice Lookup Table
           1   8506
8513: oJumpForward 8520
8515: Choice Lookup Table
          38   8496
8518: oError 14
8520: oEmit 32
8522: oInput 15
8524: oReturn
8525: oJumpForward 8530
8527: Choice Lookup Table
           1   8489
8530: oGetParam 1
8532: oPushResult
8533: oGetGlobal 15
8535: oPushResult
8536: oNodeEqual
8537: oPop 2
8539: oChoice 8579
8541: oInput 14
8543: oCall 5088
8545: oTypeSNodeType
8546: oChoice 8567
8548: oTypeSTop
8549: oPushResult
8550: oSetResult 42
8552: oPushResult
8553: oNodeGetBoolean
8554: oPop 2
8556: oChoice 8562
8558: oError 28
8560: oJumpForward 8565
8562: Choice Lookup Table
           1   8558
8565: oJumpForward 8572
8567: Choice Lookup Table
          38   8548
8570: oError 14
8572: oEmit 31
8574: oInput 15
8576: oReturn
8577: oJumpForward 8582
8579: Choice Lookup Table
           1   8541
8582: oError 16
8584: oReturn
8585: oLocalSpace 0
8587: oInputChoice 8646
8589: oCall 9749
8591: oJumpForward 8675
8593: oCall 9756
8595: oJumpForward 8675
8597: oCall 9855
8599: oJumpForward 8675
8601: oCall 9858
8603: oJumpForward 8675
8605: oCall 9234
8607: oJumpForward 8675
8609: oCall 9557
8611: oJumpForward 8675
8613: oCall 9300
8615: oJumpForward 8675
8617: oCall 9477
8619: oJumpForward 8675
8621: oCall 9642
8623: oJumpForward 8675
8625: oCall 9610
8627: oJumpForward 8675
8629: oCall 9726
8631: oJumpForward 8675
8633: oCall 8676
8635: oJumpForward 8675
8637: oCall 9674
8639: oJumpForward 8675
8641: oChangeIntLitToLabelIdent
8642: oCall 8676
8644: oJumpForward 8675
8646: Choice Lookup Table
           1   8641
          53   8637
           0   8633
          35   8629
          51   8625
          52   8621
          49   8617
          44   8613
          48   8609
          41   8605
          66   8601
          65   8597
          64   8593
          63   8589
8675: oReturn
8676: oLocalSpace 1
8678: oGetAddrLocal 1
8680: oPushResult
8681: oScopeFindRequire
8682: oAssign
8683: oGetAddrLocal 1
8685: oPushResult
8686: oCall 466
8688: oPop 1
8690: oGetLocal 1
8692: oPushResult
8693: oNodeType
8694: oPop 1
8696: oChoice 8736
8698: oGetLocal 1
8700: oPushResult
8701: oCall 8752
8703: oPop 1
8705: oCall 8585
8707: oJumpForward 8751
8709: oGetLocal 1
8711: oPushResult
8712: oCall 7762
8714: oPop 1
8716: oJumpForward 8751
8718: oGetLocal 1
8720: oPushResult
8721: oCall 8802
8723: oPop 1
8725: oJumpForward 8751
8727: oGetLocal 1
8729: oPushResult
8730: oCall 8890
8732: oPop 1
8734: oJumpForward 8751
8736: Choice Lookup Table
          13   8727
          23   8718
          21   8718
          20   8718
          12   8709
          25   8698
8749: oError 0
8751: oReturn
8752: oLocalSpace 0
8754: oGetParam 1
8756: oPushResult
8757: oSetResult 34
8759: oPushResult
8760: oNodeGetBoolean
8761: oPop 2
8763: oChoice 8769
8765: oError 21
8767: oJumpForward 8772
8769: Choice Lookup Table
           1   8765
8772: oEmit 58
8774: oGetParam 1
8776: oPushResult
8777: oSetResult 22
8779: oPushResult
8780: oNodeGetLabel
8781: oPop 2
8783: oPushResult
8784: oEmitLabel
8785: oPop 1
8787: oGetParam 1
8789: oPushResult
8790: oSetResult 34
8792: oPushResult
8793: oSetResult 1
8795: oPushResult
8796: oNodeSetBoolean
8797: oPop 3
8799: oInput 12
8801: oReturn
8802: oLocalSpace 0
8804: oGetParam 1
8806: oPushResult
8807: oSetResult 1
8809: oPushResult
8810: oCall 9063
8812: oPop 2
8814: oInput 4
8816: oCall 5088
8818: oCall 7617
8820: oCall 8823
8822: oReturn
8823: oLocalSpace 1
8825: oTypeSNodeType
8826: oChoice 8866
8828: oEmit 25
8830: oJumpForward 8888
8832: oEmit 26
8834: oJumpForward 8888
8836: oError 16
8838: oJumpForward 8888
8840: oEmit 27
8842: oJumpForward 8888
8844: oGetAddrLocal 1
8846: oPushResult
8847: oTypeSTop
8848: oPushResult
8849: oSetResult 17
8851: oPushResult
8852: oNodeGetInt
8853: oPop 2
8855: oAssign
8856: oEmit 28
8858: oGetLocal 1
8860: oPushResult
8861: oEmitInt
8862: oPop 1
8864: oJumpForward 8888
8866: Choice Lookup Table
          37   8844
          35   8844
          34   8840
          27   8836
          33   8836
          32   8832
          29   8832
          30   8832
          38   8828
          28   8828
8887: oEndChoice
8888: oTypeSPop
8889: oReturn
8890: oLocalSpace 1
8892: oGetParam 1
8894: oPushResult
8895: oSetResult 6
8897: oPushResult
8898: oNodeGet
8899: oPop 2
8901: oPushResult
8902: oScopeCurrent
8903: oPushResult
8904: oNodeEqual
8905: oPop 2
8907: oChoice 8913
8909: oError 20
8911: oJumpForward 8916
8913: Choice Lookup Table
           0   8909
8916: oEmit 8
8918: oGetParam 1
8920: oPushResult
8921: oSetResult 31
8923: oPushResult
8924: oNodeGetInt
8925: oPop 2
8927: oPushResult
8928: oEmitInt
8929: oPop 1
8931: oGetParam 1
8933: oPushResult
8934: oSetResult 21
8936: oPushResult
8937: oNodeGet
8938: oPop 2
8940: oPushResult
8941: oTypeSPush
8942: oPop 1
8944: oInput 4
8946: oCall 5088
8948: oCall 7617
8950: oTypeSNodeType
8951: oChoice 8991
8953: oEmit 25
8955: oJumpForward 9013
8957: oEmit 26
8959: oJumpForward 9013
8961: oError 16
8963: oJumpForward 9013
8965: oEmit 27
8967: oJumpForward 9013
8969: oGetAddrLocal 1
8971: oPushResult
8972: oTypeSTop
8973: oPushResult
8974: oSetResult 17
8976: oPushResult
8977: oNodeGetInt
8978: oPop 2
8980: oAssign
8981: oEmit 28
8983: oGetLocal 1
8985: oPushResult
8986: oEmitInt
8987: oPop 1
8989: oJumpForward 9013
8991: Choice Lookup Table
          37   8969
          35   8969
          34   8965
          27   8961
          33   8961
          32   8957
          29   8957
          30   8957
          38   8953
          28   8953
9012: oEndChoice
9013: oTypeSPop
9014: oReturn
9015: oLocalSpace 1
9017: oInput 0
9019: oGetAddrLocal 1
9021: oPushResult
9022: oScopeFindRequire
9023: oAssign
9024: oGetAddrLocal 1
9026: oPushResult
9027: oCall 466
9029: oPop 1
9031: oGetLocal 1
9033: oPushResult
9034: oNodeType
9035: oPop 1
9037: oChoice 9041
9039: oJumpForward 9052
9041: Choice Lookup Table
          24   9039
          23   9039
          21   9039
          20   9039
9050: oError 4
9052: oGetLocal 1
9054: oPushResult
9055: oGetParam 1
9057: oPushResult
9058: oCall 9063
9060: oPop 2
9062: oReturn
9063: oLocalSpace 0
9065: oGetParam 2
9067: oPushResult
9068: oNodeType
9069: oPop 1
9071: oChoice 9153
9073: oEmit 16
9075: oGetParam 2
9077: oPushResult
9078: oCall 10393
9080: oPop 1
9082: oJumpForward 9164
9084: oEmit 17
9086: oGetParam 2
9088: oPushResult
9089: oCall 10393
9091: oPop 1
9093: oJumpForward 9164
9095: oGetParam 2
9097: oPushResult
9098: oSetResult 33
9100: oPushResult
9101: oNodeGetBoolean
9102: oPop 2
9104: oChoice 9117
9106: oEmit 8
9108: oGetParam 2
9110: oPushResult
9111: oCall 10393
9113: oPop 1
9115: oJumpForward 9129
9117: Choice Lookup Table
           1   9106
9120: oEmit 18
9122: oGetParam 2
9124: oPushResult
9125: oCall 10393
9127: oPop 1
9129: oJumpForward 9164
9131: oGetParam 1
9133: oChoice 9146
9135: oEmit 16
9137: oGetParam 2
9139: oPushResult
9140: oCall 10393
9142: oPop 1
9144: oJumpForward 9151
9146: Choice Lookup Table
           0   9135
9149: oError 4
9151: oJumpForward 9164
9153: Choice Lookup Table
          24   9131
          23   9095
          21   9084
          20   9073
9162: oError 4
9164: oGetParam 2
9166: oPushResult
9167: oSetResult 21
9169: oPushResult
9170: oNodeGet
9171: oPop 2
9173: oPushResult
9174: oTypeSPush
9175: oPop 1
9177: oCall 7314
9179: oReturn
9180: oLocalSpace 0
9182: oGetParam 1
9184: oPushResult
9185: oSetResult 1
9187: oPushResult
9188: oCall 9063
9190: oPop 2
9192: oCall 9937
9194: oGetParam 1
9196: oPushResult
9197: oCall 6523
9199: oPop 1
9201: oTypeSPop
9202: oEmit 31
9204: oEmit 25
9206: oReturn
9207: oLocalSpace 0
9209: oGetParam 1
9211: oPushResult
9212: oSetResult 1
9214: oPushResult
9215: oCall 9063
9217: oPop 2
9219: oCall 9937
9221: oGetParam 1
9223: oPushResult
9224: oCall 6523
9226: oPop 1
9228: oTypeSPop
9229: oEmit 32
9231: oEmit 25
9233: oReturn
9234: oLocalSpace 2
9236: oGetAddrLocal 1
9238: oPushResult
9239: oSetResult 0
9241: oAssign
9242: oGetAddrLocal 1
9244: oPushResult
9245: oCall 5111
9247: oPop 1
9249: oInput 42
9251: oCall 8585
9253: oInputChoice 9288
9255: oGetAddrLocal 2
9257: oPushResult
9258: oLabelNew
9259: oAssign
9260: oEmit 55
9262: oGetLocal 2
9264: oPushResult
9265: oEmitLabel
9266: oPop 1
9268: oEmit 58
9270: oGetLocal 1
9272: oPushResult
9273: oEmitLabel
9274: oPop 1
9276: oCall 8585
9278: oEmit 58
9280: oGetLocal 2
9282: oPushResult
9283: oEmitLabel
9284: oPop 1
9286: oJumpForward 9299
9288: Choice Lookup Table
          43   9255
9291: oEmit 58
9293: oGetLocal 1
9295: oPushResult
9296: oEmitLabel
9297: oPop 1
9299: oReturn
9300: oLocalSpace 4
9302: oInput 0
9304: oGetAddrLocal 1
9306: oPushResult
9307: oScopeFindRequire
9308: oAssign
9309: oGetLocal 1
9311: oPushResult
9312: oSetResult 1
9314: oPushResult
9315: oCall 9063
9317: oPop 2
9319: oCall 9937
9321: oInput 4
9323: oCall 5088
9325: oCall 9937
9327: oEmit 25
9329: oGetAddrLocal 2
9331: oPushResult
9332: oLabelNew
9333: oAssign
9334: oGetAddrLocal 3
9336: oPushResult
9337: oLabelNew
9338: oAssign
9339: oEmit 55
9341: oGetLocal 3
9343: oPushResult
9344: oEmitLabel
9345: oPop 1
9347: oGetAddrLocal 4
9349: oPushResult
9350: oLabelNew
9351: oAssign
9352: oEmit 58
9354: oGetLocal 4
9356: oPushResult
9357: oEmitLabel
9358: oPop 1
9360: oInputChoice 9440
9362: oGetLocal 1
9364: oPushResult
9365: oCall 9180
9367: oPop 1
9369: oEmit 58
9371: oGetLocal 3
9373: oPushResult
9374: oEmitLabel
9375: oPop 1
9377: oGetLocal 1
9379: oPushResult
9380: oCall 6523
9382: oPop 1
9384: oTypeSPop
9385: oCall 5088
9387: oCall 9937
9389: oEmit 42
9391: oEmit 56
9393: oGetLocal 2
9395: oPushResult
9396: oEmitLabel
9397: oPop 1
9399: oJumpForward 9446
9401: oGetLocal 1
9403: oPushResult
9404: oCall 9207
9406: oPop 1
9408: oEmit 58
9410: oGetLocal 3
9412: oPushResult
9413: oEmitLabel
9414: oPop 1
9416: oGetLocal 1
9418: oPushResult
9419: oCall 6523
9421: oPop 1
9423: oTypeSPop
9424: oCall 5088
9426: oCall 9937
9428: oEmit 43
9430: oEmit 56
9432: oGetLocal 2
9434: oPushResult
9435: oEmitLabel
9436: oPop 1
9438: oJumpForward 9446
9440: Choice Lookup Table
          46   9401
          45   9362
9445: oEndChoice
9446: oGetLocal 4
9448: oPushResult
9449: oGetLocal 2
9451: oPushResult
9452: oLoopPush
9453: oPop 2
9455: oInput 47
9457: oCall 8585
9459: oEmit 55
9461: oGetLocal 4
9463: oPushResult
9464: oEmitLabel
9465: oPop 1
9467: oEmit 58
9469: oGetLocal 2
9471: oPushResult
9472: oEmitLabel
9473: oPop 1
9475: oLoopPop
9476: oReturn
9477: oLocalSpace 3
9479: oGetAddrLocal 1
9481: oPushResult
9482: oLabelNew
9483: oAssign
9484: oEmit 58
9486: oGetLocal 1
9488: oPushResult
9489: oEmitLabel
9490: oPop 1
9492: oGetAddrLocal 2
9494: oPushResult
9495: oLabelNew
9496: oAssign
9497: oGetLocal 1
9499: oPushResult
9500: oGetLocal 2
9502: oPushResult
9503: oLoopPush
9504: oPop 2
9506: oCall 8585
9508: oInputChoice 9539
9510: oCall 8585
9512: oJumpForward 9545
9514: oGetAddrLocal 3
9516: oPushResult
9517: oCall 5111
9519: oPop 1
9521: oEmit 59
9523: oGetLocal 3
9525: oPushResult
9526: oEmitLabel
9527: oPop 1
9529: oGetLocal 1
9531: oPushResult
9532: oEmitLabel
9533: oPop 1
9535: oJumpForward 9547
9537: oJumpForward 9545
9539: Choice Lookup Table
          50   9514
           5   9510
9544: oEndChoice
9545: oJumpBack 9508
9547: oEmit 58
9549: oGetLocal 2
9551: oPushResult
9552: oEmitLabel
9553: oPop 1
9555: oLoopPop
9556: oReturn
9557: oLocalSpace 2
9559: oGetAddrLocal 1
9561: oPushResult
9562: oLabelNew
9563: oAssign
9564: oEmit 58
9566: oGetLocal 1
9568: oPushResult
9569: oEmitLabel
9570: oPop 1
9572: oGetAddrLocal 2
9574: oPushResult
9575: oCall 5111
9577: oPop 1
9579: oGetLocal 1
9581: oPushResult
9582: oGetLocal 2
9584: oPushResult
9585: oLoopPush
9586: oPop 2
9588: oInput 47
9590: oCall 8585
9592: oEmit 55
9594: oGetLocal 1
9596: oPushResult
9597: oEmitLabel
9598: oPop 1
9600: oEmit 58
9602: oGetLocal 2
9604: oPushResult
9605: oEmitLabel
9606: oPop 1
9608: oLoopPop
9609: oReturn
9610: oLocalSpace 0
9612: oLoopContinueLabel
9613: oPushResult
9614: oSetResult 0
9616: oPushResult
9617: equal_label
9618: oPop 2
9620: oChoice 9635
9622: oError 18
9624: oJumpForward 9641
9626: oEmit 55
9628: oLoopContinueLabel
9629: oPushResult
9630: oEmitLabel
9631: oPop 1
9633: oJumpForward 9641
9635: Choice Lookup Table
           0   9626
           1   9622
9640: oEndChoice
9641: oReturn
9642: oLocalSpace 0
9644: oLoopBreakLabel
9645: oPushResult
9646: oSetResult 0
9648: oPushResult
9649: equal_label
9650: oPop 2
9652: oChoice 9667
9654: oError 18
9656: oJumpForward 9673
9658: oEmit 55
9660: oLoopBreakLabel
9661: oPushResult
9662: oEmitLabel
9663: oPop 1
9665: oJumpForward 9673
9667: Choice Lookup Table
           0   9658
           1   9654
9672: oEndChoice
9673: oReturn
9674: oLocalSpace 1
9676: oInputChoice 9683
9678: oJumpForward 9689
9680: oChangeIntLitToLabelIdent
9681: oJumpForward 9689
9683: Choice Lookup Table
           1   9680
           0   9678
9688: oEndChoice
9689: oGetAddrLocal 1
9691: oPushResult
9692: oScopeCurrent
9693: oPushResult
9694: oScopeFindRequireInScope
9695: oPop 1
9697: oAssign
9698: oGetLocal 1
9700: oPushResult
9701: oSetResult 28
9703: oPushResult
9704: oSetResult 1
9706: oPushResult
9707: oNodeSetBoolean
9708: oPop 3
9710: oEmit 55
9712: oGetLocal 1
9714: oPushResult
9715: oSetResult 22
9717: oPushResult
9718: oNodeGetLabel
9719: oPop 2
9721: oPushResult
9722: oEmitLabel
9723: oPop 1
9725: oReturn
9726: oLocalSpace 0
9728: oCall 8585
9730: oInputChoice 9740
9732: oCall 8585
9734: oJumpForward 9746
9736: oJumpForward 9748
9738: oJumpForward 9746
9740: Choice Lookup Table
          36   9736
           5   9732
9745: oEndChoice
9746: oJumpBack 9730
9748: oReturn
9749: oLocalSpace 0
9751: oCall 9756
9753: oEmit 67
9755: oReturn
9756: oLocalSpace 0
9758: oInputChoice 9851
9760: oCall 5088
9762: oTypeSNodeType
9763: oChoice 9813
9765: oEmit 61
9767: oJumpForward 9832
9769: oEmit 62
9771: oJumpForward 9832
9773: oEmit 29
9775: oEmit 61
9777: oJumpForward 9832
9779: oEmit 63
9781: oJumpForward 9832
9783: oEmit 64
9785: oJumpForward 9832
9787: oError 16
9789: oJumpForward 9832
9791: oEmit 16
9793: oTypeSTop
9794: oPushResult
9795: oSetResult 41
9797: oPushResult
9798: oNodeGetInt
9799: oPop 2
9801: oPushResult
9802: oEmitInt
9803: oPop 1
9805: oEmit 66
9807: oJumpForward 9832
9809: oEmit 65
9811: oJumpForward 9832
9813: Choice Lookup Table
          34   9809
          38   9791
          27   9787
          33   9783
          32   9779
          29   9773
          30   9769
          28   9765
9830: oError 17
9832: oTypeSPop
9833: oInputChoice 9841
9835: oJumpForward 9849
9837: oJumpForward 9847
9839: oJumpForward 9847
9841: Choice Lookup Table
          13   9839
          15   9835
9846: oEndChoice
9847: oJumpBack 9760
9849: oJumpForward 9854
9851: Choice Lookup Table
          14   9760
9854: oReturn
9855: oLocalSpace 0
9857: oReturn
9858: oLocalSpace 0
9860: oReturn
9861: oLocalSpace 0
9863: oScopeCurrent
9864: oPushResult
9865: oSetResult 14
9867: oPushResult
9868: oNodeGetInt
9869: oPop 2
9871: oReturn
9872: oReturn
9873: oLocalSpace 0
9875: oGetParam 1
9877: oPushResult
9878: oSetResult 20
9880: oPushResult
9881: oNodeGet
9882: oPop 2
9884: oPushResult
9885: oSetResult 14
9887: oPushResult
9888: oNodeGetInt
9889: oPop 2
9891: oReturn
9892: oReturn
9893: oLocalSpace 0
9895: oCall 9861
9897: oPushResult
9898: oGetParam 1
9900: oPushResult
9901: oCall 9873
9903: oPop 1
9905: oPushResult
9906: subtract
9907: oPop 2
9909: oReturn
9910: oReturn
9911: oLocalSpace 1
9913: oGetAddrLocal 1
9915: oPushResult
9916: oTypeSNodeType
9917: oAssign
9918: oTypeSPop
9919: oGetLocal 1
9921: oPushResult
9922: oTypeSNodeType
9923: oPushResult
9924: equal_node_type
9925: oPop 2
9927: oChoice 9933
9929: oError 14
9931: oJumpForward 9936
9933: Choice Lookup Table
           0   9929
9936: oReturn
9937: oLocalSpace 0
9939: oTypeSNodeType
9940: oChoice 9944
9942: oJumpForward 9949
9944: Choice Lookup Table
          28   9942
9947: oError 7
9949: oTypeSPop
9950: oReturn
9951: oLocalSpace 0
9953: oTypeSNodeType
9954: oChoice 9958
9956: oJumpForward 9963
9958: Choice Lookup Table
          28   9956
9961: oError 7
9963: oReturn
9964: oLocalSpace 0
9966: oTypeSNodeType
9967: oChoice 9975
9969: oJumpForward 9982
9971: oEmit 29
9973: oJumpForward 9982
9975: Choice Lookup Table
          29   9971
          28   9969
9980: oError 7
9982: oTypeSPop
9983: oReturn
9984: oLocalSpace 0
9986: oTypeSNodeType
9987: oChoice 10002
9989: oJumpForward 10009
9991: oEmit 29
9993: oTypeSPop
9994: oGetGlobal 6
9996: oPushResult
9997: oTypeSPush
9998: oPop 1
10000: oJumpForward 10009
10002: Choice Lookup Table
          29   9991
          28   9989
10007: oError 7
10009: oReturn
10010: oLocalSpace 0
10012: oTypeSNodeType
10013: oChoice 10026
10015: oEmit 29
10017: oTypeSPop
10018: oGetGlobal 6
10020: oPushResult
10021: oTypeSPush
10022: oPop 1
10024: oJumpForward 10029
10026: Choice Lookup Table
          29   10015
10029: oReturn
10030: oLocalSpace 0
10032: oTypeSNodeType
10033: oChoice 10037
10035: oJumpForward 10042
10037: Choice Lookup Table
          30   10035
10040: oError 8
10042: oTypeSPop
10043: oReturn
10044: oLocalSpace 0
10046: oTypeSNodeType
10047: oChoice 10051
10049: oJumpForward 10056
10051: Choice Lookup Table
          30   10049
10054: oError 8
10056: oReturn
10057: oLocalSpace 1
10059: oGetAddrLocal 1
10061: oPushResult
10062: oGetParam 2
10064: oPushResult
10065: oNodeNew
10066: oPop 1
10068: oAssign
10069: oGetLocal 1
10071: oPushResult
10072: oSetResult 17
10074: oPushResult
10075: oGetParam 1
10077: oPushResult
10078: oNodeSetInt
10079: oPop 3
10081: oGetLocal 1
10083: oPushResult
10084: oTypeAdd
10085: oPop 1
10087: oGetLocal 1
10089: oReturn
10090: oReturn
10091: oLocalSpace 1
10093: oGetAddrLocal 1
10095: oPushResult
10096: oGetParam 2
10098: oPushResult
10099: oNodeNew
10100: oPop 1
10102: oAssign
10103: oGetLocal 1
10105: oPushResult
10106: oSetResult 4
10108: oPushResult
10109: oGetParam 1
10111: oPushResult
10112: oNodeSetInt
10113: oPop 3
10115: oGetLocal 1
10117: oReturn
10118: oReturn
10119: oLocalSpace 1
10121: oGetAddrLocal 1
10123: oPushResult
10124: oGetParam 1
10126: oPushResult
10127: oSetResult 35
10129: oPushResult
10130: oNodeGet
10131: oPop 2
10133: oAssign
10134: oGetLocal 1
10136: oPushResult
10137: oNodeNull
10138: oPop 1
10140: oChoice 10196
10142: oGetAddrLocal 1
10144: oPushResult
10145: oSetResult 34
10147: oPushResult
10148: oNodeNew
10149: oPop 1
10151: oAssign
10152: oGetLocal 1
10154: oPushResult
10155: oSetResult 36
10157: oPushResult
10158: oGetParam 1
10160: oPushResult
10161: oNodeSet
10162: oPop 3
10164: oGetLocal 1
10166: oPushResult
10167: oSetResult 17
10169: oPushResult
10170: oSetResult 8
10172: oPushResult
10173: oNodeSetInt
10174: oPop 3
10176: oGetLocal 1
10178: oPushResult
10179: oTypeAdd
10180: oPop 1
10182: oGetParam 1
10184: oPushResult
10185: oSetResult 35
10187: oPushResult
10188: oGetLocal 1
10190: oPushResult
10191: oNodeSet
10192: oPop 3
10194: oJumpForward 10199
10196: Choice Lookup Table
           1   10142
10199: oGetLocal 1
10201: oReturn
10202: oReturn
10203: oLocalSpace 2
10205: oGetParam 1
10207: oPushResult
10208: oNodeType
10209: oPop 1
10211: oChoice 10281
10213: oMININT
10214: oReturn
10215: oJumpForward 10297
10217: oSetResult 0
10219: oReturn
10220: oJumpForward 10297
10222: oSetResult 0
10224: oReturn
10225: oJumpForward 10297
10227: oGetAddrLocal 1
10229: oPushResult
10230: oGetParam 1
10232: oPushResult
10233: oSetResult 40
10235: oPushResult
10236: oNodeGet
10237: oPop 2
10239: oAssign
10240: oGetAddrLocal 2
10242: oPushResult
10243: oGetLocal 1
10245: oPushResult
10246: oSetResult 15
10248: oPushResult
10249: oNodeGetIter
10250: oPop 2
10252: oPushResult
10253: oNodeIterValue
10254: oPop 1
10256: oAssign
10257: oGetLocal 2
10259: oPushResult
10260: oSetResult 22
10262: oPushResult
10263: oNodeGetInt
10264: oPop 2
10266: oReturn
10267: oJumpForward 10297
10269: oGetParam 1
10271: oPushResult
10272: oSetResult 38
10274: oPushResult
10275: oNodeGetInt
10276: oPop 2
10278: oReturn
10279: oJumpForward 10297
10281: Choice Lookup Table
          36   10269
          38   10227
          32   10222
          30   10217
          28   10213
10292: oError 3
10294: oSetResult 0
10296: oReturn
10297: oReturn
10298: oLocalSpace 2
10300: oGetParam 1
10302: oPushResult
10303: oNodeType
10304: oPop 1
10306: oChoice 10376
10308: oMAXINT
10309: oReturn
10310: oJumpForward 10392
10312: oSetResult 1
10314: oReturn
10315: oJumpForward 10392
10317: oSetResult 255
10319: oReturn
10320: oJumpForward 10392
10322: oGetAddrLocal 1
10324: oPushResult
10325: oGetParam 1
10327: oPushResult
10328: oSetResult 40
10330: oPushResult
10331: oNodeGet
10332: oPop 2
10334: oAssign
10335: oGetAddrLocal 2
10337: oPushResult
10338: oGetLocal 1
10340: oPushResult
10341: oSetResult 15
10343: oPushResult
10344: oNodeGetIterLast
10345: oPop 2
10347: oPushResult
10348: oNodeIterValue
10349: oPop 1
10351: oAssign
10352: oGetLocal 2
10354: oPushResult
10355: oSetResult 22
10357: oPushResult
10358: oNodeGetInt
10359: oPop 2
10361: oReturn
10362: oJumpForward 10392
10364: oGetParam 1
10366: oPushResult
10367: oSetResult 39
10369: oPushResult
10370: oNodeGetInt
10371: oPop 2
10373: oReturn
10374: oJumpForward 10392
10376: Choice Lookup Table
          36   10364
          38   10322
          32   10317
          30   10312
          28   10308
10387: oError 3
10389: oSetResult 0
10391: oReturn
10392: oReturn
10393: oLocalSpace 0
10395: oGetParam 1
10397: oPushResult
10398: oSetResult 22
10400: oPushResult
10401: oNodeGetInt
10402: oPop 2
10404: oPushResult
10405: oEmitInt
10406: oPop 1
10408: oReturn
10409: oLocalSpace 1
10411: oGetAddrLocal 1
10413: oPushResult
10414: oSetResult 14
10416: oPushResult
10417: oGetParam 1
10419: oPushResult
10420: oCall 10091
10422: oPop 2
10424: oAssign
10425: oGetLocal 1
10427: oPushResult
10428: oScopeDeclare
10429: oPop 1
10431: oGetLocal 1
10433: oReturn
10434: oReturn
10435: oLocalSpace 1
10437: oGetAddrGlobal 4
10439: oPushResult
10440: oIdAdd_mysystem
10441: oAssign
10442: oGetAddrGlobal 5
10444: oPushResult
10445: oSetResult 27
10447: oPushResult
10448: oSetResult 4
10450: oPushResult
10451: oCall 10057
10453: oPop 2
10455: oAssign
10456: oGetAddrGlobal 6
10458: oPushResult
10459: oSetResult 28
10461: oPushResult
10462: oSetResult 4
10464: oPushResult
10465: oCall 10057
10467: oPop 2
10469: oAssign
10470: oGetAddrGlobal 7
10472: oPushResult
10473: oSetResult 30
10475: oPushResult
10476: oSetResult 1
10478: oPushResult
10479: oCall 10057
10481: oPop 2
10483: oAssign
10484: oGetAddrGlobal 8
10486: oPushResult
10487: oSetResult 31
10489: oPushResult
10490: oSetResult 1
10492: oPushResult
10493: oCall 10057
10495: oPop 2
10497: oAssign
10498: oGetAddrGlobal 9
10500: oPushResult
10501: oSetResult 32
10503: oPushResult
10504: oSetResult 1
10506: oPushResult
10507: oCall 10057
10509: oPop 2
10511: oAssign
10512: oGetAddrGlobal 10
10514: oPushResult
10515: oSetResult 29
10517: oPushResult
10518: oSetResult 1
10520: oPushResult
10521: oCall 10057
10523: oPop 2
10525: oAssign
10526: oGetAddrGlobal 11
10528: oPushResult
10529: oSetResult 33
10531: oPushResult
10532: oSetResult 256
10534: oPushResult
10535: oCall 10057
10537: oPop 2
10539: oAssign
10540: oGetAddrLocal 1
10542: oPushResult
10543: oSetResult 18
10545: oPushResult
10546: oIdAdd_File
10547: oPushResult
10548: oCall 10091
10550: oPop 2
10552: oAssign
10553: oGetLocal 1
10555: oPushResult
10556: oSetResult 21
10558: oPushResult
10559: oGetGlobal 5
10561: oPushResult
10562: oNodeSet
10563: oPop 3
10565: oGetLocal 1
10567: oPushResult
10568: oScopeDeclare
10569: oPop 1
10571: oGetAddrLocal 1
10573: oPushResult
10574: oSetResult 18
10576: oPushResult
10577: oIdAdd_Integer
10578: oPushResult
10579: oCall 10091
10581: oPop 2
10583: oAssign
10584: oGetLocal 1
10586: oPushResult
10587: oSetResult 21
10589: oPushResult
10590: oGetGlobal 6
10592: oPushResult
10593: oNodeSet
10594: oPop 3
10596: oGetLocal 1
10598: oPushResult
10599: oScopeDeclare
10600: oPop 1
10602: oGetAddrLocal 1
10604: oPushResult
10605: oSetResult 18
10607: oPushResult
10608: oIdAdd_Boolean
10609: oPushResult
10610: oCall 10091
10612: oPop 2
10614: oAssign
10615: oGetLocal 1
10617: oPushResult
10618: oSetResult 21
10620: oPushResult
10621: oGetGlobal 7
10623: oPushResult
10624: oNodeSet
10625: oPop 3
10627: oGetLocal 1
10629: oPushResult
10630: oScopeDeclare
10631: oPop 1
10633: oGetAddrLocal 1
10635: oPushResult
10636: oSetResult 18
10638: oPushResult
10639: oIdAdd_Char
10640: oPushResult
10641: oCall 10091
10643: oPop 2
10645: oAssign
10646: oGetLocal 1
10648: oPushResult
10649: oSetResult 21
10651: oPushResult
10652: oGetGlobal 9
10654: oPushResult
10655: oNodeSet
10656: oPop 3
10658: oGetLocal 1
10660: oPushResult
10661: oScopeDeclare
10662: oPop 1
10664: oGetAddrLocal 1
10666: oPushResult
10667: oSetResult 18
10669: oPushResult
10670: oIdAdd_Byte
10671: oPushResult
10672: oCall 10091
10674: oPop 2
10676: oAssign
10677: oGetLocal 1
10679: oPushResult
10680: oSetResult 21
10682: oPushResult
10683: oGetGlobal 10
10685: oPushResult
10686: oNodeSet
10687: oPop 3
10689: oGetLocal 1
10691: oPushResult
10692: oScopeDeclare
10693: oPop 1
10695: oGetAddrLocal 1
10697: oPushResult
10698: oSetResult 18
10700: oPushResult
10701: oIdAdd_String
10702: oPushResult
10703: oCall 10091
10705: oPop 2
10707: oAssign
10708: oGetLocal 1
10710: oPushResult
10711: oSetResult 21
10713: oPushResult
10714: oGetGlobal 11
10716: oPushResult
10717: oNodeSet
10718: oPop 3
10720: oGetLocal 1
10722: oPushResult
10723: oScopeDeclare
10724: oPop 1
10726: oGetAddrLocal 1
10728: oPushResult
10729: oSetResult 16
10731: oPushResult
10732: oIdAdd_True
10733: oPushResult
10734: oCall 10091
10736: oPop 2
10738: oAssign
10739: oGetLocal 1
10741: oPushResult
10742: oSetResult 21
10744: oPushResult
10745: oGetGlobal 7
10747: oPushResult
10748: oNodeSet
10749: oPop 3
10751: oGetLocal 1
10753: oPushResult
10754: oSetResult 22
10756: oPushResult
10757: oSetResult 1
10759: oPushResult
10760: oNodeSetInt
10761: oPop 3
10763: oGetLocal 1
10765: oPushResult
10766: oScopeDeclare
10767: oPop 1
10769: oGetAddrLocal 1
10771: oPushResult
10772: oSetResult 16
10774: oPushResult
10775: oIdAdd_False
10776: oPushResult
10777: oCall 10091
10779: oPop 2
10781: oAssign
10782: oGetLocal 1
10784: oPushResult
10785: oSetResult 21
10787: oPushResult
10788: oGetGlobal 7
10790: oPushResult
10791: oNodeSet
10792: oPop 3
10794: oGetLocal 1
10796: oPushResult
10797: oSetResult 22
10799: oPushResult
10800: oSetResult 0
10802: oPushResult
10803: oNodeSetInt
10804: oPop 3
10806: oGetLocal 1
10808: oPushResult
10809: oScopeDeclare
10810: oPop 1
10812: oGetAddrGlobal 12
10814: oPushResult
10815: oIdAdd_Ord
10816: oPushResult
10817: oCall 10409
10819: oPop 1
10821: oAssign
10822: oGetAddrGlobal 13
10824: oPushResult
10825: oIdAdd_Chr
10826: oPushResult
10827: oCall 10409
10829: oPop 1
10831: oAssign
10832: oGetAddrGlobal 14
10834: oPushResult
10835: oIdAdd_Pred
10836: oPushResult
10837: oCall 10409
10839: oPop 1
10841: oAssign
10842: oGetAddrGlobal 15
10844: oPushResult
10845: oIdAdd_Succ
10846: oPushResult
10847: oCall 10409
10849: oPop 1
10851: oAssign
10852: oReturn
