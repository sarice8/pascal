   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit >> int      % alloc global space for strlit, return address
   2:    oStringAllocLitFromIdent( int id ) >> int  % alloc global space for strlit taken from name of ident;
                                                    %  return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  12:    .tEnter  oEmitInt( 0 )
  20:    Label mainLabel = oLabelNew
      
  25:    .tAllocActuals  oEmitInt( 0 )
  33:    .tCall  oEmitLabel( mainLabel )
  41:    .tFreeActuals  oEmitInt( 0 )
  49:    .tReturn
      
  51:    pProgram
  53:    pIdent
      
  55:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  71:    oScopeDeclare( progDecl )
      
  77:    [
  77:       | '(' :
  79:          pIdent      % input, output files
      
  81:          t = @newIdent( nVar, kVar, LAST_ID )
  97:          oNodeSet( t, qType, FileType )
 109:          oScopeDeclareAlloc( t )
      
 115:          ','
 117:          pIdent
      
 119:          t = @newIdent( nVar, kVar, LAST_ID )
 135:          oNodeSet( t, qType, FileType )
 147:          oScopeDeclareAlloc( t )
      
 153:          ')'
 155:       | * :
 160:    ]
 160:    ';'
      
 162:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 169:    oScopeBegin
 170:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 181:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 192:    @BlockStmt( mainLabel )
      
 199:    oScopeEnd   % main routine scope
      
 200:    '.'
 202:    oScopeEnd   % global scope
 204:    ;
      
      
 204: Block( node_type varNodeType, Label labelForBody ):
 206:    @BlockDecls( varNodeType )
 213:    @BlockStmt( labelForBody )
 221:    ;
      
      
 221: BlockDecls( node_type varNodeType ):
 223:    {[
 223:       | pConst :     @ConstDecl
 227:       | pType :      @TypeDecl
 231:       | pVar :       @VarDecl( varNodeType )
 240:       | pProcedure : @ProcDecl
 244:       | pFunction :  @FuncDecl
 248:       | * :          >
 263:    ]}
 265:    @CheckForUndefinedMethods
 268:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 268: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 271:    ;
      
      
      
 271: BlockStmt( Label labelForBody ):
 273:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 281:    int patchLS
 281:    .tEnter  patchLS = Here  .tSpace
      
 290:    @Statement
 292:    .tReturn
      
 294:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 306:    oPatch( patchLS, localSpace )
 316:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 316: MethodModifiers( Node decl ):
 318:    {[
 318:       | pCdecl :
 320:          oNodeSetBoolean( decl, qCdecl, true )
 332:          ';'
      
 334:       | * : >
 341:    ]}
 344:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 344: ExternalDecl( Node decl ):
 346:    oNodeSetBoolean( decl, qExternal, true )
 358:    [
 358:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 360:          [
 360:             | pName :
 362:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
                     % TO DO: I'm currently ignoring this.
                     %        Unfortunately my schema system doesn't support string fields yet!
 364:             | * :
 369:          ]
 369:       | * :
 374:    ]
 375:    ;
      
      
 375: ProcDecl:
 377:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 379:    boolean redeclaring = false
 385:    Node decl = oScopeFindInCurrentScope
      
 390:    [ oNodeNull( decl )
 397:       | true :
               % first declaration
 398:          decl = @newIdent( nProc, kProc, LAST_ID )
 414:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 425:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 427:          redeclaring = true
 433:          [ oNodeGetBoolean( decl, qBodyDefined )
 443:             | true : #eAlreadyDefined
 446:             | * :
 451:          ]
 451:          [ oNodeGetBoolean( decl, qExternal )
 461:             | true : #eAlreadyDefined
 464:             | * :
 469:          ]
 469:          [ oNodeType( decl )
 476:             | nProc :
 477:             | * : #eAlreadyDefined   % wrong kind
 484:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 484:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 503:          oNodeSet( decl, qParams, Null )
 515:    ]
      
 523:    oScopeBegin
 524:    Node paramScope = oScopeCurrent
      
 529:    @FormalArgDecl
 531:    oNodeSet( decl, qParams, paramScope )
 543:    oScopeEnd
 544:    ';'
      
 546:    [ redeclaring
 549:       | false : oScopeDeclare( decl )
 556:       | true :  % TO DO: check that qParams is consistent with qOldParams
 558:    ]
      
 566:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 573:    [
 573:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 575:       | pExternal : @ExternalDecl( decl )
      
 584:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 591:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 597:          oScopeBegin
 598:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 609:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 620:          Label label = oNodeGetLabel( decl, qValue )
 633:          @Block( nLocalVar, label )
 643:          oNodeSetBoolean( decl, qBodyDefined, true )
 655:          oScopeEnd
      
 656:          oScopeEnd  % paramScope
 657:    ]
 657:    ';';
      
      
 660: FuncDecl:
 662:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 664:    boolean redeclaring = false
 670:    Node decl = oScopeFindInCurrentScope
      
 675:    [ oNodeNull( decl )
 682:       | true :
               % first declaration
 683:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 699:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 710:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 712:          redeclaring = true
 718:          [ oNodeGetBoolean( decl, qBodyDefined )
 728:             | true : #eAlreadyDefined
 731:             | * :
 736:          ]
 736:          [ oNodeType( decl )
 743:             | nFunc :
 744:             | * : #eAlreadyDefined   % wrong kind
 751:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 751:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 770:          oNodeSet( decl, qParams, Null )
 782:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 801:          oNodeSet( decl, qType, Null )
 813:    ]
      
 821:    oScopeBegin
 822:    Node paramScope = oScopeCurrent
      
 827:    @FormalArgDecl
 829:    oNodeSet( decl, qParams, paramScope )
      
 841:    ':'
      
 843:    Node theType
 843:    @TypeRef( theType )
 850:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 862:    Node ptrType = @PointerTypeTo( theType )
 873:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
 889:    oScopeEnd
 890:    ';'
      
 892:    [ redeclaring
 895:       | false : oScopeDeclare( decl )
 902:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
 904:    ]
      
 912:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
 919:    [
 919:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 921:       | pExternal : @ExternalDecl( decl )
      
 930:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 937:          oScopeEnter( paramScope )
      
 943:          oScopeBegin
 944:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 955:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 966:          Label label = oNodeGetLabel( decl, qValue )
 979:          @Block( nLocalVar, label )
 989:          oNodeSetBoolean( decl, qBodyDefined, true )
1001:          oScopeEnd
      
1002:          oScopeEnd  % paramScope
1003:    ]
1003:    ';';
      
      
1006: FormalArgDecl:
1008:    [
1008:       | '(' :
1010:          {
1010:             NodeVec decls = oNodeVecNew
1015:             Node decl
1015:             boolean isInOut = false
      
1021:             [
1021:                | pVar : isInOut = true
1029:                | * :
1034:             ]
      
1034:             {  pIdent
      
1036:                decl = @newIdent( nParam, kVar, LAST_ID )
1052:                oNodeSetBoolean( decl, qInOut, isInOut )
1064:                oNodeVecAppend( decls, decl )
      
1073:                [
1073:                   | ':' : >
1077:                   | ',' :
1079:                ]
1087:             }
      
1089:             Node theType
1089:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1096:             Node allocType
1096:             [ isInOut
1099:                | true :   allocType = @PointerTypeTo( theType )
1111:                | * :      allocType = theType
1122:             ]
      
1122:             int i = 0
1128:             {[ equal( i, oNodeVecSize( decls ) )
1142:                | false :
1143:                   decl = oNodeVecElement( decls, i )
      
1156:                   oNodeSet( decl, qType, theType )
1168:                   oScopeDeclare( decl )
1174:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1190:                   inc( i )
1196:                | * :
1201:                   >
1203:             ]}
      
1205:             oNodeVecDelete( decls )
      
1211:             [
1211:                | ')' : >
1215:                | ';' :
1217:             ]
1225:          }
1227:       | * :
1232:    ];
      
1233: ConstDecl:
1235:    {[
1235:       | pIdent :
1237:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1253:          '='
      
1255:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1257:          int val = oValueTop
1262:          oValuePop
1263:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1275:          oNodeSet( decl, qType, IntegerType )
      
1287:          oScopeDeclare( decl )
1293:          ';'
1295:       | * :
1300:          >
1302:    ]};
      
1305: TypeDecl:
1307:    {[
1307:       | pIdent :
1309:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1325:          '='
1327:          Node theType
1327:          @TypeRef( theType )
1334:          oNodeSet( decl, qType, theType )
1346:          oScopeDeclare( decl )
1352:          ';'
1354:       | * :
1359:          >
1361:    ]};
      
1364: VarDecl( node_type varNodeType ):
1366:    {[
1366:       | pIdent :
1368:          NodeVec decls = oNodeVecNew
1373:          Node decl
1373:          {
1373:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1389:             oNodeVecAppend( decls, decl )
1398:             [
1398:                | ',' :
1400:                   pIdent
1402:                | * :
1407:                   >
1409:             ]
1409:          }
1411:          ':'
1413:          Node theType
1413:          @TypeRef( theType )
      
1420:          int i = 0
1426:          {[ equal( i, oNodeVecSize( decls ) )
1440:            | false :
1441:              decl = oNodeVecElement( decls, i )
1454:              oNodeSet( decl, qType, theType )
1466:              oScopeDeclareAlloc( decl )
1472:              inc( i )
1478:             | * :
1483:               >
1485:          ]}
      
1487:          oNodeVecDelete( decls )
1493:          ';'
1495:       | * :
1500:          >
1502:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1505: TypeRef( out Node resultType ):
1507:    [
1507:       | pIdent :           % previously named type (including intrinsics)
1509:          Node decl = oScopeFindRequire
1514:          [ oNodeType( decl )
1521:            | nTypeDecl :
1522:                resultType = oNodeGet( decl, qType )
1535:            | * :
1540:                #eNotType
1542:                resultType = IntegerType
1548:          ]
         
1548:       | pArray :
1550:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1552:          NodeVec dimensions = oNodeVecNew
      
1557:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1557:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1567:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1579:             @ConstExpr
1581:             oNodeSetInt( subrange, qLow, oValueTop )
1592:             oValuePop
1593:             '..'
1595:             @ConstExpr
1597:             oNodeSetInt( subrange, qHigh, oValueTop )
1608:             oValuePop
1609:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1621:             oTypeAdd( subrange )
      
1627:             Node a = oNodeNew( nArrayType )
1637:             oNodeSet( a, qIndexType, subrange )
      
1649:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1658:             [
1658:                | ']' : >
1662:                | ',' :
1664:             ]
1672:          }
      
1674:          pOf
1676:          Node baseType
1676:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1683:          int dim = oNodeVecSize( dimensions )
      
1693:          {
1693:              dec(dim)
      
1699:              Node a = oNodeVecElement( dimensions, dim )
      
1712:              oNodeSet( a, qBaseType, baseType )
1724:              Node subrange = oNodeGet( a, qIndexType )
1737:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1764:              inc( width )
1770:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1796:              oTypeAdd( a )
1802:              baseType = a
      
1808:              [ equal_zero(dim)
1815:                  | true:  >
1818:                  | *:
1823:              ]
1823:          }
      
1825:          resultType = oNodeVecElement( dimensions, 0 )
1838:          oNodeVecDelete( dimensions )
      
1844:       | '^' :
1846:          Node theType
1846:          @TypeRef( theType )
1853:          resultType = @PointerTypeTo( theType )
      
1864:       | pRecord :
1866:          resultType = oNodeNew( nRecordType )
1876:          oScopeBegin
      
1877:          @VarDecl( nRecordField )
      
1884:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1896:          [ equal_zero( size )
1903:             | true : #eRecordEmpty
1906:             | * :
1911:          ]
      
1911:          pEnd
      
1913:          oNodeSet( resultType, qScope, oScopeCurrent )
1924:          oNodeSetInt( resultType, qSize, size )
1936:          oScopeEnd
1937:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1943:       | pSet :
1945:          pOf
1947:          Node theType
1947:          @TypeRef( theType )
1954:       | * :       % this works for cases except where expr starts with an id
1967:          @ConstExpr '..' @ConstExpr
1973:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1974: ConstExpr:
1976:    [
1976:       | pIntLit :
1978:          oValuePush( TOKEN_VALUE )
1983:       | pIdent :
1985:          Node decl = oScopeFindRequire
1990:          [ oNodeType( decl )
1997:             | nConst :
1998:                oValuePush( oNodeGetInt( decl, qValue ) )
2011:             | * :
2016:                #eNotConst
2018:                oValuePush( 0 )
2024:          ]
2024:       | pMinus :
2026:          @ConstExpr
2028:          oValueNegate
2029:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2040: Expr:
2042:    Label falseLabel = labelNull
      
2048:    @ExprAllowCF( falseLabel )
2055:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2063: BooleanExprControlFlow( out Label falseLabel ):
2065:    @ExprAllowCF( falseLabel )
2072:    [ oTypeSNodeType
2074:       | nBooleanCFType :
2075:       | nBooleanType :
               % convert value to control flow
2077:          falseLabel = oLabelNew
2082:          .tJumpFalse  oEmitLabel( falseLabel )
2090:       | * :
2097:          #eNotBoolean
2099:    ]
2099:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2101: CFToVal( inout Label falseLabel ):
2103:    [ oTypeSNodeType
2105:       | nBooleanCFType :
2106:          Label doneLabel = oLabelNew
2111:          .tPushConstI  oEmitInt( 1 )
2119:          .tJump  oEmitLabel( doneLabel )
2127:          .tLabel  oEmitLabel( falseLabel )
2135:          .tPushConstI  oEmitInt( 0 )
2143:          .tLabel  oEmitLabel( doneLabel )
2151:          oTypeSPop
2152:          oTypeSPush( BooleanType )
2158:          falseLabel = labelNull
2164:       | * :
2169:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2170: ValToCF( out Label falseLabel ):
2172:    [ oTypeSNodeType
2174:       | nBooleanType :
2175:          falseLabel = oLabelNew
2180:          .tJumpFalse  oEmitLabel( falseLabel )
2188:          oTypeSPop
2189:          oTypeSPush( BooleanCFType )
2195:       | * :
2200:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2201: ExprAllowCF( out Label falseLabel ):
2203:    @BoolExprAllowCF( falseLabel )
2210:    {[
2210:       | '=' :
2212:          @CFToVal( falseLabel )
2219:          @BoolExprAllowCF( falseLabel )
2226:          @CFToVal( falseLabel )
2233:          @MatchTypes
2235:          [ oTypeSNodeType
2237:             | nIntegerType, nBooleanType :  .tEqualI
2240:             | nPointerType :                .tEqualP
2244:             | nCharType, nStringType :      #eNotImplemented
2248:             | * :                           #eNotAllowed
2263:          ]
2263:          oTypeSPop
2264:          oTypeSPush( BooleanType )
      
2270:       | '<>' :
2272:          @CFToVal( falseLabel )
2279:          @BoolExprAllowCF( falseLabel )
2286:          @CFToVal( falseLabel )
2293:          @MatchTypes
2295:          [ oTypeSNodeType
2297:             | nIntegerType, nBooleanType :  .tNotEqualI
2300:             | nPointerType :                .tNotEqualP
2304:             | nCharType, nStringType :      #eNotImplemented
2308:             | * :                           #eNotAllowed
2323:          ]
2323:          oTypeSPop
2324:          oTypeSPush( BooleanType )
      
2330:       | '<' :
2332:          @CFToVal( falseLabel )
2339:          @BoolExprAllowCF( falseLabel )
2346:          @CFToVal( falseLabel )
2353:          @MatchTypes
2355:          [ oTypeSNodeType
2357:             | nIntegerType, nBooleanType :  .tLessI
2360:             | nCharType, nStringType :      #eNotImplemented
2364:             | * :                           #eNotAllowed
2377:          ]
2377:          oTypeSPop
2378:          oTypeSPush( BooleanType )
      
2384:       | '>' :
2386:          @CFToVal( falseLabel )
2393:          @BoolExprAllowCF( falseLabel )
2400:          @CFToVal( falseLabel )
2407:          @MatchTypes
2409:          [ oTypeSNodeType
2411:             | nIntegerType, nBooleanType :  .tGreaterI
2414:             | nCharType, nStringType :      #eNotImplemented
2418:             | * :                           #eNotAllowed
2431:          ]
2431:          oTypeSPop
2432:          oTypeSPush( BooleanType )
      
2438:       | '<=' :
2440:          @CFToVal( falseLabel )
2447:          @BoolExprAllowCF( falseLabel )
2454:          @CFToVal( falseLabel )
2461:          @MatchTypes
2463:          [ oTypeSNodeType
2465:             | nIntegerType, nBooleanType :  .tLessEqualI
2468:             | nCharType, nStringType :      #eNotImplemented
2472:             | * :                           #eNotAllowed
2485:          ]
2485:          oTypeSPop
2486:          oTypeSPush( BooleanType )
      
2492:       | '>=' :
2494:          @CFToVal( falseLabel )
2501:          @BoolExprAllowCF( falseLabel )
2508:          @CFToVal( falseLabel )
2515:          @MatchTypes
2517:          [ oTypeSNodeType
2519:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2522:             | nCharType, nStringType :      #eNotImplemented
2526:             | * :                           #eNotAllowed
2539:          ]
2539:          oTypeSPop
2540:          oTypeSPush( BooleanType )
      
2546:       | * :
2561:          >
2563:    ]};
      
      
2566: BoolExprAllowCF( out Label falseLabel ):
2568:    Label trueLabel = labelNull
      
2574:    @BoolTermAllowCF( falseLabel )
2581:    {[
2581:       | pOr :
2583:          [ oTypeSNodeType
2585:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2586:                [ equal_label( trueLabel, labelNull )
2596:                   | true :  trueLabel = oLabelNew
2602:                   | * :
2607:                ]
2607:                .tJump  oEmitLabel( trueLabel )
2615:             | nBooleanType :
2617:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2624:                [ equal_label( trueLabel, labelNull )
2634:                   | true :  trueLabel = oLabelNew
2640:                   | * :
2645:                ]
2645:                .tJump  oEmitLabel( trueLabel )
2653:             | * : #eNotBoolean
2662:          ]
2662:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2663:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2671:          falseLabel = labelNull
2677:          @BoolTermAllowCF( falseLabel )
      
2684:          [ oTypeSNodeType
2686:             | nBooleanCFType :
2687:             | nBooleanType :
2689:                @ValToCF( falseLabel )
2696:             | * : #eNotBoolean
2705:          ]
      
2705:          oTypeSPop
2706:          oTypeSPush( BooleanCFType )
      
2712:       | * :
2717:          >
2719:    ]}
      
         % any short-circuit trues jump here to the end
2721:    [ equal_label( trueLabel, labelNull )
2731:       | false :
2732:          .tLabel  oEmitLabel( trueLabel )
2740:       | * :
2745:    ]
2746:    ;
      
      
2746: BoolTermAllowCF( out Label falseLabel ):
2748:    Label overallFalseLabel = labelNull
      
2754:    @BoolFactorAllowCF( falseLabel )
2761:    {[
2761:       | pAnd :
2763:          [ oTypeSNodeType
2765:             | nBooleanCFType :
2766:             | nBooleanType :
2768:                @ValToCF( falseLabel )
2775:             | * :
2782:                #eNotBoolean
2784:          ]
2784:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
2785:          [ equal_label( overallFalseLabel, labelNull )
2795:             | true :
2796:                overallFalseLabel = oLabelNew
2801:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
2815:                falseLabel = overallFalseLabel
2821:             | * :
2826:          ]
      
2826:          Label factorFalseLabel = labelNull
2832:          @BoolFactorAllowCF( factorFalseLabel )
      
2839:          [ oTypeSNodeType
2841:             | nBooleanCFType :
2842:             | nBooleanType :
2844:                @ValToCF( factorFalseLabel )
2851:             | * : #eNotBoolean
2860:          ]
2860:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
2874:       | * :
2879:          >
2881:    ]};
      
2884: BoolFactorAllowCF( out Label falseLabel ):
2886:    [
2886:       | pNot :
2888:          Label factorFalseLabel = labelNull
      
2894:          @BoolFactorAllowCF( factorFalseLabel )
2901:          [ oTypeSNodeType
2903:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
2904:                falseLabel = oLabelNew
2909:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
2917:                .tLabel  oEmitLabel( factorFalseLabel )
      
2925:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
2927:                .tNot
      
2929:             | * : #eNotBoolean
2938:          ]
      
2938:       | * :
2943:          @ArithExprAllowCF( falseLabel )
2950:    ];
      
2951: ArithExprAllowCF( out Label falseLabel ):
2953:    @TermAllowCF( falseLabel )
2960:    {[
2960:       | pPlus :
2962:          @RequireIntPop
2964:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
2971:          @RequireInt
2973:          .tAddI
2975:       | pMinus :
2977:          @RequireIntPop
2979:          @TermAllowCF( falseLabel )
2986:          @RequireInt
2988:          .tSubI
2990:       | * :
2997:          >
2999:    ]};
      
3002: TermAllowCF( out Label falseLabel ):
3004:    @FactorAllowCF( falseLabel )
3011:    {[
3011:       | pTimes :
3013:          @RequireIntPop
3015:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3022:          @RequireInt
3024:          .tMultI
3026:       | pDivide :
3028:          @RequireIntPop
3030:          @FactorAllowCF( falseLabel )
3037:          @RequireInt
3039:          .tDivI
3041:       | * :
3048:          >
3050:    ]};
      
3053: FactorAllowCF( out Label falseLabel ):
3055:    [
3055:       | pPlus :
3057:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3064:          @RequireInt
3066:       | pMinus :
3068:          @PrimaryAllowCF( falseLabel )
3075:          @RequireInt
3077:          .tNegI
3079:       | * :
3086:          @PrimaryAllowCF( falseLabel )
3093:    ];
      
3094: PrimaryAllowCF( out Label falseLabel ):
3096:    [
3096:       | pIntLit :
3098:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3105:          oTypeSPush( IntegerType )
      
3111:       | '(' :
3113:          @ExprAllowCF( falseLabel )
3120:          ')'
      
3122:       | pStrLit :
3124:          int addr = oStringAllocLit     % store in global data
3129:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3137:          oTypeSPush( StringType )
      
3143:       | pIdent :
3145:          Node decl = oScopeFindRequire
3150:          Node theType
      
3150:          [ oNodeType( decl )
3157:             | nFunc :
      
3158:                @Call( decl )
      
3165:             | nConst :
3167:                theType = oNodeGet( decl, qType )
3180:                oTypeSPush( theType )
3186:                [ oTypeSNodeType
3188:                   | nIntegerType, nBooleanType :
3189:                      .tPushConstI @EmitValue( decl )
3198:                   | * :
3205:                      #eNotImplemented
3207:                ]
      
3207:             | nGlobalVar, nLocalVar, nParam :
3209:                @VarExpr( decl )
      
3216:             | * :
3229:                #eNotValue
3231:                oTypeSPush( IntegerType )
3237:          ]
      
3237:       | '@' :        % @var -- pointer to var
3239:          pIdent
      
3241:          Node decl = oScopeFindRequire
3246:          Node theType
      
3246:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3253:          theType = oTypeSTop
3258:          oTypeSPop
3259:          Node ptrType = @PointerTypeTo( theType )
3270:          oTypeSPush( ptrType )
      
3276:       | * :
3289:          #eNotValue
3291:          oTypeSPush( IntegerType )
3297:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3298: VarExpr( Node decl ):
3300:    Node theType = oNodeGet( decl, qType )
3313:    oTypeSPush( theType )
3319:    [ oTypeSNodeType
3321:       | nIntegerType :
3322:          [ oNodeType( decl )
3329:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
3339:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
3350:             | nParam :
3352:                [ oNodeGetBoolean( decl, qInOut )
3362:                   | true :    % VAR param points to the var.  Auto dereference.
3363:                               .tPushParamP @EmitValue( decl )
3372:                               .tFetchI
3374:                   | * :       .tPushParamI @EmitValue( decl )
3388:                ]
3388:          ]
      
3398:       | nBooleanType :
3400:          [ oNodeType( decl )
3407:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
3417:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
3428:             | nParam :
3430:                [ oNodeGetBoolean( decl, qInOut )
3440:                   | true :    % VAR param points to the var.  Auto derefernce.
3441:                               .tPushParamP @EmitValue( decl )
3450:                               .tFetchB
3452:                   | * :       .tPushParamB @EmitValue( decl )
3466:                ]
3466:          ]
      
3476:       | nCharType, nStringType, nFileType :
3478:          #eNotImplemented
      
3480:       | nPointerType :
3482:          [ oNodeType( decl )
3489:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3499:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
3510:             | nParam :
3512:                [ oNodeGetBoolean( decl, qInOut )
3522:                   | true :    % VAR param points to the var.  Auto derefernce.
3523:                               .tPushParamP @EmitValue( decl )
3532:                               .tFetchP
3534:                   | * :       .tPushParamP @EmitValue( decl )
3548:                ]
3548:          ]
3558:          [
3558:             | '^' :             % dereferenced
3560:                oTypeSPop
3561:                oTypeSPush( oNodeGet( theType, qBaseType ) )
3574:                @LValueIndexes
3576:                @FetchVar
3578:             | * :               % just ptr value alone
3583:          ]
      
3583:       | * :
               % compound type
               % first, push addr of start of var
3598:          [ oNodeType( decl )
3605:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3615:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3626:             | nParam :
3628:                [ oNodeGetBoolean( decl, qInOut )
3638:                   | true :    % VAR param points to the var.  Auto derefernce.
3639:                               .tPushParamP @EmitValue( decl )
3648:                   | * :       .tPushAddrParam @EmitValue( decl )
3662:                ]
3662:          ]
               % modify addr for subscripts, field references, etc
3672:          @LValueIndexes
               % get final value
3674:          @FetchVar
3676:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
3677: FetchVar:
3679:    [ oTypeSNodeType
3681:       | nIntegerType :   .tFetchI
3684:       | nBooleanType :   .tFetchB
3688:       | nCharType, nStringType, nFileType : #eNotImplemented
3692:       | nPointerType :   .tFetchP
3696:       | * :              % compound type; leave as addr
3711:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
3712: LValueIndexes:
3714:    {[
3714:       | '[' :       @ArraySubscripts
3718:       | '.' :       @RecordFieldRef
3722:       | '^' :       @PointerDeref
3726:       | * :         >
3737:    ]};
      
3740: ArraySubscripts:
3742:    [ oTypeSNodeType
3744:       | nArrayType :
3745:       | * :       #eNotArray
3752:    ]
3752:    {
3752:       [ oTypeSNodeType
3754:          | nArrayType :
3755:          | * :    #eTooManySubscripts
3762:       ]
      
            % low subscript of this dimension
3762:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
3779:       Node baseType
3779:       baseType = oNodeGet( oTypeSTop, qBaseType )
3791:       oTypeSPop
3792:       oTypeSPush( baseType )
      
3798:       @Expr
3800:       @RequireIntPop
            % adjust for low subscript
3802:       [ equal_zero( low )
3809:          | false :
3810:             .tPushConstI oEmitInt( low ) .tSubI
3820:          | * :
3825:       ]
      
            % multiply by element size
3825:       int size = oNodeGetInt( baseType, qSize )
3838:       [ equal( size, 1 )
3848:          | false :
3849:             .tPushConstI oEmitInt( size ) .tMultI
3859:          | * :
3864:       ]
      
            % update start address
3864:       .tAddPI
3866:       [
3866:          | ']' :  >
3870:          | ',' :
3872:       ]
3880:    };
      
      
3883: RecordFieldRef:
3885:    [ oTypeSNodeType
3887:       | nRecordType :
3888:       | * :    #eNotRecord
3895:    ]
3895:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
3907:    pIdent
3909:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
3914:    [ oNodeType( field )
3921:       | nRecordField :
3922:       | * :   #eNotRecordField
3929:    ]
3929:    oScopeEnd
3930:    int offset = oNodeGetInt( field, qValue )
3943:    [ equal_zero( offset )
3950:       | false :
3951:          .tPushConstI oEmitInt( offset ) .tAddPI
3961:       | * :
3966:    ]
      
         % replace the type on the type stack, with the field type
3966:    oTypeSPop
3967:    oTypeSPush( oNodeGet( field, qType ) )
3981:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
3981: PointerDeref:
3983:    [ oTypeSNodeType
3985:       | nPointerType :
3986:       | * :       #eNotPointer
3993:    ]
3993:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
3995:    Node theType = oTypeSTop
4000:    oTypeSPop
4001:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4015:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4015: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4017:    @MatchTypes
4020:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4020: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4022:    [ oNodeGetBoolean( method, qExternal )
4032:       | true :
4033:          [ oNodeGetBoolean( method, qCalled )
4043:             | false :
                     % define the label as extern
4044:                int strAddr = oStringAllocLitFromIdent( oNodeGetInt( method, qIdent ) )
4061:                .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4076:             | * :
4081:          ]
4081:      | * :
4086:    ]
4086:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4098:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4111:    Node resultType
4111:    int tempOffset
      
4111:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4128:    [ isFunc
4131:       | true :
4132:          resultType = oNodeGet( method, qType )
4145:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4155:       | * :
4160:    ]
         
      
4160:    Node paramScope = oNodeGet( method, qParams )
4173:    int actualsSize = oNodeGetInt( paramScope, qSize )
4186:    [ cdecl
4189:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4198:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4208:    ]
      
4216:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4229:    Node param = oNodeIterValue( paramIter )
4239:    [
4239:       | '(' :
            
4241:          {
4241:             [ oNodeNull( param )
4248:                | true : >
4251:                | * :
4256:             ]
      
4256:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4269:             .tPushAddrActual oEmitInt( offset )
4277:             oTypeSPush( oNodeGet( param, qType ) )
      
4290:             [ oNodeGetBoolean( param, qInOut )
4300:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
4301:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
4303:                           @MatchTypes
      
4305:                           .tAssignP
      
4307:                | false :  @Expr
4311:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
4313:                           [ oTypeSNodeType
4315:                              | nIntegerType :            .tAssignI
4318:                              | nBooleanType :            .tAssignB
4322:                              | nCharType, nStringType, nFileType :   #eNotImplemented
4326:                              | nPointerType :            .tAssignP
4330:                              | * :
                                       % compound types: copy value into actuals space
4345:                                  int size = oNodeGetInt( oTypeSTop, qSize )
4357:                                  .tCopy  oEmitInt( size )    % multi-word copy
4365:                           ]
4365:             ]
4373:             oTypeSPop
      
4374:             oNodeIterNext( paramIter )
4380:             param = oNodeIterValue( paramIter )
4390:             [ oNodeNull( param )
4397:                | true :  >
4400:                | false :
4402:             ]
      
4410:             ','
4412:          }
      
4414:          ')'
      
4416:       | * :
4421:    ]
      
4421:    [ oNodeNull( param )
4428:       | false :    #eMissingParameter
4431:       | * :
4436:    ]
      
4436:    [ isFunc
4439:       | true :
               % Pass result temp as an additional VAR parameter.
4440:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
4455:          .tPushAddrLocal  oEmitInt( tempOffset )
4463:          .tAssignP
4465:       | * :
4470:    ]
      
4470:    [ cdecl
4473:       | true :
4474:          .tCallCdecl  @EmitValue( method )
4483:       | false :
4485:          .tCall   @EmitValue( method )
4494:    ]
      
4502:    [ isFunc
4505:       | true :
               % push return value from temp
4506:          oTypeSPush( resultType )
      
4512:          [ oTypeSNodeType
4514:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
4523:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
4533:             | nCharType, nStringType, nFileType : #eNotImplemented
4537:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
4547:             | * :              % compound type: push address
4562:                                .tPushAddrLocal  oEmitInt( tempOffset )
4570:          ]
4570:       | * :
4575:    ]
         
4575:    .tFreeActuals  oEmitInt( actualsSize )
4584:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
4584: Statement:
4586:    [
4586:       | pWriteln :     @WritelnStmt
4590:       | pWrite :       @WriteStmt
4594:       | pReadln :      @ReadlnStmt
4598:       | pRead :        @ReadStmt
4602:       | pIf :          @IfStmt
4606:       | pWhile :       @WhileStmt
4610:       | pFor :         @ForStmt
4614:       | pRepeat :      @RepeatStmt
4618:       | pBreak :       @BreakStmt
4622:       | pContinue :    @ContinueStmt
4626:       | pBegin :       @BeginStmt
4630:       | pIdent :       @AssignOrCallStmt
4634:       | * :            % null statement : don't accept any tokens
4661:    ];
      
      
4662: AssignOrCallStmt:
4664:    Node decl = oScopeFindRequire
4669:    [ oNodeType( decl )
4676:       | nProc :                           @Call( decl )
4684:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
4693:       | nFunc :                           @AssignResultStmt( decl )
4702:       | * :                               #eBadStatement
4717:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
4718: AssignStmt( Node decl ):
      
4720:    @LValueVar( decl )
      
4727:    ':=' 
4729:    @Expr
4731:    @MatchTypes
4733:    [ oTypeSNodeType
4735:       | nIntegerType :            .tAssignI
4738:       | nBooleanType :            .tAssignB
4742:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4746:       | nPointerType :            .tAssignP
4750:       | * :
4765:           int size = oNodeGetInt( oTypeSTop, qSize )
4777:           .tCopy  oEmitInt( size )    % multi-word copy
4785:    ]
4785:    oTypeSPop
4787:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
4787: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
4789:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
4805:       | false :   #eNotCurrentFunction
4808:       | * :
4813:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
4813:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
4828:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
4841:    ':='
4843:    @Expr
4845:    @MatchTypes
4847:    [ oTypeSNodeType
4849:       | nIntegerType :            .tAssignI
4852:       | nBooleanType :            .tAssignB
4856:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
4860:       | nPointerType :            .tAssignP
4864:       | * :
4879:           int size = oNodeGetInt( oTypeSTop, qSize )
4891:           .tCopy  oEmitInt( size )    % multi-word copy
4899:    ]
4899:    oTypeSPop
4901:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
4901: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
4903:    pIdent
4905:    Node decl = oScopeFindRequire
4910:    [ oNodeType( decl )
4917:       | nGlobalVar, nLocalVar, nParam :
4918:       | * :  #eNotVar
4929:    ]
4929:    @LValueVar( decl )
4937:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
4937: LValueVar( Node decl ):
4939:    [ oNodeType( decl )
4946:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4956:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
4967:       | nParam :
4969:          [ oNodeGetBoolean( decl, qInOut )
4979:             | true :   % VAR param points to variable.  No dereference.
4980:                        .tPushParamP @EmitValue( decl )
4989:             | * :      .tPushAddrParam @EmitValue( decl )
5003:          ]
5003:       | * :            #eNotVar
5014:    ]
      
5014:    oTypeSPush( oNodeGet( decl, qType ) )
5027:    @LValueIndexes        % handle subscripts, if any
5030:    ;
      
      
5030: IncVar( Node decl ):
5032:    @LValueVar( decl )
5039:    @RequireIntPop
5041:    @VarExpr( decl )
5048:    oTypeSPop
5049:    .tIncI
5051:    .tAssignI;
      
5054: DecVar( Node decl ):
5056:    @LValueVar( decl )
5063:    @RequireIntPop
5065:    @VarExpr( decl )
5072:    oTypeSPop
5073:    .tDecI
5075:    .tAssignI;
      
      
5078: IfStmt:
5080:    Label falseLabel = labelNull
      
5086:    @BooleanExprControlFlow( falseLabel )
5093:    pThen
5095:    @Statement
5097:    [
5097:       | pElse :
5099:          Label doneLabel = oLabelNew
      
5104:          .tJump  oEmitLabel( doneLabel )
5112:          .tLabel oEmitLabel( falseLabel )
5120:          @Statement
5122:          .tLabel oEmitLabel( doneLabel )
      
5130:       | * :
5135:          .tLabel oEmitLabel( falseLabel )
5143:    ];
      
      
5144: ForStmt:
5146:    pIdent
      
5148:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5153:    @LValueVar( decl )
5160:    @RequireIntPop
      
5162:    ':='
      
5164:    @Expr
5166:    @RequireIntPop
5168:    .tAssignI
      
5170:    Label breakLabel = oLabelNew
      
5175:    Label checkLabel = oLabelNew
5180:    .tJump  oEmitLabel( checkLabel )
      
5188:    Label continueLabel = oLabelNew
5193:    .tLabel  oEmitLabel( continueLabel )
5201:    [
5201:       | pTo :
5203:          @IncVar( decl )
5210:          .tLabel  oEmitLabel( checkLabel )
5218:          @VarExpr( decl )  oTypeSPop
5226:          @Expr
5228:          @RequireIntPop
5230:          .tGreaterI
5232:          .tJumpTrue  oEmitLabel( breakLabel )
5240:       | pDownto :
5242:          @DecVar( decl )
5249:          .tLabel  oEmitLabel( checkLabel )
5257:          @VarExpr( decl )  oTypeSPop
5265:          @Expr
5267:          @RequireIntPop
5269:          .tLessI
5271:          .tJumpTrue  oEmitLabel( breakLabel )
5279:    ]
5287:    oLoopPush( continueLabel, breakLabel )
5296:    pDo
5298:    @Statement
5300:    .tJump  oEmitLabel( continueLabel )
5308:    .tLabel  oEmitLabel( breakLabel )
5316:    oLoopPop;
      
      
5318: RepeatStmt:
5320:    Label continueLabel = oLabelNew
5325:    .tLabel  oEmitLabel( continueLabel )
      
5333:    Label breakLabel = oLabelNew
      
5338:    oLoopPush( continueLabel, breakLabel )
5347:    @Statement
5349:    {[
5349:       | ';' :
5351:          @Statement
5353:       | pUntil :
5355:          Label falseLabel
5355:          @BooleanExprControlFlow( falseLabel )
5362:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
5376:          >
5378:    ]}
5388:    .tLabel  oEmitLabel( breakLabel )
5396:    oLoopPop;
      
      
5398: WhileStmt:
5400:    Label continueLabel = oLabelNew
5405:    .tLabel  oEmitLabel( continueLabel )
      
5413:    Label breakLabel
5413:    @BooleanExprControlFlow( breakLabel )
      
5420:    oLoopPush( continueLabel, breakLabel )
5429:    pDo
5431:    @Statement
5433:    .tJump  oEmitLabel( continueLabel )
5441:    .tLabel  oEmitLabel( breakLabel )
5449:    oLoopPop;
      
      
5451: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
5453:    [ equal_label( oLoopContinueLabel, labelNull )
5462:       | true :
5463:          #eNotInALoop
5465:       | false :
5467:          .tJump  oEmitLabel( oLoopContinueLabel )
5474:    ];
      
      
5483: BreakStmt:
5485:    [ equal_label( oLoopBreakLabel, labelNull )
5494:       | true :
5495:          #eNotInALoop
5497:       | false :
5499:          .tJump  oEmitLabel( oLoopBreakLabel )
5506:    ];
      
      
5515: BeginStmt:
5517:    @Statement
5519:    {[
5519:       | ';' :   @Statement
5523:       | pEnd :  >
5527:    ]};
      
      
5538: WritelnStmt:
5540:    @WriteStmt
5542:    .tWriteCR;
      
      
5545: WriteStmt:
5547:    [
5547:       | '(' :
5549:          {
5549:             @Expr
5551:             [ oTypeSNodeType
5553:                | nIntegerType :             .tWriteI
5556:                | nBooleanType :             .tWriteBool
5560:                | nStringType :              .tWriteStr
5564:                | nCharType, nFileType :     #eNotImplemented
5568:                | nPointerType :             .tWriteP
5572:                | * :                        #eNotAllowed
5589:             ]
5589:             oTypeSPop
5590:             [
5590:                | ')' : >
5594:                | ',' :
5596:             ]
5604:          }
5606:       | * :
5611:    ];
      
      
5612: ReadlnStmt:      % ***
         % TO DO
5615:    ;
      
5615: ReadStmt:
         % TO DO
5618:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
5618: MatchTypes:
5620:    node_type nt = oTypeSNodeType
5625:    oTypeSPop
5626:    [ equal_node_type( nt, oTypeSNodeType )
5635:       | false :
5636:          #eTypeMismatch
5638:       | * :
5643:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
5644: RequireIntPop:
5646:    [ oTypeSNodeType
5648:       | nIntegerType :
5649:       | * :          #eNotInteger
5656:    ]
5656:    oTypeSPop;
      
5658: RequireInt:
5660:    [ oTypeSNodeType
5662:       | nIntegerType :
5663:       | * :          #eNotInteger
5670:    ];
      
5671: RequireBoolPop:
5673:    [ oTypeSNodeType
5675:       | nBooleanType :
5676:       | * :          #eNotBoolean
5683:    ]
5683:    oTypeSPop;
      
5685: RequireBool:
5687:    [ oTypeSNodeType
5689:       | nBooleanType :
5690:       | * :          #eNotBoolean
5697:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
5698: newType( node_type nt, int size ) >> Node:
5700:   Node node = oNodeNew( nt )
5710:   oNodeSetInt( node, qSize, size )
5722:   oTypeAdd( node )
5728:   >> node
5732:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
5732: newIdent( node_type nt, kind k, int id ) >> Node:
5734:   Node t = oNodeNew( nt )
5744:   oNodeSetInt( t, qIdent, id )
5756:   >> t
5760:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
5760: PointerTypeTo( Node theType ) >> Node:
5762:    Node ptrType = oNodeGet( theType, qPointerType )
5775:    [ oNodeNull( ptrType )
5782:       | true :
5783:          ptrType = oNodeNew( nPointerType )
5793:          oNodeSet( ptrType, qBaseType, theType )
5805:          oNodeSetInt( ptrType, qSize, 8 )
5817:          oTypeAdd( ptrType )
5823:          oNodeSet( theType, qPointerType, ptrType )
5835:       | * :
5840:    ]
5840:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
5844: OrdinalLow( Node theType ) >> int:
5846:    [ oNodeType( theType )
5853:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
5856:       | nBooleanType :  >> 0
5861:       | nCharType :     >> 0
5866:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
5878:       | * :             #eNotOrdinalType
5891:                         >> 0
5894:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
5895: EmitValue( Node decl ):
5897:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
5911: installBuiltIns:
      
         % install built-in types
5913:    FileType = @newType( nFileType, 4 )
5927:    IntegerType = @newType( nIntegerType, 4 )
5941:    BooleanType = @newType( nBooleanType, 1 )
5955:    BooleanCFType = @newType( nBooleanCFType, 1 )
5969:    CharType = @newType( nCharType, 1 )
5983:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
5997:    Node t
      
5997:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6013:    oNodeSet( t, qType, FileType )
6025:    oScopeDeclare( t )
      
6031:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6047:    oNodeSet( t, qType, IntegerType )
6059:    oScopeDeclare( t )
      
6065:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6081:    oNodeSet( t, qType, BooleanType )
6093:    oScopeDeclare( t )
      
6099:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6115:    oNodeSet( t, qType, CharType )
6127:    oScopeDeclare( t )
      
6133:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6149:    oNodeSet( t, qType, StringType )
6161:    oScopeDeclare( t )
      
         % Built-in constants
      
6167:    t = @newIdent( nConst, kConst, oIdAdd_True )
6183:    oNodeSet( t, qType, BooleanType )
6195:    oNodeSetInt( t, qValue, 1 )
6207:    oScopeDeclare( t )
      
6213:    t = @newIdent( nConst, kConst, oIdAdd_False )
6229:    oNodeSet( t, qType, BooleanType )
6241:    oNodeSetInt( t, qValue, 0 )
6253:    oScopeDeclare( t )
      
6260:    ;
      
6260: end
      
6260: 

Generated code:

   0: oGlobalSpace 8
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 5911
  12: oEmit 44
  14: oSetResult 0
  16: oPushResult
  17: oEmitInt
  18: oPop 1
  20: oGetAddrLocal 2
  22: oPushResult
  23: oLabelNew
  24: oAssign
  25: oEmit 38
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oEmit 41
  35: oGetLocal 2
  37: oPushResult
  38: oEmitLabel
  39: oPop 1
  41: oEmit 40
  43: oSetResult 0
  45: oPushResult
  46: oEmitInt
  47: oPop 1
  49: oEmit 43
  51: oInput 27
  53: oInput 0
  55: oGetAddrLocal 3
  57: oPushResult
  58: oSetResult 5
  60: oPushResult
  61: oSetResult 1
  63: oPushResult
  64: LAST_ID
  65: oPushResult
  66: oCall 5732
  68: oPop 3
  70: oAssign
  71: oGetLocal 3
  73: oPushResult
  74: oScopeDeclare
  75: oPop 1
  77: oInputChoice 157
  79: oInput 0
  81: oGetAddrLocal 1
  83: oPushResult
  84: oSetResult 11
  86: oPushResult
  87: oSetResult 6
  89: oPushResult
  90: LAST_ID
  91: oPushResult
  92: oCall 5732
  94: oPop 3
  96: oAssign
  97: oGetLocal 1
  99: oPushResult
 100: oSetResult 5
 102: oPushResult
 103: oGetGlobal 2
 105: oPushResult
 106: oNodeSet
 107: oPop 3
 109: oGetLocal 1
 111: oPushResult
 112: oScopeDeclareAlloc
 113: oPop 1
 115: oInput 12
 117: oInput 0
 119: oGetAddrLocal 1
 121: oPushResult
 122: oSetResult 11
 124: oPushResult
 125: oSetResult 6
 127: oPushResult
 128: LAST_ID
 129: oPushResult
 130: oCall 5732
 132: oPop 3
 134: oAssign
 135: oGetLocal 1
 137: oPushResult
 138: oSetResult 5
 140: oPushResult
 141: oGetGlobal 2
 143: oPushResult
 144: oNodeSet
 145: oPop 3
 147: oGetLocal 1
 149: oPushResult
 150: oScopeDeclareAlloc
 151: oPop 1
 153: oInput 14
 155: oJumpForward 160
 157: Choice Lookup Table
          13     79
 160: oInput 4
 162: oSetResult 12
 164: oPushResult
 165: oCall 221
 167: oPop 1
 169: oScopeBegin
 170: oScopeCurrent
 171: oPushResult
 172: oSetResult 3
 174: oPushResult
 175: oSetResult 1
 177: oPushResult
 178: oNodeSetBoolean
 179: oPop 3
 181: oGetLocal 3
 183: oPushResult
 184: oSetResult 7
 186: oPushResult
 187: oScopeCurrent
 188: oPushResult
 189: oNodeSet
 190: oPop 3
 192: oGetLocal 2
 194: oPushResult
 195: oCall 271
 197: oPop 1
 199: oScopeEnd
 200: oInput 19
 202: oScopeEnd
 203: oReturn
 204: oLocalSpace 0
 206: oGetParam 2
 208: oPushResult
 209: oCall 221
 211: oPop 1
 213: oGetParam 1
 215: oPushResult
 216: oCall 271
 218: oPop 1
 220: oReturn
 221: oLocalSpace 0
 223: oInputChoice 250
 225: oCall 1233
 227: oJumpForward 263
 229: oCall 1305
 231: oJumpForward 263
 233: oGetParam 1
 235: oPushResult
 236: oCall 1364
 238: oPop 1
 240: oJumpForward 263
 242: oCall 375
 244: oJumpForward 263
 246: oCall 660
 248: oJumpForward 263
 250: Choice Lookup Table
          29    246
          28    242
          32    233
          31    229
          30    225
 261: oJumpForward 265
 263: oJumpBack 223
 265: oCall 268
 267: oReturn
 268: oLocalSpace 0
 270: oReturn
 271: oLocalSpace 2
 273: oEmit 48
 275: oGetParam 1
 277: oPushResult
 278: oEmitLabel
 279: oPop 1
 281: oEmit 44
 283: oGetAddrLocal 1
 285: oPushResult
 286: Here
 287: oAssign
 288: oEmit 56
 290: oCall 4584
 292: oEmit 43
 294: oGetAddrLocal 2
 296: oPushResult
 297: oScopeCurrent
 298: oPushResult
 299: oSetResult 2
 301: oPushResult
 302: oNodeGetInt
 303: oPop 2
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oGetLocal 2
 311: oPushResult
 312: oPatch
 313: oPop 2
 315: oReturn
 316: oLocalSpace 0
 318: oInputChoice 336
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 12
 325: oPushResult
 326: oSetResult 1
 328: oPushResult
 329: oNodeSetBoolean
 330: oPop 3
 332: oInput 4
 334: oJumpForward 341
 336: Choice Lookup Table
          61    320
 339: oJumpForward 343
 341: oJumpBack 318
 343: oReturn
 344: oLocalSpace 0
 346: oGetParam 1
 348: oPushResult
 349: oSetResult 11
 351: oPushResult
 352: oSetResult 1
 354: oPushResult
 355: oNodeSetBoolean
 356: oPop 3
 358: oInputChoice 371
 360: oInputChoice 366
 362: oInput 2
 364: oJumpForward 369
 366: Choice Lookup Table
          60    362
 369: oJumpForward 374
 371: Choice Lookup Table
           2    360
 374: oReturn
 375: oLocalSpace 4
 377: oInput 0
 379: oGetAddrLocal 1
 381: oPushResult
 382: oSetResult 0
 384: oAssign
 385: oGetAddrLocal 2
 387: oPushResult
 388: oScopeFindInCurrentScope
 389: oAssign
 390: oGetLocal 2
 392: oPushResult
 393: oNodeNull
 394: oPop 1
 396: oChoice 517
 398: oGetAddrLocal 2
 400: oPushResult
 401: oSetResult 7
 403: oPushResult
 404: oSetResult 2
 406: oPushResult
 407: LAST_ID
 408: oPushResult
 409: oCall 5732
 411: oPop 3
 413: oAssign
 414: oGetLocal 2
 416: oPushResult
 417: oSetResult 6
 419: oPushResult
 420: oLabelNew
 421: oPushResult
 422: oNodeSetLabel
 423: oPop 3
 425: oJumpForward 523
 427: oGetAddrLocal 1
 429: oPushResult
 430: oSetResult 1
 432: oAssign
 433: oGetLocal 2
 435: oPushResult
 436: oSetResult 10
 438: oPushResult
 439: oNodeGetBoolean
 440: oPop 2
 442: oChoice 448
 444: oError 21
 446: oJumpForward 451
 448: Choice Lookup Table
           1    444
 451: oGetLocal 2
 453: oPushResult
 454: oSetResult 11
 456: oPushResult
 457: oNodeGetBoolean
 458: oPop 2
 460: oChoice 466
 462: oError 21
 464: oJumpForward 469
 466: Choice Lookup Table
           1    462
 469: oGetLocal 2
 471: oPushResult
 472: oNodeType
 473: oPop 1
 475: oChoice 479
 477: oJumpForward 484
 479: Choice Lookup Table
           7    477
 482: oError 21
 484: oGetLocal 2
 486: oPushResult
 487: oSetResult 14
 489: oPushResult
 490: oGetLocal 2
 492: oPushResult
 493: oSetResult 8
 495: oPushResult
 496: oNodeGet
 497: oPop 2
 499: oPushResult
 500: oNodeSet
 501: oPop 3
 503: oGetLocal 2
 505: oPushResult
 506: oSetResult 8
 508: oPushResult
 509: oSetResult 0
 511: oPushResult
 512: oNodeSet
 513: oPop 3
 515: oJumpForward 523
 517: Choice Lookup Table
           0    427
           1    398
 522: oEndChoice
 523: oScopeBegin
 524: oGetAddrLocal 3
 526: oPushResult
 527: oScopeCurrent
 528: oAssign
 529: oCall 1006
 531: oGetLocal 2
 533: oPushResult
 534: oSetResult 8
 536: oPushResult
 537: oGetLocal 3
 539: oPushResult
 540: oNodeSet
 541: oPop 3
 543: oScopeEnd
 544: oInput 4
 546: oGetLocal 1
 548: oChoice 560
 550: oGetLocal 2
 552: oPushResult
 553: oScopeDeclare
 554: oPop 1
 556: oJumpForward 566
 558: oJumpForward 566
 560: Choice Lookup Table
           1    558
           0    550
 565: oEndChoice
 566: oGetLocal 2
 568: oPushResult
 569: oCall 316
 571: oPop 1
 573: oInputChoice 586
 575: oJumpForward 657
 577: oGetLocal 2
 579: oPushResult
 580: oCall 344
 582: oPop 1
 584: oJumpForward 657
 586: Choice Lookup Table
          59    577
          58    575
 591: oGetLocal 3
 593: oPushResult
 594: oScopeEnter
 595: oPop 1
 597: oScopeBegin
 598: oScopeCurrent
 599: oPushResult
 600: oSetResult 3
 602: oPushResult
 603: oSetResult 1
 605: oPushResult
 606: oNodeSetBoolean
 607: oPop 3
 609: oGetLocal 2
 611: oPushResult
 612: oSetResult 9
 614: oPushResult
 615: oScopeCurrent
 616: oPushResult
 617: oNodeSet
 618: oPop 3
 620: oGetAddrLocal 4
 622: oPushResult
 623: oGetLocal 2
 625: oPushResult
 626: oSetResult 6
 628: oPushResult
 629: oNodeGetLabel
 630: oPop 2
 632: oAssign
 633: oSetResult 13
 635: oPushResult
 636: oGetLocal 4
 638: oPushResult
 639: oCall 204
 641: oPop 2
 643: oGetLocal 2
 645: oPushResult
 646: oSetResult 10
 648: oPushResult
 649: oSetResult 1
 651: oPushResult
 652: oNodeSetBoolean
 653: oPop 3
 655: oScopeEnd
 656: oScopeEnd
 657: oInput 4
 659: oReturn
 660: oLocalSpace 6
 662: oInput 0
 664: oGetAddrLocal 1
 666: oPushResult
 667: oSetResult 0
 669: oAssign
 670: oGetAddrLocal 2
 672: oPushResult
 673: oScopeFindInCurrentScope
 674: oAssign
 675: oGetLocal 2
 677: oPushResult
 678: oNodeNull
 679: oPop 1
 681: oChoice 815
 683: oGetAddrLocal 2
 685: oPushResult
 686: oSetResult 8
 688: oPushResult
 689: oSetResult 3
 691: oPushResult
 692: LAST_ID
 693: oPushResult
 694: oCall 5732
 696: oPop 3
 698: oAssign
 699: oGetLocal 2
 701: oPushResult
 702: oSetResult 6
 704: oPushResult
 705: oLabelNew
 706: oPushResult
 707: oNodeSetLabel
 708: oPop 3
 710: oJumpForward 821
 712: oGetAddrLocal 1
 714: oPushResult
 715: oSetResult 1
 717: oAssign
 718: oGetLocal 2
 720: oPushResult
 721: oSetResult 10
 723: oPushResult
 724: oNodeGetBoolean
 725: oPop 2
 727: oChoice 733
 729: oError 21
 731: oJumpForward 736
 733: Choice Lookup Table
           1    729
 736: oGetLocal 2
 738: oPushResult
 739: oNodeType
 740: oPop 1
 742: oChoice 746
 744: oJumpForward 751
 746: Choice Lookup Table
           8    744
 749: oError 21
 751: oGetLocal 2
 753: oPushResult
 754: oSetResult 14
 756: oPushResult
 757: oGetLocal 2
 759: oPushResult
 760: oSetResult 8
 762: oPushResult
 763: oNodeGet
 764: oPop 2
 766: oPushResult
 767: oNodeSet
 768: oPop 3
 770: oGetLocal 2
 772: oPushResult
 773: oSetResult 8
 775: oPushResult
 776: oSetResult 0
 778: oPushResult
 779: oNodeSet
 780: oPop 3
 782: oGetLocal 2
 784: oPushResult
 785: oSetResult 15
 787: oPushResult
 788: oGetLocal 2
 790: oPushResult
 791: oSetResult 5
 793: oPushResult
 794: oNodeGet
 795: oPop 2
 797: oPushResult
 798: oNodeSet
 799: oPop 3
 801: oGetLocal 2
 803: oPushResult
 804: oSetResult 5
 806: oPushResult
 807: oSetResult 0
 809: oPushResult
 810: oNodeSet
 811: oPop 3
 813: oJumpForward 821
 815: Choice Lookup Table
           0    712
           1    683
 820: oEndChoice
 821: oScopeBegin
 822: oGetAddrLocal 3
 824: oPushResult
 825: oScopeCurrent
 826: oAssign
 827: oCall 1006
 829: oGetLocal 2
 831: oPushResult
 832: oSetResult 8
 834: oPushResult
 835: oGetLocal 3
 837: oPushResult
 838: oNodeSet
 839: oPop 3
 841: oInput 11
 843: oGetAddrLocal 4
 845: oPushResult
 846: oCall 1505
 848: oPop 1
 850: oGetLocal 2
 852: oPushResult
 853: oSetResult 5
 855: oPushResult
 856: oGetLocal 4
 858: oPushResult
 859: oNodeSet
 860: oPop 3
 862: oGetAddrLocal 5
 864: oPushResult
 865: oGetLocal 4
 867: oPushResult
 868: oCall 5760
 870: oPop 1
 872: oAssign
 873: oGetLocal 2
 875: oPushResult
 876: oSetResult 16
 878: oPushResult
 879: oGetLocal 5
 881: oPushResult
 882: oScopeAllocType
 883: oPop 1
 885: oPushResult
 886: oNodeSetInt
 887: oPop 3
 889: oScopeEnd
 890: oInput 4
 892: oGetLocal 1
 894: oChoice 906
 896: oGetLocal 2
 898: oPushResult
 899: oScopeDeclare
 900: oPop 1
 902: oJumpForward 912
 904: oJumpForward 912
 906: Choice Lookup Table
           1    904
           0    896
 911: oEndChoice
 912: oGetLocal 2
 914: oPushResult
 915: oCall 316
 917: oPop 1
 919: oInputChoice 932
 921: oJumpForward 1003
 923: oGetLocal 2
 925: oPushResult
 926: oCall 344
 928: oPop 1
 930: oJumpForward 1003
 932: Choice Lookup Table
          59    923
          58    921
 937: oGetLocal 3
 939: oPushResult
 940: oScopeEnter
 941: oPop 1
 943: oScopeBegin
 944: oScopeCurrent
 945: oPushResult
 946: oSetResult 3
 948: oPushResult
 949: oSetResult 1
 951: oPushResult
 952: oNodeSetBoolean
 953: oPop 3
 955: oGetLocal 2
 957: oPushResult
 958: oSetResult 9
 960: oPushResult
 961: oScopeCurrent
 962: oPushResult
 963: oNodeSet
 964: oPop 3
 966: oGetAddrLocal 6
 968: oPushResult
 969: oGetLocal 2
 971: oPushResult
 972: oSetResult 6
 974: oPushResult
 975: oNodeGetLabel
 976: oPop 2
 978: oAssign
 979: oSetResult 13
 981: oPushResult
 982: oGetLocal 6
 984: oPushResult
 985: oCall 204
 987: oPop 2
 989: oGetLocal 2
 991: oPushResult
 992: oSetResult 10
 994: oPushResult
 995: oSetResult 1
 997: oPushResult
 998: oNodeSetBoolean
 999: oPop 3
1001: oScopeEnd
1002: oScopeEnd
1003: oInput 4
1005: oReturn
1006: oLocalSpace 6
1008: oInputChoice 1229
1010: oGetAddrLocal 1
1012: oPushResult
1013: oNodeVecNew
1014: oAssign
1015: oGetAddrLocal 3
1017: oPushResult
1018: oSetResult 0
1020: oAssign
1021: oInputChoice 1031
1023: oGetAddrLocal 3
1025: oPushResult
1026: oSetResult 1
1028: oAssign
1029: oJumpForward 1034
1031: Choice Lookup Table
          32   1023
1034: oInput 0
1036: oGetAddrLocal 2
1038: oPushResult
1039: oSetResult 15
1041: oPushResult
1042: oSetResult 6
1044: oPushResult
1045: LAST_ID
1046: oPushResult
1047: oCall 5732
1049: oPop 3
1051: oAssign
1052: oGetLocal 2
1054: oPushResult
1055: oSetResult 17
1057: oPushResult
1058: oGetLocal 3
1060: oPushResult
1061: oNodeSetBoolean
1062: oPop 3
1064: oGetLocal 1
1066: oPushResult
1067: oGetLocal 2
1069: oPushResult
1070: oNodeVecAppend
1071: oPop 2
1073: oInputChoice 1081
1075: oJumpForward 1089
1077: oJumpForward 1087
1079: oJumpForward 1087
1081: Choice Lookup Table
          12   1079
          11   1075
1086: oEndChoice
1087: oJumpBack 1034
1089: oGetAddrLocal 4
1091: oPushResult
1092: oCall 1505
1094: oPop 1
1096: oGetLocal 3
1098: oChoice 1113
1100: oGetAddrLocal 5
1102: oPushResult
1103: oGetLocal 4
1105: oPushResult
1106: oCall 5760
1108: oPop 1
1110: oAssign
1111: oJumpForward 1122
1113: Choice Lookup Table
           1   1100
1116: oGetAddrLocal 5
1118: oPushResult
1119: oGetLocal 4
1121: oAssign
1122: oGetAddrLocal 6
1124: oPushResult
1125: oSetResult 0
1127: oAssign
1128: oGetLocal 6
1130: oPushResult
1131: oGetLocal 1
1133: oPushResult
1134: oNodeVecSize
1135: oPop 1
1137: oPushResult
1138: equal
1139: oPop 2
1141: oChoice 1198
1143: oGetAddrLocal 2
1145: oPushResult
1146: oGetLocal 1
1148: oPushResult
1149: oGetLocal 6
1151: oPushResult
1152: oNodeVecElement
1153: oPop 2
1155: oAssign
1156: oGetLocal 2
1158: oPushResult
1159: oSetResult 5
1161: oPushResult
1162: oGetLocal 4
1164: oPushResult
1165: oNodeSet
1166: oPop 3
1168: oGetLocal 2
1170: oPushResult
1171: oScopeDeclare
1172: oPop 1
1174: oGetLocal 2
1176: oPushResult
1177: oSetResult 6
1179: oPushResult
1180: oGetLocal 5
1182: oPushResult
1183: oScopeAllocType
1184: oPop 1
1186: oPushResult
1187: oNodeSetInt
1188: oPop 3
1190: oGetAddrLocal 6
1192: oPushResult
1193: inc
1194: oPop 1
1196: oJumpForward 1203
1198: Choice Lookup Table
           0   1143
1201: oJumpForward 1205
1203: oJumpBack 1128
1205: oGetLocal 1
1207: oPushResult
1208: oNodeVecDelete
1209: oPop 1
1211: oInputChoice 1219
1213: oJumpForward 1227
1215: oJumpForward 1225
1217: oJumpForward 1225
1219: Choice Lookup Table
           4   1217
          14   1213
1224: oEndChoice
1225: oJumpBack 1010
1227: oJumpForward 1232
1229: Choice Lookup Table
          13   1010
1232: oReturn
1233: oLocalSpace 2
1235: oInputChoice 1297
1237: oGetAddrLocal 1
1239: oPushResult
1240: oSetResult 9
1242: oPushResult
1243: oSetResult 4
1245: oPushResult
1246: LAST_ID
1247: oPushResult
1248: oCall 5732
1250: oPop 3
1252: oAssign
1253: oInput 5
1255: oCall 1974
1257: oGetAddrLocal 2
1259: oPushResult
1260: oValueTop
1261: oAssign
1262: oValuePop
1263: oGetLocal 1
1265: oPushResult
1266: oSetResult 6
1268: oPushResult
1269: oGetLocal 2
1271: oPushResult
1272: oNodeSetInt
1273: oPop 3
1275: oGetLocal 1
1277: oPushResult
1278: oSetResult 5
1280: oPushResult
1281: oGetGlobal 3
1283: oPushResult
1284: oNodeSet
1285: oPop 3
1287: oGetLocal 1
1289: oPushResult
1290: oScopeDeclare
1291: oPop 1
1293: oInput 4
1295: oJumpForward 1302
1297: Choice Lookup Table
           0   1237
1300: oJumpForward 1304
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oInputChoice 1356
1309: oGetAddrLocal 1
1311: oPushResult
1312: oSetResult 10
1314: oPushResult
1315: oSetResult 5
1317: oPushResult
1318: LAST_ID
1319: oPushResult
1320: oCall 5732
1322: oPop 3
1324: oAssign
1325: oInput 5
1327: oGetAddrLocal 2
1329: oPushResult
1330: oCall 1505
1332: oPop 1
1334: oGetLocal 1
1336: oPushResult
1337: oSetResult 5
1339: oPushResult
1340: oGetLocal 2
1342: oPushResult
1343: oNodeSet
1344: oPop 3
1346: oGetLocal 1
1348: oPushResult
1349: oScopeDeclare
1350: oPop 1
1352: oInput 4
1354: oJumpForward 1361
1356: Choice Lookup Table
           0   1309
1359: oJumpForward 1363
1361: oJumpBack 1307
1363: oReturn
1364: oLocalSpace 4
1366: oInputChoice 1497
1368: oGetAddrLocal 1
1370: oPushResult
1371: oNodeVecNew
1372: oAssign
1373: oGetAddrLocal 2
1375: oPushResult
1376: oGetParam 1
1378: oPushResult
1379: oSetResult 6
1381: oPushResult
1382: LAST_ID
1383: oPushResult
1384: oCall 5732
1386: oPop 3
1388: oAssign
1389: oGetLocal 1
1391: oPushResult
1392: oGetLocal 2
1394: oPushResult
1395: oNodeVecAppend
1396: oPop 2
1398: oInputChoice 1404
1400: oInput 0
1402: oJumpForward 1409
1404: Choice Lookup Table
          12   1400
1407: oJumpForward 1411
1409: oJumpBack 1373
1411: oInput 11
1413: oGetAddrLocal 3
1415: oPushResult
1416: oCall 1505
1418: oPop 1
1420: oGetAddrLocal 4
1422: oPushResult
1423: oSetResult 0
1425: oAssign
1426: oGetLocal 4
1428: oPushResult
1429: oGetLocal 1
1431: oPushResult
1432: oNodeVecSize
1433: oPop 1
1435: oPushResult
1436: equal
1437: oPop 2
1439: oChoice 1480
1441: oGetAddrLocal 2
1443: oPushResult
1444: oGetLocal 1
1446: oPushResult
1447: oGetLocal 4
1449: oPushResult
1450: oNodeVecElement
1451: oPop 2
1453: oAssign
1454: oGetLocal 2
1456: oPushResult
1457: oSetResult 5
1459: oPushResult
1460: oGetLocal 3
1462: oPushResult
1463: oNodeSet
1464: oPop 3
1466: oGetLocal 2
1468: oPushResult
1469: oScopeDeclareAlloc
1470: oPop 1
1472: oGetAddrLocal 4
1474: oPushResult
1475: inc
1476: oPop 1
1478: oJumpForward 1485
1480: Choice Lookup Table
           0   1441
1483: oJumpForward 1487
1485: oJumpBack 1426
1487: oGetLocal 1
1489: oPushResult
1490: oNodeVecDelete
1491: oPop 1
1493: oInput 4
1495: oJumpForward 1502
1497: Choice Lookup Table
           0   1368
1500: oJumpForward 1504
1502: oJumpBack 1366
1504: oReturn
1505: oLocalSpace 12
1507: oInputChoice 1956
1509: oGetAddrLocal 1
1511: oPushResult
1512: oScopeFindRequire
1513: oAssign
1514: oGetLocal 1
1516: oPushResult
1517: oNodeType
1518: oPop 1
1520: oChoice 1537
1522: oGetParam 1
1524: oPushResult
1525: oGetLocal 1
1527: oPushResult
1528: oSetResult 5
1530: oPushResult
1531: oNodeGet
1532: oPop 2
1534: oAssign
1535: oJumpForward 1548
1537: Choice Lookup Table
          10   1522
1540: oError 2
1542: oGetParam 1
1544: oPushResult
1545: oGetGlobal 3
1547: oAssign
1548: oJumpForward 1973
1550: oInput 15
1552: oGetAddrLocal 2
1554: oPushResult
1555: oNodeVecNew
1556: oAssign
1557: oGetAddrLocal 3
1559: oPushResult
1560: oSetResult 25
1562: oPushResult
1563: oNodeNew
1564: oPop 1
1566: oAssign
1567: oGetLocal 3
1569: oPushResult
1570: oSetResult 19
1572: oPushResult
1573: oGetGlobal 3
1575: oPushResult
1576: oNodeSet
1577: oPop 3
1579: oCall 1974
1581: oGetLocal 3
1583: oPushResult
1584: oSetResult 21
1586: oPushResult
1587: oValueTop
1588: oPushResult
1589: oNodeSetInt
1590: oPop 3
1592: oValuePop
1593: oInput 20
1595: oCall 1974
1597: oGetLocal 3
1599: oPushResult
1600: oSetResult 22
1602: oPushResult
1603: oValueTop
1604: oPushResult
1605: oNodeSetInt
1606: oPop 3
1608: oValuePop
1609: oGetLocal 3
1611: oPushResult
1612: oSetResult 2
1614: oPushResult
1615: oSetResult 4
1617: oPushResult
1618: oNodeSetInt
1619: oPop 3
1621: oGetLocal 3
1623: oPushResult
1624: oTypeAdd
1625: oPop 1
1627: oGetAddrLocal 4
1629: oPushResult
1630: oSetResult 24
1632: oPushResult
1633: oNodeNew
1634: oPop 1
1636: oAssign
1637: oGetLocal 4
1639: oPushResult
1640: oSetResult 20
1642: oPushResult
1643: oGetLocal 3
1645: oPushResult
1646: oNodeSet
1647: oPop 3
1649: oGetLocal 2
1651: oPushResult
1652: oGetLocal 4
1654: oPushResult
1655: oNodeVecAppend
1656: oPop 2
1658: oInputChoice 1666
1660: oJumpForward 1674
1662: oJumpForward 1672
1664: oJumpForward 1672
1666: Choice Lookup Table
          12   1664
          16   1660
1671: oEndChoice
1672: oJumpBack 1557
1674: oInput 38
1676: oGetAddrLocal 5
1678: oPushResult
1679: oCall 1505
1681: oPop 1
1683: oGetAddrLocal 6
1685: oPushResult
1686: oGetLocal 2
1688: oPushResult
1689: oNodeVecSize
1690: oPop 1
1692: oAssign
1693: oGetAddrLocal 6
1695: oPushResult
1696: dec
1697: oPop 1
1699: oGetAddrLocal 7
1701: oPushResult
1702: oGetLocal 2
1704: oPushResult
1705: oGetLocal 6
1707: oPushResult
1708: oNodeVecElement
1709: oPop 2
1711: oAssign
1712: oGetLocal 7
1714: oPushResult
1715: oSetResult 19
1717: oPushResult
1718: oGetLocal 5
1720: oPushResult
1721: oNodeSet
1722: oPop 3
1724: oGetAddrLocal 8
1726: oPushResult
1727: oGetLocal 7
1729: oPushResult
1730: oSetResult 20
1732: oPushResult
1733: oNodeGet
1734: oPop 2
1736: oAssign
1737: oGetAddrLocal 9
1739: oPushResult
1740: oGetLocal 8
1742: oPushResult
1743: oSetResult 22
1745: oPushResult
1746: oNodeGetInt
1747: oPop 2
1749: oPushResult
1750: oGetLocal 8
1752: oPushResult
1753: oSetResult 21
1755: oPushResult
1756: oNodeGetInt
1757: oPop 2
1759: oPushResult
1760: subtract
1761: oPop 2
1763: oAssign
1764: oGetAddrLocal 9
1766: oPushResult
1767: inc
1768: oPop 1
1770: oGetLocal 7
1772: oPushResult
1773: oSetResult 2
1775: oPushResult
1776: oGetLocal 9
1778: oPushResult
1779: oGetLocal 5
1781: oPushResult
1782: oSetResult 2
1784: oPushResult
1785: oNodeGetInt
1786: oPop 2
1788: oPushResult
1789: multiply
1790: oPop 2
1792: oPushResult
1793: oNodeSetInt
1794: oPop 3
1796: oGetLocal 7
1798: oPushResult
1799: oTypeAdd
1800: oPop 1
1802: oGetAddrLocal 5
1804: oPushResult
1805: oGetLocal 7
1807: oAssign
1808: oGetLocal 6
1810: oPushResult
1811: equal_zero
1812: oPop 1
1814: oChoice 1820
1816: oJumpForward 1825
1818: oJumpForward 1823
1820: Choice Lookup Table
           1   1816
1823: oJumpBack 1693
1825: oGetParam 1
1827: oPushResult
1828: oGetLocal 2
1830: oPushResult
1831: oSetResult 0
1833: oPushResult
1834: oNodeVecElement
1835: oPop 2
1837: oAssign
1838: oGetLocal 2
1840: oPushResult
1841: oNodeVecDelete
1842: oPop 1
1844: oJumpForward 1973
1846: oGetAddrLocal 10
1848: oPushResult
1849: oCall 1505
1851: oPop 1
1853: oGetParam 1
1855: oPushResult
1856: oGetLocal 10
1858: oPushResult
1859: oCall 5760
1861: oPop 1
1863: oAssign
1864: oJumpForward 1973
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 26
1871: oPushResult
1872: oNodeNew
1873: oPop 1
1875: oAssign
1876: oScopeBegin
1877: oSetResult 14
1879: oPushResult
1880: oCall 1364
1882: oPop 1
1884: oGetAddrLocal 11
1886: oPushResult
1887: oScopeCurrent
1888: oPushResult
1889: oSetResult 2
1891: oPushResult
1892: oNodeGetInt
1893: oPop 2
1895: oAssign
1896: oGetLocal 11
1898: oPushResult
1899: equal_zero
1900: oPop 1
1902: oChoice 1908
1904: oError 19
1906: oJumpForward 1911
1908: Choice Lookup Table
           1   1904
1911: oInput 34
1913: oGetFromParam 1
1915: oPushResult
1916: oSetResult 23
1918: oPushResult
1919: oScopeCurrent
1920: oPushResult
1921: oNodeSet
1922: oPop 3
1924: oGetFromParam 1
1926: oPushResult
1927: oSetResult 2
1929: oPushResult
1930: oGetLocal 11
1932: oPushResult
1933: oNodeSetInt
1934: oPop 3
1936: oScopeEnd
1937: oGetFromParam 1
1939: oPushResult
1940: oTypeAdd
1941: oPop 1
1943: oJumpForward 1973
1945: oInput 38
1947: oGetAddrLocal 12
1949: oPushResult
1950: oCall 1505
1952: oPop 1
1954: oJumpForward 1973
1956: Choice Lookup Table
          37   1945
          36   1866
          17   1846
          35   1550
           0   1509
1967: oCall 1974
1969: oInput 20
1971: oCall 1974
1973: oReturn
1974: oLocalSpace 1
1976: oInputChoice 2031
1978: TOKEN_VALUE
1979: oPushResult
1980: oValuePush
1981: oPop 1
1983: oJumpForward 2039
1985: oGetAddrLocal 1
1987: oPushResult
1988: oScopeFindRequire
1989: oAssign
1990: oGetLocal 1
1992: oPushResult
1993: oNodeType
1994: oPop 1
1996: oChoice 2013
1998: oGetLocal 1
2000: oPushResult
2001: oSetResult 6
2003: oPushResult
2004: oNodeGetInt
2005: oPop 2
2007: oPushResult
2008: oValuePush
2009: oPop 1
2011: oJumpForward 2024
2013: Choice Lookup Table
           9   1998
2016: oError 1
2018: oSetResult 0
2020: oPushResult
2021: oValuePush
2022: oPop 1
2024: oJumpForward 2039
2026: oCall 1974
2028: oValueNegate
2029: oJumpForward 2039
2031: Choice Lookup Table
          24   2026
           0   1985
           1   1978
2038: oEndChoice
2039: oReturn
2040: oLocalSpace 1
2042: oGetAddrLocal 1
2044: oPushResult
2045: oSetResult 0
2047: oAssign
2048: oGetAddrLocal 1
2050: oPushResult
2051: oCall 2201
2053: oPop 1
2055: oGetAddrLocal 1
2057: oPushResult
2058: oCall 2101
2060: oPop 1
2062: oReturn
2063: oLocalSpace 0
2065: oGetParam 1
2067: oPushResult
2068: oCall 2201
2070: oPop 1
2072: oTypeSNodeType
2073: oChoice 2092
2075: oJumpForward 2099
2077: oGetParam 1
2079: oPushResult
2080: oLabelNew
2081: oAssign
2082: oEmit 47
2084: oGetFromParam 1
2086: oPushResult
2087: oEmitLabel
2088: oPop 1
2090: oJumpForward 2099
2092: Choice Lookup Table
          19   2077
          20   2075
2097: oError 8
2099: oTypeSPop
2100: oReturn
2101: oLocalSpace 1
2103: oTypeSNodeType
2104: oChoice 2166
2106: oGetAddrLocal 1
2108: oPushResult
2109: oLabelNew
2110: oAssign
2111: oEmit 9
2113: oSetResult 1
2115: oPushResult
2116: oEmitInt
2117: oPop 1
2119: oEmit 45
2121: oGetLocal 1
2123: oPushResult
2124: oEmitLabel
2125: oPop 1
2127: oEmit 48
2129: oGetFromParam 1
2131: oPushResult
2132: oEmitLabel
2133: oPop 1
2135: oEmit 9
2137: oSetResult 0
2139: oPushResult
2140: oEmitInt
2141: oPop 1
2143: oEmit 48
2145: oGetLocal 1
2147: oPushResult
2148: oEmitLabel
2149: oPop 1
2151: oTypeSPop
2152: oGetGlobal 4
2154: oPushResult
2155: oTypeSPush
2156: oPop 1
2158: oGetParam 1
2160: oPushResult
2161: oSetResult 0
2163: oAssign
2164: oJumpForward 2169
2166: Choice Lookup Table
          20   2106
2169: oReturn
2170: oLocalSpace 0
2172: oTypeSNodeType
2173: oChoice 2197
2175: oGetParam 1
2177: oPushResult
2178: oLabelNew
2179: oAssign
2180: oEmit 47
2182: oGetFromParam 1
2184: oPushResult
2185: oEmitLabel
2186: oPop 1
2188: oTypeSPop
2189: oGetGlobal 5
2191: oPushResult
2192: oTypeSPush
2193: oPop 1
2195: oJumpForward 2200
2197: Choice Lookup Table
          19   2175
2200: oReturn
2201: oLocalSpace 0
2203: oGetParam 1
2205: oPushResult
2206: oCall 2566
2208: oPop 1
2210: oInputChoice 2548
2212: oGetParam 1
2214: oPushResult
2215: oCall 2101
2217: oPop 1
2219: oGetParam 1
2221: oPushResult
2222: oCall 2566
2224: oPop 1
2226: oGetParam 1
2228: oPushResult
2229: oCall 2101
2231: oPop 1
2233: oCall 5618
2235: oTypeSNodeType
2236: oChoice 2250
2238: oEmit 30
2240: oJumpForward 2263
2242: oEmit 36
2244: oJumpForward 2263
2246: oError 16
2248: oJumpForward 2263
2250: Choice Lookup Table
          22   2246
          21   2246
          23   2242
          19   2238
          18   2238
2261: oError 17
2263: oTypeSPop
2264: oGetGlobal 4
2266: oPushResult
2267: oTypeSPush
2268: oPop 1
2270: oJumpForward 2563
2272: oGetParam 1
2274: oPushResult
2275: oCall 2101
2277: oPop 1
2279: oGetParam 1
2281: oPushResult
2282: oCall 2566
2284: oPop 1
2286: oGetParam 1
2288: oPushResult
2289: oCall 2101
2291: oPop 1
2293: oCall 5618
2295: oTypeSNodeType
2296: oChoice 2310
2298: oEmit 31
2300: oJumpForward 2323
2302: oEmit 37
2304: oJumpForward 2323
2306: oError 16
2308: oJumpForward 2323
2310: Choice Lookup Table
          22   2306
          21   2306
          23   2302
          19   2298
          18   2298
2321: oError 17
2323: oTypeSPop
2324: oGetGlobal 4
2326: oPushResult
2327: oTypeSPush
2328: oPop 1
2330: oJumpForward 2563
2332: oGetParam 1
2334: oPushResult
2335: oCall 2101
2337: oPop 1
2339: oGetParam 1
2341: oPushResult
2342: oCall 2566
2344: oPop 1
2346: oGetParam 1
2348: oPushResult
2349: oCall 2101
2351: oPop 1
2353: oCall 5618
2355: oTypeSNodeType
2356: oChoice 2366
2358: oEmit 33
2360: oJumpForward 2377
2362: oError 16
2364: oJumpForward 2377
2366: Choice Lookup Table
          22   2362
          21   2362
          19   2358
          18   2358
2375: oError 17
2377: oTypeSPop
2378: oGetGlobal 4
2380: oPushResult
2381: oTypeSPush
2382: oPop 1
2384: oJumpForward 2563
2386: oGetParam 1
2388: oPushResult
2389: oCall 2101
2391: oPop 1
2393: oGetParam 1
2395: oPushResult
2396: oCall 2566
2398: oPop 1
2400: oGetParam 1
2402: oPushResult
2403: oCall 2101
2405: oPop 1
2407: oCall 5618
2409: oTypeSNodeType
2410: oChoice 2420
2412: oEmit 32
2414: oJumpForward 2431
2416: oError 16
2418: oJumpForward 2431
2420: Choice Lookup Table
          22   2416
          21   2416
          19   2412
          18   2412
2429: oError 17
2431: oTypeSPop
2432: oGetGlobal 4
2434: oPushResult
2435: oTypeSPush
2436: oPop 1
2438: oJumpForward 2563
2440: oGetParam 1
2442: oPushResult
2443: oCall 2101
2445: oPop 1
2447: oGetParam 1
2449: oPushResult
2450: oCall 2566
2452: oPop 1
2454: oGetParam 1
2456: oPushResult
2457: oCall 2101
2459: oPop 1
2461: oCall 5618
2463: oTypeSNodeType
2464: oChoice 2474
2466: oEmit 35
2468: oJumpForward 2485
2470: oError 16
2472: oJumpForward 2485
2474: Choice Lookup Table
          22   2470
          21   2470
          19   2466
          18   2466
2483: oError 17
2485: oTypeSPop
2486: oGetGlobal 4
2488: oPushResult
2489: oTypeSPush
2490: oPop 1
2492: oJumpForward 2563
2494: oGetParam 1
2496: oPushResult
2497: oCall 2101
2499: oPop 1
2501: oGetParam 1
2503: oPushResult
2504: oCall 2566
2506: oPop 1
2508: oGetParam 1
2510: oPushResult
2511: oCall 2101
2513: oPop 1
2515: oCall 5618
2517: oTypeSNodeType
2518: oChoice 2528
2520: oEmit 34
2522: oJumpForward 2539
2524: oError 16
2526: oJumpForward 2539
2528: Choice Lookup Table
          22   2524
          21   2524
          19   2520
          18   2520
2537: oError 17
2539: oTypeSPop
2540: oGetGlobal 4
2542: oPushResult
2543: oTypeSPush
2544: oPop 1
2546: oJumpForward 2563
2548: Choice Lookup Table
          10   2494
           9   2440
           8   2386
           7   2332
           6   2272
           5   2212
2561: oJumpForward 2565
2563: oJumpBack 2210
2565: oReturn
2566: oLocalSpace 1
2568: oGetAddrLocal 1
2570: oPushResult
2571: oSetResult 0
2573: oAssign
2574: oGetParam 1
2576: oPushResult
2577: oCall 2746
2579: oPop 1
2581: oInputChoice 2714
2583: oTypeSNodeType
2584: oChoice 2655
2586: oGetLocal 1
2588: oPushResult
2589: oSetResult 0
2591: oPushResult
2592: equal_label
2593: oPop 2
2595: oChoice 2604
2597: oGetAddrLocal 1
2599: oPushResult
2600: oLabelNew
2601: oAssign
2602: oJumpForward 2607
2604: Choice Lookup Table
           1   2597
2607: oEmit 45
2609: oGetLocal 1
2611: oPushResult
2612: oEmitLabel
2613: oPop 1
2615: oJumpForward 2662
2617: oGetParam 1
2619: oPushResult
2620: oCall 2170
2622: oPop 1
2624: oGetLocal 1
2626: oPushResult
2627: oSetResult 0
2629: oPushResult
2630: equal_label
2631: oPop 2
2633: oChoice 2642
2635: oGetAddrLocal 1
2637: oPushResult
2638: oLabelNew
2639: oAssign
2640: oJumpForward 2645
2642: Choice Lookup Table
           1   2635
2645: oEmit 45
2647: oGetLocal 1
2649: oPushResult
2650: oEmitLabel
2651: oPop 1
2653: oJumpForward 2662
2655: Choice Lookup Table
          19   2617
          20   2586
2660: oError 8
2662: oTypeSPop
2663: oEmit 48
2665: oGetFromParam 1
2667: oPushResult
2668: oEmitLabel
2669: oPop 1
2671: oGetParam 1
2673: oPushResult
2674: oSetResult 0
2676: oAssign
2677: oGetParam 1
2679: oPushResult
2680: oCall 2746
2682: oPop 1
2684: oTypeSNodeType
2685: oChoice 2698
2687: oJumpForward 2705
2689: oGetParam 1
2691: oPushResult
2692: oCall 2170
2694: oPop 1
2696: oJumpForward 2705
2698: Choice Lookup Table
          19   2689
          20   2687
2703: oError 8
2705: oTypeSPop
2706: oGetGlobal 5
2708: oPushResult
2709: oTypeSPush
2710: oPop 1
2712: oJumpForward 2719
2714: Choice Lookup Table
          52   2583
2717: oJumpForward 2721
2719: oJumpBack 2581
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 0
2726: oPushResult
2727: equal_label
2728: oPop 2
2730: oChoice 2742
2732: oEmit 48
2734: oGetLocal 1
2736: oPushResult
2737: oEmitLabel
2738: oPop 1
2740: oJumpForward 2745
2742: Choice Lookup Table
           0   2732
2745: oReturn
2746: oLocalSpace 2
2748: oGetAddrLocal 1
2750: oPushResult
2751: oSetResult 0
2753: oAssign
2754: oGetParam 1
2756: oPushResult
2757: oCall 2884
2759: oPop 1
2761: oInputChoice 2876
2763: oTypeSNodeType
2764: oChoice 2777
2766: oJumpForward 2784
2768: oGetParam 1
2770: oPushResult
2771: oCall 2170
2773: oPop 1
2775: oJumpForward 2784
2777: Choice Lookup Table
          19   2768
          20   2766
2782: oError 8
2784: oTypeSPop
2785: oGetLocal 1
2787: oPushResult
2788: oSetResult 0
2790: oPushResult
2791: equal_label
2792: oPop 2
2794: oChoice 2823
2796: oGetAddrLocal 1
2798: oPushResult
2799: oLabelNew
2800: oAssign
2801: oEmit 49
2803: oGetFromParam 1
2805: oPushResult
2806: oEmitLabel
2807: oPop 1
2809: oGetLocal 1
2811: oPushResult
2812: oEmitLabel
2813: oPop 1
2815: oGetParam 1
2817: oPushResult
2818: oGetLocal 1
2820: oAssign
2821: oJumpForward 2826
2823: Choice Lookup Table
           1   2796
2826: oGetAddrLocal 2
2828: oPushResult
2829: oSetResult 0
2831: oAssign
2832: oGetAddrLocal 2
2834: oPushResult
2835: oCall 2884
2837: oPop 1
2839: oTypeSNodeType
2840: oChoice 2853
2842: oJumpForward 2860
2844: oGetAddrLocal 2
2846: oPushResult
2847: oCall 2170
2849: oPop 1
2851: oJumpForward 2860
2853: Choice Lookup Table
          19   2844
          20   2842
2858: oError 8
2860: oEmit 49
2862: oGetLocal 2
2864: oPushResult
2865: oEmitLabel
2866: oPop 1
2868: oGetLocal 1
2870: oPushResult
2871: oEmitLabel
2872: oPop 1
2874: oJumpForward 2881
2876: Choice Lookup Table
          51   2763
2879: oJumpForward 2883
2881: oJumpBack 2761
2883: oReturn
2884: oLocalSpace 1
2886: oInputChoice 2940
2888: oGetAddrLocal 1
2890: oPushResult
2891: oSetResult 0
2893: oAssign
2894: oGetAddrLocal 1
2896: oPushResult
2897: oCall 2884
2899: oPop 1
2901: oTypeSNodeType
2902: oChoice 2931
2904: oGetParam 1
2906: oPushResult
2907: oLabelNew
2908: oAssign
2909: oEmit 45
2911: oGetFromParam 1
2913: oPushResult
2914: oEmitLabel
2915: oPop 1
2917: oEmit 48
2919: oGetLocal 1
2921: oPushResult
2922: oEmitLabel
2923: oPop 1
2925: oJumpForward 2938
2927: oEmit 29
2929: oJumpForward 2938
2931: Choice Lookup Table
          19   2927
          20   2904
2936: oError 8
2938: oJumpForward 2950
2940: Choice Lookup Table
          53   2888
2943: oGetParam 1
2945: oPushResult
2946: oCall 2951
2948: oPop 1
2950: oReturn
2951: oLocalSpace 0
2953: oGetParam 1
2955: oPushResult
2956: oCall 3002
2958: oPop 1
2960: oInputChoice 2992
2962: oCall 5644
2964: oGetParam 1
2966: oPushResult
2967: oCall 3002
2969: oPop 1
2971: oCall 5658
2973: oEmit 26
2975: oJumpForward 2999
2977: oCall 5644
2979: oGetParam 1
2981: oPushResult
2982: oCall 3002
2984: oPop 1
2986: oCall 5658
2988: oEmit 27
2990: oJumpForward 2999
2992: Choice Lookup Table
          24   2977
          23   2962
2997: oJumpForward 3001
2999: oJumpBack 2960
3001: oReturn
3002: oLocalSpace 0
3004: oGetParam 1
3006: oPushResult
3007: oCall 3053
3009: oPop 1
3011: oInputChoice 3043
3013: oCall 5644
3015: oGetParam 1
3017: oPushResult
3018: oCall 3053
3020: oPop 1
3022: oCall 5658
3024: oEmit 23
3026: oJumpForward 3050
3028: oCall 5644
3030: oGetParam 1
3032: oPushResult
3033: oCall 3053
3035: oPop 1
3037: oCall 5658
3039: oEmit 24
3041: oJumpForward 3050
3043: Choice Lookup Table
          22   3028
          21   3013
3048: oJumpForward 3052
3050: oJumpBack 3011
3052: oReturn
3053: oLocalSpace 0
3055: oInputChoice 3081
3057: oGetParam 1
3059: oPushResult
3060: oCall 3094
3062: oPop 1
3064: oCall 5658
3066: oJumpForward 3093
3068: oGetParam 1
3070: oPushResult
3071: oCall 3094
3073: oPop 1
3075: oCall 5658
3077: oEmit 28
3079: oJumpForward 3093
3081: Choice Lookup Table
          24   3068
          23   3057
3086: oGetParam 1
3088: oPushResult
3089: oCall 3094
3091: oPop 1
3093: oReturn
3094: oLocalSpace 6
3096: oInputChoice 3278
3098: oEmit 9
3100: TOKEN_VALUE
3101: oPushResult
3102: oEmitInt
3103: oPop 1
3105: oGetGlobal 3
3107: oPushResult
3108: oTypeSPush
3109: oPop 1
3111: oJumpForward 3297
3113: oGetParam 1
3115: oPushResult
3116: oCall 2201
3118: oPop 1
3120: oInput 14
3122: oJumpForward 3297
3124: oGetAddrLocal 1
3126: oPushResult
3127: oStringAllocLit
3128: oAssign
3129: oEmit 10
3131: oGetLocal 1
3133: oPushResult
3134: oEmitInt
3135: oPop 1
3137: oGetGlobal 7
3139: oPushResult
3140: oTypeSPush
3141: oPop 1
3143: oJumpForward 3297
3145: oGetAddrLocal 2
3147: oPushResult
3148: oScopeFindRequire
3149: oAssign
3150: oGetLocal 2
3152: oPushResult
3153: oNodeType
3154: oPop 1
3156: oChoice 3218
3158: oGetLocal 2
3160: oPushResult
3161: oCall 4020
3163: oPop 1
3165: oJumpForward 3237
3167: oGetAddrLocal 3
3169: oPushResult
3170: oGetLocal 2
3172: oPushResult
3173: oSetResult 5
3175: oPushResult
3176: oNodeGet
3177: oPop 2
3179: oAssign
3180: oGetLocal 3
3182: oPushResult
3183: oTypeSPush
3184: oPop 1
3186: oTypeSNodeType
3187: oChoice 3200
3189: oEmit 9
3191: oGetLocal 2
3193: oPushResult
3194: oCall 5895
3196: oPop 1
3198: oJumpForward 3207
3200: Choice Lookup Table
          19   3189
          18   3189
3205: oError 16
3207: oJumpForward 3237
3209: oGetLocal 2
3211: oPushResult
3212: oCall 3298
3214: oPop 1
3216: oJumpForward 3237
3218: Choice Lookup Table
          15   3209
          13   3209
          12   3209
           9   3167
           8   3158
3229: oError 6
3231: oGetGlobal 3
3233: oPushResult
3234: oTypeSPush
3235: oPop 1
3237: oJumpForward 3297
3239: oInput 0
3241: oGetAddrLocal 4
3243: oPushResult
3244: oScopeFindRequire
3245: oAssign
3246: oGetLocal 4
3248: oPushResult
3249: oCall 4937
3251: oPop 1
3253: oGetAddrLocal 5
3255: oPushResult
3256: oTypeSTop
3257: oAssign
3258: oTypeSPop
3259: oGetAddrLocal 6
3261: oPushResult
3262: oGetLocal 5
3264: oPushResult
3265: oCall 5760
3267: oPop 1
3269: oAssign
3270: oGetLocal 6
3272: oPushResult
3273: oTypeSPush
3274: oPop 1
3276: oJumpForward 3297
3278: Choice Lookup Table
          18   3239
           0   3145
           2   3124
          13   3113
           1   3098
3289: oError 6
3291: oGetGlobal 3
3293: oPushResult
3294: oTypeSPush
3295: oPop 1
3297: oReturn
3298: oLocalSpace 1
3300: oGetAddrLocal 1
3302: oPushResult
3303: oGetParam 1
3305: oPushResult
3306: oSetResult 5
3308: oPushResult
3309: oNodeGet
3310: oPop 2
3312: oAssign
3313: oGetLocal 1
3315: oPushResult
3316: oTypeSPush
3317: oPop 1
3319: oTypeSNodeType
3320: oChoice 3585
3322: oGetParam 1
3324: oPushResult
3325: oNodeType
3326: oPop 1
3328: oChoice 3390
3330: oEmit 0
3332: oGetParam 1
3334: oPushResult
3335: oCall 5895
3337: oPop 1
3339: oJumpForward 3398
3341: oEmit 3
3343: oGetParam 1
3345: oPushResult
3346: oCall 5895
3348: oPop 1
3350: oJumpForward 3398
3352: oGetParam 1
3354: oPushResult
3355: oSetResult 17
3357: oPushResult
3358: oNodeGetBoolean
3359: oPop 2
3361: oChoice 3376
3363: oEmit 8
3365: oGetParam 1
3367: oPushResult
3368: oCall 5895
3370: oPop 1
3372: oEmit 14
3374: oJumpForward 3388
3376: Choice Lookup Table
           1   3363
3379: oEmit 6
3381: oGetParam 1
3383: oPushResult
3384: oCall 5895
3386: oPop 1
3388: oJumpForward 3398
3390: Choice Lookup Table
          15   3352
          13   3341
          12   3330
3397: oEndChoice
3398: oJumpForward 3676
3400: oGetParam 1
3402: oPushResult
3403: oNodeType
3404: oPop 1
3406: oChoice 3468
3408: oEmit 1
3410: oGetParam 1
3412: oPushResult
3413: oCall 5895
3415: oPop 1
3417: oJumpForward 3476
3419: oEmit 4
3421: oGetParam 1
3423: oPushResult
3424: oCall 5895
3426: oPop 1
3428: oJumpForward 3476
3430: oGetParam 1
3432: oPushResult
3433: oSetResult 17
3435: oPushResult
3436: oNodeGetBoolean
3437: oPop 2
3439: oChoice 3454
3441: oEmit 8
3443: oGetParam 1
3445: oPushResult
3446: oCall 5895
3448: oPop 1
3450: oEmit 15
3452: oJumpForward 3466
3454: Choice Lookup Table
           1   3441
3457: oEmit 7
3459: oGetParam 1
3461: oPushResult
3462: oCall 5895
3464: oPop 1
3466: oJumpForward 3476
3468: Choice Lookup Table
          15   3430
          13   3419
          12   3408
3475: oEndChoice
3476: oJumpForward 3676
3478: oError 16
3480: oJumpForward 3676
3482: oGetParam 1
3484: oPushResult
3485: oNodeType
3486: oPop 1
3488: oChoice 3550
3490: oEmit 2
3492: oGetParam 1
3494: oPushResult
3495: oCall 5895
3497: oPop 1
3499: oJumpForward 3558
3501: oEmit 5
3503: oGetParam 1
3505: oPushResult
3506: oCall 5895
3508: oPop 1
3510: oJumpForward 3558
3512: oGetParam 1
3514: oPushResult
3515: oSetResult 17
3517: oPushResult
3518: oNodeGetBoolean
3519: oPop 2
3521: oChoice 3536
3523: oEmit 8
3525: oGetParam 1
3527: oPushResult
3528: oCall 5895
3530: oPop 1
3532: oEmit 16
3534: oJumpForward 3548
3536: Choice Lookup Table
           1   3523
3539: oEmit 8
3541: oGetParam 1
3543: oPushResult
3544: oCall 5895
3546: oPop 1
3548: oJumpForward 3558
3550: Choice Lookup Table
          15   3512
          13   3501
          12   3490
3557: oEndChoice
3558: oInputChoice 3580
3560: oTypeSPop
3561: oGetLocal 1
3563: oPushResult
3564: oSetResult 19
3566: oPushResult
3567: oNodeGet
3568: oPop 2
3570: oPushResult
3571: oTypeSPush
3572: oPop 1
3574: oCall 3712
3576: oCall 3677
3578: oJumpForward 3583
3580: Choice Lookup Table
          17   3560
3583: oJumpForward 3676
3585: Choice Lookup Table
          23   3482
          17   3478
          22   3478
          21   3478
          19   3400
          18   3322
3598: oGetParam 1
3600: oPushResult
3601: oNodeType
3602: oPop 1
3604: oChoice 3664
3606: oEmit 10
3608: oGetParam 1
3610: oPushResult
3611: oCall 5895
3613: oPop 1
3615: oJumpForward 3672
3617: oEmit 11
3619: oGetParam 1
3621: oPushResult
3622: oCall 5895
3624: oPop 1
3626: oJumpForward 3672
3628: oGetParam 1
3630: oPushResult
3631: oSetResult 17
3633: oPushResult
3634: oNodeGetBoolean
3635: oPop 2
3637: oChoice 3650
3639: oEmit 8
3641: oGetParam 1
3643: oPushResult
3644: oCall 5895
3646: oPop 1
3648: oJumpForward 3662
3650: Choice Lookup Table
           1   3639
3653: oEmit 12
3655: oGetParam 1
3657: oPushResult
3658: oCall 5895
3660: oPop 1
3662: oJumpForward 3672
3664: Choice Lookup Table
          15   3628
          13   3617
          12   3606
3671: oEndChoice
3672: oCall 3712
3674: oCall 3677
3676: oReturn
3677: oLocalSpace 0
3679: oTypeSNodeType
3680: oChoice 3698
3682: oEmit 14
3684: oJumpForward 3711
3686: oEmit 15
3688: oJumpForward 3711
3690: oError 16
3692: oJumpForward 3711
3694: oEmit 16
3696: oJumpForward 3711
3698: Choice Lookup Table
          23   3694
          17   3690
          22   3690
          21   3690
          19   3686
          18   3682
3711: oReturn
3712: oLocalSpace 0
3714: oInputChoice 3728
3716: oCall 3740
3718: oJumpForward 3737
3720: oCall 3883
3722: oJumpForward 3737
3724: oCall 3981
3726: oJumpForward 3737
3728: Choice Lookup Table
          17   3724
          19   3720
          15   3716
3735: oJumpForward 3739
3737: oJumpBack 3714
3739: oReturn
3740: oLocalSpace 3
3742: oTypeSNodeType
3743: oChoice 3747
3745: oJumpForward 3752
3747: Choice Lookup Table
          24   3745
3750: oError 10
3752: oTypeSNodeType
3753: oChoice 3757
3755: oJumpForward 3762
3757: Choice Lookup Table
          24   3755
3760: oError 13
3762: oGetAddrLocal 1
3764: oPushResult
3765: oTypeSTop
3766: oPushResult
3767: oSetResult 20
3769: oPushResult
3770: oNodeGet
3771: oPop 2
3773: oPushResult
3774: oCall 5844
3776: oPop 1
3778: oAssign
3779: oGetAddrLocal 2
3781: oPushResult
3782: oTypeSTop
3783: oPushResult
3784: oSetResult 19
3786: oPushResult
3787: oNodeGet
3788: oPop 2
3790: oAssign
3791: oTypeSPop
3792: oGetLocal 2
3794: oPushResult
3795: oTypeSPush
3796: oPop 1
3798: oCall 2040
3800: oCall 5644
3802: oGetLocal 1
3804: oPushResult
3805: equal_zero
3806: oPop 1
3808: oChoice 3822
3810: oEmit 9
3812: oGetLocal 1
3814: oPushResult
3815: oEmitInt
3816: oPop 1
3818: oEmit 27
3820: oJumpForward 3825
3822: Choice Lookup Table
           0   3810
3825: oGetAddrLocal 3
3827: oPushResult
3828: oGetLocal 2
3830: oPushResult
3831: oSetResult 2
3833: oPushResult
3834: oNodeGetInt
3835: oPop 2
3837: oAssign
3838: oGetLocal 3
3840: oPushResult
3841: oSetResult 1
3843: oPushResult
3844: equal
3845: oPop 2
3847: oChoice 3861
3849: oEmit 9
3851: oGetLocal 3
3853: oPushResult
3854: oEmitInt
3855: oPop 1
3857: oEmit 23
3859: oJumpForward 3864
3861: Choice Lookup Table
           0   3849
3864: oEmit 25
3866: oInputChoice 3874
3868: oJumpForward 3882
3870: oJumpForward 3880
3872: oJumpForward 3880
3874: Choice Lookup Table
          12   3872
          16   3868
3879: oEndChoice
3880: oJumpBack 3752
3882: oReturn
3883: oLocalSpace 2
3885: oTypeSNodeType
3886: oChoice 3890
3888: oJumpForward 3895
3890: Choice Lookup Table
          26   3888
3893: oError 11
3895: oTypeSTop
3896: oPushResult
3897: oSetResult 23
3899: oPushResult
3900: oNodeGet
3901: oPop 2
3903: oPushResult
3904: oScopeEnter
3905: oPop 1
3907: oInput 0
3909: oGetAddrLocal 1
3911: oPushResult
3912: oScopeFindRequire
3913: oAssign
3914: oGetLocal 1
3916: oPushResult
3917: oNodeType
3918: oPop 1
3920: oChoice 3924
3922: oJumpForward 3929
3924: Choice Lookup Table
          14   3922
3927: oError 12
3929: oScopeEnd
3930: oGetAddrLocal 2
3932: oPushResult
3933: oGetLocal 1
3935: oPushResult
3936: oSetResult 6
3938: oPushResult
3939: oNodeGetInt
3940: oPop 2
3942: oAssign
3943: oGetLocal 2
3945: oPushResult
3946: equal_zero
3947: oPop 1
3949: oChoice 3963
3951: oEmit 9
3953: oGetLocal 2
3955: oPushResult
3956: oEmitInt
3957: oPop 1
3959: oEmit 25
3961: oJumpForward 3966
3963: Choice Lookup Table
           0   3951
3966: oTypeSPop
3967: oGetLocal 1
3969: oPushResult
3970: oSetResult 5
3972: oPushResult
3973: oNodeGet
3974: oPop 2
3976: oPushResult
3977: oTypeSPush
3978: oPop 1
3980: oReturn
3981: oLocalSpace 1
3983: oTypeSNodeType
3984: oChoice 3988
3986: oJumpForward 3993
3988: Choice Lookup Table
          23   3986
3991: oError 9
3993: oEmit 16
3995: oGetAddrLocal 1
3997: oPushResult
3998: oTypeSTop
3999: oAssign
4000: oTypeSPop
4001: oGetLocal 1
4003: oPushResult
4004: oSetResult 19
4006: oPushResult
4007: oNodeGet
4008: oPop 2
4010: oPushResult
4011: oTypeSPush
4012: oPop 1
4014: oReturn
4015: oLocalSpace 0
4017: oCall 5618
4019: oReturn
4020: oLocalSpace 11
4022: oGetParam 1
4024: oPushResult
4025: oSetResult 11
4027: oPushResult
4028: oNodeGetBoolean
4029: oPop 2
4031: oChoice 4083
4033: oGetParam 1
4035: oPushResult
4036: oSetResult 13
4038: oPushResult
4039: oNodeGetBoolean
4040: oPop 2
4042: oChoice 4078
4044: oGetAddrLocal 1
4046: oPushResult
4047: oGetParam 1
4049: oPushResult
4050: oSetResult 4
4052: oPushResult
4053: oNodeGetInt
4054: oPop 2
4056: oPushResult
4057: oStringAllocLitFromIdent
4058: oPop 1
4060: oAssign
4061: oEmit 50
4063: oGetParam 1
4065: oPushResult
4066: oCall 5895
4068: oPop 1
4070: oGetLocal 1
4072: oPushResult
4073: oEmitInt
4074: oPop 1
4076: oJumpForward 4081
4078: Choice Lookup Table
           0   4044
4081: oJumpForward 4086
4083: Choice Lookup Table
           1   4033
4086: oGetParam 1
4088: oPushResult
4089: oSetResult 13
4091: oPushResult
4092: oSetResult 1
4094: oPushResult
4095: oNodeSetBoolean
4096: oPop 3
4098: oGetAddrLocal 2
4100: oPushResult
4101: oGetParam 1
4103: oPushResult
4104: oSetResult 12
4106: oPushResult
4107: oNodeGetBoolean
4108: oPop 2
4110: oAssign
4111: oGetAddrLocal 5
4113: oPushResult
4114: oGetParam 1
4116: oPushResult
4117: oNodeType
4118: oPop 1
4120: oPushResult
4121: oSetResult 8
4123: oPushResult
4124: equal_node_type
4125: oPop 2
4127: oAssign
4128: oGetLocal 5
4130: oChoice 4157
4132: oGetAddrLocal 3
4134: oPushResult
4135: oGetParam 1
4137: oPushResult
4138: oSetResult 5
4140: oPushResult
4141: oNodeGet
4142: oPop 2
4144: oAssign
4145: oGetAddrLocal 4
4147: oPushResult
4148: oGetLocal 3
4150: oPushResult
4151: oScopeAllocType
4152: oPop 1
4154: oAssign
4155: oJumpForward 4160
4157: Choice Lookup Table
           1   4132
4160: oGetAddrLocal 6
4162: oPushResult
4163: oGetParam 1
4165: oPushResult
4166: oSetResult 8
4168: oPushResult
4169: oNodeGet
4170: oPop 2
4172: oAssign
4173: oGetAddrLocal 7
4175: oPushResult
4176: oGetLocal 6
4178: oPushResult
4179: oSetResult 2
4181: oPushResult
4182: oNodeGetInt
4183: oPop 2
4185: oAssign
4186: oGetLocal 2
4188: oChoice 4210
4190: oEmit 39
4192: oGetLocal 7
4194: oPushResult
4195: oEmitInt
4196: oPop 1
4198: oJumpForward 4216
4200: oEmit 38
4202: oGetLocal 7
4204: oPushResult
4205: oEmitInt
4206: oPop 1
4208: oJumpForward 4216
4210: Choice Lookup Table
           0   4200
           1   4190
4215: oEndChoice
4216: oGetAddrLocal 8
4218: oPushResult
4219: oGetLocal 6
4221: oPushResult
4222: oSetResult 1
4224: oPushResult
4225: oNodeGetIter
4226: oPop 2
4228: oAssign
4229: oGetAddrLocal 9
4231: oPushResult
4232: oGetLocal 8
4234: oPushResult
4235: oNodeIterValue
4236: oPop 1
4238: oAssign
4239: oInputChoice 4418
4241: oGetLocal 9
4243: oPushResult
4244: oNodeNull
4245: oPop 1
4247: oChoice 4253
4249: oJumpForward 4414
4251: oJumpForward 4256
4253: Choice Lookup Table
           1   4249
4256: oGetAddrLocal 10
4258: oPushResult
4259: oGetLocal 9
4261: oPushResult
4262: oSetResult 6
4264: oPushResult
4265: oNodeGetInt
4266: oPop 2
4268: oAssign
4269: oEmit 13
4271: oGetLocal 10
4273: oPushResult
4274: oEmitInt
4275: oPop 1
4277: oGetLocal 9
4279: oPushResult
4280: oSetResult 5
4282: oPushResult
4283: oNodeGet
4284: oPop 2
4286: oPushResult
4287: oTypeSPush
4288: oPop 1
4290: oGetLocal 9
4292: oPushResult
4293: oSetResult 17
4295: oPushResult
4296: oNodeGetBoolean
4297: oPop 2
4299: oChoice 4367
4301: oCall 4901
4303: oCall 5618
4305: oEmit 19
4307: oJumpForward 4373
4309: oCall 2040
4311: oCall 4015
4313: oTypeSNodeType
4314: oChoice 4332
4316: oEmit 17
4318: oJumpForward 4365
4320: oEmit 18
4322: oJumpForward 4365
4324: oError 16
4326: oJumpForward 4365
4328: oEmit 19
4330: oJumpForward 4365
4332: Choice Lookup Table
          23   4328
          17   4324
          22   4324
          21   4324
          19   4320
          18   4316
4345: oGetAddrLocal 11
4347: oPushResult
4348: oTypeSTop
4349: oPushResult
4350: oSetResult 2
4352: oPushResult
4353: oNodeGetInt
4354: oPop 2
4356: oAssign
4357: oEmit 20
4359: oGetLocal 11
4361: oPushResult
4362: oEmitInt
4363: oPop 1
4365: oJumpForward 4373
4367: Choice Lookup Table
           0   4309
           1   4301
4372: oEndChoice
4373: oTypeSPop
4374: oGetAddrLocal 8
4376: oPushResult
4377: oNodeIterNext
4378: oPop 1
4380: oGetAddrLocal 9
4382: oPushResult
4383: oGetLocal 8
4385: oPushResult
4386: oNodeIterValue
4387: oPop 1
4389: oAssign
4390: oGetLocal 9
4392: oPushResult
4393: oNodeNull
4394: oPop 1
4396: oChoice 4404
4398: oJumpForward 4414
4400: oJumpForward 4410
4402: oJumpForward 4410
4404: Choice Lookup Table
           0   4402
           1   4398
4409: oEndChoice
4410: oInput 12
4412: oJumpBack 4241
4414: oInput 14
4416: oJumpForward 4421
4418: Choice Lookup Table
          13   4241
4421: oGetLocal 9
4423: oPushResult
4424: oNodeNull
4425: oPop 1
4427: oChoice 4433
4429: oError 15
4431: oJumpForward 4436
4433: Choice Lookup Table
           0   4429
4436: oGetLocal 5
4438: oChoice 4467
4440: oEmit 13
4442: oGetParam 1
4444: oPushResult
4445: oSetResult 16
4447: oPushResult
4448: oNodeGetInt
4449: oPop 2
4451: oPushResult
4452: oEmitInt
4453: oPop 1
4455: oEmit 11
4457: oGetLocal 4
4459: oPushResult
4460: oEmitInt
4461: oPop 1
4463: oEmit 19
4465: oJumpForward 4470
4467: Choice Lookup Table
           1   4440
4470: oGetLocal 2
4472: oChoice 4496
4474: oEmit 42
4476: oGetParam 1
4478: oPushResult
4479: oCall 5895
4481: oPop 1
4483: oJumpForward 4502
4485: oEmit 41
4487: oGetParam 1
4489: oPushResult
4490: oCall 5895
4492: oPop 1
4494: oJumpForward 4502
4496: Choice Lookup Table
           0   4485
           1   4474
4501: oEndChoice
4502: oGetLocal 5
4504: oChoice 4572
4506: oGetLocal 3
4508: oPushResult
4509: oTypeSPush
4510: oPop 1
4512: oTypeSNodeType
4513: oChoice 4549
4515: oEmit 3
4517: oGetLocal 4
4519: oPushResult
4520: oEmitInt
4521: oPop 1
4523: oJumpForward 4570
4525: oEmit 4
4527: oGetLocal 4
4529: oPushResult
4530: oEmitInt
4531: oPop 1
4533: oJumpForward 4570
4535: oError 16
4537: oJumpForward 4570
4539: oEmit 5
4541: oGetLocal 4
4543: oPushResult
4544: oEmitInt
4545: oPop 1
4547: oJumpForward 4570
4549: Choice Lookup Table
          23   4539
          17   4535
          22   4535
          21   4535
          19   4525
          18   4515
4562: oEmit 11
4564: oGetLocal 4
4566: oPushResult
4567: oEmitInt
4568: oPop 1
4570: oJumpForward 4575
4572: Choice Lookup Table
           1   4506
4575: oEmit 40
4577: oGetLocal 7
4579: oPushResult
4580: oEmitInt
4581: oPop 1
4583: oReturn
4584: oLocalSpace 0
4586: oInputChoice 4636
4588: oCall 5538
4590: oJumpForward 4661
4592: oCall 5545
4594: oJumpForward 4661
4596: oCall 5612
4598: oJumpForward 4661
4600: oCall 5615
4602: oJumpForward 4661
4604: oCall 5078
4606: oJumpForward 4661
4608: oCall 5398
4610: oJumpForward 4661
4612: oCall 5144
4614: oJumpForward 4661
4616: oCall 5318
4618: oJumpForward 4661
4620: oCall 5483
4622: oJumpForward 4661
4624: oCall 5451
4626: oJumpForward 4661
4628: oCall 5515
4630: oJumpForward 4661
4632: oCall 4662
4634: oJumpForward 4661
4636: Choice Lookup Table
           0   4632
          33   4628
          49   4624
          50   4620
          47   4616
          42   4612
          46   4608
          39   4604
          57   4600
          56   4596
          55   4592
          54   4588
4661: oReturn
4662: oLocalSpace 1
4664: oGetAddrLocal 1
4666: oPushResult
4667: oScopeFindRequire
4668: oAssign
4669: oGetLocal 1
4671: oPushResult
4672: oNodeType
4673: oPop 1
4675: oChoice 4704
4677: oGetLocal 1
4679: oPushResult
4680: oCall 4020
4682: oPop 1
4684: oJumpForward 4717
4686: oGetLocal 1
4688: oPushResult
4689: oCall 4718
4691: oPop 1
4693: oJumpForward 4717
4695: oGetLocal 1
4697: oPushResult
4698: oCall 4787
4700: oPop 1
4702: oJumpForward 4717
4704: Choice Lookup Table
           8   4695
          15   4686
          13   4686
          12   4686
           7   4677
4715: oError 0
4717: oReturn
4718: oLocalSpace 1
4720: oGetParam 1
4722: oPushResult
4723: oCall 4937
4725: oPop 1
4727: oInput 3
4729: oCall 2040
4731: oCall 5618
4733: oTypeSNodeType
4734: oChoice 4752
4736: oEmit 17
4738: oJumpForward 4785
4740: oEmit 18
4742: oJumpForward 4785
4744: oError 16
4746: oJumpForward 4785
4748: oEmit 19
4750: oJumpForward 4785
4752: Choice Lookup Table
          23   4748
          17   4744
          22   4744
          21   4744
          19   4740
          18   4736
4765: oGetAddrLocal 1
4767: oPushResult
4768: oTypeSTop
4769: oPushResult
4770: oSetResult 2
4772: oPushResult
4773: oNodeGetInt
4774: oPop 2
4776: oAssign
4777: oEmit 20
4779: oGetLocal 1
4781: oPushResult
4782: oEmitInt
4783: oPop 1
4785: oTypeSPop
4786: oReturn
4787: oLocalSpace 1
4789: oGetParam 1
4791: oPushResult
4792: oSetResult 9
4794: oPushResult
4795: oNodeGet
4796: oPop 2
4798: oPushResult
4799: oScopeCurrent
4800: oPushResult
4801: oNodeEqual
4802: oPop 2
4804: oChoice 4810
4806: oError 20
4808: oJumpForward 4813
4810: Choice Lookup Table
           0   4806
4813: oEmit 8
4815: oGetParam 1
4817: oPushResult
4818: oSetResult 16
4820: oPushResult
4821: oNodeGetInt
4822: oPop 2
4824: oPushResult
4825: oEmitInt
4826: oPop 1
4828: oGetParam 1
4830: oPushResult
4831: oSetResult 5
4833: oPushResult
4834: oNodeGet
4835: oPop 2
4837: oPushResult
4838: oTypeSPush
4839: oPop 1
4841: oInput 3
4843: oCall 2040
4845: oCall 5618
4847: oTypeSNodeType
4848: oChoice 4866
4850: oEmit 17
4852: oJumpForward 4899
4854: oEmit 18
4856: oJumpForward 4899
4858: oError 16
4860: oJumpForward 4899
4862: oEmit 19
4864: oJumpForward 4899
4866: Choice Lookup Table
          23   4862
          17   4858
          22   4858
          21   4858
          19   4854
          18   4850
4879: oGetAddrLocal 1
4881: oPushResult
4882: oTypeSTop
4883: oPushResult
4884: oSetResult 2
4886: oPushResult
4887: oNodeGetInt
4888: oPop 2
4890: oAssign
4891: oEmit 20
4893: oGetLocal 1
4895: oPushResult
4896: oEmitInt
4897: oPop 1
4899: oTypeSPop
4900: oReturn
4901: oLocalSpace 1
4903: oInput 0
4905: oGetAddrLocal 1
4907: oPushResult
4908: oScopeFindRequire
4909: oAssign
4910: oGetLocal 1
4912: oPushResult
4913: oNodeType
4914: oPop 1
4916: oChoice 4920
4918: oJumpForward 4929
4920: Choice Lookup Table
          15   4918
          13   4918
          12   4918
4927: oError 4
4929: oGetLocal 1
4931: oPushResult
4932: oCall 4937
4934: oPop 1
4936: oReturn
4937: oLocalSpace 0
4939: oGetParam 1
4941: oPushResult
4942: oNodeType
4943: oPop 1
4945: oChoice 5005
4947: oEmit 10
4949: oGetParam 1
4951: oPushResult
4952: oCall 5895
4954: oPop 1
4956: oJumpForward 5014
4958: oEmit 11
4960: oGetParam 1
4962: oPushResult
4963: oCall 5895
4965: oPop 1
4967: oJumpForward 5014
4969: oGetParam 1
4971: oPushResult
4972: oSetResult 17
4974: oPushResult
4975: oNodeGetBoolean
4976: oPop 2
4978: oChoice 4991
4980: oEmit 8
4982: oGetParam 1
4984: oPushResult
4985: oCall 5895
4987: oPop 1
4989: oJumpForward 5003
4991: Choice Lookup Table
           1   4980
4994: oEmit 12
4996: oGetParam 1
4998: oPushResult
4999: oCall 5895
5001: oPop 1
5003: oJumpForward 5014
5005: Choice Lookup Table
          15   4969
          13   4958
          12   4947
5012: oError 4
5014: oGetParam 1
5016: oPushResult
5017: oSetResult 5
5019: oPushResult
5020: oNodeGet
5021: oPop 2
5023: oPushResult
5024: oTypeSPush
5025: oPop 1
5027: oCall 3712
5029: oReturn
5030: oLocalSpace 0
5032: oGetParam 1
5034: oPushResult
5035: oCall 4937
5037: oPop 1
5039: oCall 5644
5041: oGetParam 1
5043: oPushResult
5044: oCall 3298
5046: oPop 1
5048: oTypeSPop
5049: oEmit 21
5051: oEmit 17
5053: oReturn
5054: oLocalSpace 0
5056: oGetParam 1
5058: oPushResult
5059: oCall 4937
5061: oPop 1
5063: oCall 5644
5065: oGetParam 1
5067: oPushResult
5068: oCall 3298
5070: oPop 1
5072: oTypeSPop
5073: oEmit 22
5075: oEmit 17
5077: oReturn
5078: oLocalSpace 2
5080: oGetAddrLocal 1
5082: oPushResult
5083: oSetResult 0
5085: oAssign
5086: oGetAddrLocal 1
5088: oPushResult
5089: oCall 2063
5091: oPop 1
5093: oInput 40
5095: oCall 4584
5097: oInputChoice 5132
5099: oGetAddrLocal 2
5101: oPushResult
5102: oLabelNew
5103: oAssign
5104: oEmit 45
5106: oGetLocal 2
5108: oPushResult
5109: oEmitLabel
5110: oPop 1
5112: oEmit 48
5114: oGetLocal 1
5116: oPushResult
5117: oEmitLabel
5118: oPop 1
5120: oCall 4584
5122: oEmit 48
5124: oGetLocal 2
5126: oPushResult
5127: oEmitLabel
5128: oPop 1
5130: oJumpForward 5143
5132: Choice Lookup Table
          41   5099
5135: oEmit 48
5137: oGetLocal 1
5139: oPushResult
5140: oEmitLabel
5141: oPop 1
5143: oReturn
5144: oLocalSpace 4
5146: oInput 0
5148: oGetAddrLocal 1
5150: oPushResult
5151: oScopeFindRequire
5152: oAssign
5153: oGetLocal 1
5155: oPushResult
5156: oCall 4937
5158: oPop 1
5160: oCall 5644
5162: oInput 3
5164: oCall 2040
5166: oCall 5644
5168: oEmit 17
5170: oGetAddrLocal 2
5172: oPushResult
5173: oLabelNew
5174: oAssign
5175: oGetAddrLocal 3
5177: oPushResult
5178: oLabelNew
5179: oAssign
5180: oEmit 45
5182: oGetLocal 3
5184: oPushResult
5185: oEmitLabel
5186: oPop 1
5188: oGetAddrLocal 4
5190: oPushResult
5191: oLabelNew
5192: oAssign
5193: oEmit 48
5195: oGetLocal 4
5197: oPushResult
5198: oEmitLabel
5199: oPop 1
5201: oInputChoice 5281
5203: oGetLocal 1
5205: oPushResult
5206: oCall 5030
5208: oPop 1
5210: oEmit 48
5212: oGetLocal 3
5214: oPushResult
5215: oEmitLabel
5216: oPop 1
5218: oGetLocal 1
5220: oPushResult
5221: oCall 3298
5223: oPop 1
5225: oTypeSPop
5226: oCall 2040
5228: oCall 5644
5230: oEmit 32
5232: oEmit 46
5234: oGetLocal 2
5236: oPushResult
5237: oEmitLabel
5238: oPop 1
5240: oJumpForward 5287
5242: oGetLocal 1
5244: oPushResult
5245: oCall 5054
5247: oPop 1
5249: oEmit 48
5251: oGetLocal 3
5253: oPushResult
5254: oEmitLabel
5255: oPop 1
5257: oGetLocal 1
5259: oPushResult
5260: oCall 3298
5262: oPop 1
5264: oTypeSPop
5265: oCall 2040
5267: oCall 5644
5269: oEmit 33
5271: oEmit 46
5273: oGetLocal 2
5275: oPushResult
5276: oEmitLabel
5277: oPop 1
5279: oJumpForward 5287
5281: Choice Lookup Table
          44   5242
          43   5203
5286: oEndChoice
5287: oGetLocal 4
5289: oPushResult
5290: oGetLocal 2
5292: oPushResult
5293: oLoopPush
5294: oPop 2
5296: oInput 45
5298: oCall 4584
5300: oEmit 45
5302: oGetLocal 4
5304: oPushResult
5305: oEmitLabel
5306: oPop 1
5308: oEmit 48
5310: oGetLocal 2
5312: oPushResult
5313: oEmitLabel
5314: oPop 1
5316: oLoopPop
5317: oReturn
5318: oLocalSpace 3
5320: oGetAddrLocal 1
5322: oPushResult
5323: oLabelNew
5324: oAssign
5325: oEmit 48
5327: oGetLocal 1
5329: oPushResult
5330: oEmitLabel
5331: oPop 1
5333: oGetAddrLocal 2
5335: oPushResult
5336: oLabelNew
5337: oAssign
5338: oGetLocal 1
5340: oPushResult
5341: oGetLocal 2
5343: oPushResult
5344: oLoopPush
5345: oPop 2
5347: oCall 4584
5349: oInputChoice 5380
5351: oCall 4584
5353: oJumpForward 5386
5355: oGetAddrLocal 3
5357: oPushResult
5358: oCall 2063
5360: oPop 1
5362: oEmit 49
5364: oGetLocal 3
5366: oPushResult
5367: oEmitLabel
5368: oPop 1
5370: oGetLocal 1
5372: oPushResult
5373: oEmitLabel
5374: oPop 1
5376: oJumpForward 5388
5378: oJumpForward 5386
5380: Choice Lookup Table
          48   5355
           4   5351
5385: oEndChoice
5386: oJumpBack 5349
5388: oEmit 48
5390: oGetLocal 2
5392: oPushResult
5393: oEmitLabel
5394: oPop 1
5396: oLoopPop
5397: oReturn
5398: oLocalSpace 2
5400: oGetAddrLocal 1
5402: oPushResult
5403: oLabelNew
5404: oAssign
5405: oEmit 48
5407: oGetLocal 1
5409: oPushResult
5410: oEmitLabel
5411: oPop 1
5413: oGetAddrLocal 2
5415: oPushResult
5416: oCall 2063
5418: oPop 1
5420: oGetLocal 1
5422: oPushResult
5423: oGetLocal 2
5425: oPushResult
5426: oLoopPush
5427: oPop 2
5429: oInput 45
5431: oCall 4584
5433: oEmit 45
5435: oGetLocal 1
5437: oPushResult
5438: oEmitLabel
5439: oPop 1
5441: oEmit 48
5443: oGetLocal 2
5445: oPushResult
5446: oEmitLabel
5447: oPop 1
5449: oLoopPop
5450: oReturn
5451: oLocalSpace 0
5453: oLoopContinueLabel
5454: oPushResult
5455: oSetResult 0
5457: oPushResult
5458: equal_label
5459: oPop 2
5461: oChoice 5476
5463: oError 18
5465: oJumpForward 5482
5467: oEmit 45
5469: oLoopContinueLabel
5470: oPushResult
5471: oEmitLabel
5472: oPop 1
5474: oJumpForward 5482
5476: Choice Lookup Table
           0   5467
           1   5463
5481: oEndChoice
5482: oReturn
5483: oLocalSpace 0
5485: oLoopBreakLabel
5486: oPushResult
5487: oSetResult 0
5489: oPushResult
5490: equal_label
5491: oPop 2
5493: oChoice 5508
5495: oError 18
5497: oJumpForward 5514
5499: oEmit 45
5501: oLoopBreakLabel
5502: oPushResult
5503: oEmitLabel
5504: oPop 1
5506: oJumpForward 5514
5508: Choice Lookup Table
           0   5499
           1   5495
5513: oEndChoice
5514: oReturn
5515: oLocalSpace 0
5517: oCall 4584
5519: oInputChoice 5529
5521: oCall 4584
5523: oJumpForward 5535
5525: oJumpForward 5537
5527: oJumpForward 5535
5529: Choice Lookup Table
          34   5525
           4   5521
5534: oEndChoice
5535: oJumpBack 5519
5537: oReturn
5538: oLocalSpace 0
5540: oCall 5545
5542: oEmit 55
5544: oReturn
5545: oLocalSpace 0
5547: oInputChoice 5608
5549: oCall 2040
5551: oTypeSNodeType
5552: oChoice 5574
5554: oEmit 51
5556: oJumpForward 5589
5558: oEmit 52
5560: oJumpForward 5589
5562: oEmit 53
5564: oJumpForward 5589
5566: oError 16
5568: oJumpForward 5589
5570: oEmit 54
5572: oJumpForward 5589
5574: Choice Lookup Table
          23   5570
          17   5566
          21   5566
          22   5562
          19   5558
          18   5554
5587: oError 17
5589: oTypeSPop
5590: oInputChoice 5598
5592: oJumpForward 5606
5594: oJumpForward 5604
5596: oJumpForward 5604
5598: Choice Lookup Table
          12   5596
          14   5592
5603: oEndChoice
5604: oJumpBack 5549
5606: oJumpForward 5611
5608: Choice Lookup Table
          13   5549
5611: oReturn
5612: oLocalSpace 0
5614: oReturn
5615: oLocalSpace 0
5617: oReturn
5618: oLocalSpace 1
5620: oGetAddrLocal 1
5622: oPushResult
5623: oTypeSNodeType
5624: oAssign
5625: oTypeSPop
5626: oGetLocal 1
5628: oPushResult
5629: oTypeSNodeType
5630: oPushResult
5631: equal_node_type
5632: oPop 2
5634: oChoice 5640
5636: oError 14
5638: oJumpForward 5643
5640: Choice Lookup Table
           0   5636
5643: oReturn
5644: oLocalSpace 0
5646: oTypeSNodeType
5647: oChoice 5651
5649: oJumpForward 5656
5651: Choice Lookup Table
          18   5649
5654: oError 7
5656: oTypeSPop
5657: oReturn
5658: oLocalSpace 0
5660: oTypeSNodeType
5661: oChoice 5665
5663: oJumpForward 5670
5665: Choice Lookup Table
          18   5663
5668: oError 7
5670: oReturn
5671: oLocalSpace 0
5673: oTypeSNodeType
5674: oChoice 5678
5676: oJumpForward 5683
5678: Choice Lookup Table
          19   5676
5681: oError 8
5683: oTypeSPop
5684: oReturn
5685: oLocalSpace 0
5687: oTypeSNodeType
5688: oChoice 5692
5690: oJumpForward 5697
5692: Choice Lookup Table
          19   5690
5695: oError 8
5697: oReturn
5698: oLocalSpace 1
5700: oGetAddrLocal 1
5702: oPushResult
5703: oGetParam 2
5705: oPushResult
5706: oNodeNew
5707: oPop 1
5709: oAssign
5710: oGetLocal 1
5712: oPushResult
5713: oSetResult 2
5715: oPushResult
5716: oGetParam 1
5718: oPushResult
5719: oNodeSetInt
5720: oPop 3
5722: oGetLocal 1
5724: oPushResult
5725: oTypeAdd
5726: oPop 1
5728: oGetLocal 1
5730: oReturn
5731: oReturn
5732: oLocalSpace 1
5734: oGetAddrLocal 1
5736: oPushResult
5737: oGetParam 3
5739: oPushResult
5740: oNodeNew
5741: oPop 1
5743: oAssign
5744: oGetLocal 1
5746: oPushResult
5747: oSetResult 4
5749: oPushResult
5750: oGetParam 1
5752: oPushResult
5753: oNodeSetInt
5754: oPop 3
5756: oGetLocal 1
5758: oReturn
5759: oReturn
5760: oLocalSpace 1
5762: oGetAddrLocal 1
5764: oPushResult
5765: oGetParam 1
5767: oPushResult
5768: oSetResult 18
5770: oPushResult
5771: oNodeGet
5772: oPop 2
5774: oAssign
5775: oGetLocal 1
5777: oPushResult
5778: oNodeNull
5779: oPop 1
5781: oChoice 5837
5783: oGetAddrLocal 1
5785: oPushResult
5786: oSetResult 23
5788: oPushResult
5789: oNodeNew
5790: oPop 1
5792: oAssign
5793: oGetLocal 1
5795: oPushResult
5796: oSetResult 19
5798: oPushResult
5799: oGetParam 1
5801: oPushResult
5802: oNodeSet
5803: oPop 3
5805: oGetLocal 1
5807: oPushResult
5808: oSetResult 2
5810: oPushResult
5811: oSetResult 8
5813: oPushResult
5814: oNodeSetInt
5815: oPop 3
5817: oGetLocal 1
5819: oPushResult
5820: oTypeAdd
5821: oPop 1
5823: oGetParam 1
5825: oPushResult
5826: oSetResult 18
5828: oPushResult
5829: oGetLocal 1
5831: oPushResult
5832: oNodeSet
5833: oPop 3
5835: oJumpForward 5840
5837: Choice Lookup Table
           1   5783
5840: oGetLocal 1
5842: oReturn
5843: oReturn
5844: oLocalSpace 0
5846: oGetParam 1
5848: oPushResult
5849: oNodeType
5850: oPop 1
5852: oChoice 5880
5854: oMININT
5855: oReturn
5856: oJumpForward 5894
5858: oSetResult 0
5860: oReturn
5861: oJumpForward 5894
5863: oSetResult 0
5865: oReturn
5866: oJumpForward 5894
5868: oGetParam 1
5870: oPushResult
5871: oSetResult 21
5873: oPushResult
5874: oNodeGetInt
5875: oPop 2
5877: oReturn
5878: oJumpForward 5894
5880: Choice Lookup Table
          25   5868
          21   5863
          19   5858
          18   5854
5889: oError 3
5891: oSetResult 0
5893: oReturn
5894: oReturn
5895: oLocalSpace 0
5897: oGetParam 1
5899: oPushResult
5900: oSetResult 6
5902: oPushResult
5903: oNodeGetInt
5904: oPop 2
5906: oPushResult
5907: oEmitInt
5908: oPop 1
5910: oReturn
5911: oLocalSpace 1
5913: oGetAddrGlobal 2
5915: oPushResult
5916: oSetResult 17
5918: oPushResult
5919: oSetResult 4
5921: oPushResult
5922: oCall 5698
5924: oPop 2
5926: oAssign
5927: oGetAddrGlobal 3
5929: oPushResult
5930: oSetResult 18
5932: oPushResult
5933: oSetResult 4
5935: oPushResult
5936: oCall 5698
5938: oPop 2
5940: oAssign
5941: oGetAddrGlobal 4
5943: oPushResult
5944: oSetResult 19
5946: oPushResult
5947: oSetResult 1
5949: oPushResult
5950: oCall 5698
5952: oPop 2
5954: oAssign
5955: oGetAddrGlobal 5
5957: oPushResult
5958: oSetResult 20
5960: oPushResult
5961: oSetResult 1
5963: oPushResult
5964: oCall 5698
5966: oPop 2
5968: oAssign
5969: oGetAddrGlobal 6
5971: oPushResult
5972: oSetResult 21
5974: oPushResult
5975: oSetResult 1
5977: oPushResult
5978: oCall 5698
5980: oPop 2
5982: oAssign
5983: oGetAddrGlobal 7
5985: oPushResult
5986: oSetResult 22
5988: oPushResult
5989: oSetResult 256
5991: oPushResult
5992: oCall 5698
5994: oPop 2
5996: oAssign
5997: oGetAddrLocal 1
5999: oPushResult
6000: oSetResult 10
6002: oPushResult
6003: oSetResult 5
6005: oPushResult
6006: oIdAdd_File
6007: oPushResult
6008: oCall 5732
6010: oPop 3
6012: oAssign
6013: oGetLocal 1
6015: oPushResult
6016: oSetResult 5
6018: oPushResult
6019: oGetGlobal 2
6021: oPushResult
6022: oNodeSet
6023: oPop 3
6025: oGetLocal 1
6027: oPushResult
6028: oScopeDeclare
6029: oPop 1
6031: oGetAddrLocal 1
6033: oPushResult
6034: oSetResult 10
6036: oPushResult
6037: oSetResult 5
6039: oPushResult
6040: oIdAdd_Integer
6041: oPushResult
6042: oCall 5732
6044: oPop 3
6046: oAssign
6047: oGetLocal 1
6049: oPushResult
6050: oSetResult 5
6052: oPushResult
6053: oGetGlobal 3
6055: oPushResult
6056: oNodeSet
6057: oPop 3
6059: oGetLocal 1
6061: oPushResult
6062: oScopeDeclare
6063: oPop 1
6065: oGetAddrLocal 1
6067: oPushResult
6068: oSetResult 10
6070: oPushResult
6071: oSetResult 5
6073: oPushResult
6074: oIdAdd_Boolean
6075: oPushResult
6076: oCall 5732
6078: oPop 3
6080: oAssign
6081: oGetLocal 1
6083: oPushResult
6084: oSetResult 5
6086: oPushResult
6087: oGetGlobal 4
6089: oPushResult
6090: oNodeSet
6091: oPop 3
6093: oGetLocal 1
6095: oPushResult
6096: oScopeDeclare
6097: oPop 1
6099: oGetAddrLocal 1
6101: oPushResult
6102: oSetResult 10
6104: oPushResult
6105: oSetResult 5
6107: oPushResult
6108: oIdAdd_Char
6109: oPushResult
6110: oCall 5732
6112: oPop 3
6114: oAssign
6115: oGetLocal 1
6117: oPushResult
6118: oSetResult 5
6120: oPushResult
6121: oGetGlobal 6
6123: oPushResult
6124: oNodeSet
6125: oPop 3
6127: oGetLocal 1
6129: oPushResult
6130: oScopeDeclare
6131: oPop 1
6133: oGetAddrLocal 1
6135: oPushResult
6136: oSetResult 10
6138: oPushResult
6139: oSetResult 5
6141: oPushResult
6142: oIdAdd_String
6143: oPushResult
6144: oCall 5732
6146: oPop 3
6148: oAssign
6149: oGetLocal 1
6151: oPushResult
6152: oSetResult 5
6154: oPushResult
6155: oGetGlobal 7
6157: oPushResult
6158: oNodeSet
6159: oPop 3
6161: oGetLocal 1
6163: oPushResult
6164: oScopeDeclare
6165: oPop 1
6167: oGetAddrLocal 1
6169: oPushResult
6170: oSetResult 9
6172: oPushResult
6173: oSetResult 4
6175: oPushResult
6176: oIdAdd_True
6177: oPushResult
6178: oCall 5732
6180: oPop 3
6182: oAssign
6183: oGetLocal 1
6185: oPushResult
6186: oSetResult 5
6188: oPushResult
6189: oGetGlobal 4
6191: oPushResult
6192: oNodeSet
6193: oPop 3
6195: oGetLocal 1
6197: oPushResult
6198: oSetResult 6
6200: oPushResult
6201: oSetResult 1
6203: oPushResult
6204: oNodeSetInt
6205: oPop 3
6207: oGetLocal 1
6209: oPushResult
6210: oScopeDeclare
6211: oPop 1
6213: oGetAddrLocal 1
6215: oPushResult
6216: oSetResult 9
6218: oPushResult
6219: oSetResult 4
6221: oPushResult
6222: oIdAdd_False
6223: oPushResult
6224: oCall 5732
6226: oPop 3
6228: oAssign
6229: oGetLocal 1
6231: oPushResult
6232: oSetResult 5
6234: oPushResult
6235: oGetGlobal 4
6237: oPushResult
6238: oNodeSet
6239: oPop 3
6241: oGetLocal 1
6243: oPushResult
6244: oSetResult 6
6246: oPushResult
6247: oSetResult 0
6249: oPushResult
6250: oNodeSetInt
6251: oPop 3
6253: oGetLocal 1
6255: oPushResult
6256: oScopeDeclare
6257: oPop 1
6259: oReturn
