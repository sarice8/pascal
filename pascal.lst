   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qParentScope
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin( 0 )
  10:    globalScope = oScopeCurrent
      
  15:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  17:    .tEnter  oEmitInt( 0 )
  25:    Label mainLabel = oLabelNew
      
  30:    .tAllocActuals  oEmitInt( 0 )
  38:    .tCall  oEmitLabel( mainLabel )
  46:    .tFreeActuals  oEmitInt( 0 )
  54:    .tReturn
      
  56:    pProgram
  58:    pIdent
      
  60:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  76:    oScopeDeclare( progDecl )
      
  82:    [
  82:       | '(' :
  84:          pIdent      % input, output files
      
  86:          t = @newIdent( nVar, kVar, LAST_ID )
 102:          oNodeSet( t, qType, FileType )
 114:          oScopeDeclareAlloc( t )
      
 120:          ','
 122:          pIdent
      
 124:          t = @newIdent( nVar, kVar, LAST_ID )
 140:          oNodeSet( t, qType, FileType )
 152:          oScopeDeclareAlloc( t )
      
 158:          ')'
 160:       | * :
 165:    ]
 165:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 167:    oScopeBegin( 0 )
 173:    mainRoutineScope = oScopeCurrent
 178:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 189:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
 200:    oScopeEnd
      
 201:    @BlockDecls( nGlobalVar )
      
      
 208:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 214:    @BlockStmt( mainLabel, globalScope )
      
 224:    oScopeEnd   % main routine scope
      
 225:    '.'
 227:    oScopeEnd   % global scope
 229:    ;
      
      
 229: Block( node_type varNodeType, Label labelForBody ):
 231:    @BlockDecls( varNodeType )
 238:    @BlockStmt( labelForBody, oScopeCurrent )
 248:    ;
      
      
 248: BlockDecls( node_type varNodeType ):
 250:    {[
 250:       | pConst :     @ConstDecl
 254:       | pType :      @TypeDecl
 258:       | pVar :       @VarDecl( varNodeType )
 267:       | pProcedure : @ProcDecl
 271:       | pFunction :  @FuncDecl
 275:       | * :          >
 290:    ]}
 292:    @CheckForUndefinedMethods
 295:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 295: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 298:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 298: BlockStmt( Label labelForBody, Node varScope ):
 300:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 308:    int patchLS
 308:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 317:    Code initCode = oNodeGetCode( varScope, qInitCode )
 330:    oEmitCode( initCode )
 336:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 347:    @Statement
 349:    .tReturn
      
 351:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 363:    oPatch( patchLS, localSpace )
 373:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 373: MethodModifiers( Node decl ):
 375:    {[
 375:       | pCdecl :
 377:          oNodeSetBoolean( decl, qCdecl, true )
 389:          ';'
      
 391:       | * : >
 398:    ]}
 401:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 401: GetOrCreateInitCode >> Code:
 403:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 415:    [ equal_code( initCode, codeNull )
 425:       | true :
 426:          initCode = oCodeNew
 431:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 442:       | * :
 447:    ]
 447:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 451: ExternalDecl( Node decl ):
 453:    [ equal_zero( oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel ) )
 474:       | false :  #eExternalMethodCannotBeNested
 477:       | * :
 482:    ]
 482:    oNodeSetBoolean( decl, qExternal, true )
 494:    [
 494:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 496:          [
 496:             | pName :
 498:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 500:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 511:             | * :
 516:          ]
 516:       | * :
 521:    ]
 522:    ;
      
      
 522: ProcDecl:
 524:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 526:    boolean redeclaring = false
 532:    Node decl = oScopeFindInCurrentScope
      
 537:    [ oNodeNull( decl )
 544:       | true :
               % first declaration
 545:          decl = @newIdent( nProc, kProc, LAST_ID )
 561:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 572:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 574:          redeclaring = true
 580:          [ oNodeGetBoolean( decl, qBodyDefined )
 590:             | true : #eAlreadyDefined
 593:             | * :
 598:          ]
 598:          [ oNodeGetBoolean( decl, qExternal )
 608:             | true : #eAlreadyDefined
 611:             | * :
 616:          ]
 616:          [ oNodeType( decl )
 623:             | nProc :
 624:             | * : #eAlreadyDefined   % wrong kind
 631:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 631:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 650:          oNodeSet( decl, qParams, Null )
 662:    ]
      
 670:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 682:    boolean nested = greater( level, 0 )
 695:    inc( level )
 701:    oScopeBegin( level )
 707:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
 712:    [ nested
 715:       | true :
 716:          oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
 727:       | * :
 732:    ]
      
 732:    @FormalArgDecl
 734:    oNodeSet( decl, qParams, paramScope )
 746:    oScopeEnd
 747:    ';'
      
 749:    [ redeclaring
 752:       | false : oScopeDeclare( decl )
 759:       | true :  % TO DO: check that qParams is consistent with qOldParams
 761:    ]
      
 769:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 776:    [
 776:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 778:       | pExternal : @ExternalDecl( decl )
      
 787:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 794:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 800:          oScopeBegin( level )
 806:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 817:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 828:          Label label = oNodeGetLabel( decl, qValue )
 841:          @Block( nLocalVar, label )
 851:          oNodeSetBoolean( decl, qBodyDefined, true )
 863:          oScopeEnd
      
 864:          oScopeEnd  % paramScope
 865:    ]
 865:    ';';
      
      
 868: FuncDecl:
 870:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 872:    boolean redeclaring = false
 878:    Node decl = oScopeFindInCurrentScope
      
 883:    [ oNodeNull( decl )
 890:       | true :
               % first declaration
 891:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 907:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 918:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 920:          redeclaring = true
 926:          [ oNodeGetBoolean( decl, qBodyDefined )
 936:             | true : #eAlreadyDefined
 939:             | * :
 944:          ]
 944:          [ oNodeType( decl )
 951:             | nFunc :
 952:             | * : #eAlreadyDefined   % wrong kind
 959:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 959:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 978:          oNodeSet( decl, qParams, Null )
 990:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1009:          oNodeSet( decl, qType, Null )
1021:    ]
      
1029:    int level = oNodeGetInt( oScopeCurrent, qLevel )
1041:    boolean nested = greater( level, 0 )
1054:    inc( level )
1060:    oScopeBegin( level )
1066:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1071:    [ nested
1074:       | true :
1075:          oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1086:       | * :
1091:    ]
      
1091:    @FormalArgDecl
1093:    oNodeSet( decl, qParams, paramScope )
      
1105:    ':'
      
1107:    Node theType
1107:    @TypeRef( theType )
1114:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1126:    Node ptrType = @PointerTypeTo( theType )
1137:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1153:    oScopeEnd
1154:    ';'
      
1156:    [ redeclaring
1159:       | false : oScopeDeclare( decl )
1166:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1168:    ]
      
1176:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1183:    [
1183:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1185:       | pExternal : @ExternalDecl( decl )
      
1194:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1201:          oScopeEnter( paramScope )
      
1207:          oScopeBegin( level )
1213:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1224:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1235:          Label label = oNodeGetLabel( decl, qValue )
1248:          @Block( nLocalVar, label )
1258:          oNodeSetBoolean( decl, qBodyDefined, true )
1270:          oScopeEnd
      
1271:          oScopeEnd  % paramScope
1272:    ]
1272:    ';';
      
      
1275: FormalArgDecl:
1277:    [
1277:       | '(' :
1279:          {
1279:             NodeVec decls = oNodeVecNew
1284:             Node decl
1284:             boolean isInOut = false
      
1290:             [
1290:                | pVar : isInOut = true
1298:                | * :
1303:             ]
      
1303:             {  pIdent
      
1305:                decl = @newIdent( nParam, kVar, LAST_ID )
1321:                oNodeSetBoolean( decl, qInOut, isInOut )
1333:                oNodeVecAppend( decls, decl )
      
1342:                [
1342:                   | ':' : >
1346:                   | ',' :
1348:                ]
1356:             }
      
1358:             Node theType
1358:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1365:             Node allocType
1365:             [ isInOut
1368:                | true :   allocType = @PointerTypeTo( theType )
1380:                | * :      allocType = theType
1391:             ]
      
1391:             int i = 0
1397:             {[ equal( i, oNodeVecSize( decls ) )
1411:                | false :
1412:                   decl = oNodeVecElement( decls, i )
      
1425:                   oNodeSet( decl, qType, theType )
1437:                   oScopeDeclare( decl )
1443:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1459:                   inc( i )
1465:                | * :
1470:                   >
1472:             ]}
      
1474:             oNodeVecDelete( decls )
      
1480:             [
1480:                | ')' : >
1484:                | ';' :
1486:             ]
1494:          }
1496:       | * :
1501:    ];
      
1502: ConstDecl:
1504:    {[
1504:       | pIdent :
1506:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1522:          '='
      
1524:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1526:          int val = oValueTop
1531:          oValuePop
1532:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1544:          oNodeSet( decl, qType, IntegerType )
      
1556:          oScopeDeclare( decl )
1562:          ';'
1564:       | * :
1569:          >
1571:    ]};
      
1574: TypeDecl:
1576:    {[
1576:       | pIdent :
1578:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1594:          '='
1596:          Node theType
1596:          @TypeRef( theType )
1603:          oNodeSet( decl, qType, theType )
1615:          oScopeDeclare( decl )
1621:          ';'
1623:       | * :
1628:          >
1630:    ]};
      
1633: VarDecl( node_type varNodeType ):
1635:    {[
1635:       | pIdent :
1637:          NodeVec decls = oNodeVecNew
1642:          Node decl
1642:          {
1642:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1658:             oNodeVecAppend( decls, decl )
1667:             [
1667:                | ',' :
1669:                   pIdent
1671:                | * :
1676:                   >
1678:             ]
1678:          }
1680:          ':'
1682:          Node theType
1682:          @TypeRef( theType )
      
1689:          int i = 0
1695:          {[ equal( i, oNodeVecSize( decls ) )
1709:             | false :
1710:                decl = oNodeVecElement( decls, i )
1723:                oNodeSet( decl, qType, theType )
1735:                oScopeDeclareAlloc( decl )
1741:                inc( i )
1747:             | * :
1752:               >
1754:          ]}
      
               % optional initialization
1756:          [
1756:             | '=' :
1758:                [ oNodeVecSize( decls )
1765:                   | 1 :
1766:                   | * :  #eOnlyOneVarCanBeInitialized
1773:                ]
      
                     % we need an initCode stream for this scope
1773:                Code initCode = @GetOrCreateInitCode
1779:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1785:                boolean changedScope = false
1791:                [ equal_node( oScopeCurrent, globalScope )
1800:                   | true : oScopeEnter( mainRoutineScope )
1807:                            changedScope = true
1813:                   | * :
1818:                ]
                     % generate assignment in initCode stream
1818:                @LValueVar( decl )
1825:                @Expr
1827:                @MatchTypes
1829:                @Assign
1831:                [ changedScope
1834:                   | true : oScopeEnd
1836:                   | * :
1841:                ]
1841:                oCodePop
                   
1842:             | * :
1847:          ]
      
1847:          oNodeVecDelete( decls )
1853:          ';'
1855:       | * :
1860:          >
1862:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1865: TypeRef( out Node resultType ):
1867:    [
1867:       | pIdent :           % previously named type (including intrinsics)
1869:          Node decl = oScopeFindRequire
1874:          [ oNodeType( decl )
1881:            | nTypeDecl :
1882:                resultType = oNodeGet( decl, qType )
1895:            | * :
1900:                #eNotType
1902:                resultType = IntegerType
1908:          ]
         
1908:       | pArray :
1910:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1912:          NodeVec dimensions = oNodeVecNew
      
1917:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1917:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1927:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1939:             @ConstExpr
1941:             oNodeSetInt( subrange, qLow, oValueTop )
1952:             oValuePop
1953:             '..'
1955:             @ConstExpr
1957:             oNodeSetInt( subrange, qHigh, oValueTop )
1968:             oValuePop
1969:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1981:             oTypeAdd( subrange )
      
1987:             Node a = oNodeNew( nArrayType )
1997:             oNodeSet( a, qIndexType, subrange )
      
2009:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
2018:             [
2018:                | ']' : >
2022:                | ',' :
2024:             ]
2032:          }
      
2034:          pOf
2036:          Node baseType
2036:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
2043:          int dim = oNodeVecSize( dimensions )
      
2053:          {
2053:              dec(dim)
      
2059:              Node a = oNodeVecElement( dimensions, dim )
      
2072:              oNodeSet( a, qBaseType, baseType )
2084:              Node subrange = oNodeGet( a, qIndexType )
2097:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2124:              inc( width )
2130:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2156:              oTypeAdd( a )
2162:              baseType = a
      
2168:              [ equal_zero(dim)
2175:                  | true:  >
2178:                  | *:
2183:              ]
2183:          }
      
2185:          resultType = oNodeVecElement( dimensions, 0 )
2198:          oNodeVecDelete( dimensions )
      
2204:       | '^' :
2206:          Node theType
2206:          @TypeRef( theType )
2213:          resultType = @PointerTypeTo( theType )
      
2224:       | pRecord :
2226:          resultType = oNodeNew( nRecordType )
2236:          oScopeBegin( -1 )    % level is meaningless here
      
2242:          @VarDecl( nRecordField )
      
2249:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2261:          [ equal_zero( size )
2268:             | true : #eRecordEmpty
2271:             | * :
2276:          ]
      
2276:          pEnd
      
2278:          oNodeSet( resultType, qScope, oScopeCurrent )
2289:          oNodeSetInt( resultType, qSize, size )
2301:          oScopeEnd
2302:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2308:       | pSet :
2310:          pOf
2312:          Node theType
2312:          @TypeRef( theType )
2319:       | * :       % this works for cases except where expr starts with an id
2332:          @ConstExpr '..' @ConstExpr
2338:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2339: ConstExpr:
2341:    [
2341:       | pIntLit :
2343:          oValuePush( TOKEN_VALUE )
2348:       | pIdent :
2350:          Node decl = oScopeFindRequire
2355:          [ oNodeType( decl )
2362:             | nConst :
2363:                oValuePush( oNodeGetInt( decl, qValue ) )
2376:             | * :
2381:                #eNotConst
2383:                oValuePush( 0 )
2389:          ]
2389:       | pMinus :
2391:          @ConstExpr
2393:          oValueNegate
2394:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2405: Expr:
2407:    Label falseLabel = labelNull
      
2413:    @ExprAllowCF( falseLabel )
2420:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2428: BooleanExprControlFlow( out Label falseLabel ):
2430:    @ExprAllowCF( falseLabel )
2437:    [ oTypeSNodeType
2439:       | nBooleanCFType :
2440:       | nBooleanType :
               % convert value to control flow
2442:          falseLabel = oLabelNew
2447:          .tJumpFalse  oEmitLabel( falseLabel )
2455:       | * :
2462:          #eNotBoolean
2464:    ]
2464:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2466: CFToVal( inout Label falseLabel ):
2468:    [ oTypeSNodeType
2470:       | nBooleanCFType :
2471:          Label doneLabel = oLabelNew
2476:          .tPushConstI  oEmitInt( 1 )
2484:          .tJump  oEmitLabel( doneLabel )
2492:          .tLabel  oEmitLabel( falseLabel )
2500:          .tPushConstI  oEmitInt( 0 )
2508:          .tLabel  oEmitLabel( doneLabel )
2516:          oTypeSPop
2517:          oTypeSPush( BooleanType )
2523:          falseLabel = labelNull
2529:       | * :
2534:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2535: ValToCF( out Label falseLabel ):
2537:    [ oTypeSNodeType
2539:       | nBooleanType :
2540:          falseLabel = oLabelNew
2545:          .tJumpFalse  oEmitLabel( falseLabel )
2553:          oTypeSPop
2554:          oTypeSPush( BooleanCFType )
2560:       | * :
2565:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2566: ExprAllowCF( out Label falseLabel ):
2568:    @BoolExprAllowCF( falseLabel )
2575:    {[
2575:       | '=' :
2577:          @CFToVal( falseLabel )
2584:          @BoolExprAllowCF( falseLabel )
2591:          @CFToVal( falseLabel )
2598:          @MatchTypes
2600:          [ oTypeSNodeType
2602:             | nIntegerType, nBooleanType :  .tEqualI
2605:             | nPointerType :                .tEqualP
2609:             | nCharType, nStringType :      #eNotImplemented
2613:             | * :                           #eNotAllowed
2628:          ]
2628:          oTypeSPop
2629:          oTypeSPush( BooleanType )
      
2635:       | '<>' :
2637:          @CFToVal( falseLabel )
2644:          @BoolExprAllowCF( falseLabel )
2651:          @CFToVal( falseLabel )
2658:          @MatchTypes
2660:          [ oTypeSNodeType
2662:             | nIntegerType, nBooleanType :  .tNotEqualI
2665:             | nPointerType :                .tNotEqualP
2669:             | nCharType, nStringType :      #eNotImplemented
2673:             | * :                           #eNotAllowed
2688:          ]
2688:          oTypeSPop
2689:          oTypeSPush( BooleanType )
      
2695:       | '<' :
2697:          @CFToVal( falseLabel )
2704:          @BoolExprAllowCF( falseLabel )
2711:          @CFToVal( falseLabel )
2718:          @MatchTypes
2720:          [ oTypeSNodeType
2722:             | nIntegerType, nBooleanType :  .tLessI
2725:             | nCharType, nStringType :      #eNotImplemented
2729:             | * :                           #eNotAllowed
2742:          ]
2742:          oTypeSPop
2743:          oTypeSPush( BooleanType )
      
2749:       | '>' :
2751:          @CFToVal( falseLabel )
2758:          @BoolExprAllowCF( falseLabel )
2765:          @CFToVal( falseLabel )
2772:          @MatchTypes
2774:          [ oTypeSNodeType
2776:             | nIntegerType, nBooleanType :  .tGreaterI
2779:             | nCharType, nStringType :      #eNotImplemented
2783:             | * :                           #eNotAllowed
2796:          ]
2796:          oTypeSPop
2797:          oTypeSPush( BooleanType )
      
2803:       | '<=' :
2805:          @CFToVal( falseLabel )
2812:          @BoolExprAllowCF( falseLabel )
2819:          @CFToVal( falseLabel )
2826:          @MatchTypes
2828:          [ oTypeSNodeType
2830:             | nIntegerType, nBooleanType :  .tLessEqualI
2833:             | nCharType, nStringType :      #eNotImplemented
2837:             | * :                           #eNotAllowed
2850:          ]
2850:          oTypeSPop
2851:          oTypeSPush( BooleanType )
      
2857:       | '>=' :
2859:          @CFToVal( falseLabel )
2866:          @BoolExprAllowCF( falseLabel )
2873:          @CFToVal( falseLabel )
2880:          @MatchTypes
2882:          [ oTypeSNodeType
2884:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2887:             | nCharType, nStringType :      #eNotImplemented
2891:             | * :                           #eNotAllowed
2904:          ]
2904:          oTypeSPop
2905:          oTypeSPush( BooleanType )
      
2911:       | * :
2926:          >
2928:    ]};
      
      
2931: BoolExprAllowCF( out Label falseLabel ):
2933:    Label trueLabel = labelNull
      
2939:    @BoolTermAllowCF( falseLabel )
2946:    {[
2946:       | pOr :
2948:          [ oTypeSNodeType
2950:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2951:                [ equal_label( trueLabel, labelNull )
2961:                   | true :  trueLabel = oLabelNew
2967:                   | * :
2972:                ]
2972:                .tJump  oEmitLabel( trueLabel )
2980:             | nBooleanType :
2982:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2989:                [ equal_label( trueLabel, labelNull )
2999:                   | true :  trueLabel = oLabelNew
3005:                   | * :
3010:                ]
3010:                .tJump  oEmitLabel( trueLabel )
3018:             | * : #eNotBoolean
3027:          ]
3027:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
3028:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
3036:          falseLabel = labelNull
3042:          @BoolTermAllowCF( falseLabel )
      
3049:          [ oTypeSNodeType
3051:             | nBooleanCFType :
3052:             | nBooleanType :
3054:                @ValToCF( falseLabel )
3061:             | * : #eNotBoolean
3070:          ]
      
3070:          oTypeSPop
3071:          oTypeSPush( BooleanCFType )
      
3077:       | * :
3082:          >
3084:    ]}
      
         % any short-circuit trues jump here to the end
3086:    [ equal_label( trueLabel, labelNull )
3096:       | false :
3097:          .tLabel  oEmitLabel( trueLabel )
3105:       | * :
3110:    ]
3111:    ;
      
      
3111: BoolTermAllowCF( out Label falseLabel ):
3113:    Label overallFalseLabel = labelNull
      
3119:    @BoolFactorAllowCF( falseLabel )
3126:    {[
3126:       | pAnd :
3128:          [ oTypeSNodeType
3130:             | nBooleanCFType :
3131:             | nBooleanType :
3133:                @ValToCF( falseLabel )
3140:             | * :
3147:                #eNotBoolean
3149:          ]
3149:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3150:          [ equal_label( overallFalseLabel, labelNull )
3160:             | true :
3161:                overallFalseLabel = oLabelNew
3166:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3180:                falseLabel = overallFalseLabel
3186:             | * :
3191:          ]
      
3191:          Label factorFalseLabel = labelNull
3197:          @BoolFactorAllowCF( factorFalseLabel )
      
3204:          [ oTypeSNodeType
3206:             | nBooleanCFType :
3207:             | nBooleanType :
3209:                @ValToCF( factorFalseLabel )
3216:             | * : #eNotBoolean
3225:          ]
3225:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3239:       | * :
3244:          >
3246:    ]};
      
3249: BoolFactorAllowCF( out Label falseLabel ):
3251:    [
3251:       | pNot :
3253:          Label factorFalseLabel = labelNull
      
3259:          @BoolFactorAllowCF( factorFalseLabel )
3266:          [ oTypeSNodeType
3268:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3269:                falseLabel = oLabelNew
3274:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3282:                .tLabel  oEmitLabel( factorFalseLabel )
      
3290:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3292:                .tNot
      
3294:             | * : #eNotBoolean
3303:          ]
      
3303:       | * :
3308:          @ArithExprAllowCF( falseLabel )
3315:    ];
      
3316: ArithExprAllowCF( out Label falseLabel ):
3318:    @TermAllowCF( falseLabel )
3325:    {[
3325:       | pPlus :
3327:          @RequireIntPop
3329:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3336:          @RequireInt
3338:          .tAddI
3340:       | pMinus :
3342:          @RequireIntPop
3344:          @TermAllowCF( falseLabel )
3351:          @RequireInt
3353:          .tSubI
3355:       | * :
3362:          >
3364:    ]};
      
3367: TermAllowCF( out Label falseLabel ):
3369:    @FactorAllowCF( falseLabel )
3376:    {[
3376:       | pTimes :
3378:          @RequireIntPop
3380:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3387:          @RequireInt
3389:          .tMultI
3391:       | pDivide :
3393:          @RequireIntPop
3395:          @FactorAllowCF( falseLabel )
3402:          @RequireInt
3404:          .tDivI
3406:       | * :
3413:          >
3415:    ]};
      
3418: FactorAllowCF( out Label falseLabel ):
3420:    [
3420:       | pPlus :
3422:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3429:          @RequireInt
3431:       | pMinus :
3433:          @PrimaryAllowCF( falseLabel )
3440:          @RequireInt
3442:          .tNegI
3444:       | * :
3451:          @PrimaryAllowCF( falseLabel )
3458:    ];
      
3459: PrimaryAllowCF( out Label falseLabel ):
3461:    [
3461:       | pIntLit :
3463:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3470:          oTypeSPush( IntegerType )
      
3476:       | '(' :
3478:          @ExprAllowCF( falseLabel )
3485:          ')'
      
3487:       | pStrLit :
3489:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3498:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3506:          oTypeSPush( StringType )
      
3512:       | pIdent :
3514:          Node decl = oScopeFindRequire
3519:          Node theType
      
3519:          [ oNodeType( decl )
3526:             | nFunc :
      
3527:                @Call( decl )
      
3534:             | nConst :
3536:                theType = oNodeGet( decl, qType )
3549:                oTypeSPush( theType )
3555:                [ oTypeSNodeType
3557:                   | nIntegerType, nBooleanType :
3558:                      .tPushConstI @EmitValue( decl )
3567:                   | * :
3574:                      #eNotImplemented
3576:                ]
      
3576:             | nGlobalVar, nLocalVar, nParam :
3578:                @VarExpr( decl )
      
3585:             | * :
3598:                #eNotValue
3600:                oTypeSPush( IntegerType )
3606:          ]
      
3606:       | '@' :        % @var -- pointer to var
3608:          pIdent
      
3610:          Node decl = oScopeFindRequire
3615:          Node theType
      
3615:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3622:          theType = oTypeSTop
3627:          oTypeSPop
3628:          Node ptrType = @PointerTypeTo( theType )
3639:          oTypeSPush( ptrType )
      
3645:       | * :
3658:          #eNotValue
3660:          oTypeSPush( IntegerType )
3666:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3667: VarExpr( Node decl ):
3669:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
3682:    Node declScope = oNodeGet( decl, qParentScope )
3695:    int uplevels = subtract( oNodeGetInt( oScopeCurrent, qLevel ), oNodeGetInt( declScope, qLevel ) )
      
3721:    oTypeSPush( theType )
3727:    [ oTypeSNodeType
3729:       | nIntegerType :
3730:          [ oNodeType( decl )
3737:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
3747:             | nLocalVar :
3749:                [ equal_zero( uplevels )
3756:                   | true :  .tPushLocalI  @EmitValue( decl )
3766:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
3786:                ]
3786:             | nParam :
3788:                [ oNodeGetBoolean( decl, qInOut )
3798:                   | true :    % VAR param points to the var.  Auto dereference.
3799:                      [ equal_zero( uplevels )
3806:                         | true :  .tPushParamP  @EmitValue( decl )
3816:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3836:                      ]
3836:                      .tFetchI
3838:                   | * :
3843:                      [ equal_zero( uplevels )
3850:                         | true :  .tPushParamI  @EmitValue( decl )
3860:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
3880:                      ]
3880:                ]
3880:          ]
      
3890:       | nBooleanType :
3892:          [ oNodeType( decl )
3899:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
3909:             | nLocalVar :
3911:                [ equal_zero( uplevels )
3918:                   | true :  .tPushLocalB  @EmitValue( decl )
3928:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
3948:                ]
3948:             | nParam :
3950:                [ oNodeGetBoolean( decl, qInOut )
3960:                   | true :    % VAR param points to the var.  Auto dereference.
3961:                      [ equal_zero( uplevels )
3968:                         | true :  .tPushParamP  @EmitValue( decl )
3978:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3998:                      ]
3998:                      .tFetchB
4000:                   | * :
4005:                      [ equal_zero( uplevels )
4012:                         | true :  .tPushParamB  @EmitValue( decl )
4022:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
4042:                      ]
4042:                ]
4042:          ]
      
4052:       | nCharType, nStringType, nFileType :
4054:          #eNotImplemented
      
4056:       | nPointerType :
4058:          [ oNodeType( decl )
4065:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
4075:             | nLocalVar :
4077:                [ equal_zero( uplevels )
4084:                   | true :  .tPushLocalP  @EmitValue( decl )
4094:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4114:                ]
4114:             | nParam :
4116:                [ oNodeGetBoolean( decl, qInOut )
4126:                   | true :    % VAR param points to the var.  Auto dereference.
4127:                      [ equal_zero( uplevels )
4134:                         | true :  .tPushParamP  @EmitValue( decl )
4144:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4164:                      ]
4164:                      .tFetchP
4166:                   | * :
4171:                      [ equal_zero( uplevels )
4178:                         | true :  .tPushParamP  @EmitValue( decl )
4188:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4208:                      ]
4208:                ]
4208:          ]
4218:          [
4218:             | '^' :             % dereferenced
4220:                oTypeSPop
4221:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4234:                @LValueIndexes
4236:                @FetchVar
4238:             | * :               % just ptr value alone
4243:          ]
      
4243:       | * :
               % compound type
               % first, push addr of start of var
4258:          [ oNodeType( decl )
4265:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4275:             | nLocalVar :
4277:                [ equal_zero( uplevels )
4284:                   | true :  .tPushAddrLocal  @EmitValue( decl )
4294:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
4314:                ]
4314:             | nParam :
4316:                [ oNodeGetBoolean( decl, qInOut )
4326:                   | true :    % VAR param points to the var.  Auto dereference.
4327:                      [ equal_zero( uplevels )
4334:                         | true :  .tPushParamP  @EmitValue( decl )
4344:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4364:                      ]
4364:                   | * :
4369:                      [ equal_zero( uplevels )
4376:                         | true :  .tPushAddrParam  @EmitValue( decl )
4386:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
4406:                      ]
4406:                ]
4406:          ]
               % modify addr for subscripts, field references, etc
4416:          @LValueIndexes
               % get final value
4418:          @FetchVar
4420:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
4421: FetchVar:
4423:    [ oTypeSNodeType
4425:       | nIntegerType :   .tFetchI
4428:       | nBooleanType :   .tFetchB
4432:       | nCharType, nStringType, nFileType : #eNotImplemented
4436:       | nPointerType :   .tFetchP
4440:       | * :              % compound type; leave as addr
4455:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
4456: LValueIndexes:
4458:    {[
4458:       | '[' :       @ArraySubscripts
4462:       | '.' :       @RecordFieldRef
4466:       | '^' :       @PointerDeref
4470:       | * :         >
4481:    ]};
      
4484: ArraySubscripts:
4486:    [ oTypeSNodeType
4488:       | nArrayType :
4489:       | * :       #eNotArray
4496:    ]
4496:    {
4496:       [ oTypeSNodeType
4498:          | nArrayType :
4499:          | * :    #eTooManySubscripts
4506:       ]
      
            % low subscript of this dimension
4506:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
4523:       Node baseType
4523:       baseType = oNodeGet( oTypeSTop, qBaseType )
4535:       oTypeSPop
4536:       oTypeSPush( baseType )
      
4542:       @Expr
4544:       @RequireIntPop
            % adjust for low subscript
4546:       [ equal_zero( low )
4553:          | false :
4554:             .tPushConstI oEmitInt( low ) .tSubI
4564:          | * :
4569:       ]
      
            % multiply by element size
4569:       int size = oNodeGetInt( baseType, qSize )
4582:       [ equal( size, 1 )
4592:          | false :
4593:             .tPushConstI oEmitInt( size ) .tMultI
4603:          | * :
4608:       ]
      
            % update start address
4608:       .tAddPI
4610:       [
4610:          | ']' :  >
4614:          | ',' :
4616:       ]
4624:    };
      
      
4627: RecordFieldRef:
4629:    [ oTypeSNodeType
4631:       | nRecordType :
4632:       | * :    #eNotRecord
4639:    ]
4639:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4651:    pIdent
4653:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4658:    [ oNodeType( field )
4665:       | nRecordField :
4666:       | * :   #eNotRecordField
4673:    ]
4673:    oScopeEnd
4674:    int offset = oNodeGetInt( field, qValue )
4687:    [ equal_zero( offset )
4694:       | false :
4695:          .tPushConstI oEmitInt( offset ) .tAddPI
4705:       | * :
4710:    ]
      
         % replace the type on the type stack, with the field type
4710:    oTypeSPop
4711:    oTypeSPush( oNodeGet( field, qType ) )
4725:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4725: PointerDeref:
4727:    [ oTypeSNodeType
4729:       | nPointerType :
4730:       | * :       #eNotPointer
4737:    ]
4737:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4739:    Node theType = oTypeSTop
4744:    oTypeSPop
4745:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4759:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4759: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4761:    @MatchTypes
4764:    ;
      
      
      % Called on first use of an extern method
      %
4764: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4766:    int strAddr
4766:    String externalName = oNodeGetString( method, qExternalName )
4779:    [ equal_string( externalName, stringNull )
4789:       | true :
4790:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4811:       | false :
4813:          strAddr = oStringAllocLit( externalName )
4823:    ]
4831:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4847:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4847: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4849:    [ oNodeGetBoolean( method, qExternal )
4859:       | true :
4860:          [ oNodeGetBoolean( method, qCalled )
4870:             | false :
                     % define the extern label on first use
4871:                @DefineExternLabel( method )
4878:             | * :
4883:          ]
4883:      | * :
4888:    ]
4888:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4900:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4913:    Node resultType
4913:    int tempOffset
      
4913:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4930:    [ isFunc
4933:       | true :
4934:          resultType = oNodeGet( method, qType )
4947:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4957:       | * :
4962:    ]
         
      
4962:    Node paramScope = oNodeGet( method, qParams )
4975:    int actualsSize = oNodeGetInt( paramScope, qSize )
4988:    [ cdecl
4991:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
5000:       | false :  .tAllocActuals  oEmitInt( actualsSize )
5010:    ]
      
5018:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
5031:    Node param = oNodeIterValue( paramIter )
5041:    [
5041:       | '(' :
            
5043:          {
5043:             [ oNodeNull( param )
5050:                | true : >
5053:                | * :
5058:             ]
      
5058:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
5071:             .tPushAddrActual oEmitInt( offset )
5079:             oTypeSPush( oNodeGet( param, qType ) )
      
5092:             [ oNodeGetBoolean( param, qInOut )
5102:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5103:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5105:                           @MatchTypes
      
5107:                           .tAssignP
      
5109:                | false :  @Expr
5113:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5115:                           [ oTypeSNodeType
5117:                              | nIntegerType :            .tAssignI
5120:                              | nBooleanType :            .tAssignB
5124:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5128:                              | nPointerType :            .tAssignP
5132:                              | * :
                                       % compound types: copy value into actuals space
5147:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5159:                                  .tCopy  oEmitInt( size )    % multi-word copy
5167:                           ]
5167:             ]
5175:             oTypeSPop
      
5176:             oNodeIterNext( paramIter )
5182:             param = oNodeIterValue( paramIter )
5192:             [ oNodeNull( param )
5199:                | true :  >
5202:                | false :
5204:             ]
      
5212:             ','
5214:          }
      
5216:          ')'
      
5218:       | * :
5223:    ]
      
5223:    [ oNodeNull( param )
5230:       | false :    #eMissingParameter
5233:       | * :
5238:    ]
      
5238:    [ isFunc
5241:       | true :
               % Pass result temp as an additional VAR parameter.
5242:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
5257:          .tPushAddrLocal  oEmitInt( tempOffset )
5265:          .tAssignP
5267:       | * :
5272:    ]
      
5272:    [ cdecl
5275:       | true :
5276:          .tCallCdecl  @EmitValue( method )
5285:       | false :
5287:          .tCall   @EmitValue( method )
5296:    ]
      
5304:    [ isFunc
5307:       | true :
               % push return value from temp
5308:          oTypeSPush( resultType )
      
5314:          [ oTypeSNodeType
5316:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
5325:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
5335:             | nCharType, nStringType, nFileType : #eNotImplemented
5339:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
5349:             | * :              % compound type: push address
5364:                                .tPushAddrLocal  oEmitInt( tempOffset )
5372:          ]
5372:       | * :
5377:    ]
         
5377:    .tFreeActuals  oEmitInt( actualsSize )
5386:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
5386: Statement:
5388:    [
5388:       | pWriteln :     @WritelnStmt
5392:       | pWrite :       @WriteStmt
5396:       | pReadln :      @ReadlnStmt
5400:       | pRead :        @ReadStmt
5404:       | pIf :          @IfStmt
5408:       | pWhile :       @WhileStmt
5412:       | pFor :         @ForStmt
5416:       | pRepeat :      @RepeatStmt
5420:       | pBreak :       @BreakStmt
5424:       | pContinue :    @ContinueStmt
5428:       | pBegin :       @BeginStmt
5432:       | pIdent :       @AssignOrCallStmt
5436:       | * :            % null statement : don't accept any tokens
5463:    ];
      
      
5464: AssignOrCallStmt:
5466:    Node decl = oScopeFindRequire
5471:    [ oNodeType( decl )
5478:       | nProc :                           @Call( decl )
5486:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
5495:       | nFunc :                           @AssignResultStmt( decl )
5504:       | * :                               #eBadStatement
5519:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
5520: AssignStmt( Node decl ):
      
5522:    @LValueVar( decl )
5529:    ':=' 
5531:    @Expr
5533:    @MatchTypes
5535:    @Assign
5538:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
5538: Assign:
5540:    [ oTypeSNodeType
5542:       | nIntegerType :            .tAssignI
5545:       | nBooleanType :            .tAssignB
5549:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5553:       | nPointerType :            .tAssignP
5557:       | * :
5572:           int size = oNodeGetInt( oTypeSTop, qSize )
5584:           .tCopy  oEmitInt( size )    % multi-word copy
5592:    ]
5592:    oTypeSPop
5594:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5594: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5596:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5612:       | false :   #eNotCurrentFunction
5615:       | * :
5620:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5620:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5635:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5648:    ':='
5650:    @Expr
5652:    @MatchTypes
5654:    [ oTypeSNodeType
5656:       | nIntegerType :            .tAssignI
5659:       | nBooleanType :            .tAssignB
5663:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5667:       | nPointerType :            .tAssignP
5671:       | * :
5686:           int size = oNodeGetInt( oTypeSTop, qSize )
5698:           .tCopy  oEmitInt( size )    % multi-word copy
5706:    ]
5706:    oTypeSPop
5708:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5708: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5710:    pIdent
5712:    Node decl = oScopeFindRequire
5717:    [ oNodeType( decl )
5724:       | nGlobalVar, nLocalVar, nParam :
5725:       | * :  #eNotVar
5736:    ]
5736:    @LValueVar( decl )
5744:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5744: LValueVar( Node decl ):
5746:    [ oNodeType( decl )
5753:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5763:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5774:       | nParam :
5776:          [ oNodeGetBoolean( decl, qInOut )
5786:             | true :   % VAR param points to variable.  No dereference.
5787:                        .tPushParamP @EmitValue( decl )
5796:             | * :      .tPushAddrParam @EmitValue( decl )
5810:          ]
5810:       | * :            #eNotVar
5821:    ]
      
5821:    oTypeSPush( oNodeGet( decl, qType ) )
5834:    @LValueIndexes        % handle subscripts, if any
5837:    ;
      
      
5837: IncVar( Node decl ):
5839:    @LValueVar( decl )
5846:    @RequireIntPop
5848:    @VarExpr( decl )
5855:    oTypeSPop
5856:    .tIncI
5858:    .tAssignI;
      
5861: DecVar( Node decl ):
5863:    @LValueVar( decl )
5870:    @RequireIntPop
5872:    @VarExpr( decl )
5879:    oTypeSPop
5880:    .tDecI
5882:    .tAssignI;
      
      
5885: IfStmt:
5887:    Label falseLabel = labelNull
      
5893:    @BooleanExprControlFlow( falseLabel )
5900:    pThen
5902:    @Statement
5904:    [
5904:       | pElse :
5906:          Label doneLabel = oLabelNew
      
5911:          .tJump  oEmitLabel( doneLabel )
5919:          .tLabel oEmitLabel( falseLabel )
5927:          @Statement
5929:          .tLabel oEmitLabel( doneLabel )
      
5937:       | * :
5942:          .tLabel oEmitLabel( falseLabel )
5950:    ];
      
      
5951: ForStmt:
5953:    pIdent
      
5955:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5960:    @LValueVar( decl )
5967:    @RequireIntPop
      
5969:    ':='
      
5971:    @Expr
5973:    @RequireIntPop
5975:    .tAssignI
      
5977:    Label breakLabel = oLabelNew
      
5982:    Label checkLabel = oLabelNew
5987:    .tJump  oEmitLabel( checkLabel )
      
5995:    Label continueLabel = oLabelNew
6000:    .tLabel  oEmitLabel( continueLabel )
6008:    [
6008:       | pTo :
6010:          @IncVar( decl )
6017:          .tLabel  oEmitLabel( checkLabel )
6025:          @VarExpr( decl )  oTypeSPop
6033:          @Expr
6035:          @RequireIntPop
6037:          .tGreaterI
6039:          .tJumpTrue  oEmitLabel( breakLabel )
6047:       | pDownto :
6049:          @DecVar( decl )
6056:          .tLabel  oEmitLabel( checkLabel )
6064:          @VarExpr( decl )  oTypeSPop
6072:          @Expr
6074:          @RequireIntPop
6076:          .tLessI
6078:          .tJumpTrue  oEmitLabel( breakLabel )
6086:    ]
6094:    oLoopPush( continueLabel, breakLabel )
6103:    pDo
6105:    @Statement
6107:    .tJump  oEmitLabel( continueLabel )
6115:    .tLabel  oEmitLabel( breakLabel )
6123:    oLoopPop;
      
      
6125: RepeatStmt:
6127:    Label continueLabel = oLabelNew
6132:    .tLabel  oEmitLabel( continueLabel )
      
6140:    Label breakLabel = oLabelNew
      
6145:    oLoopPush( continueLabel, breakLabel )
6154:    @Statement
6156:    {[
6156:       | ';' :
6158:          @Statement
6160:       | pUntil :
6162:          Label falseLabel
6162:          @BooleanExprControlFlow( falseLabel )
6169:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6183:          >
6185:    ]}
6195:    .tLabel  oEmitLabel( breakLabel )
6203:    oLoopPop;
      
      
6205: WhileStmt:
6207:    Label continueLabel = oLabelNew
6212:    .tLabel  oEmitLabel( continueLabel )
      
6220:    Label breakLabel
6220:    @BooleanExprControlFlow( breakLabel )
      
6227:    oLoopPush( continueLabel, breakLabel )
6236:    pDo
6238:    @Statement
6240:    .tJump  oEmitLabel( continueLabel )
6248:    .tLabel  oEmitLabel( breakLabel )
6256:    oLoopPop;
      
      
6258: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
6260:    [ equal_label( oLoopContinueLabel, labelNull )
6269:       | true :
6270:          #eNotInALoop
6272:       | false :
6274:          .tJump  oEmitLabel( oLoopContinueLabel )
6281:    ];
      
      
6290: BreakStmt:
6292:    [ equal_label( oLoopBreakLabel, labelNull )
6301:       | true :
6302:          #eNotInALoop
6304:       | false :
6306:          .tJump  oEmitLabel( oLoopBreakLabel )
6313:    ];
      
      
6322: BeginStmt:
6324:    @Statement
6326:    {[
6326:       | ';' :   @Statement
6330:       | pEnd :  >
6334:    ]};
      
      
6345: WritelnStmt:
6347:    @WriteStmt
6349:    .tWriteCR;
      
      
6352: WriteStmt:
6354:    [
6354:       | '(' :
6356:          {
6356:             @Expr
6358:             [ oTypeSNodeType
6360:                | nIntegerType :             .tWriteI
6363:                | nBooleanType :             .tWriteBool
6367:                | nStringType :              .tWriteStr
6371:                | nCharType, nFileType :     #eNotImplemented
6375:                | nPointerType :             .tWriteP
6379:                | * :                        #eNotAllowed
6396:             ]
6396:             oTypeSPop
6397:             [
6397:                | ')' : >
6401:                | ',' :
6403:             ]
6411:          }
6413:       | * :
6418:    ];
      
      
6419: ReadlnStmt:      % ***
         % TO DO
6422:    ;
      
6422: ReadStmt:
         % TO DO
6425:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
6425: MatchTypes:
6427:    node_type nt = oTypeSNodeType
6432:    oTypeSPop
6433:    [ equal_node_type( nt, oTypeSNodeType )
6442:       | false :
6443:          #eTypeMismatch
6445:       | * :
6450:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
6451: RequireIntPop:
6453:    [ oTypeSNodeType
6455:       | nIntegerType :
6456:       | * :          #eNotInteger
6463:    ]
6463:    oTypeSPop;
      
6465: RequireInt:
6467:    [ oTypeSNodeType
6469:       | nIntegerType :
6470:       | * :          #eNotInteger
6477:    ];
      
6478: RequireBoolPop:
6480:    [ oTypeSNodeType
6482:       | nBooleanType :
6483:       | * :          #eNotBoolean
6490:    ]
6490:    oTypeSPop;
      
6492: RequireBool:
6494:    [ oTypeSNodeType
6496:       | nBooleanType :
6497:       | * :          #eNotBoolean
6504:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
6505: newType( node_type nt, int size ) >> Node:
6507:   Node node = oNodeNew( nt )
6517:   oNodeSetInt( node, qSize, size )
6529:   oTypeAdd( node )
6535:   >> node
6539:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
6539: newIdent( node_type nt, kind k, int id ) >> Node:
6541:   Node t = oNodeNew( nt )
6551:   oNodeSetInt( t, qIdent, id )
6563:   >> t
6567:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6567: PointerTypeTo( Node theType ) >> Node:
6569:    Node ptrType = oNodeGet( theType, qPointerType )
6582:    [ oNodeNull( ptrType )
6589:       | true :
6590:          ptrType = oNodeNew( nPointerType )
6600:          oNodeSet( ptrType, qBaseType, theType )
6612:          oNodeSetInt( ptrType, qSize, 8 )
6624:          oTypeAdd( ptrType )
6630:          oNodeSet( theType, qPointerType, ptrType )
6642:       | * :
6647:    ]
6647:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6651: OrdinalLow( Node theType ) >> int:
6653:    [ oNodeType( theType )
6660:       | nIntegerType :  >> oMININT
6663:       | nBooleanType :  >> 0
6668:       | nCharType :     >> 0
6673:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6685:       | * :             #eNotOrdinalType
6698:                         >> 0
6701:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6702: EmitValue( Node decl ):
6704:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6718: installBuiltIns:
      
         % install built-in types
6720:    FileType = @newType( nFileType, 4 )
6734:    IntegerType = @newType( nIntegerType, 4 )
6748:    BooleanType = @newType( nBooleanType, 1 )
6762:    BooleanCFType = @newType( nBooleanCFType, 1 )
6776:    CharType = @newType( nCharType, 1 )
6790:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6804:    Node t
      
6804:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6820:    oNodeSet( t, qType, FileType )
6832:    oScopeDeclare( t )
      
6838:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6854:    oNodeSet( t, qType, IntegerType )
6866:    oScopeDeclare( t )
      
6872:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6888:    oNodeSet( t, qType, BooleanType )
6900:    oScopeDeclare( t )
      
6906:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6922:    oNodeSet( t, qType, CharType )
6934:    oScopeDeclare( t )
      
6940:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6956:    oNodeSet( t, qType, StringType )
6968:    oScopeDeclare( t )
      
         % Built-in constants
      
6974:    t = @newIdent( nConst, kConst, oIdAdd_True )
6990:    oNodeSet( t, qType, BooleanType )
7002:    oNodeSetInt( t, qValue, 1 )
7014:    oScopeDeclare( t )
      
7020:    t = @newIdent( nConst, kConst, oIdAdd_False )
7036:    oNodeSet( t, qType, BooleanType )
7048:    oNodeSetInt( t, qValue, 0 )
7060:    oScopeDeclare( t )
      
7067:    ;
      
7067: end
      
7067: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 3
   4: oSetResult 0
   6: oPushResult
   7: oScopeBegin
   8: oPop 1
  10: oGetAddrGlobal 1
  12: oPushResult
  13: oScopeCurrent
  14: oAssign
  15: oCall 6718
  17: oEmit 52
  19: oSetResult 0
  21: oPushResult
  22: oEmitInt
  23: oPop 1
  25: oGetAddrLocal 2
  27: oPushResult
  28: oLabelNew
  29: oAssign
  30: oEmit 46
  32: oSetResult 0
  34: oPushResult
  35: oEmitInt
  36: oPop 1
  38: oEmit 49
  40: oGetLocal 2
  42: oPushResult
  43: oEmitLabel
  44: oPop 1
  46: oEmit 48
  48: oSetResult 0
  50: oPushResult
  51: oEmitInt
  52: oPop 1
  54: oEmit 51
  56: oInput 27
  58: oInput 0
  60: oGetAddrLocal 3
  62: oPushResult
  63: oSetResult 5
  65: oPushResult
  66: oSetResult 1
  68: oPushResult
  69: LAST_ID
  70: oPushResult
  71: oCall 6539
  73: oPop 3
  75: oAssign
  76: oGetLocal 3
  78: oPushResult
  79: oScopeDeclare
  80: oPop 1
  82: oInputChoice 162
  84: oInput 0
  86: oGetAddrLocal 1
  88: oPushResult
  89: oSetResult 11
  91: oPushResult
  92: oSetResult 6
  94: oPushResult
  95: LAST_ID
  96: oPushResult
  97: oCall 6539
  99: oPop 3
 101: oAssign
 102: oGetLocal 1
 104: oPushResult
 105: oSetResult 8
 107: oPushResult
 108: oGetGlobal 3
 110: oPushResult
 111: oNodeSet
 112: oPop 3
 114: oGetLocal 1
 116: oPushResult
 117: oScopeDeclareAlloc
 118: oPop 1
 120: oInput 12
 122: oInput 0
 124: oGetAddrLocal 1
 126: oPushResult
 127: oSetResult 11
 129: oPushResult
 130: oSetResult 6
 132: oPushResult
 133: LAST_ID
 134: oPushResult
 135: oCall 6539
 137: oPop 3
 139: oAssign
 140: oGetLocal 1
 142: oPushResult
 143: oSetResult 8
 145: oPushResult
 146: oGetGlobal 3
 148: oPushResult
 149: oNodeSet
 150: oPop 3
 152: oGetLocal 1
 154: oPushResult
 155: oScopeDeclareAlloc
 156: oPop 1
 158: oInput 14
 160: oJumpForward 165
 162: Choice Lookup Table
          13     84
 165: oInput 4
 167: oSetResult 0
 169: oPushResult
 170: oScopeBegin
 171: oPop 1
 173: oGetAddrGlobal 2
 175: oPushResult
 176: oScopeCurrent
 177: oAssign
 178: oScopeCurrent
 179: oPushResult
 180: oSetResult 4
 182: oPushResult
 183: oSetResult 1
 185: oPushResult
 186: oNodeSetBoolean
 187: oPop 3
 189: oGetLocal 3
 191: oPushResult
 192: oSetResult 10
 194: oPushResult
 195: oScopeCurrent
 196: oPushResult
 197: oNodeSet
 198: oPop 3
 200: oScopeEnd
 201: oSetResult 12
 203: oPushResult
 204: oCall 248
 206: oPop 1
 208: oGetGlobal 2
 210: oPushResult
 211: oScopeEnter
 212: oPop 1
 214: oGetLocal 2
 216: oPushResult
 217: oGetGlobal 1
 219: oPushResult
 220: oCall 298
 222: oPop 2
 224: oScopeEnd
 225: oInput 19
 227: oScopeEnd
 228: oReturn
 229: oLocalSpace 0
 231: oGetParam 2
 233: oPushResult
 234: oCall 248
 236: oPop 1
 238: oGetParam 1
 240: oPushResult
 241: oScopeCurrent
 242: oPushResult
 243: oCall 298
 245: oPop 2
 247: oReturn
 248: oLocalSpace 0
 250: oInputChoice 277
 252: oCall 1502
 254: oJumpForward 290
 256: oCall 1574
 258: oJumpForward 290
 260: oGetParam 1
 262: oPushResult
 263: oCall 1633
 265: oPop 1
 267: oJumpForward 290
 269: oCall 522
 271: oJumpForward 290
 273: oCall 868
 275: oJumpForward 290
 277: Choice Lookup Table
          29    273
          28    269
          32    260
          31    256
          30    252
 288: oJumpForward 292
 290: oJumpBack 250
 292: oCall 295
 294: oReturn
 295: oLocalSpace 0
 297: oReturn
 298: oLocalSpace 3
 300: oEmit 56
 302: oGetParam 2
 304: oPushResult
 305: oEmitLabel
 306: oPop 1
 308: oEmit 52
 310: oGetAddrLocal 1
 312: oPushResult
 313: Here
 314: oAssign
 315: oEmit 64
 317: oGetAddrLocal 2
 319: oPushResult
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 5
 325: oPushResult
 326: oNodeGetCode
 327: oPop 2
 329: oAssign
 330: oGetLocal 2
 332: oPushResult
 333: oEmitCode
 334: oPop 1
 336: oScopeCurrent
 337: oPushResult
 338: oSetResult 5
 340: oPushResult
 341: oSetResult 0
 343: oPushResult
 344: oNodeSetCode
 345: oPop 3
 347: oCall 5386
 349: oEmit 51
 351: oGetAddrLocal 3
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oSetResult 3
 358: oPushResult
 359: oNodeGetInt
 360: oPop 2
 362: oAssign
 363: oGetLocal 1
 365: oPushResult
 366: oGetLocal 3
 368: oPushResult
 369: oPatch
 370: oPop 2
 372: oReturn
 373: oLocalSpace 0
 375: oInputChoice 393
 377: oGetParam 1
 379: oPushResult
 380: oSetResult 16
 382: oPushResult
 383: oSetResult 1
 385: oPushResult
 386: oNodeSetBoolean
 387: oPop 3
 389: oInput 4
 391: oJumpForward 398
 393: Choice Lookup Table
          61    377
 396: oJumpForward 400
 398: oJumpBack 375
 400: oReturn
 401: oLocalSpace 1
 403: oGetAddrLocal 1
 405: oPushResult
 406: oScopeCurrent
 407: oPushResult
 408: oSetResult 5
 410: oPushResult
 411: oNodeGetCode
 412: oPop 2
 414: oAssign
 415: oGetLocal 1
 417: oPushResult
 418: oSetResult 0
 420: oPushResult
 421: equal_code
 422: oPop 2
 424: oChoice 444
 426: oGetAddrLocal 1
 428: oPushResult
 429: oCodeNew
 430: oAssign
 431: oScopeCurrent
 432: oPushResult
 433: oSetResult 5
 435: oPushResult
 436: oGetLocal 1
 438: oPushResult
 439: oNodeSetCode
 440: oPop 3
 442: oJumpForward 447
 444: Choice Lookup Table
           1    426
 447: oGetLocal 1
 449: oReturn
 450: oReturn
 451: oLocalSpace 0
 453: oGetParam 1
 455: oPushResult
 456: oSetResult 6
 458: oPushResult
 459: oNodeGet
 460: oPop 2
 462: oPushResult
 463: oSetResult 1
 465: oPushResult
 466: oNodeGetInt
 467: oPop 2
 469: oPushResult
 470: equal_zero
 471: oPop 1
 473: oChoice 479
 475: oError 23
 477: oJumpForward 482
 479: Choice Lookup Table
           0    475
 482: oGetParam 1
 484: oPushResult
 485: oSetResult 14
 487: oPushResult
 488: oSetResult 1
 490: oPushResult
 491: oNodeSetBoolean
 492: oPop 3
 494: oInputChoice 518
 496: oInputChoice 513
 498: oInput 2
 500: oGetParam 1
 502: oPushResult
 503: oSetResult 15
 505: oPushResult
 506: CURRENT_STRLIT
 507: oPushResult
 508: oNodeSetString
 509: oPop 3
 511: oJumpForward 516
 513: Choice Lookup Table
          60    498
 516: oJumpForward 521
 518: Choice Lookup Table
           2    496
 521: oReturn
 522: oLocalSpace 6
 524: oInput 0
 526: oGetAddrLocal 1
 528: oPushResult
 529: oSetResult 0
 531: oAssign
 532: oGetAddrLocal 2
 534: oPushResult
 535: oScopeFindInCurrentScope
 536: oAssign
 537: oGetLocal 2
 539: oPushResult
 540: oNodeNull
 541: oPop 1
 543: oChoice 664
 545: oGetAddrLocal 2
 547: oPushResult
 548: oSetResult 7
 550: oPushResult
 551: oSetResult 2
 553: oPushResult
 554: LAST_ID
 555: oPushResult
 556: oCall 6539
 558: oPop 3
 560: oAssign
 561: oGetLocal 2
 563: oPushResult
 564: oSetResult 9
 566: oPushResult
 567: oLabelNew
 568: oPushResult
 569: oNodeSetLabel
 570: oPop 3
 572: oJumpForward 670
 574: oGetAddrLocal 1
 576: oPushResult
 577: oSetResult 1
 579: oAssign
 580: oGetLocal 2
 582: oPushResult
 583: oSetResult 13
 585: oPushResult
 586: oNodeGetBoolean
 587: oPop 2
 589: oChoice 595
 591: oError 21
 593: oJumpForward 598
 595: Choice Lookup Table
           1    591
 598: oGetLocal 2
 600: oPushResult
 601: oSetResult 14
 603: oPushResult
 604: oNodeGetBoolean
 605: oPop 2
 607: oChoice 613
 609: oError 21
 611: oJumpForward 616
 613: Choice Lookup Table
           1    609
 616: oGetLocal 2
 618: oPushResult
 619: oNodeType
 620: oPop 1
 622: oChoice 626
 624: oJumpForward 631
 626: Choice Lookup Table
           7    624
 629: oError 21
 631: oGetLocal 2
 633: oPushResult
 634: oSetResult 18
 636: oPushResult
 637: oGetLocal 2
 639: oPushResult
 640: oSetResult 11
 642: oPushResult
 643: oNodeGet
 644: oPop 2
 646: oPushResult
 647: oNodeSet
 648: oPop 3
 650: oGetLocal 2
 652: oPushResult
 653: oSetResult 11
 655: oPushResult
 656: oSetResult 0
 658: oPushResult
 659: oNodeSet
 660: oPop 3
 662: oJumpForward 670
 664: Choice Lookup Table
           0    574
           1    545
 669: oEndChoice
 670: oGetAddrLocal 3
 672: oPushResult
 673: oScopeCurrent
 674: oPushResult
 675: oSetResult 1
 677: oPushResult
 678: oNodeGetInt
 679: oPop 2
 681: oAssign
 682: oGetAddrLocal 4
 684: oPushResult
 685: oGetLocal 3
 687: oPushResult
 688: oSetResult 0
 690: oPushResult
 691: greater
 692: oPop 2
 694: oAssign
 695: oGetAddrLocal 3
 697: oPushResult
 698: inc
 699: oPop 1
 701: oGetLocal 3
 703: oPushResult
 704: oScopeBegin
 705: oPop 1
 707: oGetAddrLocal 5
 709: oPushResult
 710: oScopeCurrent
 711: oAssign
 712: oGetLocal 4
 714: oChoice 729
 716: oGetGlobal 4
 718: oPushResult
 719: oCall 6567
 721: oPop 1
 723: oPushResult
 724: oScopeAllocType
 725: oPop 1
 727: oJumpForward 732
 729: Choice Lookup Table
           1    716
 732: oCall 1275
 734: oGetLocal 2
 736: oPushResult
 737: oSetResult 11
 739: oPushResult
 740: oGetLocal 5
 742: oPushResult
 743: oNodeSet
 744: oPop 3
 746: oScopeEnd
 747: oInput 4
 749: oGetLocal 1
 751: oChoice 763
 753: oGetLocal 2
 755: oPushResult
 756: oScopeDeclare
 757: oPop 1
 759: oJumpForward 769
 761: oJumpForward 769
 763: Choice Lookup Table
           1    761
           0    753
 768: oEndChoice
 769: oGetLocal 2
 771: oPushResult
 772: oCall 373
 774: oPop 1
 776: oInputChoice 789
 778: oJumpForward 865
 780: oGetLocal 2
 782: oPushResult
 783: oCall 451
 785: oPop 1
 787: oJumpForward 865
 789: Choice Lookup Table
          59    780
          58    778
 794: oGetLocal 5
 796: oPushResult
 797: oScopeEnter
 798: oPop 1
 800: oGetLocal 3
 802: oPushResult
 803: oScopeBegin
 804: oPop 1
 806: oScopeCurrent
 807: oPushResult
 808: oSetResult 4
 810: oPushResult
 811: oSetResult 1
 813: oPushResult
 814: oNodeSetBoolean
 815: oPop 3
 817: oGetLocal 2
 819: oPushResult
 820: oSetResult 12
 822: oPushResult
 823: oScopeCurrent
 824: oPushResult
 825: oNodeSet
 826: oPop 3
 828: oGetAddrLocal 6
 830: oPushResult
 831: oGetLocal 2
 833: oPushResult
 834: oSetResult 9
 836: oPushResult
 837: oNodeGetLabel
 838: oPop 2
 840: oAssign
 841: oSetResult 13
 843: oPushResult
 844: oGetLocal 6
 846: oPushResult
 847: oCall 229
 849: oPop 2
 851: oGetLocal 2
 853: oPushResult
 854: oSetResult 13
 856: oPushResult
 857: oSetResult 1
 859: oPushResult
 860: oNodeSetBoolean
 861: oPop 3
 863: oScopeEnd
 864: oScopeEnd
 865: oInput 4
 867: oReturn
 868: oLocalSpace 8
 870: oInput 0
 872: oGetAddrLocal 1
 874: oPushResult
 875: oSetResult 0
 877: oAssign
 878: oGetAddrLocal 2
 880: oPushResult
 881: oScopeFindInCurrentScope
 882: oAssign
 883: oGetLocal 2
 885: oPushResult
 886: oNodeNull
 887: oPop 1
 889: oChoice 1023
 891: oGetAddrLocal 2
 893: oPushResult
 894: oSetResult 8
 896: oPushResult
 897: oSetResult 3
 899: oPushResult
 900: LAST_ID
 901: oPushResult
 902: oCall 6539
 904: oPop 3
 906: oAssign
 907: oGetLocal 2
 909: oPushResult
 910: oSetResult 9
 912: oPushResult
 913: oLabelNew
 914: oPushResult
 915: oNodeSetLabel
 916: oPop 3
 918: oJumpForward 1029
 920: oGetAddrLocal 1
 922: oPushResult
 923: oSetResult 1
 925: oAssign
 926: oGetLocal 2
 928: oPushResult
 929: oSetResult 13
 931: oPushResult
 932: oNodeGetBoolean
 933: oPop 2
 935: oChoice 941
 937: oError 21
 939: oJumpForward 944
 941: Choice Lookup Table
           1    937
 944: oGetLocal 2
 946: oPushResult
 947: oNodeType
 948: oPop 1
 950: oChoice 954
 952: oJumpForward 959
 954: Choice Lookup Table
           8    952
 957: oError 21
 959: oGetLocal 2
 961: oPushResult
 962: oSetResult 18
 964: oPushResult
 965: oGetLocal 2
 967: oPushResult
 968: oSetResult 11
 970: oPushResult
 971: oNodeGet
 972: oPop 2
 974: oPushResult
 975: oNodeSet
 976: oPop 3
 978: oGetLocal 2
 980: oPushResult
 981: oSetResult 11
 983: oPushResult
 984: oSetResult 0
 986: oPushResult
 987: oNodeSet
 988: oPop 3
 990: oGetLocal 2
 992: oPushResult
 993: oSetResult 19
 995: oPushResult
 996: oGetLocal 2
 998: oPushResult
 999: oSetResult 8
1001: oPushResult
1002: oNodeGet
1003: oPop 2
1005: oPushResult
1006: oNodeSet
1007: oPop 3
1009: oGetLocal 2
1011: oPushResult
1012: oSetResult 8
1014: oPushResult
1015: oSetResult 0
1017: oPushResult
1018: oNodeSet
1019: oPop 3
1021: oJumpForward 1029
1023: Choice Lookup Table
           0    920
           1    891
1028: oEndChoice
1029: oGetAddrLocal 3
1031: oPushResult
1032: oScopeCurrent
1033: oPushResult
1034: oSetResult 1
1036: oPushResult
1037: oNodeGetInt
1038: oPop 2
1040: oAssign
1041: oGetAddrLocal 4
1043: oPushResult
1044: oGetLocal 3
1046: oPushResult
1047: oSetResult 0
1049: oPushResult
1050: greater
1051: oPop 2
1053: oAssign
1054: oGetAddrLocal 3
1056: oPushResult
1057: inc
1058: oPop 1
1060: oGetLocal 3
1062: oPushResult
1063: oScopeBegin
1064: oPop 1
1066: oGetAddrLocal 5
1068: oPushResult
1069: oScopeCurrent
1070: oAssign
1071: oGetLocal 4
1073: oChoice 1088
1075: oGetGlobal 4
1077: oPushResult
1078: oCall 6567
1080: oPop 1
1082: oPushResult
1083: oScopeAllocType
1084: oPop 1
1086: oJumpForward 1091
1088: Choice Lookup Table
           1   1075
1091: oCall 1275
1093: oGetLocal 2
1095: oPushResult
1096: oSetResult 11
1098: oPushResult
1099: oGetLocal 5
1101: oPushResult
1102: oNodeSet
1103: oPop 3
1105: oInput 11
1107: oGetAddrLocal 6
1109: oPushResult
1110: oCall 1865
1112: oPop 1
1114: oGetLocal 2
1116: oPushResult
1117: oSetResult 8
1119: oPushResult
1120: oGetLocal 6
1122: oPushResult
1123: oNodeSet
1124: oPop 3
1126: oGetAddrLocal 7
1128: oPushResult
1129: oGetLocal 6
1131: oPushResult
1132: oCall 6567
1134: oPop 1
1136: oAssign
1137: oGetLocal 2
1139: oPushResult
1140: oSetResult 20
1142: oPushResult
1143: oGetLocal 7
1145: oPushResult
1146: oScopeAllocType
1147: oPop 1
1149: oPushResult
1150: oNodeSetInt
1151: oPop 3
1153: oScopeEnd
1154: oInput 4
1156: oGetLocal 1
1158: oChoice 1170
1160: oGetLocal 2
1162: oPushResult
1163: oScopeDeclare
1164: oPop 1
1166: oJumpForward 1176
1168: oJumpForward 1176
1170: Choice Lookup Table
           1   1168
           0   1160
1175: oEndChoice
1176: oGetLocal 2
1178: oPushResult
1179: oCall 373
1181: oPop 1
1183: oInputChoice 1196
1185: oJumpForward 1272
1187: oGetLocal 2
1189: oPushResult
1190: oCall 451
1192: oPop 1
1194: oJumpForward 1272
1196: Choice Lookup Table
          59   1187
          58   1185
1201: oGetLocal 5
1203: oPushResult
1204: oScopeEnter
1205: oPop 1
1207: oGetLocal 3
1209: oPushResult
1210: oScopeBegin
1211: oPop 1
1213: oScopeCurrent
1214: oPushResult
1215: oSetResult 4
1217: oPushResult
1218: oSetResult 1
1220: oPushResult
1221: oNodeSetBoolean
1222: oPop 3
1224: oGetLocal 2
1226: oPushResult
1227: oSetResult 12
1229: oPushResult
1230: oScopeCurrent
1231: oPushResult
1232: oNodeSet
1233: oPop 3
1235: oGetAddrLocal 8
1237: oPushResult
1238: oGetLocal 2
1240: oPushResult
1241: oSetResult 9
1243: oPushResult
1244: oNodeGetLabel
1245: oPop 2
1247: oAssign
1248: oSetResult 13
1250: oPushResult
1251: oGetLocal 8
1253: oPushResult
1254: oCall 229
1256: oPop 2
1258: oGetLocal 2
1260: oPushResult
1261: oSetResult 13
1263: oPushResult
1264: oSetResult 1
1266: oPushResult
1267: oNodeSetBoolean
1268: oPop 3
1270: oScopeEnd
1271: oScopeEnd
1272: oInput 4
1274: oReturn
1275: oLocalSpace 6
1277: oInputChoice 1498
1279: oGetAddrLocal 1
1281: oPushResult
1282: oNodeVecNew
1283: oAssign
1284: oGetAddrLocal 3
1286: oPushResult
1287: oSetResult 0
1289: oAssign
1290: oInputChoice 1300
1292: oGetAddrLocal 3
1294: oPushResult
1295: oSetResult 1
1297: oAssign
1298: oJumpForward 1303
1300: Choice Lookup Table
          32   1292
1303: oInput 0
1305: oGetAddrLocal 2
1307: oPushResult
1308: oSetResult 15
1310: oPushResult
1311: oSetResult 6
1313: oPushResult
1314: LAST_ID
1315: oPushResult
1316: oCall 6539
1318: oPop 3
1320: oAssign
1321: oGetLocal 2
1323: oPushResult
1324: oSetResult 21
1326: oPushResult
1327: oGetLocal 3
1329: oPushResult
1330: oNodeSetBoolean
1331: oPop 3
1333: oGetLocal 1
1335: oPushResult
1336: oGetLocal 2
1338: oPushResult
1339: oNodeVecAppend
1340: oPop 2
1342: oInputChoice 1350
1344: oJumpForward 1358
1346: oJumpForward 1356
1348: oJumpForward 1356
1350: Choice Lookup Table
          12   1348
          11   1344
1355: oEndChoice
1356: oJumpBack 1303
1358: oGetAddrLocal 4
1360: oPushResult
1361: oCall 1865
1363: oPop 1
1365: oGetLocal 3
1367: oChoice 1382
1369: oGetAddrLocal 5
1371: oPushResult
1372: oGetLocal 4
1374: oPushResult
1375: oCall 6567
1377: oPop 1
1379: oAssign
1380: oJumpForward 1391
1382: Choice Lookup Table
           1   1369
1385: oGetAddrLocal 5
1387: oPushResult
1388: oGetLocal 4
1390: oAssign
1391: oGetAddrLocal 6
1393: oPushResult
1394: oSetResult 0
1396: oAssign
1397: oGetLocal 6
1399: oPushResult
1400: oGetLocal 1
1402: oPushResult
1403: oNodeVecSize
1404: oPop 1
1406: oPushResult
1407: equal
1408: oPop 2
1410: oChoice 1467
1412: oGetAddrLocal 2
1414: oPushResult
1415: oGetLocal 1
1417: oPushResult
1418: oGetLocal 6
1420: oPushResult
1421: oNodeVecElement
1422: oPop 2
1424: oAssign
1425: oGetLocal 2
1427: oPushResult
1428: oSetResult 8
1430: oPushResult
1431: oGetLocal 4
1433: oPushResult
1434: oNodeSet
1435: oPop 3
1437: oGetLocal 2
1439: oPushResult
1440: oScopeDeclare
1441: oPop 1
1443: oGetLocal 2
1445: oPushResult
1446: oSetResult 9
1448: oPushResult
1449: oGetLocal 5
1451: oPushResult
1452: oScopeAllocType
1453: oPop 1
1455: oPushResult
1456: oNodeSetInt
1457: oPop 3
1459: oGetAddrLocal 6
1461: oPushResult
1462: inc
1463: oPop 1
1465: oJumpForward 1472
1467: Choice Lookup Table
           0   1412
1470: oJumpForward 1474
1472: oJumpBack 1397
1474: oGetLocal 1
1476: oPushResult
1477: oNodeVecDelete
1478: oPop 1
1480: oInputChoice 1488
1482: oJumpForward 1496
1484: oJumpForward 1494
1486: oJumpForward 1494
1488: Choice Lookup Table
           4   1486
          14   1482
1493: oEndChoice
1494: oJumpBack 1279
1496: oJumpForward 1501
1498: Choice Lookup Table
          13   1279
1501: oReturn
1502: oLocalSpace 2
1504: oInputChoice 1566
1506: oGetAddrLocal 1
1508: oPushResult
1509: oSetResult 9
1511: oPushResult
1512: oSetResult 4
1514: oPushResult
1515: LAST_ID
1516: oPushResult
1517: oCall 6539
1519: oPop 3
1521: oAssign
1522: oInput 5
1524: oCall 2339
1526: oGetAddrLocal 2
1528: oPushResult
1529: oValueTop
1530: oAssign
1531: oValuePop
1532: oGetLocal 1
1534: oPushResult
1535: oSetResult 9
1537: oPushResult
1538: oGetLocal 2
1540: oPushResult
1541: oNodeSetInt
1542: oPop 3
1544: oGetLocal 1
1546: oPushResult
1547: oSetResult 8
1549: oPushResult
1550: oGetGlobal 4
1552: oPushResult
1553: oNodeSet
1554: oPop 3
1556: oGetLocal 1
1558: oPushResult
1559: oScopeDeclare
1560: oPop 1
1562: oInput 4
1564: oJumpForward 1571
1566: Choice Lookup Table
           0   1506
1569: oJumpForward 1573
1571: oJumpBack 1504
1573: oReturn
1574: oLocalSpace 2
1576: oInputChoice 1625
1578: oGetAddrLocal 1
1580: oPushResult
1581: oSetResult 10
1583: oPushResult
1584: oSetResult 5
1586: oPushResult
1587: LAST_ID
1588: oPushResult
1589: oCall 6539
1591: oPop 3
1593: oAssign
1594: oInput 5
1596: oGetAddrLocal 2
1598: oPushResult
1599: oCall 1865
1601: oPop 1
1603: oGetLocal 1
1605: oPushResult
1606: oSetResult 8
1608: oPushResult
1609: oGetLocal 2
1611: oPushResult
1612: oNodeSet
1613: oPop 3
1615: oGetLocal 1
1617: oPushResult
1618: oScopeDeclare
1619: oPop 1
1621: oInput 4
1623: oJumpForward 1630
1625: Choice Lookup Table
           0   1578
1628: oJumpForward 1632
1630: oJumpBack 1576
1632: oReturn
1633: oLocalSpace 6
1635: oInputChoice 1857
1637: oGetAddrLocal 1
1639: oPushResult
1640: oNodeVecNew
1641: oAssign
1642: oGetAddrLocal 2
1644: oPushResult
1645: oGetParam 1
1647: oPushResult
1648: oSetResult 6
1650: oPushResult
1651: LAST_ID
1652: oPushResult
1653: oCall 6539
1655: oPop 3
1657: oAssign
1658: oGetLocal 1
1660: oPushResult
1661: oGetLocal 2
1663: oPushResult
1664: oNodeVecAppend
1665: oPop 2
1667: oInputChoice 1673
1669: oInput 0
1671: oJumpForward 1678
1673: Choice Lookup Table
          12   1669
1676: oJumpForward 1680
1678: oJumpBack 1642
1680: oInput 11
1682: oGetAddrLocal 3
1684: oPushResult
1685: oCall 1865
1687: oPop 1
1689: oGetAddrLocal 4
1691: oPushResult
1692: oSetResult 0
1694: oAssign
1695: oGetLocal 4
1697: oPushResult
1698: oGetLocal 1
1700: oPushResult
1701: oNodeVecSize
1702: oPop 1
1704: oPushResult
1705: equal
1706: oPop 2
1708: oChoice 1749
1710: oGetAddrLocal 2
1712: oPushResult
1713: oGetLocal 1
1715: oPushResult
1716: oGetLocal 4
1718: oPushResult
1719: oNodeVecElement
1720: oPop 2
1722: oAssign
1723: oGetLocal 2
1725: oPushResult
1726: oSetResult 8
1728: oPushResult
1729: oGetLocal 3
1731: oPushResult
1732: oNodeSet
1733: oPop 3
1735: oGetLocal 2
1737: oPushResult
1738: oScopeDeclareAlloc
1739: oPop 1
1741: oGetAddrLocal 4
1743: oPushResult
1744: inc
1745: oPop 1
1747: oJumpForward 1754
1749: Choice Lookup Table
           0   1710
1752: oJumpForward 1756
1754: oJumpBack 1695
1756: oInputChoice 1844
1758: oGetLocal 1
1760: oPushResult
1761: oNodeVecSize
1762: oPop 1
1764: oChoice 1768
1766: oJumpForward 1773
1768: Choice Lookup Table
           1   1766
1771: oError 22
1773: oGetAddrLocal 5
1775: oPushResult
1776: oCall 401
1778: oAssign
1779: oGetLocal 5
1781: oPushResult
1782: oCodePush
1783: oPop 1
1785: oGetAddrLocal 6
1787: oPushResult
1788: oSetResult 0
1790: oAssign
1791: oScopeCurrent
1792: oPushResult
1793: oGetGlobal 1
1795: oPushResult
1796: equal_node
1797: oPop 2
1799: oChoice 1815
1801: oGetGlobal 2
1803: oPushResult
1804: oScopeEnter
1805: oPop 1
1807: oGetAddrLocal 6
1809: oPushResult
1810: oSetResult 1
1812: oAssign
1813: oJumpForward 1818
1815: Choice Lookup Table
           1   1801
1818: oGetLocal 2
1820: oPushResult
1821: oCall 5744
1823: oPop 1
1825: oCall 2405
1827: oCall 6425
1829: oCall 5538
1831: oGetLocal 6
1833: oChoice 1838
1835: oScopeEnd
1836: oJumpForward 1841
1838: Choice Lookup Table
           1   1835
1841: oCodePop
1842: oJumpForward 1847
1844: Choice Lookup Table
           5   1758
1847: oGetLocal 1
1849: oPushResult
1850: oNodeVecDelete
1851: oPop 1
1853: oInput 4
1855: oJumpForward 1862
1857: Choice Lookup Table
           0   1637
1860: oJumpForward 1864
1862: oJumpBack 1635
1864: oReturn
1865: oLocalSpace 12
1867: oInputChoice 2321
1869: oGetAddrLocal 1
1871: oPushResult
1872: oScopeFindRequire
1873: oAssign
1874: oGetLocal 1
1876: oPushResult
1877: oNodeType
1878: oPop 1
1880: oChoice 1897
1882: oGetParam 1
1884: oPushResult
1885: oGetLocal 1
1887: oPushResult
1888: oSetResult 8
1890: oPushResult
1891: oNodeGet
1892: oPop 2
1894: oAssign
1895: oJumpForward 1908
1897: Choice Lookup Table
          10   1882
1900: oError 2
1902: oGetParam 1
1904: oPushResult
1905: oGetGlobal 4
1907: oAssign
1908: oJumpForward 2338
1910: oInput 15
1912: oGetAddrLocal 2
1914: oPushResult
1915: oNodeVecNew
1916: oAssign
1917: oGetAddrLocal 3
1919: oPushResult
1920: oSetResult 25
1922: oPushResult
1923: oNodeNew
1924: oPop 1
1926: oAssign
1927: oGetLocal 3
1929: oPushResult
1930: oSetResult 23
1932: oPushResult
1933: oGetGlobal 4
1935: oPushResult
1936: oNodeSet
1937: oPop 3
1939: oCall 2339
1941: oGetLocal 3
1943: oPushResult
1944: oSetResult 25
1946: oPushResult
1947: oValueTop
1948: oPushResult
1949: oNodeSetInt
1950: oPop 3
1952: oValuePop
1953: oInput 20
1955: oCall 2339
1957: oGetLocal 3
1959: oPushResult
1960: oSetResult 26
1962: oPushResult
1963: oValueTop
1964: oPushResult
1965: oNodeSetInt
1966: oPop 3
1968: oValuePop
1969: oGetLocal 3
1971: oPushResult
1972: oSetResult 3
1974: oPushResult
1975: oSetResult 4
1977: oPushResult
1978: oNodeSetInt
1979: oPop 3
1981: oGetLocal 3
1983: oPushResult
1984: oTypeAdd
1985: oPop 1
1987: oGetAddrLocal 4
1989: oPushResult
1990: oSetResult 24
1992: oPushResult
1993: oNodeNew
1994: oPop 1
1996: oAssign
1997: oGetLocal 4
1999: oPushResult
2000: oSetResult 24
2002: oPushResult
2003: oGetLocal 3
2005: oPushResult
2006: oNodeSet
2007: oPop 3
2009: oGetLocal 2
2011: oPushResult
2012: oGetLocal 4
2014: oPushResult
2015: oNodeVecAppend
2016: oPop 2
2018: oInputChoice 2026
2020: oJumpForward 2034
2022: oJumpForward 2032
2024: oJumpForward 2032
2026: Choice Lookup Table
          12   2024
          16   2020
2031: oEndChoice
2032: oJumpBack 1917
2034: oInput 38
2036: oGetAddrLocal 5
2038: oPushResult
2039: oCall 1865
2041: oPop 1
2043: oGetAddrLocal 6
2045: oPushResult
2046: oGetLocal 2
2048: oPushResult
2049: oNodeVecSize
2050: oPop 1
2052: oAssign
2053: oGetAddrLocal 6
2055: oPushResult
2056: dec
2057: oPop 1
2059: oGetAddrLocal 7
2061: oPushResult
2062: oGetLocal 2
2064: oPushResult
2065: oGetLocal 6
2067: oPushResult
2068: oNodeVecElement
2069: oPop 2
2071: oAssign
2072: oGetLocal 7
2074: oPushResult
2075: oSetResult 23
2077: oPushResult
2078: oGetLocal 5
2080: oPushResult
2081: oNodeSet
2082: oPop 3
2084: oGetAddrLocal 8
2086: oPushResult
2087: oGetLocal 7
2089: oPushResult
2090: oSetResult 24
2092: oPushResult
2093: oNodeGet
2094: oPop 2
2096: oAssign
2097: oGetAddrLocal 9
2099: oPushResult
2100: oGetLocal 8
2102: oPushResult
2103: oSetResult 26
2105: oPushResult
2106: oNodeGetInt
2107: oPop 2
2109: oPushResult
2110: oGetLocal 8
2112: oPushResult
2113: oSetResult 25
2115: oPushResult
2116: oNodeGetInt
2117: oPop 2
2119: oPushResult
2120: subtract
2121: oPop 2
2123: oAssign
2124: oGetAddrLocal 9
2126: oPushResult
2127: inc
2128: oPop 1
2130: oGetLocal 7
2132: oPushResult
2133: oSetResult 3
2135: oPushResult
2136: oGetLocal 9
2138: oPushResult
2139: oGetLocal 5
2141: oPushResult
2142: oSetResult 3
2144: oPushResult
2145: oNodeGetInt
2146: oPop 2
2148: oPushResult
2149: multiply
2150: oPop 2
2152: oPushResult
2153: oNodeSetInt
2154: oPop 3
2156: oGetLocal 7
2158: oPushResult
2159: oTypeAdd
2160: oPop 1
2162: oGetAddrLocal 5
2164: oPushResult
2165: oGetLocal 7
2167: oAssign
2168: oGetLocal 6
2170: oPushResult
2171: equal_zero
2172: oPop 1
2174: oChoice 2180
2176: oJumpForward 2185
2178: oJumpForward 2183
2180: Choice Lookup Table
           1   2176
2183: oJumpBack 2053
2185: oGetParam 1
2187: oPushResult
2188: oGetLocal 2
2190: oPushResult
2191: oSetResult 0
2193: oPushResult
2194: oNodeVecElement
2195: oPop 2
2197: oAssign
2198: oGetLocal 2
2200: oPushResult
2201: oNodeVecDelete
2202: oPop 1
2204: oJumpForward 2338
2206: oGetAddrLocal 10
2208: oPushResult
2209: oCall 1865
2211: oPop 1
2213: oGetParam 1
2215: oPushResult
2216: oGetLocal 10
2218: oPushResult
2219: oCall 6567
2221: oPop 1
2223: oAssign
2224: oJumpForward 2338
2226: oGetParam 1
2228: oPushResult
2229: oSetResult 26
2231: oPushResult
2232: oNodeNew
2233: oPop 1
2235: oAssign
2236: oSetResult -1
2238: oPushResult
2239: oScopeBegin
2240: oPop 1
2242: oSetResult 14
2244: oPushResult
2245: oCall 1633
2247: oPop 1
2249: oGetAddrLocal 11
2251: oPushResult
2252: oScopeCurrent
2253: oPushResult
2254: oSetResult 3
2256: oPushResult
2257: oNodeGetInt
2258: oPop 2
2260: oAssign
2261: oGetLocal 11
2263: oPushResult
2264: equal_zero
2265: oPop 1
2267: oChoice 2273
2269: oError 19
2271: oJumpForward 2276
2273: Choice Lookup Table
           1   2269
2276: oInput 34
2278: oGetFromParam 1
2280: oPushResult
2281: oSetResult 27
2283: oPushResult
2284: oScopeCurrent
2285: oPushResult
2286: oNodeSet
2287: oPop 3
2289: oGetFromParam 1
2291: oPushResult
2292: oSetResult 3
2294: oPushResult
2295: oGetLocal 11
2297: oPushResult
2298: oNodeSetInt
2299: oPop 3
2301: oScopeEnd
2302: oGetFromParam 1
2304: oPushResult
2305: oTypeAdd
2306: oPop 1
2308: oJumpForward 2338
2310: oInput 38
2312: oGetAddrLocal 12
2314: oPushResult
2315: oCall 1865
2317: oPop 1
2319: oJumpForward 2338
2321: Choice Lookup Table
          37   2310
          36   2226
          17   2206
          35   1910
           0   1869
2332: oCall 2339
2334: oInput 20
2336: oCall 2339
2338: oReturn
2339: oLocalSpace 1
2341: oInputChoice 2396
2343: TOKEN_VALUE
2344: oPushResult
2345: oValuePush
2346: oPop 1
2348: oJumpForward 2404
2350: oGetAddrLocal 1
2352: oPushResult
2353: oScopeFindRequire
2354: oAssign
2355: oGetLocal 1
2357: oPushResult
2358: oNodeType
2359: oPop 1
2361: oChoice 2378
2363: oGetLocal 1
2365: oPushResult
2366: oSetResult 9
2368: oPushResult
2369: oNodeGetInt
2370: oPop 2
2372: oPushResult
2373: oValuePush
2374: oPop 1
2376: oJumpForward 2389
2378: Choice Lookup Table
           9   2363
2381: oError 1
2383: oSetResult 0
2385: oPushResult
2386: oValuePush
2387: oPop 1
2389: oJumpForward 2404
2391: oCall 2339
2393: oValueNegate
2394: oJumpForward 2404
2396: Choice Lookup Table
          24   2391
           0   2350
           1   2343
2403: oEndChoice
2404: oReturn
2405: oLocalSpace 1
2407: oGetAddrLocal 1
2409: oPushResult
2410: oSetResult 0
2412: oAssign
2413: oGetAddrLocal 1
2415: oPushResult
2416: oCall 2566
2418: oPop 1
2420: oGetAddrLocal 1
2422: oPushResult
2423: oCall 2466
2425: oPop 1
2427: oReturn
2428: oLocalSpace 0
2430: oGetParam 1
2432: oPushResult
2433: oCall 2566
2435: oPop 1
2437: oTypeSNodeType
2438: oChoice 2457
2440: oJumpForward 2464
2442: oGetParam 1
2444: oPushResult
2445: oLabelNew
2446: oAssign
2447: oEmit 55
2449: oGetFromParam 1
2451: oPushResult
2452: oEmitLabel
2453: oPop 1
2455: oJumpForward 2464
2457: Choice Lookup Table
          19   2442
          20   2440
2462: oError 8
2464: oTypeSPop
2465: oReturn
2466: oLocalSpace 1
2468: oTypeSNodeType
2469: oChoice 2531
2471: oGetAddrLocal 1
2473: oPushResult
2474: oLabelNew
2475: oAssign
2476: oEmit 15
2478: oSetResult 1
2480: oPushResult
2481: oEmitInt
2482: oPop 1
2484: oEmit 53
2486: oGetLocal 1
2488: oPushResult
2489: oEmitLabel
2490: oPop 1
2492: oEmit 56
2494: oGetFromParam 1
2496: oPushResult
2497: oEmitLabel
2498: oPop 1
2500: oEmit 15
2502: oSetResult 0
2504: oPushResult
2505: oEmitInt
2506: oPop 1
2508: oEmit 56
2510: oGetLocal 1
2512: oPushResult
2513: oEmitLabel
2514: oPop 1
2516: oTypeSPop
2517: oGetGlobal 5
2519: oPushResult
2520: oTypeSPush
2521: oPop 1
2523: oGetParam 1
2525: oPushResult
2526: oSetResult 0
2528: oAssign
2529: oJumpForward 2534
2531: Choice Lookup Table
          20   2471
2534: oReturn
2535: oLocalSpace 0
2537: oTypeSNodeType
2538: oChoice 2562
2540: oGetParam 1
2542: oPushResult
2543: oLabelNew
2544: oAssign
2545: oEmit 55
2547: oGetFromParam 1
2549: oPushResult
2550: oEmitLabel
2551: oPop 1
2553: oTypeSPop
2554: oGetGlobal 6
2556: oPushResult
2557: oTypeSPush
2558: oPop 1
2560: oJumpForward 2565
2562: Choice Lookup Table
          19   2540
2565: oReturn
2566: oLocalSpace 0
2568: oGetParam 1
2570: oPushResult
2571: oCall 2931
2573: oPop 1
2575: oInputChoice 2913
2577: oGetParam 1
2579: oPushResult
2580: oCall 2466
2582: oPop 1
2584: oGetParam 1
2586: oPushResult
2587: oCall 2931
2589: oPop 1
2591: oGetParam 1
2593: oPushResult
2594: oCall 2466
2596: oPop 1
2598: oCall 6425
2600: oTypeSNodeType
2601: oChoice 2615
2603: oEmit 38
2605: oJumpForward 2628
2607: oEmit 44
2609: oJumpForward 2628
2611: oError 16
2613: oJumpForward 2628
2615: Choice Lookup Table
          22   2611
          21   2611
          23   2607
          19   2603
          18   2603
2626: oError 17
2628: oTypeSPop
2629: oGetGlobal 5
2631: oPushResult
2632: oTypeSPush
2633: oPop 1
2635: oJumpForward 2928
2637: oGetParam 1
2639: oPushResult
2640: oCall 2466
2642: oPop 1
2644: oGetParam 1
2646: oPushResult
2647: oCall 2931
2649: oPop 1
2651: oGetParam 1
2653: oPushResult
2654: oCall 2466
2656: oPop 1
2658: oCall 6425
2660: oTypeSNodeType
2661: oChoice 2675
2663: oEmit 39
2665: oJumpForward 2688
2667: oEmit 45
2669: oJumpForward 2688
2671: oError 16
2673: oJumpForward 2688
2675: Choice Lookup Table
          22   2671
          21   2671
          23   2667
          19   2663
          18   2663
2686: oError 17
2688: oTypeSPop
2689: oGetGlobal 5
2691: oPushResult
2692: oTypeSPush
2693: oPop 1
2695: oJumpForward 2928
2697: oGetParam 1
2699: oPushResult
2700: oCall 2466
2702: oPop 1
2704: oGetParam 1
2706: oPushResult
2707: oCall 2931
2709: oPop 1
2711: oGetParam 1
2713: oPushResult
2714: oCall 2466
2716: oPop 1
2718: oCall 6425
2720: oTypeSNodeType
2721: oChoice 2731
2723: oEmit 41
2725: oJumpForward 2742
2727: oError 16
2729: oJumpForward 2742
2731: Choice Lookup Table
          22   2727
          21   2727
          19   2723
          18   2723
2740: oError 17
2742: oTypeSPop
2743: oGetGlobal 5
2745: oPushResult
2746: oTypeSPush
2747: oPop 1
2749: oJumpForward 2928
2751: oGetParam 1
2753: oPushResult
2754: oCall 2466
2756: oPop 1
2758: oGetParam 1
2760: oPushResult
2761: oCall 2931
2763: oPop 1
2765: oGetParam 1
2767: oPushResult
2768: oCall 2466
2770: oPop 1
2772: oCall 6425
2774: oTypeSNodeType
2775: oChoice 2785
2777: oEmit 40
2779: oJumpForward 2796
2781: oError 16
2783: oJumpForward 2796
2785: Choice Lookup Table
          22   2781
          21   2781
          19   2777
          18   2777
2794: oError 17
2796: oTypeSPop
2797: oGetGlobal 5
2799: oPushResult
2800: oTypeSPush
2801: oPop 1
2803: oJumpForward 2928
2805: oGetParam 1
2807: oPushResult
2808: oCall 2466
2810: oPop 1
2812: oGetParam 1
2814: oPushResult
2815: oCall 2931
2817: oPop 1
2819: oGetParam 1
2821: oPushResult
2822: oCall 2466
2824: oPop 1
2826: oCall 6425
2828: oTypeSNodeType
2829: oChoice 2839
2831: oEmit 43
2833: oJumpForward 2850
2835: oError 16
2837: oJumpForward 2850
2839: Choice Lookup Table
          22   2835
          21   2835
          19   2831
          18   2831
2848: oError 17
2850: oTypeSPop
2851: oGetGlobal 5
2853: oPushResult
2854: oTypeSPush
2855: oPop 1
2857: oJumpForward 2928
2859: oGetParam 1
2861: oPushResult
2862: oCall 2466
2864: oPop 1
2866: oGetParam 1
2868: oPushResult
2869: oCall 2931
2871: oPop 1
2873: oGetParam 1
2875: oPushResult
2876: oCall 2466
2878: oPop 1
2880: oCall 6425
2882: oTypeSNodeType
2883: oChoice 2893
2885: oEmit 42
2887: oJumpForward 2904
2889: oError 16
2891: oJumpForward 2904
2893: Choice Lookup Table
          22   2889
          21   2889
          19   2885
          18   2885
2902: oError 17
2904: oTypeSPop
2905: oGetGlobal 5
2907: oPushResult
2908: oTypeSPush
2909: oPop 1
2911: oJumpForward 2928
2913: Choice Lookup Table
          10   2859
           9   2805
           8   2751
           7   2697
           6   2637
           5   2577
2926: oJumpForward 2930
2928: oJumpBack 2575
2930: oReturn
2931: oLocalSpace 1
2933: oGetAddrLocal 1
2935: oPushResult
2936: oSetResult 0
2938: oAssign
2939: oGetParam 1
2941: oPushResult
2942: oCall 3111
2944: oPop 1
2946: oInputChoice 3079
2948: oTypeSNodeType
2949: oChoice 3020
2951: oGetLocal 1
2953: oPushResult
2954: oSetResult 0
2956: oPushResult
2957: equal_label
2958: oPop 2
2960: oChoice 2969
2962: oGetAddrLocal 1
2964: oPushResult
2965: oLabelNew
2966: oAssign
2967: oJumpForward 2972
2969: Choice Lookup Table
           1   2962
2972: oEmit 53
2974: oGetLocal 1
2976: oPushResult
2977: oEmitLabel
2978: oPop 1
2980: oJumpForward 3027
2982: oGetParam 1
2984: oPushResult
2985: oCall 2535
2987: oPop 1
2989: oGetLocal 1
2991: oPushResult
2992: oSetResult 0
2994: oPushResult
2995: equal_label
2996: oPop 2
2998: oChoice 3007
3000: oGetAddrLocal 1
3002: oPushResult
3003: oLabelNew
3004: oAssign
3005: oJumpForward 3010
3007: Choice Lookup Table
           1   3000
3010: oEmit 53
3012: oGetLocal 1
3014: oPushResult
3015: oEmitLabel
3016: oPop 1
3018: oJumpForward 3027
3020: Choice Lookup Table
          19   2982
          20   2951
3025: oError 8
3027: oTypeSPop
3028: oEmit 56
3030: oGetFromParam 1
3032: oPushResult
3033: oEmitLabel
3034: oPop 1
3036: oGetParam 1
3038: oPushResult
3039: oSetResult 0
3041: oAssign
3042: oGetParam 1
3044: oPushResult
3045: oCall 3111
3047: oPop 1
3049: oTypeSNodeType
3050: oChoice 3063
3052: oJumpForward 3070
3054: oGetParam 1
3056: oPushResult
3057: oCall 2535
3059: oPop 1
3061: oJumpForward 3070
3063: Choice Lookup Table
          19   3054
          20   3052
3068: oError 8
3070: oTypeSPop
3071: oGetGlobal 6
3073: oPushResult
3074: oTypeSPush
3075: oPop 1
3077: oJumpForward 3084
3079: Choice Lookup Table
          52   2948
3082: oJumpForward 3086
3084: oJumpBack 2946
3086: oGetLocal 1
3088: oPushResult
3089: oSetResult 0
3091: oPushResult
3092: equal_label
3093: oPop 2
3095: oChoice 3107
3097: oEmit 56
3099: oGetLocal 1
3101: oPushResult
3102: oEmitLabel
3103: oPop 1
3105: oJumpForward 3110
3107: Choice Lookup Table
           0   3097
3110: oReturn
3111: oLocalSpace 2
3113: oGetAddrLocal 1
3115: oPushResult
3116: oSetResult 0
3118: oAssign
3119: oGetParam 1
3121: oPushResult
3122: oCall 3249
3124: oPop 1
3126: oInputChoice 3241
3128: oTypeSNodeType
3129: oChoice 3142
3131: oJumpForward 3149
3133: oGetParam 1
3135: oPushResult
3136: oCall 2535
3138: oPop 1
3140: oJumpForward 3149
3142: Choice Lookup Table
          19   3133
          20   3131
3147: oError 8
3149: oTypeSPop
3150: oGetLocal 1
3152: oPushResult
3153: oSetResult 0
3155: oPushResult
3156: equal_label
3157: oPop 2
3159: oChoice 3188
3161: oGetAddrLocal 1
3163: oPushResult
3164: oLabelNew
3165: oAssign
3166: oEmit 57
3168: oGetFromParam 1
3170: oPushResult
3171: oEmitLabel
3172: oPop 1
3174: oGetLocal 1
3176: oPushResult
3177: oEmitLabel
3178: oPop 1
3180: oGetParam 1
3182: oPushResult
3183: oGetLocal 1
3185: oAssign
3186: oJumpForward 3191
3188: Choice Lookup Table
           1   3161
3191: oGetAddrLocal 2
3193: oPushResult
3194: oSetResult 0
3196: oAssign
3197: oGetAddrLocal 2
3199: oPushResult
3200: oCall 3249
3202: oPop 1
3204: oTypeSNodeType
3205: oChoice 3218
3207: oJumpForward 3225
3209: oGetAddrLocal 2
3211: oPushResult
3212: oCall 2535
3214: oPop 1
3216: oJumpForward 3225
3218: Choice Lookup Table
          19   3209
          20   3207
3223: oError 8
3225: oEmit 57
3227: oGetLocal 2
3229: oPushResult
3230: oEmitLabel
3231: oPop 1
3233: oGetLocal 1
3235: oPushResult
3236: oEmitLabel
3237: oPop 1
3239: oJumpForward 3246
3241: Choice Lookup Table
          51   3128
3244: oJumpForward 3248
3246: oJumpBack 3126
3248: oReturn
3249: oLocalSpace 1
3251: oInputChoice 3305
3253: oGetAddrLocal 1
3255: oPushResult
3256: oSetResult 0
3258: oAssign
3259: oGetAddrLocal 1
3261: oPushResult
3262: oCall 3249
3264: oPop 1
3266: oTypeSNodeType
3267: oChoice 3296
3269: oGetParam 1
3271: oPushResult
3272: oLabelNew
3273: oAssign
3274: oEmit 53
3276: oGetFromParam 1
3278: oPushResult
3279: oEmitLabel
3280: oPop 1
3282: oEmit 56
3284: oGetLocal 1
3286: oPushResult
3287: oEmitLabel
3288: oPop 1
3290: oJumpForward 3303
3292: oEmit 37
3294: oJumpForward 3303
3296: Choice Lookup Table
          19   3292
          20   3269
3301: oError 8
3303: oJumpForward 3315
3305: Choice Lookup Table
          53   3253
3308: oGetParam 1
3310: oPushResult
3311: oCall 3316
3313: oPop 1
3315: oReturn
3316: oLocalSpace 0
3318: oGetParam 1
3320: oPushResult
3321: oCall 3367
3323: oPop 1
3325: oInputChoice 3357
3327: oCall 6451
3329: oGetParam 1
3331: oPushResult
3332: oCall 3367
3334: oPop 1
3336: oCall 6465
3338: oEmit 34
3340: oJumpForward 3364
3342: oCall 6451
3344: oGetParam 1
3346: oPushResult
3347: oCall 3367
3349: oPop 1
3351: oCall 6465
3353: oEmit 35
3355: oJumpForward 3364
3357: Choice Lookup Table
          24   3342
          23   3327
3362: oJumpForward 3366
3364: oJumpBack 3325
3366: oReturn
3367: oLocalSpace 0
3369: oGetParam 1
3371: oPushResult
3372: oCall 3418
3374: oPop 1
3376: oInputChoice 3408
3378: oCall 6451
3380: oGetParam 1
3382: oPushResult
3383: oCall 3418
3385: oPop 1
3387: oCall 6465
3389: oEmit 31
3391: oJumpForward 3415
3393: oCall 6451
3395: oGetParam 1
3397: oPushResult
3398: oCall 3418
3400: oPop 1
3402: oCall 6465
3404: oEmit 32
3406: oJumpForward 3415
3408: Choice Lookup Table
          22   3393
          21   3378
3413: oJumpForward 3417
3415: oJumpBack 3376
3417: oReturn
3418: oLocalSpace 0
3420: oInputChoice 3446
3422: oGetParam 1
3424: oPushResult
3425: oCall 3459
3427: oPop 1
3429: oCall 6465
3431: oJumpForward 3458
3433: oGetParam 1
3435: oPushResult
3436: oCall 3459
3438: oPop 1
3440: oCall 6465
3442: oEmit 36
3444: oJumpForward 3458
3446: Choice Lookup Table
          24   3433
          23   3422
3451: oGetParam 1
3453: oPushResult
3454: oCall 3459
3456: oPop 1
3458: oReturn
3459: oLocalSpace 6
3461: oInputChoice 3647
3463: oEmit 15
3465: TOKEN_VALUE
3466: oPushResult
3467: oEmitInt
3468: oPop 1
3470: oGetGlobal 4
3472: oPushResult
3473: oTypeSPush
3474: oPop 1
3476: oJumpForward 3666
3478: oGetParam 1
3480: oPushResult
3481: oCall 2566
3483: oPop 1
3485: oInput 14
3487: oJumpForward 3666
3489: oGetAddrLocal 1
3491: oPushResult
3492: CURRENT_STRLIT
3493: oPushResult
3494: oStringAllocLit
3495: oPop 1
3497: oAssign
3498: oEmit 16
3500: oGetLocal 1
3502: oPushResult
3503: oEmitInt
3504: oPop 1
3506: oGetGlobal 8
3508: oPushResult
3509: oTypeSPush
3510: oPop 1
3512: oJumpForward 3666
3514: oGetAddrLocal 2
3516: oPushResult
3517: oScopeFindRequire
3518: oAssign
3519: oGetLocal 2
3521: oPushResult
3522: oNodeType
3523: oPop 1
3525: oChoice 3587
3527: oGetLocal 2
3529: oPushResult
3530: oCall 4847
3532: oPop 1
3534: oJumpForward 3606
3536: oGetAddrLocal 3
3538: oPushResult
3539: oGetLocal 2
3541: oPushResult
3542: oSetResult 8
3544: oPushResult
3545: oNodeGet
3546: oPop 2
3548: oAssign
3549: oGetLocal 3
3551: oPushResult
3552: oTypeSPush
3553: oPop 1
3555: oTypeSNodeType
3556: oChoice 3569
3558: oEmit 15
3560: oGetLocal 2
3562: oPushResult
3563: oCall 6702
3565: oPop 1
3567: oJumpForward 3576
3569: Choice Lookup Table
          19   3558
          18   3558
3574: oError 16
3576: oJumpForward 3606
3578: oGetLocal 2
3580: oPushResult
3581: oCall 3667
3583: oPop 1
3585: oJumpForward 3606
3587: Choice Lookup Table
          15   3578
          13   3578
          12   3578
           9   3536
           8   3527
3598: oError 6
3600: oGetGlobal 4
3602: oPushResult
3603: oTypeSPush
3604: oPop 1
3606: oJumpForward 3666
3608: oInput 0
3610: oGetAddrLocal 4
3612: oPushResult
3613: oScopeFindRequire
3614: oAssign
3615: oGetLocal 4
3617: oPushResult
3618: oCall 5744
3620: oPop 1
3622: oGetAddrLocal 5
3624: oPushResult
3625: oTypeSTop
3626: oAssign
3627: oTypeSPop
3628: oGetAddrLocal 6
3630: oPushResult
3631: oGetLocal 5
3633: oPushResult
3634: oCall 6567
3636: oPop 1
3638: oAssign
3639: oGetLocal 6
3641: oPushResult
3642: oTypeSPush
3643: oPop 1
3645: oJumpForward 3666
3647: Choice Lookup Table
          18   3608
           0   3514
           2   3489
          13   3478
           1   3463
3658: oError 6
3660: oGetGlobal 4
3662: oPushResult
3663: oTypeSPush
3664: oPop 1
3666: oReturn
3667: oLocalSpace 3
3669: oGetAddrLocal 1
3671: oPushResult
3672: oGetParam 1
3674: oPushResult
3675: oSetResult 8
3677: oPushResult
3678: oNodeGet
3679: oPop 2
3681: oAssign
3682: oGetAddrLocal 2
3684: oPushResult
3685: oGetParam 1
3687: oPushResult
3688: oSetResult 6
3690: oPushResult
3691: oNodeGet
3692: oPop 2
3694: oAssign
3695: oGetAddrLocal 3
3697: oPushResult
3698: oScopeCurrent
3699: oPushResult
3700: oSetResult 1
3702: oPushResult
3703: oNodeGetInt
3704: oPop 2
3706: oPushResult
3707: oGetLocal 2
3709: oPushResult
3710: oSetResult 1
3712: oPushResult
3713: oNodeGetInt
3714: oPop 2
3716: oPushResult
3717: subtract
3718: oPop 2
3720: oAssign
3721: oGetLocal 1
3723: oPushResult
3724: oTypeSPush
3725: oPop 1
3727: oTypeSNodeType
3728: oChoice 4245
3730: oGetParam 1
3732: oPushResult
3733: oNodeType
3734: oPop 1
3736: oChoice 3882
3738: oEmit 0
3740: oGetParam 1
3742: oPushResult
3743: oCall 6702
3745: oPop 1
3747: oJumpForward 3890
3749: oGetLocal 3
3751: oPushResult
3752: equal_zero
3753: oPop 1
3755: oChoice 3768
3757: oEmit 3
3759: oGetParam 1
3761: oPushResult
3762: oCall 6702
3764: oPop 1
3766: oJumpForward 3786
3768: Choice Lookup Table
           1   3757
3771: oEmit 9
3773: oGetLocal 3
3775: oPushResult
3776: oEmitInt
3777: oPop 1
3779: oGetParam 1
3781: oPushResult
3782: oCall 6702
3784: oPop 1
3786: oJumpForward 3890
3788: oGetParam 1
3790: oPushResult
3791: oSetResult 21
3793: oPushResult
3794: oNodeGetBoolean
3795: oPop 2
3797: oChoice 3840
3799: oGetLocal 3
3801: oPushResult
3802: equal_zero
3803: oPop 1
3805: oChoice 3818
3807: oEmit 8
3809: oGetParam 1
3811: oPushResult
3812: oCall 6702
3814: oPop 1
3816: oJumpForward 3836
3818: Choice Lookup Table
           1   3807
3821: oEmit 14
3823: oGetLocal 3
3825: oPushResult
3826: oEmitInt
3827: oPop 1
3829: oGetParam 1
3831: oPushResult
3832: oCall 6702
3834: oPop 1
3836: oEmit 22
3838: oJumpForward 3880
3840: Choice Lookup Table
           1   3799
3843: oGetLocal 3
3845: oPushResult
3846: equal_zero
3847: oPop 1
3849: oChoice 3862
3851: oEmit 6
3853: oGetParam 1
3855: oPushResult
3856: oCall 6702
3858: oPop 1
3860: oJumpForward 3880
3862: Choice Lookup Table
           1   3851
3865: oEmit 12
3867: oGetLocal 3
3869: oPushResult
3870: oEmitInt
3871: oPop 1
3873: oGetParam 1
3875: oPushResult
3876: oCall 6702
3878: oPop 1
3880: oJumpForward 3890
3882: Choice Lookup Table
          15   3788
          13   3749
          12   3738
3889: oEndChoice
3890: oJumpForward 4420
3892: oGetParam 1
3894: oPushResult
3895: oNodeType
3896: oPop 1
3898: oChoice 4044
3900: oEmit 1
3902: oGetParam 1
3904: oPushResult
3905: oCall 6702
3907: oPop 1
3909: oJumpForward 4052
3911: oGetLocal 3
3913: oPushResult
3914: equal_zero
3915: oPop 1
3917: oChoice 3930
3919: oEmit 4
3921: oGetParam 1
3923: oPushResult
3924: oCall 6702
3926: oPop 1
3928: oJumpForward 3948
3930: Choice Lookup Table
           1   3919
3933: oEmit 10
3935: oGetLocal 3
3937: oPushResult
3938: oEmitInt
3939: oPop 1
3941: oGetParam 1
3943: oPushResult
3944: oCall 6702
3946: oPop 1
3948: oJumpForward 4052
3950: oGetParam 1
3952: oPushResult
3953: oSetResult 21
3955: oPushResult
3956: oNodeGetBoolean
3957: oPop 2
3959: oChoice 4002
3961: oGetLocal 3
3963: oPushResult
3964: equal_zero
3965: oPop 1
3967: oChoice 3980
3969: oEmit 8
3971: oGetParam 1
3973: oPushResult
3974: oCall 6702
3976: oPop 1
3978: oJumpForward 3998
3980: Choice Lookup Table
           1   3969
3983: oEmit 14
3985: oGetLocal 3
3987: oPushResult
3988: oEmitInt
3989: oPop 1
3991: oGetParam 1
3993: oPushResult
3994: oCall 6702
3996: oPop 1
3998: oEmit 23
4000: oJumpForward 4042
4002: Choice Lookup Table
           1   3961
4005: oGetLocal 3
4007: oPushResult
4008: equal_zero
4009: oPop 1
4011: oChoice 4024
4013: oEmit 7
4015: oGetParam 1
4017: oPushResult
4018: oCall 6702
4020: oPop 1
4022: oJumpForward 4042
4024: Choice Lookup Table
           1   4013
4027: oEmit 13
4029: oGetLocal 3
4031: oPushResult
4032: oEmitInt
4033: oPop 1
4035: oGetParam 1
4037: oPushResult
4038: oCall 6702
4040: oPop 1
4042: oJumpForward 4052
4044: Choice Lookup Table
          15   3950
          13   3911
          12   3900
4051: oEndChoice
4052: oJumpForward 4420
4054: oError 16
4056: oJumpForward 4420
4058: oGetParam 1
4060: oPushResult
4061: oNodeType
4062: oPop 1
4064: oChoice 4210
4066: oEmit 2
4068: oGetParam 1
4070: oPushResult
4071: oCall 6702
4073: oPop 1
4075: oJumpForward 4218
4077: oGetLocal 3
4079: oPushResult
4080: equal_zero
4081: oPop 1
4083: oChoice 4096
4085: oEmit 5
4087: oGetParam 1
4089: oPushResult
4090: oCall 6702
4092: oPop 1
4094: oJumpForward 4114
4096: Choice Lookup Table
           1   4085
4099: oEmit 11
4101: oGetLocal 3
4103: oPushResult
4104: oEmitInt
4105: oPop 1
4107: oGetParam 1
4109: oPushResult
4110: oCall 6702
4112: oPop 1
4114: oJumpForward 4218
4116: oGetParam 1
4118: oPushResult
4119: oSetResult 21
4121: oPushResult
4122: oNodeGetBoolean
4123: oPop 2
4125: oChoice 4168
4127: oGetLocal 3
4129: oPushResult
4130: equal_zero
4131: oPop 1
4133: oChoice 4146
4135: oEmit 8
4137: oGetParam 1
4139: oPushResult
4140: oCall 6702
4142: oPop 1
4144: oJumpForward 4164
4146: Choice Lookup Table
           1   4135
4149: oEmit 14
4151: oGetLocal 3
4153: oPushResult
4154: oEmitInt
4155: oPop 1
4157: oGetParam 1
4159: oPushResult
4160: oCall 6702
4162: oPop 1
4164: oEmit 24
4166: oJumpForward 4208
4168: Choice Lookup Table
           1   4127
4171: oGetLocal 3
4173: oPushResult
4174: equal_zero
4175: oPop 1
4177: oChoice 4190
4179: oEmit 8
4181: oGetParam 1
4183: oPushResult
4184: oCall 6702
4186: oPop 1
4188: oJumpForward 4208
4190: Choice Lookup Table
           1   4179
4193: oEmit 14
4195: oGetLocal 3
4197: oPushResult
4198: oEmitInt
4199: oPop 1
4201: oGetParam 1
4203: oPushResult
4204: oCall 6702
4206: oPop 1
4208: oJumpForward 4218
4210: Choice Lookup Table
          15   4116
          13   4077
          12   4066
4217: oEndChoice
4218: oInputChoice 4240
4220: oTypeSPop
4221: oGetLocal 1
4223: oPushResult
4224: oSetResult 23
4226: oPushResult
4227: oNodeGet
4228: oPop 2
4230: oPushResult
4231: oTypeSPush
4232: oPop 1
4234: oCall 4456
4236: oCall 4421
4238: oJumpForward 4243
4240: Choice Lookup Table
          17   4220
4243: oJumpForward 4420
4245: Choice Lookup Table
          23   4058
          17   4054
          22   4054
          21   4054
          19   3892
          18   3730
4258: oGetParam 1
4260: oPushResult
4261: oNodeType
4262: oPop 1
4264: oChoice 4408
4266: oEmit 16
4268: oGetParam 1
4270: oPushResult
4271: oCall 6702
4273: oPop 1
4275: oJumpForward 4416
4277: oGetLocal 3
4279: oPushResult
4280: equal_zero
4281: oPop 1
4283: oChoice 4296
4285: oEmit 17
4287: oGetParam 1
4289: oPushResult
4290: oCall 6702
4292: oPop 1
4294: oJumpForward 4314
4296: Choice Lookup Table
           1   4285
4299: oEmit 20
4301: oGetLocal 3
4303: oPushResult
4304: oEmitInt
4305: oPop 1
4307: oGetParam 1
4309: oPushResult
4310: oCall 6702
4312: oPop 1
4314: oJumpForward 4416
4316: oGetParam 1
4318: oPushResult
4319: oSetResult 21
4321: oPushResult
4322: oNodeGetBoolean
4323: oPop 2
4325: oChoice 4366
4327: oGetLocal 3
4329: oPushResult
4330: equal_zero
4331: oPop 1
4333: oChoice 4346
4335: oEmit 8
4337: oGetParam 1
4339: oPushResult
4340: oCall 6702
4342: oPop 1
4344: oJumpForward 4364
4346: Choice Lookup Table
           1   4335
4349: oEmit 14
4351: oGetLocal 3
4353: oPushResult
4354: oEmitInt
4355: oPop 1
4357: oGetParam 1
4359: oPushResult
4360: oCall 6702
4362: oPop 1
4364: oJumpForward 4406
4366: Choice Lookup Table
           1   4327
4369: oGetLocal 3
4371: oPushResult
4372: equal_zero
4373: oPop 1
4375: oChoice 4388
4377: oEmit 18
4379: oGetParam 1
4381: oPushResult
4382: oCall 6702
4384: oPop 1
4386: oJumpForward 4406
4388: Choice Lookup Table
           1   4377
4391: oEmit 21
4393: oGetLocal 3
4395: oPushResult
4396: oEmitInt
4397: oPop 1
4399: oGetParam 1
4401: oPushResult
4402: oCall 6702
4404: oPop 1
4406: oJumpForward 4416
4408: Choice Lookup Table
          15   4316
          13   4277
          12   4266
4415: oEndChoice
4416: oCall 4456
4418: oCall 4421
4420: oReturn
4421: oLocalSpace 0
4423: oTypeSNodeType
4424: oChoice 4442
4426: oEmit 22
4428: oJumpForward 4455
4430: oEmit 23
4432: oJumpForward 4455
4434: oError 16
4436: oJumpForward 4455
4438: oEmit 24
4440: oJumpForward 4455
4442: Choice Lookup Table
          23   4438
          17   4434
          22   4434
          21   4434
          19   4430
          18   4426
4455: oReturn
4456: oLocalSpace 0
4458: oInputChoice 4472
4460: oCall 4484
4462: oJumpForward 4481
4464: oCall 4627
4466: oJumpForward 4481
4468: oCall 4725
4470: oJumpForward 4481
4472: Choice Lookup Table
          17   4468
          19   4464
          15   4460
4479: oJumpForward 4483
4481: oJumpBack 4458
4483: oReturn
4484: oLocalSpace 3
4486: oTypeSNodeType
4487: oChoice 4491
4489: oJumpForward 4496
4491: Choice Lookup Table
          24   4489
4494: oError 10
4496: oTypeSNodeType
4497: oChoice 4501
4499: oJumpForward 4506
4501: Choice Lookup Table
          24   4499
4504: oError 13
4506: oGetAddrLocal 1
4508: oPushResult
4509: oTypeSTop
4510: oPushResult
4511: oSetResult 24
4513: oPushResult
4514: oNodeGet
4515: oPop 2
4517: oPushResult
4518: oCall 6651
4520: oPop 1
4522: oAssign
4523: oGetAddrLocal 2
4525: oPushResult
4526: oTypeSTop
4527: oPushResult
4528: oSetResult 23
4530: oPushResult
4531: oNodeGet
4532: oPop 2
4534: oAssign
4535: oTypeSPop
4536: oGetLocal 2
4538: oPushResult
4539: oTypeSPush
4540: oPop 1
4542: oCall 2405
4544: oCall 6451
4546: oGetLocal 1
4548: oPushResult
4549: equal_zero
4550: oPop 1
4552: oChoice 4566
4554: oEmit 15
4556: oGetLocal 1
4558: oPushResult
4559: oEmitInt
4560: oPop 1
4562: oEmit 35
4564: oJumpForward 4569
4566: Choice Lookup Table
           0   4554
4569: oGetAddrLocal 3
4571: oPushResult
4572: oGetLocal 2
4574: oPushResult
4575: oSetResult 3
4577: oPushResult
4578: oNodeGetInt
4579: oPop 2
4581: oAssign
4582: oGetLocal 3
4584: oPushResult
4585: oSetResult 1
4587: oPushResult
4588: equal
4589: oPop 2
4591: oChoice 4605
4593: oEmit 15
4595: oGetLocal 3
4597: oPushResult
4598: oEmitInt
4599: oPop 1
4601: oEmit 31
4603: oJumpForward 4608
4605: Choice Lookup Table
           0   4593
4608: oEmit 33
4610: oInputChoice 4618
4612: oJumpForward 4626
4614: oJumpForward 4624
4616: oJumpForward 4624
4618: Choice Lookup Table
          12   4616
          16   4612
4623: oEndChoice
4624: oJumpBack 4496
4626: oReturn
4627: oLocalSpace 2
4629: oTypeSNodeType
4630: oChoice 4634
4632: oJumpForward 4639
4634: Choice Lookup Table
          26   4632
4637: oError 11
4639: oTypeSTop
4640: oPushResult
4641: oSetResult 27
4643: oPushResult
4644: oNodeGet
4645: oPop 2
4647: oPushResult
4648: oScopeEnter
4649: oPop 1
4651: oInput 0
4653: oGetAddrLocal 1
4655: oPushResult
4656: oScopeFindRequire
4657: oAssign
4658: oGetLocal 1
4660: oPushResult
4661: oNodeType
4662: oPop 1
4664: oChoice 4668
4666: oJumpForward 4673
4668: Choice Lookup Table
          14   4666
4671: oError 12
4673: oScopeEnd
4674: oGetAddrLocal 2
4676: oPushResult
4677: oGetLocal 1
4679: oPushResult
4680: oSetResult 9
4682: oPushResult
4683: oNodeGetInt
4684: oPop 2
4686: oAssign
4687: oGetLocal 2
4689: oPushResult
4690: equal_zero
4691: oPop 1
4693: oChoice 4707
4695: oEmit 15
4697: oGetLocal 2
4699: oPushResult
4700: oEmitInt
4701: oPop 1
4703: oEmit 33
4705: oJumpForward 4710
4707: Choice Lookup Table
           0   4695
4710: oTypeSPop
4711: oGetLocal 1
4713: oPushResult
4714: oSetResult 8
4716: oPushResult
4717: oNodeGet
4718: oPop 2
4720: oPushResult
4721: oTypeSPush
4722: oPop 1
4724: oReturn
4725: oLocalSpace 1
4727: oTypeSNodeType
4728: oChoice 4732
4730: oJumpForward 4737
4732: Choice Lookup Table
          23   4730
4735: oError 9
4737: oEmit 24
4739: oGetAddrLocal 1
4741: oPushResult
4742: oTypeSTop
4743: oAssign
4744: oTypeSPop
4745: oGetLocal 1
4747: oPushResult
4748: oSetResult 23
4750: oPushResult
4751: oNodeGet
4752: oPop 2
4754: oPushResult
4755: oTypeSPush
4756: oPop 1
4758: oReturn
4759: oLocalSpace 0
4761: oCall 6425
4763: oReturn
4764: oLocalSpace 2
4766: oGetAddrLocal 2
4768: oPushResult
4769: oGetParam 1
4771: oPushResult
4772: oSetResult 15
4774: oPushResult
4775: oNodeGetString
4776: oPop 2
4778: oAssign
4779: oGetLocal 2
4781: oPushResult
4782: oSetResult 0
4784: oPushResult
4785: equal_string
4786: oPop 2
4788: oChoice 4825
4790: oGetAddrLocal 1
4792: oPushResult
4793: oGetParam 1
4795: oPushResult
4796: oSetResult 7
4798: oPushResult
4799: oNodeGetInt
4800: oPop 2
4802: oPushResult
4803: ID_STRING
4804: oPop 1
4806: oPushResult
4807: oStringAllocLit
4808: oPop 1
4810: oAssign
4811: oJumpForward 4831
4813: oGetAddrLocal 1
4815: oPushResult
4816: oGetLocal 2
4818: oPushResult
4819: oStringAllocLit
4820: oPop 1
4822: oAssign
4823: oJumpForward 4831
4825: Choice Lookup Table
           0   4813
           1   4790
4830: oEndChoice
4831: oEmit 58
4833: oGetParam 1
4835: oPushResult
4836: oCall 6702
4838: oPop 1
4840: oGetLocal 1
4842: oPushResult
4843: oEmitInt
4844: oPop 1
4846: oReturn
4847: oLocalSpace 10
4849: oGetParam 1
4851: oPushResult
4852: oSetResult 14
4854: oPushResult
4855: oNodeGetBoolean
4856: oPop 2
4858: oChoice 4885
4860: oGetParam 1
4862: oPushResult
4863: oSetResult 17
4865: oPushResult
4866: oNodeGetBoolean
4867: oPop 2
4869: oChoice 4880
4871: oGetParam 1
4873: oPushResult
4874: oCall 4764
4876: oPop 1
4878: oJumpForward 4883
4880: Choice Lookup Table
           0   4871
4883: oJumpForward 4888
4885: Choice Lookup Table
           1   4860
4888: oGetParam 1
4890: oPushResult
4891: oSetResult 17
4893: oPushResult
4894: oSetResult 1
4896: oPushResult
4897: oNodeSetBoolean
4898: oPop 3
4900: oGetAddrLocal 1
4902: oPushResult
4903: oGetParam 1
4905: oPushResult
4906: oSetResult 16
4908: oPushResult
4909: oNodeGetBoolean
4910: oPop 2
4912: oAssign
4913: oGetAddrLocal 4
4915: oPushResult
4916: oGetParam 1
4918: oPushResult
4919: oNodeType
4920: oPop 1
4922: oPushResult
4923: oSetResult 8
4925: oPushResult
4926: equal_node_type
4927: oPop 2
4929: oAssign
4930: oGetLocal 4
4932: oChoice 4959
4934: oGetAddrLocal 2
4936: oPushResult
4937: oGetParam 1
4939: oPushResult
4940: oSetResult 8
4942: oPushResult
4943: oNodeGet
4944: oPop 2
4946: oAssign
4947: oGetAddrLocal 3
4949: oPushResult
4950: oGetLocal 2
4952: oPushResult
4953: oScopeAllocType
4954: oPop 1
4956: oAssign
4957: oJumpForward 4962
4959: Choice Lookup Table
           1   4934
4962: oGetAddrLocal 5
4964: oPushResult
4965: oGetParam 1
4967: oPushResult
4968: oSetResult 11
4970: oPushResult
4971: oNodeGet
4972: oPop 2
4974: oAssign
4975: oGetAddrLocal 6
4977: oPushResult
4978: oGetLocal 5
4980: oPushResult
4981: oSetResult 3
4983: oPushResult
4984: oNodeGetInt
4985: oPop 2
4987: oAssign
4988: oGetLocal 1
4990: oChoice 5012
4992: oEmit 47
4994: oGetLocal 6
4996: oPushResult
4997: oEmitInt
4998: oPop 1
5000: oJumpForward 5018
5002: oEmit 46
5004: oGetLocal 6
5006: oPushResult
5007: oEmitInt
5008: oPop 1
5010: oJumpForward 5018
5012: Choice Lookup Table
           0   5002
           1   4992
5017: oEndChoice
5018: oGetAddrLocal 7
5020: oPushResult
5021: oGetLocal 5
5023: oPushResult
5024: oSetResult 2
5026: oPushResult
5027: oNodeGetIter
5028: oPop 2
5030: oAssign
5031: oGetAddrLocal 8
5033: oPushResult
5034: oGetLocal 7
5036: oPushResult
5037: oNodeIterValue
5038: oPop 1
5040: oAssign
5041: oInputChoice 5220
5043: oGetLocal 8
5045: oPushResult
5046: oNodeNull
5047: oPop 1
5049: oChoice 5055
5051: oJumpForward 5216
5053: oJumpForward 5058
5055: Choice Lookup Table
           1   5051
5058: oGetAddrLocal 9
5060: oPushResult
5061: oGetLocal 8
5063: oPushResult
5064: oSetResult 9
5066: oPushResult
5067: oNodeGetInt
5068: oPop 2
5070: oAssign
5071: oEmit 19
5073: oGetLocal 9
5075: oPushResult
5076: oEmitInt
5077: oPop 1
5079: oGetLocal 8
5081: oPushResult
5082: oSetResult 8
5084: oPushResult
5085: oNodeGet
5086: oPop 2
5088: oPushResult
5089: oTypeSPush
5090: oPop 1
5092: oGetLocal 8
5094: oPushResult
5095: oSetResult 21
5097: oPushResult
5098: oNodeGetBoolean
5099: oPop 2
5101: oChoice 5169
5103: oCall 5708
5105: oCall 6425
5107: oEmit 27
5109: oJumpForward 5175
5111: oCall 2405
5113: oCall 4759
5115: oTypeSNodeType
5116: oChoice 5134
5118: oEmit 25
5120: oJumpForward 5167
5122: oEmit 26
5124: oJumpForward 5167
5126: oError 16
5128: oJumpForward 5167
5130: oEmit 27
5132: oJumpForward 5167
5134: Choice Lookup Table
          23   5130
          17   5126
          22   5126
          21   5126
          19   5122
          18   5118
5147: oGetAddrLocal 10
5149: oPushResult
5150: oTypeSTop
5151: oPushResult
5152: oSetResult 3
5154: oPushResult
5155: oNodeGetInt
5156: oPop 2
5158: oAssign
5159: oEmit 28
5161: oGetLocal 10
5163: oPushResult
5164: oEmitInt
5165: oPop 1
5167: oJumpForward 5175
5169: Choice Lookup Table
           0   5111
           1   5103
5174: oEndChoice
5175: oTypeSPop
5176: oGetAddrLocal 7
5178: oPushResult
5179: oNodeIterNext
5180: oPop 1
5182: oGetAddrLocal 8
5184: oPushResult
5185: oGetLocal 7
5187: oPushResult
5188: oNodeIterValue
5189: oPop 1
5191: oAssign
5192: oGetLocal 8
5194: oPushResult
5195: oNodeNull
5196: oPop 1
5198: oChoice 5206
5200: oJumpForward 5216
5202: oJumpForward 5212
5204: oJumpForward 5212
5206: Choice Lookup Table
           0   5204
           1   5200
5211: oEndChoice
5212: oInput 12
5214: oJumpBack 5043
5216: oInput 14
5218: oJumpForward 5223
5220: Choice Lookup Table
          13   5043
5223: oGetLocal 8
5225: oPushResult
5226: oNodeNull
5227: oPop 1
5229: oChoice 5235
5231: oError 15
5233: oJumpForward 5238
5235: Choice Lookup Table
           0   5231
5238: oGetLocal 4
5240: oChoice 5269
5242: oEmit 19
5244: oGetParam 1
5246: oPushResult
5247: oSetResult 20
5249: oPushResult
5250: oNodeGetInt
5251: oPop 2
5253: oPushResult
5254: oEmitInt
5255: oPop 1
5257: oEmit 17
5259: oGetLocal 3
5261: oPushResult
5262: oEmitInt
5263: oPop 1
5265: oEmit 27
5267: oJumpForward 5272
5269: Choice Lookup Table
           1   5242
5272: oGetLocal 1
5274: oChoice 5298
5276: oEmit 50
5278: oGetParam 1
5280: oPushResult
5281: oCall 6702
5283: oPop 1
5285: oJumpForward 5304
5287: oEmit 49
5289: oGetParam 1
5291: oPushResult
5292: oCall 6702
5294: oPop 1
5296: oJumpForward 5304
5298: Choice Lookup Table
           0   5287
           1   5276
5303: oEndChoice
5304: oGetLocal 4
5306: oChoice 5374
5308: oGetLocal 2
5310: oPushResult
5311: oTypeSPush
5312: oPop 1
5314: oTypeSNodeType
5315: oChoice 5351
5317: oEmit 3
5319: oGetLocal 3
5321: oPushResult
5322: oEmitInt
5323: oPop 1
5325: oJumpForward 5372
5327: oEmit 4
5329: oGetLocal 3
5331: oPushResult
5332: oEmitInt
5333: oPop 1
5335: oJumpForward 5372
5337: oError 16
5339: oJumpForward 5372
5341: oEmit 5
5343: oGetLocal 3
5345: oPushResult
5346: oEmitInt
5347: oPop 1
5349: oJumpForward 5372
5351: Choice Lookup Table
          23   5341
          17   5337
          22   5337
          21   5337
          19   5327
          18   5317
5364: oEmit 17
5366: oGetLocal 3
5368: oPushResult
5369: oEmitInt
5370: oPop 1
5372: oJumpForward 5377
5374: Choice Lookup Table
           1   5308
5377: oEmit 48
5379: oGetLocal 6
5381: oPushResult
5382: oEmitInt
5383: oPop 1
5385: oReturn
5386: oLocalSpace 0
5388: oInputChoice 5438
5390: oCall 6345
5392: oJumpForward 5463
5394: oCall 6352
5396: oJumpForward 5463
5398: oCall 6419
5400: oJumpForward 5463
5402: oCall 6422
5404: oJumpForward 5463
5406: oCall 5885
5408: oJumpForward 5463
5410: oCall 6205
5412: oJumpForward 5463
5414: oCall 5951
5416: oJumpForward 5463
5418: oCall 6125
5420: oJumpForward 5463
5422: oCall 6290
5424: oJumpForward 5463
5426: oCall 6258
5428: oJumpForward 5463
5430: oCall 6322
5432: oJumpForward 5463
5434: oCall 5464
5436: oJumpForward 5463
5438: Choice Lookup Table
           0   5434
          33   5430
          49   5426
          50   5422
          47   5418
          42   5414
          46   5410
          39   5406
          57   5402
          56   5398
          55   5394
          54   5390
5463: oReturn
5464: oLocalSpace 1
5466: oGetAddrLocal 1
5468: oPushResult
5469: oScopeFindRequire
5470: oAssign
5471: oGetLocal 1
5473: oPushResult
5474: oNodeType
5475: oPop 1
5477: oChoice 5506
5479: oGetLocal 1
5481: oPushResult
5482: oCall 4847
5484: oPop 1
5486: oJumpForward 5519
5488: oGetLocal 1
5490: oPushResult
5491: oCall 5520
5493: oPop 1
5495: oJumpForward 5519
5497: oGetLocal 1
5499: oPushResult
5500: oCall 5594
5502: oPop 1
5504: oJumpForward 5519
5506: Choice Lookup Table
           8   5497
          15   5488
          13   5488
          12   5488
           7   5479
5517: oError 0
5519: oReturn
5520: oLocalSpace 0
5522: oGetParam 1
5524: oPushResult
5525: oCall 5744
5527: oPop 1
5529: oInput 3
5531: oCall 2405
5533: oCall 6425
5535: oCall 5538
5537: oReturn
5538: oLocalSpace 1
5540: oTypeSNodeType
5541: oChoice 5559
5543: oEmit 25
5545: oJumpForward 5592
5547: oEmit 26
5549: oJumpForward 5592
5551: oError 16
5553: oJumpForward 5592
5555: oEmit 27
5557: oJumpForward 5592
5559: Choice Lookup Table
          23   5555
          17   5551
          22   5551
          21   5551
          19   5547
          18   5543
5572: oGetAddrLocal 1
5574: oPushResult
5575: oTypeSTop
5576: oPushResult
5577: oSetResult 3
5579: oPushResult
5580: oNodeGetInt
5581: oPop 2
5583: oAssign
5584: oEmit 28
5586: oGetLocal 1
5588: oPushResult
5589: oEmitInt
5590: oPop 1
5592: oTypeSPop
5593: oReturn
5594: oLocalSpace 1
5596: oGetParam 1
5598: oPushResult
5599: oSetResult 12
5601: oPushResult
5602: oNodeGet
5603: oPop 2
5605: oPushResult
5606: oScopeCurrent
5607: oPushResult
5608: oNodeEqual
5609: oPop 2
5611: oChoice 5617
5613: oError 20
5615: oJumpForward 5620
5617: Choice Lookup Table
           0   5613
5620: oEmit 8
5622: oGetParam 1
5624: oPushResult
5625: oSetResult 20
5627: oPushResult
5628: oNodeGetInt
5629: oPop 2
5631: oPushResult
5632: oEmitInt
5633: oPop 1
5635: oGetParam 1
5637: oPushResult
5638: oSetResult 8
5640: oPushResult
5641: oNodeGet
5642: oPop 2
5644: oPushResult
5645: oTypeSPush
5646: oPop 1
5648: oInput 3
5650: oCall 2405
5652: oCall 6425
5654: oTypeSNodeType
5655: oChoice 5673
5657: oEmit 25
5659: oJumpForward 5706
5661: oEmit 26
5663: oJumpForward 5706
5665: oError 16
5667: oJumpForward 5706
5669: oEmit 27
5671: oJumpForward 5706
5673: Choice Lookup Table
          23   5669
          17   5665
          22   5665
          21   5665
          19   5661
          18   5657
5686: oGetAddrLocal 1
5688: oPushResult
5689: oTypeSTop
5690: oPushResult
5691: oSetResult 3
5693: oPushResult
5694: oNodeGetInt
5695: oPop 2
5697: oAssign
5698: oEmit 28
5700: oGetLocal 1
5702: oPushResult
5703: oEmitInt
5704: oPop 1
5706: oTypeSPop
5707: oReturn
5708: oLocalSpace 1
5710: oInput 0
5712: oGetAddrLocal 1
5714: oPushResult
5715: oScopeFindRequire
5716: oAssign
5717: oGetLocal 1
5719: oPushResult
5720: oNodeType
5721: oPop 1
5723: oChoice 5727
5725: oJumpForward 5736
5727: Choice Lookup Table
          15   5725
          13   5725
          12   5725
5734: oError 4
5736: oGetLocal 1
5738: oPushResult
5739: oCall 5744
5741: oPop 1
5743: oReturn
5744: oLocalSpace 0
5746: oGetParam 1
5748: oPushResult
5749: oNodeType
5750: oPop 1
5752: oChoice 5812
5754: oEmit 16
5756: oGetParam 1
5758: oPushResult
5759: oCall 6702
5761: oPop 1
5763: oJumpForward 5821
5765: oEmit 17
5767: oGetParam 1
5769: oPushResult
5770: oCall 6702
5772: oPop 1
5774: oJumpForward 5821
5776: oGetParam 1
5778: oPushResult
5779: oSetResult 21
5781: oPushResult
5782: oNodeGetBoolean
5783: oPop 2
5785: oChoice 5798
5787: oEmit 8
5789: oGetParam 1
5791: oPushResult
5792: oCall 6702
5794: oPop 1
5796: oJumpForward 5810
5798: Choice Lookup Table
           1   5787
5801: oEmit 18
5803: oGetParam 1
5805: oPushResult
5806: oCall 6702
5808: oPop 1
5810: oJumpForward 5821
5812: Choice Lookup Table
          15   5776
          13   5765
          12   5754
5819: oError 4
5821: oGetParam 1
5823: oPushResult
5824: oSetResult 8
5826: oPushResult
5827: oNodeGet
5828: oPop 2
5830: oPushResult
5831: oTypeSPush
5832: oPop 1
5834: oCall 4456
5836: oReturn
5837: oLocalSpace 0
5839: oGetParam 1
5841: oPushResult
5842: oCall 5744
5844: oPop 1
5846: oCall 6451
5848: oGetParam 1
5850: oPushResult
5851: oCall 3667
5853: oPop 1
5855: oTypeSPop
5856: oEmit 29
5858: oEmit 25
5860: oReturn
5861: oLocalSpace 0
5863: oGetParam 1
5865: oPushResult
5866: oCall 5744
5868: oPop 1
5870: oCall 6451
5872: oGetParam 1
5874: oPushResult
5875: oCall 3667
5877: oPop 1
5879: oTypeSPop
5880: oEmit 30
5882: oEmit 25
5884: oReturn
5885: oLocalSpace 2
5887: oGetAddrLocal 1
5889: oPushResult
5890: oSetResult 0
5892: oAssign
5893: oGetAddrLocal 1
5895: oPushResult
5896: oCall 2428
5898: oPop 1
5900: oInput 40
5902: oCall 5386
5904: oInputChoice 5939
5906: oGetAddrLocal 2
5908: oPushResult
5909: oLabelNew
5910: oAssign
5911: oEmit 53
5913: oGetLocal 2
5915: oPushResult
5916: oEmitLabel
5917: oPop 1
5919: oEmit 56
5921: oGetLocal 1
5923: oPushResult
5924: oEmitLabel
5925: oPop 1
5927: oCall 5386
5929: oEmit 56
5931: oGetLocal 2
5933: oPushResult
5934: oEmitLabel
5935: oPop 1
5937: oJumpForward 5950
5939: Choice Lookup Table
          41   5906
5942: oEmit 56
5944: oGetLocal 1
5946: oPushResult
5947: oEmitLabel
5948: oPop 1
5950: oReturn
5951: oLocalSpace 4
5953: oInput 0
5955: oGetAddrLocal 1
5957: oPushResult
5958: oScopeFindRequire
5959: oAssign
5960: oGetLocal 1
5962: oPushResult
5963: oCall 5744
5965: oPop 1
5967: oCall 6451
5969: oInput 3
5971: oCall 2405
5973: oCall 6451
5975: oEmit 25
5977: oGetAddrLocal 2
5979: oPushResult
5980: oLabelNew
5981: oAssign
5982: oGetAddrLocal 3
5984: oPushResult
5985: oLabelNew
5986: oAssign
5987: oEmit 53
5989: oGetLocal 3
5991: oPushResult
5992: oEmitLabel
5993: oPop 1
5995: oGetAddrLocal 4
5997: oPushResult
5998: oLabelNew
5999: oAssign
6000: oEmit 56
6002: oGetLocal 4
6004: oPushResult
6005: oEmitLabel
6006: oPop 1
6008: oInputChoice 6088
6010: oGetLocal 1
6012: oPushResult
6013: oCall 5837
6015: oPop 1
6017: oEmit 56
6019: oGetLocal 3
6021: oPushResult
6022: oEmitLabel
6023: oPop 1
6025: oGetLocal 1
6027: oPushResult
6028: oCall 3667
6030: oPop 1
6032: oTypeSPop
6033: oCall 2405
6035: oCall 6451
6037: oEmit 40
6039: oEmit 54
6041: oGetLocal 2
6043: oPushResult
6044: oEmitLabel
6045: oPop 1
6047: oJumpForward 6094
6049: oGetLocal 1
6051: oPushResult
6052: oCall 5861
6054: oPop 1
6056: oEmit 56
6058: oGetLocal 3
6060: oPushResult
6061: oEmitLabel
6062: oPop 1
6064: oGetLocal 1
6066: oPushResult
6067: oCall 3667
6069: oPop 1
6071: oTypeSPop
6072: oCall 2405
6074: oCall 6451
6076: oEmit 41
6078: oEmit 54
6080: oGetLocal 2
6082: oPushResult
6083: oEmitLabel
6084: oPop 1
6086: oJumpForward 6094
6088: Choice Lookup Table
          44   6049
          43   6010
6093: oEndChoice
6094: oGetLocal 4
6096: oPushResult
6097: oGetLocal 2
6099: oPushResult
6100: oLoopPush
6101: oPop 2
6103: oInput 45
6105: oCall 5386
6107: oEmit 53
6109: oGetLocal 4
6111: oPushResult
6112: oEmitLabel
6113: oPop 1
6115: oEmit 56
6117: oGetLocal 2
6119: oPushResult
6120: oEmitLabel
6121: oPop 1
6123: oLoopPop
6124: oReturn
6125: oLocalSpace 3
6127: oGetAddrLocal 1
6129: oPushResult
6130: oLabelNew
6131: oAssign
6132: oEmit 56
6134: oGetLocal 1
6136: oPushResult
6137: oEmitLabel
6138: oPop 1
6140: oGetAddrLocal 2
6142: oPushResult
6143: oLabelNew
6144: oAssign
6145: oGetLocal 1
6147: oPushResult
6148: oGetLocal 2
6150: oPushResult
6151: oLoopPush
6152: oPop 2
6154: oCall 5386
6156: oInputChoice 6187
6158: oCall 5386
6160: oJumpForward 6193
6162: oGetAddrLocal 3
6164: oPushResult
6165: oCall 2428
6167: oPop 1
6169: oEmit 57
6171: oGetLocal 3
6173: oPushResult
6174: oEmitLabel
6175: oPop 1
6177: oGetLocal 1
6179: oPushResult
6180: oEmitLabel
6181: oPop 1
6183: oJumpForward 6195
6185: oJumpForward 6193
6187: Choice Lookup Table
          48   6162
           4   6158
6192: oEndChoice
6193: oJumpBack 6156
6195: oEmit 56
6197: oGetLocal 2
6199: oPushResult
6200: oEmitLabel
6201: oPop 1
6203: oLoopPop
6204: oReturn
6205: oLocalSpace 2
6207: oGetAddrLocal 1
6209: oPushResult
6210: oLabelNew
6211: oAssign
6212: oEmit 56
6214: oGetLocal 1
6216: oPushResult
6217: oEmitLabel
6218: oPop 1
6220: oGetAddrLocal 2
6222: oPushResult
6223: oCall 2428
6225: oPop 1
6227: oGetLocal 1
6229: oPushResult
6230: oGetLocal 2
6232: oPushResult
6233: oLoopPush
6234: oPop 2
6236: oInput 45
6238: oCall 5386
6240: oEmit 53
6242: oGetLocal 1
6244: oPushResult
6245: oEmitLabel
6246: oPop 1
6248: oEmit 56
6250: oGetLocal 2
6252: oPushResult
6253: oEmitLabel
6254: oPop 1
6256: oLoopPop
6257: oReturn
6258: oLocalSpace 0
6260: oLoopContinueLabel
6261: oPushResult
6262: oSetResult 0
6264: oPushResult
6265: equal_label
6266: oPop 2
6268: oChoice 6283
6270: oError 18
6272: oJumpForward 6289
6274: oEmit 53
6276: oLoopContinueLabel
6277: oPushResult
6278: oEmitLabel
6279: oPop 1
6281: oJumpForward 6289
6283: Choice Lookup Table
           0   6274
           1   6270
6288: oEndChoice
6289: oReturn
6290: oLocalSpace 0
6292: oLoopBreakLabel
6293: oPushResult
6294: oSetResult 0
6296: oPushResult
6297: equal_label
6298: oPop 2
6300: oChoice 6315
6302: oError 18
6304: oJumpForward 6321
6306: oEmit 53
6308: oLoopBreakLabel
6309: oPushResult
6310: oEmitLabel
6311: oPop 1
6313: oJumpForward 6321
6315: Choice Lookup Table
           0   6306
           1   6302
6320: oEndChoice
6321: oReturn
6322: oLocalSpace 0
6324: oCall 5386
6326: oInputChoice 6336
6328: oCall 5386
6330: oJumpForward 6342
6332: oJumpForward 6344
6334: oJumpForward 6342
6336: Choice Lookup Table
          34   6332
           4   6328
6341: oEndChoice
6342: oJumpBack 6326
6344: oReturn
6345: oLocalSpace 0
6347: oCall 6352
6349: oEmit 63
6351: oReturn
6352: oLocalSpace 0
6354: oInputChoice 6415
6356: oCall 2405
6358: oTypeSNodeType
6359: oChoice 6381
6361: oEmit 59
6363: oJumpForward 6396
6365: oEmit 60
6367: oJumpForward 6396
6369: oEmit 61
6371: oJumpForward 6396
6373: oError 16
6375: oJumpForward 6396
6377: oEmit 62
6379: oJumpForward 6396
6381: Choice Lookup Table
          23   6377
          17   6373
          21   6373
          22   6369
          19   6365
          18   6361
6394: oError 17
6396: oTypeSPop
6397: oInputChoice 6405
6399: oJumpForward 6413
6401: oJumpForward 6411
6403: oJumpForward 6411
6405: Choice Lookup Table
          12   6403
          14   6399
6410: oEndChoice
6411: oJumpBack 6356
6413: oJumpForward 6418
6415: Choice Lookup Table
          13   6356
6418: oReturn
6419: oLocalSpace 0
6421: oReturn
6422: oLocalSpace 0
6424: oReturn
6425: oLocalSpace 1
6427: oGetAddrLocal 1
6429: oPushResult
6430: oTypeSNodeType
6431: oAssign
6432: oTypeSPop
6433: oGetLocal 1
6435: oPushResult
6436: oTypeSNodeType
6437: oPushResult
6438: equal_node_type
6439: oPop 2
6441: oChoice 6447
6443: oError 14
6445: oJumpForward 6450
6447: Choice Lookup Table
           0   6443
6450: oReturn
6451: oLocalSpace 0
6453: oTypeSNodeType
6454: oChoice 6458
6456: oJumpForward 6463
6458: Choice Lookup Table
          18   6456
6461: oError 7
6463: oTypeSPop
6464: oReturn
6465: oLocalSpace 0
6467: oTypeSNodeType
6468: oChoice 6472
6470: oJumpForward 6477
6472: Choice Lookup Table
          18   6470
6475: oError 7
6477: oReturn
6478: oLocalSpace 0
6480: oTypeSNodeType
6481: oChoice 6485
6483: oJumpForward 6490
6485: Choice Lookup Table
          19   6483
6488: oError 8
6490: oTypeSPop
6491: oReturn
6492: oLocalSpace 0
6494: oTypeSNodeType
6495: oChoice 6499
6497: oJumpForward 6504
6499: Choice Lookup Table
          19   6497
6502: oError 8
6504: oReturn
6505: oLocalSpace 1
6507: oGetAddrLocal 1
6509: oPushResult
6510: oGetParam 2
6512: oPushResult
6513: oNodeNew
6514: oPop 1
6516: oAssign
6517: oGetLocal 1
6519: oPushResult
6520: oSetResult 3
6522: oPushResult
6523: oGetParam 1
6525: oPushResult
6526: oNodeSetInt
6527: oPop 3
6529: oGetLocal 1
6531: oPushResult
6532: oTypeAdd
6533: oPop 1
6535: oGetLocal 1
6537: oReturn
6538: oReturn
6539: oLocalSpace 1
6541: oGetAddrLocal 1
6543: oPushResult
6544: oGetParam 3
6546: oPushResult
6547: oNodeNew
6548: oPop 1
6550: oAssign
6551: oGetLocal 1
6553: oPushResult
6554: oSetResult 7
6556: oPushResult
6557: oGetParam 1
6559: oPushResult
6560: oNodeSetInt
6561: oPop 3
6563: oGetLocal 1
6565: oReturn
6566: oReturn
6567: oLocalSpace 1
6569: oGetAddrLocal 1
6571: oPushResult
6572: oGetParam 1
6574: oPushResult
6575: oSetResult 22
6577: oPushResult
6578: oNodeGet
6579: oPop 2
6581: oAssign
6582: oGetLocal 1
6584: oPushResult
6585: oNodeNull
6586: oPop 1
6588: oChoice 6644
6590: oGetAddrLocal 1
6592: oPushResult
6593: oSetResult 23
6595: oPushResult
6596: oNodeNew
6597: oPop 1
6599: oAssign
6600: oGetLocal 1
6602: oPushResult
6603: oSetResult 23
6605: oPushResult
6606: oGetParam 1
6608: oPushResult
6609: oNodeSet
6610: oPop 3
6612: oGetLocal 1
6614: oPushResult
6615: oSetResult 3
6617: oPushResult
6618: oSetResult 8
6620: oPushResult
6621: oNodeSetInt
6622: oPop 3
6624: oGetLocal 1
6626: oPushResult
6627: oTypeAdd
6628: oPop 1
6630: oGetParam 1
6632: oPushResult
6633: oSetResult 22
6635: oPushResult
6636: oGetLocal 1
6638: oPushResult
6639: oNodeSet
6640: oPop 3
6642: oJumpForward 6647
6644: Choice Lookup Table
           1   6590
6647: oGetLocal 1
6649: oReturn
6650: oReturn
6651: oLocalSpace 0
6653: oGetParam 1
6655: oPushResult
6656: oNodeType
6657: oPop 1
6659: oChoice 6687
6661: oMININT
6662: oReturn
6663: oJumpForward 6701
6665: oSetResult 0
6667: oReturn
6668: oJumpForward 6701
6670: oSetResult 0
6672: oReturn
6673: oJumpForward 6701
6675: oGetParam 1
6677: oPushResult
6678: oSetResult 25
6680: oPushResult
6681: oNodeGetInt
6682: oPop 2
6684: oReturn
6685: oJumpForward 6701
6687: Choice Lookup Table
          25   6675
          21   6670
          19   6665
          18   6661
6696: oError 3
6698: oSetResult 0
6700: oReturn
6701: oReturn
6702: oLocalSpace 0
6704: oGetParam 1
6706: oPushResult
6707: oSetResult 9
6709: oPushResult
6710: oNodeGetInt
6711: oPop 2
6713: oPushResult
6714: oEmitInt
6715: oPop 1
6717: oReturn
6718: oLocalSpace 1
6720: oGetAddrGlobal 3
6722: oPushResult
6723: oSetResult 17
6725: oPushResult
6726: oSetResult 4
6728: oPushResult
6729: oCall 6505
6731: oPop 2
6733: oAssign
6734: oGetAddrGlobal 4
6736: oPushResult
6737: oSetResult 18
6739: oPushResult
6740: oSetResult 4
6742: oPushResult
6743: oCall 6505
6745: oPop 2
6747: oAssign
6748: oGetAddrGlobal 5
6750: oPushResult
6751: oSetResult 19
6753: oPushResult
6754: oSetResult 1
6756: oPushResult
6757: oCall 6505
6759: oPop 2
6761: oAssign
6762: oGetAddrGlobal 6
6764: oPushResult
6765: oSetResult 20
6767: oPushResult
6768: oSetResult 1
6770: oPushResult
6771: oCall 6505
6773: oPop 2
6775: oAssign
6776: oGetAddrGlobal 7
6778: oPushResult
6779: oSetResult 21
6781: oPushResult
6782: oSetResult 1
6784: oPushResult
6785: oCall 6505
6787: oPop 2
6789: oAssign
6790: oGetAddrGlobal 8
6792: oPushResult
6793: oSetResult 22
6795: oPushResult
6796: oSetResult 256
6798: oPushResult
6799: oCall 6505
6801: oPop 2
6803: oAssign
6804: oGetAddrLocal 1
6806: oPushResult
6807: oSetResult 10
6809: oPushResult
6810: oSetResult 5
6812: oPushResult
6813: oIdAdd_File
6814: oPushResult
6815: oCall 6539
6817: oPop 3
6819: oAssign
6820: oGetLocal 1
6822: oPushResult
6823: oSetResult 8
6825: oPushResult
6826: oGetGlobal 3
6828: oPushResult
6829: oNodeSet
6830: oPop 3
6832: oGetLocal 1
6834: oPushResult
6835: oScopeDeclare
6836: oPop 1
6838: oGetAddrLocal 1
6840: oPushResult
6841: oSetResult 10
6843: oPushResult
6844: oSetResult 5
6846: oPushResult
6847: oIdAdd_Integer
6848: oPushResult
6849: oCall 6539
6851: oPop 3
6853: oAssign
6854: oGetLocal 1
6856: oPushResult
6857: oSetResult 8
6859: oPushResult
6860: oGetGlobal 4
6862: oPushResult
6863: oNodeSet
6864: oPop 3
6866: oGetLocal 1
6868: oPushResult
6869: oScopeDeclare
6870: oPop 1
6872: oGetAddrLocal 1
6874: oPushResult
6875: oSetResult 10
6877: oPushResult
6878: oSetResult 5
6880: oPushResult
6881: oIdAdd_Boolean
6882: oPushResult
6883: oCall 6539
6885: oPop 3
6887: oAssign
6888: oGetLocal 1
6890: oPushResult
6891: oSetResult 8
6893: oPushResult
6894: oGetGlobal 5
6896: oPushResult
6897: oNodeSet
6898: oPop 3
6900: oGetLocal 1
6902: oPushResult
6903: oScopeDeclare
6904: oPop 1
6906: oGetAddrLocal 1
6908: oPushResult
6909: oSetResult 10
6911: oPushResult
6912: oSetResult 5
6914: oPushResult
6915: oIdAdd_Char
6916: oPushResult
6917: oCall 6539
6919: oPop 3
6921: oAssign
6922: oGetLocal 1
6924: oPushResult
6925: oSetResult 8
6927: oPushResult
6928: oGetGlobal 7
6930: oPushResult
6931: oNodeSet
6932: oPop 3
6934: oGetLocal 1
6936: oPushResult
6937: oScopeDeclare
6938: oPop 1
6940: oGetAddrLocal 1
6942: oPushResult
6943: oSetResult 10
6945: oPushResult
6946: oSetResult 5
6948: oPushResult
6949: oIdAdd_String
6950: oPushResult
6951: oCall 6539
6953: oPop 3
6955: oAssign
6956: oGetLocal 1
6958: oPushResult
6959: oSetResult 8
6961: oPushResult
6962: oGetGlobal 8
6964: oPushResult
6965: oNodeSet
6966: oPop 3
6968: oGetLocal 1
6970: oPushResult
6971: oScopeDeclare
6972: oPop 1
6974: oGetAddrLocal 1
6976: oPushResult
6977: oSetResult 9
6979: oPushResult
6980: oSetResult 4
6982: oPushResult
6983: oIdAdd_True
6984: oPushResult
6985: oCall 6539
6987: oPop 3
6989: oAssign
6990: oGetLocal 1
6992: oPushResult
6993: oSetResult 8
6995: oPushResult
6996: oGetGlobal 5
6998: oPushResult
6999: oNodeSet
7000: oPop 3
7002: oGetLocal 1
7004: oPushResult
7005: oSetResult 9
7007: oPushResult
7008: oSetResult 1
7010: oPushResult
7011: oNodeSetInt
7012: oPop 3
7014: oGetLocal 1
7016: oPushResult
7017: oScopeDeclare
7018: oPop 1
7020: oGetAddrLocal 1
7022: oPushResult
7023: oSetResult 9
7025: oPushResult
7026: oSetResult 4
7028: oPushResult
7029: oIdAdd_False
7030: oPushResult
7031: oCall 6539
7033: oPop 3
7035: oAssign
7036: oGetLocal 1
7038: oPushResult
7039: oSetResult 8
7041: oPushResult
7042: oGetGlobal 5
7044: oPushResult
7045: oNodeSet
7046: oPop 3
7048: oGetLocal 1
7050: oPushResult
7051: oSetResult 9
7053: oPushResult
7054: oSetResult 0
7056: oPushResult
7057: oNodeSetInt
7058: oPop 3
7060: oGetLocal 1
7062: oPushResult
7063: oScopeDeclare
7064: oPop 1
7066: oReturn
