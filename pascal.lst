   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, kVar, LAST_ID )
 121:          oNodeSet( t, qType, FileType )
 133:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 139:          ','
 141:          pIdent
      
 143:          t = @newIdent( nVar, kVar, LAST_ID )
 159:          oNodeSet( t, qType, FileType )
 171:          oScopeDeclareAlloc( t )
      
 177:          ')'
 179:       | * :
 184:    ]
 184:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 186:    [
 186:       | pUses :  @UsesClause( program )
 195:       | * :
 200:    ]
 200:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 207:    oScopeBegin( 0, allocGlobal )
 216:    Node globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 221:    oScopeBegin( 0, allocDown )
 230:    initScope = oScopeCurrent
 235:    oNodeSet( program, qMainRoutineScope, initScope )
 247:    oScopeEnd
      
 248:    @BlockDecls( nGlobalVar )
      
      
 255:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 261:    boolean isMain = true
 267:    @BlockStmt( mainLabel, globalScope, isMain )
      
 280:    oScopeEnd   % main routine scope
      
 281:    '.'
 283:    oScopeEnd   % global scope
 284:    @EndUsedUnits( program )   % used units scopes
 292:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 292: UsesClause( Node user ):
 294:    {
 294:       pIdent
 296:       Node unit = @FindOrCompileUnit( LAST_ID )
 306:       [ equal_node( unit, Null )
 316:          | false :
 317:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 329:             Node unitRef = oNodeNew( nUnitRef )
 339:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 358:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 377:             oScopeDeclare( unitRef )
 383:          | * :
 388:       ]
 388:       [
 388:          | ',' :
 390:          | * :  >
 397:       ]
 397:    }   
 399:    ';'
 402:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 402: ResolveUnitRef( inout Node decl ):
 404:    [ oNodeType( decl )
 411:       | nUnitRef :
 412:          Node scope = oNodeGet( decl, qPublicScope )
 425:          '.'
 427:          pIdent
 429:          decl = oScopeFindRequireInScope( scope )
 439:       | * :
 444:    ];
      
      
 445: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 447:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 460:    {
 460:       Node unit = oNodeIterValue( unitIt )
 470:       [ oNodeNull( unit )
 477:          | false :
 478:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 491:          | * :
 496:             >
 498:       ]
 498:       oNodeIterNext( unitIt )
 504:    }
 507:    ;
      
 507: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 509:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 522:    {
 522:       Node unit = oNodeIterValue( unitIt )
 532:       [ oNodeNull( unit )
 539:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 540:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 556:                | true :
 557:                | false :  #eInternalScopeMismatch
 561:             ]
 569:             oScopeEnd
 570:          | * :
 575:             >
 577:       ]
 577:       oNodeIterPrev( unitIt )
 583:    }
 586:    ;
      
      
 586: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 588:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 607:    [ equal_node( unit, Null )
 617:       | false :  >> unit
 621:       | * :
 626:    ]
      
         % If not, search for the source file on disk
 626:    boolean ok = oIncludeUnitFile( id )
 636:    [ ok
 639:       | false :  #eCantFindUnitFile  >> Null
 645:       | * :
 650:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 650:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 656:    oIncludeEnd
 657:    >> unit;
      
      
      
 661: Unit >> Node:
 663:    pUnit
 665:    pIdent
 667:    Node unit = oNodeNew( nUnit )
 677:    oNodeSetInt( unit, qIdent, LAST_ID )
 688:    Node unitImpl = oNodeNew( nUnitImpl )
 698:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 709:    oNodeSet( unit, qImpl, unitImpl )
 721:    ';'
      
         % mandatory sections
      
 723:    pInterface
 725:    [
 725:       | pUses :   @UsesClause( unit )
 734:       | * :
 739:    ]
 739:    @EnterUsedUnits( unit )
      
 746:    oScopeBegin( 0, allocGlobal )
 755:    oNodeSet( unit, qPublicScope, oScopeCurrent )
      
         % A scope for temporaries needed by variable initialization
 766:    oScopeBegin( 0, allocDown )
 775:    initScope = oScopeCurrent
 780:    oNodeSet( unit, qInitRoutineScope, initScope )
 792:    oScopeEnd
      
 793:    @UnitInterface( unit )
 800:    oScopeEnd  % interface scope
      
 801:    pImplementation
 803:    [
 803:       | pUses :   @UsesClause( unitImpl )
 812:       | * :
 817:    ]
 817:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 824:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
      
 837:    oScopeBegin( 0, allocGlobal )
 846:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 857:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 875:    @UnitImplementation( unit )
      
 882:    [
 882:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 894:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 909:    ]
 909:    [
 909:       | pFinalization :  @UnitFinalization( unit, true )
 921:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 936:    ]
 936:    pEnd  '.'
      
 940:    oScopeEnd  % impl scope
 941:    oScopeEnd  % interface scope
 942:    @EndUsedUnits( unitImpl )  % used units scopes
 949:    @EndUsedUnits( unit )
 956:    oNodeAddLast( workspace, qUnits, unit )
 968:    >> unit;
      
      
 972: UnitInterface( Node unit ):
 974:    {[
 974:       | pConst :     @ConstDecl
 978:       | pType :      @TypeDecl
 982:       | pVar :       @VarDecl( nGlobalVar )
      
 991:       | pProcedure :
 993:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 999:          [
 999:             | pExternal :
1001:                @ExternalDecl( decl )
1008:                ';'
1010:             | * :
1015:          ]
      
1015:       | pFunction :
1017:          Node decl = @FuncHeaderDecl
1023:          [
1023:             | pExternal :
1025:                @ExternalDecl( decl )
1032:                ';'
1034:             | * :
1039:          ]
      
1039:       | * :          >
1054:    ]}
1057:    ;
      
1057: UnitImplementation( Node unit ):
1059:    @BlockDecls( nGlobalVar )
1067:    ;
      
      
1067: UnitInitialization( Node unit, boolean hasStmts ):
1069:    Label label = oLabelNew
1074:    .tLabel  oEmitLabel( label )
1082:    oNodeSetLabel( unit, qInitLabel, label )
      
1094:    int patchLS
1094:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1103:    Node scope
1103:    Code initCode
      
1103:    scope = oNodeGet( unit, qPublicScope )
1116:    initCode = oNodeGetCode( scope, qInitCode )
1129:    oEmitCode( initCode )
1135:    oNodeSetCode( scope, qInitCode, codeNull )
      
1147:    scope = oNodeGet( unit, qPrivateScope )
1160:    initCode = oNodeGetCode( scope, qInitCode )
1173:    oEmitCode( initCode )
1179:    oNodeSetCode( scope, qInitCode, codeNull )
      
1191:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1204:    [ hasStmts
1207:       | true :     
1208:          @Statement
1210:          {[
1210:             | ';' :  @Statement
1214:             | * :    >
1221:          ]}
1223:       | * :
1228:    ]
      
1228:    .tReturn
      
1230:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1242:    oPatch( patchLS, localSpace )
1251:    oScopeEnd   % init routine scope, for temporaries
1253:    ;
      
      
1253: UnitFinalization( Node unit, boolean hasStmts ):
1255:    Label label = oLabelNew
1260:    .tLabel  oEmitLabel( label )
1268:    oNodeSetLabel( unit, qFinalLabel, label )
      
1280:    int patchLS
1280:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1289:    oScopeBegin( 0, allocDown )
      
1298:    [ hasStmts
1301:       | true :     
1302:          @Statement
1304:          {[
1304:             | ';' :  @Statement
1308:             | * :    >
1315:          ]}
1317:       | * :
1322:    ]
      
1322:    .tReturn
      
1324:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1336:    oPatch( patchLS, localSpace )
1345:    oScopeEnd   % final routine scope, for temporaries
1347:    ;
      
      
1347: Block( node_type varNodeType, Label labelForBody ):
1349:    @BlockDecls( varNodeType )
1356:    @BlockStmt( labelForBody, oScopeCurrent, false )
1369:    ;
      
      
1369: BlockDecls( node_type varNodeType ):
1371:    {[
1371:       | pConst :     @ConstDecl
1375:       | pType :      @TypeDecl
1379:       | pVar :       @VarDecl( varNodeType )
1388:       | pProcedure : @ProcDecl
1392:       | pFunction :  @FuncDecl
1396:       | * :          >
1411:    ]}
1413:    @CheckForUndefinedMethods
1416:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1416: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1419:    ;
      
      
1419: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1421:    NodeIter it = oNodeGetIter( workspace, qUnits )
1434:    {
1434:       Node unit = oNodeIterValue( it )
1444:       [ oNodeNull( unit )
1451:          | true :  >
1454:          | false :
1456:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1464:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1479:             .tFreeActuals  oEmitInt( 0 )
1487:             oNodeIterNext( it )
1493:       ]
1501:    };
      
      
1504: FinalizeUnits:
1506:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1519:    {
1519:       Node unit = oNodeIterValue( it )
1529:       [ oNodeNull( unit )
1536:          | true :  >
1539:          | false :
1541:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1549:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1564:             .tFreeActuals  oEmitInt( 0 )
1572:             oNodeIterPrev( it )
1578:       ]
1586:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1589: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1591:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1599:    int patchLS
1599:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1608:    [ isMain
1611:       | true :  @InitializeUnits
1614:       | * :
1619:    ]
      
         % insert any code for initialization of this scope's variables
1619:    Code initCode = oNodeGetCode( varScope, qInitCode )
1632:    oEmitCode( initCode )
1638:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1650:    @Statement
      
1652:    [ isMain
1655:       | true :  @FinalizeUnits
1658:       | * :
1663:    ]
      
1663:    .tReturn
      
1665:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1677:    oPatch( patchLS, localSpace )
1687:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1687: MethodModifiers( Node decl ):
1689:    {[
1689:       | pCdecl :
1691:          oNodeSetBoolean( decl, qCdecl, true )
1703:          ';'
      
1705:       | * : >
1712:    ]}
1715:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1715: GetOrCreateInitCode >> Code:
1717:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
1729:    [ equal_code( initCode, codeNull )
1739:       | true :
1740:          initCode = oCodeNew
1745:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
1756:       | * :
1761:    ]
1761:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1765: ExternalDecl( Node decl ):
1767:    [ equal_zero( @DeclLevel( decl ) )
1779:       | false :  #eExternalMethodCannotBeNested
1782:       | * :
1787:    ]
1787:    oNodeSetBoolean( decl, qExternal, true )
1799:    [
1799:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1801:          [
1801:             | pName :
1803:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1805:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1816:             | * :
1821:          ]
1821:       | * :
1826:    ]
1827:    ;
      
      
1827: ProcHeaderDecl >> Node:
1829:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1831:    boolean redeclaring = false
1837:    Node decl = oScopeFindInCurrentScope
      
1842:    [ oNodeNull( decl )
1849:       | true :
               % first declaration
1850:          decl = @newIdent( nProc, kProc, LAST_ID )
1866:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1877:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1879:          redeclaring = true
1885:          [ oNodeGetBoolean( decl, qBodyDefined )
1895:             | true : #eAlreadyDefined
1898:             | * :
1903:          ]
1903:          [ oNodeGetBoolean( decl, qExternal )
1913:             | true : #eAlreadyDefined
1916:             | * :
1921:          ]
1921:          [ oNodeType( decl )
1928:             | nProc :
1929:             | * : #eAlreadyDefined   % wrong kind
1936:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1936:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1955:          oNodeSet( decl, qParams, Null )
1967:    ]
      
1975:    int level = @ScopeLevel
1981:    boolean nested = greater( level, 0 )
1994:    inc( level )
2000:    oScopeBegin( level, allocUp )
2009:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2014:    [ nested
2017:       | true :
2018:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2033:       | * :
2038:    ]
      
2038:    @FormalArgDecl
2040:    oNodeSet( decl, qParams, paramScope )
2052:    oScopeEnd
2053:    ';'
      
2055:    [ redeclaring
2058:       | false : oScopeDeclare( decl )
2065:       | true :  % TO DO: check that qParams is consistent with qOldParams
2067:    ]
      
2075:    @MethodModifiers( decl )
2082:    >> decl;
      
      
2086: ProcDecl:
2088:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2094:    [
2094:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2096:       | pExternal : @ExternalDecl( decl )
      
2105:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2112:          Node paramScope = oNodeGet( decl, qParams )
2125:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2131:          int level = oNodeGetInt( paramScope, qLevel )
2144:          oScopeBegin( level, allocDown )
2153:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2164:          Label label = oNodeGetLabel( decl, qValue )
2177:          @Block( nLocalVar, label )
2187:          oNodeSetBoolean( decl, qBodyDefined, true )
2199:          oScopeEnd
      
2200:          oScopeEnd  % paramScope
2201:    ]
2201:    ';';
      
      
      
2204: FuncHeaderDecl >> Node:
2206:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2208:    boolean redeclaring = false
2214:    Node decl = oScopeFindInCurrentScope
      
2219:    [ oNodeNull( decl )
2226:       | true :
               % first declaration
2227:          decl = @newIdent( nFunc, kFunc, LAST_ID )
2243:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2254:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2256:          redeclaring = true
2262:          [ oNodeGetBoolean( decl, qBodyDefined )
2272:             | true : #eAlreadyDefined
2275:             | * :
2280:          ]
2280:          [ oNodeType( decl )
2287:             | nFunc :
2288:             | * : #eAlreadyDefined   % wrong kind
2295:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2295:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2314:          oNodeSet( decl, qParams, Null )
2326:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2345:          oNodeSet( decl, qType, Null )
2357:    ]
      
2365:    int level = @ScopeLevel
2371:    boolean nested = greater( level, 0 )
2384:    inc( level )
2390:    oScopeBegin( level, allocUp )
2399:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2404:    [ nested
2407:       | true :
2408:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2423:       | * :
2428:    ]
      
2428:    @FormalArgDecl
2430:    oNodeSet( decl, qParams, paramScope )
      
2442:    ':'
      
2444:    Node theType
2444:    @TypeRef( theType )
2451:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2463:    Node ptrType = @PointerTypeTo( theType )
2474:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2490:    oScopeEnd
2491:    ';'
      
2493:    [ redeclaring
2496:       | false : oScopeDeclare( decl )
2503:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2505:    ]
      
2513:    @MethodModifiers( decl )
      
2520:    >> decl;
      
      
2524: FuncDecl:
2526:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2532:    [
2532:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2534:       | pExternal : @ExternalDecl( decl )
      
2543:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2550:          Node paramScope = oNodeGet( decl, qParams )
2563:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2569:          int level = oNodeGetInt( paramScope, qLevel )
2582:          oScopeBegin( level, allocDown )
2591:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2602:          Label label = oNodeGetLabel( decl, qValue )
2615:          @Block( nLocalVar, label )
2625:          oNodeSetBoolean( decl, qBodyDefined, true )
2637:          oScopeEnd
      
2638:          oScopeEnd  % paramScope
2639:    ]
2639:    ';';
      
      
2642: FormalArgDecl:
2644:    [
2644:       | '(' :
2646:          {
2646:             NodeVec decls = oNodeVecNew
2651:             Node decl
2651:             boolean isInOut = false
      
2657:             [
2657:                | pVar : isInOut = true
2665:                | * :
2670:             ]
      
2670:             {  pIdent
      
2672:                decl = @newIdent( nParam, kVar, LAST_ID )
2688:                oNodeSetBoolean( decl, qInOut, isInOut )
2700:                oNodeVecAppend( decls, decl )
      
2709:                [
2709:                   | ':' : >
2713:                   | ',' :
2715:                ]
2723:             }
      
2725:             Node theType
2725:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2732:             Node allocType
2732:             [ isInOut
2735:                | true :   allocType = @PointerTypeTo( theType )
2747:                | * :      allocType = theType
2758:             ]
      
2758:             int i = 0
2764:             {[ equal( i, oNodeVecSize( decls ) )
2778:                | false :
2779:                   decl = oNodeVecElement( decls, i )
      
2792:                   oNodeSet( decl, qType, theType )
2804:                   oScopeDeclare( decl )
2810:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2826:                   inc( i )
2832:                | * :
2837:                   >
2839:             ]}
      
2841:             oNodeVecDelete( decls )
      
2847:             [
2847:                | ')' : >
2851:                | ';' :
2853:             ]
2861:          }
2863:       | * :
2868:    ];
      
2869: ConstDecl:
2871:    {[
2871:       | pIdent :
2873:          Node decl = @newIdent( nConst, kConst, LAST_ID )
2889:          '='
      
2891:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
2893:          int val = oValueTop
2898:          oValuePop
2899:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
2911:          oNodeSet( decl, qType, IntegerType )
      
2923:          oScopeDeclare( decl )
2929:          ';'
2931:       | * :
2936:          >
2938:    ]};
      
2941: TypeDecl:
2943:    {[
2943:       | pIdent :
2945:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
2961:          '='
2963:          Node theType
2963:          @TypeRef( theType )
2970:          oNodeSet( decl, qType, theType )
2982:          oScopeDeclare( decl )
2988:          ';'
2990:       | * :
2995:          >
2997:    ]};
      
3000: VarDecl( node_type varNodeType ):
3002:    {[
3002:       | pIdent :
3004:          NodeVec decls = oNodeVecNew
3009:          Node decl
3009:          {
3009:             decl = @newIdent( varNodeType, kVar, LAST_ID )
3025:             oNodeVecAppend( decls, decl )
3034:             [
3034:                | ',' :
3036:                   pIdent
3038:                | * :
3043:                   >
3045:             ]
3045:          }
3047:          ':'
3049:          Node theType
3049:          @TypeRef( theType )
      
3056:          int i = 0
3062:          {[ equal( i, oNodeVecSize( decls ) )
3076:             | false :
3077:                decl = oNodeVecElement( decls, i )
3090:                oNodeSet( decl, qType, theType )
3102:                oScopeDeclareAlloc( decl )
3108:                inc( i )
3114:             | * :
3119:               >
3121:          ]}
      
               % optional initialization
3123:          [
3123:             | '=' :
3125:                [ oNodeVecSize( decls )
3132:                   | 1 :
3133:                   | * :  #eOnlyOneVarCanBeInitialized
3140:                ]
      
                     % we need an initCode stream for this scope
3140:                Code initCode = @GetOrCreateInitCode
3146:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3152:                boolean changedScope = false
3158:                [ equal_zero( @ScopeLevel )
3165:                   | true : oScopeEnter( initScope )
3172:                            changedScope = true
3178:                   | * :
3183:                ]
                     % generate assignment in initCode stream
3183:                @LValueVar( decl )
3190:                @Expr
3192:                @MatchTypes
3194:                @Assign
3196:                [ changedScope
3199:                   | true : oScopeEnd
3201:                   | * :
3206:                ]
3206:                oCodePop
                   
3207:             | * :
3212:          ]
      
3212:          oNodeVecDelete( decls )
3218:          ';'
3220:       | * :
3225:          >
3227:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3230: TypeRef( out Node resultType ):
3232:    [
3232:       | pIdent :           % previously named type (including intrinsics)
3234:          Node decl = oScopeFindRequire
3239:          @ResolveUnitRef( decl )
3246:          [ oNodeType( decl )
3253:             | nTypeDecl :
3254:                resultType = oNodeGet( decl, qType )
3267:             | * :
3272:                #eNotType
3274:                resultType = IntegerType
3280:          ]
         
3280:       | pArray :
3282:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3284:          NodeVec dimensions = oNodeVecNew
      
3289:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3289:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3299:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3311:             @ConstExpr
3313:             oNodeSetInt( subrange, qLow, oValueTop )
3324:             oValuePop
3325:             '..'
3327:             @ConstExpr
3329:             oNodeSetInt( subrange, qHigh, oValueTop )
3340:             oValuePop
3341:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3353:             oTypeAdd( subrange )
      
3359:             Node a = oNodeNew( nArrayType )
3369:             oNodeSet( a, qIndexType, subrange )
      
3381:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3390:             [
3390:                | ']' : >
3394:                | ',' :
3396:             ]
3404:          }
      
3406:          pOf
3408:          Node baseType
3408:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3415:          int dim = oNodeVecSize( dimensions )
      
3425:          {
3425:              dec(dim)
      
3431:              Node a = oNodeVecElement( dimensions, dim )
      
3444:              oNodeSet( a, qBaseType, baseType )
3456:              Node subrange = oNodeGet( a, qIndexType )
3469:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3496:              inc( width )
3502:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3528:              oTypeAdd( a )
3534:              baseType = a
      
3540:              [ equal_zero(dim)
3547:                  | true:  >
3550:                  | *:
3555:              ]
3555:          }
      
3557:          resultType = oNodeVecElement( dimensions, 0 )
3570:          oNodeVecDelete( dimensions )
      
3576:       | '^' :
3578:          Node theType
3578:          @TypeRef( theType )
3585:          resultType = @PointerTypeTo( theType )
      
3596:       | pRecord :
3598:          resultType = oNodeNew( nRecordType )
3608:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3617:          @VarDecl( nRecordField )
      
3624:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3636:          [ equal_zero( size )
3643:             | true : #eRecordEmpty
3646:             | * :
3651:          ]
      
3651:          pEnd
      
3653:          oNodeSet( resultType, qScope, oScopeCurrent )
3664:          oNodeSetInt( resultType, qSize, size )
3676:          oScopeEnd
3677:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
3683:       | pSet :
3685:          pOf
3687:          Node theType
3687:          @TypeRef( theType )
3694:       | * :       % this works for cases except where expr starts with an id
3707:          @ConstExpr '..' @ConstExpr
3713:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
3714: ConstExpr:
3716:    [
3716:       | pIntLit :
3718:          oValuePush( TOKEN_VALUE )
3723:       | pIdent :
3725:          Node decl = oScopeFindRequire
3730:          @ResolveUnitRef( decl )
3737:          [ oNodeType( decl )
3744:             | nConst :
3745:                oValuePush( oNodeGetInt( decl, qValue ) )
3758:             | * :
3763:                #eNotConst
3765:                oValuePush( 0 )
3771:          ]
3771:       | pMinus :
3773:          @ConstExpr
3775:          oValueNegate
3776:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
3787: Expr:
3789:    Label falseLabel = labelNull
      
3795:    @ExprAllowCF( falseLabel )
3802:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
3810: BooleanExprControlFlow( out Label falseLabel ):
3812:    @ExprAllowCF( falseLabel )
3819:    [ oTypeSNodeType
3821:       | nBooleanCFType :
3822:       | nBooleanType :
               % convert value to control flow
3824:          falseLabel = oLabelNew
3829:          .tJumpFalse  oEmitLabel( falseLabel )
3837:       | * :
3844:          #eNotBoolean
3846:    ]
3846:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
3848: CFToVal( inout Label falseLabel ):
3850:    [ oTypeSNodeType
3852:       | nBooleanCFType :
3853:          Label doneLabel = oLabelNew
3858:          .tPushConstI  oEmitInt( 1 )
3866:          .tJump  oEmitLabel( doneLabel )
3874:          .tLabel  oEmitLabel( falseLabel )
3882:          .tPushConstI  oEmitInt( 0 )
3890:          .tLabel  oEmitLabel( doneLabel )
3898:          oTypeSPop
3899:          oTypeSPush( BooleanType )
3905:          falseLabel = labelNull
3911:       | * :
3916:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
3917: ValToCF( out Label falseLabel ):
3919:    [ oTypeSNodeType
3921:       | nBooleanType :
3922:          falseLabel = oLabelNew
3927:          .tJumpFalse  oEmitLabel( falseLabel )
3935:          oTypeSPop
3936:          oTypeSPush( BooleanCFType )
3942:       | * :
3947:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
3948: ExprAllowCF( out Label falseLabel ):
3950:    @BoolExprAllowCF( falseLabel )
3957:    {[
3957:       | '=' :
3959:          @CFToVal( falseLabel )
3966:          @BoolExprAllowCF( falseLabel )
3973:          @CFToVal( falseLabel )
3980:          @MatchTypes
3982:          [ oTypeSNodeType
3984:             | nIntegerType, nBooleanType :  .tEqualI
3987:             | nPointerType :                .tEqualP
3991:             | nCharType, nStringType :      #eNotImplemented
3995:             | * :                           #eNotAllowed
4010:          ]
4010:          oTypeSPop
4011:          oTypeSPush( BooleanType )
      
4017:       | '<>' :
4019:          @CFToVal( falseLabel )
4026:          @BoolExprAllowCF( falseLabel )
4033:          @CFToVal( falseLabel )
4040:          @MatchTypes
4042:          [ oTypeSNodeType
4044:             | nIntegerType, nBooleanType :  .tNotEqualI
4047:             | nPointerType :                .tNotEqualP
4051:             | nCharType, nStringType :      #eNotImplemented
4055:             | * :                           #eNotAllowed
4070:          ]
4070:          oTypeSPop
4071:          oTypeSPush( BooleanType )
      
4077:       | '<' :
4079:          @CFToVal( falseLabel )
4086:          @BoolExprAllowCF( falseLabel )
4093:          @CFToVal( falseLabel )
4100:          @MatchTypes
4102:          [ oTypeSNodeType
4104:             | nIntegerType, nBooleanType :  .tLessI
4107:             | nCharType, nStringType :      #eNotImplemented
4111:             | * :                           #eNotAllowed
4124:          ]
4124:          oTypeSPop
4125:          oTypeSPush( BooleanType )
      
4131:       | '>' :
4133:          @CFToVal( falseLabel )
4140:          @BoolExprAllowCF( falseLabel )
4147:          @CFToVal( falseLabel )
4154:          @MatchTypes
4156:          [ oTypeSNodeType
4158:             | nIntegerType, nBooleanType :  .tGreaterI
4161:             | nCharType, nStringType :      #eNotImplemented
4165:             | * :                           #eNotAllowed
4178:          ]
4178:          oTypeSPop
4179:          oTypeSPush( BooleanType )
      
4185:       | '<=' :
4187:          @CFToVal( falseLabel )
4194:          @BoolExprAllowCF( falseLabel )
4201:          @CFToVal( falseLabel )
4208:          @MatchTypes
4210:          [ oTypeSNodeType
4212:             | nIntegerType, nBooleanType :  .tLessEqualI
4215:             | nCharType, nStringType :      #eNotImplemented
4219:             | * :                           #eNotAllowed
4232:          ]
4232:          oTypeSPop
4233:          oTypeSPush( BooleanType )
      
4239:       | '>=' :
4241:          @CFToVal( falseLabel )
4248:          @BoolExprAllowCF( falseLabel )
4255:          @CFToVal( falseLabel )
4262:          @MatchTypes
4264:          [ oTypeSNodeType
4266:             | nIntegerType, nBooleanType :  .tGreaterEqualI
4269:             | nCharType, nStringType :      #eNotImplemented
4273:             | * :                           #eNotAllowed
4286:          ]
4286:          oTypeSPop
4287:          oTypeSPush( BooleanType )
      
4293:       | * :
4308:          >
4310:    ]};
      
      
4313: BoolExprAllowCF( out Label falseLabel ):
4315:    Label trueLabel = labelNull
      
4321:    @BoolTermAllowCF( falseLabel )
4328:    {[
4328:       | pOr :
4330:          [ oTypeSNodeType
4332:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
4333:                [ equal_label( trueLabel, labelNull )
4343:                   | true :  trueLabel = oLabelNew
4349:                   | * :
4354:                ]
4354:                .tJump  oEmitLabel( trueLabel )
4362:             | nBooleanType :
4364:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
4371:                [ equal_label( trueLabel, labelNull )
4381:                   | true :  trueLabel = oLabelNew
4387:                   | * :
4392:                ]
4392:                .tJump  oEmitLabel( trueLabel )
4400:             | * : #eNotBoolean
4409:          ]
4409:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
4410:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
4418:          falseLabel = labelNull
4424:          @BoolTermAllowCF( falseLabel )
      
4431:          [ oTypeSNodeType
4433:             | nBooleanCFType :
4434:             | nBooleanType :
4436:                @ValToCF( falseLabel )
4443:             | * : #eNotBoolean
4452:          ]
      
4452:          oTypeSPop
4453:          oTypeSPush( BooleanCFType )
      
4459:       | * :
4464:          >
4466:    ]}
      
         % any short-circuit trues jump here to the end
4468:    [ equal_label( trueLabel, labelNull )
4478:       | false :
4479:          .tLabel  oEmitLabel( trueLabel )
4487:       | * :
4492:    ]
4493:    ;
      
      
4493: BoolTermAllowCF( out Label falseLabel ):
4495:    Label overallFalseLabel = labelNull
      
4501:    @BoolFactorAllowCF( falseLabel )
4508:    {[
4508:       | pAnd :
4510:          [ oTypeSNodeType
4512:             | nBooleanCFType :
4513:             | nBooleanType :
4515:                @ValToCF( falseLabel )
4522:             | * :
4529:                #eNotBoolean
4531:          ]
4531:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
4532:          [ equal_label( overallFalseLabel, labelNull )
4542:             | true :
4543:                overallFalseLabel = oLabelNew
4548:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
4562:                falseLabel = overallFalseLabel
4568:             | * :
4573:          ]
      
4573:          Label factorFalseLabel = labelNull
4579:          @BoolFactorAllowCF( factorFalseLabel )
      
4586:          [ oTypeSNodeType
4588:             | nBooleanCFType :
4589:             | nBooleanType :
4591:                @ValToCF( factorFalseLabel )
4598:             | * : #eNotBoolean
4607:          ]
4607:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
4621:       | * :
4626:          >
4628:    ]};
      
4631: BoolFactorAllowCF( out Label falseLabel ):
4633:    [
4633:       | pNot :
4635:          Label factorFalseLabel = labelNull
      
4641:          @BoolFactorAllowCF( factorFalseLabel )
4648:          [ oTypeSNodeType
4650:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
4651:                falseLabel = oLabelNew
4656:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
4664:                .tLabel  oEmitLabel( factorFalseLabel )
      
4672:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
4674:                .tNot
      
4676:             | * : #eNotBoolean
4685:          ]
      
4685:       | * :
4690:          @ArithExprAllowCF( falseLabel )
4697:    ];
      
4698: ArithExprAllowCF( out Label falseLabel ):
4700:    @TermAllowCF( falseLabel )
4707:    {[
4707:       | pPlus :
4709:          @RequireIntPop
4711:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4718:          @RequireInt
4720:          .tAddI
4722:       | pMinus :
4724:          @RequireIntPop
4726:          @TermAllowCF( falseLabel )
4733:          @RequireInt
4735:          .tSubI
4737:       | * :
4744:          >
4746:    ]};
      
4749: TermAllowCF( out Label falseLabel ):
4751:    @FactorAllowCF( falseLabel )
4758:    {[
4758:       | pTimes :
4760:          @RequireIntPop
4762:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4769:          @RequireInt
4771:          .tMultI
4773:       | pDivide :
4775:          @RequireIntPop
4777:          @FactorAllowCF( falseLabel )
4784:          @RequireInt
4786:          .tDivI
4788:       | * :
4795:          >
4797:    ]};
      
4800: FactorAllowCF( out Label falseLabel ):
4802:    [
4802:       | pPlus :
4804:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
4811:          @RequireInt
4813:       | pMinus :
4815:          @PrimaryAllowCF( falseLabel )
4822:          @RequireInt
4824:          .tNegI
4826:       | * :
4833:          @PrimaryAllowCF( falseLabel )
4840:    ];
      
4841: PrimaryAllowCF( out Label falseLabel ):
4843:    [
4843:       | pIntLit :
4845:          .tPushConstI  oEmitInt( TOKEN_VALUE )
4852:          oTypeSPush( IntegerType )
      
4858:       | '(' :
4860:          @ExprAllowCF( falseLabel )
4867:          ')'
      
4869:       | pStrLit :
4871:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
4880:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
4888:          oTypeSPush( StringType )
      
4894:       | pIdent :
4896:          Node decl = oScopeFindRequire
4901:          @ResolveUnitRef( decl )
4908:          Node theType
      
4908:          [ oNodeType( decl )
4915:             | nFunc :
      
4916:                @Call( decl )
      
4923:             | nConst :
4925:                theType = oNodeGet( decl, qType )
4938:                oTypeSPush( theType )
4944:                [ oTypeSNodeType
4946:                   | nIntegerType, nBooleanType :
4947:                      .tPushConstI @EmitValue( decl )
4956:                   | * :
4963:                      #eNotImplemented
4965:                ]
      
4965:             | nGlobalVar, nLocalVar, nParam :
4967:                @VarExpr( decl )
      
4974:             | * :
4987:                #eNotValue
4989:                oTypeSPush( IntegerType )
4995:          ]
      
4995:       | '@' :        % @var -- pointer to var
4997:          pIdent
      
4999:          Node decl = oScopeFindRequire
5004:          @ResolveUnitRef( decl )
5011:          Node theType
      
5011:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5018:          theType = oTypeSTop
5023:          oTypeSPop
5024:          Node ptrType = @PointerTypeTo( theType )
5035:          oTypeSPush( ptrType )
      
5041:       | * :
5054:          #eNotValue
5056:          oTypeSPush( IntegerType )
5062:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5063: VarExpr( Node decl ):
5065:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5078:    int uplevels = @DeclUpLevels( decl )
      
5089:    oTypeSPush( theType )
5095:    [ oTypeSNodeType
5097:       | nIntegerType :
5098:          [ oNodeType( decl )
5105:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
5115:             | nLocalVar :
5117:                [ equal_zero( uplevels )
5124:                   | true :  .tPushLocalI  @EmitValue( decl )
5134:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5154:                ]
5154:             | nParam :
5156:                [ oNodeGetBoolean( decl, qInOut )
5166:                   | true :    % VAR param points to the var.  Auto dereference.
5167:                      [ equal_zero( uplevels )
5174:                         | true :  .tPushParamP  @EmitValue( decl )
5184:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5204:                      ]
5204:                      .tFetchI
5206:                   | * :
5211:                      [ equal_zero( uplevels )
5218:                         | true :  .tPushParamI  @EmitValue( decl )
5228:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
5248:                      ]
5248:                ]
5248:          ]
      
5258:       | nBooleanType :
5260:          [ oNodeType( decl )
5267:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
5277:             | nLocalVar :
5279:                [ equal_zero( uplevels )
5286:                   | true :  .tPushLocalB  @EmitValue( decl )
5296:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
5316:                ]
5316:             | nParam :
5318:                [ oNodeGetBoolean( decl, qInOut )
5328:                   | true :    % VAR param points to the var.  Auto dereference.
5329:                      [ equal_zero( uplevels )
5336:                         | true :  .tPushParamP  @EmitValue( decl )
5346:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5366:                      ]
5366:                      .tFetchB
5368:                   | * :
5373:                      [ equal_zero( uplevels )
5380:                         | true :  .tPushParamB  @EmitValue( decl )
5390:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
5410:                      ]
5410:                ]
5410:          ]
      
5420:       | nCharType, nStringType, nFileType :
5422:          #eNotImplemented
      
5424:       | nPointerType :
5426:          [ oNodeType( decl )
5433:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
5443:             | nLocalVar :
5445:                [ equal_zero( uplevels )
5452:                   | true :  .tPushLocalP  @EmitValue( decl )
5462:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
5482:                ]
5482:             | nParam :
5484:                [ oNodeGetBoolean( decl, qInOut )
5494:                   | true :    % VAR param points to the var.  Auto dereference.
5495:                      [ equal_zero( uplevels )
5502:                         | true :  .tPushParamP  @EmitValue( decl )
5512:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5532:                      ]
5532:                      .tFetchP
5534:                   | * :
5539:                      [ equal_zero( uplevels )
5546:                         | true :  .tPushParamP  @EmitValue( decl )
5556:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5576:                      ]
5576:                ]
5576:          ]
5586:          [
5586:             | '^' :             % dereferenced
5588:                oTypeSPop
5589:                oTypeSPush( oNodeGet( theType, qBaseType ) )
5602:                @LValueIndexes
5604:                @FetchVar
5606:             | * :               % just ptr value alone
5611:          ]
      
5611:       | * :
               % compound type
               % first, push addr of start of var
5626:          [ oNodeType( decl )
5633:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5643:             | nLocalVar :
5645:                [ equal_zero( uplevels )
5652:                   | true :  .tPushAddrLocal  @EmitValue( decl )
5662:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
5682:                ]
5682:             | nParam :
5684:                [ oNodeGetBoolean( decl, qInOut )
5694:                   | true :    % VAR param points to the var.  Auto dereference.
5695:                      [ equal_zero( uplevels )
5702:                         | true :  .tPushParamP  @EmitValue( decl )
5712:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5732:                      ]
5732:                   | * :
5737:                      [ equal_zero( uplevels )
5744:                         | true :  .tPushAddrParam  @EmitValue( decl )
5754:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
5774:                      ]
5774:                ]
5774:          ]
               % modify addr for subscripts, field references, etc
5784:          @LValueIndexes
               % get final value
5786:          @FetchVar
5788:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
5789: FetchVar:
5791:    [ oTypeSNodeType
5793:       | nIntegerType :   .tFetchI
5796:       | nBooleanType :   .tFetchB
5800:       | nCharType, nStringType, nFileType : #eNotImplemented
5804:       | nPointerType :   .tFetchP
5808:       | * :              % compound type; leave as addr
5823:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
5824: LValueIndexes:
5826:    {[
5826:       | '[' :       @ArraySubscripts
5830:       | '.' :       @RecordFieldRef
5834:       | '^' :       @PointerDeref
5838:       | * :         >
5849:    ]};
      
5852: ArraySubscripts:
5854:    [ oTypeSNodeType
5856:       | nArrayType :
5857:       | * :       #eNotArray
5864:    ]
5864:    {
5864:       [ oTypeSNodeType
5866:          | nArrayType :
5867:          | * :    #eTooManySubscripts
5874:       ]
      
            % low subscript of this dimension
5874:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
5891:       Node baseType
5891:       baseType = oNodeGet( oTypeSTop, qBaseType )
5903:       oTypeSPop
5904:       oTypeSPush( baseType )
      
5910:       @Expr
5912:       @RequireIntPop
            % adjust for low subscript
5914:       [ equal_zero( low )
5921:          | false :
5922:             .tPushConstI oEmitInt( low ) .tSubI
5932:          | * :
5937:       ]
      
            % multiply by element size
5937:       int size = oNodeGetInt( baseType, qSize )
5950:       [ equal( size, 1 )
5960:          | false :
5961:             .tPushConstI oEmitInt( size ) .tMultI
5971:          | * :
5976:       ]
      
            % update start address
5976:       .tAddPI
5978:       [
5978:          | ']' :  >
5982:          | ',' :
5984:       ]
5992:    };
      
      
5995: RecordFieldRef:
5997:    [ oTypeSNodeType
5999:       | nRecordType :
6000:       | * :    #eNotRecord
6007:    ]
6007:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
6019:    pIdent
6021:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
6026:    [ oNodeType( field )
6033:       | nRecordField :
6034:       | * :   #eNotRecordField
6041:    ]
6041:    oScopeEnd
6042:    int offset = oNodeGetInt( field, qValue )
6055:    [ equal_zero( offset )
6062:       | false :
6063:          .tPushConstI oEmitInt( offset ) .tAddPI
6073:       | * :
6078:    ]
      
         % replace the type on the type stack, with the field type
6078:    oTypeSPop
6079:    oTypeSPush( oNodeGet( field, qType ) )
6093:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
6093: PointerDeref:
6095:    [ oTypeSNodeType
6097:       | nPointerType :
6098:       | * :       #eNotPointer
6105:    ]
6105:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
6107:    Node theType = oTypeSTop
6112:    oTypeSPop
6113:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6127:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6127: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
6129:    @MatchTypes
6132:    ;
      
      
      % Called on first use of an extern method
      %
6132: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
6134:    int strAddr
6134:    String externalName = oNodeGetString( method, qExternalName )
6147:    [ equal_string( externalName, stringNull )
6157:       | true :
6158:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
6179:       | false :
6181:          strAddr = oStringAllocLit( externalName )
6191:    ]
6199:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
6215:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
6215: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
6217:    [ oNodeGetBoolean( method, qExternal )
6227:       | true :
6228:          [ oNodeGetBoolean( method, qCalled )
6238:             | false :
                     % define the extern label on first use
6239:                @DefineExternLabel( method )
6246:             | * :
6251:          ]
6251:      | * :
6256:    ]
6256:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
6268:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
6281:    Node resultType
6281:    int tempOffset
      
6281:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
6298:    [ isFunc
6301:       | true :
6302:          resultType = oNodeGet( method, qType )
6315:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
6325:       | * :
6330:    ]
         
      
6330:    Node paramScope = oNodeGet( method, qParams )
6343:    int actualsSize = oNodeGetInt( paramScope, qSize )
6356:    [ cdecl
6359:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
6368:       | false :  .tAllocActuals  oEmitInt( actualsSize )
6378:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
6386:    [ greater( @DeclLevel( method ), 0 )
6401:       | true :
6402:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
6410:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
6429:          .tAssignP
6431:       | * :
6436:    ]
      
      
6436:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
6449:    Node param = oNodeIterValue( paramIter )
6459:    [
6459:       | '(' :
            
6461:          {
6461:             [ oNodeNull( param )
6468:                | true : >
6471:                | * :
6476:             ]
      
6476:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
6489:             .tPushAddrActual oEmitInt( offset )
6497:             oTypeSPush( oNodeGet( param, qType ) )
      
6510:             [ oNodeGetBoolean( param, qInOut )
6520:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
6521:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
6523:                           @MatchTypes
      
6525:                           .tAssignP
      
6527:                | false :  @Expr
6531:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
6533:                           [ oTypeSNodeType
6535:                              | nIntegerType :            .tAssignI
6538:                              | nBooleanType :            .tAssignB
6542:                              | nCharType, nStringType, nFileType :   #eNotImplemented
6546:                              | nPointerType :            .tAssignP
6550:                              | * :
                                       % compound types: copy value into actuals space
6565:                                  int size = oNodeGetInt( oTypeSTop, qSize )
6577:                                  .tCopy  oEmitInt( size )    % multi-word copy
6585:                           ]
6585:             ]
6593:             oTypeSPop
      
6594:             oNodeIterNext( paramIter )
6600:             param = oNodeIterValue( paramIter )
6610:             [ oNodeNull( param )
6617:                | true :  >
6620:                | false :
6622:             ]
      
6630:             ','
6632:          }
      
6634:          ')'
      
6636:       | * :
6641:    ]
      
6641:    [ oNodeNull( param )
6648:       | false :    #eMissingParameter
6651:       | * :
6656:    ]
      
6656:    [ isFunc
6659:       | true :
               % Pass result temp as an additional VAR parameter.
6660:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
6675:          .tPushAddrLocal  oEmitInt( tempOffset )
6683:          .tAssignP
6685:       | * :
6690:    ]
      
6690:    [ cdecl
6693:       | true :
6694:          .tCallCdecl  @EmitValue( method )
6703:       | false :
6705:          .tCall   @EmitValue( method )
6714:    ]
      
6722:    [ isFunc
6725:       | true :
               % push return value from temp
6726:          oTypeSPush( resultType )
      
6732:          [ oTypeSNodeType
6734:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
6743:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
6753:             | nCharType, nStringType, nFileType : #eNotImplemented
6757:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
6767:             | * :              % compound type: push address
6782:                                .tPushAddrLocal  oEmitInt( tempOffset )
6790:          ]
6790:       | * :
6795:    ]
         
6795:    .tFreeActuals  oEmitInt( actualsSize )
6804:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
6804: Statement:
6806:    [
6806:       | pWriteln :     @WritelnStmt
6810:       | pWrite :       @WriteStmt
6814:       | pReadln :      @ReadlnStmt
6818:       | pRead :        @ReadStmt
6822:       | pIf :          @IfStmt
6826:       | pWhile :       @WhileStmt
6830:       | pFor :         @ForStmt
6834:       | pRepeat :      @RepeatStmt
6838:       | pBreak :       @BreakStmt
6842:       | pContinue :    @ContinueStmt
6846:       | pBegin :       @BeginStmt
6850:       | pIdent :       @AssignOrCallStmt
6854:       | * :            % null statement : don't accept any tokens
6881:    ];
      
      
6882: AssignOrCallStmt:
6884:    Node decl = oScopeFindRequire
6889:    @ResolveUnitRef( decl )
6896:    [ oNodeType( decl )
6903:       | nProc :                           @Call( decl )
6911:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
6920:       | nFunc :                           @AssignResultStmt( decl )
6929:       | * :                               #eBadStatement
6944:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
6945: AssignStmt( Node decl ):
      
6947:    @LValueVar( decl )
6954:    ':=' 
6956:    @Expr
6958:    @MatchTypes
6960:    @Assign
6963:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
6963: Assign:
6965:    [ oTypeSNodeType
6967:       | nIntegerType :            .tAssignI
6970:       | nBooleanType :            .tAssignB
6974:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
6978:       | nPointerType :            .tAssignP
6982:       | * :
6997:           int size = oNodeGetInt( oTypeSTop, qSize )
7009:           .tCopy  oEmitInt( size )    % multi-word copy
7017:    ]
7017:    oTypeSPop
7019:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
7019: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
7021:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
7037:       | false :   #eNotCurrentFunction
7040:       | * :
7045:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
7045:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
7060:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
7073:    ':='
7075:    @Expr
7077:    @MatchTypes
7079:    [ oTypeSNodeType
7081:       | nIntegerType :            .tAssignI
7084:       | nBooleanType :            .tAssignB
7088:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
7092:       | nPointerType :            .tAssignP
7096:       | * :
7111:           int size = oNodeGetInt( oTypeSTop, qSize )
7123:           .tCopy  oEmitInt( size )    % multi-word copy
7131:    ]
7131:    oTypeSPop
7133:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
7133: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
7135:    pIdent
7137:    Node decl = oScopeFindRequire
7142:    @ResolveUnitRef( decl )
7149:    [ oNodeType( decl )
7156:       | nGlobalVar, nLocalVar, nParam :
7157:       | * :  #eNotVar
7168:    ]
7168:    @LValueVar( decl )
7176:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
7176: LValueVar( Node decl ):
7178:    [ oNodeType( decl )
7185:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
7195:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
7206:       | nParam :
7208:          [ oNodeGetBoolean( decl, qInOut )
7218:             | true :   % VAR param points to variable.  No dereference.
7219:                        .tPushParamP @EmitValue( decl )
7228:             | * :      .tPushAddrParam @EmitValue( decl )
7242:          ]
7242:       | * :            #eNotVar
7253:    ]
      
7253:    oTypeSPush( oNodeGet( decl, qType ) )
7266:    @LValueIndexes        % handle subscripts, if any
7269:    ;
      
      
7269: IncVar( Node decl ):
7271:    @LValueVar( decl )
7278:    @RequireIntPop
7280:    @VarExpr( decl )
7287:    oTypeSPop
7288:    .tIncI
7290:    .tAssignI;
      
7293: DecVar( Node decl ):
7295:    @LValueVar( decl )
7302:    @RequireIntPop
7304:    @VarExpr( decl )
7311:    oTypeSPop
7312:    .tDecI
7314:    .tAssignI;
      
      
7317: IfStmt:
7319:    Label falseLabel = labelNull
      
7325:    @BooleanExprControlFlow( falseLabel )
7332:    pThen
7334:    @Statement
7336:    [
7336:       | pElse :
7338:          Label doneLabel = oLabelNew
      
7343:          .tJump  oEmitLabel( doneLabel )
7351:          .tLabel oEmitLabel( falseLabel )
7359:          @Statement
7361:          .tLabel oEmitLabel( doneLabel )
      
7369:       | * :
7374:          .tLabel oEmitLabel( falseLabel )
7382:    ];
      
      
7383: ForStmt:
7385:    pIdent
      
7387:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
7392:    @LValueVar( decl )
7399:    @RequireIntPop
      
7401:    ':='
      
7403:    @Expr
7405:    @RequireIntPop
7407:    .tAssignI
      
7409:    Label breakLabel = oLabelNew
      
7414:    Label checkLabel = oLabelNew
7419:    .tJump  oEmitLabel( checkLabel )
      
7427:    Label continueLabel = oLabelNew
7432:    .tLabel  oEmitLabel( continueLabel )
7440:    [
7440:       | pTo :
7442:          @IncVar( decl )
7449:          .tLabel  oEmitLabel( checkLabel )
7457:          @VarExpr( decl )  oTypeSPop
7465:          @Expr
7467:          @RequireIntPop
7469:          .tGreaterI
7471:          .tJumpTrue  oEmitLabel( breakLabel )
7479:       | pDownto :
7481:          @DecVar( decl )
7488:          .tLabel  oEmitLabel( checkLabel )
7496:          @VarExpr( decl )  oTypeSPop
7504:          @Expr
7506:          @RequireIntPop
7508:          .tLessI
7510:          .tJumpTrue  oEmitLabel( breakLabel )
7518:    ]
7526:    oLoopPush( continueLabel, breakLabel )
7535:    pDo
7537:    @Statement
7539:    .tJump  oEmitLabel( continueLabel )
7547:    .tLabel  oEmitLabel( breakLabel )
7555:    oLoopPop;
      
      
7557: RepeatStmt:
7559:    Label continueLabel = oLabelNew
7564:    .tLabel  oEmitLabel( continueLabel )
      
7572:    Label breakLabel = oLabelNew
      
7577:    oLoopPush( continueLabel, breakLabel )
7586:    @Statement
7588:    {[
7588:       | ';' :
7590:          @Statement
7592:       | pUntil :
7594:          Label falseLabel
7594:          @BooleanExprControlFlow( falseLabel )
7601:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
7615:          >
7617:    ]}
7627:    .tLabel  oEmitLabel( breakLabel )
7635:    oLoopPop;
      
      
7637: WhileStmt:
7639:    Label continueLabel = oLabelNew
7644:    .tLabel  oEmitLabel( continueLabel )
      
7652:    Label breakLabel
7652:    @BooleanExprControlFlow( breakLabel )
      
7659:    oLoopPush( continueLabel, breakLabel )
7668:    pDo
7670:    @Statement
7672:    .tJump  oEmitLabel( continueLabel )
7680:    .tLabel  oEmitLabel( breakLabel )
7688:    oLoopPop;
      
      
7690: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
7692:    [ equal_label( oLoopContinueLabel, labelNull )
7701:       | true :
7702:          #eNotInALoop
7704:       | false :
7706:          .tJump  oEmitLabel( oLoopContinueLabel )
7713:    ];
      
      
7722: BreakStmt:
7724:    [ equal_label( oLoopBreakLabel, labelNull )
7733:       | true :
7734:          #eNotInALoop
7736:       | false :
7738:          .tJump  oEmitLabel( oLoopBreakLabel )
7745:    ];
      
      
7754: BeginStmt:
7756:    @Statement
7758:    {[
7758:       | ';' :   @Statement
7762:       | pEnd :  >
7766:    ]};
      
      
7777: WritelnStmt:
7779:    @WriteStmt
7781:    .tWriteCR;
      
      
7784: WriteStmt:
7786:    [
7786:       | '(' :
7788:          {
7788:             @Expr
7790:             [ oTypeSNodeType
7792:                | nIntegerType :             .tWriteI
7795:                | nBooleanType :             .tWriteBool
7799:                | nStringType :              .tWriteStr
7803:                | nCharType, nFileType :     #eNotImplemented
7807:                | nPointerType :             .tWriteP
7811:                | * :                        #eNotAllowed
7828:             ]
7828:             oTypeSPop
7829:             [
7829:                | ')' : >
7833:                | ',' :
7835:             ]
7843:          }
7845:       | * :
7850:    ];
      
      
7851: ReadlnStmt:      % ***
         % TO DO
7854:    ;
      
7854: ReadStmt:
         % TO DO
7857:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
7857: ScopeLevel >> int:
7859:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
7869: DeclLevel( Node decl ) >> int:
7871:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
7889: DeclUpLevels( Node decl ) >> int:
7891:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
7907: MatchTypes:
7909:    node_type nt = oTypeSNodeType
7914:    oTypeSPop
7915:    [ equal_node_type( nt, oTypeSNodeType )
7924:       | false :
7925:          #eTypeMismatch
7927:       | * :
7932:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
7933: RequireIntPop:
7935:    [ oTypeSNodeType
7937:       | nIntegerType :
7938:       | * :          #eNotInteger
7945:    ]
7945:    oTypeSPop;
      
7947: RequireInt:
7949:    [ oTypeSNodeType
7951:       | nIntegerType :
7952:       | * :          #eNotInteger
7959:    ];
      
7960: RequireBoolPop:
7962:    [ oTypeSNodeType
7964:       | nBooleanType :
7965:       | * :          #eNotBoolean
7972:    ]
7972:    oTypeSPop;
      
7974: RequireBool:
7976:    [ oTypeSNodeType
7978:       | nBooleanType :
7979:       | * :          #eNotBoolean
7986:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
7987: newType( node_type nt, int size ) >> Node:
7989:   Node node = oNodeNew( nt )
7999:   oNodeSetInt( node, qSize, size )
8011:   oTypeAdd( node )
8017:   >> node
8021:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
8021: newIdent( node_type nt, kind k, int id ) >> Node:
8023:   Node t = oNodeNew( nt )
8033:   oNodeSetInt( t, qIdent, id )
8045:   >> t
8049:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
8049: PointerTypeTo( Node theType ) >> Node:
8051:    Node ptrType = oNodeGet( theType, qPointerType )
8064:    [ oNodeNull( ptrType )
8071:       | true :
8072:          ptrType = oNodeNew( nPointerType )
8082:          oNodeSet( ptrType, qBaseType, theType )
8094:          oNodeSetInt( ptrType, qSize, 8 )
8106:          oTypeAdd( ptrType )
8112:          oNodeSet( theType, qPointerType, ptrType )
8124:       | * :
8129:    ]
8129:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
8133: OrdinalLow( Node theType ) >> int:
8135:    [ oNodeType( theType )
8142:       | nIntegerType :  >> oMININT
8145:       | nBooleanType :  >> 0
8150:       | nCharType :     >> 0
8155:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
8167:       | * :             #eNotOrdinalType
8180:                         >> 0
8183:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
8184: EmitValue( Node decl ):
8186:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
8200: installBuiltIns:
      
         % install built-in types
8202:    FileType = @newType( nFileType, 4 )
8216:    IntegerType = @newType( nIntegerType, 4 )
8230:    BooleanType = @newType( nBooleanType, 1 )
8244:    BooleanCFType = @newType( nBooleanCFType, 1 )
8258:    CharType = @newType( nCharType, 1 )
8272:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
8286:    Node t
      
8286:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
8302:    oNodeSet( t, qType, FileType )
8314:    oScopeDeclare( t )
      
8320:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
8336:    oNodeSet( t, qType, IntegerType )
8348:    oScopeDeclare( t )
      
8354:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
8370:    oNodeSet( t, qType, BooleanType )
8382:    oScopeDeclare( t )
      
8388:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
8404:    oNodeSet( t, qType, CharType )
8416:    oScopeDeclare( t )
      
8422:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
8438:    oNodeSet( t, qType, StringType )
8450:    oScopeDeclare( t )
      
         % Built-in constants
      
8456:    t = @newIdent( nConst, kConst, oIdAdd_True )
8472:    oNodeSet( t, qType, BooleanType )
8484:    oNodeSetInt( t, qValue, 1 )
8496:    oScopeDeclare( t )
      
8502:    t = @newIdent( nConst, kConst, oIdAdd_False )
8518:    oNodeSet( t, qType, BooleanType )
8530:    oNodeSetInt( t, qValue, 0 )
8542:    oScopeDeclare( t )
      
8549:    ;
      
8549: end
      
8549: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 6
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 8200
  25: oEmit 52
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 46
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 49
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 48
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 51
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 181
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 16
 110: oPushResult
 111: oSetResult 6
 113: oPushResult
 114: LAST_ID
 115: oPushResult
 116: oCall 8021
 118: oPop 3
 120: oAssign
 121: oGetLocal 1
 123: oPushResult
 124: oSetResult 21
 126: oPushResult
 127: oGetGlobal 3
 129: oPushResult
 130: oNodeSet
 131: oPop 3
 133: oGetLocal 1
 135: oPushResult
 136: oScopeDeclareAlloc
 137: oPop 1
 139: oInput 12
 141: oInput 0
 143: oGetAddrLocal 1
 145: oPushResult
 146: oSetResult 16
 148: oPushResult
 149: oSetResult 6
 151: oPushResult
 152: LAST_ID
 153: oPushResult
 154: oCall 8021
 156: oPop 3
 158: oAssign
 159: oGetLocal 1
 161: oPushResult
 162: oSetResult 21
 164: oPushResult
 165: oGetGlobal 3
 167: oPushResult
 168: oNodeSet
 169: oPop 3
 171: oGetLocal 1
 173: oPushResult
 174: oScopeDeclareAlloc
 175: oPop 1
 177: oInput 14
 179: oJumpForward 184
 181: Choice Lookup Table
          13    103
 184: oInput 4
 186: oInputChoice 197
 188: oGetLocal 4
 190: oPushResult
 191: oCall 292
 193: oPop 1
 195: oJumpForward 200
 197: Choice Lookup Table
          54    188
 200: oGetLocal 4
 202: oPushResult
 203: oCall 445
 205: oPop 1
 207: oSetResult 0
 209: oPushResult
 210: oSetResult 0
 212: oPushResult
 213: oScopeBegin
 214: oPop 2
 216: oGetAddrLocal 5
 218: oPushResult
 219: oScopeCurrent
 220: oAssign
 221: oSetResult 0
 223: oPushResult
 224: oSetResult 1
 226: oPushResult
 227: oScopeBegin
 228: oPop 2
 230: oGetAddrGlobal 2
 232: oPushResult
 233: oScopeCurrent
 234: oAssign
 235: oGetLocal 4
 237: oPushResult
 238: oSetResult 7
 240: oPushResult
 241: oGetGlobal 2
 243: oPushResult
 244: oNodeSet
 245: oPop 3
 247: oScopeEnd
 248: oSetResult 17
 250: oPushResult
 251: oCall 1369
 253: oPop 1
 255: oGetGlobal 2
 257: oPushResult
 258: oScopeEnter
 259: oPop 1
 261: oGetAddrLocal 6
 263: oPushResult
 264: oSetResult 1
 266: oAssign
 267: oGetLocal 3
 269: oPushResult
 270: oGetLocal 5
 272: oPushResult
 273: oGetLocal 6
 275: oPushResult
 276: oCall 1589
 278: oPop 3
 280: oScopeEnd
 281: oInput 19
 283: oScopeEnd
 284: oGetLocal 4
 286: oPushResult
 287: oCall 507
 289: oPop 1
 291: oReturn
 292: oLocalSpace 2
 294: oInput 0
 296: oGetAddrLocal 1
 298: oPushResult
 299: LAST_ID
 300: oPushResult
 301: oCall 586
 303: oPop 1
 305: oAssign
 306: oGetLocal 1
 308: oPushResult
 309: oSetResult 0
 311: oPushResult
 312: equal_node
 313: oPop 2
 315: oChoice 385
 317: oGetParam 1
 319: oPushResult
 320: oSetResult 5
 322: oPushResult
 323: oGetLocal 1
 325: oPushResult
 326: oNodeAddLast
 327: oPop 3
 329: oGetAddrLocal 2
 331: oPushResult
 332: oSetResult 10
 334: oPushResult
 335: oNodeNew
 336: oPop 1
 338: oAssign
 339: oGetLocal 2
 341: oPushResult
 342: oSetResult 4
 344: oPushResult
 345: oGetLocal 1
 347: oPushResult
 348: oSetResult 4
 350: oPushResult
 351: oNodeGetInt
 352: oPop 2
 354: oPushResult
 355: oNodeSetInt
 356: oPop 3
 358: oGetLocal 2
 360: oPushResult
 361: oSetResult 9
 363: oPushResult
 364: oGetLocal 1
 366: oPushResult
 367: oSetResult 9
 369: oPushResult
 370: oNodeGet
 371: oPop 2
 373: oPushResult
 374: oNodeSet
 375: oPop 3
 377: oGetLocal 2
 379: oPushResult
 380: oScopeDeclare
 381: oPop 1
 383: oJumpForward 388
 385: Choice Lookup Table
           0    317
 388: oInputChoice 392
 390: oJumpForward 397
 392: Choice Lookup Table
          12    390
 395: oJumpForward 399
 397: oJumpBack 294
 399: oInput 4
 401: oReturn
 402: oLocalSpace 1
 404: oGetFromParam 1
 406: oPushResult
 407: oNodeType
 408: oPop 1
 410: oChoice 441
 412: oGetAddrLocal 1
 414: oPushResult
 415: oGetFromParam 1
 417: oPushResult
 418: oSetResult 9
 420: oPushResult
 421: oNodeGet
 422: oPop 2
 424: oAssign
 425: oInput 19
 427: oInput 0
 429: oGetParam 1
 431: oPushResult
 432: oGetLocal 1
 434: oPushResult
 435: oScopeFindRequireInScope
 436: oPop 1
 438: oAssign
 439: oJumpForward 444
 441: Choice Lookup Table
          10    412
 444: oReturn
 445: oLocalSpace 2
 447: oGetAddrLocal 1
 449: oPushResult
 450: oGetParam 1
 452: oPushResult
 453: oSetResult 5
 455: oPushResult
 456: oNodeGetIter
 457: oPop 2
 459: oAssign
 460: oGetAddrLocal 2
 462: oPushResult
 463: oGetLocal 1
 465: oPushResult
 466: oNodeIterValue
 467: oPop 1
 469: oAssign
 470: oGetLocal 2
 472: oPushResult
 473: oNodeNull
 474: oPop 1
 476: oChoice 493
 478: oGetLocal 2
 480: oPushResult
 481: oSetResult 9
 483: oPushResult
 484: oNodeGet
 485: oPop 2
 487: oPushResult
 488: oScopeEnter
 489: oPop 1
 491: oJumpForward 498
 493: Choice Lookup Table
           0    478
 496: oJumpForward 506
 498: oGetAddrLocal 1
 500: oPushResult
 501: oNodeIterNext
 502: oPop 1
 504: oJumpBack 460
 506: oReturn
 507: oLocalSpace 2
 509: oGetAddrLocal 1
 511: oPushResult
 512: oGetParam 1
 514: oPushResult
 515: oSetResult 5
 517: oPushResult
 518: oNodeGetIterLast
 519: oPop 2
 521: oAssign
 522: oGetAddrLocal 2
 524: oPushResult
 525: oGetLocal 1
 527: oPushResult
 528: oNodeIterValue
 529: oPop 1
 531: oAssign
 532: oGetLocal 2
 534: oPushResult
 535: oNodeNull
 536: oPop 1
 538: oChoice 572
 540: oScopeCurrent
 541: oPushResult
 542: oGetLocal 2
 544: oPushResult
 545: oSetResult 9
 547: oPushResult
 548: oNodeGet
 549: oPop 2
 551: oPushResult
 552: oNodeEqual
 553: oPop 2
 555: oChoice 563
 557: oJumpForward 569
 559: oError 25
 561: oJumpForward 569
 563: Choice Lookup Table
           0    559
           1    557
 568: oEndChoice
 569: oScopeEnd
 570: oJumpForward 577
 572: Choice Lookup Table
           0    540
 575: oJumpForward 585
 577: oGetAddrLocal 1
 579: oPushResult
 580: oNodeIterPrev
 581: oPop 1
 583: oJumpBack 522
 585: oReturn
 586: oLocalSpace 2
 588: oGetAddrLocal 1
 590: oPushResult
 591: oGetGlobal 1
 593: oPushResult
 594: oSetResult 1
 596: oPushResult
 597: oSetResult 4
 599: oPushResult
 600: oGetParam 1
 602: oPushResult
 603: oNodeFind
 604: oPop 4
 606: oAssign
 607: oGetLocal 1
 609: oPushResult
 610: oSetResult 0
 612: oPushResult
 613: equal_node
 614: oPop 2
 616: oChoice 623
 618: oGetLocal 1
 620: oReturn
 621: oJumpForward 626
 623: Choice Lookup Table
           0    618
 626: oGetAddrLocal 2
 628: oPushResult
 629: oGetParam 1
 631: oPushResult
 632: oIncludeUnitFile
 633: oPop 1
 635: oAssign
 636: oGetLocal 2
 638: oChoice 647
 640: oError 24
 642: oSetResult 0
 644: oReturn
 645: oJumpForward 650
 647: Choice Lookup Table
           0    640
 650: oGetAddrLocal 1
 652: oPushResult
 653: oCall 661
 655: oAssign
 656: oIncludeEnd
 657: oGetLocal 1
 659: oReturn
 660: oReturn
 661: oLocalSpace 2
 663: oInput 55
 665: oInput 0
 667: oGetAddrLocal 1
 669: oPushResult
 670: oSetResult 5
 672: oPushResult
 673: oNodeNew
 674: oPop 1
 676: oAssign
 677: oGetLocal 1
 679: oPushResult
 680: oSetResult 4
 682: oPushResult
 683: LAST_ID
 684: oPushResult
 685: oNodeSetInt
 686: oPop 3
 688: oGetAddrLocal 2
 690: oPushResult
 691: oSetResult 6
 693: oPushResult
 694: oNodeNew
 695: oPop 1
 697: oAssign
 698: oGetLocal 2
 700: oPushResult
 701: oSetResult 4
 703: oPushResult
 704: LAST_ID
 705: oPushResult
 706: oNodeSetInt
 707: oPop 3
 709: oGetLocal 1
 711: oPushResult
 712: oSetResult 8
 714: oPushResult
 715: oGetLocal 2
 717: oPushResult
 718: oNodeSet
 719: oPop 3
 721: oInput 4
 723: oInput 56
 725: oInputChoice 736
 727: oGetLocal 1
 729: oPushResult
 730: oCall 292
 732: oPop 1
 734: oJumpForward 739
 736: Choice Lookup Table
          54    727
 739: oGetLocal 1
 741: oPushResult
 742: oCall 445
 744: oPop 1
 746: oSetResult 0
 748: oPushResult
 749: oSetResult 0
 751: oPushResult
 752: oScopeBegin
 753: oPop 2
 755: oGetLocal 1
 757: oPushResult
 758: oSetResult 9
 760: oPushResult
 761: oScopeCurrent
 762: oPushResult
 763: oNodeSet
 764: oPop 3
 766: oSetResult 0
 768: oPushResult
 769: oSetResult 1
 771: oPushResult
 772: oScopeBegin
 773: oPop 2
 775: oGetAddrGlobal 2
 777: oPushResult
 778: oScopeCurrent
 779: oAssign
 780: oGetLocal 1
 782: oPushResult
 783: oSetResult 13
 785: oPushResult
 786: oGetGlobal 2
 788: oPushResult
 789: oNodeSet
 790: oPop 3
 792: oScopeEnd
 793: oGetLocal 1
 795: oPushResult
 796: oCall 972
 798: oPop 1
 800: oScopeEnd
 801: oInput 57
 803: oInputChoice 814
 805: oGetLocal 2
 807: oPushResult
 808: oCall 292
 810: oPop 1
 812: oJumpForward 817
 814: Choice Lookup Table
          54    805
 817: oGetLocal 2
 819: oPushResult
 820: oCall 445
 822: oPop 1
 824: oGetLocal 1
 826: oPushResult
 827: oSetResult 9
 829: oPushResult
 830: oNodeGet
 831: oPop 2
 833: oPushResult
 834: oScopeEnter
 835: oPop 1
 837: oSetResult 0
 839: oPushResult
 840: oSetResult 0
 842: oPushResult
 843: oScopeBegin
 844: oPop 2
 846: oGetLocal 1
 848: oPushResult
 849: oSetResult 10
 851: oPushResult
 852: oScopeCurrent
 853: oPushResult
 854: oNodeSet
 855: oPop 3
 857: oScopeCurrent
 858: oPushResult
 859: oSetResult 16
 861: oPushResult
 862: oGetLocal 1
 864: oPushResult
 865: oSetResult 9
 867: oPushResult
 868: oNodeGet
 869: oPop 2
 871: oPushResult
 872: oNodeSet
 873: oPop 3
 875: oGetLocal 1
 877: oPushResult
 878: oCall 1057
 880: oPop 1
 882: oInputChoice 896
 884: oGetLocal 1
 886: oPushResult
 887: oSetResult 1
 889: oPushResult
 890: oCall 1067
 892: oPop 2
 894: oJumpForward 909
 896: Choice Lookup Table
          58    884
 899: oGetLocal 1
 901: oPushResult
 902: oSetResult 0
 904: oPushResult
 905: oCall 1067
 907: oPop 2
 909: oInputChoice 923
 911: oGetLocal 1
 913: oPushResult
 914: oSetResult 1
 916: oPushResult
 917: oCall 1253
 919: oPop 2
 921: oJumpForward 936
 923: Choice Lookup Table
          59    911
 926: oGetLocal 1
 928: oPushResult
 929: oSetResult 0
 931: oPushResult
 932: oCall 1253
 934: oPop 2
 936: oInput 34
 938: oInput 19
 940: oScopeEnd
 941: oScopeEnd
 942: oGetLocal 2
 944: oPushResult
 945: oCall 507
 947: oPop 1
 949: oGetLocal 1
 951: oPushResult
 952: oCall 507
 954: oPop 1
 956: oGetGlobal 1
 958: oPushResult
 959: oSetResult 1
 961: oPushResult
 962: oGetLocal 1
 964: oPushResult
 965: oNodeAddLast
 966: oPop 3
 968: oGetLocal 1
 970: oReturn
 971: oReturn
 972: oLocalSpace 2
 974: oInputChoice 1041
 976: oCall 2869
 978: oJumpForward 1054
 980: oCall 2941
 982: oJumpForward 1054
 984: oSetResult 17
 986: oPushResult
 987: oCall 3000
 989: oPop 1
 991: oJumpForward 1054
 993: oGetAddrLocal 1
 995: oPushResult
 996: oCall 1827
 998: oAssign
 999: oInputChoice 1012
1001: oGetLocal 1
1003: oPushResult
1004: oCall 1765
1006: oPop 1
1008: oInput 4
1010: oJumpForward 1015
1012: Choice Lookup Table
          65   1001
1015: oJumpForward 1054
1017: oGetAddrLocal 2
1019: oPushResult
1020: oCall 2204
1022: oAssign
1023: oInputChoice 1036
1025: oGetLocal 2
1027: oPushResult
1028: oCall 1765
1030: oPop 1
1032: oInput 4
1034: oJumpForward 1039
1036: Choice Lookup Table
          65   1025
1039: oJumpForward 1054
1041: Choice Lookup Table
          29   1017
          28    993
          32    984
          31    980
          30    976
1052: oJumpForward 1056
1054: oJumpBack 974
1056: oReturn
1057: oLocalSpace 0
1059: oSetResult 17
1061: oPushResult
1062: oCall 1369
1064: oPop 1
1066: oReturn
1067: oLocalSpace 5
1069: oGetAddrLocal 1
1071: oPushResult
1072: oLabelNew
1073: oAssign
1074: oEmit 56
1076: oGetLocal 1
1078: oPushResult
1079: oEmitLabel
1080: oPop 1
1082: oGetParam 2
1084: oPushResult
1085: oSetResult 11
1087: oPushResult
1088: oGetLocal 1
1090: oPushResult
1091: oNodeSetLabel
1092: oPop 3
1094: oEmit 52
1096: oGetAddrLocal 2
1098: oPushResult
1099: Here
1100: oAssign
1101: oEmit 64
1103: oGetAddrLocal 3
1105: oPushResult
1106: oGetParam 2
1108: oPushResult
1109: oSetResult 9
1111: oPushResult
1112: oNodeGet
1113: oPop 2
1115: oAssign
1116: oGetAddrLocal 4
1118: oPushResult
1119: oGetLocal 3
1121: oPushResult
1122: oSetResult 19
1124: oPushResult
1125: oNodeGetCode
1126: oPop 2
1128: oAssign
1129: oGetLocal 4
1131: oPushResult
1132: oEmitCode
1133: oPop 1
1135: oGetLocal 3
1137: oPushResult
1138: oSetResult 19
1140: oPushResult
1141: oSetResult 0
1143: oPushResult
1144: oNodeSetCode
1145: oPop 3
1147: oGetAddrLocal 3
1149: oPushResult
1150: oGetParam 2
1152: oPushResult
1153: oSetResult 10
1155: oPushResult
1156: oNodeGet
1157: oPop 2
1159: oAssign
1160: oGetAddrLocal 4
1162: oPushResult
1163: oGetLocal 3
1165: oPushResult
1166: oSetResult 19
1168: oPushResult
1169: oNodeGetCode
1170: oPop 2
1172: oAssign
1173: oGetLocal 4
1175: oPushResult
1176: oEmitCode
1177: oPop 1
1179: oGetLocal 3
1181: oPushResult
1182: oSetResult 19
1184: oPushResult
1185: oSetResult 0
1187: oPushResult
1188: oNodeSetCode
1189: oPop 3
1191: oGetParam 2
1193: oPushResult
1194: oSetResult 13
1196: oPushResult
1197: oNodeGet
1198: oPop 2
1200: oPushResult
1201: oScopeEnter
1202: oPop 1
1204: oGetParam 1
1206: oChoice 1225
1208: oCall 6804
1210: oInputChoice 1216
1212: oCall 6804
1214: oJumpForward 1221
1216: Choice Lookup Table
           4   1212
1219: oJumpForward 1223
1221: oJumpBack 1210
1223: oJumpForward 1228
1225: Choice Lookup Table
           1   1208
1228: oEmit 51
1230: oGetAddrLocal 5
1232: oPushResult
1233: oScopeCurrent
1234: oPushResult
1235: oSetResult 17
1237: oPushResult
1238: oNodeGetInt
1239: oPop 2
1241: oAssign
1242: oGetLocal 2
1244: oPushResult
1245: oGetLocal 5
1247: oPushResult
1248: oPatch
1249: oPop 2
1251: oScopeEnd
1252: oReturn
1253: oLocalSpace 3
1255: oGetAddrLocal 1
1257: oPushResult
1258: oLabelNew
1259: oAssign
1260: oEmit 56
1262: oGetLocal 1
1264: oPushResult
1265: oEmitLabel
1266: oPop 1
1268: oGetParam 2
1270: oPushResult
1271: oSetResult 12
1273: oPushResult
1274: oGetLocal 1
1276: oPushResult
1277: oNodeSetLabel
1278: oPop 3
1280: oEmit 52
1282: oGetAddrLocal 2
1284: oPushResult
1285: Here
1286: oAssign
1287: oEmit 64
1289: oSetResult 0
1291: oPushResult
1292: oSetResult 1
1294: oPushResult
1295: oScopeBegin
1296: oPop 2
1298: oGetParam 1
1300: oChoice 1319
1302: oCall 6804
1304: oInputChoice 1310
1306: oCall 6804
1308: oJumpForward 1315
1310: Choice Lookup Table
           4   1306
1313: oJumpForward 1317
1315: oJumpBack 1304
1317: oJumpForward 1322
1319: Choice Lookup Table
           1   1302
1322: oEmit 51
1324: oGetAddrLocal 3
1326: oPushResult
1327: oScopeCurrent
1328: oPushResult
1329: oSetResult 17
1331: oPushResult
1332: oNodeGetInt
1333: oPop 2
1335: oAssign
1336: oGetLocal 2
1338: oPushResult
1339: oGetLocal 3
1341: oPushResult
1342: oPatch
1343: oPop 2
1345: oScopeEnd
1346: oReturn
1347: oLocalSpace 0
1349: oGetParam 2
1351: oPushResult
1352: oCall 1369
1354: oPop 1
1356: oGetParam 1
1358: oPushResult
1359: oScopeCurrent
1360: oPushResult
1361: oSetResult 0
1363: oPushResult
1364: oCall 1589
1366: oPop 3
1368: oReturn
1369: oLocalSpace 0
1371: oInputChoice 1398
1373: oCall 2869
1375: oJumpForward 1411
1377: oCall 2941
1379: oJumpForward 1411
1381: oGetParam 1
1383: oPushResult
1384: oCall 3000
1386: oPop 1
1388: oJumpForward 1411
1390: oCall 2086
1392: oJumpForward 1411
1394: oCall 2524
1396: oJumpForward 1411
1398: Choice Lookup Table
          29   1394
          28   1390
          32   1381
          31   1377
          30   1373
1409: oJumpForward 1413
1411: oJumpBack 1371
1413: oCall 1416
1415: oReturn
1416: oLocalSpace 0
1418: oReturn
1419: oLocalSpace 2
1421: oGetAddrLocal 1
1423: oPushResult
1424: oGetGlobal 1
1426: oPushResult
1427: oSetResult 1
1429: oPushResult
1430: oNodeGetIter
1431: oPop 2
1433: oAssign
1434: oGetAddrLocal 2
1436: oPushResult
1437: oGetLocal 1
1439: oPushResult
1440: oNodeIterValue
1441: oPop 1
1443: oAssign
1444: oGetLocal 2
1446: oPushResult
1447: oNodeNull
1448: oPop 1
1450: oChoice 1495
1452: oJumpForward 1503
1454: oJumpForward 1501
1456: oEmit 46
1458: oSetResult 0
1460: oPushResult
1461: oEmitInt
1462: oPop 1
1464: oEmit 49
1466: oGetLocal 2
1468: oPushResult
1469: oSetResult 11
1471: oPushResult
1472: oNodeGetLabel
1473: oPop 2
1475: oPushResult
1476: oEmitLabel
1477: oPop 1
1479: oEmit 48
1481: oSetResult 0
1483: oPushResult
1484: oEmitInt
1485: oPop 1
1487: oGetAddrLocal 1
1489: oPushResult
1490: oNodeIterNext
1491: oPop 1
1493: oJumpForward 1501
1495: Choice Lookup Table
           0   1456
           1   1452
1500: oEndChoice
1501: oJumpBack 1434
1503: oReturn
1504: oLocalSpace 2
1506: oGetAddrLocal 1
1508: oPushResult
1509: oGetGlobal 1
1511: oPushResult
1512: oSetResult 1
1514: oPushResult
1515: oNodeGetIterLast
1516: oPop 2
1518: oAssign
1519: oGetAddrLocal 2
1521: oPushResult
1522: oGetLocal 1
1524: oPushResult
1525: oNodeIterValue
1526: oPop 1
1528: oAssign
1529: oGetLocal 2
1531: oPushResult
1532: oNodeNull
1533: oPop 1
1535: oChoice 1580
1537: oJumpForward 1588
1539: oJumpForward 1586
1541: oEmit 46
1543: oSetResult 0
1545: oPushResult
1546: oEmitInt
1547: oPop 1
1549: oEmit 49
1551: oGetLocal 2
1553: oPushResult
1554: oSetResult 12
1556: oPushResult
1557: oNodeGetLabel
1558: oPop 2
1560: oPushResult
1561: oEmitLabel
1562: oPop 1
1564: oEmit 48
1566: oSetResult 0
1568: oPushResult
1569: oEmitInt
1570: oPop 1
1572: oGetAddrLocal 1
1574: oPushResult
1575: oNodeIterPrev
1576: oPop 1
1578: oJumpForward 1586
1580: Choice Lookup Table
           0   1541
           1   1537
1585: oEndChoice
1586: oJumpBack 1519
1588: oReturn
1589: oLocalSpace 3
1591: oEmit 56
1593: oGetParam 3
1595: oPushResult
1596: oEmitLabel
1597: oPop 1
1599: oEmit 52
1601: oGetAddrLocal 1
1603: oPushResult
1604: Here
1605: oAssign
1606: oEmit 64
1608: oGetParam 1
1610: oChoice 1616
1612: oCall 1419
1614: oJumpForward 1619
1616: Choice Lookup Table
           1   1612
1619: oGetAddrLocal 2
1621: oPushResult
1622: oGetParam 2
1624: oPushResult
1625: oSetResult 19
1627: oPushResult
1628: oNodeGetCode
1629: oPop 2
1631: oAssign
1632: oGetLocal 2
1634: oPushResult
1635: oEmitCode
1636: oPop 1
1638: oGetParam 2
1640: oPushResult
1641: oSetResult 19
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: oNodeSetCode
1648: oPop 3
1650: oCall 6804
1652: oGetParam 1
1654: oChoice 1660
1656: oCall 1504
1658: oJumpForward 1663
1660: Choice Lookup Table
           1   1656
1663: oEmit 51
1665: oGetAddrLocal 3
1667: oPushResult
1668: oScopeCurrent
1669: oPushResult
1670: oSetResult 17
1672: oPushResult
1673: oNodeGetInt
1674: oPop 2
1676: oAssign
1677: oGetLocal 1
1679: oPushResult
1680: oGetLocal 3
1682: oPushResult
1683: oPatch
1684: oPop 2
1686: oReturn
1687: oLocalSpace 0
1689: oInputChoice 1707
1691: oGetParam 1
1693: oPushResult
1694: oSetResult 27
1696: oPushResult
1697: oSetResult 1
1699: oPushResult
1700: oNodeSetBoolean
1701: oPop 3
1703: oInput 4
1705: oJumpForward 1712
1707: Choice Lookup Table
          67   1691
1710: oJumpForward 1714
1712: oJumpBack 1689
1714: oReturn
1715: oLocalSpace 1
1717: oGetAddrLocal 1
1719: oPushResult
1720: oScopeCurrent
1721: oPushResult
1722: oSetResult 19
1724: oPushResult
1725: oNodeGetCode
1726: oPop 2
1728: oAssign
1729: oGetLocal 1
1731: oPushResult
1732: oSetResult 0
1734: oPushResult
1735: equal_code
1736: oPop 2
1738: oChoice 1758
1740: oGetAddrLocal 1
1742: oPushResult
1743: oCodeNew
1744: oAssign
1745: oScopeCurrent
1746: oPushResult
1747: oSetResult 19
1749: oPushResult
1750: oGetLocal 1
1752: oPushResult
1753: oNodeSetCode
1754: oPop 3
1756: oJumpForward 1761
1758: Choice Lookup Table
           1   1740
1761: oGetLocal 1
1763: oReturn
1764: oReturn
1765: oLocalSpace 0
1767: oGetParam 1
1769: oPushResult
1770: oCall 7869
1772: oPop 1
1774: oPushResult
1775: equal_zero
1776: oPop 1
1778: oChoice 1784
1780: oError 23
1782: oJumpForward 1787
1784: Choice Lookup Table
           0   1780
1787: oGetParam 1
1789: oPushResult
1790: oSetResult 25
1792: oPushResult
1793: oSetResult 1
1795: oPushResult
1796: oNodeSetBoolean
1797: oPop 3
1799: oInputChoice 1823
1801: oInputChoice 1818
1803: oInput 2
1805: oGetParam 1
1807: oPushResult
1808: oSetResult 26
1810: oPushResult
1811: CURRENT_STRLIT
1812: oPushResult
1813: oNodeSetString
1814: oPop 3
1816: oJumpForward 1821
1818: Choice Lookup Table
          66   1803
1821: oJumpForward 1826
1823: Choice Lookup Table
           2   1801
1826: oReturn
1827: oLocalSpace 6
1829: oInput 0
1831: oGetAddrLocal 1
1833: oPushResult
1834: oSetResult 0
1836: oAssign
1837: oGetAddrLocal 2
1839: oPushResult
1840: oScopeFindInCurrentScope
1841: oAssign
1842: oGetLocal 2
1844: oPushResult
1845: oNodeNull
1846: oPop 1
1848: oChoice 1969
1850: oGetAddrLocal 2
1852: oPushResult
1853: oSetResult 12
1855: oPushResult
1856: oSetResult 2
1858: oPushResult
1859: LAST_ID
1860: oPushResult
1861: oCall 8021
1863: oPop 3
1865: oAssign
1866: oGetLocal 2
1868: oPushResult
1869: oSetResult 22
1871: oPushResult
1872: oLabelNew
1873: oPushResult
1874: oNodeSetLabel
1875: oPop 3
1877: oJumpForward 1975
1879: oGetAddrLocal 1
1881: oPushResult
1882: oSetResult 1
1884: oAssign
1885: oGetLocal 2
1887: oPushResult
1888: oSetResult 24
1890: oPushResult
1891: oNodeGetBoolean
1892: oPop 2
1894: oChoice 1900
1896: oError 21
1898: oJumpForward 1903
1900: Choice Lookup Table
           1   1896
1903: oGetLocal 2
1905: oPushResult
1906: oSetResult 25
1908: oPushResult
1909: oNodeGetBoolean
1910: oPop 2
1912: oChoice 1918
1914: oError 21
1916: oJumpForward 1921
1918: Choice Lookup Table
           1   1914
1921: oGetLocal 2
1923: oPushResult
1924: oNodeType
1925: oPop 1
1927: oChoice 1931
1929: oJumpForward 1936
1931: Choice Lookup Table
          12   1929
1934: oError 21
1936: oGetLocal 2
1938: oPushResult
1939: oSetResult 29
1941: oPushResult
1942: oGetLocal 2
1944: oPushResult
1945: oSetResult 23
1947: oPushResult
1948: oNodeGet
1949: oPop 2
1951: oPushResult
1952: oNodeSet
1953: oPop 3
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oSetResult 0
1963: oPushResult
1964: oNodeSet
1965: oPop 3
1967: oJumpForward 1975
1969: Choice Lookup Table
           0   1879
           1   1850
1974: oEndChoice
1975: oGetAddrLocal 3
1977: oPushResult
1978: oCall 7857
1980: oAssign
1981: oGetAddrLocal 4
1983: oPushResult
1984: oGetLocal 3
1986: oPushResult
1987: oSetResult 0
1989: oPushResult
1990: greater
1991: oPop 2
1993: oAssign
1994: oGetAddrLocal 3
1996: oPushResult
1997: inc
1998: oPop 1
2000: oGetLocal 3
2002: oPushResult
2003: oSetResult 2
2005: oPushResult
2006: oScopeBegin
2007: oPop 2
2009: oGetAddrLocal 5
2011: oPushResult
2012: oScopeCurrent
2013: oAssign
2014: oGetLocal 4
2016: oChoice 2035
2018: oGetAddrLocal 6
2020: oPushResult
2021: oGetGlobal 4
2023: oPushResult
2024: oCall 8049
2026: oPop 1
2028: oPushResult
2029: oScopeAllocType
2030: oPop 1
2032: oAssign
2033: oJumpForward 2038
2035: Choice Lookup Table
           1   2018
2038: oCall 2642
2040: oGetLocal 2
2042: oPushResult
2043: oSetResult 23
2045: oPushResult
2046: oGetLocal 5
2048: oPushResult
2049: oNodeSet
2050: oPop 3
2052: oScopeEnd
2053: oInput 4
2055: oGetLocal 1
2057: oChoice 2069
2059: oGetLocal 2
2061: oPushResult
2062: oScopeDeclare
2063: oPop 1
2065: oJumpForward 2075
2067: oJumpForward 2075
2069: Choice Lookup Table
           1   2067
           0   2059
2074: oEndChoice
2075: oGetLocal 2
2077: oPushResult
2078: oCall 1687
2080: oPop 1
2082: oGetLocal 2
2084: oReturn
2085: oReturn
2086: oLocalSpace 4
2088: oGetAddrLocal 1
2090: oPushResult
2091: oCall 1827
2093: oAssign
2094: oInputChoice 2107
2096: oJumpForward 2201
2098: oGetLocal 1
2100: oPushResult
2101: oCall 1765
2103: oPop 1
2105: oJumpForward 2201
2107: Choice Lookup Table
          65   2098
          64   2096
2112: oGetAddrLocal 2
2114: oPushResult
2115: oGetLocal 1
2117: oPushResult
2118: oSetResult 23
2120: oPushResult
2121: oNodeGet
2122: oPop 2
2124: oAssign
2125: oGetLocal 2
2127: oPushResult
2128: oScopeEnter
2129: oPop 1
2131: oGetAddrLocal 3
2133: oPushResult
2134: oGetLocal 2
2136: oPushResult
2137: oSetResult 14
2139: oPushResult
2140: oNodeGetInt
2141: oPop 2
2143: oAssign
2144: oGetLocal 3
2146: oPushResult
2147: oSetResult 1
2149: oPushResult
2150: oScopeBegin
2151: oPop 2
2153: oGetLocal 1
2155: oPushResult
2156: oSetResult 6
2158: oPushResult
2159: oScopeCurrent
2160: oPushResult
2161: oNodeSet
2162: oPop 3
2164: oGetAddrLocal 4
2166: oPushResult
2167: oGetLocal 1
2169: oPushResult
2170: oSetResult 22
2172: oPushResult
2173: oNodeGetLabel
2174: oPop 2
2176: oAssign
2177: oSetResult 18
2179: oPushResult
2180: oGetLocal 4
2182: oPushResult
2183: oCall 1347
2185: oPop 2
2187: oGetLocal 1
2189: oPushResult
2190: oSetResult 24
2192: oPushResult
2193: oSetResult 1
2195: oPushResult
2196: oNodeSetBoolean
2197: oPop 3
2199: oScopeEnd
2200: oScopeEnd
2201: oInput 4
2203: oReturn
2204: oLocalSpace 8
2206: oInput 0
2208: oGetAddrLocal 1
2210: oPushResult
2211: oSetResult 0
2213: oAssign
2214: oGetAddrLocal 2
2216: oPushResult
2217: oScopeFindInCurrentScope
2218: oAssign
2219: oGetLocal 2
2221: oPushResult
2222: oNodeNull
2223: oPop 1
2225: oChoice 2359
2227: oGetAddrLocal 2
2229: oPushResult
2230: oSetResult 13
2232: oPushResult
2233: oSetResult 3
2235: oPushResult
2236: LAST_ID
2237: oPushResult
2238: oCall 8021
2240: oPop 3
2242: oAssign
2243: oGetLocal 2
2245: oPushResult
2246: oSetResult 22
2248: oPushResult
2249: oLabelNew
2250: oPushResult
2251: oNodeSetLabel
2252: oPop 3
2254: oJumpForward 2365
2256: oGetAddrLocal 1
2258: oPushResult
2259: oSetResult 1
2261: oAssign
2262: oGetLocal 2
2264: oPushResult
2265: oSetResult 24
2267: oPushResult
2268: oNodeGetBoolean
2269: oPop 2
2271: oChoice 2277
2273: oError 21
2275: oJumpForward 2280
2277: Choice Lookup Table
           1   2273
2280: oGetLocal 2
2282: oPushResult
2283: oNodeType
2284: oPop 1
2286: oChoice 2290
2288: oJumpForward 2295
2290: Choice Lookup Table
          13   2288
2293: oError 21
2295: oGetLocal 2
2297: oPushResult
2298: oSetResult 29
2300: oPushResult
2301: oGetLocal 2
2303: oPushResult
2304: oSetResult 23
2306: oPushResult
2307: oNodeGet
2308: oPop 2
2310: oPushResult
2311: oNodeSet
2312: oPop 3
2314: oGetLocal 2
2316: oPushResult
2317: oSetResult 23
2319: oPushResult
2320: oSetResult 0
2322: oPushResult
2323: oNodeSet
2324: oPop 3
2326: oGetLocal 2
2328: oPushResult
2329: oSetResult 30
2331: oPushResult
2332: oGetLocal 2
2334: oPushResult
2335: oSetResult 21
2337: oPushResult
2338: oNodeGet
2339: oPop 2
2341: oPushResult
2342: oNodeSet
2343: oPop 3
2345: oGetLocal 2
2347: oPushResult
2348: oSetResult 21
2350: oPushResult
2351: oSetResult 0
2353: oPushResult
2354: oNodeSet
2355: oPop 3
2357: oJumpForward 2365
2359: Choice Lookup Table
           0   2256
           1   2227
2364: oEndChoice
2365: oGetAddrLocal 3
2367: oPushResult
2368: oCall 7857
2370: oAssign
2371: oGetAddrLocal 4
2373: oPushResult
2374: oGetLocal 3
2376: oPushResult
2377: oSetResult 0
2379: oPushResult
2380: greater
2381: oPop 2
2383: oAssign
2384: oGetAddrLocal 3
2386: oPushResult
2387: inc
2388: oPop 1
2390: oGetLocal 3
2392: oPushResult
2393: oSetResult 2
2395: oPushResult
2396: oScopeBegin
2397: oPop 2
2399: oGetAddrLocal 5
2401: oPushResult
2402: oScopeCurrent
2403: oAssign
2404: oGetLocal 4
2406: oChoice 2425
2408: oGetAddrLocal 6
2410: oPushResult
2411: oGetGlobal 4
2413: oPushResult
2414: oCall 8049
2416: oPop 1
2418: oPushResult
2419: oScopeAllocType
2420: oPop 1
2422: oAssign
2423: oJumpForward 2428
2425: Choice Lookup Table
           1   2408
2428: oCall 2642
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oGetLocal 5
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oInput 11
2444: oGetAddrLocal 7
2446: oPushResult
2447: oCall 3230
2449: oPop 1
2451: oGetLocal 2
2453: oPushResult
2454: oSetResult 21
2456: oPushResult
2457: oGetLocal 7
2459: oPushResult
2460: oNodeSet
2461: oPop 3
2463: oGetAddrLocal 8
2465: oPushResult
2466: oGetLocal 7
2468: oPushResult
2469: oCall 8049
2471: oPop 1
2473: oAssign
2474: oGetLocal 2
2476: oPushResult
2477: oSetResult 31
2479: oPushResult
2480: oGetLocal 8
2482: oPushResult
2483: oScopeAllocType
2484: oPop 1
2486: oPushResult
2487: oNodeSetInt
2488: oPop 3
2490: oScopeEnd
2491: oInput 4
2493: oGetLocal 1
2495: oChoice 2507
2497: oGetLocal 2
2499: oPushResult
2500: oScopeDeclare
2501: oPop 1
2503: oJumpForward 2513
2505: oJumpForward 2513
2507: Choice Lookup Table
           1   2505
           0   2497
2512: oEndChoice
2513: oGetLocal 2
2515: oPushResult
2516: oCall 1687
2518: oPop 1
2520: oGetLocal 2
2522: oReturn
2523: oReturn
2524: oLocalSpace 4
2526: oGetAddrLocal 1
2528: oPushResult
2529: oCall 2204
2531: oAssign
2532: oInputChoice 2545
2534: oJumpForward 2639
2536: oGetLocal 1
2538: oPushResult
2539: oCall 1765
2541: oPop 1
2543: oJumpForward 2639
2545: Choice Lookup Table
          65   2536
          64   2534
2550: oGetAddrLocal 2
2552: oPushResult
2553: oGetLocal 1
2555: oPushResult
2556: oSetResult 23
2558: oPushResult
2559: oNodeGet
2560: oPop 2
2562: oAssign
2563: oGetLocal 2
2565: oPushResult
2566: oScopeEnter
2567: oPop 1
2569: oGetAddrLocal 3
2571: oPushResult
2572: oGetLocal 2
2574: oPushResult
2575: oSetResult 14
2577: oPushResult
2578: oNodeGetInt
2579: oPop 2
2581: oAssign
2582: oGetLocal 3
2584: oPushResult
2585: oSetResult 1
2587: oPushResult
2588: oScopeBegin
2589: oPop 2
2591: oGetLocal 1
2593: oPushResult
2594: oSetResult 6
2596: oPushResult
2597: oScopeCurrent
2598: oPushResult
2599: oNodeSet
2600: oPop 3
2602: oGetAddrLocal 4
2604: oPushResult
2605: oGetLocal 1
2607: oPushResult
2608: oSetResult 22
2610: oPushResult
2611: oNodeGetLabel
2612: oPop 2
2614: oAssign
2615: oSetResult 18
2617: oPushResult
2618: oGetLocal 4
2620: oPushResult
2621: oCall 1347
2623: oPop 2
2625: oGetLocal 1
2627: oPushResult
2628: oSetResult 24
2630: oPushResult
2631: oSetResult 1
2633: oPushResult
2634: oNodeSetBoolean
2635: oPop 3
2637: oScopeEnd
2638: oScopeEnd
2639: oInput 4
2641: oReturn
2642: oLocalSpace 6
2644: oInputChoice 2865
2646: oGetAddrLocal 1
2648: oPushResult
2649: oNodeVecNew
2650: oAssign
2651: oGetAddrLocal 3
2653: oPushResult
2654: oSetResult 0
2656: oAssign
2657: oInputChoice 2667
2659: oGetAddrLocal 3
2661: oPushResult
2662: oSetResult 1
2664: oAssign
2665: oJumpForward 2670
2667: Choice Lookup Table
          32   2659
2670: oInput 0
2672: oGetAddrLocal 2
2674: oPushResult
2675: oSetResult 20
2677: oPushResult
2678: oSetResult 6
2680: oPushResult
2681: LAST_ID
2682: oPushResult
2683: oCall 8021
2685: oPop 3
2687: oAssign
2688: oGetLocal 2
2690: oPushResult
2691: oSetResult 32
2693: oPushResult
2694: oGetLocal 3
2696: oPushResult
2697: oNodeSetBoolean
2698: oPop 3
2700: oGetLocal 1
2702: oPushResult
2703: oGetLocal 2
2705: oPushResult
2706: oNodeVecAppend
2707: oPop 2
2709: oInputChoice 2717
2711: oJumpForward 2725
2713: oJumpForward 2723
2715: oJumpForward 2723
2717: Choice Lookup Table
          12   2715
          11   2711
2722: oEndChoice
2723: oJumpBack 2670
2725: oGetAddrLocal 4
2727: oPushResult
2728: oCall 3230
2730: oPop 1
2732: oGetLocal 3
2734: oChoice 2749
2736: oGetAddrLocal 5
2738: oPushResult
2739: oGetLocal 4
2741: oPushResult
2742: oCall 8049
2744: oPop 1
2746: oAssign
2747: oJumpForward 2758
2749: Choice Lookup Table
           1   2736
2752: oGetAddrLocal 5
2754: oPushResult
2755: oGetLocal 4
2757: oAssign
2758: oGetAddrLocal 6
2760: oPushResult
2761: oSetResult 0
2763: oAssign
2764: oGetLocal 6
2766: oPushResult
2767: oGetLocal 1
2769: oPushResult
2770: oNodeVecSize
2771: oPop 1
2773: oPushResult
2774: equal
2775: oPop 2
2777: oChoice 2834
2779: oGetAddrLocal 2
2781: oPushResult
2782: oGetLocal 1
2784: oPushResult
2785: oGetLocal 6
2787: oPushResult
2788: oNodeVecElement
2789: oPop 2
2791: oAssign
2792: oGetLocal 2
2794: oPushResult
2795: oSetResult 21
2797: oPushResult
2798: oGetLocal 4
2800: oPushResult
2801: oNodeSet
2802: oPop 3
2804: oGetLocal 2
2806: oPushResult
2807: oScopeDeclare
2808: oPop 1
2810: oGetLocal 2
2812: oPushResult
2813: oSetResult 22
2815: oPushResult
2816: oGetLocal 5
2818: oPushResult
2819: oScopeAllocType
2820: oPop 1
2822: oPushResult
2823: oNodeSetInt
2824: oPop 3
2826: oGetAddrLocal 6
2828: oPushResult
2829: inc
2830: oPop 1
2832: oJumpForward 2839
2834: Choice Lookup Table
           0   2779
2837: oJumpForward 2841
2839: oJumpBack 2764
2841: oGetLocal 1
2843: oPushResult
2844: oNodeVecDelete
2845: oPop 1
2847: oInputChoice 2855
2849: oJumpForward 2863
2851: oJumpForward 2861
2853: oJumpForward 2861
2855: Choice Lookup Table
           4   2853
          14   2849
2860: oEndChoice
2861: oJumpBack 2646
2863: oJumpForward 2868
2865: Choice Lookup Table
          13   2646
2868: oReturn
2869: oLocalSpace 2
2871: oInputChoice 2933
2873: oGetAddrLocal 1
2875: oPushResult
2876: oSetResult 14
2878: oPushResult
2879: oSetResult 4
2881: oPushResult
2882: LAST_ID
2883: oPushResult
2884: oCall 8021
2886: oPop 3
2888: oAssign
2889: oInput 5
2891: oCall 3714
2893: oGetAddrLocal 2
2895: oPushResult
2896: oValueTop
2897: oAssign
2898: oValuePop
2899: oGetLocal 1
2901: oPushResult
2902: oSetResult 22
2904: oPushResult
2905: oGetLocal 2
2907: oPushResult
2908: oNodeSetInt
2909: oPop 3
2911: oGetLocal 1
2913: oPushResult
2914: oSetResult 21
2916: oPushResult
2917: oGetGlobal 4
2919: oPushResult
2920: oNodeSet
2921: oPop 3
2923: oGetLocal 1
2925: oPushResult
2926: oScopeDeclare
2927: oPop 1
2929: oInput 4
2931: oJumpForward 2938
2933: Choice Lookup Table
           0   2873
2936: oJumpForward 2940
2938: oJumpBack 2871
2940: oReturn
2941: oLocalSpace 2
2943: oInputChoice 2992
2945: oGetAddrLocal 1
2947: oPushResult
2948: oSetResult 15
2950: oPushResult
2951: oSetResult 5
2953: oPushResult
2954: LAST_ID
2955: oPushResult
2956: oCall 8021
2958: oPop 3
2960: oAssign
2961: oInput 5
2963: oGetAddrLocal 2
2965: oPushResult
2966: oCall 3230
2968: oPop 1
2970: oGetLocal 1
2972: oPushResult
2973: oSetResult 21
2975: oPushResult
2976: oGetLocal 2
2978: oPushResult
2979: oNodeSet
2980: oPop 3
2982: oGetLocal 1
2984: oPushResult
2985: oScopeDeclare
2986: oPop 1
2988: oInput 4
2990: oJumpForward 2997
2992: Choice Lookup Table
           0   2945
2995: oJumpForward 2999
2997: oJumpBack 2943
2999: oReturn
3000: oLocalSpace 6
3002: oInputChoice 3222
3004: oGetAddrLocal 1
3006: oPushResult
3007: oNodeVecNew
3008: oAssign
3009: oGetAddrLocal 2
3011: oPushResult
3012: oGetParam 1
3014: oPushResult
3015: oSetResult 6
3017: oPushResult
3018: LAST_ID
3019: oPushResult
3020: oCall 8021
3022: oPop 3
3024: oAssign
3025: oGetLocal 1
3027: oPushResult
3028: oGetLocal 2
3030: oPushResult
3031: oNodeVecAppend
3032: oPop 2
3034: oInputChoice 3040
3036: oInput 0
3038: oJumpForward 3045
3040: Choice Lookup Table
          12   3036
3043: oJumpForward 3047
3045: oJumpBack 3009
3047: oInput 11
3049: oGetAddrLocal 3
3051: oPushResult
3052: oCall 3230
3054: oPop 1
3056: oGetAddrLocal 4
3058: oPushResult
3059: oSetResult 0
3061: oAssign
3062: oGetLocal 4
3064: oPushResult
3065: oGetLocal 1
3067: oPushResult
3068: oNodeVecSize
3069: oPop 1
3071: oPushResult
3072: equal
3073: oPop 2
3075: oChoice 3116
3077: oGetAddrLocal 2
3079: oPushResult
3080: oGetLocal 1
3082: oPushResult
3083: oGetLocal 4
3085: oPushResult
3086: oNodeVecElement
3087: oPop 2
3089: oAssign
3090: oGetLocal 2
3092: oPushResult
3093: oSetResult 21
3095: oPushResult
3096: oGetLocal 3
3098: oPushResult
3099: oNodeSet
3100: oPop 3
3102: oGetLocal 2
3104: oPushResult
3105: oScopeDeclareAlloc
3106: oPop 1
3108: oGetAddrLocal 4
3110: oPushResult
3111: inc
3112: oPop 1
3114: oJumpForward 3121
3116: Choice Lookup Table
           0   3077
3119: oJumpForward 3123
3121: oJumpBack 3062
3123: oInputChoice 3209
3125: oGetLocal 1
3127: oPushResult
3128: oNodeVecSize
3129: oPop 1
3131: oChoice 3135
3133: oJumpForward 3140
3135: Choice Lookup Table
           1   3133
3138: oError 22
3140: oGetAddrLocal 5
3142: oPushResult
3143: oCall 1715
3145: oAssign
3146: oGetLocal 5
3148: oPushResult
3149: oCodePush
3150: oPop 1
3152: oGetAddrLocal 6
3154: oPushResult
3155: oSetResult 0
3157: oAssign
3158: oCall 7857
3160: oPushResult
3161: equal_zero
3162: oPop 1
3164: oChoice 3180
3166: oGetGlobal 2
3168: oPushResult
3169: oScopeEnter
3170: oPop 1
3172: oGetAddrLocal 6
3174: oPushResult
3175: oSetResult 1
3177: oAssign
3178: oJumpForward 3183
3180: Choice Lookup Table
           1   3166
3183: oGetLocal 2
3185: oPushResult
3186: oCall 7176
3188: oPop 1
3190: oCall 3787
3192: oCall 7907
3194: oCall 6963
3196: oGetLocal 6
3198: oChoice 3203
3200: oScopeEnd
3201: oJumpForward 3206
3203: Choice Lookup Table
           1   3200
3206: oCodePop
3207: oJumpForward 3212
3209: Choice Lookup Table
           5   3125
3212: oGetLocal 1
3214: oPushResult
3215: oNodeVecDelete
3216: oPop 1
3218: oInput 4
3220: oJumpForward 3227
3222: Choice Lookup Table
           0   3004
3225: oJumpForward 3229
3227: oJumpBack 3002
3229: oReturn
3230: oLocalSpace 12
3232: oInputChoice 3696
3234: oGetAddrLocal 1
3236: oPushResult
3237: oScopeFindRequire
3238: oAssign
3239: oGetAddrLocal 1
3241: oPushResult
3242: oCall 402
3244: oPop 1
3246: oGetLocal 1
3248: oPushResult
3249: oNodeType
3250: oPop 1
3252: oChoice 3269
3254: oGetParam 1
3256: oPushResult
3257: oGetLocal 1
3259: oPushResult
3260: oSetResult 21
3262: oPushResult
3263: oNodeGet
3264: oPop 2
3266: oAssign
3267: oJumpForward 3280
3269: Choice Lookup Table
          15   3254
3272: oError 2
3274: oGetParam 1
3276: oPushResult
3277: oGetGlobal 4
3279: oAssign
3280: oJumpForward 3713
3282: oInput 15
3284: oGetAddrLocal 2
3286: oPushResult
3287: oNodeVecNew
3288: oAssign
3289: oGetAddrLocal 3
3291: oPushResult
3292: oSetResult 30
3294: oPushResult
3295: oNodeNew
3296: oPop 1
3298: oAssign
3299: oGetLocal 3
3301: oPushResult
3302: oSetResult 34
3304: oPushResult
3305: oGetGlobal 4
3307: oPushResult
3308: oNodeSet
3309: oPop 3
3311: oCall 3714
3313: oGetLocal 3
3315: oPushResult
3316: oSetResult 36
3318: oPushResult
3319: oValueTop
3320: oPushResult
3321: oNodeSetInt
3322: oPop 3
3324: oValuePop
3325: oInput 20
3327: oCall 3714
3329: oGetLocal 3
3331: oPushResult
3332: oSetResult 37
3334: oPushResult
3335: oValueTop
3336: oPushResult
3337: oNodeSetInt
3338: oPop 3
3340: oValuePop
3341: oGetLocal 3
3343: oPushResult
3344: oSetResult 17
3346: oPushResult
3347: oSetResult 4
3349: oPushResult
3350: oNodeSetInt
3351: oPop 3
3353: oGetLocal 3
3355: oPushResult
3356: oTypeAdd
3357: oPop 1
3359: oGetAddrLocal 4
3361: oPushResult
3362: oSetResult 29
3364: oPushResult
3365: oNodeNew
3366: oPop 1
3368: oAssign
3369: oGetLocal 4
3371: oPushResult
3372: oSetResult 35
3374: oPushResult
3375: oGetLocal 3
3377: oPushResult
3378: oNodeSet
3379: oPop 3
3381: oGetLocal 2
3383: oPushResult
3384: oGetLocal 4
3386: oPushResult
3387: oNodeVecAppend
3388: oPop 2
3390: oInputChoice 3398
3392: oJumpForward 3406
3394: oJumpForward 3404
3396: oJumpForward 3404
3398: Choice Lookup Table
          12   3396
          16   3392
3403: oEndChoice
3404: oJumpBack 3289
3406: oInput 38
3408: oGetAddrLocal 5
3410: oPushResult
3411: oCall 3230
3413: oPop 1
3415: oGetAddrLocal 6
3417: oPushResult
3418: oGetLocal 2
3420: oPushResult
3421: oNodeVecSize
3422: oPop 1
3424: oAssign
3425: oGetAddrLocal 6
3427: oPushResult
3428: dec
3429: oPop 1
3431: oGetAddrLocal 7
3433: oPushResult
3434: oGetLocal 2
3436: oPushResult
3437: oGetLocal 6
3439: oPushResult
3440: oNodeVecElement
3441: oPop 2
3443: oAssign
3444: oGetLocal 7
3446: oPushResult
3447: oSetResult 34
3449: oPushResult
3450: oGetLocal 5
3452: oPushResult
3453: oNodeSet
3454: oPop 3
3456: oGetAddrLocal 8
3458: oPushResult
3459: oGetLocal 7
3461: oPushResult
3462: oSetResult 35
3464: oPushResult
3465: oNodeGet
3466: oPop 2
3468: oAssign
3469: oGetAddrLocal 9
3471: oPushResult
3472: oGetLocal 8
3474: oPushResult
3475: oSetResult 37
3477: oPushResult
3478: oNodeGetInt
3479: oPop 2
3481: oPushResult
3482: oGetLocal 8
3484: oPushResult
3485: oSetResult 36
3487: oPushResult
3488: oNodeGetInt
3489: oPop 2
3491: oPushResult
3492: subtract
3493: oPop 2
3495: oAssign
3496: oGetAddrLocal 9
3498: oPushResult
3499: inc
3500: oPop 1
3502: oGetLocal 7
3504: oPushResult
3505: oSetResult 17
3507: oPushResult
3508: oGetLocal 9
3510: oPushResult
3511: oGetLocal 5
3513: oPushResult
3514: oSetResult 17
3516: oPushResult
3517: oNodeGetInt
3518: oPop 2
3520: oPushResult
3521: multiply
3522: oPop 2
3524: oPushResult
3525: oNodeSetInt
3526: oPop 3
3528: oGetLocal 7
3530: oPushResult
3531: oTypeAdd
3532: oPop 1
3534: oGetAddrLocal 5
3536: oPushResult
3537: oGetLocal 7
3539: oAssign
3540: oGetLocal 6
3542: oPushResult
3543: equal_zero
3544: oPop 1
3546: oChoice 3552
3548: oJumpForward 3557
3550: oJumpForward 3555
3552: Choice Lookup Table
           1   3548
3555: oJumpBack 3425
3557: oGetParam 1
3559: oPushResult
3560: oGetLocal 2
3562: oPushResult
3563: oSetResult 0
3565: oPushResult
3566: oNodeVecElement
3567: oPop 2
3569: oAssign
3570: oGetLocal 2
3572: oPushResult
3573: oNodeVecDelete
3574: oPop 1
3576: oJumpForward 3713
3578: oGetAddrLocal 10
3580: oPushResult
3581: oCall 3230
3583: oPop 1
3585: oGetParam 1
3587: oPushResult
3588: oGetLocal 10
3590: oPushResult
3591: oCall 8049
3593: oPop 1
3595: oAssign
3596: oJumpForward 3713
3598: oGetParam 1
3600: oPushResult
3601: oSetResult 31
3603: oPushResult
3604: oNodeNew
3605: oPop 1
3607: oAssign
3608: oSetResult -1
3610: oPushResult
3611: oSetResult 2
3613: oPushResult
3614: oScopeBegin
3615: oPop 2
3617: oSetResult 19
3619: oPushResult
3620: oCall 3000
3622: oPop 1
3624: oGetAddrLocal 11
3626: oPushResult
3627: oScopeCurrent
3628: oPushResult
3629: oSetResult 17
3631: oPushResult
3632: oNodeGetInt
3633: oPop 2
3635: oAssign
3636: oGetLocal 11
3638: oPushResult
3639: equal_zero
3640: oPop 1
3642: oChoice 3648
3644: oError 19
3646: oJumpForward 3651
3648: Choice Lookup Table
           1   3644
3651: oInput 34
3653: oGetFromParam 1
3655: oPushResult
3656: oSetResult 38
3658: oPushResult
3659: oScopeCurrent
3660: oPushResult
3661: oNodeSet
3662: oPop 3
3664: oGetFromParam 1
3666: oPushResult
3667: oSetResult 17
3669: oPushResult
3670: oGetLocal 11
3672: oPushResult
3673: oNodeSetInt
3674: oPop 3
3676: oScopeEnd
3677: oGetFromParam 1
3679: oPushResult
3680: oTypeAdd
3681: oPop 1
3683: oJumpForward 3713
3685: oInput 38
3687: oGetAddrLocal 12
3689: oPushResult
3690: oCall 3230
3692: oPop 1
3694: oJumpForward 3713
3696: Choice Lookup Table
          37   3685
          36   3598
          17   3578
          35   3282
           0   3234
3707: oCall 3714
3709: oInput 20
3711: oCall 3714
3713: oReturn
3714: oLocalSpace 1
3716: oInputChoice 3778
3718: TOKEN_VALUE
3719: oPushResult
3720: oValuePush
3721: oPop 1
3723: oJumpForward 3786
3725: oGetAddrLocal 1
3727: oPushResult
3728: oScopeFindRequire
3729: oAssign
3730: oGetAddrLocal 1
3732: oPushResult
3733: oCall 402
3735: oPop 1
3737: oGetLocal 1
3739: oPushResult
3740: oNodeType
3741: oPop 1
3743: oChoice 3760
3745: oGetLocal 1
3747: oPushResult
3748: oSetResult 22
3750: oPushResult
3751: oNodeGetInt
3752: oPop 2
3754: oPushResult
3755: oValuePush
3756: oPop 1
3758: oJumpForward 3771
3760: Choice Lookup Table
          14   3745
3763: oError 1
3765: oSetResult 0
3767: oPushResult
3768: oValuePush
3769: oPop 1
3771: oJumpForward 3786
3773: oCall 3714
3775: oValueNegate
3776: oJumpForward 3786
3778: Choice Lookup Table
          24   3773
           0   3725
           1   3718
3785: oEndChoice
3786: oReturn
3787: oLocalSpace 1
3789: oGetAddrLocal 1
3791: oPushResult
3792: oSetResult 0
3794: oAssign
3795: oGetAddrLocal 1
3797: oPushResult
3798: oCall 3948
3800: oPop 1
3802: oGetAddrLocal 1
3804: oPushResult
3805: oCall 3848
3807: oPop 1
3809: oReturn
3810: oLocalSpace 0
3812: oGetParam 1
3814: oPushResult
3815: oCall 3948
3817: oPop 1
3819: oTypeSNodeType
3820: oChoice 3839
3822: oJumpForward 3846
3824: oGetParam 1
3826: oPushResult
3827: oLabelNew
3828: oAssign
3829: oEmit 55
3831: oGetFromParam 1
3833: oPushResult
3834: oEmitLabel
3835: oPop 1
3837: oJumpForward 3846
3839: Choice Lookup Table
          24   3824
          25   3822
3844: oError 8
3846: oTypeSPop
3847: oReturn
3848: oLocalSpace 1
3850: oTypeSNodeType
3851: oChoice 3913
3853: oGetAddrLocal 1
3855: oPushResult
3856: oLabelNew
3857: oAssign
3858: oEmit 15
3860: oSetResult 1
3862: oPushResult
3863: oEmitInt
3864: oPop 1
3866: oEmit 53
3868: oGetLocal 1
3870: oPushResult
3871: oEmitLabel
3872: oPop 1
3874: oEmit 56
3876: oGetFromParam 1
3878: oPushResult
3879: oEmitLabel
3880: oPop 1
3882: oEmit 15
3884: oSetResult 0
3886: oPushResult
3887: oEmitInt
3888: oPop 1
3890: oEmit 56
3892: oGetLocal 1
3894: oPushResult
3895: oEmitLabel
3896: oPop 1
3898: oTypeSPop
3899: oGetGlobal 5
3901: oPushResult
3902: oTypeSPush
3903: oPop 1
3905: oGetParam 1
3907: oPushResult
3908: oSetResult 0
3910: oAssign
3911: oJumpForward 3916
3913: Choice Lookup Table
          25   3853
3916: oReturn
3917: oLocalSpace 0
3919: oTypeSNodeType
3920: oChoice 3944
3922: oGetParam 1
3924: oPushResult
3925: oLabelNew
3926: oAssign
3927: oEmit 55
3929: oGetFromParam 1
3931: oPushResult
3932: oEmitLabel
3933: oPop 1
3935: oTypeSPop
3936: oGetGlobal 6
3938: oPushResult
3939: oTypeSPush
3940: oPop 1
3942: oJumpForward 3947
3944: Choice Lookup Table
          24   3922
3947: oReturn
3948: oLocalSpace 0
3950: oGetParam 1
3952: oPushResult
3953: oCall 4313
3955: oPop 1
3957: oInputChoice 4295
3959: oGetParam 1
3961: oPushResult
3962: oCall 3848
3964: oPop 1
3966: oGetParam 1
3968: oPushResult
3969: oCall 4313
3971: oPop 1
3973: oGetParam 1
3975: oPushResult
3976: oCall 3848
3978: oPop 1
3980: oCall 7907
3982: oTypeSNodeType
3983: oChoice 3997
3985: oEmit 38
3987: oJumpForward 4010
3989: oEmit 44
3991: oJumpForward 4010
3993: oError 16
3995: oJumpForward 4010
3997: Choice Lookup Table
          27   3993
          26   3993
          28   3989
          24   3985
          23   3985
4008: oError 17
4010: oTypeSPop
4011: oGetGlobal 5
4013: oPushResult
4014: oTypeSPush
4015: oPop 1
4017: oJumpForward 4310
4019: oGetParam 1
4021: oPushResult
4022: oCall 3848
4024: oPop 1
4026: oGetParam 1
4028: oPushResult
4029: oCall 4313
4031: oPop 1
4033: oGetParam 1
4035: oPushResult
4036: oCall 3848
4038: oPop 1
4040: oCall 7907
4042: oTypeSNodeType
4043: oChoice 4057
4045: oEmit 39
4047: oJumpForward 4070
4049: oEmit 45
4051: oJumpForward 4070
4053: oError 16
4055: oJumpForward 4070
4057: Choice Lookup Table
          27   4053
          26   4053
          28   4049
          24   4045
          23   4045
4068: oError 17
4070: oTypeSPop
4071: oGetGlobal 5
4073: oPushResult
4074: oTypeSPush
4075: oPop 1
4077: oJumpForward 4310
4079: oGetParam 1
4081: oPushResult
4082: oCall 3848
4084: oPop 1
4086: oGetParam 1
4088: oPushResult
4089: oCall 4313
4091: oPop 1
4093: oGetParam 1
4095: oPushResult
4096: oCall 3848
4098: oPop 1
4100: oCall 7907
4102: oTypeSNodeType
4103: oChoice 4113
4105: oEmit 41
4107: oJumpForward 4124
4109: oError 16
4111: oJumpForward 4124
4113: Choice Lookup Table
          27   4109
          26   4109
          24   4105
          23   4105
4122: oError 17
4124: oTypeSPop
4125: oGetGlobal 5
4127: oPushResult
4128: oTypeSPush
4129: oPop 1
4131: oJumpForward 4310
4133: oGetParam 1
4135: oPushResult
4136: oCall 3848
4138: oPop 1
4140: oGetParam 1
4142: oPushResult
4143: oCall 4313
4145: oPop 1
4147: oGetParam 1
4149: oPushResult
4150: oCall 3848
4152: oPop 1
4154: oCall 7907
4156: oTypeSNodeType
4157: oChoice 4167
4159: oEmit 40
4161: oJumpForward 4178
4163: oError 16
4165: oJumpForward 4178
4167: Choice Lookup Table
          27   4163
          26   4163
          24   4159
          23   4159
4176: oError 17
4178: oTypeSPop
4179: oGetGlobal 5
4181: oPushResult
4182: oTypeSPush
4183: oPop 1
4185: oJumpForward 4310
4187: oGetParam 1
4189: oPushResult
4190: oCall 3848
4192: oPop 1
4194: oGetParam 1
4196: oPushResult
4197: oCall 4313
4199: oPop 1
4201: oGetParam 1
4203: oPushResult
4204: oCall 3848
4206: oPop 1
4208: oCall 7907
4210: oTypeSNodeType
4211: oChoice 4221
4213: oEmit 43
4215: oJumpForward 4232
4217: oError 16
4219: oJumpForward 4232
4221: Choice Lookup Table
          27   4217
          26   4217
          24   4213
          23   4213
4230: oError 17
4232: oTypeSPop
4233: oGetGlobal 5
4235: oPushResult
4236: oTypeSPush
4237: oPop 1
4239: oJumpForward 4310
4241: oGetParam 1
4243: oPushResult
4244: oCall 3848
4246: oPop 1
4248: oGetParam 1
4250: oPushResult
4251: oCall 4313
4253: oPop 1
4255: oGetParam 1
4257: oPushResult
4258: oCall 3848
4260: oPop 1
4262: oCall 7907
4264: oTypeSNodeType
4265: oChoice 4275
4267: oEmit 42
4269: oJumpForward 4286
4271: oError 16
4273: oJumpForward 4286
4275: Choice Lookup Table
          27   4271
          26   4271
          24   4267
          23   4267
4284: oError 17
4286: oTypeSPop
4287: oGetGlobal 5
4289: oPushResult
4290: oTypeSPush
4291: oPop 1
4293: oJumpForward 4310
4295: Choice Lookup Table
          10   4241
           9   4187
           8   4133
           7   4079
           6   4019
           5   3959
4308: oJumpForward 4312
4310: oJumpBack 3957
4312: oReturn
4313: oLocalSpace 1
4315: oGetAddrLocal 1
4317: oPushResult
4318: oSetResult 0
4320: oAssign
4321: oGetParam 1
4323: oPushResult
4324: oCall 4493
4326: oPop 1
4328: oInputChoice 4461
4330: oTypeSNodeType
4331: oChoice 4402
4333: oGetLocal 1
4335: oPushResult
4336: oSetResult 0
4338: oPushResult
4339: equal_label
4340: oPop 2
4342: oChoice 4351
4344: oGetAddrLocal 1
4346: oPushResult
4347: oLabelNew
4348: oAssign
4349: oJumpForward 4354
4351: Choice Lookup Table
           1   4344
4354: oEmit 53
4356: oGetLocal 1
4358: oPushResult
4359: oEmitLabel
4360: oPop 1
4362: oJumpForward 4409
4364: oGetParam 1
4366: oPushResult
4367: oCall 3917
4369: oPop 1
4371: oGetLocal 1
4373: oPushResult
4374: oSetResult 0
4376: oPushResult
4377: equal_label
4378: oPop 2
4380: oChoice 4389
4382: oGetAddrLocal 1
4384: oPushResult
4385: oLabelNew
4386: oAssign
4387: oJumpForward 4392
4389: Choice Lookup Table
           1   4382
4392: oEmit 53
4394: oGetLocal 1
4396: oPushResult
4397: oEmitLabel
4398: oPop 1
4400: oJumpForward 4409
4402: Choice Lookup Table
          24   4364
          25   4333
4407: oError 8
4409: oTypeSPop
4410: oEmit 56
4412: oGetFromParam 1
4414: oPushResult
4415: oEmitLabel
4416: oPop 1
4418: oGetParam 1
4420: oPushResult
4421: oSetResult 0
4423: oAssign
4424: oGetParam 1
4426: oPushResult
4427: oCall 4493
4429: oPop 1
4431: oTypeSNodeType
4432: oChoice 4445
4434: oJumpForward 4452
4436: oGetParam 1
4438: oPushResult
4439: oCall 3917
4441: oPop 1
4443: oJumpForward 4452
4445: Choice Lookup Table
          24   4436
          25   4434
4450: oError 8
4452: oTypeSPop
4453: oGetGlobal 6
4455: oPushResult
4456: oTypeSPush
4457: oPop 1
4459: oJumpForward 4466
4461: Choice Lookup Table
          52   4330
4464: oJumpForward 4468
4466: oJumpBack 4328
4468: oGetLocal 1
4470: oPushResult
4471: oSetResult 0
4473: oPushResult
4474: equal_label
4475: oPop 2
4477: oChoice 4489
4479: oEmit 56
4481: oGetLocal 1
4483: oPushResult
4484: oEmitLabel
4485: oPop 1
4487: oJumpForward 4492
4489: Choice Lookup Table
           0   4479
4492: oReturn
4493: oLocalSpace 2
4495: oGetAddrLocal 1
4497: oPushResult
4498: oSetResult 0
4500: oAssign
4501: oGetParam 1
4503: oPushResult
4504: oCall 4631
4506: oPop 1
4508: oInputChoice 4623
4510: oTypeSNodeType
4511: oChoice 4524
4513: oJumpForward 4531
4515: oGetParam 1
4517: oPushResult
4518: oCall 3917
4520: oPop 1
4522: oJumpForward 4531
4524: Choice Lookup Table
          24   4515
          25   4513
4529: oError 8
4531: oTypeSPop
4532: oGetLocal 1
4534: oPushResult
4535: oSetResult 0
4537: oPushResult
4538: equal_label
4539: oPop 2
4541: oChoice 4570
4543: oGetAddrLocal 1
4545: oPushResult
4546: oLabelNew
4547: oAssign
4548: oEmit 57
4550: oGetFromParam 1
4552: oPushResult
4553: oEmitLabel
4554: oPop 1
4556: oGetLocal 1
4558: oPushResult
4559: oEmitLabel
4560: oPop 1
4562: oGetParam 1
4564: oPushResult
4565: oGetLocal 1
4567: oAssign
4568: oJumpForward 4573
4570: Choice Lookup Table
           1   4543
4573: oGetAddrLocal 2
4575: oPushResult
4576: oSetResult 0
4578: oAssign
4579: oGetAddrLocal 2
4581: oPushResult
4582: oCall 4631
4584: oPop 1
4586: oTypeSNodeType
4587: oChoice 4600
4589: oJumpForward 4607
4591: oGetAddrLocal 2
4593: oPushResult
4594: oCall 3917
4596: oPop 1
4598: oJumpForward 4607
4600: Choice Lookup Table
          24   4591
          25   4589
4605: oError 8
4607: oEmit 57
4609: oGetLocal 2
4611: oPushResult
4612: oEmitLabel
4613: oPop 1
4615: oGetLocal 1
4617: oPushResult
4618: oEmitLabel
4619: oPop 1
4621: oJumpForward 4628
4623: Choice Lookup Table
          51   4510
4626: oJumpForward 4630
4628: oJumpBack 4508
4630: oReturn
4631: oLocalSpace 1
4633: oInputChoice 4687
4635: oGetAddrLocal 1
4637: oPushResult
4638: oSetResult 0
4640: oAssign
4641: oGetAddrLocal 1
4643: oPushResult
4644: oCall 4631
4646: oPop 1
4648: oTypeSNodeType
4649: oChoice 4678
4651: oGetParam 1
4653: oPushResult
4654: oLabelNew
4655: oAssign
4656: oEmit 53
4658: oGetFromParam 1
4660: oPushResult
4661: oEmitLabel
4662: oPop 1
4664: oEmit 56
4666: oGetLocal 1
4668: oPushResult
4669: oEmitLabel
4670: oPop 1
4672: oJumpForward 4685
4674: oEmit 37
4676: oJumpForward 4685
4678: Choice Lookup Table
          24   4674
          25   4651
4683: oError 8
4685: oJumpForward 4697
4687: Choice Lookup Table
          53   4635
4690: oGetParam 1
4692: oPushResult
4693: oCall 4698
4695: oPop 1
4697: oReturn
4698: oLocalSpace 0
4700: oGetParam 1
4702: oPushResult
4703: oCall 4749
4705: oPop 1
4707: oInputChoice 4739
4709: oCall 7933
4711: oGetParam 1
4713: oPushResult
4714: oCall 4749
4716: oPop 1
4718: oCall 7947
4720: oEmit 34
4722: oJumpForward 4746
4724: oCall 7933
4726: oGetParam 1
4728: oPushResult
4729: oCall 4749
4731: oPop 1
4733: oCall 7947
4735: oEmit 35
4737: oJumpForward 4746
4739: Choice Lookup Table
          24   4724
          23   4709
4744: oJumpForward 4748
4746: oJumpBack 4707
4748: oReturn
4749: oLocalSpace 0
4751: oGetParam 1
4753: oPushResult
4754: oCall 4800
4756: oPop 1
4758: oInputChoice 4790
4760: oCall 7933
4762: oGetParam 1
4764: oPushResult
4765: oCall 4800
4767: oPop 1
4769: oCall 7947
4771: oEmit 31
4773: oJumpForward 4797
4775: oCall 7933
4777: oGetParam 1
4779: oPushResult
4780: oCall 4800
4782: oPop 1
4784: oCall 7947
4786: oEmit 32
4788: oJumpForward 4797
4790: Choice Lookup Table
          22   4775
          21   4760
4795: oJumpForward 4799
4797: oJumpBack 4758
4799: oReturn
4800: oLocalSpace 0
4802: oInputChoice 4828
4804: oGetParam 1
4806: oPushResult
4807: oCall 4841
4809: oPop 1
4811: oCall 7947
4813: oJumpForward 4840
4815: oGetParam 1
4817: oPushResult
4818: oCall 4841
4820: oPop 1
4822: oCall 7947
4824: oEmit 36
4826: oJumpForward 4840
4828: Choice Lookup Table
          24   4815
          23   4804
4833: oGetParam 1
4835: oPushResult
4836: oCall 4841
4838: oPop 1
4840: oReturn
4841: oLocalSpace 6
4843: oInputChoice 5043
4845: oEmit 15
4847: TOKEN_VALUE
4848: oPushResult
4849: oEmitInt
4850: oPop 1
4852: oGetGlobal 4
4854: oPushResult
4855: oTypeSPush
4856: oPop 1
4858: oJumpForward 5062
4860: oGetParam 1
4862: oPushResult
4863: oCall 3948
4865: oPop 1
4867: oInput 14
4869: oJumpForward 5062
4871: oGetAddrLocal 1
4873: oPushResult
4874: CURRENT_STRLIT
4875: oPushResult
4876: oStringAllocLit
4877: oPop 1
4879: oAssign
4880: oEmit 16
4882: oGetLocal 1
4884: oPushResult
4885: oEmitInt
4886: oPop 1
4888: oGetGlobal 8
4890: oPushResult
4891: oTypeSPush
4892: oPop 1
4894: oJumpForward 5062
4896: oGetAddrLocal 2
4898: oPushResult
4899: oScopeFindRequire
4900: oAssign
4901: oGetAddrLocal 2
4903: oPushResult
4904: oCall 402
4906: oPop 1
4908: oGetLocal 2
4910: oPushResult
4911: oNodeType
4912: oPop 1
4914: oChoice 4976
4916: oGetLocal 2
4918: oPushResult
4919: oCall 6215
4921: oPop 1
4923: oJumpForward 4995
4925: oGetAddrLocal 3
4927: oPushResult
4928: oGetLocal 2
4930: oPushResult
4931: oSetResult 21
4933: oPushResult
4934: oNodeGet
4935: oPop 2
4937: oAssign
4938: oGetLocal 3
4940: oPushResult
4941: oTypeSPush
4942: oPop 1
4944: oTypeSNodeType
4945: oChoice 4958
4947: oEmit 15
4949: oGetLocal 2
4951: oPushResult
4952: oCall 8184
4954: oPop 1
4956: oJumpForward 4965
4958: Choice Lookup Table
          24   4947
          23   4947
4963: oError 16
4965: oJumpForward 4995
4967: oGetLocal 2
4969: oPushResult
4970: oCall 5063
4972: oPop 1
4974: oJumpForward 4995
4976: Choice Lookup Table
          20   4967
          18   4967
          17   4967
          14   4925
          13   4916
4987: oError 6
4989: oGetGlobal 4
4991: oPushResult
4992: oTypeSPush
4993: oPop 1
4995: oJumpForward 5062
4997: oInput 0
4999: oGetAddrLocal 4
5001: oPushResult
5002: oScopeFindRequire
5003: oAssign
5004: oGetAddrLocal 4
5006: oPushResult
5007: oCall 402
5009: oPop 1
5011: oGetLocal 4
5013: oPushResult
5014: oCall 7176
5016: oPop 1
5018: oGetAddrLocal 5
5020: oPushResult
5021: oTypeSTop
5022: oAssign
5023: oTypeSPop
5024: oGetAddrLocal 6
5026: oPushResult
5027: oGetLocal 5
5029: oPushResult
5030: oCall 8049
5032: oPop 1
5034: oAssign
5035: oGetLocal 6
5037: oPushResult
5038: oTypeSPush
5039: oPop 1
5041: oJumpForward 5062
5043: Choice Lookup Table
          18   4997
           0   4896
           2   4871
          13   4860
           1   4845
5054: oError 6
5056: oGetGlobal 4
5058: oPushResult
5059: oTypeSPush
5060: oPop 1
5062: oReturn
5063: oLocalSpace 2
5065: oGetAddrLocal 1
5067: oPushResult
5068: oGetParam 1
5070: oPushResult
5071: oSetResult 21
5073: oPushResult
5074: oNodeGet
5075: oPop 2
5077: oAssign
5078: oGetAddrLocal 2
5080: oPushResult
5081: oGetParam 1
5083: oPushResult
5084: oCall 7889
5086: oPop 1
5088: oAssign
5089: oGetLocal 1
5091: oPushResult
5092: oTypeSPush
5093: oPop 1
5095: oTypeSNodeType
5096: oChoice 5613
5098: oGetParam 1
5100: oPushResult
5101: oNodeType
5102: oPop 1
5104: oChoice 5250
5106: oEmit 0
5108: oGetParam 1
5110: oPushResult
5111: oCall 8184
5113: oPop 1
5115: oJumpForward 5258
5117: oGetLocal 2
5119: oPushResult
5120: equal_zero
5121: oPop 1
5123: oChoice 5136
5125: oEmit 3
5127: oGetParam 1
5129: oPushResult
5130: oCall 8184
5132: oPop 1
5134: oJumpForward 5154
5136: Choice Lookup Table
           1   5125
5139: oEmit 9
5141: oGetLocal 2
5143: oPushResult
5144: oEmitInt
5145: oPop 1
5147: oGetParam 1
5149: oPushResult
5150: oCall 8184
5152: oPop 1
5154: oJumpForward 5258
5156: oGetParam 1
5158: oPushResult
5159: oSetResult 32
5161: oPushResult
5162: oNodeGetBoolean
5163: oPop 2
5165: oChoice 5208
5167: oGetLocal 2
5169: oPushResult
5170: equal_zero
5171: oPop 1
5173: oChoice 5186
5175: oEmit 8
5177: oGetParam 1
5179: oPushResult
5180: oCall 8184
5182: oPop 1
5184: oJumpForward 5204
5186: Choice Lookup Table
           1   5175
5189: oEmit 14
5191: oGetLocal 2
5193: oPushResult
5194: oEmitInt
5195: oPop 1
5197: oGetParam 1
5199: oPushResult
5200: oCall 8184
5202: oPop 1
5204: oEmit 22
5206: oJumpForward 5248
5208: Choice Lookup Table
           1   5167
5211: oGetLocal 2
5213: oPushResult
5214: equal_zero
5215: oPop 1
5217: oChoice 5230
5219: oEmit 6
5221: oGetParam 1
5223: oPushResult
5224: oCall 8184
5226: oPop 1
5228: oJumpForward 5248
5230: Choice Lookup Table
           1   5219
5233: oEmit 12
5235: oGetLocal 2
5237: oPushResult
5238: oEmitInt
5239: oPop 1
5241: oGetParam 1
5243: oPushResult
5244: oCall 8184
5246: oPop 1
5248: oJumpForward 5258
5250: Choice Lookup Table
          20   5156
          18   5117
          17   5106
5257: oEndChoice
5258: oJumpForward 5788
5260: oGetParam 1
5262: oPushResult
5263: oNodeType
5264: oPop 1
5266: oChoice 5412
5268: oEmit 1
5270: oGetParam 1
5272: oPushResult
5273: oCall 8184
5275: oPop 1
5277: oJumpForward 5420
5279: oGetLocal 2
5281: oPushResult
5282: equal_zero
5283: oPop 1
5285: oChoice 5298
5287: oEmit 4
5289: oGetParam 1
5291: oPushResult
5292: oCall 8184
5294: oPop 1
5296: oJumpForward 5316
5298: Choice Lookup Table
           1   5287
5301: oEmit 10
5303: oGetLocal 2
5305: oPushResult
5306: oEmitInt
5307: oPop 1
5309: oGetParam 1
5311: oPushResult
5312: oCall 8184
5314: oPop 1
5316: oJumpForward 5420
5318: oGetParam 1
5320: oPushResult
5321: oSetResult 32
5323: oPushResult
5324: oNodeGetBoolean
5325: oPop 2
5327: oChoice 5370
5329: oGetLocal 2
5331: oPushResult
5332: equal_zero
5333: oPop 1
5335: oChoice 5348
5337: oEmit 8
5339: oGetParam 1
5341: oPushResult
5342: oCall 8184
5344: oPop 1
5346: oJumpForward 5366
5348: Choice Lookup Table
           1   5337
5351: oEmit 14
5353: oGetLocal 2
5355: oPushResult
5356: oEmitInt
5357: oPop 1
5359: oGetParam 1
5361: oPushResult
5362: oCall 8184
5364: oPop 1
5366: oEmit 23
5368: oJumpForward 5410
5370: Choice Lookup Table
           1   5329
5373: oGetLocal 2
5375: oPushResult
5376: equal_zero
5377: oPop 1
5379: oChoice 5392
5381: oEmit 7
5383: oGetParam 1
5385: oPushResult
5386: oCall 8184
5388: oPop 1
5390: oJumpForward 5410
5392: Choice Lookup Table
           1   5381
5395: oEmit 13
5397: oGetLocal 2
5399: oPushResult
5400: oEmitInt
5401: oPop 1
5403: oGetParam 1
5405: oPushResult
5406: oCall 8184
5408: oPop 1
5410: oJumpForward 5420
5412: Choice Lookup Table
          20   5318
          18   5279
          17   5268
5419: oEndChoice
5420: oJumpForward 5788
5422: oError 16
5424: oJumpForward 5788
5426: oGetParam 1
5428: oPushResult
5429: oNodeType
5430: oPop 1
5432: oChoice 5578
5434: oEmit 2
5436: oGetParam 1
5438: oPushResult
5439: oCall 8184
5441: oPop 1
5443: oJumpForward 5586
5445: oGetLocal 2
5447: oPushResult
5448: equal_zero
5449: oPop 1
5451: oChoice 5464
5453: oEmit 5
5455: oGetParam 1
5457: oPushResult
5458: oCall 8184
5460: oPop 1
5462: oJumpForward 5482
5464: Choice Lookup Table
           1   5453
5467: oEmit 11
5469: oGetLocal 2
5471: oPushResult
5472: oEmitInt
5473: oPop 1
5475: oGetParam 1
5477: oPushResult
5478: oCall 8184
5480: oPop 1
5482: oJumpForward 5586
5484: oGetParam 1
5486: oPushResult
5487: oSetResult 32
5489: oPushResult
5490: oNodeGetBoolean
5491: oPop 2
5493: oChoice 5536
5495: oGetLocal 2
5497: oPushResult
5498: equal_zero
5499: oPop 1
5501: oChoice 5514
5503: oEmit 8
5505: oGetParam 1
5507: oPushResult
5508: oCall 8184
5510: oPop 1
5512: oJumpForward 5532
5514: Choice Lookup Table
           1   5503
5517: oEmit 14
5519: oGetLocal 2
5521: oPushResult
5522: oEmitInt
5523: oPop 1
5525: oGetParam 1
5527: oPushResult
5528: oCall 8184
5530: oPop 1
5532: oEmit 24
5534: oJumpForward 5576
5536: Choice Lookup Table
           1   5495
5539: oGetLocal 2
5541: oPushResult
5542: equal_zero
5543: oPop 1
5545: oChoice 5558
5547: oEmit 8
5549: oGetParam 1
5551: oPushResult
5552: oCall 8184
5554: oPop 1
5556: oJumpForward 5576
5558: Choice Lookup Table
           1   5547
5561: oEmit 14
5563: oGetLocal 2
5565: oPushResult
5566: oEmitInt
5567: oPop 1
5569: oGetParam 1
5571: oPushResult
5572: oCall 8184
5574: oPop 1
5576: oJumpForward 5586
5578: Choice Lookup Table
          20   5484
          18   5445
          17   5434
5585: oEndChoice
5586: oInputChoice 5608
5588: oTypeSPop
5589: oGetLocal 1
5591: oPushResult
5592: oSetResult 34
5594: oPushResult
5595: oNodeGet
5596: oPop 2
5598: oPushResult
5599: oTypeSPush
5600: oPop 1
5602: oCall 5824
5604: oCall 5789
5606: oJumpForward 5611
5608: Choice Lookup Table
          17   5588
5611: oJumpForward 5788
5613: Choice Lookup Table
          28   5426
          22   5422
          27   5422
          26   5422
          24   5260
          23   5098
5626: oGetParam 1
5628: oPushResult
5629: oNodeType
5630: oPop 1
5632: oChoice 5776
5634: oEmit 16
5636: oGetParam 1
5638: oPushResult
5639: oCall 8184
5641: oPop 1
5643: oJumpForward 5784
5645: oGetLocal 2
5647: oPushResult
5648: equal_zero
5649: oPop 1
5651: oChoice 5664
5653: oEmit 17
5655: oGetParam 1
5657: oPushResult
5658: oCall 8184
5660: oPop 1
5662: oJumpForward 5682
5664: Choice Lookup Table
           1   5653
5667: oEmit 20
5669: oGetLocal 2
5671: oPushResult
5672: oEmitInt
5673: oPop 1
5675: oGetParam 1
5677: oPushResult
5678: oCall 8184
5680: oPop 1
5682: oJumpForward 5784
5684: oGetParam 1
5686: oPushResult
5687: oSetResult 32
5689: oPushResult
5690: oNodeGetBoolean
5691: oPop 2
5693: oChoice 5734
5695: oGetLocal 2
5697: oPushResult
5698: equal_zero
5699: oPop 1
5701: oChoice 5714
5703: oEmit 8
5705: oGetParam 1
5707: oPushResult
5708: oCall 8184
5710: oPop 1
5712: oJumpForward 5732
5714: Choice Lookup Table
           1   5703
5717: oEmit 14
5719: oGetLocal 2
5721: oPushResult
5722: oEmitInt
5723: oPop 1
5725: oGetParam 1
5727: oPushResult
5728: oCall 8184
5730: oPop 1
5732: oJumpForward 5774
5734: Choice Lookup Table
           1   5695
5737: oGetLocal 2
5739: oPushResult
5740: equal_zero
5741: oPop 1
5743: oChoice 5756
5745: oEmit 18
5747: oGetParam 1
5749: oPushResult
5750: oCall 8184
5752: oPop 1
5754: oJumpForward 5774
5756: Choice Lookup Table
           1   5745
5759: oEmit 21
5761: oGetLocal 2
5763: oPushResult
5764: oEmitInt
5765: oPop 1
5767: oGetParam 1
5769: oPushResult
5770: oCall 8184
5772: oPop 1
5774: oJumpForward 5784
5776: Choice Lookup Table
          20   5684
          18   5645
          17   5634
5783: oEndChoice
5784: oCall 5824
5786: oCall 5789
5788: oReturn
5789: oLocalSpace 0
5791: oTypeSNodeType
5792: oChoice 5810
5794: oEmit 22
5796: oJumpForward 5823
5798: oEmit 23
5800: oJumpForward 5823
5802: oError 16
5804: oJumpForward 5823
5806: oEmit 24
5808: oJumpForward 5823
5810: Choice Lookup Table
          28   5806
          22   5802
          27   5802
          26   5802
          24   5798
          23   5794
5823: oReturn
5824: oLocalSpace 0
5826: oInputChoice 5840
5828: oCall 5852
5830: oJumpForward 5849
5832: oCall 5995
5834: oJumpForward 5849
5836: oCall 6093
5838: oJumpForward 5849
5840: Choice Lookup Table
          17   5836
          19   5832
          15   5828
5847: oJumpForward 5851
5849: oJumpBack 5826
5851: oReturn
5852: oLocalSpace 3
5854: oTypeSNodeType
5855: oChoice 5859
5857: oJumpForward 5864
5859: Choice Lookup Table
          29   5857
5862: oError 10
5864: oTypeSNodeType
5865: oChoice 5869
5867: oJumpForward 5874
5869: Choice Lookup Table
          29   5867
5872: oError 13
5874: oGetAddrLocal 1
5876: oPushResult
5877: oTypeSTop
5878: oPushResult
5879: oSetResult 35
5881: oPushResult
5882: oNodeGet
5883: oPop 2
5885: oPushResult
5886: oCall 8133
5888: oPop 1
5890: oAssign
5891: oGetAddrLocal 2
5893: oPushResult
5894: oTypeSTop
5895: oPushResult
5896: oSetResult 34
5898: oPushResult
5899: oNodeGet
5900: oPop 2
5902: oAssign
5903: oTypeSPop
5904: oGetLocal 2
5906: oPushResult
5907: oTypeSPush
5908: oPop 1
5910: oCall 3787
5912: oCall 7933
5914: oGetLocal 1
5916: oPushResult
5917: equal_zero
5918: oPop 1
5920: oChoice 5934
5922: oEmit 15
5924: oGetLocal 1
5926: oPushResult
5927: oEmitInt
5928: oPop 1
5930: oEmit 35
5932: oJumpForward 5937
5934: Choice Lookup Table
           0   5922
5937: oGetAddrLocal 3
5939: oPushResult
5940: oGetLocal 2
5942: oPushResult
5943: oSetResult 17
5945: oPushResult
5946: oNodeGetInt
5947: oPop 2
5949: oAssign
5950: oGetLocal 3
5952: oPushResult
5953: oSetResult 1
5955: oPushResult
5956: equal
5957: oPop 2
5959: oChoice 5973
5961: oEmit 15
5963: oGetLocal 3
5965: oPushResult
5966: oEmitInt
5967: oPop 1
5969: oEmit 31
5971: oJumpForward 5976
5973: Choice Lookup Table
           0   5961
5976: oEmit 33
5978: oInputChoice 5986
5980: oJumpForward 5994
5982: oJumpForward 5992
5984: oJumpForward 5992
5986: Choice Lookup Table
          12   5984
          16   5980
5991: oEndChoice
5992: oJumpBack 5864
5994: oReturn
5995: oLocalSpace 2
5997: oTypeSNodeType
5998: oChoice 6002
6000: oJumpForward 6007
6002: Choice Lookup Table
          31   6000
6005: oError 11
6007: oTypeSTop
6008: oPushResult
6009: oSetResult 38
6011: oPushResult
6012: oNodeGet
6013: oPop 2
6015: oPushResult
6016: oScopeEnter
6017: oPop 1
6019: oInput 0
6021: oGetAddrLocal 1
6023: oPushResult
6024: oScopeFindRequire
6025: oAssign
6026: oGetLocal 1
6028: oPushResult
6029: oNodeType
6030: oPop 1
6032: oChoice 6036
6034: oJumpForward 6041
6036: Choice Lookup Table
          19   6034
6039: oError 12
6041: oScopeEnd
6042: oGetAddrLocal 2
6044: oPushResult
6045: oGetLocal 1
6047: oPushResult
6048: oSetResult 22
6050: oPushResult
6051: oNodeGetInt
6052: oPop 2
6054: oAssign
6055: oGetLocal 2
6057: oPushResult
6058: equal_zero
6059: oPop 1
6061: oChoice 6075
6063: oEmit 15
6065: oGetLocal 2
6067: oPushResult
6068: oEmitInt
6069: oPop 1
6071: oEmit 33
6073: oJumpForward 6078
6075: Choice Lookup Table
           0   6063
6078: oTypeSPop
6079: oGetLocal 1
6081: oPushResult
6082: oSetResult 21
6084: oPushResult
6085: oNodeGet
6086: oPop 2
6088: oPushResult
6089: oTypeSPush
6090: oPop 1
6092: oReturn
6093: oLocalSpace 1
6095: oTypeSNodeType
6096: oChoice 6100
6098: oJumpForward 6105
6100: Choice Lookup Table
          28   6098
6103: oError 9
6105: oEmit 24
6107: oGetAddrLocal 1
6109: oPushResult
6110: oTypeSTop
6111: oAssign
6112: oTypeSPop
6113: oGetLocal 1
6115: oPushResult
6116: oSetResult 34
6118: oPushResult
6119: oNodeGet
6120: oPop 2
6122: oPushResult
6123: oTypeSPush
6124: oPop 1
6126: oReturn
6127: oLocalSpace 0
6129: oCall 7907
6131: oReturn
6132: oLocalSpace 2
6134: oGetAddrLocal 2
6136: oPushResult
6137: oGetParam 1
6139: oPushResult
6140: oSetResult 26
6142: oPushResult
6143: oNodeGetString
6144: oPop 2
6146: oAssign
6147: oGetLocal 2
6149: oPushResult
6150: oSetResult 0
6152: oPushResult
6153: equal_string
6154: oPop 2
6156: oChoice 6193
6158: oGetAddrLocal 1
6160: oPushResult
6161: oGetParam 1
6163: oPushResult
6164: oSetResult 4
6166: oPushResult
6167: oNodeGetInt
6168: oPop 2
6170: oPushResult
6171: ID_STRING
6172: oPop 1
6174: oPushResult
6175: oStringAllocLit
6176: oPop 1
6178: oAssign
6179: oJumpForward 6199
6181: oGetAddrLocal 1
6183: oPushResult
6184: oGetLocal 2
6186: oPushResult
6187: oStringAllocLit
6188: oPop 1
6190: oAssign
6191: oJumpForward 6199
6193: Choice Lookup Table
           0   6181
           1   6158
6198: oEndChoice
6199: oEmit 58
6201: oGetParam 1
6203: oPushResult
6204: oCall 8184
6206: oPop 1
6208: oGetLocal 1
6210: oPushResult
6211: oEmitInt
6212: oPop 1
6214: oReturn
6215: oLocalSpace 10
6217: oGetParam 1
6219: oPushResult
6220: oSetResult 25
6222: oPushResult
6223: oNodeGetBoolean
6224: oPop 2
6226: oChoice 6253
6228: oGetParam 1
6230: oPushResult
6231: oSetResult 28
6233: oPushResult
6234: oNodeGetBoolean
6235: oPop 2
6237: oChoice 6248
6239: oGetParam 1
6241: oPushResult
6242: oCall 6132
6244: oPop 1
6246: oJumpForward 6251
6248: Choice Lookup Table
           0   6239
6251: oJumpForward 6256
6253: Choice Lookup Table
           1   6228
6256: oGetParam 1
6258: oPushResult
6259: oSetResult 28
6261: oPushResult
6262: oSetResult 1
6264: oPushResult
6265: oNodeSetBoolean
6266: oPop 3
6268: oGetAddrLocal 1
6270: oPushResult
6271: oGetParam 1
6273: oPushResult
6274: oSetResult 27
6276: oPushResult
6277: oNodeGetBoolean
6278: oPop 2
6280: oAssign
6281: oGetAddrLocal 4
6283: oPushResult
6284: oGetParam 1
6286: oPushResult
6287: oNodeType
6288: oPop 1
6290: oPushResult
6291: oSetResult 13
6293: oPushResult
6294: equal_node_type
6295: oPop 2
6297: oAssign
6298: oGetLocal 4
6300: oChoice 6327
6302: oGetAddrLocal 2
6304: oPushResult
6305: oGetParam 1
6307: oPushResult
6308: oSetResult 21
6310: oPushResult
6311: oNodeGet
6312: oPop 2
6314: oAssign
6315: oGetAddrLocal 3
6317: oPushResult
6318: oGetLocal 2
6320: oPushResult
6321: oScopeAllocType
6322: oPop 1
6324: oAssign
6325: oJumpForward 6330
6327: Choice Lookup Table
           1   6302
6330: oGetAddrLocal 5
6332: oPushResult
6333: oGetParam 1
6335: oPushResult
6336: oSetResult 23
6338: oPushResult
6339: oNodeGet
6340: oPop 2
6342: oAssign
6343: oGetAddrLocal 6
6345: oPushResult
6346: oGetLocal 5
6348: oPushResult
6349: oSetResult 17
6351: oPushResult
6352: oNodeGetInt
6353: oPop 2
6355: oAssign
6356: oGetLocal 1
6358: oChoice 6380
6360: oEmit 47
6362: oGetLocal 6
6364: oPushResult
6365: oEmitInt
6366: oPop 1
6368: oJumpForward 6386
6370: oEmit 46
6372: oGetLocal 6
6374: oPushResult
6375: oEmitInt
6376: oPop 1
6378: oJumpForward 6386
6380: Choice Lookup Table
           0   6370
           1   6360
6385: oEndChoice
6386: oGetParam 1
6388: oPushResult
6389: oCall 7869
6391: oPop 1
6393: oPushResult
6394: oSetResult 0
6396: oPushResult
6397: greater
6398: oPop 2
6400: oChoice 6433
6402: oEmit 19
6404: oSetResult 0
6406: oPushResult
6407: oEmitInt
6408: oPop 1
6410: oEmit 20
6412: oGetParam 1
6414: oPushResult
6415: oCall 7889
6417: oPop 1
6419: oPushResult
6420: oEmitInt
6421: oPop 1
6423: oSetResult 0
6425: oPushResult
6426: oEmitInt
6427: oPop 1
6429: oEmit 27
6431: oJumpForward 6436
6433: Choice Lookup Table
           1   6402
6436: oGetAddrLocal 7
6438: oPushResult
6439: oGetLocal 5
6441: oPushResult
6442: oSetResult 15
6444: oPushResult
6445: oNodeGetIter
6446: oPop 2
6448: oAssign
6449: oGetAddrLocal 8
6451: oPushResult
6452: oGetLocal 7
6454: oPushResult
6455: oNodeIterValue
6456: oPop 1
6458: oAssign
6459: oInputChoice 6638
6461: oGetLocal 8
6463: oPushResult
6464: oNodeNull
6465: oPop 1
6467: oChoice 6473
6469: oJumpForward 6634
6471: oJumpForward 6476
6473: Choice Lookup Table
           1   6469
6476: oGetAddrLocal 9
6478: oPushResult
6479: oGetLocal 8
6481: oPushResult
6482: oSetResult 22
6484: oPushResult
6485: oNodeGetInt
6486: oPop 2
6488: oAssign
6489: oEmit 19
6491: oGetLocal 9
6493: oPushResult
6494: oEmitInt
6495: oPop 1
6497: oGetLocal 8
6499: oPushResult
6500: oSetResult 21
6502: oPushResult
6503: oNodeGet
6504: oPop 2
6506: oPushResult
6507: oTypeSPush
6508: oPop 1
6510: oGetLocal 8
6512: oPushResult
6513: oSetResult 32
6515: oPushResult
6516: oNodeGetBoolean
6517: oPop 2
6519: oChoice 6587
6521: oCall 7133
6523: oCall 7907
6525: oEmit 27
6527: oJumpForward 6593
6529: oCall 3787
6531: oCall 6127
6533: oTypeSNodeType
6534: oChoice 6552
6536: oEmit 25
6538: oJumpForward 6585
6540: oEmit 26
6542: oJumpForward 6585
6544: oError 16
6546: oJumpForward 6585
6548: oEmit 27
6550: oJumpForward 6585
6552: Choice Lookup Table
          28   6548
          22   6544
          27   6544
          26   6544
          24   6540
          23   6536
6565: oGetAddrLocal 10
6567: oPushResult
6568: oTypeSTop
6569: oPushResult
6570: oSetResult 17
6572: oPushResult
6573: oNodeGetInt
6574: oPop 2
6576: oAssign
6577: oEmit 28
6579: oGetLocal 10
6581: oPushResult
6582: oEmitInt
6583: oPop 1
6585: oJumpForward 6593
6587: Choice Lookup Table
           0   6529
           1   6521
6592: oEndChoice
6593: oTypeSPop
6594: oGetAddrLocal 7
6596: oPushResult
6597: oNodeIterNext
6598: oPop 1
6600: oGetAddrLocal 8
6602: oPushResult
6603: oGetLocal 7
6605: oPushResult
6606: oNodeIterValue
6607: oPop 1
6609: oAssign
6610: oGetLocal 8
6612: oPushResult
6613: oNodeNull
6614: oPop 1
6616: oChoice 6624
6618: oJumpForward 6634
6620: oJumpForward 6630
6622: oJumpForward 6630
6624: Choice Lookup Table
           0   6622
           1   6618
6629: oEndChoice
6630: oInput 12
6632: oJumpBack 6461
6634: oInput 14
6636: oJumpForward 6641
6638: Choice Lookup Table
          13   6461
6641: oGetLocal 8
6643: oPushResult
6644: oNodeNull
6645: oPop 1
6647: oChoice 6653
6649: oError 15
6651: oJumpForward 6656
6653: Choice Lookup Table
           0   6649
6656: oGetLocal 4
6658: oChoice 6687
6660: oEmit 19
6662: oGetParam 1
6664: oPushResult
6665: oSetResult 31
6667: oPushResult
6668: oNodeGetInt
6669: oPop 2
6671: oPushResult
6672: oEmitInt
6673: oPop 1
6675: oEmit 17
6677: oGetLocal 3
6679: oPushResult
6680: oEmitInt
6681: oPop 1
6683: oEmit 27
6685: oJumpForward 6690
6687: Choice Lookup Table
           1   6660
6690: oGetLocal 1
6692: oChoice 6716
6694: oEmit 50
6696: oGetParam 1
6698: oPushResult
6699: oCall 8184
6701: oPop 1
6703: oJumpForward 6722
6705: oEmit 49
6707: oGetParam 1
6709: oPushResult
6710: oCall 8184
6712: oPop 1
6714: oJumpForward 6722
6716: Choice Lookup Table
           0   6705
           1   6694
6721: oEndChoice
6722: oGetLocal 4
6724: oChoice 6792
6726: oGetLocal 2
6728: oPushResult
6729: oTypeSPush
6730: oPop 1
6732: oTypeSNodeType
6733: oChoice 6769
6735: oEmit 3
6737: oGetLocal 3
6739: oPushResult
6740: oEmitInt
6741: oPop 1
6743: oJumpForward 6790
6745: oEmit 4
6747: oGetLocal 3
6749: oPushResult
6750: oEmitInt
6751: oPop 1
6753: oJumpForward 6790
6755: oError 16
6757: oJumpForward 6790
6759: oEmit 5
6761: oGetLocal 3
6763: oPushResult
6764: oEmitInt
6765: oPop 1
6767: oJumpForward 6790
6769: Choice Lookup Table
          28   6759
          22   6755
          27   6755
          26   6755
          24   6745
          23   6735
6782: oEmit 17
6784: oGetLocal 3
6786: oPushResult
6787: oEmitInt
6788: oPop 1
6790: oJumpForward 6795
6792: Choice Lookup Table
           1   6726
6795: oEmit 48
6797: oGetLocal 6
6799: oPushResult
6800: oEmitInt
6801: oPop 1
6803: oReturn
6804: oLocalSpace 0
6806: oInputChoice 6856
6808: oCall 7777
6810: oJumpForward 6881
6812: oCall 7784
6814: oJumpForward 6881
6816: oCall 7851
6818: oJumpForward 6881
6820: oCall 7854
6822: oJumpForward 6881
6824: oCall 7317
6826: oJumpForward 6881
6828: oCall 7637
6830: oJumpForward 6881
6832: oCall 7383
6834: oJumpForward 6881
6836: oCall 7557
6838: oJumpForward 6881
6840: oCall 7722
6842: oJumpForward 6881
6844: oCall 7690
6846: oJumpForward 6881
6848: oCall 7754
6850: oJumpForward 6881
6852: oCall 6882
6854: oJumpForward 6881
6856: Choice Lookup Table
           0   6852
          33   6848
          49   6844
          50   6840
          47   6836
          42   6832
          46   6828
          39   6824
          63   6820
          62   6816
          61   6812
          60   6808
6881: oReturn
6882: oLocalSpace 1
6884: oGetAddrLocal 1
6886: oPushResult
6887: oScopeFindRequire
6888: oAssign
6889: oGetAddrLocal 1
6891: oPushResult
6892: oCall 402
6894: oPop 1
6896: oGetLocal 1
6898: oPushResult
6899: oNodeType
6900: oPop 1
6902: oChoice 6931
6904: oGetLocal 1
6906: oPushResult
6907: oCall 6215
6909: oPop 1
6911: oJumpForward 6944
6913: oGetLocal 1
6915: oPushResult
6916: oCall 6945
6918: oPop 1
6920: oJumpForward 6944
6922: oGetLocal 1
6924: oPushResult
6925: oCall 7019
6927: oPop 1
6929: oJumpForward 6944
6931: Choice Lookup Table
          13   6922
          20   6913
          18   6913
          17   6913
          12   6904
6942: oError 0
6944: oReturn
6945: oLocalSpace 0
6947: oGetParam 1
6949: oPushResult
6950: oCall 7176
6952: oPop 1
6954: oInput 3
6956: oCall 3787
6958: oCall 7907
6960: oCall 6963
6962: oReturn
6963: oLocalSpace 1
6965: oTypeSNodeType
6966: oChoice 6984
6968: oEmit 25
6970: oJumpForward 7017
6972: oEmit 26
6974: oJumpForward 7017
6976: oError 16
6978: oJumpForward 7017
6980: oEmit 27
6982: oJumpForward 7017
6984: Choice Lookup Table
          28   6980
          22   6976
          27   6976
          26   6976
          24   6972
          23   6968
6997: oGetAddrLocal 1
6999: oPushResult
7000: oTypeSTop
7001: oPushResult
7002: oSetResult 17
7004: oPushResult
7005: oNodeGetInt
7006: oPop 2
7008: oAssign
7009: oEmit 28
7011: oGetLocal 1
7013: oPushResult
7014: oEmitInt
7015: oPop 1
7017: oTypeSPop
7018: oReturn
7019: oLocalSpace 1
7021: oGetParam 1
7023: oPushResult
7024: oSetResult 6
7026: oPushResult
7027: oNodeGet
7028: oPop 2
7030: oPushResult
7031: oScopeCurrent
7032: oPushResult
7033: oNodeEqual
7034: oPop 2
7036: oChoice 7042
7038: oError 20
7040: oJumpForward 7045
7042: Choice Lookup Table
           0   7038
7045: oEmit 8
7047: oGetParam 1
7049: oPushResult
7050: oSetResult 31
7052: oPushResult
7053: oNodeGetInt
7054: oPop 2
7056: oPushResult
7057: oEmitInt
7058: oPop 1
7060: oGetParam 1
7062: oPushResult
7063: oSetResult 21
7065: oPushResult
7066: oNodeGet
7067: oPop 2
7069: oPushResult
7070: oTypeSPush
7071: oPop 1
7073: oInput 3
7075: oCall 3787
7077: oCall 7907
7079: oTypeSNodeType
7080: oChoice 7098
7082: oEmit 25
7084: oJumpForward 7131
7086: oEmit 26
7088: oJumpForward 7131
7090: oError 16
7092: oJumpForward 7131
7094: oEmit 27
7096: oJumpForward 7131
7098: Choice Lookup Table
          28   7094
          22   7090
          27   7090
          26   7090
          24   7086
          23   7082
7111: oGetAddrLocal 1
7113: oPushResult
7114: oTypeSTop
7115: oPushResult
7116: oSetResult 17
7118: oPushResult
7119: oNodeGetInt
7120: oPop 2
7122: oAssign
7123: oEmit 28
7125: oGetLocal 1
7127: oPushResult
7128: oEmitInt
7129: oPop 1
7131: oTypeSPop
7132: oReturn
7133: oLocalSpace 1
7135: oInput 0
7137: oGetAddrLocal 1
7139: oPushResult
7140: oScopeFindRequire
7141: oAssign
7142: oGetAddrLocal 1
7144: oPushResult
7145: oCall 402
7147: oPop 1
7149: oGetLocal 1
7151: oPushResult
7152: oNodeType
7153: oPop 1
7155: oChoice 7159
7157: oJumpForward 7168
7159: Choice Lookup Table
          20   7157
          18   7157
          17   7157
7166: oError 4
7168: oGetLocal 1
7170: oPushResult
7171: oCall 7176
7173: oPop 1
7175: oReturn
7176: oLocalSpace 0
7178: oGetParam 1
7180: oPushResult
7181: oNodeType
7182: oPop 1
7184: oChoice 7244
7186: oEmit 16
7188: oGetParam 1
7190: oPushResult
7191: oCall 8184
7193: oPop 1
7195: oJumpForward 7253
7197: oEmit 17
7199: oGetParam 1
7201: oPushResult
7202: oCall 8184
7204: oPop 1
7206: oJumpForward 7253
7208: oGetParam 1
7210: oPushResult
7211: oSetResult 32
7213: oPushResult
7214: oNodeGetBoolean
7215: oPop 2
7217: oChoice 7230
7219: oEmit 8
7221: oGetParam 1
7223: oPushResult
7224: oCall 8184
7226: oPop 1
7228: oJumpForward 7242
7230: Choice Lookup Table
           1   7219
7233: oEmit 18
7235: oGetParam 1
7237: oPushResult
7238: oCall 8184
7240: oPop 1
7242: oJumpForward 7253
7244: Choice Lookup Table
          20   7208
          18   7197
          17   7186
7251: oError 4
7253: oGetParam 1
7255: oPushResult
7256: oSetResult 21
7258: oPushResult
7259: oNodeGet
7260: oPop 2
7262: oPushResult
7263: oTypeSPush
7264: oPop 1
7266: oCall 5824
7268: oReturn
7269: oLocalSpace 0
7271: oGetParam 1
7273: oPushResult
7274: oCall 7176
7276: oPop 1
7278: oCall 7933
7280: oGetParam 1
7282: oPushResult
7283: oCall 5063
7285: oPop 1
7287: oTypeSPop
7288: oEmit 29
7290: oEmit 25
7292: oReturn
7293: oLocalSpace 0
7295: oGetParam 1
7297: oPushResult
7298: oCall 7176
7300: oPop 1
7302: oCall 7933
7304: oGetParam 1
7306: oPushResult
7307: oCall 5063
7309: oPop 1
7311: oTypeSPop
7312: oEmit 30
7314: oEmit 25
7316: oReturn
7317: oLocalSpace 2
7319: oGetAddrLocal 1
7321: oPushResult
7322: oSetResult 0
7324: oAssign
7325: oGetAddrLocal 1
7327: oPushResult
7328: oCall 3810
7330: oPop 1
7332: oInput 40
7334: oCall 6804
7336: oInputChoice 7371
7338: oGetAddrLocal 2
7340: oPushResult
7341: oLabelNew
7342: oAssign
7343: oEmit 53
7345: oGetLocal 2
7347: oPushResult
7348: oEmitLabel
7349: oPop 1
7351: oEmit 56
7353: oGetLocal 1
7355: oPushResult
7356: oEmitLabel
7357: oPop 1
7359: oCall 6804
7361: oEmit 56
7363: oGetLocal 2
7365: oPushResult
7366: oEmitLabel
7367: oPop 1
7369: oJumpForward 7382
7371: Choice Lookup Table
          41   7338
7374: oEmit 56
7376: oGetLocal 1
7378: oPushResult
7379: oEmitLabel
7380: oPop 1
7382: oReturn
7383: oLocalSpace 4
7385: oInput 0
7387: oGetAddrLocal 1
7389: oPushResult
7390: oScopeFindRequire
7391: oAssign
7392: oGetLocal 1
7394: oPushResult
7395: oCall 7176
7397: oPop 1
7399: oCall 7933
7401: oInput 3
7403: oCall 3787
7405: oCall 7933
7407: oEmit 25
7409: oGetAddrLocal 2
7411: oPushResult
7412: oLabelNew
7413: oAssign
7414: oGetAddrLocal 3
7416: oPushResult
7417: oLabelNew
7418: oAssign
7419: oEmit 53
7421: oGetLocal 3
7423: oPushResult
7424: oEmitLabel
7425: oPop 1
7427: oGetAddrLocal 4
7429: oPushResult
7430: oLabelNew
7431: oAssign
7432: oEmit 56
7434: oGetLocal 4
7436: oPushResult
7437: oEmitLabel
7438: oPop 1
7440: oInputChoice 7520
7442: oGetLocal 1
7444: oPushResult
7445: oCall 7269
7447: oPop 1
7449: oEmit 56
7451: oGetLocal 3
7453: oPushResult
7454: oEmitLabel
7455: oPop 1
7457: oGetLocal 1
7459: oPushResult
7460: oCall 5063
7462: oPop 1
7464: oTypeSPop
7465: oCall 3787
7467: oCall 7933
7469: oEmit 40
7471: oEmit 54
7473: oGetLocal 2
7475: oPushResult
7476: oEmitLabel
7477: oPop 1
7479: oJumpForward 7526
7481: oGetLocal 1
7483: oPushResult
7484: oCall 7293
7486: oPop 1
7488: oEmit 56
7490: oGetLocal 3
7492: oPushResult
7493: oEmitLabel
7494: oPop 1
7496: oGetLocal 1
7498: oPushResult
7499: oCall 5063
7501: oPop 1
7503: oTypeSPop
7504: oCall 3787
7506: oCall 7933
7508: oEmit 41
7510: oEmit 54
7512: oGetLocal 2
7514: oPushResult
7515: oEmitLabel
7516: oPop 1
7518: oJumpForward 7526
7520: Choice Lookup Table
          44   7481
          43   7442
7525: oEndChoice
7526: oGetLocal 4
7528: oPushResult
7529: oGetLocal 2
7531: oPushResult
7532: oLoopPush
7533: oPop 2
7535: oInput 45
7537: oCall 6804
7539: oEmit 53
7541: oGetLocal 4
7543: oPushResult
7544: oEmitLabel
7545: oPop 1
7547: oEmit 56
7549: oGetLocal 2
7551: oPushResult
7552: oEmitLabel
7553: oPop 1
7555: oLoopPop
7556: oReturn
7557: oLocalSpace 3
7559: oGetAddrLocal 1
7561: oPushResult
7562: oLabelNew
7563: oAssign
7564: oEmit 56
7566: oGetLocal 1
7568: oPushResult
7569: oEmitLabel
7570: oPop 1
7572: oGetAddrLocal 2
7574: oPushResult
7575: oLabelNew
7576: oAssign
7577: oGetLocal 1
7579: oPushResult
7580: oGetLocal 2
7582: oPushResult
7583: oLoopPush
7584: oPop 2
7586: oCall 6804
7588: oInputChoice 7619
7590: oCall 6804
7592: oJumpForward 7625
7594: oGetAddrLocal 3
7596: oPushResult
7597: oCall 3810
7599: oPop 1
7601: oEmit 57
7603: oGetLocal 3
7605: oPushResult
7606: oEmitLabel
7607: oPop 1
7609: oGetLocal 1
7611: oPushResult
7612: oEmitLabel
7613: oPop 1
7615: oJumpForward 7627
7617: oJumpForward 7625
7619: Choice Lookup Table
          48   7594
           4   7590
7624: oEndChoice
7625: oJumpBack 7588
7627: oEmit 56
7629: oGetLocal 2
7631: oPushResult
7632: oEmitLabel
7633: oPop 1
7635: oLoopPop
7636: oReturn
7637: oLocalSpace 2
7639: oGetAddrLocal 1
7641: oPushResult
7642: oLabelNew
7643: oAssign
7644: oEmit 56
7646: oGetLocal 1
7648: oPushResult
7649: oEmitLabel
7650: oPop 1
7652: oGetAddrLocal 2
7654: oPushResult
7655: oCall 3810
7657: oPop 1
7659: oGetLocal 1
7661: oPushResult
7662: oGetLocal 2
7664: oPushResult
7665: oLoopPush
7666: oPop 2
7668: oInput 45
7670: oCall 6804
7672: oEmit 53
7674: oGetLocal 1
7676: oPushResult
7677: oEmitLabel
7678: oPop 1
7680: oEmit 56
7682: oGetLocal 2
7684: oPushResult
7685: oEmitLabel
7686: oPop 1
7688: oLoopPop
7689: oReturn
7690: oLocalSpace 0
7692: oLoopContinueLabel
7693: oPushResult
7694: oSetResult 0
7696: oPushResult
7697: equal_label
7698: oPop 2
7700: oChoice 7715
7702: oError 18
7704: oJumpForward 7721
7706: oEmit 53
7708: oLoopContinueLabel
7709: oPushResult
7710: oEmitLabel
7711: oPop 1
7713: oJumpForward 7721
7715: Choice Lookup Table
           0   7706
           1   7702
7720: oEndChoice
7721: oReturn
7722: oLocalSpace 0
7724: oLoopBreakLabel
7725: oPushResult
7726: oSetResult 0
7728: oPushResult
7729: equal_label
7730: oPop 2
7732: oChoice 7747
7734: oError 18
7736: oJumpForward 7753
7738: oEmit 53
7740: oLoopBreakLabel
7741: oPushResult
7742: oEmitLabel
7743: oPop 1
7745: oJumpForward 7753
7747: Choice Lookup Table
           0   7738
           1   7734
7752: oEndChoice
7753: oReturn
7754: oLocalSpace 0
7756: oCall 6804
7758: oInputChoice 7768
7760: oCall 6804
7762: oJumpForward 7774
7764: oJumpForward 7776
7766: oJumpForward 7774
7768: Choice Lookup Table
          34   7764
           4   7760
7773: oEndChoice
7774: oJumpBack 7758
7776: oReturn
7777: oLocalSpace 0
7779: oCall 7784
7781: oEmit 63
7783: oReturn
7784: oLocalSpace 0
7786: oInputChoice 7847
7788: oCall 3787
7790: oTypeSNodeType
7791: oChoice 7813
7793: oEmit 59
7795: oJumpForward 7828
7797: oEmit 60
7799: oJumpForward 7828
7801: oEmit 61
7803: oJumpForward 7828
7805: oError 16
7807: oJumpForward 7828
7809: oEmit 62
7811: oJumpForward 7828
7813: Choice Lookup Table
          28   7809
          22   7805
          26   7805
          27   7801
          24   7797
          23   7793
7826: oError 17
7828: oTypeSPop
7829: oInputChoice 7837
7831: oJumpForward 7845
7833: oJumpForward 7843
7835: oJumpForward 7843
7837: Choice Lookup Table
          12   7835
          14   7831
7842: oEndChoice
7843: oJumpBack 7788
7845: oJumpForward 7850
7847: Choice Lookup Table
          13   7788
7850: oReturn
7851: oLocalSpace 0
7853: oReturn
7854: oLocalSpace 0
7856: oReturn
7857: oLocalSpace 0
7859: oScopeCurrent
7860: oPushResult
7861: oSetResult 14
7863: oPushResult
7864: oNodeGetInt
7865: oPop 2
7867: oReturn
7868: oReturn
7869: oLocalSpace 0
7871: oGetParam 1
7873: oPushResult
7874: oSetResult 20
7876: oPushResult
7877: oNodeGet
7878: oPop 2
7880: oPushResult
7881: oSetResult 14
7883: oPushResult
7884: oNodeGetInt
7885: oPop 2
7887: oReturn
7888: oReturn
7889: oLocalSpace 0
7891: oCall 7857
7893: oPushResult
7894: oGetParam 1
7896: oPushResult
7897: oCall 7869
7899: oPop 1
7901: oPushResult
7902: subtract
7903: oPop 2
7905: oReturn
7906: oReturn
7907: oLocalSpace 1
7909: oGetAddrLocal 1
7911: oPushResult
7912: oTypeSNodeType
7913: oAssign
7914: oTypeSPop
7915: oGetLocal 1
7917: oPushResult
7918: oTypeSNodeType
7919: oPushResult
7920: equal_node_type
7921: oPop 2
7923: oChoice 7929
7925: oError 14
7927: oJumpForward 7932
7929: Choice Lookup Table
           0   7925
7932: oReturn
7933: oLocalSpace 0
7935: oTypeSNodeType
7936: oChoice 7940
7938: oJumpForward 7945
7940: Choice Lookup Table
          23   7938
7943: oError 7
7945: oTypeSPop
7946: oReturn
7947: oLocalSpace 0
7949: oTypeSNodeType
7950: oChoice 7954
7952: oJumpForward 7959
7954: Choice Lookup Table
          23   7952
7957: oError 7
7959: oReturn
7960: oLocalSpace 0
7962: oTypeSNodeType
7963: oChoice 7967
7965: oJumpForward 7972
7967: Choice Lookup Table
          24   7965
7970: oError 8
7972: oTypeSPop
7973: oReturn
7974: oLocalSpace 0
7976: oTypeSNodeType
7977: oChoice 7981
7979: oJumpForward 7986
7981: Choice Lookup Table
          24   7979
7984: oError 8
7986: oReturn
7987: oLocalSpace 1
7989: oGetAddrLocal 1
7991: oPushResult
7992: oGetParam 2
7994: oPushResult
7995: oNodeNew
7996: oPop 1
7998: oAssign
7999: oGetLocal 1
8001: oPushResult
8002: oSetResult 17
8004: oPushResult
8005: oGetParam 1
8007: oPushResult
8008: oNodeSetInt
8009: oPop 3
8011: oGetLocal 1
8013: oPushResult
8014: oTypeAdd
8015: oPop 1
8017: oGetLocal 1
8019: oReturn
8020: oReturn
8021: oLocalSpace 1
8023: oGetAddrLocal 1
8025: oPushResult
8026: oGetParam 3
8028: oPushResult
8029: oNodeNew
8030: oPop 1
8032: oAssign
8033: oGetLocal 1
8035: oPushResult
8036: oSetResult 4
8038: oPushResult
8039: oGetParam 1
8041: oPushResult
8042: oNodeSetInt
8043: oPop 3
8045: oGetLocal 1
8047: oReturn
8048: oReturn
8049: oLocalSpace 1
8051: oGetAddrLocal 1
8053: oPushResult
8054: oGetParam 1
8056: oPushResult
8057: oSetResult 33
8059: oPushResult
8060: oNodeGet
8061: oPop 2
8063: oAssign
8064: oGetLocal 1
8066: oPushResult
8067: oNodeNull
8068: oPop 1
8070: oChoice 8126
8072: oGetAddrLocal 1
8074: oPushResult
8075: oSetResult 28
8077: oPushResult
8078: oNodeNew
8079: oPop 1
8081: oAssign
8082: oGetLocal 1
8084: oPushResult
8085: oSetResult 34
8087: oPushResult
8088: oGetParam 1
8090: oPushResult
8091: oNodeSet
8092: oPop 3
8094: oGetLocal 1
8096: oPushResult
8097: oSetResult 17
8099: oPushResult
8100: oSetResult 8
8102: oPushResult
8103: oNodeSetInt
8104: oPop 3
8106: oGetLocal 1
8108: oPushResult
8109: oTypeAdd
8110: oPop 1
8112: oGetParam 1
8114: oPushResult
8115: oSetResult 33
8117: oPushResult
8118: oGetLocal 1
8120: oPushResult
8121: oNodeSet
8122: oPop 3
8124: oJumpForward 8129
8126: Choice Lookup Table
           1   8072
8129: oGetLocal 1
8131: oReturn
8132: oReturn
8133: oLocalSpace 0
8135: oGetParam 1
8137: oPushResult
8138: oNodeType
8139: oPop 1
8141: oChoice 8169
8143: oMININT
8144: oReturn
8145: oJumpForward 8183
8147: oSetResult 0
8149: oReturn
8150: oJumpForward 8183
8152: oSetResult 0
8154: oReturn
8155: oJumpForward 8183
8157: oGetParam 1
8159: oPushResult
8160: oSetResult 36
8162: oPushResult
8163: oNodeGetInt
8164: oPop 2
8166: oReturn
8167: oJumpForward 8183
8169: Choice Lookup Table
          30   8157
          26   8152
          24   8147
          23   8143
8178: oError 3
8180: oSetResult 0
8182: oReturn
8183: oReturn
8184: oLocalSpace 0
8186: oGetParam 1
8188: oPushResult
8189: oSetResult 22
8191: oPushResult
8192: oNodeGetInt
8193: oPop 2
8195: oPushResult
8196: oEmitInt
8197: oPop 1
8199: oReturn
8200: oLocalSpace 1
8202: oGetAddrGlobal 3
8204: oPushResult
8205: oSetResult 22
8207: oPushResult
8208: oSetResult 4
8210: oPushResult
8211: oCall 7987
8213: oPop 2
8215: oAssign
8216: oGetAddrGlobal 4
8218: oPushResult
8219: oSetResult 23
8221: oPushResult
8222: oSetResult 4
8224: oPushResult
8225: oCall 7987
8227: oPop 2
8229: oAssign
8230: oGetAddrGlobal 5
8232: oPushResult
8233: oSetResult 24
8235: oPushResult
8236: oSetResult 1
8238: oPushResult
8239: oCall 7987
8241: oPop 2
8243: oAssign
8244: oGetAddrGlobal 6
8246: oPushResult
8247: oSetResult 25
8249: oPushResult
8250: oSetResult 1
8252: oPushResult
8253: oCall 7987
8255: oPop 2
8257: oAssign
8258: oGetAddrGlobal 7
8260: oPushResult
8261: oSetResult 26
8263: oPushResult
8264: oSetResult 1
8266: oPushResult
8267: oCall 7987
8269: oPop 2
8271: oAssign
8272: oGetAddrGlobal 8
8274: oPushResult
8275: oSetResult 27
8277: oPushResult
8278: oSetResult 256
8280: oPushResult
8281: oCall 7987
8283: oPop 2
8285: oAssign
8286: oGetAddrLocal 1
8288: oPushResult
8289: oSetResult 15
8291: oPushResult
8292: oSetResult 5
8294: oPushResult
8295: oIdAdd_File
8296: oPushResult
8297: oCall 8021
8299: oPop 3
8301: oAssign
8302: oGetLocal 1
8304: oPushResult
8305: oSetResult 21
8307: oPushResult
8308: oGetGlobal 3
8310: oPushResult
8311: oNodeSet
8312: oPop 3
8314: oGetLocal 1
8316: oPushResult
8317: oScopeDeclare
8318: oPop 1
8320: oGetAddrLocal 1
8322: oPushResult
8323: oSetResult 15
8325: oPushResult
8326: oSetResult 5
8328: oPushResult
8329: oIdAdd_Integer
8330: oPushResult
8331: oCall 8021
8333: oPop 3
8335: oAssign
8336: oGetLocal 1
8338: oPushResult
8339: oSetResult 21
8341: oPushResult
8342: oGetGlobal 4
8344: oPushResult
8345: oNodeSet
8346: oPop 3
8348: oGetLocal 1
8350: oPushResult
8351: oScopeDeclare
8352: oPop 1
8354: oGetAddrLocal 1
8356: oPushResult
8357: oSetResult 15
8359: oPushResult
8360: oSetResult 5
8362: oPushResult
8363: oIdAdd_Boolean
8364: oPushResult
8365: oCall 8021
8367: oPop 3
8369: oAssign
8370: oGetLocal 1
8372: oPushResult
8373: oSetResult 21
8375: oPushResult
8376: oGetGlobal 5
8378: oPushResult
8379: oNodeSet
8380: oPop 3
8382: oGetLocal 1
8384: oPushResult
8385: oScopeDeclare
8386: oPop 1
8388: oGetAddrLocal 1
8390: oPushResult
8391: oSetResult 15
8393: oPushResult
8394: oSetResult 5
8396: oPushResult
8397: oIdAdd_Char
8398: oPushResult
8399: oCall 8021
8401: oPop 3
8403: oAssign
8404: oGetLocal 1
8406: oPushResult
8407: oSetResult 21
8409: oPushResult
8410: oGetGlobal 7
8412: oPushResult
8413: oNodeSet
8414: oPop 3
8416: oGetLocal 1
8418: oPushResult
8419: oScopeDeclare
8420: oPop 1
8422: oGetAddrLocal 1
8424: oPushResult
8425: oSetResult 15
8427: oPushResult
8428: oSetResult 5
8430: oPushResult
8431: oIdAdd_String
8432: oPushResult
8433: oCall 8021
8435: oPop 3
8437: oAssign
8438: oGetLocal 1
8440: oPushResult
8441: oSetResult 21
8443: oPushResult
8444: oGetGlobal 8
8446: oPushResult
8447: oNodeSet
8448: oPop 3
8450: oGetLocal 1
8452: oPushResult
8453: oScopeDeclare
8454: oPop 1
8456: oGetAddrLocal 1
8458: oPushResult
8459: oSetResult 14
8461: oPushResult
8462: oSetResult 4
8464: oPushResult
8465: oIdAdd_True
8466: oPushResult
8467: oCall 8021
8469: oPop 3
8471: oAssign
8472: oGetLocal 1
8474: oPushResult
8475: oSetResult 21
8477: oPushResult
8478: oGetGlobal 5
8480: oPushResult
8481: oNodeSet
8482: oPop 3
8484: oGetLocal 1
8486: oPushResult
8487: oSetResult 22
8489: oPushResult
8490: oSetResult 1
8492: oPushResult
8493: oNodeSetInt
8494: oPop 3
8496: oGetLocal 1
8498: oPushResult
8499: oScopeDeclare
8500: oPop 1
8502: oGetAddrLocal 1
8504: oPushResult
8505: oSetResult 14
8507: oPushResult
8508: oSetResult 4
8510: oPushResult
8511: oIdAdd_False
8512: oPushResult
8513: oCall 8021
8515: oPop 3
8517: oAssign
8518: oGetLocal 1
8520: oPushResult
8521: oSetResult 21
8523: oPushResult
8524: oGetGlobal 5
8526: oPushResult
8527: oNodeSet
8528: oPop 3
8530: oGetLocal 1
8532: oPushResult
8533: oSetResult 22
8535: oPushResult
8536: oSetResult 0
8538: oPushResult
8539: oNodeSetInt
8540: oPop 3
8542: oGetLocal 1
8544: oPushResult
8545: oScopeDeclare
8546: oPop 1
8548: oReturn
