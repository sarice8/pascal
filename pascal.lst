   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    ByteType
   2: Node    StringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 215:    oScopeBegin( 0, allocDown )
 224:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 235:    initScope = oScopeCurrent
 240:    oNodeSet( program, qMainRoutineScope, initScope )
 252:    oScopeEnd
      
 253:    @BlockDecls( nGlobalVar )
      
      
 260:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 266:    boolean isMain = true
 272:    @BlockStmt( mainLabel, globalScope, isMain )
      
 285:    oScopeEnd   % main routine scope
      
 286:    '.'
 288:    @CheckForUndefinedLabels
 290:    oScopeEnd   % global scope
 291:    @EndUsedUnits( program )   % used units scopes
 299:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 299: UsesClause( Node user ):
 301:    {
 301:       pIdent
 303:       Node unit = @FindOrCompileUnit( LAST_ID )
 313:       [ equal_node( unit, Null )
 323:          | false :
 324:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 336:             Node unitRef = oNodeNew( nUnitRef )
 346:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 365:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 384:             oScopeDeclare( unitRef )
 390:          | * :
 395:       ]
 395:       [
 395:          | ',' :
 397:          | * :  >
 404:       ]
 404:    }   
 406:    ';'
 409:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 409: ResolveUnitRef( inout Node decl ):
 411:    [ oNodeType( decl )
 418:       | nUnitRef :
 419:          Node scope = oNodeGet( decl, qPublicScope )
 432:          '.'
 434:          pIdent
 436:          decl = oScopeFindRequireInScope( scope )
 446:       | * :
 451:    ];
      
      
 452: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 454:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 467:    {
 467:       Node unit = oNodeIterValue( unitIt )
 477:       [ oNodeNull( unit )
 484:          | false :
 485:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 498:          | * :
 503:             >
 505:       ]
 505:       oNodeIterNext( unitIt )
 511:    }
 514:    ;
      
 514: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 516:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 529:    {
 529:       Node unit = oNodeIterValue( unitIt )
 539:       [ oNodeNull( unit )
 546:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 547:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 563:                | true :
 564:                | false :  #eInternalScopeMismatch
 568:             ]
 576:             oScopeEnd
 577:          | * :
 582:             >
 584:       ]
 584:       oNodeIterPrev( unitIt )
 590:    }
 593:    ;
      
      
 593: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 595:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 614:    [ equal_node( unit, Null )
 624:       | false :  >> unit
 628:       | * :
 633:    ]
      
         % If not, search for the source file on disk
 633:    boolean ok = oIncludeUnitFile( id )
 643:    [ ok
 646:       | false :  #eCantFindUnitFile  >> Null
 652:       | * :
 657:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 657:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 663:    oIncludeEnd
 664:    >> unit;
      
      
      
 668: Unit >> Node:
 670:    pUnit
 672:    pIdent
 674:    Node unit = oNodeNew( nUnit )
 684:    oNodeSetInt( unit, qIdent, LAST_ID )
 695:    Node unitImpl = oNodeNew( nUnitImpl )
 705:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 716:    oNodeSet( unit, qImpl, unitImpl )
 728:    ';'
      
         % mandatory sections
      
 730:    pInterface
 732:    [
 732:       | pUses :   @UsesClause( unit )
 741:       | * :
 746:    ]
 746:    @EnterUsedUnits( unit )
      
 753:    oScopeBegin( 0, allocGlobal )
 762:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 773:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 778:    oScopeBegin( 0, allocDown )
 787:    initScope = oScopeCurrent
 792:    oNodeSet( unit, qInitRoutineScope, initScope )
 804:    oScopeEnd
      
 805:    @UnitInterface( unit )
 812:    oScopeEnd  % interface scope
      
 813:    pImplementation
 815:    [
 815:       | pUses :   @UsesClause( unitImpl )
 824:       | * :
 829:    ]
 829:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 836:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 849:    oScopeBegin( 0, allocGlobal )
 858:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 869:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 887:    globalScope = oScopeCurrent
 892:    @UnitImplementation( unit )
      
 899:    [
 899:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 911:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 926:    ]
 926:    [
 926:       | pFinalization :  @UnitFinalization( unit, true )
 938:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 953:    ]
 953:    pEnd  '.'
      
 957:    oScopeEnd  % impl scope
 958:    oScopeEnd  % interface scope
 959:    @EndUsedUnits( unitImpl )  % used units scopes
 966:    @EndUsedUnits( unit )
 973:    oNodeAddLast( workspace, qUnits, unit )
 985:    >> unit;
      
      
 989: UnitInterface( Node unit ):
 991:    {[
 991:       | pConst :     @ConstDecl
 995:       | pType :      @TypeDecl
 999:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1008:       | pProcedure :
1010:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1016:          [
1016:             | pExternal :
1018:                @ExternalDecl( decl )
1025:                ';'
1027:             | * :
1032:          ]
      
1032:       | pFunction :
1034:          Node decl = @FuncHeaderDecl
1040:          [
1040:             | pExternal :
1042:                @ExternalDecl( decl )
1049:                ';'
1051:             | * :
1056:          ]
      
1056:       | * :          >
1071:    ]}
1074:    ;
      
1074: UnitImplementation( Node unit ):
1076:    @BlockDecls( nGlobalVar )
1084:    ;
      
      
1084: UnitInitialization( Node unit, boolean hasStmts ):
1086:    Label label = oLabelNew
1091:    .tLabel  oEmitLabel( label )
1099:    oNodeSetLabel( unit, qInitLabel, label )
      
1111:    int patchLS
1111:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1120:    Node scope
1120:    Code initCode
      
1120:    scope = oNodeGet( unit, qPublicScope )
1133:    initCode = oNodeGetCode( scope, qInitCode )
1146:    oEmitCode( initCode )
1152:    oNodeSetCode( scope, qInitCode, codeNull )
      
1164:    scope = oNodeGet( unit, qPrivateScope )
1177:    initCode = oNodeGetCode( scope, qInitCode )
1190:    oEmitCode( initCode )
1196:    oNodeSetCode( scope, qInitCode, codeNull )
      
1208:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1221:    [ hasStmts
1224:       | true :     
1225:          @Statement
1227:          {[
1227:             | ';' :  @Statement
1231:             | * :    >
1238:          ]}
1240:       | * :
1245:    ]
      
1245:    .tReturn
      
1247:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1259:    oPatch( patchLS, localSpace )
1268:    oScopeEnd   % init routine scope, for temporaries
1270:    ;
      
      
1270: UnitFinalization( Node unit, boolean hasStmts ):
1272:    Label label = oLabelNew
1277:    .tLabel  oEmitLabel( label )
1285:    oNodeSetLabel( unit, qFinalLabel, label )
      
1297:    int patchLS
1297:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1306:    oScopeBegin( 0, allocDown )
      
1315:    [ hasStmts
1318:       | true :     
1319:          @Statement
1321:          {[
1321:             | ';' :  @Statement
1325:             | * :    >
1332:          ]}
1334:       | * :
1339:    ]
      
1339:    .tReturn
      
1341:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1353:    oPatch( patchLS, localSpace )
1362:    oScopeEnd   % final routine scope, for temporaries
1364:    ;
      
      
1364: Block( node_type varNodeType, Label labelForBody ):
1366:    @BlockDecls( varNodeType )
1373:    @BlockStmt( labelForBody, oScopeCurrent, false )
1385:    @CheckForUndefinedLabels
1388:    ;
      
      
1388: BlockDecls( node_type varNodeType ):
1390:    {[
1390:       | pConst :     @ConstDecl
1394:       | pType :      @TypeDecl
1398:       | pVar :       @VarDecl( varNodeType )
1407:       | pLabel :     @LabelDecl
1411:       | pProcedure : @ProcDecl
1415:       | pFunction :  @FuncDecl
1419:       | * :          >
1436:    ]}
1438:    @CheckForUndefinedMethods
1441:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1441: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1444:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1444: CheckForUndefinedLabels:
1446:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1458:    {
1458:       Node decl = oNodeIterValue( it )
1468:       [ oNodeNull( decl )
1475:          | false :
1476:          | * :  >
1483:       ]
1483:       [ oNodeType( decl )
1490:          | nLabel :
1491:             [ oNodeGetBoolean( decl, qDefined )
1501:                | false :
1502:                   [ oNodeGetBoolean( decl, qUsed )
1512:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1515:                      | * :
1520:                   ]
1520:                | * :
1525:             ]
1525:          | * :
1530:       ]
1530:       oNodeIterNext( it )
1536:    }
1539:    ;
      
      
1539: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1541:    NodeIter it = oNodeGetIter( workspace, qUnits )
1554:    {
1554:       Node unit = oNodeIterValue( it )
1564:       [ oNodeNull( unit )
1571:          | true :  >
1574:          | false :
1576:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1584:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1599:             .tFreeActuals  oEmitInt( 0 )
1607:             oNodeIterNext( it )
1613:       ]
1621:    };
      
      
1624: FinalizeUnits:
1626:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1639:    {
1639:       Node unit = oNodeIterValue( it )
1649:       [ oNodeNull( unit )
1656:          | true :  >
1659:          | false :
1661:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1669:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1684:             .tFreeActuals  oEmitInt( 0 )
1692:             oNodeIterPrev( it )
1698:       ]
1706:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1709: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1711:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1719:    int patchLS
1719:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1728:    [ isMain
1731:       | true :  @InitializeUnits
1734:       | * :
1739:    ]
      
         % insert any code for initialization of this scope's variables
1739:    Code initCode = oNodeGetCode( varScope, qInitCode )
1752:    oEmitCode( initCode )
1758:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1770:    @Statement
      
1772:    [ isMain
1775:       | true :  @FinalizeUnits
1778:       | * :
1783:    ]
      
1783:    .tReturn
      
1785:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1797:    oPatch( patchLS, localSpace )
1807:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1807: MethodModifiers( Node decl ):
1809:    {[
1809:       | pCdecl :
1811:          oNodeSetBoolean( decl, qCdecl, true )
1823:          ';'
      
1825:       | * : >
1832:    ]}
1835:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1835: GetOrCreateInitCode( Node scope ) >> Code:
1837:    Code initCode = oNodeGetCode( scope, qInitCode )
1850:    [ equal_code( initCode, codeNull )
1860:       | true :
1861:          initCode = oCodeNew
1866:          oNodeSetCode( scope, qInitCode, initCode )
1878:       | * :
1883:    ]
1883:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1887: ExternalDecl( Node decl ):
1889:    [ equal_zero( @DeclLevel( decl ) )
1901:       | false :  #eExternalMethodCannotBeNested
1904:       | * :
1909:    ]
1909:    oNodeSetBoolean( decl, qExternal, true )
1921:    [
1921:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1923:          [
1923:             | pName :
1925:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1927:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1938:             | * :
1943:          ]
1943:       | * :
1948:    ]
1949:    ;
      
      
1949: ProcHeaderDecl >> Node:
1951:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1953:    boolean redeclaring = false
1959:    Node decl = oScopeFindInCurrentScope
      
1964:    [ oNodeNull( decl )
1971:       | true :
               % first declaration
1972:          decl = @newIdent( nProc, LAST_ID )
1985:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1996:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1998:          redeclaring = true
2004:          [ oNodeGetBoolean( decl, qBodyDefined )
2014:             | true : #eAlreadyDefined
2017:             | * :
2022:          ]
2022:          [ oNodeGetBoolean( decl, qExternal )
2032:             | true : #eAlreadyDefined
2035:             | * :
2040:          ]
2040:          [ oNodeType( decl )
2047:             | nProc :
2048:             | * : #eAlreadyDefined   % wrong kind
2055:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2055:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2074:          oNodeSet( decl, qParams, Null )
2086:    ]
      
2094:    int level = @ScopeLevel
2100:    boolean nested = greater( level, 0 )
2113:    inc( level )
2119:    oScopeBegin( level, allocUp )
2128:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2133:    [ nested
2136:       | true :
2137:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2152:       | * :
2157:    ]
      
2157:    @FormalArgDecl
2159:    oNodeSet( decl, qParams, paramScope )
2171:    oScopeEnd
2172:    ';'
      
2174:    [ redeclaring
2177:       | false : oScopeDeclare( decl )
2184:       | true :  % TO DO: check that qParams is consistent with qOldParams
2186:    ]
      
2194:    @MethodModifiers( decl )
2201:    >> decl;
      
      
2205: ProcDecl:
2207:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2213:    [
2213:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2215:       | pExternal : @ExternalDecl( decl )
      
2224:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2231:          Node paramScope = oNodeGet( decl, qParams )
2244:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2250:          int level = oNodeGetInt( paramScope, qLevel )
2263:          oScopeBegin( level, allocDown )
2272:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2283:          Label label = oNodeGetLabel( decl, qValue )
2296:          @Block( nLocalVar, label )
2306:          oNodeSetBoolean( decl, qBodyDefined, true )
2318:          oScopeEnd
      
2319:          oScopeEnd  % paramScope
2320:    ]
2320:    ';';
      
      
      
2323: FuncHeaderDecl >> Node:
2325:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2327:    boolean redeclaring = false
2333:    Node decl = oScopeFindInCurrentScope
      
2338:    [ oNodeNull( decl )
2345:       | true :
               % first declaration
2346:          decl = @newIdent( nFunc, LAST_ID )
2359:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2370:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2372:          redeclaring = true
2378:          [ oNodeGetBoolean( decl, qBodyDefined )
2388:             | true : #eAlreadyDefined
2391:             | * :
2396:          ]
2396:          [ oNodeType( decl )
2403:             | nFunc :
2404:             | * : #eAlreadyDefined   % wrong kind
2411:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2411:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2430:          oNodeSet( decl, qParams, Null )
2442:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2461:          oNodeSet( decl, qType, Null )
2473:    ]
      
2481:    int level = @ScopeLevel
2487:    boolean nested = greater( level, 0 )
2500:    inc( level )
2506:    oScopeBegin( level, allocUp )
2515:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2520:    [ nested
2523:       | true :
2524:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2539:       | * :
2544:    ]
      
2544:    @FormalArgDecl
2546:    oNodeSet( decl, qParams, paramScope )
      
2558:    ':'
      
2560:    Node theType
2560:    @TypeRef( theType )
2567:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2579:    Node ptrType = @PointerTypeTo( theType )
2590:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2606:    oScopeEnd
2607:    ';'
      
2609:    [ redeclaring
2612:       | false : oScopeDeclare( decl )
2619:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2621:    ]
      
2629:    @MethodModifiers( decl )
      
2636:    >> decl;
      
      
2640: FuncDecl:
2642:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2648:    [
2648:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2650:       | pExternal : @ExternalDecl( decl )
      
2659:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2666:          Node paramScope = oNodeGet( decl, qParams )
2679:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2685:          int level = oNodeGetInt( paramScope, qLevel )
2698:          oScopeBegin( level, allocDown )
2707:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2718:          Label label = oNodeGetLabel( decl, qValue )
2731:          @Block( nLocalVar, label )
2741:          oNodeSetBoolean( decl, qBodyDefined, true )
2753:          oScopeEnd
      
2754:          oScopeEnd  % paramScope
2755:    ]
2755:    ';';
      
      
2758: FormalArgDecl:
2760:    [
2760:       | '(' :
2762:          {
2762:             NodeVec decls = oNodeVecNew
2767:             Node decl
2767:             boolean isInOut = false
      
2773:             [
2773:                | pVar : isInOut = true
2781:                | * :
2786:             ]
      
2786:             {  pIdent
      
2788:                decl = @newIdent( nParam, LAST_ID )
2801:                oNodeSetBoolean( decl, qInOut, isInOut )
2813:                oNodeVecAppend( decls, decl )
      
2822:                [
2822:                   | ':' : >
2826:                   | ',' :
2828:                ]
2836:             }
      
2838:             Node theType
2838:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2845:             Node allocType
2845:             [ isInOut
2848:                | true :   allocType = @PointerTypeTo( theType )
2860:                | * :      allocType = theType
2871:             ]
      
2871:             int i = 0
2877:             {[ equal( i, oNodeVecSize( decls ) )
2891:                | false :
2892:                   decl = oNodeVecElement( decls, i )
      
2905:                   oNodeSet( decl, qType, theType )
2917:                   oScopeDeclare( decl )
2923:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2939:                   inc( i )
2945:                | * :
2950:                   >
2952:             ]}
      
2954:             oNodeVecDelete( decls )
      
2960:             [
2960:                | ')' : >
2964:                | ';' :
2966:             ]
2974:          }
2976:       | * :
2981:    ];
      
2982: ConstDecl:
2984:    {[
2984:       | pIdent :
2986:          Node decl = @newIdent( nConst, LAST_ID )
2999:          '='
      
3001:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3003:          int val = oValueTop
3008:          oValuePop
3009:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
3021:          oNodeSet( decl, qType, IntegerType )
      
3033:          oScopeDeclare( decl )
3039:          ';'
3041:       | * :
3046:          >
3048:    ]};
      
3051: TypeDecl:
3053:    {[
3053:       | pIdent :
3055:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3068:          '='
3070:          Node theType
3070:          @TypeRef( theType )
3077:          oNodeSet( decl, qType, theType )
3089:          oScopeDeclare( decl )
3095:          ';'
3097:       | * :
3102:          >
3104:    ]};
      
3107: VarDecl( node_type varNodeType ):
3109:    {[
3109:       | pIdent :
3111:          NodeVec decls = oNodeVecNew
3116:          Node decl
3116:          {
3116:             decl = @newIdent( varNodeType, LAST_ID )
3129:             oNodeVecAppend( decls, decl )
3138:             [
3138:                | ',' :
3140:                   pIdent
3142:                | * :
3147:                   >
3149:             ]
3149:          }
3151:          ':'
3153:          Node theType
3153:          @TypeRef( theType )
      
3160:          int i = 0
3166:          {[ equal( i, oNodeVecSize( decls ) )
3180:             | false :
3181:                decl = oNodeVecElement( decls, i )
3194:                oNodeSet( decl, qType, theType )
3206:                oScopeDeclareAlloc( decl )
3212:                inc( i )
3218:             | * :
3223:               >
3225:          ]}
      
               % optional initialization
3227:          [
3227:             | '=' :
3229:                [ oNodeVecSize( decls )
3236:                   | 1 :
3237:                   | * :  #eOnlyOneVarCanBeInitialized
3244:                ]
      
                     % we need an initCode stream for this scope
3244:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3254:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3260:                boolean changedScope = false
3266:                [ equal_zero( @ScopeLevel )
3273:                   | true : oScopeEnter( initScope )
3280:                            changedScope = true
3286:                   | * :
3291:                ]
                     % generate assignment in initCode stream
3291:                @LValueVar( decl )
3298:                @Expr
3300:                @MatchTypes
3302:                @Assign
3304:                [ changedScope
3307:                   | true : oScopeEnd
3309:                   | * :
3314:                ]
3314:                oCodePop
                   
3315:             | * :
3320:          ]
      
3320:          oNodeVecDelete( decls )
3326:          ';'
3328:       | * :
3333:          >
3335:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3338: LabelDecl:
3340:    {
3340:       Node decl
3340:       [
3340:          | pIdent :
3342:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3344:             oChangeIntLitToLabelIdent
3345:       ]
3353:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3366:       Label label = oLabelNew
3371:       oNodeSetLabel( decl, qValue, label )
3383:       oScopeDeclare( decl )
3389:       [
3389:          | ',' :
3391:          | * :
3396:             >
3398:       ]
3398:    }
3400:    ';'
3403:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3403: TypeRef( out Node resultType ):
3405:    [
3405:       | pIdent :           % previously named type (including intrinsics)
3407:          Node decl = oScopeFindRequire
3412:          @ResolveUnitRef( decl )
3419:          [ oNodeType( decl )
3426:             | nTypeDecl :
3427:                resultType = oNodeGet( decl, qType )
3440:             | * :
3445:                #eNotType
3447:                resultType = IntegerType
3453:          ]
         
3453:       | pArray :
3455:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3457:          NodeVec dimensions = oNodeVecNew
      
3462:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3462:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3472:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3484:             @ConstExpr
3486:             oNodeSetInt( subrange, qLow, oValueTop )
3497:             oValuePop
3498:             '..'
3500:             @ConstExpr
3502:             oNodeSetInt( subrange, qHigh, oValueTop )
3513:             oValuePop
3514:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3526:             oTypeAdd( subrange )
      
3532:             Node a = oNodeNew( nArrayType )
3542:             oNodeSet( a, qIndexType, subrange )
      
3554:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3563:             [
3563:                | ']' : >
3567:                | ',' :
3569:             ]
3577:          }
      
3579:          pOf
3581:          Node baseType
3581:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3588:          int dim = oNodeVecSize( dimensions )
      
3598:          {
3598:              dec(dim)
      
3604:              Node a = oNodeVecElement( dimensions, dim )
      
3617:              oNodeSet( a, qBaseType, baseType )
3629:              Node subrange = oNodeGet( a, qIndexType )
3642:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3669:              inc( width )
3675:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3701:              oTypeAdd( a )
3707:              baseType = a
      
3713:              [ equal_zero(dim)
3720:                  | true:  >
3723:                  | *:
3728:              ]
3728:          }
      
3730:          resultType = oNodeVecElement( dimensions, 0 )
3743:          oNodeVecDelete( dimensions )
      
3749:       | '^' :
3751:          Node theType
3751:          @TypeRef( theType )
3758:          resultType = @PointerTypeTo( theType )
      
3769:       | pRecord :
3771:          resultType = oNodeNew( nRecordType )
3781:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3790:          @VarDecl( nRecordField )
      
3797:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3809:          [ equal_zero( size )
3816:             | true : #eRecordEmpty
3819:             | * :
3824:          ]
      
3824:          pEnd
      
3826:          oNodeSet( resultType, qScope, oScopeCurrent )
3837:          oNodeSetInt( resultType, qSize, size )
3849:          oScopeEnd
3850:          oTypeAdd( resultType )
      
      
3856:       | '(' :
               % An enum type declaration.
3858:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
3865:       | pSet :
3867:          pOf
3869:          Node theType
3869:          @TypeRef( theType )
3876:       | * :       % this works for cases except where expr starts with an id
3891:          @ConstExpr '..' @ConstExpr
3897:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
3898: EnumTypeRef( out Node resultType ):
      
3900:    resultType = oNodeNew( nEnumType )
3910:    int value = 0
3916:    int numValues = 0
3922:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
3928:    Node outerScope = oScopeCurrent
3933:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
3942:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
3942:       pIdent
3944:       Node decl = @newIdent( nEnumValue, LAST_ID )
3957:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
3970:       oNodeSet( decl, qType, resultType )
3982:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
3994:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4007:       oNodeSetInt( decl, qNameOffset, nameOffset )
4019:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4031:       [
4031:          | '=', ':=' :
4033:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4035:             [ equal_zero( numValues )
4042:                | false :
4043:                   [ greater( oValueTop, value )
4052:                      | false :   #eEnumValueNotAscending
4055:                      | * :
4060:                   ]
4060:                | * :
4065:             ]
4065:             [ equal( value, oValueTop )
4074:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4075:                   oNodeSetBoolean( resultType, qHasGap, true )
4087:                | * :
4092:             ]
4092:             value = oValueTop
4097:             oValuePop
4098:          | * :
4105:       ]
4105:       oNodeSetInt( decl, qValue, value )
4117:       oNodeSetInt( decl2, qValue, value )
4129:       oScopeDeclare( decl )
      
4135:       oScopeEnter( outerScope )
4141:       oScopeDeclare( decl2 )
4147:       oScopeEnd
      
4148:       inc( value )
4154:       inc( numValues )
4160:       [
4160:          | ',' :
4162:          | * :    >
4169:       ]
4169:    }
4171:    ')'
      
4173:    oNodeSet( resultType, qScope, oScopeCurrent )
4184:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4196:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4197:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4208:    oScopeEnter( globalScope )
4214:    int size = multiply( add( numValues, 1 ), 16 )
4234:    int addr = oScopeAlloc( size, 8 )
4247:    oScopeEnd
4248:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4260:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4280:    {
4280:       Node enumValue = oNodeIterValue( it )
4290:       [ oNodeNull( enumValue )
4297:          | true :  >
4300:          | * :
4305:       ]
4305:       .tPushAddrGlobal  oEmitInt( addr )
4313:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4328:       .tAssignI
4330:       addr = add( addr, 8 )
4343:       .tPushAddrGlobal  oEmitInt( addr )
4351:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4366:       .tAssignP
4368:       addr = add( addr, 8 )
4381:       oNodeIterNext( it )
4387:    }
         % final table entry
4389:    .tPushAddrGlobal  oEmitInt( addr )
4397:    .tPushConstI  oEmitInt( 0 )
4405:    .tAssignI
4407:    addr = add( addr, 8 )
4420:    .tPushAddrGlobal  oEmitInt( addr )
4428:    .tPushConstI  oEmitInt( 0 )
4436:    .tAssignP
4438:    addr = add( addr, 8 )
4451:    oCodePop
      
4452:    oTypeAdd( resultType )
4459:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
4459: ConstExpr:
4461:    [
4461:       | pIntLit :
4463:          oValuePush( TOKEN_VALUE )
4468:       | pIdent :
4470:          Node decl = oScopeFindRequire
4475:          @ResolveUnitRef( decl )
4482:          [ oNodeType( decl )
4489:             | nConst :
4490:                oValuePush( oNodeGetInt( decl, qValue ) )
4503:             | * :
4508:                #eNotConst
4510:                oValuePush( 0 )
4516:          ]
4516:       | pMinus :
4518:          @ConstExpr
4520:          oValueNegate
4521:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4532: Expr:
4534:    Label falseLabel = labelNull
      
4540:    @ExprAllowCF( falseLabel )
4547:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4555: BooleanExprControlFlow( out Label falseLabel ):
4557:    @ExprAllowCF( falseLabel )
4564:    [ oTypeSNodeType
4566:       | nBooleanCFType :
4567:       | nBooleanType :
               % convert value to control flow
4569:          falseLabel = oLabelNew
4574:          .tJumpFalse  oEmitLabel( falseLabel )
4582:       | * :
4589:          #eNotBoolean
4591:    ]
4591:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4593: CFToVal( inout Label falseLabel ):
4595:    [ oTypeSNodeType
4597:       | nBooleanCFType :
4598:          Label doneLabel = oLabelNew
4603:          .tPushConstI  oEmitInt( 1 )
4611:          .tJump  oEmitLabel( doneLabel )
4619:          .tLabel  oEmitLabel( falseLabel )
4627:          .tPushConstI  oEmitInt( 0 )
4635:          .tLabel  oEmitLabel( doneLabel )
4643:          oTypeSPop
4644:          oTypeSPush( BooleanType )
4650:          falseLabel = labelNull
4656:       | * :
4661:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4662: ValToCF( out Label falseLabel ):
4664:    [ oTypeSNodeType
4666:       | nBooleanType :
4667:          falseLabel = oLabelNew
4672:          .tJumpFalse  oEmitLabel( falseLabel )
4680:          oTypeSPop
4681:          oTypeSPush( BooleanCFType )
4687:       | * :
4692:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
4693: ExprAllowCF( out Label falseLabel ):
4695:    @BoolExprAllowCF( falseLabel )
4702:    {[
4702:       | '=' :
4704:          @CFToVal( falseLabel )
4711:          @PromoteToIntOptional
4713:          @BoolExprAllowCF( falseLabel )
4720:          @CFToVal( falseLabel )
4727:          @PromoteToIntOptional
4729:          @MatchTypes
4731:          [ oTypeSNodeType
4733:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
4736:             | nPointerType :                .tEqualP
4740:             | nCharType, nStringType :      #eNotImplemented
4744:             | * :                           #eNotAllowed
4761:          ]
4761:          oTypeSPop
4762:          oTypeSPush( BooleanType )
      
4768:       | '<>' :
4770:          @CFToVal( falseLabel )
4777:          @PromoteToIntOptional
4779:          @BoolExprAllowCF( falseLabel )
4786:          @CFToVal( falseLabel )
4793:          @PromoteToIntOptional
4795:          @MatchTypes
4797:          [ oTypeSNodeType
4799:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
4802:             | nPointerType :                .tNotEqualP
4806:             | nCharType, nStringType :      #eNotImplemented
4810:             | * :                           #eNotAllowed
4827:          ]
4827:          oTypeSPop
4828:          oTypeSPush( BooleanType )
      
4834:       | '<' :
4836:          @CFToVal( falseLabel )
4843:          @PromoteToIntOptional
4845:          @BoolExprAllowCF( falseLabel )
4852:          @CFToVal( falseLabel )
4859:          @PromoteToIntOptional
4861:          @MatchTypes
4863:          [ oTypeSNodeType
4865:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
4868:             | nCharType, nStringType :      #eNotImplemented
4872:             | * :                           #eNotAllowed
4887:          ]
4887:          oTypeSPop
4888:          oTypeSPush( BooleanType )
      
4894:       | '>' :
4896:          @CFToVal( falseLabel )
4903:          @PromoteToIntOptional
4905:          @BoolExprAllowCF( falseLabel )
4912:          @CFToVal( falseLabel )
4919:          @PromoteToIntOptional
4921:          @MatchTypes
4923:          [ oTypeSNodeType
4925:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
4928:             | nCharType, nStringType :      #eNotImplemented
4932:             | * :                           #eNotAllowed
4947:          ]
4947:          oTypeSPop
4948:          oTypeSPush( BooleanType )
      
4954:       | '<=' :
4956:          @CFToVal( falseLabel )
4963:          @PromoteToIntOptional
4965:          @BoolExprAllowCF( falseLabel )
4972:          @CFToVal( falseLabel )
4979:          @PromoteToIntOptional
4981:          @MatchTypes
4983:          [ oTypeSNodeType
4985:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
4988:             | nCharType, nStringType :      #eNotImplemented
4992:             | * :                           #eNotAllowed
5007:          ]
5007:          oTypeSPop
5008:          oTypeSPush( BooleanType )
      
5014:       | '>=' :
5016:          @CFToVal( falseLabel )
5023:          @PromoteToIntOptional
5025:          @BoolExprAllowCF( falseLabel )
5032:          @CFToVal( falseLabel )
5039:          @PromoteToIntOptional
5041:          @MatchTypes
5043:          [ oTypeSNodeType
5045:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
5048:             | nCharType, nStringType :      #eNotImplemented
5052:             | * :                           #eNotAllowed
5067:          ]
5067:          oTypeSPop
5068:          oTypeSPush( BooleanType )
      
5074:       | * :
5089:          >
5091:    ]};
      
      
5094: BoolExprAllowCF( out Label falseLabel ):
5096:    Label trueLabel = labelNull
      
5102:    @BoolTermAllowCF( falseLabel )
5109:    {[
5109:       | pOr :
5111:          [ oTypeSNodeType
5113:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5114:                [ equal_label( trueLabel, labelNull )
5124:                   | true :  trueLabel = oLabelNew
5130:                   | * :
5135:                ]
5135:                .tJump  oEmitLabel( trueLabel )
5143:             | nBooleanType :
5145:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5152:                [ equal_label( trueLabel, labelNull )
5162:                   | true :  trueLabel = oLabelNew
5168:                   | * :
5173:                ]
5173:                .tJump  oEmitLabel( trueLabel )
5181:             | * : #eNotBoolean
5190:          ]
5190:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5191:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5199:          falseLabel = labelNull
5205:          @BoolTermAllowCF( falseLabel )
      
5212:          [ oTypeSNodeType
5214:             | nBooleanCFType :
5215:             | nBooleanType :
5217:                @ValToCF( falseLabel )
5224:             | * : #eNotBoolean
5233:          ]
      
5233:          oTypeSPop
5234:          oTypeSPush( BooleanCFType )
      
5240:       | * :
5245:          >
5247:    ]}
      
         % any short-circuit trues jump here to the end
5249:    [ equal_label( trueLabel, labelNull )
5259:       | false :
5260:          .tLabel  oEmitLabel( trueLabel )
5268:       | * :
5273:    ]
5274:    ;
      
      
5274: BoolTermAllowCF( out Label falseLabel ):
5276:    Label overallFalseLabel = labelNull
      
5282:    @BoolFactorAllowCF( falseLabel )
5289:    {[
5289:       | pAnd :
5291:          [ oTypeSNodeType
5293:             | nBooleanCFType :
5294:             | nBooleanType :
5296:                @ValToCF( falseLabel )
5303:             | * :
5310:                #eNotBoolean
5312:          ]
5312:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5313:          [ equal_label( overallFalseLabel, labelNull )
5323:             | true :
5324:                overallFalseLabel = oLabelNew
5329:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5343:                falseLabel = overallFalseLabel
5349:             | * :
5354:          ]
      
5354:          Label factorFalseLabel = labelNull
5360:          @BoolFactorAllowCF( factorFalseLabel )
      
5367:          [ oTypeSNodeType
5369:             | nBooleanCFType :
5370:             | nBooleanType :
5372:                @ValToCF( factorFalseLabel )
5379:             | * : #eNotBoolean
5388:          ]
5388:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5402:       | * :
5407:          >
5409:    ]};
      
5412: BoolFactorAllowCF( out Label falseLabel ):
5414:    [
5414:       | pNot :
5416:          Label factorFalseLabel = labelNull
      
5422:          @BoolFactorAllowCF( factorFalseLabel )
5429:          [ oTypeSNodeType
5431:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5432:                falseLabel = oLabelNew
5437:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5445:                .tLabel  oEmitLabel( factorFalseLabel )
      
5453:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5455:                .tNot
      
5457:             | * : #eNotBoolean
5466:          ]
      
5466:       | * :
5471:          @ArithExprAllowCF( falseLabel )
5478:    ];
      
5479: ArithExprAllowCF( out Label falseLabel ):
5481:    @TermAllowCF( falseLabel )
5488:    {[
5488:       | pPlus :
5490:          @PromoteToIntPop
5492:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5499:          @PromoteToInt
5501:          .tAddI
5503:       | pMinus :
5505:          @PromoteToIntPop
5507:          @TermAllowCF( falseLabel )
5514:          @PromoteToInt
5516:          .tSubI
5518:       | * :
5525:          >
5527:    ]};
      
5530: TermAllowCF( out Label falseLabel ):
5532:    @FactorAllowCF( falseLabel )
5539:    {[
5539:       | pTimes :
5541:          @PromoteToIntPop
5543:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5550:          @PromoteToInt
5552:          .tMultI
5554:       | pDivide :
5556:          @PromoteToIntPop
5558:          @FactorAllowCF( falseLabel )
5565:          @PromoteToInt
5567:          .tDivI
5569:       | * :
5576:          >
5578:    ]};
      
5581: FactorAllowCF( out Label falseLabel ):
5583:    [
5583:       | pPlus :
5585:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5592:          @PromoteToInt
5594:       | pMinus :
5596:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5603:          @PromoteToInt
5605:          .tNegI
5607:       | * :
5614:          @PrimaryAllowCF( falseLabel )
5621:    ];
      
5622: PrimaryAllowCF( out Label falseLabel ):
5624:    [
5624:       | pIntLit :
5626:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5633:          oTypeSPush( IntegerType )
      
5639:       | pCharLit :
5641:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5648:          oTypeSPush( CharType )
      
5654:       | '(' :
5656:          @ExprAllowCF( falseLabel )
5663:          ')'
      
5665:       | pStrLit :
5667:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
5676:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
5684:          oTypeSPush( StringType )
      
5690:       | pIdent :
5692:          Node decl = oScopeFindRequire
5697:          @ResolveUnitRef( decl )
5704:          Node theType
      
5704:          [ oNodeType( decl )
5711:             | nFunc :
5712:                @Call( decl )
      
5719:             | nBuiltInFunc :
5721:                @CallBuiltInFunc( decl )
      
5728:             | nConst, nEnumValue :
5730:                theType = oNodeGet( decl, qType )
5743:                oTypeSPush( theType )
5749:                [ oTypeSNodeType
5751:                   | nIntegerType, nEnumType, nBooleanType :
5752:                      .tPushConstI @EmitValue( decl )
5761:                   | * :
5770:                      #eNotImplemented
5772:                ]
      
5772:             | nGlobalVar, nLocalVar, nParam :
5774:                @VarExpr( decl )
      
5781:             | * :
5798:                #eNotValue
5800:                oTypeSPush( IntegerType )
5806:          ]
      
5806:       | '@' :        % @var -- pointer to var
5808:          pIdent
      
5810:          Node decl = oScopeFindRequire
5815:          @ResolveUnitRef( decl )
5822:          Node theType
      
5822:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5829:          theType = oTypeSTop
5834:          oTypeSPop
5835:          Node ptrType = @PointerTypeTo( theType )
5846:          oTypeSPush( ptrType )
      
5852:       | * :
5867:          #eNotValue
5869:          oTypeSPush( IntegerType )
5875:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5876: VarExpr( Node decl ):
5878:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5891:    int uplevels = @DeclUpLevels( decl )
      
5902:    oTypeSPush( theType )
5908:    [ oTypeSNodeType
5910:       | nIntegerType, nEnumType :
5911:          [ oNodeType( decl )
5918:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
5928:             | nLocalVar :
5930:                [ equal_zero( uplevels )
5937:                   | true :  .tPushLocalI  @EmitValue( decl )
5947:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5967:                ]
5967:             | nParam :
5969:                [ oNodeGetBoolean( decl, qInOut )
5979:                   | true :    % VAR param points to the var.  Auto dereference.
5980:                      [ equal_zero( uplevels )
5987:                         | true :  .tPushParamP  @EmitValue( decl )
5997:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6017:                      ]
6017:                      .tFetchI
6019:                   | * :
6024:                      [ equal_zero( uplevels )
6031:                         | true :  .tPushParamI  @EmitValue( decl )
6041:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6061:                      ]
6061:                ]
6061:          ]
      
6071:       | nBooleanType, nByteType, nCharType :
6073:          [ oNodeType( decl )
6080:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
6090:             | nLocalVar :
6092:                [ equal_zero( uplevels )
6099:                   | true :  .tPushLocalB  @EmitValue( decl )
6109:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6129:                ]
6129:             | nParam :
6131:                [ oNodeGetBoolean( decl, qInOut )
6141:                   | true :    % VAR param points to the var.  Auto dereference.
6142:                      [ equal_zero( uplevels )
6149:                         | true :  .tPushParamP  @EmitValue( decl )
6159:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6179:                      ]
6179:                      .tFetchB
6181:                   | * :
6186:                      [ equal_zero( uplevels )
6193:                         | true :  .tPushParamB  @EmitValue( decl )
6203:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6223:                      ]
6223:                ]
6223:          ]
      
6233:       | nStringType, nFileType :
6235:          #eNotImplemented
      
6237:       | nPointerType :
6239:          [ oNodeType( decl )
6246:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
6256:             | nLocalVar :
6258:                [ equal_zero( uplevels )
6265:                   | true :  .tPushLocalP  @EmitValue( decl )
6275:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6295:                ]
6295:             | nParam :
6297:                [ oNodeGetBoolean( decl, qInOut )
6307:                   | true :    % VAR param points to the var.  Auto dereference.
6308:                      [ equal_zero( uplevels )
6315:                         | true :  .tPushParamP  @EmitValue( decl )
6325:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6345:                      ]
6345:                      .tFetchP
6347:                   | * :
6352:                      [ equal_zero( uplevels )
6359:                         | true :  .tPushParamP  @EmitValue( decl )
6369:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6389:                      ]
6389:                ]
6389:          ]
6399:          [
6399:             | '^' :             % dereferenced
6401:                oTypeSPop
6402:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6415:                @LValueIndexes
6417:                @FetchVar
6419:             | * :               % just ptr value alone
6424:          ]
      
6424:       | nArrayType, nRecordType :
               % compound type
               % first, push addr of start of var
6426:          [ oNodeType( decl )
6433:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6443:             | nLocalVar :
6445:                [ equal_zero( uplevels )
6452:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6462:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6482:                ]
6482:             | nParam :
6484:                [ oNodeGetBoolean( decl, qInOut )
6494:                   | true :    % VAR param points to the var.  Auto dereference.
6495:                      [ equal_zero( uplevels )
6502:                         | true :  .tPushParamP  @EmitValue( decl )
6512:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6532:                      ]
6532:                   | * :
6537:                      [ equal_zero( uplevels )
6544:                         | true :  .tPushAddrParam  @EmitValue( decl )
6554:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6574:                      ]
6574:                ]
6574:          ]
               % modify addr for subscripts, field references, etc
6584:          @LValueIndexes
               % get final value
6586:          @FetchVar
6588:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
6613: FetchVar:
6615:    [ oTypeSNodeType
6617:       | nIntegerType, nEnumType :  .tFetchI
6620:       | nBooleanType, nByteType, nCharType :  .tFetchB
6624:       | nStringType, nFileType :   #eNotImplemented
6628:       | nPointerType :             .tFetchP
6632:       | nArrayType, nRecordType :  % compound type; leave as addr
6634:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
6659: LValueIndexes:
6661:    {[
6661:       | '[' :       @ArraySubscripts
6665:       | '.' :       @RecordFieldRef
6669:       | '^' :       @PointerDeref
6673:       | * :         >
6684:    ]};
      
6687: ArraySubscripts:
6689:    [ oTypeSNodeType
6691:       | nArrayType :
6692:       | * :       #eNotArray
6699:    ]
6699:    {
6699:       [ oTypeSNodeType
6701:          | nArrayType :
6702:          | * :    #eTooManySubscripts
6709:       ]
      
            % low subscript of this dimension
6709:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
6726:       Node baseType
6726:       baseType = oNodeGet( oTypeSTop, qBaseType )
6738:       oTypeSPop
6739:       oTypeSPush( baseType )
      
6745:       @Expr
6747:       @RequireIntPop
            % adjust for low subscript
6749:       [ equal_zero( low )
6756:          | false :
6757:             .tPushConstI oEmitInt( low ) .tSubI
6767:          | * :
6772:       ]
      
            % multiply by element size
6772:       int size = oNodeGetInt( baseType, qSize )
6785:       [ equal( size, 1 )
6795:          | false :
6796:             .tPushConstI oEmitInt( size ) .tMultI
6806:          | * :
6811:       ]
      
            % update start address
6811:       .tAddPI
6813:       [
6813:          | ']' :  >
6817:          | ',' :
6819:       ]
6827:    };
      
      
6830: RecordFieldRef:
6832:    [ oTypeSNodeType
6834:       | nRecordType :
6835:       | * :    #eNotRecord
6842:    ]
6842:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
6854:    pIdent
6856:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
6861:    [ oNodeType( field )
6868:       | nRecordField :
6869:       | * :   #eNotRecordField
6876:    ]
6876:    oScopeEnd
6877:    int offset = oNodeGetInt( field, qValue )
6890:    [ equal_zero( offset )
6897:       | false :
6898:          .tPushConstI oEmitInt( offset ) .tAddPI
6908:       | * :
6913:    ]
      
         % replace the type on the type stack, with the field type
6913:    oTypeSPop
6914:    oTypeSPush( oNodeGet( field, qType ) )
6928:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
6928: PointerDeref:
6930:    [ oTypeSNodeType
6932:       | nPointerType :
6933:       | * :       #eNotPointer
6940:    ]
6940:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
6942:    Node theType = oTypeSTop
6947:    oTypeSPop
6948:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6962:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6962: CoerceType:
6964:    node_type nt = oTypeSNodeType
6969:    oTypeSPop
6970:    [ equal_node_type( nt, oTypeSNodeType )
6979:       | false :
               % Can we implicitly convert the value to the desired type?
6980:          [ oTypeSNodeType
6982:             | nIntegerType :
6983:                [ nt
6986:                   | nByteType :   .tCastBtoI  >>
6990:                   | * :
6995:                ]
6995:             | nByteType :
6997:                [ nt
7000:                   | nIntegerType :   .tCastItoB  >>
7004:                   | * :
7009:                ]
7009:             | * :
7016:          ]
7016:          #eTypeMismatch
7018:       | * :
7023:    ];
      
      
      % Called on first use of an extern method
      %
7024: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7026:    int strAddr
7026:    String externalName = oNodeGetString( method, qExternalName )
7039:    [ equal_string( externalName, stringNull )
7049:       | true :
7050:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7071:       | false :
7073:          strAddr = oStringAllocLit( externalName )
7083:    ]
7091:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
7107:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7107: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
7109:    [ oNodeGetBoolean( method, qExternal )
7119:       | true :
7120:          [ oNodeGetBoolean( method, qUsed )
7130:             | false :
                     % define the extern label on first use
7131:                @DefineExternLabel( method )
7138:             | * :
7143:          ]
7143:      | * :
7148:    ]
7148:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
7160:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
7173:    Node resultType
7173:    int tempOffset
      
7173:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
7190:    [ isFunc
7193:       | true :
7194:          resultType = oNodeGet( method, qType )
7207:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
7217:       | * :
7222:    ]
         
      
7222:    Node paramScope = oNodeGet( method, qParams )
7235:    int actualsSize = oNodeGetInt( paramScope, qSize )
7248:    [ cdecl
7251:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
7260:       | false :  .tAllocActuals  oEmitInt( actualsSize )
7270:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
7278:    [ greater( @DeclLevel( method ), 0 )
7293:       | true :
7294:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
7302:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
7321:          .tAssignP
7323:       | * :
7328:    ]
      
      
7328:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
7341:    Node param = oNodeIterValue( paramIter )
7351:    [
7351:       | '(' :
            
7353:          {
7353:             [ oNodeNull( param )
7360:                | true : >
7363:                | * :
7368:             ]
      
7368:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
7381:             .tPushAddrActual oEmitInt( offset )
7389:             oTypeSPush( oNodeGet( param, qType ) )
      
7402:             [ oNodeGetBoolean( param, qInOut )
7412:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
7413:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
7415:                           @MatchTypes
      
7417:                           .tAssignP
      
7419:                | false :  @Expr
7423:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
7425:                           [ oTypeSNodeType
7427:                              | nIntegerType, nEnumType : .tAssignI
7430:                              | nBooleanType, nByteType, nCharType :  .tAssignB
7434:                              | nStringType, nFileType :   #eNotImplemented
7438:                              | nPointerType :            .tAssignP
7442:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
7444:                                  int size = oNodeGetInt( oTypeSTop, qSize )
7456:                                  .tCopy  oEmitInt( size )    % multi-word copy
7464:                           ]
7488:             ]
7496:             oTypeSPop
      
7497:             oNodeIterNext( paramIter )
7503:             param = oNodeIterValue( paramIter )
7513:             [ oNodeNull( param )
7520:                | true :  >
7523:                | false :
7525:             ]
      
7533:             ','
7535:          }
      
7537:          ')'
      
7539:       | * :
7544:    ]
      
7544:    [ oNodeNull( param )
7551:       | false :    #eMissingParameter
7554:       | * :
7559:    ]
      
7559:    [ isFunc
7562:       | true :
               % Pass result temp as an additional VAR parameter.
7563:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
7578:          .tPushAddrLocal  oEmitInt( tempOffset )
7586:          .tAssignP
7588:       | * :
7593:    ]
      
7593:    [ cdecl
7596:       | true :
7597:          .tCallCdecl  @EmitValue( method )
7606:       | false :
7608:          .tCall   @EmitValue( method )
7617:    ]
      
7625:    [ isFunc
7628:       | true :
               % push return value from temp
7629:          oTypeSPush( resultType )
      
7635:          [ oTypeSNodeType
7637:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
7646:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
7656:             | nStringType, nFileType :  #eNotImplemented
7660:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
7670:             | nArrayType, nRecordType :   % compound type: push address
7672:                                .tPushAddrLocal  oEmitInt( tempOffset )
7680:          ]
7704:       | * :
7709:    ]
         
7709:    .tFreeActuals  oEmitInt( actualsSize )
7718:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7718: CallBuiltInFunc( Node method ):
      
         % Ord(x)
7720:    [ oNodeEqual( method, BuiltIn_Ord )
7730:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
7731:          '('
7733:          @Expr
7735:          [ oTypeSNodeType
7737:             | nIntegerType, nEnumType :
7738:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
7742:             | * :  #eTypeMismatch
7757:          ]
7757:          oTypeSPop
7758:          oTypeSPush( IntegerType )
7764:          ')'
7766:          >>
7767:       | * :
7772:    ]
      
         % Chr(x)
7772:    [ oNodeEqual( method, BuiltIn_Chr )
7782:       | true :
               % parameter is integer
               % result is char
7783:          '('
7785:          @Expr
7787:          [ oTypeSNodeType
7789:             | nIntegerType :    .tCastItoB
7792:             | nByteType :
7794:             | * :  #eTypeMismatch
7803:          ]
7803:          oTypeSPop
7804:          oTypeSPush( CharType )
7810:          ')'
7812:          >>
7813:       | * :
7818:    ]
      
         % Pred(x)
7818:    [ oNodeEqual( method, BuiltIn_Pred )
7828:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
7829:          '('
7831:          @Expr
7833:          [ oTypeSNodeType
7835:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
7836:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
7845:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
7848:                   | * :
7853:                ]
7853:             | * :  #eTypeMismatch
7860:          ]
7860:          .tDecI
7862:          ')'
7864:          >>
7865:       | * :
7870:    ]
      
         % Succ(x)
7870:    [ oNodeEqual( method, BuiltIn_Succ )
7880:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
7881:          '('
7883:          @Expr
7885:          [ oTypeSNodeType
7887:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
7888:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
7897:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
7900:                   | * :
7905:                ]
7905:             | * :  #eTypeMismatch
7912:          ]
7912:          .tIncI
7914:          ')'
7916:          >>
7917:       | * :
7922:    ]
      
7922:    #eNotImplemented
7925:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
7925: Statement:
7927:    [
7927:       | pWriteln :     @WritelnStmt
7931:       | pWrite :       @WriteStmt
7935:       | pReadln :      @ReadlnStmt
7939:       | pRead :        @ReadStmt
7943:       | pIf :          @IfStmt
7947:       | pWhile :       @WhileStmt
7951:       | pFor :         @ForStmt
7955:       | pRepeat :      @RepeatStmt
7959:       | pBreak :       @BreakStmt
7963:       | pContinue :    @ContinueStmt
7967:       | pBegin :       @BeginStmt
7971:       | pIdent :       @LabelOrAssignOrCallStmt
7975:       | pGoto :        @GotoStmt
7979:       | pIntLit :      % should be an integer label
7981:                        oChangeIntLitToLabelIdent
7982:                        @LabelOrAssignOrCallStmt
7984:       | * :            % null statement : don't accept any tokens
8015:    ];
      
      
8016: LabelOrAssignOrCallStmt:
8018:    Node decl = oScopeFindRequire
8023:    @ResolveUnitRef( decl )
8030:    [ oNodeType( decl )
8037:       | nLabel :                          @LabelDefinition( decl )
8045:                                           @Statement
8047:       | nProc :                           @Call( decl )
8056:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8065:       | nFunc :                           @AssignResultStmt( decl )
8074:       | * :                               #eBadStatement
8091:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
8092: LabelDefinition( Node decl ):
8094:    [ oNodeGetBoolean( decl, qDefined )
8104:       | true :  #eAlreadyDefined
8107:       | * :
8112:    ]
8112:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8127:    oNodeSetBoolean( decl, qDefined, true )
8139:    ':'
8142:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
8142: AssignStmt( Node decl ):
      
8144:    @LValueVar( decl )
8151:    ':=' 
8153:    @Expr
8155:    @CoerceType
8157:    @Assign
8160:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8160: Assign:
8162:    [ oTypeSNodeType
8164:       | nIntegerType, nEnumType :  .tAssignI
8167:       | nBooleanType, nByteType, nCharType :  .tAssignB
8171:       | nStringType, nFileType :   #eNotImplemented
8175:       | nPointerType :             .tAssignP
            % compound var assigns; addrs of src, dest on stack
8179:       | nArrayType, nRecordType :
8181:           int size = oNodeGetInt( oTypeSTop, qSize )
8193:           .tCopy  oEmitInt( size )    % multi-word copy
8201:    ]
8225:    oTypeSPop
8227:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8227: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8229:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8245:       | false :   #eNotCurrentFunction
8248:       | * :
8253:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8253:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8268:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8281:    ':='
8283:    @Expr
8285:    @CoerceType
8287:    [ oTypeSNodeType
8289:       | nIntegerType, nEnumType : .tAssignI
8292:       | nBooleanType, nByteType, nCharType :  .tAssignB
8296:       | nStringType, nFileType :   #eNotImplemented
8300:       | nPointerType :            .tAssignP
            % compound var assigns; addrs of src, dest on stack
8304:       | nArrayType, nRecordType :
8306:           int size = oNodeGetInt( oTypeSTop, qSize )
8318:           .tCopy  oEmitInt( size )    % multi-word copy
8326:    ]
8350:    oTypeSPop
8352:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
8352: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8354:    pIdent
8356:    Node decl = oScopeFindRequire
8361:    @ResolveUnitRef( decl )
8368:    [ oNodeType( decl )
8375:       | nGlobalVar, nLocalVar, nParam :
8376:       | * :  #eNotVar
8387:    ]
8387:    @LValueVar( decl )
8395:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8395: LValueVar( Node decl ):
8397:    [ oNodeType( decl )
8404:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8414:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8425:       | nParam :
8427:          [ oNodeGetBoolean( decl, qInOut )
8437:             | true :   % VAR param points to variable.  No dereference.
8438:                        .tPushParamP @EmitValue( decl )
8447:             | * :      .tPushAddrParam @EmitValue( decl )
8461:          ]
8461:       | * :            #eNotVar
8472:    ]
      
8472:    oTypeSPush( oNodeGet( decl, qType ) )
8485:    @LValueIndexes        % handle subscripts, if any
8488:    ;
      
      
8488: IncVar( Node decl ):
8490:    @LValueVar( decl )
8497:    @RequireIntPop
8499:    @VarExpr( decl )
8506:    oTypeSPop
8507:    .tIncI
8509:    .tAssignI;
      
8512: DecVar( Node decl ):
8514:    @LValueVar( decl )
8521:    @RequireIntPop
8523:    @VarExpr( decl )
8530:    oTypeSPop
8531:    .tDecI
8533:    .tAssignI;
      
      
8536: IfStmt:
8538:    Label falseLabel = labelNull
      
8544:    @BooleanExprControlFlow( falseLabel )
8551:    pThen
8553:    @Statement
8555:    [
8555:       | pElse :
8557:          Label doneLabel = oLabelNew
      
8562:          .tJump  oEmitLabel( doneLabel )
8570:          .tLabel oEmitLabel( falseLabel )
8578:          @Statement
8580:          .tLabel oEmitLabel( doneLabel )
      
8588:       | * :
8593:          .tLabel oEmitLabel( falseLabel )
8601:    ];
      
      
8602: ForStmt:
8604:    pIdent
      
8606:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8611:    @LValueVar( decl )
8618:    @RequireIntPop
      
8620:    ':='
      
8622:    @Expr
8624:    @RequireIntPop
8626:    .tAssignI
      
8628:    Label breakLabel = oLabelNew
      
8633:    Label checkLabel = oLabelNew
8638:    .tJump  oEmitLabel( checkLabel )
      
8646:    Label continueLabel = oLabelNew
8651:    .tLabel  oEmitLabel( continueLabel )
8659:    [
8659:       | pTo :
8661:          @IncVar( decl )
8668:          .tLabel  oEmitLabel( checkLabel )
8676:          @VarExpr( decl )  oTypeSPop
8684:          @Expr
8686:          @RequireIntPop
8688:          .tGreaterI
8690:          .tJumpTrue  oEmitLabel( breakLabel )
8698:       | pDownto :
8700:          @DecVar( decl )
8707:          .tLabel  oEmitLabel( checkLabel )
8715:          @VarExpr( decl )  oTypeSPop
8723:          @Expr
8725:          @RequireIntPop
8727:          .tLessI
8729:          .tJumpTrue  oEmitLabel( breakLabel )
8737:    ]
8745:    oLoopPush( continueLabel, breakLabel )
8754:    pDo
8756:    @Statement
8758:    .tJump  oEmitLabel( continueLabel )
8766:    .tLabel  oEmitLabel( breakLabel )
8774:    oLoopPop;
      
      
8776: RepeatStmt:
8778:    Label continueLabel = oLabelNew
8783:    .tLabel  oEmitLabel( continueLabel )
      
8791:    Label breakLabel = oLabelNew
      
8796:    oLoopPush( continueLabel, breakLabel )
8805:    @Statement
8807:    {[
8807:       | ';' :
8809:          @Statement
8811:       | pUntil :
8813:          Label falseLabel
8813:          @BooleanExprControlFlow( falseLabel )
8820:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
8834:          >
8836:    ]}
8846:    .tLabel  oEmitLabel( breakLabel )
8854:    oLoopPop;
      
      
8856: WhileStmt:
8858:    Label continueLabel = oLabelNew
8863:    .tLabel  oEmitLabel( continueLabel )
      
8871:    Label breakLabel
8871:    @BooleanExprControlFlow( breakLabel )
      
8878:    oLoopPush( continueLabel, breakLabel )
8887:    pDo
8889:    @Statement
8891:    .tJump  oEmitLabel( continueLabel )
8899:    .tLabel  oEmitLabel( breakLabel )
8907:    oLoopPop;
      
      
8909: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
8911:    [ equal_label( oLoopContinueLabel, labelNull )
8920:       | true :
8921:          #eNotInALoop
8923:       | false :
8925:          .tJump  oEmitLabel( oLoopContinueLabel )
8932:    ];
      
      
8941: BreakStmt:
8943:    [ equal_label( oLoopBreakLabel, labelNull )
8952:       | true :
8953:          #eNotInALoop
8955:       | false :
8957:          .tJump  oEmitLabel( oLoopBreakLabel )
8964:    ];
      
      
8973: GotoStmt:
8975:    [
8975:       | pIdent :
8977:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
8979:          oChangeIntLitToLabelIdent
8980:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
8988:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
8997:    oNodeSetBoolean( decl, qUsed, true )
9009:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9025:    ;
      
      
9025: BeginStmt:
9027:    @Statement
9029:    {[
9029:       | ';' :   @Statement
9033:       | pEnd :  >
9037:    ]};
      
      
9048: WritelnStmt:
9050:    @WriteStmt
9052:    .tWriteCR;
      
      
9055: WriteStmt:
9057:    [
9057:       | '(' :
9059:          {
9059:             @Expr
9061:             [ oTypeSNodeType
9063:                | nIntegerType :             .tWriteI
9066:                | nBooleanType :             .tWriteBool
9070:                | nByteType :                .tCastBtoI  .tWriteI
9076:                | nCharType :                .tWriteChar
9080:                | nStringType :              .tWriteStr
9084:                | nFileType :                #eNotImplemented
9088:                | nEnumType :
                        % write name via table lookup
9090:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
9104:                   .tWriteEnum
9106:                | nPointerType :             .tWriteP
9110:                | * :                        #eNotAllowed
9131:             ]
9131:             oTypeSPop
9132:             [
9132:                | ')' : >
9136:                | ',' :
9138:             ]
9146:          }
9148:       | * :
9153:    ];
      
      
9154: ReadlnStmt:      % ***
         % TO DO
9157:    ;
      
9157: ReadStmt:
         % TO DO
9160:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
9160: ScopeLevel >> int:
9162:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
9172: DeclLevel( Node decl ) >> int:
9174:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
9192: DeclUpLevels( Node decl ) >> int:
9194:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
9210: MatchTypes:
9212:    node_type nt = oTypeSNodeType
9217:    oTypeSPop
9218:    [ equal_node_type( nt, oTypeSNodeType )
9227:       | false :
9228:          #eTypeMismatch
9230:       | * :
9235:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9236: RequireIntPop:
9238:    [ oTypeSNodeType
9240:       | nIntegerType :
9241:       | * :          #eNotInteger
9248:    ]
9248:    oTypeSPop;
      
9250: RequireInt:
9252:    [ oTypeSNodeType
9254:       | nIntegerType :
9255:       | * :          #eNotInteger
9262:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9263: PromoteToIntPop:
9265:    [ oTypeSNodeType
9267:       | nIntegerType :
9268:       | nByteType :        .tCastBtoI
9272:       | * :                #eNotInteger
9281:    ]
9281:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9283: PromoteToInt:
9285:    [ oTypeSNodeType
9287:       | nIntegerType :
9288:       | nByteType :        .tCastBtoI
9292:                            oTypeSPop
9293:                            oTypeSPush( IntegerType )
9299:       | * :                #eNotInteger
9308:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9309: PromoteToIntOptional:
9311:    [ oTypeSNodeType
9313:       | nByteType :        .tCastBtoI
9316:                            oTypeSPop
9317:                            oTypeSPush( IntegerType )
9323:       | * :
9328:    ];
      
      
      
      
9329: RequireBoolPop:
9331:    [ oTypeSNodeType
9333:       | nBooleanType :
9334:       | * :          #eNotBoolean
9341:    ]
9341:    oTypeSPop;
      
9343: RequireBool:
9345:    [ oTypeSNodeType
9347:       | nBooleanType :
9348:       | * :          #eNotBoolean
9355:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
9356: newType( node_type nt, int size ) >> Node:
9358:   Node node = oNodeNew( nt )
9368:   oNodeSetInt( node, qSize, size )
9380:   oTypeAdd( node )
9386:   >> node
9390:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
9390: newIdent( node_type nt, int id ) >> Node:
9392:   Node t = oNodeNew( nt )
9402:   oNodeSetInt( t, qIdent, id )
9414:   >> t
9418:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
9418: PointerTypeTo( Node theType ) >> Node:
9420:    Node ptrType = oNodeGet( theType, qPointerType )
9433:    [ oNodeNull( ptrType )
9440:       | true :
9441:          ptrType = oNodeNew( nPointerType )
9451:          oNodeSet( ptrType, qBaseType, theType )
9463:          oNodeSetInt( ptrType, qSize, 8 )
9475:          oTypeAdd( ptrType )
9481:          oNodeSet( theType, qPointerType, ptrType )
9493:       | * :
9498:    ]
9498:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
9502: OrdinalLow( Node theType ) >> int:
9504:    [ oNodeType( theType )
9511:       | nIntegerType :  >> oMININT
9514:       | nBooleanType :  >> 0
9519:       | nCharType :     >> 0
9524:       | nEnumType :
9526:          Node enumScope = oNodeGet( theType, qScope )
9539:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
9556:          >> oNodeGetInt( first, qValue )
9566:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
9578:       | * :             #eNotOrdinalType
9593:                         >> 0
9596:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
9597: EmitValue( Node decl ):
9599:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
9613: DeclareBuiltInFunc( int id ) >> Node:
9615:    Node decl = @newIdent( nBuiltInFunc, id )
9629:    oScopeDeclare( decl )
9635:    >> decl;
      
      
9639: installBuiltIns:
      
         % install built-in types
9641:    FileType = @newType( nFileType, 4 )
9655:    IntegerType = @newType( nIntegerType, 4 )
9669:    BooleanType = @newType( nBooleanType, 1 )
9683:    BooleanCFType = @newType( nBooleanCFType, 1 )
9697:    CharType = @newType( nCharType, 1 )
9711:    ByteType = @newType( nByteType, 1 )
9725:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
9739:    Node t
      
9739:    t = @newIdent( nTypeDecl, oIdAdd_File )
9752:    oNodeSet( t, qType, FileType )
9764:    oScopeDeclare( t )
      
9770:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
9783:    oNodeSet( t, qType, IntegerType )
9795:    oScopeDeclare( t )
      
9801:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
9814:    oNodeSet( t, qType, BooleanType )
9826:    oScopeDeclare( t )
      
9832:    t = @newIdent( nTypeDecl, oIdAdd_Char )
9845:    oNodeSet( t, qType, CharType )
9857:    oScopeDeclare( t )
      
9863:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
9876:    oNodeSet( t, qType, ByteType )
9888:    oScopeDeclare( t )
      
9894:    t = @newIdent( nTypeDecl, oIdAdd_String )
9907:    oNodeSet( t, qType, StringType )
9919:    oScopeDeclare( t )
      
         % Built-in constants
      
9925:    t = @newIdent( nConst, oIdAdd_True )
9938:    oNodeSet( t, qType, BooleanType )
9950:    oNodeSetInt( t, qValue, 1 )
9962:    oScopeDeclare( t )
      
9968:    t = @newIdent( nConst, oIdAdd_False )
9981:    oNodeSet( t, qType, BooleanType )
9993:    oNodeSetInt( t, qValue, 0 )
10005:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
10011:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
10021:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
10031:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
10041:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
10052:    ;
      
10052: end
      
10052: 

Generated code:

   0: oGlobalSpace 15
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 9639
  25: oEmit 54
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 48
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 51
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 50
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 53
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 9390
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 4
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 9390
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 4
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 299
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          57    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 452
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrGlobal 2
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oScopeCurrent
 225: oPushResult
 226: oSetResult 16
 228: oPushResult
 229: oGetGlobal 2
 231: oPushResult
 232: oNodeSet
 233: oPop 3
 235: oGetAddrGlobal 3
 237: oPushResult
 238: oScopeCurrent
 239: oAssign
 240: oGetLocal 4
 242: oPushResult
 243: oSetResult 7
 245: oPushResult
 246: oGetGlobal 3
 248: oPushResult
 249: oNodeSet
 250: oPop 3
 252: oScopeEnd
 253: oSetResult 20
 255: oPushResult
 256: oCall 1388
 258: oPop 1
 260: oGetGlobal 3
 262: oPushResult
 263: oScopeEnter
 264: oPop 1
 266: oGetAddrLocal 5
 268: oPushResult
 269: oSetResult 1
 271: oAssign
 272: oGetLocal 3
 274: oPushResult
 275: oGetGlobal 2
 277: oPushResult
 278: oGetLocal 5
 280: oPushResult
 281: oCall 1709
 283: oPop 3
 285: oScopeEnd
 286: oInput 20
 288: oCall 1444
 290: oScopeEnd
 291: oGetLocal 4
 293: oPushResult
 294: oCall 514
 296: oPop 1
 298: oReturn
 299: oLocalSpace 2
 301: oInput 0
 303: oGetAddrLocal 1
 305: oPushResult
 306: LAST_ID
 307: oPushResult
 308: oCall 593
 310: oPop 1
 312: oAssign
 313: oGetLocal 1
 315: oPushResult
 316: oSetResult 0
 318: oPushResult
 319: equal_node
 320: oPop 2
 322: oChoice 392
 324: oGetParam 1
 326: oPushResult
 327: oSetResult 5
 329: oPushResult
 330: oGetLocal 1
 332: oPushResult
 333: oNodeAddLast
 334: oPop 3
 336: oGetAddrLocal 2
 338: oPushResult
 339: oSetResult 10
 341: oPushResult
 342: oNodeNew
 343: oPop 1
 345: oAssign
 346: oGetLocal 2
 348: oPushResult
 349: oSetResult 4
 351: oPushResult
 352: oGetLocal 1
 354: oPushResult
 355: oSetResult 4
 357: oPushResult
 358: oNodeGetInt
 359: oPop 2
 361: oPushResult
 362: oNodeSetInt
 363: oPop 3
 365: oGetLocal 2
 367: oPushResult
 368: oSetResult 9
 370: oPushResult
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 9
 376: oPushResult
 377: oNodeGet
 378: oPop 2
 380: oPushResult
 381: oNodeSet
 382: oPop 3
 384: oGetLocal 2
 386: oPushResult
 387: oScopeDeclare
 388: oPop 1
 390: oJumpForward 395
 392: Choice Lookup Table
           0    324
 395: oInputChoice 399
 397: oJumpForward 404
 399: Choice Lookup Table
          13    397
 402: oJumpForward 406
 404: oJumpBack 301
 406: oInput 5
 408: oReturn
 409: oLocalSpace 1
 411: oGetFromParam 1
 413: oPushResult
 414: oNodeType
 415: oPop 1
 417: oChoice 448
 419: oGetAddrLocal 1
 421: oPushResult
 422: oGetFromParam 1
 424: oPushResult
 425: oSetResult 9
 427: oPushResult
 428: oNodeGet
 429: oPop 2
 431: oAssign
 432: oInput 20
 434: oInput 0
 436: oGetParam 1
 438: oPushResult
 439: oGetLocal 1
 441: oPushResult
 442: oScopeFindRequireInScope
 443: oPop 1
 445: oAssign
 446: oJumpForward 451
 448: Choice Lookup Table
          10    419
 451: oReturn
 452: oLocalSpace 2
 454: oGetAddrLocal 1
 456: oPushResult
 457: oGetParam 1
 459: oPushResult
 460: oSetResult 5
 462: oPushResult
 463: oNodeGetIter
 464: oPop 2
 466: oAssign
 467: oGetAddrLocal 2
 469: oPushResult
 470: oGetLocal 1
 472: oPushResult
 473: oNodeIterValue
 474: oPop 1
 476: oAssign
 477: oGetLocal 2
 479: oPushResult
 480: oNodeNull
 481: oPop 1
 483: oChoice 500
 485: oGetLocal 2
 487: oPushResult
 488: oSetResult 9
 490: oPushResult
 491: oNodeGet
 492: oPop 2
 494: oPushResult
 495: oScopeEnter
 496: oPop 1
 498: oJumpForward 505
 500: Choice Lookup Table
           0    485
 503: oJumpForward 513
 505: oGetAddrLocal 1
 507: oPushResult
 508: oNodeIterNext
 509: oPop 1
 511: oJumpBack 467
 513: oReturn
 514: oLocalSpace 2
 516: oGetAddrLocal 1
 518: oPushResult
 519: oGetParam 1
 521: oPushResult
 522: oSetResult 5
 524: oPushResult
 525: oNodeGetIterLast
 526: oPop 2
 528: oAssign
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetLocal 1
 534: oPushResult
 535: oNodeIterValue
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oPushResult
 542: oNodeNull
 543: oPop 1
 545: oChoice 579
 547: oScopeCurrent
 548: oPushResult
 549: oGetLocal 2
 551: oPushResult
 552: oSetResult 9
 554: oPushResult
 555: oNodeGet
 556: oPop 2
 558: oPushResult
 559: oNodeEqual
 560: oPop 2
 562: oChoice 570
 564: oJumpForward 576
 566: oError 25
 568: oJumpForward 576
 570: Choice Lookup Table
           0    566
           1    564
 575: oEndChoice
 576: oScopeEnd
 577: oJumpForward 584
 579: Choice Lookup Table
           0    547
 582: oJumpForward 592
 584: oGetAddrLocal 1
 586: oPushResult
 587: oNodeIterPrev
 588: oPop 1
 590: oJumpBack 529
 592: oReturn
 593: oLocalSpace 2
 595: oGetAddrLocal 1
 597: oPushResult
 598: oGetGlobal 1
 600: oPushResult
 601: oSetResult 1
 603: oPushResult
 604: oSetResult 4
 606: oPushResult
 607: oGetParam 1
 609: oPushResult
 610: oNodeFind
 611: oPop 4
 613: oAssign
 614: oGetLocal 1
 616: oPushResult
 617: oSetResult 0
 619: oPushResult
 620: equal_node
 621: oPop 2
 623: oChoice 630
 625: oGetLocal 1
 627: oReturn
 628: oJumpForward 633
 630: Choice Lookup Table
           0    625
 633: oGetAddrLocal 2
 635: oPushResult
 636: oGetParam 1
 638: oPushResult
 639: oIncludeUnitFile
 640: oPop 1
 642: oAssign
 643: oGetLocal 2
 645: oChoice 654
 647: oError 24
 649: oSetResult 0
 651: oReturn
 652: oJumpForward 657
 654: Choice Lookup Table
           0    647
 657: oGetAddrLocal 1
 659: oPushResult
 660: oCall 668
 662: oAssign
 663: oIncludeEnd
 664: oGetLocal 1
 666: oReturn
 667: oReturn
 668: oLocalSpace 2
 670: oInput 58
 672: oInput 0
 674: oGetAddrLocal 1
 676: oPushResult
 677: oSetResult 5
 679: oPushResult
 680: oNodeNew
 681: oPop 1
 683: oAssign
 684: oGetLocal 1
 686: oPushResult
 687: oSetResult 4
 689: oPushResult
 690: LAST_ID
 691: oPushResult
 692: oNodeSetInt
 693: oPop 3
 695: oGetAddrLocal 2
 697: oPushResult
 698: oSetResult 6
 700: oPushResult
 701: oNodeNew
 702: oPop 1
 704: oAssign
 705: oGetLocal 2
 707: oPushResult
 708: oSetResult 4
 710: oPushResult
 711: LAST_ID
 712: oPushResult
 713: oNodeSetInt
 714: oPop 3
 716: oGetLocal 1
 718: oPushResult
 719: oSetResult 8
 721: oPushResult
 722: oGetLocal 2
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oInput 5
 730: oInput 59
 732: oInputChoice 743
 734: oGetLocal 1
 736: oPushResult
 737: oCall 299
 739: oPop 1
 741: oJumpForward 746
 743: Choice Lookup Table
          57    734
 746: oGetLocal 1
 748: oPushResult
 749: oCall 452
 751: oPop 1
 753: oSetResult 0
 755: oPushResult
 756: oSetResult 0
 758: oPushResult
 759: oScopeBegin
 760: oPop 2
 762: oGetLocal 1
 764: oPushResult
 765: oSetResult 9
 767: oPushResult
 768: oScopeCurrent
 769: oPushResult
 770: oNodeSet
 771: oPop 3
 773: oGetAddrGlobal 2
 775: oPushResult
 776: oScopeCurrent
 777: oAssign
 778: oSetResult 0
 780: oPushResult
 781: oSetResult 1
 783: oPushResult
 784: oScopeBegin
 785: oPop 2
 787: oGetAddrGlobal 3
 789: oPushResult
 790: oScopeCurrent
 791: oAssign
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 13
 797: oPushResult
 798: oGetGlobal 3
 800: oPushResult
 801: oNodeSet
 802: oPop 3
 804: oScopeEnd
 805: oGetLocal 1
 807: oPushResult
 808: oCall 989
 810: oPop 1
 812: oScopeEnd
 813: oInput 60
 815: oInputChoice 826
 817: oGetLocal 2
 819: oPushResult
 820: oCall 299
 822: oPop 1
 824: oJumpForward 829
 826: Choice Lookup Table
          57    817
 829: oGetLocal 2
 831: oPushResult
 832: oCall 452
 834: oPop 1
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 9
 841: oPushResult
 842: oNodeGet
 843: oPop 2
 845: oPushResult
 846: oScopeEnter
 847: oPop 1
 849: oSetResult 0
 851: oPushResult
 852: oSetResult 0
 854: oPushResult
 855: oScopeBegin
 856: oPop 2
 858: oGetLocal 1
 860: oPushResult
 861: oSetResult 10
 863: oPushResult
 864: oScopeCurrent
 865: oPushResult
 866: oNodeSet
 867: oPop 3
 869: oScopeCurrent
 870: oPushResult
 871: oSetResult 16
 873: oPushResult
 874: oGetLocal 1
 876: oPushResult
 877: oSetResult 9
 879: oPushResult
 880: oNodeGet
 881: oPop 2
 883: oPushResult
 884: oNodeSet
 885: oPop 3
 887: oGetAddrGlobal 2
 889: oPushResult
 890: oScopeCurrent
 891: oAssign
 892: oGetLocal 1
 894: oPushResult
 895: oCall 1074
 897: oPop 1
 899: oInputChoice 913
 901: oGetLocal 1
 903: oPushResult
 904: oSetResult 1
 906: oPushResult
 907: oCall 1084
 909: oPop 2
 911: oJumpForward 926
 913: Choice Lookup Table
          61    901
 916: oGetLocal 1
 918: oPushResult
 919: oSetResult 0
 921: oPushResult
 922: oCall 1084
 924: oPop 2
 926: oInputChoice 940
 928: oGetLocal 1
 930: oPushResult
 931: oSetResult 1
 933: oPushResult
 934: oCall 1270
 936: oPop 2
 938: oJumpForward 953
 940: Choice Lookup Table
          62    928
 943: oGetLocal 1
 945: oPushResult
 946: oSetResult 0
 948: oPushResult
 949: oCall 1270
 951: oPop 2
 953: oInput 36
 955: oInput 20
 957: oScopeEnd
 958: oScopeEnd
 959: oGetLocal 2
 961: oPushResult
 962: oCall 514
 964: oPop 1
 966: oGetLocal 1
 968: oPushResult
 969: oCall 514
 971: oPop 1
 973: oGetGlobal 1
 975: oPushResult
 976: oSetResult 1
 978: oPushResult
 979: oGetLocal 1
 981: oPushResult
 982: oNodeAddLast
 983: oPop 3
 985: oGetLocal 1
 987: oReturn
 988: oReturn
 989: oLocalSpace 2
 991: oInputChoice 1058
 993: oCall 2982
 995: oJumpForward 1071
 997: oCall 3051
 999: oJumpForward 1071
1001: oSetResult 20
1003: oPushResult
1004: oCall 3107
1006: oPop 1
1008: oJumpForward 1071
1010: oGetAddrLocal 1
1012: oPushResult
1013: oCall 1949
1015: oAssign
1016: oInputChoice 1029
1018: oGetLocal 1
1020: oPushResult
1021: oCall 1887
1023: oPop 1
1025: oInput 5
1027: oJumpForward 1032
1029: Choice Lookup Table
          68   1018
1032: oJumpForward 1071
1034: oGetAddrLocal 2
1036: oPushResult
1037: oCall 2323
1039: oAssign
1040: oInputChoice 1053
1042: oGetLocal 2
1044: oPushResult
1045: oCall 1887
1047: oPop 1
1049: oInput 5
1051: oJumpForward 1056
1053: Choice Lookup Table
          68   1042
1056: oJumpForward 1071
1058: Choice Lookup Table
          30   1034
          29   1010
          33   1001
          32    997
          31    993
1069: oJumpForward 1073
1071: oJumpBack 991
1073: oReturn
1074: oLocalSpace 0
1076: oSetResult 20
1078: oPushResult
1079: oCall 1388
1081: oPop 1
1083: oReturn
1084: oLocalSpace 5
1086: oGetAddrLocal 1
1088: oPushResult
1089: oLabelNew
1090: oAssign
1091: oEmit 58
1093: oGetLocal 1
1095: oPushResult
1096: oEmitLabel
1097: oPop 1
1099: oGetParam 2
1101: oPushResult
1102: oSetResult 11
1104: oPushResult
1105: oGetLocal 1
1107: oPushResult
1108: oNodeSetLabel
1109: oPop 3
1111: oEmit 54
1113: oGetAddrLocal 2
1115: oPushResult
1116: Here
1117: oAssign
1118: oEmit 68
1120: oGetAddrLocal 3
1122: oPushResult
1123: oGetParam 2
1125: oPushResult
1126: oSetResult 9
1128: oPushResult
1129: oNodeGet
1130: oPop 2
1132: oAssign
1133: oGetAddrLocal 4
1135: oPushResult
1136: oGetLocal 3
1138: oPushResult
1139: oSetResult 19
1141: oPushResult
1142: oNodeGetCode
1143: oPop 2
1145: oAssign
1146: oGetLocal 4
1148: oPushResult
1149: oEmitCode
1150: oPop 1
1152: oGetLocal 3
1154: oPushResult
1155: oSetResult 19
1157: oPushResult
1158: oSetResult 0
1160: oPushResult
1161: oNodeSetCode
1162: oPop 3
1164: oGetAddrLocal 3
1166: oPushResult
1167: oGetParam 2
1169: oPushResult
1170: oSetResult 10
1172: oPushResult
1173: oNodeGet
1174: oPop 2
1176: oAssign
1177: oGetAddrLocal 4
1179: oPushResult
1180: oGetLocal 3
1182: oPushResult
1183: oSetResult 19
1185: oPushResult
1186: oNodeGetCode
1187: oPop 2
1189: oAssign
1190: oGetLocal 4
1192: oPushResult
1193: oEmitCode
1194: oPop 1
1196: oGetLocal 3
1198: oPushResult
1199: oSetResult 19
1201: oPushResult
1202: oSetResult 0
1204: oPushResult
1205: oNodeSetCode
1206: oPop 3
1208: oGetParam 2
1210: oPushResult
1211: oSetResult 13
1213: oPushResult
1214: oNodeGet
1215: oPop 2
1217: oPushResult
1218: oScopeEnter
1219: oPop 1
1221: oGetParam 1
1223: oChoice 1242
1225: oCall 7925
1227: oInputChoice 1233
1229: oCall 7925
1231: oJumpForward 1238
1233: Choice Lookup Table
           5   1229
1236: oJumpForward 1240
1238: oJumpBack 1227
1240: oJumpForward 1245
1242: Choice Lookup Table
           1   1225
1245: oEmit 53
1247: oGetAddrLocal 5
1249: oPushResult
1250: oScopeCurrent
1251: oPushResult
1252: oSetResult 17
1254: oPushResult
1255: oNodeGetInt
1256: oPop 2
1258: oAssign
1259: oGetLocal 2
1261: oPushResult
1262: oGetLocal 5
1264: oPushResult
1265: oPatch
1266: oPop 2
1268: oScopeEnd
1269: oReturn
1270: oLocalSpace 3
1272: oGetAddrLocal 1
1274: oPushResult
1275: oLabelNew
1276: oAssign
1277: oEmit 58
1279: oGetLocal 1
1281: oPushResult
1282: oEmitLabel
1283: oPop 1
1285: oGetParam 2
1287: oPushResult
1288: oSetResult 12
1290: oPushResult
1291: oGetLocal 1
1293: oPushResult
1294: oNodeSetLabel
1295: oPop 3
1297: oEmit 54
1299: oGetAddrLocal 2
1301: oPushResult
1302: Here
1303: oAssign
1304: oEmit 68
1306: oSetResult 0
1308: oPushResult
1309: oSetResult 1
1311: oPushResult
1312: oScopeBegin
1313: oPop 2
1315: oGetParam 1
1317: oChoice 1336
1319: oCall 7925
1321: oInputChoice 1327
1323: oCall 7925
1325: oJumpForward 1332
1327: Choice Lookup Table
           5   1323
1330: oJumpForward 1334
1332: oJumpBack 1321
1334: oJumpForward 1339
1336: Choice Lookup Table
           1   1319
1339: oEmit 53
1341: oGetAddrLocal 3
1343: oPushResult
1344: oScopeCurrent
1345: oPushResult
1346: oSetResult 17
1348: oPushResult
1349: oNodeGetInt
1350: oPop 2
1352: oAssign
1353: oGetLocal 2
1355: oPushResult
1356: oGetLocal 3
1358: oPushResult
1359: oPatch
1360: oPop 2
1362: oScopeEnd
1363: oReturn
1364: oLocalSpace 0
1366: oGetParam 2
1368: oPushResult
1369: oCall 1388
1371: oPop 1
1373: oGetParam 1
1375: oPushResult
1376: oScopeCurrent
1377: oPushResult
1378: oSetResult 0
1380: oPushResult
1381: oCall 1709
1383: oPop 3
1385: oCall 1444
1387: oReturn
1388: oLocalSpace 0
1390: oInputChoice 1421
1392: oCall 2982
1394: oJumpForward 1436
1396: oCall 3051
1398: oJumpForward 1436
1400: oGetParam 1
1402: oPushResult
1403: oCall 3107
1405: oPop 1
1407: oJumpForward 1436
1409: oCall 3338
1411: oJumpForward 1436
1413: oCall 2205
1415: oJumpForward 1436
1417: oCall 2640
1419: oJumpForward 1436
1421: Choice Lookup Table
          30   1417
          29   1413
          34   1409
          33   1400
          32   1396
          31   1392
1434: oJumpForward 1438
1436: oJumpBack 1390
1438: oCall 1441
1440: oReturn
1441: oLocalSpace 0
1443: oReturn
1444: oLocalSpace 2
1446: oGetAddrLocal 1
1448: oPushResult
1449: oScopeCurrent
1450: oPushResult
1451: oSetResult 15
1453: oPushResult
1454: oNodeGetIter
1455: oPop 2
1457: oAssign
1458: oGetAddrLocal 2
1460: oPushResult
1461: oGetLocal 1
1463: oPushResult
1464: oNodeIterValue
1465: oPop 1
1467: oAssign
1468: oGetLocal 2
1470: oPushResult
1471: oNodeNull
1472: oPop 1
1474: oChoice 1478
1476: oJumpForward 1483
1478: Choice Lookup Table
           0   1476
1481: oJumpForward 1538
1483: oGetLocal 2
1485: oPushResult
1486: oNodeType
1487: oPop 1
1489: oChoice 1527
1491: oGetLocal 2
1493: oPushResult
1494: oSetResult 34
1496: oPushResult
1497: oNodeGetBoolean
1498: oPop 2
1500: oChoice 1522
1502: oGetLocal 2
1504: oPushResult
1505: oSetResult 28
1507: oPushResult
1508: oNodeGetBoolean
1509: oPop 2
1511: oChoice 1517
1513: oError 27
1515: oJumpForward 1520
1517: Choice Lookup Table
           1   1513
1520: oJumpForward 1525
1522: Choice Lookup Table
           0   1502
1525: oJumpForward 1530
1527: Choice Lookup Table
          24   1491
1530: oGetAddrLocal 1
1532: oPushResult
1533: oNodeIterNext
1534: oPop 1
1536: oJumpBack 1458
1538: oReturn
1539: oLocalSpace 2
1541: oGetAddrLocal 1
1543: oPushResult
1544: oGetGlobal 1
1546: oPushResult
1547: oSetResult 1
1549: oPushResult
1550: oNodeGetIter
1551: oPop 2
1553: oAssign
1554: oGetAddrLocal 2
1556: oPushResult
1557: oGetLocal 1
1559: oPushResult
1560: oNodeIterValue
1561: oPop 1
1563: oAssign
1564: oGetLocal 2
1566: oPushResult
1567: oNodeNull
1568: oPop 1
1570: oChoice 1615
1572: oJumpForward 1623
1574: oJumpForward 1621
1576: oEmit 48
1578: oSetResult 0
1580: oPushResult
1581: oEmitInt
1582: oPop 1
1584: oEmit 51
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 11
1591: oPushResult
1592: oNodeGetLabel
1593: oPop 2
1595: oPushResult
1596: oEmitLabel
1597: oPop 1
1599: oEmit 50
1601: oSetResult 0
1603: oPushResult
1604: oEmitInt
1605: oPop 1
1607: oGetAddrLocal 1
1609: oPushResult
1610: oNodeIterNext
1611: oPop 1
1613: oJumpForward 1621
1615: Choice Lookup Table
           0   1576
           1   1572
1620: oEndChoice
1621: oJumpBack 1554
1623: oReturn
1624: oLocalSpace 2
1626: oGetAddrLocal 1
1628: oPushResult
1629: oGetGlobal 1
1631: oPushResult
1632: oSetResult 1
1634: oPushResult
1635: oNodeGetIterLast
1636: oPop 2
1638: oAssign
1639: oGetAddrLocal 2
1641: oPushResult
1642: oGetLocal 1
1644: oPushResult
1645: oNodeIterValue
1646: oPop 1
1648: oAssign
1649: oGetLocal 2
1651: oPushResult
1652: oNodeNull
1653: oPop 1
1655: oChoice 1700
1657: oJumpForward 1708
1659: oJumpForward 1706
1661: oEmit 48
1663: oSetResult 0
1665: oPushResult
1666: oEmitInt
1667: oPop 1
1669: oEmit 51
1671: oGetLocal 2
1673: oPushResult
1674: oSetResult 12
1676: oPushResult
1677: oNodeGetLabel
1678: oPop 2
1680: oPushResult
1681: oEmitLabel
1682: oPop 1
1684: oEmit 50
1686: oSetResult 0
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oGetAddrLocal 1
1694: oPushResult
1695: oNodeIterPrev
1696: oPop 1
1698: oJumpForward 1706
1700: Choice Lookup Table
           0   1661
           1   1657
1705: oEndChoice
1706: oJumpBack 1639
1708: oReturn
1709: oLocalSpace 3
1711: oEmit 58
1713: oGetParam 3
1715: oPushResult
1716: oEmitLabel
1717: oPop 1
1719: oEmit 54
1721: oGetAddrLocal 1
1723: oPushResult
1724: Here
1725: oAssign
1726: oEmit 68
1728: oGetParam 1
1730: oChoice 1736
1732: oCall 1539
1734: oJumpForward 1739
1736: Choice Lookup Table
           1   1732
1739: oGetAddrLocal 2
1741: oPushResult
1742: oGetParam 2
1744: oPushResult
1745: oSetResult 19
1747: oPushResult
1748: oNodeGetCode
1749: oPop 2
1751: oAssign
1752: oGetLocal 2
1754: oPushResult
1755: oEmitCode
1756: oPop 1
1758: oGetParam 2
1760: oPushResult
1761: oSetResult 19
1763: oPushResult
1764: oSetResult 0
1766: oPushResult
1767: oNodeSetCode
1768: oPop 3
1770: oCall 7925
1772: oGetParam 1
1774: oChoice 1780
1776: oCall 1624
1778: oJumpForward 1783
1780: Choice Lookup Table
           1   1776
1783: oEmit 53
1785: oGetAddrLocal 3
1787: oPushResult
1788: oScopeCurrent
1789: oPushResult
1790: oSetResult 17
1792: oPushResult
1793: oNodeGetInt
1794: oPop 2
1796: oAssign
1797: oGetLocal 1
1799: oPushResult
1800: oGetLocal 3
1802: oPushResult
1803: oPatch
1804: oPop 2
1806: oReturn
1807: oLocalSpace 0
1809: oInputChoice 1827
1811: oGetParam 1
1813: oPushResult
1814: oSetResult 27
1816: oPushResult
1817: oSetResult 1
1819: oPushResult
1820: oNodeSetBoolean
1821: oPop 3
1823: oInput 5
1825: oJumpForward 1832
1827: Choice Lookup Table
          70   1811
1830: oJumpForward 1834
1832: oJumpBack 1809
1834: oReturn
1835: oLocalSpace 1
1837: oGetAddrLocal 1
1839: oPushResult
1840: oGetParam 1
1842: oPushResult
1843: oSetResult 19
1845: oPushResult
1846: oNodeGetCode
1847: oPop 2
1849: oAssign
1850: oGetLocal 1
1852: oPushResult
1853: oSetResult 0
1855: oPushResult
1856: equal_code
1857: oPop 2
1859: oChoice 1880
1861: oGetAddrLocal 1
1863: oPushResult
1864: oCodeNew
1865: oAssign
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 19
1871: oPushResult
1872: oGetLocal 1
1874: oPushResult
1875: oNodeSetCode
1876: oPop 3
1878: oJumpForward 1883
1880: Choice Lookup Table
           1   1861
1883: oGetLocal 1
1885: oReturn
1886: oReturn
1887: oLocalSpace 0
1889: oGetParam 1
1891: oPushResult
1892: oCall 9172
1894: oPop 1
1896: oPushResult
1897: equal_zero
1898: oPop 1
1900: oChoice 1906
1902: oError 23
1904: oJumpForward 1909
1906: Choice Lookup Table
           0   1902
1909: oGetParam 1
1911: oPushResult
1912: oSetResult 25
1914: oPushResult
1915: oSetResult 1
1917: oPushResult
1918: oNodeSetBoolean
1919: oPop 3
1921: oInputChoice 1945
1923: oInputChoice 1940
1925: oInput 2
1927: oGetParam 1
1929: oPushResult
1930: oSetResult 26
1932: oPushResult
1933: CURRENT_STRLIT
1934: oPushResult
1935: oNodeSetString
1936: oPop 3
1938: oJumpForward 1943
1940: Choice Lookup Table
          69   1925
1943: oJumpForward 1948
1945: Choice Lookup Table
           2   1923
1948: oReturn
1949: oLocalSpace 6
1951: oInput 0
1953: oGetAddrLocal 1
1955: oPushResult
1956: oSetResult 0
1958: oAssign
1959: oGetAddrLocal 2
1961: oPushResult
1962: oScopeFindInCurrentScope
1963: oAssign
1964: oGetLocal 2
1966: oPushResult
1967: oNodeNull
1968: oPop 1
1970: oChoice 2088
1972: oGetAddrLocal 2
1974: oPushResult
1975: oSetResult 12
1977: oPushResult
1978: LAST_ID
1979: oPushResult
1980: oCall 9390
1982: oPop 2
1984: oAssign
1985: oGetLocal 2
1987: oPushResult
1988: oSetResult 22
1990: oPushResult
1991: oLabelNew
1992: oPushResult
1993: oNodeSetLabel
1994: oPop 3
1996: oJumpForward 2094
1998: oGetAddrLocal 1
2000: oPushResult
2001: oSetResult 1
2003: oAssign
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 24
2009: oPushResult
2010: oNodeGetBoolean
2011: oPop 2
2013: oChoice 2019
2015: oError 21
2017: oJumpForward 2022
2019: Choice Lookup Table
           1   2015
2022: oGetLocal 2
2024: oPushResult
2025: oSetResult 25
2027: oPushResult
2028: oNodeGetBoolean
2029: oPop 2
2031: oChoice 2037
2033: oError 21
2035: oJumpForward 2040
2037: Choice Lookup Table
           1   2033
2040: oGetLocal 2
2042: oPushResult
2043: oNodeType
2044: oPop 1
2046: oChoice 2050
2048: oJumpForward 2055
2050: Choice Lookup Table
          12   2048
2053: oError 21
2055: oGetLocal 2
2057: oPushResult
2058: oSetResult 29
2060: oPushResult
2061: oGetLocal 2
2063: oPushResult
2064: oSetResult 23
2066: oPushResult
2067: oNodeGet
2068: oPop 2
2070: oPushResult
2071: oNodeSet
2072: oPop 3
2074: oGetLocal 2
2076: oPushResult
2077: oSetResult 23
2079: oPushResult
2080: oSetResult 0
2082: oPushResult
2083: oNodeSet
2084: oPop 3
2086: oJumpForward 2094
2088: Choice Lookup Table
           0   1998
           1   1972
2093: oEndChoice
2094: oGetAddrLocal 3
2096: oPushResult
2097: oCall 9160
2099: oAssign
2100: oGetAddrLocal 4
2102: oPushResult
2103: oGetLocal 3
2105: oPushResult
2106: oSetResult 0
2108: oPushResult
2109: greater
2110: oPop 2
2112: oAssign
2113: oGetAddrLocal 3
2115: oPushResult
2116: inc
2117: oPop 1
2119: oGetLocal 3
2121: oPushResult
2122: oSetResult 2
2124: oPushResult
2125: oScopeBegin
2126: oPop 2
2128: oGetAddrLocal 5
2130: oPushResult
2131: oScopeCurrent
2132: oAssign
2133: oGetLocal 4
2135: oChoice 2154
2137: oGetAddrLocal 6
2139: oPushResult
2140: oGetGlobal 5
2142: oPushResult
2143: oCall 9418
2145: oPop 1
2147: oPushResult
2148: oScopeAllocType
2149: oPop 1
2151: oAssign
2152: oJumpForward 2157
2154: Choice Lookup Table
           1   2137
2157: oCall 2758
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 23
2164: oPushResult
2165: oGetLocal 5
2167: oPushResult
2168: oNodeSet
2169: oPop 3
2171: oScopeEnd
2172: oInput 5
2174: oGetLocal 1
2176: oChoice 2188
2178: oGetLocal 2
2180: oPushResult
2181: oScopeDeclare
2182: oPop 1
2184: oJumpForward 2194
2186: oJumpForward 2194
2188: Choice Lookup Table
           1   2186
           0   2178
2193: oEndChoice
2194: oGetLocal 2
2196: oPushResult
2197: oCall 1807
2199: oPop 1
2201: oGetLocal 2
2203: oReturn
2204: oReturn
2205: oLocalSpace 4
2207: oGetAddrLocal 1
2209: oPushResult
2210: oCall 1949
2212: oAssign
2213: oInputChoice 2226
2215: oJumpForward 2320
2217: oGetLocal 1
2219: oPushResult
2220: oCall 1887
2222: oPop 1
2224: oJumpForward 2320
2226: Choice Lookup Table
          68   2217
          67   2215
2231: oGetAddrLocal 2
2233: oPushResult
2234: oGetLocal 1
2236: oPushResult
2237: oSetResult 23
2239: oPushResult
2240: oNodeGet
2241: oPop 2
2243: oAssign
2244: oGetLocal 2
2246: oPushResult
2247: oScopeEnter
2248: oPop 1
2250: oGetAddrLocal 3
2252: oPushResult
2253: oGetLocal 2
2255: oPushResult
2256: oSetResult 14
2258: oPushResult
2259: oNodeGetInt
2260: oPop 2
2262: oAssign
2263: oGetLocal 3
2265: oPushResult
2266: oSetResult 1
2268: oPushResult
2269: oScopeBegin
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 6
2277: oPushResult
2278: oScopeCurrent
2279: oPushResult
2280: oNodeSet
2281: oPop 3
2283: oGetAddrLocal 4
2285: oPushResult
2286: oGetLocal 1
2288: oPushResult
2289: oSetResult 22
2291: oPushResult
2292: oNodeGetLabel
2293: oPop 2
2295: oAssign
2296: oSetResult 21
2298: oPushResult
2299: oGetLocal 4
2301: oPushResult
2302: oCall 1364
2304: oPop 2
2306: oGetLocal 1
2308: oPushResult
2309: oSetResult 24
2311: oPushResult
2312: oSetResult 1
2314: oPushResult
2315: oNodeSetBoolean
2316: oPop 3
2318: oScopeEnd
2319: oScopeEnd
2320: oInput 5
2322: oReturn
2323: oLocalSpace 8
2325: oInput 0
2327: oGetAddrLocal 1
2329: oPushResult
2330: oSetResult 0
2332: oAssign
2333: oGetAddrLocal 2
2335: oPushResult
2336: oScopeFindInCurrentScope
2337: oAssign
2338: oGetLocal 2
2340: oPushResult
2341: oNodeNull
2342: oPop 1
2344: oChoice 2475
2346: oGetAddrLocal 2
2348: oPushResult
2349: oSetResult 13
2351: oPushResult
2352: LAST_ID
2353: oPushResult
2354: oCall 9390
2356: oPop 2
2358: oAssign
2359: oGetLocal 2
2361: oPushResult
2362: oSetResult 22
2364: oPushResult
2365: oLabelNew
2366: oPushResult
2367: oNodeSetLabel
2368: oPop 3
2370: oJumpForward 2481
2372: oGetAddrLocal 1
2374: oPushResult
2375: oSetResult 1
2377: oAssign
2378: oGetLocal 2
2380: oPushResult
2381: oSetResult 24
2383: oPushResult
2384: oNodeGetBoolean
2385: oPop 2
2387: oChoice 2393
2389: oError 21
2391: oJumpForward 2396
2393: Choice Lookup Table
           1   2389
2396: oGetLocal 2
2398: oPushResult
2399: oNodeType
2400: oPop 1
2402: oChoice 2406
2404: oJumpForward 2411
2406: Choice Lookup Table
          13   2404
2409: oError 21
2411: oGetLocal 2
2413: oPushResult
2414: oSetResult 29
2416: oPushResult
2417: oGetLocal 2
2419: oPushResult
2420: oSetResult 23
2422: oPushResult
2423: oNodeGet
2424: oPop 2
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oSetResult 0
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oGetLocal 2
2444: oPushResult
2445: oSetResult 30
2447: oPushResult
2448: oGetLocal 2
2450: oPushResult
2451: oSetResult 21
2453: oPushResult
2454: oNodeGet
2455: oPop 2
2457: oPushResult
2458: oNodeSet
2459: oPop 3
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oSetResult 0
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oJumpForward 2481
2475: Choice Lookup Table
           0   2372
           1   2346
2480: oEndChoice
2481: oGetAddrLocal 3
2483: oPushResult
2484: oCall 9160
2486: oAssign
2487: oGetAddrLocal 4
2489: oPushResult
2490: oGetLocal 3
2492: oPushResult
2493: oSetResult 0
2495: oPushResult
2496: greater
2497: oPop 2
2499: oAssign
2500: oGetAddrLocal 3
2502: oPushResult
2503: inc
2504: oPop 1
2506: oGetLocal 3
2508: oPushResult
2509: oSetResult 2
2511: oPushResult
2512: oScopeBegin
2513: oPop 2
2515: oGetAddrLocal 5
2517: oPushResult
2518: oScopeCurrent
2519: oAssign
2520: oGetLocal 4
2522: oChoice 2541
2524: oGetAddrLocal 6
2526: oPushResult
2527: oGetGlobal 5
2529: oPushResult
2530: oCall 9418
2532: oPop 1
2534: oPushResult
2535: oScopeAllocType
2536: oPop 1
2538: oAssign
2539: oJumpForward 2544
2541: Choice Lookup Table
           1   2524
2544: oCall 2758
2546: oGetLocal 2
2548: oPushResult
2549: oSetResult 23
2551: oPushResult
2552: oGetLocal 5
2554: oPushResult
2555: oNodeSet
2556: oPop 3
2558: oInput 12
2560: oGetAddrLocal 7
2562: oPushResult
2563: oCall 3403
2565: oPop 1
2567: oGetLocal 2
2569: oPushResult
2570: oSetResult 21
2572: oPushResult
2573: oGetLocal 7
2575: oPushResult
2576: oNodeSet
2577: oPop 3
2579: oGetAddrLocal 8
2581: oPushResult
2582: oGetLocal 7
2584: oPushResult
2585: oCall 9418
2587: oPop 1
2589: oAssign
2590: oGetLocal 2
2592: oPushResult
2593: oSetResult 31
2595: oPushResult
2596: oGetLocal 8
2598: oPushResult
2599: oScopeAllocType
2600: oPop 1
2602: oPushResult
2603: oNodeSetInt
2604: oPop 3
2606: oScopeEnd
2607: oInput 5
2609: oGetLocal 1
2611: oChoice 2623
2613: oGetLocal 2
2615: oPushResult
2616: oScopeDeclare
2617: oPop 1
2619: oJumpForward 2629
2621: oJumpForward 2629
2623: Choice Lookup Table
           1   2621
           0   2613
2628: oEndChoice
2629: oGetLocal 2
2631: oPushResult
2632: oCall 1807
2634: oPop 1
2636: oGetLocal 2
2638: oReturn
2639: oReturn
2640: oLocalSpace 4
2642: oGetAddrLocal 1
2644: oPushResult
2645: oCall 2323
2647: oAssign
2648: oInputChoice 2661
2650: oJumpForward 2755
2652: oGetLocal 1
2654: oPushResult
2655: oCall 1887
2657: oPop 1
2659: oJumpForward 2755
2661: Choice Lookup Table
          68   2652
          67   2650
2666: oGetAddrLocal 2
2668: oPushResult
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 23
2674: oPushResult
2675: oNodeGet
2676: oPop 2
2678: oAssign
2679: oGetLocal 2
2681: oPushResult
2682: oScopeEnter
2683: oPop 1
2685: oGetAddrLocal 3
2687: oPushResult
2688: oGetLocal 2
2690: oPushResult
2691: oSetResult 14
2693: oPushResult
2694: oNodeGetInt
2695: oPop 2
2697: oAssign
2698: oGetLocal 3
2700: oPushResult
2701: oSetResult 1
2703: oPushResult
2704: oScopeBegin
2705: oPop 2
2707: oGetLocal 1
2709: oPushResult
2710: oSetResult 6
2712: oPushResult
2713: oScopeCurrent
2714: oPushResult
2715: oNodeSet
2716: oPop 3
2718: oGetAddrLocal 4
2720: oPushResult
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 22
2726: oPushResult
2727: oNodeGetLabel
2728: oPop 2
2730: oAssign
2731: oSetResult 21
2733: oPushResult
2734: oGetLocal 4
2736: oPushResult
2737: oCall 1364
2739: oPop 2
2741: oGetLocal 1
2743: oPushResult
2744: oSetResult 24
2746: oPushResult
2747: oSetResult 1
2749: oPushResult
2750: oNodeSetBoolean
2751: oPop 3
2753: oScopeEnd
2754: oScopeEnd
2755: oInput 5
2757: oReturn
2758: oLocalSpace 6
2760: oInputChoice 2978
2762: oGetAddrLocal 1
2764: oPushResult
2765: oNodeVecNew
2766: oAssign
2767: oGetAddrLocal 3
2769: oPushResult
2770: oSetResult 0
2772: oAssign
2773: oInputChoice 2783
2775: oGetAddrLocal 3
2777: oPushResult
2778: oSetResult 1
2780: oAssign
2781: oJumpForward 2786
2783: Choice Lookup Table
          33   2775
2786: oInput 0
2788: oGetAddrLocal 2
2790: oPushResult
2791: oSetResult 23
2793: oPushResult
2794: LAST_ID
2795: oPushResult
2796: oCall 9390
2798: oPop 2
2800: oAssign
2801: oGetLocal 2
2803: oPushResult
2804: oSetResult 33
2806: oPushResult
2807: oGetLocal 3
2809: oPushResult
2810: oNodeSetBoolean
2811: oPop 3
2813: oGetLocal 1
2815: oPushResult
2816: oGetLocal 2
2818: oPushResult
2819: oNodeVecAppend
2820: oPop 2
2822: oInputChoice 2830
2824: oJumpForward 2838
2826: oJumpForward 2836
2828: oJumpForward 2836
2830: Choice Lookup Table
          13   2828
          12   2824
2835: oEndChoice
2836: oJumpBack 2786
2838: oGetAddrLocal 4
2840: oPushResult
2841: oCall 3403
2843: oPop 1
2845: oGetLocal 3
2847: oChoice 2862
2849: oGetAddrLocal 5
2851: oPushResult
2852: oGetLocal 4
2854: oPushResult
2855: oCall 9418
2857: oPop 1
2859: oAssign
2860: oJumpForward 2871
2862: Choice Lookup Table
           1   2849
2865: oGetAddrLocal 5
2867: oPushResult
2868: oGetLocal 4
2870: oAssign
2871: oGetAddrLocal 6
2873: oPushResult
2874: oSetResult 0
2876: oAssign
2877: oGetLocal 6
2879: oPushResult
2880: oGetLocal 1
2882: oPushResult
2883: oNodeVecSize
2884: oPop 1
2886: oPushResult
2887: equal
2888: oPop 2
2890: oChoice 2947
2892: oGetAddrLocal 2
2894: oPushResult
2895: oGetLocal 1
2897: oPushResult
2898: oGetLocal 6
2900: oPushResult
2901: oNodeVecElement
2902: oPop 2
2904: oAssign
2905: oGetLocal 2
2907: oPushResult
2908: oSetResult 21
2910: oPushResult
2911: oGetLocal 4
2913: oPushResult
2914: oNodeSet
2915: oPop 3
2917: oGetLocal 2
2919: oPushResult
2920: oScopeDeclare
2921: oPop 1
2923: oGetLocal 2
2925: oPushResult
2926: oSetResult 22
2928: oPushResult
2929: oGetLocal 5
2931: oPushResult
2932: oScopeAllocType
2933: oPop 1
2935: oPushResult
2936: oNodeSetInt
2937: oPop 3
2939: oGetAddrLocal 6
2941: oPushResult
2942: inc
2943: oPop 1
2945: oJumpForward 2952
2947: Choice Lookup Table
           0   2892
2950: oJumpForward 2954
2952: oJumpBack 2877
2954: oGetLocal 1
2956: oPushResult
2957: oNodeVecDelete
2958: oPop 1
2960: oInputChoice 2968
2962: oJumpForward 2976
2964: oJumpForward 2974
2966: oJumpForward 2974
2968: Choice Lookup Table
           5   2966
          15   2962
2973: oEndChoice
2974: oJumpBack 2762
2976: oJumpForward 2981
2978: Choice Lookup Table
          14   2762
2981: oReturn
2982: oLocalSpace 2
2984: oInputChoice 3043
2986: oGetAddrLocal 1
2988: oPushResult
2989: oSetResult 16
2991: oPushResult
2992: LAST_ID
2993: oPushResult
2994: oCall 9390
2996: oPop 2
2998: oAssign
2999: oInput 6
3001: oCall 4459
3003: oGetAddrLocal 2
3005: oPushResult
3006: oValueTop
3007: oAssign
3008: oValuePop
3009: oGetLocal 1
3011: oPushResult
3012: oSetResult 22
3014: oPushResult
3015: oGetLocal 2
3017: oPushResult
3018: oNodeSetInt
3019: oPop 3
3021: oGetLocal 1
3023: oPushResult
3024: oSetResult 21
3026: oPushResult
3027: oGetGlobal 5
3029: oPushResult
3030: oNodeSet
3031: oPop 3
3033: oGetLocal 1
3035: oPushResult
3036: oScopeDeclare
3037: oPop 1
3039: oInput 5
3041: oJumpForward 3048
3043: Choice Lookup Table
           0   2986
3046: oJumpForward 3050
3048: oJumpBack 2984
3050: oReturn
3051: oLocalSpace 2
3053: oInputChoice 3099
3055: oGetAddrLocal 1
3057: oPushResult
3058: oSetResult 18
3060: oPushResult
3061: LAST_ID
3062: oPushResult
3063: oCall 9390
3065: oPop 2
3067: oAssign
3068: oInput 6
3070: oGetAddrLocal 2
3072: oPushResult
3073: oCall 3403
3075: oPop 1
3077: oGetLocal 1
3079: oPushResult
3080: oSetResult 21
3082: oPushResult
3083: oGetLocal 2
3085: oPushResult
3086: oNodeSet
3087: oPop 3
3089: oGetLocal 1
3091: oPushResult
3092: oScopeDeclare
3093: oPop 1
3095: oInput 5
3097: oJumpForward 3104
3099: Choice Lookup Table
           0   3055
3102: oJumpForward 3106
3104: oJumpBack 3053
3106: oReturn
3107: oLocalSpace 6
3109: oInputChoice 3330
3111: oGetAddrLocal 1
3113: oPushResult
3114: oNodeVecNew
3115: oAssign
3116: oGetAddrLocal 2
3118: oPushResult
3119: oGetParam 1
3121: oPushResult
3122: LAST_ID
3123: oPushResult
3124: oCall 9390
3126: oPop 2
3128: oAssign
3129: oGetLocal 1
3131: oPushResult
3132: oGetLocal 2
3134: oPushResult
3135: oNodeVecAppend
3136: oPop 2
3138: oInputChoice 3144
3140: oInput 0
3142: oJumpForward 3149
3144: Choice Lookup Table
          13   3140
3147: oJumpForward 3151
3149: oJumpBack 3116
3151: oInput 12
3153: oGetAddrLocal 3
3155: oPushResult
3156: oCall 3403
3158: oPop 1
3160: oGetAddrLocal 4
3162: oPushResult
3163: oSetResult 0
3165: oAssign
3166: oGetLocal 4
3168: oPushResult
3169: oGetLocal 1
3171: oPushResult
3172: oNodeVecSize
3173: oPop 1
3175: oPushResult
3176: equal
3177: oPop 2
3179: oChoice 3220
3181: oGetAddrLocal 2
3183: oPushResult
3184: oGetLocal 1
3186: oPushResult
3187: oGetLocal 4
3189: oPushResult
3190: oNodeVecElement
3191: oPop 2
3193: oAssign
3194: oGetLocal 2
3196: oPushResult
3197: oSetResult 21
3199: oPushResult
3200: oGetLocal 3
3202: oPushResult
3203: oNodeSet
3204: oPop 3
3206: oGetLocal 2
3208: oPushResult
3209: oScopeDeclareAlloc
3210: oPop 1
3212: oGetAddrLocal 4
3214: oPushResult
3215: inc
3216: oPop 1
3218: oJumpForward 3225
3220: Choice Lookup Table
           0   3181
3223: oJumpForward 3227
3225: oJumpBack 3166
3227: oInputChoice 3317
3229: oGetLocal 1
3231: oPushResult
3232: oNodeVecSize
3233: oPop 1
3235: oChoice 3239
3237: oJumpForward 3244
3239: Choice Lookup Table
           1   3237
3242: oError 22
3244: oGetAddrLocal 5
3246: oPushResult
3247: oScopeCurrent
3248: oPushResult
3249: oCall 1835
3251: oPop 1
3253: oAssign
3254: oGetLocal 5
3256: oPushResult
3257: oCodePush
3258: oPop 1
3260: oGetAddrLocal 6
3262: oPushResult
3263: oSetResult 0
3265: oAssign
3266: oCall 9160
3268: oPushResult
3269: equal_zero
3270: oPop 1
3272: oChoice 3288
3274: oGetGlobal 3
3276: oPushResult
3277: oScopeEnter
3278: oPop 1
3280: oGetAddrLocal 6
3282: oPushResult
3283: oSetResult 1
3285: oAssign
3286: oJumpForward 3291
3288: Choice Lookup Table
           1   3274
3291: oGetLocal 2
3293: oPushResult
3294: oCall 8395
3296: oPop 1
3298: oCall 4532
3300: oCall 9210
3302: oCall 8160
3304: oGetLocal 6
3306: oChoice 3311
3308: oScopeEnd
3309: oJumpForward 3314
3311: Choice Lookup Table
           1   3308
3314: oCodePop
3315: oJumpForward 3320
3317: Choice Lookup Table
           6   3229
3320: oGetLocal 1
3322: oPushResult
3323: oNodeVecDelete
3324: oPop 1
3326: oInput 5
3328: oJumpForward 3335
3330: Choice Lookup Table
           0   3111
3333: oJumpForward 3337
3335: oJumpBack 3109
3337: oReturn
3338: oLocalSpace 2
3340: oInputChoice 3347
3342: oJumpForward 3353
3344: oChangeIntLitToLabelIdent
3345: oJumpForward 3353
3347: Choice Lookup Table
           1   3344
           0   3342
3352: oEndChoice
3353: oGetAddrLocal 1
3355: oPushResult
3356: oSetResult 24
3358: oPushResult
3359: LAST_ID
3360: oPushResult
3361: oCall 9390
3363: oPop 2
3365: oAssign
3366: oGetAddrLocal 2
3368: oPushResult
3369: oLabelNew
3370: oAssign
3371: oGetLocal 1
3373: oPushResult
3374: oSetResult 22
3376: oPushResult
3377: oGetLocal 2
3379: oPushResult
3380: oNodeSetLabel
3381: oPop 3
3383: oGetLocal 1
3385: oPushResult
3386: oScopeDeclare
3387: oPop 1
3389: oInputChoice 3393
3391: oJumpForward 3398
3393: Choice Lookup Table
          13   3391
3396: oJumpForward 3400
3398: oJumpBack 3340
3400: oInput 5
3402: oReturn
3403: oLocalSpace 12
3405: oInputChoice 3878
3407: oGetAddrLocal 1
3409: oPushResult
3410: oScopeFindRequire
3411: oAssign
3412: oGetAddrLocal 1
3414: oPushResult
3415: oCall 409
3417: oPop 1
3419: oGetLocal 1
3421: oPushResult
3422: oNodeType
3423: oPop 1
3425: oChoice 3442
3427: oGetParam 1
3429: oPushResult
3430: oGetLocal 1
3432: oPushResult
3433: oSetResult 21
3435: oPushResult
3436: oNodeGet
3437: oPop 2
3439: oAssign
3440: oJumpForward 3453
3442: Choice Lookup Table
          18   3427
3445: oError 2
3447: oGetParam 1
3449: oPushResult
3450: oGetGlobal 5
3452: oAssign
3453: oJumpForward 3897
3455: oInput 16
3457: oGetAddrLocal 2
3459: oPushResult
3460: oNodeVecNew
3461: oAssign
3462: oGetAddrLocal 3
3464: oPushResult
3465: oSetResult 35
3467: oPushResult
3468: oNodeNew
3469: oPop 1
3471: oAssign
3472: oGetLocal 3
3474: oPushResult
3475: oSetResult 36
3477: oPushResult
3478: oGetGlobal 5
3480: oPushResult
3481: oNodeSet
3482: oPop 3
3484: oCall 4459
3486: oGetLocal 3
3488: oPushResult
3489: oSetResult 38
3491: oPushResult
3492: oValueTop
3493: oPushResult
3494: oNodeSetInt
3495: oPop 3
3497: oValuePop
3498: oInput 21
3500: oCall 4459
3502: oGetLocal 3
3504: oPushResult
3505: oSetResult 39
3507: oPushResult
3508: oValueTop
3509: oPushResult
3510: oNodeSetInt
3511: oPop 3
3513: oValuePop
3514: oGetLocal 3
3516: oPushResult
3517: oSetResult 17
3519: oPushResult
3520: oSetResult 4
3522: oPushResult
3523: oNodeSetInt
3524: oPop 3
3526: oGetLocal 3
3528: oPushResult
3529: oTypeAdd
3530: oPop 1
3532: oGetAddrLocal 4
3534: oPushResult
3535: oSetResult 34
3537: oPushResult
3538: oNodeNew
3539: oPop 1
3541: oAssign
3542: oGetLocal 4
3544: oPushResult
3545: oSetResult 37
3547: oPushResult
3548: oGetLocal 3
3550: oPushResult
3551: oNodeSet
3552: oPop 3
3554: oGetLocal 2
3556: oPushResult
3557: oGetLocal 4
3559: oPushResult
3560: oNodeVecAppend
3561: oPop 2
3563: oInputChoice 3571
3565: oJumpForward 3579
3567: oJumpForward 3577
3569: oJumpForward 3577
3571: Choice Lookup Table
          13   3569
          17   3565
3576: oEndChoice
3577: oJumpBack 3462
3579: oInput 40
3581: oGetAddrLocal 5
3583: oPushResult
3584: oCall 3403
3586: oPop 1
3588: oGetAddrLocal 6
3590: oPushResult
3591: oGetLocal 2
3593: oPushResult
3594: oNodeVecSize
3595: oPop 1
3597: oAssign
3598: oGetAddrLocal 6
3600: oPushResult
3601: dec
3602: oPop 1
3604: oGetAddrLocal 7
3606: oPushResult
3607: oGetLocal 2
3609: oPushResult
3610: oGetLocal 6
3612: oPushResult
3613: oNodeVecElement
3614: oPop 2
3616: oAssign
3617: oGetLocal 7
3619: oPushResult
3620: oSetResult 36
3622: oPushResult
3623: oGetLocal 5
3625: oPushResult
3626: oNodeSet
3627: oPop 3
3629: oGetAddrLocal 8
3631: oPushResult
3632: oGetLocal 7
3634: oPushResult
3635: oSetResult 37
3637: oPushResult
3638: oNodeGet
3639: oPop 2
3641: oAssign
3642: oGetAddrLocal 9
3644: oPushResult
3645: oGetLocal 8
3647: oPushResult
3648: oSetResult 39
3650: oPushResult
3651: oNodeGetInt
3652: oPop 2
3654: oPushResult
3655: oGetLocal 8
3657: oPushResult
3658: oSetResult 38
3660: oPushResult
3661: oNodeGetInt
3662: oPop 2
3664: oPushResult
3665: subtract
3666: oPop 2
3668: oAssign
3669: oGetAddrLocal 9
3671: oPushResult
3672: inc
3673: oPop 1
3675: oGetLocal 7
3677: oPushResult
3678: oSetResult 17
3680: oPushResult
3681: oGetLocal 9
3683: oPushResult
3684: oGetLocal 5
3686: oPushResult
3687: oSetResult 17
3689: oPushResult
3690: oNodeGetInt
3691: oPop 2
3693: oPushResult
3694: multiply
3695: oPop 2
3697: oPushResult
3698: oNodeSetInt
3699: oPop 3
3701: oGetLocal 7
3703: oPushResult
3704: oTypeAdd
3705: oPop 1
3707: oGetAddrLocal 5
3709: oPushResult
3710: oGetLocal 7
3712: oAssign
3713: oGetLocal 6
3715: oPushResult
3716: equal_zero
3717: oPop 1
3719: oChoice 3725
3721: oJumpForward 3730
3723: oJumpForward 3728
3725: Choice Lookup Table
           1   3721
3728: oJumpBack 3598
3730: oGetParam 1
3732: oPushResult
3733: oGetLocal 2
3735: oPushResult
3736: oSetResult 0
3738: oPushResult
3739: oNodeVecElement
3740: oPop 2
3742: oAssign
3743: oGetLocal 2
3745: oPushResult
3746: oNodeVecDelete
3747: oPop 1
3749: oJumpForward 3897
3751: oGetAddrLocal 10
3753: oPushResult
3754: oCall 3403
3756: oPop 1
3758: oGetParam 1
3760: oPushResult
3761: oGetLocal 10
3763: oPushResult
3764: oCall 9418
3766: oPop 1
3768: oAssign
3769: oJumpForward 3897
3771: oGetParam 1
3773: oPushResult
3774: oSetResult 36
3776: oPushResult
3777: oNodeNew
3778: oPop 1
3780: oAssign
3781: oSetResult -1
3783: oPushResult
3784: oSetResult 2
3786: oPushResult
3787: oScopeBegin
3788: oPop 2
3790: oSetResult 22
3792: oPushResult
3793: oCall 3107
3795: oPop 1
3797: oGetAddrLocal 11
3799: oPushResult
3800: oScopeCurrent
3801: oPushResult
3802: oSetResult 17
3804: oPushResult
3805: oNodeGetInt
3806: oPop 2
3808: oAssign
3809: oGetLocal 11
3811: oPushResult
3812: equal_zero
3813: oPop 1
3815: oChoice 3821
3817: oError 19
3819: oJumpForward 3824
3821: Choice Lookup Table
           1   3817
3824: oInput 36
3826: oGetFromParam 1
3828: oPushResult
3829: oSetResult 40
3831: oPushResult
3832: oScopeCurrent
3833: oPushResult
3834: oNodeSet
3835: oPop 3
3837: oGetFromParam 1
3839: oPushResult
3840: oSetResult 17
3842: oPushResult
3843: oGetLocal 11
3845: oPushResult
3846: oNodeSetInt
3847: oPop 3
3849: oScopeEnd
3850: oGetFromParam 1
3852: oPushResult
3853: oTypeAdd
3854: oPop 1
3856: oJumpForward 3897
3858: oGetParam 1
3860: oPushResult
3861: oCall 3898
3863: oPop 1
3865: oJumpForward 3897
3867: oInput 40
3869: oGetAddrLocal 12
3871: oPushResult
3872: oCall 3403
3874: oPop 1
3876: oJumpForward 3897
3878: Choice Lookup Table
          39   3867
          14   3858
          38   3771
          18   3751
          37   3455
           0   3407
3891: oCall 4459
3893: oInput 21
3895: oCall 4459
3897: oReturn
3898: oLocalSpace 11
3900: oGetParam 1
3902: oPushResult
3903: oSetResult 37
3905: oPushResult
3906: oNodeNew
3907: oPop 1
3909: oAssign
3910: oGetAddrLocal 1
3912: oPushResult
3913: oSetResult 0
3915: oAssign
3916: oGetAddrLocal 2
3918: oPushResult
3919: oSetResult 0
3921: oAssign
3922: oGetAddrLocal 3
3924: oPushResult
3925: oSetResult 1
3927: oAssign
3928: oGetAddrLocal 4
3930: oPushResult
3931: oScopeCurrent
3932: oAssign
3933: oSetResult -1
3935: oPushResult
3936: oSetResult 2
3938: oPushResult
3939: oScopeBegin
3940: oPop 2
3942: oInput 0
3944: oGetAddrLocal 5
3946: oPushResult
3947: oSetResult 17
3949: oPushResult
3950: LAST_ID
3951: oPushResult
3952: oCall 9390
3954: oPop 2
3956: oAssign
3957: oGetAddrLocal 6
3959: oPushResult
3960: oSetResult 17
3962: oPushResult
3963: LAST_ID
3964: oPushResult
3965: oCall 9390
3967: oPop 2
3969: oAssign
3970: oGetLocal 5
3972: oPushResult
3973: oSetResult 21
3975: oPushResult
3976: oGetFromParam 1
3978: oPushResult
3979: oNodeSet
3980: oPop 3
3982: oGetLocal 6
3984: oPushResult
3985: oSetResult 21
3987: oPushResult
3988: oGetFromParam 1
3990: oPushResult
3991: oNodeSet
3992: oPop 3
3994: oGetAddrLocal 7
3996: oPushResult
3997: LAST_ID
3998: oPushResult
3999: ID_STRING
4000: oPop 1
4002: oPushResult
4003: oStringAllocLit
4004: oPop 1
4006: oAssign
4007: oGetLocal 5
4009: oPushResult
4010: oSetResult 32
4012: oPushResult
4013: oGetLocal 7
4015: oPushResult
4016: oNodeSetInt
4017: oPop 3
4019: oGetLocal 6
4021: oPushResult
4022: oSetResult 32
4024: oPushResult
4025: oGetLocal 7
4027: oPushResult
4028: oNodeSetInt
4029: oPop 3
4031: oInputChoice 4100
4033: oCall 4459
4035: oGetLocal 2
4037: oPushResult
4038: equal_zero
4039: oPop 1
4041: oChoice 4062
4043: oValueTop
4044: oPushResult
4045: oGetLocal 1
4047: oPushResult
4048: greater
4049: oPop 2
4051: oChoice 4057
4053: oError 26
4055: oJumpForward 4060
4057: Choice Lookup Table
           0   4053
4060: oJumpForward 4065
4062: Choice Lookup Table
           0   4043
4065: oGetLocal 1
4067: oPushResult
4068: oValueTop
4069: oPushResult
4070: equal
4071: oPop 2
4073: oChoice 4089
4075: oGetFromParam 1
4077: oPushResult
4078: oSetResult 42
4080: oPushResult
4081: oSetResult 1
4083: oPushResult
4084: oNodeSetBoolean
4085: oPop 3
4087: oJumpForward 4092
4089: Choice Lookup Table
           0   4075
4092: oGetAddrLocal 1
4094: oPushResult
4095: oValueTop
4096: oAssign
4097: oValuePop
4098: oJumpForward 4105
4100: Choice Lookup Table
           4   4033
           6   4033
4105: oGetLocal 5
4107: oPushResult
4108: oSetResult 22
4110: oPushResult
4111: oGetLocal 1
4113: oPushResult
4114: oNodeSetInt
4115: oPop 3
4117: oGetLocal 6
4119: oPushResult
4120: oSetResult 22
4122: oPushResult
4123: oGetLocal 1
4125: oPushResult
4126: oNodeSetInt
4127: oPop 3
4129: oGetLocal 5
4131: oPushResult
4132: oScopeDeclare
4133: oPop 1
4135: oGetLocal 4
4137: oPushResult
4138: oScopeEnter
4139: oPop 1
4141: oGetLocal 6
4143: oPushResult
4144: oScopeDeclare
4145: oPop 1
4147: oScopeEnd
4148: oGetAddrLocal 1
4150: oPushResult
4151: inc
4152: oPop 1
4154: oGetAddrLocal 2
4156: oPushResult
4157: inc
4158: oPop 1
4160: oInputChoice 4164
4162: oJumpForward 4169
4164: Choice Lookup Table
          13   4162
4167: oJumpForward 4171
4169: oJumpBack 3942
4171: oInput 15
4173: oGetFromParam 1
4175: oPushResult
4176: oSetResult 40
4178: oPushResult
4179: oScopeCurrent
4180: oPushResult
4181: oNodeSet
4182: oPop 3
4184: oGetFromParam 1
4186: oPushResult
4187: oSetResult 17
4189: oPushResult
4190: oSetResult 4
4192: oPushResult
4193: oNodeSetInt
4194: oPop 3
4196: oScopeEnd
4197: oGetGlobal 2
4199: oPushResult
4200: oCall 1835
4202: oPop 1
4204: oPushResult
4205: oCodePush
4206: oPop 1
4208: oGetGlobal 2
4210: oPushResult
4211: oScopeEnter
4212: oPop 1
4214: oGetAddrLocal 8
4216: oPushResult
4217: oGetLocal 2
4219: oPushResult
4220: oSetResult 1
4222: oPushResult
4223: add
4224: oPop 2
4226: oPushResult
4227: oSetResult 16
4229: oPushResult
4230: multiply
4231: oPop 2
4233: oAssign
4234: oGetAddrLocal 9
4236: oPushResult
4237: oGetLocal 8
4239: oPushResult
4240: oSetResult 8
4242: oPushResult
4243: oScopeAlloc
4244: oPop 2
4246: oAssign
4247: oScopeEnd
4248: oGetFromParam 1
4250: oPushResult
4251: oSetResult 41
4253: oPushResult
4254: oGetLocal 9
4256: oPushResult
4257: oNodeSetInt
4258: oPop 3
4260: oGetAddrLocal 10
4262: oPushResult
4263: oGetFromParam 1
4265: oPushResult
4266: oSetResult 40
4268: oPushResult
4269: oNodeGet
4270: oPop 2
4272: oPushResult
4273: oSetResult 15
4275: oPushResult
4276: oNodeGetIter
4277: oPop 2
4279: oAssign
4280: oGetAddrLocal 11
4282: oPushResult
4283: oGetLocal 10
4285: oPushResult
4286: oNodeIterValue
4287: oPop 1
4289: oAssign
4290: oGetLocal 11
4292: oPushResult
4293: oNodeNull
4294: oPop 1
4296: oChoice 4302
4298: oJumpForward 4389
4300: oJumpForward 4305
4302: Choice Lookup Table
           1   4298
4305: oEmit 16
4307: oGetLocal 9
4309: oPushResult
4310: oEmitInt
4311: oPop 1
4313: oEmit 15
4315: oGetLocal 11
4317: oPushResult
4318: oSetResult 22
4320: oPushResult
4321: oNodeGetInt
4322: oPop 2
4324: oPushResult
4325: oEmitInt
4326: oPop 1
4328: oEmit 25
4330: oGetAddrLocal 9
4332: oPushResult
4333: oGetLocal 9
4335: oPushResult
4336: oSetResult 8
4338: oPushResult
4339: add
4340: oPop 2
4342: oAssign
4343: oEmit 16
4345: oGetLocal 9
4347: oPushResult
4348: oEmitInt
4349: oPop 1
4351: oEmit 16
4353: oGetLocal 11
4355: oPushResult
4356: oSetResult 32
4358: oPushResult
4359: oNodeGetInt
4360: oPop 2
4362: oPushResult
4363: oEmitInt
4364: oPop 1
4366: oEmit 27
4368: oGetAddrLocal 9
4370: oPushResult
4371: oGetLocal 9
4373: oPushResult
4374: oSetResult 8
4376: oPushResult
4377: add
4378: oPop 2
4380: oAssign
4381: oGetAddrLocal 10
4383: oPushResult
4384: oNodeIterNext
4385: oPop 1
4387: oJumpBack 4280
4389: oEmit 16
4391: oGetLocal 9
4393: oPushResult
4394: oEmitInt
4395: oPop 1
4397: oEmit 15
4399: oSetResult 0
4401: oPushResult
4402: oEmitInt
4403: oPop 1
4405: oEmit 25
4407: oGetAddrLocal 9
4409: oPushResult
4410: oGetLocal 9
4412: oPushResult
4413: oSetResult 8
4415: oPushResult
4416: add
4417: oPop 2
4419: oAssign
4420: oEmit 16
4422: oGetLocal 9
4424: oPushResult
4425: oEmitInt
4426: oPop 1
4428: oEmit 15
4430: oSetResult 0
4432: oPushResult
4433: oEmitInt
4434: oPop 1
4436: oEmit 27
4438: oGetAddrLocal 9
4440: oPushResult
4441: oGetLocal 9
4443: oPushResult
4444: oSetResult 8
4446: oPushResult
4447: add
4448: oPop 2
4450: oAssign
4451: oCodePop
4452: oGetFromParam 1
4454: oPushResult
4455: oTypeAdd
4456: oPop 1
4458: oReturn
4459: oLocalSpace 1
4461: oInputChoice 4523
4463: TOKEN_VALUE
4464: oPushResult
4465: oValuePush
4466: oPop 1
4468: oJumpForward 4531
4470: oGetAddrLocal 1
4472: oPushResult
4473: oScopeFindRequire
4474: oAssign
4475: oGetAddrLocal 1
4477: oPushResult
4478: oCall 409
4480: oPop 1
4482: oGetLocal 1
4484: oPushResult
4485: oNodeType
4486: oPop 1
4488: oChoice 4505
4490: oGetLocal 1
4492: oPushResult
4493: oSetResult 22
4495: oPushResult
4496: oNodeGetInt
4497: oPop 2
4499: oPushResult
4500: oValuePush
4501: oPop 1
4503: oJumpForward 4516
4505: Choice Lookup Table
          16   4490
4508: oError 1
4510: oSetResult 0
4512: oPushResult
4513: oValuePush
4514: oPop 1
4516: oJumpForward 4531
4518: oCall 4459
4520: oValueNegate
4521: oJumpForward 4531
4523: Choice Lookup Table
          25   4518
           0   4470
           1   4463
4530: oEndChoice
4531: oReturn
4532: oLocalSpace 1
4534: oGetAddrLocal 1
4536: oPushResult
4537: oSetResult 0
4539: oAssign
4540: oGetAddrLocal 1
4542: oPushResult
4543: oCall 4693
4545: oPop 1
4547: oGetAddrLocal 1
4549: oPushResult
4550: oCall 4593
4552: oPop 1
4554: oReturn
4555: oLocalSpace 0
4557: oGetParam 1
4559: oPushResult
4560: oCall 4693
4562: oPop 1
4564: oTypeSNodeType
4565: oChoice 4584
4567: oJumpForward 4591
4569: oGetParam 1
4571: oPushResult
4572: oLabelNew
4573: oAssign
4574: oEmit 57
4576: oGetFromParam 1
4578: oPushResult
4579: oEmitLabel
4580: oPop 1
4582: oJumpForward 4591
4584: Choice Lookup Table
          29   4569
          30   4567
4589: oError 8
4591: oTypeSPop
4592: oReturn
4593: oLocalSpace 1
4595: oTypeSNodeType
4596: oChoice 4658
4598: oGetAddrLocal 1
4600: oPushResult
4601: oLabelNew
4602: oAssign
4603: oEmit 15
4605: oSetResult 1
4607: oPushResult
4608: oEmitInt
4609: oPop 1
4611: oEmit 55
4613: oGetLocal 1
4615: oPushResult
4616: oEmitLabel
4617: oPop 1
4619: oEmit 58
4621: oGetFromParam 1
4623: oPushResult
4624: oEmitLabel
4625: oPop 1
4627: oEmit 15
4629: oSetResult 0
4631: oPushResult
4632: oEmitInt
4633: oPop 1
4635: oEmit 58
4637: oGetLocal 1
4639: oPushResult
4640: oEmitLabel
4641: oPop 1
4643: oTypeSPop
4644: oGetGlobal 6
4646: oPushResult
4647: oTypeSPush
4648: oPop 1
4650: oGetParam 1
4652: oPushResult
4653: oSetResult 0
4655: oAssign
4656: oJumpForward 4661
4658: Choice Lookup Table
          30   4598
4661: oReturn
4662: oLocalSpace 0
4664: oTypeSNodeType
4665: oChoice 4689
4667: oGetParam 1
4669: oPushResult
4670: oLabelNew
4671: oAssign
4672: oEmit 57
4674: oGetFromParam 1
4676: oPushResult
4677: oEmitLabel
4678: oPop 1
4680: oTypeSPop
4681: oGetGlobal 7
4683: oPushResult
4684: oTypeSPush
4685: oPop 1
4687: oJumpForward 4692
4689: Choice Lookup Table
          29   4667
4692: oReturn
4693: oLocalSpace 0
4695: oGetParam 1
4697: oPushResult
4698: oCall 5094
4700: oPop 1
4702: oInputChoice 5076
4704: oGetParam 1
4706: oPushResult
4707: oCall 4593
4709: oPop 1
4711: oCall 9309
4713: oGetParam 1
4715: oPushResult
4716: oCall 5094
4718: oPop 1
4720: oGetParam 1
4722: oPushResult
4723: oCall 4593
4725: oPop 1
4727: oCall 9309
4729: oCall 9210
4731: oTypeSNodeType
4732: oChoice 4746
4734: oEmit 40
4736: oJumpForward 4761
4738: oEmit 46
4740: oJumpForward 4761
4742: oError 16
4744: oJumpForward 4761
4746: Choice Lookup Table
          32   4742
          31   4742
          33   4738
          29   4734
          37   4734
          27   4734
4759: oError 17
4761: oTypeSPop
4762: oGetGlobal 6
4764: oPushResult
4765: oTypeSPush
4766: oPop 1
4768: oJumpForward 5091
4770: oGetParam 1
4772: oPushResult
4773: oCall 4593
4775: oPop 1
4777: oCall 9309
4779: oGetParam 1
4781: oPushResult
4782: oCall 5094
4784: oPop 1
4786: oGetParam 1
4788: oPushResult
4789: oCall 4593
4791: oPop 1
4793: oCall 9309
4795: oCall 9210
4797: oTypeSNodeType
4798: oChoice 4812
4800: oEmit 41
4802: oJumpForward 4827
4804: oEmit 47
4806: oJumpForward 4827
4808: oError 16
4810: oJumpForward 4827
4812: Choice Lookup Table
          32   4808
          31   4808
          33   4804
          29   4800
          37   4800
          27   4800
4825: oError 17
4827: oTypeSPop
4828: oGetGlobal 6
4830: oPushResult
4831: oTypeSPush
4832: oPop 1
4834: oJumpForward 5091
4836: oGetParam 1
4838: oPushResult
4839: oCall 4593
4841: oPop 1
4843: oCall 9309
4845: oGetParam 1
4847: oPushResult
4848: oCall 5094
4850: oPop 1
4852: oGetParam 1
4854: oPushResult
4855: oCall 4593
4857: oPop 1
4859: oCall 9309
4861: oCall 9210
4863: oTypeSNodeType
4864: oChoice 4874
4866: oEmit 43
4868: oJumpForward 4887
4870: oError 16
4872: oJumpForward 4887
4874: Choice Lookup Table
          32   4870
          31   4870
          29   4866
          37   4866
          27   4866
4885: oError 17
4887: oTypeSPop
4888: oGetGlobal 6
4890: oPushResult
4891: oTypeSPush
4892: oPop 1
4894: oJumpForward 5091
4896: oGetParam 1
4898: oPushResult
4899: oCall 4593
4901: oPop 1
4903: oCall 9309
4905: oGetParam 1
4907: oPushResult
4908: oCall 5094
4910: oPop 1
4912: oGetParam 1
4914: oPushResult
4915: oCall 4593
4917: oPop 1
4919: oCall 9309
4921: oCall 9210
4923: oTypeSNodeType
4924: oChoice 4934
4926: oEmit 42
4928: oJumpForward 4947
4930: oError 16
4932: oJumpForward 4947
4934: Choice Lookup Table
          32   4930
          31   4930
          29   4926
          37   4926
          27   4926
4945: oError 17
4947: oTypeSPop
4948: oGetGlobal 6
4950: oPushResult
4951: oTypeSPush
4952: oPop 1
4954: oJumpForward 5091
4956: oGetParam 1
4958: oPushResult
4959: oCall 4593
4961: oPop 1
4963: oCall 9309
4965: oGetParam 1
4967: oPushResult
4968: oCall 5094
4970: oPop 1
4972: oGetParam 1
4974: oPushResult
4975: oCall 4593
4977: oPop 1
4979: oCall 9309
4981: oCall 9210
4983: oTypeSNodeType
4984: oChoice 4994
4986: oEmit 45
4988: oJumpForward 5007
4990: oError 16
4992: oJumpForward 5007
4994: Choice Lookup Table
          32   4990
          31   4990
          29   4986
          37   4986
          27   4986
5005: oError 17
5007: oTypeSPop
5008: oGetGlobal 6
5010: oPushResult
5011: oTypeSPush
5012: oPop 1
5014: oJumpForward 5091
5016: oGetParam 1
5018: oPushResult
5019: oCall 4593
5021: oPop 1
5023: oCall 9309
5025: oGetParam 1
5027: oPushResult
5028: oCall 5094
5030: oPop 1
5032: oGetParam 1
5034: oPushResult
5035: oCall 4593
5037: oPop 1
5039: oCall 9309
5041: oCall 9210
5043: oTypeSNodeType
5044: oChoice 5054
5046: oEmit 44
5048: oJumpForward 5067
5050: oError 16
5052: oJumpForward 5067
5054: Choice Lookup Table
          32   5050
          31   5050
          29   5046
          37   5046
          27   5046
5065: oError 17
5067: oTypeSPop
5068: oGetGlobal 6
5070: oPushResult
5071: oTypeSPush
5072: oPop 1
5074: oJumpForward 5091
5076: Choice Lookup Table
          11   5016
          10   4956
           9   4896
           8   4836
           7   4770
           6   4704
5089: oJumpForward 5093
5091: oJumpBack 4702
5093: oReturn
5094: oLocalSpace 1
5096: oGetAddrLocal 1
5098: oPushResult
5099: oSetResult 0
5101: oAssign
5102: oGetParam 1
5104: oPushResult
5105: oCall 5274
5107: oPop 1
5109: oInputChoice 5242
5111: oTypeSNodeType
5112: oChoice 5183
5114: oGetLocal 1
5116: oPushResult
5117: oSetResult 0
5119: oPushResult
5120: equal_label
5121: oPop 2
5123: oChoice 5132
5125: oGetAddrLocal 1
5127: oPushResult
5128: oLabelNew
5129: oAssign
5130: oJumpForward 5135
5132: Choice Lookup Table
           1   5125
5135: oEmit 55
5137: oGetLocal 1
5139: oPushResult
5140: oEmitLabel
5141: oPop 1
5143: oJumpForward 5190
5145: oGetParam 1
5147: oPushResult
5148: oCall 4662
5150: oPop 1
5152: oGetLocal 1
5154: oPushResult
5155: oSetResult 0
5157: oPushResult
5158: equal_label
5159: oPop 2
5161: oChoice 5170
5163: oGetAddrLocal 1
5165: oPushResult
5166: oLabelNew
5167: oAssign
5168: oJumpForward 5173
5170: Choice Lookup Table
           1   5163
5173: oEmit 55
5175: oGetLocal 1
5177: oPushResult
5178: oEmitLabel
5179: oPop 1
5181: oJumpForward 5190
5183: Choice Lookup Table
          29   5145
          30   5114
5188: oError 8
5190: oTypeSPop
5191: oEmit 58
5193: oGetFromParam 1
5195: oPushResult
5196: oEmitLabel
5197: oPop 1
5199: oGetParam 1
5201: oPushResult
5202: oSetResult 0
5204: oAssign
5205: oGetParam 1
5207: oPushResult
5208: oCall 5274
5210: oPop 1
5212: oTypeSNodeType
5213: oChoice 5226
5215: oJumpForward 5233
5217: oGetParam 1
5219: oPushResult
5220: oCall 4662
5222: oPop 1
5224: oJumpForward 5233
5226: Choice Lookup Table
          29   5217
          30   5215
5231: oError 8
5233: oTypeSPop
5234: oGetGlobal 7
5236: oPushResult
5237: oTypeSPush
5238: oPop 1
5240: oJumpForward 5247
5242: Choice Lookup Table
          55   5111
5245: oJumpForward 5249
5247: oJumpBack 5109
5249: oGetLocal 1
5251: oPushResult
5252: oSetResult 0
5254: oPushResult
5255: equal_label
5256: oPop 2
5258: oChoice 5270
5260: oEmit 58
5262: oGetLocal 1
5264: oPushResult
5265: oEmitLabel
5266: oPop 1
5268: oJumpForward 5273
5270: Choice Lookup Table
           0   5260
5273: oReturn
5274: oLocalSpace 2
5276: oGetAddrLocal 1
5278: oPushResult
5279: oSetResult 0
5281: oAssign
5282: oGetParam 1
5284: oPushResult
5285: oCall 5412
5287: oPop 1
5289: oInputChoice 5404
5291: oTypeSNodeType
5292: oChoice 5305
5294: oJumpForward 5312
5296: oGetParam 1
5298: oPushResult
5299: oCall 4662
5301: oPop 1
5303: oJumpForward 5312
5305: Choice Lookup Table
          29   5296
          30   5294
5310: oError 8
5312: oTypeSPop
5313: oGetLocal 1
5315: oPushResult
5316: oSetResult 0
5318: oPushResult
5319: equal_label
5320: oPop 2
5322: oChoice 5351
5324: oGetAddrLocal 1
5326: oPushResult
5327: oLabelNew
5328: oAssign
5329: oEmit 59
5331: oGetFromParam 1
5333: oPushResult
5334: oEmitLabel
5335: oPop 1
5337: oGetLocal 1
5339: oPushResult
5340: oEmitLabel
5341: oPop 1
5343: oGetParam 1
5345: oPushResult
5346: oGetLocal 1
5348: oAssign
5349: oJumpForward 5354
5351: Choice Lookup Table
           1   5324
5354: oGetAddrLocal 2
5356: oPushResult
5357: oSetResult 0
5359: oAssign
5360: oGetAddrLocal 2
5362: oPushResult
5363: oCall 5412
5365: oPop 1
5367: oTypeSNodeType
5368: oChoice 5381
5370: oJumpForward 5388
5372: oGetAddrLocal 2
5374: oPushResult
5375: oCall 4662
5377: oPop 1
5379: oJumpForward 5388
5381: Choice Lookup Table
          29   5372
          30   5370
5386: oError 8
5388: oEmit 59
5390: oGetLocal 2
5392: oPushResult
5393: oEmitLabel
5394: oPop 1
5396: oGetLocal 1
5398: oPushResult
5399: oEmitLabel
5400: oPop 1
5402: oJumpForward 5409
5404: Choice Lookup Table
          54   5291
5407: oJumpForward 5411
5409: oJumpBack 5289
5411: oReturn
5412: oLocalSpace 1
5414: oInputChoice 5468
5416: oGetAddrLocal 1
5418: oPushResult
5419: oSetResult 0
5421: oAssign
5422: oGetAddrLocal 1
5424: oPushResult
5425: oCall 5412
5427: oPop 1
5429: oTypeSNodeType
5430: oChoice 5459
5432: oGetParam 1
5434: oPushResult
5435: oLabelNew
5436: oAssign
5437: oEmit 55
5439: oGetFromParam 1
5441: oPushResult
5442: oEmitLabel
5443: oPop 1
5445: oEmit 58
5447: oGetLocal 1
5449: oPushResult
5450: oEmitLabel
5451: oPop 1
5453: oJumpForward 5466
5455: oEmit 39
5457: oJumpForward 5466
5459: Choice Lookup Table
          29   5455
          30   5432
5464: oError 8
5466: oJumpForward 5478
5468: Choice Lookup Table
          56   5416
5471: oGetParam 1
5473: oPushResult
5474: oCall 5479
5476: oPop 1
5478: oReturn
5479: oLocalSpace 0
5481: oGetParam 1
5483: oPushResult
5484: oCall 5530
5486: oPop 1
5488: oInputChoice 5520
5490: oCall 9263
5492: oGetParam 1
5494: oPushResult
5495: oCall 5530
5497: oPop 1
5499: oCall 9283
5501: oEmit 36
5503: oJumpForward 5527
5505: oCall 9263
5507: oGetParam 1
5509: oPushResult
5510: oCall 5530
5512: oPop 1
5514: oCall 9283
5516: oEmit 37
5518: oJumpForward 5527
5520: Choice Lookup Table
          25   5505
          24   5490
5525: oJumpForward 5529
5527: oJumpBack 5488
5529: oReturn
5530: oLocalSpace 0
5532: oGetParam 1
5534: oPushResult
5535: oCall 5581
5537: oPop 1
5539: oInputChoice 5571
5541: oCall 9263
5543: oGetParam 1
5545: oPushResult
5546: oCall 5581
5548: oPop 1
5550: oCall 9283
5552: oEmit 33
5554: oJumpForward 5578
5556: oCall 9263
5558: oGetParam 1
5560: oPushResult
5561: oCall 5581
5563: oPop 1
5565: oCall 9283
5567: oEmit 34
5569: oJumpForward 5578
5571: Choice Lookup Table
          23   5556
          22   5541
5576: oJumpForward 5580
5578: oJumpBack 5539
5580: oReturn
5581: oLocalSpace 0
5583: oInputChoice 5609
5585: oGetParam 1
5587: oPushResult
5588: oCall 5622
5590: oPop 1
5592: oCall 9283
5594: oJumpForward 5621
5596: oGetParam 1
5598: oPushResult
5599: oCall 5622
5601: oPop 1
5603: oCall 9283
5605: oEmit 38
5607: oJumpForward 5621
5609: Choice Lookup Table
          25   5596
          24   5585
5614: oGetParam 1
5616: oPushResult
5617: oCall 5622
5619: oPop 1
5621: oReturn
5622: oLocalSpace 6
5624: oInputChoice 5854
5626: oEmit 15
5628: TOKEN_VALUE
5629: oPushResult
5630: oEmitInt
5631: oPop 1
5633: oGetGlobal 5
5635: oPushResult
5636: oTypeSPush
5637: oPop 1
5639: oJumpForward 5875
5641: oEmit 15
5643: TOKEN_VALUE
5644: oPushResult
5645: oEmitInt
5646: oPop 1
5648: oGetGlobal 8
5650: oPushResult
5651: oTypeSPush
5652: oPop 1
5654: oJumpForward 5875
5656: oGetParam 1
5658: oPushResult
5659: oCall 4693
5661: oPop 1
5663: oInput 15
5665: oJumpForward 5875
5667: oGetAddrLocal 1
5669: oPushResult
5670: CURRENT_STRLIT
5671: oPushResult
5672: oStringAllocLit
5673: oPop 1
5675: oAssign
5676: oEmit 16
5678: oGetLocal 1
5680: oPushResult
5681: oEmitInt
5682: oPop 1
5684: oGetGlobal 10
5686: oPushResult
5687: oTypeSPush
5688: oPop 1
5690: oJumpForward 5875
5692: oGetAddrLocal 2
5694: oPushResult
5695: oScopeFindRequire
5696: oAssign
5697: oGetAddrLocal 2
5699: oPushResult
5700: oCall 409
5702: oPop 1
5704: oGetLocal 2
5706: oPushResult
5707: oNodeType
5708: oPop 1
5710: oChoice 5783
5712: oGetLocal 2
5714: oPushResult
5715: oCall 7107
5717: oPop 1
5719: oJumpForward 5806
5721: oGetLocal 2
5723: oPushResult
5724: oCall 7718
5726: oPop 1
5728: oJumpForward 5806
5730: oGetAddrLocal 3
5732: oPushResult
5733: oGetLocal 2
5735: oPushResult
5736: oSetResult 21
5738: oPushResult
5739: oNodeGet
5740: oPop 2
5742: oAssign
5743: oGetLocal 3
5745: oPushResult
5746: oTypeSPush
5747: oPop 1
5749: oTypeSNodeType
5750: oChoice 5763
5752: oEmit 15
5754: oGetLocal 2
5756: oPushResult
5757: oCall 9597
5759: oPop 1
5761: oJumpForward 5772
5763: Choice Lookup Table
          29   5752
          37   5752
          27   5752
5770: oError 16
5772: oJumpForward 5806
5774: oGetLocal 2
5776: oPushResult
5777: oCall 5876
5779: oPop 1
5781: oJumpForward 5806
5783: Choice Lookup Table
          23   5774
          21   5774
          20   5774
          17   5730
          16   5730
          14   5721
          13   5712
5798: oError 6
5800: oGetGlobal 5
5802: oPushResult
5803: oTypeSPush
5804: oPop 1
5806: oJumpForward 5875
5808: oInput 0
5810: oGetAddrLocal 4
5812: oPushResult
5813: oScopeFindRequire
5814: oAssign
5815: oGetAddrLocal 4
5817: oPushResult
5818: oCall 409
5820: oPop 1
5822: oGetLocal 4
5824: oPushResult
5825: oCall 8395
5827: oPop 1
5829: oGetAddrLocal 5
5831: oPushResult
5832: oTypeSTop
5833: oAssign
5834: oTypeSPop
5835: oGetAddrLocal 6
5837: oPushResult
5838: oGetLocal 5
5840: oPushResult
5841: oCall 9418
5843: oPop 1
5845: oAssign
5846: oGetLocal 6
5848: oPushResult
5849: oTypeSPush
5850: oPop 1
5852: oJumpForward 5875
5854: Choice Lookup Table
          19   5808
           0   5692
           2   5667
          14   5656
           3   5641
           1   5626
5867: oError 6
5869: oGetGlobal 5
5871: oPushResult
5872: oTypeSPush
5873: oPop 1
5875: oReturn
5876: oLocalSpace 2
5878: oGetAddrLocal 1
5880: oPushResult
5881: oGetParam 1
5883: oPushResult
5884: oSetResult 21
5886: oPushResult
5887: oNodeGet
5888: oPop 2
5890: oAssign
5891: oGetAddrLocal 2
5893: oPushResult
5894: oGetParam 1
5896: oPushResult
5897: oCall 9192
5899: oPop 1
5901: oAssign
5902: oGetLocal 1
5904: oPushResult
5905: oTypeSPush
5906: oPop 1
5908: oTypeSNodeType
5909: oChoice 6590
5911: oGetParam 1
5913: oPushResult
5914: oNodeType
5915: oPop 1
5917: oChoice 6063
5919: oEmit 0
5921: oGetParam 1
5923: oPushResult
5924: oCall 9597
5926: oPop 1
5928: oJumpForward 6071
5930: oGetLocal 2
5932: oPushResult
5933: equal_zero
5934: oPop 1
5936: oChoice 5949
5938: oEmit 3
5940: oGetParam 1
5942: oPushResult
5943: oCall 9597
5945: oPop 1
5947: oJumpForward 5967
5949: Choice Lookup Table
           1   5938
5952: oEmit 9
5954: oGetLocal 2
5956: oPushResult
5957: oEmitInt
5958: oPop 1
5960: oGetParam 1
5962: oPushResult
5963: oCall 9597
5965: oPop 1
5967: oJumpForward 6071
5969: oGetParam 1
5971: oPushResult
5972: oSetResult 33
5974: oPushResult
5975: oNodeGetBoolean
5976: oPop 2
5978: oChoice 6021
5980: oGetLocal 2
5982: oPushResult
5983: equal_zero
5984: oPop 1
5986: oChoice 5999
5988: oEmit 8
5990: oGetParam 1
5992: oPushResult
5993: oCall 9597
5995: oPop 1
5997: oJumpForward 6017
5999: Choice Lookup Table
           1   5988
6002: oEmit 14
6004: oGetLocal 2
6006: oPushResult
6007: oEmitInt
6008: oPop 1
6010: oGetParam 1
6012: oPushResult
6013: oCall 9597
6015: oPop 1
6017: oEmit 22
6019: oJumpForward 6061
6021: Choice Lookup Table
           1   5980
6024: oGetLocal 2
6026: oPushResult
6027: equal_zero
6028: oPop 1
6030: oChoice 6043
6032: oEmit 6
6034: oGetParam 1
6036: oPushResult
6037: oCall 9597
6039: oPop 1
6041: oJumpForward 6061
6043: Choice Lookup Table
           1   6032
6046: oEmit 12
6048: oGetLocal 2
6050: oPushResult
6051: oEmitInt
6052: oPop 1
6054: oGetParam 1
6056: oPushResult
6057: oCall 9597
6059: oPop 1
6061: oJumpForward 6071
6063: Choice Lookup Table
          23   5969
          21   5930
          20   5919
6070: oEndChoice
6071: oJumpForward 6612
6073: oGetParam 1
6075: oPushResult
6076: oNodeType
6077: oPop 1
6079: oChoice 6225
6081: oEmit 1
6083: oGetParam 1
6085: oPushResult
6086: oCall 9597
6088: oPop 1
6090: oJumpForward 6233
6092: oGetLocal 2
6094: oPushResult
6095: equal_zero
6096: oPop 1
6098: oChoice 6111
6100: oEmit 4
6102: oGetParam 1
6104: oPushResult
6105: oCall 9597
6107: oPop 1
6109: oJumpForward 6129
6111: Choice Lookup Table
           1   6100
6114: oEmit 10
6116: oGetLocal 2
6118: oPushResult
6119: oEmitInt
6120: oPop 1
6122: oGetParam 1
6124: oPushResult
6125: oCall 9597
6127: oPop 1
6129: oJumpForward 6233
6131: oGetParam 1
6133: oPushResult
6134: oSetResult 33
6136: oPushResult
6137: oNodeGetBoolean
6138: oPop 2
6140: oChoice 6183
6142: oGetLocal 2
6144: oPushResult
6145: equal_zero
6146: oPop 1
6148: oChoice 6161
6150: oEmit 8
6152: oGetParam 1
6154: oPushResult
6155: oCall 9597
6157: oPop 1
6159: oJumpForward 6179
6161: Choice Lookup Table
           1   6150
6164: oEmit 14
6166: oGetLocal 2
6168: oPushResult
6169: oEmitInt
6170: oPop 1
6172: oGetParam 1
6174: oPushResult
6175: oCall 9597
6177: oPop 1
6179: oEmit 23
6181: oJumpForward 6223
6183: Choice Lookup Table
           1   6142
6186: oGetLocal 2
6188: oPushResult
6189: equal_zero
6190: oPop 1
6192: oChoice 6205
6194: oEmit 7
6196: oGetParam 1
6198: oPushResult
6199: oCall 9597
6201: oPop 1
6203: oJumpForward 6223
6205: Choice Lookup Table
           1   6194
6208: oEmit 13
6210: oGetLocal 2
6212: oPushResult
6213: oEmitInt
6214: oPop 1
6216: oGetParam 1
6218: oPushResult
6219: oCall 9597
6221: oPop 1
6223: oJumpForward 6233
6225: Choice Lookup Table
          23   6131
          21   6092
          20   6081
6232: oEndChoice
6233: oJumpForward 6612
6235: oError 16
6237: oJumpForward 6612
6239: oGetParam 1
6241: oPushResult
6242: oNodeType
6243: oPop 1
6245: oChoice 6391
6247: oEmit 2
6249: oGetParam 1
6251: oPushResult
6252: oCall 9597
6254: oPop 1
6256: oJumpForward 6399
6258: oGetLocal 2
6260: oPushResult
6261: equal_zero
6262: oPop 1
6264: oChoice 6277
6266: oEmit 5
6268: oGetParam 1
6270: oPushResult
6271: oCall 9597
6273: oPop 1
6275: oJumpForward 6295
6277: Choice Lookup Table
           1   6266
6280: oEmit 11
6282: oGetLocal 2
6284: oPushResult
6285: oEmitInt
6286: oPop 1
6288: oGetParam 1
6290: oPushResult
6291: oCall 9597
6293: oPop 1
6295: oJumpForward 6399
6297: oGetParam 1
6299: oPushResult
6300: oSetResult 33
6302: oPushResult
6303: oNodeGetBoolean
6304: oPop 2
6306: oChoice 6349
6308: oGetLocal 2
6310: oPushResult
6311: equal_zero
6312: oPop 1
6314: oChoice 6327
6316: oEmit 8
6318: oGetParam 1
6320: oPushResult
6321: oCall 9597
6323: oPop 1
6325: oJumpForward 6345
6327: Choice Lookup Table
           1   6316
6330: oEmit 14
6332: oGetLocal 2
6334: oPushResult
6335: oEmitInt
6336: oPop 1
6338: oGetParam 1
6340: oPushResult
6341: oCall 9597
6343: oPop 1
6345: oEmit 24
6347: oJumpForward 6389
6349: Choice Lookup Table
           1   6308
6352: oGetLocal 2
6354: oPushResult
6355: equal_zero
6356: oPop 1
6358: oChoice 6371
6360: oEmit 8
6362: oGetParam 1
6364: oPushResult
6365: oCall 9597
6367: oPop 1
6369: oJumpForward 6389
6371: Choice Lookup Table
           1   6360
6374: oEmit 14
6376: oGetLocal 2
6378: oPushResult
6379: oEmitInt
6380: oPop 1
6382: oGetParam 1
6384: oPushResult
6385: oCall 9597
6387: oPop 1
6389: oJumpForward 6399
6391: Choice Lookup Table
          23   6297
          21   6258
          20   6247
6398: oEndChoice
6399: oInputChoice 6421
6401: oTypeSPop
6402: oGetLocal 1
6404: oPushResult
6405: oSetResult 36
6407: oPushResult
6408: oNodeGet
6409: oPop 2
6411: oPushResult
6412: oTypeSPush
6413: oPop 1
6415: oCall 6659
6417: oCall 6613
6419: oJumpForward 6424
6421: Choice Lookup Table
          18   6401
6424: oJumpForward 6612
6426: oGetParam 1
6428: oPushResult
6429: oNodeType
6430: oPop 1
6432: oChoice 6576
6434: oEmit 16
6436: oGetParam 1
6438: oPushResult
6439: oCall 9597
6441: oPop 1
6443: oJumpForward 6584
6445: oGetLocal 2
6447: oPushResult
6448: equal_zero
6449: oPop 1
6451: oChoice 6464
6453: oEmit 17
6455: oGetParam 1
6457: oPushResult
6458: oCall 9597
6460: oPop 1
6462: oJumpForward 6482
6464: Choice Lookup Table
           1   6453
6467: oEmit 20
6469: oGetLocal 2
6471: oPushResult
6472: oEmitInt
6473: oPop 1
6475: oGetParam 1
6477: oPushResult
6478: oCall 9597
6480: oPop 1
6482: oJumpForward 6584
6484: oGetParam 1
6486: oPushResult
6487: oSetResult 33
6489: oPushResult
6490: oNodeGetBoolean
6491: oPop 2
6493: oChoice 6534
6495: oGetLocal 2
6497: oPushResult
6498: equal_zero
6499: oPop 1
6501: oChoice 6514
6503: oEmit 8
6505: oGetParam 1
6507: oPushResult
6508: oCall 9597
6510: oPop 1
6512: oJumpForward 6532
6514: Choice Lookup Table
           1   6503
6517: oEmit 14
6519: oGetLocal 2
6521: oPushResult
6522: oEmitInt
6523: oPop 1
6525: oGetParam 1
6527: oPushResult
6528: oCall 9597
6530: oPop 1
6532: oJumpForward 6574
6534: Choice Lookup Table
           1   6495
6537: oGetLocal 2
6539: oPushResult
6540: equal_zero
6541: oPop 1
6543: oChoice 6556
6545: oEmit 18
6547: oGetParam 1
6549: oPushResult
6550: oCall 9597
6552: oPop 1
6554: oJumpForward 6574
6556: Choice Lookup Table
           1   6545
6559: oEmit 21
6561: oGetLocal 2
6563: oPushResult
6564: oEmitInt
6565: oPop 1
6567: oGetParam 1
6569: oPushResult
6570: oCall 9597
6572: oPop 1
6574: oJumpForward 6584
6576: Choice Lookup Table
          23   6484
          21   6445
          20   6434
6583: oEndChoice
6584: oCall 6659
6586: oCall 6613
6588: oJumpForward 6612
6590: Choice Lookup Table
          36   6426
          34   6426
          33   6239
          26   6235
          32   6235
          31   6073
          28   6073
          29   6073
          37   5911
          27   5911
6611: oEndChoice
6612: oReturn
6613: oLocalSpace 0
6615: oTypeSNodeType
6616: oChoice 6636
6618: oEmit 22
6620: oJumpForward 6658
6622: oEmit 23
6624: oJumpForward 6658
6626: oError 16
6628: oJumpForward 6658
6630: oEmit 24
6632: oJumpForward 6658
6634: oJumpForward 6658
6636: Choice Lookup Table
          36   6634
          34   6634
          33   6630
          26   6626
          32   6626
          31   6622
          28   6622
          29   6622
          37   6618
          27   6618
6657: oEndChoice
6658: oReturn
6659: oLocalSpace 0
6661: oInputChoice 6675
6663: oCall 6687
6665: oJumpForward 6684
6667: oCall 6830
6669: oJumpForward 6684
6671: oCall 6928
6673: oJumpForward 6684
6675: Choice Lookup Table
          18   6671
          20   6667
          16   6663
6682: oJumpForward 6686
6684: oJumpBack 6661
6686: oReturn
6687: oLocalSpace 3
6689: oTypeSNodeType
6690: oChoice 6694
6692: oJumpForward 6699
6694: Choice Lookup Table
          34   6692
6697: oError 10
6699: oTypeSNodeType
6700: oChoice 6704
6702: oJumpForward 6709
6704: Choice Lookup Table
          34   6702
6707: oError 13
6709: oGetAddrLocal 1
6711: oPushResult
6712: oTypeSTop
6713: oPushResult
6714: oSetResult 37
6716: oPushResult
6717: oNodeGet
6718: oPop 2
6720: oPushResult
6721: oCall 9502
6723: oPop 1
6725: oAssign
6726: oGetAddrLocal 2
6728: oPushResult
6729: oTypeSTop
6730: oPushResult
6731: oSetResult 36
6733: oPushResult
6734: oNodeGet
6735: oPop 2
6737: oAssign
6738: oTypeSPop
6739: oGetLocal 2
6741: oPushResult
6742: oTypeSPush
6743: oPop 1
6745: oCall 4532
6747: oCall 9236
6749: oGetLocal 1
6751: oPushResult
6752: equal_zero
6753: oPop 1
6755: oChoice 6769
6757: oEmit 15
6759: oGetLocal 1
6761: oPushResult
6762: oEmitInt
6763: oPop 1
6765: oEmit 37
6767: oJumpForward 6772
6769: Choice Lookup Table
           0   6757
6772: oGetAddrLocal 3
6774: oPushResult
6775: oGetLocal 2
6777: oPushResult
6778: oSetResult 17
6780: oPushResult
6781: oNodeGetInt
6782: oPop 2
6784: oAssign
6785: oGetLocal 3
6787: oPushResult
6788: oSetResult 1
6790: oPushResult
6791: equal
6792: oPop 2
6794: oChoice 6808
6796: oEmit 15
6798: oGetLocal 3
6800: oPushResult
6801: oEmitInt
6802: oPop 1
6804: oEmit 33
6806: oJumpForward 6811
6808: Choice Lookup Table
           0   6796
6811: oEmit 35
6813: oInputChoice 6821
6815: oJumpForward 6829
6817: oJumpForward 6827
6819: oJumpForward 6827
6821: Choice Lookup Table
          13   6819
          17   6815
6826: oEndChoice
6827: oJumpBack 6699
6829: oReturn
6830: oLocalSpace 2
6832: oTypeSNodeType
6833: oChoice 6837
6835: oJumpForward 6842
6837: Choice Lookup Table
          36   6835
6840: oError 11
6842: oTypeSTop
6843: oPushResult
6844: oSetResult 40
6846: oPushResult
6847: oNodeGet
6848: oPop 2
6850: oPushResult
6851: oScopeEnter
6852: oPop 1
6854: oInput 0
6856: oGetAddrLocal 1
6858: oPushResult
6859: oScopeFindRequire
6860: oAssign
6861: oGetLocal 1
6863: oPushResult
6864: oNodeType
6865: oPop 1
6867: oChoice 6871
6869: oJumpForward 6876
6871: Choice Lookup Table
          22   6869
6874: oError 12
6876: oScopeEnd
6877: oGetAddrLocal 2
6879: oPushResult
6880: oGetLocal 1
6882: oPushResult
6883: oSetResult 22
6885: oPushResult
6886: oNodeGetInt
6887: oPop 2
6889: oAssign
6890: oGetLocal 2
6892: oPushResult
6893: equal_zero
6894: oPop 1
6896: oChoice 6910
6898: oEmit 15
6900: oGetLocal 2
6902: oPushResult
6903: oEmitInt
6904: oPop 1
6906: oEmit 35
6908: oJumpForward 6913
6910: Choice Lookup Table
           0   6898
6913: oTypeSPop
6914: oGetLocal 1
6916: oPushResult
6917: oSetResult 21
6919: oPushResult
6920: oNodeGet
6921: oPop 2
6923: oPushResult
6924: oTypeSPush
6925: oPop 1
6927: oReturn
6928: oLocalSpace 1
6930: oTypeSNodeType
6931: oChoice 6935
6933: oJumpForward 6940
6935: Choice Lookup Table
          33   6933
6938: oError 9
6940: oEmit 24
6942: oGetAddrLocal 1
6944: oPushResult
6945: oTypeSTop
6946: oAssign
6947: oTypeSPop
6948: oGetLocal 1
6950: oPushResult
6951: oSetResult 36
6953: oPushResult
6954: oNodeGet
6955: oPop 2
6957: oPushResult
6958: oTypeSPush
6959: oPop 1
6961: oReturn
6962: oLocalSpace 1
6964: oGetAddrLocal 1
6966: oPushResult
6967: oTypeSNodeType
6968: oAssign
6969: oTypeSPop
6970: oGetLocal 1
6972: oPushResult
6973: oTypeSNodeType
6974: oPushResult
6975: equal_node_type
6976: oPop 2
6978: oChoice 7020
6980: oTypeSNodeType
6981: oChoice 7011
6983: oGetLocal 1
6985: oChoice 6992
6987: oEmit 29
6989: oReturn
6990: oJumpForward 6995
6992: Choice Lookup Table
          28   6987
6995: oJumpForward 7016
6997: oGetLocal 1
6999: oChoice 7006
7001: oEmit 30
7003: oReturn
7004: oJumpForward 7009
7006: Choice Lookup Table
          27   7001
7009: oJumpForward 7016
7011: Choice Lookup Table
          28   6997
          27   6983
7016: oError 14
7018: oJumpForward 7023
7020: Choice Lookup Table
           0   6980
7023: oReturn
7024: oLocalSpace 2
7026: oGetAddrLocal 2
7028: oPushResult
7029: oGetParam 1
7031: oPushResult
7032: oSetResult 26
7034: oPushResult
7035: oNodeGetString
7036: oPop 2
7038: oAssign
7039: oGetLocal 2
7041: oPushResult
7042: oSetResult 0
7044: oPushResult
7045: equal_string
7046: oPop 2
7048: oChoice 7085
7050: oGetAddrLocal 1
7052: oPushResult
7053: oGetParam 1
7055: oPushResult
7056: oSetResult 4
7058: oPushResult
7059: oNodeGetInt
7060: oPop 2
7062: oPushResult
7063: ID_STRING
7064: oPop 1
7066: oPushResult
7067: oStringAllocLit
7068: oPop 1
7070: oAssign
7071: oJumpForward 7091
7073: oGetAddrLocal 1
7075: oPushResult
7076: oGetLocal 2
7078: oPushResult
7079: oStringAllocLit
7080: oPop 1
7082: oAssign
7083: oJumpForward 7091
7085: Choice Lookup Table
           0   7073
           1   7050
7090: oEndChoice
7091: oEmit 60
7093: oGetParam 1
7095: oPushResult
7096: oCall 9597
7098: oPop 1
7100: oGetLocal 1
7102: oPushResult
7103: oEmitInt
7104: oPop 1
7106: oReturn
7107: oLocalSpace 10
7109: oGetParam 1
7111: oPushResult
7112: oSetResult 25
7114: oPushResult
7115: oNodeGetBoolean
7116: oPop 2
7118: oChoice 7145
7120: oGetParam 1
7122: oPushResult
7123: oSetResult 28
7125: oPushResult
7126: oNodeGetBoolean
7127: oPop 2
7129: oChoice 7140
7131: oGetParam 1
7133: oPushResult
7134: oCall 7024
7136: oPop 1
7138: oJumpForward 7143
7140: Choice Lookup Table
           0   7131
7143: oJumpForward 7148
7145: Choice Lookup Table
           1   7120
7148: oGetParam 1
7150: oPushResult
7151: oSetResult 28
7153: oPushResult
7154: oSetResult 1
7156: oPushResult
7157: oNodeSetBoolean
7158: oPop 3
7160: oGetAddrLocal 1
7162: oPushResult
7163: oGetParam 1
7165: oPushResult
7166: oSetResult 27
7168: oPushResult
7169: oNodeGetBoolean
7170: oPop 2
7172: oAssign
7173: oGetAddrLocal 4
7175: oPushResult
7176: oGetParam 1
7178: oPushResult
7179: oNodeType
7180: oPop 1
7182: oPushResult
7183: oSetResult 13
7185: oPushResult
7186: equal_node_type
7187: oPop 2
7189: oAssign
7190: oGetLocal 4
7192: oChoice 7219
7194: oGetAddrLocal 2
7196: oPushResult
7197: oGetParam 1
7199: oPushResult
7200: oSetResult 21
7202: oPushResult
7203: oNodeGet
7204: oPop 2
7206: oAssign
7207: oGetAddrLocal 3
7209: oPushResult
7210: oGetLocal 2
7212: oPushResult
7213: oScopeAllocType
7214: oPop 1
7216: oAssign
7217: oJumpForward 7222
7219: Choice Lookup Table
           1   7194
7222: oGetAddrLocal 5
7224: oPushResult
7225: oGetParam 1
7227: oPushResult
7228: oSetResult 23
7230: oPushResult
7231: oNodeGet
7232: oPop 2
7234: oAssign
7235: oGetAddrLocal 6
7237: oPushResult
7238: oGetLocal 5
7240: oPushResult
7241: oSetResult 17
7243: oPushResult
7244: oNodeGetInt
7245: oPop 2
7247: oAssign
7248: oGetLocal 1
7250: oChoice 7272
7252: oEmit 49
7254: oGetLocal 6
7256: oPushResult
7257: oEmitInt
7258: oPop 1
7260: oJumpForward 7278
7262: oEmit 48
7264: oGetLocal 6
7266: oPushResult
7267: oEmitInt
7268: oPop 1
7270: oJumpForward 7278
7272: Choice Lookup Table
           0   7262
           1   7252
7277: oEndChoice
7278: oGetParam 1
7280: oPushResult
7281: oCall 9172
7283: oPop 1
7285: oPushResult
7286: oSetResult 0
7288: oPushResult
7289: greater
7290: oPop 2
7292: oChoice 7325
7294: oEmit 19
7296: oSetResult 0
7298: oPushResult
7299: oEmitInt
7300: oPop 1
7302: oEmit 20
7304: oGetParam 1
7306: oPushResult
7307: oCall 9192
7309: oPop 1
7311: oPushResult
7312: oEmitInt
7313: oPop 1
7315: oSetResult 0
7317: oPushResult
7318: oEmitInt
7319: oPop 1
7321: oEmit 27
7323: oJumpForward 7328
7325: Choice Lookup Table
           1   7294
7328: oGetAddrLocal 7
7330: oPushResult
7331: oGetLocal 5
7333: oPushResult
7334: oSetResult 15
7336: oPushResult
7337: oNodeGetIter
7338: oPop 2
7340: oAssign
7341: oGetAddrLocal 8
7343: oPushResult
7344: oGetLocal 7
7346: oPushResult
7347: oNodeIterValue
7348: oPop 1
7350: oAssign
7351: oInputChoice 7541
7353: oGetLocal 8
7355: oPushResult
7356: oNodeNull
7357: oPop 1
7359: oChoice 7365
7361: oJumpForward 7537
7363: oJumpForward 7368
7365: Choice Lookup Table
           1   7361
7368: oGetAddrLocal 9
7370: oPushResult
7371: oGetLocal 8
7373: oPushResult
7374: oSetResult 22
7376: oPushResult
7377: oNodeGetInt
7378: oPop 2
7380: oAssign
7381: oEmit 19
7383: oGetLocal 9
7385: oPushResult
7386: oEmitInt
7387: oPop 1
7389: oGetLocal 8
7391: oPushResult
7392: oSetResult 21
7394: oPushResult
7395: oNodeGet
7396: oPop 2
7398: oPushResult
7399: oTypeSPush
7400: oPop 1
7402: oGetLocal 8
7404: oPushResult
7405: oSetResult 33
7407: oPushResult
7408: oNodeGetBoolean
7409: oPop 2
7411: oChoice 7490
7413: oCall 8352
7415: oCall 9210
7417: oEmit 27
7419: oJumpForward 7496
7421: oCall 4532
7423: oCall 6962
7425: oTypeSNodeType
7426: oChoice 7466
7428: oEmit 25
7430: oJumpForward 7488
7432: oEmit 26
7434: oJumpForward 7488
7436: oError 16
7438: oJumpForward 7488
7440: oEmit 27
7442: oJumpForward 7488
7444: oGetAddrLocal 10
7446: oPushResult
7447: oTypeSTop
7448: oPushResult
7449: oSetResult 17
7451: oPushResult
7452: oNodeGetInt
7453: oPop 2
7455: oAssign
7456: oEmit 28
7458: oGetLocal 10
7460: oPushResult
7461: oEmitInt
7462: oPop 1
7464: oJumpForward 7488
7466: Choice Lookup Table
          36   7444
          34   7444
          33   7440
          26   7436
          32   7436
          31   7432
          28   7432
          29   7432
          37   7428
          27   7428
7487: oEndChoice
7488: oJumpForward 7496
7490: Choice Lookup Table
           0   7421
           1   7413
7495: oEndChoice
7496: oTypeSPop
7497: oGetAddrLocal 7
7499: oPushResult
7500: oNodeIterNext
7501: oPop 1
7503: oGetAddrLocal 8
7505: oPushResult
7506: oGetLocal 7
7508: oPushResult
7509: oNodeIterValue
7510: oPop 1
7512: oAssign
7513: oGetLocal 8
7515: oPushResult
7516: oNodeNull
7517: oPop 1
7519: oChoice 7527
7521: oJumpForward 7537
7523: oJumpForward 7533
7525: oJumpForward 7533
7527: Choice Lookup Table
           0   7525
           1   7521
7532: oEndChoice
7533: oInput 13
7535: oJumpBack 7353
7537: oInput 15
7539: oJumpForward 7544
7541: Choice Lookup Table
          14   7353
7544: oGetLocal 8
7546: oPushResult
7547: oNodeNull
7548: oPop 1
7550: oChoice 7556
7552: oError 15
7554: oJumpForward 7559
7556: Choice Lookup Table
           0   7552
7559: oGetLocal 4
7561: oChoice 7590
7563: oEmit 19
7565: oGetParam 1
7567: oPushResult
7568: oSetResult 31
7570: oPushResult
7571: oNodeGetInt
7572: oPop 2
7574: oPushResult
7575: oEmitInt
7576: oPop 1
7578: oEmit 17
7580: oGetLocal 3
7582: oPushResult
7583: oEmitInt
7584: oPop 1
7586: oEmit 27
7588: oJumpForward 7593
7590: Choice Lookup Table
           1   7563
7593: oGetLocal 1
7595: oChoice 7619
7597: oEmit 52
7599: oGetParam 1
7601: oPushResult
7602: oCall 9597
7604: oPop 1
7606: oJumpForward 7625
7608: oEmit 51
7610: oGetParam 1
7612: oPushResult
7613: oCall 9597
7615: oPop 1
7617: oJumpForward 7625
7619: Choice Lookup Table
           0   7608
           1   7597
7624: oEndChoice
7625: oGetLocal 4
7627: oChoice 7706
7629: oGetLocal 2
7631: oPushResult
7632: oTypeSPush
7633: oPop 1
7635: oTypeSNodeType
7636: oChoice 7682
7638: oEmit 3
7640: oGetLocal 3
7642: oPushResult
7643: oEmitInt
7644: oPop 1
7646: oJumpForward 7704
7648: oEmit 4
7650: oGetLocal 3
7652: oPushResult
7653: oEmitInt
7654: oPop 1
7656: oJumpForward 7704
7658: oError 16
7660: oJumpForward 7704
7662: oEmit 5
7664: oGetLocal 3
7666: oPushResult
7667: oEmitInt
7668: oPop 1
7670: oJumpForward 7704
7672: oEmit 17
7674: oGetLocal 3
7676: oPushResult
7677: oEmitInt
7678: oPop 1
7680: oJumpForward 7704
7682: Choice Lookup Table
          36   7672
          34   7672
          33   7662
          26   7658
          32   7658
          31   7648
          28   7648
          29   7648
          37   7638
          27   7638
7703: oEndChoice
7704: oJumpForward 7709
7706: Choice Lookup Table
           1   7629
7709: oEmit 50
7711: oGetLocal 6
7713: oPushResult
7714: oEmitInt
7715: oPop 1
7717: oReturn
7718: oLocalSpace 0
7720: oGetParam 1
7722: oPushResult
7723: oGetGlobal 11
7725: oPushResult
7726: oNodeEqual
7727: oPop 2
7729: oChoice 7769
7731: oInput 14
7733: oCall 4532
7735: oTypeSNodeType
7736: oChoice 7744
7738: oJumpForward 7757
7740: oEmit 29
7742: oJumpForward 7757
7744: Choice Lookup Table
          31   7740
          28   7740
          29   7740
          37   7738
          27   7738
7755: oError 14
7757: oTypeSPop
7758: oGetGlobal 5
7760: oPushResult
7761: oTypeSPush
7762: oPop 1
7764: oInput 15
7766: oReturn
7767: oJumpForward 7772
7769: Choice Lookup Table
           1   7731
7772: oGetParam 1
7774: oPushResult
7775: oGetGlobal 12
7777: oPushResult
7778: oNodeEqual
7779: oPop 2
7781: oChoice 7815
7783: oInput 14
7785: oCall 4532
7787: oTypeSNodeType
7788: oChoice 7796
7790: oEmit 30
7792: oJumpForward 7803
7794: oJumpForward 7803
7796: Choice Lookup Table
          28   7794
          27   7790
7801: oError 14
7803: oTypeSPop
7804: oGetGlobal 8
7806: oPushResult
7807: oTypeSPush
7808: oPop 1
7810: oInput 15
7812: oReturn
7813: oJumpForward 7818
7815: Choice Lookup Table
           1   7783
7818: oGetParam 1
7820: oPushResult
7821: oGetGlobal 13
7823: oPushResult
7824: oNodeEqual
7825: oPop 2
7827: oChoice 7867
7829: oInput 14
7831: oCall 4532
7833: oTypeSNodeType
7834: oChoice 7855
7836: oTypeSTop
7837: oPushResult
7838: oSetResult 42
7840: oPushResult
7841: oNodeGetBoolean
7842: oPop 2
7844: oChoice 7850
7846: oError 28
7848: oJumpForward 7853
7850: Choice Lookup Table
           1   7846
7853: oJumpForward 7860
7855: Choice Lookup Table
          37   7836
7858: oError 14
7860: oEmit 32
7862: oInput 15
7864: oReturn
7865: oJumpForward 7870
7867: Choice Lookup Table
           1   7829
7870: oGetParam 1
7872: oPushResult
7873: oGetGlobal 14
7875: oPushResult
7876: oNodeEqual
7877: oPop 2
7879: oChoice 7919
7881: oInput 14
7883: oCall 4532
7885: oTypeSNodeType
7886: oChoice 7907
7888: oTypeSTop
7889: oPushResult
7890: oSetResult 42
7892: oPushResult
7893: oNodeGetBoolean
7894: oPop 2
7896: oChoice 7902
7898: oError 28
7900: oJumpForward 7905
7902: Choice Lookup Table
           1   7898
7905: oJumpForward 7912
7907: Choice Lookup Table
          37   7888
7910: oError 14
7912: oEmit 31
7914: oInput 15
7916: oReturn
7917: oJumpForward 7922
7919: Choice Lookup Table
           1   7881
7922: oError 16
7924: oReturn
7925: oLocalSpace 0
7927: oInputChoice 7986
7929: oCall 9048
7931: oJumpForward 8015
7933: oCall 9055
7935: oJumpForward 8015
7937: oCall 9154
7939: oJumpForward 8015
7941: oCall 9157
7943: oJumpForward 8015
7945: oCall 8536
7947: oJumpForward 8015
7949: oCall 8856
7951: oJumpForward 8015
7953: oCall 8602
7955: oJumpForward 8015
7957: oCall 8776
7959: oJumpForward 8015
7961: oCall 8941
7963: oJumpForward 8015
7965: oCall 8909
7967: oJumpForward 8015
7969: oCall 9025
7971: oJumpForward 8015
7973: oCall 8016
7975: oJumpForward 8015
7977: oCall 8973
7979: oJumpForward 8015
7981: oChangeIntLitToLabelIdent
7982: oCall 8016
7984: oJumpForward 8015
7986: Choice Lookup Table
           1   7981
          53   7977
           0   7973
          35   7969
          51   7965
          52   7961
          49   7957
          44   7953
          48   7949
          41   7945
          66   7941
          65   7937
          64   7933
          63   7929
8015: oReturn
8016: oLocalSpace 1
8018: oGetAddrLocal 1
8020: oPushResult
8021: oScopeFindRequire
8022: oAssign
8023: oGetAddrLocal 1
8025: oPushResult
8026: oCall 409
8028: oPop 1
8030: oGetLocal 1
8032: oPushResult
8033: oNodeType
8034: oPop 1
8036: oChoice 8076
8038: oGetLocal 1
8040: oPushResult
8041: oCall 8092
8043: oPop 1
8045: oCall 7925
8047: oJumpForward 8091
8049: oGetLocal 1
8051: oPushResult
8052: oCall 7107
8054: oPop 1
8056: oJumpForward 8091
8058: oGetLocal 1
8060: oPushResult
8061: oCall 8142
8063: oPop 1
8065: oJumpForward 8091
8067: oGetLocal 1
8069: oPushResult
8070: oCall 8227
8072: oPop 1
8074: oJumpForward 8091
8076: Choice Lookup Table
          13   8067
          23   8058
          21   8058
          20   8058
          12   8049
          24   8038
8089: oError 0
8091: oReturn
8092: oLocalSpace 0
8094: oGetParam 1
8096: oPushResult
8097: oSetResult 34
8099: oPushResult
8100: oNodeGetBoolean
8101: oPop 2
8103: oChoice 8109
8105: oError 21
8107: oJumpForward 8112
8109: Choice Lookup Table
           1   8105
8112: oEmit 58
8114: oGetParam 1
8116: oPushResult
8117: oSetResult 22
8119: oPushResult
8120: oNodeGetLabel
8121: oPop 2
8123: oPushResult
8124: oEmitLabel
8125: oPop 1
8127: oGetParam 1
8129: oPushResult
8130: oSetResult 34
8132: oPushResult
8133: oSetResult 1
8135: oPushResult
8136: oNodeSetBoolean
8137: oPop 3
8139: oInput 12
8141: oReturn
8142: oLocalSpace 0
8144: oGetParam 1
8146: oPushResult
8147: oCall 8395
8149: oPop 1
8151: oInput 4
8153: oCall 4532
8155: oCall 6962
8157: oCall 8160
8159: oReturn
8160: oLocalSpace 1
8162: oTypeSNodeType
8163: oChoice 8203
8165: oEmit 25
8167: oJumpForward 8225
8169: oEmit 26
8171: oJumpForward 8225
8173: oError 16
8175: oJumpForward 8225
8177: oEmit 27
8179: oJumpForward 8225
8181: oGetAddrLocal 1
8183: oPushResult
8184: oTypeSTop
8185: oPushResult
8186: oSetResult 17
8188: oPushResult
8189: oNodeGetInt
8190: oPop 2
8192: oAssign
8193: oEmit 28
8195: oGetLocal 1
8197: oPushResult
8198: oEmitInt
8199: oPop 1
8201: oJumpForward 8225
8203: Choice Lookup Table
          36   8181
          34   8181
          33   8177
          26   8173
          32   8173
          31   8169
          28   8169
          29   8169
          37   8165
          27   8165
8224: oEndChoice
8225: oTypeSPop
8226: oReturn
8227: oLocalSpace 1
8229: oGetParam 1
8231: oPushResult
8232: oSetResult 6
8234: oPushResult
8235: oNodeGet
8236: oPop 2
8238: oPushResult
8239: oScopeCurrent
8240: oPushResult
8241: oNodeEqual
8242: oPop 2
8244: oChoice 8250
8246: oError 20
8248: oJumpForward 8253
8250: Choice Lookup Table
           0   8246
8253: oEmit 8
8255: oGetParam 1
8257: oPushResult
8258: oSetResult 31
8260: oPushResult
8261: oNodeGetInt
8262: oPop 2
8264: oPushResult
8265: oEmitInt
8266: oPop 1
8268: oGetParam 1
8270: oPushResult
8271: oSetResult 21
8273: oPushResult
8274: oNodeGet
8275: oPop 2
8277: oPushResult
8278: oTypeSPush
8279: oPop 1
8281: oInput 4
8283: oCall 4532
8285: oCall 6962
8287: oTypeSNodeType
8288: oChoice 8328
8290: oEmit 25
8292: oJumpForward 8350
8294: oEmit 26
8296: oJumpForward 8350
8298: oError 16
8300: oJumpForward 8350
8302: oEmit 27
8304: oJumpForward 8350
8306: oGetAddrLocal 1
8308: oPushResult
8309: oTypeSTop
8310: oPushResult
8311: oSetResult 17
8313: oPushResult
8314: oNodeGetInt
8315: oPop 2
8317: oAssign
8318: oEmit 28
8320: oGetLocal 1
8322: oPushResult
8323: oEmitInt
8324: oPop 1
8326: oJumpForward 8350
8328: Choice Lookup Table
          36   8306
          34   8306
          33   8302
          26   8298
          32   8298
          31   8294
          28   8294
          29   8294
          37   8290
          27   8290
8349: oEndChoice
8350: oTypeSPop
8351: oReturn
8352: oLocalSpace 1
8354: oInput 0
8356: oGetAddrLocal 1
8358: oPushResult
8359: oScopeFindRequire
8360: oAssign
8361: oGetAddrLocal 1
8363: oPushResult
8364: oCall 409
8366: oPop 1
8368: oGetLocal 1
8370: oPushResult
8371: oNodeType
8372: oPop 1
8374: oChoice 8378
8376: oJumpForward 8387
8378: Choice Lookup Table
          23   8376
          21   8376
          20   8376
8385: oError 4
8387: oGetLocal 1
8389: oPushResult
8390: oCall 8395
8392: oPop 1
8394: oReturn
8395: oLocalSpace 0
8397: oGetParam 1
8399: oPushResult
8400: oNodeType
8401: oPop 1
8403: oChoice 8463
8405: oEmit 16
8407: oGetParam 1
8409: oPushResult
8410: oCall 9597
8412: oPop 1
8414: oJumpForward 8472
8416: oEmit 17
8418: oGetParam 1
8420: oPushResult
8421: oCall 9597
8423: oPop 1
8425: oJumpForward 8472
8427: oGetParam 1
8429: oPushResult
8430: oSetResult 33
8432: oPushResult
8433: oNodeGetBoolean
8434: oPop 2
8436: oChoice 8449
8438: oEmit 8
8440: oGetParam 1
8442: oPushResult
8443: oCall 9597
8445: oPop 1
8447: oJumpForward 8461
8449: Choice Lookup Table
           1   8438
8452: oEmit 18
8454: oGetParam 1
8456: oPushResult
8457: oCall 9597
8459: oPop 1
8461: oJumpForward 8472
8463: Choice Lookup Table
          23   8427
          21   8416
          20   8405
8470: oError 4
8472: oGetParam 1
8474: oPushResult
8475: oSetResult 21
8477: oPushResult
8478: oNodeGet
8479: oPop 2
8481: oPushResult
8482: oTypeSPush
8483: oPop 1
8485: oCall 6659
8487: oReturn
8488: oLocalSpace 0
8490: oGetParam 1
8492: oPushResult
8493: oCall 8395
8495: oPop 1
8497: oCall 9236
8499: oGetParam 1
8501: oPushResult
8502: oCall 5876
8504: oPop 1
8506: oTypeSPop
8507: oEmit 31
8509: oEmit 25
8511: oReturn
8512: oLocalSpace 0
8514: oGetParam 1
8516: oPushResult
8517: oCall 8395
8519: oPop 1
8521: oCall 9236
8523: oGetParam 1
8525: oPushResult
8526: oCall 5876
8528: oPop 1
8530: oTypeSPop
8531: oEmit 32
8533: oEmit 25
8535: oReturn
8536: oLocalSpace 2
8538: oGetAddrLocal 1
8540: oPushResult
8541: oSetResult 0
8543: oAssign
8544: oGetAddrLocal 1
8546: oPushResult
8547: oCall 4555
8549: oPop 1
8551: oInput 42
8553: oCall 7925
8555: oInputChoice 8590
8557: oGetAddrLocal 2
8559: oPushResult
8560: oLabelNew
8561: oAssign
8562: oEmit 55
8564: oGetLocal 2
8566: oPushResult
8567: oEmitLabel
8568: oPop 1
8570: oEmit 58
8572: oGetLocal 1
8574: oPushResult
8575: oEmitLabel
8576: oPop 1
8578: oCall 7925
8580: oEmit 58
8582: oGetLocal 2
8584: oPushResult
8585: oEmitLabel
8586: oPop 1
8588: oJumpForward 8601
8590: Choice Lookup Table
          43   8557
8593: oEmit 58
8595: oGetLocal 1
8597: oPushResult
8598: oEmitLabel
8599: oPop 1
8601: oReturn
8602: oLocalSpace 4
8604: oInput 0
8606: oGetAddrLocal 1
8608: oPushResult
8609: oScopeFindRequire
8610: oAssign
8611: oGetLocal 1
8613: oPushResult
8614: oCall 8395
8616: oPop 1
8618: oCall 9236
8620: oInput 4
8622: oCall 4532
8624: oCall 9236
8626: oEmit 25
8628: oGetAddrLocal 2
8630: oPushResult
8631: oLabelNew
8632: oAssign
8633: oGetAddrLocal 3
8635: oPushResult
8636: oLabelNew
8637: oAssign
8638: oEmit 55
8640: oGetLocal 3
8642: oPushResult
8643: oEmitLabel
8644: oPop 1
8646: oGetAddrLocal 4
8648: oPushResult
8649: oLabelNew
8650: oAssign
8651: oEmit 58
8653: oGetLocal 4
8655: oPushResult
8656: oEmitLabel
8657: oPop 1
8659: oInputChoice 8739
8661: oGetLocal 1
8663: oPushResult
8664: oCall 8488
8666: oPop 1
8668: oEmit 58
8670: oGetLocal 3
8672: oPushResult
8673: oEmitLabel
8674: oPop 1
8676: oGetLocal 1
8678: oPushResult
8679: oCall 5876
8681: oPop 1
8683: oTypeSPop
8684: oCall 4532
8686: oCall 9236
8688: oEmit 42
8690: oEmit 56
8692: oGetLocal 2
8694: oPushResult
8695: oEmitLabel
8696: oPop 1
8698: oJumpForward 8745
8700: oGetLocal 1
8702: oPushResult
8703: oCall 8512
8705: oPop 1
8707: oEmit 58
8709: oGetLocal 3
8711: oPushResult
8712: oEmitLabel
8713: oPop 1
8715: oGetLocal 1
8717: oPushResult
8718: oCall 5876
8720: oPop 1
8722: oTypeSPop
8723: oCall 4532
8725: oCall 9236
8727: oEmit 43
8729: oEmit 56
8731: oGetLocal 2
8733: oPushResult
8734: oEmitLabel
8735: oPop 1
8737: oJumpForward 8745
8739: Choice Lookup Table
          46   8700
          45   8661
8744: oEndChoice
8745: oGetLocal 4
8747: oPushResult
8748: oGetLocal 2
8750: oPushResult
8751: oLoopPush
8752: oPop 2
8754: oInput 47
8756: oCall 7925
8758: oEmit 55
8760: oGetLocal 4
8762: oPushResult
8763: oEmitLabel
8764: oPop 1
8766: oEmit 58
8768: oGetLocal 2
8770: oPushResult
8771: oEmitLabel
8772: oPop 1
8774: oLoopPop
8775: oReturn
8776: oLocalSpace 3
8778: oGetAddrLocal 1
8780: oPushResult
8781: oLabelNew
8782: oAssign
8783: oEmit 58
8785: oGetLocal 1
8787: oPushResult
8788: oEmitLabel
8789: oPop 1
8791: oGetAddrLocal 2
8793: oPushResult
8794: oLabelNew
8795: oAssign
8796: oGetLocal 1
8798: oPushResult
8799: oGetLocal 2
8801: oPushResult
8802: oLoopPush
8803: oPop 2
8805: oCall 7925
8807: oInputChoice 8838
8809: oCall 7925
8811: oJumpForward 8844
8813: oGetAddrLocal 3
8815: oPushResult
8816: oCall 4555
8818: oPop 1
8820: oEmit 59
8822: oGetLocal 3
8824: oPushResult
8825: oEmitLabel
8826: oPop 1
8828: oGetLocal 1
8830: oPushResult
8831: oEmitLabel
8832: oPop 1
8834: oJumpForward 8846
8836: oJumpForward 8844
8838: Choice Lookup Table
          50   8813
           5   8809
8843: oEndChoice
8844: oJumpBack 8807
8846: oEmit 58
8848: oGetLocal 2
8850: oPushResult
8851: oEmitLabel
8852: oPop 1
8854: oLoopPop
8855: oReturn
8856: oLocalSpace 2
8858: oGetAddrLocal 1
8860: oPushResult
8861: oLabelNew
8862: oAssign
8863: oEmit 58
8865: oGetLocal 1
8867: oPushResult
8868: oEmitLabel
8869: oPop 1
8871: oGetAddrLocal 2
8873: oPushResult
8874: oCall 4555
8876: oPop 1
8878: oGetLocal 1
8880: oPushResult
8881: oGetLocal 2
8883: oPushResult
8884: oLoopPush
8885: oPop 2
8887: oInput 47
8889: oCall 7925
8891: oEmit 55
8893: oGetLocal 1
8895: oPushResult
8896: oEmitLabel
8897: oPop 1
8899: oEmit 58
8901: oGetLocal 2
8903: oPushResult
8904: oEmitLabel
8905: oPop 1
8907: oLoopPop
8908: oReturn
8909: oLocalSpace 0
8911: oLoopContinueLabel
8912: oPushResult
8913: oSetResult 0
8915: oPushResult
8916: equal_label
8917: oPop 2
8919: oChoice 8934
8921: oError 18
8923: oJumpForward 8940
8925: oEmit 55
8927: oLoopContinueLabel
8928: oPushResult
8929: oEmitLabel
8930: oPop 1
8932: oJumpForward 8940
8934: Choice Lookup Table
           0   8925
           1   8921
8939: oEndChoice
8940: oReturn
8941: oLocalSpace 0
8943: oLoopBreakLabel
8944: oPushResult
8945: oSetResult 0
8947: oPushResult
8948: equal_label
8949: oPop 2
8951: oChoice 8966
8953: oError 18
8955: oJumpForward 8972
8957: oEmit 55
8959: oLoopBreakLabel
8960: oPushResult
8961: oEmitLabel
8962: oPop 1
8964: oJumpForward 8972
8966: Choice Lookup Table
           0   8957
           1   8953
8971: oEndChoice
8972: oReturn
8973: oLocalSpace 1
8975: oInputChoice 8982
8977: oJumpForward 8988
8979: oChangeIntLitToLabelIdent
8980: oJumpForward 8988
8982: Choice Lookup Table
           1   8979
           0   8977
8987: oEndChoice
8988: oGetAddrLocal 1
8990: oPushResult
8991: oScopeCurrent
8992: oPushResult
8993: oScopeFindRequireInScope
8994: oPop 1
8996: oAssign
8997: oGetLocal 1
8999: oPushResult
9000: oSetResult 28
9002: oPushResult
9003: oSetResult 1
9005: oPushResult
9006: oNodeSetBoolean
9007: oPop 3
9009: oEmit 55
9011: oGetLocal 1
9013: oPushResult
9014: oSetResult 22
9016: oPushResult
9017: oNodeGetLabel
9018: oPop 2
9020: oPushResult
9021: oEmitLabel
9022: oPop 1
9024: oReturn
9025: oLocalSpace 0
9027: oCall 7925
9029: oInputChoice 9039
9031: oCall 7925
9033: oJumpForward 9045
9035: oJumpForward 9047
9037: oJumpForward 9045
9039: Choice Lookup Table
          36   9035
           5   9031
9044: oEndChoice
9045: oJumpBack 9029
9047: oReturn
9048: oLocalSpace 0
9050: oCall 9055
9052: oEmit 67
9054: oReturn
9055: oLocalSpace 0
9057: oInputChoice 9150
9059: oCall 4532
9061: oTypeSNodeType
9062: oChoice 9112
9064: oEmit 61
9066: oJumpForward 9131
9068: oEmit 62
9070: oJumpForward 9131
9072: oEmit 29
9074: oEmit 61
9076: oJumpForward 9131
9078: oEmit 63
9080: oJumpForward 9131
9082: oEmit 64
9084: oJumpForward 9131
9086: oError 16
9088: oJumpForward 9131
9090: oEmit 16
9092: oTypeSTop
9093: oPushResult
9094: oSetResult 41
9096: oPushResult
9097: oNodeGetInt
9098: oPop 2
9100: oPushResult
9101: oEmitInt
9102: oPop 1
9104: oEmit 66
9106: oJumpForward 9131
9108: oEmit 65
9110: oJumpForward 9131
9112: Choice Lookup Table
          33   9108
          37   9090
          26   9086
          32   9082
          31   9078
          28   9072
          29   9068
          27   9064
9129: oError 17
9131: oTypeSPop
9132: oInputChoice 9140
9134: oJumpForward 9148
9136: oJumpForward 9146
9138: oJumpForward 9146
9140: Choice Lookup Table
          13   9138
          15   9134
9145: oEndChoice
9146: oJumpBack 9059
9148: oJumpForward 9153
9150: Choice Lookup Table
          14   9059
9153: oReturn
9154: oLocalSpace 0
9156: oReturn
9157: oLocalSpace 0
9159: oReturn
9160: oLocalSpace 0
9162: oScopeCurrent
9163: oPushResult
9164: oSetResult 14
9166: oPushResult
9167: oNodeGetInt
9168: oPop 2
9170: oReturn
9171: oReturn
9172: oLocalSpace 0
9174: oGetParam 1
9176: oPushResult
9177: oSetResult 20
9179: oPushResult
9180: oNodeGet
9181: oPop 2
9183: oPushResult
9184: oSetResult 14
9186: oPushResult
9187: oNodeGetInt
9188: oPop 2
9190: oReturn
9191: oReturn
9192: oLocalSpace 0
9194: oCall 9160
9196: oPushResult
9197: oGetParam 1
9199: oPushResult
9200: oCall 9172
9202: oPop 1
9204: oPushResult
9205: subtract
9206: oPop 2
9208: oReturn
9209: oReturn
9210: oLocalSpace 1
9212: oGetAddrLocal 1
9214: oPushResult
9215: oTypeSNodeType
9216: oAssign
9217: oTypeSPop
9218: oGetLocal 1
9220: oPushResult
9221: oTypeSNodeType
9222: oPushResult
9223: equal_node_type
9224: oPop 2
9226: oChoice 9232
9228: oError 14
9230: oJumpForward 9235
9232: Choice Lookup Table
           0   9228
9235: oReturn
9236: oLocalSpace 0
9238: oTypeSNodeType
9239: oChoice 9243
9241: oJumpForward 9248
9243: Choice Lookup Table
          27   9241
9246: oError 7
9248: oTypeSPop
9249: oReturn
9250: oLocalSpace 0
9252: oTypeSNodeType
9253: oChoice 9257
9255: oJumpForward 9262
9257: Choice Lookup Table
          27   9255
9260: oError 7
9262: oReturn
9263: oLocalSpace 0
9265: oTypeSNodeType
9266: oChoice 9274
9268: oJumpForward 9281
9270: oEmit 29
9272: oJumpForward 9281
9274: Choice Lookup Table
          28   9270
          27   9268
9279: oError 7
9281: oTypeSPop
9282: oReturn
9283: oLocalSpace 0
9285: oTypeSNodeType
9286: oChoice 9301
9288: oJumpForward 9308
9290: oEmit 29
9292: oTypeSPop
9293: oGetGlobal 5
9295: oPushResult
9296: oTypeSPush
9297: oPop 1
9299: oJumpForward 9308
9301: Choice Lookup Table
          28   9290
          27   9288
9306: oError 7
9308: oReturn
9309: oLocalSpace 0
9311: oTypeSNodeType
9312: oChoice 9325
9314: oEmit 29
9316: oTypeSPop
9317: oGetGlobal 5
9319: oPushResult
9320: oTypeSPush
9321: oPop 1
9323: oJumpForward 9328
9325: Choice Lookup Table
          28   9314
9328: oReturn
9329: oLocalSpace 0
9331: oTypeSNodeType
9332: oChoice 9336
9334: oJumpForward 9341
9336: Choice Lookup Table
          29   9334
9339: oError 8
9341: oTypeSPop
9342: oReturn
9343: oLocalSpace 0
9345: oTypeSNodeType
9346: oChoice 9350
9348: oJumpForward 9355
9350: Choice Lookup Table
          29   9348
9353: oError 8
9355: oReturn
9356: oLocalSpace 1
9358: oGetAddrLocal 1
9360: oPushResult
9361: oGetParam 2
9363: oPushResult
9364: oNodeNew
9365: oPop 1
9367: oAssign
9368: oGetLocal 1
9370: oPushResult
9371: oSetResult 17
9373: oPushResult
9374: oGetParam 1
9376: oPushResult
9377: oNodeSetInt
9378: oPop 3
9380: oGetLocal 1
9382: oPushResult
9383: oTypeAdd
9384: oPop 1
9386: oGetLocal 1
9388: oReturn
9389: oReturn
9390: oLocalSpace 1
9392: oGetAddrLocal 1
9394: oPushResult
9395: oGetParam 2
9397: oPushResult
9398: oNodeNew
9399: oPop 1
9401: oAssign
9402: oGetLocal 1
9404: oPushResult
9405: oSetResult 4
9407: oPushResult
9408: oGetParam 1
9410: oPushResult
9411: oNodeSetInt
9412: oPop 3
9414: oGetLocal 1
9416: oReturn
9417: oReturn
9418: oLocalSpace 1
9420: oGetAddrLocal 1
9422: oPushResult
9423: oGetParam 1
9425: oPushResult
9426: oSetResult 35
9428: oPushResult
9429: oNodeGet
9430: oPop 2
9432: oAssign
9433: oGetLocal 1
9435: oPushResult
9436: oNodeNull
9437: oPop 1
9439: oChoice 9495
9441: oGetAddrLocal 1
9443: oPushResult
9444: oSetResult 33
9446: oPushResult
9447: oNodeNew
9448: oPop 1
9450: oAssign
9451: oGetLocal 1
9453: oPushResult
9454: oSetResult 36
9456: oPushResult
9457: oGetParam 1
9459: oPushResult
9460: oNodeSet
9461: oPop 3
9463: oGetLocal 1
9465: oPushResult
9466: oSetResult 17
9468: oPushResult
9469: oSetResult 8
9471: oPushResult
9472: oNodeSetInt
9473: oPop 3
9475: oGetLocal 1
9477: oPushResult
9478: oTypeAdd
9479: oPop 1
9481: oGetParam 1
9483: oPushResult
9484: oSetResult 35
9486: oPushResult
9487: oGetLocal 1
9489: oPushResult
9490: oNodeSet
9491: oPop 3
9493: oJumpForward 9498
9495: Choice Lookup Table
           1   9441
9498: oGetLocal 1
9500: oReturn
9501: oReturn
9502: oLocalSpace 2
9504: oGetParam 1
9506: oPushResult
9507: oNodeType
9508: oPop 1
9510: oChoice 9580
9512: oMININT
9513: oReturn
9514: oJumpForward 9596
9516: oSetResult 0
9518: oReturn
9519: oJumpForward 9596
9521: oSetResult 0
9523: oReturn
9524: oJumpForward 9596
9526: oGetAddrLocal 1
9528: oPushResult
9529: oGetParam 1
9531: oPushResult
9532: oSetResult 40
9534: oPushResult
9535: oNodeGet
9536: oPop 2
9538: oAssign
9539: oGetAddrLocal 2
9541: oPushResult
9542: oGetLocal 1
9544: oPushResult
9545: oSetResult 15
9547: oPushResult
9548: oNodeGetIter
9549: oPop 2
9551: oPushResult
9552: oNodeIterValue
9553: oPop 1
9555: oAssign
9556: oGetLocal 2
9558: oPushResult
9559: oSetResult 22
9561: oPushResult
9562: oNodeGetInt
9563: oPop 2
9565: oReturn
9566: oJumpForward 9596
9568: oGetParam 1
9570: oPushResult
9571: oSetResult 38
9573: oPushResult
9574: oNodeGetInt
9575: oPop 2
9577: oReturn
9578: oJumpForward 9596
9580: Choice Lookup Table
          35   9568
          37   9526
          31   9521
          29   9516
          27   9512
9591: oError 3
9593: oSetResult 0
9595: oReturn
9596: oReturn
9597: oLocalSpace 0
9599: oGetParam 1
9601: oPushResult
9602: oSetResult 22
9604: oPushResult
9605: oNodeGetInt
9606: oPop 2
9608: oPushResult
9609: oEmitInt
9610: oPop 1
9612: oReturn
9613: oLocalSpace 1
9615: oGetAddrLocal 1
9617: oPushResult
9618: oSetResult 14
9620: oPushResult
9621: oGetParam 1
9623: oPushResult
9624: oCall 9390
9626: oPop 2
9628: oAssign
9629: oGetLocal 1
9631: oPushResult
9632: oScopeDeclare
9633: oPop 1
9635: oGetLocal 1
9637: oReturn
9638: oReturn
9639: oLocalSpace 1
9641: oGetAddrGlobal 4
9643: oPushResult
9644: oSetResult 26
9646: oPushResult
9647: oSetResult 4
9649: oPushResult
9650: oCall 9356
9652: oPop 2
9654: oAssign
9655: oGetAddrGlobal 5
9657: oPushResult
9658: oSetResult 27
9660: oPushResult
9661: oSetResult 4
9663: oPushResult
9664: oCall 9356
9666: oPop 2
9668: oAssign
9669: oGetAddrGlobal 6
9671: oPushResult
9672: oSetResult 29
9674: oPushResult
9675: oSetResult 1
9677: oPushResult
9678: oCall 9356
9680: oPop 2
9682: oAssign
9683: oGetAddrGlobal 7
9685: oPushResult
9686: oSetResult 30
9688: oPushResult
9689: oSetResult 1
9691: oPushResult
9692: oCall 9356
9694: oPop 2
9696: oAssign
9697: oGetAddrGlobal 8
9699: oPushResult
9700: oSetResult 31
9702: oPushResult
9703: oSetResult 1
9705: oPushResult
9706: oCall 9356
9708: oPop 2
9710: oAssign
9711: oGetAddrGlobal 9
9713: oPushResult
9714: oSetResult 28
9716: oPushResult
9717: oSetResult 1
9719: oPushResult
9720: oCall 9356
9722: oPop 2
9724: oAssign
9725: oGetAddrGlobal 10
9727: oPushResult
9728: oSetResult 32
9730: oPushResult
9731: oSetResult 256
9733: oPushResult
9734: oCall 9356
9736: oPop 2
9738: oAssign
9739: oGetAddrLocal 1
9741: oPushResult
9742: oSetResult 18
9744: oPushResult
9745: oIdAdd_File
9746: oPushResult
9747: oCall 9390
9749: oPop 2
9751: oAssign
9752: oGetLocal 1
9754: oPushResult
9755: oSetResult 21
9757: oPushResult
9758: oGetGlobal 4
9760: oPushResult
9761: oNodeSet
9762: oPop 3
9764: oGetLocal 1
9766: oPushResult
9767: oScopeDeclare
9768: oPop 1
9770: oGetAddrLocal 1
9772: oPushResult
9773: oSetResult 18
9775: oPushResult
9776: oIdAdd_Integer
9777: oPushResult
9778: oCall 9390
9780: oPop 2
9782: oAssign
9783: oGetLocal 1
9785: oPushResult
9786: oSetResult 21
9788: oPushResult
9789: oGetGlobal 5
9791: oPushResult
9792: oNodeSet
9793: oPop 3
9795: oGetLocal 1
9797: oPushResult
9798: oScopeDeclare
9799: oPop 1
9801: oGetAddrLocal 1
9803: oPushResult
9804: oSetResult 18
9806: oPushResult
9807: oIdAdd_Boolean
9808: oPushResult
9809: oCall 9390
9811: oPop 2
9813: oAssign
9814: oGetLocal 1
9816: oPushResult
9817: oSetResult 21
9819: oPushResult
9820: oGetGlobal 6
9822: oPushResult
9823: oNodeSet
9824: oPop 3
9826: oGetLocal 1
9828: oPushResult
9829: oScopeDeclare
9830: oPop 1
9832: oGetAddrLocal 1
9834: oPushResult
9835: oSetResult 18
9837: oPushResult
9838: oIdAdd_Char
9839: oPushResult
9840: oCall 9390
9842: oPop 2
9844: oAssign
9845: oGetLocal 1
9847: oPushResult
9848: oSetResult 21
9850: oPushResult
9851: oGetGlobal 8
9853: oPushResult
9854: oNodeSet
9855: oPop 3
9857: oGetLocal 1
9859: oPushResult
9860: oScopeDeclare
9861: oPop 1
9863: oGetAddrLocal 1
9865: oPushResult
9866: oSetResult 18
9868: oPushResult
9869: oIdAdd_Byte
9870: oPushResult
9871: oCall 9390
9873: oPop 2
9875: oAssign
9876: oGetLocal 1
9878: oPushResult
9879: oSetResult 21
9881: oPushResult
9882: oGetGlobal 9
9884: oPushResult
9885: oNodeSet
9886: oPop 3
9888: oGetLocal 1
9890: oPushResult
9891: oScopeDeclare
9892: oPop 1
9894: oGetAddrLocal 1
9896: oPushResult
9897: oSetResult 18
9899: oPushResult
9900: oIdAdd_String
9901: oPushResult
9902: oCall 9390
9904: oPop 2
9906: oAssign
9907: oGetLocal 1
9909: oPushResult
9910: oSetResult 21
9912: oPushResult
9913: oGetGlobal 10
9915: oPushResult
9916: oNodeSet
9917: oPop 3
9919: oGetLocal 1
9921: oPushResult
9922: oScopeDeclare
9923: oPop 1
9925: oGetAddrLocal 1
9927: oPushResult
9928: oSetResult 16
9930: oPushResult
9931: oIdAdd_True
9932: oPushResult
9933: oCall 9390
9935: oPop 2
9937: oAssign
9938: oGetLocal 1
9940: oPushResult
9941: oSetResult 21
9943: oPushResult
9944: oGetGlobal 6
9946: oPushResult
9947: oNodeSet
9948: oPop 3
9950: oGetLocal 1
9952: oPushResult
9953: oSetResult 22
9955: oPushResult
9956: oSetResult 1
9958: oPushResult
9959: oNodeSetInt
9960: oPop 3
9962: oGetLocal 1
9964: oPushResult
9965: oScopeDeclare
9966: oPop 1
9968: oGetAddrLocal 1
9970: oPushResult
9971: oSetResult 16
9973: oPushResult
9974: oIdAdd_False
9975: oPushResult
9976: oCall 9390
9978: oPop 2
9980: oAssign
9981: oGetLocal 1
9983: oPushResult
9984: oSetResult 21
9986: oPushResult
9987: oGetGlobal 6
9989: oPushResult
9990: oNodeSet
9991: oPop 3
9993: oGetLocal 1
9995: oPushResult
9996: oSetResult 22
9998: oPushResult
9999: oSetResult 0
10001: oPushResult
10002: oNodeSetInt
10003: oPop 3
10005: oGetLocal 1
10007: oPushResult
10008: oScopeDeclare
10009: oPop 1
10011: oGetAddrGlobal 11
10013: oPushResult
10014: oIdAdd_Ord
10015: oPushResult
10016: oCall 9613
10018: oPop 1
10020: oAssign
10021: oGetAddrGlobal 12
10023: oPushResult
10024: oIdAdd_Chr
10025: oPushResult
10026: oCall 9613
10028: oPop 1
10030: oAssign
10031: oGetAddrGlobal 13
10033: oPushResult
10034: oIdAdd_Pred
10035: oPushResult
10036: oCall 9613
10038: oPop 1
10040: oAssign
10041: oGetAddrGlobal 14
10043: oPushResult
10044: oIdAdd_Succ
10045: oPushResult
10046: oCall 9613
10048: oPop 1
10050: oAssign
10051: oReturn
