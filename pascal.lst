   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_mysystem >> int
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_Pointer >> int
   2:     oIdAdd_ShortString >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oIdAdd_Pred >> int
   2:     oIdAdd_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 370: Uses( int id, Node user ):
 372:    Node unit = @FindOrCompileUnit( id )
 383:    [ equal_node( unit, Null )
 393:       | false :
 394:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 406:          Node unitRef = oNodeNew( nUnitRef )
 416:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 435:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 454:          oScopeDeclare( unitRef )
 460:       | * :
 465:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 466: ResolveUnitRef( inout Node decl ):
 468:    [ oNodeType( decl )
 475:       | nUnitRef :
 476:          Node scope = oNodeGet( decl, qPublicScope )
 489:          '.'
 491:          pIdent
 493:          decl = oScopeFindRequireInScope( scope )
 503:       | * :
 508:    ];
      
      
 509: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 511:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 524:    {
 524:       Node unit = oNodeIterValue( unitIt )
 534:       [ oNodeNull( unit )
 541:          | false :
 542:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 555:          | * :
 560:             >
 562:       ]
 562:       oNodeIterNext( unitIt )
 568:    }
 571:    ;
      
 571: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 573:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 586:    {
 586:       Node unit = oNodeIterValue( unitIt )
 596:       [ oNodeNull( unit )
 603:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 604:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 620:                | true :
 621:                | false :  #eInternalScopeMismatch
 625:             ]
 633:             oScopeEnd
 634:          | * :
 639:             >
 641:       ]
 641:       oNodeIterPrev( unitIt )
 647:    }
 650:    ;
      
      
 650: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 652:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 671:    [ equal_node( unit, Null )
 681:       | false :  >> unit
 685:       | * :
 690:    ]
      
         % If not, search for the source file on disk
 690:    boolean ok = oIncludeUnitFile( id )
 700:    [ ok
 703:       | false :  #eCantFindUnitFile  >> Null
 709:       | * :
 714:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 714:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 720:    oIncludeEnd
 721:    >> unit;
      
      
      
 725: Unit >> Node:
 727:    pUnit
 729:    pIdent
 731:    Node unit = oNodeNew( nUnit )
 741:    oNodeSetInt( unit, qIdent, LAST_ID )
 752:    Node unitImpl = oNodeNew( nUnitImpl )
 762:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 773:    oNodeSet( unit, qImpl, unitImpl )
 785:    ';'
      
         % mandatory sections
      
 787:    pInterface
 789:    @UsesMySystem( unit )
 796:    [
 796:       | pUses :   @UsesClause( unit )
 805:       | * :
 810:    ]
 810:    @EnterUsedUnits( unit )
      
 817:    oScopeBegin( 0, allocGlobal )
 826:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 837:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 842:    oScopeBegin( 0, allocDown )
 851:    initScope = oScopeCurrent
 856:    oNodeSet( unit, qInitRoutineScope, initScope )
 868:    oScopeEnd
      
 869:    @UnitInterface( unit )
 876:    oScopeEnd  % interface scope
      
 877:    pImplementation
 879:    @UsesMySystem( unitImpl )
 886:    [
 886:       | pUses :   @UsesClause( unitImpl )
 895:       | * :
 900:    ]
 900:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 907:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 920:    oScopeBegin( 0, allocGlobal )
 929:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 940:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 958:    globalScope = oScopeCurrent
 963:    @UnitImplementation( unit )
      
 970:    [
 970:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 982:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 997:    ]
 997:    [
 997:       | pFinalization :  @UnitFinalization( unit, true )
1009:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1024:    ]
1024:    pEnd  '.'
      
1028:    oScopeEnd  % impl scope
1029:    oScopeEnd  % interface scope
1030:    @EndUsedUnits( unitImpl )  % used units scopes
1037:    @EndUsedUnits( unit )
1044:    oNodeAddLast( workspace, qUnits, unit )
1056:    >> unit;
      
      
1060: UnitInterface( Node unit ):
1062:    {[
1062:       | pConst :     @ConstDecl
1066:       | pType :      @TypeDecl
1070:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1079:       | pProcedure :
1081:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1087:          [
1087:             | pExternal :
1089:                @ExternalDecl( decl )
1096:                ';'
1098:             | * :
1103:          ]
      
1103:       | pFunction :
1105:          Node decl = @FuncHeaderDecl
1111:          [
1111:             | pExternal :
1113:                @ExternalDecl( decl )
1120:                ';'
1122:             | * :
1127:          ]
      
1127:       | * :          >
1142:    ]}
1145:    ;
      
1145: UnitImplementation( Node unit ):
1147:    @BlockDecls( nGlobalVar )
1155:    ;
      
      
1155: UnitInitialization( Node unit, boolean hasStmts ):
1157:    Label label = oLabelNew
1162:    .tLabel  oEmitLabel( label )
1170:    oNodeSetLabel( unit, qInitLabel, label )
      
1182:    int patchLS
1182:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1191:    Node scope
1191:    Code initCode
      
1191:    scope = oNodeGet( unit, qPublicScope )
1204:    initCode = oNodeGetCode( scope, qInitCode )
1217:    oEmitCode( initCode )
1223:    oNodeSetCode( scope, qInitCode, codeNull )
      
1235:    scope = oNodeGet( unit, qPrivateScope )
1248:    initCode = oNodeGetCode( scope, qInitCode )
1261:    oEmitCode( initCode )
1267:    oNodeSetCode( scope, qInitCode, codeNull )
      
1279:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1292:    [ hasStmts
1295:       | true :     
1296:          @Statement
1298:          {[
1298:             | ';' :  @Statement
1302:             | * :    >
1309:          ]}
1311:       | * :
1316:    ]
      
1316:    .tReturn
      
1318:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1330:    oPatch( patchLS, localSpace )
1339:    oScopeEnd   % init routine scope, for temporaries
1341:    ;
      
      
1341: UnitFinalization( Node unit, boolean hasStmts ):
1343:    Label label = oLabelNew
1348:    .tLabel  oEmitLabel( label )
1356:    oNodeSetLabel( unit, qFinalLabel, label )
      
1368:    int patchLS
1368:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1377:    oScopeBegin( 0, allocDown )
      
1386:    [ hasStmts
1389:       | true :     
1390:          @Statement
1392:          {[
1392:             | ';' :  @Statement
1396:             | * :    >
1403:          ]}
1405:       | * :
1410:    ]
      
1410:    .tReturn
      
1412:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1424:    oPatch( patchLS, localSpace )
1433:    oScopeEnd   % final routine scope, for temporaries
1435:    ;
      
      
1435: Block( node_type varNodeType, Label labelForBody ):
1437:    @BlockDecls( varNodeType )
1444:    @BlockStmt( labelForBody, oScopeCurrent, false )
1456:    @CheckForUndefinedLabels
1459:    ;
      
      
1459: BlockDecls( node_type varNodeType ):
1461:    {[
1461:       | pConst :     @ConstDecl
1465:       | pType :      @TypeDecl
1469:       | pVar :       @VarDecl( varNodeType )
1478:       | pLabel :     @LabelDecl
1482:       | pProcedure : @ProcDecl
1486:       | pFunction :  @FuncDecl
1490:       | * :          >
1507:    ]}
1509:    @CheckForUndefinedMethods
1512:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1512: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1515:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1515: CheckForUndefinedLabels:
1517:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1529:    {
1529:       Node decl = oNodeIterValue( it )
1539:       [ oNodeNull( decl )
1546:          | false :
1547:          | * :  >
1554:       ]
1554:       [ oNodeType( decl )
1561:          | nLabel :
1562:             [ oNodeGetBoolean( decl, qDefined )
1572:                | false :
1573:                   [ oNodeGetBoolean( decl, qUsed )
1583:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1586:                      | * :
1591:                   ]
1591:                | * :
1596:             ]
1596:          | * :
1601:       ]
1601:       oNodeIterNext( it )
1607:    }
1610:    ;
      
      
1610: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1612:    NodeIter it = oNodeGetIter( workspace, qUnits )
1625:    {
1625:       Node unit = oNodeIterValue( it )
1635:       [ oNodeNull( unit )
1642:          | true :  >
1645:          | false :
1647:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1655:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1670:             .tFreeActuals  oEmitInt( 0 )
1678:             oNodeIterNext( it )
1684:       ]
1692:    };
      
      
1695: FinalizeUnits:
1697:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1710:    {
1710:       Node unit = oNodeIterValue( it )
1720:       [ oNodeNull( unit )
1727:          | true :  >
1730:          | false :
1732:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1740:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1755:             .tFreeActuals  oEmitInt( 0 )
1763:             oNodeIterPrev( it )
1769:       ]
1777:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1780: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1782:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1790:    int patchLS
1790:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1799:    [ isMain
1802:       | true :  @InitializeUnits
1805:       | * :
1810:    ]
      
         % insert any code for initialization of this scope's variables
1810:    Code initCode = oNodeGetCode( varScope, qInitCode )
1823:    oEmitCode( initCode )
1829:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1841:    @Statement
      
1843:    [ isMain
1846:       | true :  @FinalizeUnits
1849:       | * :
1854:    ]
      
1854:    .tReturn
      
1856:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1868:    oPatch( patchLS, localSpace )
1878:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1878: MethodModifiers( Node decl ):
1880:    {[
1880:       | pCdecl :
1882:          oNodeSetBoolean( decl, qCdecl, true )
1894:          ';'
      
1896:       | * : >
1903:    ]}
1906:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1906: GetOrCreateInitCode( Node scope ) >> Code:
1908:    Code initCode = oNodeGetCode( scope, qInitCode )
1921:    [ equal_code( initCode, codeNull )
1931:       | true :
1932:          initCode = oCodeNew
1937:          oNodeSetCode( scope, qInitCode, initCode )
1949:       | * :
1954:    ]
1954:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1958: ExternalDecl( Node decl ):
1960:    [ equal_zero( @DeclLevel( decl ) )
1972:       | false :  #eExternalMethodCannotBeNested
1975:       | * :
1980:    ]
1980:    oNodeSetBoolean( decl, qExternal, true )
1992:    [
1992:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1994:          [
1994:             | pName :
1996:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1998:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2009:             | * :
2014:          ]
2014:       | * :
2019:    ]
2020:    ;
      
      
2020: ProcHeaderDecl >> Node:
2022:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2024:    boolean redeclaring = false
2030:    Node decl = oScopeFindInCurrentScope
      
2035:    [ oNodeNull( decl )
2042:       | true :
               % first declaration
2043:          decl = @newIdent( nProc, LAST_ID )
2056:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2067:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2069:          redeclaring = true
2075:          [ oNodeGetBoolean( decl, qBodyDefined )
2085:             | true : #eAlreadyDefined
2088:             | * :
2093:          ]
2093:          [ oNodeGetBoolean( decl, qExternal )
2103:             | true : #eAlreadyDefined
2106:             | * :
2111:          ]
2111:          [ oNodeType( decl )
2118:             | nProc :
2119:             | * : #eAlreadyDefined   % wrong kind
2126:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2126:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2145:          oNodeSet( decl, qParams, Null )
2157:    ]
      
2165:    int level = @ScopeLevel
2171:    boolean nested = greater( level, 0 )
2184:    inc( level )
2190:    oScopeBegin( level, allocUp )
2199:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2204:    [ nested
2207:       | true :
2208:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2223:       | * :
2228:    ]
      
2228:    @FormalArgDecl
2230:    oNodeSet( decl, qParams, paramScope )
2242:    oScopeEnd
2243:    ';'
      
2245:    [ redeclaring
2248:       | false : oScopeDeclare( decl )
2255:       | true :  % TO DO: check that qParams is consistent with qOldParams
2257:    ]
      
2265:    @MethodModifiers( decl )
2272:    >> decl;
      
      
2276: ProcDecl:
2278:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2284:    [
2284:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2286:       | pExternal : @ExternalDecl( decl )
      
2295:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2302:          Node paramScope = oNodeGet( decl, qParams )
2315:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2321:          int level = oNodeGetInt( paramScope, qLevel )
2334:          oScopeBegin( level, allocDown )
2343:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2354:          Label label = oNodeGetLabel( decl, qValue )
2367:          @Block( nLocalVar, label )
2377:          oNodeSetBoolean( decl, qBodyDefined, true )
2389:          oScopeEnd
      
2390:          oScopeEnd  % paramScope
2391:    ]
2391:    ';';
      
      
      
2394: FuncHeaderDecl >> Node:
2396:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2398:    boolean redeclaring = false
2404:    Node decl = oScopeFindInCurrentScope
      
2409:    [ oNodeNull( decl )
2416:       | true :
               % first declaration
2417:          decl = @newIdent( nFunc, LAST_ID )
2430:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2441:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2443:          redeclaring = true
2449:          [ oNodeGetBoolean( decl, qBodyDefined )
2459:             | true : #eAlreadyDefined
2462:             | * :
2467:          ]
2467:          [ oNodeType( decl )
2474:             | nFunc :
2475:             | * : #eAlreadyDefined   % wrong kind
2482:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2482:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2501:          oNodeSet( decl, qParams, Null )
2513:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2532:          oNodeSet( decl, qType, Null )
2544:    ]
      
2552:    int level = @ScopeLevel
2558:    boolean nested = greater( level, 0 )
2571:    inc( level )
2577:    oScopeBegin( level, allocUp )
2586:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2591:    [ nested
2594:       | true :
2595:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2610:       | * :
2615:    ]
      
2615:    @FormalArgDecl
2617:    oNodeSet( decl, qParams, paramScope )
      
2629:    ':'
      
2631:    Node theType
2631:    @TypeRef( theType )
2638:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2650:    Node ptrType = @PointerTypeTo( theType )
2661:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2677:    oScopeEnd
2678:    ';'
      
2680:    [ redeclaring
2683:       | false : oScopeDeclare( decl )
2690:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2692:    ]
      
2700:    @MethodModifiers( decl )
      
2707:    >> decl;
      
      
2711: FuncDecl:
2713:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2719:    [
2719:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2721:       | pExternal : @ExternalDecl( decl )
      
2730:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2737:          Node paramScope = oNodeGet( decl, qParams )
2750:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2756:          int level = oNodeGetInt( paramScope, qLevel )
2769:          oScopeBegin( level, allocDown )
2778:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2789:          Label label = oNodeGetLabel( decl, qValue )
2802:          @Block( nLocalVar, label )
2812:          oNodeSetBoolean( decl, qBodyDefined, true )
2824:          oScopeEnd
      
2825:          oScopeEnd  % paramScope
2826:    ]
2826:    ';';
      
      
2829: FormalArgDecl:
2831:    [
2831:       | '(' :
2833:          {
2833:             NodeVec decls = oNodeVecNew
2838:             Node decl
2838:             boolean isInOut = false
      
2844:             [
2844:                | pVar : isInOut = true
2852:                | * :
2857:             ]
      
2857:             {  pIdent
      
2859:                decl = @newIdent( nParam, LAST_ID )
2872:                oNodeSetBoolean( decl, qInOut, isInOut )
2884:                oNodeVecAppend( decls, decl )
      
2893:                [
2893:                   | ':' : >
2897:                   | ',' :
2899:                ]
2907:             }
      
2909:             Node theType
2909:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2916:             Node allocType
2916:             [ isInOut
2919:                | true :   allocType = @PointerTypeTo( theType )
2931:                | * :      allocType = theType
2942:             ]
      
2942:             int i = 0
2948:             {[ equal( i, oNodeVecSize( decls ) )
2962:                | false :
2963:                   decl = oNodeVecElement( decls, i )
      
2976:                   oNodeSet( decl, qType, theType )
2988:                   oScopeDeclare( decl )
2994:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3010:                   inc( i )
3016:                | * :
3021:                   >
3023:             ]}
      
3025:             oNodeVecDelete( decls )
      
3031:             [
3031:                | ')' : >
3035:                | ';' :
3037:             ]
3045:          }
3047:       | * :
3052:    ];
      
      
3053: ConstDecl:
3055:    {[
3055:       | pIdent :
3057:          [
3057:             | ':' :
3059:                @TypedConstDecl
3061:             | * :
3066:                @UntypedConstDecl
3068:          ]
3068:       | * :
3073:          >
3075:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3078: UntypedConstDecl:
3080:    Node decl = @newIdent( nConst, LAST_ID )
3093:    '='
      
3095:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3097:    int val = oValueTop
3102:    oValuePop
3103:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3115:    oNodeSet( decl, qType, IntegerType )
      
3127:    oScopeDeclare( decl )
3133:    ';'
3136:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3136: TypedConstDecl:
3138:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3151:    Node theType
3151:    @TypeRef( theType )
3158:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3170:    [ oNodeType( theType )
3177:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3178:          '='
      
3180:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3182:          int val = oValueTop
3187:          oValuePop
3188:          oNodeSetInt( decl, qValue, val )
3200:          oScopeDeclare( decl )
3206:          ';'
      
3208:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3210:          #eNotImplemented
      
3212:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3214:          oScopeEnter( globalScope )
3220:          int addr = oScopeAllocType( theType )
3230:          oScopeEnd
3231:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3242:          oNodeSetInt( decl, qValue, addr )
3254:          '='
3256:          @TypedConstInit( theType, addr )
3266:          oCodePop
3267:          oScopeDeclare( decl )
3273:          ';'
3275:    ]
3302:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3302: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3304:    [ oNodeType( theType )
3311:       | nArrayType :
3312:          Node baseType = oNodeGet( theType, qBaseType )
3325:          Node indexType = oNodeGet( theType, qIndexType )
3338:          int low = @OrdinalLow( indexType )
3349:          int high = @OrdinalHigh( indexType )
3360:          int elementSize = oNodeGetInt( baseType, qSize )
      
3373:          '('
               % Loop over elements
3375:          int i = low
3381:          {
3381:             @TypedConstInit( baseType, addr )
3391:             [ equal( i, high )
3401:                | true : >
3404:                | false :
3406:             ]
3414:             ','
3416:             addr = add( addr, elementSize )
3429:             inc( i )
3435:          }
3437:          ')'
      
3439:       | nRecordType :
3441:          '('
3443:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3456:          {
3456:             [
3456:                | pIdent :
3458:                | * :  >
3465:             ]
3465:             Node field = oScopeFindRequireInScope( fieldScope )
3475:             ':'
3477:             Node fieldType = oNodeGet( field, qType )
3490:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3510:             @TypedConstInit( fieldType, fieldAddr )
3520:             [
3520:                | ';' :
3522:                | * :  >
3529:             ]
3529:          }
3531:          ')'
      
3533:       | nBooleanType, nByteType, nCharType:
3535:          .tPushAddrGlobal  oEmitInt( addr )
3543:          @ConstExpr
3545:          .tPushConstI  oEmitInt( oValueTop )
3552:          oValuePop
3553:          .tAssignB
      
3555:       | nIntegerType, nEnumType:
3557:          .tPushAddrGlobal  oEmitInt( addr )
3565:          @ConstExpr
3567:          .tPushConstI  oEmitInt( oValueTop )
3574:          oValuePop
3575:          .tAssignI
      
3577:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3579:          #eNotImplemented
3581:    ]
3608:    ;
      
      
3608: TypeDecl:
3610:    {[
3610:       | pIdent :
3612:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3625:          '='
3627:          Node theType
3627:          @TypeRef( theType )
3634:          oNodeSet( decl, qType, theType )
3646:          oScopeDeclare( decl )
3652:          ';'
3654:       | * :
3659:          >
3661:    ]};
      
3664: VarDecl( node_type varNodeType ):
3666:    {[
3666:       | pIdent :
3668:          NodeVec decls = oNodeVecNew
3673:          Node decl
3673:          {
3673:             decl = @newIdent( varNodeType, LAST_ID )
3686:             oNodeVecAppend( decls, decl )
3695:             [
3695:                | ',' :
3697:                   pIdent
3699:                | * :
3704:                   >
3706:             ]
3706:          }
3708:          ':'
3710:          Node theType
3710:          @TypeRef( theType )
      
3717:          int i = 0
3723:          {[ equal( i, oNodeVecSize( decls ) )
3737:             | false :
3738:                decl = oNodeVecElement( decls, i )
3751:                oNodeSet( decl, qType, theType )
3763:                oScopeDeclareAlloc( decl )
3769:                inc( i )
3775:             | * :
3780:               >
3782:          ]}
      
               % optional initialization
3784:          [
3784:             | '=' :
3786:                [ oNodeVecSize( decls )
3793:                   | 1 :
3794:                   | * :  #eOnlyOneVarCanBeInitialized
3801:                ]
      
                     % we need an initCode stream for this scope
3801:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3811:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3817:                boolean changedScope = false
3823:                [ equal_zero( @ScopeLevel )
3830:                   | true : oScopeEnter( initScope )
3837:                            changedScope = true
3843:                   | * :
3848:                ]
                     % generate assignment in initCode stream
3848:                @LValueVar( decl, true )
3858:                @Expr
3860:                @CoerceType
3862:                @Assign
3864:                [ changedScope
3867:                   | true : oScopeEnd
3869:                   | * :
3874:                ]
3874:                oCodePop
                   
3875:             | * :
3880:          ]
      
3880:          oNodeVecDelete( decls )
3886:          ';'
3888:       | * :
3893:          >
3895:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3898: LabelDecl:
3900:    {
3900:       Node decl
3900:       [
3900:          | pIdent :
3902:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3904:             oChangeIntLitToLabelIdent
3905:       ]
3913:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3926:       Label label = oLabelNew
3931:       oNodeSetLabel( decl, qValue, label )
3943:       oScopeDeclare( decl )
3949:       [
3949:          | ',' :
3951:          | * :
3956:             >
3958:       ]
3958:    }
3960:    ';'
3963:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3963: TypeRef( out Node resultType ):
3965:    [
3965:       | pIdent :           % previously named type (including intrinsics)
3967:          Node decl = oScopeFindRequire
3972:          @ResolveUnitRef( decl )
3979:          [ oNodeType( decl )
3986:             | nTypeDecl :
3987:                resultType = oNodeGet( decl, qType )
4000:             | * :
4005:                #eNotType
4007:                resultType = IntegerType
4013:          ]
         
4013:       | pArray :
4015:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4017:          NodeVec dimensions = oNodeVecNew
      
4022:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4022:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4032:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4044:             @ConstExpr
4046:             oNodeSetInt( subrange, qLow, oValueTop )
4057:             oValuePop
4058:             '..'
4060:             @ConstExpr
4062:             oNodeSetInt( subrange, qHigh, oValueTop )
4073:             oValuePop
4074:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4086:             oTypeAdd( subrange )
      
4092:             Node a = oNodeNew( nArrayType )
4102:             oNodeSet( a, qIndexType, subrange )
      
4114:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4123:             [
4123:                | ']' : >
4127:                | ',' :
4129:             ]
4137:          }
      
4139:          pOf
4141:          Node baseType
4141:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4148:          int dim = oNodeVecSize( dimensions )
      
4158:          {
4158:              dec(dim)
      
4164:              Node a = oNodeVecElement( dimensions, dim )
      
4177:              oNodeSet( a, qBaseType, baseType )
4189:              Node subrange = oNodeGet( a, qIndexType )
4202:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4229:              inc( width )
4235:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4261:              oTypeAdd( a )
4267:              baseType = a
      
4273:              [ equal_zero(dim)
4280:                  | true:  >
4283:                  | *:
4288:              ]
4288:          }
      
4290:          resultType = oNodeVecElement( dimensions, 0 )
4303:          oNodeVecDelete( dimensions )
      
4309:       | '^' :
4311:          Node theType
4311:          @TypeRef( theType )
4318:          resultType = @PointerTypeTo( theType )
      
4329:       | pRecord :
4331:          resultType = oNodeNew( nRecordType )
4341:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4350:          @VarDecl( nRecordField )
      
4357:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4369:          [ equal_zero( size )
4376:             | true : #eRecordEmpty
4379:             | * :
4384:          ]
      
4384:          pEnd
      
4386:          oNodeSet( resultType, qScope, oScopeCurrent )
4397:          oNodeSetInt( resultType, qSize, size )
4409:          oScopeEnd
4410:          oTypeAdd( resultType )
      
      
4416:       | '(' :
               % An enum type declaration.
4418:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4425:       | pSet :
4427:          pOf
4429:          Node theType
4429:          @TypeRef( theType )
4436:       | * :       % this works for cases except where expr starts with an id
4451:          @ConstExpr '..' @ConstExpr
4457:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4458: EnumTypeRef( out Node resultType ):
      
4460:    resultType = oNodeNew( nEnumType )
4470:    int value = 0
4476:    int numValues = 0
4482:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4488:    Node outerScope = oScopeCurrent
4493:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4502:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4502:       pIdent
4504:       Node decl = @newIdent( nEnumValue, LAST_ID )
4517:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4530:       oNodeSet( decl, qType, resultType )
4542:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4554:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4567:       oNodeSetInt( decl, qNameOffset, nameOffset )
4579:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4591:       [
4591:          | '=', ':=' :
4593:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4595:             [ equal_zero( numValues )
4602:                | false :
4603:                   [ greater( oValueTop, value )
4612:                      | false :   #eEnumValueNotAscending
4615:                      | * :
4620:                   ]
4620:                | * :
4625:             ]
4625:             [ equal( value, oValueTop )
4634:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4635:                   oNodeSetBoolean( resultType, qHasGap, true )
4647:                | * :
4652:             ]
4652:             value = oValueTop
4657:             oValuePop
4658:          | * :
4665:       ]
4665:       oNodeSetInt( decl, qValue, value )
4677:       oNodeSetInt( decl2, qValue, value )
4689:       oScopeDeclare( decl )
      
4695:       oScopeEnter( outerScope )
4701:       oScopeDeclare( decl2 )
4707:       oScopeEnd
      
4708:       inc( value )
4714:       inc( numValues )
4720:       [
4720:          | ',' :
4722:          | * :    >
4729:       ]
4729:    }
4731:    ')'
      
4733:    oNodeSet( resultType, qScope, oScopeCurrent )
4744:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4756:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4757:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4768:    oScopeEnter( globalScope )
4774:    int size = multiply( add( numValues, 1 ), 16 )
4794:    int addr = oScopeAlloc( size, 8 )
4807:    oScopeEnd
4808:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4820:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4840:    {
4840:       Node enumValue = oNodeIterValue( it )
4850:       [ oNodeNull( enumValue )
4857:          | true :  >
4860:          | * :
4865:       ]
4865:       .tPushAddrGlobal  oEmitInt( addr )
4873:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4888:       .tAssignI
4890:       addr = add( addr, 8 )
4903:       .tPushAddrGlobal  oEmitInt( addr )
4911:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4926:       .tAssignP
4928:       addr = add( addr, 8 )
4941:       oNodeIterNext( it )
4947:    }
         % final table entry
4949:    .tPushAddrGlobal  oEmitInt( addr )
4957:    .tPushConstI  oEmitInt( 0 )
4965:    .tAssignI
4967:    addr = add( addr, 8 )
4980:    .tPushAddrGlobal  oEmitInt( addr )
4988:    .tPushConstI  oEmitInt( 0 )
4996:    .tAssignP
4998:    addr = add( addr, 8 )
5011:    oCodePop
      
5012:    oTypeAdd( resultType )
5019:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
5019: ConstExpr:
5021:    [
5021:       | pIntLit :
5023:          oValuePush( TOKEN_VALUE )
5028:       | pIdent :
5030:          Node decl = oScopeFindRequire
5035:          @ResolveUnitRef( decl )
5042:          [ oNodeType( decl )
5049:             | nConst :
5050:                oValuePush( oNodeGetInt( decl, qValue ) )
5063:             | * :
5068:                #eNotConst
5070:                oValuePush( 0 )
5076:          ]
5076:       | pMinus :
5078:          @ConstExpr
5080:          oValueNegate
5081:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5092: Expr:
5094:    Label falseLabel = labelNull
      
5100:    @ExprAllowCF( falseLabel )
5107:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5115: BooleanExprControlFlow( out Label falseLabel ):
5117:    @ExprAllowCF( falseLabel )
5124:    [ oTypeSNodeType
5126:       | nBooleanCFType :
5127:       | nBooleanType :
               % convert value to control flow
5129:          falseLabel = oLabelNew
5134:          .tJumpFalse  oEmitLabel( falseLabel )
5142:       | * :
5149:          #eNotBoolean
5151:    ]
5151:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5153: CFToVal( inout Label falseLabel ):
5155:    [ oTypeSNodeType
5157:       | nBooleanCFType :
5158:          Label doneLabel = oLabelNew
5163:          .tPushConstI  oEmitInt( 1 )
5171:          .tJump  oEmitLabel( doneLabel )
5179:          .tLabel  oEmitLabel( falseLabel )
5187:          .tPushConstI  oEmitInt( 0 )
5195:          .tLabel  oEmitLabel( doneLabel )
5203:          oTypeSPop
5204:          oTypeSPush( BooleanType )
5210:          falseLabel = labelNull
5216:       | * :
5221:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5222: ValToCF( out Label falseLabel ):
5224:    [ oTypeSNodeType
5226:       | nBooleanType :
5227:          falseLabel = oLabelNew
5232:          .tJumpFalse  oEmitLabel( falseLabel )
5240:          oTypeSPop
5241:          oTypeSPush( BooleanCFType )
5247:       | * :
5252:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5253: ExprAllowCF( out Label falseLabel ):
5255:    @BoolExprAllowCF( falseLabel )
5262:    {[
5262:       | '=' :
5264:          @CFToVal( falseLabel )
5271:          @PromoteToIntOptional
5273:          @BoolExprAllowCF( falseLabel )
5280:          @CFToVal( falseLabel )
5287:          @PromoteToIntOptional
5289:          @MatchTypes
5291:          [ oTypeSNodeType
5293:             | nBooleanType, nCharType :     .tEqualB
5296:             | nIntegerType, nEnumType :     .tEqualI
5300:             | nPointerType, nUniversalPointerType :    .tEqualP
5304:             | nShortStringType :            #eNotImplemented
5308:             | * :                           #eNotAllowed
5327:          ]
5327:          oTypeSPop
5328:          oTypeSPush( BooleanType )
      
5334:       | '<>' :
5336:          @CFToVal( falseLabel )
5343:          @PromoteToIntOptional
5345:          @BoolExprAllowCF( falseLabel )
5352:          @CFToVal( falseLabel )
5359:          @PromoteToIntOptional
5361:          @MatchTypes
5363:          [ oTypeSNodeType
5365:             | nBooleanType, nCharType :     .tNotEqualB
5368:             | nIntegerType, nEnumType :     .tNotEqualI
5372:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5376:             | nShortStringType :            #eNotImplemented
5380:             | * :                           #eNotAllowed
5399:          ]
5399:          oTypeSPop
5400:          oTypeSPush( BooleanType )
      
5406:       | '<' :
5408:          @CFToVal( falseLabel )
5415:          @PromoteToIntOptional
5417:          @BoolExprAllowCF( falseLabel )
5424:          @CFToVal( falseLabel )
5431:          @PromoteToIntOptional
5433:          @MatchTypes
5435:          [ oTypeSNodeType
5437:             | nBooleanType, nCharType :     .tLessB
5440:             | nIntegerType, nEnumType :     .tLessI
5444:             | nPointerType, nUniversalPointerType :   .tLessP
5448:             | nShortStringType :            #eNotImplemented
5452:             | * :                           #eNotAllowed
5471:          ]
5471:          oTypeSPop
5472:          oTypeSPush( BooleanType )
      
5478:       | '>' :
5480:          @CFToVal( falseLabel )
5487:          @PromoteToIntOptional
5489:          @BoolExprAllowCF( falseLabel )
5496:          @CFToVal( falseLabel )
5503:          @PromoteToIntOptional
5505:          @MatchTypes
5507:          [ oTypeSNodeType
5509:             | nBooleanType, nCharType :     .tGreaterB
5512:             | nIntegerType, nEnumType :     .tGreaterI
5516:             | nPointerType, nUniversalPointerType :   .tGreaterP
5520:             | nShortStringType :            #eNotImplemented
5524:             | * :                           #eNotAllowed
5543:          ]
5543:          oTypeSPop
5544:          oTypeSPush( BooleanType )
      
5550:       | '<=' :
5552:          @CFToVal( falseLabel )
5559:          @PromoteToIntOptional
5561:          @BoolExprAllowCF( falseLabel )
5568:          @CFToVal( falseLabel )
5575:          @PromoteToIntOptional
5577:          @MatchTypes
5579:          [ oTypeSNodeType
5581:             | nBooleanType, nCharType :     .tLessEqualB
5584:             | nIntegerType, nEnumType :     .tLessEqualI
5588:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5592:             | nShortStringType :            #eNotImplemented
5596:             | * :                           #eNotAllowed
5615:          ]
5615:          oTypeSPop
5616:          oTypeSPush( BooleanType )
      
5622:       | '>=' :
5624:          @CFToVal( falseLabel )
5631:          @PromoteToIntOptional
5633:          @BoolExprAllowCF( falseLabel )
5640:          @CFToVal( falseLabel )
5647:          @PromoteToIntOptional
5649:          @MatchTypes
5651:          [ oTypeSNodeType
5653:             | nBooleanType, nCharType :     .tGreaterEqualB
5656:             | nIntegerType, nEnumType :     .tGreaterEqualI
5660:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5664:             | nShortStringType :            #eNotImplemented
5668:             | * :                           #eNotAllowed
5687:          ]
5687:          oTypeSPop
5688:          oTypeSPush( BooleanType )
      
5694:       | * :
5709:          >
5711:    ]};
      
      
5714: BoolExprAllowCF( out Label falseLabel ):
5716:    Label trueLabel = labelNull
      
5722:    @BoolTermAllowCF( falseLabel )
5729:    {[
5729:       | pOr :
5731:          [ oTypeSNodeType
5733:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5734:                [ equal_label( trueLabel, labelNull )
5744:                   | true :  trueLabel = oLabelNew
5750:                   | * :
5755:                ]
5755:                .tJump  oEmitLabel( trueLabel )
5763:             | nBooleanType :
5765:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5772:                [ equal_label( trueLabel, labelNull )
5782:                   | true :  trueLabel = oLabelNew
5788:                   | * :
5793:                ]
5793:                .tJump  oEmitLabel( trueLabel )
5801:             | * : #eNotBoolean
5810:          ]
5810:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5811:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5819:          falseLabel = labelNull
5825:          @BoolTermAllowCF( falseLabel )
      
5832:          [ oTypeSNodeType
5834:             | nBooleanCFType :
5835:             | nBooleanType :
5837:                @ValToCF( falseLabel )
5844:             | * : #eNotBoolean
5853:          ]
      
5853:          oTypeSPop
5854:          oTypeSPush( BooleanCFType )
      
5860:       | * :
5865:          >
5867:    ]}
      
         % any short-circuit trues jump here to the end
5869:    [ equal_label( trueLabel, labelNull )
5879:       | false :
5880:          .tLabel  oEmitLabel( trueLabel )
5888:       | * :
5893:    ]
5894:    ;
      
      
5894: BoolTermAllowCF( out Label falseLabel ):
5896:    Label overallFalseLabel = labelNull
      
5902:    @BoolFactorAllowCF( falseLabel )
5909:    {[
5909:       | pAnd :
5911:          [ oTypeSNodeType
5913:             | nBooleanCFType :
5914:             | nBooleanType :
5916:                @ValToCF( falseLabel )
5923:             | * :
5930:                #eNotBoolean
5932:          ]
5932:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5933:          [ equal_label( overallFalseLabel, labelNull )
5943:             | true :
5944:                overallFalseLabel = oLabelNew
5949:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5963:                falseLabel = overallFalseLabel
5969:             | * :
5974:          ]
      
5974:          Label factorFalseLabel = labelNull
5980:          @BoolFactorAllowCF( factorFalseLabel )
      
5987:          [ oTypeSNodeType
5989:             | nBooleanCFType :
5990:             | nBooleanType :
5992:                @ValToCF( factorFalseLabel )
5999:             | * : #eNotBoolean
6008:          ]
6008:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6022:       | * :
6027:          >
6029:    ]};
      
6032: BoolFactorAllowCF( out Label falseLabel ):
6034:    [
6034:       | pNot :
6036:          Label factorFalseLabel = labelNull
      
6042:          @BoolFactorAllowCF( factorFalseLabel )
6049:          [ oTypeSNodeType
6051:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
6052:                falseLabel = oLabelNew
6057:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6065:                .tLabel  oEmitLabel( factorFalseLabel )
      
6073:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6075:                .tNot
      
6077:             | * : #eNotBoolean
6086:          ]
      
6086:       | * :
6091:          @ArithExprAllowCF( falseLabel )
6098:    ];
      
6099: ArithExprAllowCF( out Label falseLabel ):
6101:    @TermAllowCF( falseLabel )
6108:    {[
6108:       | '+' :
6110:          [ oTypeSNodeType
6112:             | nIntegerType, nByteType :
6113:                @PromoteToIntPop
6115:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6122:                @PromoteToInt
6124:                .tAddI
6126:             | nShortStringType, nCharType :
                     % String concatenation
6128:                #eNotImplemented
6130:             | nPointerType, nUniversalPointerType :
6132:                Node elementType = oNodeGet( oTypeSTop, qBaseType )
6144:                int elementSize = oNodeGetInt( elementType, qSize )
6157:                @TermAllowCF( falseLabel )  % actually not allowing CF
6164:                @PromoteToIntPop
6166:                [ equal( elementSize, 1 )
6176:                   | false :
6177:                      .tPushConstI  oEmitInt( elementSize )
6185:                      .tMultI
6187:                   | * :
6192:                ]
6192:                .tAddPI
6194:             | * :
6209:                #eNotAllowed
6211:          ]
      
6211:       | '-' :
               % TO DO: pointer arithmetic, as above
      
6213:          @PromoteToIntPop
6215:          @TermAllowCF( falseLabel )
6222:          @PromoteToInt
6224:          .tSubI
6226:       | * :
6233:          >
6235:    ]};
      
6238: TermAllowCF( out Label falseLabel ):
6240:    @FactorAllowCF( falseLabel )
6247:    {[
6247:       | pTimes :
6249:          @PromoteToIntPop
6251:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6258:          @PromoteToInt
6260:          .tMultI
6262:       | pDivide :
6264:          @PromoteToIntPop
6266:          @FactorAllowCF( falseLabel )
6273:          @PromoteToInt
6275:          .tDivI
6277:       | * :
6284:          >
6286:    ]};
      
6289: FactorAllowCF( out Label falseLabel ):
6291:    [
6291:       | pPlus :
6293:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6300:          @PromoteToInt
6302:       | pMinus :
6304:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6311:          @PromoteToInt
6313:          .tNegI
6315:       | * :
6322:          @PrimaryAllowCF( falseLabel )
6329:    ];
      
6330: PrimaryAllowCF( out Label falseLabel ):
6332:    [
6332:       | pIntLit :
6334:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6341:          oTypeSPush( IntegerType )
      
6347:       | pCharLit :
6349:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6356:          oTypeSPush( CharType )
      
6362:       | '(' :
6364:          @ExprAllowCF( falseLabel )
6371:          ')'
      
6373:       | pStrLit :
6375:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6384:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6392:          oTypeSPush( ShortStringType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6398:          @LValueIndexes
               % get final value of dereferencing, if any
6400:          @FetchVar
      
6402:       | pIdent :
6404:          Node decl = oScopeFindRequire
6409:          @ResolveUnitRef( decl )
6416:          Node theType
      
6416:          [ oNodeType( decl )
6423:             | nFunc :
6424:                @Call( decl )
      
6431:             | nBuiltInFunc :
6433:                @CallBuiltInFunc( decl )
      
6440:             | nConst, nEnumValue :
6442:                theType = oNodeGet( decl, qType )
6455:                oTypeSPush( theType )
6461:                [ oTypeSNodeType
6463:                   | nIntegerType, nEnumType, nBooleanType :
6464:                      .tPushConstI @EmitValue( decl )
6473:                   | * :
6482:                      #eNotImplemented
6484:                ]
      
6484:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6486:                @VarExpr( decl )
      
6493:             | * :
6512:                #eNotValue
6514:                oTypeSPush( IntegerType )
6520:          ]
      
6520:       | '@' :        % @var -- pointer to var
6522:          pIdent
      
6524:          Node decl = oScopeFindRequire
6529:          @ResolveUnitRef( decl )
6536:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6536:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6546:          theType = oTypeSTop
6551:          oTypeSPop
6552:          Node ptrType = @PointerTypeTo( theType )
6563:          oTypeSPush( ptrType )
      
6569:       | * :
6584:          #eNotValue
6586:          oTypeSPush( IntegerType )
6592:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6593: VarExpr( Node decl ):
6595:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6608:    int uplevels = @DeclUpLevels( decl )
      
6619:    oTypeSPush( theType )
6625:    [ oTypeSNodeType
6627:       | nIntegerType, nEnumType :
6628:          [ oNodeType( decl )
6635:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6645:             | nLocalVar :
6647:                [ equal_zero( uplevels )
6654:                   | true :  .tPushLocalI  @EmitValue( decl )
6664:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6684:                ]
6684:             | nParam :
6686:                [ oNodeGetBoolean( decl, qInOut )
6696:                   | true :    % VAR param points to the var.  Auto dereference.
6697:                      [ equal_zero( uplevels )
6704:                         | true :  .tPushParamP  @EmitValue( decl )
6714:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6734:                      ]
6734:                      .tFetchI
6736:                   | * :
6741:                      [ equal_zero( uplevels )
6748:                         | true :  .tPushParamI  @EmitValue( decl )
6758:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6778:                      ]
6778:                ]
6778:          ]
      
6790:       | nBooleanType, nByteType, nCharType :
6792:          [ oNodeType( decl )
6799:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
6809:             | nLocalVar :
6811:                [ equal_zero( uplevels )
6818:                   | true :  .tPushLocalB  @EmitValue( decl )
6828:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6848:                ]
6848:             | nParam :
6850:                [ oNodeGetBoolean( decl, qInOut )
6860:                   | true :    % VAR param points to the var.  Auto dereference.
6861:                      [ equal_zero( uplevels )
6868:                         | true :  .tPushParamP  @EmitValue( decl )
6878:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6898:                      ]
6898:                      .tFetchB
6900:                   | * :
6905:                      [ equal_zero( uplevels )
6912:                         | true :  .tPushParamB  @EmitValue( decl )
6922:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6942:                      ]
6942:                ]
6942:          ]
      
6954:       | nFileType :
6956:          #eNotImplemented
      
6958:       | nPointerType, nUniversalPointerType :
6960:          [ oNodeType( decl )
6967:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
6977:             | nLocalVar :
6979:                [ equal_zero( uplevels )
6986:                   | true :  .tPushLocalP  @EmitValue( decl )
6996:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7016:                ]
7016:             | nParam :
7018:                [ oNodeGetBoolean( decl, qInOut )
7028:                   | true :    % VAR param points to the var.  Auto dereference.
7029:                      [ equal_zero( uplevels )
7036:                         | true :  .tPushParamP  @EmitValue( decl )
7046:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7066:                      ]
7066:                      .tFetchP
7068:                   | * :
7073:                      [ equal_zero( uplevels )
7080:                         | true :  .tPushParamP  @EmitValue( decl )
7090:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7110:                      ]
7110:                ]               
7110:          ]
7122:          [
7122:             | '^' :             % dereferenced
7124:                oTypeSPop
7125:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7138:                @LValueIndexes
7140:                @FetchVar
7142:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7144:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7146:                @LValueIndexes
7148:                @FetchVar
7150:             | * :               % just ptr value alone
7157:          ]
      
7157:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7159:          [ oNodeType( decl )
7166:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7176:             | nLocalVar :
7178:                [ equal_zero( uplevels )
7185:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7195:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7215:                ]
7215:             | nParam :
7217:                [ oNodeGetBoolean( decl, qInOut )
7227:                   | true :    % VAR param points to the var.  Auto dereference.
7228:                      [ equal_zero( uplevels )
7235:                         | true :  .tPushParamP  @EmitValue( decl )
7245:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7265:                      ]
7265:                   | * :
7270:                      [ equal_zero( uplevels )
7277:                         | true :  .tPushAddrParam  @EmitValue( decl )
7287:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7307:                      ]
7307:                ]
7307:          ]
               % modify addr for subscripts, field references, etc
7319:          @LValueIndexes
               % get final value
7321:          @FetchVar
7323:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7350: FetchVar:
7352:    [ oTypeSNodeType
7354:       | nIntegerType, nEnumType :  .tFetchI
7357:       | nBooleanType, nByteType, nCharType :  .tFetchB
7361:       | nFileType :   #eNotImplemented
7365:       | nPointerType :             .tFetchP
7369:       | nUniversalPointerType :    #eCantDereference
7373:       | nArrayType, nRecordType, nShortStringType :  % compound type; leave as addr
7375:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7402: LValueIndexes:
7404:    {[
7404:       | '[' :
7406:          [ oTypeSNodeType
7408:             | nArrayType :    @ArraySubscripts
7411:             | nPointerType :  @PointerArraySubscript
7415:             | nShortStringType :  @ShortStringArraySubscript
7419:             | * :             #eNotArray
7430:          ]
7430:       | '.' :       @RecordFieldRef
7434:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7438:       | * :         >
7449:    ]};
      
7452: ArraySubscripts:
7454:    [ oTypeSNodeType
7456:       | nArrayType :
7457:       | * :       #eNotArray
7464:    ]
7464:    {
7464:       [ oTypeSNodeType
7466:          | nArrayType :
7467:          | * :    #eTooManySubscripts
7474:       ]
      
            % low subscript of this dimension
7474:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7491:       Node baseType
7491:       baseType = oNodeGet( oTypeSTop, qBaseType )
7503:       oTypeSPop
7504:       oTypeSPush( baseType )
      
7510:       @Expr
7512:       @RequireIntPop
            % adjust for low subscript
7514:       [ equal_zero( low )
7521:          | false :
7522:             .tPushConstI oEmitInt( low ) .tSubI
7532:          | * :
7537:       ]
      
            % multiply by element size
7537:       int size = oNodeGetInt( baseType, qSize )
7550:       [ equal( size, 1 )
7560:          | false :
7561:             .tPushConstI oEmitInt( size ) .tMultI
7571:          | * :
7576:       ]
      
            % update start address
7576:       .tAddPI
7578:       [
7578:          | ']' :  >
7582:          | ',' :
7584:       ]
7592:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7595: PointerArraySubscript:
7597:    [ oTypeSNodeType
7599:       | nPointerType :
7600:       | * :    #eCantDereference
7607:    ]
         % replace type stack with base type
7607:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7619:    oTypeSPop
7620:    oTypeSPush( baseType )
         
7626:    @Expr
7628:    @RequireIntPop
         % multiply by element size
7630:    int size = oNodeGetInt( baseType, qSize )
7643:    [ equal( size, 1 )
7653:       | false :
7654:          .tPushConstI  oEmitInt( size )  .tMultI
7664:       | * :
7669:    ]
         % update start address
7669:    .tAddPI
7671:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7674: ShortStringArraySubscript:
7676:    [ oTypeSNodeType
7678:       | nShortStringType :
7679:       | * :    #eCantDereference
7686:    ]
7686:    oTypeSPop
7687:    oTypeSPush( CharType )
7693:    @Expr
7695:    @RequireIntPop
7697:    .tAddPI
7699:    ']';
      
      
7702: RecordFieldRef:
7704:    [ oTypeSNodeType
7706:       | nRecordType :
7707:       | * :    #eNotRecord
7714:    ]
7714:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7726:    pIdent
7728:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7733:    [ oNodeType( field )
7740:       | nRecordField :
7741:       | * :   #eNotRecordField
7748:    ]
7748:    oScopeEnd
7749:    int offset = oNodeGetInt( field, qValue )
7762:    [ equal_zero( offset )
7769:       | false :
7770:          .tPushConstI oEmitInt( offset ) .tAddPI
7780:       | * :
7785:    ]
      
         % replace the type on the type stack, with the field type
7785:    oTypeSPop
7786:    oTypeSPush( oNodeGet( field, qType ) )
7800:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
7800: PointerDeref:
7802:    [ oTypeSNodeType
7804:       | nPointerType :
7805:       | nUniversalPointerType :   #eCantDereference
7809:       | * :       #eNotPointer
7818:    ]
7818:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
7820:    Node theType = oTypeSTop
7825:    oTypeSPop
7826:    oTypeSPush( oNodeGet( theType, qBaseType ) )
7840:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
7840: CoerceType:
7842:    node_type nt = oTypeSNodeType
7847:    oTypeSPop
7848:    [ equal_node_type( nt, oTypeSNodeType )
7857:       | false :
               % Can we implicitly convert the value to the desired type?
7858:          [ oTypeSNodeType
7860:             | nIntegerType :
7861:                [ nt
7864:                   | nByteType :   .tCastBtoI  >>
7868:                   | * :
7873:                ]
7873:             | nByteType :
7875:                [ nt
7878:                   | nIntegerType :   .tCastItoB  >>
7882:                   | * :
7887:                ]
7887:             | nPointerType :
7889:                [ nt
7892:                   | nUniversalPointerType :  >>
7894:                   | * :
7899:                ]
7899:             | nUniversalPointerType :
7901:                [ nt
7904:                   | nPointerType :  >>
7906:                ]
7912:             | * :
7923:          ]
7923:          #eTypeMismatch
7925:       | * :
7930:    ];
      
      
      % Called on first use of an extern method
      %
7931: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
7933:    int strAddr
7933:    String externalName = oNodeGetString( method, qExternalName )
7946:    [ equal_string( externalName, stringNull )
7956:       | true :
7957:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7978:       | false :
7980:          strAddr = oStringAllocLit( externalName )
7990:    ]
7998:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
8014:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8014: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
8016:    [ oNodeGetBoolean( method, qExternal )
8026:       | true :
8027:          [ oNodeGetBoolean( method, qUsed )
8037:             | false :
                     % define the extern label on first use
8038:                @DefineExternLabel( method )
8045:             | * :
8050:          ]
8050:      | * :
8055:    ]
8055:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
8067:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
8080:    Node resultType
8080:    int tempOffset
      
8080:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
8097:    [ isFunc
8100:       | true :
8101:          resultType = oNodeGet( method, qType )
8114:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
8124:       | * :
8129:    ]
         
      
8129:    Node paramScope = oNodeGet( method, qParams )
8142:    int actualsSize = oNodeGetInt( paramScope, qSize )
8155:    [ cdecl
8158:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
8167:       | false :  .tAllocActuals  oEmitInt( actualsSize )
8177:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
8185:    [ greater( @DeclLevel( method ), 0 )
8200:       | true :
8201:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
8209:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
8228:          .tAssignP
8230:       | * :
8235:    ]
      
      
8235:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
8248:    Node param = oNodeIterValue( paramIter )
8258:    [
8258:       | '(' :
            
8260:          {
8260:             [ oNodeNull( param )
8267:                | true : >
8270:                | * :
8275:             ]
      
8275:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
8288:             .tPushAddrActual oEmitInt( offset )
8296:             oTypeSPush( oNodeGet( param, qType ) )
      
8309:             [ oNodeGetBoolean( param, qInOut )
8319:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
8320:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
8327:                           @MatchTypes
      
8329:                           .tAssignP
      
8331:                | false :  @Expr
8335:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
8337:                           [ oTypeSNodeType
8339:                              | nIntegerType, nEnumType : .tAssignI
8342:                              | nBooleanType, nByteType, nCharType :  .tAssignB
8346:                              | nShortStringType, nFileType :   #eNotImplemented
8350:                              | nPointerType, nUniversalPointerType :  .tAssignP
8354:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
8356:                                  int size = oNodeGetInt( oTypeSTop, qSize )
8368:                                  .tCopy  oEmitInt( size )    % multi-word copy
8376:                           ]
8402:             ]
8410:             oTypeSPop
      
8411:             oNodeIterNext( paramIter )
8417:             param = oNodeIterValue( paramIter )
8427:             [ oNodeNull( param )
8434:                | true :  >
8437:                | false :
8439:             ]
      
8447:             ','
8449:          }
      
8451:          ')'
      
8453:       | * :
8458:    ]
      
8458:    [ oNodeNull( param )
8465:       | false :    #eMissingParameter
8468:       | * :
8473:    ]
      
8473:    [ isFunc
8476:       | true :
               % Pass result temp as an additional VAR parameter.
8477:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
8492:          .tPushAddrLocal  oEmitInt( tempOffset )
8500:          .tAssignP
8502:       | * :
8507:    ]
      
8507:    [ cdecl
8510:       | true :
8511:          .tCallCdecl  @EmitValue( method )
8520:       | false :
8522:          .tCall   @EmitValue( method )
8531:    ]
      
8539:    [ isFunc
8542:       | true :
               % push return value from temp
8543:          oTypeSPush( resultType )
      
8549:          [ oTypeSNodeType
8551:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
8560:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
8570:             | nShortStringType, nFileType :  #eNotImplemented
8574:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
8584:             | nArrayType, nRecordType :   % compound type: push address
8586:                                .tPushAddrLocal  oEmitInt( tempOffset )
8594:          ]
8620:       | * :
8625:    ]
         
8625:    .tFreeActuals  oEmitInt( actualsSize )
8634:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8634: CallBuiltInFunc( Node method ):
      
         % Ord(x)
8636:    [ oNodeEqual( method, BuiltIn_Ord )
8646:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
8647:          '('
8649:          @Expr
8651:          [ oTypeSNodeType
8653:             | nIntegerType, nEnumType :
8654:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
8658:             | * :  #eTypeMismatch
8673:          ]
8673:          oTypeSPop
8674:          oTypeSPush( IntegerType )
8680:          ')'
8682:          >>
8683:       | * :
8688:    ]
      
         % Chr(x)
8688:    [ oNodeEqual( method, BuiltIn_Chr )
8698:       | true :
               % parameter is integer
               % result is char
8699:          '('
8701:          @Expr
8703:          [ oTypeSNodeType
8705:             | nIntegerType :    .tCastItoB
8708:             | nByteType :
8710:             | * :  #eTypeMismatch
8719:          ]
8719:          oTypeSPop
8720:          oTypeSPush( CharType )
8726:          ')'
8728:          >>
8729:       | * :
8734:    ]
      
         % Pred(x)
8734:    [ oNodeEqual( method, BuiltIn_Pred )
8744:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8745:          '('
8747:          @Expr
8749:          [ oTypeSNodeType
8751:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8752:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8761:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8764:                   | * :
8769:                ]
8769:             | * :  #eTypeMismatch
8776:          ]
8776:          .tDecI
8778:          ')'
8780:          >>
8781:       | * :
8786:    ]
      
         % Succ(x)
8786:    [ oNodeEqual( method, BuiltIn_Succ )
8796:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
8797:          '('
8799:          @Expr
8801:          [ oTypeSNodeType
8803:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
8804:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
8813:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
8816:                   | * :
8821:                ]
8821:             | * :  #eTypeMismatch
8828:          ]
8828:          .tIncI
8830:          ')'
8832:          >>
8833:       | * :
8838:    ]
      
8838:    #eNotImplemented
8841:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
8841: Statement:
8843:    [
8843:       | pWriteln :     @WritelnStmt
8847:       | pWrite :       @WriteStmt
8851:       | pReadln :      @ReadlnStmt
8855:       | pRead :        @ReadStmt
8859:       | pIf :          @IfStmt
8863:       | pWhile :       @WhileStmt
8867:       | pFor :         @ForStmt
8871:       | pRepeat :      @RepeatStmt
8875:       | pBreak :       @BreakStmt
8879:       | pContinue :    @ContinueStmt
8883:       | pBegin :       @BeginStmt
8887:       | pIdent :       @LabelOrAssignOrCallStmt
8891:       | pGoto :        @GotoStmt
8895:       | pIntLit :      % should be an integer label
8897:                        oChangeIntLitToLabelIdent
8898:                        @LabelOrAssignOrCallStmt
8900:       | * :            % null statement : don't accept any tokens
8931:    ];
      
      
8932: LabelOrAssignOrCallStmt:
8934:    Node decl = oScopeFindRequire
8939:    @ResolveUnitRef( decl )
8946:    [ oNodeType( decl )
8953:       | nLabel :                          @LabelDefinition( decl )
8961:                                           @Statement
8963:       | nProc :                           @Call( decl )
8972:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
8981:       | nFunc :                           @AssignResultStmt( decl )
8990:       | * :                               #eBadStatement
9007:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9008: LabelDefinition( Node decl ):
9010:    [ oNodeGetBoolean( decl, qDefined )
9020:       | true :  #eAlreadyDefined
9023:       | * :
9028:    ]
9028:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9043:    oNodeSetBoolean( decl, qDefined, true )
9055:    ':'
9058:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9058: AssignStmt( Node decl ):
      
9060:    @LValueVar( decl, true )
9070:    ':=' 
9072:    @Expr
9074:    @CoerceType
9076:    @Assign
9079:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9079: Assign:
9081:    [ oTypeSNodeType
9083:       | nIntegerType, nEnumType :  .tAssignI
9086:       | nBooleanType, nByteType, nCharType :  .tAssignB
9090:       | nFileType :   #eNotImplemented
9094:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9098:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9100:           int size = oNodeGetInt( oTypeSTop, qSize )
9112:           .tCopy  oEmitInt( size )    % multi-word copy
9120:    ]
9146:    oTypeSPop
9148:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9148: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9150:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9166:       | false :   #eNotCurrentFunction
9169:       | * :
9174:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9174:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9189:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9202:    ':='
9204:    @Expr
9206:    @CoerceType
9208:    [ oTypeSNodeType
9210:       | nIntegerType, nEnumType : .tAssignI
9213:       | nBooleanType, nByteType, nCharType :  .tAssignB
9217:       | nShortStringType, nFileType :   #eNotImplemented
9221:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9225:       | nArrayType, nRecordType :
9227:           int size = oNodeGetInt( oTypeSTop, qSize )
9239:           .tCopy  oEmitInt( size )    % multi-word copy
9247:    ]
9273:    oTypeSPop
9275:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9275: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
9277:    pIdent
9279:    Node decl = oScopeFindRequire
9284:    @ResolveUnitRef( decl )
9291:    [ oNodeType( decl )
9298:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9299:       | * :  #eNotVar
9312:    ]
9312:    @LValueVar( decl, writeable )
9323:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9323: LValueVar( Node decl, boolean writeable ):
9325:    [ oNodeType( decl )
9332:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9342:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9353:       | nParam :
9355:          [ oNodeGetBoolean( decl, qInOut )
9365:             | true :   % VAR param points to variable.  No dereference.
9366:                        .tPushParamP @EmitValue( decl )
9375:             | * :      .tPushAddrParam @EmitValue( decl )
9389:          ]
9389:       | nTypedConst :
9391:          [ writeable
9394:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9404:             | * :      #eNotVar
9411:          ]
9411:       | * :            #eNotVar
9424:    ]
      
9424:    oTypeSPush( oNodeGet( decl, qType ) )
9437:    @LValueIndexes        % handle subscripts, if any
9440:    ;
      
      
9440: IncVar( Node decl ):
9442:    @LValueVar( decl, true )
9452:    @RequireIntPop
9454:    @VarExpr( decl )
9461:    oTypeSPop
9462:    .tIncI
9464:    .tAssignI;
      
9467: DecVar( Node decl ):
9469:    @LValueVar( decl, true )
9479:    @RequireIntPop
9481:    @VarExpr( decl )
9488:    oTypeSPop
9489:    .tDecI
9491:    .tAssignI;
      
      
9494: IfStmt:
9496:    Label falseLabel = labelNull
      
9502:    @BooleanExprControlFlow( falseLabel )
9509:    pThen
9511:    @Statement
9513:    [
9513:       | pElse :
9515:          Label doneLabel = oLabelNew
      
9520:          .tJump  oEmitLabel( doneLabel )
9528:          .tLabel oEmitLabel( falseLabel )
9536:          @Statement
9538:          .tLabel oEmitLabel( doneLabel )
      
9546:       | * :
9551:          .tLabel oEmitLabel( falseLabel )
9559:    ];
      
      
9560: ForStmt:
9562:    pIdent
      
9564:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
9569:    @LValueVar( decl, true )
9579:    @RequireIntPop
      
9581:    ':='
      
9583:    @Expr
9585:    @RequireIntPop
9587:    .tAssignI
      
9589:    Label breakLabel = oLabelNew
      
9594:    Label checkLabel = oLabelNew
9599:    .tJump  oEmitLabel( checkLabel )
      
9607:    Label continueLabel = oLabelNew
9612:    .tLabel  oEmitLabel( continueLabel )
9620:    [
9620:       | pTo :
9622:          @IncVar( decl )
9629:          .tLabel  oEmitLabel( checkLabel )
9637:          @VarExpr( decl )  oTypeSPop
9645:          @Expr
9647:          @RequireIntPop
9649:          .tGreaterI
9651:          .tJumpTrue  oEmitLabel( breakLabel )
9659:       | pDownto :
9661:          @DecVar( decl )
9668:          .tLabel  oEmitLabel( checkLabel )
9676:          @VarExpr( decl )  oTypeSPop
9684:          @Expr
9686:          @RequireIntPop
9688:          .tLessI
9690:          .tJumpTrue  oEmitLabel( breakLabel )
9698:    ]
9706:    oLoopPush( continueLabel, breakLabel )
9715:    pDo
9717:    @Statement
9719:    .tJump  oEmitLabel( continueLabel )
9727:    .tLabel  oEmitLabel( breakLabel )
9735:    oLoopPop;
      
      
9737: RepeatStmt:
9739:    Label continueLabel = oLabelNew
9744:    .tLabel  oEmitLabel( continueLabel )
      
9752:    Label breakLabel = oLabelNew
      
9757:    oLoopPush( continueLabel, breakLabel )
9766:    @Statement
9768:    {[
9768:       | ';' :
9770:          @Statement
9772:       | pUntil :
9774:          Label falseLabel
9774:          @BooleanExprControlFlow( falseLabel )
9781:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
9795:          >
9797:    ]}
9807:    .tLabel  oEmitLabel( breakLabel )
9815:    oLoopPop;
      
      
9817: WhileStmt:
9819:    Label continueLabel = oLabelNew
9824:    .tLabel  oEmitLabel( continueLabel )
      
9832:    Label breakLabel
9832:    @BooleanExprControlFlow( breakLabel )
      
9839:    oLoopPush( continueLabel, breakLabel )
9848:    pDo
9850:    @Statement
9852:    .tJump  oEmitLabel( continueLabel )
9860:    .tLabel  oEmitLabel( breakLabel )
9868:    oLoopPop;
      
      
9870: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
9872:    [ equal_label( oLoopContinueLabel, labelNull )
9881:       | true :
9882:          #eNotInALoop
9884:       | false :
9886:          .tJump  oEmitLabel( oLoopContinueLabel )
9893:    ];
      
      
9902: BreakStmt:
9904:    [ equal_label( oLoopBreakLabel, labelNull )
9913:       | true :
9914:          #eNotInALoop
9916:       | false :
9918:          .tJump  oEmitLabel( oLoopBreakLabel )
9925:    ];
      
      
9934: GotoStmt:
9936:    [
9936:       | pIdent :
9938:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
9940:          oChangeIntLitToLabelIdent
9941:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
9949:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
9958:    oNodeSetBoolean( decl, qUsed, true )
9970:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9986:    ;
      
      
9986: BeginStmt:
9988:    @Statement
9990:    {[
9990:       | ';' :   @Statement
9994:       | pEnd :  >
9998:    ]};
      
      
10009: WritelnStmt:
10011:    @WriteStmt
10013:    .tWriteCR;
      
      
10016: WriteStmt:
10018:    [
10018:       | '(' :
10020:          {
10020:             @Expr
10022:             [ oTypeSNodeType
10024:                | nIntegerType :             .tWriteI
10027:                | nBooleanType :             .tWriteBool
10031:                | nByteType :                .tCastBtoI  .tWriteI
10037:                | nCharType :                .tWriteChar
10041:                | nShortStringType :         .tWriteShortStr
10045:                | nFileType :                #eNotImplemented
10049:                | nEnumType :
                        % write name via table lookup
10051:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10065:                   .tWriteEnum
10067:                | nPointerType, nUniversalPointerType :   .tWriteP
10071:                | * :                        #eNotAllowed
10094:             ]
10094:             oTypeSPop
10095:             [
10095:                | ')' : >
10099:                | ',' :
10101:             ]
10109:          }
10111:       | * :
10116:    ];
      
      
10117: ReadlnStmt:      % ***
         % TO DO
10120:    ;
      
10120: ReadStmt:
         % TO DO
10123:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
10123: ScopeLevel >> int:
10125:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
10135: DeclLevel( Node decl ) >> int:
10137:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
10155: DeclUpLevels( Node decl ) >> int:
10157:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
10173: MatchTypes:
10175:    node_type nt = oTypeSNodeType
10180:    oTypeSPop
10181:    [ equal_node_type( nt, oTypeSNodeType )
10190:       | false :
               % Some implicit conversion is allowed even here
10191:          [ oTypeSNodeType
10193:             | nPointerType :
10194:                [ nt
10197:                   | nUniversalPointerType :  >>
10199:                   | * :
10204:                ]
10204:             | nUniversalPointerType :
10206:                [ nt
10209:                   | nPointerType :  >>
10211:                   | * :
10216:                ]
10216:             | * :
10223:          ]
10223:          #eTypeMismatch
10225:       | * :
10230:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
10231: RequireIntPop:
10233:    [ oTypeSNodeType
10235:       | nIntegerType :
10236:       | * :          #eNotInteger
10243:    ]
10243:    oTypeSPop;
      
10245: RequireInt:
10247:    [ oTypeSNodeType
10249:       | nIntegerType :
10250:       | * :          #eNotInteger
10257:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
10258: PromoteToIntPop:
10260:    [ oTypeSNodeType
10262:       | nIntegerType :
10263:       | nByteType :        .tCastBtoI
10267:       | * :                #eNotInteger
10276:    ]
10276:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
10278: PromoteToInt:
10280:    [ oTypeSNodeType
10282:       | nIntegerType :
10283:       | nByteType :        .tCastBtoI
10287:                            oTypeSPop
10288:                            oTypeSPush( IntegerType )
10294:       | * :                #eNotInteger
10303:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
10304: PromoteToIntOptional:
10306:    [ oTypeSNodeType
10308:       | nByteType :        .tCastBtoI
10311:                            oTypeSPop
10312:                            oTypeSPush( IntegerType )
10318:       | * :
10323:    ];
      
      
      
      
10324: RequireBoolPop:
10326:    [ oTypeSNodeType
10328:       | nBooleanType :
10329:       | * :          #eNotBoolean
10336:    ]
10336:    oTypeSPop;
      
10338: RequireBool:
10340:    [ oTypeSNodeType
10342:       | nBooleanType :
10343:       | * :          #eNotBoolean
10350:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
10351: newType( node_type nt, int size ) >> Node:
10353:   Node node = oNodeNew( nt )
10363:   oNodeSetInt( node, qSize, size )
10375:   oTypeAdd( node )
10381:   >> node
10385:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
10385: newIdent( node_type nt, int id ) >> Node:
10387:   Node t = oNodeNew( nt )
10397:   oNodeSetInt( t, qIdent, id )
10409:   >> t
10413:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
10413: PointerTypeTo( Node theType ) >> Node:
10415:    Node ptrType = oNodeGet( theType, qPointerType )
10428:    [ oNodeNull( ptrType )
10435:       | true :
10436:          ptrType = oNodeNew( nPointerType )
10446:          oNodeSet( ptrType, qBaseType, theType )
10458:          oNodeSetInt( ptrType, qSize, 8 )
10470:          oTypeAdd( ptrType )
10476:          oNodeSet( theType, qPointerType, ptrType )
10488:       | * :
10493:    ]
10493:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
10497: OrdinalLow( Node theType ) >> int:
10499:    [ oNodeType( theType )
10506:       | nIntegerType :  >> oMININT
10509:       | nBooleanType :  >> 0
10514:       | nCharType :     >> 0
10519:       | nEnumType :
10521:          Node enumScope = oNodeGet( theType, qScope )
10534:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
10551:          >> oNodeGetInt( first, qValue )
10561:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
10573:       | * :             #eNotOrdinalType
10588:                         >> 0
10591:    ];
      
      
      % Return the high value of an ordinal type
      %
10592: OrdinalHigh( Node theType ) >> int:
10594:    [ oNodeType( theType )
10601:       | nIntegerType :  >> oMAXINT
10604:       | nBooleanType :  >> 1
10609:       | nCharType :     >> 255
10614:       | nEnumType :
10616:          Node enumScope = oNodeGet( theType, qScope )
10629:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
10646:          >> oNodeGetInt( last, qValue )
10656:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
10668:       | * :             #eNotOrdinalType
10683:                         >> 0
10686:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
10687: EmitValue( Node decl ):
10689:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
10703: DeclareBuiltInFunc( int id ) >> Node:
10705:    Node decl = @newIdent( nBuiltInFunc, id )
10719:    oScopeDeclare( decl )
10725:    >> decl;
      
      
10729: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
10731:    mysystemId = oIdAdd_mysystem
      
         % install built-in types
10736:    FileType = @newType( nFileType, 4 )
10750:    IntegerType = @newType( nIntegerType, 4 )
10764:    BooleanType = @newType( nBooleanType, 1 )
10778:    BooleanCFType = @newType( nBooleanCFType, 1 )
10792:    CharType = @newType( nCharType, 1 )
10806:    PCharType = @PointerTypeTo( CharType )
10817:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
10831:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
10845:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
10857:    ShortStringType = @newType( nShortStringType, 256 )
10871:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
10883:    Node t
      
10883:    t = @newIdent( nTypeDecl, oIdAdd_File )
10896:    oNodeSet( t, qType, FileType )
10908:    oScopeDeclare( t )
      
10914:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
10927:    oNodeSet( t, qType, IntegerType )
10939:    oScopeDeclare( t )
      
10945:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
10958:    oNodeSet( t, qType, BooleanType )
10970:    oScopeDeclare( t )
      
10976:    t = @newIdent( nTypeDecl, oIdAdd_Char )
10989:    oNodeSet( t, qType, CharType )
11001:    oScopeDeclare( t )
      
11007:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
11020:    oNodeSet( t, qType, ByteType )
11032:    oScopeDeclare( t )
      
11038:    t = @newIdent( nTypeDecl, oIdAdd_Pointer )
11051:    oNodeSet( t, qType, UniversalPointerType )
11063:    oScopeDeclare( t )
      
11069:    t = @newIdent( nTypeDecl, oIdAdd_ShortString )
11082:    oNodeSet( t, qType, ShortStringType )
11094:    oScopeDeclare( t )
      
         % Built-in constants
      
11100:    t = @newIdent( nConst, oIdAdd_True )
11113:    oNodeSet( t, qType, BooleanType )
11125:    oNodeSetInt( t, qValue, 1 )
11137:    oScopeDeclare( t )
      
11143:    t = @newIdent( nConst, oIdAdd_False )
11156:    oNodeSet( t, qType, BooleanType )
11168:    oNodeSetInt( t, qValue, 0 )
11180:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
11186:    BuiltIn_Ord = @DeclareBuiltInFunc( oIdAdd_Ord )
11196:    BuiltIn_Chr = @DeclareBuiltInFunc( oIdAdd_Chr )
11206:    BuiltIn_Pred = @DeclareBuiltInFunc( oIdAdd_Pred )
11216:    BuiltIn_Succ = @DeclareBuiltInFunc( oIdAdd_Succ )
11227:    ;
      
11227: end
      
11227: 

Generated code:

   0: oGlobalSpace 18
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 10729
  25: oEmit 64
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 58
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 61
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 60
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 63
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 10385
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 10385
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          57    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 509
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1459
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1780
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1515
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 571
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 370
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 370
 367: oPop 2
 369: oReturn
 370: oLocalSpace 2
 372: oGetAddrLocal 1
 374: oPushResult
 375: oGetParam 2
 377: oPushResult
 378: oCall 650
 380: oPop 1
 382: oAssign
 383: oGetLocal 1
 385: oPushResult
 386: oSetResult 0
 388: oPushResult
 389: equal_node
 390: oPop 2
 392: oChoice 462
 394: oGetParam 1
 396: oPushResult
 397: oSetResult 5
 399: oPushResult
 400: oGetLocal 1
 402: oPushResult
 403: oNodeAddLast
 404: oPop 3
 406: oGetAddrLocal 2
 408: oPushResult
 409: oSetResult 10
 411: oPushResult
 412: oNodeNew
 413: oPop 1
 415: oAssign
 416: oGetLocal 2
 418: oPushResult
 419: oSetResult 4
 421: oPushResult
 422: oGetLocal 1
 424: oPushResult
 425: oSetResult 4
 427: oPushResult
 428: oNodeGetInt
 429: oPop 2
 431: oPushResult
 432: oNodeSetInt
 433: oPop 3
 435: oGetLocal 2
 437: oPushResult
 438: oSetResult 9
 440: oPushResult
 441: oGetLocal 1
 443: oPushResult
 444: oSetResult 9
 446: oPushResult
 447: oNodeGet
 448: oPop 2
 450: oPushResult
 451: oNodeSet
 452: oPop 3
 454: oGetLocal 2
 456: oPushResult
 457: oScopeDeclare
 458: oPop 1
 460: oJumpForward 465
 462: Choice Lookup Table
           0    394
 465: oReturn
 466: oLocalSpace 1
 468: oGetFromParam 1
 470: oPushResult
 471: oNodeType
 472: oPop 1
 474: oChoice 505
 476: oGetAddrLocal 1
 478: oPushResult
 479: oGetFromParam 1
 481: oPushResult
 482: oSetResult 9
 484: oPushResult
 485: oNodeGet
 486: oPop 2
 488: oAssign
 489: oInput 20
 491: oInput 0
 493: oGetParam 1
 495: oPushResult
 496: oGetLocal 1
 498: oPushResult
 499: oScopeFindRequireInScope
 500: oPop 1
 502: oAssign
 503: oJumpForward 508
 505: Choice Lookup Table
          10    476
 508: oReturn
 509: oLocalSpace 2
 511: oGetAddrLocal 1
 513: oPushResult
 514: oGetParam 1
 516: oPushResult
 517: oSetResult 5
 519: oPushResult
 520: oNodeGetIter
 521: oPop 2
 523: oAssign
 524: oGetAddrLocal 2
 526: oPushResult
 527: oGetLocal 1
 529: oPushResult
 530: oNodeIterValue
 531: oPop 1
 533: oAssign
 534: oGetLocal 2
 536: oPushResult
 537: oNodeNull
 538: oPop 1
 540: oChoice 557
 542: oGetLocal 2
 544: oPushResult
 545: oSetResult 9
 547: oPushResult
 548: oNodeGet
 549: oPop 2
 551: oPushResult
 552: oScopeEnter
 553: oPop 1
 555: oJumpForward 562
 557: Choice Lookup Table
           0    542
 560: oJumpForward 570
 562: oGetAddrLocal 1
 564: oPushResult
 565: oNodeIterNext
 566: oPop 1
 568: oJumpBack 524
 570: oReturn
 571: oLocalSpace 2
 573: oGetAddrLocal 1
 575: oPushResult
 576: oGetParam 1
 578: oPushResult
 579: oSetResult 5
 581: oPushResult
 582: oNodeGetIterLast
 583: oPop 2
 585: oAssign
 586: oGetAddrLocal 2
 588: oPushResult
 589: oGetLocal 1
 591: oPushResult
 592: oNodeIterValue
 593: oPop 1
 595: oAssign
 596: oGetLocal 2
 598: oPushResult
 599: oNodeNull
 600: oPop 1
 602: oChoice 636
 604: oScopeCurrent
 605: oPushResult
 606: oGetLocal 2
 608: oPushResult
 609: oSetResult 9
 611: oPushResult
 612: oNodeGet
 613: oPop 2
 615: oPushResult
 616: oNodeEqual
 617: oPop 2
 619: oChoice 627
 621: oJumpForward 633
 623: oError 25
 625: oJumpForward 633
 627: Choice Lookup Table
           0    623
           1    621
 632: oEndChoice
 633: oScopeEnd
 634: oJumpForward 641
 636: Choice Lookup Table
           0    604
 639: oJumpForward 649
 641: oGetAddrLocal 1
 643: oPushResult
 644: oNodeIterPrev
 645: oPop 1
 647: oJumpBack 586
 649: oReturn
 650: oLocalSpace 2
 652: oGetAddrLocal 1
 654: oPushResult
 655: oGetGlobal 1
 657: oPushResult
 658: oSetResult 1
 660: oPushResult
 661: oSetResult 4
 663: oPushResult
 664: oGetParam 1
 666: oPushResult
 667: oNodeFind
 668: oPop 4
 670: oAssign
 671: oGetLocal 1
 673: oPushResult
 674: oSetResult 0
 676: oPushResult
 677: equal_node
 678: oPop 2
 680: oChoice 687
 682: oGetLocal 1
 684: oReturn
 685: oJumpForward 690
 687: Choice Lookup Table
           0    682
 690: oGetAddrLocal 2
 692: oPushResult
 693: oGetParam 1
 695: oPushResult
 696: oIncludeUnitFile
 697: oPop 1
 699: oAssign
 700: oGetLocal 2
 702: oChoice 711
 704: oError 24
 706: oSetResult 0
 708: oReturn
 709: oJumpForward 714
 711: Choice Lookup Table
           0    704
 714: oGetAddrLocal 1
 716: oPushResult
 717: oCall 725
 719: oAssign
 720: oIncludeEnd
 721: oGetLocal 1
 723: oReturn
 724: oReturn
 725: oLocalSpace 2
 727: oInput 58
 729: oInput 0
 731: oGetAddrLocal 1
 733: oPushResult
 734: oSetResult 5
 736: oPushResult
 737: oNodeNew
 738: oPop 1
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oSetResult 4
 746: oPushResult
 747: LAST_ID
 748: oPushResult
 749: oNodeSetInt
 750: oPop 3
 752: oGetAddrLocal 2
 754: oPushResult
 755: oSetResult 6
 757: oPushResult
 758: oNodeNew
 759: oPop 1
 761: oAssign
 762: oGetLocal 2
 764: oPushResult
 765: oSetResult 4
 767: oPushResult
 768: LAST_ID
 769: oPushResult
 770: oNodeSetInt
 771: oPop 3
 773: oGetLocal 1
 775: oPushResult
 776: oSetResult 8
 778: oPushResult
 779: oGetLocal 2
 781: oPushResult
 782: oNodeSet
 783: oPop 3
 785: oInput 5
 787: oInput 59
 789: oGetLocal 1
 791: oPushResult
 792: oCall 333
 794: oPop 1
 796: oInputChoice 807
 798: oGetLocal 1
 800: oPushResult
 801: oCall 306
 803: oPop 1
 805: oJumpForward 810
 807: Choice Lookup Table
          57    798
 810: oGetLocal 1
 812: oPushResult
 813: oCall 509
 815: oPop 1
 817: oSetResult 0
 819: oPushResult
 820: oSetResult 0
 822: oPushResult
 823: oScopeBegin
 824: oPop 2
 826: oGetLocal 1
 828: oPushResult
 829: oSetResult 9
 831: oPushResult
 832: oScopeCurrent
 833: oPushResult
 834: oNodeSet
 835: oPop 3
 837: oGetAddrGlobal 2
 839: oPushResult
 840: oScopeCurrent
 841: oAssign
 842: oSetResult 0
 844: oPushResult
 845: oSetResult 1
 847: oPushResult
 848: oScopeBegin
 849: oPop 2
 851: oGetAddrGlobal 3
 853: oPushResult
 854: oScopeCurrent
 855: oAssign
 856: oGetLocal 1
 858: oPushResult
 859: oSetResult 13
 861: oPushResult
 862: oGetGlobal 3
 864: oPushResult
 865: oNodeSet
 866: oPop 3
 868: oScopeEnd
 869: oGetLocal 1
 871: oPushResult
 872: oCall 1060
 874: oPop 1
 876: oScopeEnd
 877: oInput 60
 879: oGetLocal 2
 881: oPushResult
 882: oCall 333
 884: oPop 1
 886: oInputChoice 897
 888: oGetLocal 2
 890: oPushResult
 891: oCall 306
 893: oPop 1
 895: oJumpForward 900
 897: Choice Lookup Table
          57    888
 900: oGetLocal 2
 902: oPushResult
 903: oCall 509
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 9
 912: oPushResult
 913: oNodeGet
 914: oPop 2
 916: oPushResult
 917: oScopeEnter
 918: oPop 1
 920: oSetResult 0
 922: oPushResult
 923: oSetResult 0
 925: oPushResult
 926: oScopeBegin
 927: oPop 2
 929: oGetLocal 1
 931: oPushResult
 932: oSetResult 10
 934: oPushResult
 935: oScopeCurrent
 936: oPushResult
 937: oNodeSet
 938: oPop 3
 940: oScopeCurrent
 941: oPushResult
 942: oSetResult 16
 944: oPushResult
 945: oGetLocal 1
 947: oPushResult
 948: oSetResult 9
 950: oPushResult
 951: oNodeGet
 952: oPop 2
 954: oPushResult
 955: oNodeSet
 956: oPop 3
 958: oGetAddrGlobal 2
 960: oPushResult
 961: oScopeCurrent
 962: oAssign
 963: oGetLocal 1
 965: oPushResult
 966: oCall 1145
 968: oPop 1
 970: oInputChoice 984
 972: oGetLocal 1
 974: oPushResult
 975: oSetResult 1
 977: oPushResult
 978: oCall 1155
 980: oPop 2
 982: oJumpForward 997
 984: Choice Lookup Table
          61    972
 987: oGetLocal 1
 989: oPushResult
 990: oSetResult 0
 992: oPushResult
 993: oCall 1155
 995: oPop 2
 997: oInputChoice 1011
 999: oGetLocal 1
1001: oPushResult
1002: oSetResult 1
1004: oPushResult
1005: oCall 1341
1007: oPop 2
1009: oJumpForward 1024
1011: Choice Lookup Table
          62    999
1014: oGetLocal 1
1016: oPushResult
1017: oSetResult 0
1019: oPushResult
1020: oCall 1341
1022: oPop 2
1024: oInput 36
1026: oInput 20
1028: oScopeEnd
1029: oScopeEnd
1030: oGetLocal 2
1032: oPushResult
1033: oCall 571
1035: oPop 1
1037: oGetLocal 1
1039: oPushResult
1040: oCall 571
1042: oPop 1
1044: oGetGlobal 1
1046: oPushResult
1047: oSetResult 1
1049: oPushResult
1050: oGetLocal 1
1052: oPushResult
1053: oNodeAddLast
1054: oPop 3
1056: oGetLocal 1
1058: oReturn
1059: oReturn
1060: oLocalSpace 2
1062: oInputChoice 1129
1064: oCall 3053
1066: oJumpForward 1142
1068: oCall 3608
1070: oJumpForward 1142
1072: oSetResult 20
1074: oPushResult
1075: oCall 3664
1077: oPop 1
1079: oJumpForward 1142
1081: oGetAddrLocal 1
1083: oPushResult
1084: oCall 2020
1086: oAssign
1087: oInputChoice 1100
1089: oGetLocal 1
1091: oPushResult
1092: oCall 1958
1094: oPop 1
1096: oInput 5
1098: oJumpForward 1103
1100: Choice Lookup Table
          68   1089
1103: oJumpForward 1142
1105: oGetAddrLocal 2
1107: oPushResult
1108: oCall 2394
1110: oAssign
1111: oInputChoice 1124
1113: oGetLocal 2
1115: oPushResult
1116: oCall 1958
1118: oPop 1
1120: oInput 5
1122: oJumpForward 1127
1124: Choice Lookup Table
          68   1113
1127: oJumpForward 1142
1129: Choice Lookup Table
          30   1105
          29   1081
          33   1072
          32   1068
          31   1064
1140: oJumpForward 1144
1142: oJumpBack 1062
1144: oReturn
1145: oLocalSpace 0
1147: oSetResult 20
1149: oPushResult
1150: oCall 1459
1152: oPop 1
1154: oReturn
1155: oLocalSpace 5
1157: oGetAddrLocal 1
1159: oPushResult
1160: oLabelNew
1161: oAssign
1162: oEmit 68
1164: oGetLocal 1
1166: oPushResult
1167: oEmitLabel
1168: oPop 1
1170: oGetParam 2
1172: oPushResult
1173: oSetResult 11
1175: oPushResult
1176: oGetLocal 1
1178: oPushResult
1179: oNodeSetLabel
1180: oPop 3
1182: oEmit 64
1184: oGetAddrLocal 2
1186: oPushResult
1187: Here
1188: oAssign
1189: oEmit 78
1191: oGetAddrLocal 3
1193: oPushResult
1194: oGetParam 2
1196: oPushResult
1197: oSetResult 9
1199: oPushResult
1200: oNodeGet
1201: oPop 2
1203: oAssign
1204: oGetAddrLocal 4
1206: oPushResult
1207: oGetLocal 3
1209: oPushResult
1210: oSetResult 19
1212: oPushResult
1213: oNodeGetCode
1214: oPop 2
1216: oAssign
1217: oGetLocal 4
1219: oPushResult
1220: oEmitCode
1221: oPop 1
1223: oGetLocal 3
1225: oPushResult
1226: oSetResult 19
1228: oPushResult
1229: oSetResult 0
1231: oPushResult
1232: oNodeSetCode
1233: oPop 3
1235: oGetAddrLocal 3
1237: oPushResult
1238: oGetParam 2
1240: oPushResult
1241: oSetResult 10
1243: oPushResult
1244: oNodeGet
1245: oPop 2
1247: oAssign
1248: oGetAddrLocal 4
1250: oPushResult
1251: oGetLocal 3
1253: oPushResult
1254: oSetResult 19
1256: oPushResult
1257: oNodeGetCode
1258: oPop 2
1260: oAssign
1261: oGetLocal 4
1263: oPushResult
1264: oEmitCode
1265: oPop 1
1267: oGetLocal 3
1269: oPushResult
1270: oSetResult 19
1272: oPushResult
1273: oSetResult 0
1275: oPushResult
1276: oNodeSetCode
1277: oPop 3
1279: oGetParam 2
1281: oPushResult
1282: oSetResult 13
1284: oPushResult
1285: oNodeGet
1286: oPop 2
1288: oPushResult
1289: oScopeEnter
1290: oPop 1
1292: oGetParam 1
1294: oChoice 1313
1296: oCall 8841
1298: oInputChoice 1304
1300: oCall 8841
1302: oJumpForward 1309
1304: Choice Lookup Table
           5   1300
1307: oJumpForward 1311
1309: oJumpBack 1298
1311: oJumpForward 1316
1313: Choice Lookup Table
           1   1296
1316: oEmit 63
1318: oGetAddrLocal 5
1320: oPushResult
1321: oScopeCurrent
1322: oPushResult
1323: oSetResult 17
1325: oPushResult
1326: oNodeGetInt
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oGetLocal 5
1335: oPushResult
1336: oPatch
1337: oPop 2
1339: oScopeEnd
1340: oReturn
1341: oLocalSpace 3
1343: oGetAddrLocal 1
1345: oPushResult
1346: oLabelNew
1347: oAssign
1348: oEmit 68
1350: oGetLocal 1
1352: oPushResult
1353: oEmitLabel
1354: oPop 1
1356: oGetParam 2
1358: oPushResult
1359: oSetResult 12
1361: oPushResult
1362: oGetLocal 1
1364: oPushResult
1365: oNodeSetLabel
1366: oPop 3
1368: oEmit 64
1370: oGetAddrLocal 2
1372: oPushResult
1373: Here
1374: oAssign
1375: oEmit 78
1377: oSetResult 0
1379: oPushResult
1380: oSetResult 1
1382: oPushResult
1383: oScopeBegin
1384: oPop 2
1386: oGetParam 1
1388: oChoice 1407
1390: oCall 8841
1392: oInputChoice 1398
1394: oCall 8841
1396: oJumpForward 1403
1398: Choice Lookup Table
           5   1394
1401: oJumpForward 1405
1403: oJumpBack 1392
1405: oJumpForward 1410
1407: Choice Lookup Table
           1   1390
1410: oEmit 63
1412: oGetAddrLocal 3
1414: oPushResult
1415: oScopeCurrent
1416: oPushResult
1417: oSetResult 17
1419: oPushResult
1420: oNodeGetInt
1421: oPop 2
1423: oAssign
1424: oGetLocal 2
1426: oPushResult
1427: oGetLocal 3
1429: oPushResult
1430: oPatch
1431: oPop 2
1433: oScopeEnd
1434: oReturn
1435: oLocalSpace 0
1437: oGetParam 2
1439: oPushResult
1440: oCall 1459
1442: oPop 1
1444: oGetParam 1
1446: oPushResult
1447: oScopeCurrent
1448: oPushResult
1449: oSetResult 0
1451: oPushResult
1452: oCall 1780
1454: oPop 3
1456: oCall 1515
1458: oReturn
1459: oLocalSpace 0
1461: oInputChoice 1492
1463: oCall 3053
1465: oJumpForward 1507
1467: oCall 3608
1469: oJumpForward 1507
1471: oGetParam 1
1473: oPushResult
1474: oCall 3664
1476: oPop 1
1478: oJumpForward 1507
1480: oCall 3898
1482: oJumpForward 1507
1484: oCall 2276
1486: oJumpForward 1507
1488: oCall 2711
1490: oJumpForward 1507
1492: Choice Lookup Table
          30   1488
          29   1484
          34   1480
          33   1471
          32   1467
          31   1463
1505: oJumpForward 1509
1507: oJumpBack 1461
1509: oCall 1512
1511: oReturn
1512: oLocalSpace 0
1514: oReturn
1515: oLocalSpace 2
1517: oGetAddrLocal 1
1519: oPushResult
1520: oScopeCurrent
1521: oPushResult
1522: oSetResult 15
1524: oPushResult
1525: oNodeGetIter
1526: oPop 2
1528: oAssign
1529: oGetAddrLocal 2
1531: oPushResult
1532: oGetLocal 1
1534: oPushResult
1535: oNodeIterValue
1536: oPop 1
1538: oAssign
1539: oGetLocal 2
1541: oPushResult
1542: oNodeNull
1543: oPop 1
1545: oChoice 1549
1547: oJumpForward 1554
1549: Choice Lookup Table
           0   1547
1552: oJumpForward 1609
1554: oGetLocal 2
1556: oPushResult
1557: oNodeType
1558: oPop 1
1560: oChoice 1598
1562: oGetLocal 2
1564: oPushResult
1565: oSetResult 34
1567: oPushResult
1568: oNodeGetBoolean
1569: oPop 2
1571: oChoice 1593
1573: oGetLocal 2
1575: oPushResult
1576: oSetResult 28
1578: oPushResult
1579: oNodeGetBoolean
1580: oPop 2
1582: oChoice 1588
1584: oError 27
1586: oJumpForward 1591
1588: Choice Lookup Table
           1   1584
1591: oJumpForward 1596
1593: Choice Lookup Table
           0   1573
1596: oJumpForward 1601
1598: Choice Lookup Table
          25   1562
1601: oGetAddrLocal 1
1603: oPushResult
1604: oNodeIterNext
1605: oPop 1
1607: oJumpBack 1529
1609: oReturn
1610: oLocalSpace 2
1612: oGetAddrLocal 1
1614: oPushResult
1615: oGetGlobal 1
1617: oPushResult
1618: oSetResult 1
1620: oPushResult
1621: oNodeGetIter
1622: oPop 2
1624: oAssign
1625: oGetAddrLocal 2
1627: oPushResult
1628: oGetLocal 1
1630: oPushResult
1631: oNodeIterValue
1632: oPop 1
1634: oAssign
1635: oGetLocal 2
1637: oPushResult
1638: oNodeNull
1639: oPop 1
1641: oChoice 1686
1643: oJumpForward 1694
1645: oJumpForward 1692
1647: oEmit 58
1649: oSetResult 0
1651: oPushResult
1652: oEmitInt
1653: oPop 1
1655: oEmit 61
1657: oGetLocal 2
1659: oPushResult
1660: oSetResult 11
1662: oPushResult
1663: oNodeGetLabel
1664: oPop 2
1666: oPushResult
1667: oEmitLabel
1668: oPop 1
1670: oEmit 60
1672: oSetResult 0
1674: oPushResult
1675: oEmitInt
1676: oPop 1
1678: oGetAddrLocal 1
1680: oPushResult
1681: oNodeIterNext
1682: oPop 1
1684: oJumpForward 1692
1686: Choice Lookup Table
           0   1647
           1   1643
1691: oEndChoice
1692: oJumpBack 1625
1694: oReturn
1695: oLocalSpace 2
1697: oGetAddrLocal 1
1699: oPushResult
1700: oGetGlobal 1
1702: oPushResult
1703: oSetResult 1
1705: oPushResult
1706: oNodeGetIterLast
1707: oPop 2
1709: oAssign
1710: oGetAddrLocal 2
1712: oPushResult
1713: oGetLocal 1
1715: oPushResult
1716: oNodeIterValue
1717: oPop 1
1719: oAssign
1720: oGetLocal 2
1722: oPushResult
1723: oNodeNull
1724: oPop 1
1726: oChoice 1771
1728: oJumpForward 1779
1730: oJumpForward 1777
1732: oEmit 58
1734: oSetResult 0
1736: oPushResult
1737: oEmitInt
1738: oPop 1
1740: oEmit 61
1742: oGetLocal 2
1744: oPushResult
1745: oSetResult 12
1747: oPushResult
1748: oNodeGetLabel
1749: oPop 2
1751: oPushResult
1752: oEmitLabel
1753: oPop 1
1755: oEmit 60
1757: oSetResult 0
1759: oPushResult
1760: oEmitInt
1761: oPop 1
1763: oGetAddrLocal 1
1765: oPushResult
1766: oNodeIterPrev
1767: oPop 1
1769: oJumpForward 1777
1771: Choice Lookup Table
           0   1732
           1   1728
1776: oEndChoice
1777: oJumpBack 1710
1779: oReturn
1780: oLocalSpace 3
1782: oEmit 68
1784: oGetParam 3
1786: oPushResult
1787: oEmitLabel
1788: oPop 1
1790: oEmit 64
1792: oGetAddrLocal 1
1794: oPushResult
1795: Here
1796: oAssign
1797: oEmit 78
1799: oGetParam 1
1801: oChoice 1807
1803: oCall 1610
1805: oJumpForward 1810
1807: Choice Lookup Table
           1   1803
1810: oGetAddrLocal 2
1812: oPushResult
1813: oGetParam 2
1815: oPushResult
1816: oSetResult 19
1818: oPushResult
1819: oNodeGetCode
1820: oPop 2
1822: oAssign
1823: oGetLocal 2
1825: oPushResult
1826: oEmitCode
1827: oPop 1
1829: oGetParam 2
1831: oPushResult
1832: oSetResult 19
1834: oPushResult
1835: oSetResult 0
1837: oPushResult
1838: oNodeSetCode
1839: oPop 3
1841: oCall 8841
1843: oGetParam 1
1845: oChoice 1851
1847: oCall 1695
1849: oJumpForward 1854
1851: Choice Lookup Table
           1   1847
1854: oEmit 63
1856: oGetAddrLocal 3
1858: oPushResult
1859: oScopeCurrent
1860: oPushResult
1861: oSetResult 17
1863: oPushResult
1864: oNodeGetInt
1865: oPop 2
1867: oAssign
1868: oGetLocal 1
1870: oPushResult
1871: oGetLocal 3
1873: oPushResult
1874: oPatch
1875: oPop 2
1877: oReturn
1878: oLocalSpace 0
1880: oInputChoice 1898
1882: oGetParam 1
1884: oPushResult
1885: oSetResult 27
1887: oPushResult
1888: oSetResult 1
1890: oPushResult
1891: oNodeSetBoolean
1892: oPop 3
1894: oInput 5
1896: oJumpForward 1903
1898: Choice Lookup Table
          70   1882
1901: oJumpForward 1905
1903: oJumpBack 1880
1905: oReturn
1906: oLocalSpace 1
1908: oGetAddrLocal 1
1910: oPushResult
1911: oGetParam 1
1913: oPushResult
1914: oSetResult 19
1916: oPushResult
1917: oNodeGetCode
1918: oPop 2
1920: oAssign
1921: oGetLocal 1
1923: oPushResult
1924: oSetResult 0
1926: oPushResult
1927: equal_code
1928: oPop 2
1930: oChoice 1951
1932: oGetAddrLocal 1
1934: oPushResult
1935: oCodeNew
1936: oAssign
1937: oGetParam 1
1939: oPushResult
1940: oSetResult 19
1942: oPushResult
1943: oGetLocal 1
1945: oPushResult
1946: oNodeSetCode
1947: oPop 3
1949: oJumpForward 1954
1951: Choice Lookup Table
           1   1932
1954: oGetLocal 1
1956: oReturn
1957: oReturn
1958: oLocalSpace 0
1960: oGetParam 1
1962: oPushResult
1963: oCall 10135
1965: oPop 1
1967: oPushResult
1968: equal_zero
1969: oPop 1
1971: oChoice 1977
1973: oError 23
1975: oJumpForward 1980
1977: Choice Lookup Table
           0   1973
1980: oGetParam 1
1982: oPushResult
1983: oSetResult 25
1985: oPushResult
1986: oSetResult 1
1988: oPushResult
1989: oNodeSetBoolean
1990: oPop 3
1992: oInputChoice 2016
1994: oInputChoice 2011
1996: oInput 2
1998: oGetParam 1
2000: oPushResult
2001: oSetResult 26
2003: oPushResult
2004: CURRENT_STRLIT
2005: oPushResult
2006: oNodeSetString
2007: oPop 3
2009: oJumpForward 2014
2011: Choice Lookup Table
          69   1996
2014: oJumpForward 2019
2016: Choice Lookup Table
           2   1994
2019: oReturn
2020: oLocalSpace 6
2022: oInput 0
2024: oGetAddrLocal 1
2026: oPushResult
2027: oSetResult 0
2029: oAssign
2030: oGetAddrLocal 2
2032: oPushResult
2033: oScopeFindInCurrentScope
2034: oAssign
2035: oGetLocal 2
2037: oPushResult
2038: oNodeNull
2039: oPop 1
2041: oChoice 2159
2043: oGetAddrLocal 2
2045: oPushResult
2046: oSetResult 12
2048: oPushResult
2049: LAST_ID
2050: oPushResult
2051: oCall 10385
2053: oPop 2
2055: oAssign
2056: oGetLocal 2
2058: oPushResult
2059: oSetResult 22
2061: oPushResult
2062: oLabelNew
2063: oPushResult
2064: oNodeSetLabel
2065: oPop 3
2067: oJumpForward 2165
2069: oGetAddrLocal 1
2071: oPushResult
2072: oSetResult 1
2074: oAssign
2075: oGetLocal 2
2077: oPushResult
2078: oSetResult 24
2080: oPushResult
2081: oNodeGetBoolean
2082: oPop 2
2084: oChoice 2090
2086: oError 21
2088: oJumpForward 2093
2090: Choice Lookup Table
           1   2086
2093: oGetLocal 2
2095: oPushResult
2096: oSetResult 25
2098: oPushResult
2099: oNodeGetBoolean
2100: oPop 2
2102: oChoice 2108
2104: oError 21
2106: oJumpForward 2111
2108: Choice Lookup Table
           1   2104
2111: oGetLocal 2
2113: oPushResult
2114: oNodeType
2115: oPop 1
2117: oChoice 2121
2119: oJumpForward 2126
2121: Choice Lookup Table
          12   2119
2124: oError 21
2126: oGetLocal 2
2128: oPushResult
2129: oSetResult 29
2131: oPushResult
2132: oGetLocal 2
2134: oPushResult
2135: oSetResult 23
2137: oPushResult
2138: oNodeGet
2139: oPop 2
2141: oPushResult
2142: oNodeSet
2143: oPop 3
2145: oGetLocal 2
2147: oPushResult
2148: oSetResult 23
2150: oPushResult
2151: oSetResult 0
2153: oPushResult
2154: oNodeSet
2155: oPop 3
2157: oJumpForward 2165
2159: Choice Lookup Table
           0   2069
           1   2043
2164: oEndChoice
2165: oGetAddrLocal 3
2167: oPushResult
2168: oCall 10123
2170: oAssign
2171: oGetAddrLocal 4
2173: oPushResult
2174: oGetLocal 3
2176: oPushResult
2177: oSetResult 0
2179: oPushResult
2180: greater
2181: oPop 2
2183: oAssign
2184: oGetAddrLocal 3
2186: oPushResult
2187: inc
2188: oPop 1
2190: oGetLocal 3
2192: oPushResult
2193: oSetResult 2
2195: oPushResult
2196: oScopeBegin
2197: oPop 2
2199: oGetAddrLocal 5
2201: oPushResult
2202: oScopeCurrent
2203: oAssign
2204: oGetLocal 4
2206: oChoice 2225
2208: oGetAddrLocal 6
2210: oPushResult
2211: oGetGlobal 6
2213: oPushResult
2214: oCall 10413
2216: oPop 1
2218: oPushResult
2219: oScopeAllocType
2220: oPop 1
2222: oAssign
2223: oJumpForward 2228
2225: Choice Lookup Table
           1   2208
2228: oCall 2829
2230: oGetLocal 2
2232: oPushResult
2233: oSetResult 23
2235: oPushResult
2236: oGetLocal 5
2238: oPushResult
2239: oNodeSet
2240: oPop 3
2242: oScopeEnd
2243: oInput 5
2245: oGetLocal 1
2247: oChoice 2259
2249: oGetLocal 2
2251: oPushResult
2252: oScopeDeclare
2253: oPop 1
2255: oJumpForward 2265
2257: oJumpForward 2265
2259: Choice Lookup Table
           1   2257
           0   2249
2264: oEndChoice
2265: oGetLocal 2
2267: oPushResult
2268: oCall 1878
2270: oPop 1
2272: oGetLocal 2
2274: oReturn
2275: oReturn
2276: oLocalSpace 4
2278: oGetAddrLocal 1
2280: oPushResult
2281: oCall 2020
2283: oAssign
2284: oInputChoice 2297
2286: oJumpForward 2391
2288: oGetLocal 1
2290: oPushResult
2291: oCall 1958
2293: oPop 1
2295: oJumpForward 2391
2297: Choice Lookup Table
          68   2288
          67   2286
2302: oGetAddrLocal 2
2304: oPushResult
2305: oGetLocal 1
2307: oPushResult
2308: oSetResult 23
2310: oPushResult
2311: oNodeGet
2312: oPop 2
2314: oAssign
2315: oGetLocal 2
2317: oPushResult
2318: oScopeEnter
2319: oPop 1
2321: oGetAddrLocal 3
2323: oPushResult
2324: oGetLocal 2
2326: oPushResult
2327: oSetResult 14
2329: oPushResult
2330: oNodeGetInt
2331: oPop 2
2333: oAssign
2334: oGetLocal 3
2336: oPushResult
2337: oSetResult 1
2339: oPushResult
2340: oScopeBegin
2341: oPop 2
2343: oGetLocal 1
2345: oPushResult
2346: oSetResult 6
2348: oPushResult
2349: oScopeCurrent
2350: oPushResult
2351: oNodeSet
2352: oPop 3
2354: oGetAddrLocal 4
2356: oPushResult
2357: oGetLocal 1
2359: oPushResult
2360: oSetResult 22
2362: oPushResult
2363: oNodeGetLabel
2364: oPop 2
2366: oAssign
2367: oSetResult 21
2369: oPushResult
2370: oGetLocal 4
2372: oPushResult
2373: oCall 1435
2375: oPop 2
2377: oGetLocal 1
2379: oPushResult
2380: oSetResult 24
2382: oPushResult
2383: oSetResult 1
2385: oPushResult
2386: oNodeSetBoolean
2387: oPop 3
2389: oScopeEnd
2390: oScopeEnd
2391: oInput 5
2393: oReturn
2394: oLocalSpace 8
2396: oInput 0
2398: oGetAddrLocal 1
2400: oPushResult
2401: oSetResult 0
2403: oAssign
2404: oGetAddrLocal 2
2406: oPushResult
2407: oScopeFindInCurrentScope
2408: oAssign
2409: oGetLocal 2
2411: oPushResult
2412: oNodeNull
2413: oPop 1
2415: oChoice 2546
2417: oGetAddrLocal 2
2419: oPushResult
2420: oSetResult 13
2422: oPushResult
2423: LAST_ID
2424: oPushResult
2425: oCall 10385
2427: oPop 2
2429: oAssign
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 22
2435: oPushResult
2436: oLabelNew
2437: oPushResult
2438: oNodeSetLabel
2439: oPop 3
2441: oJumpForward 2552
2443: oGetAddrLocal 1
2445: oPushResult
2446: oSetResult 1
2448: oAssign
2449: oGetLocal 2
2451: oPushResult
2452: oSetResult 24
2454: oPushResult
2455: oNodeGetBoolean
2456: oPop 2
2458: oChoice 2464
2460: oError 21
2462: oJumpForward 2467
2464: Choice Lookup Table
           1   2460
2467: oGetLocal 2
2469: oPushResult
2470: oNodeType
2471: oPop 1
2473: oChoice 2477
2475: oJumpForward 2482
2477: Choice Lookup Table
          13   2475
2480: oError 21
2482: oGetLocal 2
2484: oPushResult
2485: oSetResult 29
2487: oPushResult
2488: oGetLocal 2
2490: oPushResult
2491: oSetResult 23
2493: oPushResult
2494: oNodeGet
2495: oPop 2
2497: oPushResult
2498: oNodeSet
2499: oPop 3
2501: oGetLocal 2
2503: oPushResult
2504: oSetResult 23
2506: oPushResult
2507: oSetResult 0
2509: oPushResult
2510: oNodeSet
2511: oPop 3
2513: oGetLocal 2
2515: oPushResult
2516: oSetResult 30
2518: oPushResult
2519: oGetLocal 2
2521: oPushResult
2522: oSetResult 21
2524: oPushResult
2525: oNodeGet
2526: oPop 2
2528: oPushResult
2529: oNodeSet
2530: oPop 3
2532: oGetLocal 2
2534: oPushResult
2535: oSetResult 21
2537: oPushResult
2538: oSetResult 0
2540: oPushResult
2541: oNodeSet
2542: oPop 3
2544: oJumpForward 2552
2546: Choice Lookup Table
           0   2443
           1   2417
2551: oEndChoice
2552: oGetAddrLocal 3
2554: oPushResult
2555: oCall 10123
2557: oAssign
2558: oGetAddrLocal 4
2560: oPushResult
2561: oGetLocal 3
2563: oPushResult
2564: oSetResult 0
2566: oPushResult
2567: greater
2568: oPop 2
2570: oAssign
2571: oGetAddrLocal 3
2573: oPushResult
2574: inc
2575: oPop 1
2577: oGetLocal 3
2579: oPushResult
2580: oSetResult 2
2582: oPushResult
2583: oScopeBegin
2584: oPop 2
2586: oGetAddrLocal 5
2588: oPushResult
2589: oScopeCurrent
2590: oAssign
2591: oGetLocal 4
2593: oChoice 2612
2595: oGetAddrLocal 6
2597: oPushResult
2598: oGetGlobal 6
2600: oPushResult
2601: oCall 10413
2603: oPop 1
2605: oPushResult
2606: oScopeAllocType
2607: oPop 1
2609: oAssign
2610: oJumpForward 2615
2612: Choice Lookup Table
           1   2595
2615: oCall 2829
2617: oGetLocal 2
2619: oPushResult
2620: oSetResult 23
2622: oPushResult
2623: oGetLocal 5
2625: oPushResult
2626: oNodeSet
2627: oPop 3
2629: oInput 12
2631: oGetAddrLocal 7
2633: oPushResult
2634: oCall 3963
2636: oPop 1
2638: oGetLocal 2
2640: oPushResult
2641: oSetResult 21
2643: oPushResult
2644: oGetLocal 7
2646: oPushResult
2647: oNodeSet
2648: oPop 3
2650: oGetAddrLocal 8
2652: oPushResult
2653: oGetLocal 7
2655: oPushResult
2656: oCall 10413
2658: oPop 1
2660: oAssign
2661: oGetLocal 2
2663: oPushResult
2664: oSetResult 31
2666: oPushResult
2667: oGetLocal 8
2669: oPushResult
2670: oScopeAllocType
2671: oPop 1
2673: oPushResult
2674: oNodeSetInt
2675: oPop 3
2677: oScopeEnd
2678: oInput 5
2680: oGetLocal 1
2682: oChoice 2694
2684: oGetLocal 2
2686: oPushResult
2687: oScopeDeclare
2688: oPop 1
2690: oJumpForward 2700
2692: oJumpForward 2700
2694: Choice Lookup Table
           1   2692
           0   2684
2699: oEndChoice
2700: oGetLocal 2
2702: oPushResult
2703: oCall 1878
2705: oPop 1
2707: oGetLocal 2
2709: oReturn
2710: oReturn
2711: oLocalSpace 4
2713: oGetAddrLocal 1
2715: oPushResult
2716: oCall 2394
2718: oAssign
2719: oInputChoice 2732
2721: oJumpForward 2826
2723: oGetLocal 1
2725: oPushResult
2726: oCall 1958
2728: oPop 1
2730: oJumpForward 2826
2732: Choice Lookup Table
          68   2723
          67   2721
2737: oGetAddrLocal 2
2739: oPushResult
2740: oGetLocal 1
2742: oPushResult
2743: oSetResult 23
2745: oPushResult
2746: oNodeGet
2747: oPop 2
2749: oAssign
2750: oGetLocal 2
2752: oPushResult
2753: oScopeEnter
2754: oPop 1
2756: oGetAddrLocal 3
2758: oPushResult
2759: oGetLocal 2
2761: oPushResult
2762: oSetResult 14
2764: oPushResult
2765: oNodeGetInt
2766: oPop 2
2768: oAssign
2769: oGetLocal 3
2771: oPushResult
2772: oSetResult 1
2774: oPushResult
2775: oScopeBegin
2776: oPop 2
2778: oGetLocal 1
2780: oPushResult
2781: oSetResult 6
2783: oPushResult
2784: oScopeCurrent
2785: oPushResult
2786: oNodeSet
2787: oPop 3
2789: oGetAddrLocal 4
2791: oPushResult
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oNodeGetLabel
2799: oPop 2
2801: oAssign
2802: oSetResult 21
2804: oPushResult
2805: oGetLocal 4
2807: oPushResult
2808: oCall 1435
2810: oPop 2
2812: oGetLocal 1
2814: oPushResult
2815: oSetResult 24
2817: oPushResult
2818: oSetResult 1
2820: oPushResult
2821: oNodeSetBoolean
2822: oPop 3
2824: oScopeEnd
2825: oScopeEnd
2826: oInput 5
2828: oReturn
2829: oLocalSpace 6
2831: oInputChoice 3049
2833: oGetAddrLocal 1
2835: oPushResult
2836: oNodeVecNew
2837: oAssign
2838: oGetAddrLocal 3
2840: oPushResult
2841: oSetResult 0
2843: oAssign
2844: oInputChoice 2854
2846: oGetAddrLocal 3
2848: oPushResult
2849: oSetResult 1
2851: oAssign
2852: oJumpForward 2857
2854: Choice Lookup Table
          33   2846
2857: oInput 0
2859: oGetAddrLocal 2
2861: oPushResult
2862: oSetResult 23
2864: oPushResult
2865: LAST_ID
2866: oPushResult
2867: oCall 10385
2869: oPop 2
2871: oAssign
2872: oGetLocal 2
2874: oPushResult
2875: oSetResult 33
2877: oPushResult
2878: oGetLocal 3
2880: oPushResult
2881: oNodeSetBoolean
2882: oPop 3
2884: oGetLocal 1
2886: oPushResult
2887: oGetLocal 2
2889: oPushResult
2890: oNodeVecAppend
2891: oPop 2
2893: oInputChoice 2901
2895: oJumpForward 2909
2897: oJumpForward 2907
2899: oJumpForward 2907
2901: Choice Lookup Table
          13   2899
          12   2895
2906: oEndChoice
2907: oJumpBack 2857
2909: oGetAddrLocal 4
2911: oPushResult
2912: oCall 3963
2914: oPop 1
2916: oGetLocal 3
2918: oChoice 2933
2920: oGetAddrLocal 5
2922: oPushResult
2923: oGetLocal 4
2925: oPushResult
2926: oCall 10413
2928: oPop 1
2930: oAssign
2931: oJumpForward 2942
2933: Choice Lookup Table
           1   2920
2936: oGetAddrLocal 5
2938: oPushResult
2939: oGetLocal 4
2941: oAssign
2942: oGetAddrLocal 6
2944: oPushResult
2945: oSetResult 0
2947: oAssign
2948: oGetLocal 6
2950: oPushResult
2951: oGetLocal 1
2953: oPushResult
2954: oNodeVecSize
2955: oPop 1
2957: oPushResult
2958: equal
2959: oPop 2
2961: oChoice 3018
2963: oGetAddrLocal 2
2965: oPushResult
2966: oGetLocal 1
2968: oPushResult
2969: oGetLocal 6
2971: oPushResult
2972: oNodeVecElement
2973: oPop 2
2975: oAssign
2976: oGetLocal 2
2978: oPushResult
2979: oSetResult 21
2981: oPushResult
2982: oGetLocal 4
2984: oPushResult
2985: oNodeSet
2986: oPop 3
2988: oGetLocal 2
2990: oPushResult
2991: oScopeDeclare
2992: oPop 1
2994: oGetLocal 2
2996: oPushResult
2997: oSetResult 22
2999: oPushResult
3000: oGetLocal 5
3002: oPushResult
3003: oScopeAllocType
3004: oPop 1
3006: oPushResult
3007: oNodeSetInt
3008: oPop 3
3010: oGetAddrLocal 6
3012: oPushResult
3013: inc
3014: oPop 1
3016: oJumpForward 3023
3018: Choice Lookup Table
           0   2963
3021: oJumpForward 3025
3023: oJumpBack 2948
3025: oGetLocal 1
3027: oPushResult
3028: oNodeVecDelete
3029: oPop 1
3031: oInputChoice 3039
3033: oJumpForward 3047
3035: oJumpForward 3045
3037: oJumpForward 3045
3039: Choice Lookup Table
           5   3037
          15   3033
3044: oEndChoice
3045: oJumpBack 2833
3047: oJumpForward 3052
3049: Choice Lookup Table
          14   2833
3052: oReturn
3053: oLocalSpace 0
3055: oInputChoice 3070
3057: oInputChoice 3063
3059: oCall 3136
3061: oJumpForward 3068
3063: Choice Lookup Table
          12   3059
3066: oCall 3078
3068: oJumpForward 3075
3070: Choice Lookup Table
           0   3057
3073: oJumpForward 3077
3075: oJumpBack 3055
3077: oReturn
3078: oLocalSpace 2
3080: oGetAddrLocal 1
3082: oPushResult
3083: oSetResult 16
3085: oPushResult
3086: LAST_ID
3087: oPushResult
3088: oCall 10385
3090: oPop 2
3092: oAssign
3093: oInput 6
3095: oCall 5019
3097: oGetAddrLocal 2
3099: oPushResult
3100: oValueTop
3101: oAssign
3102: oValuePop
3103: oGetLocal 1
3105: oPushResult
3106: oSetResult 22
3108: oPushResult
3109: oGetLocal 2
3111: oPushResult
3112: oNodeSetInt
3113: oPop 3
3115: oGetLocal 1
3117: oPushResult
3118: oSetResult 21
3120: oPushResult
3121: oGetGlobal 6
3123: oPushResult
3124: oNodeSet
3125: oPop 3
3127: oGetLocal 1
3129: oPushResult
3130: oScopeDeclare
3131: oPop 1
3133: oInput 5
3135: oReturn
3136: oLocalSpace 4
3138: oGetAddrLocal 1
3140: oPushResult
3141: oSetResult 24
3143: oPushResult
3144: LAST_ID
3145: oPushResult
3146: oCall 10385
3148: oPop 2
3150: oAssign
3151: oGetAddrLocal 2
3153: oPushResult
3154: oCall 3963
3156: oPop 1
3158: oGetLocal 1
3160: oPushResult
3161: oSetResult 21
3163: oPushResult
3164: oGetLocal 2
3166: oPushResult
3167: oNodeSet
3168: oPop 3
3170: oGetLocal 2
3172: oPushResult
3173: oNodeType
3174: oPop 1
3176: oChoice 3277
3178: oInput 6
3180: oCall 5019
3182: oGetAddrLocal 3
3184: oPushResult
3185: oValueTop
3186: oAssign
3187: oValuePop
3188: oGetLocal 1
3190: oPushResult
3191: oSetResult 22
3193: oPushResult
3194: oGetLocal 3
3196: oPushResult
3197: oNodeSetInt
3198: oPop 3
3200: oGetLocal 1
3202: oPushResult
3203: oScopeDeclare
3204: oPop 1
3206: oInput 5
3208: oJumpForward 3301
3210: oError 16
3212: oJumpForward 3301
3214: oGetGlobal 2
3216: oPushResult
3217: oScopeEnter
3218: oPop 1
3220: oGetAddrLocal 4
3222: oPushResult
3223: oGetLocal 2
3225: oPushResult
3226: oScopeAllocType
3227: oPop 1
3229: oAssign
3230: oScopeEnd
3231: oGetGlobal 2
3233: oPushResult
3234: oCall 1906
3236: oPop 1
3238: oPushResult
3239: oCodePush
3240: oPop 1
3242: oGetLocal 1
3244: oPushResult
3245: oSetResult 22
3247: oPushResult
3248: oGetLocal 4
3250: oPushResult
3251: oNodeSetInt
3252: oPop 3
3254: oInput 6
3256: oGetLocal 2
3258: oPushResult
3259: oGetLocal 4
3261: oPushResult
3262: oCall 3302
3264: oPop 2
3266: oCodePop
3267: oGetLocal 1
3269: oPushResult
3270: oScopeDeclare
3271: oPop 1
3273: oInput 5
3275: oJumpForward 3301
3277: Choice Lookup Table
          37   3214
          35   3214
          34   3210
          33   3210
          27   3210
          38   3210
          39   3178
          28   3178
          32   3178
          29   3178
          30   3178
3300: oEndChoice
3301: oReturn
3302: oLocalSpace 10
3304: oGetParam 2
3306: oPushResult
3307: oNodeType
3308: oPop 1
3310: oChoice 3583
3312: oGetAddrLocal 1
3314: oPushResult
3315: oGetParam 2
3317: oPushResult
3318: oSetResult 36
3320: oPushResult
3321: oNodeGet
3322: oPop 2
3324: oAssign
3325: oGetAddrLocal 2
3327: oPushResult
3328: oGetParam 2
3330: oPushResult
3331: oSetResult 37
3333: oPushResult
3334: oNodeGet
3335: oPop 2
3337: oAssign
3338: oGetAddrLocal 3
3340: oPushResult
3341: oGetLocal 2
3343: oPushResult
3344: oCall 10497
3346: oPop 1
3348: oAssign
3349: oGetAddrLocal 4
3351: oPushResult
3352: oGetLocal 2
3354: oPushResult
3355: oCall 10592
3357: oPop 1
3359: oAssign
3360: oGetAddrLocal 5
3362: oPushResult
3363: oGetLocal 1
3365: oPushResult
3366: oSetResult 17
3368: oPushResult
3369: oNodeGetInt
3370: oPop 2
3372: oAssign
3373: oInput 14
3375: oGetAddrLocal 6
3377: oPushResult
3378: oGetLocal 3
3380: oAssign
3381: oGetLocal 1
3383: oPushResult
3384: oGetParam 1
3386: oPushResult
3387: oCall 3302
3389: oPop 2
3391: oGetLocal 6
3393: oPushResult
3394: oGetLocal 4
3396: oPushResult
3397: equal
3398: oPop 2
3400: oChoice 3408
3402: oJumpForward 3437
3404: oJumpForward 3414
3406: oJumpForward 3414
3408: Choice Lookup Table
           0   3406
           1   3402
3413: oEndChoice
3414: oInput 13
3416: oGetAddrParam 1
3418: oPushResult
3419: oGetParam 1
3421: oPushResult
3422: oGetLocal 5
3424: oPushResult
3425: add
3426: oPop 2
3428: oAssign
3429: oGetAddrLocal 6
3431: oPushResult
3432: inc
3433: oPop 1
3435: oJumpBack 3381
3437: oInput 15
3439: oJumpForward 3607
3441: oInput 14
3443: oGetAddrLocal 7
3445: oPushResult
3446: oGetParam 2
3448: oPushResult
3449: oSetResult 40
3451: oPushResult
3452: oNodeGet
3453: oPop 2
3455: oAssign
3456: oInputChoice 3460
3458: oJumpForward 3465
3460: Choice Lookup Table
           0   3458
3463: oJumpForward 3531
3465: oGetAddrLocal 8
3467: oPushResult
3468: oGetLocal 7
3470: oPushResult
3471: oScopeFindRequireInScope
3472: oPop 1
3474: oAssign
3475: oInput 12
3477: oGetAddrLocal 9
3479: oPushResult
3480: oGetLocal 8
3482: oPushResult
3483: oSetResult 21
3485: oPushResult
3486: oNodeGet
3487: oPop 2
3489: oAssign
3490: oGetAddrLocal 10
3492: oPushResult
3493: oGetParam 1
3495: oPushResult
3496: oGetLocal 8
3498: oPushResult
3499: oSetResult 22
3501: oPushResult
3502: oNodeGetInt
3503: oPop 2
3505: oPushResult
3506: add
3507: oPop 2
3509: oAssign
3510: oGetLocal 9
3512: oPushResult
3513: oGetLocal 10
3515: oPushResult
3516: oCall 3302
3518: oPop 2
3520: oInputChoice 3524
3522: oJumpForward 3529
3524: Choice Lookup Table
           5   3522
3527: oJumpForward 3531
3529: oJumpBack 3456
3531: oInput 15
3533: oJumpForward 3607
3535: oEmit 16
3537: oGetParam 1
3539: oPushResult
3540: oEmitInt
3541: oPop 1
3543: oCall 5019
3545: oEmit 15
3547: oValueTop
3548: oPushResult
3549: oEmitInt
3550: oPop 1
3552: oValuePop
3553: oEmit 26
3555: oJumpForward 3607
3557: oEmit 16
3559: oGetParam 1
3561: oPushResult
3562: oEmitInt
3563: oPop 1
3565: oCall 5019
3567: oEmit 15
3569: oValueTop
3570: oPushResult
3571: oEmitInt
3572: oPop 1
3574: oValuePop
3575: oEmit 25
3577: oJumpForward 3607
3579: oError 16
3581: oJumpForward 3607
3583: Choice Lookup Table
          34   3579
          33   3579
          27   3579
          38   3579
          39   3557
          28   3557
          32   3535
          29   3535
          30   3535
          37   3441
          35   3312
3606: oEndChoice
3607: oReturn
3608: oLocalSpace 2
3610: oInputChoice 3656
3612: oGetAddrLocal 1
3614: oPushResult
3615: oSetResult 18
3617: oPushResult
3618: LAST_ID
3619: oPushResult
3620: oCall 10385
3622: oPop 2
3624: oAssign
3625: oInput 6
3627: oGetAddrLocal 2
3629: oPushResult
3630: oCall 3963
3632: oPop 1
3634: oGetLocal 1
3636: oPushResult
3637: oSetResult 21
3639: oPushResult
3640: oGetLocal 2
3642: oPushResult
3643: oNodeSet
3644: oPop 3
3646: oGetLocal 1
3648: oPushResult
3649: oScopeDeclare
3650: oPop 1
3652: oInput 5
3654: oJumpForward 3661
3656: Choice Lookup Table
           0   3612
3659: oJumpForward 3663
3661: oJumpBack 3610
3663: oReturn
3664: oLocalSpace 6
3666: oInputChoice 3890
3668: oGetAddrLocal 1
3670: oPushResult
3671: oNodeVecNew
3672: oAssign
3673: oGetAddrLocal 2
3675: oPushResult
3676: oGetParam 1
3678: oPushResult
3679: LAST_ID
3680: oPushResult
3681: oCall 10385
3683: oPop 2
3685: oAssign
3686: oGetLocal 1
3688: oPushResult
3689: oGetLocal 2
3691: oPushResult
3692: oNodeVecAppend
3693: oPop 2
3695: oInputChoice 3701
3697: oInput 0
3699: oJumpForward 3706
3701: Choice Lookup Table
          13   3697
3704: oJumpForward 3708
3706: oJumpBack 3673
3708: oInput 12
3710: oGetAddrLocal 3
3712: oPushResult
3713: oCall 3963
3715: oPop 1
3717: oGetAddrLocal 4
3719: oPushResult
3720: oSetResult 0
3722: oAssign
3723: oGetLocal 4
3725: oPushResult
3726: oGetLocal 1
3728: oPushResult
3729: oNodeVecSize
3730: oPop 1
3732: oPushResult
3733: equal
3734: oPop 2
3736: oChoice 3777
3738: oGetAddrLocal 2
3740: oPushResult
3741: oGetLocal 1
3743: oPushResult
3744: oGetLocal 4
3746: oPushResult
3747: oNodeVecElement
3748: oPop 2
3750: oAssign
3751: oGetLocal 2
3753: oPushResult
3754: oSetResult 21
3756: oPushResult
3757: oGetLocal 3
3759: oPushResult
3760: oNodeSet
3761: oPop 3
3763: oGetLocal 2
3765: oPushResult
3766: oScopeDeclareAlloc
3767: oPop 1
3769: oGetAddrLocal 4
3771: oPushResult
3772: inc
3773: oPop 1
3775: oJumpForward 3782
3777: Choice Lookup Table
           0   3738
3780: oJumpForward 3784
3782: oJumpBack 3723
3784: oInputChoice 3877
3786: oGetLocal 1
3788: oPushResult
3789: oNodeVecSize
3790: oPop 1
3792: oChoice 3796
3794: oJumpForward 3801
3796: Choice Lookup Table
           1   3794
3799: oError 22
3801: oGetAddrLocal 5
3803: oPushResult
3804: oScopeCurrent
3805: oPushResult
3806: oCall 1906
3808: oPop 1
3810: oAssign
3811: oGetLocal 5
3813: oPushResult
3814: oCodePush
3815: oPop 1
3817: oGetAddrLocal 6
3819: oPushResult
3820: oSetResult 0
3822: oAssign
3823: oCall 10123
3825: oPushResult
3826: equal_zero
3827: oPop 1
3829: oChoice 3845
3831: oGetGlobal 3
3833: oPushResult
3834: oScopeEnter
3835: oPop 1
3837: oGetAddrLocal 6
3839: oPushResult
3840: oSetResult 1
3842: oAssign
3843: oJumpForward 3848
3845: Choice Lookup Table
           1   3831
3848: oGetLocal 2
3850: oPushResult
3851: oSetResult 1
3853: oPushResult
3854: oCall 9323
3856: oPop 2
3858: oCall 5092
3860: oCall 7840
3862: oCall 9079
3864: oGetLocal 6
3866: oChoice 3871
3868: oScopeEnd
3869: oJumpForward 3874
3871: Choice Lookup Table
           1   3868
3874: oCodePop
3875: oJumpForward 3880
3877: Choice Lookup Table
           6   3786
3880: oGetLocal 1
3882: oPushResult
3883: oNodeVecDelete
3884: oPop 1
3886: oInput 5
3888: oJumpForward 3895
3890: Choice Lookup Table
           0   3668
3893: oJumpForward 3897
3895: oJumpBack 3666
3897: oReturn
3898: oLocalSpace 2
3900: oInputChoice 3907
3902: oJumpForward 3913
3904: oChangeIntLitToLabelIdent
3905: oJumpForward 3913
3907: Choice Lookup Table
           1   3904
           0   3902
3912: oEndChoice
3913: oGetAddrLocal 1
3915: oPushResult
3916: oSetResult 25
3918: oPushResult
3919: LAST_ID
3920: oPushResult
3921: oCall 10385
3923: oPop 2
3925: oAssign
3926: oGetAddrLocal 2
3928: oPushResult
3929: oLabelNew
3930: oAssign
3931: oGetLocal 1
3933: oPushResult
3934: oSetResult 22
3936: oPushResult
3937: oGetLocal 2
3939: oPushResult
3940: oNodeSetLabel
3941: oPop 3
3943: oGetLocal 1
3945: oPushResult
3946: oScopeDeclare
3947: oPop 1
3949: oInputChoice 3953
3951: oJumpForward 3958
3953: Choice Lookup Table
          13   3951
3956: oJumpForward 3960
3958: oJumpBack 3900
3960: oInput 5
3962: oReturn
3963: oLocalSpace 12
3965: oInputChoice 4438
3967: oGetAddrLocal 1
3969: oPushResult
3970: oScopeFindRequire
3971: oAssign
3972: oGetAddrLocal 1
3974: oPushResult
3975: oCall 466
3977: oPop 1
3979: oGetLocal 1
3981: oPushResult
3982: oNodeType
3983: oPop 1
3985: oChoice 4002
3987: oGetParam 1
3989: oPushResult
3990: oGetLocal 1
3992: oPushResult
3993: oSetResult 21
3995: oPushResult
3996: oNodeGet
3997: oPop 2
3999: oAssign
4000: oJumpForward 4013
4002: Choice Lookup Table
          18   3987
4005: oError 2
4007: oGetParam 1
4009: oPushResult
4010: oGetGlobal 6
4012: oAssign
4013: oJumpForward 4457
4015: oInput 16
4017: oGetAddrLocal 2
4019: oPushResult
4020: oNodeVecNew
4021: oAssign
4022: oGetAddrLocal 3
4024: oPushResult
4025: oSetResult 36
4027: oPushResult
4028: oNodeNew
4029: oPop 1
4031: oAssign
4032: oGetLocal 3
4034: oPushResult
4035: oSetResult 36
4037: oPushResult
4038: oGetGlobal 6
4040: oPushResult
4041: oNodeSet
4042: oPop 3
4044: oCall 5019
4046: oGetLocal 3
4048: oPushResult
4049: oSetResult 38
4051: oPushResult
4052: oValueTop
4053: oPushResult
4054: oNodeSetInt
4055: oPop 3
4057: oValuePop
4058: oInput 21
4060: oCall 5019
4062: oGetLocal 3
4064: oPushResult
4065: oSetResult 39
4067: oPushResult
4068: oValueTop
4069: oPushResult
4070: oNodeSetInt
4071: oPop 3
4073: oValuePop
4074: oGetLocal 3
4076: oPushResult
4077: oSetResult 17
4079: oPushResult
4080: oSetResult 4
4082: oPushResult
4083: oNodeSetInt
4084: oPop 3
4086: oGetLocal 3
4088: oPushResult
4089: oTypeAdd
4090: oPop 1
4092: oGetAddrLocal 4
4094: oPushResult
4095: oSetResult 35
4097: oPushResult
4098: oNodeNew
4099: oPop 1
4101: oAssign
4102: oGetLocal 4
4104: oPushResult
4105: oSetResult 37
4107: oPushResult
4108: oGetLocal 3
4110: oPushResult
4111: oNodeSet
4112: oPop 3
4114: oGetLocal 2
4116: oPushResult
4117: oGetLocal 4
4119: oPushResult
4120: oNodeVecAppend
4121: oPop 2
4123: oInputChoice 4131
4125: oJumpForward 4139
4127: oJumpForward 4137
4129: oJumpForward 4137
4131: Choice Lookup Table
          13   4129
          17   4125
4136: oEndChoice
4137: oJumpBack 4022
4139: oInput 40
4141: oGetAddrLocal 5
4143: oPushResult
4144: oCall 3963
4146: oPop 1
4148: oGetAddrLocal 6
4150: oPushResult
4151: oGetLocal 2
4153: oPushResult
4154: oNodeVecSize
4155: oPop 1
4157: oAssign
4158: oGetAddrLocal 6
4160: oPushResult
4161: dec
4162: oPop 1
4164: oGetAddrLocal 7
4166: oPushResult
4167: oGetLocal 2
4169: oPushResult
4170: oGetLocal 6
4172: oPushResult
4173: oNodeVecElement
4174: oPop 2
4176: oAssign
4177: oGetLocal 7
4179: oPushResult
4180: oSetResult 36
4182: oPushResult
4183: oGetLocal 5
4185: oPushResult
4186: oNodeSet
4187: oPop 3
4189: oGetAddrLocal 8
4191: oPushResult
4192: oGetLocal 7
4194: oPushResult
4195: oSetResult 37
4197: oPushResult
4198: oNodeGet
4199: oPop 2
4201: oAssign
4202: oGetAddrLocal 9
4204: oPushResult
4205: oGetLocal 8
4207: oPushResult
4208: oSetResult 39
4210: oPushResult
4211: oNodeGetInt
4212: oPop 2
4214: oPushResult
4215: oGetLocal 8
4217: oPushResult
4218: oSetResult 38
4220: oPushResult
4221: oNodeGetInt
4222: oPop 2
4224: oPushResult
4225: subtract
4226: oPop 2
4228: oAssign
4229: oGetAddrLocal 9
4231: oPushResult
4232: inc
4233: oPop 1
4235: oGetLocal 7
4237: oPushResult
4238: oSetResult 17
4240: oPushResult
4241: oGetLocal 9
4243: oPushResult
4244: oGetLocal 5
4246: oPushResult
4247: oSetResult 17
4249: oPushResult
4250: oNodeGetInt
4251: oPop 2
4253: oPushResult
4254: multiply
4255: oPop 2
4257: oPushResult
4258: oNodeSetInt
4259: oPop 3
4261: oGetLocal 7
4263: oPushResult
4264: oTypeAdd
4265: oPop 1
4267: oGetAddrLocal 5
4269: oPushResult
4270: oGetLocal 7
4272: oAssign
4273: oGetLocal 6
4275: oPushResult
4276: equal_zero
4277: oPop 1
4279: oChoice 4285
4281: oJumpForward 4290
4283: oJumpForward 4288
4285: Choice Lookup Table
           1   4281
4288: oJumpBack 4158
4290: oGetParam 1
4292: oPushResult
4293: oGetLocal 2
4295: oPushResult
4296: oSetResult 0
4298: oPushResult
4299: oNodeVecElement
4300: oPop 2
4302: oAssign
4303: oGetLocal 2
4305: oPushResult
4306: oNodeVecDelete
4307: oPop 1
4309: oJumpForward 4457
4311: oGetAddrLocal 10
4313: oPushResult
4314: oCall 3963
4316: oPop 1
4318: oGetParam 1
4320: oPushResult
4321: oGetLocal 10
4323: oPushResult
4324: oCall 10413
4326: oPop 1
4328: oAssign
4329: oJumpForward 4457
4331: oGetParam 1
4333: oPushResult
4334: oSetResult 37
4336: oPushResult
4337: oNodeNew
4338: oPop 1
4340: oAssign
4341: oSetResult -1
4343: oPushResult
4344: oSetResult 2
4346: oPushResult
4347: oScopeBegin
4348: oPop 2
4350: oSetResult 22
4352: oPushResult
4353: oCall 3664
4355: oPop 1
4357: oGetAddrLocal 11
4359: oPushResult
4360: oScopeCurrent
4361: oPushResult
4362: oSetResult 17
4364: oPushResult
4365: oNodeGetInt
4366: oPop 2
4368: oAssign
4369: oGetLocal 11
4371: oPushResult
4372: equal_zero
4373: oPop 1
4375: oChoice 4381
4377: oError 19
4379: oJumpForward 4384
4381: Choice Lookup Table
           1   4377
4384: oInput 36
4386: oGetFromParam 1
4388: oPushResult
4389: oSetResult 40
4391: oPushResult
4392: oScopeCurrent
4393: oPushResult
4394: oNodeSet
4395: oPop 3
4397: oGetFromParam 1
4399: oPushResult
4400: oSetResult 17
4402: oPushResult
4403: oGetLocal 11
4405: oPushResult
4406: oNodeSetInt
4407: oPop 3
4409: oScopeEnd
4410: oGetFromParam 1
4412: oPushResult
4413: oTypeAdd
4414: oPop 1
4416: oJumpForward 4457
4418: oGetParam 1
4420: oPushResult
4421: oCall 4458
4423: oPop 1
4425: oJumpForward 4457
4427: oInput 40
4429: oGetAddrLocal 12
4431: oPushResult
4432: oCall 3963
4434: oPop 1
4436: oJumpForward 4457
4438: Choice Lookup Table
          39   4427
          14   4418
          38   4331
          18   4311
          37   4015
           0   3967
4451: oCall 5019
4453: oInput 21
4455: oCall 5019
4457: oReturn
4458: oLocalSpace 11
4460: oGetParam 1
4462: oPushResult
4463: oSetResult 39
4465: oPushResult
4466: oNodeNew
4467: oPop 1
4469: oAssign
4470: oGetAddrLocal 1
4472: oPushResult
4473: oSetResult 0
4475: oAssign
4476: oGetAddrLocal 2
4478: oPushResult
4479: oSetResult 0
4481: oAssign
4482: oGetAddrLocal 3
4484: oPushResult
4485: oSetResult 1
4487: oAssign
4488: oGetAddrLocal 4
4490: oPushResult
4491: oScopeCurrent
4492: oAssign
4493: oSetResult -1
4495: oPushResult
4496: oSetResult 2
4498: oPushResult
4499: oScopeBegin
4500: oPop 2
4502: oInput 0
4504: oGetAddrLocal 5
4506: oPushResult
4507: oSetResult 17
4509: oPushResult
4510: LAST_ID
4511: oPushResult
4512: oCall 10385
4514: oPop 2
4516: oAssign
4517: oGetAddrLocal 6
4519: oPushResult
4520: oSetResult 17
4522: oPushResult
4523: LAST_ID
4524: oPushResult
4525: oCall 10385
4527: oPop 2
4529: oAssign
4530: oGetLocal 5
4532: oPushResult
4533: oSetResult 21
4535: oPushResult
4536: oGetFromParam 1
4538: oPushResult
4539: oNodeSet
4540: oPop 3
4542: oGetLocal 6
4544: oPushResult
4545: oSetResult 21
4547: oPushResult
4548: oGetFromParam 1
4550: oPushResult
4551: oNodeSet
4552: oPop 3
4554: oGetAddrLocal 7
4556: oPushResult
4557: LAST_ID
4558: oPushResult
4559: ID_STRING
4560: oPop 1
4562: oPushResult
4563: oStringAllocLit
4564: oPop 1
4566: oAssign
4567: oGetLocal 5
4569: oPushResult
4570: oSetResult 32
4572: oPushResult
4573: oGetLocal 7
4575: oPushResult
4576: oNodeSetInt
4577: oPop 3
4579: oGetLocal 6
4581: oPushResult
4582: oSetResult 32
4584: oPushResult
4585: oGetLocal 7
4587: oPushResult
4588: oNodeSetInt
4589: oPop 3
4591: oInputChoice 4660
4593: oCall 5019
4595: oGetLocal 2
4597: oPushResult
4598: equal_zero
4599: oPop 1
4601: oChoice 4622
4603: oValueTop
4604: oPushResult
4605: oGetLocal 1
4607: oPushResult
4608: greater
4609: oPop 2
4611: oChoice 4617
4613: oError 26
4615: oJumpForward 4620
4617: Choice Lookup Table
           0   4613
4620: oJumpForward 4625
4622: Choice Lookup Table
           0   4603
4625: oGetLocal 1
4627: oPushResult
4628: oValueTop
4629: oPushResult
4630: equal
4631: oPop 2
4633: oChoice 4649
4635: oGetFromParam 1
4637: oPushResult
4638: oSetResult 43
4640: oPushResult
4641: oSetResult 1
4643: oPushResult
4644: oNodeSetBoolean
4645: oPop 3
4647: oJumpForward 4652
4649: Choice Lookup Table
           0   4635
4652: oGetAddrLocal 1
4654: oPushResult
4655: oValueTop
4656: oAssign
4657: oValuePop
4658: oJumpForward 4665
4660: Choice Lookup Table
           4   4593
           6   4593
4665: oGetLocal 5
4667: oPushResult
4668: oSetResult 22
4670: oPushResult
4671: oGetLocal 1
4673: oPushResult
4674: oNodeSetInt
4675: oPop 3
4677: oGetLocal 6
4679: oPushResult
4680: oSetResult 22
4682: oPushResult
4683: oGetLocal 1
4685: oPushResult
4686: oNodeSetInt
4687: oPop 3
4689: oGetLocal 5
4691: oPushResult
4692: oScopeDeclare
4693: oPop 1
4695: oGetLocal 4
4697: oPushResult
4698: oScopeEnter
4699: oPop 1
4701: oGetLocal 6
4703: oPushResult
4704: oScopeDeclare
4705: oPop 1
4707: oScopeEnd
4708: oGetAddrLocal 1
4710: oPushResult
4711: inc
4712: oPop 1
4714: oGetAddrLocal 2
4716: oPushResult
4717: inc
4718: oPop 1
4720: oInputChoice 4724
4722: oJumpForward 4729
4724: Choice Lookup Table
          13   4722
4727: oJumpForward 4731
4729: oJumpBack 4502
4731: oInput 15
4733: oGetFromParam 1
4735: oPushResult
4736: oSetResult 40
4738: oPushResult
4739: oScopeCurrent
4740: oPushResult
4741: oNodeSet
4742: oPop 3
4744: oGetFromParam 1
4746: oPushResult
4747: oSetResult 17
4749: oPushResult
4750: oSetResult 4
4752: oPushResult
4753: oNodeSetInt
4754: oPop 3
4756: oScopeEnd
4757: oGetGlobal 2
4759: oPushResult
4760: oCall 1906
4762: oPop 1
4764: oPushResult
4765: oCodePush
4766: oPop 1
4768: oGetGlobal 2
4770: oPushResult
4771: oScopeEnter
4772: oPop 1
4774: oGetAddrLocal 8
4776: oPushResult
4777: oGetLocal 2
4779: oPushResult
4780: oSetResult 1
4782: oPushResult
4783: add
4784: oPop 2
4786: oPushResult
4787: oSetResult 16
4789: oPushResult
4790: multiply
4791: oPop 2
4793: oAssign
4794: oGetAddrLocal 9
4796: oPushResult
4797: oGetLocal 8
4799: oPushResult
4800: oSetResult 8
4802: oPushResult
4803: oScopeAlloc
4804: oPop 2
4806: oAssign
4807: oScopeEnd
4808: oGetFromParam 1
4810: oPushResult
4811: oSetResult 42
4813: oPushResult
4814: oGetLocal 9
4816: oPushResult
4817: oNodeSetInt
4818: oPop 3
4820: oGetAddrLocal 10
4822: oPushResult
4823: oGetFromParam 1
4825: oPushResult
4826: oSetResult 40
4828: oPushResult
4829: oNodeGet
4830: oPop 2
4832: oPushResult
4833: oSetResult 15
4835: oPushResult
4836: oNodeGetIter
4837: oPop 2
4839: oAssign
4840: oGetAddrLocal 11
4842: oPushResult
4843: oGetLocal 10
4845: oPushResult
4846: oNodeIterValue
4847: oPop 1
4849: oAssign
4850: oGetLocal 11
4852: oPushResult
4853: oNodeNull
4854: oPop 1
4856: oChoice 4862
4858: oJumpForward 4949
4860: oJumpForward 4865
4862: Choice Lookup Table
           1   4858
4865: oEmit 16
4867: oGetLocal 9
4869: oPushResult
4870: oEmitInt
4871: oPop 1
4873: oEmit 15
4875: oGetLocal 11
4877: oPushResult
4878: oSetResult 22
4880: oPushResult
4881: oNodeGetInt
4882: oPop 2
4884: oPushResult
4885: oEmitInt
4886: oPop 1
4888: oEmit 25
4890: oGetAddrLocal 9
4892: oPushResult
4893: oGetLocal 9
4895: oPushResult
4896: oSetResult 8
4898: oPushResult
4899: add
4900: oPop 2
4902: oAssign
4903: oEmit 16
4905: oGetLocal 9
4907: oPushResult
4908: oEmitInt
4909: oPop 1
4911: oEmit 16
4913: oGetLocal 11
4915: oPushResult
4916: oSetResult 32
4918: oPushResult
4919: oNodeGetInt
4920: oPop 2
4922: oPushResult
4923: oEmitInt
4924: oPop 1
4926: oEmit 27
4928: oGetAddrLocal 9
4930: oPushResult
4931: oGetLocal 9
4933: oPushResult
4934: oSetResult 8
4936: oPushResult
4937: add
4938: oPop 2
4940: oAssign
4941: oGetAddrLocal 10
4943: oPushResult
4944: oNodeIterNext
4945: oPop 1
4947: oJumpBack 4840
4949: oEmit 16
4951: oGetLocal 9
4953: oPushResult
4954: oEmitInt
4955: oPop 1
4957: oEmit 15
4959: oSetResult 0
4961: oPushResult
4962: oEmitInt
4963: oPop 1
4965: oEmit 25
4967: oGetAddrLocal 9
4969: oPushResult
4970: oGetLocal 9
4972: oPushResult
4973: oSetResult 8
4975: oPushResult
4976: add
4977: oPop 2
4979: oAssign
4980: oEmit 16
4982: oGetLocal 9
4984: oPushResult
4985: oEmitInt
4986: oPop 1
4988: oEmit 15
4990: oSetResult 0
4992: oPushResult
4993: oEmitInt
4994: oPop 1
4996: oEmit 27
4998: oGetAddrLocal 9
5000: oPushResult
5001: oGetLocal 9
5003: oPushResult
5004: oSetResult 8
5006: oPushResult
5007: add
5008: oPop 2
5010: oAssign
5011: oCodePop
5012: oGetFromParam 1
5014: oPushResult
5015: oTypeAdd
5016: oPop 1
5018: oReturn
5019: oLocalSpace 1
5021: oInputChoice 5083
5023: TOKEN_VALUE
5024: oPushResult
5025: oValuePush
5026: oPop 1
5028: oJumpForward 5091
5030: oGetAddrLocal 1
5032: oPushResult
5033: oScopeFindRequire
5034: oAssign
5035: oGetAddrLocal 1
5037: oPushResult
5038: oCall 466
5040: oPop 1
5042: oGetLocal 1
5044: oPushResult
5045: oNodeType
5046: oPop 1
5048: oChoice 5065
5050: oGetLocal 1
5052: oPushResult
5053: oSetResult 22
5055: oPushResult
5056: oNodeGetInt
5057: oPop 2
5059: oPushResult
5060: oValuePush
5061: oPop 1
5063: oJumpForward 5076
5065: Choice Lookup Table
          16   5050
5068: oError 1
5070: oSetResult 0
5072: oPushResult
5073: oValuePush
5074: oPop 1
5076: oJumpForward 5091
5078: oCall 5019
5080: oValueNegate
5081: oJumpForward 5091
5083: Choice Lookup Table
          25   5078
           0   5030
           1   5023
5090: oEndChoice
5091: oReturn
5092: oLocalSpace 1
5094: oGetAddrLocal 1
5096: oPushResult
5097: oSetResult 0
5099: oAssign
5100: oGetAddrLocal 1
5102: oPushResult
5103: oCall 5253
5105: oPop 1
5107: oGetAddrLocal 1
5109: oPushResult
5110: oCall 5153
5112: oPop 1
5114: oReturn
5115: oLocalSpace 0
5117: oGetParam 1
5119: oPushResult
5120: oCall 5253
5122: oPop 1
5124: oTypeSNodeType
5125: oChoice 5144
5127: oJumpForward 5151
5129: oGetParam 1
5131: oPushResult
5132: oLabelNew
5133: oAssign
5134: oEmit 67
5136: oGetFromParam 1
5138: oPushResult
5139: oEmitLabel
5140: oPop 1
5142: oJumpForward 5151
5144: Choice Lookup Table
          30   5129
          31   5127
5149: oError 8
5151: oTypeSPop
5152: oReturn
5153: oLocalSpace 1
5155: oTypeSNodeType
5156: oChoice 5218
5158: oGetAddrLocal 1
5160: oPushResult
5161: oLabelNew
5162: oAssign
5163: oEmit 15
5165: oSetResult 1
5167: oPushResult
5168: oEmitInt
5169: oPop 1
5171: oEmit 65
5173: oGetLocal 1
5175: oPushResult
5176: oEmitLabel
5177: oPop 1
5179: oEmit 68
5181: oGetFromParam 1
5183: oPushResult
5184: oEmitLabel
5185: oPop 1
5187: oEmit 15
5189: oSetResult 0
5191: oPushResult
5192: oEmitInt
5193: oPop 1
5195: oEmit 68
5197: oGetLocal 1
5199: oPushResult
5200: oEmitLabel
5201: oPop 1
5203: oTypeSPop
5204: oGetGlobal 7
5206: oPushResult
5207: oTypeSPush
5208: oPop 1
5210: oGetParam 1
5212: oPushResult
5213: oSetResult 0
5215: oAssign
5216: oJumpForward 5221
5218: Choice Lookup Table
          31   5158
5221: oReturn
5222: oLocalSpace 0
5224: oTypeSNodeType
5225: oChoice 5249
5227: oGetParam 1
5229: oPushResult
5230: oLabelNew
5231: oAssign
5232: oEmit 67
5234: oGetFromParam 1
5236: oPushResult
5237: oEmitLabel
5238: oPop 1
5240: oTypeSPop
5241: oGetGlobal 8
5243: oPushResult
5244: oTypeSPush
5245: oPop 1
5247: oJumpForward 5252
5249: Choice Lookup Table
          30   5227
5252: oReturn
5253: oLocalSpace 0
5255: oGetParam 1
5257: oPushResult
5258: oCall 5714
5260: oPop 1
5262: oInputChoice 5696
5264: oGetParam 1
5266: oPushResult
5267: oCall 5153
5269: oPop 1
5271: oCall 10304
5273: oGetParam 1
5275: oPushResult
5276: oCall 5714
5278: oPop 1
5280: oGetParam 1
5282: oPushResult
5283: oCall 5153
5285: oPop 1
5287: oCall 10304
5289: oCall 10173
5291: oTypeSNodeType
5292: oChoice 5310
5294: oEmit 40
5296: oJumpForward 5327
5298: oEmit 46
5300: oJumpForward 5327
5302: oEmit 52
5304: oJumpForward 5327
5306: oError 16
5308: oJumpForward 5327
5310: Choice Lookup Table
          38   5306
          34   5302
          33   5302
          39   5298
          28   5298
          32   5294
          30   5294
5325: oError 17
5327: oTypeSPop
5328: oGetGlobal 7
5330: oPushResult
5331: oTypeSPush
5332: oPop 1
5334: oJumpForward 5711
5336: oGetParam 1
5338: oPushResult
5339: oCall 5153
5341: oPop 1
5343: oCall 10304
5345: oGetParam 1
5347: oPushResult
5348: oCall 5714
5350: oPop 1
5352: oGetParam 1
5354: oPushResult
5355: oCall 5153
5357: oPop 1
5359: oCall 10304
5361: oCall 10173
5363: oTypeSNodeType
5364: oChoice 5382
5366: oEmit 41
5368: oJumpForward 5399
5370: oEmit 47
5372: oJumpForward 5399
5374: oEmit 53
5376: oJumpForward 5399
5378: oError 16
5380: oJumpForward 5399
5382: Choice Lookup Table
          38   5378
          34   5374
          33   5374
          39   5370
          28   5370
          32   5366
          30   5366
5397: oError 17
5399: oTypeSPop
5400: oGetGlobal 7
5402: oPushResult
5403: oTypeSPush
5404: oPop 1
5406: oJumpForward 5711
5408: oGetParam 1
5410: oPushResult
5411: oCall 5153
5413: oPop 1
5415: oCall 10304
5417: oGetParam 1
5419: oPushResult
5420: oCall 5714
5422: oPop 1
5424: oGetParam 1
5426: oPushResult
5427: oCall 5153
5429: oPop 1
5431: oCall 10304
5433: oCall 10173
5435: oTypeSNodeType
5436: oChoice 5454
5438: oEmit 43
5440: oJumpForward 5471
5442: oEmit 49
5444: oJumpForward 5471
5446: oEmit 55
5448: oJumpForward 5471
5450: oError 16
5452: oJumpForward 5471
5454: Choice Lookup Table
          38   5450
          34   5446
          33   5446
          39   5442
          28   5442
          32   5438
          30   5438
5469: oError 17
5471: oTypeSPop
5472: oGetGlobal 7
5474: oPushResult
5475: oTypeSPush
5476: oPop 1
5478: oJumpForward 5711
5480: oGetParam 1
5482: oPushResult
5483: oCall 5153
5485: oPop 1
5487: oCall 10304
5489: oGetParam 1
5491: oPushResult
5492: oCall 5714
5494: oPop 1
5496: oGetParam 1
5498: oPushResult
5499: oCall 5153
5501: oPop 1
5503: oCall 10304
5505: oCall 10173
5507: oTypeSNodeType
5508: oChoice 5526
5510: oEmit 42
5512: oJumpForward 5543
5514: oEmit 48
5516: oJumpForward 5543
5518: oEmit 54
5520: oJumpForward 5543
5522: oError 16
5524: oJumpForward 5543
5526: Choice Lookup Table
          38   5522
          34   5518
          33   5518
          39   5514
          28   5514
          32   5510
          30   5510
5541: oError 17
5543: oTypeSPop
5544: oGetGlobal 7
5546: oPushResult
5547: oTypeSPush
5548: oPop 1
5550: oJumpForward 5711
5552: oGetParam 1
5554: oPushResult
5555: oCall 5153
5557: oPop 1
5559: oCall 10304
5561: oGetParam 1
5563: oPushResult
5564: oCall 5714
5566: oPop 1
5568: oGetParam 1
5570: oPushResult
5571: oCall 5153
5573: oPop 1
5575: oCall 10304
5577: oCall 10173
5579: oTypeSNodeType
5580: oChoice 5598
5582: oEmit 45
5584: oJumpForward 5615
5586: oEmit 51
5588: oJumpForward 5615
5590: oEmit 57
5592: oJumpForward 5615
5594: oError 16
5596: oJumpForward 5615
5598: Choice Lookup Table
          38   5594
          34   5590
          33   5590
          39   5586
          28   5586
          32   5582
          30   5582
5613: oError 17
5615: oTypeSPop
5616: oGetGlobal 7
5618: oPushResult
5619: oTypeSPush
5620: oPop 1
5622: oJumpForward 5711
5624: oGetParam 1
5626: oPushResult
5627: oCall 5153
5629: oPop 1
5631: oCall 10304
5633: oGetParam 1
5635: oPushResult
5636: oCall 5714
5638: oPop 1
5640: oGetParam 1
5642: oPushResult
5643: oCall 5153
5645: oPop 1
5647: oCall 10304
5649: oCall 10173
5651: oTypeSNodeType
5652: oChoice 5670
5654: oEmit 44
5656: oJumpForward 5687
5658: oEmit 50
5660: oJumpForward 5687
5662: oEmit 56
5664: oJumpForward 5687
5666: oError 16
5668: oJumpForward 5687
5670: Choice Lookup Table
          38   5666
          34   5662
          33   5662
          39   5658
          28   5658
          32   5654
          30   5654
5685: oError 17
5687: oTypeSPop
5688: oGetGlobal 7
5690: oPushResult
5691: oTypeSPush
5692: oPop 1
5694: oJumpForward 5711
5696: Choice Lookup Table
          11   5624
          10   5552
           9   5480
           8   5408
           7   5336
           6   5264
5709: oJumpForward 5713
5711: oJumpBack 5262
5713: oReturn
5714: oLocalSpace 1
5716: oGetAddrLocal 1
5718: oPushResult
5719: oSetResult 0
5721: oAssign
5722: oGetParam 1
5724: oPushResult
5725: oCall 5894
5727: oPop 1
5729: oInputChoice 5862
5731: oTypeSNodeType
5732: oChoice 5803
5734: oGetLocal 1
5736: oPushResult
5737: oSetResult 0
5739: oPushResult
5740: equal_label
5741: oPop 2
5743: oChoice 5752
5745: oGetAddrLocal 1
5747: oPushResult
5748: oLabelNew
5749: oAssign
5750: oJumpForward 5755
5752: Choice Lookup Table
           1   5745
5755: oEmit 65
5757: oGetLocal 1
5759: oPushResult
5760: oEmitLabel
5761: oPop 1
5763: oJumpForward 5810
5765: oGetParam 1
5767: oPushResult
5768: oCall 5222
5770: oPop 1
5772: oGetLocal 1
5774: oPushResult
5775: oSetResult 0
5777: oPushResult
5778: equal_label
5779: oPop 2
5781: oChoice 5790
5783: oGetAddrLocal 1
5785: oPushResult
5786: oLabelNew
5787: oAssign
5788: oJumpForward 5793
5790: Choice Lookup Table
           1   5783
5793: oEmit 65
5795: oGetLocal 1
5797: oPushResult
5798: oEmitLabel
5799: oPop 1
5801: oJumpForward 5810
5803: Choice Lookup Table
          30   5765
          31   5734
5808: oError 8
5810: oTypeSPop
5811: oEmit 68
5813: oGetFromParam 1
5815: oPushResult
5816: oEmitLabel
5817: oPop 1
5819: oGetParam 1
5821: oPushResult
5822: oSetResult 0
5824: oAssign
5825: oGetParam 1
5827: oPushResult
5828: oCall 5894
5830: oPop 1
5832: oTypeSNodeType
5833: oChoice 5846
5835: oJumpForward 5853
5837: oGetParam 1
5839: oPushResult
5840: oCall 5222
5842: oPop 1
5844: oJumpForward 5853
5846: Choice Lookup Table
          30   5837
          31   5835
5851: oError 8
5853: oTypeSPop
5854: oGetGlobal 8
5856: oPushResult
5857: oTypeSPush
5858: oPop 1
5860: oJumpForward 5867
5862: Choice Lookup Table
          55   5731
5865: oJumpForward 5869
5867: oJumpBack 5729
5869: oGetLocal 1
5871: oPushResult
5872: oSetResult 0
5874: oPushResult
5875: equal_label
5876: oPop 2
5878: oChoice 5890
5880: oEmit 68
5882: oGetLocal 1
5884: oPushResult
5885: oEmitLabel
5886: oPop 1
5888: oJumpForward 5893
5890: Choice Lookup Table
           0   5880
5893: oReturn
5894: oLocalSpace 2
5896: oGetAddrLocal 1
5898: oPushResult
5899: oSetResult 0
5901: oAssign
5902: oGetParam 1
5904: oPushResult
5905: oCall 6032
5907: oPop 1
5909: oInputChoice 6024
5911: oTypeSNodeType
5912: oChoice 5925
5914: oJumpForward 5932
5916: oGetParam 1
5918: oPushResult
5919: oCall 5222
5921: oPop 1
5923: oJumpForward 5932
5925: Choice Lookup Table
          30   5916
          31   5914
5930: oError 8
5932: oTypeSPop
5933: oGetLocal 1
5935: oPushResult
5936: oSetResult 0
5938: oPushResult
5939: equal_label
5940: oPop 2
5942: oChoice 5971
5944: oGetAddrLocal 1
5946: oPushResult
5947: oLabelNew
5948: oAssign
5949: oEmit 69
5951: oGetFromParam 1
5953: oPushResult
5954: oEmitLabel
5955: oPop 1
5957: oGetLocal 1
5959: oPushResult
5960: oEmitLabel
5961: oPop 1
5963: oGetParam 1
5965: oPushResult
5966: oGetLocal 1
5968: oAssign
5969: oJumpForward 5974
5971: Choice Lookup Table
           1   5944
5974: oGetAddrLocal 2
5976: oPushResult
5977: oSetResult 0
5979: oAssign
5980: oGetAddrLocal 2
5982: oPushResult
5983: oCall 6032
5985: oPop 1
5987: oTypeSNodeType
5988: oChoice 6001
5990: oJumpForward 6008
5992: oGetAddrLocal 2
5994: oPushResult
5995: oCall 5222
5997: oPop 1
5999: oJumpForward 6008
6001: Choice Lookup Table
          30   5992
          31   5990
6006: oError 8
6008: oEmit 69
6010: oGetLocal 2
6012: oPushResult
6013: oEmitLabel
6014: oPop 1
6016: oGetLocal 1
6018: oPushResult
6019: oEmitLabel
6020: oPop 1
6022: oJumpForward 6029
6024: Choice Lookup Table
          54   5911
6027: oJumpForward 6031
6029: oJumpBack 5909
6031: oReturn
6032: oLocalSpace 1
6034: oInputChoice 6088
6036: oGetAddrLocal 1
6038: oPushResult
6039: oSetResult 0
6041: oAssign
6042: oGetAddrLocal 1
6044: oPushResult
6045: oCall 6032
6047: oPop 1
6049: oTypeSNodeType
6050: oChoice 6079
6052: oGetParam 1
6054: oPushResult
6055: oLabelNew
6056: oAssign
6057: oEmit 65
6059: oGetFromParam 1
6061: oPushResult
6062: oEmitLabel
6063: oPop 1
6065: oEmit 68
6067: oGetLocal 1
6069: oPushResult
6070: oEmitLabel
6071: oPop 1
6073: oJumpForward 6086
6075: oEmit 39
6077: oJumpForward 6086
6079: Choice Lookup Table
          30   6075
          31   6052
6084: oError 8
6086: oJumpForward 6098
6088: Choice Lookup Table
          56   6036
6091: oGetParam 1
6093: oPushResult
6094: oCall 6099
6096: oPop 1
6098: oReturn
6099: oLocalSpace 2
6101: oGetParam 1
6103: oPushResult
6104: oCall 6238
6106: oPop 1
6108: oInputChoice 6228
6110: oTypeSNodeType
6111: oChoice 6196
6113: oCall 10258
6115: oGetParam 1
6117: oPushResult
6118: oCall 6238
6120: oPop 1
6122: oCall 10278
6124: oEmit 36
6126: oJumpForward 6211
6128: oError 16
6130: oJumpForward 6211
6132: oGetAddrLocal 1
6134: oPushResult
6135: oTypeSTop
6136: oPushResult
6137: oSetResult 36
6139: oPushResult
6140: oNodeGet
6141: oPop 2
6143: oAssign
6144: oGetAddrLocal 2
6146: oPushResult
6147: oGetLocal 1
6149: oPushResult
6150: oSetResult 17
6152: oPushResult
6153: oNodeGetInt
6154: oPop 2
6156: oAssign
6157: oGetParam 1
6159: oPushResult
6160: oCall 6238
6162: oPop 1
6164: oCall 10258
6166: oGetLocal 2
6168: oPushResult
6169: oSetResult 1
6171: oPushResult
6172: equal
6173: oPop 2
6175: oChoice 6189
6177: oEmit 15
6179: oGetLocal 2
6181: oPushResult
6182: oEmitInt
6183: oPop 1
6185: oEmit 33
6187: oJumpForward 6192
6189: Choice Lookup Table
           0   6177
6192: oEmit 35
6194: oJumpForward 6211
6196: Choice Lookup Table
          34   6132
          33   6132
          32   6128
          38   6128
          29   6113
          28   6113
6209: oError 17
6211: oJumpForward 6235
6213: oCall 10258
6215: oGetParam 1
6217: oPushResult
6218: oCall 6238
6220: oPop 1
6222: oCall 10278
6224: oEmit 37
6226: oJumpForward 6235
6228: Choice Lookup Table
          25   6213
          24   6110
6233: oJumpForward 6237
6235: oJumpBack 6108
6237: oReturn
6238: oLocalSpace 0
6240: oGetParam 1
6242: oPushResult
6243: oCall 6289
6245: oPop 1
6247: oInputChoice 6279
6249: oCall 10258
6251: oGetParam 1
6253: oPushResult
6254: oCall 6289
6256: oPop 1
6258: oCall 10278
6260: oEmit 33
6262: oJumpForward 6286
6264: oCall 10258
6266: oGetParam 1
6268: oPushResult
6269: oCall 6289
6271: oPop 1
6273: oCall 10278
6275: oEmit 34
6277: oJumpForward 6286
6279: Choice Lookup Table
          23   6264
          22   6249
6284: oJumpForward 6288
6286: oJumpBack 6247
6288: oReturn
6289: oLocalSpace 0
6291: oInputChoice 6317
6293: oGetParam 1
6295: oPushResult
6296: oCall 6330
6298: oPop 1
6300: oCall 10278
6302: oJumpForward 6329
6304: oGetParam 1
6306: oPushResult
6307: oCall 6330
6309: oPop 1
6311: oCall 10278
6313: oEmit 38
6315: oJumpForward 6329
6317: Choice Lookup Table
          25   6304
          24   6293
6322: oGetParam 1
6324: oPushResult
6325: oCall 6330
6327: oPop 1
6329: oReturn
6330: oLocalSpace 6
6332: oInputChoice 6571
6334: oEmit 15
6336: TOKEN_VALUE
6337: oPushResult
6338: oEmitInt
6339: oPop 1
6341: oGetGlobal 6
6343: oPushResult
6344: oTypeSPush
6345: oPop 1
6347: oJumpForward 6592
6349: oEmit 15
6351: TOKEN_VALUE
6352: oPushResult
6353: oEmitInt
6354: oPop 1
6356: oGetGlobal 9
6358: oPushResult
6359: oTypeSPush
6360: oPop 1
6362: oJumpForward 6592
6364: oGetParam 1
6366: oPushResult
6367: oCall 5253
6369: oPop 1
6371: oInput 15
6373: oJumpForward 6592
6375: oGetAddrLocal 1
6377: oPushResult
6378: CURRENT_STRLIT
6379: oPushResult
6380: oStringAllocShortStringLit
6381: oPop 1
6383: oAssign
6384: oEmit 16
6386: oGetLocal 1
6388: oPushResult
6389: oEmitInt
6390: oPop 1
6392: oGetGlobal 13
6394: oPushResult
6395: oTypeSPush
6396: oPop 1
6398: oCall 7402
6400: oCall 7350
6402: oJumpForward 6592
6404: oGetAddrLocal 2
6406: oPushResult
6407: oScopeFindRequire
6408: oAssign
6409: oGetAddrLocal 2
6411: oPushResult
6412: oCall 466
6414: oPop 1
6416: oGetLocal 2
6418: oPushResult
6419: oNodeType
6420: oPop 1
6422: oChoice 6495
6424: oGetLocal 2
6426: oPushResult
6427: oCall 8014
6429: oPop 1
6431: oJumpForward 6520
6433: oGetLocal 2
6435: oPushResult
6436: oCall 8634
6438: oPop 1
6440: oJumpForward 6520
6442: oGetAddrLocal 3
6444: oPushResult
6445: oGetLocal 2
6447: oPushResult
6448: oSetResult 21
6450: oPushResult
6451: oNodeGet
6452: oPop 2
6454: oAssign
6455: oGetLocal 3
6457: oPushResult
6458: oTypeSPush
6459: oPop 1
6461: oTypeSNodeType
6462: oChoice 6475
6464: oEmit 15
6466: oGetLocal 2
6468: oPushResult
6469: oCall 10687
6471: oPop 1
6473: oJumpForward 6484
6475: Choice Lookup Table
          30   6464
          39   6464
          28   6464
6482: oError 16
6484: oJumpForward 6520
6486: oGetLocal 2
6488: oPushResult
6489: oCall 6593
6491: oPop 1
6493: oJumpForward 6520
6495: Choice Lookup Table
          24   6486
          23   6486
          21   6486
          20   6486
          17   6442
          16   6442
          14   6433
          13   6424
6512: oError 6
6514: oGetGlobal 6
6516: oPushResult
6517: oTypeSPush
6518: oPop 1
6520: oJumpForward 6592
6522: oInput 0
6524: oGetAddrLocal 4
6526: oPushResult
6527: oScopeFindRequire
6528: oAssign
6529: oGetAddrLocal 4
6531: oPushResult
6532: oCall 466
6534: oPop 1
6536: oGetLocal 4
6538: oPushResult
6539: oSetResult 0
6541: oPushResult
6542: oCall 9323
6544: oPop 2
6546: oGetAddrLocal 5
6548: oPushResult
6549: oTypeSTop
6550: oAssign
6551: oTypeSPop
6552: oGetAddrLocal 6
6554: oPushResult
6555: oGetLocal 5
6557: oPushResult
6558: oCall 10413
6560: oPop 1
6562: oAssign
6563: oGetLocal 6
6565: oPushResult
6566: oTypeSPush
6567: oPop 1
6569: oJumpForward 6592
6571: Choice Lookup Table
          19   6522
           0   6404
           2   6375
          14   6364
           3   6349
           1   6334
6584: oError 6
6586: oGetGlobal 6
6588: oPushResult
6589: oTypeSPush
6590: oPop 1
6592: oReturn
6593: oLocalSpace 2
6595: oGetAddrLocal 1
6597: oPushResult
6598: oGetParam 1
6600: oPushResult
6601: oSetResult 21
6603: oPushResult
6604: oNodeGet
6605: oPop 2
6607: oAssign
6608: oGetAddrLocal 2
6610: oPushResult
6611: oGetParam 1
6613: oPushResult
6614: oCall 10155
6616: oPop 1
6618: oAssign
6619: oGetLocal 1
6621: oPushResult
6622: oTypeSPush
6623: oPop 1
6625: oTypeSNodeType
6626: oChoice 7325
6628: oGetParam 1
6630: oPushResult
6631: oNodeType
6632: oPop 1
6634: oChoice 6780
6636: oEmit 0
6638: oGetParam 1
6640: oPushResult
6641: oCall 10687
6643: oPop 1
6645: oJumpForward 6790
6647: oGetLocal 2
6649: oPushResult
6650: equal_zero
6651: oPop 1
6653: oChoice 6666
6655: oEmit 3
6657: oGetParam 1
6659: oPushResult
6660: oCall 10687
6662: oPop 1
6664: oJumpForward 6684
6666: Choice Lookup Table
           1   6655
6669: oEmit 9
6671: oGetLocal 2
6673: oPushResult
6674: oEmitInt
6675: oPop 1
6677: oGetParam 1
6679: oPushResult
6680: oCall 10687
6682: oPop 1
6684: oJumpForward 6790
6686: oGetParam 1
6688: oPushResult
6689: oSetResult 33
6691: oPushResult
6692: oNodeGetBoolean
6693: oPop 2
6695: oChoice 6738
6697: oGetLocal 2
6699: oPushResult
6700: equal_zero
6701: oPop 1
6703: oChoice 6716
6705: oEmit 8
6707: oGetParam 1
6709: oPushResult
6710: oCall 10687
6712: oPop 1
6714: oJumpForward 6734
6716: Choice Lookup Table
           1   6705
6719: oEmit 14
6721: oGetLocal 2
6723: oPushResult
6724: oEmitInt
6725: oPop 1
6727: oGetParam 1
6729: oPushResult
6730: oCall 10687
6732: oPop 1
6734: oEmit 22
6736: oJumpForward 6778
6738: Choice Lookup Table
           1   6697
6741: oGetLocal 2
6743: oPushResult
6744: equal_zero
6745: oPop 1
6747: oChoice 6760
6749: oEmit 6
6751: oGetParam 1
6753: oPushResult
6754: oCall 10687
6756: oPop 1
6758: oJumpForward 6778
6760: Choice Lookup Table
           1   6749
6763: oEmit 12
6765: oGetLocal 2
6767: oPushResult
6768: oEmitInt
6769: oPop 1
6771: oGetParam 1
6773: oPushResult
6774: oCall 10687
6776: oPop 1
6778: oJumpForward 6790
6780: Choice Lookup Table
          23   6686
          21   6647
          24   6636
          20   6636
6789: oEndChoice
6790: oJumpForward 7349
6792: oGetParam 1
6794: oPushResult
6795: oNodeType
6796: oPop 1
6798: oChoice 6944
6800: oEmit 1
6802: oGetParam 1
6804: oPushResult
6805: oCall 10687
6807: oPop 1
6809: oJumpForward 6954
6811: oGetLocal 2
6813: oPushResult
6814: equal_zero
6815: oPop 1
6817: oChoice 6830
6819: oEmit 4
6821: oGetParam 1
6823: oPushResult
6824: oCall 10687
6826: oPop 1
6828: oJumpForward 6848
6830: Choice Lookup Table
           1   6819
6833: oEmit 10
6835: oGetLocal 2
6837: oPushResult
6838: oEmitInt
6839: oPop 1
6841: oGetParam 1
6843: oPushResult
6844: oCall 10687
6846: oPop 1
6848: oJumpForward 6954
6850: oGetParam 1
6852: oPushResult
6853: oSetResult 33
6855: oPushResult
6856: oNodeGetBoolean
6857: oPop 2
6859: oChoice 6902
6861: oGetLocal 2
6863: oPushResult
6864: equal_zero
6865: oPop 1
6867: oChoice 6880
6869: oEmit 8
6871: oGetParam 1
6873: oPushResult
6874: oCall 10687
6876: oPop 1
6878: oJumpForward 6898
6880: Choice Lookup Table
           1   6869
6883: oEmit 14
6885: oGetLocal 2
6887: oPushResult
6888: oEmitInt
6889: oPop 1
6891: oGetParam 1
6893: oPushResult
6894: oCall 10687
6896: oPop 1
6898: oEmit 23
6900: oJumpForward 6942
6902: Choice Lookup Table
           1   6861
6905: oGetLocal 2
6907: oPushResult
6908: equal_zero
6909: oPop 1
6911: oChoice 6924
6913: oEmit 7
6915: oGetParam 1
6917: oPushResult
6918: oCall 10687
6920: oPop 1
6922: oJumpForward 6942
6924: Choice Lookup Table
           1   6913
6927: oEmit 13
6929: oGetLocal 2
6931: oPushResult
6932: oEmitInt
6933: oPop 1
6935: oGetParam 1
6937: oPushResult
6938: oCall 10687
6940: oPop 1
6942: oJumpForward 6954
6944: Choice Lookup Table
          23   6850
          21   6811
          24   6800
          20   6800
6953: oEndChoice
6954: oJumpForward 7349
6956: oError 16
6958: oJumpForward 7349
6960: oGetParam 1
6962: oPushResult
6963: oNodeType
6964: oPop 1
6966: oChoice 7112
6968: oEmit 2
6970: oGetParam 1
6972: oPushResult
6973: oCall 10687
6975: oPop 1
6977: oJumpForward 7122
6979: oGetLocal 2
6981: oPushResult
6982: equal_zero
6983: oPop 1
6985: oChoice 6998
6987: oEmit 5
6989: oGetParam 1
6991: oPushResult
6992: oCall 10687
6994: oPop 1
6996: oJumpForward 7016
6998: Choice Lookup Table
           1   6987
7001: oEmit 11
7003: oGetLocal 2
7005: oPushResult
7006: oEmitInt
7007: oPop 1
7009: oGetParam 1
7011: oPushResult
7012: oCall 10687
7014: oPop 1
7016: oJumpForward 7122
7018: oGetParam 1
7020: oPushResult
7021: oSetResult 33
7023: oPushResult
7024: oNodeGetBoolean
7025: oPop 2
7027: oChoice 7070
7029: oGetLocal 2
7031: oPushResult
7032: equal_zero
7033: oPop 1
7035: oChoice 7048
7037: oEmit 8
7039: oGetParam 1
7041: oPushResult
7042: oCall 10687
7044: oPop 1
7046: oJumpForward 7066
7048: Choice Lookup Table
           1   7037
7051: oEmit 14
7053: oGetLocal 2
7055: oPushResult
7056: oEmitInt
7057: oPop 1
7059: oGetParam 1
7061: oPushResult
7062: oCall 10687
7064: oPop 1
7066: oEmit 24
7068: oJumpForward 7110
7070: Choice Lookup Table
           1   7029
7073: oGetLocal 2
7075: oPushResult
7076: equal_zero
7077: oPop 1
7079: oChoice 7092
7081: oEmit 8
7083: oGetParam 1
7085: oPushResult
7086: oCall 10687
7088: oPop 1
7090: oJumpForward 7110
7092: Choice Lookup Table
           1   7081
7095: oEmit 14
7097: oGetLocal 2
7099: oPushResult
7100: oEmitInt
7101: oPop 1
7103: oGetParam 1
7105: oPushResult
7106: oCall 10687
7108: oPop 1
7110: oJumpForward 7122
7112: Choice Lookup Table
          23   7018
          21   6979
          24   6968
          20   6968
7121: oEndChoice
7122: oInputChoice 7152
7124: oTypeSPop
7125: oGetLocal 1
7127: oPushResult
7128: oSetResult 36
7130: oPushResult
7131: oNodeGet
7132: oPop 2
7134: oPushResult
7135: oTypeSPush
7136: oPop 1
7138: oCall 7402
7140: oCall 7350
7142: oJumpForward 7157
7144: oCall 7595
7146: oCall 7402
7148: oCall 7350
7150: oJumpForward 7157
7152: Choice Lookup Table
          16   7144
          18   7124
7157: oJumpForward 7349
7159: oGetParam 1
7161: oPushResult
7162: oNodeType
7163: oPop 1
7165: oChoice 7309
7167: oEmit 16
7169: oGetParam 1
7171: oPushResult
7172: oCall 10687
7174: oPop 1
7176: oJumpForward 7319
7178: oGetLocal 2
7180: oPushResult
7181: equal_zero
7182: oPop 1
7184: oChoice 7197
7186: oEmit 17
7188: oGetParam 1
7190: oPushResult
7191: oCall 10687
7193: oPop 1
7195: oJumpForward 7215
7197: Choice Lookup Table
           1   7186
7200: oEmit 20
7202: oGetLocal 2
7204: oPushResult
7205: oEmitInt
7206: oPop 1
7208: oGetParam 1
7210: oPushResult
7211: oCall 10687
7213: oPop 1
7215: oJumpForward 7319
7217: oGetParam 1
7219: oPushResult
7220: oSetResult 33
7222: oPushResult
7223: oNodeGetBoolean
7224: oPop 2
7226: oChoice 7267
7228: oGetLocal 2
7230: oPushResult
7231: equal_zero
7232: oPop 1
7234: oChoice 7247
7236: oEmit 8
7238: oGetParam 1
7240: oPushResult
7241: oCall 10687
7243: oPop 1
7245: oJumpForward 7265
7247: Choice Lookup Table
           1   7236
7250: oEmit 14
7252: oGetLocal 2
7254: oPushResult
7255: oEmitInt
7256: oPop 1
7258: oGetParam 1
7260: oPushResult
7261: oCall 10687
7263: oPop 1
7265: oJumpForward 7307
7267: Choice Lookup Table
           1   7228
7270: oGetLocal 2
7272: oPushResult
7273: equal_zero
7274: oPop 1
7276: oChoice 7289
7278: oEmit 18
7280: oGetParam 1
7282: oPushResult
7283: oCall 10687
7285: oPop 1
7287: oJumpForward 7307
7289: Choice Lookup Table
           1   7278
7292: oEmit 21
7294: oGetLocal 2
7296: oPushResult
7297: oEmitInt
7298: oPop 1
7300: oGetParam 1
7302: oPushResult
7303: oCall 10687
7305: oPop 1
7307: oJumpForward 7319
7309: Choice Lookup Table
          23   7217
          21   7178
          24   7167
          20   7167
7318: oEndChoice
7319: oCall 7402
7321: oCall 7350
7323: oJumpForward 7349
7325: Choice Lookup Table
          38   7159
          37   7159
          35   7159
          34   6960
          33   6960
          27   6956
          32   6792
          29   6792
          30   6792
          39   6628
          28   6628
7348: oEndChoice
7349: oReturn
7350: oLocalSpace 0
7352: oTypeSNodeType
7353: oChoice 7377
7355: oEmit 22
7357: oJumpForward 7401
7359: oEmit 23
7361: oJumpForward 7401
7363: oError 16
7365: oJumpForward 7401
7367: oEmit 24
7369: oJumpForward 7401
7371: oError 29
7373: oJumpForward 7401
7375: oJumpForward 7401
7377: Choice Lookup Table
          38   7375
          37   7375
          35   7375
          34   7371
          33   7367
          27   7363
          32   7359
          29   7359
          30   7359
          39   7355
          28   7355
7400: oEndChoice
7401: oReturn
7402: oLocalSpace 0
7404: oInputChoice 7440
7406: oTypeSNodeType
7407: oChoice 7421
7409: oCall 7452
7411: oJumpForward 7430
7413: oCall 7595
7415: oJumpForward 7430
7417: oCall 7674
7419: oJumpForward 7430
7421: Choice Lookup Table
          38   7417
          33   7413
          35   7409
7428: oError 10
7430: oJumpForward 7449
7432: oCall 7702
7434: oJumpForward 7449
7436: oCall 7800
7438: oJumpForward 7449
7440: Choice Lookup Table
          18   7436
          20   7432
          16   7406
7447: oJumpForward 7451
7449: oJumpBack 7404
7451: oReturn
7452: oLocalSpace 3
7454: oTypeSNodeType
7455: oChoice 7459
7457: oJumpForward 7464
7459: Choice Lookup Table
          35   7457
7462: oError 10
7464: oTypeSNodeType
7465: oChoice 7469
7467: oJumpForward 7474
7469: Choice Lookup Table
          35   7467
7472: oError 13
7474: oGetAddrLocal 1
7476: oPushResult
7477: oTypeSTop
7478: oPushResult
7479: oSetResult 37
7481: oPushResult
7482: oNodeGet
7483: oPop 2
7485: oPushResult
7486: oCall 10497
7488: oPop 1
7490: oAssign
7491: oGetAddrLocal 2
7493: oPushResult
7494: oTypeSTop
7495: oPushResult
7496: oSetResult 36
7498: oPushResult
7499: oNodeGet
7500: oPop 2
7502: oAssign
7503: oTypeSPop
7504: oGetLocal 2
7506: oPushResult
7507: oTypeSPush
7508: oPop 1
7510: oCall 5092
7512: oCall 10231
7514: oGetLocal 1
7516: oPushResult
7517: equal_zero
7518: oPop 1
7520: oChoice 7534
7522: oEmit 15
7524: oGetLocal 1
7526: oPushResult
7527: oEmitInt
7528: oPop 1
7530: oEmit 37
7532: oJumpForward 7537
7534: Choice Lookup Table
           0   7522
7537: oGetAddrLocal 3
7539: oPushResult
7540: oGetLocal 2
7542: oPushResult
7543: oSetResult 17
7545: oPushResult
7546: oNodeGetInt
7547: oPop 2
7549: oAssign
7550: oGetLocal 3
7552: oPushResult
7553: oSetResult 1
7555: oPushResult
7556: equal
7557: oPop 2
7559: oChoice 7573
7561: oEmit 15
7563: oGetLocal 3
7565: oPushResult
7566: oEmitInt
7567: oPop 1
7569: oEmit 33
7571: oJumpForward 7576
7573: Choice Lookup Table
           0   7561
7576: oEmit 35
7578: oInputChoice 7586
7580: oJumpForward 7594
7582: oJumpForward 7592
7584: oJumpForward 7592
7586: Choice Lookup Table
          13   7584
          17   7580
7591: oEndChoice
7592: oJumpBack 7464
7594: oReturn
7595: oLocalSpace 2
7597: oTypeSNodeType
7598: oChoice 7602
7600: oJumpForward 7607
7602: Choice Lookup Table
          33   7600
7605: oError 29
7607: oGetAddrLocal 1
7609: oPushResult
7610: oTypeSTop
7611: oPushResult
7612: oSetResult 36
7614: oPushResult
7615: oNodeGet
7616: oPop 2
7618: oAssign
7619: oTypeSPop
7620: oGetLocal 1
7622: oPushResult
7623: oTypeSPush
7624: oPop 1
7626: oCall 5092
7628: oCall 10231
7630: oGetAddrLocal 2
7632: oPushResult
7633: oGetLocal 1
7635: oPushResult
7636: oSetResult 17
7638: oPushResult
7639: oNodeGetInt
7640: oPop 2
7642: oAssign
7643: oGetLocal 2
7645: oPushResult
7646: oSetResult 1
7648: oPushResult
7649: equal
7650: oPop 2
7652: oChoice 7666
7654: oEmit 15
7656: oGetLocal 2
7658: oPushResult
7659: oEmitInt
7660: oPop 1
7662: oEmit 33
7664: oJumpForward 7669
7666: Choice Lookup Table
           0   7654
7669: oEmit 35
7671: oInput 17
7673: oReturn
7674: oLocalSpace 0
7676: oTypeSNodeType
7677: oChoice 7681
7679: oJumpForward 7686
7681: Choice Lookup Table
          38   7679
7684: oError 29
7686: oTypeSPop
7687: oGetGlobal 9
7689: oPushResult
7690: oTypeSPush
7691: oPop 1
7693: oCall 5092
7695: oCall 10231
7697: oEmit 35
7699: oInput 17
7701: oReturn
7702: oLocalSpace 2
7704: oTypeSNodeType
7705: oChoice 7709
7707: oJumpForward 7714
7709: Choice Lookup Table
          37   7707
7712: oError 11
7714: oTypeSTop
7715: oPushResult
7716: oSetResult 40
7718: oPushResult
7719: oNodeGet
7720: oPop 2
7722: oPushResult
7723: oScopeEnter
7724: oPop 1
7726: oInput 0
7728: oGetAddrLocal 1
7730: oPushResult
7731: oScopeFindRequire
7732: oAssign
7733: oGetLocal 1
7735: oPushResult
7736: oNodeType
7737: oPop 1
7739: oChoice 7743
7741: oJumpForward 7748
7743: Choice Lookup Table
          22   7741
7746: oError 12
7748: oScopeEnd
7749: oGetAddrLocal 2
7751: oPushResult
7752: oGetLocal 1
7754: oPushResult
7755: oSetResult 22
7757: oPushResult
7758: oNodeGetInt
7759: oPop 2
7761: oAssign
7762: oGetLocal 2
7764: oPushResult
7765: equal_zero
7766: oPop 1
7768: oChoice 7782
7770: oEmit 15
7772: oGetLocal 2
7774: oPushResult
7775: oEmitInt
7776: oPop 1
7778: oEmit 35
7780: oJumpForward 7785
7782: Choice Lookup Table
           0   7770
7785: oTypeSPop
7786: oGetLocal 1
7788: oPushResult
7789: oSetResult 21
7791: oPushResult
7792: oNodeGet
7793: oPop 2
7795: oPushResult
7796: oTypeSPush
7797: oPop 1
7799: oReturn
7800: oLocalSpace 1
7802: oTypeSNodeType
7803: oChoice 7811
7805: oJumpForward 7818
7807: oError 29
7809: oJumpForward 7818
7811: Choice Lookup Table
          34   7807
          33   7805
7816: oError 9
7818: oEmit 24
7820: oGetAddrLocal 1
7822: oPushResult
7823: oTypeSTop
7824: oAssign
7825: oTypeSPop
7826: oGetLocal 1
7828: oPushResult
7829: oSetResult 36
7831: oPushResult
7832: oNodeGet
7833: oPop 2
7835: oPushResult
7836: oTypeSPush
7837: oPop 1
7839: oReturn
7840: oLocalSpace 1
7842: oGetAddrLocal 1
7844: oPushResult
7845: oTypeSNodeType
7846: oAssign
7847: oTypeSPop
7848: oGetLocal 1
7850: oPushResult
7851: oTypeSNodeType
7852: oPushResult
7853: equal_node_type
7854: oPop 2
7856: oChoice 7927
7858: oTypeSNodeType
7859: oChoice 7914
7861: oGetLocal 1
7863: oChoice 7870
7865: oEmit 29
7867: oReturn
7868: oJumpForward 7873
7870: Choice Lookup Table
          29   7865
7873: oJumpForward 7923
7875: oGetLocal 1
7877: oChoice 7884
7879: oEmit 30
7881: oReturn
7882: oJumpForward 7887
7884: Choice Lookup Table
          28   7879
7887: oJumpForward 7923
7889: oGetLocal 1
7891: oChoice 7896
7893: oReturn
7894: oJumpForward 7899
7896: Choice Lookup Table
          34   7893
7899: oJumpForward 7923
7901: oGetLocal 1
7903: oChoice 7908
7905: oReturn
7906: oJumpForward 7912
7908: Choice Lookup Table
          33   7905
7911: oEndChoice
7912: oJumpForward 7923
7914: Choice Lookup Table
          34   7901
          33   7889
          29   7875
          28   7861
7923: oError 14
7925: oJumpForward 7930
7927: Choice Lookup Table
           0   7858
7930: oReturn
7931: oLocalSpace 2
7933: oGetAddrLocal 2
7935: oPushResult
7936: oGetParam 1
7938: oPushResult
7939: oSetResult 26
7941: oPushResult
7942: oNodeGetString
7943: oPop 2
7945: oAssign
7946: oGetLocal 2
7948: oPushResult
7949: oSetResult 0
7951: oPushResult
7952: equal_string
7953: oPop 2
7955: oChoice 7992
7957: oGetAddrLocal 1
7959: oPushResult
7960: oGetParam 1
7962: oPushResult
7963: oSetResult 4
7965: oPushResult
7966: oNodeGetInt
7967: oPop 2
7969: oPushResult
7970: ID_STRING
7971: oPop 1
7973: oPushResult
7974: oStringAllocLit
7975: oPop 1
7977: oAssign
7978: oJumpForward 7998
7980: oGetAddrLocal 1
7982: oPushResult
7983: oGetLocal 2
7985: oPushResult
7986: oStringAllocLit
7987: oPop 1
7989: oAssign
7990: oJumpForward 7998
7992: Choice Lookup Table
           0   7980
           1   7957
7997: oEndChoice
7998: oEmit 70
8000: oGetParam 1
8002: oPushResult
8003: oCall 10687
8005: oPop 1
8007: oGetLocal 1
8009: oPushResult
8010: oEmitInt
8011: oPop 1
8013: oReturn
8014: oLocalSpace 10
8016: oGetParam 1
8018: oPushResult
8019: oSetResult 25
8021: oPushResult
8022: oNodeGetBoolean
8023: oPop 2
8025: oChoice 8052
8027: oGetParam 1
8029: oPushResult
8030: oSetResult 28
8032: oPushResult
8033: oNodeGetBoolean
8034: oPop 2
8036: oChoice 8047
8038: oGetParam 1
8040: oPushResult
8041: oCall 7931
8043: oPop 1
8045: oJumpForward 8050
8047: Choice Lookup Table
           0   8038
8050: oJumpForward 8055
8052: Choice Lookup Table
           1   8027
8055: oGetParam 1
8057: oPushResult
8058: oSetResult 28
8060: oPushResult
8061: oSetResult 1
8063: oPushResult
8064: oNodeSetBoolean
8065: oPop 3
8067: oGetAddrLocal 1
8069: oPushResult
8070: oGetParam 1
8072: oPushResult
8073: oSetResult 27
8075: oPushResult
8076: oNodeGetBoolean
8077: oPop 2
8079: oAssign
8080: oGetAddrLocal 4
8082: oPushResult
8083: oGetParam 1
8085: oPushResult
8086: oNodeType
8087: oPop 1
8089: oPushResult
8090: oSetResult 13
8092: oPushResult
8093: equal_node_type
8094: oPop 2
8096: oAssign
8097: oGetLocal 4
8099: oChoice 8126
8101: oGetAddrLocal 2
8103: oPushResult
8104: oGetParam 1
8106: oPushResult
8107: oSetResult 21
8109: oPushResult
8110: oNodeGet
8111: oPop 2
8113: oAssign
8114: oGetAddrLocal 3
8116: oPushResult
8117: oGetLocal 2
8119: oPushResult
8120: oScopeAllocType
8121: oPop 1
8123: oAssign
8124: oJumpForward 8129
8126: Choice Lookup Table
           1   8101
8129: oGetAddrLocal 5
8131: oPushResult
8132: oGetParam 1
8134: oPushResult
8135: oSetResult 23
8137: oPushResult
8138: oNodeGet
8139: oPop 2
8141: oAssign
8142: oGetAddrLocal 6
8144: oPushResult
8145: oGetLocal 5
8147: oPushResult
8148: oSetResult 17
8150: oPushResult
8151: oNodeGetInt
8152: oPop 2
8154: oAssign
8155: oGetLocal 1
8157: oChoice 8179
8159: oEmit 59
8161: oGetLocal 6
8163: oPushResult
8164: oEmitInt
8165: oPop 1
8167: oJumpForward 8185
8169: oEmit 58
8171: oGetLocal 6
8173: oPushResult
8174: oEmitInt
8175: oPop 1
8177: oJumpForward 8185
8179: Choice Lookup Table
           0   8169
           1   8159
8184: oEndChoice
8185: oGetParam 1
8187: oPushResult
8188: oCall 10135
8190: oPop 1
8192: oPushResult
8193: oSetResult 0
8195: oPushResult
8196: greater
8197: oPop 2
8199: oChoice 8232
8201: oEmit 19
8203: oSetResult 0
8205: oPushResult
8206: oEmitInt
8207: oPop 1
8209: oEmit 20
8211: oGetParam 1
8213: oPushResult
8214: oCall 10155
8216: oPop 1
8218: oPushResult
8219: oEmitInt
8220: oPop 1
8222: oSetResult 0
8224: oPushResult
8225: oEmitInt
8226: oPop 1
8228: oEmit 27
8230: oJumpForward 8235
8232: Choice Lookup Table
           1   8201
8235: oGetAddrLocal 7
8237: oPushResult
8238: oGetLocal 5
8240: oPushResult
8241: oSetResult 15
8243: oPushResult
8244: oNodeGetIter
8245: oPop 2
8247: oAssign
8248: oGetAddrLocal 8
8250: oPushResult
8251: oGetLocal 7
8253: oPushResult
8254: oNodeIterValue
8255: oPop 1
8257: oAssign
8258: oInputChoice 8455
8260: oGetLocal 8
8262: oPushResult
8263: oNodeNull
8264: oPop 1
8266: oChoice 8272
8268: oJumpForward 8451
8270: oJumpForward 8275
8272: Choice Lookup Table
           1   8268
8275: oGetAddrLocal 9
8277: oPushResult
8278: oGetLocal 8
8280: oPushResult
8281: oSetResult 22
8283: oPushResult
8284: oNodeGetInt
8285: oPop 2
8287: oAssign
8288: oEmit 19
8290: oGetLocal 9
8292: oPushResult
8293: oEmitInt
8294: oPop 1
8296: oGetLocal 8
8298: oPushResult
8299: oSetResult 21
8301: oPushResult
8302: oNodeGet
8303: oPop 2
8305: oPushResult
8306: oTypeSPush
8307: oPop 1
8309: oGetLocal 8
8311: oPushResult
8312: oSetResult 33
8314: oPushResult
8315: oNodeGetBoolean
8316: oPop 2
8318: oChoice 8404
8320: oSetResult 1
8322: oPushResult
8323: oCall 9275
8325: oPop 1
8327: oCall 10173
8329: oEmit 27
8331: oJumpForward 8410
8333: oCall 5092
8335: oCall 7840
8337: oTypeSNodeType
8338: oChoice 8378
8340: oEmit 25
8342: oJumpForward 8402
8344: oEmit 26
8346: oJumpForward 8402
8348: oError 16
8350: oJumpForward 8402
8352: oEmit 27
8354: oJumpForward 8402
8356: oGetAddrLocal 10
8358: oPushResult
8359: oTypeSTop
8360: oPushResult
8361: oSetResult 17
8363: oPushResult
8364: oNodeGetInt
8365: oPop 2
8367: oAssign
8368: oEmit 28
8370: oGetLocal 10
8372: oPushResult
8373: oEmitInt
8374: oPop 1
8376: oJumpForward 8402
8378: Choice Lookup Table
          37   8356
          35   8356
          34   8352
          33   8352
          27   8348
          38   8348
          32   8344
          29   8344
          30   8344
          39   8340
          28   8340
8401: oEndChoice
8402: oJumpForward 8410
8404: Choice Lookup Table
           0   8333
           1   8320
8409: oEndChoice
8410: oTypeSPop
8411: oGetAddrLocal 7
8413: oPushResult
8414: oNodeIterNext
8415: oPop 1
8417: oGetAddrLocal 8
8419: oPushResult
8420: oGetLocal 7
8422: oPushResult
8423: oNodeIterValue
8424: oPop 1
8426: oAssign
8427: oGetLocal 8
8429: oPushResult
8430: oNodeNull
8431: oPop 1
8433: oChoice 8441
8435: oJumpForward 8451
8437: oJumpForward 8447
8439: oJumpForward 8447
8441: Choice Lookup Table
           0   8439
           1   8435
8446: oEndChoice
8447: oInput 13
8449: oJumpBack 8260
8451: oInput 15
8453: oJumpForward 8458
8455: Choice Lookup Table
          14   8260
8458: oGetLocal 8
8460: oPushResult
8461: oNodeNull
8462: oPop 1
8464: oChoice 8470
8466: oError 15
8468: oJumpForward 8473
8470: Choice Lookup Table
           0   8466
8473: oGetLocal 4
8475: oChoice 8504
8477: oEmit 19
8479: oGetParam 1
8481: oPushResult
8482: oSetResult 31
8484: oPushResult
8485: oNodeGetInt
8486: oPop 2
8488: oPushResult
8489: oEmitInt
8490: oPop 1
8492: oEmit 17
8494: oGetLocal 3
8496: oPushResult
8497: oEmitInt
8498: oPop 1
8500: oEmit 27
8502: oJumpForward 8507
8504: Choice Lookup Table
           1   8477
8507: oGetLocal 1
8509: oChoice 8533
8511: oEmit 62
8513: oGetParam 1
8515: oPushResult
8516: oCall 10687
8518: oPop 1
8520: oJumpForward 8539
8522: oEmit 61
8524: oGetParam 1
8526: oPushResult
8527: oCall 10687
8529: oPop 1
8531: oJumpForward 8539
8533: Choice Lookup Table
           0   8522
           1   8511
8538: oEndChoice
8539: oGetLocal 4
8541: oChoice 8622
8543: oGetLocal 2
8545: oPushResult
8546: oTypeSPush
8547: oPop 1
8549: oTypeSNodeType
8550: oChoice 8596
8552: oEmit 3
8554: oGetLocal 3
8556: oPushResult
8557: oEmitInt
8558: oPop 1
8560: oJumpForward 8620
8562: oEmit 4
8564: oGetLocal 3
8566: oPushResult
8567: oEmitInt
8568: oPop 1
8570: oJumpForward 8620
8572: oError 16
8574: oJumpForward 8620
8576: oEmit 5
8578: oGetLocal 3
8580: oPushResult
8581: oEmitInt
8582: oPop 1
8584: oJumpForward 8620
8586: oEmit 17
8588: oGetLocal 3
8590: oPushResult
8591: oEmitInt
8592: oPop 1
8594: oJumpForward 8620
8596: Choice Lookup Table
          37   8586
          35   8586
          34   8576
          33   8576
          27   8572
          38   8572
          32   8562
          29   8562
          30   8562
          39   8552
          28   8552
8619: oEndChoice
8620: oJumpForward 8625
8622: Choice Lookup Table
           1   8543
8625: oEmit 60
8627: oGetLocal 6
8629: oPushResult
8630: oEmitInt
8631: oPop 1
8633: oReturn
8634: oLocalSpace 0
8636: oGetParam 1
8638: oPushResult
8639: oGetGlobal 14
8641: oPushResult
8642: oNodeEqual
8643: oPop 2
8645: oChoice 8685
8647: oInput 14
8649: oCall 5092
8651: oTypeSNodeType
8652: oChoice 8660
8654: oJumpForward 8673
8656: oEmit 29
8658: oJumpForward 8673
8660: Choice Lookup Table
          32   8656
          29   8656
          30   8656
          39   8654
          28   8654
8671: oError 14
8673: oTypeSPop
8674: oGetGlobal 6
8676: oPushResult
8677: oTypeSPush
8678: oPop 1
8680: oInput 15
8682: oReturn
8683: oJumpForward 8688
8685: Choice Lookup Table
           1   8647
8688: oGetParam 1
8690: oPushResult
8691: oGetGlobal 15
8693: oPushResult
8694: oNodeEqual
8695: oPop 2
8697: oChoice 8731
8699: oInput 14
8701: oCall 5092
8703: oTypeSNodeType
8704: oChoice 8712
8706: oEmit 30
8708: oJumpForward 8719
8710: oJumpForward 8719
8712: Choice Lookup Table
          29   8710
          28   8706
8717: oError 14
8719: oTypeSPop
8720: oGetGlobal 9
8722: oPushResult
8723: oTypeSPush
8724: oPop 1
8726: oInput 15
8728: oReturn
8729: oJumpForward 8734
8731: Choice Lookup Table
           1   8699
8734: oGetParam 1
8736: oPushResult
8737: oGetGlobal 16
8739: oPushResult
8740: oNodeEqual
8741: oPop 2
8743: oChoice 8783
8745: oInput 14
8747: oCall 5092
8749: oTypeSNodeType
8750: oChoice 8771
8752: oTypeSTop
8753: oPushResult
8754: oSetResult 43
8756: oPushResult
8757: oNodeGetBoolean
8758: oPop 2
8760: oChoice 8766
8762: oError 28
8764: oJumpForward 8769
8766: Choice Lookup Table
           1   8762
8769: oJumpForward 8776
8771: Choice Lookup Table
          39   8752
8774: oError 14
8776: oEmit 32
8778: oInput 15
8780: oReturn
8781: oJumpForward 8786
8783: Choice Lookup Table
           1   8745
8786: oGetParam 1
8788: oPushResult
8789: oGetGlobal 17
8791: oPushResult
8792: oNodeEqual
8793: oPop 2
8795: oChoice 8835
8797: oInput 14
8799: oCall 5092
8801: oTypeSNodeType
8802: oChoice 8823
8804: oTypeSTop
8805: oPushResult
8806: oSetResult 43
8808: oPushResult
8809: oNodeGetBoolean
8810: oPop 2
8812: oChoice 8818
8814: oError 28
8816: oJumpForward 8821
8818: Choice Lookup Table
           1   8814
8821: oJumpForward 8828
8823: Choice Lookup Table
          39   8804
8826: oError 14
8828: oEmit 31
8830: oInput 15
8832: oReturn
8833: oJumpForward 8838
8835: Choice Lookup Table
           1   8797
8838: oError 16
8840: oReturn
8841: oLocalSpace 0
8843: oInputChoice 8902
8845: oCall 10009
8847: oJumpForward 8931
8849: oCall 10016
8851: oJumpForward 8931
8853: oCall 10117
8855: oJumpForward 8931
8857: oCall 10120
8859: oJumpForward 8931
8861: oCall 9494
8863: oJumpForward 8931
8865: oCall 9817
8867: oJumpForward 8931
8869: oCall 9560
8871: oJumpForward 8931
8873: oCall 9737
8875: oJumpForward 8931
8877: oCall 9902
8879: oJumpForward 8931
8881: oCall 9870
8883: oJumpForward 8931
8885: oCall 9986
8887: oJumpForward 8931
8889: oCall 8932
8891: oJumpForward 8931
8893: oCall 9934
8895: oJumpForward 8931
8897: oChangeIntLitToLabelIdent
8898: oCall 8932
8900: oJumpForward 8931
8902: Choice Lookup Table
           1   8897
          53   8893
           0   8889
          35   8885
          51   8881
          52   8877
          49   8873
          44   8869
          48   8865
          41   8861
          66   8857
          65   8853
          64   8849
          63   8845
8931: oReturn
8932: oLocalSpace 1
8934: oGetAddrLocal 1
8936: oPushResult
8937: oScopeFindRequire
8938: oAssign
8939: oGetAddrLocal 1
8941: oPushResult
8942: oCall 466
8944: oPop 1
8946: oGetLocal 1
8948: oPushResult
8949: oNodeType
8950: oPop 1
8952: oChoice 8992
8954: oGetLocal 1
8956: oPushResult
8957: oCall 9008
8959: oPop 1
8961: oCall 8841
8963: oJumpForward 9007
8965: oGetLocal 1
8967: oPushResult
8968: oCall 8014
8970: oPop 1
8972: oJumpForward 9007
8974: oGetLocal 1
8976: oPushResult
8977: oCall 9058
8979: oPop 1
8981: oJumpForward 9007
8983: oGetLocal 1
8985: oPushResult
8986: oCall 9148
8988: oPop 1
8990: oJumpForward 9007
8992: Choice Lookup Table
          13   8983
          23   8974
          21   8974
          20   8974
          12   8965
          25   8954
9005: oError 0
9007: oReturn
9008: oLocalSpace 0
9010: oGetParam 1
9012: oPushResult
9013: oSetResult 34
9015: oPushResult
9016: oNodeGetBoolean
9017: oPop 2
9019: oChoice 9025
9021: oError 21
9023: oJumpForward 9028
9025: Choice Lookup Table
           1   9021
9028: oEmit 68
9030: oGetParam 1
9032: oPushResult
9033: oSetResult 22
9035: oPushResult
9036: oNodeGetLabel
9037: oPop 2
9039: oPushResult
9040: oEmitLabel
9041: oPop 1
9043: oGetParam 1
9045: oPushResult
9046: oSetResult 34
9048: oPushResult
9049: oSetResult 1
9051: oPushResult
9052: oNodeSetBoolean
9053: oPop 3
9055: oInput 12
9057: oReturn
9058: oLocalSpace 0
9060: oGetParam 1
9062: oPushResult
9063: oSetResult 1
9065: oPushResult
9066: oCall 9323
9068: oPop 2
9070: oInput 4
9072: oCall 5092
9074: oCall 7840
9076: oCall 9079
9078: oReturn
9079: oLocalSpace 1
9081: oTypeSNodeType
9082: oChoice 9122
9084: oEmit 25
9086: oJumpForward 9146
9088: oEmit 26
9090: oJumpForward 9146
9092: oError 16
9094: oJumpForward 9146
9096: oEmit 27
9098: oJumpForward 9146
9100: oGetAddrLocal 1
9102: oPushResult
9103: oTypeSTop
9104: oPushResult
9105: oSetResult 17
9107: oPushResult
9108: oNodeGetInt
9109: oPop 2
9111: oAssign
9112: oEmit 28
9114: oGetLocal 1
9116: oPushResult
9117: oEmitInt
9118: oPop 1
9120: oJumpForward 9146
9122: Choice Lookup Table
          38   9100
          37   9100
          35   9100
          34   9096
          33   9096
          27   9092
          32   9088
          29   9088
          30   9088
          39   9084
          28   9084
9145: oEndChoice
9146: oTypeSPop
9147: oReturn
9148: oLocalSpace 1
9150: oGetParam 1
9152: oPushResult
9153: oSetResult 6
9155: oPushResult
9156: oNodeGet
9157: oPop 2
9159: oPushResult
9160: oScopeCurrent
9161: oPushResult
9162: oNodeEqual
9163: oPop 2
9165: oChoice 9171
9167: oError 20
9169: oJumpForward 9174
9171: Choice Lookup Table
           0   9167
9174: oEmit 8
9176: oGetParam 1
9178: oPushResult
9179: oSetResult 31
9181: oPushResult
9182: oNodeGetInt
9183: oPop 2
9185: oPushResult
9186: oEmitInt
9187: oPop 1
9189: oGetParam 1
9191: oPushResult
9192: oSetResult 21
9194: oPushResult
9195: oNodeGet
9196: oPop 2
9198: oPushResult
9199: oTypeSPush
9200: oPop 1
9202: oInput 4
9204: oCall 5092
9206: oCall 7840
9208: oTypeSNodeType
9209: oChoice 9249
9211: oEmit 25
9213: oJumpForward 9273
9215: oEmit 26
9217: oJumpForward 9273
9219: oError 16
9221: oJumpForward 9273
9223: oEmit 27
9225: oJumpForward 9273
9227: oGetAddrLocal 1
9229: oPushResult
9230: oTypeSTop
9231: oPushResult
9232: oSetResult 17
9234: oPushResult
9235: oNodeGetInt
9236: oPop 2
9238: oAssign
9239: oEmit 28
9241: oGetLocal 1
9243: oPushResult
9244: oEmitInt
9245: oPop 1
9247: oJumpForward 9273
9249: Choice Lookup Table
          37   9227
          35   9227
          34   9223
          33   9223
          27   9219
          38   9219
          32   9215
          29   9215
          30   9215
          39   9211
          28   9211
9272: oEndChoice
9273: oTypeSPop
9274: oReturn
9275: oLocalSpace 1
9277: oInput 0
9279: oGetAddrLocal 1
9281: oPushResult
9282: oScopeFindRequire
9283: oAssign
9284: oGetAddrLocal 1
9286: oPushResult
9287: oCall 466
9289: oPop 1
9291: oGetLocal 1
9293: oPushResult
9294: oNodeType
9295: oPop 1
9297: oChoice 9301
9299: oJumpForward 9312
9301: Choice Lookup Table
          24   9299
          23   9299
          21   9299
          20   9299
9310: oError 4
9312: oGetLocal 1
9314: oPushResult
9315: oGetParam 1
9317: oPushResult
9318: oCall 9323
9320: oPop 2
9322: oReturn
9323: oLocalSpace 0
9325: oGetParam 2
9327: oPushResult
9328: oNodeType
9329: oPop 1
9331: oChoice 9413
9333: oEmit 16
9335: oGetParam 2
9337: oPushResult
9338: oCall 10687
9340: oPop 1
9342: oJumpForward 9424
9344: oEmit 17
9346: oGetParam 2
9348: oPushResult
9349: oCall 10687
9351: oPop 1
9353: oJumpForward 9424
9355: oGetParam 2
9357: oPushResult
9358: oSetResult 33
9360: oPushResult
9361: oNodeGetBoolean
9362: oPop 2
9364: oChoice 9377
9366: oEmit 8
9368: oGetParam 2
9370: oPushResult
9371: oCall 10687
9373: oPop 1
9375: oJumpForward 9389
9377: Choice Lookup Table
           1   9366
9380: oEmit 18
9382: oGetParam 2
9384: oPushResult
9385: oCall 10687
9387: oPop 1
9389: oJumpForward 9424
9391: oGetParam 1
9393: oChoice 9406
9395: oEmit 16
9397: oGetParam 2
9399: oPushResult
9400: oCall 10687
9402: oPop 1
9404: oJumpForward 9411
9406: Choice Lookup Table
           0   9395
9409: oError 4
9411: oJumpForward 9424
9413: Choice Lookup Table
          24   9391
          23   9355
          21   9344
          20   9333
9422: oError 4
9424: oGetParam 2
9426: oPushResult
9427: oSetResult 21
9429: oPushResult
9430: oNodeGet
9431: oPop 2
9433: oPushResult
9434: oTypeSPush
9435: oPop 1
9437: oCall 7402
9439: oReturn
9440: oLocalSpace 0
9442: oGetParam 1
9444: oPushResult
9445: oSetResult 1
9447: oPushResult
9448: oCall 9323
9450: oPop 2
9452: oCall 10231
9454: oGetParam 1
9456: oPushResult
9457: oCall 6593
9459: oPop 1
9461: oTypeSPop
9462: oEmit 31
9464: oEmit 25
9466: oReturn
9467: oLocalSpace 0
9469: oGetParam 1
9471: oPushResult
9472: oSetResult 1
9474: oPushResult
9475: oCall 9323
9477: oPop 2
9479: oCall 10231
9481: oGetParam 1
9483: oPushResult
9484: oCall 6593
9486: oPop 1
9488: oTypeSPop
9489: oEmit 32
9491: oEmit 25
9493: oReturn
9494: oLocalSpace 2
9496: oGetAddrLocal 1
9498: oPushResult
9499: oSetResult 0
9501: oAssign
9502: oGetAddrLocal 1
9504: oPushResult
9505: oCall 5115
9507: oPop 1
9509: oInput 42
9511: oCall 8841
9513: oInputChoice 9548
9515: oGetAddrLocal 2
9517: oPushResult
9518: oLabelNew
9519: oAssign
9520: oEmit 65
9522: oGetLocal 2
9524: oPushResult
9525: oEmitLabel
9526: oPop 1
9528: oEmit 68
9530: oGetLocal 1
9532: oPushResult
9533: oEmitLabel
9534: oPop 1
9536: oCall 8841
9538: oEmit 68
9540: oGetLocal 2
9542: oPushResult
9543: oEmitLabel
9544: oPop 1
9546: oJumpForward 9559
9548: Choice Lookup Table
          43   9515
9551: oEmit 68
9553: oGetLocal 1
9555: oPushResult
9556: oEmitLabel
9557: oPop 1
9559: oReturn
9560: oLocalSpace 4
9562: oInput 0
9564: oGetAddrLocal 1
9566: oPushResult
9567: oScopeFindRequire
9568: oAssign
9569: oGetLocal 1
9571: oPushResult
9572: oSetResult 1
9574: oPushResult
9575: oCall 9323
9577: oPop 2
9579: oCall 10231
9581: oInput 4
9583: oCall 5092
9585: oCall 10231
9587: oEmit 25
9589: oGetAddrLocal 2
9591: oPushResult
9592: oLabelNew
9593: oAssign
9594: oGetAddrLocal 3
9596: oPushResult
9597: oLabelNew
9598: oAssign
9599: oEmit 65
9601: oGetLocal 3
9603: oPushResult
9604: oEmitLabel
9605: oPop 1
9607: oGetAddrLocal 4
9609: oPushResult
9610: oLabelNew
9611: oAssign
9612: oEmit 68
9614: oGetLocal 4
9616: oPushResult
9617: oEmitLabel
9618: oPop 1
9620: oInputChoice 9700
9622: oGetLocal 1
9624: oPushResult
9625: oCall 9440
9627: oPop 1
9629: oEmit 68
9631: oGetLocal 3
9633: oPushResult
9634: oEmitLabel
9635: oPop 1
9637: oGetLocal 1
9639: oPushResult
9640: oCall 6593
9642: oPop 1
9644: oTypeSPop
9645: oCall 5092
9647: oCall 10231
9649: oEmit 48
9651: oEmit 66
9653: oGetLocal 2
9655: oPushResult
9656: oEmitLabel
9657: oPop 1
9659: oJumpForward 9706
9661: oGetLocal 1
9663: oPushResult
9664: oCall 9467
9666: oPop 1
9668: oEmit 68
9670: oGetLocal 3
9672: oPushResult
9673: oEmitLabel
9674: oPop 1
9676: oGetLocal 1
9678: oPushResult
9679: oCall 6593
9681: oPop 1
9683: oTypeSPop
9684: oCall 5092
9686: oCall 10231
9688: oEmit 49
9690: oEmit 66
9692: oGetLocal 2
9694: oPushResult
9695: oEmitLabel
9696: oPop 1
9698: oJumpForward 9706
9700: Choice Lookup Table
          46   9661
          45   9622
9705: oEndChoice
9706: oGetLocal 4
9708: oPushResult
9709: oGetLocal 2
9711: oPushResult
9712: oLoopPush
9713: oPop 2
9715: oInput 47
9717: oCall 8841
9719: oEmit 65
9721: oGetLocal 4
9723: oPushResult
9724: oEmitLabel
9725: oPop 1
9727: oEmit 68
9729: oGetLocal 2
9731: oPushResult
9732: oEmitLabel
9733: oPop 1
9735: oLoopPop
9736: oReturn
9737: oLocalSpace 3
9739: oGetAddrLocal 1
9741: oPushResult
9742: oLabelNew
9743: oAssign
9744: oEmit 68
9746: oGetLocal 1
9748: oPushResult
9749: oEmitLabel
9750: oPop 1
9752: oGetAddrLocal 2
9754: oPushResult
9755: oLabelNew
9756: oAssign
9757: oGetLocal 1
9759: oPushResult
9760: oGetLocal 2
9762: oPushResult
9763: oLoopPush
9764: oPop 2
9766: oCall 8841
9768: oInputChoice 9799
9770: oCall 8841
9772: oJumpForward 9805
9774: oGetAddrLocal 3
9776: oPushResult
9777: oCall 5115
9779: oPop 1
9781: oEmit 69
9783: oGetLocal 3
9785: oPushResult
9786: oEmitLabel
9787: oPop 1
9789: oGetLocal 1
9791: oPushResult
9792: oEmitLabel
9793: oPop 1
9795: oJumpForward 9807
9797: oJumpForward 9805
9799: Choice Lookup Table
          50   9774
           5   9770
9804: oEndChoice
9805: oJumpBack 9768
9807: oEmit 68
9809: oGetLocal 2
9811: oPushResult
9812: oEmitLabel
9813: oPop 1
9815: oLoopPop
9816: oReturn
9817: oLocalSpace 2
9819: oGetAddrLocal 1
9821: oPushResult
9822: oLabelNew
9823: oAssign
9824: oEmit 68
9826: oGetLocal 1
9828: oPushResult
9829: oEmitLabel
9830: oPop 1
9832: oGetAddrLocal 2
9834: oPushResult
9835: oCall 5115
9837: oPop 1
9839: oGetLocal 1
9841: oPushResult
9842: oGetLocal 2
9844: oPushResult
9845: oLoopPush
9846: oPop 2
9848: oInput 47
9850: oCall 8841
9852: oEmit 65
9854: oGetLocal 1
9856: oPushResult
9857: oEmitLabel
9858: oPop 1
9860: oEmit 68
9862: oGetLocal 2
9864: oPushResult
9865: oEmitLabel
9866: oPop 1
9868: oLoopPop
9869: oReturn
9870: oLocalSpace 0
9872: oLoopContinueLabel
9873: oPushResult
9874: oSetResult 0
9876: oPushResult
9877: equal_label
9878: oPop 2
9880: oChoice 9895
9882: oError 18
9884: oJumpForward 9901
9886: oEmit 65
9888: oLoopContinueLabel
9889: oPushResult
9890: oEmitLabel
9891: oPop 1
9893: oJumpForward 9901
9895: Choice Lookup Table
           0   9886
           1   9882
9900: oEndChoice
9901: oReturn
9902: oLocalSpace 0
9904: oLoopBreakLabel
9905: oPushResult
9906: oSetResult 0
9908: oPushResult
9909: equal_label
9910: oPop 2
9912: oChoice 9927
9914: oError 18
9916: oJumpForward 9933
9918: oEmit 65
9920: oLoopBreakLabel
9921: oPushResult
9922: oEmitLabel
9923: oPop 1
9925: oJumpForward 9933
9927: Choice Lookup Table
           0   9918
           1   9914
9932: oEndChoice
9933: oReturn
9934: oLocalSpace 1
9936: oInputChoice 9943
9938: oJumpForward 9949
9940: oChangeIntLitToLabelIdent
9941: oJumpForward 9949
9943: Choice Lookup Table
           1   9940
           0   9938
9948: oEndChoice
9949: oGetAddrLocal 1
9951: oPushResult
9952: oScopeCurrent
9953: oPushResult
9954: oScopeFindRequireInScope
9955: oPop 1
9957: oAssign
9958: oGetLocal 1
9960: oPushResult
9961: oSetResult 28
9963: oPushResult
9964: oSetResult 1
9966: oPushResult
9967: oNodeSetBoolean
9968: oPop 3
9970: oEmit 65
9972: oGetLocal 1
9974: oPushResult
9975: oSetResult 22
9977: oPushResult
9978: oNodeGetLabel
9979: oPop 2
9981: oPushResult
9982: oEmitLabel
9983: oPop 1
9985: oReturn
9986: oLocalSpace 0
9988: oCall 8841
9990: oInputChoice 10000
9992: oCall 8841
9994: oJumpForward 10006
9996: oJumpForward 10008
9998: oJumpForward 10006
10000: Choice Lookup Table
          36   9996
           5   9992
10005: oEndChoice
10006: oJumpBack 9990
10008: oReturn
10009: oLocalSpace 0
10011: oCall 10016
10013: oEmit 77
10015: oReturn
10016: oLocalSpace 0
10018: oInputChoice 10113
10020: oCall 5092
10022: oTypeSNodeType
10023: oChoice 10073
10025: oEmit 71
10027: oJumpForward 10094
10029: oEmit 72
10031: oJumpForward 10094
10033: oEmit 29
10035: oEmit 71
10037: oJumpForward 10094
10039: oEmit 73
10041: oJumpForward 10094
10043: oEmit 74
10045: oJumpForward 10094
10047: oError 16
10049: oJumpForward 10094
10051: oEmit 16
10053: oTypeSTop
10054: oPushResult
10055: oSetResult 42
10057: oPushResult
10058: oNodeGetInt
10059: oPop 2
10061: oPushResult
10062: oEmitInt
10063: oPop 1
10065: oEmit 76
10067: oJumpForward 10094
10069: oEmit 75
10071: oJumpForward 10094
10073: Choice Lookup Table
          34   10069
          33   10069
          39   10051
          27   10047
          38   10043
          32   10039
          29   10033
          30   10029
          28   10025
10092: oError 17
10094: oTypeSPop
10095: oInputChoice 10103
10097: oJumpForward 10111
10099: oJumpForward 10109
10101: oJumpForward 10109
10103: Choice Lookup Table
          13   10101
          15   10097
10108: oEndChoice
10109: oJumpBack 10020
10111: oJumpForward 10116
10113: Choice Lookup Table
          14   10020
10116: oReturn
10117: oLocalSpace 0
10119: oReturn
10120: oLocalSpace 0
10122: oReturn
10123: oLocalSpace 0
10125: oScopeCurrent
10126: oPushResult
10127: oSetResult 14
10129: oPushResult
10130: oNodeGetInt
10131: oPop 2
10133: oReturn
10134: oReturn
10135: oLocalSpace 0
10137: oGetParam 1
10139: oPushResult
10140: oSetResult 20
10142: oPushResult
10143: oNodeGet
10144: oPop 2
10146: oPushResult
10147: oSetResult 14
10149: oPushResult
10150: oNodeGetInt
10151: oPop 2
10153: oReturn
10154: oReturn
10155: oLocalSpace 0
10157: oCall 10123
10159: oPushResult
10160: oGetParam 1
10162: oPushResult
10163: oCall 10135
10165: oPop 1
10167: oPushResult
10168: subtract
10169: oPop 2
10171: oReturn
10172: oReturn
10173: oLocalSpace 1
10175: oGetAddrLocal 1
10177: oPushResult
10178: oTypeSNodeType
10179: oAssign
10180: oTypeSPop
10181: oGetLocal 1
10183: oPushResult
10184: oTypeSNodeType
10185: oPushResult
10186: equal_node_type
10187: oPop 2
10189: oChoice 10227
10191: oTypeSNodeType
10192: oChoice 10218
10194: oGetLocal 1
10196: oChoice 10201
10198: oReturn
10199: oJumpForward 10204
10201: Choice Lookup Table
          34   10198
10204: oJumpForward 10223
10206: oGetLocal 1
10208: oChoice 10213
10210: oReturn
10211: oJumpForward 10216
10213: Choice Lookup Table
          33   10210
10216: oJumpForward 10223
10218: Choice Lookup Table
          34   10206
          33   10194
10223: oError 14
10225: oJumpForward 10230
10227: Choice Lookup Table
           0   10191
10230: oReturn
10231: oLocalSpace 0
10233: oTypeSNodeType
10234: oChoice 10238
10236: oJumpForward 10243
10238: Choice Lookup Table
          28   10236
10241: oError 7
10243: oTypeSPop
10244: oReturn
10245: oLocalSpace 0
10247: oTypeSNodeType
10248: oChoice 10252
10250: oJumpForward 10257
10252: Choice Lookup Table
          28   10250
10255: oError 7
10257: oReturn
10258: oLocalSpace 0
10260: oTypeSNodeType
10261: oChoice 10269
10263: oJumpForward 10276
10265: oEmit 29
10267: oJumpForward 10276
10269: Choice Lookup Table
          29   10265
          28   10263
10274: oError 7
10276: oTypeSPop
10277: oReturn
10278: oLocalSpace 0
10280: oTypeSNodeType
10281: oChoice 10296
10283: oJumpForward 10303
10285: oEmit 29
10287: oTypeSPop
10288: oGetGlobal 6
10290: oPushResult
10291: oTypeSPush
10292: oPop 1
10294: oJumpForward 10303
10296: Choice Lookup Table
          29   10285
          28   10283
10301: oError 7
10303: oReturn
10304: oLocalSpace 0
10306: oTypeSNodeType
10307: oChoice 10320
10309: oEmit 29
10311: oTypeSPop
10312: oGetGlobal 6
10314: oPushResult
10315: oTypeSPush
10316: oPop 1
10318: oJumpForward 10323
10320: Choice Lookup Table
          29   10309
10323: oReturn
10324: oLocalSpace 0
10326: oTypeSNodeType
10327: oChoice 10331
10329: oJumpForward 10336
10331: Choice Lookup Table
          30   10329
10334: oError 8
10336: oTypeSPop
10337: oReturn
10338: oLocalSpace 0
10340: oTypeSNodeType
10341: oChoice 10345
10343: oJumpForward 10350
10345: Choice Lookup Table
          30   10343
10348: oError 8
10350: oReturn
10351: oLocalSpace 1
10353: oGetAddrLocal 1
10355: oPushResult
10356: oGetParam 2
10358: oPushResult
10359: oNodeNew
10360: oPop 1
10362: oAssign
10363: oGetLocal 1
10365: oPushResult
10366: oSetResult 17
10368: oPushResult
10369: oGetParam 1
10371: oPushResult
10372: oNodeSetInt
10373: oPop 3
10375: oGetLocal 1
10377: oPushResult
10378: oTypeAdd
10379: oPop 1
10381: oGetLocal 1
10383: oReturn
10384: oReturn
10385: oLocalSpace 1
10387: oGetAddrLocal 1
10389: oPushResult
10390: oGetParam 2
10392: oPushResult
10393: oNodeNew
10394: oPop 1
10396: oAssign
10397: oGetLocal 1
10399: oPushResult
10400: oSetResult 4
10402: oPushResult
10403: oGetParam 1
10405: oPushResult
10406: oNodeSetInt
10407: oPop 3
10409: oGetLocal 1
10411: oReturn
10412: oReturn
10413: oLocalSpace 1
10415: oGetAddrLocal 1
10417: oPushResult
10418: oGetParam 1
10420: oPushResult
10421: oSetResult 35
10423: oPushResult
10424: oNodeGet
10425: oPop 2
10427: oAssign
10428: oGetLocal 1
10430: oPushResult
10431: oNodeNull
10432: oPop 1
10434: oChoice 10490
10436: oGetAddrLocal 1
10438: oPushResult
10439: oSetResult 33
10441: oPushResult
10442: oNodeNew
10443: oPop 1
10445: oAssign
10446: oGetLocal 1
10448: oPushResult
10449: oSetResult 36
10451: oPushResult
10452: oGetParam 1
10454: oPushResult
10455: oNodeSet
10456: oPop 3
10458: oGetLocal 1
10460: oPushResult
10461: oSetResult 17
10463: oPushResult
10464: oSetResult 8
10466: oPushResult
10467: oNodeSetInt
10468: oPop 3
10470: oGetLocal 1
10472: oPushResult
10473: oTypeAdd
10474: oPop 1
10476: oGetParam 1
10478: oPushResult
10479: oSetResult 35
10481: oPushResult
10482: oGetLocal 1
10484: oPushResult
10485: oNodeSet
10486: oPop 3
10488: oJumpForward 10493
10490: Choice Lookup Table
           1   10436
10493: oGetLocal 1
10495: oReturn
10496: oReturn
10497: oLocalSpace 2
10499: oGetParam 1
10501: oPushResult
10502: oNodeType
10503: oPop 1
10505: oChoice 10575
10507: oMININT
10508: oReturn
10509: oJumpForward 10591
10511: oSetResult 0
10513: oReturn
10514: oJumpForward 10591
10516: oSetResult 0
10518: oReturn
10519: oJumpForward 10591
10521: oGetAddrLocal 1
10523: oPushResult
10524: oGetParam 1
10526: oPushResult
10527: oSetResult 40
10529: oPushResult
10530: oNodeGet
10531: oPop 2
10533: oAssign
10534: oGetAddrLocal 2
10536: oPushResult
10537: oGetLocal 1
10539: oPushResult
10540: oSetResult 15
10542: oPushResult
10543: oNodeGetIter
10544: oPop 2
10546: oPushResult
10547: oNodeIterValue
10548: oPop 1
10550: oAssign
10551: oGetLocal 2
10553: oPushResult
10554: oSetResult 22
10556: oPushResult
10557: oNodeGetInt
10558: oPop 2
10560: oReturn
10561: oJumpForward 10591
10563: oGetParam 1
10565: oPushResult
10566: oSetResult 38
10568: oPushResult
10569: oNodeGetInt
10570: oPop 2
10572: oReturn
10573: oJumpForward 10591
10575: Choice Lookup Table
          36   10563
          39   10521
          32   10516
          30   10511
          28   10507
10586: oError 3
10588: oSetResult 0
10590: oReturn
10591: oReturn
10592: oLocalSpace 2
10594: oGetParam 1
10596: oPushResult
10597: oNodeType
10598: oPop 1
10600: oChoice 10670
10602: oMAXINT
10603: oReturn
10604: oJumpForward 10686
10606: oSetResult 1
10608: oReturn
10609: oJumpForward 10686
10611: oSetResult 255
10613: oReturn
10614: oJumpForward 10686
10616: oGetAddrLocal 1
10618: oPushResult
10619: oGetParam 1
10621: oPushResult
10622: oSetResult 40
10624: oPushResult
10625: oNodeGet
10626: oPop 2
10628: oAssign
10629: oGetAddrLocal 2
10631: oPushResult
10632: oGetLocal 1
10634: oPushResult
10635: oSetResult 15
10637: oPushResult
10638: oNodeGetIterLast
10639: oPop 2
10641: oPushResult
10642: oNodeIterValue
10643: oPop 1
10645: oAssign
10646: oGetLocal 2
10648: oPushResult
10649: oSetResult 22
10651: oPushResult
10652: oNodeGetInt
10653: oPop 2
10655: oReturn
10656: oJumpForward 10686
10658: oGetParam 1
10660: oPushResult
10661: oSetResult 39
10663: oPushResult
10664: oNodeGetInt
10665: oPop 2
10667: oReturn
10668: oJumpForward 10686
10670: Choice Lookup Table
          36   10658
          39   10616
          32   10611
          30   10606
          28   10602
10681: oError 3
10683: oSetResult 0
10685: oReturn
10686: oReturn
10687: oLocalSpace 0
10689: oGetParam 1
10691: oPushResult
10692: oSetResult 22
10694: oPushResult
10695: oNodeGetInt
10696: oPop 2
10698: oPushResult
10699: oEmitInt
10700: oPop 1
10702: oReturn
10703: oLocalSpace 1
10705: oGetAddrLocal 1
10707: oPushResult
10708: oSetResult 14
10710: oPushResult
10711: oGetParam 1
10713: oPushResult
10714: oCall 10385
10716: oPop 2
10718: oAssign
10719: oGetLocal 1
10721: oPushResult
10722: oScopeDeclare
10723: oPop 1
10725: oGetLocal 1
10727: oReturn
10728: oReturn
10729: oLocalSpace 1
10731: oGetAddrGlobal 4
10733: oPushResult
10734: oIdAdd_mysystem
10735: oAssign
10736: oGetAddrGlobal 5
10738: oPushResult
10739: oSetResult 27
10741: oPushResult
10742: oSetResult 4
10744: oPushResult
10745: oCall 10351
10747: oPop 2
10749: oAssign
10750: oGetAddrGlobal 6
10752: oPushResult
10753: oSetResult 28
10755: oPushResult
10756: oSetResult 4
10758: oPushResult
10759: oCall 10351
10761: oPop 2
10763: oAssign
10764: oGetAddrGlobal 7
10766: oPushResult
10767: oSetResult 30
10769: oPushResult
10770: oSetResult 1
10772: oPushResult
10773: oCall 10351
10775: oPop 2
10777: oAssign
10778: oGetAddrGlobal 8
10780: oPushResult
10781: oSetResult 31
10783: oPushResult
10784: oSetResult 1
10786: oPushResult
10787: oCall 10351
10789: oPop 2
10791: oAssign
10792: oGetAddrGlobal 9
10794: oPushResult
10795: oSetResult 32
10797: oPushResult
10798: oSetResult 1
10800: oPushResult
10801: oCall 10351
10803: oPop 2
10805: oAssign
10806: oGetAddrGlobal 10
10808: oPushResult
10809: oGetGlobal 9
10811: oPushResult
10812: oCall 10413
10814: oPop 1
10816: oAssign
10817: oGetAddrGlobal 11
10819: oPushResult
10820: oSetResult 29
10822: oPushResult
10823: oSetResult 1
10825: oPushResult
10826: oCall 10351
10828: oPop 2
10830: oAssign
10831: oGetAddrGlobal 12
10833: oPushResult
10834: oSetResult 34
10836: oPushResult
10837: oSetResult 8
10839: oPushResult
10840: oCall 10351
10842: oPop 2
10844: oAssign
10845: oGetGlobal 12
10847: oPushResult
10848: oSetResult 36
10850: oPushResult
10851: oGetGlobal 11
10853: oPushResult
10854: oNodeSet
10855: oPop 3
10857: oGetAddrGlobal 13
10859: oPushResult
10860: oSetResult 38
10862: oPushResult
10863: oSetResult 256
10865: oPushResult
10866: oCall 10351
10868: oPop 2
10870: oAssign
10871: oGetGlobal 13
10873: oPushResult
10874: oSetResult 41
10876: oPushResult
10877: oSetResult 255
10879: oPushResult
10880: oNodeSetInt
10881: oPop 3
10883: oGetAddrLocal 1
10885: oPushResult
10886: oSetResult 18
10888: oPushResult
10889: oIdAdd_File
10890: oPushResult
10891: oCall 10385
10893: oPop 2
10895: oAssign
10896: oGetLocal 1
10898: oPushResult
10899: oSetResult 21
10901: oPushResult
10902: oGetGlobal 5
10904: oPushResult
10905: oNodeSet
10906: oPop 3
10908: oGetLocal 1
10910: oPushResult
10911: oScopeDeclare
10912: oPop 1
10914: oGetAddrLocal 1
10916: oPushResult
10917: oSetResult 18
10919: oPushResult
10920: oIdAdd_Integer
10921: oPushResult
10922: oCall 10385
10924: oPop 2
10926: oAssign
10927: oGetLocal 1
10929: oPushResult
10930: oSetResult 21
10932: oPushResult
10933: oGetGlobal 6
10935: oPushResult
10936: oNodeSet
10937: oPop 3
10939: oGetLocal 1
10941: oPushResult
10942: oScopeDeclare
10943: oPop 1
10945: oGetAddrLocal 1
10947: oPushResult
10948: oSetResult 18
10950: oPushResult
10951: oIdAdd_Boolean
10952: oPushResult
10953: oCall 10385
10955: oPop 2
10957: oAssign
10958: oGetLocal 1
10960: oPushResult
10961: oSetResult 21
10963: oPushResult
10964: oGetGlobal 7
10966: oPushResult
10967: oNodeSet
10968: oPop 3
10970: oGetLocal 1
10972: oPushResult
10973: oScopeDeclare
10974: oPop 1
10976: oGetAddrLocal 1
10978: oPushResult
10979: oSetResult 18
10981: oPushResult
10982: oIdAdd_Char
10983: oPushResult
10984: oCall 10385
10986: oPop 2
10988: oAssign
10989: oGetLocal 1
10991: oPushResult
10992: oSetResult 21
10994: oPushResult
10995: oGetGlobal 9
10997: oPushResult
10998: oNodeSet
10999: oPop 3
11001: oGetLocal 1
11003: oPushResult
11004: oScopeDeclare
11005: oPop 1
11007: oGetAddrLocal 1
11009: oPushResult
11010: oSetResult 18
11012: oPushResult
11013: oIdAdd_Byte
11014: oPushResult
11015: oCall 10385
11017: oPop 2
11019: oAssign
11020: oGetLocal 1
11022: oPushResult
11023: oSetResult 21
11025: oPushResult
11026: oGetGlobal 11
11028: oPushResult
11029: oNodeSet
11030: oPop 3
11032: oGetLocal 1
11034: oPushResult
11035: oScopeDeclare
11036: oPop 1
11038: oGetAddrLocal 1
11040: oPushResult
11041: oSetResult 18
11043: oPushResult
11044: oIdAdd_Pointer
11045: oPushResult
11046: oCall 10385
11048: oPop 2
11050: oAssign
11051: oGetLocal 1
11053: oPushResult
11054: oSetResult 21
11056: oPushResult
11057: oGetGlobal 12
11059: oPushResult
11060: oNodeSet
11061: oPop 3
11063: oGetLocal 1
11065: oPushResult
11066: oScopeDeclare
11067: oPop 1
11069: oGetAddrLocal 1
11071: oPushResult
11072: oSetResult 18
11074: oPushResult
11075: oIdAdd_ShortString
11076: oPushResult
11077: oCall 10385
11079: oPop 2
11081: oAssign
11082: oGetLocal 1
11084: oPushResult
11085: oSetResult 21
11087: oPushResult
11088: oGetGlobal 13
11090: oPushResult
11091: oNodeSet
11092: oPop 3
11094: oGetLocal 1
11096: oPushResult
11097: oScopeDeclare
11098: oPop 1
11100: oGetAddrLocal 1
11102: oPushResult
11103: oSetResult 16
11105: oPushResult
11106: oIdAdd_True
11107: oPushResult
11108: oCall 10385
11110: oPop 2
11112: oAssign
11113: oGetLocal 1
11115: oPushResult
11116: oSetResult 21
11118: oPushResult
11119: oGetGlobal 7
11121: oPushResult
11122: oNodeSet
11123: oPop 3
11125: oGetLocal 1
11127: oPushResult
11128: oSetResult 22
11130: oPushResult
11131: oSetResult 1
11133: oPushResult
11134: oNodeSetInt
11135: oPop 3
11137: oGetLocal 1
11139: oPushResult
11140: oScopeDeclare
11141: oPop 1
11143: oGetAddrLocal 1
11145: oPushResult
11146: oSetResult 16
11148: oPushResult
11149: oIdAdd_False
11150: oPushResult
11151: oCall 10385
11153: oPop 2
11155: oAssign
11156: oGetLocal 1
11158: oPushResult
11159: oSetResult 21
11161: oPushResult
11162: oGetGlobal 7
11164: oPushResult
11165: oNodeSet
11166: oPop 3
11168: oGetLocal 1
11170: oPushResult
11171: oSetResult 22
11173: oPushResult
11174: oSetResult 0
11176: oPushResult
11177: oNodeSetInt
11178: oPop 3
11180: oGetLocal 1
11182: oPushResult
11183: oScopeDeclare
11184: oPop 1
11186: oGetAddrGlobal 14
11188: oPushResult
11189: oIdAdd_Ord
11190: oPushResult
11191: oCall 10703
11193: oPop 1
11195: oAssign
11196: oGetAddrGlobal 15
11198: oPushResult
11199: oIdAdd_Chr
11200: oPushResult
11201: oCall 10703
11203: oPop 1
11205: oAssign
11206: oGetAddrGlobal 16
11208: oPushResult
11209: oIdAdd_Pred
11210: oPushResult
11211: oCall 10703
11213: oPop 1
11215: oAssign
11216: oGetAddrGlobal 17
11218: oPushResult
11219: oIdAdd_Succ
11220: oPushResult
11221: oCall 10703
11223: oPop 1
11225: oAssign
11226: oReturn
