   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - variable initialization.
      %      The code should execute on entry to the scope.  I probably need multiple tcode streams,
      %      because there may be nested methods between the variables being initialized
      %      and the block statement of the scope.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qLevel
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qInitCode
   2: 	qParentScope
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qCalled
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                 % advance iterator through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.  necessary because ssl literal ints are currently (silently) short (!)
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level )             % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
   2: Node    mainRoutineScope       % scope for temporaries in main routine
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
      
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    oScopeBegin( 0 )
  10:    globalScope = oScopeCurrent
      
  15:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  17:    .tEnter  oEmitInt( 0 )
  25:    Label mainLabel = oLabelNew
      
  30:    .tAllocActuals  oEmitInt( 0 )
  38:    .tCall  oEmitLabel( mainLabel )
  46:    .tFreeActuals  oEmitInt( 0 )
  54:    .tReturn
      
  56:    pProgram
  58:    pIdent
      
  60:    Node progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  76:    oScopeDeclare( progDecl )
      
  82:    [
  82:       | '(' :
  84:          pIdent      % input, output files
      
  86:          t = @newIdent( nVar, kVar, LAST_ID )
 102:          oNodeSet( t, qType, FileType )
 114:          oScopeDeclareAlloc( t )
      
 120:          ','
 122:          pIdent
      
 124:          t = @newIdent( nVar, kVar, LAST_ID )
 140:          oNodeSet( t, qType, FileType )
 152:          oScopeDeclareAlloc( t )
      
 158:          ')'
 160:       | * :
 165:    ]
 165:    ';'
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
 167:    oScopeBegin( 0 )
 173:    mainRoutineScope = oScopeCurrent
 178:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 189:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
 200:    oScopeEnd
      
 201:    @BlockDecls( nGlobalVar )
      
      
 208:    oScopeEnter( mainRoutineScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 214:    @BlockStmt( mainLabel, globalScope )
      
 224:    oScopeEnd   % main routine scope
      
 225:    '.'
 227:    oScopeEnd   % global scope
 229:    ;
      
      
 229: Block( node_type varNodeType, Label labelForBody ):
 231:    @BlockDecls( varNodeType )
 238:    @BlockStmt( labelForBody, oScopeCurrent )
 248:    ;
      
      
 248: BlockDecls( node_type varNodeType ):
 250:    {[
 250:       | pConst :     @ConstDecl
 254:       | pType :      @TypeDecl
 258:       | pVar :       @VarDecl( varNodeType )
 267:       | pProcedure : @ProcDecl
 271:       | pFunction :  @FuncDecl
 275:       | * :          >
 290:    ]}
 292:    @CheckForUndefinedMethods
 295:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
 295: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
 298:    ;
      
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
 298: BlockStmt( Label labelForBody, Node varScope ):
 300:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 308:    int patchLS
 308:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this scope's variables
 317:    Code initCode = oNodeGetCode( varScope, qInitCode )
 330:    oEmitCode( initCode )
 336:    oNodeSetCode( oScopeCurrent, qInitCode, codeNull )
      
 347:    @Statement
 349:    .tReturn
      
 351:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
 363:    oPatch( patchLS, localSpace )
 373:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
 373: MethodModifiers( Node decl ):
 375:    {[
 375:       | pCdecl :
 377:          oNodeSetBoolean( decl, qCdecl, true )
 389:          ';'
      
 391:       | * : >
 398:    ]}
 401:    ;
      
      
      % We need an initCode code stream for the current scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
 401: GetOrCreateInitCode >> Code:
 403:    Code initCode = oNodeGetCode( oScopeCurrent, qInitCode )
 415:    [ equal_code( initCode, codeNull )
 425:       | true :
 426:          initCode = oCodeNew
 431:          oNodeSetCode( oScopeCurrent, qInitCode, initCode )
 442:       | * :
 447:    ]
 447:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
 451: ExternalDecl( Node decl ):
 453:    oNodeSetBoolean( decl, qExternal, true )
 465:    [
 465:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
 467:          [
 467:             | pName :
 469:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
 471:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
 482:             | * :
 487:          ]
 487:       | * :
 492:    ]
 493:    ;
      
      
 493: ProcDecl:
 495:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 497:    boolean redeclaring = false
 503:    Node decl = oScopeFindInCurrentScope
      
 508:    [ oNodeNull( decl )
 515:       | true :
               % first declaration
 516:          decl = @newIdent( nProc, kProc, LAST_ID )
 532:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 543:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 545:          redeclaring = true
 551:          [ oNodeGetBoolean( decl, qBodyDefined )
 561:             | true : #eAlreadyDefined
 564:             | * :
 569:          ]
 569:          [ oNodeGetBoolean( decl, qExternal )
 579:             | true : #eAlreadyDefined
 582:             | * :
 587:          ]
 587:          [ oNodeType( decl )
 594:             | nProc :
 595:             | * : #eAlreadyDefined   % wrong kind
 602:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 602:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 621:          oNodeSet( decl, qParams, Null )
 633:    ]
      
 641:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 653:    inc( level )
 659:    oScopeBegin( level )
 665:    Node paramScope = oScopeCurrent
      
 670:    @FormalArgDecl
 672:    oNodeSet( decl, qParams, paramScope )
 684:    oScopeEnd
 685:    ';'
      
 687:    [ redeclaring
 690:       | false : oScopeDeclare( decl )
 697:       | true :  % TO DO: check that qParams is consistent with qOldParams
 699:    ]
      
 707:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
 714:    [
 714:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
 716:       | pExternal : @ExternalDecl( decl )
      
 725:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
 732:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
 738:          oScopeBegin( level )
 744:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 755:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
 766:          Label label = oNodeGetLabel( decl, qValue )
 779:          @Block( nLocalVar, label )
 789:          oNodeSetBoolean( decl, qBodyDefined, true )
 801:          oScopeEnd
      
 802:          oScopeEnd  % paramScope
 803:    ]
 803:    ';';
      
      
 806: FuncDecl:
 808:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
 810:    boolean redeclaring = false
 816:    Node decl = oScopeFindInCurrentScope
      
 821:    [ oNodeNull( decl )
 828:       | true :
               % first declaration
 829:          decl = @newIdent( nFunc, kFunc, LAST_ID )
 845:          oNodeSetLabel( decl, qValue, oLabelNew )
      
 856:       | false :
               % we already have a declaration.
               % Keep it, and its label.
 858:          redeclaring = true
 864:          [ oNodeGetBoolean( decl, qBodyDefined )
 874:             | true : #eAlreadyDefined
 877:             | * :
 882:          ]
 882:          [ oNodeType( decl )
 889:             | nFunc :
 890:             | * : #eAlreadyDefined   % wrong kind
 897:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
 897:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
 916:          oNodeSet( decl, qParams, Null )
 928:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
 947:          oNodeSet( decl, qType, Null )
 959:    ]
      
 967:    int level = oNodeGetInt( oScopeCurrent, qLevel )
 979:    inc( level )
 985:    oScopeBegin( level )
 991:    Node paramScope = oScopeCurrent
      
 996:    @FormalArgDecl
 998:    oNodeSet( decl, qParams, paramScope )
      
1010:    ':'
      
1012:    Node theType
1012:    @TypeRef( theType )
1019:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
1031:    Node ptrType = @PointerTypeTo( theType )
1042:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
1058:    oScopeEnd
1059:    ';'
      
1061:    [ redeclaring
1064:       | false : oScopeDeclare( decl )
1071:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
1073:    ]
      
1081:    @MethodModifiers( decl )
      
         % Body may be a statement, "forward", "external".
1088:    [
1088:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1090:       | pExternal : @ExternalDecl( decl )
      
1099:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1106:          oScopeEnter( paramScope )
      
1112:          oScopeBegin( level )
1118:          oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
1129:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1140:          Label label = oNodeGetLabel( decl, qValue )
1153:          @Block( nLocalVar, label )
1163:          oNodeSetBoolean( decl, qBodyDefined, true )
1175:          oScopeEnd
      
1176:          oScopeEnd  % paramScope
1177:    ]
1177:    ';';
      
      
1180: FormalArgDecl:
1182:    [
1182:       | '(' :
1184:          {
1184:             NodeVec decls = oNodeVecNew
1189:             Node decl
1189:             boolean isInOut = false
      
1195:             [
1195:                | pVar : isInOut = true
1203:                | * :
1208:             ]
      
1208:             {  pIdent
      
1210:                decl = @newIdent( nParam, kVar, LAST_ID )
1226:                oNodeSetBoolean( decl, qInOut, isInOut )
1238:                oNodeVecAppend( decls, decl )
      
1247:                [
1247:                   | ':' : >
1251:                   | ',' :
1253:                ]
1261:             }
      
1263:             Node theType
1263:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
1270:             Node allocType
1270:             [ isInOut
1273:                | true :   allocType = @PointerTypeTo( theType )
1285:                | * :      allocType = theType
1296:             ]
      
1296:             int i = 0
1302:             {[ equal( i, oNodeVecSize( decls ) )
1316:                | false :
1317:                   decl = oNodeVecElement( decls, i )
      
1330:                   oNodeSet( decl, qType, theType )
1342:                   oScopeDeclare( decl )
1348:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
1364:                   inc( i )
1370:                | * :
1375:                   >
1377:             ]}
      
1379:             oNodeVecDelete( decls )
      
1385:             [
1385:                | ')' : >
1389:                | ';' :
1391:             ]
1399:          }
1401:       | * :
1406:    ];
      
1407: ConstDecl:
1409:    {[
1409:       | pIdent :
1411:          Node decl = @newIdent( nConst, kConst, LAST_ID )
1427:          '='
      
1429:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
1431:          int val = oValueTop
1436:          oValuePop
1437:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
1449:          oNodeSet( decl, qType, IntegerType )
      
1461:          oScopeDeclare( decl )
1467:          ';'
1469:       | * :
1474:          >
1476:    ]};
      
1479: TypeDecl:
1481:    {[
1481:       | pIdent :
1483:          Node decl = @newIdent( nTypeDecl, kType, LAST_ID )
1499:          '='
1501:          Node theType
1501:          @TypeRef( theType )
1508:          oNodeSet( decl, qType, theType )
1520:          oScopeDeclare( decl )
1526:          ';'
1528:       | * :
1533:          >
1535:    ]};
      
1538: VarDecl( node_type varNodeType ):
1540:    {[
1540:       | pIdent :
1542:          NodeVec decls = oNodeVecNew
1547:          Node decl
1547:          {
1547:             decl = @newIdent( varNodeType, kVar, LAST_ID )
1563:             oNodeVecAppend( decls, decl )
1572:             [
1572:                | ',' :
1574:                   pIdent
1576:                | * :
1581:                   >
1583:             ]
1583:          }
1585:          ':'
1587:          Node theType
1587:          @TypeRef( theType )
      
1594:          int i = 0
1600:          {[ equal( i, oNodeVecSize( decls ) )
1614:             | false :
1615:                decl = oNodeVecElement( decls, i )
1628:                oNodeSet( decl, qType, theType )
1640:                oScopeDeclareAlloc( decl )
1646:                inc( i )
1652:             | * :
1657:               >
1659:          ]}
      
               % optional initialization
1661:          [
1661:             | '=' :
1663:                [ oNodeVecSize( decls )
1670:                   | 1 :
1671:                   | * :  #eOnlyOneVarCanBeInitialized
1678:                ]
      
                     % we need an initCode stream for this scope
1678:                Code initCode = @GetOrCreateInitCode
1684:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
1690:                boolean changedScope = false
1696:                [ equal_node( oScopeCurrent, globalScope )
1705:                   | true : oScopeEnter( mainRoutineScope )
1712:                            changedScope = true
1718:                   | * :
1723:                ]
                     % generate assignment in initCode stream
1723:                @LValueVar( decl )
1730:                @Expr
1732:                @MatchTypes
1734:                @Assign
1736:                [ changedScope
1739:                   | true : oScopeEnd
1741:                   | * :
1746:                ]
1746:                oCodePop
                   
1747:             | * :
1752:          ]
      
1752:          oNodeVecDelete( decls )
1758:          ';'
1760:       | * :
1765:          >
1767:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1770: TypeRef( out Node resultType ):
1772:    [
1772:       | pIdent :           % previously named type (including intrinsics)
1774:          Node decl = oScopeFindRequire
1779:          [ oNodeType( decl )
1786:            | nTypeDecl :
1787:                resultType = oNodeGet( decl, qType )
1800:            | * :
1805:                #eNotType
1807:                resultType = IntegerType
1813:          ]
         
1813:       | pArray :
1815:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1817:          NodeVec dimensions = oNodeVecNew
      
1822:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1822:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1832:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1844:             @ConstExpr
1846:             oNodeSetInt( subrange, qLow, oValueTop )
1857:             oValuePop
1858:             '..'
1860:             @ConstExpr
1862:             oNodeSetInt( subrange, qHigh, oValueTop )
1873:             oValuePop
1874:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1886:             oTypeAdd( subrange )
      
1892:             Node a = oNodeNew( nArrayType )
1902:             oNodeSet( a, qIndexType, subrange )
      
1914:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1923:             [
1923:                | ']' : >
1927:                | ',' :
1929:             ]
1937:          }
      
1939:          pOf
1941:          Node baseType
1941:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1948:          int dim = oNodeVecSize( dimensions )
      
1958:          {
1958:              dec(dim)
      
1964:              Node a = oNodeVecElement( dimensions, dim )
      
1977:              oNodeSet( a, qBaseType, baseType )
1989:              Node subrange = oNodeGet( a, qIndexType )
2002:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
2029:              inc( width )
2035:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
2061:              oTypeAdd( a )
2067:              baseType = a
      
2073:              [ equal_zero(dim)
2080:                  | true:  >
2083:                  | *:
2088:              ]
2088:          }
      
2090:          resultType = oNodeVecElement( dimensions, 0 )
2103:          oNodeVecDelete( dimensions )
      
2109:       | '^' :
2111:          Node theType
2111:          @TypeRef( theType )
2118:          resultType = @PointerTypeTo( theType )
      
2129:       | pRecord :
2131:          resultType = oNodeNew( nRecordType )
2141:          oScopeBegin( -1 )    % level is meaningless here
      
2147:          @VarDecl( nRecordField )
      
2154:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
2166:          [ equal_zero( size )
2173:             | true : #eRecordEmpty
2176:             | * :
2181:          ]
      
2181:          pEnd
      
2183:          oNodeSet( resultType, qScope, oScopeCurrent )
2194:          oNodeSetInt( resultType, qSize, size )
2206:          oScopeEnd
2207:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
2213:       | pSet :
2215:          pOf
2217:          Node theType
2217:          @TypeRef( theType )
2224:       | * :       % this works for cases except where expr starts with an id
2237:          @ConstExpr '..' @ConstExpr
2243:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
2244: ConstExpr:
2246:    [
2246:       | pIntLit :
2248:          oValuePush( TOKEN_VALUE )
2253:       | pIdent :
2255:          Node decl = oScopeFindRequire
2260:          [ oNodeType( decl )
2267:             | nConst :
2268:                oValuePush( oNodeGetInt( decl, qValue ) )
2281:             | * :
2286:                #eNotConst
2288:                oValuePush( 0 )
2294:          ]
2294:       | pMinus :
2296:          @ConstExpr
2298:          oValueNegate
2299:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
2310: Expr:
2312:    Label falseLabel = labelNull
      
2318:    @ExprAllowCF( falseLabel )
2325:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
2333: BooleanExprControlFlow( out Label falseLabel ):
2335:    @ExprAllowCF( falseLabel )
2342:    [ oTypeSNodeType
2344:       | nBooleanCFType :
2345:       | nBooleanType :
               % convert value to control flow
2347:          falseLabel = oLabelNew
2352:          .tJumpFalse  oEmitLabel( falseLabel )
2360:       | * :
2367:          #eNotBoolean
2369:    ]
2369:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
2371: CFToVal( inout Label falseLabel ):
2373:    [ oTypeSNodeType
2375:       | nBooleanCFType :
2376:          Label doneLabel = oLabelNew
2381:          .tPushConstI  oEmitInt( 1 )
2389:          .tJump  oEmitLabel( doneLabel )
2397:          .tLabel  oEmitLabel( falseLabel )
2405:          .tPushConstI  oEmitInt( 0 )
2413:          .tLabel  oEmitLabel( doneLabel )
2421:          oTypeSPop
2422:          oTypeSPush( BooleanType )
2428:          falseLabel = labelNull
2434:       | * :
2439:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
2440: ValToCF( out Label falseLabel ):
2442:    [ oTypeSNodeType
2444:       | nBooleanType :
2445:          falseLabel = oLabelNew
2450:          .tJumpFalse  oEmitLabel( falseLabel )
2458:          oTypeSPop
2459:          oTypeSPush( BooleanCFType )
2465:       | * :
2470:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
2471: ExprAllowCF( out Label falseLabel ):
2473:    @BoolExprAllowCF( falseLabel )
2480:    {[
2480:       | '=' :
2482:          @CFToVal( falseLabel )
2489:          @BoolExprAllowCF( falseLabel )
2496:          @CFToVal( falseLabel )
2503:          @MatchTypes
2505:          [ oTypeSNodeType
2507:             | nIntegerType, nBooleanType :  .tEqualI
2510:             | nPointerType :                .tEqualP
2514:             | nCharType, nStringType :      #eNotImplemented
2518:             | * :                           #eNotAllowed
2533:          ]
2533:          oTypeSPop
2534:          oTypeSPush( BooleanType )
      
2540:       | '<>' :
2542:          @CFToVal( falseLabel )
2549:          @BoolExprAllowCF( falseLabel )
2556:          @CFToVal( falseLabel )
2563:          @MatchTypes
2565:          [ oTypeSNodeType
2567:             | nIntegerType, nBooleanType :  .tNotEqualI
2570:             | nPointerType :                .tNotEqualP
2574:             | nCharType, nStringType :      #eNotImplemented
2578:             | * :                           #eNotAllowed
2593:          ]
2593:          oTypeSPop
2594:          oTypeSPush( BooleanType )
      
2600:       | '<' :
2602:          @CFToVal( falseLabel )
2609:          @BoolExprAllowCF( falseLabel )
2616:          @CFToVal( falseLabel )
2623:          @MatchTypes
2625:          [ oTypeSNodeType
2627:             | nIntegerType, nBooleanType :  .tLessI
2630:             | nCharType, nStringType :      #eNotImplemented
2634:             | * :                           #eNotAllowed
2647:          ]
2647:          oTypeSPop
2648:          oTypeSPush( BooleanType )
      
2654:       | '>' :
2656:          @CFToVal( falseLabel )
2663:          @BoolExprAllowCF( falseLabel )
2670:          @CFToVal( falseLabel )
2677:          @MatchTypes
2679:          [ oTypeSNodeType
2681:             | nIntegerType, nBooleanType :  .tGreaterI
2684:             | nCharType, nStringType :      #eNotImplemented
2688:             | * :                           #eNotAllowed
2701:          ]
2701:          oTypeSPop
2702:          oTypeSPush( BooleanType )
      
2708:       | '<=' :
2710:          @CFToVal( falseLabel )
2717:          @BoolExprAllowCF( falseLabel )
2724:          @CFToVal( falseLabel )
2731:          @MatchTypes
2733:          [ oTypeSNodeType
2735:             | nIntegerType, nBooleanType :  .tLessEqualI
2738:             | nCharType, nStringType :      #eNotImplemented
2742:             | * :                           #eNotAllowed
2755:          ]
2755:          oTypeSPop
2756:          oTypeSPush( BooleanType )
      
2762:       | '>=' :
2764:          @CFToVal( falseLabel )
2771:          @BoolExprAllowCF( falseLabel )
2778:          @CFToVal( falseLabel )
2785:          @MatchTypes
2787:          [ oTypeSNodeType
2789:             | nIntegerType, nBooleanType :  .tGreaterEqualI
2792:             | nCharType, nStringType :      #eNotImplemented
2796:             | * :                           #eNotAllowed
2809:          ]
2809:          oTypeSPop
2810:          oTypeSPush( BooleanType )
      
2816:       | * :
2831:          >
2833:    ]};
      
      
2836: BoolExprAllowCF( out Label falseLabel ):
2838:    Label trueLabel = labelNull
      
2844:    @BoolTermAllowCF( falseLabel )
2851:    {[
2851:       | pOr :
2853:          [ oTypeSNodeType
2855:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
2856:                [ equal_label( trueLabel, labelNull )
2866:                   | true :  trueLabel = oLabelNew
2872:                   | * :
2877:                ]
2877:                .tJump  oEmitLabel( trueLabel )
2885:             | nBooleanType :
2887:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
2894:                [ equal_label( trueLabel, labelNull )
2904:                   | true :  trueLabel = oLabelNew
2910:                   | * :
2915:                ]
2915:                .tJump  oEmitLabel( trueLabel )
2923:             | * : #eNotBoolean
2932:          ]
2932:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
2933:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
2941:          falseLabel = labelNull
2947:          @BoolTermAllowCF( falseLabel )
      
2954:          [ oTypeSNodeType
2956:             | nBooleanCFType :
2957:             | nBooleanType :
2959:                @ValToCF( falseLabel )
2966:             | * : #eNotBoolean
2975:          ]
      
2975:          oTypeSPop
2976:          oTypeSPush( BooleanCFType )
      
2982:       | * :
2987:          >
2989:    ]}
      
         % any short-circuit trues jump here to the end
2991:    [ equal_label( trueLabel, labelNull )
3001:       | false :
3002:          .tLabel  oEmitLabel( trueLabel )
3010:       | * :
3015:    ]
3016:    ;
      
      
3016: BoolTermAllowCF( out Label falseLabel ):
3018:    Label overallFalseLabel = labelNull
      
3024:    @BoolFactorAllowCF( falseLabel )
3031:    {[
3031:       | pAnd :
3033:          [ oTypeSNodeType
3035:             | nBooleanCFType :
3036:             | nBooleanType :
3038:                @ValToCF( falseLabel )
3045:             | * :
3052:                #eNotBoolean
3054:          ]
3054:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
3055:          [ equal_label( overallFalseLabel, labelNull )
3065:             | true :
3066:                overallFalseLabel = oLabelNew
3071:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
3085:                falseLabel = overallFalseLabel
3091:             | * :
3096:          ]
      
3096:          Label factorFalseLabel = labelNull
3102:          @BoolFactorAllowCF( factorFalseLabel )
      
3109:          [ oTypeSNodeType
3111:             | nBooleanCFType :
3112:             | nBooleanType :
3114:                @ValToCF( factorFalseLabel )
3121:             | * : #eNotBoolean
3130:          ]
3130:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
3144:       | * :
3149:          >
3151:    ]};
      
3154: BoolFactorAllowCF( out Label falseLabel ):
3156:    [
3156:       | pNot :
3158:          Label factorFalseLabel = labelNull
      
3164:          @BoolFactorAllowCF( factorFalseLabel )
3171:          [ oTypeSNodeType
3173:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
3174:                falseLabel = oLabelNew
3179:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
3187:                .tLabel  oEmitLabel( factorFalseLabel )
      
3195:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
3197:                .tNot
      
3199:             | * : #eNotBoolean
3208:          ]
      
3208:       | * :
3213:          @ArithExprAllowCF( falseLabel )
3220:    ];
      
3221: ArithExprAllowCF( out Label falseLabel ):
3223:    @TermAllowCF( falseLabel )
3230:    {[
3230:       | pPlus :
3232:          @RequireIntPop
3234:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3241:          @RequireInt
3243:          .tAddI
3245:       | pMinus :
3247:          @RequireIntPop
3249:          @TermAllowCF( falseLabel )
3256:          @RequireInt
3258:          .tSubI
3260:       | * :
3267:          >
3269:    ]};
      
3272: TermAllowCF( out Label falseLabel ):
3274:    @FactorAllowCF( falseLabel )
3281:    {[
3281:       | pTimes :
3283:          @RequireIntPop
3285:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3292:          @RequireInt
3294:          .tMultI
3296:       | pDivide :
3298:          @RequireIntPop
3300:          @FactorAllowCF( falseLabel )
3307:          @RequireInt
3309:          .tDivI
3311:       | * :
3318:          >
3320:    ]};
      
3323: FactorAllowCF( out Label falseLabel ):
3325:    [
3325:       | pPlus :
3327:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
3334:          @RequireInt
3336:       | pMinus :
3338:          @PrimaryAllowCF( falseLabel )
3345:          @RequireInt
3347:          .tNegI
3349:       | * :
3356:          @PrimaryAllowCF( falseLabel )
3363:    ];
      
3364: PrimaryAllowCF( out Label falseLabel ):
3366:    [
3366:       | pIntLit :
3368:          .tPushConstI  oEmitInt( TOKEN_VALUE )
3375:          oTypeSPush( IntegerType )
      
3381:       | '(' :
3383:          @ExprAllowCF( falseLabel )
3390:          ')'
      
3392:       | pStrLit :
3394:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
3403:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
3411:          oTypeSPush( StringType )
      
3417:       | pIdent :
3419:          Node decl = oScopeFindRequire
3424:          Node theType
      
3424:          [ oNodeType( decl )
3431:             | nFunc :
      
3432:                @Call( decl )
      
3439:             | nConst :
3441:                theType = oNodeGet( decl, qType )
3454:                oTypeSPush( theType )
3460:                [ oTypeSNodeType
3462:                   | nIntegerType, nBooleanType :
3463:                      .tPushConstI @EmitValue( decl )
3472:                   | * :
3479:                      #eNotImplemented
3481:                ]
      
3481:             | nGlobalVar, nLocalVar, nParam :
3483:                @VarExpr( decl )
      
3490:             | * :
3503:                #eNotValue
3505:                oTypeSPush( IntegerType )
3511:          ]
      
3511:       | '@' :        % @var -- pointer to var
3513:          pIdent
      
3515:          Node decl = oScopeFindRequire
3520:          Node theType
      
3520:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
3527:          theType = oTypeSTop
3532:          oTypeSPop
3533:          Node ptrType = @PointerTypeTo( theType )
3544:          oTypeSPush( ptrType )
      
3550:       | * :
3563:          #eNotValue
3565:          oTypeSPush( IntegerType )
3571:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
3572: VarExpr( Node decl ):
3574:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
3587:    Node declScope = oNodeGet( decl, qParentScope )
3600:    int uplevels = subtract( oNodeGetInt( oScopeCurrent, qLevel ), oNodeGetInt( declScope, qLevel ) )
      
3626:    oTypeSPush( theType )
3632:    [ oTypeSNodeType
3634:       | nIntegerType :
3635:          [ oNodeType( decl )
3642:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
3652:             | nLocalVar :
3654:                [ equal_zero( uplevels )
3661:                   | true :  .tPushLocalI  @EmitValue( decl )
3671:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
3691:                ]
3691:             | nParam :
3693:                [ oNodeGetBoolean( decl, qInOut )
3703:                   | true :    % VAR param points to the var.  Auto dereference.
3704:                      [ equal_zero( uplevels )
3711:                         | true :  .tPushParamP  @EmitValue( decl )
3721:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3741:                      ]
3741:                      .tFetchI
3743:                   | * :
3748:                      [ equal_zero( uplevels )
3755:                         | true :  .tPushParamI  @EmitValue( decl )
3765:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
3785:                      ]
3785:                ]
3785:          ]
      
3795:       | nBooleanType :
3797:          [ oNodeType( decl )
3804:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
3814:             | nLocalVar :
3816:                [ equal_zero( uplevels )
3823:                   | true :  .tPushLocalB  @EmitValue( decl )
3833:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
3853:                ]
3853:             | nParam :
3855:                [ oNodeGetBoolean( decl, qInOut )
3865:                   | true :    % VAR param points to the var.  Auto dereference.
3866:                      [ equal_zero( uplevels )
3873:                         | true :  .tPushParamP  @EmitValue( decl )
3883:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
3903:                      ]
3903:                      .tFetchB
3905:                   | * :
3910:                      [ equal_zero( uplevels )
3917:                         | true :  .tPushParamB  @EmitValue( decl )
3927:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
3947:                      ]
3947:                ]
3947:          ]
      
3957:       | nCharType, nStringType, nFileType :
3959:          #eNotImplemented
      
3961:       | nPointerType :
3963:          [ oNodeType( decl )
3970:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
3980:             | nLocalVar :
3982:                [ equal_zero( uplevels )
3989:                   | true :  .tPushLocalP  @EmitValue( decl )
3999:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
4019:                ]
4019:             | nParam :
4021:                [ oNodeGetBoolean( decl, qInOut )
4031:                   | true :    % VAR param points to the var.  Auto dereference.
4032:                      [ equal_zero( uplevels )
4039:                         | true :  .tPushParamP  @EmitValue( decl )
4049:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4069:                      ]
4069:                      .tFetchP
4071:                   | * :
4076:                      [ equal_zero( uplevels )
4083:                         | true :  .tPushParamP  @EmitValue( decl )
4093:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4113:                      ]
4113:                ]
4113:          ]
4123:          [
4123:             | '^' :             % dereferenced
4125:                oTypeSPop
4126:                oTypeSPush( oNodeGet( theType, qBaseType ) )
4139:                @LValueIndexes
4141:                @FetchVar
4143:             | * :               % just ptr value alone
4148:          ]
      
4148:       | * :
               % compound type
               % first, push addr of start of var
4163:          [ oNodeType( decl )
4170:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
4180:             | nLocalVar :
4182:                [ equal_zero( uplevels )
4189:                   | true :  .tPushAddrLocal  @EmitValue( decl )
4199:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
4219:                ]
4219:             | nParam :
4221:                [ oNodeGetBoolean( decl, qInOut )
4231:                   | true :    % VAR param points to the var.  Auto dereference.
4232:                      [ equal_zero( uplevels )
4239:                         | true :  .tPushParamP  @EmitValue( decl )
4249:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
4269:                      ]
4269:                   | * :
4274:                      [ equal_zero( uplevels )
4281:                         | true :  .tPushAddrParam  @EmitValue( decl )
4291:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
4311:                      ]
4311:                ]
4311:          ]
               % modify addr for subscripts, field references, etc
4321:          @LValueIndexes
               % get final value
4323:          @FetchVar
4325:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
4326: FetchVar:
4328:    [ oTypeSNodeType
4330:       | nIntegerType :   .tFetchI
4333:       | nBooleanType :   .tFetchB
4337:       | nCharType, nStringType, nFileType : #eNotImplemented
4341:       | nPointerType :   .tFetchP
4345:       | * :              % compound type; leave as addr
4360:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
4361: LValueIndexes:
4363:    {[
4363:       | '[' :       @ArraySubscripts
4367:       | '.' :       @RecordFieldRef
4371:       | '^' :       @PointerDeref
4375:       | * :         >
4386:    ]};
      
4389: ArraySubscripts:
4391:    [ oTypeSNodeType
4393:       | nArrayType :
4394:       | * :       #eNotArray
4401:    ]
4401:    {
4401:       [ oTypeSNodeType
4403:          | nArrayType :
4404:          | * :    #eTooManySubscripts
4411:       ]
      
            % low subscript of this dimension
4411:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
4428:       Node baseType
4428:       baseType = oNodeGet( oTypeSTop, qBaseType )
4440:       oTypeSPop
4441:       oTypeSPush( baseType )
      
4447:       @Expr
4449:       @RequireIntPop
            % adjust for low subscript
4451:       [ equal_zero( low )
4458:          | false :
4459:             .tPushConstI oEmitInt( low ) .tSubI
4469:          | * :
4474:       ]
      
            % multiply by element size
4474:       int size = oNodeGetInt( baseType, qSize )
4487:       [ equal( size, 1 )
4497:          | false :
4498:             .tPushConstI oEmitInt( size ) .tMultI
4508:          | * :
4513:       ]
      
            % update start address
4513:       .tAddPI
4515:       [
4515:          | ']' :  >
4519:          | ',' :
4521:       ]
4529:    };
      
      
4532: RecordFieldRef:
4534:    [ oTypeSNodeType
4536:       | nRecordType :
4537:       | * :    #eNotRecord
4544:    ]
4544:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
4556:    pIdent
4558:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
4563:    [ oNodeType( field )
4570:       | nRecordField :
4571:       | * :   #eNotRecordField
4578:    ]
4578:    oScopeEnd
4579:    int offset = oNodeGetInt( field, qValue )
4592:    [ equal_zero( offset )
4599:       | false :
4600:          .tPushConstI oEmitInt( offset ) .tAddPI
4610:       | * :
4615:    ]
      
         % replace the type on the type stack, with the field type
4615:    oTypeSPop
4616:    oTypeSPush( oNodeGet( field, qType ) )
4630:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
4630: PointerDeref:
4632:    [ oTypeSNodeType
4634:       | nPointerType :
4635:       | * :       #eNotPointer
4642:    ]
4642:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
4644:    Node theType = oTypeSTop
4649:    oTypeSPop
4650:    oTypeSPush( oNodeGet( theType, qBaseType ) )
4664:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
4664: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
4666:    @MatchTypes
4669:    ;
      
      
      % Called on first use of an extern method
      %
4669: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
4671:    int strAddr
4671:    String externalName = oNodeGetString( method, qExternalName )
4684:    [ equal_string( externalName, stringNull )
4694:       | true :
4695:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
4716:       | false :
4718:          strAddr = oStringAllocLit( externalName )
4728:    ]
4736:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
4752:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
4752: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
4754:    [ oNodeGetBoolean( method, qExternal )
4764:       | true :
4765:          [ oNodeGetBoolean( method, qCalled )
4775:             | false :
                     % define the extern label on first use
4776:                @DefineExternLabel( method )
4783:             | * :
4788:          ]
4788:      | * :
4793:    ]
4793:    oNodeSetBoolean( method, qCalled, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
4805:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
4818:    Node resultType
4818:    int tempOffset
      
4818:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
4835:    [ isFunc
4838:       | true :
4839:          resultType = oNodeGet( method, qType )
4852:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
4862:       | * :
4867:    ]
         
      
4867:    Node paramScope = oNodeGet( method, qParams )
4880:    int actualsSize = oNodeGetInt( paramScope, qSize )
4893:    [ cdecl
4896:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
4905:       | false :  .tAllocActuals  oEmitInt( actualsSize )
4915:    ]
      
4923:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
4936:    Node param = oNodeIterValue( paramIter )
4946:    [
4946:       | '(' :
            
4948:          {
4948:             [ oNodeNull( param )
4955:                | true : >
4958:                | * :
4963:             ]
      
4963:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
4976:             .tPushAddrActual oEmitInt( offset )
4984:             oTypeSPush( oNodeGet( param, qType ) )
      
4997:             [ oNodeGetBoolean( param, qInOut )
5007:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
5008:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
5010:                           @MatchTypes
      
5012:                           .tAssignP
      
5014:                | false :  @Expr
5018:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
5020:                           [ oTypeSNodeType
5022:                              | nIntegerType :            .tAssignI
5025:                              | nBooleanType :            .tAssignB
5029:                              | nCharType, nStringType, nFileType :   #eNotImplemented
5033:                              | nPointerType :            .tAssignP
5037:                              | * :
                                       % compound types: copy value into actuals space
5052:                                  int size = oNodeGetInt( oTypeSTop, qSize )
5064:                                  .tCopy  oEmitInt( size )    % multi-word copy
5072:                           ]
5072:             ]
5080:             oTypeSPop
      
5081:             oNodeIterNext( paramIter )
5087:             param = oNodeIterValue( paramIter )
5097:             [ oNodeNull( param )
5104:                | true :  >
5107:                | false :
5109:             ]
      
5117:             ','
5119:          }
      
5121:          ')'
      
5123:       | * :
5128:    ]
      
5128:    [ oNodeNull( param )
5135:       | false :    #eMissingParameter
5138:       | * :
5143:    ]
      
5143:    [ isFunc
5146:       | true :
               % Pass result temp as an additional VAR parameter.
5147:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
5162:          .tPushAddrLocal  oEmitInt( tempOffset )
5170:          .tAssignP
5172:       | * :
5177:    ]
      
5177:    [ cdecl
5180:       | true :
5181:          .tCallCdecl  @EmitValue( method )
5190:       | false :
5192:          .tCall   @EmitValue( method )
5201:    ]
      
5209:    [ isFunc
5212:       | true :
               % push return value from temp
5213:          oTypeSPush( resultType )
      
5219:          [ oTypeSNodeType
5221:             | nIntegerType :   .tPushLocalI  oEmitInt( tempOffset )
5230:             | nBooleanType :   .tPushLocalB  oEmitInt( tempOffset )
5240:             | nCharType, nStringType, nFileType : #eNotImplemented
5244:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
5254:             | * :              % compound type: push address
5269:                                .tPushAddrLocal  oEmitInt( tempOffset )
5277:          ]
5277:       | * :
5282:    ]
         
5282:    .tFreeActuals  oEmitInt( actualsSize )
5291:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
5291: Statement:
5293:    [
5293:       | pWriteln :     @WritelnStmt
5297:       | pWrite :       @WriteStmt
5301:       | pReadln :      @ReadlnStmt
5305:       | pRead :        @ReadStmt
5309:       | pIf :          @IfStmt
5313:       | pWhile :       @WhileStmt
5317:       | pFor :         @ForStmt
5321:       | pRepeat :      @RepeatStmt
5325:       | pBreak :       @BreakStmt
5329:       | pContinue :    @ContinueStmt
5333:       | pBegin :       @BeginStmt
5337:       | pIdent :       @AssignOrCallStmt
5341:       | * :            % null statement : don't accept any tokens
5368:    ];
      
      
5369: AssignOrCallStmt:
5371:    Node decl = oScopeFindRequire
5376:    [ oNodeType( decl )
5383:       | nProc :                           @Call( decl )
5391:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
5400:       | nFunc :                           @AssignResultStmt( decl )
5409:       | * :                               #eBadStatement
5424:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
5425: AssignStmt( Node decl ):
      
5427:    @LValueVar( decl )
5434:    ':=' 
5436:    @Expr
5438:    @MatchTypes
5440:    @Assign
5443:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
5443: Assign:
5445:    [ oTypeSNodeType
5447:       | nIntegerType :            .tAssignI
5450:       | nBooleanType :            .tAssignB
5454:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5458:       | nPointerType :            .tAssignP
5462:       | * :
5477:           int size = oNodeGetInt( oTypeSTop, qSize )
5489:           .tCopy  oEmitInt( size )    % multi-word copy
5497:    ]
5497:    oTypeSPop
5499:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
5499: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
5501:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
5517:       | false :   #eNotCurrentFunction
5520:       | * :
5525:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
5525:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
5540:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
5553:    ':='
5555:    @Expr
5557:    @MatchTypes
5559:    [ oTypeSNodeType
5561:       | nIntegerType :            .tAssignI
5564:       | nBooleanType :            .tAssignB
5568:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
5572:       | nPointerType :            .tAssignP
5576:       | * :
5591:           int size = oNodeGetInt( oTypeSTop, qSize )
5603:           .tCopy  oEmitInt( size )    % multi-word copy
5611:    ]
5611:    oTypeSPop
5613:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
5613: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
5615:    pIdent
5617:    Node decl = oScopeFindRequire
5622:    [ oNodeType( decl )
5629:       | nGlobalVar, nLocalVar, nParam :
5630:       | * :  #eNotVar
5641:    ]
5641:    @LValueVar( decl )
5649:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
5649: LValueVar( Node decl ):
5651:    [ oNodeType( decl )
5658:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
5668:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
5679:       | nParam :
5681:          [ oNodeGetBoolean( decl, qInOut )
5691:             | true :   % VAR param points to variable.  No dereference.
5692:                        .tPushParamP @EmitValue( decl )
5701:             | * :      .tPushAddrParam @EmitValue( decl )
5715:          ]
5715:       | * :            #eNotVar
5726:    ]
      
5726:    oTypeSPush( oNodeGet( decl, qType ) )
5739:    @LValueIndexes        % handle subscripts, if any
5742:    ;
      
      
5742: IncVar( Node decl ):
5744:    @LValueVar( decl )
5751:    @RequireIntPop
5753:    @VarExpr( decl )
5760:    oTypeSPop
5761:    .tIncI
5763:    .tAssignI;
      
5766: DecVar( Node decl ):
5768:    @LValueVar( decl )
5775:    @RequireIntPop
5777:    @VarExpr( decl )
5784:    oTypeSPop
5785:    .tDecI
5787:    .tAssignI;
      
      
5790: IfStmt:
5792:    Label falseLabel = labelNull
      
5798:    @BooleanExprControlFlow( falseLabel )
5805:    pThen
5807:    @Statement
5809:    [
5809:       | pElse :
5811:          Label doneLabel = oLabelNew
      
5816:          .tJump  oEmitLabel( doneLabel )
5824:          .tLabel oEmitLabel( falseLabel )
5832:          @Statement
5834:          .tLabel oEmitLabel( doneLabel )
      
5842:       | * :
5847:          .tLabel oEmitLabel( falseLabel )
5855:    ];
      
      
5856: ForStmt:
5858:    pIdent
      
5860:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
5865:    @LValueVar( decl )
5872:    @RequireIntPop
      
5874:    ':='
      
5876:    @Expr
5878:    @RequireIntPop
5880:    .tAssignI
      
5882:    Label breakLabel = oLabelNew
      
5887:    Label checkLabel = oLabelNew
5892:    .tJump  oEmitLabel( checkLabel )
      
5900:    Label continueLabel = oLabelNew
5905:    .tLabel  oEmitLabel( continueLabel )
5913:    [
5913:       | pTo :
5915:          @IncVar( decl )
5922:          .tLabel  oEmitLabel( checkLabel )
5930:          @VarExpr( decl )  oTypeSPop
5938:          @Expr
5940:          @RequireIntPop
5942:          .tGreaterI
5944:          .tJumpTrue  oEmitLabel( breakLabel )
5952:       | pDownto :
5954:          @DecVar( decl )
5961:          .tLabel  oEmitLabel( checkLabel )
5969:          @VarExpr( decl )  oTypeSPop
5977:          @Expr
5979:          @RequireIntPop
5981:          .tLessI
5983:          .tJumpTrue  oEmitLabel( breakLabel )
5991:    ]
5999:    oLoopPush( continueLabel, breakLabel )
6008:    pDo
6010:    @Statement
6012:    .tJump  oEmitLabel( continueLabel )
6020:    .tLabel  oEmitLabel( breakLabel )
6028:    oLoopPop;
      
      
6030: RepeatStmt:
6032:    Label continueLabel = oLabelNew
6037:    .tLabel  oEmitLabel( continueLabel )
      
6045:    Label breakLabel = oLabelNew
      
6050:    oLoopPush( continueLabel, breakLabel )
6059:    @Statement
6061:    {[
6061:       | ';' :
6063:          @Statement
6065:       | pUntil :
6067:          Label falseLabel
6067:          @BooleanExprControlFlow( falseLabel )
6074:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
6088:          >
6090:    ]}
6100:    .tLabel  oEmitLabel( breakLabel )
6108:    oLoopPop;
      
      
6110: WhileStmt:
6112:    Label continueLabel = oLabelNew
6117:    .tLabel  oEmitLabel( continueLabel )
      
6125:    Label breakLabel
6125:    @BooleanExprControlFlow( breakLabel )
      
6132:    oLoopPush( continueLabel, breakLabel )
6141:    pDo
6143:    @Statement
6145:    .tJump  oEmitLabel( continueLabel )
6153:    .tLabel  oEmitLabel( breakLabel )
6161:    oLoopPop;
      
      
6163: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
6165:    [ equal_label( oLoopContinueLabel, labelNull )
6174:       | true :
6175:          #eNotInALoop
6177:       | false :
6179:          .tJump  oEmitLabel( oLoopContinueLabel )
6186:    ];
      
      
6195: BreakStmt:
6197:    [ equal_label( oLoopBreakLabel, labelNull )
6206:       | true :
6207:          #eNotInALoop
6209:       | false :
6211:          .tJump  oEmitLabel( oLoopBreakLabel )
6218:    ];
      
      
6227: BeginStmt:
6229:    @Statement
6231:    {[
6231:       | ';' :   @Statement
6235:       | pEnd :  >
6239:    ]};
      
      
6250: WritelnStmt:
6252:    @WriteStmt
6254:    .tWriteCR;
      
      
6257: WriteStmt:
6259:    [
6259:       | '(' :
6261:          {
6261:             @Expr
6263:             [ oTypeSNodeType
6265:                | nIntegerType :             .tWriteI
6268:                | nBooleanType :             .tWriteBool
6272:                | nStringType :              .tWriteStr
6276:                | nCharType, nFileType :     #eNotImplemented
6280:                | nPointerType :             .tWriteP
6284:                | * :                        #eNotAllowed
6301:             ]
6301:             oTypeSPop
6302:             [
6302:                | ')' : >
6306:                | ',' :
6308:             ]
6316:          }
6318:       | * :
6323:    ];
      
      
6324: ReadlnStmt:      % ***
         % TO DO
6327:    ;
      
6327: ReadStmt:
         % TO DO
6330:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
6330: MatchTypes:
6332:    node_type nt = oTypeSNodeType
6337:    oTypeSPop
6338:    [ equal_node_type( nt, oTypeSNodeType )
6347:       | false :
6348:          #eTypeMismatch
6350:       | * :
6355:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
6356: RequireIntPop:
6358:    [ oTypeSNodeType
6360:       | nIntegerType :
6361:       | * :          #eNotInteger
6368:    ]
6368:    oTypeSPop;
      
6370: RequireInt:
6372:    [ oTypeSNodeType
6374:       | nIntegerType :
6375:       | * :          #eNotInteger
6382:    ];
      
6383: RequireBoolPop:
6385:    [ oTypeSNodeType
6387:       | nBooleanType :
6388:       | * :          #eNotBoolean
6395:    ]
6395:    oTypeSPop;
      
6397: RequireBool:
6399:    [ oTypeSNodeType
6401:       | nBooleanType :
6402:       | * :          #eNotBoolean
6409:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
6410: newType( node_type nt, int size ) >> Node:
6412:   Node node = oNodeNew( nt )
6422:   oNodeSetInt( node, qSize, size )
6434:   oTypeAdd( node )
6440:   >> node
6444:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
6444: newIdent( node_type nt, kind k, int id ) >> Node:
6446:   Node t = oNodeNew( nt )
6456:   oNodeSetInt( t, qIdent, id )
6468:   >> t
6472:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
6472: PointerTypeTo( Node theType ) >> Node:
6474:    Node ptrType = oNodeGet( theType, qPointerType )
6487:    [ oNodeNull( ptrType )
6494:       | true :
6495:          ptrType = oNodeNew( nPointerType )
6505:          oNodeSet( ptrType, qBaseType, theType )
6517:          oNodeSetInt( ptrType, qSize, 8 )
6529:          oTypeAdd( ptrType )
6535:          oNodeSet( theType, qPointerType, ptrType )
6547:       | * :
6552:    ]
6552:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
6556: OrdinalLow( Node theType ) >> int:
6558:    [ oNodeType( theType )
6565:       | nIntegerType :  >> oMININT    % NOTE ssl literals are limited to 16 bit at the moment, though values are 32 bit ok. So need a mechanism.
6568:       | nBooleanType :  >> 0
6573:       | nCharType :     >> 0
6578:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
6590:       | * :             #eNotOrdinalType
6603:                         >> 0
6606:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
6607: EmitValue( Node decl ):
6609:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
6623: installBuiltIns:
      
         % install built-in types
6625:    FileType = @newType( nFileType, 4 )
6639:    IntegerType = @newType( nIntegerType, 4 )
6653:    BooleanType = @newType( nBooleanType, 1 )
6667:    BooleanCFType = @newType( nBooleanCFType, 1 )
6681:    CharType = @newType( nCharType, 1 )
6695:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
6709:    Node t
      
6709:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
6725:    oNodeSet( t, qType, FileType )
6737:    oScopeDeclare( t )
      
6743:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
6759:    oNodeSet( t, qType, IntegerType )
6771:    oScopeDeclare( t )
      
6777:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
6793:    oNodeSet( t, qType, BooleanType )
6805:    oScopeDeclare( t )
      
6811:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
6827:    oNodeSet( t, qType, CharType )
6839:    oScopeDeclare( t )
      
6845:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
6861:    oNodeSet( t, qType, StringType )
6873:    oScopeDeclare( t )
      
         % Built-in constants
      
6879:    t = @newIdent( nConst, kConst, oIdAdd_True )
6895:    oNodeSet( t, qType, BooleanType )
6907:    oNodeSetInt( t, qValue, 1 )
6919:    oScopeDeclare( t )
      
6925:    t = @newIdent( nConst, kConst, oIdAdd_False )
6941:    oNodeSet( t, qType, BooleanType )
6953:    oNodeSetInt( t, qValue, 0 )
6965:    oScopeDeclare( t )
      
6972:    ;
      
6972: end
      
6972: 

Generated code:

   0: oGlobalSpace 9
   2: oLocalSpace 3
   4: oSetResult 0
   6: oPushResult
   7: oScopeBegin
   8: oPop 1
  10: oGetAddrGlobal 1
  12: oPushResult
  13: oScopeCurrent
  14: oAssign
  15: oCall 6623
  17: oEmit 52
  19: oSetResult 0
  21: oPushResult
  22: oEmitInt
  23: oPop 1
  25: oGetAddrLocal 2
  27: oPushResult
  28: oLabelNew
  29: oAssign
  30: oEmit 46
  32: oSetResult 0
  34: oPushResult
  35: oEmitInt
  36: oPop 1
  38: oEmit 49
  40: oGetLocal 2
  42: oPushResult
  43: oEmitLabel
  44: oPop 1
  46: oEmit 48
  48: oSetResult 0
  50: oPushResult
  51: oEmitInt
  52: oPop 1
  54: oEmit 51
  56: oInput 27
  58: oInput 0
  60: oGetAddrLocal 3
  62: oPushResult
  63: oSetResult 5
  65: oPushResult
  66: oSetResult 1
  68: oPushResult
  69: LAST_ID
  70: oPushResult
  71: oCall 6444
  73: oPop 3
  75: oAssign
  76: oGetLocal 3
  78: oPushResult
  79: oScopeDeclare
  80: oPop 1
  82: oInputChoice 162
  84: oInput 0
  86: oGetAddrLocal 1
  88: oPushResult
  89: oSetResult 11
  91: oPushResult
  92: oSetResult 6
  94: oPushResult
  95: LAST_ID
  96: oPushResult
  97: oCall 6444
  99: oPop 3
 101: oAssign
 102: oGetLocal 1
 104: oPushResult
 105: oSetResult 8
 107: oPushResult
 108: oGetGlobal 3
 110: oPushResult
 111: oNodeSet
 112: oPop 3
 114: oGetLocal 1
 116: oPushResult
 117: oScopeDeclareAlloc
 118: oPop 1
 120: oInput 12
 122: oInput 0
 124: oGetAddrLocal 1
 126: oPushResult
 127: oSetResult 11
 129: oPushResult
 130: oSetResult 6
 132: oPushResult
 133: LAST_ID
 134: oPushResult
 135: oCall 6444
 137: oPop 3
 139: oAssign
 140: oGetLocal 1
 142: oPushResult
 143: oSetResult 8
 145: oPushResult
 146: oGetGlobal 3
 148: oPushResult
 149: oNodeSet
 150: oPop 3
 152: oGetLocal 1
 154: oPushResult
 155: oScopeDeclareAlloc
 156: oPop 1
 158: oInput 14
 160: oJumpForward 165
 162: Choice Lookup Table
          13     84
 165: oInput 4
 167: oSetResult 0
 169: oPushResult
 170: oScopeBegin
 171: oPop 1
 173: oGetAddrGlobal 2
 175: oPushResult
 176: oScopeCurrent
 177: oAssign
 178: oScopeCurrent
 179: oPushResult
 180: oSetResult 4
 182: oPushResult
 183: oSetResult 1
 185: oPushResult
 186: oNodeSetBoolean
 187: oPop 3
 189: oGetLocal 3
 191: oPushResult
 192: oSetResult 10
 194: oPushResult
 195: oScopeCurrent
 196: oPushResult
 197: oNodeSet
 198: oPop 3
 200: oScopeEnd
 201: oSetResult 12
 203: oPushResult
 204: oCall 248
 206: oPop 1
 208: oGetGlobal 2
 210: oPushResult
 211: oScopeEnter
 212: oPop 1
 214: oGetLocal 2
 216: oPushResult
 217: oGetGlobal 1
 219: oPushResult
 220: oCall 298
 222: oPop 2
 224: oScopeEnd
 225: oInput 19
 227: oScopeEnd
 228: oReturn
 229: oLocalSpace 0
 231: oGetParam 2
 233: oPushResult
 234: oCall 248
 236: oPop 1
 238: oGetParam 1
 240: oPushResult
 241: oScopeCurrent
 242: oPushResult
 243: oCall 298
 245: oPop 2
 247: oReturn
 248: oLocalSpace 0
 250: oInputChoice 277
 252: oCall 1407
 254: oJumpForward 290
 256: oCall 1479
 258: oJumpForward 290
 260: oGetParam 1
 262: oPushResult
 263: oCall 1538
 265: oPop 1
 267: oJumpForward 290
 269: oCall 493
 271: oJumpForward 290
 273: oCall 806
 275: oJumpForward 290
 277: Choice Lookup Table
          29    273
          28    269
          32    260
          31    256
          30    252
 288: oJumpForward 292
 290: oJumpBack 250
 292: oCall 295
 294: oReturn
 295: oLocalSpace 0
 297: oReturn
 298: oLocalSpace 3
 300: oEmit 56
 302: oGetParam 2
 304: oPushResult
 305: oEmitLabel
 306: oPop 1
 308: oEmit 52
 310: oGetAddrLocal 1
 312: oPushResult
 313: Here
 314: oAssign
 315: oEmit 64
 317: oGetAddrLocal 2
 319: oPushResult
 320: oGetParam 1
 322: oPushResult
 323: oSetResult 5
 325: oPushResult
 326: oNodeGetCode
 327: oPop 2
 329: oAssign
 330: oGetLocal 2
 332: oPushResult
 333: oEmitCode
 334: oPop 1
 336: oScopeCurrent
 337: oPushResult
 338: oSetResult 5
 340: oPushResult
 341: oSetResult 0
 343: oPushResult
 344: oNodeSetCode
 345: oPop 3
 347: oCall 5291
 349: oEmit 51
 351: oGetAddrLocal 3
 353: oPushResult
 354: oScopeCurrent
 355: oPushResult
 356: oSetResult 3
 358: oPushResult
 359: oNodeGetInt
 360: oPop 2
 362: oAssign
 363: oGetLocal 1
 365: oPushResult
 366: oGetLocal 3
 368: oPushResult
 369: oPatch
 370: oPop 2
 372: oReturn
 373: oLocalSpace 0
 375: oInputChoice 393
 377: oGetParam 1
 379: oPushResult
 380: oSetResult 16
 382: oPushResult
 383: oSetResult 1
 385: oPushResult
 386: oNodeSetBoolean
 387: oPop 3
 389: oInput 4
 391: oJumpForward 398
 393: Choice Lookup Table
          61    377
 396: oJumpForward 400
 398: oJumpBack 375
 400: oReturn
 401: oLocalSpace 1
 403: oGetAddrLocal 1
 405: oPushResult
 406: oScopeCurrent
 407: oPushResult
 408: oSetResult 5
 410: oPushResult
 411: oNodeGetCode
 412: oPop 2
 414: oAssign
 415: oGetLocal 1
 417: oPushResult
 418: oSetResult 0
 420: oPushResult
 421: equal_code
 422: oPop 2
 424: oChoice 444
 426: oGetAddrLocal 1
 428: oPushResult
 429: oCodeNew
 430: oAssign
 431: oScopeCurrent
 432: oPushResult
 433: oSetResult 5
 435: oPushResult
 436: oGetLocal 1
 438: oPushResult
 439: oNodeSetCode
 440: oPop 3
 442: oJumpForward 447
 444: Choice Lookup Table
           1    426
 447: oGetLocal 1
 449: oReturn
 450: oReturn
 451: oLocalSpace 0
 453: oGetParam 1
 455: oPushResult
 456: oSetResult 14
 458: oPushResult
 459: oSetResult 1
 461: oPushResult
 462: oNodeSetBoolean
 463: oPop 3
 465: oInputChoice 489
 467: oInputChoice 484
 469: oInput 2
 471: oGetParam 1
 473: oPushResult
 474: oSetResult 15
 476: oPushResult
 477: CURRENT_STRLIT
 478: oPushResult
 479: oNodeSetString
 480: oPop 3
 482: oJumpForward 487
 484: Choice Lookup Table
          60    469
 487: oJumpForward 492
 489: Choice Lookup Table
           2    467
 492: oReturn
 493: oLocalSpace 5
 495: oInput 0
 497: oGetAddrLocal 1
 499: oPushResult
 500: oSetResult 0
 502: oAssign
 503: oGetAddrLocal 2
 505: oPushResult
 506: oScopeFindInCurrentScope
 507: oAssign
 508: oGetLocal 2
 510: oPushResult
 511: oNodeNull
 512: oPop 1
 514: oChoice 635
 516: oGetAddrLocal 2
 518: oPushResult
 519: oSetResult 7
 521: oPushResult
 522: oSetResult 2
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oCall 6444
 529: oPop 3
 531: oAssign
 532: oGetLocal 2
 534: oPushResult
 535: oSetResult 9
 537: oPushResult
 538: oLabelNew
 539: oPushResult
 540: oNodeSetLabel
 541: oPop 3
 543: oJumpForward 641
 545: oGetAddrLocal 1
 547: oPushResult
 548: oSetResult 1
 550: oAssign
 551: oGetLocal 2
 553: oPushResult
 554: oSetResult 13
 556: oPushResult
 557: oNodeGetBoolean
 558: oPop 2
 560: oChoice 566
 562: oError 21
 564: oJumpForward 569
 566: Choice Lookup Table
           1    562
 569: oGetLocal 2
 571: oPushResult
 572: oSetResult 14
 574: oPushResult
 575: oNodeGetBoolean
 576: oPop 2
 578: oChoice 584
 580: oError 21
 582: oJumpForward 587
 584: Choice Lookup Table
           1    580
 587: oGetLocal 2
 589: oPushResult
 590: oNodeType
 591: oPop 1
 593: oChoice 597
 595: oJumpForward 602
 597: Choice Lookup Table
           7    595
 600: oError 21
 602: oGetLocal 2
 604: oPushResult
 605: oSetResult 18
 607: oPushResult
 608: oGetLocal 2
 610: oPushResult
 611: oSetResult 11
 613: oPushResult
 614: oNodeGet
 615: oPop 2
 617: oPushResult
 618: oNodeSet
 619: oPop 3
 621: oGetLocal 2
 623: oPushResult
 624: oSetResult 11
 626: oPushResult
 627: oSetResult 0
 629: oPushResult
 630: oNodeSet
 631: oPop 3
 633: oJumpForward 641
 635: Choice Lookup Table
           0    545
           1    516
 640: oEndChoice
 641: oGetAddrLocal 3
 643: oPushResult
 644: oScopeCurrent
 645: oPushResult
 646: oSetResult 1
 648: oPushResult
 649: oNodeGetInt
 650: oPop 2
 652: oAssign
 653: oGetAddrLocal 3
 655: oPushResult
 656: inc
 657: oPop 1
 659: oGetLocal 3
 661: oPushResult
 662: oScopeBegin
 663: oPop 1
 665: oGetAddrLocal 4
 667: oPushResult
 668: oScopeCurrent
 669: oAssign
 670: oCall 1180
 672: oGetLocal 2
 674: oPushResult
 675: oSetResult 11
 677: oPushResult
 678: oGetLocal 4
 680: oPushResult
 681: oNodeSet
 682: oPop 3
 684: oScopeEnd
 685: oInput 4
 687: oGetLocal 1
 689: oChoice 701
 691: oGetLocal 2
 693: oPushResult
 694: oScopeDeclare
 695: oPop 1
 697: oJumpForward 707
 699: oJumpForward 707
 701: Choice Lookup Table
           1    699
           0    691
 706: oEndChoice
 707: oGetLocal 2
 709: oPushResult
 710: oCall 373
 712: oPop 1
 714: oInputChoice 727
 716: oJumpForward 803
 718: oGetLocal 2
 720: oPushResult
 721: oCall 451
 723: oPop 1
 725: oJumpForward 803
 727: Choice Lookup Table
          59    718
          58    716
 732: oGetLocal 4
 734: oPushResult
 735: oScopeEnter
 736: oPop 1
 738: oGetLocal 3
 740: oPushResult
 741: oScopeBegin
 742: oPop 1
 744: oScopeCurrent
 745: oPushResult
 746: oSetResult 4
 748: oPushResult
 749: oSetResult 1
 751: oPushResult
 752: oNodeSetBoolean
 753: oPop 3
 755: oGetLocal 2
 757: oPushResult
 758: oSetResult 12
 760: oPushResult
 761: oScopeCurrent
 762: oPushResult
 763: oNodeSet
 764: oPop 3
 766: oGetAddrLocal 5
 768: oPushResult
 769: oGetLocal 2
 771: oPushResult
 772: oSetResult 9
 774: oPushResult
 775: oNodeGetLabel
 776: oPop 2
 778: oAssign
 779: oSetResult 13
 781: oPushResult
 782: oGetLocal 5
 784: oPushResult
 785: oCall 229
 787: oPop 2
 789: oGetLocal 2
 791: oPushResult
 792: oSetResult 13
 794: oPushResult
 795: oSetResult 1
 797: oPushResult
 798: oNodeSetBoolean
 799: oPop 3
 801: oScopeEnd
 802: oScopeEnd
 803: oInput 4
 805: oReturn
 806: oLocalSpace 7
 808: oInput 0
 810: oGetAddrLocal 1
 812: oPushResult
 813: oSetResult 0
 815: oAssign
 816: oGetAddrLocal 2
 818: oPushResult
 819: oScopeFindInCurrentScope
 820: oAssign
 821: oGetLocal 2
 823: oPushResult
 824: oNodeNull
 825: oPop 1
 827: oChoice 961
 829: oGetAddrLocal 2
 831: oPushResult
 832: oSetResult 8
 834: oPushResult
 835: oSetResult 3
 837: oPushResult
 838: LAST_ID
 839: oPushResult
 840: oCall 6444
 842: oPop 3
 844: oAssign
 845: oGetLocal 2
 847: oPushResult
 848: oSetResult 9
 850: oPushResult
 851: oLabelNew
 852: oPushResult
 853: oNodeSetLabel
 854: oPop 3
 856: oJumpForward 967
 858: oGetAddrLocal 1
 860: oPushResult
 861: oSetResult 1
 863: oAssign
 864: oGetLocal 2
 866: oPushResult
 867: oSetResult 13
 869: oPushResult
 870: oNodeGetBoolean
 871: oPop 2
 873: oChoice 879
 875: oError 21
 877: oJumpForward 882
 879: Choice Lookup Table
           1    875
 882: oGetLocal 2
 884: oPushResult
 885: oNodeType
 886: oPop 1
 888: oChoice 892
 890: oJumpForward 897
 892: Choice Lookup Table
           8    890
 895: oError 21
 897: oGetLocal 2
 899: oPushResult
 900: oSetResult 18
 902: oPushResult
 903: oGetLocal 2
 905: oPushResult
 906: oSetResult 11
 908: oPushResult
 909: oNodeGet
 910: oPop 2
 912: oPushResult
 913: oNodeSet
 914: oPop 3
 916: oGetLocal 2
 918: oPushResult
 919: oSetResult 11
 921: oPushResult
 922: oSetResult 0
 924: oPushResult
 925: oNodeSet
 926: oPop 3
 928: oGetLocal 2
 930: oPushResult
 931: oSetResult 19
 933: oPushResult
 934: oGetLocal 2
 936: oPushResult
 937: oSetResult 8
 939: oPushResult
 940: oNodeGet
 941: oPop 2
 943: oPushResult
 944: oNodeSet
 945: oPop 3
 947: oGetLocal 2
 949: oPushResult
 950: oSetResult 8
 952: oPushResult
 953: oSetResult 0
 955: oPushResult
 956: oNodeSet
 957: oPop 3
 959: oJumpForward 967
 961: Choice Lookup Table
           0    858
           1    829
 966: oEndChoice
 967: oGetAddrLocal 3
 969: oPushResult
 970: oScopeCurrent
 971: oPushResult
 972: oSetResult 1
 974: oPushResult
 975: oNodeGetInt
 976: oPop 2
 978: oAssign
 979: oGetAddrLocal 3
 981: oPushResult
 982: inc
 983: oPop 1
 985: oGetLocal 3
 987: oPushResult
 988: oScopeBegin
 989: oPop 1
 991: oGetAddrLocal 4
 993: oPushResult
 994: oScopeCurrent
 995: oAssign
 996: oCall 1180
 998: oGetLocal 2
1000: oPushResult
1001: oSetResult 11
1003: oPushResult
1004: oGetLocal 4
1006: oPushResult
1007: oNodeSet
1008: oPop 3
1010: oInput 11
1012: oGetAddrLocal 5
1014: oPushResult
1015: oCall 1770
1017: oPop 1
1019: oGetLocal 2
1021: oPushResult
1022: oSetResult 8
1024: oPushResult
1025: oGetLocal 5
1027: oPushResult
1028: oNodeSet
1029: oPop 3
1031: oGetAddrLocal 6
1033: oPushResult
1034: oGetLocal 5
1036: oPushResult
1037: oCall 6472
1039: oPop 1
1041: oAssign
1042: oGetLocal 2
1044: oPushResult
1045: oSetResult 20
1047: oPushResult
1048: oGetLocal 6
1050: oPushResult
1051: oScopeAllocType
1052: oPop 1
1054: oPushResult
1055: oNodeSetInt
1056: oPop 3
1058: oScopeEnd
1059: oInput 4
1061: oGetLocal 1
1063: oChoice 1075
1065: oGetLocal 2
1067: oPushResult
1068: oScopeDeclare
1069: oPop 1
1071: oJumpForward 1081
1073: oJumpForward 1081
1075: Choice Lookup Table
           1   1073
           0   1065
1080: oEndChoice
1081: oGetLocal 2
1083: oPushResult
1084: oCall 373
1086: oPop 1
1088: oInputChoice 1101
1090: oJumpForward 1177
1092: oGetLocal 2
1094: oPushResult
1095: oCall 451
1097: oPop 1
1099: oJumpForward 1177
1101: Choice Lookup Table
          59   1092
          58   1090
1106: oGetLocal 4
1108: oPushResult
1109: oScopeEnter
1110: oPop 1
1112: oGetLocal 3
1114: oPushResult
1115: oScopeBegin
1116: oPop 1
1118: oScopeCurrent
1119: oPushResult
1120: oSetResult 4
1122: oPushResult
1123: oSetResult 1
1125: oPushResult
1126: oNodeSetBoolean
1127: oPop 3
1129: oGetLocal 2
1131: oPushResult
1132: oSetResult 12
1134: oPushResult
1135: oScopeCurrent
1136: oPushResult
1137: oNodeSet
1138: oPop 3
1140: oGetAddrLocal 7
1142: oPushResult
1143: oGetLocal 2
1145: oPushResult
1146: oSetResult 9
1148: oPushResult
1149: oNodeGetLabel
1150: oPop 2
1152: oAssign
1153: oSetResult 13
1155: oPushResult
1156: oGetLocal 7
1158: oPushResult
1159: oCall 229
1161: oPop 2
1163: oGetLocal 2
1165: oPushResult
1166: oSetResult 13
1168: oPushResult
1169: oSetResult 1
1171: oPushResult
1172: oNodeSetBoolean
1173: oPop 3
1175: oScopeEnd
1176: oScopeEnd
1177: oInput 4
1179: oReturn
1180: oLocalSpace 6
1182: oInputChoice 1403
1184: oGetAddrLocal 1
1186: oPushResult
1187: oNodeVecNew
1188: oAssign
1189: oGetAddrLocal 3
1191: oPushResult
1192: oSetResult 0
1194: oAssign
1195: oInputChoice 1205
1197: oGetAddrLocal 3
1199: oPushResult
1200: oSetResult 1
1202: oAssign
1203: oJumpForward 1208
1205: Choice Lookup Table
          32   1197
1208: oInput 0
1210: oGetAddrLocal 2
1212: oPushResult
1213: oSetResult 15
1215: oPushResult
1216: oSetResult 6
1218: oPushResult
1219: LAST_ID
1220: oPushResult
1221: oCall 6444
1223: oPop 3
1225: oAssign
1226: oGetLocal 2
1228: oPushResult
1229: oSetResult 21
1231: oPushResult
1232: oGetLocal 3
1234: oPushResult
1235: oNodeSetBoolean
1236: oPop 3
1238: oGetLocal 1
1240: oPushResult
1241: oGetLocal 2
1243: oPushResult
1244: oNodeVecAppend
1245: oPop 2
1247: oInputChoice 1255
1249: oJumpForward 1263
1251: oJumpForward 1261
1253: oJumpForward 1261
1255: Choice Lookup Table
          12   1253
          11   1249
1260: oEndChoice
1261: oJumpBack 1208
1263: oGetAddrLocal 4
1265: oPushResult
1266: oCall 1770
1268: oPop 1
1270: oGetLocal 3
1272: oChoice 1287
1274: oGetAddrLocal 5
1276: oPushResult
1277: oGetLocal 4
1279: oPushResult
1280: oCall 6472
1282: oPop 1
1284: oAssign
1285: oJumpForward 1296
1287: Choice Lookup Table
           1   1274
1290: oGetAddrLocal 5
1292: oPushResult
1293: oGetLocal 4
1295: oAssign
1296: oGetAddrLocal 6
1298: oPushResult
1299: oSetResult 0
1301: oAssign
1302: oGetLocal 6
1304: oPushResult
1305: oGetLocal 1
1307: oPushResult
1308: oNodeVecSize
1309: oPop 1
1311: oPushResult
1312: equal
1313: oPop 2
1315: oChoice 1372
1317: oGetAddrLocal 2
1319: oPushResult
1320: oGetLocal 1
1322: oPushResult
1323: oGetLocal 6
1325: oPushResult
1326: oNodeVecElement
1327: oPop 2
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oSetResult 8
1335: oPushResult
1336: oGetLocal 4
1338: oPushResult
1339: oNodeSet
1340: oPop 3
1342: oGetLocal 2
1344: oPushResult
1345: oScopeDeclare
1346: oPop 1
1348: oGetLocal 2
1350: oPushResult
1351: oSetResult 9
1353: oPushResult
1354: oGetLocal 5
1356: oPushResult
1357: oScopeAllocType
1358: oPop 1
1360: oPushResult
1361: oNodeSetInt
1362: oPop 3
1364: oGetAddrLocal 6
1366: oPushResult
1367: inc
1368: oPop 1
1370: oJumpForward 1377
1372: Choice Lookup Table
           0   1317
1375: oJumpForward 1379
1377: oJumpBack 1302
1379: oGetLocal 1
1381: oPushResult
1382: oNodeVecDelete
1383: oPop 1
1385: oInputChoice 1393
1387: oJumpForward 1401
1389: oJumpForward 1399
1391: oJumpForward 1399
1393: Choice Lookup Table
           4   1391
          14   1387
1398: oEndChoice
1399: oJumpBack 1184
1401: oJumpForward 1406
1403: Choice Lookup Table
          13   1184
1406: oReturn
1407: oLocalSpace 2
1409: oInputChoice 1471
1411: oGetAddrLocal 1
1413: oPushResult
1414: oSetResult 9
1416: oPushResult
1417: oSetResult 4
1419: oPushResult
1420: LAST_ID
1421: oPushResult
1422: oCall 6444
1424: oPop 3
1426: oAssign
1427: oInput 5
1429: oCall 2244
1431: oGetAddrLocal 2
1433: oPushResult
1434: oValueTop
1435: oAssign
1436: oValuePop
1437: oGetLocal 1
1439: oPushResult
1440: oSetResult 9
1442: oPushResult
1443: oGetLocal 2
1445: oPushResult
1446: oNodeSetInt
1447: oPop 3
1449: oGetLocal 1
1451: oPushResult
1452: oSetResult 8
1454: oPushResult
1455: oGetGlobal 4
1457: oPushResult
1458: oNodeSet
1459: oPop 3
1461: oGetLocal 1
1463: oPushResult
1464: oScopeDeclare
1465: oPop 1
1467: oInput 4
1469: oJumpForward 1476
1471: Choice Lookup Table
           0   1411
1474: oJumpForward 1478
1476: oJumpBack 1409
1478: oReturn
1479: oLocalSpace 2
1481: oInputChoice 1530
1483: oGetAddrLocal 1
1485: oPushResult
1486: oSetResult 10
1488: oPushResult
1489: oSetResult 5
1491: oPushResult
1492: LAST_ID
1493: oPushResult
1494: oCall 6444
1496: oPop 3
1498: oAssign
1499: oInput 5
1501: oGetAddrLocal 2
1503: oPushResult
1504: oCall 1770
1506: oPop 1
1508: oGetLocal 1
1510: oPushResult
1511: oSetResult 8
1513: oPushResult
1514: oGetLocal 2
1516: oPushResult
1517: oNodeSet
1518: oPop 3
1520: oGetLocal 1
1522: oPushResult
1523: oScopeDeclare
1524: oPop 1
1526: oInput 4
1528: oJumpForward 1535
1530: Choice Lookup Table
           0   1483
1533: oJumpForward 1537
1535: oJumpBack 1481
1537: oReturn
1538: oLocalSpace 6
1540: oInputChoice 1762
1542: oGetAddrLocal 1
1544: oPushResult
1545: oNodeVecNew
1546: oAssign
1547: oGetAddrLocal 2
1549: oPushResult
1550: oGetParam 1
1552: oPushResult
1553: oSetResult 6
1555: oPushResult
1556: LAST_ID
1557: oPushResult
1558: oCall 6444
1560: oPop 3
1562: oAssign
1563: oGetLocal 1
1565: oPushResult
1566: oGetLocal 2
1568: oPushResult
1569: oNodeVecAppend
1570: oPop 2
1572: oInputChoice 1578
1574: oInput 0
1576: oJumpForward 1583
1578: Choice Lookup Table
          12   1574
1581: oJumpForward 1585
1583: oJumpBack 1547
1585: oInput 11
1587: oGetAddrLocal 3
1589: oPushResult
1590: oCall 1770
1592: oPop 1
1594: oGetAddrLocal 4
1596: oPushResult
1597: oSetResult 0
1599: oAssign
1600: oGetLocal 4
1602: oPushResult
1603: oGetLocal 1
1605: oPushResult
1606: oNodeVecSize
1607: oPop 1
1609: oPushResult
1610: equal
1611: oPop 2
1613: oChoice 1654
1615: oGetAddrLocal 2
1617: oPushResult
1618: oGetLocal 1
1620: oPushResult
1621: oGetLocal 4
1623: oPushResult
1624: oNodeVecElement
1625: oPop 2
1627: oAssign
1628: oGetLocal 2
1630: oPushResult
1631: oSetResult 8
1633: oPushResult
1634: oGetLocal 3
1636: oPushResult
1637: oNodeSet
1638: oPop 3
1640: oGetLocal 2
1642: oPushResult
1643: oScopeDeclareAlloc
1644: oPop 1
1646: oGetAddrLocal 4
1648: oPushResult
1649: inc
1650: oPop 1
1652: oJumpForward 1659
1654: Choice Lookup Table
           0   1615
1657: oJumpForward 1661
1659: oJumpBack 1600
1661: oInputChoice 1749
1663: oGetLocal 1
1665: oPushResult
1666: oNodeVecSize
1667: oPop 1
1669: oChoice 1673
1671: oJumpForward 1678
1673: Choice Lookup Table
           1   1671
1676: oError 22
1678: oGetAddrLocal 5
1680: oPushResult
1681: oCall 401
1683: oAssign
1684: oGetLocal 5
1686: oPushResult
1687: oCodePush
1688: oPop 1
1690: oGetAddrLocal 6
1692: oPushResult
1693: oSetResult 0
1695: oAssign
1696: oScopeCurrent
1697: oPushResult
1698: oGetGlobal 1
1700: oPushResult
1701: equal_node
1702: oPop 2
1704: oChoice 1720
1706: oGetGlobal 2
1708: oPushResult
1709: oScopeEnter
1710: oPop 1
1712: oGetAddrLocal 6
1714: oPushResult
1715: oSetResult 1
1717: oAssign
1718: oJumpForward 1723
1720: Choice Lookup Table
           1   1706
1723: oGetLocal 2
1725: oPushResult
1726: oCall 5649
1728: oPop 1
1730: oCall 2310
1732: oCall 6330
1734: oCall 5443
1736: oGetLocal 6
1738: oChoice 1743
1740: oScopeEnd
1741: oJumpForward 1746
1743: Choice Lookup Table
           1   1740
1746: oCodePop
1747: oJumpForward 1752
1749: Choice Lookup Table
           5   1663
1752: oGetLocal 1
1754: oPushResult
1755: oNodeVecDelete
1756: oPop 1
1758: oInput 4
1760: oJumpForward 1767
1762: Choice Lookup Table
           0   1542
1765: oJumpForward 1769
1767: oJumpBack 1540
1769: oReturn
1770: oLocalSpace 12
1772: oInputChoice 2226
1774: oGetAddrLocal 1
1776: oPushResult
1777: oScopeFindRequire
1778: oAssign
1779: oGetLocal 1
1781: oPushResult
1782: oNodeType
1783: oPop 1
1785: oChoice 1802
1787: oGetParam 1
1789: oPushResult
1790: oGetLocal 1
1792: oPushResult
1793: oSetResult 8
1795: oPushResult
1796: oNodeGet
1797: oPop 2
1799: oAssign
1800: oJumpForward 1813
1802: Choice Lookup Table
          10   1787
1805: oError 2
1807: oGetParam 1
1809: oPushResult
1810: oGetGlobal 4
1812: oAssign
1813: oJumpForward 2243
1815: oInput 15
1817: oGetAddrLocal 2
1819: oPushResult
1820: oNodeVecNew
1821: oAssign
1822: oGetAddrLocal 3
1824: oPushResult
1825: oSetResult 25
1827: oPushResult
1828: oNodeNew
1829: oPop 1
1831: oAssign
1832: oGetLocal 3
1834: oPushResult
1835: oSetResult 23
1837: oPushResult
1838: oGetGlobal 4
1840: oPushResult
1841: oNodeSet
1842: oPop 3
1844: oCall 2244
1846: oGetLocal 3
1848: oPushResult
1849: oSetResult 25
1851: oPushResult
1852: oValueTop
1853: oPushResult
1854: oNodeSetInt
1855: oPop 3
1857: oValuePop
1858: oInput 20
1860: oCall 2244
1862: oGetLocal 3
1864: oPushResult
1865: oSetResult 26
1867: oPushResult
1868: oValueTop
1869: oPushResult
1870: oNodeSetInt
1871: oPop 3
1873: oValuePop
1874: oGetLocal 3
1876: oPushResult
1877: oSetResult 3
1879: oPushResult
1880: oSetResult 4
1882: oPushResult
1883: oNodeSetInt
1884: oPop 3
1886: oGetLocal 3
1888: oPushResult
1889: oTypeAdd
1890: oPop 1
1892: oGetAddrLocal 4
1894: oPushResult
1895: oSetResult 24
1897: oPushResult
1898: oNodeNew
1899: oPop 1
1901: oAssign
1902: oGetLocal 4
1904: oPushResult
1905: oSetResult 24
1907: oPushResult
1908: oGetLocal 3
1910: oPushResult
1911: oNodeSet
1912: oPop 3
1914: oGetLocal 2
1916: oPushResult
1917: oGetLocal 4
1919: oPushResult
1920: oNodeVecAppend
1921: oPop 2
1923: oInputChoice 1931
1925: oJumpForward 1939
1927: oJumpForward 1937
1929: oJumpForward 1937
1931: Choice Lookup Table
          12   1929
          16   1925
1936: oEndChoice
1937: oJumpBack 1822
1939: oInput 38
1941: oGetAddrLocal 5
1943: oPushResult
1944: oCall 1770
1946: oPop 1
1948: oGetAddrLocal 6
1950: oPushResult
1951: oGetLocal 2
1953: oPushResult
1954: oNodeVecSize
1955: oPop 1
1957: oAssign
1958: oGetAddrLocal 6
1960: oPushResult
1961: dec
1962: oPop 1
1964: oGetAddrLocal 7
1966: oPushResult
1967: oGetLocal 2
1969: oPushResult
1970: oGetLocal 6
1972: oPushResult
1973: oNodeVecElement
1974: oPop 2
1976: oAssign
1977: oGetLocal 7
1979: oPushResult
1980: oSetResult 23
1982: oPushResult
1983: oGetLocal 5
1985: oPushResult
1986: oNodeSet
1987: oPop 3
1989: oGetAddrLocal 8
1991: oPushResult
1992: oGetLocal 7
1994: oPushResult
1995: oSetResult 24
1997: oPushResult
1998: oNodeGet
1999: oPop 2
2001: oAssign
2002: oGetAddrLocal 9
2004: oPushResult
2005: oGetLocal 8
2007: oPushResult
2008: oSetResult 26
2010: oPushResult
2011: oNodeGetInt
2012: oPop 2
2014: oPushResult
2015: oGetLocal 8
2017: oPushResult
2018: oSetResult 25
2020: oPushResult
2021: oNodeGetInt
2022: oPop 2
2024: oPushResult
2025: subtract
2026: oPop 2
2028: oAssign
2029: oGetAddrLocal 9
2031: oPushResult
2032: inc
2033: oPop 1
2035: oGetLocal 7
2037: oPushResult
2038: oSetResult 3
2040: oPushResult
2041: oGetLocal 9
2043: oPushResult
2044: oGetLocal 5
2046: oPushResult
2047: oSetResult 3
2049: oPushResult
2050: oNodeGetInt
2051: oPop 2
2053: oPushResult
2054: multiply
2055: oPop 2
2057: oPushResult
2058: oNodeSetInt
2059: oPop 3
2061: oGetLocal 7
2063: oPushResult
2064: oTypeAdd
2065: oPop 1
2067: oGetAddrLocal 5
2069: oPushResult
2070: oGetLocal 7
2072: oAssign
2073: oGetLocal 6
2075: oPushResult
2076: equal_zero
2077: oPop 1
2079: oChoice 2085
2081: oJumpForward 2090
2083: oJumpForward 2088
2085: Choice Lookup Table
           1   2081
2088: oJumpBack 1958
2090: oGetParam 1
2092: oPushResult
2093: oGetLocal 2
2095: oPushResult
2096: oSetResult 0
2098: oPushResult
2099: oNodeVecElement
2100: oPop 2
2102: oAssign
2103: oGetLocal 2
2105: oPushResult
2106: oNodeVecDelete
2107: oPop 1
2109: oJumpForward 2243
2111: oGetAddrLocal 10
2113: oPushResult
2114: oCall 1770
2116: oPop 1
2118: oGetParam 1
2120: oPushResult
2121: oGetLocal 10
2123: oPushResult
2124: oCall 6472
2126: oPop 1
2128: oAssign
2129: oJumpForward 2243
2131: oGetParam 1
2133: oPushResult
2134: oSetResult 26
2136: oPushResult
2137: oNodeNew
2138: oPop 1
2140: oAssign
2141: oSetResult -1
2143: oPushResult
2144: oScopeBegin
2145: oPop 1
2147: oSetResult 14
2149: oPushResult
2150: oCall 1538
2152: oPop 1
2154: oGetAddrLocal 11
2156: oPushResult
2157: oScopeCurrent
2158: oPushResult
2159: oSetResult 3
2161: oPushResult
2162: oNodeGetInt
2163: oPop 2
2165: oAssign
2166: oGetLocal 11
2168: oPushResult
2169: equal_zero
2170: oPop 1
2172: oChoice 2178
2174: oError 19
2176: oJumpForward 2181
2178: Choice Lookup Table
           1   2174
2181: oInput 34
2183: oGetFromParam 1
2185: oPushResult
2186: oSetResult 27
2188: oPushResult
2189: oScopeCurrent
2190: oPushResult
2191: oNodeSet
2192: oPop 3
2194: oGetFromParam 1
2196: oPushResult
2197: oSetResult 3
2199: oPushResult
2200: oGetLocal 11
2202: oPushResult
2203: oNodeSetInt
2204: oPop 3
2206: oScopeEnd
2207: oGetFromParam 1
2209: oPushResult
2210: oTypeAdd
2211: oPop 1
2213: oJumpForward 2243
2215: oInput 38
2217: oGetAddrLocal 12
2219: oPushResult
2220: oCall 1770
2222: oPop 1
2224: oJumpForward 2243
2226: Choice Lookup Table
          37   2215
          36   2131
          17   2111
          35   1815
           0   1774
2237: oCall 2244
2239: oInput 20
2241: oCall 2244
2243: oReturn
2244: oLocalSpace 1
2246: oInputChoice 2301
2248: TOKEN_VALUE
2249: oPushResult
2250: oValuePush
2251: oPop 1
2253: oJumpForward 2309
2255: oGetAddrLocal 1
2257: oPushResult
2258: oScopeFindRequire
2259: oAssign
2260: oGetLocal 1
2262: oPushResult
2263: oNodeType
2264: oPop 1
2266: oChoice 2283
2268: oGetLocal 1
2270: oPushResult
2271: oSetResult 9
2273: oPushResult
2274: oNodeGetInt
2275: oPop 2
2277: oPushResult
2278: oValuePush
2279: oPop 1
2281: oJumpForward 2294
2283: Choice Lookup Table
           9   2268
2286: oError 1
2288: oSetResult 0
2290: oPushResult
2291: oValuePush
2292: oPop 1
2294: oJumpForward 2309
2296: oCall 2244
2298: oValueNegate
2299: oJumpForward 2309
2301: Choice Lookup Table
          24   2296
           0   2255
           1   2248
2308: oEndChoice
2309: oReturn
2310: oLocalSpace 1
2312: oGetAddrLocal 1
2314: oPushResult
2315: oSetResult 0
2317: oAssign
2318: oGetAddrLocal 1
2320: oPushResult
2321: oCall 2471
2323: oPop 1
2325: oGetAddrLocal 1
2327: oPushResult
2328: oCall 2371
2330: oPop 1
2332: oReturn
2333: oLocalSpace 0
2335: oGetParam 1
2337: oPushResult
2338: oCall 2471
2340: oPop 1
2342: oTypeSNodeType
2343: oChoice 2362
2345: oJumpForward 2369
2347: oGetParam 1
2349: oPushResult
2350: oLabelNew
2351: oAssign
2352: oEmit 55
2354: oGetFromParam 1
2356: oPushResult
2357: oEmitLabel
2358: oPop 1
2360: oJumpForward 2369
2362: Choice Lookup Table
          19   2347
          20   2345
2367: oError 8
2369: oTypeSPop
2370: oReturn
2371: oLocalSpace 1
2373: oTypeSNodeType
2374: oChoice 2436
2376: oGetAddrLocal 1
2378: oPushResult
2379: oLabelNew
2380: oAssign
2381: oEmit 15
2383: oSetResult 1
2385: oPushResult
2386: oEmitInt
2387: oPop 1
2389: oEmit 53
2391: oGetLocal 1
2393: oPushResult
2394: oEmitLabel
2395: oPop 1
2397: oEmit 56
2399: oGetFromParam 1
2401: oPushResult
2402: oEmitLabel
2403: oPop 1
2405: oEmit 15
2407: oSetResult 0
2409: oPushResult
2410: oEmitInt
2411: oPop 1
2413: oEmit 56
2415: oGetLocal 1
2417: oPushResult
2418: oEmitLabel
2419: oPop 1
2421: oTypeSPop
2422: oGetGlobal 5
2424: oPushResult
2425: oTypeSPush
2426: oPop 1
2428: oGetParam 1
2430: oPushResult
2431: oSetResult 0
2433: oAssign
2434: oJumpForward 2439
2436: Choice Lookup Table
          20   2376
2439: oReturn
2440: oLocalSpace 0
2442: oTypeSNodeType
2443: oChoice 2467
2445: oGetParam 1
2447: oPushResult
2448: oLabelNew
2449: oAssign
2450: oEmit 55
2452: oGetFromParam 1
2454: oPushResult
2455: oEmitLabel
2456: oPop 1
2458: oTypeSPop
2459: oGetGlobal 6
2461: oPushResult
2462: oTypeSPush
2463: oPop 1
2465: oJumpForward 2470
2467: Choice Lookup Table
          19   2445
2470: oReturn
2471: oLocalSpace 0
2473: oGetParam 1
2475: oPushResult
2476: oCall 2836
2478: oPop 1
2480: oInputChoice 2818
2482: oGetParam 1
2484: oPushResult
2485: oCall 2371
2487: oPop 1
2489: oGetParam 1
2491: oPushResult
2492: oCall 2836
2494: oPop 1
2496: oGetParam 1
2498: oPushResult
2499: oCall 2371
2501: oPop 1
2503: oCall 6330
2505: oTypeSNodeType
2506: oChoice 2520
2508: oEmit 38
2510: oJumpForward 2533
2512: oEmit 44
2514: oJumpForward 2533
2516: oError 16
2518: oJumpForward 2533
2520: Choice Lookup Table
          22   2516
          21   2516
          23   2512
          19   2508
          18   2508
2531: oError 17
2533: oTypeSPop
2534: oGetGlobal 5
2536: oPushResult
2537: oTypeSPush
2538: oPop 1
2540: oJumpForward 2833
2542: oGetParam 1
2544: oPushResult
2545: oCall 2371
2547: oPop 1
2549: oGetParam 1
2551: oPushResult
2552: oCall 2836
2554: oPop 1
2556: oGetParam 1
2558: oPushResult
2559: oCall 2371
2561: oPop 1
2563: oCall 6330
2565: oTypeSNodeType
2566: oChoice 2580
2568: oEmit 39
2570: oJumpForward 2593
2572: oEmit 45
2574: oJumpForward 2593
2576: oError 16
2578: oJumpForward 2593
2580: Choice Lookup Table
          22   2576
          21   2576
          23   2572
          19   2568
          18   2568
2591: oError 17
2593: oTypeSPop
2594: oGetGlobal 5
2596: oPushResult
2597: oTypeSPush
2598: oPop 1
2600: oJumpForward 2833
2602: oGetParam 1
2604: oPushResult
2605: oCall 2371
2607: oPop 1
2609: oGetParam 1
2611: oPushResult
2612: oCall 2836
2614: oPop 1
2616: oGetParam 1
2618: oPushResult
2619: oCall 2371
2621: oPop 1
2623: oCall 6330
2625: oTypeSNodeType
2626: oChoice 2636
2628: oEmit 41
2630: oJumpForward 2647
2632: oError 16
2634: oJumpForward 2647
2636: Choice Lookup Table
          22   2632
          21   2632
          19   2628
          18   2628
2645: oError 17
2647: oTypeSPop
2648: oGetGlobal 5
2650: oPushResult
2651: oTypeSPush
2652: oPop 1
2654: oJumpForward 2833
2656: oGetParam 1
2658: oPushResult
2659: oCall 2371
2661: oPop 1
2663: oGetParam 1
2665: oPushResult
2666: oCall 2836
2668: oPop 1
2670: oGetParam 1
2672: oPushResult
2673: oCall 2371
2675: oPop 1
2677: oCall 6330
2679: oTypeSNodeType
2680: oChoice 2690
2682: oEmit 40
2684: oJumpForward 2701
2686: oError 16
2688: oJumpForward 2701
2690: Choice Lookup Table
          22   2686
          21   2686
          19   2682
          18   2682
2699: oError 17
2701: oTypeSPop
2702: oGetGlobal 5
2704: oPushResult
2705: oTypeSPush
2706: oPop 1
2708: oJumpForward 2833
2710: oGetParam 1
2712: oPushResult
2713: oCall 2371
2715: oPop 1
2717: oGetParam 1
2719: oPushResult
2720: oCall 2836
2722: oPop 1
2724: oGetParam 1
2726: oPushResult
2727: oCall 2371
2729: oPop 1
2731: oCall 6330
2733: oTypeSNodeType
2734: oChoice 2744
2736: oEmit 43
2738: oJumpForward 2755
2740: oError 16
2742: oJumpForward 2755
2744: Choice Lookup Table
          22   2740
          21   2740
          19   2736
          18   2736
2753: oError 17
2755: oTypeSPop
2756: oGetGlobal 5
2758: oPushResult
2759: oTypeSPush
2760: oPop 1
2762: oJumpForward 2833
2764: oGetParam 1
2766: oPushResult
2767: oCall 2371
2769: oPop 1
2771: oGetParam 1
2773: oPushResult
2774: oCall 2836
2776: oPop 1
2778: oGetParam 1
2780: oPushResult
2781: oCall 2371
2783: oPop 1
2785: oCall 6330
2787: oTypeSNodeType
2788: oChoice 2798
2790: oEmit 42
2792: oJumpForward 2809
2794: oError 16
2796: oJumpForward 2809
2798: Choice Lookup Table
          22   2794
          21   2794
          19   2790
          18   2790
2807: oError 17
2809: oTypeSPop
2810: oGetGlobal 5
2812: oPushResult
2813: oTypeSPush
2814: oPop 1
2816: oJumpForward 2833
2818: Choice Lookup Table
          10   2764
           9   2710
           8   2656
           7   2602
           6   2542
           5   2482
2831: oJumpForward 2835
2833: oJumpBack 2480
2835: oReturn
2836: oLocalSpace 1
2838: oGetAddrLocal 1
2840: oPushResult
2841: oSetResult 0
2843: oAssign
2844: oGetParam 1
2846: oPushResult
2847: oCall 3016
2849: oPop 1
2851: oInputChoice 2984
2853: oTypeSNodeType
2854: oChoice 2925
2856: oGetLocal 1
2858: oPushResult
2859: oSetResult 0
2861: oPushResult
2862: equal_label
2863: oPop 2
2865: oChoice 2874
2867: oGetAddrLocal 1
2869: oPushResult
2870: oLabelNew
2871: oAssign
2872: oJumpForward 2877
2874: Choice Lookup Table
           1   2867
2877: oEmit 53
2879: oGetLocal 1
2881: oPushResult
2882: oEmitLabel
2883: oPop 1
2885: oJumpForward 2932
2887: oGetParam 1
2889: oPushResult
2890: oCall 2440
2892: oPop 1
2894: oGetLocal 1
2896: oPushResult
2897: oSetResult 0
2899: oPushResult
2900: equal_label
2901: oPop 2
2903: oChoice 2912
2905: oGetAddrLocal 1
2907: oPushResult
2908: oLabelNew
2909: oAssign
2910: oJumpForward 2915
2912: Choice Lookup Table
           1   2905
2915: oEmit 53
2917: oGetLocal 1
2919: oPushResult
2920: oEmitLabel
2921: oPop 1
2923: oJumpForward 2932
2925: Choice Lookup Table
          19   2887
          20   2856
2930: oError 8
2932: oTypeSPop
2933: oEmit 56
2935: oGetFromParam 1
2937: oPushResult
2938: oEmitLabel
2939: oPop 1
2941: oGetParam 1
2943: oPushResult
2944: oSetResult 0
2946: oAssign
2947: oGetParam 1
2949: oPushResult
2950: oCall 3016
2952: oPop 1
2954: oTypeSNodeType
2955: oChoice 2968
2957: oJumpForward 2975
2959: oGetParam 1
2961: oPushResult
2962: oCall 2440
2964: oPop 1
2966: oJumpForward 2975
2968: Choice Lookup Table
          19   2959
          20   2957
2973: oError 8
2975: oTypeSPop
2976: oGetGlobal 6
2978: oPushResult
2979: oTypeSPush
2980: oPop 1
2982: oJumpForward 2989
2984: Choice Lookup Table
          52   2853
2987: oJumpForward 2991
2989: oJumpBack 2851
2991: oGetLocal 1
2993: oPushResult
2994: oSetResult 0
2996: oPushResult
2997: equal_label
2998: oPop 2
3000: oChoice 3012
3002: oEmit 56
3004: oGetLocal 1
3006: oPushResult
3007: oEmitLabel
3008: oPop 1
3010: oJumpForward 3015
3012: Choice Lookup Table
           0   3002
3015: oReturn
3016: oLocalSpace 2
3018: oGetAddrLocal 1
3020: oPushResult
3021: oSetResult 0
3023: oAssign
3024: oGetParam 1
3026: oPushResult
3027: oCall 3154
3029: oPop 1
3031: oInputChoice 3146
3033: oTypeSNodeType
3034: oChoice 3047
3036: oJumpForward 3054
3038: oGetParam 1
3040: oPushResult
3041: oCall 2440
3043: oPop 1
3045: oJumpForward 3054
3047: Choice Lookup Table
          19   3038
          20   3036
3052: oError 8
3054: oTypeSPop
3055: oGetLocal 1
3057: oPushResult
3058: oSetResult 0
3060: oPushResult
3061: equal_label
3062: oPop 2
3064: oChoice 3093
3066: oGetAddrLocal 1
3068: oPushResult
3069: oLabelNew
3070: oAssign
3071: oEmit 57
3073: oGetFromParam 1
3075: oPushResult
3076: oEmitLabel
3077: oPop 1
3079: oGetLocal 1
3081: oPushResult
3082: oEmitLabel
3083: oPop 1
3085: oGetParam 1
3087: oPushResult
3088: oGetLocal 1
3090: oAssign
3091: oJumpForward 3096
3093: Choice Lookup Table
           1   3066
3096: oGetAddrLocal 2
3098: oPushResult
3099: oSetResult 0
3101: oAssign
3102: oGetAddrLocal 2
3104: oPushResult
3105: oCall 3154
3107: oPop 1
3109: oTypeSNodeType
3110: oChoice 3123
3112: oJumpForward 3130
3114: oGetAddrLocal 2
3116: oPushResult
3117: oCall 2440
3119: oPop 1
3121: oJumpForward 3130
3123: Choice Lookup Table
          19   3114
          20   3112
3128: oError 8
3130: oEmit 57
3132: oGetLocal 2
3134: oPushResult
3135: oEmitLabel
3136: oPop 1
3138: oGetLocal 1
3140: oPushResult
3141: oEmitLabel
3142: oPop 1
3144: oJumpForward 3151
3146: Choice Lookup Table
          51   3033
3149: oJumpForward 3153
3151: oJumpBack 3031
3153: oReturn
3154: oLocalSpace 1
3156: oInputChoice 3210
3158: oGetAddrLocal 1
3160: oPushResult
3161: oSetResult 0
3163: oAssign
3164: oGetAddrLocal 1
3166: oPushResult
3167: oCall 3154
3169: oPop 1
3171: oTypeSNodeType
3172: oChoice 3201
3174: oGetParam 1
3176: oPushResult
3177: oLabelNew
3178: oAssign
3179: oEmit 53
3181: oGetFromParam 1
3183: oPushResult
3184: oEmitLabel
3185: oPop 1
3187: oEmit 56
3189: oGetLocal 1
3191: oPushResult
3192: oEmitLabel
3193: oPop 1
3195: oJumpForward 3208
3197: oEmit 37
3199: oJumpForward 3208
3201: Choice Lookup Table
          19   3197
          20   3174
3206: oError 8
3208: oJumpForward 3220
3210: Choice Lookup Table
          53   3158
3213: oGetParam 1
3215: oPushResult
3216: oCall 3221
3218: oPop 1
3220: oReturn
3221: oLocalSpace 0
3223: oGetParam 1
3225: oPushResult
3226: oCall 3272
3228: oPop 1
3230: oInputChoice 3262
3232: oCall 6356
3234: oGetParam 1
3236: oPushResult
3237: oCall 3272
3239: oPop 1
3241: oCall 6370
3243: oEmit 34
3245: oJumpForward 3269
3247: oCall 6356
3249: oGetParam 1
3251: oPushResult
3252: oCall 3272
3254: oPop 1
3256: oCall 6370
3258: oEmit 35
3260: oJumpForward 3269
3262: Choice Lookup Table
          24   3247
          23   3232
3267: oJumpForward 3271
3269: oJumpBack 3230
3271: oReturn
3272: oLocalSpace 0
3274: oGetParam 1
3276: oPushResult
3277: oCall 3323
3279: oPop 1
3281: oInputChoice 3313
3283: oCall 6356
3285: oGetParam 1
3287: oPushResult
3288: oCall 3323
3290: oPop 1
3292: oCall 6370
3294: oEmit 31
3296: oJumpForward 3320
3298: oCall 6356
3300: oGetParam 1
3302: oPushResult
3303: oCall 3323
3305: oPop 1
3307: oCall 6370
3309: oEmit 32
3311: oJumpForward 3320
3313: Choice Lookup Table
          22   3298
          21   3283
3318: oJumpForward 3322
3320: oJumpBack 3281
3322: oReturn
3323: oLocalSpace 0
3325: oInputChoice 3351
3327: oGetParam 1
3329: oPushResult
3330: oCall 3364
3332: oPop 1
3334: oCall 6370
3336: oJumpForward 3363
3338: oGetParam 1
3340: oPushResult
3341: oCall 3364
3343: oPop 1
3345: oCall 6370
3347: oEmit 36
3349: oJumpForward 3363
3351: Choice Lookup Table
          24   3338
          23   3327
3356: oGetParam 1
3358: oPushResult
3359: oCall 3364
3361: oPop 1
3363: oReturn
3364: oLocalSpace 6
3366: oInputChoice 3552
3368: oEmit 15
3370: TOKEN_VALUE
3371: oPushResult
3372: oEmitInt
3373: oPop 1
3375: oGetGlobal 4
3377: oPushResult
3378: oTypeSPush
3379: oPop 1
3381: oJumpForward 3571
3383: oGetParam 1
3385: oPushResult
3386: oCall 2471
3388: oPop 1
3390: oInput 14
3392: oJumpForward 3571
3394: oGetAddrLocal 1
3396: oPushResult
3397: CURRENT_STRLIT
3398: oPushResult
3399: oStringAllocLit
3400: oPop 1
3402: oAssign
3403: oEmit 16
3405: oGetLocal 1
3407: oPushResult
3408: oEmitInt
3409: oPop 1
3411: oGetGlobal 8
3413: oPushResult
3414: oTypeSPush
3415: oPop 1
3417: oJumpForward 3571
3419: oGetAddrLocal 2
3421: oPushResult
3422: oScopeFindRequire
3423: oAssign
3424: oGetLocal 2
3426: oPushResult
3427: oNodeType
3428: oPop 1
3430: oChoice 3492
3432: oGetLocal 2
3434: oPushResult
3435: oCall 4752
3437: oPop 1
3439: oJumpForward 3511
3441: oGetAddrLocal 3
3443: oPushResult
3444: oGetLocal 2
3446: oPushResult
3447: oSetResult 8
3449: oPushResult
3450: oNodeGet
3451: oPop 2
3453: oAssign
3454: oGetLocal 3
3456: oPushResult
3457: oTypeSPush
3458: oPop 1
3460: oTypeSNodeType
3461: oChoice 3474
3463: oEmit 15
3465: oGetLocal 2
3467: oPushResult
3468: oCall 6607
3470: oPop 1
3472: oJumpForward 3481
3474: Choice Lookup Table
          19   3463
          18   3463
3479: oError 16
3481: oJumpForward 3511
3483: oGetLocal 2
3485: oPushResult
3486: oCall 3572
3488: oPop 1
3490: oJumpForward 3511
3492: Choice Lookup Table
          15   3483
          13   3483
          12   3483
           9   3441
           8   3432
3503: oError 6
3505: oGetGlobal 4
3507: oPushResult
3508: oTypeSPush
3509: oPop 1
3511: oJumpForward 3571
3513: oInput 0
3515: oGetAddrLocal 4
3517: oPushResult
3518: oScopeFindRequire
3519: oAssign
3520: oGetLocal 4
3522: oPushResult
3523: oCall 5649
3525: oPop 1
3527: oGetAddrLocal 5
3529: oPushResult
3530: oTypeSTop
3531: oAssign
3532: oTypeSPop
3533: oGetAddrLocal 6
3535: oPushResult
3536: oGetLocal 5
3538: oPushResult
3539: oCall 6472
3541: oPop 1
3543: oAssign
3544: oGetLocal 6
3546: oPushResult
3547: oTypeSPush
3548: oPop 1
3550: oJumpForward 3571
3552: Choice Lookup Table
          18   3513
           0   3419
           2   3394
          13   3383
           1   3368
3563: oError 6
3565: oGetGlobal 4
3567: oPushResult
3568: oTypeSPush
3569: oPop 1
3571: oReturn
3572: oLocalSpace 3
3574: oGetAddrLocal 1
3576: oPushResult
3577: oGetParam 1
3579: oPushResult
3580: oSetResult 8
3582: oPushResult
3583: oNodeGet
3584: oPop 2
3586: oAssign
3587: oGetAddrLocal 2
3589: oPushResult
3590: oGetParam 1
3592: oPushResult
3593: oSetResult 6
3595: oPushResult
3596: oNodeGet
3597: oPop 2
3599: oAssign
3600: oGetAddrLocal 3
3602: oPushResult
3603: oScopeCurrent
3604: oPushResult
3605: oSetResult 1
3607: oPushResult
3608: oNodeGetInt
3609: oPop 2
3611: oPushResult
3612: oGetLocal 2
3614: oPushResult
3615: oSetResult 1
3617: oPushResult
3618: oNodeGetInt
3619: oPop 2
3621: oPushResult
3622: subtract
3623: oPop 2
3625: oAssign
3626: oGetLocal 1
3628: oPushResult
3629: oTypeSPush
3630: oPop 1
3632: oTypeSNodeType
3633: oChoice 4150
3635: oGetParam 1
3637: oPushResult
3638: oNodeType
3639: oPop 1
3641: oChoice 3787
3643: oEmit 0
3645: oGetParam 1
3647: oPushResult
3648: oCall 6607
3650: oPop 1
3652: oJumpForward 3795
3654: oGetLocal 3
3656: oPushResult
3657: equal_zero
3658: oPop 1
3660: oChoice 3673
3662: oEmit 3
3664: oGetParam 1
3666: oPushResult
3667: oCall 6607
3669: oPop 1
3671: oJumpForward 3691
3673: Choice Lookup Table
           1   3662
3676: oEmit 9
3678: oGetLocal 3
3680: oPushResult
3681: oEmitInt
3682: oPop 1
3684: oGetParam 1
3686: oPushResult
3687: oCall 6607
3689: oPop 1
3691: oJumpForward 3795
3693: oGetParam 1
3695: oPushResult
3696: oSetResult 21
3698: oPushResult
3699: oNodeGetBoolean
3700: oPop 2
3702: oChoice 3745
3704: oGetLocal 3
3706: oPushResult
3707: equal_zero
3708: oPop 1
3710: oChoice 3723
3712: oEmit 8
3714: oGetParam 1
3716: oPushResult
3717: oCall 6607
3719: oPop 1
3721: oJumpForward 3741
3723: Choice Lookup Table
           1   3712
3726: oEmit 14
3728: oGetLocal 3
3730: oPushResult
3731: oEmitInt
3732: oPop 1
3734: oGetParam 1
3736: oPushResult
3737: oCall 6607
3739: oPop 1
3741: oEmit 22
3743: oJumpForward 3785
3745: Choice Lookup Table
           1   3704
3748: oGetLocal 3
3750: oPushResult
3751: equal_zero
3752: oPop 1
3754: oChoice 3767
3756: oEmit 6
3758: oGetParam 1
3760: oPushResult
3761: oCall 6607
3763: oPop 1
3765: oJumpForward 3785
3767: Choice Lookup Table
           1   3756
3770: oEmit 12
3772: oGetLocal 3
3774: oPushResult
3775: oEmitInt
3776: oPop 1
3778: oGetParam 1
3780: oPushResult
3781: oCall 6607
3783: oPop 1
3785: oJumpForward 3795
3787: Choice Lookup Table
          15   3693
          13   3654
          12   3643
3794: oEndChoice
3795: oJumpForward 4325
3797: oGetParam 1
3799: oPushResult
3800: oNodeType
3801: oPop 1
3803: oChoice 3949
3805: oEmit 1
3807: oGetParam 1
3809: oPushResult
3810: oCall 6607
3812: oPop 1
3814: oJumpForward 3957
3816: oGetLocal 3
3818: oPushResult
3819: equal_zero
3820: oPop 1
3822: oChoice 3835
3824: oEmit 4
3826: oGetParam 1
3828: oPushResult
3829: oCall 6607
3831: oPop 1
3833: oJumpForward 3853
3835: Choice Lookup Table
           1   3824
3838: oEmit 10
3840: oGetLocal 3
3842: oPushResult
3843: oEmitInt
3844: oPop 1
3846: oGetParam 1
3848: oPushResult
3849: oCall 6607
3851: oPop 1
3853: oJumpForward 3957
3855: oGetParam 1
3857: oPushResult
3858: oSetResult 21
3860: oPushResult
3861: oNodeGetBoolean
3862: oPop 2
3864: oChoice 3907
3866: oGetLocal 3
3868: oPushResult
3869: equal_zero
3870: oPop 1
3872: oChoice 3885
3874: oEmit 8
3876: oGetParam 1
3878: oPushResult
3879: oCall 6607
3881: oPop 1
3883: oJumpForward 3903
3885: Choice Lookup Table
           1   3874
3888: oEmit 14
3890: oGetLocal 3
3892: oPushResult
3893: oEmitInt
3894: oPop 1
3896: oGetParam 1
3898: oPushResult
3899: oCall 6607
3901: oPop 1
3903: oEmit 23
3905: oJumpForward 3947
3907: Choice Lookup Table
           1   3866
3910: oGetLocal 3
3912: oPushResult
3913: equal_zero
3914: oPop 1
3916: oChoice 3929
3918: oEmit 7
3920: oGetParam 1
3922: oPushResult
3923: oCall 6607
3925: oPop 1
3927: oJumpForward 3947
3929: Choice Lookup Table
           1   3918
3932: oEmit 13
3934: oGetLocal 3
3936: oPushResult
3937: oEmitInt
3938: oPop 1
3940: oGetParam 1
3942: oPushResult
3943: oCall 6607
3945: oPop 1
3947: oJumpForward 3957
3949: Choice Lookup Table
          15   3855
          13   3816
          12   3805
3956: oEndChoice
3957: oJumpForward 4325
3959: oError 16
3961: oJumpForward 4325
3963: oGetParam 1
3965: oPushResult
3966: oNodeType
3967: oPop 1
3969: oChoice 4115
3971: oEmit 2
3973: oGetParam 1
3975: oPushResult
3976: oCall 6607
3978: oPop 1
3980: oJumpForward 4123
3982: oGetLocal 3
3984: oPushResult
3985: equal_zero
3986: oPop 1
3988: oChoice 4001
3990: oEmit 5
3992: oGetParam 1
3994: oPushResult
3995: oCall 6607
3997: oPop 1
3999: oJumpForward 4019
4001: Choice Lookup Table
           1   3990
4004: oEmit 11
4006: oGetLocal 3
4008: oPushResult
4009: oEmitInt
4010: oPop 1
4012: oGetParam 1
4014: oPushResult
4015: oCall 6607
4017: oPop 1
4019: oJumpForward 4123
4021: oGetParam 1
4023: oPushResult
4024: oSetResult 21
4026: oPushResult
4027: oNodeGetBoolean
4028: oPop 2
4030: oChoice 4073
4032: oGetLocal 3
4034: oPushResult
4035: equal_zero
4036: oPop 1
4038: oChoice 4051
4040: oEmit 8
4042: oGetParam 1
4044: oPushResult
4045: oCall 6607
4047: oPop 1
4049: oJumpForward 4069
4051: Choice Lookup Table
           1   4040
4054: oEmit 14
4056: oGetLocal 3
4058: oPushResult
4059: oEmitInt
4060: oPop 1
4062: oGetParam 1
4064: oPushResult
4065: oCall 6607
4067: oPop 1
4069: oEmit 24
4071: oJumpForward 4113
4073: Choice Lookup Table
           1   4032
4076: oGetLocal 3
4078: oPushResult
4079: equal_zero
4080: oPop 1
4082: oChoice 4095
4084: oEmit 8
4086: oGetParam 1
4088: oPushResult
4089: oCall 6607
4091: oPop 1
4093: oJumpForward 4113
4095: Choice Lookup Table
           1   4084
4098: oEmit 14
4100: oGetLocal 3
4102: oPushResult
4103: oEmitInt
4104: oPop 1
4106: oGetParam 1
4108: oPushResult
4109: oCall 6607
4111: oPop 1
4113: oJumpForward 4123
4115: Choice Lookup Table
          15   4021
          13   3982
          12   3971
4122: oEndChoice
4123: oInputChoice 4145
4125: oTypeSPop
4126: oGetLocal 1
4128: oPushResult
4129: oSetResult 23
4131: oPushResult
4132: oNodeGet
4133: oPop 2
4135: oPushResult
4136: oTypeSPush
4137: oPop 1
4139: oCall 4361
4141: oCall 4326
4143: oJumpForward 4148
4145: Choice Lookup Table
          17   4125
4148: oJumpForward 4325
4150: Choice Lookup Table
          23   3963
          17   3959
          22   3959
          21   3959
          19   3797
          18   3635
4163: oGetParam 1
4165: oPushResult
4166: oNodeType
4167: oPop 1
4169: oChoice 4313
4171: oEmit 16
4173: oGetParam 1
4175: oPushResult
4176: oCall 6607
4178: oPop 1
4180: oJumpForward 4321
4182: oGetLocal 3
4184: oPushResult
4185: equal_zero
4186: oPop 1
4188: oChoice 4201
4190: oEmit 17
4192: oGetParam 1
4194: oPushResult
4195: oCall 6607
4197: oPop 1
4199: oJumpForward 4219
4201: Choice Lookup Table
           1   4190
4204: oEmit 20
4206: oGetLocal 3
4208: oPushResult
4209: oEmitInt
4210: oPop 1
4212: oGetParam 1
4214: oPushResult
4215: oCall 6607
4217: oPop 1
4219: oJumpForward 4321
4221: oGetParam 1
4223: oPushResult
4224: oSetResult 21
4226: oPushResult
4227: oNodeGetBoolean
4228: oPop 2
4230: oChoice 4271
4232: oGetLocal 3
4234: oPushResult
4235: equal_zero
4236: oPop 1
4238: oChoice 4251
4240: oEmit 8
4242: oGetParam 1
4244: oPushResult
4245: oCall 6607
4247: oPop 1
4249: oJumpForward 4269
4251: Choice Lookup Table
           1   4240
4254: oEmit 14
4256: oGetLocal 3
4258: oPushResult
4259: oEmitInt
4260: oPop 1
4262: oGetParam 1
4264: oPushResult
4265: oCall 6607
4267: oPop 1
4269: oJumpForward 4311
4271: Choice Lookup Table
           1   4232
4274: oGetLocal 3
4276: oPushResult
4277: equal_zero
4278: oPop 1
4280: oChoice 4293
4282: oEmit 18
4284: oGetParam 1
4286: oPushResult
4287: oCall 6607
4289: oPop 1
4291: oJumpForward 4311
4293: Choice Lookup Table
           1   4282
4296: oEmit 21
4298: oGetLocal 3
4300: oPushResult
4301: oEmitInt
4302: oPop 1
4304: oGetParam 1
4306: oPushResult
4307: oCall 6607
4309: oPop 1
4311: oJumpForward 4321
4313: Choice Lookup Table
          15   4221
          13   4182
          12   4171
4320: oEndChoice
4321: oCall 4361
4323: oCall 4326
4325: oReturn
4326: oLocalSpace 0
4328: oTypeSNodeType
4329: oChoice 4347
4331: oEmit 22
4333: oJumpForward 4360
4335: oEmit 23
4337: oJumpForward 4360
4339: oError 16
4341: oJumpForward 4360
4343: oEmit 24
4345: oJumpForward 4360
4347: Choice Lookup Table
          23   4343
          17   4339
          22   4339
          21   4339
          19   4335
          18   4331
4360: oReturn
4361: oLocalSpace 0
4363: oInputChoice 4377
4365: oCall 4389
4367: oJumpForward 4386
4369: oCall 4532
4371: oJumpForward 4386
4373: oCall 4630
4375: oJumpForward 4386
4377: Choice Lookup Table
          17   4373
          19   4369
          15   4365
4384: oJumpForward 4388
4386: oJumpBack 4363
4388: oReturn
4389: oLocalSpace 3
4391: oTypeSNodeType
4392: oChoice 4396
4394: oJumpForward 4401
4396: Choice Lookup Table
          24   4394
4399: oError 10
4401: oTypeSNodeType
4402: oChoice 4406
4404: oJumpForward 4411
4406: Choice Lookup Table
          24   4404
4409: oError 13
4411: oGetAddrLocal 1
4413: oPushResult
4414: oTypeSTop
4415: oPushResult
4416: oSetResult 24
4418: oPushResult
4419: oNodeGet
4420: oPop 2
4422: oPushResult
4423: oCall 6556
4425: oPop 1
4427: oAssign
4428: oGetAddrLocal 2
4430: oPushResult
4431: oTypeSTop
4432: oPushResult
4433: oSetResult 23
4435: oPushResult
4436: oNodeGet
4437: oPop 2
4439: oAssign
4440: oTypeSPop
4441: oGetLocal 2
4443: oPushResult
4444: oTypeSPush
4445: oPop 1
4447: oCall 2310
4449: oCall 6356
4451: oGetLocal 1
4453: oPushResult
4454: equal_zero
4455: oPop 1
4457: oChoice 4471
4459: oEmit 15
4461: oGetLocal 1
4463: oPushResult
4464: oEmitInt
4465: oPop 1
4467: oEmit 35
4469: oJumpForward 4474
4471: Choice Lookup Table
           0   4459
4474: oGetAddrLocal 3
4476: oPushResult
4477: oGetLocal 2
4479: oPushResult
4480: oSetResult 3
4482: oPushResult
4483: oNodeGetInt
4484: oPop 2
4486: oAssign
4487: oGetLocal 3
4489: oPushResult
4490: oSetResult 1
4492: oPushResult
4493: equal
4494: oPop 2
4496: oChoice 4510
4498: oEmit 15
4500: oGetLocal 3
4502: oPushResult
4503: oEmitInt
4504: oPop 1
4506: oEmit 31
4508: oJumpForward 4513
4510: Choice Lookup Table
           0   4498
4513: oEmit 33
4515: oInputChoice 4523
4517: oJumpForward 4531
4519: oJumpForward 4529
4521: oJumpForward 4529
4523: Choice Lookup Table
          12   4521
          16   4517
4528: oEndChoice
4529: oJumpBack 4401
4531: oReturn
4532: oLocalSpace 2
4534: oTypeSNodeType
4535: oChoice 4539
4537: oJumpForward 4544
4539: Choice Lookup Table
          26   4537
4542: oError 11
4544: oTypeSTop
4545: oPushResult
4546: oSetResult 27
4548: oPushResult
4549: oNodeGet
4550: oPop 2
4552: oPushResult
4553: oScopeEnter
4554: oPop 1
4556: oInput 0
4558: oGetAddrLocal 1
4560: oPushResult
4561: oScopeFindRequire
4562: oAssign
4563: oGetLocal 1
4565: oPushResult
4566: oNodeType
4567: oPop 1
4569: oChoice 4573
4571: oJumpForward 4578
4573: Choice Lookup Table
          14   4571
4576: oError 12
4578: oScopeEnd
4579: oGetAddrLocal 2
4581: oPushResult
4582: oGetLocal 1
4584: oPushResult
4585: oSetResult 9
4587: oPushResult
4588: oNodeGetInt
4589: oPop 2
4591: oAssign
4592: oGetLocal 2
4594: oPushResult
4595: equal_zero
4596: oPop 1
4598: oChoice 4612
4600: oEmit 15
4602: oGetLocal 2
4604: oPushResult
4605: oEmitInt
4606: oPop 1
4608: oEmit 33
4610: oJumpForward 4615
4612: Choice Lookup Table
           0   4600
4615: oTypeSPop
4616: oGetLocal 1
4618: oPushResult
4619: oSetResult 8
4621: oPushResult
4622: oNodeGet
4623: oPop 2
4625: oPushResult
4626: oTypeSPush
4627: oPop 1
4629: oReturn
4630: oLocalSpace 1
4632: oTypeSNodeType
4633: oChoice 4637
4635: oJumpForward 4642
4637: Choice Lookup Table
          23   4635
4640: oError 9
4642: oEmit 24
4644: oGetAddrLocal 1
4646: oPushResult
4647: oTypeSTop
4648: oAssign
4649: oTypeSPop
4650: oGetLocal 1
4652: oPushResult
4653: oSetResult 23
4655: oPushResult
4656: oNodeGet
4657: oPop 2
4659: oPushResult
4660: oTypeSPush
4661: oPop 1
4663: oReturn
4664: oLocalSpace 0
4666: oCall 6330
4668: oReturn
4669: oLocalSpace 2
4671: oGetAddrLocal 2
4673: oPushResult
4674: oGetParam 1
4676: oPushResult
4677: oSetResult 15
4679: oPushResult
4680: oNodeGetString
4681: oPop 2
4683: oAssign
4684: oGetLocal 2
4686: oPushResult
4687: oSetResult 0
4689: oPushResult
4690: equal_string
4691: oPop 2
4693: oChoice 4730
4695: oGetAddrLocal 1
4697: oPushResult
4698: oGetParam 1
4700: oPushResult
4701: oSetResult 7
4703: oPushResult
4704: oNodeGetInt
4705: oPop 2
4707: oPushResult
4708: ID_STRING
4709: oPop 1
4711: oPushResult
4712: oStringAllocLit
4713: oPop 1
4715: oAssign
4716: oJumpForward 4736
4718: oGetAddrLocal 1
4720: oPushResult
4721: oGetLocal 2
4723: oPushResult
4724: oStringAllocLit
4725: oPop 1
4727: oAssign
4728: oJumpForward 4736
4730: Choice Lookup Table
           0   4718
           1   4695
4735: oEndChoice
4736: oEmit 58
4738: oGetParam 1
4740: oPushResult
4741: oCall 6607
4743: oPop 1
4745: oGetLocal 1
4747: oPushResult
4748: oEmitInt
4749: oPop 1
4751: oReturn
4752: oLocalSpace 10
4754: oGetParam 1
4756: oPushResult
4757: oSetResult 14
4759: oPushResult
4760: oNodeGetBoolean
4761: oPop 2
4763: oChoice 4790
4765: oGetParam 1
4767: oPushResult
4768: oSetResult 17
4770: oPushResult
4771: oNodeGetBoolean
4772: oPop 2
4774: oChoice 4785
4776: oGetParam 1
4778: oPushResult
4779: oCall 4669
4781: oPop 1
4783: oJumpForward 4788
4785: Choice Lookup Table
           0   4776
4788: oJumpForward 4793
4790: Choice Lookup Table
           1   4765
4793: oGetParam 1
4795: oPushResult
4796: oSetResult 17
4798: oPushResult
4799: oSetResult 1
4801: oPushResult
4802: oNodeSetBoolean
4803: oPop 3
4805: oGetAddrLocal 1
4807: oPushResult
4808: oGetParam 1
4810: oPushResult
4811: oSetResult 16
4813: oPushResult
4814: oNodeGetBoolean
4815: oPop 2
4817: oAssign
4818: oGetAddrLocal 4
4820: oPushResult
4821: oGetParam 1
4823: oPushResult
4824: oNodeType
4825: oPop 1
4827: oPushResult
4828: oSetResult 8
4830: oPushResult
4831: equal_node_type
4832: oPop 2
4834: oAssign
4835: oGetLocal 4
4837: oChoice 4864
4839: oGetAddrLocal 2
4841: oPushResult
4842: oGetParam 1
4844: oPushResult
4845: oSetResult 8
4847: oPushResult
4848: oNodeGet
4849: oPop 2
4851: oAssign
4852: oGetAddrLocal 3
4854: oPushResult
4855: oGetLocal 2
4857: oPushResult
4858: oScopeAllocType
4859: oPop 1
4861: oAssign
4862: oJumpForward 4867
4864: Choice Lookup Table
           1   4839
4867: oGetAddrLocal 5
4869: oPushResult
4870: oGetParam 1
4872: oPushResult
4873: oSetResult 11
4875: oPushResult
4876: oNodeGet
4877: oPop 2
4879: oAssign
4880: oGetAddrLocal 6
4882: oPushResult
4883: oGetLocal 5
4885: oPushResult
4886: oSetResult 3
4888: oPushResult
4889: oNodeGetInt
4890: oPop 2
4892: oAssign
4893: oGetLocal 1
4895: oChoice 4917
4897: oEmit 47
4899: oGetLocal 6
4901: oPushResult
4902: oEmitInt
4903: oPop 1
4905: oJumpForward 4923
4907: oEmit 46
4909: oGetLocal 6
4911: oPushResult
4912: oEmitInt
4913: oPop 1
4915: oJumpForward 4923
4917: Choice Lookup Table
           0   4907
           1   4897
4922: oEndChoice
4923: oGetAddrLocal 7
4925: oPushResult
4926: oGetLocal 5
4928: oPushResult
4929: oSetResult 2
4931: oPushResult
4932: oNodeGetIter
4933: oPop 2
4935: oAssign
4936: oGetAddrLocal 8
4938: oPushResult
4939: oGetLocal 7
4941: oPushResult
4942: oNodeIterValue
4943: oPop 1
4945: oAssign
4946: oInputChoice 5125
4948: oGetLocal 8
4950: oPushResult
4951: oNodeNull
4952: oPop 1
4954: oChoice 4960
4956: oJumpForward 5121
4958: oJumpForward 4963
4960: Choice Lookup Table
           1   4956
4963: oGetAddrLocal 9
4965: oPushResult
4966: oGetLocal 8
4968: oPushResult
4969: oSetResult 9
4971: oPushResult
4972: oNodeGetInt
4973: oPop 2
4975: oAssign
4976: oEmit 19
4978: oGetLocal 9
4980: oPushResult
4981: oEmitInt
4982: oPop 1
4984: oGetLocal 8
4986: oPushResult
4987: oSetResult 8
4989: oPushResult
4990: oNodeGet
4991: oPop 2
4993: oPushResult
4994: oTypeSPush
4995: oPop 1
4997: oGetLocal 8
4999: oPushResult
5000: oSetResult 21
5002: oPushResult
5003: oNodeGetBoolean
5004: oPop 2
5006: oChoice 5074
5008: oCall 5613
5010: oCall 6330
5012: oEmit 27
5014: oJumpForward 5080
5016: oCall 2310
5018: oCall 4664
5020: oTypeSNodeType
5021: oChoice 5039
5023: oEmit 25
5025: oJumpForward 5072
5027: oEmit 26
5029: oJumpForward 5072
5031: oError 16
5033: oJumpForward 5072
5035: oEmit 27
5037: oJumpForward 5072
5039: Choice Lookup Table
          23   5035
          17   5031
          22   5031
          21   5031
          19   5027
          18   5023
5052: oGetAddrLocal 10
5054: oPushResult
5055: oTypeSTop
5056: oPushResult
5057: oSetResult 3
5059: oPushResult
5060: oNodeGetInt
5061: oPop 2
5063: oAssign
5064: oEmit 28
5066: oGetLocal 10
5068: oPushResult
5069: oEmitInt
5070: oPop 1
5072: oJumpForward 5080
5074: Choice Lookup Table
           0   5016
           1   5008
5079: oEndChoice
5080: oTypeSPop
5081: oGetAddrLocal 7
5083: oPushResult
5084: oNodeIterNext
5085: oPop 1
5087: oGetAddrLocal 8
5089: oPushResult
5090: oGetLocal 7
5092: oPushResult
5093: oNodeIterValue
5094: oPop 1
5096: oAssign
5097: oGetLocal 8
5099: oPushResult
5100: oNodeNull
5101: oPop 1
5103: oChoice 5111
5105: oJumpForward 5121
5107: oJumpForward 5117
5109: oJumpForward 5117
5111: Choice Lookup Table
           0   5109
           1   5105
5116: oEndChoice
5117: oInput 12
5119: oJumpBack 4948
5121: oInput 14
5123: oJumpForward 5128
5125: Choice Lookup Table
          13   4948
5128: oGetLocal 8
5130: oPushResult
5131: oNodeNull
5132: oPop 1
5134: oChoice 5140
5136: oError 15
5138: oJumpForward 5143
5140: Choice Lookup Table
           0   5136
5143: oGetLocal 4
5145: oChoice 5174
5147: oEmit 19
5149: oGetParam 1
5151: oPushResult
5152: oSetResult 20
5154: oPushResult
5155: oNodeGetInt
5156: oPop 2
5158: oPushResult
5159: oEmitInt
5160: oPop 1
5162: oEmit 17
5164: oGetLocal 3
5166: oPushResult
5167: oEmitInt
5168: oPop 1
5170: oEmit 27
5172: oJumpForward 5177
5174: Choice Lookup Table
           1   5147
5177: oGetLocal 1
5179: oChoice 5203
5181: oEmit 50
5183: oGetParam 1
5185: oPushResult
5186: oCall 6607
5188: oPop 1
5190: oJumpForward 5209
5192: oEmit 49
5194: oGetParam 1
5196: oPushResult
5197: oCall 6607
5199: oPop 1
5201: oJumpForward 5209
5203: Choice Lookup Table
           0   5192
           1   5181
5208: oEndChoice
5209: oGetLocal 4
5211: oChoice 5279
5213: oGetLocal 2
5215: oPushResult
5216: oTypeSPush
5217: oPop 1
5219: oTypeSNodeType
5220: oChoice 5256
5222: oEmit 3
5224: oGetLocal 3
5226: oPushResult
5227: oEmitInt
5228: oPop 1
5230: oJumpForward 5277
5232: oEmit 4
5234: oGetLocal 3
5236: oPushResult
5237: oEmitInt
5238: oPop 1
5240: oJumpForward 5277
5242: oError 16
5244: oJumpForward 5277
5246: oEmit 5
5248: oGetLocal 3
5250: oPushResult
5251: oEmitInt
5252: oPop 1
5254: oJumpForward 5277
5256: Choice Lookup Table
          23   5246
          17   5242
          22   5242
          21   5242
          19   5232
          18   5222
5269: oEmit 17
5271: oGetLocal 3
5273: oPushResult
5274: oEmitInt
5275: oPop 1
5277: oJumpForward 5282
5279: Choice Lookup Table
           1   5213
5282: oEmit 48
5284: oGetLocal 6
5286: oPushResult
5287: oEmitInt
5288: oPop 1
5290: oReturn
5291: oLocalSpace 0
5293: oInputChoice 5343
5295: oCall 6250
5297: oJumpForward 5368
5299: oCall 6257
5301: oJumpForward 5368
5303: oCall 6324
5305: oJumpForward 5368
5307: oCall 6327
5309: oJumpForward 5368
5311: oCall 5790
5313: oJumpForward 5368
5315: oCall 6110
5317: oJumpForward 5368
5319: oCall 5856
5321: oJumpForward 5368
5323: oCall 6030
5325: oJumpForward 5368
5327: oCall 6195
5329: oJumpForward 5368
5331: oCall 6163
5333: oJumpForward 5368
5335: oCall 6227
5337: oJumpForward 5368
5339: oCall 5369
5341: oJumpForward 5368
5343: Choice Lookup Table
           0   5339
          33   5335
          49   5331
          50   5327
          47   5323
          42   5319
          46   5315
          39   5311
          57   5307
          56   5303
          55   5299
          54   5295
5368: oReturn
5369: oLocalSpace 1
5371: oGetAddrLocal 1
5373: oPushResult
5374: oScopeFindRequire
5375: oAssign
5376: oGetLocal 1
5378: oPushResult
5379: oNodeType
5380: oPop 1
5382: oChoice 5411
5384: oGetLocal 1
5386: oPushResult
5387: oCall 4752
5389: oPop 1
5391: oJumpForward 5424
5393: oGetLocal 1
5395: oPushResult
5396: oCall 5425
5398: oPop 1
5400: oJumpForward 5424
5402: oGetLocal 1
5404: oPushResult
5405: oCall 5499
5407: oPop 1
5409: oJumpForward 5424
5411: Choice Lookup Table
           8   5402
          15   5393
          13   5393
          12   5393
           7   5384
5422: oError 0
5424: oReturn
5425: oLocalSpace 0
5427: oGetParam 1
5429: oPushResult
5430: oCall 5649
5432: oPop 1
5434: oInput 3
5436: oCall 2310
5438: oCall 6330
5440: oCall 5443
5442: oReturn
5443: oLocalSpace 1
5445: oTypeSNodeType
5446: oChoice 5464
5448: oEmit 25
5450: oJumpForward 5497
5452: oEmit 26
5454: oJumpForward 5497
5456: oError 16
5458: oJumpForward 5497
5460: oEmit 27
5462: oJumpForward 5497
5464: Choice Lookup Table
          23   5460
          17   5456
          22   5456
          21   5456
          19   5452
          18   5448
5477: oGetAddrLocal 1
5479: oPushResult
5480: oTypeSTop
5481: oPushResult
5482: oSetResult 3
5484: oPushResult
5485: oNodeGetInt
5486: oPop 2
5488: oAssign
5489: oEmit 28
5491: oGetLocal 1
5493: oPushResult
5494: oEmitInt
5495: oPop 1
5497: oTypeSPop
5498: oReturn
5499: oLocalSpace 1
5501: oGetParam 1
5503: oPushResult
5504: oSetResult 12
5506: oPushResult
5507: oNodeGet
5508: oPop 2
5510: oPushResult
5511: oScopeCurrent
5512: oPushResult
5513: oNodeEqual
5514: oPop 2
5516: oChoice 5522
5518: oError 20
5520: oJumpForward 5525
5522: Choice Lookup Table
           0   5518
5525: oEmit 8
5527: oGetParam 1
5529: oPushResult
5530: oSetResult 20
5532: oPushResult
5533: oNodeGetInt
5534: oPop 2
5536: oPushResult
5537: oEmitInt
5538: oPop 1
5540: oGetParam 1
5542: oPushResult
5543: oSetResult 8
5545: oPushResult
5546: oNodeGet
5547: oPop 2
5549: oPushResult
5550: oTypeSPush
5551: oPop 1
5553: oInput 3
5555: oCall 2310
5557: oCall 6330
5559: oTypeSNodeType
5560: oChoice 5578
5562: oEmit 25
5564: oJumpForward 5611
5566: oEmit 26
5568: oJumpForward 5611
5570: oError 16
5572: oJumpForward 5611
5574: oEmit 27
5576: oJumpForward 5611
5578: Choice Lookup Table
          23   5574
          17   5570
          22   5570
          21   5570
          19   5566
          18   5562
5591: oGetAddrLocal 1
5593: oPushResult
5594: oTypeSTop
5595: oPushResult
5596: oSetResult 3
5598: oPushResult
5599: oNodeGetInt
5600: oPop 2
5602: oAssign
5603: oEmit 28
5605: oGetLocal 1
5607: oPushResult
5608: oEmitInt
5609: oPop 1
5611: oTypeSPop
5612: oReturn
5613: oLocalSpace 1
5615: oInput 0
5617: oGetAddrLocal 1
5619: oPushResult
5620: oScopeFindRequire
5621: oAssign
5622: oGetLocal 1
5624: oPushResult
5625: oNodeType
5626: oPop 1
5628: oChoice 5632
5630: oJumpForward 5641
5632: Choice Lookup Table
          15   5630
          13   5630
          12   5630
5639: oError 4
5641: oGetLocal 1
5643: oPushResult
5644: oCall 5649
5646: oPop 1
5648: oReturn
5649: oLocalSpace 0
5651: oGetParam 1
5653: oPushResult
5654: oNodeType
5655: oPop 1
5657: oChoice 5717
5659: oEmit 16
5661: oGetParam 1
5663: oPushResult
5664: oCall 6607
5666: oPop 1
5668: oJumpForward 5726
5670: oEmit 17
5672: oGetParam 1
5674: oPushResult
5675: oCall 6607
5677: oPop 1
5679: oJumpForward 5726
5681: oGetParam 1
5683: oPushResult
5684: oSetResult 21
5686: oPushResult
5687: oNodeGetBoolean
5688: oPop 2
5690: oChoice 5703
5692: oEmit 8
5694: oGetParam 1
5696: oPushResult
5697: oCall 6607
5699: oPop 1
5701: oJumpForward 5715
5703: Choice Lookup Table
           1   5692
5706: oEmit 18
5708: oGetParam 1
5710: oPushResult
5711: oCall 6607
5713: oPop 1
5715: oJumpForward 5726
5717: Choice Lookup Table
          15   5681
          13   5670
          12   5659
5724: oError 4
5726: oGetParam 1
5728: oPushResult
5729: oSetResult 8
5731: oPushResult
5732: oNodeGet
5733: oPop 2
5735: oPushResult
5736: oTypeSPush
5737: oPop 1
5739: oCall 4361
5741: oReturn
5742: oLocalSpace 0
5744: oGetParam 1
5746: oPushResult
5747: oCall 5649
5749: oPop 1
5751: oCall 6356
5753: oGetParam 1
5755: oPushResult
5756: oCall 3572
5758: oPop 1
5760: oTypeSPop
5761: oEmit 29
5763: oEmit 25
5765: oReturn
5766: oLocalSpace 0
5768: oGetParam 1
5770: oPushResult
5771: oCall 5649
5773: oPop 1
5775: oCall 6356
5777: oGetParam 1
5779: oPushResult
5780: oCall 3572
5782: oPop 1
5784: oTypeSPop
5785: oEmit 30
5787: oEmit 25
5789: oReturn
5790: oLocalSpace 2
5792: oGetAddrLocal 1
5794: oPushResult
5795: oSetResult 0
5797: oAssign
5798: oGetAddrLocal 1
5800: oPushResult
5801: oCall 2333
5803: oPop 1
5805: oInput 40
5807: oCall 5291
5809: oInputChoice 5844
5811: oGetAddrLocal 2
5813: oPushResult
5814: oLabelNew
5815: oAssign
5816: oEmit 53
5818: oGetLocal 2
5820: oPushResult
5821: oEmitLabel
5822: oPop 1
5824: oEmit 56
5826: oGetLocal 1
5828: oPushResult
5829: oEmitLabel
5830: oPop 1
5832: oCall 5291
5834: oEmit 56
5836: oGetLocal 2
5838: oPushResult
5839: oEmitLabel
5840: oPop 1
5842: oJumpForward 5855
5844: Choice Lookup Table
          41   5811
5847: oEmit 56
5849: oGetLocal 1
5851: oPushResult
5852: oEmitLabel
5853: oPop 1
5855: oReturn
5856: oLocalSpace 4
5858: oInput 0
5860: oGetAddrLocal 1
5862: oPushResult
5863: oScopeFindRequire
5864: oAssign
5865: oGetLocal 1
5867: oPushResult
5868: oCall 5649
5870: oPop 1
5872: oCall 6356
5874: oInput 3
5876: oCall 2310
5878: oCall 6356
5880: oEmit 25
5882: oGetAddrLocal 2
5884: oPushResult
5885: oLabelNew
5886: oAssign
5887: oGetAddrLocal 3
5889: oPushResult
5890: oLabelNew
5891: oAssign
5892: oEmit 53
5894: oGetLocal 3
5896: oPushResult
5897: oEmitLabel
5898: oPop 1
5900: oGetAddrLocal 4
5902: oPushResult
5903: oLabelNew
5904: oAssign
5905: oEmit 56
5907: oGetLocal 4
5909: oPushResult
5910: oEmitLabel
5911: oPop 1
5913: oInputChoice 5993
5915: oGetLocal 1
5917: oPushResult
5918: oCall 5742
5920: oPop 1
5922: oEmit 56
5924: oGetLocal 3
5926: oPushResult
5927: oEmitLabel
5928: oPop 1
5930: oGetLocal 1
5932: oPushResult
5933: oCall 3572
5935: oPop 1
5937: oTypeSPop
5938: oCall 2310
5940: oCall 6356
5942: oEmit 40
5944: oEmit 54
5946: oGetLocal 2
5948: oPushResult
5949: oEmitLabel
5950: oPop 1
5952: oJumpForward 5999
5954: oGetLocal 1
5956: oPushResult
5957: oCall 5766
5959: oPop 1
5961: oEmit 56
5963: oGetLocal 3
5965: oPushResult
5966: oEmitLabel
5967: oPop 1
5969: oGetLocal 1
5971: oPushResult
5972: oCall 3572
5974: oPop 1
5976: oTypeSPop
5977: oCall 2310
5979: oCall 6356
5981: oEmit 41
5983: oEmit 54
5985: oGetLocal 2
5987: oPushResult
5988: oEmitLabel
5989: oPop 1
5991: oJumpForward 5999
5993: Choice Lookup Table
          44   5954
          43   5915
5998: oEndChoice
5999: oGetLocal 4
6001: oPushResult
6002: oGetLocal 2
6004: oPushResult
6005: oLoopPush
6006: oPop 2
6008: oInput 45
6010: oCall 5291
6012: oEmit 53
6014: oGetLocal 4
6016: oPushResult
6017: oEmitLabel
6018: oPop 1
6020: oEmit 56
6022: oGetLocal 2
6024: oPushResult
6025: oEmitLabel
6026: oPop 1
6028: oLoopPop
6029: oReturn
6030: oLocalSpace 3
6032: oGetAddrLocal 1
6034: oPushResult
6035: oLabelNew
6036: oAssign
6037: oEmit 56
6039: oGetLocal 1
6041: oPushResult
6042: oEmitLabel
6043: oPop 1
6045: oGetAddrLocal 2
6047: oPushResult
6048: oLabelNew
6049: oAssign
6050: oGetLocal 1
6052: oPushResult
6053: oGetLocal 2
6055: oPushResult
6056: oLoopPush
6057: oPop 2
6059: oCall 5291
6061: oInputChoice 6092
6063: oCall 5291
6065: oJumpForward 6098
6067: oGetAddrLocal 3
6069: oPushResult
6070: oCall 2333
6072: oPop 1
6074: oEmit 57
6076: oGetLocal 3
6078: oPushResult
6079: oEmitLabel
6080: oPop 1
6082: oGetLocal 1
6084: oPushResult
6085: oEmitLabel
6086: oPop 1
6088: oJumpForward 6100
6090: oJumpForward 6098
6092: Choice Lookup Table
          48   6067
           4   6063
6097: oEndChoice
6098: oJumpBack 6061
6100: oEmit 56
6102: oGetLocal 2
6104: oPushResult
6105: oEmitLabel
6106: oPop 1
6108: oLoopPop
6109: oReturn
6110: oLocalSpace 2
6112: oGetAddrLocal 1
6114: oPushResult
6115: oLabelNew
6116: oAssign
6117: oEmit 56
6119: oGetLocal 1
6121: oPushResult
6122: oEmitLabel
6123: oPop 1
6125: oGetAddrLocal 2
6127: oPushResult
6128: oCall 2333
6130: oPop 1
6132: oGetLocal 1
6134: oPushResult
6135: oGetLocal 2
6137: oPushResult
6138: oLoopPush
6139: oPop 2
6141: oInput 45
6143: oCall 5291
6145: oEmit 53
6147: oGetLocal 1
6149: oPushResult
6150: oEmitLabel
6151: oPop 1
6153: oEmit 56
6155: oGetLocal 2
6157: oPushResult
6158: oEmitLabel
6159: oPop 1
6161: oLoopPop
6162: oReturn
6163: oLocalSpace 0
6165: oLoopContinueLabel
6166: oPushResult
6167: oSetResult 0
6169: oPushResult
6170: equal_label
6171: oPop 2
6173: oChoice 6188
6175: oError 18
6177: oJumpForward 6194
6179: oEmit 53
6181: oLoopContinueLabel
6182: oPushResult
6183: oEmitLabel
6184: oPop 1
6186: oJumpForward 6194
6188: Choice Lookup Table
           0   6179
           1   6175
6193: oEndChoice
6194: oReturn
6195: oLocalSpace 0
6197: oLoopBreakLabel
6198: oPushResult
6199: oSetResult 0
6201: oPushResult
6202: equal_label
6203: oPop 2
6205: oChoice 6220
6207: oError 18
6209: oJumpForward 6226
6211: oEmit 53
6213: oLoopBreakLabel
6214: oPushResult
6215: oEmitLabel
6216: oPop 1
6218: oJumpForward 6226
6220: Choice Lookup Table
           0   6211
           1   6207
6225: oEndChoice
6226: oReturn
6227: oLocalSpace 0
6229: oCall 5291
6231: oInputChoice 6241
6233: oCall 5291
6235: oJumpForward 6247
6237: oJumpForward 6249
6239: oJumpForward 6247
6241: Choice Lookup Table
          34   6237
           4   6233
6246: oEndChoice
6247: oJumpBack 6231
6249: oReturn
6250: oLocalSpace 0
6252: oCall 6257
6254: oEmit 63
6256: oReturn
6257: oLocalSpace 0
6259: oInputChoice 6320
6261: oCall 2310
6263: oTypeSNodeType
6264: oChoice 6286
6266: oEmit 59
6268: oJumpForward 6301
6270: oEmit 60
6272: oJumpForward 6301
6274: oEmit 61
6276: oJumpForward 6301
6278: oError 16
6280: oJumpForward 6301
6282: oEmit 62
6284: oJumpForward 6301
6286: Choice Lookup Table
          23   6282
          17   6278
          21   6278
          22   6274
          19   6270
          18   6266
6299: oError 17
6301: oTypeSPop
6302: oInputChoice 6310
6304: oJumpForward 6318
6306: oJumpForward 6316
6308: oJumpForward 6316
6310: Choice Lookup Table
          12   6308
          14   6304
6315: oEndChoice
6316: oJumpBack 6261
6318: oJumpForward 6323
6320: Choice Lookup Table
          13   6261
6323: oReturn
6324: oLocalSpace 0
6326: oReturn
6327: oLocalSpace 0
6329: oReturn
6330: oLocalSpace 1
6332: oGetAddrLocal 1
6334: oPushResult
6335: oTypeSNodeType
6336: oAssign
6337: oTypeSPop
6338: oGetLocal 1
6340: oPushResult
6341: oTypeSNodeType
6342: oPushResult
6343: equal_node_type
6344: oPop 2
6346: oChoice 6352
6348: oError 14
6350: oJumpForward 6355
6352: Choice Lookup Table
           0   6348
6355: oReturn
6356: oLocalSpace 0
6358: oTypeSNodeType
6359: oChoice 6363
6361: oJumpForward 6368
6363: Choice Lookup Table
          18   6361
6366: oError 7
6368: oTypeSPop
6369: oReturn
6370: oLocalSpace 0
6372: oTypeSNodeType
6373: oChoice 6377
6375: oJumpForward 6382
6377: Choice Lookup Table
          18   6375
6380: oError 7
6382: oReturn
6383: oLocalSpace 0
6385: oTypeSNodeType
6386: oChoice 6390
6388: oJumpForward 6395
6390: Choice Lookup Table
          19   6388
6393: oError 8
6395: oTypeSPop
6396: oReturn
6397: oLocalSpace 0
6399: oTypeSNodeType
6400: oChoice 6404
6402: oJumpForward 6409
6404: Choice Lookup Table
          19   6402
6407: oError 8
6409: oReturn
6410: oLocalSpace 1
6412: oGetAddrLocal 1
6414: oPushResult
6415: oGetParam 2
6417: oPushResult
6418: oNodeNew
6419: oPop 1
6421: oAssign
6422: oGetLocal 1
6424: oPushResult
6425: oSetResult 3
6427: oPushResult
6428: oGetParam 1
6430: oPushResult
6431: oNodeSetInt
6432: oPop 3
6434: oGetLocal 1
6436: oPushResult
6437: oTypeAdd
6438: oPop 1
6440: oGetLocal 1
6442: oReturn
6443: oReturn
6444: oLocalSpace 1
6446: oGetAddrLocal 1
6448: oPushResult
6449: oGetParam 3
6451: oPushResult
6452: oNodeNew
6453: oPop 1
6455: oAssign
6456: oGetLocal 1
6458: oPushResult
6459: oSetResult 7
6461: oPushResult
6462: oGetParam 1
6464: oPushResult
6465: oNodeSetInt
6466: oPop 3
6468: oGetLocal 1
6470: oReturn
6471: oReturn
6472: oLocalSpace 1
6474: oGetAddrLocal 1
6476: oPushResult
6477: oGetParam 1
6479: oPushResult
6480: oSetResult 22
6482: oPushResult
6483: oNodeGet
6484: oPop 2
6486: oAssign
6487: oGetLocal 1
6489: oPushResult
6490: oNodeNull
6491: oPop 1
6493: oChoice 6549
6495: oGetAddrLocal 1
6497: oPushResult
6498: oSetResult 23
6500: oPushResult
6501: oNodeNew
6502: oPop 1
6504: oAssign
6505: oGetLocal 1
6507: oPushResult
6508: oSetResult 23
6510: oPushResult
6511: oGetParam 1
6513: oPushResult
6514: oNodeSet
6515: oPop 3
6517: oGetLocal 1
6519: oPushResult
6520: oSetResult 3
6522: oPushResult
6523: oSetResult 8
6525: oPushResult
6526: oNodeSetInt
6527: oPop 3
6529: oGetLocal 1
6531: oPushResult
6532: oTypeAdd
6533: oPop 1
6535: oGetParam 1
6537: oPushResult
6538: oSetResult 22
6540: oPushResult
6541: oGetLocal 1
6543: oPushResult
6544: oNodeSet
6545: oPop 3
6547: oJumpForward 6552
6549: Choice Lookup Table
           1   6495
6552: oGetLocal 1
6554: oReturn
6555: oReturn
6556: oLocalSpace 0
6558: oGetParam 1
6560: oPushResult
6561: oNodeType
6562: oPop 1
6564: oChoice 6592
6566: oMININT
6567: oReturn
6568: oJumpForward 6606
6570: oSetResult 0
6572: oReturn
6573: oJumpForward 6606
6575: oSetResult 0
6577: oReturn
6578: oJumpForward 6606
6580: oGetParam 1
6582: oPushResult
6583: oSetResult 25
6585: oPushResult
6586: oNodeGetInt
6587: oPop 2
6589: oReturn
6590: oJumpForward 6606
6592: Choice Lookup Table
          25   6580
          21   6575
          19   6570
          18   6566
6601: oError 3
6603: oSetResult 0
6605: oReturn
6606: oReturn
6607: oLocalSpace 0
6609: oGetParam 1
6611: oPushResult
6612: oSetResult 9
6614: oPushResult
6615: oNodeGetInt
6616: oPop 2
6618: oPushResult
6619: oEmitInt
6620: oPop 1
6622: oReturn
6623: oLocalSpace 1
6625: oGetAddrGlobal 3
6627: oPushResult
6628: oSetResult 17
6630: oPushResult
6631: oSetResult 4
6633: oPushResult
6634: oCall 6410
6636: oPop 2
6638: oAssign
6639: oGetAddrGlobal 4
6641: oPushResult
6642: oSetResult 18
6644: oPushResult
6645: oSetResult 4
6647: oPushResult
6648: oCall 6410
6650: oPop 2
6652: oAssign
6653: oGetAddrGlobal 5
6655: oPushResult
6656: oSetResult 19
6658: oPushResult
6659: oSetResult 1
6661: oPushResult
6662: oCall 6410
6664: oPop 2
6666: oAssign
6667: oGetAddrGlobal 6
6669: oPushResult
6670: oSetResult 20
6672: oPushResult
6673: oSetResult 1
6675: oPushResult
6676: oCall 6410
6678: oPop 2
6680: oAssign
6681: oGetAddrGlobal 7
6683: oPushResult
6684: oSetResult 21
6686: oPushResult
6687: oSetResult 1
6689: oPushResult
6690: oCall 6410
6692: oPop 2
6694: oAssign
6695: oGetAddrGlobal 8
6697: oPushResult
6698: oSetResult 22
6700: oPushResult
6701: oSetResult 256
6703: oPushResult
6704: oCall 6410
6706: oPop 2
6708: oAssign
6709: oGetAddrLocal 1
6711: oPushResult
6712: oSetResult 10
6714: oPushResult
6715: oSetResult 5
6717: oPushResult
6718: oIdAdd_File
6719: oPushResult
6720: oCall 6444
6722: oPop 3
6724: oAssign
6725: oGetLocal 1
6727: oPushResult
6728: oSetResult 8
6730: oPushResult
6731: oGetGlobal 3
6733: oPushResult
6734: oNodeSet
6735: oPop 3
6737: oGetLocal 1
6739: oPushResult
6740: oScopeDeclare
6741: oPop 1
6743: oGetAddrLocal 1
6745: oPushResult
6746: oSetResult 10
6748: oPushResult
6749: oSetResult 5
6751: oPushResult
6752: oIdAdd_Integer
6753: oPushResult
6754: oCall 6444
6756: oPop 3
6758: oAssign
6759: oGetLocal 1
6761: oPushResult
6762: oSetResult 8
6764: oPushResult
6765: oGetGlobal 4
6767: oPushResult
6768: oNodeSet
6769: oPop 3
6771: oGetLocal 1
6773: oPushResult
6774: oScopeDeclare
6775: oPop 1
6777: oGetAddrLocal 1
6779: oPushResult
6780: oSetResult 10
6782: oPushResult
6783: oSetResult 5
6785: oPushResult
6786: oIdAdd_Boolean
6787: oPushResult
6788: oCall 6444
6790: oPop 3
6792: oAssign
6793: oGetLocal 1
6795: oPushResult
6796: oSetResult 8
6798: oPushResult
6799: oGetGlobal 5
6801: oPushResult
6802: oNodeSet
6803: oPop 3
6805: oGetLocal 1
6807: oPushResult
6808: oScopeDeclare
6809: oPop 1
6811: oGetAddrLocal 1
6813: oPushResult
6814: oSetResult 10
6816: oPushResult
6817: oSetResult 5
6819: oPushResult
6820: oIdAdd_Char
6821: oPushResult
6822: oCall 6444
6824: oPop 3
6826: oAssign
6827: oGetLocal 1
6829: oPushResult
6830: oSetResult 8
6832: oPushResult
6833: oGetGlobal 7
6835: oPushResult
6836: oNodeSet
6837: oPop 3
6839: oGetLocal 1
6841: oPushResult
6842: oScopeDeclare
6843: oPop 1
6845: oGetAddrLocal 1
6847: oPushResult
6848: oSetResult 10
6850: oPushResult
6851: oSetResult 5
6853: oPushResult
6854: oIdAdd_String
6855: oPushResult
6856: oCall 6444
6858: oPop 3
6860: oAssign
6861: oGetLocal 1
6863: oPushResult
6864: oSetResult 8
6866: oPushResult
6867: oGetGlobal 8
6869: oPushResult
6870: oNodeSet
6871: oPop 3
6873: oGetLocal 1
6875: oPushResult
6876: oScopeDeclare
6877: oPop 1
6879: oGetAddrLocal 1
6881: oPushResult
6882: oSetResult 9
6884: oPushResult
6885: oSetResult 4
6887: oPushResult
6888: oIdAdd_True
6889: oPushResult
6890: oCall 6444
6892: oPop 3
6894: oAssign
6895: oGetLocal 1
6897: oPushResult
6898: oSetResult 8
6900: oPushResult
6901: oGetGlobal 5
6903: oPushResult
6904: oNodeSet
6905: oPop 3
6907: oGetLocal 1
6909: oPushResult
6910: oSetResult 9
6912: oPushResult
6913: oSetResult 1
6915: oPushResult
6916: oNodeSetInt
6917: oPop 3
6919: oGetLocal 1
6921: oPushResult
6922: oScopeDeclare
6923: oPop 1
6925: oGetAddrLocal 1
6927: oPushResult
6928: oSetResult 9
6930: oPushResult
6931: oSetResult 4
6933: oPushResult
6934: oIdAdd_False
6935: oPushResult
6936: oCall 6444
6938: oPop 3
6940: oAssign
6941: oGetLocal 1
6943: oPushResult
6944: oSetResult 8
6946: oPushResult
6947: oGetGlobal 5
6949: oPushResult
6950: oNodeSet
6951: oPop 3
6953: oGetLocal 1
6955: oPushResult
6956: oSetResult 9
6958: oPushResult
6959: oSetResult 0
6961: oPushResult
6962: oNodeSetInt
6963: oPop 3
6965: oGetLocal 1
6967: oPushResult
6968: oScopeDeclare
6969: oPop 1
6971: oReturn
