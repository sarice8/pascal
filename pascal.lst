   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pDoubleLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pCase
   2:    pOtherwise
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushConstD       % <double> - push double value on stack
   2:    tPushAddrGlobal   % <offset> - push ptr to global var
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tAssignD          %   "    double "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tCastItoD         % convert int32_t to double
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tMultD            % operations on double-precision floating point values
   2:    tDivD
   2:    tAddD
   2:    tSubD
   2:    tNegD
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tGreaterD         % double comparisions.  (equality uses EqualP, at least for now)
   2:    tLessD
   2:    tGreaterEqualD
   2:    tLessEqualD
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tJumpCaseB        % <label#>  pops uint8_t, jumps to case indicated by table at label (consisting of tCase, tCaseRange, tCaseEnd)
   2:    tJumpCaseI        % <label#>  pops integer, jumps to case indicated by table at label
   2:    tJumpCaseS        % <label#>  pops pointer to ShortString, jumps to case indicated by table at label
   2:    tCase             % <int> <label#>  - case table entry: if match int, goto label.  For tJumpCaseS, int is offset into global data.
   2:    tCaseRange        % <lowint> <highint> <label#>  - case table entry: if lowint <= value <= highint, goto label.  For tJumpCaseS, offsets into global.
   2:    tCaseEnd          % <label#> - end of case table.  Label points to no-match code (otherwise clause or end of statement).
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteD           %  "     "    : write double-precision floating point value on tos, pop
   2:    tWriteCR          %  "     "    : write cr
   2:    tReadI            % for readln : pointer to integer on tos.  Assign read value to it, and pop
   2:    tReadChar         %  "     "   : pointer to char on tos.  Asign read value to it, and pop
   2:    tReadShortStr     % <capacity>  "     "   : pointer to ShortString on tos, and given max capacity.  Assign read value to it, and pop
   2:    tReadCR           %  "     "   : read the end-of-line.  Will accept any platform's eoln sequence.
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotDouble
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    eSizeMismatch
   2:    eTypeNameNotAllowedHere
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nConstStr
   2: 	nConstDouble
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nByteType
   2: 	nIntegerType
   2: 	nSingleType
   2: 	nDoubleType
   2: 	nBooleanType
   2: 	nBooleanFlowType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qValueStr
   2: 	qValueDouble
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type double:
   2:    doubleZero = 0
   2:    ;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetDouble (Node, node_attribute, double)   % set double attribute
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetDouble (Node, node_attribute) >> double
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitDouble( double )        % emit double into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     TOKEN_VALUE_DOUBLE >> double
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     UNACCEPT_TOKEN            % Unaccept the last accepted token.  The next input, inputchoice will see it again.
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_ShortStringCmp >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Single >> int
   2:     oId_Double >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oId_Sizeof >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    oCodeDiscard( Code )     % discard the given code stream
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValuePushDouble(double)    % push a double onto value stack
   2:    oValuePushString(String)    % push string onto value stack
   2:    oValueTop >> int            % get top value on value stack
   2:    oValueTopDouble >> double
   2:    oValueTopString >> String
   2:    oValueSwap                  % swap top two
   2:    oValuePop
   2:    oValueCharToString          % convert top value from char to string
   2:    oValueIntToDouble
      
   2:    oValueNegate                % negate top numeric value
   2:    oValueEqual
   2:    oValueNotEqual
   2:    oValueLess
   2:    oValueGreater
   2:    oValueLessEqual
   2:    oValueGreaterEqual
      
   2:    oValueNegateD               % operations on double values
   2:    oValueEqualD
   2:    oValueNotEqualD
   2:    oValueLessD
   2:    oValueGreaterD
   2:    oValueLessEqualD
   2:    oValueGreaterEqualD
      
   2:    oValueOr                    % boolean or
   2:    oValueAnd
   2:    oValueNot                   % boolean not
      
   2:    oValueAdd
   2:    oValueSub
   2:    oValueMult
   2:    oValueDiv
      
   2:    oValueAddD
   2:    oValueSubD
   2:    oValueMultD
   2:    oValueDivD
      
   2:    oValueStringCmp             % compare top two strings. replace with negative, 0, or positive
   2:    oValueStringConcat
   2:    ;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanFlowType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    SingleType
   2: Node    DoubleType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
   2: Node    BuiltIn_Sizeof
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
   2: Node    System_ShortStringCmp
      
      
      % Expr has a corner case flag, needed for sizeof()
   2: boolean flagExprAllowTypeName
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowFlow( out Label falseLabel );
   2: BoolExprAllowFlow( out Label falseLabel );
   2: BoolTermAllowFlow( out Label falseLabel );
   2: BoolFactorAllowFlow( out Label falseLabel );
   2: ArithExprAllowFlow( out Label falseLabel );
   2: TermAllowFlow( out Label falseLabel );
   2: FactorAllowFlow( out Label falseLabel );
   2: PrimaryAllowFlow( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueFromDecl( Node decl, boolean writeable );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: FlowToVal( inout Label falseLabel );
   2: ValToFlow( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Start ----------------------------
      
   2: MainRule:
   4:    @Program
   7:    ;
      
   7: include 'pascal_unit.ssl'
      
      %
      %  Pascal Compiler
      %
      
      % ------------------------------ Units -----------------------------
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
   7: UsesClause( Node user ):
   9:    {
   9:       pIdent
  11:       @Uses( LAST_ID, user )
  20:       [
  20:          | ',' :
  22:          | * :  >
  29:       ]
  29:    }   
  31:    ';'
  34:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
  34: UsesMySystem( Node user ):
  36:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
  53:       | true :  >>
  55:       | * :
  60:    ]
  60:    @Uses( mysystemId, user )
  71:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
  71: FindSelectSystemDecls( Node unit ):
  73:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
  90:       | true :
  91:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 108:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 125:          System_ShortStringCmp = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringCmp )
 142:       | * :
 147:    ]
 148:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 148: Uses( int id, Node user ):
 150:    Node unit = @FindOrCompileUnit( id )
 161:    [ equal_node( unit, Null )
 171:       | false :
 172:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 184:          Node unitRef = oNodeNew( nUnitRef )
 194:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 213:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 232:          oScopeDeclare( unitRef )
 238:       | * :
 243:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 244: ResolveUnitRef( inout Node decl ):
 246:    [ oNodeType( decl )
 253:       | nUnitRef :
 254:          Node scope = oNodeGet( decl, qPublicScope )
 267:          '.'
 269:          pIdent
 271:          decl = oScopeFindRequireInScope( scope )
 281:       | * :
 286:    ];
      
      
 287: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 289:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 302:    {
 302:       Node unit = oNodeIterValue( unitIt )
 312:       [ oNodeNull( unit )
 319:          | false :
 320:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 333:          | * :
 338:             >
 340:       ]
 340:       oNodeIterNext( unitIt )
 346:    }
 349:    ;
      
 349: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 351:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 364:    {
 364:       Node unit = oNodeIterValue( unitIt )
 374:       [ oNodeNull( unit )
 381:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 382:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 398:                | true :
 399:                | false :  #eInternalScopeMismatch
 403:             ]
 411:             oScopeEnd
 412:          | * :
 417:             >
 419:       ]
 419:       oNodeIterPrev( unitIt )
 425:    }
 428:    ;
      
      
 428: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 430:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 449:    [ equal_node( unit, Null )
 459:       | false :  >> unit
 463:       | * :
 468:    ]
      
         % If not, search for the source file on disk
 468:    boolean ok = oIncludeUnitFile( id )
 478:    [ ok
 481:       | false :  #eCantFindUnitFile  >> Null
 487:       | * :
 492:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 492:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 498:    oIncludeEnd
 499:    >> unit;
      
      
      
 503: Unit >> Node:
 505:    pUnit
 507:    pIdent
 509:    Node unit = oNodeNew( nUnit )
 519:    oNodeSetInt( unit, qIdent, LAST_ID )
 530:    Node unitImpl = oNodeNew( nUnitImpl )
 540:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 551:    oNodeSet( unit, qImpl, unitImpl )
 563:    ';'
      
         % mandatory sections
      
 565:    pInterface
 567:    @UsesMySystem( unit )
 574:    [
 574:       | pUses :   @UsesClause( unit )
 583:       | * :
 588:    ]
 588:    @EnterUsedUnits( unit )
      
 595:    oScopeBegin( 0, allocGlobal )
 604:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 615:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 620:    oScopeBegin( 0, allocDown )
 629:    initScope = oScopeCurrent
 634:    oNodeSet( unit, qInitRoutineScope, initScope )
 646:    oScopeEnd
      
 647:    @UnitInterface( unit )
 654:    oScopeEnd  % interface scope
      
 655:    pImplementation
 657:    @UsesMySystem( unitImpl )
 664:    [
 664:       | pUses :   @UsesClause( unitImpl )
 673:       | * :
 678:    ]
 678:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 685:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 698:    oScopeBegin( 0, allocGlobal )
 707:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 718:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 736:    globalScope = oScopeCurrent
 741:    @UnitImplementation( unit )
      
 748:    [
 748:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 760:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 775:    ]
 775:    [
 775:       | pFinalization :  @UnitFinalization( unit, true )
 787:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 802:    ]
 802:    pEnd  '.'
      
 806:    oScopeEnd  % impl scope
 807:    oScopeEnd  % interface scope
 808:    @EndUsedUnits( unitImpl )  % used units scopes
 815:    @EndUsedUnits( unit )
 822:    oNodeAddLast( workspace, qUnits, unit )
 834:    >> unit;
      
      
 838: UnitInterface( Node unit ):
 840:    {[
 840:       | pConst :     @ConstDecl
 844:       | pType :      @TypeDecl
 848:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
 857:       | pProcedure :
 859:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
 865:          [
 865:             | pExternal :
 867:                @ExternalDecl( decl )
 874:                ';'
 876:             | * :
 881:          ]
      
 881:       | pFunction :
 883:          Node decl = @FuncHeaderDecl
 889:          [
 889:             | pExternal :
 891:                @ExternalDecl( decl )
 898:                ';'
 900:             | * :
 905:          ]
      
 905:       | * :          >
 920:    ]}
 922:    @FindSelectSystemDecls( unit )
 930:    ;
      
 930: UnitImplementation( Node unit ):
 932:    @BlockDecls( nGlobalVar )
 940:    ;
      
      
 940: UnitInitialization( Node unit, boolean hasStmts ):
 942:    Label label = oLabelNew
 947:    .tLabel  oEmitLabel( label )
 955:    oNodeSetLabel( unit, qInitLabel, label )
      
 967:    int patchLS
 967:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
 976:    Node scope
 976:    Code initCode
      
 976:    scope = oNodeGet( unit, qPublicScope )
 989:    initCode = oNodeGetCode( scope, qInitCode )
1002:    oEmitCode( initCode )
1008:    oNodeSetCode( scope, qInitCode, codeNull )
      
1020:    scope = oNodeGet( unit, qPrivateScope )
1033:    initCode = oNodeGetCode( scope, qInitCode )
1046:    oEmitCode( initCode )
1052:    oNodeSetCode( scope, qInitCode, codeNull )
      
1064:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1077:    [ hasStmts
1080:       | true :     
1081:          @Statement
1083:          {[
1083:             | ';' :  @Statement
1087:             | * :    >
1094:          ]}
1096:       | * :
1101:    ]
      
1101:    .tReturn
      
1103:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1115:    oPatch( patchLS, localSpace )
1124:    oScopeEnd   % init routine scope, for temporaries
1126:    ;
      
      
1126: UnitFinalization( Node unit, boolean hasStmts ):
1128:    Label label = oLabelNew
1133:    .tLabel  oEmitLabel( label )
1141:    oNodeSetLabel( unit, qFinalLabel, label )
      
1153:    int patchLS
1153:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1162:    oScopeBegin( 0, allocDown )
      
1171:    [ hasStmts
1174:       | true :     
1175:          @Statement
1177:          {[
1177:             | ';' :  @Statement
1181:             | * :    >
1188:          ]}
1190:       | * :
1195:    ]
      
1195:    .tReturn
      
1197:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1209:    oPatch( patchLS, localSpace )
1218:    oScopeEnd   % final routine scope, for temporaries
1220:    ;
      
      
1220: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1222:    NodeIter it = oNodeGetIter( workspace, qUnits )
1235:    {
1235:       Node unit = oNodeIterValue( it )
1245:       [ oNodeNull( unit )
1252:          | true :  >
1255:          | false :
1257:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1265:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1280:             .tFreeActuals  oEmitInt( 0 )
1288:             oNodeIterNext( it )
1294:       ]
1302:    };
      
      
1305: FinalizeUnits:
1307:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1320:    {
1320:       Node unit = oNodeIterValue( it )
1330:       [ oNodeNull( unit )
1337:          | true :  >
1340:          | false :
1342:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1350:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1365:             .tFreeActuals  oEmitInt( 0 )
1373:             oNodeIterPrev( it )
1379:       ]
1387:    };
      
1390: include 'pascal_decl.ssl'
      %
      % Pascal Compiler
      %
      
      % ----------------------------- Declarations ----------------------------
      
      
      
      % modifers that may appear on a proc/function declaration.
      %
1390: MethodModifiers( Node decl ):
1392:    {[
1392:       | pCdecl :
1394:          oNodeSetBoolean( decl, qCdecl, true )
1406:          ';'
      
1408:       | * : >
1415:    ]}
1418:    ;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1418: ExternalDecl( Node decl ):
1420:    [ equal_zero( @DeclLevel( decl ) )
1432:       | false :  #eExternalMethodCannotBeNested
1435:       | * :
1440:    ]
1440:    oNodeSetBoolean( decl, qExternal, true )
1452:    [
1452:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1454:          [
1454:             | pName :
1456:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1458:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1469:             | * :
1474:          ]
1474:       | * :
1479:    ]
1479:    @DefineExternLabel( decl )
1487:    ;
      
      
1487: ProcHeaderDecl >> Node:
1489:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1491:    boolean redeclaring = false
1497:    Node decl = oScopeFindInCurrentScope
      
1502:    [ oNodeNull( decl )
1509:       | true :
               % first declaration
1510:          decl = @newIdent( nProc, LAST_ID )
1523:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1534:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1536:          redeclaring = true
1542:          [ oNodeGetBoolean( decl, qBodyDefined )
1552:             | true : #eAlreadyDefined
1555:             | * :
1560:          ]
1560:          [ oNodeGetBoolean( decl, qExternal )
1570:             | true : #eAlreadyDefined
1573:             | * :
1578:          ]
1578:          [ oNodeType( decl )
1585:             | nProc :
1586:             | * : #eAlreadyDefined   % wrong kind
1593:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1593:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1612:          oNodeSet( decl, qParams, Null )
1624:    ]
      
1632:    int level = @ScopeLevel
1638:    boolean nested = greater( level, 0 )
1651:    inc( level )
1657:    oScopeBegin( level, allocUp )
1666:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
1671:    [ nested
1674:       | true :
1675:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
1690:       | * :
1695:    ]
      
1695:    @FormalArgDecl
1697:    oNodeSet( decl, qParams, paramScope )
1709:    oScopeEnd
1710:    ';'
      
1712:    [ redeclaring
1715:       | false : oScopeDeclare( decl )
1722:       | true :  % TO DO: check that qParams is consistent with qOldParams
1724:    ]
      
1732:    @MethodModifiers( decl )
1739:    >> decl;
      
      
1743: ProcDecl:
1745:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
1751:    [
1751:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
1753:       | pExternal : @ExternalDecl( decl )
      
1762:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
1769:          Node paramScope = oNodeGet( decl, qParams )
1782:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
1788:          int level = oNodeGetInt( paramScope, qLevel )
1801:          oScopeBegin( level, allocDown )
1810:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
1821:          Label label = oNodeGetLabel( decl, qValue )
1834:          @Block( nLocalVar, label )
1844:          oNodeSetBoolean( decl, qBodyDefined, true )
1856:          oScopeEnd
      
1857:          oScopeEnd  % paramScope
1858:    ]
1858:    ';';
      
      
      
1861: FuncHeaderDecl >> Node:
1863:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1865:    boolean redeclaring = false
1871:    Node decl = oScopeFindInCurrentScope
      
1876:    [ oNodeNull( decl )
1883:       | true :
               % first declaration
1884:          decl = @newIdent( nFunc, LAST_ID )
1897:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1908:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1910:          redeclaring = true
1916:          [ oNodeGetBoolean( decl, qBodyDefined )
1926:             | true : #eAlreadyDefined
1929:             | * :
1934:          ]
1934:          [ oNodeType( decl )
1941:             | nFunc :
1942:             | * : #eAlreadyDefined   % wrong kind
1949:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
1949:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
1968:          oNodeSet( decl, qParams, Null )
1980:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
1999:          oNodeSet( decl, qType, Null )
2011:    ]
      
2019:    int level = @ScopeLevel
2025:    boolean nested = greater( level, 0 )
2038:    inc( level )
2044:    oScopeBegin( level, allocUp )
2053:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2058:    [ nested
2061:       | true :
2062:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2077:       | * :
2082:    ]
      
2082:    @FormalArgDecl
2084:    oNodeSet( decl, qParams, paramScope )
      
2096:    ':'
      
2098:    Node theType
2098:    @TypeRef( theType )
2105:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2117:    Node ptrType = @PointerTypeTo( theType )
2128:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2144:    oScopeEnd
2145:    ';'
      
2147:    [ redeclaring
2150:       | false : oScopeDeclare( decl )
2157:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2159:    ]
      
2167:    @MethodModifiers( decl )
      
2174:    >> decl;
      
      
2178: FuncDecl:
2180:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2186:    [
2186:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2188:       | pExternal : @ExternalDecl( decl )
      
2197:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2204:          Node paramScope = oNodeGet( decl, qParams )
2217:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2223:          int level = oNodeGetInt( paramScope, qLevel )
2236:          oScopeBegin( level, allocDown )
2245:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2256:          Label label = oNodeGetLabel( decl, qValue )
2269:          @Block( nLocalVar, label )
2279:          oNodeSetBoolean( decl, qBodyDefined, true )
2291:          oScopeEnd
      
2292:          oScopeEnd  % paramScope
2293:    ]
2293:    ';';
      
      
2296: FormalArgDecl:
2298:    [
2298:       | '(' :
2300:          {
2300:             NodeVec decls = oNodeVecNew
2305:             Node decl
2305:             boolean isInOut = false
      
2311:             [
2311:                | pVar : isInOut = true
2319:                | * :
2324:             ]
      
2324:             {  pIdent
      
2326:                decl = @newIdent( nParam, LAST_ID )
2339:                oNodeSetBoolean( decl, qInOut, isInOut )
2351:                oNodeVecAppend( decls, decl )
      
2360:                [
2360:                   | ':' : >
2364:                   | ',' :
2366:                ]
2374:             }
      
2376:             Node theType
2376:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2383:             Node allocType
2383:             [ isInOut
2386:                | true :   allocType = @PointerTypeTo( theType )
2398:                | * :      allocType = theType
2409:             ]
      
2409:             int i = 0
2415:             {[ equal( i, oNodeVecSize( decls ) )
2429:                | false :
2430:                   decl = oNodeVecElement( decls, i )
      
2443:                   oNodeSet( decl, qType, theType )
2455:                   oScopeDeclare( decl )
2461:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2477:                   inc( i )
2483:                | * :
2488:                   >
2490:             ]}
      
2492:             oNodeVecDelete( decls )
      
2498:             [
2498:                | ')' : >
2502:                | ';' :
2504:             ]
2512:          }
2514:       | * :
2519:    ];
      
      
2520: ConstDecl:
2522:    {[
2522:       | pIdent :
2524:          [
2524:             | ':' :
2526:                @TypedConstDecl
2528:             | * :
2533:                @TrueConstDecl
2535:          ]
2535:       | * :
2540:          >
2542:    ]};
      
      
      % Parse a true constant declaration (as opposed to a typed const declaration).
      % The "true constant" terminology comes from Delphi docs.  It refers to a const that is
      % evaluated at compile time, rather than at program startup time.
      %
      % We've just accepted the identifier.
      %
2545: TrueConstDecl:
2547:    int id = LAST_ID
2552:    '='
      
2554:    @ConstExpr
      
2556:    Node decl
2556:    [ oTypeSNodeType
2558:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2559:         nPointerType, nUniversalPointerType :
2559:          decl = @newIdent( nConst, id )
2573:          oNodeSetInt( decl, qValue, oValueTop )
2584:       | nDoubleType :
2586:          decl = @newIdent( nConstDouble, id )
2600:          oNodeSetDouble( decl, qValueDouble, oValueTopDouble )
2611:       | nStrLitType :
2613:          decl = @newIdent( nConstStr, id )
2627:          oNodeSetString( decl, qValueStr, oValueTopString )
2638:       | * :  #eNotAllowed
2661:    ]
2661:    oValuePop
2662:    oNodeSet( decl, qType, oTypeSTop )
2673:    oTypeSPop
2674:    oScopeDeclare( decl )
2680:    ';'
2683:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
2683: TypedConstDecl:
2685:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
2698:    Node theType
2698:    @TypeRef( theType )
2705:    oNodeSet( decl, qType, theType )
      
         % Array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value, as I do with "true constants".
         %
         % TO DO: I probably should store scalar consts in memory too, in case somebody
         % wants to get a pointer to them.  And anyway, typed constants can't be used in
         % constant expressions, so less need to store value in decl node.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
2717:    [ oNodeType( theType )
2724:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType,
2725:         nPointerType, nUniversalPointerType :
               % Parse expression and store value in decl
2725:          '='
      
2727:          oTypeSPush( theType )
2733:          @ConstExpr
2735:          @ConstCoerceType
      
2737:          oNodeSetInt( decl, qValue, oValueTop )
2748:          oValuePop
2749:          oTypeSPop
2750:          oScopeDeclare( decl )
2756:          ';'
      
2758:       | nShortStringType, nFileType :
2760:          #eNotImplemented
      
2762:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
2764:          oScopeEnter( globalScope )
2770:          int addr = oScopeAllocType( theType )
2780:          oScopeEnd
2781:          oCodePush( @GetOrCreateInitCode( globalScope ) )
2792:          oNodeSetInt( decl, qValue, addr )
2804:          '='
2806:          @TypedConstInit( theType, addr )
2816:          oCodePop
2817:          oScopeDeclare( decl )
2823:          ';'
2825:    ]
2852:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
2852: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
2854:    [ oNodeType( theType )
2861:       | nArrayType :
2862:          Node baseType = oNodeGet( theType, qBaseType )
2875:          Node indexType = oNodeGet( theType, qIndexType )
2888:          int low = @OrdinalLow( indexType )
2899:          int high = @OrdinalHigh( indexType )
2910:          int elementSize = oNodeGetInt( baseType, qSize )
      
2923:          '('
               % Loop over elements
2925:          int i = low
2931:          {
2931:             @TypedConstInit( baseType, addr )
2941:             [ equal( i, high )
2951:                | true : >
2954:                | false :
2956:             ]
2964:             ','
2966:             addr = add( addr, elementSize )
2979:             inc( i )
2985:          }
2987:          ')'
      
2989:       | nRecordType :
2991:          '('
2993:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3006:          {
3006:             [
3006:                | pIdent :
3008:                | * :  >
3015:             ]
3015:             Node field = oScopeFindRequireInScope( fieldScope )
3025:             ':'
3027:             Node fieldType = oNodeGet( field, qType )
3040:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3060:             @TypedConstInit( fieldType, fieldAddr )
3070:             [
3070:                | ';' :
3072:                | * :  >
3079:             ]
3079:          }
3081:          ')'
      
3083:       | nBooleanType, nByteType, nCharType:
3085:          .tPushAddrGlobal  oEmitInt( addr )
3093:          oTypeSPush( theType )
3099:          @ConstExpr
3101:          @ConstCoerceType
3103:          .tPushConstI  oEmitInt( oValueTop )
3110:          oValuePop
3111:          oTypeSPop
3112:          .tAssignB
      
3114:       | nIntegerType, nEnumType:
3116:          .tPushAddrGlobal  oEmitInt( addr )
3124:          oTypeSPush( theType )
3130:          @ConstExpr
3132:          @ConstCoerceType
3134:          .tPushConstI  oEmitInt( oValueTop )
3141:          oValuePop
3142:          oTypeSPop
3143:          .tAssignI
      
3145:       | nDoubleType:
3147:          #eNotImplemented
      
3149:       | nPointerType, nUniversalPointerType :
3151:          .tPushAddrGlobal  oEmitInt( addr )
3159:          oTypeSPush( theType )
3165:          @ConstExpr
3167:          @ConstCoerceType
3169:          .tPushConstI  oEmitInt( oValueTop )   % only allowing ptr constant Nil so don't need tPushConstP or link redirection
3176:          oValuePop
3177:          oTypeSPop
3178:          .tAssignP
      
3180:       | nShortStringType, nFileType :
3182:          #eNotImplemented
3184:    ]
3213:    ;
      
      
3213: TypeDecl:
3215:    {[
3215:       | pIdent :
3217:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3230:          '='
3232:          Node theType
3232:          @TypeRef( theType )
3239:          oNodeSet( decl, qType, theType )
3251:          oScopeDeclare( decl )
3257:          ';'
3259:       | * :
3264:          >
3266:    ]};
      
3269: VarDecl( node_type varNodeType ):
3271:    {[
3271:       | pIdent :
3273:          NodeVec decls = oNodeVecNew
3278:          Node decl
3278:          {
3278:             decl = @newIdent( varNodeType, LAST_ID )
3291:             oNodeVecAppend( decls, decl )
3300:             [
3300:                | ',' :
3302:                   pIdent
3304:                | * :
3309:                   >
3311:             ]
3311:          }
3313:          ':'
3315:          Node theType
3315:          @TypeRef( theType )
      
3322:          int i = 0
3328:          {[ equal( i, oNodeVecSize( decls ) )
3342:             | false :
3343:                decl = oNodeVecElement( decls, i )
3356:                oNodeSet( decl, qType, theType )
3368:                oScopeDeclareAlloc( decl )
3374:                inc( i )
3380:             | * :
3385:               >
3387:          ]}
      
               % optional initialization
3389:          [
3389:             | '=' :
3391:                [ oNodeVecSize( decls )
3398:                   | 1 :
3399:                   | * :  #eOnlyOneVarCanBeInitialized
3406:                ]
      
                     % we need an initCode stream for this scope
3406:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3416:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3422:                boolean changedScope = false
3428:                [ equal_zero( @ScopeLevel )
3435:                   | true : oScopeEnter( initScope )
3442:                            changedScope = true
3448:                   | * :
3453:                ]
                     % generate assignment in initCode stream
3453:                @LValueVar( decl, true )
3463:                @Expr
3465:                @CoerceType
3467:                @Assign
3469:                [ changedScope
3472:                   | true : oScopeEnd
3474:                   | * :
3479:                ]
3479:                oCodePop
                   
3480:             | * :
3485:          ]
      
3485:          oNodeVecDelete( decls )
3491:          ';'
3493:       | * :
3498:          >
3500:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3503: LabelDecl:
3505:    {
3505:       Node decl
3505:       [
3505:          | pIdent :
3507:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3509:             oChangeIntLitToLabelIdent
3510:       ]
3518:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3531:       Label label = oLabelNew
3536:       oNodeSetLabel( decl, qValue, label )
3548:       oScopeDeclare( decl )
3554:       [
3554:          | ',' :
3556:          | * :
3561:             >
3563:       ]
3563:    }
3565:    ';'
3568:    ;
3568: include 'pascal_constexpr.ssl'
      %
      % Pascal Compiler
      %
      
      % --------------------------- Const Expressions --------------------------
      
      
      % Constant expressions are evaluated at compile time.
      % They are limited to constant literals, declared constants (not including TypedConstants!)
      % and a small selection of built-in functions. 
      %
      % The value of a constant expression is left on the Value Stack.
      % The type is left on the Type Stack.
      
3568: ConstExpr:
3570:    @ConstBoolExpr
3572:    {[
3572:       | '=' :
3574:          @ConstBoolTerm
3576:          @ConstMatchTypes
3578:          [ oTypeSNodeType
3580:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueEqual
3589:             | nDoubleType :   oValueEqualD
3592:             | * :             oValueEqual
3600:          ]
3600:          oTypeSPop  oTypeSPush( BooleanType )
3607:       | '<>' :
3609:          @ConstBoolExpr
3611:          @ConstMatchTypes
3613:          [ oTypeSNodeType
3615:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueNotEqual
3624:             | nDoubleType :   oValueNotEqualD
3627:             | * :             oValueNotEqual
3635:          ]
3635:          oTypeSPop  oTypeSPush( BooleanType )
3642:       | '<' :
3644:          @ConstBoolExpr
3646:          @ConstMatchTypes
3648:          [ oTypeSNodeType
3650:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLess
3659:             | nDoubleType :   oValueLessD
3662:             | * :             oValueLess
3670:          ]
3670:          oTypeSPop  oTypeSPush( BooleanType )
3677:       | '>' :
3679:          @ConstBoolExpr
3681:          @ConstMatchTypes
3683:          [ oTypeSNodeType
3685:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreater
3694:             | nDoubleType :   oValueGreaterD
3697:             | * :             oValueGreater
3705:          ]
3705:          oTypeSPop  oTypeSPush( BooleanType )
3712:       | '<=' :
3714:          @ConstBoolExpr
3716:          @ConstMatchTypes
3718:          [ oTypeSNodeType
3720:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueLessEqual
3729:             | nDoubleType :   oValueLessEqualD
3732:             | * :             oValueLessEqual
3740:          ]
3740:          oTypeSPop  oTypeSPush( BooleanType )
3747:       | '>=' :
3749:          @ConstBoolExpr
3751:          @ConstMatchTypes
3753:          [ oTypeSNodeType
3755:             | nStrLitType :   oValueStringCmp  oValuePush( 0 )  oValueGreaterEqual
3764:             | nDoubleType :   oValueGreaterEqualD
3767:             | * :             oValueGreaterEqual
3775:          ]
3775:          oTypeSPop  oTypeSPush( BooleanType )
3782:       | * :  >
3799:    ]};
      
      
      % Same as ConstExpr, but allow a typename as a primary.
      % This is for use within sizeof().
      % The value produced by that primary is bogus, but doesn't matter.
      %
3802: ConstExprAllowTypeName:
3804:    boolean oldAllowTypeName = flagExprAllowTypeName
3810:    flagExprAllowTypeName = true
3816:    @ConstExpr
3818:    flagExprAllowTypeName = oldAllowTypeName
3825:    ;
      
      
3825: ConstBoolExpr:
3827:    @ConstBoolTerm
3829:    {[
3829:       | pOr :
3831:          @ConstRequireBool
3833:          @ConstBoolTerm
3835:          @ConstRequireBoolPop
3837:          oValueOr
3838:       | * :  >
3845:    ]};
      
      
3848: ConstBoolTerm:
3850:    @ConstBoolFactor
3852:    {[
3852:       | pAnd :
3854:          @ConstRequireBool
3856:          @ConstBoolFactor
3858:          @ConstRequireBoolPop
3860:          oValueAnd
3861:       | * :  >
3868:    ]};
      
      
3871: ConstBoolFactor:
3873:    [
3873:       | pNot :
3875:          @ConstBoolFactor
3877:          @ConstRequireBool
3879:          oValueNot
3880:       | * :
3885:          @ConstArithExpr
3887:    ];
      
      
3888: ConstArithExpr:
3890:    @ConstTerm
3892:    {[
3892:       | '+' :
3894:          @ConstTerm
3896:          @ConstMatchTypes
3898:          [ oTypeSNodeType
3900:             | nStrLitType :   oValueStringConcat
3902:             | nDoubleType :   oValueAddD
3905:             | * :             oValueAdd
3913:          ]
3913:       | '-' :
3915:          @ConstTerm
3917:          @ConstMatchTypes
3919:          [ oTypeSNodeType
3921:             | nStrLitType :   #eNotAllowed
3924:             | nDoubleType :   oValueSubD
3927:             | * :             oValueSub
3935:          ]
3935:       | * :  >
3944:    ]};
      
      
3947: ConstTerm:
3949:    @ConstFactor
3951:    {[
3951:       | pTimes :
3953:          @ConstFactor
3955:          @ConstMatchTypes
3957:          [ oTypeSNodeType
3959:             | nStrLitType :   #eNotAllowed
3962:             | nDoubleType :   oValueMultD
3965:             | * :             oValueMult
3973:          ]
3973:       | pDivide :
3975:          @ConstFactor
3977:          @ConstMatchTypes
3979:          [ oTypeSNodeType
3981:             | nStrLitType :   #eNotAllowed
3984:             | nDoubleType :   oValueDivD
3987:             | * :             oValueDiv
3995:          ]
3995:       | * :  >
4004:    ]};
      
      
4007: ConstFactor:
4009:    [
4009:       | pPlus :
4011:          @ConstPrimary
4013:       | pMinus :
4015:          @ConstPrimary
4017:          [ oTypeSNodeType
4019:             | nStrLitType :   #eNotAllowed
4022:             | nDoubleType :   oValueNegateD
4025:             | * :             oValueNegate
4033:          ]
4033:       | * :
4040:          @ConstPrimary
4042:    ];
      
      
4043: ConstPrimary:
4045:    [
4045:       | pIntLit :
4047:          oValuePush( TOKEN_VALUE )
4052:          oTypeSPush( IntegerType )
4058:       | pCharLit :
4060:          oValuePush( TOKEN_VALUE )
4065:          oTypeSPush( CharType )
4071:       | pDoubleLit :
4073:          oValuePushDouble( TOKEN_VALUE_DOUBLE )
4078:          oTypeSPush( DoubleType )
4084:       | pStrLit :
4086:          oValuePushString( CURRENT_STRLIT )
4091:          oTypeSPush( StrLitType )
4097:       | '(' :
4099:          @ConstExpr
4101:          ')'
4103:       | pIdent :
4105:          Node decl = oScopeFindRequire
4110:          @ResolveUnitRef( decl )
4117:          [ oNodeType( decl )
4124:             | nBuiltInFunc :
4125:                @ConstBuiltInFunc( decl )
4132:             | nConst :
4134:                oValuePush( oNodeGetInt( decl, qValue ) )
4147:                oTypeSPush( oNodeGet( decl, qType ) )
4160:             | nConstStr :
4162:                oValuePushString( oNodeGetString( decl, qValueStr ) )
4175:                oTypeSPush( oNodeGet( decl, qType ) )
4188:             | nEnumValue :
4190:                oValuePush( oNodeGetInt( decl, qValue ) )
4203:                oTypeSPush( oNodeGet( decl, qType ) )
4216:             | nTypeDecl :
                     % A type cast, or a typename primary when within sizeof()
4218:                oTypeSPush( oNodeGet( decl, qType ) )
4231:                [
4231:                   | '(' :
                           % Type cast
4233:                      @ConstExpr
4235:                      ')'
4237:                      @ConstCastType
                           % Constexprs are not compound types or dereferenceable pointers (I believe)
                           % so no need to check for additional suffixes here as we do in PrimaryAllowCF
4239:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
4244:                      [ flagExprAllowTypeName
4247:                         | true :
                                 % The value we produce is bogus.  Only the type stack matters.
4248:                            oValuePush( 0 )
4254:                         | * :   #eTypeNameNotAllowedHere
4261:                      ]
4261:                ]
      
4261:             | * :
4274:                #eNotConst
4276:                oValuePush( 0 )
4282:                oTypeSPush( IntegerType )
4288:          ]
4288:       | '@' :
4290:          #eNotImplemented
4292:          oValuePush( 0 )
4298:          oTypeSPush( UniversalPointerType )
4304:       | * :
4321:          #eNotConst
4323:          oValuePush( 0 )
4329:          oTypeSPush( IntegerType )
4335:    ];
      
4336: ConstRequireBoolPop:
4338:    [ oTypeSNodeType
4340:       | nBooleanType :
4341:       | * :          #eNotBoolean
4348:    ]
4348:    oTypeSPop;
      
      
4350: ConstRequireBool:
4352:    [ oTypeSNodeType
4354:       | nBooleanType :
4355:       | * :          #eNotBoolean
4362:    ];
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      % The types refer to constant values on the Value Stack,
      % so any implicit conversion would occur there, not in code.
      %
      % Some implicit conversion is allowed for either of the types.
      % See also ConstCoerceType where only the top type may change.
      %
4363: ConstMatchTypes:
4365:    node_type nt = oTypeSNodeType
4370:    oTypeSPop
4371:    [ equal_node_type( nt, oTypeSNodeType )
4380:       | false :
               % Some implicit conversion is allowed even here
4381:          [ oTypeSNodeType
4383:             | nPointerType :
4384:                [ nt
4387:                   | nUniversalPointerType :  >>
4389:                   | * :
4394:                ]
4394:             | nUniversalPointerType :
4396:                [ nt
4399:                   | nPointerType :  >>
4401:                   | * :
4406:                ]
4406:             | nStrLitType :
4408:                [ nt
4411:                   | nCharType :
4412:                      oValueCharToString
4413:                      >>
4414:                   | * :
4419:                ]
4419:             | nCharType :
4421:                [ nt
4424:                   | nStrLitType :
4425:                      oValueSwap
4426:                      oValueCharToString
4427:                      oValueSwap
4428:                      oTypeSPop
4429:                      oTypeSPush( StrLitType )
4435:                      >>
4436:                   | * :
4441:                ]
4441:             | * :
4452:          ]
4452:          #eTypeMismatch
4454:       | * :
4459:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary implicit conversions so the value is the desired type.
      % Pop the top type, leaving only the desired type.
      %
4460: ConstCoerceType:
4462:    node_type nt = oTypeSNodeType
4467:    oTypeSPop
4468:    [ equal_node_type( nt, oTypeSNodeType )
4477:       | false :
               % Can we implicitly convert the value to the desired type?
4478:          [ oTypeSNodeType
4480:             | nIntegerType :
4481:                [ nt
4484:                   | nByteType :  >>
4486:                   | * :
4491:                ]
4491:             | nByteType :
4493:                [ nt
4496:                   | nIntegerType :  >>
4498:                   | * :
4503:                ]
4503:             | nPointerType :
4505:                [ nt
4508:                   | nUniversalPointerType :  >>
4510:                   | * :
4515:                ]
4515:             | nUniversalPointerType :
4517:                [ nt
4520:                   | nPointerType :  >>
4522:                   | * :
4527:                ]
4527:             | nStrLitType :
4529:                [ nt
4532:                   | nCharType :
4533:                      oValueCharToString
4534:                      >>
4535:                   | * :
4540:                ]
4540:             | nShortStringType :
4542:                [ nt
4545:                   | nStrLitType :  >>
4547:                   | nCharType :
4549:                      oValueCharToString
4550:                      >>
4551:                   | * :
4558:                ]
4558:             | * :
4573:          ]
4573:          #eTypeMismatch
4575:       | * :
4580:    ];
      
      
      % Given a constant value on the value stack, its type on the type stack,
      % and the desired type under it on the type stack.
      % Perform any necessary conversions so the value is cast to the desired type.
      % Pop the top type, leaving only the desired type.
      %
      % This is stronger than ConstCoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
4581: ConstCastType:
4583:    node_type nt = oTypeSNodeType
4588:    oTypeSPop
4589:    [ equal_node_type( nt, oTypeSNodeType )
4598:       | false :
               % Can we cast the value to the desired type?
4599:          [ oTypeSNodeType
4601:             | nIntegerType, nEnumType :
4602:                [ nt
4605:                   | nByteType, nCharType, nBooleanType :  >>
4607:                   | nIntegerType, nEnumType :  >>
                        % fpc does not allow explicit cast of double to integer.
                        % User must call trunc() / round().
4610:                   | * :
4623:                ]
4623:             | nByteType, nCharType, nBooleanType :
4625:                [ nt
4628:                   | nByteType, nCharType, nBooleanType :  >>
4630:                   | nIntegerType, nEnumType :  >>
4633:                   | * :
4646:                ]
4646:             | nDoubleType :
4648:                [ nt
4651:                   | nByteType, nCharType, nBooleanType, nIntegerType, nEnumType :
4652:                      oValueIntToDouble
4653:                      >>
4654:                   | nDoubleType :  >>
4657:                   | * :
4672:                ]
4672:             | nPointerType :
4674:                [ nt
4677:                   | nUniversalPointerType :  >>
4679:                   | * :
4684:                ]
4684:             | nUniversalPointerType :
4686:                [ nt
4689:                   | nPointerType :  >>
4691:                   | * :
4696:                ]
4696:             | nStrLitType :
4698:                [ nt
4701:                   | nCharType :
4702:                      oValueCharToString
4703:                      >>
4704:                   | * :
4709:                ]
4709:             | nShortStringType :
4711:                [ nt
4714:                   | nStrLitType :  >>
4716:                   | nCharType :
4718:                      oValueCharToString
4719:                      >>
4720:                   | * :
4727:                ]
4727:             | * :
4750:          ]
4750:          #eTypeMismatch
4752:       | * :
4757:    ];
      
      
      % These are the methods that Pascal allows in a constant expression:
      %   Abs( x: integer_or_real ) : integer_or_real
      %   Round( x: real ) : integer
      %   Trunc( x: real ) : integer
      %   Chr( x: integer ) : char
      %   Ord( x: ordinal ) : integer
      %   Length( s: string ) : integer
      %   Pred( x: ordinal ) : ordinal
      %   Succ( x: ordinal ) : ordinal
      %   SizeOf( var, expr, or typename ) : integer
      %   Odd( x: integer ) : boolean  - true if the argument is odd
      %
4758: ConstBuiltInFunc( Node method ):
      
         % Ord(x)
4760:    [ oNodeEqual( method, BuiltIn_Ord )
4770:       | true :
4771:          '('
4773:          @ConstExpr
4775:          ')'
4777:          [ oTypeSNodeType
4779:             | nIntegerType, nEnumType :
4780:             | nBooleanType, nByteType, nCharType :
4782:             | * :  #eTypeMismatch
4797:          ]
4797:          oTypeSPop
4798:          oTypeSPush( IntegerType )
4804:          ')'
4806:          >>
4807:       | * :
4812:    ]
      
         % Chr(x)
4812:    [ oNodeEqual( method, BuiltIn_Chr )
4822:       | true :
4823:          '('
4825:          @ConstExpr
4827:          ')'
4829:          [ oTypeSNodeType
4831:             | nIntegerType :
4832:             | nByteType :
4834:             | * :  #eTypeMismatch
4843:          ]
4843:          oTypeSPop
4844:          oTypeSPush( CharType )
4850:          ')'
4852:          >>
4853:       | * :
4858:    ]
      
         % Pred(x)
4858:    [ oNodeEqual( method, BuiltIn_Pred )
4868:       | true :
4869:          '('
4871:          @ConstExpr
4873:          [ oTypeSNodeType
4875:             | nEnumType :
4876:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4885:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4888:                   | * :
4893:                ]
4893:             | * :  #eTypeMismatch
4900:          ]
4900:          oValuePush( 1 )  oValueSub
4907:          ')'
4909:          >>
4910:       | * :
4915:    ]
      
         % Succ(x)
4915:    [ oNodeEqual( method, BuiltIn_Succ )
4925:       | true :
4926:          '('
4928:          @ConstExpr
4930:          [ oTypeSNodeType
4932:             | nEnumType :
4933:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
4942:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
4945:                   | * :
4950:                ]
4950:             | * :  #eTypeMismatch
4957:          ]
4957:          oValuePush( 1 )  oValueAdd
4964:          ')'
4966:          >>
4967:       | * :
4972:    ]
      
         % Sizeof(x)
4972:    [ oNodeEqual( method, BuiltIn_Sizeof )
4982:       | true :
4983:          '('
               % Parse expression but only for its type.
               % And, allow use of typename as a primary in the expression.
4985:          @ConstExprAllowTypeName
4987:          oValuePop
4988:          Node theType = oTypeSTop
4993:          oTypeSPop
4994:          oValuePush( oNodeGetInt( theType, qSize ) )
5007:          oTypeSPush( IntegerType )
5013:          ')'
5015:          >>
5016:       | * :
5021:    ]
      
5021:    #eNotImplemented
5024:    ;
      
      
5024: include 'pascal_expr.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Expressions -----------------------------
      
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanFlowType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5024: Expr:
5026:    Label falseLabel = labelNull
      
5032:    @ExprAllowFlow( falseLabel )
5039:    @FlowToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse an expression, just like Expr,
      % but also allows type names as Primary elements of the expression.
      % This is for use by sizeof().
      % The value produced by that primary is bogus, but this is ok because the
      % caller (sizeof) is going to discard all generated code for the expression.
      % It's only interested in the type produced by the expression.
      %
5047: ExprAllowTypeName:
5049:    boolean oldAllowTypeName = flagExprAllowTypeName
5055:    flagExprAllowTypeName = true
5061:    @Expr
5063:    flagExprAllowTypeName = oldAllowTypeName
5070:    ;
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5070: BooleanExprControlFlow( out Label falseLabel ):
5072:    @ExprAllowFlow( falseLabel )
5079:    [ oTypeSNodeType
5081:       | nBooleanFlowType :
5082:       | nBooleanType :
               % convert value to control flow
5084:          falseLabel = oLabelNew
5089:          .tJumpFalse  oEmitLabel( falseLabel )
5097:       | * :
5104:          #eNotBoolean
5106:    ]
5106:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5108: FlowToVal( inout Label falseLabel ):
5110:    [ oTypeSNodeType
5112:       | nBooleanFlowType :
5113:          Label doneLabel = oLabelNew
5118:          .tPushConstI  oEmitInt( 1 )
5126:          .tJump  oEmitLabel( doneLabel )
5134:          .tLabel  oEmitLabel( falseLabel )
5142:          .tPushConstI  oEmitInt( 0 )
5150:          .tLabel  oEmitLabel( doneLabel )
5158:          oTypeSPop
5159:          oTypeSPush( BooleanType )
5165:          falseLabel = labelNull
5171:       | * :
5176:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5177: ValToFlow( out Label falseLabel ):
5179:    [ oTypeSNodeType
5181:       | nBooleanType :
5182:          falseLabel = oLabelNew
5187:          .tJumpFalse  oEmitLabel( falseLabel )
5195:          oTypeSPop
5196:          oTypeSPush( BooleanFlowType )
5202:       | * :
5207:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanFlowType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanFlowType.
      % In this case, falseLabel is ignored.
      %
5208: ExprAllowFlow( out Label falseLabel ):
5210:    @BoolExprAllowFlow( falseLabel )
5217:    {[
5217:       | '=' :
5219:          @FlowToVal( falseLabel )
5226:          @PromoteToIntOptional
5228:          @BoolExprAllowFlow( falseLabel )
5235:          @FlowToVal( falseLabel )
5242:          @PromoteToIntOptional
5244:          @MatchTypes
5246:          [ oTypeSNodeType
5248:             | nBooleanType, nCharType :     .tEqualB
5251:             | nIntegerType, nEnumType :     .tEqualI
5255:             | nPointerType, nUniversalPointerType :    .tEqualP
5259:             | nShortStringType, nStrLitType :
5261:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tEqualI
5273:             | * :                           #eNotAllowed
5294:          ]
5294:          oTypeSPop
5295:          oTypeSPush( BooleanType )
      
5301:       | '<>' :
5303:          @FlowToVal( falseLabel )
5310:          @PromoteToIntOptional
5312:          @BoolExprAllowFlow( falseLabel )
5319:          @FlowToVal( falseLabel )
5326:          @PromoteToIntOptional
5328:          @MatchTypes
5330:          [ oTypeSNodeType
5332:             | nBooleanType, nCharType :     .tNotEqualB
5335:             | nIntegerType, nEnumType :     .tNotEqualI
5339:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5343:             | nShortStringType, nStrLitType :
5345:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tNotEqualI
5357:             | * :                           #eNotAllowed
5378:          ]
5378:          oTypeSPop
5379:          oTypeSPush( BooleanType )
      
5385:       | '<' :
5387:          @FlowToVal( falseLabel )
5394:          @PromoteToIntOptional
5396:          @BoolExprAllowFlow( falseLabel )
5403:          @FlowToVal( falseLabel )
5410:          @PromoteToIntOptional
5412:          @MatchTypes
5414:          [ oTypeSNodeType
5416:             | nBooleanType, nCharType :     .tLessB
5419:             | nIntegerType, nEnumType :     .tLessI
5423:             | nPointerType, nUniversalPointerType :   .tLessP
5427:             | nShortStringType, nStrLitType :
5429:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessI
5441:             | * :                           #eNotAllowed
5462:          ]
5462:          oTypeSPop
5463:          oTypeSPush( BooleanType )
      
5469:       | '>' :
5471:          @FlowToVal( falseLabel )
5478:          @PromoteToIntOptional
5480:          @BoolExprAllowFlow( falseLabel )
5487:          @FlowToVal( falseLabel )
5494:          @PromoteToIntOptional
5496:          @MatchTypes
5498:          [ oTypeSNodeType
5500:             | nBooleanType, nCharType :     .tGreaterB
5503:             | nIntegerType, nEnumType :     .tGreaterI
5507:             | nPointerType, nUniversalPointerType :   .tGreaterP
5511:             | nShortStringType, nStrLitType :
5513:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterI
5525:             | * :                           #eNotAllowed
5546:          ]
5546:          oTypeSPop
5547:          oTypeSPush( BooleanType )
      
5553:       | '<=' :
5555:          @FlowToVal( falseLabel )
5562:          @PromoteToIntOptional
5564:          @BoolExprAllowFlow( falseLabel )
5571:          @FlowToVal( falseLabel )
5578:          @PromoteToIntOptional
5580:          @MatchTypes
5582:          [ oTypeSNodeType
5584:             | nBooleanType, nCharType :     .tLessEqualB
5587:             | nIntegerType, nEnumType :     .tLessEqualI
5591:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5595:             | nShortStringType, nStrLitType :
5597:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tLessEqualI
5609:             | * :                           #eNotAllowed
5630:          ]
5630:          oTypeSPop
5631:          oTypeSPush( BooleanType )
      
5637:       | '>=' :
5639:          @FlowToVal( falseLabel )
5646:          @PromoteToIntOptional
5648:          @BoolExprAllowFlow( falseLabel )
5655:          @FlowToVal( falseLabel )
5662:          @PromoteToIntOptional
5664:          @MatchTypes
5666:          [ oTypeSNodeType
5668:             | nBooleanType, nCharType :     .tGreaterEqualB
5671:             | nIntegerType, nEnumType :     .tGreaterEqualI
5675:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5679:             | nShortStringType, nStrLitType :
5681:                @ShortStringCmp  .tPushConstI  oEmitInt( 0 )  .tGreaterEqualI
5693:             | * :                           #eNotAllowed
5714:          ]
5714:          oTypeSPop
5715:          oTypeSPush( BooleanType )
      
5721:       | * :
5736:          >
5738:    ]};
      
      
5741: BoolExprAllowFlow( out Label falseLabel ):
5743:    Label trueLabel = labelNull
      
5749:    @BoolTermAllowFlow( falseLabel )
5756:    {[
5756:       | pOr :
5758:          [ oTypeSNodeType
5760:             | nBooleanFlowType :
                     % We are true here. Jump ahead to done
5761:                [ equal_label( trueLabel, labelNull )
5771:                   | true :  trueLabel = oLabelNew
5777:                   | * :
5782:                ]
5782:                .tJump  oEmitLabel( trueLabel )
5790:             | nBooleanType :
5792:                @ValToFlow( falseLabel )
                     % We are true here. Jump ahead to done
5799:                [ equal_label( trueLabel, labelNull )
5809:                   | true :  trueLabel = oLabelNew
5815:                   | * :
5820:                ]
5820:                .tJump  oEmitLabel( trueLabel )
5828:             | * : #eNotBoolean
5837:          ]
5837:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5838:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5846:          falseLabel = labelNull
5852:          @BoolTermAllowFlow( falseLabel )
      
5859:          [ oTypeSNodeType
5861:             | nBooleanFlowType :
5862:             | nBooleanType :
5864:                @ValToFlow( falseLabel )
5871:             | * : #eNotBoolean
5880:          ]
      
5880:          oTypeSPop
5881:          oTypeSPush( BooleanFlowType )
      
5887:       | * :
5892:          >
5894:    ]}
      
         % any short-circuit trues jump here to the end
5896:    [ equal_label( trueLabel, labelNull )
5906:       | false :
5907:          .tLabel  oEmitLabel( trueLabel )
5915:       | * :
5920:    ]
5921:    ;
      
      
5921: BoolTermAllowFlow( out Label falseLabel ):
5923:    Label overallFalseLabel = labelNull
      
5929:    @BoolFactorAllowFlow( falseLabel )
5936:    {[
5936:       | pAnd :
5938:          [ oTypeSNodeType
5940:             | nBooleanFlowType :
5941:             | nBooleanType :
5943:                @ValToFlow( falseLabel )
5950:             | * :
5957:                #eNotBoolean
5959:          ]
5959:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5960:          [ equal_label( overallFalseLabel, labelNull )
5970:             | true :
5971:                overallFalseLabel = oLabelNew
5976:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5990:                falseLabel = overallFalseLabel
5996:             | * :
6001:          ]
      
6001:          Label factorFalseLabel = labelNull
6007:          @BoolFactorAllowFlow( factorFalseLabel )
      
6014:          [ oTypeSNodeType
6016:             | nBooleanFlowType :
6017:             | nBooleanType :
6019:                @ValToFlow( factorFalseLabel )
6026:             | * : #eNotBoolean
6035:          ]
6035:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6049:       | * :
6054:          >
6056:    ]};
      
      
6059: BoolFactorAllowFlow( out Label falseLabel ):
6061:    [
6061:       | pNot :
6063:          Label factorFalseLabel = labelNull
      
6069:          @BoolFactorAllowFlow( factorFalseLabel )
6076:          [ oTypeSNodeType
6078:             | nBooleanFlowType :
                     % We have control flow, and are sitting at the point that has value false.
6079:                falseLabel = oLabelNew
6084:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6092:                .tLabel  oEmitLabel( factorFalseLabel )
      
6100:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6102:                .tNot
      
6104:             | * : #eNotBoolean
6113:          ]
      
6113:       | * :
6118:          @ArithExprAllowFlow( falseLabel )
6125:    ];
      
      
6126: ArithExprAllowFlow( out Label falseLabel ):
6128:    boolean first = true
6134:    int tempStrOffset
      
6134:    @TermAllowFlow( falseLabel )
6141:    {[
6141:       | '+' :
6143:          [ oTypeSNodeType
6145:             | nIntegerType, nByteType :
6146:                @PromoteToIntPop
6148:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6155:                [ oTypeSNodeType
6157:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6158:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6160:                      @PointerAddition
6162:                   | nDoubleType :
                           % int + double
                           % int type was already popped above; leave double on type stack
6164:                      .tSwap
6166:                      .tCastItoD
6168:                      .tAddD
6170:                   | * :
6179:                      @PromoteToInt
6181:                      .tAddI
6183:                ]
      
6183:             | nDoubleType :
6185:                @TermAllowFlow( falseLabel )
6192:                @PromoteToDoublePop
6194:                .tAddD
      
6196:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6198:                [ first
6201:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6202:                             tempStrOffset = @MoveIntoTempShortString
6208:                             first = false
6214:                   | * :
6219:                ]
6219:                @TermAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6226:                [ oTypeSNodeType
6228:                   | nShortStringType, nStrLitType :
6229:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6231:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6239:                      oTypeSPush( ShortStringType )
6245:                   | nCharType :
6247:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6249:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6257:                      oTypeSPush( ShortStringType )
6263:                   | * :
6272:                      #eTypeMismatch
6274:                      oTypeSPop
6275:                ]
      
6275:             | nPointerType, nUniversalPointerType :
6277:                @TermAllowFlow( falseLabel )   % actually not allowing CF
6284:                @PromoteToIntPop
6286:                @PointerAddition
      
6288:             | * :
6307:                #eNotAllowed
6309:          ]
      
6309:       | '-' :
6311:          [ oTypeSNodeType
6313:             | nIntegerType, nByteType :
6314:                @PromoteToIntPop
6316:                @TermAllowFlow( falseLabel )
      
6323:                [ oTypeSNodeType
6325:                   | nDoubleType :
                           % int - double
                           % int type was already popped above; leave double on type stack
6326:                      .tSwap
6328:                      .tCastItoD
6330:                      .tSwap
6332:                      .tSubD
6334:                   | * :
6339:                      @PromoteToInt
6341:                      .tSubI
6343:                ]
      
6343:             | nDoubleType :
6345:                @TermAllowFlow( falseLabel )
6352:                @PromoteToDoublePop
6354:                .tSubD
      
6356:             | nPointerType, nUniversalPointerType :
6358:                @TermAllowFlow( falseLabel )
6365:                [ oTypeSNodeType
6367:                   | nIntegerType, nByteType :
6368:                      @PromoteToIntPop
6370:                      @PointerSubInt
6372:                   | nPointerType, nUniversalPointerType :
6374:                      @MatchTypes
6376:                      @PointerSubPointer
6378:                   | * :
6389:                      #eNotAllowed
6391:                ]
      
6391:             | * :  #eNotAllowed
      
6406:          ]
6406:       | * :
6413:          >
6415:    ]};
      
      
6418: TermAllowFlow( out Label falseLabel ):
6420:    @FactorAllowFlow( falseLabel )
6427:    {[
6427:       | '*' :
6429:          [ oTypeSNodeType
6431:             | nIntegerType, nByteType :
6432:                @PromoteToIntPop
6434:                @FactorAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
      
6441:                [ oTypeSNodeType
6443:                   | nDoubleType :
                           % int * double
                           % int type was already popped above; leave double on type stack
6444:                      .tSwap
6446:                      .tCastItoD
6448:                      .tMultD
6450:                   | * :
6455:                      @PromoteToInt
6457:                      .tMultI
6459:                ]
      
6459:             | nDoubleType :
6461:                @FactorAllowFlow( falseLabel )
6468:                @PromoteToDoublePop
6470:                .tMultD
      
6472:             | * :
6481:                #eNotAllowed
6483:          ]
      
6483:       | '/' :
6485:          [ oTypeSNodeType
6487:             | nIntegerType, nByteType :
6488:                @PromoteToIntPop
6490:                @FactorAllowFlow( falseLabel )
6497:                [ oTypeSNodeType
6499:                   | nDoubleType :
                           % int / double
                           % int type was already popped above; leave double on type stack
6500:                      .tSwap
6502:                      .tCastItoD
6504:                      .tSwap
6506:                      .tDivD
6508:                   | * :
6513:                      @PromoteToInt
6515:                      .tDivI
6517:                ]
      
6517:             | nDoubleType :
6519:                @FactorAllowFlow( falseLabel )
6526:                @PromoteToDoublePop
6528:                .tDivD
      
6530:             | * :
6539:                #eNotAllowed
6541:          ]
      
6541:       | * :
6548:          >
6550:    ]};
      
      
6553: FactorAllowFlow( out Label falseLabel ):
6555:    [
6555:       | '+' :
6557:          @PrimaryAllowFlow( falseLabel )  % actually not allowing CF, will be caught by type check
6564:          [ oTypeSNodeType
6566:             | nIntegerType, nByteType :
6567:             | nDoubleType :
6569:             | * :
6578:                #eNotAllowed
6580:          ]
6580:       | '-' :
6582:          @PrimaryAllowFlow( falseLabel )
6589:          [ oTypeSNodeType
6591:             | nIntegerType, nByteType :
                     % It's probably fair to promote byte to int, since byte is unsigned
6592:                @PromoteToInt
6594:                .tNegI
6596:             | nDoubleType :
6598:                .tNegD
6600:             | * :
6609:                #eNotAllowed
6611:          ]
6611:       | * :
6618:          @PrimaryAllowFlow( falseLabel )
6625:    ];
      
      
6626: PrimaryAllowFlow( out Label falseLabel ):
6628:    [
6628:       | pIntLit :
6630:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6637:          oTypeSPush( IntegerType )
      
6643:       | pCharLit :
6645:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6652:          oTypeSPush( CharType )
      
6658:       | pDoubleLit :
6660:          .tPushConstD  oEmitDouble( TOKEN_VALUE_DOUBLE )
6667:          oTypeSPush( DoubleType )
      
6673:       | '(' :
6675:          @ExprAllowFlow( falseLabel )
6682:          ')'
      
6684:       | pStrLit :
6686:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6695:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6703:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6709:          @LValueIndexes
               % get final value of dereferencing, if any
6711:          @FetchVar
      
6713:       | pIdent :
6715:          Node decl = oScopeFindRequire
6720:          @ResolveUnitRef( decl )
6727:          Node theType
      
6727:          [ oNodeType( decl )
6734:             | nFunc :
6735:                @Call( decl )
      
6742:             | nBuiltInFunc :
6744:                @CallBuiltInFunc( decl )
      
6751:             | nConst, nEnumValue :
6753:                theType = oNodeGet( decl, qType )
6766:                oTypeSPush( theType )
6772:                [ oTypeSNodeType
6774:                   | nIntegerType, nEnumType, nBooleanType, nCharType, nByteType :
6775:                      .tPushConstI @EmitValue( decl )
6784:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
                           % Sign-extending I to P won't hurt since it's 0.
6786:                      .tPushConstI @EmitValue( decl )
6795:                   | * :
6812:                      #eNotImplemented
6814:                ]
      
6814:             | nConstDouble :
6816:                theType = oNodeGet( decl, qType )
6829:                oTypeSPush( theType )
6835:                [ oTypeSNodeType
6837:                   | nDoubleType :
6838:                      .tPushConstD  oEmitDouble( oNodeGetDouble( decl, qValueDouble ) )
6853:                   | * :
6858:                      #eNotImplemented
6860:                ]
                     
6860:             | nConstStr :
                     % This is a non-typed const defined as a strlit.
                     % So far, the value is held in the compiler's symbol table.
                     % Referencing the constant in the code will work the same as directly giving a strlit.
                     % (See pStrLit above).  We store the strlit in global memory, and set expr type to StrLitType.
      
                     % Storage in global memory only happens the first time the const is referenced.
                     % The global offset is stored in qValue.
6862:                int addr = oNodeGetInt( decl, qValue )
6875:                [ equal_zero( addr )
6882:                   | true :
6883:                      addr = oStringAllocShortStringLit( oNodeGetString( decl, qValueStr ) )
6900:                      oNodeSetInt( decl, qValue, addr )
6912:                   | * :
6917:                ]
6917:                .tPushAddrGlobal oEmitInt( addr )
6925:                oTypeSPush( StrLitType )
                     % This seems unlikely, but the strlit may be followed by
                     % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
                     % First, advance the pointer by index if any
6931:                @LValueIndexes
                     % get final value of dereferencing, if any
6933:                @FetchVar
      
6935:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6937:                @VarExpr( decl )
      
6944:             | nTypeDecl :
                     % A type name.
                     % This is normally a type cast.
                     % Or, if Expr is running within sizeof(), we do also allow type names as primaries.
6946:                oTypeSPush( oNodeGet( decl, qType ) )
6959:                [
6959:                   | '(' : 
                           % Type cast
6961:                      @Expr
6963:                      ')'
6965:                      @CastType
      
                           % The expression can be further modified after the typecast.
                           % This is taken from VarExpr.  Try to consolidate.
      
6967:                      [ oTypeSNodeType
6969:                         | nPointerType, nUniversalPointerType :
6970:                            [
6970:                               | '^' :             % dereferenced
6972:                                  oTypeSPop
6973:                                  oTypeSPush( oNodeGet( theType, qBaseType ) )
6986:                                  @LValueIndexes
6988:                                  @FetchVar
6990:                               | '[' :             % dereferencing pointer like an array [0..] of baseType
6992:                                  @PointerArraySubscript
                                       % modify addr for any subsequent subscripts, field references, etc
6994:                                  @LValueIndexes
6996:                                  @FetchVar
6998:                               | * :               % just ptr value alone
7005:                            ]
      
7005:                         | nArrayType, nRecordType, nShortStringType :
                                 % So far we would have the addr of the compound value.
                                 % Modify addr for subscripts, field references, etc
7007:                            @LValueIndexes
                                 % get final value, if no longer compound
7009:                            @FetchVar
      
7011:                         | *:
7024:                      ]
      
7024:                   | * :
                           % Not a type cast
                           % A raw typename is only allowed in expressions within sizeof
7029:                      [ flagExprAllowTypeName
7032:                         | true :
                                 % The value we produce is bogus.  The caller will discard all code.
                                 % Only the type stack matters.
7033:                            .tPushConstI  oEmitInt( 0 )
7041:                         | * :    #eTypeNameNotAllowedHere
7048:                      ]
7048:                ]
      
7048:             | * :
7073:                #eNotValue
7075:                oTypeSPush( IntegerType )
7081:          ]
      
7081:       | '@' :        % @var -- pointer to var
7083:          pIdent
      
7085:          Node decl = oScopeFindRequire
7090:          @ResolveUnitRef( decl )
7097:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passing into a var parameter.  So it's ok to take the address of a typed const.
7097:          @LValueFromDecl( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
7107:          theType = oTypeSTop
7112:          oTypeSPop
7113:          Node ptrType = @PointerTypeTo( theType )
7124:          oTypeSPush( ptrType )
      
7130:       | * :
7147:          #eNotValue
7149:          oTypeSPush( IntegerType )
7155:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
7156: VarExpr( Node decl ):
7158:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
7171:    int uplevels = @DeclUpLevels( decl )
      
7182:    oTypeSPush( theType )
7188:    [ oTypeSNodeType
7190:       | nIntegerType, nEnumType :
7191:          [ oNodeType( decl )
7198:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
7208:             | nLocalVar :
7210:                [ equal_zero( uplevels )
7217:                   | true :  .tPushLocalI  @EmitValue( decl )
7227:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
7247:                ]
7247:             | nParam :
7249:                [ oNodeGetBoolean( decl, qInOut )
7259:                   | true :    % VAR param points to the var.  Auto dereference.
7260:                      [ equal_zero( uplevels )
7267:                         | true :  .tPushParamP  @EmitValue( decl )
7277:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7297:                      ]
7297:                      .tFetchI
7299:                   | * :
7304:                      [ equal_zero( uplevels )
7311:                         | true :  .tPushParamI  @EmitValue( decl )
7321:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
7341:                      ]
7341:                ]
7341:          ]
      
7353:       | nBooleanType, nByteType, nCharType :
7355:          [ oNodeType( decl )
7362:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7372:             | nLocalVar :
7374:                [ equal_zero( uplevels )
7381:                   | true :  .tPushLocalB  @EmitValue( decl )
7391:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7411:                ]
7411:             | nParam :
7413:                [ oNodeGetBoolean( decl, qInOut )
7423:                   | true :    % VAR param points to the var.  Auto dereference.
7424:                      [ equal_zero( uplevels )
7431:                         | true :  .tPushParamP  @EmitValue( decl )
7441:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7461:                      ]
7461:                      .tFetchB
7463:                   | * :
7468:                      [ equal_zero( uplevels )
7475:                         | true :  .tPushParamB  @EmitValue( decl )
7485:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7505:                      ]
7505:                ]
7505:          ]
      
7517:       | nFileType :
7519:          #eNotImplemented
      
7521:       | nPointerType, nUniversalPointerType, nDoubleType :
               % Note we're using this code for reading double vars too.
               % P is the correct size, and no differences are needed at the moment.
7523:          [ oNodeType( decl )
7530:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7540:             | nLocalVar :
7542:                [ equal_zero( uplevels )
7549:                   | true :  .tPushLocalP  @EmitValue( decl )
7559:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7579:                ]
7579:             | nParam :
7581:                [ oNodeGetBoolean( decl, qInOut )
7591:                   | true :    % VAR param points to the var.  Auto dereference.
7592:                      [ equal_zero( uplevels )
7599:                         | true :  .tPushParamP  @EmitValue( decl )
7609:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7629:                      ]
7629:                      .tFetchP
7631:                   | * :
7636:                      [ equal_zero( uplevels )
7643:                         | true :  .tPushParamP  @EmitValue( decl )
7653:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7673:                      ]
7673:                ]               
7673:          ]
7685:          [
7685:             | '^' :             % dereferenced
7687:                oTypeSPop
7688:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7701:                @LValueIndexes
7703:                @FetchVar
7705:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7707:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7709:                @LValueIndexes
7711:                @FetchVar
7713:             | * :               % just ptr value alone
7720:          ]
      
7720:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7722:          [ oNodeType( decl )
7729:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7739:             | nLocalVar :
7741:                [ equal_zero( uplevels )
7748:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7758:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7778:                ]
7778:             | nParam :
7780:                [ oNodeGetBoolean( decl, qInOut )
7790:                   | true :    % VAR param points to the var.  Auto dereference.
7791:                      [ equal_zero( uplevels )
7798:                         | true :  .tPushParamP  @EmitValue( decl )
7808:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7828:                      ]
7828:                   | * :
7833:                      [ equal_zero( uplevels )
7840:                         | true :  .tPushAddrParam  @EmitValue( decl )
7850:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7870:                      ]
7870:                ]
7870:          ]
               % modify addr for subscripts, field references, etc
7882:          @LValueIndexes
               % get final value
7884:          @FetchVar
7886:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7915: FetchVar:
7917:    [ oTypeSNodeType
7919:       | nIntegerType, nEnumType :  .tFetchI
7922:       | nBooleanType, nByteType, nCharType :  .tFetchB
7926:       | nFileType :   #eNotImplemented
7930:       | nPointerType :             .tFetchP
7934:       | nUniversalPointerType :    #eCantDereference
7938:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7940:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7969: LValueIndexes:
7971:    {[
7971:       | '[' :
7973:          [ oTypeSNodeType
7975:             | nArrayType :    @ArraySubscripts
7978:             | nPointerType :  @PointerArraySubscript
7982:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7986:             | * :             #eNotArray
7999:          ]
7999:       | '.' :       @RecordFieldRef
8003:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
8007:       | * :         >
8018:    ]};
      
      
8021: ArraySubscripts:
8023:    [ oTypeSNodeType
8025:       | nArrayType :
8026:       | * :       #eNotArray
8033:    ]
8033:    {
8033:       [ oTypeSNodeType
8035:          | nArrayType :
8036:          | * :    #eTooManySubscripts
8043:       ]
      
            % low subscript of this dimension
8043:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
8060:       Node baseType
8060:       baseType = oNodeGet( oTypeSTop, qBaseType )
8072:       oTypeSPop
8073:       oTypeSPush( baseType )
      
8079:       @Expr
8081:       @RequireIntPop
            % adjust for low subscript
8083:       [ equal_zero( low )
8090:          | false :
8091:             .tPushConstI oEmitInt( low ) .tSubI
8101:          | * :
8106:       ]
      
            % multiply by element size
8106:       int size = oNodeGetInt( baseType, qSize )
8119:       [ equal( size, 1 )
8129:          | false :
8130:             .tPushConstI oEmitInt( size ) .tMultI
8140:          | * :
8145:       ]
      
            % update start address
8145:       .tAddPI
8147:       [
8147:          | ']' :  >
8151:          | ',' :
8153:       ]
8161:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
8164: PointerArraySubscript:
8166:    [ oTypeSNodeType
8168:       | nPointerType :
8169:       | * :    #eCantDereference
8176:    ]
         % replace type stack with base type
8176:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
8188:    oTypeSPop
8189:    oTypeSPush( baseType )
         
8195:    @Expr
8197:    @RequireIntPop
         % multiply by element size
8199:    int size = oNodeGetInt( baseType, qSize )
8212:    [ equal( size, 1 )
8222:       | false :
8223:          .tPushConstI  oEmitInt( size )  .tMultI
8233:       | * :
8238:    ]
         % update start address
8238:    .tAddPI
8240:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
8243: ShortStringArraySubscript:
8245:    [ oTypeSNodeType
8247:       | nStrLitType, nShortStringType :
8248:       | * :    #eCantDereference
8257:    ]
8257:    oTypeSPop
8258:    oTypeSPush( CharType )
8264:    @Expr
8266:    @RequireIntPop
8268:    .tAddPI
8270:    ']';
      
      
8273: RecordFieldRef:
8275:    [ oTypeSNodeType
8277:       | nRecordType :
8278:       | * :    #eNotRecord
8285:    ]
8285:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
8297:    pIdent
8299:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
8304:    [ oNodeType( field )
8311:       | nRecordField :
8312:       | * :   #eNotRecordField
8319:    ]
8319:    oScopeEnd
8320:    int offset = oNodeGetInt( field, qValue )
8333:    [ equal_zero( offset )
8340:       | false :
8341:          .tPushConstI oEmitInt( offset ) .tAddPI
8351:       | * :
8356:    ]
      
         % replace the type on the type stack, with the field type
8356:    oTypeSPop
8357:    oTypeSPush( oNodeGet( field, qType ) )
8371:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8371: PointerAddition:
8373:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8385:    int elementSize = oNodeGetInt( elementType, qSize )
8398:    [ equal( elementSize, 1 )
8408:       | false :
8409:          .tPushConstI  oEmitInt( elementSize )
8417:          .tMultI
8419:       | * :
8424:    ]
8424:    .tAddPI
8427:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8427: PointerSubInt:
8429:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8441:    int elementSize = oNodeGetInt( elementType, qSize )
8454:    [ equal( elementSize, 1 )
8464:       | false :
8465:          .tPushConstI  oEmitInt( elementSize )
8473:          .tMultI
8475:       | * :
8480:    ]
8480:    .tSubPI
8483:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8483: PointerSubPointer:
8485:    .tSubP
8487:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8499:    int elementSize = oNodeGetInt( elementType, qSize )
8512:    [ equal( elementSize, 1 )
8522:       | false :
8523:          .tPushConstI  oEmitInt( elementSize )
8531:          .tDivI
8533:       | * :
8538:    ]
8538:    oTypeSPop
8539:    oTypeSPush( IntegerType )
8546:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8546: PointerDeref:
8548:    [ oTypeSNodeType
8550:       | nPointerType :
8551:       | nUniversalPointerType :   #eCantDereference
8555:       | * :       #eNotPointer
8564:    ]
8564:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8566:    Node theType = oTypeSTop
8571:    oTypeSPop
8572:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8586:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8586: CoerceType:
8588:    node_type nt = oTypeSNodeType
8593:    Node given = oTypeSTop
8598:    oTypeSPop
8599:    [ equal_node_type( nt, oTypeSNodeType )
8608:       | false :
               % Can we implicitly convert the value to the desired type?
8609:          [ oTypeSNodeType
8611:             | nIntegerType :
8612:                [ nt
8615:                   | nByteType :   .tCastBtoI  >>
8619:                   | * :
8624:                ]
8624:             | nByteType :
8626:                [ nt
8629:                   | nIntegerType :   .tCastItoB  >>
8633:                   | * :
8638:                ]
8638:             | nPointerType :
8640:                [ nt
8643:                   | nUniversalPointerType :  >>
8645:                   | nStrLitType :
8647:                      [ equal_node( oTypeSTop, PCharType )
8656:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8657:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8668:                         | * :
8673:                      ]
8673:                   | * :
8680:                ]
8680:             | nUniversalPointerType :
8682:                [ nt
8685:                   | nPointerType :  >>
8687:                   | * :
8692:                ]
8692:             | nShortStringType :
8694:                [ nt
8697:                   | nStrLitType :  >>
8699:                   | nCharType :
                           % Store char as a temp ShortString.
8701:                      oTypeSPush( CharType )
8707:                      int tempOffset = @MoveIntoTempShortString
8713:                      oTypeSPop
8714:                      >>
8715:                   | * :
8722:                ]
8722:             | * :
8735:          ]
8735:          #eTypeMismatch
8737:       | * :
8742:    ];
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to cast the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      %
      % This is stronger than CoerceType, since it isn't limited to implicit conversions.
      % There are still going to be limits on what is allowed though.
      %
8743: CastType:
8745:    node_type nt = oTypeSNodeType
8750:    oTypeSPop
8751:    [ equal_node_type( nt, oTypeSNodeType )
8760:       | false :
               % Can we cast the value to the desired type?
8761:          [ oTypeSNodeType
8763:             | nIntegerType, nEnumType :
8764:                [ nt
8767:                   | nByteType, nCharType, nBooleanType :   .tCastBtoI  >>
8771:                   | nIntegerType, nEnumType :   >>
8774:                   | * :
8787:                ]
8787:             | nByteType, nCharType, nBooleanType :
8789:                [ nt
8792:                   | nByteType, nCharType, nBooleanType :   >>
8794:                   | nIntegerType, nEnumType :   .tCastItoB  >>
8799:                   | * :
8812:                ]
8812:             | nPointerType :
8814:                [ nt
8817:                   | nUniversalPointerType :  >>
8819:                   | nStrLitType :
8821:                      [ equal_node( oTypeSTop, PCharType )
8830:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8831:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8842:                         | * :
8847:                      ]
8847:                   | * :
8854:                ]
8854:             | nUniversalPointerType :
8856:                [ nt
8859:                   | nPointerType :  >>
8861:                   | * :
8866:                ]
8866:             | nShortStringType :
8868:                [ nt
8871:                   | nStrLitType :  >>
8873:                   | nCharType :
                           % Store char as a temp ShortString.
8875:                      oTypeSPush( CharType )
8881:                      int tempOffset = @MoveIntoTempShortString
8887:                      oTypeSPop
8888:                      >>
8889:                   | * :
8896:                ]
8896:             | * :
8915:          ]
8915:          #eTypeMismatch
8917:       | * :
8922:    ];
      
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
8923: MatchTypes:
8925:    node_type nt = oTypeSNodeType
8930:    oTypeSPop
8931:    [ equal_node_type( nt, oTypeSNodeType )
8940:       | false :
               % Some implicit conversion is allowed even here
8941:          [ oTypeSNodeType
8943:             | nPointerType :
8944:                [ nt
8947:                   | nUniversalPointerType :  >>
8949:                   | * :
8954:                ]
8954:             | nUniversalPointerType :
8956:                [ nt
8959:                   | nPointerType :  >>
8961:                   | * :
8966:                ]
8966:             | * :
8973:          ]
8973:          #eTypeMismatch
8975:       | * :
8980:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
8981: RequireIntPop:
8983:    [ oTypeSNodeType
8985:       | nIntegerType :
8986:       | * :          #eNotInteger
8993:    ]
8993:    oTypeSPop;
      
8995: RequireInt:
8997:    [ oTypeSNodeType
8999:       | nIntegerType :
9000:       | * :          #eNotInteger
9007:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9008: PromoteToIntPop:
9010:    [ oTypeSNodeType
9012:       | nIntegerType :
9013:       | nByteType :        .tCastBtoI
9017:       | * :                #eNotInteger
9026:    ]
9026:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9028: PromoteToInt:
9030:    [ oTypeSNodeType
9032:       | nIntegerType :
9033:       | nByteType :        .tCastBtoI
9037:                            oTypeSPop
9038:                            oTypeSPush( IntegerType )
9044:       | * :                #eNotInteger
9053:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9054: PromoteToIntOptional:
9056:    [ oTypeSNodeType
9058:       | nByteType :        .tCastBtoI
9061:                            oTypeSPop
9062:                            oTypeSPush( IntegerType )
9068:       | * :
9073:    ];
      
      % Convert the top value to double (if it isn't already).
      % It must be implicitly convertable to double.
      % Pop the type stack.
      %
9074: PromoteToDoublePop:
9076:    [ oTypeSNodeType
9078:       | nDoubleType :
9079:       | nIntegerType :     .tCastItoD
9083:                            oTypeSPop
9084:                            oTypeSPush( DoubleType )
9090:       | nByteType :        .tCastBtoI
9094:                            .tCastItoD
9096:                            oTypeSPop
9097:                            oTypeSPush( DoubleType )
9103:       | * :                #eNotDouble
9114:    ]
9114:    oTypeSPop;
      
      
9116: RequireBoolPop:
9118:    [ oTypeSNodeType
9120:       | nBooleanType :
9121:       | * :          #eNotBoolean
9128:    ]
9128:    oTypeSPop;
      
9130: RequireBool:
9132:    [ oTypeSNodeType
9134:       | nBooleanType :
9135:       | * :          #eNotBoolean
9142:    ];
      
      
9143: include 'pascal_stmt.ssl'
      %
      % Pascal Compiler
      %
      
      
      % ------------------------------ Statements -----------------------------
      
9143: Statement:
9145:    [
9145:       | pWriteln :     @WritelnStmt
9149:       | pWrite :       @WriteStmt
9153:       | pReadln :      @ReadlnStmt
9157:       | pRead :        @ReadStmt
9161:       | pIf :          @IfStmt
9165:       | pWhile :       @WhileStmt
9169:       | pFor :         @ForStmt
9173:       | pRepeat :      @RepeatStmt
9177:       | pBreak :       @BreakStmt
9181:       | pContinue :    @ContinueStmt
9185:       | pBegin :       @BeginStmt
9189:       | pIdent :       @LabelOrAssignOrCallStmt
9193:       | pCase :        @CaseStmt
9197:       | pGoto :        @GotoStmt
9201:       | pIntLit :      % should be an integer label
9203:                        oChangeIntLitToLabelIdent
9204:                        @LabelOrAssignOrCallStmt
9206:       | * :            % null statement : don't accept any tokens
9239:    ];
      
      
9240: LabelOrAssignOrCallStmt:
9242:    Node decl = oScopeFindRequire
9247:    @ResolveUnitRef( decl )
9254:    [ oNodeType( decl )
9261:       | nLabel :                          @LabelDefinition( decl )
9269:                                           @Statement
9271:       | nProc :                           @Call( decl )
9280:       | nGlobalVar, nLocalVar, nParam, nTypeDecl :
9282:                                           @AssignStmt( decl )
9289:       | nFunc :                           @AssignResultStmt( decl )
9298:       | * :                               #eBadStatement
9317:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9318: LabelDefinition( Node decl ):
9320:    [ oNodeGetBoolean( decl, qDefined )
9330:       | true :  #eAlreadyDefined
9333:       | * :
9338:    ]
9338:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9353:    oNodeSetBoolean( decl, qDefined, true )
9365:    ':'
9368:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9368: AssignStmt( Node decl ):
9370:    @LValueFromDecl( decl, true )
9380:    ':=' 
9382:    @Expr
9384:    @CoerceType
9386:    @Assign
9389:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9389: Assign:
9391:    [ oTypeSNodeType
9393:       | nIntegerType, nEnumType :  .tAssignI
9396:       | nBooleanType, nByteType, nCharType :  .tAssignB
9400:       | nDoubleType :  .tAssignD
9404:       | nFileType :   #eNotImplemented
9408:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9412:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9414:           int size = oNodeGetInt( oTypeSTop, qSize )
9426:           .tCopy  oEmitInt( size )    % multi-word copy
9434:    ]
9462:    oTypeSPop
9464:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9464: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9466:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9482:       | false :   #eNotCurrentFunction
9485:       | * :
9490:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9490:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9505:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9518:    ':='
9520:    @Expr
9522:    @CoerceType
9524:    [ oTypeSNodeType
9526:       | nIntegerType, nEnumType : .tAssignI
9529:       | nBooleanType, nByteType, nCharType :  .tAssignB
9533:       | nDoubleType :  .tAssignD
9537:       | nFileType :   #eNotImplemented
9541:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9545:       | nArrayType, nRecordType, nShortStringType :
9547:           int size = oNodeGetInt( oTypeSTop, qSize )
9559:           .tCopy  oEmitInt( size )    % multi-word copy
9567:    ]
9595:    oTypeSPop
9597:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9597: LValueExpr( boolean writeable ):
         % Al lvalue expressions start with a variable name,
         % or a type name (for an lvalue typecast).
9599:    pIdent
9601:    Node decl = oScopeFindRequire
9606:    @ResolveUnitRef( decl )
9613:    @LValueFromDecl( decl, writeable )
9624:    ;
      
      
      % Parse an lvalue expression, starting with the decl of the just accepted identifier.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9624: LValueFromDecl( Node decl, boolean writeable ):
9626:    [ oNodeType( decl )
9633:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9634:          @LValueVar( decl, writeable )
      
9644:       | nTypeDecl :
               % lvalue typecast
               % This is only allowed if the provided lvalue we're casting from has the same size.
               % No conversion code occurs, it's just a different interpretation of the same bits.
9646:          oTypeSPush( oNodeGet( decl, qType ) )
9659:          '('
9661:          @LValueExpr( writeable )
9668:          ')'
9670:          @LValueCastType
               % There can be further modifications of the lvalue after the cast.
               % This is taken from LValueVar.  Try to consolidate.
9672:          [ oTypeSNodeType
9674:             | nPointerType :
9675:                [
9675:                   | '[' :
                           % dereference the pointer var first
9677:                      .tFetchP
9679:                      @PointerArraySubscript
9681:                   | * :
9686:                ]
9686:             | * :
9691:          ]
               % additional subscripts, if any
9691:          @LValueIndexes
       
9693:       | * :  #eNotVar
9708:    ]
9709:    ;
      
      
      % An lvalue is on the expression stack.
      % The type of the lvalue is on the type stack.
      % The desired type is under it on the type stack.
      % Perform an lvalue cast to the desired type, leaving just that type.
      %
      % An lvalue cast is allowed only if the data size is the same.
      % No conversion code occurs, it's just a different interpretation of the same bits.
      %
9709: LValueCastType:
9711:    node_type nt = oTypeSNodeType
9716:    oTypeSPop
9717:    [ equal_node_type( nt, oTypeSNodeType )
9726:       | false :
               % Can we cast the value to the desired type?
9727:          [ oTypeSNodeType
9729:             | nIntegerType, nEnumType :
9730:                [ nt
9733:                   | nByteType, nCharType, nBooleanType :  #eSizeMismatch  >>
9737:                   | nIntegerType, nEnumType :   >>
9740:                   | * :
9753:                ]
9753:             | nByteType, nCharType, nBooleanType :
9755:                [ nt
9758:                   | nByteType, nCharType, nBooleanType :   >>
9760:                   | nIntegerType, nEnumType :  #eSizeMismatch  >>
9765:                   | * :
9778:                ]
9778:             | nPointerType :
9780:                [ nt
9783:                   | nUniversalPointerType :  >>
9785:                   | * :
9790:                ]
9790:             | nUniversalPointerType :
9792:                [ nt
9795:                   | nPointerType :  >>
9797:                   | * :
9802:                ]
9802:             | nShortStringType :
9804:                [ nt
9807:                   | nStrLitType :  >>
9809:                   | * :
9814:                ]
9814:             | * :
9833:          ]
9833:          #eTypeMismatch
9835:       | * :
9840:    ];
      
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9841: LValueVar( Node decl, boolean writeable ):
9843:    [ oNodeType( decl )
9850:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9860:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9871:       | nParam :
9873:          [ oNodeGetBoolean( decl, qInOut )
9883:             | true :   % VAR param points to variable.  No dereference.
9884:                        .tPushParamP @EmitValue( decl )
9893:             | * :      .tPushAddrParam @EmitValue( decl )
9907:          ]
9907:       | nTypedConst :
9909:          [ writeable
9912:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
9922:             | * :      #eNotVar
9929:          ]
9929:       | * :            #eNotVar
9942:    ]
      
9942:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
9955:    [ oTypeSNodeType
9957:       | nPointerType :
9958:          [
9958:             | '[' :
                     % dereference the pointer var first
9960:                .tFetchP
9962:                @PointerArraySubscript
9964:             | * :
9969:          ]
9969:       | * :
9974:    ]
         % additional subscripts, if any
9974:    @LValueIndexes
9977:    ;
      
      
9977: IncVar( Node decl ):
9979:    @LValueVar( decl, true )
9989:    @RequireIntPop
9991:    @VarExpr( decl )
9998:    oTypeSPop
9999:    .tIncI
10001:    .tAssignI;
      
10004: DecVar( Node decl ):
10006:    @LValueVar( decl, true )
10016:    @RequireIntPop
10018:    @VarExpr( decl )
10025:    oTypeSPop
10026:    .tDecI
10028:    .tAssignI;
      
      
10031: IfStmt:
10033:    Label falseLabel = labelNull
      
10039:    @BooleanExprControlFlow( falseLabel )
10046:    pThen
10048:    @Statement
10050:    [
10050:       | pElse :
10052:          Label doneLabel = oLabelNew
      
10057:          .tJump  oEmitLabel( doneLabel )
10065:          .tLabel oEmitLabel( falseLabel )
10073:          @Statement
10075:          .tLabel oEmitLabel( doneLabel )
      
10083:       | * :
10088:          .tLabel oEmitLabel( falseLabel )
10096:    ];
      
      
10097: ForStmt:
10099:    pIdent
      
10101:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10106:    @LValueVar( decl, true )
10116:    @RequireIntPop
      
10118:    ':='
      
10120:    @Expr
10122:    @RequireIntPop
10124:    .tAssignI
      
10126:    Label breakLabel = oLabelNew
      
10131:    Label checkLabel = oLabelNew
10136:    .tJump  oEmitLabel( checkLabel )
      
10144:    Label continueLabel = oLabelNew
10149:    .tLabel  oEmitLabel( continueLabel )
10157:    [
10157:       | pTo :
10159:          @IncVar( decl )
10166:          .tLabel  oEmitLabel( checkLabel )
10174:          @VarExpr( decl )  oTypeSPop
10182:          @Expr
10184:          @RequireIntPop
10186:          .tGreaterI
10188:          .tJumpTrue  oEmitLabel( breakLabel )
10196:       | pDownto :
10198:          @DecVar( decl )
10205:          .tLabel  oEmitLabel( checkLabel )
10213:          @VarExpr( decl )  oTypeSPop
10221:          @Expr
10223:          @RequireIntPop
10225:          .tLessI
10227:          .tJumpTrue  oEmitLabel( breakLabel )
10235:    ]
10243:    oLoopPush( continueLabel, breakLabel )
10252:    pDo
10254:    @Statement
10256:    .tJump  oEmitLabel( continueLabel )
10264:    .tLabel  oEmitLabel( breakLabel )
10272:    oLoopPop;
      
      
10274: RepeatStmt:
10276:    Label continueLabel = oLabelNew
10281:    .tLabel  oEmitLabel( continueLabel )
      
10289:    Label breakLabel = oLabelNew
      
10294:    oLoopPush( continueLabel, breakLabel )
10303:    @Statement
10305:    {[
10305:       | ';' :
10307:          @Statement
10309:       | pUntil :
10311:          Label falseLabel
10311:          @BooleanExprControlFlow( falseLabel )
10318:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10332:          >
10334:    ]}
10344:    .tLabel  oEmitLabel( breakLabel )
10352:    oLoopPop;
      
      
10354: WhileStmt:
10356:    Label continueLabel = oLabelNew
10361:    .tLabel  oEmitLabel( continueLabel )
      
10369:    Label breakLabel
10369:    @BooleanExprControlFlow( breakLabel )
      
10376:    oLoopPush( continueLabel, breakLabel )
10385:    pDo
10387:    @Statement
10389:    .tJump  oEmitLabel( continueLabel )
10397:    .tLabel  oEmitLabel( breakLabel )
10405:    oLoopPop;
      
      
10407: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10409:    [ equal_label( oLoopContinueLabel, labelNull )
10418:       | true :
10419:          #eNotInALoop
10421:       | false :
10423:          .tJump  oEmitLabel( oLoopContinueLabel )
10430:    ];
      
      
10439: BreakStmt:
10441:    [ equal_label( oLoopBreakLabel, labelNull )
10450:       | true :
10451:          #eNotInALoop
10453:       | false :
10455:          .tJump  oEmitLabel( oLoopBreakLabel )
10462:    ];
      
      
10471: CaseStmt:
10473:    Code tableCode = oCodeNew
10478:    Label tableLabel = oLabelNew
10483:    Label doneLabel = oLabelNew
10488:    Label otherwiseLabel = doneLabel
10494:    boolean isString = false
      
10500:    @Expr
         % Leave the expr type on the type stack throughout case statement
10502:    [ oTypeSNodeType
10504:       | nBooleanType, nByteType, nCharType :   .tJumpCaseB  oEmitLabel( tableLabel )
10513:       | nIntegerType, nEnumType :              .tJumpCaseI  oEmitLabel( tableLabel )
10523:       | nShortStringType, nStrLitType :        isString = true
10531:                                                .tJumpCaseS  oEmitLabel( tableLabel )
10539:       | * :     #eNotAllowed
10558:    ]
10558:    pOf
      
10560:    {
10560:       [
10560:          | pOtherwise, pElse :
10562:             otherwiseLabel = oLabelNew
10567:             .tLabel  oEmitLabel( otherwiseLabel )
      
                  % A bit tricky:
                  % The otherwise clause allows multiple statements (unlike other cases).
                  % ';' might be separating statements in the otherwise clause,
                  % or might be an optional trailing ; after the last statement.
                  % I have to watch for End to know when the statements stop.
                  % (Note, the otherwise clause is the last part of the case statement.)
10575:             {[
10575:                | pEnd :  >
10579:                | * :
10584:                   @Statement
10586:                   [
10586:                      | ';' :
10588:                      | * :   pEnd  >
10597:                   ]
10597:             ]}
10599:             >
      
10601:          | pEnd :
                  % Reached end with no otherwise clause
10603:             >
      
10605:          | * :
10614:             Label caseLabel = oLabelNew
10619:             oCodePush( tableCode )
10625:             {
10625:                @ConstExpr
10627:                @ConstCoerceType
10629:                int val
10629:                [ isString
10632:                   | true :    val = oStringAllocShortStringLit( oValueTopString )
10642:                   | false :   val = oValueTop
10649:                ]
10657:                oValuePop
10658:                [
10658:                   | '..' :  @ConstExpr
10662:                             @ConstCoerceType
10664:                             int highval
10664:                             [ isString
10667:                                | true :   highval = oStringAllocShortStringLit( oValueTopString )
10677:                                | false :  highval = oValueTop
10684:                             ]
10692:                             oValuePop
10693:                             .tCaseRange  oEmitInt( val )  oEmitInt( highval )  oEmitLabel( caseLabel )
10713:                   | * :     .tCase  oEmitInt( val )  oEmitLabel( caseLabel )
10732:                ]
10732:                [
10732:                   | ',' :
10734:                   | * :  >
10741:                ]
10741:             }
10743:             oCodePop
10744:             ':'
10746:             .tLabel  oEmitLabel( caseLabel )
10754:             @Statement
10756:             .tJump  oEmitLabel( doneLabel )
                  % Swallow optional trailing ';'
10764:             [
10764:                | ';' :
10766:                | * :
10771:             ]
                  
10771:       ]
         
10771:    }
      
10773:    .tLabel  oEmitLabel( tableLabel )
10781:    oEmitCode( tableCode )
10787:    .tCaseEnd  oEmitLabel( otherwiseLabel )
10795:    .tLabel  oEmitLabel( doneLabel )
10803:    oTypeSPop
10805:    ;
      
      
10805: GotoStmt:
10807:    [
10807:       | pIdent :
10809:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10811:          oChangeIntLitToLabelIdent
10812:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10820:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10829:    oNodeSetBoolean( decl, qUsed, true )
10841:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10857:    ;
      
      
10857: BeginStmt:
10859:    @Statement
10861:    {[
10861:       | ';' :   @Statement
10865:       | pEnd :  >
10869:    ]};
      
      
10880: WritelnStmt:
10882:    @WriteStmt
10884:    .tWriteCR;
      
      
10887: WriteStmt:
10889:    [
10889:       | '(' :
10891:          {
10891:             @Expr
10893:             [ oTypeSNodeType
10895:                | nIntegerType :             .tWriteI
10898:                | nBooleanType :             .tWriteBool
10902:                | nByteType :                .tCastBtoI  .tWriteI
10908:                | nCharType :                .tWriteChar
10912:                | nDoubleType :              .tWriteD
10916:                | nShortStringType, nStrLitType :   .tWriteShortStr
10920:                | nFileType :                #eNotImplemented
10924:                | nEnumType :
                        % write name via table lookup
10926:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10940:                   .tWriteEnum
10942:                | nPointerType :
10944:                   [ equal_node( oTypeSTop, PCharType )
10953:                      | true :               .tWritePChar
10956:                      | * :                  .tWriteP
10963:                   ]
10963:                | nUniversalPointerType :    .tWriteP
10967:                | * :                        #eNotAllowed
10994:             ]
10994:             oTypeSPop
10995:             [
10995:                | ')' : >
10999:                | ',' :
11001:             ]
11009:          }
11011:       | * :
11016:    ];
      
      
11017: ReadlnStmt:
11019:    @ReadStmt
11021:    .tReadCR;
      
      
11024: ReadStmt:
11026:    [
11026:       | '(' :
11028:          {
11028:             @LValueExpr( true )
11035:             [ oTypeSNodeType
11037:                | nIntegerType :      .tReadI
11040:                | nCharType :         .tReadChar
11044:                | nShortStringType :  
11046:                    int capacity = subtract( oNodeGetInt( oTypeSTop, qSize ), 1 )
11065:                    .tReadShortStr  oEmitInt( capacity )
11073:                | * :                 #eNotAllowed
11084:             ]
11084:             oTypeSPop
11085:             [
11085:                | ')' : >
11089:                | ',' :
11091:             ]
11099:          }
11101:       | * :
11106:    ];
11107: include 'pascal_str.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ String Operations -----------------------------
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
11107: MoveIntoTempShortString >> int:
11109:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
11119:    [ oTypeSNodeType
11121:       | nShortStringType, nStrLitType :
11122:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
11130:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
11132:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
11147:       | nCharType :
               % temp[0] = 1
11149:          .tPushAddrLocal  oEmitInt( tempOffset )
11157:          .tPushConstI  oEmitInt( 1 )
11165:          .tAssignB
               % temp[1] = value
11167:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
11182:          .tSwap
11184:          .tAssignB
11186:       | * :   #eTypeMismatch
11197:    ]
11197:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
11198:    .tPushAddrLocal  oEmitInt( tempOffset )
11206:    oTypeSPush( ShortStringType )
11212:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11216: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
11218:    .tAllocActuals  oEmitInt( 16 )
11226:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11238:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11250:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
11259:    .tFreeActuals  oEmitInt( 16 )
11267:    oTypeSPop
11268:    oTypeSPop
11270:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
11270: ShortStringAppendChar:
         % Note at the moment I don't align params
11272:    .tAllocActuals  oEmitInt( 12 )
11280:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignB
11292:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11304:    .tCall  @EmitValue( System_ShortStringAppendChar )
11313:    .tFreeActuals  oEmitInt( 12 )
11321:    oTypeSPop
11322:    oTypeSPop
11324:    ;
      
      % Expr stack has ShortString A, and ShortString B above it.
      % Type stack has just the type of ShortString A.
      % Replaces the expr stack with the integer value of string comparison:
      % -1 if A < B,  0 if A = B,  1 if A > B
      % Leaves Integer on the type stack.
      %
      % TO DO: kind of annoying that we need to hardcode the fact that the called method is cdecl extern.
      %   It would be nicer if that was noted only in the label.
      %   Alternatively, use a utility method in SSL to generate the appropriate call,
      %   given the method decl.
      %
11324: ShortStringCmp:
11326:    .tAllocActualsCdecl  oEmitInt( 24 )
11334:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
11346:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
11358:    int tempOffset = oScopeAllocType( IntegerType )
11368:    .tPushAddrActual  oEmitInt( 16 )  .tPushAddrLocal  oEmitInt( tempOffset )  .tAssignP
11386:    .tCallCdecl  @EmitValue( System_ShortStringCmp )
11395:    .tPushLocalI  oEmitInt( tempOffset )
11403:    .tFreeActuals  oEmitInt( 24 )
11411:    oTypeSPop
11412:    oTypeSPush( IntegerType )
11419:    ;
11419: include 'pascal_call.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Method Calls -----------------------------
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
11419: Call( Node method ):
11421:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
11433:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
11446:    Node resultType
11446:    int tempOffset
      
11446:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
11463:    [ isFunc
11466:       | true :
11467:          resultType = oNodeGet( method, qType )
11480:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
11490:       | * :
11495:    ]
         
      
11495:    Node paramScope = oNodeGet( method, qParams )
11508:    int actualsSize = oNodeGetInt( paramScope, qSize )
11521:    [ cdecl
11524:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
11533:       | false :  .tAllocActuals  oEmitInt( actualsSize )
11543:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
11551:    [ greater( @DeclLevel( method ), 0 )
11566:       | true :
11567:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
11575:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
11594:          .tAssignP
11596:       | * :
11601:    ]
      
      
11601:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
11614:    Node param = oNodeIterValue( paramIter )
11624:    [
11624:       | '(' :
            
11626:          {
11626:             [ oNodeNull( param )
11633:                | true : >
11636:                | * :
11641:             ]
      
11641:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
11654:             .tPushAddrActual oEmitInt( offset )
11662:             oTypeSPush( oNodeGet( param, qType ) )
      
11675:             [ oNodeGetBoolean( param, qInOut )
11685:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
11686:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
11693:                           @MatchTypes
      
11695:                           .tAssignP
      
11697:                | false :  @Expr
11701:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
11703:                           [ oTypeSNodeType
11705:                              | nIntegerType, nEnumType : .tAssignI
11708:                              | nBooleanType, nByteType, nCharType :  .tAssignB
11712:                              | nDoubleType :  .tAssignD
11716:                              | nFileType :   #eNotImplemented
11720:                              | nPointerType, nUniversalPointerType :  .tAssignP
11724:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
11726:                                  int size = oNodeGetInt( oTypeSTop, qSize )
11738:                                  .tCopy  oEmitInt( size )    % multi-word copy
11746:                           ]
11774:             ]
11782:             oTypeSPop
      
11783:             oNodeIterNext( paramIter )
11789:             param = oNodeIterValue( paramIter )
11799:             [ oNodeNull( param )
11806:                | true :  >
11809:                | false :
11811:             ]
      
11819:             ','
11821:          }
      
11823:          ')'
      
11825:       | * :
11830:    ]
      
11830:    [ oNodeNull( param )
11837:       | false :    #eMissingParameter
11840:       | * :
11845:    ]
      
11845:    [ isFunc
11848:       | true :
               % Pass result temp as an additional VAR parameter.
11849:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
11864:          .tPushAddrLocal  oEmitInt( tempOffset )
11872:          .tAssignP
11874:       | * :
11879:    ]
      
11879:    [ cdecl
11882:       | true :
11883:          .tCallCdecl  @EmitValue( method )
11892:       | false :
11894:          .tCall   @EmitValue( method )
11903:    ]
      
11911:    [ isFunc
11914:       | true :
               % push return value from temp
11915:          oTypeSPush( resultType )
      
11921:          [ oTypeSNodeType
11923:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
11932:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
11942:             | nFileType :  #eNotImplemented
11946:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
11956:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
11958:                                .tPushAddrLocal  oEmitInt( tempOffset )
11966:          ]
11992:       | * :
11997:    ]
         
11997:    .tFreeActuals  oEmitInt( actualsSize )
12006:    ;
      
      
      
      % Called on first use of an extern method
      %
12006: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
12008:    int strAddr
12008:    String externalName = oNodeGetString( method, qExternalName )
12021:    [ equal_string( externalName, stringNull )
12031:       | true :
12032:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
12053:       | false :
12055:          strAddr = oStringAllocLit( externalName )
12065:    ]
12073:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
12089:    ;
      
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
12089: CallBuiltInFunc( Node method ):
      
         % Ord(x)
12091:    [ oNodeEqual( method, BuiltIn_Ord )
12101:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
12102:          '('
12104:          @Expr
12106:          [ oTypeSNodeType
12108:             | nIntegerType, nEnumType :
12109:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
12113:             | * :  #eTypeMismatch
12128:          ]
12128:          oTypeSPop
12129:          oTypeSPush( IntegerType )
12135:          ')'
12137:          >>
12138:       | * :
12143:    ]
      
         % Chr(x)
12143:    [ oNodeEqual( method, BuiltIn_Chr )
12153:       | true :
               % parameter is integer
               % result is char
12154:          '('
12156:          @Expr
12158:          [ oTypeSNodeType
12160:             | nIntegerType :    .tCastItoB
12163:             | nByteType :
12165:             | * :  #eTypeMismatch
12174:          ]
12174:          oTypeSPop
12175:          oTypeSPush( CharType )
12181:          ')'
12183:          >>
12184:       | * :
12189:    ]
      
         % Pred(x)
12189:    [ oNodeEqual( method, BuiltIn_Pred )
12199:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12200:          '('
12202:          @Expr
12204:          [ oTypeSNodeType
12206:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12207:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12216:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12219:                   | * :
12224:                ]
12224:             | * :  #eTypeMismatch
12231:          ]
12231:          .tDecI
12233:          ')'
12235:          >>
12236:       | * :
12241:    ]
      
         % Succ(x)
12241:    [ oNodeEqual( method, BuiltIn_Succ )
12251:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
12252:          '('
12254:          @Expr
12256:          [ oTypeSNodeType
12258:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
12259:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
12268:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
12271:                   | * :
12276:                ]
12276:             | * :  #eTypeMismatch
12283:          ]
12283:          .tIncI
12285:          ')'
12287:          >>
12288:       | * :
12293:    ]
      
         % Sizeof(x)
12293:    [ oNodeEqual( method, BuiltIn_Sizeof )
12303:       | true :
               % parameter is a type name (cannot be a general type description),
               % or an expression (which is not evaluated).
               %
               % My initial thought was to look at the first token to see if it's a type name,
               % and if not, unaccept it and run @Expr  (with the code stream set to a dummy stream).
               % But that's not completely sufficient.
               % First, the typename might be   unit.name  so unaccepting one token wouldn't be good enough.
               % Also, an expression can start with a typename e.g.  integer(1+2) * 3
               %
               % So, instead of looking for a type name at this level, and going to Expr if not,
               % I'll just go into Expr.  But I'll turn on an option to accept type names in Primary.
               % Since we're discarding the code anyway, I'll have that primary push a bogus value
               % on the expr stack.  The main thing is just to get the type right.
               
12304:          '('
               % Parse expression but don't evaluate its code (so no side effects occur).
               % I'll accomplish that by sending the code to a temp stream that I discard.
12306:          Code dummyCode = oCodeNew
12311:          oCodePush( dummyCode )
12317:          @ExprAllowTypeName
12319:          oCodePop
12320:          oCodeDiscard( dummyCode )
12326:          Node theType = oTypeSTop
12331:          oTypeSPop
12332:          .tPushConstI  oEmitInt( oNodeGetInt( theType, qSize ) )
12347:          oTypeSPush( IntegerType )
12353:          ')'
12355:          >>
      
12356:       | * :
12361:    ]
      
12361:    #eNotImplemented
12364:    ;
      
12364: include 'pascal_type.ssl'
      %
      % Pascal Compiler
      %
      
      % ------------------------------ Types -----------------------------
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
12364: newType( node_type nt, int size ) >> Node:
12366:   Node node = oNodeNew( nt )
12376:   oNodeSetInt( node, qSize, size )
12388:   oTypeAdd( node )
12394:   >> node
12398:   ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
12398: TypeRef( out Node resultType ):
12400:    [
12400:       | pIdent :           % previously named type (including intrinsics)
12402:          Node decl = oScopeFindRequire
12407:          @ResolveUnitRef( decl )
12414:          [ oNodeType( decl )
12421:             | nTypeDecl :
12422:                resultType = oNodeGet( decl, qType )
12435:             | * :
12440:                #eNotType
12442:                resultType = IntegerType
12448:          ]
         
12448:       | pArray :
12450:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
12452:          NodeVec dimensions = oNodeVecNew
      
12457:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
12457:             Node subrange = oNodeNew( nSubrangeType )
      
12467:             @ConstExpr
12469:             oNodeSetInt( subrange, qLow, oValueTop )
12480:             oValuePop
12481:             '..'
12483:             @ConstExpr
12485:             oNodeSetInt( subrange, qHigh, oValueTop )
12496:             oValuePop
      
12497:             @ConstMatchTypes
12499:             oNodeSet( subrange, qBaseType, oTypeSTop )
12510:             oNodeSetInt( subrange, qSize, oNodeGetInt( oTypeSTop, qSize ) )
12528:             oTypeSPop
12529:             oTypeAdd( subrange )
      
12535:             Node a = oNodeNew( nArrayType )
12545:             oNodeSet( a, qIndexType, subrange )
      
12557:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
12566:             [
12566:                | ']' : >
12570:                | ',' :
12572:             ]
12580:          }
      
12582:          pOf
12584:          Node baseType
12584:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
12591:          int dim = oNodeVecSize( dimensions )
      
12601:          {
12601:              dec(dim)
      
12607:              Node a = oNodeVecElement( dimensions, dim )
      
12620:              oNodeSet( a, qBaseType, baseType )
12632:              Node subrange = oNodeGet( a, qIndexType )
12645:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
12672:              inc( width )
12678:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
12704:              oTypeAdd( a )
12710:              baseType = a
      
12716:              [ equal_zero(dim)
12723:                  | true:  >
12726:                  | *:
12731:              ]
12731:          }
      
12733:          resultType = oNodeVecElement( dimensions, 0 )
12746:          oNodeVecDelete( dimensions )
      
12752:       | '^' :
12754:          Node theType
12754:          @TypeRef( theType )
12761:          resultType = @PointerTypeTo( theType )
      
12772:       | pRecord :
12774:          resultType = oNodeNew( nRecordType )
12784:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
12793:          @VarDecl( nRecordField )
      
12800:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
12812:          [ equal_zero( size )
12819:             | true : #eRecordEmpty
12822:             | * :
12827:          ]
      
12827:          pEnd
      
12829:          oNodeSet( resultType, qScope, oScopeCurrent )
12840:          oNodeSetInt( resultType, qSize, size )
12852:          oScopeEnd
12853:          oTypeAdd( resultType )
      
      
12859:       | '(' :
               % An enum type declaration.
12861:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
12868:       | pSet :
12870:          pOf
12872:          Node theType
12872:          @TypeRef( theType )
12879:          #eNotImplemented
12881:       | * :       % this works for cases except where expr starts with an id
12896:          @ConstExpr '..' @ConstExpr
12902:          @ConstMatchTypes
12904:          #eNotImplemented
12906:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
12907: EnumTypeRef( out Node resultType ):
      
12909:    resultType = oNodeNew( nEnumType )
12919:    int value = 0
12925:    int numValues = 0
12931:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
12937:    Node outerScope = oScopeCurrent
12942:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
12951:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
12951:       pIdent
12953:       Node decl = @newIdent( nEnumValue, LAST_ID )
12966:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
12979:       oNodeSet( decl, qType, resultType )
12991:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
13003:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
13016:       oNodeSetInt( decl, qNameOffset, nameOffset )
13028:       oNodeSetInt( decl2, qNameOffset, nameOffset )
13040:       [
13040:          | '=', ':=' :
13042:             oTypeSPush( IntegerType )
13048:             @ConstExpr
13050:             @ConstCoerceType
13052:             oTypeSPop
                  % value must be ascending
                  % this obviously doesn't apply to the first value
13053:             [ equal_zero( numValues )
13060:                | false :
13061:                   [ greater( oValueTop, value )
13070:                      | false :   #eEnumValueNotAscending
13073:                      | * :
13078:                   ]
13078:                | * :
13083:             ]
13083:             [ equal( value, oValueTop )
13092:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
13093:                   oNodeSetBoolean( resultType, qHasGap, true )
13105:                | * :
13110:             ]
13110:             value = oValueTop
13115:             oValuePop
13116:          | * :
13123:       ]
13123:       oNodeSetInt( decl, qValue, value )
13135:       oNodeSetInt( decl2, qValue, value )
13147:       oScopeDeclare( decl )
      
13153:       oScopeEnter( outerScope )
13159:       oScopeDeclare( decl2 )
13165:       oScopeEnd
      
13166:       inc( value )
13172:       inc( numValues )
13178:       [
13178:          | ',' :
13180:          | * :    >
13187:       ]
13187:    }
13189:    ')'
      
13191:    oNodeSet( resultType, qScope, oScopeCurrent )
13202:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
13214:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
13215:    oCodePush( @GetOrCreateInitCode( globalScope ) )
13226:    oScopeEnter( globalScope )
13232:    int size = multiply( add( numValues, 1 ), 16 )
13252:    int addr = oScopeAlloc( size, 8 )
13265:    oScopeEnd
13266:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
13278:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
13298:    {
13298:       Node enumValue = oNodeIterValue( it )
13308:       [ oNodeNull( enumValue )
13315:          | true :  >
13318:          | * :
13323:       ]
13323:       .tPushAddrGlobal  oEmitInt( addr )
13331:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
13346:       .tAssignI
13348:       addr = add( addr, 8 )
13361:       .tPushAddrGlobal  oEmitInt( addr )
13369:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
13384:       .tAssignP
13386:       addr = add( addr, 8 )
13399:       oNodeIterNext( it )
13405:    }
         % final table entry
13407:    .tPushAddrGlobal  oEmitInt( addr )
13415:    .tPushConstI  oEmitInt( 0 )
13423:    .tAssignI
13425:    addr = add( addr, 8 )
13438:    .tPushAddrGlobal  oEmitInt( addr )
13446:    .tPushConstI  oEmitInt( 0 )
13454:    .tAssignP
13456:    addr = add( addr, 8 )
13469:    oCodePop
      
13470:    oTypeAdd( resultType )
13477:    ;
      
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
13477: PointerTypeTo( Node theType ) >> Node:
13479:    Node ptrType = oNodeGet( theType, qPointerType )
13492:    [ oNodeNull( ptrType )
13499:       | true :
13500:          ptrType = oNodeNew( nPointerType )
13510:          oNodeSet( ptrType, qBaseType, theType )
13522:          oNodeSetInt( ptrType, qSize, 8 )
13534:          oTypeAdd( ptrType )
13540:          oNodeSet( theType, qPointerType, ptrType )
13552:       | * :
13557:    ]
13557:    >> ptrType;
      
      
      
      % Return the low value of an ordinal type
      %
13561: OrdinalLow( Node theType ) >> int:
13563:    [ oNodeType( theType )
13570:       | nIntegerType :  >> oMININT
13573:       | nBooleanType :  >> 0
13578:       | nCharType :     >> 0
13583:       | nEnumType :
13585:          Node enumScope = oNodeGet( theType, qScope )
13598:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
13615:          >> oNodeGetInt( first, qValue )
13625:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
13637:       | * :             #eNotOrdinalType
13652:                         >> 0
13655:    ];
      
      
      % Return the high value of an ordinal type
      %
13656: OrdinalHigh( Node theType ) >> int:
13658:    [ oNodeType( theType )
13665:       | nIntegerType :  >> oMAXINT
13668:       | nBooleanType :  >> 1
13673:       | nCharType :     >> 255
13678:       | nEnumType :
13680:          Node enumScope = oNodeGet( theType, qScope )
13693:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
13710:          >> oNodeGetInt( last, qValue )
13720:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
13732:       | * :             #eNotOrdinalType
13747:                         >> 0
13750:    ];
      
      
      
13751: Program:
13753:    Node t
      
13753:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
13758:    oScopeBegin( 0, allocGlobal )
13767:    Node rootScope = oScopeCurrent
      
13772:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
13774:    .tEnter  oEmitInt( 0 )
13782:    Label mainLabel = oLabelNew
      
13787:    .tAllocActuals  oEmitInt( 0 )
13795:    .tCall  oEmitLabel( mainLabel )
13803:    .tFreeActuals  oEmitInt( 0 )
13811:    .tReturn
      
13813:    pProgram
13815:    pIdent
      
13817:    Node program = oNodeNew( nProgram )
13827:    oNodeSetInt( program, qIdent, LAST_ID )
13838:    oNodeSet( workspace, qProgram, program )
      
      
13850:    [
13850:       | '(' :
13852:          pIdent      % input, output files
      
13854:          t = @newIdent( nVar, LAST_ID )
13867:          oNodeSet( t, qType, FileType )
13879:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
13885:          ','
13887:          pIdent
      
13889:          t = @newIdent( nVar, LAST_ID )
13902:          oNodeSet( t, qType, FileType )
13914:          oScopeDeclareAlloc( t )
      
13920:          ')'
13922:       | * :
13927:    ]
13927:    ';'
      
13929:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
13936:    [
13936:       | pUses :  @UsesClause( program )
13945:       | * :
13950:    ]
13950:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
13957:    oScopeBegin( 0, allocGlobal )
13966:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
13971:    oScopeBegin( 0, allocDown )
13980:    oNodeSet( oScopeCurrent, qExtends, globalScope )
13991:    initScope = oScopeCurrent
13996:    oNodeSet( program, qMainRoutineScope, initScope )
14008:    oScopeEnd
      
14009:    @BlockDecls( nGlobalVar )
      
      
14016:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
14022:    boolean isMain = true
14028:    @BlockStmt( mainLabel, globalScope, isMain )
      
14041:    oScopeEnd   % main routine scope
      
14042:    '.'
14044:    @CheckForUndefinedLabels
14046:    oScopeEnd   % global scope
14047:    @EndUsedUnits( program )   % used units scopes
14055:    ;
      
      
      
      
14055: Block( node_type varNodeType, Label labelForBody ):
14057:    @BlockDecls( varNodeType )
14064:    @BlockStmt( labelForBody, oScopeCurrent, false )
14076:    @CheckForUndefinedLabels
14079:    ;
      
      
14079: BlockDecls( node_type varNodeType ):
14081:    {[
14081:       | pConst :     @ConstDecl
14085:       | pType :      @TypeDecl
14089:       | pVar :       @VarDecl( varNodeType )
14098:       | pLabel :     @LabelDecl
14102:       | pProcedure : @ProcDecl
14106:       | pFunction :  @FuncDecl
14110:       | * :          >
14127:    ]}
14129:    @CheckForUndefinedMethods
14132:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
14132: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
14135:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
14135: CheckForUndefinedLabels:
14137:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
14149:    {
14149:       Node decl = oNodeIterValue( it )
14159:       [ oNodeNull( decl )
14166:          | false :
14167:          | * :  >
14174:       ]
14174:       [ oNodeType( decl )
14181:          | nLabel :
14182:             [ oNodeGetBoolean( decl, qDefined )
14192:                | false :
14193:                   [ oNodeGetBoolean( decl, qUsed )
14203:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
14206:                      | * :
14211:                   ]
14211:                | * :
14216:             ]
14216:          | * :
14221:       ]
14221:       oNodeIterNext( it )
14227:    }
14230:    ;
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
14230: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
14232:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
14240:    int patchLS
14240:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
14249:    [ isMain
14252:       | true :  @InitializeUnits
14255:       | * :
14260:    ]
      
         % insert any code for initialization of this scope's variables
14260:    Code initCode = oNodeGetCode( varScope, qInitCode )
14273:    oEmitCode( initCode )
14279:    oNodeSetCode( varScope, qInitCode, codeNull )
      
14291:    @Statement
      
14293:    [ isMain
14296:       | true :  @FinalizeUnits
14299:       | * :
14304:    ]
      
14304:    .tReturn
      
14306:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
14318:    oPatch( patchLS, localSpace )
14328:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
14328: GetOrCreateInitCode( Node scope ) >> Code:
14330:    Code initCode = oNodeGetCode( scope, qInitCode )
14343:    [ equal_code( initCode, codeNull )
14353:       | true :
14354:          initCode = oCodeNew
14359:          oNodeSetCode( scope, qInitCode, initCode )
14371:       | * :
14376:    ]
14376:    >> initCode;
      
      
      
      
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
14380: ScopeLevel >> int:
14382:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
14392: DeclLevel( Node decl ) >> int:
14394:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
14412: DeclUpLevels( Node decl ) >> int:
14414:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
14430: newIdent( node_type nt, int id ) >> Node:
14432:   Node t = oNodeNew( nt )
14442:   oNodeSetInt( t, qIdent, id )
14454:   >> t
14458:   ;
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
14458: EmitValue( Node decl ):
14460:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
14474: DeclareBuiltInFunc( int id ) >> Node:
14476:    Node decl = @newIdent( nBuiltInFunc, id )
14490:    oScopeDeclare( decl )
14496:    >> decl;
      
      
14500: installBuiltIns:
      
         % initialize some other globals too
14502:    flagExprAllowTypeName = false
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
14508:    mysystemId = oId_mysystem
      
         % install built-in types
14513:    FileType = @newType( nFileType, 4 )
14527:    IntegerType = @newType( nIntegerType, 4 )
14541:    BooleanType = @newType( nBooleanType, 1 )
14555:    BooleanFlowType = @newType( nBooleanFlowType, 1 )
14569:    CharType = @newType( nCharType, 1 )
14583:    PCharType = @PointerTypeTo( CharType )
14594:    ByteType = @newType( nByteType, 1 )
14608:    SingleType = @newType( nSingleType, 4 )
14622:    DoubleType = @newType( nDoubleType, 8 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
14636:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
14650:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
14662:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
14676:    ShortStringType = @newType( nShortStringType, 256 )
14690:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
14702:    Node t
      
14702:    t = @newIdent( nTypeDecl, oId_File )
14715:    oNodeSet( t, qType, FileType )
14727:    oScopeDeclare( t )
      
14733:    t = @newIdent( nTypeDecl, oId_Integer )
14746:    oNodeSet( t, qType, IntegerType )
14758:    oScopeDeclare( t )
      
14764:    t = @newIdent( nTypeDecl, oId_Boolean )
14777:    oNodeSet( t, qType, BooleanType )
14789:    oScopeDeclare( t )
      
14795:    t = @newIdent( nTypeDecl, oId_Char )
14808:    oNodeSet( t, qType, CharType )
14820:    oScopeDeclare( t )
      
14826:    t = @newIdent( nTypeDecl, oId_Byte )
14839:    oNodeSet( t, qType, ByteType )
14851:    oScopeDeclare( t )
      
14857:    t = @newIdent( nTypeDecl, oId_Single )
14870:    oNodeSet( t, qType, SingleType )
14882:    oScopeDeclare( t )
      
14888:    t = @newIdent( nTypeDecl, oId_Double )
14901:    oNodeSet( t, qType, DoubleType )
14913:    oScopeDeclare( t )
      
14919:    t = @newIdent( nTypeDecl, oId_Pointer )
14932:    oNodeSet( t, qType, UniversalPointerType )
14944:    oScopeDeclare( t )
      
14950:    t = @newIdent( nTypeDecl, oId_ShortString )
14963:    oNodeSet( t, qType, ShortStringType )
14975:    oScopeDeclare( t )
      
         % Built-in constants
      
14981:    t = @newIdent( nConst, oId_True )
14994:    oNodeSet( t, qType, BooleanType )
15006:    oNodeSetInt( t, qValue, 1 )
15018:    oScopeDeclare( t )
      
15024:    t = @newIdent( nConst, oId_False )
15037:    oNodeSet( t, qType, BooleanType )
15049:    oNodeSetInt( t, qValue, 0 )
15061:    oScopeDeclare( t )
      
15067:    t = @newIdent( nConst, oId_Nil )
15080:    oNodeSet( t, qType, UniversalPointerType )
15092:    oNodeSetInt( t, qValue, 0 )
15104:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
15110:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
15120:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
15130:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
15140:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
15150:    BuiltIn_Sizeof = @DeclareBuiltInFunc( oId_Sizeof )
15161:    ;
      
15161: end
      
15161: 

Generated code:

   0: oGlobalSpace 26
   2: oLocalSpace 0
   4: oCall 13751
   6: oReturn
   7: oLocalSpace 0
   9: oInput 0
  11: LAST_ID
  12: oPushResult
  13: oGetParam 1
  15: oPushResult
  16: oCall 148
  18: oPop 2
  20: oInputChoice 24
  22: oJumpForward 29
  24: Choice Lookup Table
          14     22
  27: oJumpForward 31
  29: oJumpBack 9
  31: oInput 6
  33: oReturn
  34: oLocalSpace 0
  36: oGetParam 1
  38: oPushResult
  39: oSetResult 4
  41: oPushResult
  42: oNodeGetInt
  43: oPop 2
  45: oPushResult
  46: oGetGlobal 4
  48: oPushResult
  49: equal
  50: oPop 2
  52: oChoice 57
  54: oReturn
  55: oJumpForward 60
  57: Choice Lookup Table
           1     54
  60: oGetGlobal 4
  62: oPushResult
  63: oGetParam 1
  65: oPushResult
  66: oCall 148
  68: oPop 2
  70: oReturn
  71: oLocalSpace 0
  73: oGetParam 1
  75: oPushResult
  76: oSetResult 4
  78: oPushResult
  79: oNodeGetInt
  80: oPop 2
  82: oPushResult
  83: oGetGlobal 4
  85: oPushResult
  86: equal
  87: oPop 2
  89: oChoice 144
  91: oGetAddrGlobal 22
  93: oPushResult
  94: oScopeCurrent
  95: oPushResult
  96: oSetResult 15
  98: oPushResult
  99: oSetResult 4
 101: oPushResult
 102: oId_ShortStringAppendShortString
 103: oPushResult
 104: oNodeFind
 105: oPop 4
 107: oAssign
 108: oGetAddrGlobal 23
 110: oPushResult
 111: oScopeCurrent
 112: oPushResult
 113: oSetResult 15
 115: oPushResult
 116: oSetResult 4
 118: oPushResult
 119: oId_ShortStringAppendChar
 120: oPushResult
 121: oNodeFind
 122: oPop 4
 124: oAssign
 125: oGetAddrGlobal 24
 127: oPushResult
 128: oScopeCurrent
 129: oPushResult
 130: oSetResult 15
 132: oPushResult
 133: oSetResult 4
 135: oPushResult
 136: oId_ShortStringCmp
 137: oPushResult
 138: oNodeFind
 139: oPop 4
 141: oAssign
 142: oJumpForward 147
 144: Choice Lookup Table
           1     91
 147: oReturn
 148: oLocalSpace 2
 150: oGetAddrLocal 1
 152: oPushResult
 153: oGetParam 2
 155: oPushResult
 156: oCall 428
 158: oPop 1
 160: oAssign
 161: oGetLocal 1
 163: oPushResult
 164: oSetResult 0
 166: oPushResult
 167: equal_node
 168: oPop 2
 170: oChoice 240
 172: oGetParam 1
 174: oPushResult
 175: oSetResult 5
 177: oPushResult
 178: oGetLocal 1
 180: oPushResult
 181: oNodeAddLast
 182: oPop 3
 184: oGetAddrLocal 2
 186: oPushResult
 187: oSetResult 10
 189: oPushResult
 190: oNodeNew
 191: oPop 1
 193: oAssign
 194: oGetLocal 2
 196: oPushResult
 197: oSetResult 4
 199: oPushResult
 200: oGetLocal 1
 202: oPushResult
 203: oSetResult 4
 205: oPushResult
 206: oNodeGetInt
 207: oPop 2
 209: oPushResult
 210: oNodeSetInt
 211: oPop 3
 213: oGetLocal 2
 215: oPushResult
 216: oSetResult 9
 218: oPushResult
 219: oGetLocal 1
 221: oPushResult
 222: oSetResult 9
 224: oPushResult
 225: oNodeGet
 226: oPop 2
 228: oPushResult
 229: oNodeSet
 230: oPop 3
 232: oGetLocal 2
 234: oPushResult
 235: oScopeDeclare
 236: oPop 1
 238: oJumpForward 243
 240: Choice Lookup Table
           0    172
 243: oReturn
 244: oLocalSpace 1
 246: oGetFromParam 1
 248: oPushResult
 249: oNodeType
 250: oPop 1
 252: oChoice 283
 254: oGetAddrLocal 1
 256: oPushResult
 257: oGetFromParam 1
 259: oPushResult
 260: oSetResult 9
 262: oPushResult
 263: oNodeGet
 264: oPop 2
 266: oAssign
 267: oInput 21
 269: oInput 0
 271: oGetParam 1
 273: oPushResult
 274: oGetLocal 1
 276: oPushResult
 277: oScopeFindRequireInScope
 278: oPop 1
 280: oAssign
 281: oJumpForward 286
 283: Choice Lookup Table
          10    254
 286: oReturn
 287: oLocalSpace 2
 289: oGetAddrLocal 1
 291: oPushResult
 292: oGetParam 1
 294: oPushResult
 295: oSetResult 5
 297: oPushResult
 298: oNodeGetIter
 299: oPop 2
 301: oAssign
 302: oGetAddrLocal 2
 304: oPushResult
 305: oGetLocal 1
 307: oPushResult
 308: oNodeIterValue
 309: oPop 1
 311: oAssign
 312: oGetLocal 2
 314: oPushResult
 315: oNodeNull
 316: oPop 1
 318: oChoice 335
 320: oGetLocal 2
 322: oPushResult
 323: oSetResult 9
 325: oPushResult
 326: oNodeGet
 327: oPop 2
 329: oPushResult
 330: oScopeEnter
 331: oPop 1
 333: oJumpForward 340
 335: Choice Lookup Table
           0    320
 338: oJumpForward 348
 340: oGetAddrLocal 1
 342: oPushResult
 343: oNodeIterNext
 344: oPop 1
 346: oJumpBack 302
 348: oReturn
 349: oLocalSpace 2
 351: oGetAddrLocal 1
 353: oPushResult
 354: oGetParam 1
 356: oPushResult
 357: oSetResult 5
 359: oPushResult
 360: oNodeGetIterLast
 361: oPop 2
 363: oAssign
 364: oGetAddrLocal 2
 366: oPushResult
 367: oGetLocal 1
 369: oPushResult
 370: oNodeIterValue
 371: oPop 1
 373: oAssign
 374: oGetLocal 2
 376: oPushResult
 377: oNodeNull
 378: oPop 1
 380: oChoice 414
 382: oScopeCurrent
 383: oPushResult
 384: oGetLocal 2
 386: oPushResult
 387: oSetResult 9
 389: oPushResult
 390: oNodeGet
 391: oPop 2
 393: oPushResult
 394: oNodeEqual
 395: oPop 2
 397: oChoice 405
 399: oJumpForward 411
 401: oError 26
 403: oJumpForward 411
 405: Choice Lookup Table
           0    401
           1    399
 410: oEndChoice
 411: oScopeEnd
 412: oJumpForward 419
 414: Choice Lookup Table
           0    382
 417: oJumpForward 427
 419: oGetAddrLocal 1
 421: oPushResult
 422: oNodeIterPrev
 423: oPop 1
 425: oJumpBack 364
 427: oReturn
 428: oLocalSpace 2
 430: oGetAddrLocal 1
 432: oPushResult
 433: oGetGlobal 1
 435: oPushResult
 436: oSetResult 1
 438: oPushResult
 439: oSetResult 4
 441: oPushResult
 442: oGetParam 1
 444: oPushResult
 445: oNodeFind
 446: oPop 4
 448: oAssign
 449: oGetLocal 1
 451: oPushResult
 452: oSetResult 0
 454: oPushResult
 455: equal_node
 456: oPop 2
 458: oChoice 465
 460: oGetLocal 1
 462: oReturn
 463: oJumpForward 468
 465: Choice Lookup Table
           0    460
 468: oGetAddrLocal 2
 470: oPushResult
 471: oGetParam 1
 473: oPushResult
 474: oIncludeUnitFile
 475: oPop 1
 477: oAssign
 478: oGetLocal 2
 480: oChoice 489
 482: oError 25
 484: oSetResult 0
 486: oReturn
 487: oJumpForward 492
 489: Choice Lookup Table
           0    482
 492: oGetAddrLocal 1
 494: oPushResult
 495: oCall 503
 497: oAssign
 498: oIncludeEnd
 499: oGetLocal 1
 501: oReturn
 502: oReturn
 503: oLocalSpace 2
 505: oInput 61
 507: oInput 0
 509: oGetAddrLocal 1
 511: oPushResult
 512: oSetResult 5
 514: oPushResult
 515: oNodeNew
 516: oPop 1
 518: oAssign
 519: oGetLocal 1
 521: oPushResult
 522: oSetResult 4
 524: oPushResult
 525: LAST_ID
 526: oPushResult
 527: oNodeSetInt
 528: oPop 3
 530: oGetAddrLocal 2
 532: oPushResult
 533: oSetResult 6
 535: oPushResult
 536: oNodeNew
 537: oPop 1
 539: oAssign
 540: oGetLocal 2
 542: oPushResult
 543: oSetResult 4
 545: oPushResult
 546: LAST_ID
 547: oPushResult
 548: oNodeSetInt
 549: oPop 3
 551: oGetLocal 1
 553: oPushResult
 554: oSetResult 8
 556: oPushResult
 557: oGetLocal 2
 559: oPushResult
 560: oNodeSet
 561: oPop 3
 563: oInput 6
 565: oInput 62
 567: oGetLocal 1
 569: oPushResult
 570: oCall 34
 572: oPop 1
 574: oInputChoice 585
 576: oGetLocal 1
 578: oPushResult
 579: oCall 7
 581: oPop 1
 583: oJumpForward 588
 585: Choice Lookup Table
          60    576
 588: oGetLocal 1
 590: oPushResult
 591: oCall 287
 593: oPop 1
 595: oSetResult 0
 597: oPushResult
 598: oSetResult 0
 600: oPushResult
 601: oScopeBegin
 602: oPop 2
 604: oGetLocal 1
 606: oPushResult
 607: oSetResult 9
 609: oPushResult
 610: oScopeCurrent
 611: oPushResult
 612: oNodeSet
 613: oPop 3
 615: oGetAddrGlobal 2
 617: oPushResult
 618: oScopeCurrent
 619: oAssign
 620: oSetResult 0
 622: oPushResult
 623: oSetResult 1
 625: oPushResult
 626: oScopeBegin
 627: oPop 2
 629: oGetAddrGlobal 3
 631: oPushResult
 632: oScopeCurrent
 633: oAssign
 634: oGetLocal 1
 636: oPushResult
 637: oSetResult 13
 639: oPushResult
 640: oGetGlobal 3
 642: oPushResult
 643: oNodeSet
 644: oPop 3
 646: oScopeEnd
 647: oGetLocal 1
 649: oPushResult
 650: oCall 838
 652: oPop 1
 654: oScopeEnd
 655: oInput 63
 657: oGetLocal 2
 659: oPushResult
 660: oCall 34
 662: oPop 1
 664: oInputChoice 675
 666: oGetLocal 2
 668: oPushResult
 669: oCall 7
 671: oPop 1
 673: oJumpForward 678
 675: Choice Lookup Table
          60    666
 678: oGetLocal 2
 680: oPushResult
 681: oCall 287
 683: oPop 1
 685: oGetLocal 1
 687: oPushResult
 688: oSetResult 9
 690: oPushResult
 691: oNodeGet
 692: oPop 2
 694: oPushResult
 695: oScopeEnter
 696: oPop 1
 698: oSetResult 0
 700: oPushResult
 701: oSetResult 0
 703: oPushResult
 704: oScopeBegin
 705: oPop 2
 707: oGetLocal 1
 709: oPushResult
 710: oSetResult 10
 712: oPushResult
 713: oScopeCurrent
 714: oPushResult
 715: oNodeSet
 716: oPop 3
 718: oScopeCurrent
 719: oPushResult
 720: oSetResult 16
 722: oPushResult
 723: oGetLocal 1
 725: oPushResult
 726: oSetResult 9
 728: oPushResult
 729: oNodeGet
 730: oPop 2
 732: oPushResult
 733: oNodeSet
 734: oPop 3
 736: oGetAddrGlobal 2
 738: oPushResult
 739: oScopeCurrent
 740: oAssign
 741: oGetLocal 1
 743: oPushResult
 744: oCall 930
 746: oPop 1
 748: oInputChoice 762
 750: oGetLocal 1
 752: oPushResult
 753: oSetResult 1
 755: oPushResult
 756: oCall 940
 758: oPop 2
 760: oJumpForward 775
 762: Choice Lookup Table
          64    750
 765: oGetLocal 1
 767: oPushResult
 768: oSetResult 0
 770: oPushResult
 771: oCall 940
 773: oPop 2
 775: oInputChoice 789
 777: oGetLocal 1
 779: oPushResult
 780: oSetResult 1
 782: oPushResult
 783: oCall 1126
 785: oPop 2
 787: oJumpForward 802
 789: Choice Lookup Table
          65    777
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 0
 797: oPushResult
 798: oCall 1126
 800: oPop 2
 802: oInput 37
 804: oInput 21
 806: oScopeEnd
 807: oScopeEnd
 808: oGetLocal 2
 810: oPushResult
 811: oCall 349
 813: oPop 1
 815: oGetLocal 1
 817: oPushResult
 818: oCall 349
 820: oPop 1
 822: oGetGlobal 1
 824: oPushResult
 825: oSetResult 1
 827: oPushResult
 828: oGetLocal 1
 830: oPushResult
 831: oNodeAddLast
 832: oPop 3
 834: oGetLocal 1
 836: oReturn
 837: oReturn
 838: oLocalSpace 2
 840: oInputChoice 907
 842: oCall 2520
 844: oJumpForward 920
 846: oCall 3213
 848: oJumpForward 920
 850: oSetResult 22
 852: oPushResult
 853: oCall 3269
 855: oPop 1
 857: oJumpForward 920
 859: oGetAddrLocal 1
 861: oPushResult
 862: oCall 1487
 864: oAssign
 865: oInputChoice 878
 867: oGetLocal 1
 869: oPushResult
 870: oCall 1418
 872: oPop 1
 874: oInput 6
 876: oJumpForward 881
 878: Choice Lookup Table
          71    867
 881: oJumpForward 920
 883: oGetAddrLocal 2
 885: oPushResult
 886: oCall 1861
 888: oAssign
 889: oInputChoice 902
 891: oGetLocal 2
 893: oPushResult
 894: oCall 1418
 896: oPop 1
 898: oInput 6
 900: oJumpForward 905
 902: Choice Lookup Table
          71    891
 905: oJumpForward 920
 907: Choice Lookup Table
          31    883
          30    859
          34    850
          33    846
          32    842
 918: oJumpForward 922
 920: oJumpBack 840
 922: oGetParam 1
 924: oPushResult
 925: oCall 71
 927: oPop 1
 929: oReturn
 930: oLocalSpace 0
 932: oSetResult 22
 934: oPushResult
 935: oCall 14079
 937: oPop 1
 939: oReturn
 940: oLocalSpace 5
 942: oGetAddrLocal 1
 944: oPushResult
 945: oLabelNew
 946: oAssign
 947: oEmit 89
 949: oGetLocal 1
 951: oPushResult
 952: oEmitLabel
 953: oPop 1
 955: oGetParam 2
 957: oPushResult
 958: oSetResult 11
 960: oPushResult
 961: oGetLocal 1
 963: oPushResult
 964: oNodeSetLabel
 965: oPop 3
 967: oEmit 79
 969: oGetAddrLocal 2
 971: oPushResult
 972: Here
 973: oAssign
 974: oEmit 107
 976: oGetAddrLocal 3
 978: oPushResult
 979: oGetParam 2
 981: oPushResult
 982: oSetResult 9
 984: oPushResult
 985: oNodeGet
 986: oPop 2
 988: oAssign
 989: oGetAddrLocal 4
 991: oPushResult
 992: oGetLocal 3
 994: oPushResult
 995: oSetResult 19
 997: oPushResult
 998: oNodeGetCode
 999: oPop 2
1001: oAssign
1002: oGetLocal 4
1004: oPushResult
1005: oEmitCode
1006: oPop 1
1008: oGetLocal 3
1010: oPushResult
1011: oSetResult 19
1013: oPushResult
1014: oSetResult 0
1016: oPushResult
1017: oNodeSetCode
1018: oPop 3
1020: oGetAddrLocal 3
1022: oPushResult
1023: oGetParam 2
1025: oPushResult
1026: oSetResult 10
1028: oPushResult
1029: oNodeGet
1030: oPop 2
1032: oAssign
1033: oGetAddrLocal 4
1035: oPushResult
1036: oGetLocal 3
1038: oPushResult
1039: oSetResult 19
1041: oPushResult
1042: oNodeGetCode
1043: oPop 2
1045: oAssign
1046: oGetLocal 4
1048: oPushResult
1049: oEmitCode
1050: oPop 1
1052: oGetLocal 3
1054: oPushResult
1055: oSetResult 19
1057: oPushResult
1058: oSetResult 0
1060: oPushResult
1061: oNodeSetCode
1062: oPop 3
1064: oGetParam 2
1066: oPushResult
1067: oSetResult 13
1069: oPushResult
1070: oNodeGet
1071: oPop 2
1073: oPushResult
1074: oScopeEnter
1075: oPop 1
1077: oGetParam 1
1079: oChoice 1098
1081: oCall 9143
1083: oInputChoice 1089
1085: oCall 9143
1087: oJumpForward 1094
1089: Choice Lookup Table
           6   1085
1092: oJumpForward 1096
1094: oJumpBack 1083
1096: oJumpForward 1101
1098: Choice Lookup Table
           1   1081
1101: oEmit 78
1103: oGetAddrLocal 5
1105: oPushResult
1106: oScopeCurrent
1107: oPushResult
1108: oSetResult 17
1110: oPushResult
1111: oNodeGetInt
1112: oPop 2
1114: oAssign
1115: oGetLocal 2
1117: oPushResult
1118: oGetLocal 5
1120: oPushResult
1121: oPatch
1122: oPop 2
1124: oScopeEnd
1125: oReturn
1126: oLocalSpace 3
1128: oGetAddrLocal 1
1130: oPushResult
1131: oLabelNew
1132: oAssign
1133: oEmit 89
1135: oGetLocal 1
1137: oPushResult
1138: oEmitLabel
1139: oPop 1
1141: oGetParam 2
1143: oPushResult
1144: oSetResult 12
1146: oPushResult
1147: oGetLocal 1
1149: oPushResult
1150: oNodeSetLabel
1151: oPop 3
1153: oEmit 79
1155: oGetAddrLocal 2
1157: oPushResult
1158: Here
1159: oAssign
1160: oEmit 107
1162: oSetResult 0
1164: oPushResult
1165: oSetResult 1
1167: oPushResult
1168: oScopeBegin
1169: oPop 2
1171: oGetParam 1
1173: oChoice 1192
1175: oCall 9143
1177: oInputChoice 1183
1179: oCall 9143
1181: oJumpForward 1188
1183: Choice Lookup Table
           6   1179
1186: oJumpForward 1190
1188: oJumpBack 1177
1190: oJumpForward 1195
1192: Choice Lookup Table
           1   1175
1195: oEmit 78
1197: oGetAddrLocal 3
1199: oPushResult
1200: oScopeCurrent
1201: oPushResult
1202: oSetResult 17
1204: oPushResult
1205: oNodeGetInt
1206: oPop 2
1208: oAssign
1209: oGetLocal 2
1211: oPushResult
1212: oGetLocal 3
1214: oPushResult
1215: oPatch
1216: oPop 2
1218: oScopeEnd
1219: oReturn
1220: oLocalSpace 2
1222: oGetAddrLocal 1
1224: oPushResult
1225: oGetGlobal 1
1227: oPushResult
1228: oSetResult 1
1230: oPushResult
1231: oNodeGetIter
1232: oPop 2
1234: oAssign
1235: oGetAddrLocal 2
1237: oPushResult
1238: oGetLocal 1
1240: oPushResult
1241: oNodeIterValue
1242: oPop 1
1244: oAssign
1245: oGetLocal 2
1247: oPushResult
1248: oNodeNull
1249: oPop 1
1251: oChoice 1296
1253: oJumpForward 1304
1255: oJumpForward 1302
1257: oEmit 73
1259: oSetResult 0
1261: oPushResult
1262: oEmitInt
1263: oPop 1
1265: oEmit 76
1267: oGetLocal 2
1269: oPushResult
1270: oSetResult 11
1272: oPushResult
1273: oNodeGetLabel
1274: oPop 2
1276: oPushResult
1277: oEmitLabel
1278: oPop 1
1280: oEmit 75
1282: oSetResult 0
1284: oPushResult
1285: oEmitInt
1286: oPop 1
1288: oGetAddrLocal 1
1290: oPushResult
1291: oNodeIterNext
1292: oPop 1
1294: oJumpForward 1302
1296: Choice Lookup Table
           0   1257
           1   1253
1301: oEndChoice
1302: oJumpBack 1235
1304: oReturn
1305: oLocalSpace 2
1307: oGetAddrLocal 1
1309: oPushResult
1310: oGetGlobal 1
1312: oPushResult
1313: oSetResult 1
1315: oPushResult
1316: oNodeGetIterLast
1317: oPop 2
1319: oAssign
1320: oGetAddrLocal 2
1322: oPushResult
1323: oGetLocal 1
1325: oPushResult
1326: oNodeIterValue
1327: oPop 1
1329: oAssign
1330: oGetLocal 2
1332: oPushResult
1333: oNodeNull
1334: oPop 1
1336: oChoice 1381
1338: oJumpForward 1389
1340: oJumpForward 1387
1342: oEmit 73
1344: oSetResult 0
1346: oPushResult
1347: oEmitInt
1348: oPop 1
1350: oEmit 76
1352: oGetLocal 2
1354: oPushResult
1355: oSetResult 12
1357: oPushResult
1358: oNodeGetLabel
1359: oPop 2
1361: oPushResult
1362: oEmitLabel
1363: oPop 1
1365: oEmit 75
1367: oSetResult 0
1369: oPushResult
1370: oEmitInt
1371: oPop 1
1373: oGetAddrLocal 1
1375: oPushResult
1376: oNodeIterPrev
1377: oPop 1
1379: oJumpForward 1387
1381: Choice Lookup Table
           0   1342
           1   1338
1386: oEndChoice
1387: oJumpBack 1320
1389: oReturn
1390: oLocalSpace 0
1392: oInputChoice 1410
1394: oGetParam 1
1396: oPushResult
1397: oSetResult 27
1399: oPushResult
1400: oSetResult 1
1402: oPushResult
1403: oNodeSetBoolean
1404: oPop 3
1406: oInput 6
1408: oJumpForward 1415
1410: Choice Lookup Table
          73   1394
1413: oJumpForward 1417
1415: oJumpBack 1392
1417: oReturn
1418: oLocalSpace 0
1420: oGetParam 1
1422: oPushResult
1423: oCall 14392
1425: oPop 1
1427: oPushResult
1428: equal_zero
1429: oPop 1
1431: oChoice 1437
1433: oError 24
1435: oJumpForward 1440
1437: Choice Lookup Table
           0   1433
1440: oGetParam 1
1442: oPushResult
1443: oSetResult 25
1445: oPushResult
1446: oSetResult 1
1448: oPushResult
1449: oNodeSetBoolean
1450: oPop 3
1452: oInputChoice 1476
1454: oInputChoice 1471
1456: oInput 3
1458: oGetParam 1
1460: oPushResult
1461: oSetResult 26
1463: oPushResult
1464: CURRENT_STRLIT
1465: oPushResult
1466: oNodeSetString
1467: oPop 3
1469: oJumpForward 1474
1471: Choice Lookup Table
          72   1456
1474: oJumpForward 1479
1476: Choice Lookup Table
           3   1454
1479: oGetParam 1
1481: oPushResult
1482: oCall 12006
1484: oPop 1
1486: oReturn
1487: oLocalSpace 6
1489: oInput 0
1491: oGetAddrLocal 1
1493: oPushResult
1494: oSetResult 0
1496: oAssign
1497: oGetAddrLocal 2
1499: oPushResult
1500: oScopeFindInCurrentScope
1501: oAssign
1502: oGetLocal 2
1504: oPushResult
1505: oNodeNull
1506: oPop 1
1508: oChoice 1626
1510: oGetAddrLocal 2
1512: oPushResult
1513: oSetResult 12
1515: oPushResult
1516: LAST_ID
1517: oPushResult
1518: oCall 14430
1520: oPop 2
1522: oAssign
1523: oGetLocal 2
1525: oPushResult
1526: oSetResult 22
1528: oPushResult
1529: oLabelNew
1530: oPushResult
1531: oNodeSetLabel
1532: oPop 3
1534: oJumpForward 1632
1536: oGetAddrLocal 1
1538: oPushResult
1539: oSetResult 1
1541: oAssign
1542: oGetLocal 2
1544: oPushResult
1545: oSetResult 24
1547: oPushResult
1548: oNodeGetBoolean
1549: oPop 2
1551: oChoice 1557
1553: oError 22
1555: oJumpForward 1560
1557: Choice Lookup Table
           1   1553
1560: oGetLocal 2
1562: oPushResult
1563: oSetResult 25
1565: oPushResult
1566: oNodeGetBoolean
1567: oPop 2
1569: oChoice 1575
1571: oError 22
1573: oJumpForward 1578
1575: Choice Lookup Table
           1   1571
1578: oGetLocal 2
1580: oPushResult
1581: oNodeType
1582: oPop 1
1584: oChoice 1588
1586: oJumpForward 1593
1588: Choice Lookup Table
          12   1586
1591: oError 22
1593: oGetLocal 2
1595: oPushResult
1596: oSetResult 29
1598: oPushResult
1599: oGetLocal 2
1601: oPushResult
1602: oSetResult 23
1604: oPushResult
1605: oNodeGet
1606: oPop 2
1608: oPushResult
1609: oNodeSet
1610: oPop 3
1612: oGetLocal 2
1614: oPushResult
1615: oSetResult 23
1617: oPushResult
1618: oSetResult 0
1620: oPushResult
1621: oNodeSet
1622: oPop 3
1624: oJumpForward 1632
1626: Choice Lookup Table
           0   1536
           1   1510
1631: oEndChoice
1632: oGetAddrLocal 3
1634: oPushResult
1635: oCall 14380
1637: oAssign
1638: oGetAddrLocal 4
1640: oPushResult
1641: oGetLocal 3
1643: oPushResult
1644: oSetResult 0
1646: oPushResult
1647: greater
1648: oPop 2
1650: oAssign
1651: oGetAddrLocal 3
1653: oPushResult
1654: inc
1655: oPop 1
1657: oGetLocal 3
1659: oPushResult
1660: oSetResult 2
1662: oPushResult
1663: oScopeBegin
1664: oPop 2
1666: oGetAddrLocal 5
1668: oPushResult
1669: oScopeCurrent
1670: oAssign
1671: oGetLocal 4
1673: oChoice 1692
1675: oGetAddrLocal 6
1677: oPushResult
1678: oGetGlobal 6
1680: oPushResult
1681: oCall 13477
1683: oPop 1
1685: oPushResult
1686: oScopeAllocType
1687: oPop 1
1689: oAssign
1690: oJumpForward 1695
1692: Choice Lookup Table
           1   1675
1695: oCall 2296
1697: oGetLocal 2
1699: oPushResult
1700: oSetResult 23
1702: oPushResult
1703: oGetLocal 5
1705: oPushResult
1706: oNodeSet
1707: oPop 3
1709: oScopeEnd
1710: oInput 6
1712: oGetLocal 1
1714: oChoice 1726
1716: oGetLocal 2
1718: oPushResult
1719: oScopeDeclare
1720: oPop 1
1722: oJumpForward 1732
1724: oJumpForward 1732
1726: Choice Lookup Table
           1   1724
           0   1716
1731: oEndChoice
1732: oGetLocal 2
1734: oPushResult
1735: oCall 1390
1737: oPop 1
1739: oGetLocal 2
1741: oReturn
1742: oReturn
1743: oLocalSpace 4
1745: oGetAddrLocal 1
1747: oPushResult
1748: oCall 1487
1750: oAssign
1751: oInputChoice 1764
1753: oJumpForward 1858
1755: oGetLocal 1
1757: oPushResult
1758: oCall 1418
1760: oPop 1
1762: oJumpForward 1858
1764: Choice Lookup Table
          71   1755
          70   1753
1769: oGetAddrLocal 2
1771: oPushResult
1772: oGetLocal 1
1774: oPushResult
1775: oSetResult 23
1777: oPushResult
1778: oNodeGet
1779: oPop 2
1781: oAssign
1782: oGetLocal 2
1784: oPushResult
1785: oScopeEnter
1786: oPop 1
1788: oGetAddrLocal 3
1790: oPushResult
1791: oGetLocal 2
1793: oPushResult
1794: oSetResult 14
1796: oPushResult
1797: oNodeGetInt
1798: oPop 2
1800: oAssign
1801: oGetLocal 3
1803: oPushResult
1804: oSetResult 1
1806: oPushResult
1807: oScopeBegin
1808: oPop 2
1810: oGetLocal 1
1812: oPushResult
1813: oSetResult 6
1815: oPushResult
1816: oScopeCurrent
1817: oPushResult
1818: oNodeSet
1819: oPop 3
1821: oGetAddrLocal 4
1823: oPushResult
1824: oGetLocal 1
1826: oPushResult
1827: oSetResult 22
1829: oPushResult
1830: oNodeGetLabel
1831: oPop 2
1833: oAssign
1834: oSetResult 23
1836: oPushResult
1837: oGetLocal 4
1839: oPushResult
1840: oCall 14055
1842: oPop 2
1844: oGetLocal 1
1846: oPushResult
1847: oSetResult 24
1849: oPushResult
1850: oSetResult 1
1852: oPushResult
1853: oNodeSetBoolean
1854: oPop 3
1856: oScopeEnd
1857: oScopeEnd
1858: oInput 6
1860: oReturn
1861: oLocalSpace 8
1863: oInput 0
1865: oGetAddrLocal 1
1867: oPushResult
1868: oSetResult 0
1870: oAssign
1871: oGetAddrLocal 2
1873: oPushResult
1874: oScopeFindInCurrentScope
1875: oAssign
1876: oGetLocal 2
1878: oPushResult
1879: oNodeNull
1880: oPop 1
1882: oChoice 2013
1884: oGetAddrLocal 2
1886: oPushResult
1887: oSetResult 13
1889: oPushResult
1890: LAST_ID
1891: oPushResult
1892: oCall 14430
1894: oPop 2
1896: oAssign
1897: oGetLocal 2
1899: oPushResult
1900: oSetResult 22
1902: oPushResult
1903: oLabelNew
1904: oPushResult
1905: oNodeSetLabel
1906: oPop 3
1908: oJumpForward 2019
1910: oGetAddrLocal 1
1912: oPushResult
1913: oSetResult 1
1915: oAssign
1916: oGetLocal 2
1918: oPushResult
1919: oSetResult 24
1921: oPushResult
1922: oNodeGetBoolean
1923: oPop 2
1925: oChoice 1931
1927: oError 22
1929: oJumpForward 1934
1931: Choice Lookup Table
           1   1927
1934: oGetLocal 2
1936: oPushResult
1937: oNodeType
1938: oPop 1
1940: oChoice 1944
1942: oJumpForward 1949
1944: Choice Lookup Table
          13   1942
1947: oError 22
1949: oGetLocal 2
1951: oPushResult
1952: oSetResult 29
1954: oPushResult
1955: oGetLocal 2
1957: oPushResult
1958: oSetResult 23
1960: oPushResult
1961: oNodeGet
1962: oPop 2
1964: oPushResult
1965: oNodeSet
1966: oPop 3
1968: oGetLocal 2
1970: oPushResult
1971: oSetResult 23
1973: oPushResult
1974: oSetResult 0
1976: oPushResult
1977: oNodeSet
1978: oPop 3
1980: oGetLocal 2
1982: oPushResult
1983: oSetResult 30
1985: oPushResult
1986: oGetLocal 2
1988: oPushResult
1989: oSetResult 21
1991: oPushResult
1992: oNodeGet
1993: oPop 2
1995: oPushResult
1996: oNodeSet
1997: oPop 3
1999: oGetLocal 2
2001: oPushResult
2002: oSetResult 21
2004: oPushResult
2005: oSetResult 0
2007: oPushResult
2008: oNodeSet
2009: oPop 3
2011: oJumpForward 2019
2013: Choice Lookup Table
           0   1910
           1   1884
2018: oEndChoice
2019: oGetAddrLocal 3
2021: oPushResult
2022: oCall 14380
2024: oAssign
2025: oGetAddrLocal 4
2027: oPushResult
2028: oGetLocal 3
2030: oPushResult
2031: oSetResult 0
2033: oPushResult
2034: greater
2035: oPop 2
2037: oAssign
2038: oGetAddrLocal 3
2040: oPushResult
2041: inc
2042: oPop 1
2044: oGetLocal 3
2046: oPushResult
2047: oSetResult 2
2049: oPushResult
2050: oScopeBegin
2051: oPop 2
2053: oGetAddrLocal 5
2055: oPushResult
2056: oScopeCurrent
2057: oAssign
2058: oGetLocal 4
2060: oChoice 2079
2062: oGetAddrLocal 6
2064: oPushResult
2065: oGetGlobal 6
2067: oPushResult
2068: oCall 13477
2070: oPop 1
2072: oPushResult
2073: oScopeAllocType
2074: oPop 1
2076: oAssign
2077: oJumpForward 2082
2079: Choice Lookup Table
           1   2062
2082: oCall 2296
2084: oGetLocal 2
2086: oPushResult
2087: oSetResult 23
2089: oPushResult
2090: oGetLocal 5
2092: oPushResult
2093: oNodeSet
2094: oPop 3
2096: oInput 13
2098: oGetAddrLocal 7
2100: oPushResult
2101: oCall 12398
2103: oPop 1
2105: oGetLocal 2
2107: oPushResult
2108: oSetResult 21
2110: oPushResult
2111: oGetLocal 7
2113: oPushResult
2114: oNodeSet
2115: oPop 3
2117: oGetAddrLocal 8
2119: oPushResult
2120: oGetLocal 7
2122: oPushResult
2123: oCall 13477
2125: oPop 1
2127: oAssign
2128: oGetLocal 2
2130: oPushResult
2131: oSetResult 31
2133: oPushResult
2134: oGetLocal 8
2136: oPushResult
2137: oScopeAllocType
2138: oPop 1
2140: oPushResult
2141: oNodeSetInt
2142: oPop 3
2144: oScopeEnd
2145: oInput 6
2147: oGetLocal 1
2149: oChoice 2161
2151: oGetLocal 2
2153: oPushResult
2154: oScopeDeclare
2155: oPop 1
2157: oJumpForward 2167
2159: oJumpForward 2167
2161: Choice Lookup Table
           1   2159
           0   2151
2166: oEndChoice
2167: oGetLocal 2
2169: oPushResult
2170: oCall 1390
2172: oPop 1
2174: oGetLocal 2
2176: oReturn
2177: oReturn
2178: oLocalSpace 4
2180: oGetAddrLocal 1
2182: oPushResult
2183: oCall 1861
2185: oAssign
2186: oInputChoice 2199
2188: oJumpForward 2293
2190: oGetLocal 1
2192: oPushResult
2193: oCall 1418
2195: oPop 1
2197: oJumpForward 2293
2199: Choice Lookup Table
          71   2190
          70   2188
2204: oGetAddrLocal 2
2206: oPushResult
2207: oGetLocal 1
2209: oPushResult
2210: oSetResult 23
2212: oPushResult
2213: oNodeGet
2214: oPop 2
2216: oAssign
2217: oGetLocal 2
2219: oPushResult
2220: oScopeEnter
2221: oPop 1
2223: oGetAddrLocal 3
2225: oPushResult
2226: oGetLocal 2
2228: oPushResult
2229: oSetResult 14
2231: oPushResult
2232: oNodeGetInt
2233: oPop 2
2235: oAssign
2236: oGetLocal 3
2238: oPushResult
2239: oSetResult 1
2241: oPushResult
2242: oScopeBegin
2243: oPop 2
2245: oGetLocal 1
2247: oPushResult
2248: oSetResult 6
2250: oPushResult
2251: oScopeCurrent
2252: oPushResult
2253: oNodeSet
2254: oPop 3
2256: oGetAddrLocal 4
2258: oPushResult
2259: oGetLocal 1
2261: oPushResult
2262: oSetResult 22
2264: oPushResult
2265: oNodeGetLabel
2266: oPop 2
2268: oAssign
2269: oSetResult 23
2271: oPushResult
2272: oGetLocal 4
2274: oPushResult
2275: oCall 14055
2277: oPop 2
2279: oGetLocal 1
2281: oPushResult
2282: oSetResult 24
2284: oPushResult
2285: oSetResult 1
2287: oPushResult
2288: oNodeSetBoolean
2289: oPop 3
2291: oScopeEnd
2292: oScopeEnd
2293: oInput 6
2295: oReturn
2296: oLocalSpace 6
2298: oInputChoice 2516
2300: oGetAddrLocal 1
2302: oPushResult
2303: oNodeVecNew
2304: oAssign
2305: oGetAddrLocal 3
2307: oPushResult
2308: oSetResult 0
2310: oAssign
2311: oInputChoice 2321
2313: oGetAddrLocal 3
2315: oPushResult
2316: oSetResult 1
2318: oAssign
2319: oJumpForward 2324
2321: Choice Lookup Table
          34   2313
2324: oInput 0
2326: oGetAddrLocal 2
2328: oPushResult
2329: oSetResult 25
2331: oPushResult
2332: LAST_ID
2333: oPushResult
2334: oCall 14430
2336: oPop 2
2338: oAssign
2339: oGetLocal 2
2341: oPushResult
2342: oSetResult 35
2344: oPushResult
2345: oGetLocal 3
2347: oPushResult
2348: oNodeSetBoolean
2349: oPop 3
2351: oGetLocal 1
2353: oPushResult
2354: oGetLocal 2
2356: oPushResult
2357: oNodeVecAppend
2358: oPop 2
2360: oInputChoice 2368
2362: oJumpForward 2376
2364: oJumpForward 2374
2366: oJumpForward 2374
2368: Choice Lookup Table
          14   2366
          13   2362
2373: oEndChoice
2374: oJumpBack 2324
2376: oGetAddrLocal 4
2378: oPushResult
2379: oCall 12398
2381: oPop 1
2383: oGetLocal 3
2385: oChoice 2400
2387: oGetAddrLocal 5
2389: oPushResult
2390: oGetLocal 4
2392: oPushResult
2393: oCall 13477
2395: oPop 1
2397: oAssign
2398: oJumpForward 2409
2400: Choice Lookup Table
           1   2387
2403: oGetAddrLocal 5
2405: oPushResult
2406: oGetLocal 4
2408: oAssign
2409: oGetAddrLocal 6
2411: oPushResult
2412: oSetResult 0
2414: oAssign
2415: oGetLocal 6
2417: oPushResult
2418: oGetLocal 1
2420: oPushResult
2421: oNodeVecSize
2422: oPop 1
2424: oPushResult
2425: equal
2426: oPop 2
2428: oChoice 2485
2430: oGetAddrLocal 2
2432: oPushResult
2433: oGetLocal 1
2435: oPushResult
2436: oGetLocal 6
2438: oPushResult
2439: oNodeVecElement
2440: oPop 2
2442: oAssign
2443: oGetLocal 2
2445: oPushResult
2446: oSetResult 21
2448: oPushResult
2449: oGetLocal 4
2451: oPushResult
2452: oNodeSet
2453: oPop 3
2455: oGetLocal 2
2457: oPushResult
2458: oScopeDeclare
2459: oPop 1
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 22
2466: oPushResult
2467: oGetLocal 5
2469: oPushResult
2470: oScopeAllocType
2471: oPop 1
2473: oPushResult
2474: oNodeSetInt
2475: oPop 3
2477: oGetAddrLocal 6
2479: oPushResult
2480: inc
2481: oPop 1
2483: oJumpForward 2490
2485: Choice Lookup Table
           0   2430
2488: oJumpForward 2492
2490: oJumpBack 2415
2492: oGetLocal 1
2494: oPushResult
2495: oNodeVecDelete
2496: oPop 1
2498: oInputChoice 2506
2500: oJumpForward 2514
2502: oJumpForward 2512
2504: oJumpForward 2512
2506: Choice Lookup Table
           6   2504
          16   2500
2511: oEndChoice
2512: oJumpBack 2300
2514: oJumpForward 2519
2516: Choice Lookup Table
          15   2300
2519: oReturn
2520: oLocalSpace 0
2522: oInputChoice 2537
2524: oInputChoice 2530
2526: oCall 2683
2528: oJumpForward 2535
2530: Choice Lookup Table
          13   2526
2533: oCall 2545
2535: oJumpForward 2542
2537: Choice Lookup Table
           0   2524
2540: oJumpForward 2544
2542: oJumpBack 2522
2544: oReturn
2545: oLocalSpace 2
2547: oGetAddrLocal 1
2549: oPushResult
2550: LAST_ID
2551: oAssign
2552: oInput 7
2554: oCall 3568
2556: oTypeSNodeType
2557: oChoice 2640
2559: oGetAddrLocal 2
2561: oPushResult
2562: oSetResult 16
2564: oPushResult
2565: oGetLocal 1
2567: oPushResult
2568: oCall 14430
2570: oPop 2
2572: oAssign
2573: oGetLocal 2
2575: oPushResult
2576: oSetResult 22
2578: oPushResult
2579: oValueTop
2580: oPushResult
2581: oNodeSetInt
2582: oPop 3
2584: oJumpForward 2661
2586: oGetAddrLocal 2
2588: oPushResult
2589: oSetResult 19
2591: oPushResult
2592: oGetLocal 1
2594: oPushResult
2595: oCall 14430
2597: oPop 2
2599: oAssign
2600: oGetLocal 2
2602: oPushResult
2603: oSetResult 34
2605: oPushResult
2606: oValueTopDouble
2607: oPushResult
2608: oNodeSetDouble
2609: oPop 3
2611: oJumpForward 2661
2613: oGetAddrLocal 2
2615: oPushResult
2616: oSetResult 18
2618: oPushResult
2619: oGetLocal 1
2621: oPushResult
2622: oCall 14430
2624: oPop 2
2626: oAssign
2627: oGetLocal 2
2629: oPushResult
2630: oSetResult 33
2632: oPushResult
2633: oValueTopString
2634: oPushResult
2635: oNodeSetString
2636: oPop 3
2638: oJumpForward 2661
2640: Choice Lookup Table
          42   2613
          33   2586
          38   2559
          37   2559
          44   2559
          31   2559
          36   2559
          30   2559
          34   2559
2659: oError 18
2661: oValuePop
2662: oGetLocal 2
2664: oPushResult
2665: oSetResult 21
2667: oPushResult
2668: oTypeSTop
2669: oPushResult
2670: oNodeSet
2671: oPop 3
2673: oTypeSPop
2674: oGetLocal 2
2676: oPushResult
2677: oScopeDeclare
2678: oPop 1
2680: oInput 6
2682: oReturn
2683: oLocalSpace 3
2685: oGetAddrLocal 1
2687: oPushResult
2688: oSetResult 26
2690: oPushResult
2691: LAST_ID
2692: oPushResult
2693: oCall 14430
2695: oPop 2
2697: oAssign
2698: oGetAddrLocal 2
2700: oPushResult
2701: oCall 12398
2703: oPop 1
2705: oGetLocal 1
2707: oPushResult
2708: oSetResult 21
2710: oPushResult
2711: oGetLocal 2
2713: oPushResult
2714: oNodeSet
2715: oPop 3
2717: oGetLocal 2
2719: oPushResult
2720: oNodeType
2721: oPop 1
2723: oChoice 2827
2725: oInput 7
2727: oGetLocal 2
2729: oPushResult
2730: oTypeSPush
2731: oPop 1
2733: oCall 3568
2735: oCall 4460
2737: oGetLocal 1
2739: oPushResult
2740: oSetResult 22
2742: oPushResult
2743: oValueTop
2744: oPushResult
2745: oNodeSetInt
2746: oPop 3
2748: oValuePop
2749: oTypeSPop
2750: oGetLocal 1
2752: oPushResult
2753: oScopeDeclare
2754: oPop 1
2756: oInput 6
2758: oJumpForward 2851
2760: oError 17
2762: oJumpForward 2851
2764: oGetGlobal 2
2766: oPushResult
2767: oScopeEnter
2768: oPop 1
2770: oGetAddrLocal 3
2772: oPushResult
2773: oGetLocal 2
2775: oPushResult
2776: oScopeAllocType
2777: oPop 1
2779: oAssign
2780: oScopeEnd
2781: oGetGlobal 2
2783: oPushResult
2784: oCall 14328
2786: oPop 1
2788: oPushResult
2789: oCodePush
2790: oPop 1
2792: oGetLocal 1
2794: oPushResult
2795: oSetResult 22
2797: oPushResult
2798: oGetLocal 3
2800: oPushResult
2801: oNodeSetInt
2802: oPop 3
2804: oInput 7
2806: oGetLocal 2
2808: oPushResult
2809: oGetLocal 3
2811: oPushResult
2812: oCall 2852
2814: oPop 2
2816: oCodePop
2817: oGetLocal 1
2819: oPushResult
2820: oScopeDeclare
2821: oPop 1
2823: oInput 6
2825: oJumpForward 2851
2827: Choice Lookup Table
          41   2764
          39   2764
          29   2760
          43   2760
          38   2725
          37   2725
          44   2725
          31   2725
          36   2725
          30   2725
          34   2725
2850: oEndChoice
2851: oReturn
2852: oLocalSpace 10
2854: oGetParam 2
2856: oPushResult
2857: oNodeType
2858: oPop 1
2860: oChoice 3186
2862: oGetAddrLocal 1
2864: oPushResult
2865: oGetParam 2
2867: oPushResult
2868: oSetResult 38
2870: oPushResult
2871: oNodeGet
2872: oPop 2
2874: oAssign
2875: oGetAddrLocal 2
2877: oPushResult
2878: oGetParam 2
2880: oPushResult
2881: oSetResult 39
2883: oPushResult
2884: oNodeGet
2885: oPop 2
2887: oAssign
2888: oGetAddrLocal 3
2890: oPushResult
2891: oGetLocal 2
2893: oPushResult
2894: oCall 13561
2896: oPop 1
2898: oAssign
2899: oGetAddrLocal 4
2901: oPushResult
2902: oGetLocal 2
2904: oPushResult
2905: oCall 13656
2907: oPop 1
2909: oAssign
2910: oGetAddrLocal 5
2912: oPushResult
2913: oGetLocal 1
2915: oPushResult
2916: oSetResult 17
2918: oPushResult
2919: oNodeGetInt
2920: oPop 2
2922: oAssign
2923: oInput 15
2925: oGetAddrLocal 6
2927: oPushResult
2928: oGetLocal 3
2930: oAssign
2931: oGetLocal 1
2933: oPushResult
2934: oGetParam 1
2936: oPushResult
2937: oCall 2852
2939: oPop 2
2941: oGetLocal 6
2943: oPushResult
2944: oGetLocal 4
2946: oPushResult
2947: equal
2948: oPop 2
2950: oChoice 2958
2952: oJumpForward 2987
2954: oJumpForward 2964
2956: oJumpForward 2964
2958: Choice Lookup Table
           0   2956
           1   2952
2963: oEndChoice
2964: oInput 14
2966: oGetAddrParam 1
2968: oPushResult
2969: oGetParam 1
2971: oPushResult
2972: oGetLocal 5
2974: oPushResult
2975: add
2976: oPop 2
2978: oAssign
2979: oGetAddrLocal 6
2981: oPushResult
2982: inc
2983: oPop 1
2985: oJumpBack 2931
2987: oInput 16
2989: oJumpForward 3212
2991: oInput 15
2993: oGetAddrLocal 7
2995: oPushResult
2996: oGetParam 2
2998: oPushResult
2999: oSetResult 42
3001: oPushResult
3002: oNodeGet
3003: oPop 2
3005: oAssign
3006: oInputChoice 3010
3008: oJumpForward 3015
3010: Choice Lookup Table
           0   3008
3013: oJumpForward 3081
3015: oGetAddrLocal 8
3017: oPushResult
3018: oGetLocal 7
3020: oPushResult
3021: oScopeFindRequireInScope
3022: oPop 1
3024: oAssign
3025: oInput 13
3027: oGetAddrLocal 9
3029: oPushResult
3030: oGetLocal 8
3032: oPushResult
3033: oSetResult 21
3035: oPushResult
3036: oNodeGet
3037: oPop 2
3039: oAssign
3040: oGetAddrLocal 10
3042: oPushResult
3043: oGetParam 1
3045: oPushResult
3046: oGetLocal 8
3048: oPushResult
3049: oSetResult 22
3051: oPushResult
3052: oNodeGetInt
3053: oPop 2
3055: oPushResult
3056: add
3057: oPop 2
3059: oAssign
3060: oGetLocal 9
3062: oPushResult
3063: oGetLocal 10
3065: oPushResult
3066: oCall 2852
3068: oPop 2
3070: oInputChoice 3074
3072: oJumpForward 3079
3074: Choice Lookup Table
           6   3072
3077: oJumpForward 3081
3079: oJumpBack 3006
3081: oInput 16
3083: oJumpForward 3212
3085: oEmit 17
3087: oGetParam 1
3089: oPushResult
3090: oEmitInt
3091: oPop 1
3093: oGetParam 2
3095: oPushResult
3096: oTypeSPush
3097: oPop 1
3099: oCall 3568
3101: oCall 4460
3103: oEmit 15
3105: oValueTop
3106: oPushResult
3107: oEmitInt
3108: oPop 1
3110: oValuePop
3111: oTypeSPop
3112: oEmit 28
3114: oJumpForward 3212
3116: oEmit 17
3118: oGetParam 1
3120: oPushResult
3121: oEmitInt
3122: oPop 1
3124: oGetParam 2
3126: oPushResult
3127: oTypeSPush
3128: oPop 1
3130: oCall 3568
3132: oCall 4460
3134: oEmit 15
3136: oValueTop
3137: oPushResult
3138: oEmitInt
3139: oPop 1
3141: oValuePop
3142: oTypeSPop
3143: oEmit 27
3145: oJumpForward 3212
3147: oError 17
3149: oJumpForward 3212
3151: oEmit 17
3153: oGetParam 1
3155: oPushResult
3156: oEmitInt
3157: oPop 1
3159: oGetParam 2
3161: oPushResult
3162: oTypeSPush
3163: oPop 1
3165: oCall 3568
3167: oCall 4460
3169: oEmit 15
3171: oValueTop
3172: oPushResult
3173: oEmitInt
3174: oPop 1
3176: oValuePop
3177: oTypeSPop
3178: oEmit 29
3180: oJumpForward 3212
3182: oError 17
3184: oJumpForward 3212
3186: Choice Lookup Table
          29   3182
          43   3182
          38   3151
          37   3151
          33   3147
          44   3116
          31   3116
          36   3085
          30   3085
          34   3085
          41   2991
          39   2862
3211: oEndChoice
3212: oReturn
3213: oLocalSpace 2
3215: oInputChoice 3261
3217: oGetAddrLocal 1
3219: oPushResult
3220: oSetResult 20
3222: oPushResult
3223: LAST_ID
3224: oPushResult
3225: oCall 14430
3227: oPop 2
3229: oAssign
3230: oInput 7
3232: oGetAddrLocal 2
3234: oPushResult
3235: oCall 12398
3237: oPop 1
3239: oGetLocal 1
3241: oPushResult
3242: oSetResult 21
3244: oPushResult
3245: oGetLocal 2
3247: oPushResult
3248: oNodeSet
3249: oPop 3
3251: oGetLocal 1
3253: oPushResult
3254: oScopeDeclare
3255: oPop 1
3257: oInput 6
3259: oJumpForward 3266
3261: Choice Lookup Table
           0   3217
3264: oJumpForward 3268
3266: oJumpBack 3215
3268: oReturn
3269: oLocalSpace 6
3271: oInputChoice 3495
3273: oGetAddrLocal 1
3275: oPushResult
3276: oNodeVecNew
3277: oAssign
3278: oGetAddrLocal 2
3280: oPushResult
3281: oGetParam 1
3283: oPushResult
3284: LAST_ID
3285: oPushResult
3286: oCall 14430
3288: oPop 2
3290: oAssign
3291: oGetLocal 1
3293: oPushResult
3294: oGetLocal 2
3296: oPushResult
3297: oNodeVecAppend
3298: oPop 2
3300: oInputChoice 3306
3302: oInput 0
3304: oJumpForward 3311
3306: Choice Lookup Table
          14   3302
3309: oJumpForward 3313
3311: oJumpBack 3278
3313: oInput 13
3315: oGetAddrLocal 3
3317: oPushResult
3318: oCall 12398
3320: oPop 1
3322: oGetAddrLocal 4
3324: oPushResult
3325: oSetResult 0
3327: oAssign
3328: oGetLocal 4
3330: oPushResult
3331: oGetLocal 1
3333: oPushResult
3334: oNodeVecSize
3335: oPop 1
3337: oPushResult
3338: equal
3339: oPop 2
3341: oChoice 3382
3343: oGetAddrLocal 2
3345: oPushResult
3346: oGetLocal 1
3348: oPushResult
3349: oGetLocal 4
3351: oPushResult
3352: oNodeVecElement
3353: oPop 2
3355: oAssign
3356: oGetLocal 2
3358: oPushResult
3359: oSetResult 21
3361: oPushResult
3362: oGetLocal 3
3364: oPushResult
3365: oNodeSet
3366: oPop 3
3368: oGetLocal 2
3370: oPushResult
3371: oScopeDeclareAlloc
3372: oPop 1
3374: oGetAddrLocal 4
3376: oPushResult
3377: inc
3378: oPop 1
3380: oJumpForward 3387
3382: Choice Lookup Table
           0   3343
3385: oJumpForward 3389
3387: oJumpBack 3328
3389: oInputChoice 3482
3391: oGetLocal 1
3393: oPushResult
3394: oNodeVecSize
3395: oPop 1
3397: oChoice 3401
3399: oJumpForward 3406
3401: Choice Lookup Table
           1   3399
3404: oError 23
3406: oGetAddrLocal 5
3408: oPushResult
3409: oScopeCurrent
3410: oPushResult
3411: oCall 14328
3413: oPop 1
3415: oAssign
3416: oGetLocal 5
3418: oPushResult
3419: oCodePush
3420: oPop 1
3422: oGetAddrLocal 6
3424: oPushResult
3425: oSetResult 0
3427: oAssign
3428: oCall 14380
3430: oPushResult
3431: equal_zero
3432: oPop 1
3434: oChoice 3450
3436: oGetGlobal 3
3438: oPushResult
3439: oScopeEnter
3440: oPop 1
3442: oGetAddrLocal 6
3444: oPushResult
3445: oSetResult 1
3447: oAssign
3448: oJumpForward 3453
3450: Choice Lookup Table
           1   3436
3453: oGetLocal 2
3455: oPushResult
3456: oSetResult 1
3458: oPushResult
3459: oCall 9841
3461: oPop 2
3463: oCall 5024
3465: oCall 8586
3467: oCall 9389
3469: oGetLocal 6
3471: oChoice 3476
3473: oScopeEnd
3474: oJumpForward 3479
3476: Choice Lookup Table
           1   3473
3479: oCodePop
3480: oJumpForward 3485
3482: Choice Lookup Table
           7   3391
3485: oGetLocal 1
3487: oPushResult
3488: oNodeVecDelete
3489: oPop 1
3491: oInput 6
3493: oJumpForward 3500
3495: Choice Lookup Table
           0   3273
3498: oJumpForward 3502
3500: oJumpBack 3271
3502: oReturn
3503: oLocalSpace 2
3505: oInputChoice 3512
3507: oJumpForward 3518
3509: oChangeIntLitToLabelIdent
3510: oJumpForward 3518
3512: Choice Lookup Table
           1   3509
           0   3507
3517: oEndChoice
3518: oGetAddrLocal 1
3520: oPushResult
3521: oSetResult 27
3523: oPushResult
3524: LAST_ID
3525: oPushResult
3526: oCall 14430
3528: oPop 2
3530: oAssign
3531: oGetAddrLocal 2
3533: oPushResult
3534: oLabelNew
3535: oAssign
3536: oGetLocal 1
3538: oPushResult
3539: oSetResult 22
3541: oPushResult
3542: oGetLocal 2
3544: oPushResult
3545: oNodeSetLabel
3546: oPop 3
3548: oGetLocal 1
3550: oPushResult
3551: oScopeDeclare
3552: oPop 1
3554: oInputChoice 3558
3556: oJumpForward 3563
3558: Choice Lookup Table
          14   3556
3561: oJumpForward 3565
3563: oJumpBack 3505
3565: oInput 6
3567: oReturn
3568: oLocalSpace 0
3570: oCall 3825
3572: oInputChoice 3784
3574: oCall 3848
3576: oCall 4363
3578: oTypeSNodeType
3579: oChoice 3594
3581: oValueStringCmp
3582: oSetResult 0
3584: oPushResult
3585: oValuePush
3586: oPop 1
3588: oValueEqual
3589: oJumpForward 3600
3591: oValueEqualD
3592: oJumpForward 3600
3594: Choice Lookup Table
          33   3591
          42   3581
3599: oValueEqual
3600: oTypeSPop
3601: oGetGlobal 7
3603: oPushResult
3604: oTypeSPush
3605: oPop 1
3607: oJumpForward 3799
3609: oCall 3825
3611: oCall 4363
3613: oTypeSNodeType
3614: oChoice 3629
3616: oValueStringCmp
3617: oSetResult 0
3619: oPushResult
3620: oValuePush
3621: oPop 1
3623: oValueNotEqual
3624: oJumpForward 3635
3626: oValueNotEqualD
3627: oJumpForward 3635
3629: Choice Lookup Table
          33   3626
          42   3616
3634: oValueNotEqual
3635: oTypeSPop
3636: oGetGlobal 7
3638: oPushResult
3639: oTypeSPush
3640: oPop 1
3642: oJumpForward 3799
3644: oCall 3825
3646: oCall 4363
3648: oTypeSNodeType
3649: oChoice 3664
3651: oValueStringCmp
3652: oSetResult 0
3654: oPushResult
3655: oValuePush
3656: oPop 1
3658: oValueLess
3659: oJumpForward 3670
3661: oValueLessD
3662: oJumpForward 3670
3664: Choice Lookup Table
          33   3661
          42   3651
3669: oValueLess
3670: oTypeSPop
3671: oGetGlobal 7
3673: oPushResult
3674: oTypeSPush
3675: oPop 1
3677: oJumpForward 3799
3679: oCall 3825
3681: oCall 4363
3683: oTypeSNodeType
3684: oChoice 3699
3686: oValueStringCmp
3687: oSetResult 0
3689: oPushResult
3690: oValuePush
3691: oPop 1
3693: oValueGreater
3694: oJumpForward 3705
3696: oValueGreaterD
3697: oJumpForward 3705
3699: Choice Lookup Table
          33   3696
          42   3686
3704: oValueGreater
3705: oTypeSPop
3706: oGetGlobal 7
3708: oPushResult
3709: oTypeSPush
3710: oPop 1
3712: oJumpForward 3799
3714: oCall 3825
3716: oCall 4363
3718: oTypeSNodeType
3719: oChoice 3734
3721: oValueStringCmp
3722: oSetResult 0
3724: oPushResult
3725: oValuePush
3726: oPop 1
3728: oValueLessEqual
3729: oJumpForward 3740
3731: oValueLessEqualD
3732: oJumpForward 3740
3734: Choice Lookup Table
          33   3731
          42   3721
3739: oValueLessEqual
3740: oTypeSPop
3741: oGetGlobal 7
3743: oPushResult
3744: oTypeSPush
3745: oPop 1
3747: oJumpForward 3799
3749: oCall 3825
3751: oCall 4363
3753: oTypeSNodeType
3754: oChoice 3769
3756: oValueStringCmp
3757: oSetResult 0
3759: oPushResult
3760: oValuePush
3761: oPop 1
3763: oValueGreaterEqual
3764: oJumpForward 3775
3766: oValueGreaterEqualD
3767: oJumpForward 3775
3769: Choice Lookup Table
          33   3766
          42   3756
3774: oValueGreaterEqual
3775: oTypeSPop
3776: oGetGlobal 7
3778: oPushResult
3779: oTypeSPush
3780: oPop 1
3782: oJumpForward 3799
3784: Choice Lookup Table
          12   3749
          11   3714
          10   3679
           9   3644
           8   3609
           7   3574
3797: oJumpForward 3801
3799: oJumpBack 3572
3801: oReturn
3802: oLocalSpace 1
3804: oGetAddrLocal 1
3806: oPushResult
3807: oGetGlobal 25
3809: oAssign
3810: oGetAddrGlobal 25
3812: oPushResult
3813: oSetResult 1
3815: oAssign
3816: oCall 3568
3818: oGetAddrGlobal 25
3820: oPushResult
3821: oGetLocal 1
3823: oAssign
3824: oReturn
3825: oLocalSpace 0
3827: oCall 3848
3829: oInputChoice 3840
3831: oCall 4350
3833: oCall 3848
3835: oCall 4336
3837: oValueOr
3838: oJumpForward 3845
3840: Choice Lookup Table
          58   3831
3843: oJumpForward 3847
3845: oJumpBack 3829
3847: oReturn
3848: oLocalSpace 0
3850: oCall 3871
3852: oInputChoice 3863
3854: oCall 4350
3856: oCall 3871
3858: oCall 4336
3860: oValueAnd
3861: oJumpForward 3868
3863: Choice Lookup Table
          57   3854
3866: oJumpForward 3870
3868: oJumpBack 3852
3870: oReturn
3871: oLocalSpace 0
3873: oInputChoice 3882
3875: oCall 3871
3877: oCall 4350
3879: oValueNot
3880: oJumpForward 3887
3882: Choice Lookup Table
          59   3875
3885: oCall 3888
3887: oReturn
3888: oLocalSpace 0
3890: oCall 3947
3892: oInputChoice 3937
3894: oCall 3947
3896: oCall 4363
3898: oTypeSNodeType
3899: oChoice 3907
3901: oValueStringConcat
3902: oJumpForward 3913
3904: oValueAddD
3905: oJumpForward 3913
3907: Choice Lookup Table
          33   3904
          42   3901
3912: oValueAdd
3913: oJumpForward 3944
3915: oCall 3947
3917: oCall 4363
3919: oTypeSNodeType
3920: oChoice 3929
3922: oError 18
3924: oJumpForward 3935
3926: oValueSubD
3927: oJumpForward 3935
3929: Choice Lookup Table
          33   3926
          42   3922
3934: oValueSub
3935: oJumpForward 3944
3937: Choice Lookup Table
          26   3915
          25   3894
3942: oJumpForward 3946
3944: oJumpBack 3892
3946: oReturn
3947: oLocalSpace 0
3949: oCall 4007
3951: oInputChoice 3997
3953: oCall 4007
3955: oCall 4363
3957: oTypeSNodeType
3958: oChoice 3967
3960: oError 18
3962: oJumpForward 3973
3964: oValueMultD
3965: oJumpForward 3973
3967: Choice Lookup Table
          33   3964
          42   3960
3972: oValueMult
3973: oJumpForward 4004
3975: oCall 4007
3977: oCall 4363
3979: oTypeSNodeType
3980: oChoice 3989
3982: oError 18
3984: oJumpForward 3995
3986: oValueDivD
3987: oJumpForward 3995
3989: Choice Lookup Table
          33   3986
          42   3982
3994: oValueDiv
3995: oJumpForward 4004
3997: Choice Lookup Table
          24   3975
          23   3953
4002: oJumpForward 4006
4004: oJumpBack 3951
4006: oReturn
4007: oLocalSpace 0
4009: oInputChoice 4035
4011: oCall 4043
4013: oJumpForward 4042
4015: oCall 4043
4017: oTypeSNodeType
4018: oChoice 4027
4020: oError 18
4022: oJumpForward 4033
4024: oValueNegateD
4025: oJumpForward 4033
4027: Choice Lookup Table
          33   4024
          42   4020
4032: oValueNegate
4033: oJumpForward 4042
4035: Choice Lookup Table
          26   4015
          25   4011
4040: oCall 4043
4042: oReturn
4043: oLocalSpace 1
4045: oInputChoice 4306
4047: TOKEN_VALUE
4048: oPushResult
4049: oValuePush
4050: oPop 1
4052: oGetGlobal 6
4054: oPushResult
4055: oTypeSPush
4056: oPop 1
4058: oJumpForward 4335
4060: TOKEN_VALUE
4061: oPushResult
4062: oValuePush
4063: oPop 1
4065: oGetGlobal 9
4067: oPushResult
4068: oTypeSPush
4069: oPop 1
4071: oJumpForward 4335
4073: TOKEN_VALUE_DOUBLE
4074: oPushResult
4075: oValuePushDouble
4076: oPop 1
4078: oGetGlobal 13
4080: oPushResult
4081: oTypeSPush
4082: oPop 1
4084: oJumpForward 4335
4086: CURRENT_STRLIT
4087: oPushResult
4088: oValuePushString
4089: oPop 1
4091: oGetGlobal 15
4093: oPushResult
4094: oTypeSPush
4095: oPop 1
4097: oJumpForward 4335
4099: oCall 3568
4101: oInput 16
4103: oJumpForward 4335
4105: oGetAddrLocal 1
4107: oPushResult
4108: oScopeFindRequire
4109: oAssign
4110: oGetAddrLocal 1
4112: oPushResult
4113: oCall 244
4115: oPop 1
4117: oGetLocal 1
4119: oPushResult
4120: oNodeType
4121: oPop 1
4123: oChoice 4263
4125: oGetLocal 1
4127: oPushResult
4128: oCall 4758
4130: oPop 1
4132: oJumpForward 4288
4134: oGetLocal 1
4136: oPushResult
4137: oSetResult 22
4139: oPushResult
4140: oNodeGetInt
4141: oPop 2
4143: oPushResult
4144: oValuePush
4145: oPop 1
4147: oGetLocal 1
4149: oPushResult
4150: oSetResult 21
4152: oPushResult
4153: oNodeGet
4154: oPop 2
4156: oPushResult
4157: oTypeSPush
4158: oPop 1
4160: oJumpForward 4288
4162: oGetLocal 1
4164: oPushResult
4165: oSetResult 33
4167: oPushResult
4168: oNodeGetString
4169: oPop 2
4171: oPushResult
4172: oValuePushString
4173: oPop 1
4175: oGetLocal 1
4177: oPushResult
4178: oSetResult 21
4180: oPushResult
4181: oNodeGet
4182: oPop 2
4184: oPushResult
4185: oTypeSPush
4186: oPop 1
4188: oJumpForward 4288
4190: oGetLocal 1
4192: oPushResult
4193: oSetResult 22
4195: oPushResult
4196: oNodeGetInt
4197: oPop 2
4199: oPushResult
4200: oValuePush
4201: oPop 1
4203: oGetLocal 1
4205: oPushResult
4206: oSetResult 21
4208: oPushResult
4209: oNodeGet
4210: oPop 2
4212: oPushResult
4213: oTypeSPush
4214: oPop 1
4216: oJumpForward 4288
4218: oGetLocal 1
4220: oPushResult
4221: oSetResult 21
4223: oPushResult
4224: oNodeGet
4225: oPop 2
4227: oPushResult
4228: oTypeSPush
4229: oPop 1
4231: oInputChoice 4241
4233: oCall 3568
4235: oInput 16
4237: oCall 4581
4239: oJumpForward 4261
4241: Choice Lookup Table
          15   4233
4244: oGetGlobal 25
4246: oChoice 4256
4248: oSetResult 0
4250: oPushResult
4251: oValuePush
4252: oPop 1
4254: oJumpForward 4261
4256: Choice Lookup Table
           1   4248
4259: oError 32
4261: oJumpForward 4288
4263: Choice Lookup Table
          20   4218
          17   4190
          18   4162
          16   4134
          14   4125
4274: oError 1
4276: oSetResult 0
4278: oPushResult
4279: oValuePush
4280: oPop 1
4282: oGetGlobal 6
4284: oPushResult
4285: oTypeSPush
4286: oPop 1
4288: oJumpForward 4335
4290: oError 17
4292: oSetResult 0
4294: oPushResult
4295: oValuePush
4296: oPop 1
4298: oGetGlobal 14
4300: oPushResult
4301: oTypeSPush
4302: oPop 1
4304: oJumpForward 4335
4306: Choice Lookup Table
          20   4290
           0   4105
          15   4099
           3   4086
           2   4073
           4   4060
           1   4047
4321: oError 1
4323: oSetResult 0
4325: oPushResult
4326: oValuePush
4327: oPop 1
4329: oGetGlobal 6
4331: oPushResult
4332: oTypeSPush
4333: oPop 1
4335: oReturn
4336: oLocalSpace 0
4338: oTypeSNodeType
4339: oChoice 4343
4341: oJumpForward 4348
4343: Choice Lookup Table
          34   4341
4346: oError 8
4348: oTypeSPop
4349: oReturn
4350: oLocalSpace 0
4352: oTypeSNodeType
4353: oChoice 4357
4355: oJumpForward 4362
4357: Choice Lookup Table
          34   4355
4360: oError 8
4362: oReturn
4363: oLocalSpace 1
4365: oGetAddrLocal 1
4367: oPushResult
4368: oTypeSNodeType
4369: oAssign
4370: oTypeSPop
4371: oGetLocal 1
4373: oPushResult
4374: oTypeSNodeType
4375: oPushResult
4376: equal_node_type
4377: oPop 2
4379: oChoice 4456
4381: oTypeSNodeType
4382: oChoice 4443
4384: oGetLocal 1
4386: oChoice 4391
4388: oReturn
4389: oJumpForward 4394
4391: Choice Lookup Table
          38   4388
4394: oJumpForward 4452
4396: oGetLocal 1
4398: oChoice 4403
4400: oReturn
4401: oJumpForward 4406
4403: Choice Lookup Table
          37   4400
4406: oJumpForward 4452
4408: oGetLocal 1
4410: oChoice 4416
4412: oValueCharToString
4413: oReturn
4414: oJumpForward 4419
4416: Choice Lookup Table
          36   4412
4419: oJumpForward 4452
4421: oGetLocal 1
4423: oChoice 4438
4425: oValueSwap
4426: oValueCharToString
4427: oValueSwap
4428: oTypeSPop
4429: oGetGlobal 15
4431: oPushResult
4432: oTypeSPush
4433: oPop 1
4435: oReturn
4436: oJumpForward 4441
4438: Choice Lookup Table
          42   4425
4441: oJumpForward 4452
4443: Choice Lookup Table
          36   4421
          42   4408
          38   4396
          37   4384
4452: oError 15
4454: oJumpForward 4459
4456: Choice Lookup Table
           0   4381
4459: oReturn
4460: oLocalSpace 1
4462: oGetAddrLocal 1
4464: oPushResult
4465: oTypeSNodeType
4466: oAssign
4467: oTypeSPop
4468: oGetLocal 1
4470: oPushResult
4471: oTypeSNodeType
4472: oPushResult
4473: equal_node_type
4474: oPop 2
4476: oChoice 4577
4478: oTypeSNodeType
4479: oChoice 4560
4481: oGetLocal 1
4483: oChoice 4488
4485: oReturn
4486: oJumpForward 4491
4488: Choice Lookup Table
          30   4485
4491: oJumpForward 4573
4493: oGetLocal 1
4495: oChoice 4500
4497: oReturn
4498: oJumpForward 4503
4500: Choice Lookup Table
          31   4497
4503: oJumpForward 4573
4505: oGetLocal 1
4507: oChoice 4512
4509: oReturn
4510: oJumpForward 4515
4512: Choice Lookup Table
          38   4509
4515: oJumpForward 4573
4517: oGetLocal 1
4519: oChoice 4524
4521: oReturn
4522: oJumpForward 4527
4524: Choice Lookup Table
          37   4521
4527: oJumpForward 4573
4529: oGetLocal 1
4531: oChoice 4537
4533: oValueCharToString
4534: oReturn
4535: oJumpForward 4540
4537: Choice Lookup Table
          36   4533
4540: oJumpForward 4573
4542: oGetLocal 1
4544: oChoice 4553
4546: oReturn
4547: oJumpForward 4558
4549: oValueCharToString
4550: oReturn
4551: oJumpForward 4558
4553: Choice Lookup Table
          36   4549
          42   4546
4558: oJumpForward 4573
4560: Choice Lookup Table
          43   4542
          42   4529
          38   4517
          37   4505
          30   4493
          31   4481
4573: oError 15
4575: oJumpForward 4580
4577: Choice Lookup Table
           0   4478
4580: oReturn
4581: oLocalSpace 1
4583: oGetAddrLocal 1
4585: oPushResult
4586: oTypeSNodeType
4587: oAssign
4588: oTypeSPop
4589: oGetLocal 1
4591: oPushResult
4592: oTypeSNodeType
4593: oPushResult
4594: equal_node_type
4595: oPop 2
4597: oChoice 4754
4599: oTypeSNodeType
4600: oChoice 4729
4602: oGetLocal 1
4604: oChoice 4612
4606: oReturn
4607: oJumpForward 4623
4609: oReturn
4610: oJumpForward 4623
4612: Choice Lookup Table
          44   4609
          31   4609
          34   4606
          36   4606
          30   4606
4623: oJumpForward 4750
4625: oGetLocal 1
4627: oChoice 4635
4629: oReturn
4630: oJumpForward 4646
4632: oReturn
4633: oJumpForward 4646
4635: Choice Lookup Table
          44   4632
          31   4632
          34   4629
          36   4629
          30   4629
4646: oJumpForward 4750
4648: oGetLocal 1
4650: oChoice 4659
4652: oValueIntToDouble
4653: oReturn
4654: oJumpForward 4672
4656: oReturn
4657: oJumpForward 4672
4659: Choice Lookup Table
          33   4656
          44   4652
          31   4652
          34   4652
          36   4652
          30   4652
4672: oJumpForward 4750
4674: oGetLocal 1
4676: oChoice 4681
4678: oReturn
4679: oJumpForward 4684
4681: Choice Lookup Table
          38   4678
4684: oJumpForward 4750
4686: oGetLocal 1
4688: oChoice 4693
4690: oReturn
4691: oJumpForward 4696
4693: Choice Lookup Table
          37   4690
4696: oJumpForward 4750
4698: oGetLocal 1
4700: oChoice 4706
4702: oValueCharToString
4703: oReturn
4704: oJumpForward 4709
4706: Choice Lookup Table
          36   4702
4709: oJumpForward 4750
4711: oGetLocal 1
4713: oChoice 4722
4715: oReturn
4716: oJumpForward 4727
4718: oValueCharToString
4719: oReturn
4720: oJumpForward 4727
4722: Choice Lookup Table
          36   4718
          42   4715
4727: oJumpForward 4750
4729: Choice Lookup Table
          43   4711
          42   4698
          38   4686
          37   4674
          33   4648
          34   4625
          36   4625
          30   4625
          44   4602
          31   4602
4750: oError 15
4752: oJumpForward 4757
4754: Choice Lookup Table
           0   4599
4757: oReturn
4758: oLocalSpace 1
4760: oGetParam 1
4762: oPushResult
4763: oGetGlobal 17
4765: oPushResult
4766: oNodeEqual
4767: oPop 2
4769: oChoice 4809
4771: oInput 15
4773: oCall 3568
4775: oInput 16
4777: oTypeSNodeType
4778: oChoice 4784
4780: oJumpForward 4797
4782: oJumpForward 4797
4784: Choice Lookup Table
          36   4782
          30   4782
          34   4782
          44   4780
          31   4780
4795: oError 15
4797: oTypeSPop
4798: oGetGlobal 6
4800: oPushResult
4801: oTypeSPush
4802: oPop 1
4804: oInput 16
4806: oReturn
4807: oJumpForward 4812
4809: Choice Lookup Table
           1   4771
4812: oGetParam 1
4814: oPushResult
4815: oGetGlobal 18
4817: oPushResult
4818: oNodeEqual
4819: oPop 2
4821: oChoice 4855
4823: oInput 15
4825: oCall 3568
4827: oInput 16
4829: oTypeSNodeType
4830: oChoice 4836
4832: oJumpForward 4843
4834: oJumpForward 4843
4836: Choice Lookup Table
          30   4834
          31   4832
4841: oError 15
4843: oTypeSPop
4844: oGetGlobal 9
4846: oPushResult
4847: oTypeSPush
4848: oPop 1
4850: oInput 16
4852: oReturn
4853: oJumpForward 4858
4855: Choice Lookup Table
           1   4823
4858: oGetParam 1
4860: oPushResult
4861: oGetGlobal 19
4863: oPushResult
4864: oNodeEqual
4865: oPop 2
4867: oChoice 4912
4869: oInput 15
4871: oCall 3568
4873: oTypeSNodeType
4874: oChoice 4895
4876: oTypeSTop
4877: oPushResult
4878: oSetResult 45
4880: oPushResult
4881: oNodeGetBoolean
4882: oPop 2
4884: oChoice 4890
4886: oError 29
4888: oJumpForward 4893
4890: Choice Lookup Table
           1   4886
4893: oJumpForward 4900
4895: Choice Lookup Table
          44   4876
4898: oError 15
4900: oSetResult 1
4902: oPushResult
4903: oValuePush
4904: oPop 1
4906: oValueSub
4907: oInput 16
4909: oReturn
4910: oJumpForward 4915
4912: Choice Lookup Table
           1   4869
4915: oGetParam 1
4917: oPushResult
4918: oGetGlobal 20
4920: oPushResult
4921: oNodeEqual
4922: oPop 2
4924: oChoice 4969
4926: oInput 15
4928: oCall 3568
4930: oTypeSNodeType
4931: oChoice 4952
4933: oTypeSTop
4934: oPushResult
4935: oSetResult 45
4937: oPushResult
4938: oNodeGetBoolean
4939: oPop 2
4941: oChoice 4947
4943: oError 29
4945: oJumpForward 4950
4947: Choice Lookup Table
           1   4943
4950: oJumpForward 4957
4952: Choice Lookup Table
          44   4933
4955: oError 15
4957: oSetResult 1
4959: oPushResult
4960: oValuePush
4961: oPop 1
4963: oValueAdd
4964: oInput 16
4966: oReturn
4967: oJumpForward 4972
4969: Choice Lookup Table
           1   4926
4972: oGetParam 1
4974: oPushResult
4975: oGetGlobal 21
4977: oPushResult
4978: oNodeEqual
4979: oPop 2
4981: oChoice 5018
4983: oInput 15
4985: oCall 3802
4987: oValuePop
4988: oGetAddrLocal 1
4990: oPushResult
4991: oTypeSTop
4992: oAssign
4993: oTypeSPop
4994: oGetLocal 1
4996: oPushResult
4997: oSetResult 17
4999: oPushResult
5000: oNodeGetInt
5001: oPop 2
5003: oPushResult
5004: oValuePush
5005: oPop 1
5007: oGetGlobal 6
5009: oPushResult
5010: oTypeSPush
5011: oPop 1
5013: oInput 16
5015: oReturn
5016: oJumpForward 5021
5018: Choice Lookup Table
           1   4983
5021: oError 17
5023: oReturn
5024: oLocalSpace 1
5026: oGetAddrLocal 1
5028: oPushResult
5029: oSetResult 0
5031: oAssign
5032: oGetAddrLocal 1
5034: oPushResult
5035: oCall 5208
5037: oPop 1
5039: oGetAddrLocal 1
5041: oPushResult
5042: oCall 5108
5044: oPop 1
5046: oReturn
5047: oLocalSpace 1
5049: oGetAddrLocal 1
5051: oPushResult
5052: oGetGlobal 25
5054: oAssign
5055: oGetAddrGlobal 25
5057: oPushResult
5058: oSetResult 1
5060: oAssign
5061: oCall 5024
5063: oGetAddrGlobal 25
5065: oPushResult
5066: oGetLocal 1
5068: oAssign
5069: oReturn
5070: oLocalSpace 0
5072: oGetParam 1
5074: oPushResult
5075: oCall 5208
5077: oPop 1
5079: oTypeSNodeType
5080: oChoice 5099
5082: oJumpForward 5106
5084: oGetParam 1
5086: oPushResult
5087: oLabelNew
5088: oAssign
5089: oEmit 82
5091: oGetFromParam 1
5093: oPushResult
5094: oEmitLabel
5095: oPop 1
5097: oJumpForward 5106
5099: Choice Lookup Table
          34   5084
          35   5082
5104: oError 8
5106: oTypeSPop
5107: oReturn
5108: oLocalSpace 1
5110: oTypeSNodeType
5111: oChoice 5173
5113: oGetAddrLocal 1
5115: oPushResult
5116: oLabelNew
5117: oAssign
5118: oEmit 15
5120: oSetResult 1
5122: oPushResult
5123: oEmitInt
5124: oPop 1
5126: oEmit 80
5128: oGetLocal 1
5130: oPushResult
5131: oEmitLabel
5132: oPop 1
5134: oEmit 89
5136: oGetFromParam 1
5138: oPushResult
5139: oEmitLabel
5140: oPop 1
5142: oEmit 15
5144: oSetResult 0
5146: oPushResult
5147: oEmitInt
5148: oPop 1
5150: oEmit 89
5152: oGetLocal 1
5154: oPushResult
5155: oEmitLabel
5156: oPop 1
5158: oTypeSPop
5159: oGetGlobal 7
5161: oPushResult
5162: oTypeSPush
5163: oPop 1
5165: oGetParam 1
5167: oPushResult
5168: oSetResult 0
5170: oAssign
5171: oJumpForward 5176
5173: Choice Lookup Table
          35   5113
5176: oReturn
5177: oLocalSpace 0
5179: oTypeSNodeType
5180: oChoice 5204
5182: oGetParam 1
5184: oPushResult
5185: oLabelNew
5186: oAssign
5187: oEmit 82
5189: oGetFromParam 1
5191: oPushResult
5192: oEmitLabel
5193: oPop 1
5195: oTypeSPop
5196: oGetGlobal 8
5198: oPushResult
5199: oTypeSPush
5200: oPop 1
5202: oJumpForward 5207
5204: Choice Lookup Table
          34   5182
5207: oReturn
5208: oLocalSpace 0
5210: oGetParam 1
5212: oPushResult
5213: oCall 5741
5215: oPop 1
5217: oInputChoice 5723
5219: oGetParam 1
5221: oPushResult
5222: oCall 5108
5224: oPop 1
5226: oCall 9054
5228: oGetParam 1
5230: oPushResult
5231: oCall 5741
5233: oPop 1
5235: oGetParam 1
5237: oPushResult
5238: oCall 5108
5240: oPop 1
5242: oCall 9054
5244: oCall 8923
5246: oTypeSNodeType
5247: oChoice 5275
5249: oEmit 51
5251: oJumpForward 5294
5253: oEmit 57
5255: oJumpForward 5294
5257: oEmit 63
5259: oJumpForward 5294
5261: oCall 11324
5263: oEmit 15
5265: oSetResult 0
5267: oPushResult
5268: oEmitInt
5269: oPop 1
5271: oEmit 57
5273: oJumpForward 5294
5275: Choice Lookup Table
          42   5261
          43   5261
          38   5257
          37   5257
          44   5253
          31   5253
          36   5249
          34   5249
5292: oError 18
5294: oTypeSPop
5295: oGetGlobal 7
5297: oPushResult
5298: oTypeSPush
5299: oPop 1
5301: oJumpForward 5738
5303: oGetParam 1
5305: oPushResult
5306: oCall 5108
5308: oPop 1
5310: oCall 9054
5312: oGetParam 1
5314: oPushResult
5315: oCall 5741
5317: oPop 1
5319: oGetParam 1
5321: oPushResult
5322: oCall 5108
5324: oPop 1
5326: oCall 9054
5328: oCall 8923
5330: oTypeSNodeType
5331: oChoice 5359
5333: oEmit 52
5335: oJumpForward 5378
5337: oEmit 58
5339: oJumpForward 5378
5341: oEmit 64
5343: oJumpForward 5378
5345: oCall 11324
5347: oEmit 15
5349: oSetResult 0
5351: oPushResult
5352: oEmitInt
5353: oPop 1
5355: oEmit 58
5357: oJumpForward 5378
5359: Choice Lookup Table
          42   5345
          43   5345
          38   5341
          37   5341
          44   5337
          31   5337
          36   5333
          34   5333
5376: oError 18
5378: oTypeSPop
5379: oGetGlobal 7
5381: oPushResult
5382: oTypeSPush
5383: oPop 1
5385: oJumpForward 5738
5387: oGetParam 1
5389: oPushResult
5390: oCall 5108
5392: oPop 1
5394: oCall 9054
5396: oGetParam 1
5398: oPushResult
5399: oCall 5741
5401: oPop 1
5403: oGetParam 1
5405: oPushResult
5406: oCall 5108
5408: oPop 1
5410: oCall 9054
5412: oCall 8923
5414: oTypeSNodeType
5415: oChoice 5443
5417: oEmit 54
5419: oJumpForward 5462
5421: oEmit 60
5423: oJumpForward 5462
5425: oEmit 66
5427: oJumpForward 5462
5429: oCall 11324
5431: oEmit 15
5433: oSetResult 0
5435: oPushResult
5436: oEmitInt
5437: oPop 1
5439: oEmit 60
5441: oJumpForward 5462
5443: Choice Lookup Table
          42   5429
          43   5429
          38   5425
          37   5425
          44   5421
          31   5421
          36   5417
          34   5417
5460: oError 18
5462: oTypeSPop
5463: oGetGlobal 7
5465: oPushResult
5466: oTypeSPush
5467: oPop 1
5469: oJumpForward 5738
5471: oGetParam 1
5473: oPushResult
5474: oCall 5108
5476: oPop 1
5478: oCall 9054
5480: oGetParam 1
5482: oPushResult
5483: oCall 5741
5485: oPop 1
5487: oGetParam 1
5489: oPushResult
5490: oCall 5108
5492: oPop 1
5494: oCall 9054
5496: oCall 8923
5498: oTypeSNodeType
5499: oChoice 5527
5501: oEmit 53
5503: oJumpForward 5546
5505: oEmit 59
5507: oJumpForward 5546
5509: oEmit 65
5511: oJumpForward 5546
5513: oCall 11324
5515: oEmit 15
5517: oSetResult 0
5519: oPushResult
5520: oEmitInt
5521: oPop 1
5523: oEmit 59
5525: oJumpForward 5546
5527: Choice Lookup Table
          42   5513
          43   5513
          38   5509
          37   5509
          44   5505
          31   5505
          36   5501
          34   5501
5544: oError 18
5546: oTypeSPop
5547: oGetGlobal 7
5549: oPushResult
5550: oTypeSPush
5551: oPop 1
5553: oJumpForward 5738
5555: oGetParam 1
5557: oPushResult
5558: oCall 5108
5560: oPop 1
5562: oCall 9054
5564: oGetParam 1
5566: oPushResult
5567: oCall 5741
5569: oPop 1
5571: oGetParam 1
5573: oPushResult
5574: oCall 5108
5576: oPop 1
5578: oCall 9054
5580: oCall 8923
5582: oTypeSNodeType
5583: oChoice 5611
5585: oEmit 56
5587: oJumpForward 5630
5589: oEmit 62
5591: oJumpForward 5630
5593: oEmit 68
5595: oJumpForward 5630
5597: oCall 11324
5599: oEmit 15
5601: oSetResult 0
5603: oPushResult
5604: oEmitInt
5605: oPop 1
5607: oEmit 62
5609: oJumpForward 5630
5611: Choice Lookup Table
          42   5597
          43   5597
          38   5593
          37   5593
          44   5589
          31   5589
          36   5585
          34   5585
5628: oError 18
5630: oTypeSPop
5631: oGetGlobal 7
5633: oPushResult
5634: oTypeSPush
5635: oPop 1
5637: oJumpForward 5738
5639: oGetParam 1
5641: oPushResult
5642: oCall 5108
5644: oPop 1
5646: oCall 9054
5648: oGetParam 1
5650: oPushResult
5651: oCall 5741
5653: oPop 1
5655: oGetParam 1
5657: oPushResult
5658: oCall 5108
5660: oPop 1
5662: oCall 9054
5664: oCall 8923
5666: oTypeSNodeType
5667: oChoice 5695
5669: oEmit 55
5671: oJumpForward 5714
5673: oEmit 61
5675: oJumpForward 5714
5677: oEmit 67
5679: oJumpForward 5714
5681: oCall 11324
5683: oEmit 15
5685: oSetResult 0
5687: oPushResult
5688: oEmitInt
5689: oPop 1
5691: oEmit 61
5693: oJumpForward 5714
5695: Choice Lookup Table
          42   5681
          43   5681
          38   5677
          37   5677
          44   5673
          31   5673
          36   5669
          34   5669
5712: oError 18
5714: oTypeSPop
5715: oGetGlobal 7
5717: oPushResult
5718: oTypeSPush
5719: oPop 1
5721: oJumpForward 5738
5723: Choice Lookup Table
          12   5639
          11   5555
          10   5471
           9   5387
           8   5303
           7   5219
5736: oJumpForward 5740
5738: oJumpBack 5217
5740: oReturn
5741: oLocalSpace 1
5743: oGetAddrLocal 1
5745: oPushResult
5746: oSetResult 0
5748: oAssign
5749: oGetParam 1
5751: oPushResult
5752: oCall 5921
5754: oPop 1
5756: oInputChoice 5889
5758: oTypeSNodeType
5759: oChoice 5830
5761: oGetLocal 1
5763: oPushResult
5764: oSetResult 0
5766: oPushResult
5767: equal_label
5768: oPop 2
5770: oChoice 5779
5772: oGetAddrLocal 1
5774: oPushResult
5775: oLabelNew
5776: oAssign
5777: oJumpForward 5782
5779: Choice Lookup Table
           1   5772
5782: oEmit 80
5784: oGetLocal 1
5786: oPushResult
5787: oEmitLabel
5788: oPop 1
5790: oJumpForward 5837
5792: oGetParam 1
5794: oPushResult
5795: oCall 5177
5797: oPop 1
5799: oGetLocal 1
5801: oPushResult
5802: oSetResult 0
5804: oPushResult
5805: equal_label
5806: oPop 2
5808: oChoice 5817
5810: oGetAddrLocal 1
5812: oPushResult
5813: oLabelNew
5814: oAssign
5815: oJumpForward 5820
5817: Choice Lookup Table
           1   5810
5820: oEmit 80
5822: oGetLocal 1
5824: oPushResult
5825: oEmitLabel
5826: oPop 1
5828: oJumpForward 5837
5830: Choice Lookup Table
          34   5792
          35   5761
5835: oError 8
5837: oTypeSPop
5838: oEmit 89
5840: oGetFromParam 1
5842: oPushResult
5843: oEmitLabel
5844: oPop 1
5846: oGetParam 1
5848: oPushResult
5849: oSetResult 0
5851: oAssign
5852: oGetParam 1
5854: oPushResult
5855: oCall 5921
5857: oPop 1
5859: oTypeSNodeType
5860: oChoice 5873
5862: oJumpForward 5880
5864: oGetParam 1
5866: oPushResult
5867: oCall 5177
5869: oPop 1
5871: oJumpForward 5880
5873: Choice Lookup Table
          34   5864
          35   5862
5878: oError 8
5880: oTypeSPop
5881: oGetGlobal 8
5883: oPushResult
5884: oTypeSPush
5885: oPop 1
5887: oJumpForward 5894
5889: Choice Lookup Table
          58   5758
5892: oJumpForward 5896
5894: oJumpBack 5756
5896: oGetLocal 1
5898: oPushResult
5899: oSetResult 0
5901: oPushResult
5902: equal_label
5903: oPop 2
5905: oChoice 5917
5907: oEmit 89
5909: oGetLocal 1
5911: oPushResult
5912: oEmitLabel
5913: oPop 1
5915: oJumpForward 5920
5917: Choice Lookup Table
           0   5907
5920: oReturn
5921: oLocalSpace 2
5923: oGetAddrLocal 1
5925: oPushResult
5926: oSetResult 0
5928: oAssign
5929: oGetParam 1
5931: oPushResult
5932: oCall 6059
5934: oPop 1
5936: oInputChoice 6051
5938: oTypeSNodeType
5939: oChoice 5952
5941: oJumpForward 5959
5943: oGetParam 1
5945: oPushResult
5946: oCall 5177
5948: oPop 1
5950: oJumpForward 5959
5952: Choice Lookup Table
          34   5943
          35   5941
5957: oError 8
5959: oTypeSPop
5960: oGetLocal 1
5962: oPushResult
5963: oSetResult 0
5965: oPushResult
5966: equal_label
5967: oPop 2
5969: oChoice 5998
5971: oGetAddrLocal 1
5973: oPushResult
5974: oLabelNew
5975: oAssign
5976: oEmit 90
5978: oGetFromParam 1
5980: oPushResult
5981: oEmitLabel
5982: oPop 1
5984: oGetLocal 1
5986: oPushResult
5987: oEmitLabel
5988: oPop 1
5990: oGetParam 1
5992: oPushResult
5993: oGetLocal 1
5995: oAssign
5996: oJumpForward 6001
5998: Choice Lookup Table
           1   5971
6001: oGetAddrLocal 2
6003: oPushResult
6004: oSetResult 0
6006: oAssign
6007: oGetAddrLocal 2
6009: oPushResult
6010: oCall 6059
6012: oPop 1
6014: oTypeSNodeType
6015: oChoice 6028
6017: oJumpForward 6035
6019: oGetAddrLocal 2
6021: oPushResult
6022: oCall 5177
6024: oPop 1
6026: oJumpForward 6035
6028: Choice Lookup Table
          34   6019
          35   6017
6033: oError 8
6035: oEmit 90
6037: oGetLocal 2
6039: oPushResult
6040: oEmitLabel
6041: oPop 1
6043: oGetLocal 1
6045: oPushResult
6046: oEmitLabel
6047: oPop 1
6049: oJumpForward 6056
6051: Choice Lookup Table
          57   5938
6054: oJumpForward 6058
6056: oJumpBack 5936
6058: oReturn
6059: oLocalSpace 1
6061: oInputChoice 6115
6063: oGetAddrLocal 1
6065: oPushResult
6066: oSetResult 0
6068: oAssign
6069: oGetAddrLocal 1
6071: oPushResult
6072: oCall 6059
6074: oPop 1
6076: oTypeSNodeType
6077: oChoice 6106
6079: oGetParam 1
6081: oPushResult
6082: oLabelNew
6083: oAssign
6084: oEmit 80
6086: oGetFromParam 1
6088: oPushResult
6089: oEmitLabel
6090: oPop 1
6092: oEmit 89
6094: oGetLocal 1
6096: oPushResult
6097: oEmitLabel
6098: oPop 1
6100: oJumpForward 6113
6102: oEmit 50
6104: oJumpForward 6113
6106: Choice Lookup Table
          34   6102
          35   6079
6111: oError 8
6113: oJumpForward 6125
6115: Choice Lookup Table
          59   6063
6118: oGetParam 1
6120: oPushResult
6121: oCall 6126
6123: oPop 1
6125: oReturn
6126: oLocalSpace 2
6128: oGetAddrLocal 1
6130: oPushResult
6131: oSetResult 1
6133: oAssign
6134: oGetParam 1
6136: oPushResult
6137: oCall 6418
6139: oPop 1
6141: oInputChoice 6408
6143: oTypeSNodeType
6144: oChoice 6290
6146: oCall 9008
6148: oGetParam 1
6150: oPushResult
6151: oCall 6418
6153: oPop 1
6155: oTypeSNodeType
6156: oChoice 6172
6158: oEmit 23
6160: oCall 8371
6162: oJumpForward 6183
6164: oEmit 23
6166: oEmit 34
6168: oEmit 47
6170: oJumpForward 6183
6172: Choice Lookup Table
          33   6164
          38   6158
          37   6158
6179: oCall 9028
6181: oEmit 40
6183: oJumpForward 6309
6185: oGetParam 1
6187: oPushResult
6188: oCall 6418
6190: oPop 1
6192: oCall 9074
6194: oEmit 47
6196: oJumpForward 6309
6198: oGetLocal 1
6200: oChoice 6216
6202: oGetAddrLocal 2
6204: oPushResult
6205: oCall 11107
6207: oAssign
6208: oGetAddrLocal 1
6210: oPushResult
6211: oSetResult 0
6213: oAssign
6214: oJumpForward 6219
6216: Choice Lookup Table
           1   6202
6219: oGetParam 1
6221: oPushResult
6222: oCall 6418
6224: oPop 1
6226: oTypeSNodeType
6227: oChoice 6265
6229: oCall 11216
6231: oEmit 18
6233: oGetLocal 2
6235: oPushResult
6236: oEmitInt
6237: oPop 1
6239: oGetGlobal 16
6241: oPushResult
6242: oTypeSPush
6243: oPop 1
6245: oJumpForward 6275
6247: oCall 11270
6249: oEmit 18
6251: oGetLocal 2
6253: oPushResult
6254: oEmitInt
6255: oPop 1
6257: oGetGlobal 16
6259: oPushResult
6260: oTypeSPush
6261: oPop 1
6263: oJumpForward 6275
6265: Choice Lookup Table
          36   6247
          42   6229
          43   6229
6272: oError 15
6274: oTypeSPop
6275: oJumpForward 6309
6277: oGetParam 1
6279: oPushResult
6280: oCall 6418
6282: oPop 1
6284: oCall 9008
6286: oCall 8371
6288: oJumpForward 6309
6290: Choice Lookup Table
          38   6277
          37   6277
          36   6198
          42   6198
          43   6198
          33   6185
          30   6146
          31   6146
6307: oError 18
6309: oJumpForward 6415
6311: oTypeSNodeType
6312: oChoice 6393
6314: oCall 9008
6316: oGetParam 1
6318: oPushResult
6319: oCall 6418
6321: oPop 1
6323: oTypeSNodeType
6324: oChoice 6336
6326: oEmit 23
6328: oEmit 34
6330: oEmit 23
6332: oEmit 48
6334: oJumpForward 6343
6336: Choice Lookup Table
          33   6326
6339: oCall 9028
6341: oEmit 43
6343: oJumpForward 6406
6345: oGetParam 1
6347: oPushResult
6348: oCall 6418
6350: oPop 1
6352: oCall 9074
6354: oEmit 48
6356: oJumpForward 6406
6358: oGetParam 1
6360: oPushResult
6361: oCall 6418
6363: oPop 1
6365: oTypeSNodeType
6366: oChoice 6380
6368: oCall 9008
6370: oCall 8427
6372: oJumpForward 6391
6374: oCall 8923
6376: oCall 8483
6378: oJumpForward 6391
6380: Choice Lookup Table
          38   6374
          37   6374
          30   6368
          31   6368
6389: oError 18
6391: oJumpForward 6406
6393: Choice Lookup Table
          38   6358
          37   6358
          33   6345
          30   6314
          31   6314
6404: oError 18
6406: oJumpForward 6415
6408: Choice Lookup Table
          26   6311
          25   6143
6413: oJumpForward 6417
6415: oJumpBack 6141
6417: oReturn
6418: oLocalSpace 0
6420: oGetParam 1
6422: oPushResult
6423: oCall 6553
6425: oPop 1
6427: oInputChoice 6543
6429: oTypeSNodeType
6430: oChoice 6474
6432: oCall 9008
6434: oGetParam 1
6436: oPushResult
6437: oCall 6553
6439: oPop 1
6441: oTypeSNodeType
6442: oChoice 6452
6444: oEmit 23
6446: oEmit 34
6448: oEmit 45
6450: oJumpForward 6459
6452: Choice Lookup Table
          33   6444
6455: oCall 9028
6457: oEmit 37
6459: oJumpForward 6483
6461: oGetParam 1
6463: oPushResult
6464: oCall 6553
6466: oPop 1
6468: oCall 9074
6470: oEmit 45
6472: oJumpForward 6483
6474: Choice Lookup Table
          33   6461
          30   6432
          31   6432
6481: oError 18
6483: oJumpForward 6550
6485: oTypeSNodeType
6486: oChoice 6532
6488: oCall 9008
6490: oGetParam 1
6492: oPushResult
6493: oCall 6553
6495: oPop 1
6497: oTypeSNodeType
6498: oChoice 6510
6500: oEmit 23
6502: oEmit 34
6504: oEmit 23
6506: oEmit 46
6508: oJumpForward 6517
6510: Choice Lookup Table
          33   6500
6513: oCall 9028
6515: oEmit 38
6517: oJumpForward 6541
6519: oGetParam 1
6521: oPushResult
6522: oCall 6553
6524: oPop 1
6526: oCall 9074
6528: oEmit 46
6530: oJumpForward 6541
6532: Choice Lookup Table
          33   6519
          30   6488
          31   6488
6539: oError 18
6541: oJumpForward 6550
6543: Choice Lookup Table
          24   6485
          23   6429
6548: oJumpForward 6552
6550: oJumpBack 6427
6552: oReturn
6553: oLocalSpace 0
6555: oInputChoice 6613
6557: oGetParam 1
6559: oPushResult
6560: oCall 6626
6562: oPop 1
6564: oTypeSNodeType
6565: oChoice 6571
6567: oJumpForward 6580
6569: oJumpForward 6580
6571: Choice Lookup Table
          33   6569
          30   6567
          31   6567
6578: oError 18
6580: oJumpForward 6625
6582: oGetParam 1
6584: oPushResult
6585: oCall 6626
6587: oPop 1
6589: oTypeSNodeType
6590: oChoice 6602
6592: oCall 9028
6594: oEmit 44
6596: oJumpForward 6611
6598: oEmit 49
6600: oJumpForward 6611
6602: Choice Lookup Table
          33   6598
          30   6592
          31   6592
6609: oError 18
6611: oJumpForward 6625
6613: Choice Lookup Table
          26   6582
          25   6557
6618: oGetParam 1
6620: oPushResult
6621: oCall 6626
6623: oPop 1
6625: oReturn
6626: oLocalSpace 7
6628: oInputChoice 7132
6630: oEmit 15
6632: TOKEN_VALUE
6633: oPushResult
6634: oEmitInt
6635: oPop 1
6637: oGetGlobal 6
6639: oPushResult
6640: oTypeSPush
6641: oPop 1
6643: oJumpForward 7155
6645: oEmit 15
6647: TOKEN_VALUE
6648: oPushResult
6649: oEmitInt
6650: oPop 1
6652: oGetGlobal 9
6654: oPushResult
6655: oTypeSPush
6656: oPop 1
6658: oJumpForward 7155
6660: oEmit 16
6662: TOKEN_VALUE_DOUBLE
6663: oPushResult
6664: oEmitDouble
6665: oPop 1
6667: oGetGlobal 13
6669: oPushResult
6670: oTypeSPush
6671: oPop 1
6673: oJumpForward 7155
6675: oGetParam 1
6677: oPushResult
6678: oCall 5208
6680: oPop 1
6682: oInput 16
6684: oJumpForward 7155
6686: oGetAddrLocal 1
6688: oPushResult
6689: CURRENT_STRLIT
6690: oPushResult
6691: oStringAllocShortStringLit
6692: oPop 1
6694: oAssign
6695: oEmit 17
6697: oGetLocal 1
6699: oPushResult
6700: oEmitInt
6701: oPop 1
6703: oGetGlobal 15
6705: oPushResult
6706: oTypeSPush
6707: oPop 1
6709: oCall 7969
6711: oCall 7915
6713: oJumpForward 7155
6715: oGetAddrLocal 2
6717: oPushResult
6718: oScopeFindRequire
6719: oAssign
6720: oGetAddrLocal 2
6722: oPushResult
6723: oCall 244
6725: oPop 1
6727: oGetLocal 2
6729: oPushResult
6730: oNodeType
6731: oPop 1
6733: oChoice 7050
6735: oGetLocal 2
6737: oPushResult
6738: oCall 11419
6740: oPop 1
6742: oJumpForward 7081
6744: oGetLocal 2
6746: oPushResult
6747: oCall 12089
6749: oPop 1
6751: oJumpForward 7081
6753: oGetAddrLocal 3
6755: oPushResult
6756: oGetLocal 2
6758: oPushResult
6759: oSetResult 21
6761: oPushResult
6762: oNodeGet
6763: oPop 2
6765: oAssign
6766: oGetLocal 3
6768: oPushResult
6769: oTypeSPush
6770: oPop 1
6772: oTypeSNodeType
6773: oChoice 6797
6775: oEmit 15
6777: oGetLocal 2
6779: oPushResult
6780: oCall 14458
6782: oPop 1
6784: oJumpForward 6814
6786: oEmit 15
6788: oGetLocal 2
6790: oPushResult
6791: oCall 14458
6793: oPop 1
6795: oJumpForward 6814
6797: Choice Lookup Table
          38   6786
          37   6786
          30   6775
          36   6775
          34   6775
          44   6775
          31   6775
6812: oError 17
6814: oJumpForward 7081
6816: oGetAddrLocal 3
6818: oPushResult
6819: oGetLocal 2
6821: oPushResult
6822: oSetResult 21
6824: oPushResult
6825: oNodeGet
6826: oPop 2
6828: oAssign
6829: oGetLocal 3
6831: oPushResult
6832: oTypeSPush
6833: oPop 1
6835: oTypeSNodeType
6836: oChoice 6855
6838: oEmit 16
6840: oGetLocal 2
6842: oPushResult
6843: oSetResult 34
6845: oPushResult
6846: oNodeGetDouble
6847: oPop 2
6849: oPushResult
6850: oEmitDouble
6851: oPop 1
6853: oJumpForward 6860
6855: Choice Lookup Table
          33   6838
6858: oError 17
6860: oJumpForward 7081
6862: oGetAddrLocal 4
6864: oPushResult
6865: oGetLocal 2
6867: oPushResult
6868: oSetResult 22
6870: oPushResult
6871: oNodeGetInt
6872: oPop 2
6874: oAssign
6875: oGetLocal 4
6877: oPushResult
6878: equal_zero
6879: oPop 1
6881: oChoice 6914
6883: oGetAddrLocal 4
6885: oPushResult
6886: oGetLocal 2
6888: oPushResult
6889: oSetResult 33
6891: oPushResult
6892: oNodeGetString
6893: oPop 2
6895: oPushResult
6896: oStringAllocShortStringLit
6897: oPop 1
6899: oAssign
6900: oGetLocal 2
6902: oPushResult
6903: oSetResult 22
6905: oPushResult
6906: oGetLocal 4
6908: oPushResult
6909: oNodeSetInt
6910: oPop 3
6912: oJumpForward 6917
6914: Choice Lookup Table
           1   6883
6917: oEmit 17
6919: oGetLocal 4
6921: oPushResult
6922: oEmitInt
6923: oPop 1
6925: oGetGlobal 15
6927: oPushResult
6928: oTypeSPush
6929: oPop 1
6931: oCall 7969
6933: oCall 7915
6935: oJumpForward 7081
6937: oGetLocal 2
6939: oPushResult
6940: oCall 7156
6942: oPop 1
6944: oJumpForward 7081
6946: oGetLocal 2
6948: oPushResult
6949: oSetResult 21
6951: oPushResult
6952: oNodeGet
6953: oPop 2
6955: oPushResult
6956: oTypeSPush
6957: oPop 1
6959: oInputChoice 7026
6961: oCall 5024
6963: oInput 16
6965: oCall 8743
6967: oTypeSNodeType
6968: oChoice 7013
6970: oInputChoice 7000
6972: oTypeSPop
6973: oGetLocal 3
6975: oPushResult
6976: oSetResult 38
6978: oPushResult
6979: oNodeGet
6980: oPop 2
6982: oPushResult
6983: oTypeSPush
6984: oPop 1
6986: oCall 7969
6988: oCall 7915
6990: oJumpForward 7005
6992: oCall 8164
6994: oCall 7969
6996: oCall 7915
6998: oJumpForward 7005
7000: Choice Lookup Table
          17   6992
          19   6972
7005: oJumpForward 7024
7007: oCall 7969
7009: oCall 7915
7011: oJumpForward 7024
7013: Choice Lookup Table
          43   7007
          41   7007
          39   7007
          38   6970
          37   6970
7024: oJumpForward 7048
7026: Choice Lookup Table
          15   6961
7029: oGetGlobal 25
7031: oChoice 7043
7033: oEmit 15
7035: oSetResult 0
7037: oPushResult
7038: oEmitInt
7039: oPop 1
7041: oJumpForward 7048
7043: Choice Lookup Table
           1   7033
7046: oError 32
7048: oJumpForward 7081
7050: Choice Lookup Table
          20   6946
          26   6937
          25   6937
          23   6937
          22   6937
          18   6862
          19   6816
          17   6753
          16   6753
          14   6744
          13   6735
7073: oError 6
7075: oGetGlobal 6
7077: oPushResult
7078: oTypeSPush
7079: oPop 1
7081: oJumpForward 7155
7083: oInput 0
7085: oGetAddrLocal 5
7087: oPushResult
7088: oScopeFindRequire
7089: oAssign
7090: oGetAddrLocal 5
7092: oPushResult
7093: oCall 244
7095: oPop 1
7097: oGetLocal 5
7099: oPushResult
7100: oSetResult 0
7102: oPushResult
7103: oCall 9624
7105: oPop 2
7107: oGetAddrLocal 6
7109: oPushResult
7110: oTypeSTop
7111: oAssign
7112: oTypeSPop
7113: oGetAddrLocal 7
7115: oPushResult
7116: oGetLocal 6
7118: oPushResult
7119: oCall 13477
7121: oPop 1
7123: oAssign
7124: oGetLocal 7
7126: oPushResult
7127: oTypeSPush
7128: oPop 1
7130: oJumpForward 7155
7132: Choice Lookup Table
          20   7083
           0   6715
           3   6686
          15   6675
           2   6660
           4   6645
           1   6630
7147: oError 6
7149: oGetGlobal 6
7151: oPushResult
7152: oTypeSPush
7153: oPop 1
7155: oReturn
7156: oLocalSpace 2
7158: oGetAddrLocal 1
7160: oPushResult
7161: oGetParam 1
7163: oPushResult
7164: oSetResult 21
7166: oPushResult
7167: oNodeGet
7168: oPop 2
7170: oAssign
7171: oGetAddrLocal 2
7173: oPushResult
7174: oGetParam 1
7176: oPushResult
7177: oCall 14412
7179: oPop 1
7181: oAssign
7182: oGetLocal 1
7184: oPushResult
7185: oTypeSPush
7186: oPop 1
7188: oTypeSNodeType
7189: oChoice 7888
7191: oGetParam 1
7193: oPushResult
7194: oNodeType
7195: oPop 1
7197: oChoice 7343
7199: oEmit 0
7201: oGetParam 1
7203: oPushResult
7204: oCall 14458
7206: oPop 1
7208: oJumpForward 7353
7210: oGetLocal 2
7212: oPushResult
7213: equal_zero
7214: oPop 1
7216: oChoice 7229
7218: oEmit 3
7220: oGetParam 1
7222: oPushResult
7223: oCall 14458
7225: oPop 1
7227: oJumpForward 7247
7229: Choice Lookup Table
           1   7218
7232: oEmit 9
7234: oGetLocal 2
7236: oPushResult
7237: oEmitInt
7238: oPop 1
7240: oGetParam 1
7242: oPushResult
7243: oCall 14458
7245: oPop 1
7247: oJumpForward 7353
7249: oGetParam 1
7251: oPushResult
7252: oSetResult 35
7254: oPushResult
7255: oNodeGetBoolean
7256: oPop 2
7258: oChoice 7301
7260: oGetLocal 2
7262: oPushResult
7263: equal_zero
7264: oPop 1
7266: oChoice 7279
7268: oEmit 8
7270: oGetParam 1
7272: oPushResult
7273: oCall 14458
7275: oPop 1
7277: oJumpForward 7297
7279: Choice Lookup Table
           1   7268
7282: oEmit 14
7284: oGetLocal 2
7286: oPushResult
7287: oEmitInt
7288: oPop 1
7290: oGetParam 1
7292: oPushResult
7293: oCall 14458
7295: oPop 1
7297: oEmit 24
7299: oJumpForward 7341
7301: Choice Lookup Table
           1   7260
7304: oGetLocal 2
7306: oPushResult
7307: equal_zero
7308: oPop 1
7310: oChoice 7323
7312: oEmit 6
7314: oGetParam 1
7316: oPushResult
7317: oCall 14458
7319: oPop 1
7321: oJumpForward 7341
7323: Choice Lookup Table
           1   7312
7326: oEmit 12
7328: oGetLocal 2
7330: oPushResult
7331: oEmitInt
7332: oPop 1
7334: oGetParam 1
7336: oPushResult
7337: oCall 14458
7339: oPop 1
7341: oJumpForward 7353
7343: Choice Lookup Table
          25   7249
          23   7210
          26   7199
          22   7199
7352: oEndChoice
7353: oJumpForward 7914
7355: oGetParam 1
7357: oPushResult
7358: oNodeType
7359: oPop 1
7361: oChoice 7507
7363: oEmit 1
7365: oGetParam 1
7367: oPushResult
7368: oCall 14458
7370: oPop 1
7372: oJumpForward 7517
7374: oGetLocal 2
7376: oPushResult
7377: equal_zero
7378: oPop 1
7380: oChoice 7393
7382: oEmit 4
7384: oGetParam 1
7386: oPushResult
7387: oCall 14458
7389: oPop 1
7391: oJumpForward 7411
7393: Choice Lookup Table
           1   7382
7396: oEmit 10
7398: oGetLocal 2
7400: oPushResult
7401: oEmitInt
7402: oPop 1
7404: oGetParam 1
7406: oPushResult
7407: oCall 14458
7409: oPop 1
7411: oJumpForward 7517
7413: oGetParam 1
7415: oPushResult
7416: oSetResult 35
7418: oPushResult
7419: oNodeGetBoolean
7420: oPop 2
7422: oChoice 7465
7424: oGetLocal 2
7426: oPushResult
7427: equal_zero
7428: oPop 1
7430: oChoice 7443
7432: oEmit 8
7434: oGetParam 1
7436: oPushResult
7437: oCall 14458
7439: oPop 1
7441: oJumpForward 7461
7443: Choice Lookup Table
           1   7432
7446: oEmit 14
7448: oGetLocal 2
7450: oPushResult
7451: oEmitInt
7452: oPop 1
7454: oGetParam 1
7456: oPushResult
7457: oCall 14458
7459: oPop 1
7461: oEmit 25
7463: oJumpForward 7505
7465: Choice Lookup Table
           1   7424
7468: oGetLocal 2
7470: oPushResult
7471: equal_zero
7472: oPop 1
7474: oChoice 7487
7476: oEmit 7
7478: oGetParam 1
7480: oPushResult
7481: oCall 14458
7483: oPop 1
7485: oJumpForward 7505
7487: Choice Lookup Table
           1   7476
7490: oEmit 13
7492: oGetLocal 2
7494: oPushResult
7495: oEmitInt
7496: oPop 1
7498: oGetParam 1
7500: oPushResult
7501: oCall 14458
7503: oPop 1
7505: oJumpForward 7517
7507: Choice Lookup Table
          25   7413
          23   7374
          26   7363
          22   7363
7516: oEndChoice
7517: oJumpForward 7914
7519: oError 17
7521: oJumpForward 7914
7523: oGetParam 1
7525: oPushResult
7526: oNodeType
7527: oPop 1
7529: oChoice 7675
7531: oEmit 2
7533: oGetParam 1
7535: oPushResult
7536: oCall 14458
7538: oPop 1
7540: oJumpForward 7685
7542: oGetLocal 2
7544: oPushResult
7545: equal_zero
7546: oPop 1
7548: oChoice 7561
7550: oEmit 5
7552: oGetParam 1
7554: oPushResult
7555: oCall 14458
7557: oPop 1
7559: oJumpForward 7579
7561: Choice Lookup Table
           1   7550
7564: oEmit 11
7566: oGetLocal 2
7568: oPushResult
7569: oEmitInt
7570: oPop 1
7572: oGetParam 1
7574: oPushResult
7575: oCall 14458
7577: oPop 1
7579: oJumpForward 7685
7581: oGetParam 1
7583: oPushResult
7584: oSetResult 35
7586: oPushResult
7587: oNodeGetBoolean
7588: oPop 2
7590: oChoice 7633
7592: oGetLocal 2
7594: oPushResult
7595: equal_zero
7596: oPop 1
7598: oChoice 7611
7600: oEmit 8
7602: oGetParam 1
7604: oPushResult
7605: oCall 14458
7607: oPop 1
7609: oJumpForward 7629
7611: Choice Lookup Table
           1   7600
7614: oEmit 14
7616: oGetLocal 2
7618: oPushResult
7619: oEmitInt
7620: oPop 1
7622: oGetParam 1
7624: oPushResult
7625: oCall 14458
7627: oPop 1
7629: oEmit 26
7631: oJumpForward 7673
7633: Choice Lookup Table
           1   7592
7636: oGetLocal 2
7638: oPushResult
7639: equal_zero
7640: oPop 1
7642: oChoice 7655
7644: oEmit 8
7646: oGetParam 1
7648: oPushResult
7649: oCall 14458
7651: oPop 1
7653: oJumpForward 7673
7655: Choice Lookup Table
           1   7644
7658: oEmit 14
7660: oGetLocal 2
7662: oPushResult
7663: oEmitInt
7664: oPop 1
7666: oGetParam 1
7668: oPushResult
7669: oCall 14458
7671: oPop 1
7673: oJumpForward 7685
7675: Choice Lookup Table
          25   7581
          23   7542
          26   7531
          22   7531
7684: oEndChoice
7685: oInputChoice 7715
7687: oTypeSPop
7688: oGetLocal 1
7690: oPushResult
7691: oSetResult 38
7693: oPushResult
7694: oNodeGet
7695: oPop 2
7697: oPushResult
7698: oTypeSPush
7699: oPop 1
7701: oCall 7969
7703: oCall 7915
7705: oJumpForward 7720
7707: oCall 8164
7709: oCall 7969
7711: oCall 7915
7713: oJumpForward 7720
7715: Choice Lookup Table
          17   7707
          19   7687
7720: oJumpForward 7914
7722: oGetParam 1
7724: oPushResult
7725: oNodeType
7726: oPop 1
7728: oChoice 7872
7730: oEmit 17
7732: oGetParam 1
7734: oPushResult
7735: oCall 14458
7737: oPop 1
7739: oJumpForward 7882
7741: oGetLocal 2
7743: oPushResult
7744: equal_zero
7745: oPop 1
7747: oChoice 7760
7749: oEmit 18
7751: oGetParam 1
7753: oPushResult
7754: oCall 14458
7756: oPop 1
7758: oJumpForward 7778
7760: Choice Lookup Table
           1   7749
7763: oEmit 21
7765: oGetLocal 2
7767: oPushResult
7768: oEmitInt
7769: oPop 1
7771: oGetParam 1
7773: oPushResult
7774: oCall 14458
7776: oPop 1
7778: oJumpForward 7882
7780: oGetParam 1
7782: oPushResult
7783: oSetResult 35
7785: oPushResult
7786: oNodeGetBoolean
7787: oPop 2
7789: oChoice 7830
7791: oGetLocal 2
7793: oPushResult
7794: equal_zero
7795: oPop 1
7797: oChoice 7810
7799: oEmit 8
7801: oGetParam 1
7803: oPushResult
7804: oCall 14458
7806: oPop 1
7808: oJumpForward 7828
7810: Choice Lookup Table
           1   7799
7813: oEmit 14
7815: oGetLocal 2
7817: oPushResult
7818: oEmitInt
7819: oPop 1
7821: oGetParam 1
7823: oPushResult
7824: oCall 14458
7826: oPop 1
7828: oJumpForward 7870
7830: Choice Lookup Table
           1   7791
7833: oGetLocal 2
7835: oPushResult
7836: equal_zero
7837: oPop 1
7839: oChoice 7852
7841: oEmit 19
7843: oGetParam 1
7845: oPushResult
7846: oCall 14458
7848: oPop 1
7850: oJumpForward 7870
7852: Choice Lookup Table
           1   7841
7855: oEmit 22
7857: oGetLocal 2
7859: oPushResult
7860: oEmitInt
7861: oPop 1
7863: oGetParam 1
7865: oPushResult
7866: oCall 14458
7868: oPop 1
7870: oJumpForward 7882
7872: Choice Lookup Table
          25   7780
          23   7741
          26   7730
          22   7730
7881: oEndChoice
7882: oCall 7969
7884: oCall 7915
7886: oJumpForward 7914
7888: Choice Lookup Table
          43   7722
          41   7722
          39   7722
          33   7523
          38   7523
          37   7523
          29   7519
          36   7355
          30   7355
          34   7355
          44   7191
          31   7191
7913: oEndChoice
7914: oReturn
7915: oLocalSpace 0
7917: oTypeSNodeType
7918: oChoice 7942
7920: oEmit 24
7922: oJumpForward 7968
7924: oEmit 25
7926: oJumpForward 7968
7928: oError 17
7930: oJumpForward 7968
7932: oEmit 26
7934: oJumpForward 7968
7936: oError 30
7938: oJumpForward 7968
7940: oJumpForward 7968
7942: Choice Lookup Table
          43   7940
          42   7940
          41   7940
          39   7940
          38   7936
          37   7932
          29   7928
          36   7924
          30   7924
          34   7924
          44   7920
          31   7920
7967: oEndChoice
7968: oReturn
7969: oLocalSpace 0
7971: oInputChoice 8009
7973: oTypeSNodeType
7974: oChoice 7988
7976: oCall 8021
7978: oJumpForward 7999
7980: oCall 8164
7982: oJumpForward 7999
7984: oCall 8243
7986: oJumpForward 7999
7988: Choice Lookup Table
          43   7984
          42   7984
          37   7980
          39   7976
7997: oError 11
7999: oJumpForward 8018
8001: oCall 8273
8003: oJumpForward 8018
8005: oCall 8546
8007: oJumpForward 8018
8009: Choice Lookup Table
          19   8005
          21   8001
          17   7973
8016: oJumpForward 8020
8018: oJumpBack 7971
8020: oReturn
8021: oLocalSpace 3
8023: oTypeSNodeType
8024: oChoice 8028
8026: oJumpForward 8033
8028: Choice Lookup Table
          39   8026
8031: oError 11
8033: oTypeSNodeType
8034: oChoice 8038
8036: oJumpForward 8043
8038: Choice Lookup Table
          39   8036
8041: oError 14
8043: oGetAddrLocal 1
8045: oPushResult
8046: oTypeSTop
8047: oPushResult
8048: oSetResult 39
8050: oPushResult
8051: oNodeGet
8052: oPop 2
8054: oPushResult
8055: oCall 13561
8057: oPop 1
8059: oAssign
8060: oGetAddrLocal 2
8062: oPushResult
8063: oTypeSTop
8064: oPushResult
8065: oSetResult 38
8067: oPushResult
8068: oNodeGet
8069: oPop 2
8071: oAssign
8072: oTypeSPop
8073: oGetLocal 2
8075: oPushResult
8076: oTypeSPush
8077: oPop 1
8079: oCall 5024
8081: oCall 8981
8083: oGetLocal 1
8085: oPushResult
8086: equal_zero
8087: oPop 1
8089: oChoice 8103
8091: oEmit 15
8093: oGetLocal 1
8095: oPushResult
8096: oEmitInt
8097: oPop 1
8099: oEmit 43
8101: oJumpForward 8106
8103: Choice Lookup Table
           0   8091
8106: oGetAddrLocal 3
8108: oPushResult
8109: oGetLocal 2
8111: oPushResult
8112: oSetResult 17
8114: oPushResult
8115: oNodeGetInt
8116: oPop 2
8118: oAssign
8119: oGetLocal 3
8121: oPushResult
8122: oSetResult 1
8124: oPushResult
8125: equal
8126: oPop 2
8128: oChoice 8142
8130: oEmit 15
8132: oGetLocal 3
8134: oPushResult
8135: oEmitInt
8136: oPop 1
8138: oEmit 37
8140: oJumpForward 8145
8142: Choice Lookup Table
           0   8130
8145: oEmit 39
8147: oInputChoice 8155
8149: oJumpForward 8163
8151: oJumpForward 8161
8153: oJumpForward 8161
8155: Choice Lookup Table
          14   8153
          18   8149
8160: oEndChoice
8161: oJumpBack 8033
8163: oReturn
8164: oLocalSpace 2
8166: oTypeSNodeType
8167: oChoice 8171
8169: oJumpForward 8176
8171: Choice Lookup Table
          37   8169
8174: oError 30
8176: oGetAddrLocal 1
8178: oPushResult
8179: oTypeSTop
8180: oPushResult
8181: oSetResult 38
8183: oPushResult
8184: oNodeGet
8185: oPop 2
8187: oAssign
8188: oTypeSPop
8189: oGetLocal 1
8191: oPushResult
8192: oTypeSPush
8193: oPop 1
8195: oCall 5024
8197: oCall 8981
8199: oGetAddrLocal 2
8201: oPushResult
8202: oGetLocal 1
8204: oPushResult
8205: oSetResult 17
8207: oPushResult
8208: oNodeGetInt
8209: oPop 2
8211: oAssign
8212: oGetLocal 2
8214: oPushResult
8215: oSetResult 1
8217: oPushResult
8218: equal
8219: oPop 2
8221: oChoice 8235
8223: oEmit 15
8225: oGetLocal 2
8227: oPushResult
8228: oEmitInt
8229: oPop 1
8231: oEmit 37
8233: oJumpForward 8238
8235: Choice Lookup Table
           0   8223
8238: oEmit 39
8240: oInput 18
8242: oReturn
8243: oLocalSpace 0
8245: oTypeSNodeType
8246: oChoice 8250
8248: oJumpForward 8257
8250: Choice Lookup Table
          43   8248
          42   8248
8255: oError 30
8257: oTypeSPop
8258: oGetGlobal 9
8260: oPushResult
8261: oTypeSPush
8262: oPop 1
8264: oCall 5024
8266: oCall 8981
8268: oEmit 39
8270: oInput 18
8272: oReturn
8273: oLocalSpace 2
8275: oTypeSNodeType
8276: oChoice 8280
8278: oJumpForward 8285
8280: Choice Lookup Table
          41   8278
8283: oError 12
8285: oTypeSTop
8286: oPushResult
8287: oSetResult 42
8289: oPushResult
8290: oNodeGet
8291: oPop 2
8293: oPushResult
8294: oScopeEnter
8295: oPop 1
8297: oInput 0
8299: oGetAddrLocal 1
8301: oPushResult
8302: oScopeFindRequire
8303: oAssign
8304: oGetLocal 1
8306: oPushResult
8307: oNodeType
8308: oPop 1
8310: oChoice 8314
8312: oJumpForward 8319
8314: Choice Lookup Table
          24   8312
8317: oError 13
8319: oScopeEnd
8320: oGetAddrLocal 2
8322: oPushResult
8323: oGetLocal 1
8325: oPushResult
8326: oSetResult 22
8328: oPushResult
8329: oNodeGetInt
8330: oPop 2
8332: oAssign
8333: oGetLocal 2
8335: oPushResult
8336: equal_zero
8337: oPop 1
8339: oChoice 8353
8341: oEmit 15
8343: oGetLocal 2
8345: oPushResult
8346: oEmitInt
8347: oPop 1
8349: oEmit 39
8351: oJumpForward 8356
8353: Choice Lookup Table
           0   8341
8356: oTypeSPop
8357: oGetLocal 1
8359: oPushResult
8360: oSetResult 21
8362: oPushResult
8363: oNodeGet
8364: oPop 2
8366: oPushResult
8367: oTypeSPush
8368: oPop 1
8370: oReturn
8371: oLocalSpace 2
8373: oGetAddrLocal 1
8375: oPushResult
8376: oTypeSTop
8377: oPushResult
8378: oSetResult 38
8380: oPushResult
8381: oNodeGet
8382: oPop 2
8384: oAssign
8385: oGetAddrLocal 2
8387: oPushResult
8388: oGetLocal 1
8390: oPushResult
8391: oSetResult 17
8393: oPushResult
8394: oNodeGetInt
8395: oPop 2
8397: oAssign
8398: oGetLocal 2
8400: oPushResult
8401: oSetResult 1
8403: oPushResult
8404: equal
8405: oPop 2
8407: oChoice 8421
8409: oEmit 15
8411: oGetLocal 2
8413: oPushResult
8414: oEmitInt
8415: oPop 1
8417: oEmit 37
8419: oJumpForward 8424
8421: Choice Lookup Table
           0   8409
8424: oEmit 39
8426: oReturn
8427: oLocalSpace 2
8429: oGetAddrLocal 1
8431: oPushResult
8432: oTypeSTop
8433: oPushResult
8434: oSetResult 38
8436: oPushResult
8437: oNodeGet
8438: oPop 2
8440: oAssign
8441: oGetAddrLocal 2
8443: oPushResult
8444: oGetLocal 1
8446: oPushResult
8447: oSetResult 17
8449: oPushResult
8450: oNodeGetInt
8451: oPop 2
8453: oAssign
8454: oGetLocal 2
8456: oPushResult
8457: oSetResult 1
8459: oPushResult
8460: equal
8461: oPop 2
8463: oChoice 8477
8465: oEmit 15
8467: oGetLocal 2
8469: oPushResult
8470: oEmitInt
8471: oPop 1
8473: oEmit 37
8475: oJumpForward 8480
8477: Choice Lookup Table
           0   8465
8480: oEmit 42
8482: oReturn
8483: oLocalSpace 2
8485: oEmit 41
8487: oGetAddrLocal 1
8489: oPushResult
8490: oTypeSTop
8491: oPushResult
8492: oSetResult 38
8494: oPushResult
8495: oNodeGet
8496: oPop 2
8498: oAssign
8499: oGetAddrLocal 2
8501: oPushResult
8502: oGetLocal 1
8504: oPushResult
8505: oSetResult 17
8507: oPushResult
8508: oNodeGetInt
8509: oPop 2
8511: oAssign
8512: oGetLocal 2
8514: oPushResult
8515: oSetResult 1
8517: oPushResult
8518: equal
8519: oPop 2
8521: oChoice 8535
8523: oEmit 15
8525: oGetLocal 2
8527: oPushResult
8528: oEmitInt
8529: oPop 1
8531: oEmit 38
8533: oJumpForward 8538
8535: Choice Lookup Table
           0   8523
8538: oTypeSPop
8539: oGetGlobal 6
8541: oPushResult
8542: oTypeSPush
8543: oPop 1
8545: oReturn
8546: oLocalSpace 1
8548: oTypeSNodeType
8549: oChoice 8557
8551: oJumpForward 8564
8553: oError 30
8555: oJumpForward 8564
8557: Choice Lookup Table
          38   8553
          37   8551
8562: oError 10
8564: oEmit 26
8566: oGetAddrLocal 1
8568: oPushResult
8569: oTypeSTop
8570: oAssign
8571: oTypeSPop
8572: oGetLocal 1
8574: oPushResult
8575: oSetResult 38
8577: oPushResult
8578: oNodeGet
8579: oPop 2
8581: oPushResult
8582: oTypeSPush
8583: oPop 1
8585: oReturn
8586: oLocalSpace 3
8588: oGetAddrLocal 1
8590: oPushResult
8591: oTypeSNodeType
8592: oAssign
8593: oGetAddrLocal 2
8595: oPushResult
8596: oTypeSTop
8597: oAssign
8598: oTypeSPop
8599: oGetLocal 1
8601: oPushResult
8602: oTypeSNodeType
8603: oPushResult
8604: equal_node_type
8605: oPop 2
8607: oChoice 8739
8609: oTypeSNodeType
8610: oChoice 8724
8612: oGetLocal 1
8614: oChoice 8621
8616: oEmit 32
8618: oReturn
8619: oJumpForward 8624
8621: Choice Lookup Table
          30   8616
8624: oJumpForward 8735
8626: oGetLocal 1
8628: oChoice 8635
8630: oEmit 33
8632: oReturn
8633: oJumpForward 8638
8635: Choice Lookup Table
          31   8630
8638: oJumpForward 8735
8640: oGetLocal 1
8642: oChoice 8675
8644: oReturn
8645: oJumpForward 8680
8647: oTypeSTop
8648: oPushResult
8649: oGetGlobal 10
8651: oPushResult
8652: equal_node
8653: oPop 2
8655: oChoice 8670
8657: oEmit 15
8659: oSetResult 1
8661: oPushResult
8662: oEmitInt
8663: oPop 1
8665: oEmit 39
8667: oReturn
8668: oJumpForward 8673
8670: Choice Lookup Table
           1   8657
8673: oJumpForward 8680
8675: Choice Lookup Table
          42   8647
          38   8644
8680: oJumpForward 8735
8682: oGetLocal 1
8684: oChoice 8689
8686: oReturn
8687: oJumpForward 8692
8689: Choice Lookup Table
          37   8686
8692: oJumpForward 8735
8694: oGetLocal 1
8696: oChoice 8717
8698: oReturn
8699: oJumpForward 8722
8701: oGetGlobal 9
8703: oPushResult
8704: oTypeSPush
8705: oPop 1
8707: oGetAddrLocal 3
8709: oPushResult
8710: oCall 11107
8712: oAssign
8713: oTypeSPop
8714: oReturn
8715: oJumpForward 8722
8717: Choice Lookup Table
          36   8701
          42   8698
8722: oJumpForward 8735
8724: Choice Lookup Table
          43   8694
          38   8682
          37   8640
          30   8626
          31   8612
8735: oError 15
8737: oJumpForward 8742
8739: Choice Lookup Table
           0   8609
8742: oReturn
8743: oLocalSpace 2
8745: oGetAddrLocal 1
8747: oPushResult
8748: oTypeSNodeType
8749: oAssign
8750: oTypeSPop
8751: oGetLocal 1
8753: oPushResult
8754: oTypeSNodeType
8755: oPushResult
8756: equal_node_type
8757: oPop 2
8759: oChoice 8919
8761: oTypeSNodeType
8762: oChoice 8898
8764: oGetLocal 1
8766: oChoice 8776
8768: oEmit 32
8770: oReturn
8771: oJumpForward 8787
8773: oReturn
8774: oJumpForward 8787
8776: Choice Lookup Table
          44   8773
          31   8773
          34   8768
          36   8768
          30   8768
8787: oJumpForward 8915
8789: oGetLocal 1
8791: oChoice 8801
8793: oReturn
8794: oJumpForward 8812
8796: oEmit 33
8798: oReturn
8799: oJumpForward 8812
8801: Choice Lookup Table
          44   8796
          31   8796
          34   8793
          36   8793
          30   8793
8812: oJumpForward 8915
8814: oGetLocal 1
8816: oChoice 8849
8818: oReturn
8819: oJumpForward 8854
8821: oTypeSTop
8822: oPushResult
8823: oGetGlobal 10
8825: oPushResult
8826: equal_node
8827: oPop 2
8829: oChoice 8844
8831: oEmit 15
8833: oSetResult 1
8835: oPushResult
8836: oEmitInt
8837: oPop 1
8839: oEmit 39
8841: oReturn
8842: oJumpForward 8847
8844: Choice Lookup Table
           1   8831
8847: oJumpForward 8854
8849: Choice Lookup Table
          42   8821
          38   8818
8854: oJumpForward 8915
8856: oGetLocal 1
8858: oChoice 8863
8860: oReturn
8861: oJumpForward 8866
8863: Choice Lookup Table
          37   8860
8866: oJumpForward 8915
8868: oGetLocal 1
8870: oChoice 8891
8872: oReturn
8873: oJumpForward 8896
8875: oGetGlobal 9
8877: oPushResult
8878: oTypeSPush
8879: oPop 1
8881: oGetAddrLocal 2
8883: oPushResult
8884: oCall 11107
8886: oAssign
8887: oTypeSPop
8888: oReturn
8889: oJumpForward 8896
8891: Choice Lookup Table
          36   8875
          42   8872
8896: oJumpForward 8915
8898: Choice Lookup Table
          43   8868
          38   8856
          37   8814
          34   8789
          36   8789
          30   8789
          44   8764
          31   8764
8915: oError 15
8917: oJumpForward 8922
8919: Choice Lookup Table
           0   8761
8922: oReturn
8923: oLocalSpace 1
8925: oGetAddrLocal 1
8927: oPushResult
8928: oTypeSNodeType
8929: oAssign
8930: oTypeSPop
8931: oGetLocal 1
8933: oPushResult
8934: oTypeSNodeType
8935: oPushResult
8936: equal_node_type
8937: oPop 2
8939: oChoice 8977
8941: oTypeSNodeType
8942: oChoice 8968
8944: oGetLocal 1
8946: oChoice 8951
8948: oReturn
8949: oJumpForward 8954
8951: Choice Lookup Table
          38   8948
8954: oJumpForward 8973
8956: oGetLocal 1
8958: oChoice 8963
8960: oReturn
8961: oJumpForward 8966
8963: Choice Lookup Table
          37   8960
8966: oJumpForward 8973
8968: Choice Lookup Table
          38   8956
          37   8944
8973: oError 15
8975: oJumpForward 8980
8977: Choice Lookup Table
           0   8941
8980: oReturn
8981: oLocalSpace 0
8983: oTypeSNodeType
8984: oChoice 8988
8986: oJumpForward 8993
8988: Choice Lookup Table
          31   8986
8991: oError 7
8993: oTypeSPop
8994: oReturn
8995: oLocalSpace 0
8997: oTypeSNodeType
8998: oChoice 9002
9000: oJumpForward 9007
9002: Choice Lookup Table
          31   9000
9005: oError 7
9007: oReturn
9008: oLocalSpace 0
9010: oTypeSNodeType
9011: oChoice 9019
9013: oJumpForward 9026
9015: oEmit 32
9017: oJumpForward 9026
9019: Choice Lookup Table
          30   9015
          31   9013
9024: oError 7
9026: oTypeSPop
9027: oReturn
9028: oLocalSpace 0
9030: oTypeSNodeType
9031: oChoice 9046
9033: oJumpForward 9053
9035: oEmit 32
9037: oTypeSPop
9038: oGetGlobal 6
9040: oPushResult
9041: oTypeSPush
9042: oPop 1
9044: oJumpForward 9053
9046: Choice Lookup Table
          30   9035
          31   9033
9051: oError 7
9053: oReturn
9054: oLocalSpace 0
9056: oTypeSNodeType
9057: oChoice 9070
9059: oEmit 32
9061: oTypeSPop
9062: oGetGlobal 6
9064: oPushResult
9065: oTypeSPush
9066: oPop 1
9068: oJumpForward 9073
9070: Choice Lookup Table
          30   9059
9073: oReturn
9074: oLocalSpace 0
9076: oTypeSNodeType
9077: oChoice 9105
9079: oJumpForward 9114
9081: oEmit 34
9083: oTypeSPop
9084: oGetGlobal 13
9086: oPushResult
9087: oTypeSPush
9088: oPop 1
9090: oJumpForward 9114
9092: oEmit 32
9094: oEmit 34
9096: oTypeSPop
9097: oGetGlobal 13
9099: oPushResult
9100: oTypeSPush
9101: oPop 1
9103: oJumpForward 9114
9105: Choice Lookup Table
          30   9092
          31   9081
          33   9079
9112: oError 9
9114: oTypeSPop
9115: oReturn
9116: oLocalSpace 0
9118: oTypeSNodeType
9119: oChoice 9123
9121: oJumpForward 9128
9123: Choice Lookup Table
          34   9121
9126: oError 8
9128: oTypeSPop
9129: oReturn
9130: oLocalSpace 0
9132: oTypeSNodeType
9133: oChoice 9137
9135: oJumpForward 9142
9137: Choice Lookup Table
          34   9135
9140: oError 8
9142: oReturn
9143: oLocalSpace 0
9145: oInputChoice 9208
9147: oCall 10880
9149: oJumpForward 9239
9151: oCall 10887
9153: oJumpForward 9239
9155: oCall 11017
9157: oJumpForward 9239
9159: oCall 11024
9161: oJumpForward 9239
9163: oCall 10031
9165: oJumpForward 9239
9167: oCall 10354
9169: oJumpForward 9239
9171: oCall 10097
9173: oJumpForward 9239
9175: oCall 10274
9177: oJumpForward 9239
9179: oCall 10439
9181: oJumpForward 9239
9183: oCall 10407
9185: oJumpForward 9239
9187: oCall 10857
9189: oJumpForward 9239
9191: oCall 9240
9193: oJumpForward 9239
9195: oCall 10471
9197: oJumpForward 9239
9199: oCall 10805
9201: oJumpForward 9239
9203: oChangeIntLitToLabelIdent
9204: oCall 9240
9206: oJumpForward 9239
9208: Choice Lookup Table
           1   9203
          56   9199
          54   9195
           0   9191
          36   9187
          52   9183
          53   9179
          50   9175
          45   9171
          49   9167
          42   9163
          69   9159
          68   9155
          67   9151
          66   9147
9239: oReturn
9240: oLocalSpace 1
9242: oGetAddrLocal 1
9244: oPushResult
9245: oScopeFindRequire
9246: oAssign
9247: oGetAddrLocal 1
9249: oPushResult
9250: oCall 244
9252: oPop 1
9254: oGetLocal 1
9256: oPushResult
9257: oNodeType
9258: oPop 1
9260: oChoice 9300
9262: oGetLocal 1
9264: oPushResult
9265: oCall 9318
9267: oPop 1
9269: oCall 9143
9271: oJumpForward 9317
9273: oGetLocal 1
9275: oPushResult
9276: oCall 11419
9278: oPop 1
9280: oJumpForward 9317
9282: oGetLocal 1
9284: oPushResult
9285: oCall 9368
9287: oPop 1
9289: oJumpForward 9317
9291: oGetLocal 1
9293: oPushResult
9294: oCall 9464
9296: oPop 1
9298: oJumpForward 9317
9300: Choice Lookup Table
          13   9291
          20   9282
          25   9282
          23   9282
          22   9282
          12   9273
          27   9262
9315: oError 0
9317: oReturn
9318: oLocalSpace 0
9320: oGetParam 1
9322: oPushResult
9323: oSetResult 36
9325: oPushResult
9326: oNodeGetBoolean
9327: oPop 2
9329: oChoice 9335
9331: oError 22
9333: oJumpForward 9338
9335: Choice Lookup Table
           1   9331
9338: oEmit 89
9340: oGetParam 1
9342: oPushResult
9343: oSetResult 22
9345: oPushResult
9346: oNodeGetLabel
9347: oPop 2
9349: oPushResult
9350: oEmitLabel
9351: oPop 1
9353: oGetParam 1
9355: oPushResult
9356: oSetResult 36
9358: oPushResult
9359: oSetResult 1
9361: oPushResult
9362: oNodeSetBoolean
9363: oPop 3
9365: oInput 13
9367: oReturn
9368: oLocalSpace 0
9370: oGetParam 1
9372: oPushResult
9373: oSetResult 1
9375: oPushResult
9376: oCall 9624
9378: oPop 2
9380: oInput 5
9382: oCall 5024
9384: oCall 8586
9386: oCall 9389
9388: oReturn
9389: oLocalSpace 1
9391: oTypeSNodeType
9392: oChoice 9436
9394: oEmit 27
9396: oJumpForward 9462
9398: oEmit 28
9400: oJumpForward 9462
9402: oEmit 30
9404: oJumpForward 9462
9406: oError 17
9408: oJumpForward 9462
9410: oEmit 29
9412: oJumpForward 9462
9414: oGetAddrLocal 1
9416: oPushResult
9417: oTypeSTop
9418: oPushResult
9419: oSetResult 17
9421: oPushResult
9422: oNodeGetInt
9423: oPop 2
9425: oAssign
9426: oEmit 31
9428: oGetLocal 1
9430: oPushResult
9431: oEmitInt
9432: oPop 1
9434: oJumpForward 9462
9436: Choice Lookup Table
          43   9414
          41   9414
          39   9414
          38   9410
          37   9410
          29   9406
          33   9402
          36   9398
          30   9398
          34   9398
          44   9394
          31   9394
9461: oEndChoice
9462: oTypeSPop
9463: oReturn
9464: oLocalSpace 1
9466: oGetParam 1
9468: oPushResult
9469: oSetResult 6
9471: oPushResult
9472: oNodeGet
9473: oPop 2
9475: oPushResult
9476: oScopeCurrent
9477: oPushResult
9478: oNodeEqual
9479: oPop 2
9481: oChoice 9487
9483: oError 21
9485: oJumpForward 9490
9487: Choice Lookup Table
           0   9483
9490: oEmit 8
9492: oGetParam 1
9494: oPushResult
9495: oSetResult 31
9497: oPushResult
9498: oNodeGetInt
9499: oPop 2
9501: oPushResult
9502: oEmitInt
9503: oPop 1
9505: oGetParam 1
9507: oPushResult
9508: oSetResult 21
9510: oPushResult
9511: oNodeGet
9512: oPop 2
9514: oPushResult
9515: oTypeSPush
9516: oPop 1
9518: oInput 5
9520: oCall 5024
9522: oCall 8586
9524: oTypeSNodeType
9525: oChoice 9569
9527: oEmit 27
9529: oJumpForward 9595
9531: oEmit 28
9533: oJumpForward 9595
9535: oEmit 30
9537: oJumpForward 9595
9539: oError 17
9541: oJumpForward 9595
9543: oEmit 29
9545: oJumpForward 9595
9547: oGetAddrLocal 1
9549: oPushResult
9550: oTypeSTop
9551: oPushResult
9552: oSetResult 17
9554: oPushResult
9555: oNodeGetInt
9556: oPop 2
9558: oAssign
9559: oEmit 31
9561: oGetLocal 1
9563: oPushResult
9564: oEmitInt
9565: oPop 1
9567: oJumpForward 9595
9569: Choice Lookup Table
          43   9547
          41   9547
          39   9547
          38   9543
          37   9543
          29   9539
          33   9535
          36   9531
          30   9531
          34   9531
          44   9527
          31   9527
9594: oEndChoice
9595: oTypeSPop
9596: oReturn
9597: oLocalSpace 1
9599: oInput 0
9601: oGetAddrLocal 1
9603: oPushResult
9604: oScopeFindRequire
9605: oAssign
9606: oGetAddrLocal 1
9608: oPushResult
9609: oCall 244
9611: oPop 1
9613: oGetLocal 1
9615: oPushResult
9616: oGetParam 1
9618: oPushResult
9619: oCall 9624
9621: oPop 2
9623: oReturn
9624: oLocalSpace 0
9626: oGetParam 2
9628: oPushResult
9629: oNodeType
9630: oPop 1
9632: oChoice 9695
9634: oGetParam 2
9636: oPushResult
9637: oGetParam 1
9639: oPushResult
9640: oCall 9841
9642: oPop 2
9644: oJumpForward 9708
9646: oGetParam 2
9648: oPushResult
9649: oSetResult 21
9651: oPushResult
9652: oNodeGet
9653: oPop 2
9655: oPushResult
9656: oTypeSPush
9657: oPop 1
9659: oInput 15
9661: oGetParam 1
9663: oPushResult
9664: oCall 9597
9666: oPop 1
9668: oInput 16
9670: oCall 9709
9672: oTypeSNodeType
9673: oChoice 9688
9675: oInputChoice 9683
9677: oEmit 26
9679: oCall 8164
9681: oJumpForward 9686
9683: Choice Lookup Table
          17   9677
9686: oJumpForward 9691
9688: Choice Lookup Table
          37   9675
9691: oCall 7969
9693: oJumpForward 9708
9695: Choice Lookup Table
          20   9646
          26   9634
          25   9634
          23   9634
          22   9634
9706: oError 4
9708: oReturn
9709: oLocalSpace 1
9711: oGetAddrLocal 1
9713: oPushResult
9714: oTypeSNodeType
9715: oAssign
9716: oTypeSPop
9717: oGetLocal 1
9719: oPushResult
9720: oTypeSNodeType
9721: oPushResult
9722: equal_node_type
9723: oPop 2
9725: oChoice 9837
9727: oTypeSNodeType
9728: oChoice 9816
9730: oGetLocal 1
9732: oChoice 9742
9734: oError 31
9736: oReturn
9737: oJumpForward 9753
9739: oReturn
9740: oJumpForward 9753
9742: Choice Lookup Table
          44   9739
          31   9739
          34   9734
          36   9734
          30   9734
9753: oJumpForward 9833
9755: oGetLocal 1
9757: oChoice 9767
9759: oReturn
9760: oJumpForward 9778
9762: oError 31
9764: oReturn
9765: oJumpForward 9778
9767: Choice Lookup Table
          44   9762
          31   9762
          34   9759
          36   9759
          30   9759
9778: oJumpForward 9833
9780: oGetLocal 1
9782: oChoice 9787
9784: oReturn
9785: oJumpForward 9790
9787: Choice Lookup Table
          38   9784
9790: oJumpForward 9833
9792: oGetLocal 1
9794: oChoice 9799
9796: oReturn
9797: oJumpForward 9802
9799: Choice Lookup Table
          37   9796
9802: oJumpForward 9833
9804: oGetLocal 1
9806: oChoice 9811
9808: oReturn
9809: oJumpForward 9814
9811: Choice Lookup Table
          42   9808
9814: oJumpForward 9833
9816: Choice Lookup Table
          43   9804
          38   9792
          37   9780
          34   9755
          36   9755
          30   9755
          44   9730
          31   9730
9833: oError 15
9835: oJumpForward 9840
9837: Choice Lookup Table
           0   9727
9840: oReturn
9841: oLocalSpace 0
9843: oGetParam 2
9845: oPushResult
9846: oNodeType
9847: oPop 1
9849: oChoice 9931
9851: oEmit 17
9853: oGetParam 2
9855: oPushResult
9856: oCall 14458
9858: oPop 1
9860: oJumpForward 9942
9862: oEmit 18
9864: oGetParam 2
9866: oPushResult
9867: oCall 14458
9869: oPop 1
9871: oJumpForward 9942
9873: oGetParam 2
9875: oPushResult
9876: oSetResult 35
9878: oPushResult
9879: oNodeGetBoolean
9880: oPop 2
9882: oChoice 9895
9884: oEmit 8
9886: oGetParam 2
9888: oPushResult
9889: oCall 14458
9891: oPop 1
9893: oJumpForward 9907
9895: Choice Lookup Table
           1   9884
9898: oEmit 19
9900: oGetParam 2
9902: oPushResult
9903: oCall 14458
9905: oPop 1
9907: oJumpForward 9942
9909: oGetParam 1
9911: oChoice 9924
9913: oEmit 17
9915: oGetParam 2
9917: oPushResult
9918: oCall 14458
9920: oPop 1
9922: oJumpForward 9929
9924: Choice Lookup Table
           0   9913
9927: oError 4
9929: oJumpForward 9942
9931: Choice Lookup Table
          26   9909
          25   9873
          23   9862
          22   9851
9940: oError 4
9942: oGetParam 2
9944: oPushResult
9945: oSetResult 21
9947: oPushResult
9948: oNodeGet
9949: oPop 2
9951: oPushResult
9952: oTypeSPush
9953: oPop 1
9955: oTypeSNodeType
9956: oChoice 9971
9958: oInputChoice 9966
9960: oEmit 26
9962: oCall 8164
9964: oJumpForward 9969
9966: Choice Lookup Table
          17   9960
9969: oJumpForward 9974
9971: Choice Lookup Table
          37   9958
9974: oCall 7969
9976: oReturn
9977: oLocalSpace 0
9979: oGetParam 1
9981: oPushResult
9982: oSetResult 1
9984: oPushResult
9985: oCall 9841
9987: oPop 2
9989: oCall 8981
9991: oGetParam 1
9993: oPushResult
9994: oCall 7156
9996: oPop 1
9998: oTypeSPop
9999: oEmit 35
10001: oEmit 27
10003: oReturn
10004: oLocalSpace 0
10006: oGetParam 1
10008: oPushResult
10009: oSetResult 1
10011: oPushResult
10012: oCall 9841
10014: oPop 2
10016: oCall 8981
10018: oGetParam 1
10020: oPushResult
10021: oCall 7156
10023: oPop 1
10025: oTypeSPop
10026: oEmit 36
10028: oEmit 27
10030: oReturn
10031: oLocalSpace 2
10033: oGetAddrLocal 1
10035: oPushResult
10036: oSetResult 0
10038: oAssign
10039: oGetAddrLocal 1
10041: oPushResult
10042: oCall 5070
10044: oPop 1
10046: oInput 43
10048: oCall 9143
10050: oInputChoice 10085
10052: oGetAddrLocal 2
10054: oPushResult
10055: oLabelNew
10056: oAssign
10057: oEmit 80
10059: oGetLocal 2
10061: oPushResult
10062: oEmitLabel
10063: oPop 1
10065: oEmit 89
10067: oGetLocal 1
10069: oPushResult
10070: oEmitLabel
10071: oPop 1
10073: oCall 9143
10075: oEmit 89
10077: oGetLocal 2
10079: oPushResult
10080: oEmitLabel
10081: oPop 1
10083: oJumpForward 10096
10085: Choice Lookup Table
          44   10052
10088: oEmit 89
10090: oGetLocal 1
10092: oPushResult
10093: oEmitLabel
10094: oPop 1
10096: oReturn
10097: oLocalSpace 4
10099: oInput 0
10101: oGetAddrLocal 1
10103: oPushResult
10104: oScopeFindRequire
10105: oAssign
10106: oGetLocal 1
10108: oPushResult
10109: oSetResult 1
10111: oPushResult
10112: oCall 9841
10114: oPop 2
10116: oCall 8981
10118: oInput 5
10120: oCall 5024
10122: oCall 8981
10124: oEmit 27
10126: oGetAddrLocal 2
10128: oPushResult
10129: oLabelNew
10130: oAssign
10131: oGetAddrLocal 3
10133: oPushResult
10134: oLabelNew
10135: oAssign
10136: oEmit 80
10138: oGetLocal 3
10140: oPushResult
10141: oEmitLabel
10142: oPop 1
10144: oGetAddrLocal 4
10146: oPushResult
10147: oLabelNew
10148: oAssign
10149: oEmit 89
10151: oGetLocal 4
10153: oPushResult
10154: oEmitLabel
10155: oPop 1
10157: oInputChoice 10237
10159: oGetLocal 1
10161: oPushResult
10162: oCall 9977
10164: oPop 1
10166: oEmit 89
10168: oGetLocal 3
10170: oPushResult
10171: oEmitLabel
10172: oPop 1
10174: oGetLocal 1
10176: oPushResult
10177: oCall 7156
10179: oPop 1
10181: oTypeSPop
10182: oCall 5024
10184: oCall 8981
10186: oEmit 59
10188: oEmit 81
10190: oGetLocal 2
10192: oPushResult
10193: oEmitLabel
10194: oPop 1
10196: oJumpForward 10243
10198: oGetLocal 1
10200: oPushResult
10201: oCall 10004
10203: oPop 1
10205: oEmit 89
10207: oGetLocal 3
10209: oPushResult
10210: oEmitLabel
10211: oPop 1
10213: oGetLocal 1
10215: oPushResult
10216: oCall 7156
10218: oPop 1
10220: oTypeSPop
10221: oCall 5024
10223: oCall 8981
10225: oEmit 60
10227: oEmit 81
10229: oGetLocal 2
10231: oPushResult
10232: oEmitLabel
10233: oPop 1
10235: oJumpForward 10243
10237: Choice Lookup Table
          47   10198
          46   10159
10242: oEndChoice
10243: oGetLocal 4
10245: oPushResult
10246: oGetLocal 2
10248: oPushResult
10249: oLoopPush
10250: oPop 2
10252: oInput 48
10254: oCall 9143
10256: oEmit 80
10258: oGetLocal 4
10260: oPushResult
10261: oEmitLabel
10262: oPop 1
10264: oEmit 89
10266: oGetLocal 2
10268: oPushResult
10269: oEmitLabel
10270: oPop 1
10272: oLoopPop
10273: oReturn
10274: oLocalSpace 3
10276: oGetAddrLocal 1
10278: oPushResult
10279: oLabelNew
10280: oAssign
10281: oEmit 89
10283: oGetLocal 1
10285: oPushResult
10286: oEmitLabel
10287: oPop 1
10289: oGetAddrLocal 2
10291: oPushResult
10292: oLabelNew
10293: oAssign
10294: oGetLocal 1
10296: oPushResult
10297: oGetLocal 2
10299: oPushResult
10300: oLoopPush
10301: oPop 2
10303: oCall 9143
10305: oInputChoice 10336
10307: oCall 9143
10309: oJumpForward 10342
10311: oGetAddrLocal 3
10313: oPushResult
10314: oCall 5070
10316: oPop 1
10318: oEmit 90
10320: oGetLocal 3
10322: oPushResult
10323: oEmitLabel
10324: oPop 1
10326: oGetLocal 1
10328: oPushResult
10329: oEmitLabel
10330: oPop 1
10332: oJumpForward 10344
10334: oJumpForward 10342
10336: Choice Lookup Table
          51   10311
           6   10307
10341: oEndChoice
10342: oJumpBack 10305
10344: oEmit 89
10346: oGetLocal 2
10348: oPushResult
10349: oEmitLabel
10350: oPop 1
10352: oLoopPop
10353: oReturn
10354: oLocalSpace 2
10356: oGetAddrLocal 1
10358: oPushResult
10359: oLabelNew
10360: oAssign
10361: oEmit 89
10363: oGetLocal 1
10365: oPushResult
10366: oEmitLabel
10367: oPop 1
10369: oGetAddrLocal 2
10371: oPushResult
10372: oCall 5070
10374: oPop 1
10376: oGetLocal 1
10378: oPushResult
10379: oGetLocal 2
10381: oPushResult
10382: oLoopPush
10383: oPop 2
10385: oInput 48
10387: oCall 9143
10389: oEmit 80
10391: oGetLocal 1
10393: oPushResult
10394: oEmitLabel
10395: oPop 1
10397: oEmit 89
10399: oGetLocal 2
10401: oPushResult
10402: oEmitLabel
10403: oPop 1
10405: oLoopPop
10406: oReturn
10407: oLocalSpace 0
10409: oLoopContinueLabel
10410: oPushResult
10411: oSetResult 0
10413: oPushResult
10414: equal_label
10415: oPop 2
10417: oChoice 10432
10419: oError 19
10421: oJumpForward 10438
10423: oEmit 80
10425: oLoopContinueLabel
10426: oPushResult
10427: oEmitLabel
10428: oPop 1
10430: oJumpForward 10438
10432: Choice Lookup Table
           0   10423
           1   10419
10437: oEndChoice
10438: oReturn
10439: oLocalSpace 0
10441: oLoopBreakLabel
10442: oPushResult
10443: oSetResult 0
10445: oPushResult
10446: equal_label
10447: oPop 2
10449: oChoice 10464
10451: oError 19
10453: oJumpForward 10470
10455: oEmit 80
10457: oLoopBreakLabel
10458: oPushResult
10459: oEmitLabel
10460: oPop 1
10462: oJumpForward 10470
10464: Choice Lookup Table
           0   10455
           1   10451
10469: oEndChoice
10470: oReturn
10471: oLocalSpace 8
10473: oGetAddrLocal 1
10475: oPushResult
10476: oCodeNew
10477: oAssign
10478: oGetAddrLocal 2
10480: oPushResult
10481: oLabelNew
10482: oAssign
10483: oGetAddrLocal 3
10485: oPushResult
10486: oLabelNew
10487: oAssign
10488: oGetAddrLocal 4
10490: oPushResult
10491: oGetLocal 3
10493: oAssign
10494: oGetAddrLocal 5
10496: oPushResult
10497: oSetResult 0
10499: oAssign
10500: oCall 5024
10502: oTypeSNodeType
10503: oChoice 10541
10505: oEmit 83
10507: oGetLocal 2
10509: oPushResult
10510: oEmitLabel
10511: oPop 1
10513: oJumpForward 10558
10515: oEmit 84
10517: oGetLocal 2
10519: oPushResult
10520: oEmitLabel
10521: oPop 1
10523: oJumpForward 10558
10525: oGetAddrLocal 5
10527: oPushResult
10528: oSetResult 1
10530: oAssign
10531: oEmit 85
10533: oGetLocal 2
10535: oPushResult
10536: oEmitLabel
10537: oPop 1
10539: oJumpForward 10558
10541: Choice Lookup Table
          42   10525
          43   10525
          44   10515
          31   10515
          36   10505
          30   10505
          34   10505
10556: oError 18
10558: oInput 41
10560: oInputChoice 10607
10562: oGetAddrLocal 4
10564: oPushResult
10565: oLabelNew
10566: oAssign
10567: oEmit 89
10569: oGetLocal 4
10571: oPushResult
10572: oEmitLabel
10573: oPop 1
10575: oInputChoice 10581
10577: oJumpForward 10599
10579: oJumpForward 10597
10581: Choice Lookup Table
          37   10577
10584: oCall 9143
10586: oInputChoice 10590
10588: oJumpForward 10597
10590: Choice Lookup Table
           6   10588
10593: oInput 37
10595: oJumpForward 10599
10597: oJumpBack 10575
10599: oJumpForward 10773
10601: oJumpForward 10771
10603: oJumpForward 10773
10605: oJumpForward 10771
10607: Choice Lookup Table
          37   10603
          44   10562
          55   10562
10614: oGetAddrLocal 6
10616: oPushResult
10617: oLabelNew
10618: oAssign
10619: oGetLocal 1
10621: oPushResult
10622: oCodePush
10623: oPop 1
10625: oCall 3568
10627: oCall 4460
10629: oGetLocal 5
10631: oChoice 10651
10633: oGetAddrLocal 7
10635: oPushResult
10636: oValueTopString
10637: oPushResult
10638: oStringAllocShortStringLit
10639: oPop 1
10641: oAssign
10642: oJumpForward 10657
10644: oGetAddrLocal 7
10646: oPushResult
10647: oValueTop
10648: oAssign
10649: oJumpForward 10657
10651: Choice Lookup Table
           0   10644
           1   10633
10656: oEndChoice
10657: oValuePop
10658: oInputChoice 10715
10660: oCall 3568
10662: oCall 4460
10664: oGetLocal 5
10666: oChoice 10686
10668: oGetAddrLocal 8
10670: oPushResult
10671: oValueTopString
10672: oPushResult
10673: oStringAllocShortStringLit
10674: oPop 1
10676: oAssign
10677: oJumpForward 10692
10679: oGetAddrLocal 8
10681: oPushResult
10682: oValueTop
10683: oAssign
10684: oJumpForward 10692
10686: Choice Lookup Table
           0   10679
           1   10668
10691: oEndChoice
10692: oValuePop
10693: oEmit 87
10695: oGetLocal 7
10697: oPushResult
10698: oEmitInt
10699: oPop 1
10701: oGetLocal 8
10703: oPushResult
10704: oEmitInt
10705: oPop 1
10707: oGetLocal 6
10709: oPushResult
10710: oEmitLabel
10711: oPop 1
10713: oJumpForward 10732
10715: Choice Lookup Table
          22   10660
10718: oEmit 86
10720: oGetLocal 7
10722: oPushResult
10723: oEmitInt
10724: oPop 1
10726: oGetLocal 6
10728: oPushResult
10729: oEmitLabel
10730: oPop 1
10732: oInputChoice 10736
10734: oJumpForward 10741
10736: Choice Lookup Table
          14   10734
10739: oJumpForward 10743
10741: oJumpBack 10625
10743: oCodePop
10744: oInput 13
10746: oEmit 89
10748: oGetLocal 6
10750: oPushResult
10751: oEmitLabel
10752: oPop 1
10754: oCall 9143
10756: oEmit 80
10758: oGetLocal 3
10760: oPushResult
10761: oEmitLabel
10762: oPop 1
10764: oInputChoice 10768
10766: oJumpForward 10771
10768: Choice Lookup Table
           6   10766
10771: oJumpBack 10560
10773: oEmit 89
10775: oGetLocal 2
10777: oPushResult
10778: oEmitLabel
10779: oPop 1
10781: oGetLocal 1
10783: oPushResult
10784: oEmitCode
10785: oPop 1
10787: oEmit 88
10789: oGetLocal 4
10791: oPushResult
10792: oEmitLabel
10793: oPop 1
10795: oEmit 89
10797: oGetLocal 3
10799: oPushResult
10800: oEmitLabel
10801: oPop 1
10803: oTypeSPop
10804: oReturn
10805: oLocalSpace 1
10807: oInputChoice 10814
10809: oJumpForward 10820
10811: oChangeIntLitToLabelIdent
10812: oJumpForward 10820
10814: Choice Lookup Table
           1   10811
           0   10809
10819: oEndChoice
10820: oGetAddrLocal 1
10822: oPushResult
10823: oScopeCurrent
10824: oPushResult
10825: oScopeFindRequireInScope
10826: oPop 1
10828: oAssign
10829: oGetLocal 1
10831: oPushResult
10832: oSetResult 28
10834: oPushResult
10835: oSetResult 1
10837: oPushResult
10838: oNodeSetBoolean
10839: oPop 3
10841: oEmit 80
10843: oGetLocal 1
10845: oPushResult
10846: oSetResult 22
10848: oPushResult
10849: oNodeGetLabel
10850: oPop 2
10852: oPushResult
10853: oEmitLabel
10854: oPop 1
10856: oReturn
10857: oLocalSpace 0
10859: oCall 9143
10861: oInputChoice 10871
10863: oCall 9143
10865: oJumpForward 10877
10867: oJumpForward 10879
10869: oJumpForward 10877
10871: Choice Lookup Table
          37   10867
           6   10863
10876: oEndChoice
10877: oJumpBack 10861
10879: oReturn
10880: oLocalSpace 0
10882: oCall 10887
10884: oEmit 100
10886: oReturn
10887: oLocalSpace 0
10889: oInputChoice 11013
10891: oCall 5024
10893: oTypeSNodeType
10894: oChoice 10969
10896: oEmit 92
10898: oJumpForward 10994
10900: oEmit 93
10902: oJumpForward 10994
10904: oEmit 32
10906: oEmit 92
10908: oJumpForward 10994
10910: oEmit 94
10912: oJumpForward 10994
10914: oEmit 99
10916: oJumpForward 10994
10918: oEmit 95
10920: oJumpForward 10994
10922: oError 17
10924: oJumpForward 10994
10926: oEmit 17
10928: oTypeSTop
10929: oPushResult
10930: oSetResult 44
10932: oPushResult
10933: oNodeGetInt
10934: oPop 2
10936: oPushResult
10937: oEmitInt
10938: oPop 1
10940: oEmit 98
10942: oJumpForward 10994
10944: oTypeSTop
10945: oPushResult
10946: oGetGlobal 10
10948: oPushResult
10949: equal_node
10950: oPop 2
10952: oChoice 10958
10954: oEmit 96
10956: oJumpForward 10963
10958: Choice Lookup Table
           1   10954
10961: oEmit 97
10963: oJumpForward 10994
10965: oEmit 97
10967: oJumpForward 10994
10969: Choice Lookup Table
          38   10965
          37   10944
          44   10926
          29   10922
          42   10918
          43   10918
          33   10914
          36   10910
          30   10904
          34   10900
          31   10896
10992: oError 18
10994: oTypeSPop
10995: oInputChoice 11003
10997: oJumpForward 11011
10999: oJumpForward 11009
11001: oJumpForward 11009
11003: Choice Lookup Table
          14   11001
          16   10997
11008: oEndChoice
11009: oJumpBack 10891
11011: oJumpForward 11016
11013: Choice Lookup Table
          15   10891
11016: oReturn
11017: oLocalSpace 0
11019: oCall 11024
11021: oEmit 104
11023: oReturn
11024: oLocalSpace 1
11026: oInputChoice 11103
11028: oSetResult 1
11030: oPushResult
11031: oCall 9597
11033: oPop 1
11035: oTypeSNodeType
11036: oChoice 11075
11038: oEmit 101
11040: oJumpForward 11084
11042: oEmit 102
11044: oJumpForward 11084
11046: oGetAddrLocal 1
11048: oPushResult
11049: oTypeSTop
11050: oPushResult
11051: oSetResult 17
11053: oPushResult
11054: oNodeGetInt
11055: oPop 2
11057: oPushResult
11058: oSetResult 1
11060: oPushResult
11061: subtract
11062: oPop 2
11064: oAssign
11065: oEmit 103
11067: oGetLocal 1
11069: oPushResult
11070: oEmitInt
11071: oPop 1
11073: oJumpForward 11084
11075: Choice Lookup Table
          43   11046
          36   11042
          31   11038
11082: oError 18
11084: oTypeSPop
11085: oInputChoice 11093
11087: oJumpForward 11101
11089: oJumpForward 11099
11091: oJumpForward 11099
11093: Choice Lookup Table
          14   11091
          16   11087
11098: oEndChoice
11099: oJumpBack 11028
11101: oJumpForward 11106
11103: Choice Lookup Table
          15   11028
11106: oReturn
11107: oLocalSpace 1
11109: oGetAddrLocal 1
11111: oPushResult
11112: oGetGlobal 16
11114: oPushResult
11115: oScopeAllocType
11116: oPop 1
11118: oAssign
11119: oTypeSNodeType
11120: oChoice 11188
11122: oEmit 18
11124: oGetLocal 1
11126: oPushResult
11127: oEmitInt
11128: oPop 1
11130: oEmit 23
11132: oEmit 31
11134: oGetGlobal 16
11136: oPushResult
11137: oSetResult 17
11139: oPushResult
11140: oNodeGetInt
11141: oPop 2
11143: oPushResult
11144: oEmitInt
11145: oPop 1
11147: oJumpForward 11197
11149: oEmit 18
11151: oGetLocal 1
11153: oPushResult
11154: oEmitInt
11155: oPop 1
11157: oEmit 15
11159: oSetResult 1
11161: oPushResult
11162: oEmitInt
11163: oPop 1
11165: oEmit 28
11167: oEmit 18
11169: oGetLocal 1
11171: oPushResult
11172: oSetResult 1
11174: oPushResult
11175: add
11176: oPop 2
11178: oPushResult
11179: oEmitInt
11180: oPop 1
11182: oEmit 23
11184: oEmit 28
11186: oJumpForward 11197
11188: Choice Lookup Table
          36   11149
          42   11122
          43   11122
11195: oError 15
11197: oTypeSPop
11198: oEmit 18
11200: oGetLocal 1
11202: oPushResult
11203: oEmitInt
11204: oPop 1
11206: oGetGlobal 16
11208: oPushResult
11209: oTypeSPush
11210: oPop 1
11212: oGetLocal 1
11214: oReturn
11215: oReturn
11216: oLocalSpace 0
11218: oEmit 73
11220: oSetResult 16
11222: oPushResult
11223: oEmitInt
11224: oPop 1
11226: oEmit 20
11228: oSetResult 8
11230: oPushResult
11231: oEmitInt
11232: oPop 1
11234: oEmit 23
11236: oEmit 29
11238: oEmit 20
11240: oSetResult 0
11242: oPushResult
11243: oEmitInt
11244: oPop 1
11246: oEmit 23
11248: oEmit 29
11250: oEmit 76
11252: oGetGlobal 22
11254: oPushResult
11255: oCall 14458
11257: oPop 1
11259: oEmit 75
11261: oSetResult 16
11263: oPushResult
11264: oEmitInt
11265: oPop 1
11267: oTypeSPop
11268: oTypeSPop
11269: oReturn
11270: oLocalSpace 0
11272: oEmit 73
11274: oSetResult 12
11276: oPushResult
11277: oEmitInt
11278: oPop 1
11280: oEmit 20
11282: oSetResult 8
11284: oPushResult
11285: oEmitInt
11286: oPop 1
11288: oEmit 23
11290: oEmit 28
11292: oEmit 20
11294: oSetResult 0
11296: oPushResult
11297: oEmitInt
11298: oPop 1
11300: oEmit 23
11302: oEmit 29
11304: oEmit 76
11306: oGetGlobal 23
11308: oPushResult
11309: oCall 14458
11311: oPop 1
11313: oEmit 75
11315: oSetResult 12
11317: oPushResult
11318: oEmitInt
11319: oPop 1
11321: oTypeSPop
11322: oTypeSPop
11323: oReturn
11324: oLocalSpace 1
11326: oEmit 74
11328: oSetResult 24
11330: oPushResult
11331: oEmitInt
11332: oPop 1
11334: oEmit 20
11336: oSetResult 8
11338: oPushResult
11339: oEmitInt
11340: oPop 1
11342: oEmit 23
11344: oEmit 29
11346: oEmit 20
11348: oSetResult 0
11350: oPushResult
11351: oEmitInt
11352: oPop 1
11354: oEmit 23
11356: oEmit 29
11358: oGetAddrLocal 1
11360: oPushResult
11361: oGetGlobal 6
11363: oPushResult
11364: oScopeAllocType
11365: oPop 1
11367: oAssign
11368: oEmit 20
11370: oSetResult 16
11372: oPushResult
11373: oEmitInt
11374: oPop 1
11376: oEmit 18
11378: oGetLocal 1
11380: oPushResult
11381: oEmitInt
11382: oPop 1
11384: oEmit 29
11386: oEmit 77
11388: oGetGlobal 24
11390: oPushResult
11391: oCall 14458
11393: oPop 1
11395: oEmit 3
11397: oGetLocal 1
11399: oPushResult
11400: oEmitInt
11401: oPop 1
11403: oEmit 75
11405: oSetResult 24
11407: oPushResult
11408: oEmitInt
11409: oPop 1
11411: oTypeSPop
11412: oGetGlobal 6
11414: oPushResult
11415: oTypeSPush
11416: oPop 1
11418: oReturn
11419: oLocalSpace 10
11421: oGetParam 1
11423: oPushResult
11424: oSetResult 28
11426: oPushResult
11427: oSetResult 1
11429: oPushResult
11430: oNodeSetBoolean
11431: oPop 3
11433: oGetAddrLocal 1
11435: oPushResult
11436: oGetParam 1
11438: oPushResult
11439: oSetResult 27
11441: oPushResult
11442: oNodeGetBoolean
11443: oPop 2
11445: oAssign
11446: oGetAddrLocal 4
11448: oPushResult
11449: oGetParam 1
11451: oPushResult
11452: oNodeType
11453: oPop 1
11455: oPushResult
11456: oSetResult 13
11458: oPushResult
11459: equal_node_type
11460: oPop 2
11462: oAssign
11463: oGetLocal 4
11465: oChoice 11492
11467: oGetAddrLocal 2
11469: oPushResult
11470: oGetParam 1
11472: oPushResult
11473: oSetResult 21
11475: oPushResult
11476: oNodeGet
11477: oPop 2
11479: oAssign
11480: oGetAddrLocal 3
11482: oPushResult
11483: oGetLocal 2
11485: oPushResult
11486: oScopeAllocType
11487: oPop 1
11489: oAssign
11490: oJumpForward 11495
11492: Choice Lookup Table
           1   11467
11495: oGetAddrLocal 5
11497: oPushResult
11498: oGetParam 1
11500: oPushResult
11501: oSetResult 23
11503: oPushResult
11504: oNodeGet
11505: oPop 2
11507: oAssign
11508: oGetAddrLocal 6
11510: oPushResult
11511: oGetLocal 5
11513: oPushResult
11514: oSetResult 17
11516: oPushResult
11517: oNodeGetInt
11518: oPop 2
11520: oAssign
11521: oGetLocal 1
11523: oChoice 11545
11525: oEmit 74
11527: oGetLocal 6
11529: oPushResult
11530: oEmitInt
11531: oPop 1
11533: oJumpForward 11551
11535: oEmit 73
11537: oGetLocal 6
11539: oPushResult
11540: oEmitInt
11541: oPop 1
11543: oJumpForward 11551
11545: Choice Lookup Table
           0   11535
           1   11525
11550: oEndChoice
11551: oGetParam 1
11553: oPushResult
11554: oCall 14392
11556: oPop 1
11558: oPushResult
11559: oSetResult 0
11561: oPushResult
11562: greater
11563: oPop 2
11565: oChoice 11598
11567: oEmit 20
11569: oSetResult 0
11571: oPushResult
11572: oEmitInt
11573: oPop 1
11575: oEmit 21
11577: oGetParam 1
11579: oPushResult
11580: oCall 14412
11582: oPop 1
11584: oPushResult
11585: oEmitInt
11586: oPop 1
11588: oSetResult 0
11590: oPushResult
11591: oEmitInt
11592: oPop 1
11594: oEmit 29
11596: oJumpForward 11601
11598: Choice Lookup Table
           1   11567
11601: oGetAddrLocal 7
11603: oPushResult
11604: oGetLocal 5
11606: oPushResult
11607: oSetResult 15
11609: oPushResult
11610: oNodeGetIter
11611: oPop 2
11613: oAssign
11614: oGetAddrLocal 8
11616: oPushResult
11617: oGetLocal 7
11619: oPushResult
11620: oNodeIterValue
11621: oPop 1
11623: oAssign
11624: oInputChoice 11827
11626: oGetLocal 8
11628: oPushResult
11629: oNodeNull
11630: oPop 1
11632: oChoice 11638
11634: oJumpForward 11823
11636: oJumpForward 11641
11638: Choice Lookup Table
           1   11634
11641: oGetAddrLocal 9
11643: oPushResult
11644: oGetLocal 8
11646: oPushResult
11647: oSetResult 22
11649: oPushResult
11650: oNodeGetInt
11651: oPop 2
11653: oAssign
11654: oEmit 20
11656: oGetLocal 9
11658: oPushResult
11659: oEmitInt
11660: oPop 1
11662: oGetLocal 8
11664: oPushResult
11665: oSetResult 21
11667: oPushResult
11668: oNodeGet
11669: oPop 2
11671: oPushResult
11672: oTypeSPush
11673: oPop 1
11675: oGetLocal 8
11677: oPushResult
11678: oSetResult 35
11680: oPushResult
11681: oNodeGetBoolean
11682: oPop 2
11684: oChoice 11776
11686: oSetResult 1
11688: oPushResult
11689: oCall 9597
11691: oPop 1
11693: oCall 8923
11695: oEmit 29
11697: oJumpForward 11782
11699: oCall 5024
11701: oCall 8586
11703: oTypeSNodeType
11704: oChoice 11748
11706: oEmit 27
11708: oJumpForward 11774
11710: oEmit 28
11712: oJumpForward 11774
11714: oEmit 30
11716: oJumpForward 11774
11718: oError 17
11720: oJumpForward 11774
11722: oEmit 29
11724: oJumpForward 11774
11726: oGetAddrLocal 10
11728: oPushResult
11729: oTypeSTop
11730: oPushResult
11731: oSetResult 17
11733: oPushResult
11734: oNodeGetInt
11735: oPop 2
11737: oAssign
11738: oEmit 31
11740: oGetLocal 10
11742: oPushResult
11743: oEmitInt
11744: oPop 1
11746: oJumpForward 11774
11748: Choice Lookup Table
          43   11726
          41   11726
          39   11726
          38   11722
          37   11722
          29   11718
          33   11714
          36   11710
          30   11710
          34   11710
          44   11706
          31   11706
11773: oEndChoice
11774: oJumpForward 11782
11776: Choice Lookup Table
           0   11699
           1   11686
11781: oEndChoice
11782: oTypeSPop
11783: oGetAddrLocal 7
11785: oPushResult
11786: oNodeIterNext
11787: oPop 1
11789: oGetAddrLocal 8
11791: oPushResult
11792: oGetLocal 7
11794: oPushResult
11795: oNodeIterValue
11796: oPop 1
11798: oAssign
11799: oGetLocal 8
11801: oPushResult
11802: oNodeNull
11803: oPop 1
11805: oChoice 11813
11807: oJumpForward 11823
11809: oJumpForward 11819
11811: oJumpForward 11819
11813: Choice Lookup Table
           0   11811
           1   11807
11818: oEndChoice
11819: oInput 14
11821: oJumpBack 11626
11823: oInput 16
11825: oJumpForward 11830
11827: Choice Lookup Table
          15   11626
11830: oGetLocal 8
11832: oPushResult
11833: oNodeNull
11834: oPop 1
11836: oChoice 11842
11838: oError 16
11840: oJumpForward 11845
11842: Choice Lookup Table
           0   11838
11845: oGetLocal 4
11847: oChoice 11876
11849: oEmit 20
11851: oGetParam 1
11853: oPushResult
11854: oSetResult 31
11856: oPushResult
11857: oNodeGetInt
11858: oPop 2
11860: oPushResult
11861: oEmitInt
11862: oPop 1
11864: oEmit 18
11866: oGetLocal 3
11868: oPushResult
11869: oEmitInt
11870: oPop 1
11872: oEmit 29
11874: oJumpForward 11879
11876: Choice Lookup Table
           1   11849
11879: oGetLocal 1
11881: oChoice 11905
11883: oEmit 77
11885: oGetParam 1
11887: oPushResult
11888: oCall 14458
11890: oPop 1
11892: oJumpForward 11911
11894: oEmit 76
11896: oGetParam 1
11898: oPushResult
11899: oCall 14458
11901: oPop 1
11903: oJumpForward 11911
11905: Choice Lookup Table
           0   11894
           1   11883
11910: oEndChoice
11911: oGetLocal 4
11913: oChoice 11994
11915: oGetLocal 2
11917: oPushResult
11918: oTypeSPush
11919: oPop 1
11921: oTypeSNodeType
11922: oChoice 11968
11924: oEmit 3
11926: oGetLocal 3
11928: oPushResult
11929: oEmitInt
11930: oPop 1
11932: oJumpForward 11992
11934: oEmit 4
11936: oGetLocal 3
11938: oPushResult
11939: oEmitInt
11940: oPop 1
11942: oJumpForward 11992
11944: oError 17
11946: oJumpForward 11992
11948: oEmit 5
11950: oGetLocal 3
11952: oPushResult
11953: oEmitInt
11954: oPop 1
11956: oJumpForward 11992
11958: oEmit 18
11960: oGetLocal 3
11962: oPushResult
11963: oEmitInt
11964: oPop 1
11966: oJumpForward 11992
11968: Choice Lookup Table
          43   11958
          41   11958
          39   11958
          38   11948
          37   11948
          29   11944
          36   11934
          30   11934
          34   11934
          44   11924
          31   11924
11991: oEndChoice
11992: oJumpForward 11997
11994: Choice Lookup Table
           1   11915
11997: oEmit 75
11999: oGetLocal 6
12001: oPushResult
12002: oEmitInt
12003: oPop 1
12005: oReturn
12006: oLocalSpace 2
12008: oGetAddrLocal 2
12010: oPushResult
12011: oGetParam 1
12013: oPushResult
12014: oSetResult 26
12016: oPushResult
12017: oNodeGetString
12018: oPop 2
12020: oAssign
12021: oGetLocal 2
12023: oPushResult
12024: oSetResult 0
12026: oPushResult
12027: equal_string
12028: oPop 2
12030: oChoice 12067
12032: oGetAddrLocal 1
12034: oPushResult
12035: oGetParam 1
12037: oPushResult
12038: oSetResult 4
12040: oPushResult
12041: oNodeGetInt
12042: oPop 2
12044: oPushResult
12045: ID_STRING
12046: oPop 1
12048: oPushResult
12049: oStringAllocLit
12050: oPop 1
12052: oAssign
12053: oJumpForward 12073
12055: oGetAddrLocal 1
12057: oPushResult
12058: oGetLocal 2
12060: oPushResult
12061: oStringAllocLit
12062: oPop 1
12064: oAssign
12065: oJumpForward 12073
12067: Choice Lookup Table
           0   12055
           1   12032
12072: oEndChoice
12073: oEmit 91
12075: oGetParam 1
12077: oPushResult
12078: oCall 14458
12080: oPop 1
12082: oGetLocal 1
12084: oPushResult
12085: oEmitInt
12086: oPop 1
12088: oReturn
12089: oLocalSpace 2
12091: oGetParam 1
12093: oPushResult
12094: oGetGlobal 17
12096: oPushResult
12097: oNodeEqual
12098: oPop 2
12100: oChoice 12140
12102: oInput 15
12104: oCall 5024
12106: oTypeSNodeType
12107: oChoice 12115
12109: oJumpForward 12128
12111: oEmit 32
12113: oJumpForward 12128
12115: Choice Lookup Table
          36   12111
          30   12111
          34   12111
          44   12109
          31   12109
12126: oError 15
12128: oTypeSPop
12129: oGetGlobal 6
12131: oPushResult
12132: oTypeSPush
12133: oPop 1
12135: oInput 16
12137: oReturn
12138: oJumpForward 12143
12140: Choice Lookup Table
           1   12102
12143: oGetParam 1
12145: oPushResult
12146: oGetGlobal 18
12148: oPushResult
12149: oNodeEqual
12150: oPop 2
12152: oChoice 12186
12154: oInput 15
12156: oCall 5024
12158: oTypeSNodeType
12159: oChoice 12167
12161: oEmit 33
12163: oJumpForward 12174
12165: oJumpForward 12174
12167: Choice Lookup Table
          30   12165
          31   12161
12172: oError 15
12174: oTypeSPop
12175: oGetGlobal 9
12177: oPushResult
12178: oTypeSPush
12179: oPop 1
12181: oInput 16
12183: oReturn
12184: oJumpForward 12189
12186: Choice Lookup Table
           1   12154
12189: oGetParam 1
12191: oPushResult
12192: oGetGlobal 19
12194: oPushResult
12195: oNodeEqual
12196: oPop 2
12198: oChoice 12238
12200: oInput 15
12202: oCall 5024
12204: oTypeSNodeType
12205: oChoice 12226
12207: oTypeSTop
12208: oPushResult
12209: oSetResult 45
12211: oPushResult
12212: oNodeGetBoolean
12213: oPop 2
12215: oChoice 12221
12217: oError 29
12219: oJumpForward 12224
12221: Choice Lookup Table
           1   12217
12224: oJumpForward 12231
12226: Choice Lookup Table
          44   12207
12229: oError 15
12231: oEmit 36
12233: oInput 16
12235: oReturn
12236: oJumpForward 12241
12238: Choice Lookup Table
           1   12200
12241: oGetParam 1
12243: oPushResult
12244: oGetGlobal 20
12246: oPushResult
12247: oNodeEqual
12248: oPop 2
12250: oChoice 12290
12252: oInput 15
12254: oCall 5024
12256: oTypeSNodeType
12257: oChoice 12278
12259: oTypeSTop
12260: oPushResult
12261: oSetResult 45
12263: oPushResult
12264: oNodeGetBoolean
12265: oPop 2
12267: oChoice 12273
12269: oError 29
12271: oJumpForward 12276
12273: Choice Lookup Table
           1   12269
12276: oJumpForward 12283
12278: Choice Lookup Table
          44   12259
12281: oError 15
12283: oEmit 35
12285: oInput 16
12287: oReturn
12288: oJumpForward 12293
12290: Choice Lookup Table
           1   12252
12293: oGetParam 1
12295: oPushResult
12296: oGetGlobal 21
12298: oPushResult
12299: oNodeEqual
12300: oPop 2
12302: oChoice 12358
12304: oInput 15
12306: oGetAddrLocal 1
12308: oPushResult
12309: oCodeNew
12310: oAssign
12311: oGetLocal 1
12313: oPushResult
12314: oCodePush
12315: oPop 1
12317: oCall 5047
12319: oCodePop
12320: oGetLocal 1
12322: oPushResult
12323: oCodeDiscard
12324: oPop 1
12326: oGetAddrLocal 2
12328: oPushResult
12329: oTypeSTop
12330: oAssign
12331: oTypeSPop
12332: oEmit 15
12334: oGetLocal 2
12336: oPushResult
12337: oSetResult 17
12339: oPushResult
12340: oNodeGetInt
12341: oPop 2
12343: oPushResult
12344: oEmitInt
12345: oPop 1
12347: oGetGlobal 6
12349: oPushResult
12350: oTypeSPush
12351: oPop 1
12353: oInput 16
12355: oReturn
12356: oJumpForward 12361
12358: Choice Lookup Table
           1   12304
12361: oError 17
12363: oReturn
12364: oLocalSpace 1
12366: oGetAddrLocal 1
12368: oPushResult
12369: oGetParam 2
12371: oPushResult
12372: oNodeNew
12373: oPop 1
12375: oAssign
12376: oGetLocal 1
12378: oPushResult
12379: oSetResult 17
12381: oPushResult
12382: oGetParam 1
12384: oPushResult
12385: oNodeSetInt
12386: oPop 3
12388: oGetLocal 1
12390: oPushResult
12391: oTypeAdd
12392: oPop 1
12394: oGetLocal 1
12396: oReturn
12397: oReturn
12398: oLocalSpace 12
12400: oInputChoice 12883
12402: oGetAddrLocal 1
12404: oPushResult
12405: oScopeFindRequire
12406: oAssign
12407: oGetAddrLocal 1
12409: oPushResult
12410: oCall 244
12412: oPop 1
12414: oGetLocal 1
12416: oPushResult
12417: oNodeType
12418: oPop 1
12420: oChoice 12437
12422: oGetParam 1
12424: oPushResult
12425: oGetLocal 1
12427: oPushResult
12428: oSetResult 21
12430: oPushResult
12431: oNodeGet
12432: oPop 2
12434: oAssign
12435: oJumpForward 12448
12437: Choice Lookup Table
          20   12422
12440: oError 2
12442: oGetParam 1
12444: oPushResult
12445: oGetGlobal 6
12447: oAssign
12448: oJumpForward 12906
12450: oInput 17
12452: oGetAddrLocal 2
12454: oPushResult
12455: oNodeVecNew
12456: oAssign
12457: oGetAddrLocal 3
12459: oPushResult
12460: oSetResult 40
12462: oPushResult
12463: oNodeNew
12464: oPop 1
12466: oAssign
12467: oCall 3568
12469: oGetLocal 3
12471: oPushResult
12472: oSetResult 40
12474: oPushResult
12475: oValueTop
12476: oPushResult
12477: oNodeSetInt
12478: oPop 3
12480: oValuePop
12481: oInput 22
12483: oCall 3568
12485: oGetLocal 3
12487: oPushResult
12488: oSetResult 41
12490: oPushResult
12491: oValueTop
12492: oPushResult
12493: oNodeSetInt
12494: oPop 3
12496: oValuePop
12497: oCall 4363
12499: oGetLocal 3
12501: oPushResult
12502: oSetResult 38
12504: oPushResult
12505: oTypeSTop
12506: oPushResult
12507: oNodeSet
12508: oPop 3
12510: oGetLocal 3
12512: oPushResult
12513: oSetResult 17
12515: oPushResult
12516: oTypeSTop
12517: oPushResult
12518: oSetResult 17
12520: oPushResult
12521: oNodeGetInt
12522: oPop 2
12524: oPushResult
12525: oNodeSetInt
12526: oPop 3
12528: oTypeSPop
12529: oGetLocal 3
12531: oPushResult
12532: oTypeAdd
12533: oPop 1
12535: oGetAddrLocal 4
12537: oPushResult
12538: oSetResult 39
12540: oPushResult
12541: oNodeNew
12542: oPop 1
12544: oAssign
12545: oGetLocal 4
12547: oPushResult
12548: oSetResult 39
12550: oPushResult
12551: oGetLocal 3
12553: oPushResult
12554: oNodeSet
12555: oPop 3
12557: oGetLocal 2
12559: oPushResult
12560: oGetLocal 4
12562: oPushResult
12563: oNodeVecAppend
12564: oPop 2
12566: oInputChoice 12574
12568: oJumpForward 12582
12570: oJumpForward 12580
12572: oJumpForward 12580
12574: Choice Lookup Table
          14   12572
          18   12568
12579: oEndChoice
12580: oJumpBack 12457
12582: oInput 41
12584: oGetAddrLocal 5
12586: oPushResult
12587: oCall 12398
12589: oPop 1
12591: oGetAddrLocal 6
12593: oPushResult
12594: oGetLocal 2
12596: oPushResult
12597: oNodeVecSize
12598: oPop 1
12600: oAssign
12601: oGetAddrLocal 6
12603: oPushResult
12604: dec
12605: oPop 1
12607: oGetAddrLocal 7
12609: oPushResult
12610: oGetLocal 2
12612: oPushResult
12613: oGetLocal 6
12615: oPushResult
12616: oNodeVecElement
12617: oPop 2
12619: oAssign
12620: oGetLocal 7
12622: oPushResult
12623: oSetResult 38
12625: oPushResult
12626: oGetLocal 5
12628: oPushResult
12629: oNodeSet
12630: oPop 3
12632: oGetAddrLocal 8
12634: oPushResult
12635: oGetLocal 7
12637: oPushResult
12638: oSetResult 39
12640: oPushResult
12641: oNodeGet
12642: oPop 2
12644: oAssign
12645: oGetAddrLocal 9
12647: oPushResult
12648: oGetLocal 8
12650: oPushResult
12651: oSetResult 41
12653: oPushResult
12654: oNodeGetInt
12655: oPop 2
12657: oPushResult
12658: oGetLocal 8
12660: oPushResult
12661: oSetResult 40
12663: oPushResult
12664: oNodeGetInt
12665: oPop 2
12667: oPushResult
12668: subtract
12669: oPop 2
12671: oAssign
12672: oGetAddrLocal 9
12674: oPushResult
12675: inc
12676: oPop 1
12678: oGetLocal 7
12680: oPushResult
12681: oSetResult 17
12683: oPushResult
12684: oGetLocal 9
12686: oPushResult
12687: oGetLocal 5
12689: oPushResult
12690: oSetResult 17
12692: oPushResult
12693: oNodeGetInt
12694: oPop 2
12696: oPushResult
12697: multiply
12698: oPop 2
12700: oPushResult
12701: oNodeSetInt
12702: oPop 3
12704: oGetLocal 7
12706: oPushResult
12707: oTypeAdd
12708: oPop 1
12710: oGetAddrLocal 5
12712: oPushResult
12713: oGetLocal 7
12715: oAssign
12716: oGetLocal 6
12718: oPushResult
12719: equal_zero
12720: oPop 1
12722: oChoice 12728
12724: oJumpForward 12733
12726: oJumpForward 12731
12728: Choice Lookup Table
           1   12724
12731: oJumpBack 12601
12733: oGetParam 1
12735: oPushResult
12736: oGetLocal 2
12738: oPushResult
12739: oSetResult 0
12741: oPushResult
12742: oNodeVecElement
12743: oPop 2
12745: oAssign
12746: oGetLocal 2
12748: oPushResult
12749: oNodeVecDelete
12750: oPop 1
12752: oJumpForward 12906
12754: oGetAddrLocal 10
12756: oPushResult
12757: oCall 12398
12759: oPop 1
12761: oGetParam 1
12763: oPushResult
12764: oGetLocal 10
12766: oPushResult
12767: oCall 13477
12769: oPop 1
12771: oAssign
12772: oJumpForward 12906
12774: oGetParam 1
12776: oPushResult
12777: oSetResult 41
12779: oPushResult
12780: oNodeNew
12781: oPop 1
12783: oAssign
12784: oSetResult -1
12786: oPushResult
12787: oSetResult 2
12789: oPushResult
12790: oScopeBegin
12791: oPop 2
12793: oSetResult 24
12795: oPushResult
12796: oCall 3269
12798: oPop 1
12800: oGetAddrLocal 11
12802: oPushResult
12803: oScopeCurrent
12804: oPushResult
12805: oSetResult 17
12807: oPushResult
12808: oNodeGetInt
12809: oPop 2
12811: oAssign
12812: oGetLocal 11
12814: oPushResult
12815: equal_zero
12816: oPop 1
12818: oChoice 12824
12820: oError 20
12822: oJumpForward 12827
12824: Choice Lookup Table
           1   12820
12827: oInput 37
12829: oGetFromParam 1
12831: oPushResult
12832: oSetResult 42
12834: oPushResult
12835: oScopeCurrent
12836: oPushResult
12837: oNodeSet
12838: oPop 3
12840: oGetFromParam 1
12842: oPushResult
12843: oSetResult 17
12845: oPushResult
12846: oGetLocal 11
12848: oPushResult
12849: oNodeSetInt
12850: oPop 3
12852: oScopeEnd
12853: oGetFromParam 1
12855: oPushResult
12856: oTypeAdd
12857: oPop 1
12859: oJumpForward 12906
12861: oGetParam 1
12863: oPushResult
12864: oCall 12907
12866: oPop 1
12868: oJumpForward 12906
12870: oInput 41
12872: oGetAddrLocal 12
12874: oPushResult
12875: oCall 12398
12877: oPop 1
12879: oError 17
12881: oJumpForward 12906
12883: Choice Lookup Table
          40   12870
          15   12861
          39   12774
          19   12754
          38   12450
           0   12402
12896: oCall 3568
12898: oInput 22
12900: oCall 3568
12902: oCall 4363
12904: oError 17
12906: oReturn
12907: oLocalSpace 11
12909: oGetParam 1
12911: oPushResult
12912: oSetResult 44
12914: oPushResult
12915: oNodeNew
12916: oPop 1
12918: oAssign
12919: oGetAddrLocal 1
12921: oPushResult
12922: oSetResult 0
12924: oAssign
12925: oGetAddrLocal 2
12927: oPushResult
12928: oSetResult 0
12930: oAssign
12931: oGetAddrLocal 3
12933: oPushResult
12934: oSetResult 1
12936: oAssign
12937: oGetAddrLocal 4
12939: oPushResult
12940: oScopeCurrent
12941: oAssign
12942: oSetResult -1
12944: oPushResult
12945: oSetResult 2
12947: oPushResult
12948: oScopeBegin
12949: oPop 2
12951: oInput 0
12953: oGetAddrLocal 5
12955: oPushResult
12956: oSetResult 17
12958: oPushResult
12959: LAST_ID
12960: oPushResult
12961: oCall 14430
12963: oPop 2
12965: oAssign
12966: oGetAddrLocal 6
12968: oPushResult
12969: oSetResult 17
12971: oPushResult
12972: LAST_ID
12973: oPushResult
12974: oCall 14430
12976: oPop 2
12978: oAssign
12979: oGetLocal 5
12981: oPushResult
12982: oSetResult 21
12984: oPushResult
12985: oGetFromParam 1
12987: oPushResult
12988: oNodeSet
12989: oPop 3
12991: oGetLocal 6
12993: oPushResult
12994: oSetResult 21
12996: oPushResult
12997: oGetFromParam 1
12999: oPushResult
13000: oNodeSet
13001: oPop 3
13003: oGetAddrLocal 7
13005: oPushResult
13006: LAST_ID
13007: oPushResult
13008: ID_STRING
13009: oPop 1
13011: oPushResult
13012: oStringAllocLit
13013: oPop 1
13015: oAssign
13016: oGetLocal 5
13018: oPushResult
13019: oSetResult 32
13021: oPushResult
13022: oGetLocal 7
13024: oPushResult
13025: oNodeSetInt
13026: oPop 3
13028: oGetLocal 6
13030: oPushResult
13031: oSetResult 32
13033: oPushResult
13034: oGetLocal 7
13036: oPushResult
13037: oNodeSetInt
13038: oPop 3
13040: oInputChoice 13118
13042: oGetGlobal 6
13044: oPushResult
13045: oTypeSPush
13046: oPop 1
13048: oCall 3568
13050: oCall 4460
13052: oTypeSPop
13053: oGetLocal 2
13055: oPushResult
13056: equal_zero
13057: oPop 1
13059: oChoice 13080
13061: oValueTop
13062: oPushResult
13063: oGetLocal 1
13065: oPushResult
13066: greater
13067: oPop 2
13069: oChoice 13075
13071: oError 27
13073: oJumpForward 13078
13075: Choice Lookup Table
           0   13071
13078: oJumpForward 13083
13080: Choice Lookup Table
           0   13061
13083: oGetLocal 1
13085: oPushResult
13086: oValueTop
13087: oPushResult
13088: equal
13089: oPop 2
13091: oChoice 13107
13093: oGetFromParam 1
13095: oPushResult
13096: oSetResult 45
13098: oPushResult
13099: oSetResult 1
13101: oPushResult
13102: oNodeSetBoolean
13103: oPop 3
13105: oJumpForward 13110
13107: Choice Lookup Table
           0   13093
13110: oGetAddrLocal 1
13112: oPushResult
13113: oValueTop
13114: oAssign
13115: oValuePop
13116: oJumpForward 13123
13118: Choice Lookup Table
           5   13042
           7   13042
13123: oGetLocal 5
13125: oPushResult
13126: oSetResult 22
13128: oPushResult
13129: oGetLocal 1
13131: oPushResult
13132: oNodeSetInt
13133: oPop 3
13135: oGetLocal 6
13137: oPushResult
13138: oSetResult 22
13140: oPushResult
13141: oGetLocal 1
13143: oPushResult
13144: oNodeSetInt
13145: oPop 3
13147: oGetLocal 5
13149: oPushResult
13150: oScopeDeclare
13151: oPop 1
13153: oGetLocal 4
13155: oPushResult
13156: oScopeEnter
13157: oPop 1
13159: oGetLocal 6
13161: oPushResult
13162: oScopeDeclare
13163: oPop 1
13165: oScopeEnd
13166: oGetAddrLocal 1
13168: oPushResult
13169: inc
13170: oPop 1
13172: oGetAddrLocal 2
13174: oPushResult
13175: inc
13176: oPop 1
13178: oInputChoice 13182
13180: oJumpForward 13187
13182: Choice Lookup Table
          14   13180
13185: oJumpForward 13189
13187: oJumpBack 12951
13189: oInput 16
13191: oGetFromParam 1
13193: oPushResult
13194: oSetResult 42
13196: oPushResult
13197: oScopeCurrent
13198: oPushResult
13199: oNodeSet
13200: oPop 3
13202: oGetFromParam 1
13204: oPushResult
13205: oSetResult 17
13207: oPushResult
13208: oSetResult 4
13210: oPushResult
13211: oNodeSetInt
13212: oPop 3
13214: oScopeEnd
13215: oGetGlobal 2
13217: oPushResult
13218: oCall 14328
13220: oPop 1
13222: oPushResult
13223: oCodePush
13224: oPop 1
13226: oGetGlobal 2
13228: oPushResult
13229: oScopeEnter
13230: oPop 1
13232: oGetAddrLocal 8
13234: oPushResult
13235: oGetLocal 2
13237: oPushResult
13238: oSetResult 1
13240: oPushResult
13241: add
13242: oPop 2
13244: oPushResult
13245: oSetResult 16
13247: oPushResult
13248: multiply
13249: oPop 2
13251: oAssign
13252: oGetAddrLocal 9
13254: oPushResult
13255: oGetLocal 8
13257: oPushResult
13258: oSetResult 8
13260: oPushResult
13261: oScopeAlloc
13262: oPop 2
13264: oAssign
13265: oScopeEnd
13266: oGetFromParam 1
13268: oPushResult
13269: oSetResult 44
13271: oPushResult
13272: oGetLocal 9
13274: oPushResult
13275: oNodeSetInt
13276: oPop 3
13278: oGetAddrLocal 10
13280: oPushResult
13281: oGetFromParam 1
13283: oPushResult
13284: oSetResult 42
13286: oPushResult
13287: oNodeGet
13288: oPop 2
13290: oPushResult
13291: oSetResult 15
13293: oPushResult
13294: oNodeGetIter
13295: oPop 2
13297: oAssign
13298: oGetAddrLocal 11
13300: oPushResult
13301: oGetLocal 10
13303: oPushResult
13304: oNodeIterValue
13305: oPop 1
13307: oAssign
13308: oGetLocal 11
13310: oPushResult
13311: oNodeNull
13312: oPop 1
13314: oChoice 13320
13316: oJumpForward 13407
13318: oJumpForward 13323
13320: Choice Lookup Table
           1   13316
13323: oEmit 17
13325: oGetLocal 9
13327: oPushResult
13328: oEmitInt
13329: oPop 1
13331: oEmit 15
13333: oGetLocal 11
13335: oPushResult
13336: oSetResult 22
13338: oPushResult
13339: oNodeGetInt
13340: oPop 2
13342: oPushResult
13343: oEmitInt
13344: oPop 1
13346: oEmit 27
13348: oGetAddrLocal 9
13350: oPushResult
13351: oGetLocal 9
13353: oPushResult
13354: oSetResult 8
13356: oPushResult
13357: add
13358: oPop 2
13360: oAssign
13361: oEmit 17
13363: oGetLocal 9
13365: oPushResult
13366: oEmitInt
13367: oPop 1
13369: oEmit 17
13371: oGetLocal 11
13373: oPushResult
13374: oSetResult 32
13376: oPushResult
13377: oNodeGetInt
13378: oPop 2
13380: oPushResult
13381: oEmitInt
13382: oPop 1
13384: oEmit 29
13386: oGetAddrLocal 9
13388: oPushResult
13389: oGetLocal 9
13391: oPushResult
13392: oSetResult 8
13394: oPushResult
13395: add
13396: oPop 2
13398: oAssign
13399: oGetAddrLocal 10
13401: oPushResult
13402: oNodeIterNext
13403: oPop 1
13405: oJumpBack 13298
13407: oEmit 17
13409: oGetLocal 9
13411: oPushResult
13412: oEmitInt
13413: oPop 1
13415: oEmit 15
13417: oSetResult 0
13419: oPushResult
13420: oEmitInt
13421: oPop 1
13423: oEmit 27
13425: oGetAddrLocal 9
13427: oPushResult
13428: oGetLocal 9
13430: oPushResult
13431: oSetResult 8
13433: oPushResult
13434: add
13435: oPop 2
13437: oAssign
13438: oEmit 17
13440: oGetLocal 9
13442: oPushResult
13443: oEmitInt
13444: oPop 1
13446: oEmit 15
13448: oSetResult 0
13450: oPushResult
13451: oEmitInt
13452: oPop 1
13454: oEmit 29
13456: oGetAddrLocal 9
13458: oPushResult
13459: oGetLocal 9
13461: oPushResult
13462: oSetResult 8
13464: oPushResult
13465: add
13466: oPop 2
13468: oAssign
13469: oCodePop
13470: oGetFromParam 1
13472: oPushResult
13473: oTypeAdd
13474: oPop 1
13476: oReturn
13477: oLocalSpace 1
13479: oGetAddrLocal 1
13481: oPushResult
13482: oGetParam 1
13484: oPushResult
13485: oSetResult 37
13487: oPushResult
13488: oNodeGet
13489: oPop 2
13491: oAssign
13492: oGetLocal 1
13494: oPushResult
13495: oNodeNull
13496: oPop 1
13498: oChoice 13554
13500: oGetAddrLocal 1
13502: oPushResult
13503: oSetResult 37
13505: oPushResult
13506: oNodeNew
13507: oPop 1
13509: oAssign
13510: oGetLocal 1
13512: oPushResult
13513: oSetResult 38
13515: oPushResult
13516: oGetParam 1
13518: oPushResult
13519: oNodeSet
13520: oPop 3
13522: oGetLocal 1
13524: oPushResult
13525: oSetResult 17
13527: oPushResult
13528: oSetResult 8
13530: oPushResult
13531: oNodeSetInt
13532: oPop 3
13534: oGetLocal 1
13536: oPushResult
13537: oTypeAdd
13538: oPop 1
13540: oGetParam 1
13542: oPushResult
13543: oSetResult 37
13545: oPushResult
13546: oGetLocal 1
13548: oPushResult
13549: oNodeSet
13550: oPop 3
13552: oJumpForward 13557
13554: Choice Lookup Table
           1   13500
13557: oGetLocal 1
13559: oReturn
13560: oReturn
13561: oLocalSpace 2
13563: oGetParam 1
13565: oPushResult
13566: oNodeType
13567: oPop 1
13569: oChoice 13639
13571: oMININT
13572: oReturn
13573: oJumpForward 13655
13575: oSetResult 0
13577: oReturn
13578: oJumpForward 13655
13580: oSetResult 0
13582: oReturn
13583: oJumpForward 13655
13585: oGetAddrLocal 1
13587: oPushResult
13588: oGetParam 1
13590: oPushResult
13591: oSetResult 42
13593: oPushResult
13594: oNodeGet
13595: oPop 2
13597: oAssign
13598: oGetAddrLocal 2
13600: oPushResult
13601: oGetLocal 1
13603: oPushResult
13604: oSetResult 15
13606: oPushResult
13607: oNodeGetIter
13608: oPop 2
13610: oPushResult
13611: oNodeIterValue
13612: oPop 1
13614: oAssign
13615: oGetLocal 2
13617: oPushResult
13618: oSetResult 22
13620: oPushResult
13621: oNodeGetInt
13622: oPop 2
13624: oReturn
13625: oJumpForward 13655
13627: oGetParam 1
13629: oPushResult
13630: oSetResult 40
13632: oPushResult
13633: oNodeGetInt
13634: oPop 2
13636: oReturn
13637: oJumpForward 13655
13639: Choice Lookup Table
          40   13627
          44   13585
          36   13580
          34   13575
          31   13571
13650: oError 3
13652: oSetResult 0
13654: oReturn
13655: oReturn
13656: oLocalSpace 2
13658: oGetParam 1
13660: oPushResult
13661: oNodeType
13662: oPop 1
13664: oChoice 13734
13666: oMAXINT
13667: oReturn
13668: oJumpForward 13750
13670: oSetResult 1
13672: oReturn
13673: oJumpForward 13750
13675: oSetResult 255
13677: oReturn
13678: oJumpForward 13750
13680: oGetAddrLocal 1
13682: oPushResult
13683: oGetParam 1
13685: oPushResult
13686: oSetResult 42
13688: oPushResult
13689: oNodeGet
13690: oPop 2
13692: oAssign
13693: oGetAddrLocal 2
13695: oPushResult
13696: oGetLocal 1
13698: oPushResult
13699: oSetResult 15
13701: oPushResult
13702: oNodeGetIterLast
13703: oPop 2
13705: oPushResult
13706: oNodeIterValue
13707: oPop 1
13709: oAssign
13710: oGetLocal 2
13712: oPushResult
13713: oSetResult 22
13715: oPushResult
13716: oNodeGetInt
13717: oPop 2
13719: oReturn
13720: oJumpForward 13750
13722: oGetParam 1
13724: oPushResult
13725: oSetResult 41
13727: oPushResult
13728: oNodeGetInt
13729: oPop 2
13731: oReturn
13732: oJumpForward 13750
13734: Choice Lookup Table
          40   13722
          44   13680
          36   13675
          34   13670
          31   13666
13745: oError 3
13747: oSetResult 0
13749: oReturn
13750: oReturn
13751: oLocalSpace 5
13753: oGetAddrGlobal 1
13755: oPushResult
13756: oWorkspaceNew
13757: oAssign
13758: oSetResult 0
13760: oPushResult
13761: oSetResult 0
13763: oPushResult
13764: oScopeBegin
13765: oPop 2
13767: oGetAddrLocal 2
13769: oPushResult
13770: oScopeCurrent
13771: oAssign
13772: oCall 14500
13774: oEmit 79
13776: oSetResult 0
13778: oPushResult
13779: oEmitInt
13780: oPop 1
13782: oGetAddrLocal 3
13784: oPushResult
13785: oLabelNew
13786: oAssign
13787: oEmit 73
13789: oSetResult 0
13791: oPushResult
13792: oEmitInt
13793: oPop 1
13795: oEmit 76
13797: oGetLocal 3
13799: oPushResult
13800: oEmitLabel
13801: oPop 1
13803: oEmit 75
13805: oSetResult 0
13807: oPushResult
13808: oEmitInt
13809: oPop 1
13811: oEmit 78
13813: oInput 29
13815: oInput 0
13817: oGetAddrLocal 4
13819: oPushResult
13820: oSetResult 4
13822: oPushResult
13823: oNodeNew
13824: oPop 1
13826: oAssign
13827: oGetLocal 4
13829: oPushResult
13830: oSetResult 4
13832: oPushResult
13833: LAST_ID
13834: oPushResult
13835: oNodeSetInt
13836: oPop 3
13838: oGetGlobal 1
13840: oPushResult
13841: oSetResult 2
13843: oPushResult
13844: oGetLocal 4
13846: oPushResult
13847: oNodeSet
13848: oPop 3
13850: oInputChoice 13924
13852: oInput 0
13854: oGetAddrLocal 1
13856: oPushResult
13857: oSetResult 21
13859: oPushResult
13860: LAST_ID
13861: oPushResult
13862: oCall 14430
13864: oPop 2
13866: oAssign
13867: oGetLocal 1
13869: oPushResult
13870: oSetResult 21
13872: oPushResult
13873: oGetGlobal 5
13875: oPushResult
13876: oNodeSet
13877: oPop 3
13879: oGetLocal 1
13881: oPushResult
13882: oScopeDeclareAlloc
13883: oPop 1
13885: oInput 14
13887: oInput 0
13889: oGetAddrLocal 1
13891: oPushResult
13892: oSetResult 21
13894: oPushResult
13895: LAST_ID
13896: oPushResult
13897: oCall 14430
13899: oPop 2
13901: oAssign
13902: oGetLocal 1
13904: oPushResult
13905: oSetResult 21
13907: oPushResult
13908: oGetGlobal 5
13910: oPushResult
13911: oNodeSet
13912: oPop 3
13914: oGetLocal 1
13916: oPushResult
13917: oScopeDeclareAlloc
13918: oPop 1
13920: oInput 16
13922: oJumpForward 13927
13924: Choice Lookup Table
          15   13852
13927: oInput 6
13929: oGetLocal 4
13931: oPushResult
13932: oCall 34
13934: oPop 1
13936: oInputChoice 13947
13938: oGetLocal 4
13940: oPushResult
13941: oCall 7
13943: oPop 1
13945: oJumpForward 13950
13947: Choice Lookup Table
          60   13938
13950: oGetLocal 4
13952: oPushResult
13953: oCall 287
13955: oPop 1
13957: oSetResult 0
13959: oPushResult
13960: oSetResult 0
13962: oPushResult
13963: oScopeBegin
13964: oPop 2
13966: oGetAddrGlobal 2
13968: oPushResult
13969: oScopeCurrent
13970: oAssign
13971: oSetResult 0
13973: oPushResult
13974: oSetResult 1
13976: oPushResult
13977: oScopeBegin
13978: oPop 2
13980: oScopeCurrent
13981: oPushResult
13982: oSetResult 16
13984: oPushResult
13985: oGetGlobal 2
13987: oPushResult
13988: oNodeSet
13989: oPop 3
13991: oGetAddrGlobal 3
13993: oPushResult
13994: oScopeCurrent
13995: oAssign
13996: oGetLocal 4
13998: oPushResult
13999: oSetResult 7
14001: oPushResult
14002: oGetGlobal 3
14004: oPushResult
14005: oNodeSet
14006: oPop 3
14008: oScopeEnd
14009: oSetResult 22
14011: oPushResult
14012: oCall 14079
14014: oPop 1
14016: oGetGlobal 3
14018: oPushResult
14019: oScopeEnter
14020: oPop 1
14022: oGetAddrLocal 5
14024: oPushResult
14025: oSetResult 1
14027: oAssign
14028: oGetLocal 3
14030: oPushResult
14031: oGetGlobal 2
14033: oPushResult
14034: oGetLocal 5
14036: oPushResult
14037: oCall 14230
14039: oPop 3
14041: oScopeEnd
14042: oInput 21
14044: oCall 14135
14046: oScopeEnd
14047: oGetLocal 4
14049: oPushResult
14050: oCall 349
14052: oPop 1
14054: oReturn
14055: oLocalSpace 0
14057: oGetParam 2
14059: oPushResult
14060: oCall 14079
14062: oPop 1
14064: oGetParam 1
14066: oPushResult
14067: oScopeCurrent
14068: oPushResult
14069: oSetResult 0
14071: oPushResult
14072: oCall 14230
14074: oPop 3
14076: oCall 14135
14078: oReturn
14079: oLocalSpace 0
14081: oInputChoice 14112
14083: oCall 2520
14085: oJumpForward 14127
14087: oCall 3213
14089: oJumpForward 14127
14091: oGetParam 1
14093: oPushResult
14094: oCall 3269
14096: oPop 1
14098: oJumpForward 14127
14100: oCall 3503
14102: oJumpForward 14127
14104: oCall 1743
14106: oJumpForward 14127
14108: oCall 2178
14110: oJumpForward 14127
14112: Choice Lookup Table
          31   14108
          30   14104
          35   14100
          34   14091
          33   14087
          32   14083
14125: oJumpForward 14129
14127: oJumpBack 14081
14129: oCall 14132
14131: oReturn
14132: oLocalSpace 0
14134: oReturn
14135: oLocalSpace 2
14137: oGetAddrLocal 1
14139: oPushResult
14140: oScopeCurrent
14141: oPushResult
14142: oSetResult 15
14144: oPushResult
14145: oNodeGetIter
14146: oPop 2
14148: oAssign
14149: oGetAddrLocal 2
14151: oPushResult
14152: oGetLocal 1
14154: oPushResult
14155: oNodeIterValue
14156: oPop 1
14158: oAssign
14159: oGetLocal 2
14161: oPushResult
14162: oNodeNull
14163: oPop 1
14165: oChoice 14169
14167: oJumpForward 14174
14169: Choice Lookup Table
           0   14167
14172: oJumpForward 14229
14174: oGetLocal 2
14176: oPushResult
14177: oNodeType
14178: oPop 1
14180: oChoice 14218
14182: oGetLocal 2
14184: oPushResult
14185: oSetResult 36
14187: oPushResult
14188: oNodeGetBoolean
14189: oPop 2
14191: oChoice 14213
14193: oGetLocal 2
14195: oPushResult
14196: oSetResult 28
14198: oPushResult
14199: oNodeGetBoolean
14200: oPop 2
14202: oChoice 14208
14204: oError 28
14206: oJumpForward 14211
14208: Choice Lookup Table
           1   14204
14211: oJumpForward 14216
14213: Choice Lookup Table
           0   14193
14216: oJumpForward 14221
14218: Choice Lookup Table
          27   14182
14221: oGetAddrLocal 1
14223: oPushResult
14224: oNodeIterNext
14225: oPop 1
14227: oJumpBack 14149
14229: oReturn
14230: oLocalSpace 3
14232: oEmit 89
14234: oGetParam 3
14236: oPushResult
14237: oEmitLabel
14238: oPop 1
14240: oEmit 79
14242: oGetAddrLocal 1
14244: oPushResult
14245: Here
14246: oAssign
14247: oEmit 107
14249: oGetParam 1
14251: oChoice 14257
14253: oCall 1220
14255: oJumpForward 14260
14257: Choice Lookup Table
           1   14253
14260: oGetAddrLocal 2
14262: oPushResult
14263: oGetParam 2
14265: oPushResult
14266: oSetResult 19
14268: oPushResult
14269: oNodeGetCode
14270: oPop 2
14272: oAssign
14273: oGetLocal 2
14275: oPushResult
14276: oEmitCode
14277: oPop 1
14279: oGetParam 2
14281: oPushResult
14282: oSetResult 19
14284: oPushResult
14285: oSetResult 0
14287: oPushResult
14288: oNodeSetCode
14289: oPop 3
14291: oCall 9143
14293: oGetParam 1
14295: oChoice 14301
14297: oCall 1305
14299: oJumpForward 14304
14301: Choice Lookup Table
           1   14297
14304: oEmit 78
14306: oGetAddrLocal 3
14308: oPushResult
14309: oScopeCurrent
14310: oPushResult
14311: oSetResult 17
14313: oPushResult
14314: oNodeGetInt
14315: oPop 2
14317: oAssign
14318: oGetLocal 1
14320: oPushResult
14321: oGetLocal 3
14323: oPushResult
14324: oPatch
14325: oPop 2
14327: oReturn
14328: oLocalSpace 1
14330: oGetAddrLocal 1
14332: oPushResult
14333: oGetParam 1
14335: oPushResult
14336: oSetResult 19
14338: oPushResult
14339: oNodeGetCode
14340: oPop 2
14342: oAssign
14343: oGetLocal 1
14345: oPushResult
14346: oSetResult 0
14348: oPushResult
14349: equal_code
14350: oPop 2
14352: oChoice 14373
14354: oGetAddrLocal 1
14356: oPushResult
14357: oCodeNew
14358: oAssign
14359: oGetParam 1
14361: oPushResult
14362: oSetResult 19
14364: oPushResult
14365: oGetLocal 1
14367: oPushResult
14368: oNodeSetCode
14369: oPop 3
14371: oJumpForward 14376
14373: Choice Lookup Table
           1   14354
14376: oGetLocal 1
14378: oReturn
14379: oReturn
14380: oLocalSpace 0
14382: oScopeCurrent
14383: oPushResult
14384: oSetResult 14
14386: oPushResult
14387: oNodeGetInt
14388: oPop 2
14390: oReturn
14391: oReturn
14392: oLocalSpace 0
14394: oGetParam 1
14396: oPushResult
14397: oSetResult 20
14399: oPushResult
14400: oNodeGet
14401: oPop 2
14403: oPushResult
14404: oSetResult 14
14406: oPushResult
14407: oNodeGetInt
14408: oPop 2
14410: oReturn
14411: oReturn
14412: oLocalSpace 0
14414: oCall 14380
14416: oPushResult
14417: oGetParam 1
14419: oPushResult
14420: oCall 14392
14422: oPop 1
14424: oPushResult
14425: subtract
14426: oPop 2
14428: oReturn
14429: oReturn
14430: oLocalSpace 1
14432: oGetAddrLocal 1
14434: oPushResult
14435: oGetParam 2
14437: oPushResult
14438: oNodeNew
14439: oPop 1
14441: oAssign
14442: oGetLocal 1
14444: oPushResult
14445: oSetResult 4
14447: oPushResult
14448: oGetParam 1
14450: oPushResult
14451: oNodeSetInt
14452: oPop 3
14454: oGetLocal 1
14456: oReturn
14457: oReturn
14458: oLocalSpace 0
14460: oGetParam 1
14462: oPushResult
14463: oSetResult 22
14465: oPushResult
14466: oNodeGetInt
14467: oPop 2
14469: oPushResult
14470: oEmitInt
14471: oPop 1
14473: oReturn
14474: oLocalSpace 1
14476: oGetAddrLocal 1
14478: oPushResult
14479: oSetResult 14
14481: oPushResult
14482: oGetParam 1
14484: oPushResult
14485: oCall 14430
14487: oPop 2
14489: oAssign
14490: oGetLocal 1
14492: oPushResult
14493: oScopeDeclare
14494: oPop 1
14496: oGetLocal 1
14498: oReturn
14499: oReturn
14500: oLocalSpace 1
14502: oGetAddrGlobal 25
14504: oPushResult
14505: oSetResult 0
14507: oAssign
14508: oGetAddrGlobal 4
14510: oPushResult
14511: oId_mysystem
14512: oAssign
14513: oGetAddrGlobal 5
14515: oPushResult
14516: oSetResult 29
14518: oPushResult
14519: oSetResult 4
14521: oPushResult
14522: oCall 12364
14524: oPop 2
14526: oAssign
14527: oGetAddrGlobal 6
14529: oPushResult
14530: oSetResult 31
14532: oPushResult
14533: oSetResult 4
14535: oPushResult
14536: oCall 12364
14538: oPop 2
14540: oAssign
14541: oGetAddrGlobal 7
14543: oPushResult
14544: oSetResult 34
14546: oPushResult
14547: oSetResult 1
14549: oPushResult
14550: oCall 12364
14552: oPop 2
14554: oAssign
14555: oGetAddrGlobal 8
14557: oPushResult
14558: oSetResult 35
14560: oPushResult
14561: oSetResult 1
14563: oPushResult
14564: oCall 12364
14566: oPop 2
14568: oAssign
14569: oGetAddrGlobal 9
14571: oPushResult
14572: oSetResult 36
14574: oPushResult
14575: oSetResult 1
14577: oPushResult
14578: oCall 12364
14580: oPop 2
14582: oAssign
14583: oGetAddrGlobal 10
14585: oPushResult
14586: oGetGlobal 9
14588: oPushResult
14589: oCall 13477
14591: oPop 1
14593: oAssign
14594: oGetAddrGlobal 11
14596: oPushResult
14597: oSetResult 30
14599: oPushResult
14600: oSetResult 1
14602: oPushResult
14603: oCall 12364
14605: oPop 2
14607: oAssign
14608: oGetAddrGlobal 12
14610: oPushResult
14611: oSetResult 32
14613: oPushResult
14614: oSetResult 4
14616: oPushResult
14617: oCall 12364
14619: oPop 2
14621: oAssign
14622: oGetAddrGlobal 13
14624: oPushResult
14625: oSetResult 33
14627: oPushResult
14628: oSetResult 8
14630: oPushResult
14631: oCall 12364
14633: oPop 2
14635: oAssign
14636: oGetAddrGlobal 14
14638: oPushResult
14639: oSetResult 38
14641: oPushResult
14642: oSetResult 8
14644: oPushResult
14645: oCall 12364
14647: oPop 2
14649: oAssign
14650: oGetGlobal 14
14652: oPushResult
14653: oSetResult 38
14655: oPushResult
14656: oGetGlobal 11
14658: oPushResult
14659: oNodeSet
14660: oPop 3
14662: oGetAddrGlobal 15
14664: oPushResult
14665: oSetResult 42
14667: oPushResult
14668: oSetResult 256
14670: oPushResult
14671: oCall 12364
14673: oPop 2
14675: oAssign
14676: oGetAddrGlobal 16
14678: oPushResult
14679: oSetResult 43
14681: oPushResult
14682: oSetResult 256
14684: oPushResult
14685: oCall 12364
14687: oPop 2
14689: oAssign
14690: oGetGlobal 16
14692: oPushResult
14693: oSetResult 43
14695: oPushResult
14696: oSetResult 255
14698: oPushResult
14699: oNodeSetInt
14700: oPop 3
14702: oGetAddrLocal 1
14704: oPushResult
14705: oSetResult 20
14707: oPushResult
14708: oId_File
14709: oPushResult
14710: oCall 14430
14712: oPop 2
14714: oAssign
14715: oGetLocal 1
14717: oPushResult
14718: oSetResult 21
14720: oPushResult
14721: oGetGlobal 5
14723: oPushResult
14724: oNodeSet
14725: oPop 3
14727: oGetLocal 1
14729: oPushResult
14730: oScopeDeclare
14731: oPop 1
14733: oGetAddrLocal 1
14735: oPushResult
14736: oSetResult 20
14738: oPushResult
14739: oId_Integer
14740: oPushResult
14741: oCall 14430
14743: oPop 2
14745: oAssign
14746: oGetLocal 1
14748: oPushResult
14749: oSetResult 21
14751: oPushResult
14752: oGetGlobal 6
14754: oPushResult
14755: oNodeSet
14756: oPop 3
14758: oGetLocal 1
14760: oPushResult
14761: oScopeDeclare
14762: oPop 1
14764: oGetAddrLocal 1
14766: oPushResult
14767: oSetResult 20
14769: oPushResult
14770: oId_Boolean
14771: oPushResult
14772: oCall 14430
14774: oPop 2
14776: oAssign
14777: oGetLocal 1
14779: oPushResult
14780: oSetResult 21
14782: oPushResult
14783: oGetGlobal 7
14785: oPushResult
14786: oNodeSet
14787: oPop 3
14789: oGetLocal 1
14791: oPushResult
14792: oScopeDeclare
14793: oPop 1
14795: oGetAddrLocal 1
14797: oPushResult
14798: oSetResult 20
14800: oPushResult
14801: oId_Char
14802: oPushResult
14803: oCall 14430
14805: oPop 2
14807: oAssign
14808: oGetLocal 1
14810: oPushResult
14811: oSetResult 21
14813: oPushResult
14814: oGetGlobal 9
14816: oPushResult
14817: oNodeSet
14818: oPop 3
14820: oGetLocal 1
14822: oPushResult
14823: oScopeDeclare
14824: oPop 1
14826: oGetAddrLocal 1
14828: oPushResult
14829: oSetResult 20
14831: oPushResult
14832: oId_Byte
14833: oPushResult
14834: oCall 14430
14836: oPop 2
14838: oAssign
14839: oGetLocal 1
14841: oPushResult
14842: oSetResult 21
14844: oPushResult
14845: oGetGlobal 11
14847: oPushResult
14848: oNodeSet
14849: oPop 3
14851: oGetLocal 1
14853: oPushResult
14854: oScopeDeclare
14855: oPop 1
14857: oGetAddrLocal 1
14859: oPushResult
14860: oSetResult 20
14862: oPushResult
14863: oId_Single
14864: oPushResult
14865: oCall 14430
14867: oPop 2
14869: oAssign
14870: oGetLocal 1
14872: oPushResult
14873: oSetResult 21
14875: oPushResult
14876: oGetGlobal 12
14878: oPushResult
14879: oNodeSet
14880: oPop 3
14882: oGetLocal 1
14884: oPushResult
14885: oScopeDeclare
14886: oPop 1
14888: oGetAddrLocal 1
14890: oPushResult
14891: oSetResult 20
14893: oPushResult
14894: oId_Double
14895: oPushResult
14896: oCall 14430
14898: oPop 2
14900: oAssign
14901: oGetLocal 1
14903: oPushResult
14904: oSetResult 21
14906: oPushResult
14907: oGetGlobal 13
14909: oPushResult
14910: oNodeSet
14911: oPop 3
14913: oGetLocal 1
14915: oPushResult
14916: oScopeDeclare
14917: oPop 1
14919: oGetAddrLocal 1
14921: oPushResult
14922: oSetResult 20
14924: oPushResult
14925: oId_Pointer
14926: oPushResult
14927: oCall 14430
14929: oPop 2
14931: oAssign
14932: oGetLocal 1
14934: oPushResult
14935: oSetResult 21
14937: oPushResult
14938: oGetGlobal 14
14940: oPushResult
14941: oNodeSet
14942: oPop 3
14944: oGetLocal 1
14946: oPushResult
14947: oScopeDeclare
14948: oPop 1
14950: oGetAddrLocal 1
14952: oPushResult
14953: oSetResult 20
14955: oPushResult
14956: oId_ShortString
14957: oPushResult
14958: oCall 14430
14960: oPop 2
14962: oAssign
14963: oGetLocal 1
14965: oPushResult
14966: oSetResult 21
14968: oPushResult
14969: oGetGlobal 16
14971: oPushResult
14972: oNodeSet
14973: oPop 3
14975: oGetLocal 1
14977: oPushResult
14978: oScopeDeclare
14979: oPop 1
14981: oGetAddrLocal 1
14983: oPushResult
14984: oSetResult 16
14986: oPushResult
14987: oId_True
14988: oPushResult
14989: oCall 14430
14991: oPop 2
14993: oAssign
14994: oGetLocal 1
14996: oPushResult
14997: oSetResult 21
14999: oPushResult
15000: oGetGlobal 7
15002: oPushResult
15003: oNodeSet
15004: oPop 3
15006: oGetLocal 1
15008: oPushResult
15009: oSetResult 22
15011: oPushResult
15012: oSetResult 1
15014: oPushResult
15015: oNodeSetInt
15016: oPop 3
15018: oGetLocal 1
15020: oPushResult
15021: oScopeDeclare
15022: oPop 1
15024: oGetAddrLocal 1
15026: oPushResult
15027: oSetResult 16
15029: oPushResult
15030: oId_False
15031: oPushResult
15032: oCall 14430
15034: oPop 2
15036: oAssign
15037: oGetLocal 1
15039: oPushResult
15040: oSetResult 21
15042: oPushResult
15043: oGetGlobal 7
15045: oPushResult
15046: oNodeSet
15047: oPop 3
15049: oGetLocal 1
15051: oPushResult
15052: oSetResult 22
15054: oPushResult
15055: oSetResult 0
15057: oPushResult
15058: oNodeSetInt
15059: oPop 3
15061: oGetLocal 1
15063: oPushResult
15064: oScopeDeclare
15065: oPop 1
15067: oGetAddrLocal 1
15069: oPushResult
15070: oSetResult 16
15072: oPushResult
15073: oId_Nil
15074: oPushResult
15075: oCall 14430
15077: oPop 2
15079: oAssign
15080: oGetLocal 1
15082: oPushResult
15083: oSetResult 21
15085: oPushResult
15086: oGetGlobal 14
15088: oPushResult
15089: oNodeSet
15090: oPop 3
15092: oGetLocal 1
15094: oPushResult
15095: oSetResult 22
15097: oPushResult
15098: oSetResult 0
15100: oPushResult
15101: oNodeSetInt
15102: oPop 3
15104: oGetLocal 1
15106: oPushResult
15107: oScopeDeclare
15108: oPop 1
15110: oGetAddrGlobal 17
15112: oPushResult
15113: oId_Ord
15114: oPushResult
15115: oCall 14474
15117: oPop 1
15119: oAssign
15120: oGetAddrGlobal 18
15122: oPushResult
15123: oId_Chr
15124: oPushResult
15125: oCall 14474
15127: oPop 1
15129: oAssign
15130: oGetAddrGlobal 19
15132: oPushResult
15133: oId_Pred
15134: oPushResult
15135: oCall 14474
15137: oPop 1
15139: oAssign
15140: oGetAddrGlobal 20
15142: oPushResult
15143: oId_Succ
15144: oPushResult
15145: oCall 14474
15147: oPop 1
15149: oAssign
15150: oGetAddrGlobal 21
15152: oPushResult
15153: oId_Sizeof
15154: oPushResult
15155: oCall 14474
15157: oPop 1
15159: oAssign
15160: oReturn
