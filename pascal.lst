   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression ^x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Functions. 
      %      Caller allocates a temporary variable for the result.
      %      The params contain an extra hidden VAR parameter, i.e. passing in the temporary by reference.
      %      After the call, the caller pushes a reference to the temporary on the expression stack.
      %      (This would push a scalar value, or the addr of the temporary if a compound type.)
      %
      %    - VAR parameters need work, on caller side and reference side (lhs and rhs).
      %
      %    - Forward declaration of proceudres and functions.
      %      Only one forward declaration should be allowed.
      %      I will overwrite the nMethod info with the final addr and param names when the true body is seen.
      %      If a call is made to a foward declared method, add the forward decl node & Here to patch table.
      % 
      %    - procedure and function declarations may be nested within other procs/funcs!
      %      They are allowed to see locals within those parent scopes.
      %      Pass a hidden parameter to nested methods, to follow up to parent scopes as needed.
      %      Need a level counter at each scope, and uplevels count on reference to local/param.
      %      
      %    - Consider non-ISO extensions.  e.g. see "Units" e.g. from Turbo Pascal wikipedia page.
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %    - x86 code generation.
      %
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pCycle
   2:    pExit
   2:    pReturn
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var
   2:    tPushLocalB       % <offset> - push byte value read from local var
   2:    tPushLocalP       % <offset> - push ptr value read from local var
   2:    tPushParamI       % <offset> - push int value read from local var
   2:    tPushParamB       % <offset> - push byte value read from local var
   2:    tPushParamP       % <offset> - push ptr value read from local var
      
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % #words follows.  tos=src, 2nd=dest (pop 2)
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tAnd              % boolean AND of top 2 (pop 2, push 1)
   2:    tOr               % boolean OR or top 2 (pop 2, push 1)
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nProgram
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nConst
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nBooleanType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qDecls
   2: 	qSize
   2: 	qAllocDown
   2: 	qIdent
   2: 	qType
   2: 	qValue
   2: 	qMainRoutineScope
   2: 	qParams
   2: 	qChildScope
   2: 	qAddrDefined
   2: 	qResultOffset
   2: 	qInOut
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:     Null = 0
   2:     ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:     NullVec = 0
   2:     ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
   2: type kind:           % kind of identifier
   2:    kUndefined        % not yet added to symbol table
   2:    kProgram
   2:    kProc
   2:    kFunc
   2:    kConst
   2:    kType
   2:    kVar;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull;
      
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetKind (Node, node_attribute, kind) % set attribute of node  *** MIGHT NOT NEED
   2:     oNodeSetLabel( Node, node_attribute, Label )
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeNext (inout Node)               % advance Node to next in list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     Here >> int                  % current address in the generated code
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin                          % create a new scope. Subsequent declarations will go here.
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     ;
      
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit;            % alloc data space for strlit, push address
                                     %   on value stack
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label cycleLabel, Label exitLabel )
   2:    oLoopCycleLabel >> Label
   2:    oLoopExitLabel >> Label
   2:    oLoopPop
   2:    ;
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    globalScope            % global nScope
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    CharType
   2: Node    StringType
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, kind k, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node progDecl
   4:    Node t
      
   4:    oScopeBegin
   5:    globalScope = oScopeCurrent
      
  10:    @installBuiltIns
      
         % Start by calling the main program routine
  12:    Label mainLabel
  12:    mainLabel = oLabelNew
      
  17:    .tCall  oEmitLabel( mainLabel )
  25:    .tReturn
      
  27:    pProgram
  29:    pIdent
      
  31:    progDecl = @newIdent( nProgram, kProgram, LAST_ID )
  47:    oScopeDeclare( progDecl )
      
  53:    [
  53:       | '(' :
  55:          pIdent      % input, output files
      
  57:          t = @newIdent( nVar, kVar, LAST_ID )
  73:          oNodeSet( t, qType, FileType )
  85:          oScopeDeclareAlloc( t )
      
  91:          ','
  93:          pIdent
      
  95:          t = @newIdent( nVar, kVar, LAST_ID )
 111:          oNodeSet( t, qType, FileType )
 123:          oScopeDeclareAlloc( t )
      
 129:          ')'
 131:       | * :
 136:    ]
 136:    ';'
      
 138:    @BlockDecls( nGlobalVar )
      
         % a new scope just for temporaries in the main routine
 145:    oScopeBegin
 146:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 157:    oNodeSet( progDecl, qMainRoutineScope, oScopeCurrent )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
 168:    @BlockStmt( mainLabel )
      
 175:    oScopeEnd   % main routine scope
      
 176:    '.'
 178:    oScopeEnd   % global scope
 180:    ;
      
      
 180: Block( node_type varNodeType, Label labelForBody ):
 182:    @BlockDecls( varNodeType )
 189:    @BlockStmt( labelForBody )
 197:    ;
      
      
 197: BlockDecls( node_type varNodeType ):
 199:    {[
 199:       | pConst :     @ConstDecl
 203:       | pType :      @TypeDecl
 207:       | pVar :       @VarDecl( varNodeType )
 216:       | pProcedure : @ProcDecl
 220:       | pFunction :  @FuncDecl
 224:       | * :          >
 239:    ]};
      
      
 242: BlockStmt( Label labelForBody ):
 244:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
 252:    int patchLS
 252:    .tEnter  patchLS = Here  .tSpace
      
 261:    @Statement
 263:    .tReturn
      
 265:    int localSpace
 265:    localSpace = oNodeGetInt( oScopeCurrent, qSize )
 277:    oPatch( patchLS, localSpace )
 287:    ;
      
      
      
 287: ProcDecl:
 289:    Node decl
      
 289:    pIdent
 291:    decl = @newIdent( nProc, kProc, LAST_ID )
      
 307:    oScopeBegin
 308:    Node paramScope
 308:    paramScope = oScopeCurrent
      
 313:    @FormalArgDecl
 315:    oNodeSet( decl, qParams, paramScope )
 327:    oScopeEnd
      
 328:    oScopeDeclare( decl )
 334:    ';'
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 336:    oScopeEnter( paramScope )
      
         % Start scope for declarations within the proc
 342:    oScopeBegin
 343:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 354:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 365:    Label label
 365:    label = oLabelNew
 370:    @Block( nLocalVar, label )
 380:    oNodeSetLabel( decl, qValue, label )
 392:    oNodeSetBoolean( decl, qAddrDefined, true )
 404:    oScopeEnd
      
 405:    oScopeEnd  % paramScope
 406:    ';';
      
 409: FuncDecl:
 411:    Node decl
 411:    Node theType
      
 411:    pIdent
 413:    decl = @newIdent( nFunc, kFunc, LAST_ID )
      
 429:    oScopeBegin
 430:    Node paramScope
 430:    paramScope = oScopeCurrent
      
 435:    @FormalArgDecl
 437:    oNodeSet( decl, qParams, paramScope )
      
 449:    ':'
      
 451:    @TypeRef( theType )
 458:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
 470:    Node ptrType
 470:    ptrType = @PointerTypeTo( theType )
 481:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
      
 497:    ';'
      
 499:    oScopeEnd
 500:    oScopeDeclare( decl )
      
         % Enter the params scope again, so params are visible in body.
         % TO DO: Perhaps I could mark the scope read-only at this point.
 506:    oScopeEnter( paramScope )
      
 512:    oScopeBegin
 513:    oNodeSetBoolean( oScopeCurrent, qAllocDown, true )
 524:    oNodeSet( decl, qChildScope, oScopeCurrent )
      
 535:    Label label
 535:    label = oLabelNew
 540:    @Block( nLocalVar, label )
 550:    oNodeSetLabel( decl, qValue, label )
 562:    oNodeSetBoolean( decl, qAddrDefined, true )
 574:    oScopeEnd
      
 575:    oScopeEnd  % paramScope
 576:    ';';
      
      
 579: FormalArgDecl:
 581:    [
 581:       | '(' :
 583:          {
 583:             NodeVec decls
 583:             decls = oNodeVecNew
 588:             Node decl
 588:             boolean isInOut
 588:             isInOut = false
      
 594:             [
 594:                | pVar : isInOut = true
 602:                | * :
 607:             ]
      
 607:             {  pIdent
      
 609:                decl = @newIdent( nParam, kVar, LAST_ID )
 625:                oNodeSetBoolean( decl, qInOut, isInOut )
 637:                oNodeVecAppend( decls, decl )
      
 646:                [
 646:                   | ':' : >
 650:                   | ',' :
 652:                ]
 660:             }
      
 662:             Node theType
 662:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
 669:             Node allocType
 669:             [ isInOut
 672:                | true :   allocType = @PointerTypeTo( theType )
 684:                | * :      allocType = theType
 695:             ]
      
 695:             int i
 695:             i = 0
 701:             {[ equal( i, oNodeVecSize( decls ) )
 715:                | false :
 716:                   decl = oNodeVecElement( decls, i )
      
 729:                   oNodeSet( decl, qType, theType )
 741:                   oScopeDeclare( decl )
 747:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
 763:                   inc( i )
 769:                | * :
 774:                   >
 776:             ]}
      
 778:             oNodeVecDelete( decls )
      
 784:             [
 784:                | ')' : >
 788:                | ';' :
 790:             ]
 798:          }
 800:       | * :
 805:    ];
      
 806: ConstDecl:
 808:    {[
 808:       | pIdent :
 810:          Node decl
 810:          decl = @newIdent( nConst, kConst, LAST_ID )
 826:          '='
      
 828:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
 830:          int val
 830:          val = oValueTop
 835:          oValuePop
 836:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
 848:          oNodeSet( decl, qType, IntegerType )
      
 860:          oScopeDeclare( decl )
 866:          ';'
 868:       | * :
 873:          >
 875:    ]};
      
 878: TypeDecl:
 880:    {[
 880:       | pIdent :
 882:          Node decl
 882:          decl = @newIdent( nTypeDecl, kType, LAST_ID )
 898:          '='
 900:          Node theType
 900:          @TypeRef( theType )
 907:          oNodeSet( decl, qType, theType )
 919:          oScopeDeclare( decl )
 925:          ';'
 927:       | * :
 932:          >
 934:    ]};
      
 937: VarDecl( node_type varNodeType ):
 939:    {[
 939:       | pIdent :
 941:          NodeVec decls
 941:          decls = oNodeVecNew
 946:          Node decl
 946:          {
 946:             decl = @newIdent( varNodeType, kVar, LAST_ID )
 962:             oNodeVecAppend( decls, decl )
 971:             [
 971:                | ',' :
 973:                   pIdent
 975:                | * :
 980:                   >
 982:             ]
 982:          }
 984:          ':'
 986:          Node theType
 986:          @TypeRef( theType )
      
 993:          int i
 993:          i = 0
 999:          {[ equal( i, oNodeVecSize( decls ) )
1013:            | false :
1014:              decl = oNodeVecElement( decls, i )
1027:              oNodeSet( decl, qType, theType )
1039:              oScopeDeclareAlloc( decl )
1045:              inc( i )
1051:             | * :
1056:               >
1058:          ]}
      
1060:          oNodeVecDelete( decls )
1066:          ';'
1068:       | * :
1073:          >
1075:    ]};
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
1078: TypeRef( out Node resultType ):
1080:    [
1080:       | pIdent :           % previously named type (including intrinsics)
1082:          Node decl
1082:          decl = oScopeFindRequire
1087:          [ oNodeType( decl )
1094:            | nTypeDecl :
1095:                resultType = oNodeGet( decl, qType )
1108:            | * :
1113:                #eNotType
1115:                resultType = IntegerType
1121:          ]
         
1121:       | pArray :
1123:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
1125:          NodeVec dimensions
1125:          dimensions = oNodeVecNew
      
1130:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
1130:             Node subrange
1130:             subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
1140:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
1152:             @ConstExpr
1154:             oNodeSetInt( subrange, qLow, oValueTop )
1165:             oValuePop
1166:             '..'
1168:             @ConstExpr
1170:             oNodeSetInt( subrange, qHigh, oValueTop )
1181:             oValuePop
1182:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
1194:             oTypeAdd( subrange )
      
1200:             Node a
1200:             a = oNodeNew( nArrayType )
1210:             oNodeSet( a, qIndexType, subrange )
      
1222:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
1231:             [
1231:                | ']' : >
1235:                | ',' :
1237:             ]
1245:          }
1247:          pOf
1249:          Node baseType
1249:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
1256:          int dim
1256:          dim = oNodeVecSize( dimensions )
1266:          {
1266:              dec(dim)
      
1272:              Node a
1272:              a = oNodeVecElement( dimensions, dim )
1285:              oNodeSet( a, qBaseType, baseType )
1297:              Node subrange
1297:              subrange = oNodeGet( a, qIndexType )
1310:              int width
1310:              width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
1337:              inc( width )
1343:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
1369:              oTypeAdd( a )
1375:              baseType = a
      
1381:              [ equal_zero(dim)
1388:                  | true:  >
1391:                  | *:
1396:              ]
1396:          }
      
1398:          resultType = oNodeVecElement( dimensions, 0 )
1411:          oNodeVecDelete( dimensions )
      
1417:       | '^' :
1419:          Node theType
1419:          @TypeRef( theType )
1426:          resultType = @PointerTypeTo( theType )
      
1437:       | pRecord :
1439:          resultType = oNodeNew( nRecordType )
1449:          oScopeBegin
      
1450:          @VarDecl( nRecordField )
      
1457:          int size
1457:          size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
1469:          [ equal_zero( size )
1476:             | true : #eRecordEmpty
1479:             | * :
1484:          ]
      
1484:          pEnd
      
1486:          oNodeSet( resultType, qScope, oScopeCurrent )
1497:          oNodeSetInt( resultType, qSize, size )
1509:          oScopeEnd
1510:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
            % *** TO DO: also missing declaration of enum type
1516:       | pSet :
1518:          pOf
1520:          Node theType
1520:          @TypeRef( theType )
1527:       | * :       % this works for cases except where expr starts with an id
1540:          @ConstExpr '..' @ConstExpr
1546:    ];
      
      
      % ------------------------------ Expressions -----------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
1547: ConstExpr:
1549:    [
1549:       | pIntLit :
1551:          oValuePush( TOKEN_VALUE )
1556:       | pIdent :
1558:          Node decl
1558:          decl = oScopeFindRequire
1563:          [ oNodeType( decl )
1570:             | nConst :
1571:                oValuePush( oNodeGetInt( decl, qValue ) )
1584:             | * :
1589:                #eNotConst
1591:                oValuePush( 0 )
1597:          ]
1597:       | pMinus :
1599:          @ConstExpr
1601:          oValueNegate
1602:    ];
      
      %
      % General run-time expressions
      % The type stack tracks the type of the expression.
      %
      
1613: Expr:
1615:    @BoolExpr
1617:    {[
1617:       | '=' :
1619:          @BoolExpr
1621:          @MatchTypes
1623:          [ oTypeSNodeType
1625:             | nIntegerType, nBooleanType :  .tEqualI
1628:             | nPointerType :                .tEqualP
1632:             | nCharType, nStringType :      #eNotImplemented
1636:             | * :                           #eNotAllowed
1651:          ]
1651:          oTypeSPop
1652:          oTypeSPush( BooleanType )
      
1658:       | '<>' :
1660:          @BoolExpr
1662:          @MatchTypes
1664:          [ oTypeSNodeType
1666:             | nIntegerType, nBooleanType :  .tNotEqualI
1669:             | nPointerType :                .tNotEqualP
1673:             | nCharType, nStringType :      #eNotImplemented
1677:             | * :                           #eNotAllowed
1692:          ]
1692:          oTypeSPop
1693:          oTypeSPush( BooleanType )
      
1699:       | '<' :
1701:          @BoolExpr
1703:          @MatchTypes
1705:          [ oTypeSNodeType
1707:             | nIntegerType, nBooleanType :  .tLessI
1710:             | nCharType, nStringType :      #eNotImplemented
1714:             | * :                           #eNotAllowed
1727:          ]
1727:          oTypeSPop
1728:          oTypeSPush( BooleanType )
      
1734:       | '>' :
1736:          @BoolExpr
1738:          @MatchTypes
1740:          [ oTypeSNodeType
1742:             | nIntegerType, nBooleanType :  .tGreaterI
1745:             | nCharType, nStringType :      #eNotImplemented
1749:             | * :                           #eNotAllowed
1762:          ]
1762:          oTypeSPop
1763:          oTypeSPush( BooleanType )
      
1769:       | '<=' :
1771:          @BoolExpr
1773:          @MatchTypes
1775:          [ oTypeSNodeType
1777:             | nIntegerType, nBooleanType :  .tLessEqualI
1780:             | nCharType, nStringType :      #eNotImplemented
1784:             | * :                           #eNotAllowed
1797:          ]
1797:          oTypeSPop
1798:          oTypeSPush( BooleanType )
      
1804:       | '>=' :
1806:          @BoolExpr
1808:          @MatchTypes
1810:          [ oTypeSNodeType
1812:             | nIntegerType, nBooleanType :  .tGreaterEqualI
1815:             | nCharType, nStringType :      #eNotImplemented
1819:             | * :                           #eNotAllowed
1832:          ]
1832:          oTypeSPop
1833:          oTypeSPush( BooleanType )
      
1839:       | * :
1854:          >
1856:    ]};
      
1859: BoolExpr:
1861:    @BoolTerm
1863:    {[
1863:       | pOr :
1865:          @RequireBoolPop
1867:          @BoolTerm
1869:          @RequireBool
1871:          .tOr
1873:       | * :
1878:          >
1880:    ]};
      
1883: BoolTerm:
1885:    @BoolFactor
1887:    {[
1887:       | pAnd :
1889:          @RequireBoolPop
1891:          @BoolFactor
1893:          @RequireBool
1895:          .tAnd
1897:       | * :
1902:          >
1904:    ]};
      
1907: BoolFactor:
1909:    [
1909:       | pNot :
               % TO DO: Is the grammar shown in FPC docs standard?
               %   That's where I took the recursive definition  factor: 'not' factor
               %   If not where can I find the a standard grammar.
               %
               % TO DO: FPC says there is a xor operator too, which I don't accept.
               % TO DO: apparently operator and or xor not  can work as bitwise operations on integer/ordinal
               %     operands, in addition to being short-circuit boolean operations.
               %     I haven't allowed for that yet.
      
1911:          @BoolFactor
1913:          @RequireBool
1915:          .tNot
1917:       | * :
1922:          @ArithExpr
1924:    ];
      
1925: ArithExpr:
1927:    @Term
1929:    {[
1929:       | pPlus :
1931:          @RequireIntPop
1933:          @Term
1935:          @RequireInt
1937:          .tAddI
1939:       | pMinus :
1941:          @RequireIntPop
1943:          @Term
1945:          @RequireInt
1947:          .tSubI
1949:       | * :
1956:          >
1958:    ]};
      
1961: Term:
1963:    @Factor
1965:    {[
1965:       | pTimes :
1967:          @RequireIntPop
1969:          @Factor
1971:          @RequireInt
1973:          .tMultI
1975:       | pDivide :
1977:          @RequireIntPop
1979:          @Factor
1981:          @RequireInt
1983:          .tDivI
1985:       | * :
1992:          >
1994:    ]};
      
1997: Factor:
1999:    [
1999:       | pPlus :
2001:          @Primary
2003:          @RequireInt
2005:       | pMinus :
2007:          @Primary
2009:          @RequireInt
2011:          .tNegI
2013:       | * :
2020:          @Primary
2022:    ];
      
2023: Primary:
2025:    [
2025:       | pIntLit :
2027:          .tPushConstI  oEmitInt( TOKEN_VALUE )
2034:          oTypeSPush( IntegerType )
      
2040:       | '(' :
2042:          @Expr
2044:          ')'
      
2046:       | pStrLit :
2048:          oStringAllocLit     % store in global data, push offset on value stack
2049:          .tPushAddrGlobal oEmitInt( oValueTop )  oValuePop
               % TO DO: do we need to create a type with the literal's length?
2057:          oTypeSPush( StringType )
      
2063:       | pIdent :
2065:          Node decl
2065:          Node theType
2065:          decl = oScopeFindRequire
      
2070:          [ oNodeType( decl )
2077:             | nFunc :
      
2078:                @Call( decl )
      
2085:             | nConst :
2087:                theType = oNodeGet( decl, qType )
2100:                oTypeSPush( theType )
2106:                [ oTypeSNodeType
2108:                   | nIntegerType, nBooleanType :
2109:                      .tPushConstI @EmitValue( decl )
2118:                   | * :
2125:                      #eNotImplemented
2127:                ]
      
2127:             | nGlobalVar, nLocalVar, nParam :
2129:                @VarExpr( decl )
      
2136:             | * :
2149:                #eNotValue
2151:                oTypeSPush( IntegerType )
2157:          ]
      
2157:       | '^' :        % ^var
2159:          pIdent
      
2161:          Node decl
2161:          Node theType
2161:          decl = oScopeFindRequire
      
2166:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
2173:          theType = oTypeSTop
2178:          oTypeSPop
2179:          Node ptrType
2179:          ptrType = @PointerTypeTo( theType )
2190:          oTypeSPush( ptrType )
      
2196:       | * :
2209:          #eNotValue
2211:          oTypeSPush( IntegerType )
2217:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
2218: VarExpr( Node decl ):
2220:    Node theType
2220:    theType = oNodeGet( decl, qType )
2233:    oTypeSPush( theType )
2239:    [ oTypeSNodeType
2241:       | nIntegerType :
2242:          [ oNodeType( decl )
2249:             | nGlobalVar :   .tPushGlobalI @EmitValue( decl )
2259:             | nLocalVar :    .tPushLocalI @EmitValue( decl )
2270:             | nParam :
2272:                [ oNodeGetBoolean( decl, qInOut )
2282:                   | true :    % VAR param points to the var.  Auto dereference.
2283:                               .tPushParamP @EmitValue( decl )
2292:                               .tFetchI
2294:                   | * :       .tPushParamI @EmitValue( decl )
2308:                ]
2308:          ]
      
2318:       | nBooleanType :
2320:          [ oNodeType( decl )
2327:             | nGlobalVar :   .tPushGlobalB @EmitValue( decl )
2337:             | nLocalVar :    .tPushLocalB @EmitValue( decl )
2348:             | nParam :
2350:                [ oNodeGetBoolean( decl, qInOut )
2360:                   | true :    % VAR param points to the var.  Auto derefernce.
2361:                               .tPushParamP @EmitValue( decl )
2370:                               .tFetchB
2372:                   | * :       .tPushParamB @EmitValue( decl )
2386:                ]
2386:          ]
      
2396:       | nCharType, nStringType, nFileType :
2398:          #eNotImplemented
      
2400:       | nPointerType :
2402:          [ oNodeType( decl )
2409:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
2419:             | nLocalVar :    .tPushLocalP @EmitValue( decl )
2430:             | nParam :
2432:                [ oNodeGetBoolean( decl, qInOut )
2442:                   | true :    % VAR param points to the var.  Auto derefernce.
2443:                               .tPushParamP @EmitValue( decl )
2452:                               .tFetchP
2454:                   | * :       .tPushParamP @EmitValue( decl )
2468:                ]
2468:          ]
2478:          [
2478:             | '^' :             % dereferenced
2480:                oTypeSPop
2481:                oTypeSPush( oNodeGet( theType, qBaseType ) )
2494:                @LValueIndexes
2496:                @FetchVar
2498:             | * :               % just ptr value alone
2503:          ]
      
2503:       | * :
               % compound type
               % first, push addr of start of var
2518:          [ oNodeType( decl )
2525:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
2535:             | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
2546:             | nParam :
2548:                [ oNodeGetBoolean( decl, qInOut )
2558:                   | true :    % VAR param points to the var.  Auto derefernce.
2559:                               .tPushParamP @EmitValue( decl )
2568:                   | * :       .tPushAddrParam @EmitValue( decl )
2582:                ]
2582:          ]
               % modify addr for subscripts, field references, etc
2592:          @LValueIndexes
               % get final value
2594:          @FetchVar
2596:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
2597: FetchVar:
2599:    [ oTypeSNodeType
2601:       | nIntegerType :   .tFetchI
2604:       | nBooleanType :   .tFetchB
2608:       | nCharType, nStringType, nFileType : #eNotImplemented
2612:       | nPointerType :   .tFetchP
2616:       | * :              % compound type; leave as addr
2631:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
2632: LValueIndexes:
2634:    {[
2634:       | '[' :       @ArraySubscripts
2638:       | '.' :       @RecordFieldRef
2642:       | '^' :       @PointerDeref
2646:       | * :         >
2657:    ]};
      
2660: ArraySubscripts:
2662:    [ oTypeSNodeType
2664:       | nArrayType :
2665:       | * :       #eNotArray
2672:    ]
2672:    {
2672:       [ oTypeSNodeType
2674:          | nArrayType :
2675:          | * :    #eTooManySubscripts
2682:       ]
      
            % low subscript of this dimension
2682:       int low
2682:       low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
2699:       Node baseType
2699:       baseType = oNodeGet( oTypeSTop, qBaseType )
2711:       oTypeSPop
2712:       oTypeSPush( baseType )
      
2718:       @Expr
2720:       @RequireIntPop
            % adjust for low subscript
2722:       [ equal_zero( low )
2729:          | false :
2730:             .tPushConstI oEmitInt( low ) .tSubI
2740:          | * :
2745:       ]
      
            % multiply by element size
2745:       int size
2745:       size = oNodeGetInt( baseType, qSize )
2758:       [ equal( size, 1 )
2768:          | false :
2769:             .tPushConstI oEmitInt( size ) .tMultI
2779:          | * :
2784:       ]
      
            % update start address
2784:       .tAddPI
2786:       [
2786:          | ']' :  >
2790:          | ',' :
2792:       ]
2800:    };
      
      
2803: RecordFieldRef:
2805:    [ oTypeSNodeType
2807:       | nRecordType :
2808:       | * :    #eNotRecord
2815:    ]
2815:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
2827:    pIdent
2829:    Node field
2829:    field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
2834:    [ oNodeType( field )
2841:       | nRecordField :
2842:       | * :   #eNotRecordField
2849:    ]
2849:    oScopeEnd
2850:    int offset
2850:    offset = oNodeGetInt( field, qValue )
2863:    [ equal_zero( offset )
2870:       | false :
2871:          .tPushConstI oEmitInt( offset ) .tAddPI
2881:       | * :
2886:    ]
      
         % replace the type on the type stack, with the field type
2886:    oTypeSPop
2887:    oTypeSPush( oNodeGet( field, qType ) )
2901:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
2901: PointerDeref:
2903:    [ oTypeSNodeType
2905:       | nPointerType :
2906:       | * :       #eNotPointer
2913:    ]
2913:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
2915:    Node theType
2915:    theType = oTypeSTop
2920:    oTypeSPop
2921:    oTypeSPush( oNodeGet( theType, qBaseType ) )
2935:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
2935: CoerceType:
         % TO DO: not implemented yet.  For now I require exact type match.
2937:    @MatchTypes
2940:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
2940: Call( Node method ):
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
2942:    boolean isFunc
2942:    Node resultType
2942:    int tempOffset
      
2942:    isFunc = equal_node_type( oNodeType( method ), nFunc )
      
2959:    [ isFunc
2962:       | true :
2963:          resultType = oNodeGet( method, qType )
2976:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
2986:       | * :
2991:    ]
         
      
2991:    Node paramScope
2991:    paramScope = oNodeGet( method, qParams )
3004:    int actualsSize
3004:    actualsSize = oNodeGetInt( paramScope, qSize )
3017:    .tAllocActuals  oEmitInt( actualsSize )
      
3025:    Node param
3025:    param = oNodeGet( paramScope, qDecls )
3038:    [
3038:       | '(' :
            
3040:          {
3040:             [ oNodeNull( param )
3047:                | true : >
3050:                | * :
3055:             ]
      
3055:             int offset
3055:             offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
3068:             .tPushAddrActual oEmitInt( offset )
3076:             oTypeSPush( oNodeGet( param, qType ) )
      
3089:             [ oNodeGetBoolean( param, qInOut )
3099:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
3100:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
3102:                           @MatchTypes
      
3104:                           .tAssignP
      
3106:                | false :  @Expr
3110:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
3112:                           [ oTypeSNodeType
3114:                              | nIntegerType :            .tAssignI
3117:                              | nBooleanType :            .tAssignB
3121:                              | nCharType, nStringType, nFileType :   #eNotImplemented
3125:                              | nPointerType :            .tAssignP
3129:                              | * :
                                       % compound types: copy value into actuals space
3144:                                  int size
3144:                                  size = oNodeGetInt( oTypeSTop, qSize )
3156:                                  .tCopy  oEmitInt( size )    % multi-word copy
3164:                           ]
3164:             ]
3172:             oTypeSPop
      
3173:             oNodeNext( param )
3179:             [ oNodeNull( param )
3186:                | true :  >
3189:                | false :
3191:             ]
      
3199:             ','
3201:          }
      
3203:          ')'
      
3205:       | * :
3210:    ]
      
3210:    [ oNodeNull( param )
3217:       | false :    #eMissingParameter
3220:       | * :
3225:    ]
      
3225:    [ isFunc
3228:       | true :
               % Pass result temp as an additional VAR parameter.
3229:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
3244:          .tPushAddrLocal  oEmitInt( tempOffset )
3252:          .tAssignP
3254:       | * :
3259:    ]
      
3259:    .tCall   @EmitValue( method )
      
3268:    [ isFunc
3271:       | true :
               % push return value from temp
3272:          oTypeSPush( resultType )
3278:          .tPushAddrLocal  oEmitInt( tempOffset )
3286:          @FetchVar
3288:       | * :
3293:    ]
         
3293:    .tFreeActuals  oEmitInt( actualsSize )
3302:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
3302: Statement:
3304:    [
3304:       | pWriteln :     @WritelnStmt
3308:       | pWrite :       @WriteStmt
3312:       | pReadln :      @ReadlnStmt
3316:       | pRead :        @ReadStmt
3320:       | pIf :          @IfStmt
3324:       | pWhile :       @WhileStmt
3328:       | pFor :         @ForStmt
3332:       | pRepeat :      @RepeatStmt
3336:       | pExit :        @ExitStmt
3340:       | pCycle :       @CycleStmt
3344:       | pBegin :       @BeginStmt
3348:       | pIdent :       @AssignOrCallStmt
3352:       | * :            % null statement : don't accept any tokens
3379:    ];
      
      
3380: AssignOrCallStmt:
3382:    Node decl
3382:    decl = oScopeFindRequire
3387:    [ oNodeType( decl )
3394:       | nProc :                           @Call( decl )
3402:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
3411:       | nFunc :                           @AssignResultStmt( decl )
3420:       | * :                               #eBadStatement
3435:    ];
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
3436: AssignStmt( Node decl ):
      
3438:    @LValueVar( decl )
      
3445:    ':=' 
3447:    @Expr
3449:    @MatchTypes
3451:    [ oTypeSNodeType
3453:       | nIntegerType :            .tAssignI
3456:       | nBooleanType :            .tAssignB
3460:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3464:       | nPointerType :            .tAssignP
3468:       | * :
3483:           int size
3483:           size = oNodeGetInt( oTypeSTop, qSize )
3495:           .tCopy  oEmitInt( size )    % multi-word copy
3503:    ]
3503:    oTypeSPop
3505:    ;
      
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
3505: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
3507:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
3523:       | false :   #eNotCurrentFunction
3526:       | * :
3531:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
3531:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
3546:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
3559:    ':='
3561:    @Expr
3563:    @MatchTypes
3565:    [ oTypeSNodeType
3567:       | nIntegerType :            .tAssignI
3570:       | nBooleanType :            .tAssignB
3574:       | nCharType, nStringType, nFileType :   #eNotImplemented
      
            % compound var assigns; addrs of src, dest on stack
3578:       | nPointerType :            .tAssignP
3582:       | * :
3597:           int size
3597:           size = oNodeGetInt( oTypeSTop, qSize )
3609:           .tCopy  oEmitInt( size )    % multi-word copy
3617:    ]
3617:    oTypeSPop
3619:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
3619: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
3621:    pIdent
3623:    Node decl
3623:    decl = oScopeFindRequire
3628:    [ oNodeType( decl )
3635:       | nGlobalVar, nLocalVar, nParam :
3636:       | * :  #eNotVar
3647:    ]
3647:    @LValueVar( decl )
3655:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
3655: LValueVar( Node decl ):
3657:    [ oNodeType( decl )
3664:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
3674:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
3685:       | nParam :
3687:          [ oNodeGetBoolean( decl, qInOut )
3697:             | true :   % VAR param points to variable.  No dereference.
3698:                        .tPushParamP @EmitValue( decl )
3707:             | * :      .tPushAddrParam @EmitValue( decl )
3721:          ]
3721:       | * :            #eNotVar
3732:    ]
      
3732:    oTypeSPush( oNodeGet( decl, qType ) )
3745:    @LValueIndexes        % handle subscripts, if any
3748:    ;
      
      
3748: IncVar( Node decl ):
3750:    @LValueVar( decl )
3757:    @RequireIntPop
3759:    @VarExpr( decl )
3766:    oTypeSPop
3767:    .tIncI
3769:    .tAssignI;
      
3772: DecVar( Node decl ):
3774:    @LValueVar( decl )
3781:    @RequireIntPop
3783:    @VarExpr( decl )
3790:    oTypeSPop
3791:    .tDecI
3793:    .tAssignI;
      
      
3796: IfStmt:
3798:    Label falseLabel
3798:    falseLabel = oLabelNew
      
3803:    @Expr
3805:    @RequireBoolPop
3807:    pThen
3809:    .tJumpFalse  oEmitLabel( falseLabel )
3817:    @Statement
3819:    [
3819:       | pElse :
3821:          Label doneLabel
3821:          doneLabel = oLabelNew
      
3826:          .tJump  oEmitLabel( doneLabel )
3834:          .tLabel oEmitLabel( falseLabel )
3842:          @Statement
3844:          .tLabel oEmitLabel( doneLabel )
      
3852:       | * :
3857:          .tLabel oEmitLabel( falseLabel )
3865:    ];
      
      
3866: ForStmt:
3868:    pIdent
      
3870:    Node decl
3870:    decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
3875:    @LValueVar( decl )
3882:    @RequireIntPop
      
3884:    ':='
      
3886:    @Expr
3888:    @RequireIntPop
3890:    .tAssignI
      
3892:    Label exitLabel
3892:    exitLabel = oLabelNew
      
3897:    Label checkLabel
3897:    checkLabel = oLabelNew
3902:    .tJump  oEmitLabel( checkLabel )
      
3910:    Label cycleLabel
3910:    cycleLabel = oLabelNew
3915:    .tLabel  oEmitLabel( cycleLabel )
3923:    [
3923:       | pTo :
3925:          @IncVar( decl )
3932:          .tLabel  oEmitLabel( checkLabel )
3940:          @VarExpr( decl )  oTypeSPop
3948:          @Expr
3950:          @RequireIntPop
3952:          .tGreaterI
3954:          .tJumpTrue  oEmitLabel( exitLabel )
3962:       | pDownto :
3964:          @DecVar( decl )
3971:          .tLabel  oEmitLabel( checkLabel )
3979:          @VarExpr( decl )  oTypeSPop
3987:          @Expr
3989:          @RequireIntPop
3991:          .tLessI
3993:          .tJumpTrue  oEmitLabel( exitLabel )
4001:    ]
4009:    oLoopPush( cycleLabel, exitLabel )
4018:    pDo
4020:    @Statement
4022:    .tJump  oEmitLabel( cycleLabel )
4030:    .tLabel  oEmitLabel( exitLabel )
4038:    oLoopPop;
      
      
4040: RepeatStmt:
4042:    Label cycleLabel
4042:    cycleLabel = oLabelNew
4047:    .tLabel  oEmitLabel( cycleLabel )
      
4055:    Label exitLabel
4055:    exitLabel = oLabelNew
      
4060:    oLoopPush( cycleLabel, exitLabel )
4069:    @Statement
4071:    {[
4071:       | ';' :
4073:          @Statement
4075:       | pUntil :
4077:          @Expr
4079:          @RequireBoolPop
4081:          .tJumpFalse  oEmitLabel( cycleLabel )
4089:          >
4091:    ]}
4101:    .tLabel  oEmitLabel( exitLabel )
4109:    oLoopPop;
      
      
4111: WhileStmt:
4113:    Label cycleLabel
4113:    cycleLabel = oLabelNew
4118:    .tLabel  oEmitLabel( cycleLabel )
      
4126:    Label exitLabel
4126:    exitLabel = oLabelNew
      
4131:    oLoopPush( cycleLabel, exitLabel )
4140:    @Expr
4142:    @RequireBoolPop
4144:    pDo
4146:    .tJumpFalse  oEmitLabel( exitLabel )
4154:    @Statement
4156:    .tJump  oEmitLabel( cycleLabel )
4164:    .tLabel  oEmitLabel( exitLabel )
4172:    oLoopPop;
      
      
4174: CycleStmt:                     % NOTE, for repeat..until, skips test (??)
4176:    [ equal_label( oLoopCycleLabel, labelNull )
4185:       | true :
4186:          #eNotInALoop
4188:       | false :
4190:          .tJump  oEmitLabel( oLoopCycleLabel )
4197:    ];
      
      
4206: ExitStmt:
4208:    [ equal_label( oLoopExitLabel, labelNull )
4217:       | true :
4218:          #eNotInALoop
4220:       | false :
4222:          .tJump  oEmitLabel( oLoopExitLabel )
4229:    ];
      
      
4238: BeginStmt:
4240:    @Statement
4242:    {[
4242:       | ';' :   @Statement
4246:       | pEnd :  >
4250:    ]};
      
      
4261: WritelnStmt:
4263:    @WriteStmt
4265:    .tWriteCR;
      
      
4268: WriteStmt:
4270:    [
4270:       | '(' :
4272:          {
4272:             @Expr
4274:             [ oTypeSNodeType
4276:                | nIntegerType :             .tWriteI
4279:                | nBooleanType :             .tWriteBool
4283:                | nStringType :              .tWriteStr
4287:                | nCharType, nFileType :     #eNotImplemented
4291:                | nPointerType :             .tWriteP
4295:                | * :                        #eNotAllowed
4312:             ]
4312:             oTypeSPop
4313:             [
4313:                | ')' : >
4317:                | ',' :
4319:             ]
4327:          }
4329:       | * :
4334:    ];
      
      
4335: ReadlnStmt:      % ***
         % TO DO
4338:    ;
      
4338: ReadStmt:
         % TO DO
4341:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
4341: MatchTypes:
4343:    node_type nt
4343:    nt = oTypeSNodeType
4348:    oTypeSPop
4349:    [ equal_node_type( nt, oTypeSNodeType )
4358:       | false :
4359:          #eTypeMismatch
4361:       | * :
4366:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
4367: RequireIntPop:
4369:    [ oTypeSNodeType
4371:       | nIntegerType :
4372:       | * :          #eNotInteger
4379:    ]
4379:    oTypeSPop;
      
4381: RequireInt:
4383:    [ oTypeSNodeType
4385:       | nIntegerType :
4386:       | * :          #eNotInteger
4393:    ];
      
4394: RequireBoolPop:
4396:    [ oTypeSNodeType
4398:       | nBooleanType :
4399:       | * :          #eNotBoolean
4406:    ]
4406:    oTypeSPop;
      
4408: RequireBool:
4410:    [ oTypeSNodeType
4412:       | nBooleanType :
4413:       | * :          #eNotBoolean
4420:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
4421: newType( node_type nt, int size ) >> Node:
4423:   Node node
4423:   node = oNodeNew( nt )
4433:   oNodeSetInt( node, qSize, size )
4445:   oTypeAdd( node )
4451:   >> node
4455:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
4455: newIdent( node_type nt, kind k, int id ) >> Node:
4457:   Node t
4457:   t = oNodeNew( nt )
4467:   oNodeSetInt( t, qIdent, id )
4479:   >> t
4483:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
4483: PointerTypeTo( Node theType ) >> Node:
4485:    Node ptrType
4485:    ptrType = oNodeGet( theType, qPointerType )
4498:    [ oNodeNull( ptrType )
4505:       | true :
4506:          ptrType = oNodeNew( nPointerType )
4516:          oNodeSet( ptrType, qBaseType, theType )
4528:          oNodeSetInt( ptrType, qSize, 8 )
4540:          oTypeAdd( ptrType )
4546:          oNodeSet( theType, qPointerType, ptrType )
4558:       | * :
4563:    ]
4563:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
4567: OrdinalLow( Node theType ) >> int:
4569:    [ oNodeType( theType )
4576:       | nIntegerType :  >> -2147483648
4580:       | nBooleanType :  >> 0
4585:       | nCharType :     >> 0
4590:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
4602:       | * :             #eNotOrdinalType
4615:                         >> 0
4618:    ];
      
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
4619: EmitValue( Node decl ):
4621:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
4635: installBuiltIns:
      
         % install built-in types
4637:    FileType = @newType( nFileType, 4 )
4651:    IntegerType = @newType( nIntegerType, 4 )
4665:    BooleanType = @newType( nBooleanType, 1 )
4679:    CharType = @newType( nCharType, 1 )
4693:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
4707:    Node t
      
4707:    t = @newIdent( nTypeDecl, kType, oIdAdd_File )
4723:    oNodeSet( t, qType, FileType )
4735:    oScopeDeclare( t )
      
4741:    t = @newIdent( nTypeDecl, kType, oIdAdd_Integer )
4757:    oNodeSet( t, qType, IntegerType )
4769:    oScopeDeclare( t )
      
4775:    t = @newIdent( nTypeDecl, kType, oIdAdd_Boolean )
4791:    oNodeSet( t, qType, BooleanType )
4803:    oScopeDeclare( t )
      
4809:    t = @newIdent( nTypeDecl, kType, oIdAdd_Char )
4825:    oNodeSet( t, qType, CharType )
4837:    oScopeDeclare( t )
      
4843:    t = @newIdent( nTypeDecl, kType, oIdAdd_String )
4859:    oNodeSet( t, qType, StringType )
4871:    oScopeDeclare( t )
      
         % Built-in constants
      
4877:    t = @newIdent( nConst, kConst, oIdAdd_True )
4893:    oNodeSet( t, qType, BooleanType )
4905:    oNodeSetInt( t, qValue, 1 )
4917:    oScopeDeclare( t )
      
4923:    t = @newIdent( nConst, kConst, oIdAdd_False )
4939:    oNodeSet( t, qType, BooleanType )
4951:    oNodeSetInt( t, qValue, 0 )
4963:    oScopeDeclare( t )
      
4970:    ;
      
4970: end
      
4970: 

Generated code:

   0: oGlobalSpace 7
   2: oLocalSpace 3
   4: oScopeBegin
   5: oGetAddrGlobal 1
   7: oPushResult
   8: oScopeCurrent
   9: oAssign
  10: oCall 4635
  12: oGetAddrLocal 3
  14: oPushResult
  15: oLabelNew
  16: oAssign
  17: oEmit 42
  19: oGetLocal 3
  21: oPushResult
  22: oEmitLabel
  23: oPop 1
  25: oEmit 43
  27: oInput 26
  29: oInput 0
  31: oGetAddrLocal 1
  33: oPushResult
  34: oSetResult 5
  36: oPushResult
  37: oSetResult 1
  39: oPushResult
  40: LAST_ID
  41: oPushResult
  42: oCall 4455
  44: oPop 3
  46: oAssign
  47: oGetLocal 1
  49: oPushResult
  50: oScopeDeclare
  51: oPop 1
  53: oInputChoice 133
  55: oInput 0
  57: oGetAddrLocal 2
  59: oPushResult
  60: oSetResult 11
  62: oPushResult
  63: oSetResult 6
  65: oPushResult
  66: LAST_ID
  67: oPushResult
  68: oCall 4455
  70: oPop 3
  72: oAssign
  73: oGetLocal 2
  75: oPushResult
  76: oSetResult 5
  78: oPushResult
  79: oGetGlobal 2
  81: oPushResult
  82: oNodeSet
  83: oPop 3
  85: oGetLocal 2
  87: oPushResult
  88: oScopeDeclareAlloc
  89: oPop 1
  91: oInput 12
  93: oInput 0
  95: oGetAddrLocal 2
  97: oPushResult
  98: oSetResult 11
 100: oPushResult
 101: oSetResult 6
 103: oPushResult
 104: LAST_ID
 105: oPushResult
 106: oCall 4455
 108: oPop 3
 110: oAssign
 111: oGetLocal 2
 113: oPushResult
 114: oSetResult 5
 116: oPushResult
 117: oGetGlobal 2
 119: oPushResult
 120: oNodeSet
 121: oPop 3
 123: oGetLocal 2
 125: oPushResult
 126: oScopeDeclareAlloc
 127: oPop 1
 129: oInput 14
 131: oJumpForward 136
 133: Choice Lookup Table
          13     55
 136: oInput 4
 138: oSetResult 12
 140: oPushResult
 141: oCall 197
 143: oPop 1
 145: oScopeBegin
 146: oScopeCurrent
 147: oPushResult
 148: oSetResult 3
 150: oPushResult
 151: oSetResult 1
 153: oPushResult
 154: oNodeSetBoolean
 155: oPop 3
 157: oGetLocal 1
 159: oPushResult
 160: oSetResult 7
 162: oPushResult
 163: oScopeCurrent
 164: oPushResult
 165: oNodeSet
 166: oPop 3
 168: oGetLocal 3
 170: oPushResult
 171: oCall 242
 173: oPop 1
 175: oScopeEnd
 176: oInput 18
 178: oScopeEnd
 179: oReturn
 180: oLocalSpace 0
 182: oGetParam 2
 184: oPushResult
 185: oCall 197
 187: oPop 1
 189: oGetParam 1
 191: oPushResult
 192: oCall 242
 194: oPop 1
 196: oReturn
 197: oLocalSpace 0
 199: oInputChoice 226
 201: oCall 806
 203: oJumpForward 239
 205: oCall 878
 207: oJumpForward 239
 209: oGetParam 1
 211: oPushResult
 212: oCall 937
 214: oPop 1
 216: oJumpForward 239
 218: oCall 287
 220: oJumpForward 239
 222: oCall 409
 224: oJumpForward 239
 226: Choice Lookup Table
          28    222
          27    218
          31    209
          30    205
          29    201
 237: oJumpForward 241
 239: oJumpBack 199
 241: oReturn
 242: oLocalSpace 2
 244: oEmit 48
 246: oGetParam 1
 248: oPushResult
 249: oEmitLabel
 250: oPop 1
 252: oEmit 44
 254: oGetAddrLocal 1
 256: oPushResult
 257: Here
 258: oAssign
 259: oEmit 54
 261: oCall 3302
 263: oEmit 43
 265: oGetAddrLocal 2
 267: oPushResult
 268: oScopeCurrent
 269: oPushResult
 270: oSetResult 2
 272: oPushResult
 273: oNodeGetInt
 274: oPop 2
 276: oAssign
 277: oGetLocal 1
 279: oPushResult
 280: oGetLocal 2
 282: oPushResult
 283: oPatch
 284: oPop 2
 286: oReturn
 287: oLocalSpace 3
 289: oInput 0
 291: oGetAddrLocal 1
 293: oPushResult
 294: oSetResult 7
 296: oPushResult
 297: oSetResult 2
 299: oPushResult
 300: LAST_ID
 301: oPushResult
 302: oCall 4455
 304: oPop 3
 306: oAssign
 307: oScopeBegin
 308: oGetAddrLocal 2
 310: oPushResult
 311: oScopeCurrent
 312: oAssign
 313: oCall 579
 315: oGetLocal 1
 317: oPushResult
 318: oSetResult 8
 320: oPushResult
 321: oGetLocal 2
 323: oPushResult
 324: oNodeSet
 325: oPop 3
 327: oScopeEnd
 328: oGetLocal 1
 330: oPushResult
 331: oScopeDeclare
 332: oPop 1
 334: oInput 4
 336: oGetLocal 2
 338: oPushResult
 339: oScopeEnter
 340: oPop 1
 342: oScopeBegin
 343: oScopeCurrent
 344: oPushResult
 345: oSetResult 3
 347: oPushResult
 348: oSetResult 1
 350: oPushResult
 351: oNodeSetBoolean
 352: oPop 3
 354: oGetLocal 1
 356: oPushResult
 357: oSetResult 9
 359: oPushResult
 360: oScopeCurrent
 361: oPushResult
 362: oNodeSet
 363: oPop 3
 365: oGetAddrLocal 3
 367: oPushResult
 368: oLabelNew
 369: oAssign
 370: oSetResult 13
 372: oPushResult
 373: oGetLocal 3
 375: oPushResult
 376: oCall 180
 378: oPop 2
 380: oGetLocal 1
 382: oPushResult
 383: oSetResult 6
 385: oPushResult
 386: oGetLocal 3
 388: oPushResult
 389: oNodeSetLabel
 390: oPop 3
 392: oGetLocal 1
 394: oPushResult
 395: oSetResult 10
 397: oPushResult
 398: oSetResult 1
 400: oPushResult
 401: oNodeSetBoolean
 402: oPop 3
 404: oScopeEnd
 405: oScopeEnd
 406: oInput 4
 408: oReturn
 409: oLocalSpace 5
 411: oInput 0
 413: oGetAddrLocal 1
 415: oPushResult
 416: oSetResult 8
 418: oPushResult
 419: oSetResult 3
 421: oPushResult
 422: LAST_ID
 423: oPushResult
 424: oCall 4455
 426: oPop 3
 428: oAssign
 429: oScopeBegin
 430: oGetAddrLocal 3
 432: oPushResult
 433: oScopeCurrent
 434: oAssign
 435: oCall 579
 437: oGetLocal 1
 439: oPushResult
 440: oSetResult 8
 442: oPushResult
 443: oGetLocal 3
 445: oPushResult
 446: oNodeSet
 447: oPop 3
 449: oInput 11
 451: oGetAddrLocal 2
 453: oPushResult
 454: oCall 1078
 456: oPop 1
 458: oGetLocal 1
 460: oPushResult
 461: oSetResult 5
 463: oPushResult
 464: oGetLocal 2
 466: oPushResult
 467: oNodeSet
 468: oPop 3
 470: oGetAddrLocal 4
 472: oPushResult
 473: oGetLocal 2
 475: oPushResult
 476: oCall 4483
 478: oPop 1
 480: oAssign
 481: oGetLocal 1
 483: oPushResult
 484: oSetResult 11
 486: oPushResult
 487: oGetLocal 4
 489: oPushResult
 490: oScopeAllocType
 491: oPop 1
 493: oPushResult
 494: oNodeSetInt
 495: oPop 3
 497: oInput 4
 499: oScopeEnd
 500: oGetLocal 1
 502: oPushResult
 503: oScopeDeclare
 504: oPop 1
 506: oGetLocal 3
 508: oPushResult
 509: oScopeEnter
 510: oPop 1
 512: oScopeBegin
 513: oScopeCurrent
 514: oPushResult
 515: oSetResult 3
 517: oPushResult
 518: oSetResult 1
 520: oPushResult
 521: oNodeSetBoolean
 522: oPop 3
 524: oGetLocal 1
 526: oPushResult
 527: oSetResult 9
 529: oPushResult
 530: oScopeCurrent
 531: oPushResult
 532: oNodeSet
 533: oPop 3
 535: oGetAddrLocal 5
 537: oPushResult
 538: oLabelNew
 539: oAssign
 540: oSetResult 13
 542: oPushResult
 543: oGetLocal 5
 545: oPushResult
 546: oCall 180
 548: oPop 2
 550: oGetLocal 1
 552: oPushResult
 553: oSetResult 6
 555: oPushResult
 556: oGetLocal 5
 558: oPushResult
 559: oNodeSetLabel
 560: oPop 3
 562: oGetLocal 1
 564: oPushResult
 565: oSetResult 10
 567: oPushResult
 568: oSetResult 1
 570: oPushResult
 571: oNodeSetBoolean
 572: oPop 3
 574: oScopeEnd
 575: oScopeEnd
 576: oInput 4
 578: oReturn
 579: oLocalSpace 6
 581: oInputChoice 802
 583: oGetAddrLocal 1
 585: oPushResult
 586: oNodeVecNew
 587: oAssign
 588: oGetAddrLocal 3
 590: oPushResult
 591: oSetResult 0
 593: oAssign
 594: oInputChoice 604
 596: oGetAddrLocal 3
 598: oPushResult
 599: oSetResult 1
 601: oAssign
 602: oJumpForward 607
 604: Choice Lookup Table
          31    596
 607: oInput 0
 609: oGetAddrLocal 2
 611: oPushResult
 612: oSetResult 15
 614: oPushResult
 615: oSetResult 6
 617: oPushResult
 618: LAST_ID
 619: oPushResult
 620: oCall 4455
 622: oPop 3
 624: oAssign
 625: oGetLocal 2
 627: oPushResult
 628: oSetResult 12
 630: oPushResult
 631: oGetLocal 3
 633: oPushResult
 634: oNodeSetBoolean
 635: oPop 3
 637: oGetLocal 1
 639: oPushResult
 640: oGetLocal 2
 642: oPushResult
 643: oNodeVecAppend
 644: oPop 2
 646: oInputChoice 654
 648: oJumpForward 662
 650: oJumpForward 660
 652: oJumpForward 660
 654: Choice Lookup Table
          12    652
          11    648
 659: oEndChoice
 660: oJumpBack 607
 662: oGetAddrLocal 4
 664: oPushResult
 665: oCall 1078
 667: oPop 1
 669: oGetLocal 3
 671: oChoice 686
 673: oGetAddrLocal 5
 675: oPushResult
 676: oGetLocal 4
 678: oPushResult
 679: oCall 4483
 681: oPop 1
 683: oAssign
 684: oJumpForward 695
 686: Choice Lookup Table
           1    673
 689: oGetAddrLocal 5
 691: oPushResult
 692: oGetLocal 4
 694: oAssign
 695: oGetAddrLocal 6
 697: oPushResult
 698: oSetResult 0
 700: oAssign
 701: oGetLocal 6
 703: oPushResult
 704: oGetLocal 1
 706: oPushResult
 707: oNodeVecSize
 708: oPop 1
 710: oPushResult
 711: equal
 712: oPop 2
 714: oChoice 771
 716: oGetAddrLocal 2
 718: oPushResult
 719: oGetLocal 1
 721: oPushResult
 722: oGetLocal 6
 724: oPushResult
 725: oNodeVecElement
 726: oPop 2
 728: oAssign
 729: oGetLocal 2
 731: oPushResult
 732: oSetResult 5
 734: oPushResult
 735: oGetLocal 4
 737: oPushResult
 738: oNodeSet
 739: oPop 3
 741: oGetLocal 2
 743: oPushResult
 744: oScopeDeclare
 745: oPop 1
 747: oGetLocal 2
 749: oPushResult
 750: oSetResult 6
 752: oPushResult
 753: oGetLocal 5
 755: oPushResult
 756: oScopeAllocType
 757: oPop 1
 759: oPushResult
 760: oNodeSetInt
 761: oPop 3
 763: oGetAddrLocal 6
 765: oPushResult
 766: inc
 767: oPop 1
 769: oJumpForward 776
 771: Choice Lookup Table
           0    716
 774: oJumpForward 778
 776: oJumpBack 701
 778: oGetLocal 1
 780: oPushResult
 781: oNodeVecDelete
 782: oPop 1
 784: oInputChoice 792
 786: oJumpForward 800
 788: oJumpForward 798
 790: oJumpForward 798
 792: Choice Lookup Table
           4    790
          14    786
 797: oEndChoice
 798: oJumpBack 583
 800: oJumpForward 805
 802: Choice Lookup Table
          13    583
 805: oReturn
 806: oLocalSpace 2
 808: oInputChoice 870
 810: oGetAddrLocal 1
 812: oPushResult
 813: oSetResult 9
 815: oPushResult
 816: oSetResult 4
 818: oPushResult
 819: LAST_ID
 820: oPushResult
 821: oCall 4455
 823: oPop 3
 825: oAssign
 826: oInput 5
 828: oCall 1547
 830: oGetAddrLocal 2
 832: oPushResult
 833: oValueTop
 834: oAssign
 835: oValuePop
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 6
 841: oPushResult
 842: oGetLocal 2
 844: oPushResult
 845: oNodeSetInt
 846: oPop 3
 848: oGetLocal 1
 850: oPushResult
 851: oSetResult 5
 853: oPushResult
 854: oGetGlobal 3
 856: oPushResult
 857: oNodeSet
 858: oPop 3
 860: oGetLocal 1
 862: oPushResult
 863: oScopeDeclare
 864: oPop 1
 866: oInput 4
 868: oJumpForward 875
 870: Choice Lookup Table
           0    810
 873: oJumpForward 877
 875: oJumpBack 808
 877: oReturn
 878: oLocalSpace 2
 880: oInputChoice 929
 882: oGetAddrLocal 1
 884: oPushResult
 885: oSetResult 10
 887: oPushResult
 888: oSetResult 5
 890: oPushResult
 891: LAST_ID
 892: oPushResult
 893: oCall 4455
 895: oPop 3
 897: oAssign
 898: oInput 5
 900: oGetAddrLocal 2
 902: oPushResult
 903: oCall 1078
 905: oPop 1
 907: oGetLocal 1
 909: oPushResult
 910: oSetResult 5
 912: oPushResult
 913: oGetLocal 2
 915: oPushResult
 916: oNodeSet
 917: oPop 3
 919: oGetLocal 1
 921: oPushResult
 922: oScopeDeclare
 923: oPop 1
 925: oInput 4
 927: oJumpForward 934
 929: Choice Lookup Table
           0    882
 932: oJumpForward 936
 934: oJumpBack 880
 936: oReturn
 937: oLocalSpace 4
 939: oInputChoice 1070
 941: oGetAddrLocal 1
 943: oPushResult
 944: oNodeVecNew
 945: oAssign
 946: oGetAddrLocal 2
 948: oPushResult
 949: oGetParam 1
 951: oPushResult
 952: oSetResult 6
 954: oPushResult
 955: LAST_ID
 956: oPushResult
 957: oCall 4455
 959: oPop 3
 961: oAssign
 962: oGetLocal 1
 964: oPushResult
 965: oGetLocal 2
 967: oPushResult
 968: oNodeVecAppend
 969: oPop 2
 971: oInputChoice 977
 973: oInput 0
 975: oJumpForward 982
 977: Choice Lookup Table
          12    973
 980: oJumpForward 984
 982: oJumpBack 946
 984: oInput 11
 986: oGetAddrLocal 3
 988: oPushResult
 989: oCall 1078
 991: oPop 1
 993: oGetAddrLocal 4
 995: oPushResult
 996: oSetResult 0
 998: oAssign
 999: oGetLocal 4
1001: oPushResult
1002: oGetLocal 1
1004: oPushResult
1005: oNodeVecSize
1006: oPop 1
1008: oPushResult
1009: equal
1010: oPop 2
1012: oChoice 1053
1014: oGetAddrLocal 2
1016: oPushResult
1017: oGetLocal 1
1019: oPushResult
1020: oGetLocal 4
1022: oPushResult
1023: oNodeVecElement
1024: oPop 2
1026: oAssign
1027: oGetLocal 2
1029: oPushResult
1030: oSetResult 5
1032: oPushResult
1033: oGetLocal 3
1035: oPushResult
1036: oNodeSet
1037: oPop 3
1039: oGetLocal 2
1041: oPushResult
1042: oScopeDeclareAlloc
1043: oPop 1
1045: oGetAddrLocal 4
1047: oPushResult
1048: inc
1049: oPop 1
1051: oJumpForward 1058
1053: Choice Lookup Table
           0   1014
1056: oJumpForward 1060
1058: oJumpBack 999
1060: oGetLocal 1
1062: oPushResult
1063: oNodeVecDelete
1064: oPop 1
1066: oInput 4
1068: oJumpForward 1075
1070: Choice Lookup Table
           0    941
1073: oJumpForward 1077
1075: oJumpBack 939
1077: oReturn
1078: oLocalSpace 12
1080: oInputChoice 1529
1082: oGetAddrLocal 1
1084: oPushResult
1085: oScopeFindRequire
1086: oAssign
1087: oGetLocal 1
1089: oPushResult
1090: oNodeType
1091: oPop 1
1093: oChoice 1110
1095: oGetParam 1
1097: oPushResult
1098: oGetLocal 1
1100: oPushResult
1101: oSetResult 5
1103: oPushResult
1104: oNodeGet
1105: oPop 2
1107: oAssign
1108: oJumpForward 1121
1110: Choice Lookup Table
          10   1095
1113: oError 2
1115: oGetParam 1
1117: oPushResult
1118: oGetGlobal 3
1120: oAssign
1121: oJumpForward 1546
1123: oInput 15
1125: oGetAddrLocal 2
1127: oPushResult
1128: oNodeVecNew
1129: oAssign
1130: oGetAddrLocal 3
1132: oPushResult
1133: oSetResult 24
1135: oPushResult
1136: oNodeNew
1137: oPop 1
1139: oAssign
1140: oGetLocal 3
1142: oPushResult
1143: oSetResult 14
1145: oPushResult
1146: oGetGlobal 3
1148: oPushResult
1149: oNodeSet
1150: oPop 3
1152: oCall 1547
1154: oGetLocal 3
1156: oPushResult
1157: oSetResult 16
1159: oPushResult
1160: oValueTop
1161: oPushResult
1162: oNodeSetInt
1163: oPop 3
1165: oValuePop
1166: oInput 19
1168: oCall 1547
1170: oGetLocal 3
1172: oPushResult
1173: oSetResult 17
1175: oPushResult
1176: oValueTop
1177: oPushResult
1178: oNodeSetInt
1179: oPop 3
1181: oValuePop
1182: oGetLocal 3
1184: oPushResult
1185: oSetResult 2
1187: oPushResult
1188: oSetResult 4
1190: oPushResult
1191: oNodeSetInt
1192: oPop 3
1194: oGetLocal 3
1196: oPushResult
1197: oTypeAdd
1198: oPop 1
1200: oGetAddrLocal 4
1202: oPushResult
1203: oSetResult 23
1205: oPushResult
1206: oNodeNew
1207: oPop 1
1209: oAssign
1210: oGetLocal 4
1212: oPushResult
1213: oSetResult 15
1215: oPushResult
1216: oGetLocal 3
1218: oPushResult
1219: oNodeSet
1220: oPop 3
1222: oGetLocal 2
1224: oPushResult
1225: oGetLocal 4
1227: oPushResult
1228: oNodeVecAppend
1229: oPop 2
1231: oInputChoice 1239
1233: oJumpForward 1247
1235: oJumpForward 1245
1237: oJumpForward 1245
1239: Choice Lookup Table
          12   1237
          16   1233
1244: oEndChoice
1245: oJumpBack 1130
1247: oInput 37
1249: oGetAddrLocal 5
1251: oPushResult
1252: oCall 1078
1254: oPop 1
1256: oGetAddrLocal 6
1258: oPushResult
1259: oGetLocal 2
1261: oPushResult
1262: oNodeVecSize
1263: oPop 1
1265: oAssign
1266: oGetAddrLocal 6
1268: oPushResult
1269: dec
1270: oPop 1
1272: oGetAddrLocal 4
1274: oPushResult
1275: oGetLocal 2
1277: oPushResult
1278: oGetLocal 6
1280: oPushResult
1281: oNodeVecElement
1282: oPop 2
1284: oAssign
1285: oGetLocal 4
1287: oPushResult
1288: oSetResult 14
1290: oPushResult
1291: oGetLocal 5
1293: oPushResult
1294: oNodeSet
1295: oPop 3
1297: oGetAddrLocal 3
1299: oPushResult
1300: oGetLocal 4
1302: oPushResult
1303: oSetResult 15
1305: oPushResult
1306: oNodeGet
1307: oPop 2
1309: oAssign
1310: oGetAddrLocal 9
1312: oPushResult
1313: oGetLocal 3
1315: oPushResult
1316: oSetResult 17
1318: oPushResult
1319: oNodeGetInt
1320: oPop 2
1322: oPushResult
1323: oGetLocal 3
1325: oPushResult
1326: oSetResult 16
1328: oPushResult
1329: oNodeGetInt
1330: oPop 2
1332: oPushResult
1333: subtract
1334: oPop 2
1336: oAssign
1337: oGetAddrLocal 9
1339: oPushResult
1340: inc
1341: oPop 1
1343: oGetLocal 4
1345: oPushResult
1346: oSetResult 2
1348: oPushResult
1349: oGetLocal 9
1351: oPushResult
1352: oGetLocal 5
1354: oPushResult
1355: oSetResult 2
1357: oPushResult
1358: oNodeGetInt
1359: oPop 2
1361: oPushResult
1362: multiply
1363: oPop 2
1365: oPushResult
1366: oNodeSetInt
1367: oPop 3
1369: oGetLocal 4
1371: oPushResult
1372: oTypeAdd
1373: oPop 1
1375: oGetAddrLocal 5
1377: oPushResult
1378: oGetLocal 4
1380: oAssign
1381: oGetLocal 6
1383: oPushResult
1384: equal_zero
1385: oPop 1
1387: oChoice 1393
1389: oJumpForward 1398
1391: oJumpForward 1396
1393: Choice Lookup Table
           1   1389
1396: oJumpBack 1266
1398: oGetParam 1
1400: oPushResult
1401: oGetLocal 2
1403: oPushResult
1404: oSetResult 0
1406: oPushResult
1407: oNodeVecElement
1408: oPop 2
1410: oAssign
1411: oGetLocal 2
1413: oPushResult
1414: oNodeVecDelete
1415: oPop 1
1417: oJumpForward 1546
1419: oGetAddrLocal 10
1421: oPushResult
1422: oCall 1078
1424: oPop 1
1426: oGetParam 1
1428: oPushResult
1429: oGetLocal 10
1431: oPushResult
1432: oCall 4483
1434: oPop 1
1436: oAssign
1437: oJumpForward 1546
1439: oGetParam 1
1441: oPushResult
1442: oSetResult 25
1444: oPushResult
1445: oNodeNew
1446: oPop 1
1448: oAssign
1449: oScopeBegin
1450: oSetResult 14
1452: oPushResult
1453: oCall 937
1455: oPop 1
1457: oGetAddrLocal 11
1459: oPushResult
1460: oScopeCurrent
1461: oPushResult
1462: oSetResult 2
1464: oPushResult
1465: oNodeGetInt
1466: oPop 2
1468: oAssign
1469: oGetLocal 11
1471: oPushResult
1472: equal_zero
1473: oPop 1
1475: oChoice 1481
1477: oError 19
1479: oJumpForward 1484
1481: Choice Lookup Table
           1   1477
1484: oInput 33
1486: oGetFromParam 1
1488: oPushResult
1489: oSetResult 18
1491: oPushResult
1492: oScopeCurrent
1493: oPushResult
1494: oNodeSet
1495: oPop 3
1497: oGetFromParam 1
1499: oPushResult
1500: oSetResult 2
1502: oPushResult
1503: oGetLocal 11
1505: oPushResult
1506: oNodeSetInt
1507: oPop 3
1509: oScopeEnd
1510: oGetFromParam 1
1512: oPushResult
1513: oTypeAdd
1514: oPop 1
1516: oJumpForward 1546
1518: oInput 37
1520: oGetAddrLocal 10
1522: oPushResult
1523: oCall 1078
1525: oPop 1
1527: oJumpForward 1546
1529: Choice Lookup Table
          36   1518
          35   1439
          17   1419
          34   1123
           0   1082
1540: oCall 1547
1542: oInput 19
1544: oCall 1547
1546: oReturn
1547: oLocalSpace 1
1549: oInputChoice 1604
1551: TOKEN_VALUE
1552: oPushResult
1553: oValuePush
1554: oPop 1
1556: oJumpForward 1612
1558: oGetAddrLocal 1
1560: oPushResult
1561: oScopeFindRequire
1562: oAssign
1563: oGetLocal 1
1565: oPushResult
1566: oNodeType
1567: oPop 1
1569: oChoice 1586
1571: oGetLocal 1
1573: oPushResult
1574: oSetResult 6
1576: oPushResult
1577: oNodeGetInt
1578: oPop 2
1580: oPushResult
1581: oValuePush
1582: oPop 1
1584: oJumpForward 1597
1586: Choice Lookup Table
           9   1571
1589: oError 1
1591: oSetResult 0
1593: oPushResult
1594: oValuePush
1595: oPop 1
1597: oJumpForward 1612
1599: oCall 1547
1601: oValueNegate
1602: oJumpForward 1612
1604: Choice Lookup Table
          23   1599
           0   1558
           1   1551
1611: oEndChoice
1612: oReturn
1613: oLocalSpace 0
1615: oCall 1859
1617: oInputChoice 1841
1619: oCall 1859
1621: oCall 4341
1623: oTypeSNodeType
1624: oChoice 1638
1626: oEmit 32
1628: oJumpForward 1651
1630: oEmit 38
1632: oJumpForward 1651
1634: oError 16
1636: oJumpForward 1651
1638: Choice Lookup Table
          21   1634
          20   1634
          22   1630
          19   1626
          18   1626
1649: oError 17
1651: oTypeSPop
1652: oGetGlobal 4
1654: oPushResult
1655: oTypeSPush
1656: oPop 1
1658: oJumpForward 1856
1660: oCall 1859
1662: oCall 4341
1664: oTypeSNodeType
1665: oChoice 1679
1667: oEmit 33
1669: oJumpForward 1692
1671: oEmit 39
1673: oJumpForward 1692
1675: oError 16
1677: oJumpForward 1692
1679: Choice Lookup Table
          21   1675
          20   1675
          22   1671
          19   1667
          18   1667
1690: oError 17
1692: oTypeSPop
1693: oGetGlobal 4
1695: oPushResult
1696: oTypeSPush
1697: oPop 1
1699: oJumpForward 1856
1701: oCall 1859
1703: oCall 4341
1705: oTypeSNodeType
1706: oChoice 1716
1708: oEmit 35
1710: oJumpForward 1727
1712: oError 16
1714: oJumpForward 1727
1716: Choice Lookup Table
          21   1712
          20   1712
          19   1708
          18   1708
1725: oError 17
1727: oTypeSPop
1728: oGetGlobal 4
1730: oPushResult
1731: oTypeSPush
1732: oPop 1
1734: oJumpForward 1856
1736: oCall 1859
1738: oCall 4341
1740: oTypeSNodeType
1741: oChoice 1751
1743: oEmit 34
1745: oJumpForward 1762
1747: oError 16
1749: oJumpForward 1762
1751: Choice Lookup Table
          21   1747
          20   1747
          19   1743
          18   1743
1760: oError 17
1762: oTypeSPop
1763: oGetGlobal 4
1765: oPushResult
1766: oTypeSPush
1767: oPop 1
1769: oJumpForward 1856
1771: oCall 1859
1773: oCall 4341
1775: oTypeSNodeType
1776: oChoice 1786
1778: oEmit 37
1780: oJumpForward 1797
1782: oError 16
1784: oJumpForward 1797
1786: Choice Lookup Table
          21   1782
          20   1782
          19   1778
          18   1778
1795: oError 17
1797: oTypeSPop
1798: oGetGlobal 4
1800: oPushResult
1801: oTypeSPush
1802: oPop 1
1804: oJumpForward 1856
1806: oCall 1859
1808: oCall 4341
1810: oTypeSNodeType
1811: oChoice 1821
1813: oEmit 36
1815: oJumpForward 1832
1817: oError 16
1819: oJumpForward 1832
1821: Choice Lookup Table
          21   1817
          20   1817
          19   1813
          18   1813
1830: oError 17
1832: oTypeSPop
1833: oGetGlobal 4
1835: oPushResult
1836: oTypeSPush
1837: oPop 1
1839: oJumpForward 1856
1841: Choice Lookup Table
          10   1806
           9   1771
           8   1736
           7   1701
           6   1660
           5   1619
1854: oJumpForward 1858
1856: oJumpBack 1617
1858: oReturn
1859: oLocalSpace 0
1861: oCall 1883
1863: oInputChoice 1875
1865: oCall 4394
1867: oCall 1883
1869: oCall 4408
1871: oEmit 31
1873: oJumpForward 1880
1875: Choice Lookup Table
          52   1865
1878: oJumpForward 1882
1880: oJumpBack 1863
1882: oReturn
1883: oLocalSpace 0
1885: oCall 1907
1887: oInputChoice 1899
1889: oCall 4394
1891: oCall 1907
1893: oCall 4408
1895: oEmit 30
1897: oJumpForward 1904
1899: Choice Lookup Table
          51   1889
1902: oJumpForward 1906
1904: oJumpBack 1887
1906: oReturn
1907: oLocalSpace 0
1909: oInputChoice 1919
1911: oCall 1907
1913: oCall 4408
1915: oEmit 29
1917: oJumpForward 1924
1919: Choice Lookup Table
          53   1911
1922: oCall 1925
1924: oReturn
1925: oLocalSpace 0
1927: oCall 1961
1929: oInputChoice 1951
1931: oCall 4367
1933: oCall 1961
1935: oCall 4381
1937: oEmit 26
1939: oJumpForward 1958
1941: oCall 4367
1943: oCall 1961
1945: oCall 4381
1947: oEmit 27
1949: oJumpForward 1958
1951: Choice Lookup Table
          23   1941
          22   1931
1956: oJumpForward 1960
1958: oJumpBack 1929
1960: oReturn
1961: oLocalSpace 0
1963: oCall 1997
1965: oInputChoice 1987
1967: oCall 4367
1969: oCall 1997
1971: oCall 4381
1973: oEmit 23
1975: oJumpForward 1994
1977: oCall 4367
1979: oCall 1997
1981: oCall 4381
1983: oEmit 24
1985: oJumpForward 1994
1987: Choice Lookup Table
          21   1977
          20   1967
1992: oJumpForward 1996
1994: oJumpBack 1965
1996: oReturn
1997: oLocalSpace 0
1999: oInputChoice 2015
2001: oCall 2023
2003: oCall 4381
2005: oJumpForward 2022
2007: oCall 2023
2009: oCall 4381
2011: oEmit 28
2013: oJumpForward 2022
2015: Choice Lookup Table
          23   2007
          22   2001
2020: oCall 2023
2022: oReturn
2023: oLocalSpace 5
2025: oInputChoice 2198
2027: oEmit 9
2029: TOKEN_VALUE
2030: oPushResult
2031: oEmitInt
2032: oPop 1
2034: oGetGlobal 3
2036: oPushResult
2037: oTypeSPush
2038: oPop 1
2040: oJumpForward 2217
2042: oCall 1613
2044: oInput 14
2046: oJumpForward 2217
2048: oStringAllocLit
2049: oEmit 10
2051: oValueTop
2052: oPushResult
2053: oEmitInt
2054: oPop 1
2056: oValuePop
2057: oGetGlobal 6
2059: oPushResult
2060: oTypeSPush
2061: oPop 1
2063: oJumpForward 2217
2065: oGetAddrLocal 1
2067: oPushResult
2068: oScopeFindRequire
2069: oAssign
2070: oGetLocal 1
2072: oPushResult
2073: oNodeType
2074: oPop 1
2076: oChoice 2138
2078: oGetLocal 1
2080: oPushResult
2081: oCall 2940
2083: oPop 1
2085: oJumpForward 2157
2087: oGetAddrLocal 2
2089: oPushResult
2090: oGetLocal 1
2092: oPushResult
2093: oSetResult 5
2095: oPushResult
2096: oNodeGet
2097: oPop 2
2099: oAssign
2100: oGetLocal 2
2102: oPushResult
2103: oTypeSPush
2104: oPop 1
2106: oTypeSNodeType
2107: oChoice 2120
2109: oEmit 9
2111: oGetLocal 1
2113: oPushResult
2114: oCall 4619
2116: oPop 1
2118: oJumpForward 2127
2120: Choice Lookup Table
          19   2109
          18   2109
2125: oError 16
2127: oJumpForward 2157
2129: oGetLocal 1
2131: oPushResult
2132: oCall 2218
2134: oPop 1
2136: oJumpForward 2157
2138: Choice Lookup Table
          15   2129
          13   2129
          12   2129
           9   2087
           8   2078
2149: oError 6
2151: oGetGlobal 3
2153: oPushResult
2154: oTypeSPush
2155: oPop 1
2157: oJumpForward 2217
2159: oInput 0
2161: oGetAddrLocal 1
2163: oPushResult
2164: oScopeFindRequire
2165: oAssign
2166: oGetLocal 1
2168: oPushResult
2169: oCall 3655
2171: oPop 1
2173: oGetAddrLocal 2
2175: oPushResult
2176: oTypeSTop
2177: oAssign
2178: oTypeSPop
2179: oGetAddrLocal 5
2181: oPushResult
2182: oGetLocal 2
2184: oPushResult
2185: oCall 4483
2187: oPop 1
2189: oAssign
2190: oGetLocal 5
2192: oPushResult
2193: oTypeSPush
2194: oPop 1
2196: oJumpForward 2217
2198: Choice Lookup Table
          17   2159
           0   2065
           2   2048
          13   2042
           1   2027
2209: oError 6
2211: oGetGlobal 3
2213: oPushResult
2214: oTypeSPush
2215: oPop 1
2217: oReturn
2218: oLocalSpace 1
2220: oGetAddrLocal 1
2222: oPushResult
2223: oGetParam 1
2225: oPushResult
2226: oSetResult 5
2228: oPushResult
2229: oNodeGet
2230: oPop 2
2232: oAssign
2233: oGetLocal 1
2235: oPushResult
2236: oTypeSPush
2237: oPop 1
2239: oTypeSNodeType
2240: oChoice 2505
2242: oGetParam 1
2244: oPushResult
2245: oNodeType
2246: oPop 1
2248: oChoice 2310
2250: oEmit 0
2252: oGetParam 1
2254: oPushResult
2255: oCall 4619
2257: oPop 1
2259: oJumpForward 2318
2261: oEmit 3
2263: oGetParam 1
2265: oPushResult
2266: oCall 4619
2268: oPop 1
2270: oJumpForward 2318
2272: oGetParam 1
2274: oPushResult
2275: oSetResult 12
2277: oPushResult
2278: oNodeGetBoolean
2279: oPop 2
2281: oChoice 2296
2283: oEmit 8
2285: oGetParam 1
2287: oPushResult
2288: oCall 4619
2290: oPop 1
2292: oEmit 14
2294: oJumpForward 2308
2296: Choice Lookup Table
           1   2283
2299: oEmit 6
2301: oGetParam 1
2303: oPushResult
2304: oCall 4619
2306: oPop 1
2308: oJumpForward 2318
2310: Choice Lookup Table
          15   2272
          13   2261
          12   2250
2317: oEndChoice
2318: oJumpForward 2596
2320: oGetParam 1
2322: oPushResult
2323: oNodeType
2324: oPop 1
2326: oChoice 2388
2328: oEmit 1
2330: oGetParam 1
2332: oPushResult
2333: oCall 4619
2335: oPop 1
2337: oJumpForward 2396
2339: oEmit 4
2341: oGetParam 1
2343: oPushResult
2344: oCall 4619
2346: oPop 1
2348: oJumpForward 2396
2350: oGetParam 1
2352: oPushResult
2353: oSetResult 12
2355: oPushResult
2356: oNodeGetBoolean
2357: oPop 2
2359: oChoice 2374
2361: oEmit 8
2363: oGetParam 1
2365: oPushResult
2366: oCall 4619
2368: oPop 1
2370: oEmit 15
2372: oJumpForward 2386
2374: Choice Lookup Table
           1   2361
2377: oEmit 7
2379: oGetParam 1
2381: oPushResult
2382: oCall 4619
2384: oPop 1
2386: oJumpForward 2396
2388: Choice Lookup Table
          15   2350
          13   2339
          12   2328
2395: oEndChoice
2396: oJumpForward 2596
2398: oError 16
2400: oJumpForward 2596
2402: oGetParam 1
2404: oPushResult
2405: oNodeType
2406: oPop 1
2408: oChoice 2470
2410: oEmit 2
2412: oGetParam 1
2414: oPushResult
2415: oCall 4619
2417: oPop 1
2419: oJumpForward 2478
2421: oEmit 5
2423: oGetParam 1
2425: oPushResult
2426: oCall 4619
2428: oPop 1
2430: oJumpForward 2478
2432: oGetParam 1
2434: oPushResult
2435: oSetResult 12
2437: oPushResult
2438: oNodeGetBoolean
2439: oPop 2
2441: oChoice 2456
2443: oEmit 8
2445: oGetParam 1
2447: oPushResult
2448: oCall 4619
2450: oPop 1
2452: oEmit 16
2454: oJumpForward 2468
2456: Choice Lookup Table
           1   2443
2459: oEmit 8
2461: oGetParam 1
2463: oPushResult
2464: oCall 4619
2466: oPop 1
2468: oJumpForward 2478
2470: Choice Lookup Table
          15   2432
          13   2421
          12   2410
2477: oEndChoice
2478: oInputChoice 2500
2480: oTypeSPop
2481: oGetLocal 1
2483: oPushResult
2484: oSetResult 14
2486: oPushResult
2487: oNodeGet
2488: oPop 2
2490: oPushResult
2491: oTypeSPush
2492: oPop 1
2494: oCall 2632
2496: oCall 2597
2498: oJumpForward 2503
2500: Choice Lookup Table
          17   2480
2503: oJumpForward 2596
2505: Choice Lookup Table
          22   2402
          17   2398
          21   2398
          20   2398
          19   2320
          18   2242
2518: oGetParam 1
2520: oPushResult
2521: oNodeType
2522: oPop 1
2524: oChoice 2584
2526: oEmit 10
2528: oGetParam 1
2530: oPushResult
2531: oCall 4619
2533: oPop 1
2535: oJumpForward 2592
2537: oEmit 11
2539: oGetParam 1
2541: oPushResult
2542: oCall 4619
2544: oPop 1
2546: oJumpForward 2592
2548: oGetParam 1
2550: oPushResult
2551: oSetResult 12
2553: oPushResult
2554: oNodeGetBoolean
2555: oPop 2
2557: oChoice 2570
2559: oEmit 8
2561: oGetParam 1
2563: oPushResult
2564: oCall 4619
2566: oPop 1
2568: oJumpForward 2582
2570: Choice Lookup Table
           1   2559
2573: oEmit 12
2575: oGetParam 1
2577: oPushResult
2578: oCall 4619
2580: oPop 1
2582: oJumpForward 2592
2584: Choice Lookup Table
          15   2548
          13   2537
          12   2526
2591: oEndChoice
2592: oCall 2632
2594: oCall 2597
2596: oReturn
2597: oLocalSpace 0
2599: oTypeSNodeType
2600: oChoice 2618
2602: oEmit 14
2604: oJumpForward 2631
2606: oEmit 15
2608: oJumpForward 2631
2610: oError 16
2612: oJumpForward 2631
2614: oEmit 16
2616: oJumpForward 2631
2618: Choice Lookup Table
          22   2614
          17   2610
          21   2610
          20   2610
          19   2606
          18   2602
2631: oReturn
2632: oLocalSpace 0
2634: oInputChoice 2648
2636: oCall 2660
2638: oJumpForward 2657
2640: oCall 2803
2642: oJumpForward 2657
2644: oCall 2901
2646: oJumpForward 2657
2648: Choice Lookup Table
          17   2644
          18   2640
          15   2636
2655: oJumpForward 2659
2657: oJumpBack 2634
2659: oReturn
2660: oLocalSpace 3
2662: oTypeSNodeType
2663: oChoice 2667
2665: oJumpForward 2672
2667: Choice Lookup Table
          23   2665
2670: oError 10
2672: oTypeSNodeType
2673: oChoice 2677
2675: oJumpForward 2682
2677: Choice Lookup Table
          23   2675
2680: oError 13
2682: oGetAddrLocal 1
2684: oPushResult
2685: oTypeSTop
2686: oPushResult
2687: oSetResult 15
2689: oPushResult
2690: oNodeGet
2691: oPop 2
2693: oPushResult
2694: oCall 4567
2696: oPop 1
2698: oAssign
2699: oGetAddrLocal 2
2701: oPushResult
2702: oTypeSTop
2703: oPushResult
2704: oSetResult 14
2706: oPushResult
2707: oNodeGet
2708: oPop 2
2710: oAssign
2711: oTypeSPop
2712: oGetLocal 2
2714: oPushResult
2715: oTypeSPush
2716: oPop 1
2718: oCall 1613
2720: oCall 4367
2722: oGetLocal 1
2724: oPushResult
2725: equal_zero
2726: oPop 1
2728: oChoice 2742
2730: oEmit 9
2732: oGetLocal 1
2734: oPushResult
2735: oEmitInt
2736: oPop 1
2738: oEmit 27
2740: oJumpForward 2745
2742: Choice Lookup Table
           0   2730
2745: oGetAddrLocal 3
2747: oPushResult
2748: oGetLocal 2
2750: oPushResult
2751: oSetResult 2
2753: oPushResult
2754: oNodeGetInt
2755: oPop 2
2757: oAssign
2758: oGetLocal 3
2760: oPushResult
2761: oSetResult 1
2763: oPushResult
2764: equal
2765: oPop 2
2767: oChoice 2781
2769: oEmit 9
2771: oGetLocal 3
2773: oPushResult
2774: oEmitInt
2775: oPop 1
2777: oEmit 23
2779: oJumpForward 2784
2781: Choice Lookup Table
           0   2769
2784: oEmit 25
2786: oInputChoice 2794
2788: oJumpForward 2802
2790: oJumpForward 2800
2792: oJumpForward 2800
2794: Choice Lookup Table
          12   2792
          16   2788
2799: oEndChoice
2800: oJumpBack 2672
2802: oReturn
2803: oLocalSpace 2
2805: oTypeSNodeType
2806: oChoice 2810
2808: oJumpForward 2815
2810: Choice Lookup Table
          25   2808
2813: oError 11
2815: oTypeSTop
2816: oPushResult
2817: oSetResult 18
2819: oPushResult
2820: oNodeGet
2821: oPop 2
2823: oPushResult
2824: oScopeEnter
2825: oPop 1
2827: oInput 0
2829: oGetAddrLocal 1
2831: oPushResult
2832: oScopeFindRequire
2833: oAssign
2834: oGetLocal 1
2836: oPushResult
2837: oNodeType
2838: oPop 1
2840: oChoice 2844
2842: oJumpForward 2849
2844: Choice Lookup Table
          14   2842
2847: oError 12
2849: oScopeEnd
2850: oGetAddrLocal 2
2852: oPushResult
2853: oGetLocal 1
2855: oPushResult
2856: oSetResult 6
2858: oPushResult
2859: oNodeGetInt
2860: oPop 2
2862: oAssign
2863: oGetLocal 2
2865: oPushResult
2866: equal_zero
2867: oPop 1
2869: oChoice 2883
2871: oEmit 9
2873: oGetLocal 2
2875: oPushResult
2876: oEmitInt
2877: oPop 1
2879: oEmit 25
2881: oJumpForward 2886
2883: Choice Lookup Table
           0   2871
2886: oTypeSPop
2887: oGetLocal 1
2889: oPushResult
2890: oSetResult 5
2892: oPushResult
2893: oNodeGet
2894: oPop 2
2896: oPushResult
2897: oTypeSPush
2898: oPop 1
2900: oReturn
2901: oLocalSpace 1
2903: oTypeSNodeType
2904: oChoice 2908
2906: oJumpForward 2913
2908: Choice Lookup Table
          22   2906
2911: oError 9
2913: oEmit 16
2915: oGetAddrLocal 1
2917: oPushResult
2918: oTypeSTop
2919: oAssign
2920: oTypeSPop
2921: oGetLocal 1
2923: oPushResult
2924: oSetResult 14
2926: oPushResult
2927: oNodeGet
2928: oPop 2
2930: oPushResult
2931: oTypeSPush
2932: oPop 1
2934: oReturn
2935: oLocalSpace 0
2937: oCall 4341
2939: oReturn
2940: oLocalSpace 8
2942: oGetAddrLocal 1
2944: oPushResult
2945: oGetParam 1
2947: oPushResult
2948: oNodeType
2949: oPop 1
2951: oPushResult
2952: oSetResult 8
2954: oPushResult
2955: equal_node_type
2956: oPop 2
2958: oAssign
2959: oGetLocal 1
2961: oChoice 2988
2963: oGetAddrLocal 2
2965: oPushResult
2966: oGetParam 1
2968: oPushResult
2969: oSetResult 5
2971: oPushResult
2972: oNodeGet
2973: oPop 2
2975: oAssign
2976: oGetAddrLocal 3
2978: oPushResult
2979: oGetLocal 2
2981: oPushResult
2982: oScopeAllocType
2983: oPop 1
2985: oAssign
2986: oJumpForward 2991
2988: Choice Lookup Table
           1   2963
2991: oGetAddrLocal 4
2993: oPushResult
2994: oGetParam 1
2996: oPushResult
2997: oSetResult 8
2999: oPushResult
3000: oNodeGet
3001: oPop 2
3003: oAssign
3004: oGetAddrLocal 5
3006: oPushResult
3007: oGetLocal 4
3009: oPushResult
3010: oSetResult 2
3012: oPushResult
3013: oNodeGetInt
3014: oPop 2
3016: oAssign
3017: oEmit 40
3019: oGetLocal 5
3021: oPushResult
3022: oEmitInt
3023: oPop 1
3025: oGetAddrLocal 6
3027: oPushResult
3028: oGetLocal 4
3030: oPushResult
3031: oSetResult 1
3033: oPushResult
3034: oNodeGet
3035: oPop 2
3037: oAssign
3038: oInputChoice 3207
3040: oGetLocal 6
3042: oPushResult
3043: oNodeNull
3044: oPop 1
3046: oChoice 3052
3048: oJumpForward 3203
3050: oJumpForward 3055
3052: Choice Lookup Table
           1   3048
3055: oGetAddrLocal 7
3057: oPushResult
3058: oGetLocal 6
3060: oPushResult
3061: oSetResult 6
3063: oPushResult
3064: oNodeGetInt
3065: oPop 2
3067: oAssign
3068: oEmit 13
3070: oGetLocal 7
3072: oPushResult
3073: oEmitInt
3074: oPop 1
3076: oGetLocal 6
3078: oPushResult
3079: oSetResult 5
3081: oPushResult
3082: oNodeGet
3083: oPop 2
3085: oPushResult
3086: oTypeSPush
3087: oPop 1
3089: oGetLocal 6
3091: oPushResult
3092: oSetResult 12
3094: oPushResult
3095: oNodeGetBoolean
3096: oPop 2
3098: oChoice 3166
3100: oCall 3619
3102: oCall 4341
3104: oEmit 19
3106: oJumpForward 3172
3108: oCall 1613
3110: oCall 2935
3112: oTypeSNodeType
3113: oChoice 3131
3115: oEmit 17
3117: oJumpForward 3164
3119: oEmit 18
3121: oJumpForward 3164
3123: oError 16
3125: oJumpForward 3164
3127: oEmit 19
3129: oJumpForward 3164
3131: Choice Lookup Table
          22   3127
          17   3123
          21   3123
          20   3123
          19   3119
          18   3115
3144: oGetAddrLocal 8
3146: oPushResult
3147: oTypeSTop
3148: oPushResult
3149: oSetResult 2
3151: oPushResult
3152: oNodeGetInt
3153: oPop 2
3155: oAssign
3156: oEmit 20
3158: oGetLocal 8
3160: oPushResult
3161: oEmitInt
3162: oPop 1
3164: oJumpForward 3172
3166: Choice Lookup Table
           0   3108
           1   3100
3171: oEndChoice
3172: oTypeSPop
3173: oGetAddrLocal 6
3175: oPushResult
3176: oNodeNext
3177: oPop 1
3179: oGetLocal 6
3181: oPushResult
3182: oNodeNull
3183: oPop 1
3185: oChoice 3193
3187: oJumpForward 3203
3189: oJumpForward 3199
3191: oJumpForward 3199
3193: Choice Lookup Table
           0   3191
           1   3187
3198: oEndChoice
3199: oInput 12
3201: oJumpBack 3040
3203: oInput 14
3205: oJumpForward 3210
3207: Choice Lookup Table
          13   3040
3210: oGetLocal 6
3212: oPushResult
3213: oNodeNull
3214: oPop 1
3216: oChoice 3222
3218: oError 15
3220: oJumpForward 3225
3222: Choice Lookup Table
           0   3218
3225: oGetLocal 1
3227: oChoice 3256
3229: oEmit 13
3231: oGetParam 1
3233: oPushResult
3234: oSetResult 11
3236: oPushResult
3237: oNodeGetInt
3238: oPop 2
3240: oPushResult
3241: oEmitInt
3242: oPop 1
3244: oEmit 11
3246: oGetLocal 3
3248: oPushResult
3249: oEmitInt
3250: oPop 1
3252: oEmit 19
3254: oJumpForward 3259
3256: Choice Lookup Table
           1   3229
3259: oEmit 42
3261: oGetParam 1
3263: oPushResult
3264: oCall 4619
3266: oPop 1
3268: oGetLocal 1
3270: oChoice 3290
3272: oGetLocal 2
3274: oPushResult
3275: oTypeSPush
3276: oPop 1
3278: oEmit 11
3280: oGetLocal 3
3282: oPushResult
3283: oEmitInt
3284: oPop 1
3286: oCall 2597
3288: oJumpForward 3293
3290: Choice Lookup Table
           1   3272
3293: oEmit 41
3295: oGetLocal 5
3297: oPushResult
3298: oEmitInt
3299: oPop 1
3301: oReturn
3302: oLocalSpace 0
3304: oInputChoice 3354
3306: oCall 4261
3308: oJumpForward 3379
3310: oCall 4268
3312: oJumpForward 3379
3314: oCall 4335
3316: oJumpForward 3379
3318: oCall 4338
3320: oJumpForward 3379
3322: oCall 3796
3324: oJumpForward 3379
3326: oCall 4111
3328: oJumpForward 3379
3330: oCall 3866
3332: oJumpForward 3379
3334: oCall 4040
3336: oJumpForward 3379
3338: oCall 4206
3340: oJumpForward 3379
3342: oCall 4174
3344: oJumpForward 3379
3346: oCall 4238
3348: oJumpForward 3379
3350: oCall 3380
3352: oJumpForward 3379
3354: Choice Lookup Table
           0   3350
          32   3346
          48   3342
          49   3338
          46   3334
          41   3330
          45   3326
          38   3322
          57   3318
          56   3314
          55   3310
          54   3306
3379: oReturn
3380: oLocalSpace 1
3382: oGetAddrLocal 1
3384: oPushResult
3385: oScopeFindRequire
3386: oAssign
3387: oGetLocal 1
3389: oPushResult
3390: oNodeType
3391: oPop 1
3393: oChoice 3422
3395: oGetLocal 1
3397: oPushResult
3398: oCall 2940
3400: oPop 1
3402: oJumpForward 3435
3404: oGetLocal 1
3406: oPushResult
3407: oCall 3436
3409: oPop 1
3411: oJumpForward 3435
3413: oGetLocal 1
3415: oPushResult
3416: oCall 3505
3418: oPop 1
3420: oJumpForward 3435
3422: Choice Lookup Table
           8   3413
          15   3404
          13   3404
          12   3404
           7   3395
3433: oError 0
3435: oReturn
3436: oLocalSpace 1
3438: oGetParam 1
3440: oPushResult
3441: oCall 3655
3443: oPop 1
3445: oInput 3
3447: oCall 1613
3449: oCall 4341
3451: oTypeSNodeType
3452: oChoice 3470
3454: oEmit 17
3456: oJumpForward 3503
3458: oEmit 18
3460: oJumpForward 3503
3462: oError 16
3464: oJumpForward 3503
3466: oEmit 19
3468: oJumpForward 3503
3470: Choice Lookup Table
          22   3466
          17   3462
          21   3462
          20   3462
          19   3458
          18   3454
3483: oGetAddrLocal 1
3485: oPushResult
3486: oTypeSTop
3487: oPushResult
3488: oSetResult 2
3490: oPushResult
3491: oNodeGetInt
3492: oPop 2
3494: oAssign
3495: oEmit 20
3497: oGetLocal 1
3499: oPushResult
3500: oEmitInt
3501: oPop 1
3503: oTypeSPop
3504: oReturn
3505: oLocalSpace 1
3507: oGetParam 1
3509: oPushResult
3510: oSetResult 9
3512: oPushResult
3513: oNodeGet
3514: oPop 2
3516: oPushResult
3517: oScopeCurrent
3518: oPushResult
3519: oNodeEqual
3520: oPop 2
3522: oChoice 3528
3524: oError 20
3526: oJumpForward 3531
3528: Choice Lookup Table
           0   3524
3531: oEmit 8
3533: oGetParam 1
3535: oPushResult
3536: oSetResult 11
3538: oPushResult
3539: oNodeGetInt
3540: oPop 2
3542: oPushResult
3543: oEmitInt
3544: oPop 1
3546: oGetParam 1
3548: oPushResult
3549: oSetResult 5
3551: oPushResult
3552: oNodeGet
3553: oPop 2
3555: oPushResult
3556: oTypeSPush
3557: oPop 1
3559: oInput 3
3561: oCall 1613
3563: oCall 4341
3565: oTypeSNodeType
3566: oChoice 3584
3568: oEmit 17
3570: oJumpForward 3617
3572: oEmit 18
3574: oJumpForward 3617
3576: oError 16
3578: oJumpForward 3617
3580: oEmit 19
3582: oJumpForward 3617
3584: Choice Lookup Table
          22   3580
          17   3576
          21   3576
          20   3576
          19   3572
          18   3568
3597: oGetAddrLocal 1
3599: oPushResult
3600: oTypeSTop
3601: oPushResult
3602: oSetResult 2
3604: oPushResult
3605: oNodeGetInt
3606: oPop 2
3608: oAssign
3609: oEmit 20
3611: oGetLocal 1
3613: oPushResult
3614: oEmitInt
3615: oPop 1
3617: oTypeSPop
3618: oReturn
3619: oLocalSpace 1
3621: oInput 0
3623: oGetAddrLocal 1
3625: oPushResult
3626: oScopeFindRequire
3627: oAssign
3628: oGetLocal 1
3630: oPushResult
3631: oNodeType
3632: oPop 1
3634: oChoice 3638
3636: oJumpForward 3647
3638: Choice Lookup Table
          15   3636
          13   3636
          12   3636
3645: oError 4
3647: oGetLocal 1
3649: oPushResult
3650: oCall 3655
3652: oPop 1
3654: oReturn
3655: oLocalSpace 0
3657: oGetParam 1
3659: oPushResult
3660: oNodeType
3661: oPop 1
3663: oChoice 3723
3665: oEmit 10
3667: oGetParam 1
3669: oPushResult
3670: oCall 4619
3672: oPop 1
3674: oJumpForward 3732
3676: oEmit 11
3678: oGetParam 1
3680: oPushResult
3681: oCall 4619
3683: oPop 1
3685: oJumpForward 3732
3687: oGetParam 1
3689: oPushResult
3690: oSetResult 12
3692: oPushResult
3693: oNodeGetBoolean
3694: oPop 2
3696: oChoice 3709
3698: oEmit 8
3700: oGetParam 1
3702: oPushResult
3703: oCall 4619
3705: oPop 1
3707: oJumpForward 3721
3709: Choice Lookup Table
           1   3698
3712: oEmit 12
3714: oGetParam 1
3716: oPushResult
3717: oCall 4619
3719: oPop 1
3721: oJumpForward 3732
3723: Choice Lookup Table
          15   3687
          13   3676
          12   3665
3730: oError 4
3732: oGetParam 1
3734: oPushResult
3735: oSetResult 5
3737: oPushResult
3738: oNodeGet
3739: oPop 2
3741: oPushResult
3742: oTypeSPush
3743: oPop 1
3745: oCall 2632
3747: oReturn
3748: oLocalSpace 0
3750: oGetParam 1
3752: oPushResult
3753: oCall 3655
3755: oPop 1
3757: oCall 4367
3759: oGetParam 1
3761: oPushResult
3762: oCall 2218
3764: oPop 1
3766: oTypeSPop
3767: oEmit 21
3769: oEmit 17
3771: oReturn
3772: oLocalSpace 0
3774: oGetParam 1
3776: oPushResult
3777: oCall 3655
3779: oPop 1
3781: oCall 4367
3783: oGetParam 1
3785: oPushResult
3786: oCall 2218
3788: oPop 1
3790: oTypeSPop
3791: oEmit 22
3793: oEmit 17
3795: oReturn
3796: oLocalSpace 2
3798: oGetAddrLocal 1
3800: oPushResult
3801: oLabelNew
3802: oAssign
3803: oCall 1613
3805: oCall 4394
3807: oInput 39
3809: oEmit 47
3811: oGetLocal 1
3813: oPushResult
3814: oEmitLabel
3815: oPop 1
3817: oCall 3302
3819: oInputChoice 3854
3821: oGetAddrLocal 2
3823: oPushResult
3824: oLabelNew
3825: oAssign
3826: oEmit 45
3828: oGetLocal 2
3830: oPushResult
3831: oEmitLabel
3832: oPop 1
3834: oEmit 48
3836: oGetLocal 1
3838: oPushResult
3839: oEmitLabel
3840: oPop 1
3842: oCall 3302
3844: oEmit 48
3846: oGetLocal 2
3848: oPushResult
3849: oEmitLabel
3850: oPop 1
3852: oJumpForward 3865
3854: Choice Lookup Table
          40   3821
3857: oEmit 48
3859: oGetLocal 1
3861: oPushResult
3862: oEmitLabel
3863: oPop 1
3865: oReturn
3866: oLocalSpace 4
3868: oInput 0
3870: oGetAddrLocal 1
3872: oPushResult
3873: oScopeFindRequire
3874: oAssign
3875: oGetLocal 1
3877: oPushResult
3878: oCall 3655
3880: oPop 1
3882: oCall 4367
3884: oInput 3
3886: oCall 1613
3888: oCall 4367
3890: oEmit 17
3892: oGetAddrLocal 2
3894: oPushResult
3895: oLabelNew
3896: oAssign
3897: oGetAddrLocal 3
3899: oPushResult
3900: oLabelNew
3901: oAssign
3902: oEmit 45
3904: oGetLocal 3
3906: oPushResult
3907: oEmitLabel
3908: oPop 1
3910: oGetAddrLocal 4
3912: oPushResult
3913: oLabelNew
3914: oAssign
3915: oEmit 48
3917: oGetLocal 4
3919: oPushResult
3920: oEmitLabel
3921: oPop 1
3923: oInputChoice 4003
3925: oGetLocal 1
3927: oPushResult
3928: oCall 3748
3930: oPop 1
3932: oEmit 48
3934: oGetLocal 3
3936: oPushResult
3937: oEmitLabel
3938: oPop 1
3940: oGetLocal 1
3942: oPushResult
3943: oCall 2218
3945: oPop 1
3947: oTypeSPop
3948: oCall 1613
3950: oCall 4367
3952: oEmit 34
3954: oEmit 46
3956: oGetLocal 2
3958: oPushResult
3959: oEmitLabel
3960: oPop 1
3962: oJumpForward 4009
3964: oGetLocal 1
3966: oPushResult
3967: oCall 3772
3969: oPop 1
3971: oEmit 48
3973: oGetLocal 3
3975: oPushResult
3976: oEmitLabel
3977: oPop 1
3979: oGetLocal 1
3981: oPushResult
3982: oCall 2218
3984: oPop 1
3986: oTypeSPop
3987: oCall 1613
3989: oCall 4367
3991: oEmit 35
3993: oEmit 46
3995: oGetLocal 2
3997: oPushResult
3998: oEmitLabel
3999: oPop 1
4001: oJumpForward 4009
4003: Choice Lookup Table
          43   3964
          42   3925
4008: oEndChoice
4009: oGetLocal 4
4011: oPushResult
4012: oGetLocal 2
4014: oPushResult
4015: oLoopPush
4016: oPop 2
4018: oInput 44
4020: oCall 3302
4022: oEmit 45
4024: oGetLocal 4
4026: oPushResult
4027: oEmitLabel
4028: oPop 1
4030: oEmit 48
4032: oGetLocal 2
4034: oPushResult
4035: oEmitLabel
4036: oPop 1
4038: oLoopPop
4039: oReturn
4040: oLocalSpace 2
4042: oGetAddrLocal 1
4044: oPushResult
4045: oLabelNew
4046: oAssign
4047: oEmit 48
4049: oGetLocal 1
4051: oPushResult
4052: oEmitLabel
4053: oPop 1
4055: oGetAddrLocal 2
4057: oPushResult
4058: oLabelNew
4059: oAssign
4060: oGetLocal 1
4062: oPushResult
4063: oGetLocal 2
4065: oPushResult
4066: oLoopPush
4067: oPop 2
4069: oCall 3302
4071: oInputChoice 4093
4073: oCall 3302
4075: oJumpForward 4099
4077: oCall 1613
4079: oCall 4394
4081: oEmit 47
4083: oGetLocal 1
4085: oPushResult
4086: oEmitLabel
4087: oPop 1
4089: oJumpForward 4101
4091: oJumpForward 4099
4093: Choice Lookup Table
          47   4077
           4   4073
4098: oEndChoice
4099: oJumpBack 4071
4101: oEmit 48
4103: oGetLocal 2
4105: oPushResult
4106: oEmitLabel
4107: oPop 1
4109: oLoopPop
4110: oReturn
4111: oLocalSpace 2
4113: oGetAddrLocal 1
4115: oPushResult
4116: oLabelNew
4117: oAssign
4118: oEmit 48
4120: oGetLocal 1
4122: oPushResult
4123: oEmitLabel
4124: oPop 1
4126: oGetAddrLocal 2
4128: oPushResult
4129: oLabelNew
4130: oAssign
4131: oGetLocal 1
4133: oPushResult
4134: oGetLocal 2
4136: oPushResult
4137: oLoopPush
4138: oPop 2
4140: oCall 1613
4142: oCall 4394
4144: oInput 44
4146: oEmit 47
4148: oGetLocal 2
4150: oPushResult
4151: oEmitLabel
4152: oPop 1
4154: oCall 3302
4156: oEmit 45
4158: oGetLocal 1
4160: oPushResult
4161: oEmitLabel
4162: oPop 1
4164: oEmit 48
4166: oGetLocal 2
4168: oPushResult
4169: oEmitLabel
4170: oPop 1
4172: oLoopPop
4173: oReturn
4174: oLocalSpace 0
4176: oLoopCycleLabel
4177: oPushResult
4178: oSetResult 0
4180: oPushResult
4181: equal_label
4182: oPop 2
4184: oChoice 4199
4186: oError 18
4188: oJumpForward 4205
4190: oEmit 45
4192: oLoopCycleLabel
4193: oPushResult
4194: oEmitLabel
4195: oPop 1
4197: oJumpForward 4205
4199: Choice Lookup Table
           0   4190
           1   4186
4204: oEndChoice
4205: oReturn
4206: oLocalSpace 0
4208: oLoopExitLabel
4209: oPushResult
4210: oSetResult 0
4212: oPushResult
4213: equal_label
4214: oPop 2
4216: oChoice 4231
4218: oError 18
4220: oJumpForward 4237
4222: oEmit 45
4224: oLoopExitLabel
4225: oPushResult
4226: oEmitLabel
4227: oPop 1
4229: oJumpForward 4237
4231: Choice Lookup Table
           0   4222
           1   4218
4236: oEndChoice
4237: oReturn
4238: oLocalSpace 0
4240: oCall 3302
4242: oInputChoice 4252
4244: oCall 3302
4246: oJumpForward 4258
4248: oJumpForward 4260
4250: oJumpForward 4258
4252: Choice Lookup Table
          33   4248
           4   4244
4257: oEndChoice
4258: oJumpBack 4242
4260: oReturn
4261: oLocalSpace 0
4263: oCall 4268
4265: oEmit 53
4267: oReturn
4268: oLocalSpace 0
4270: oInputChoice 4331
4272: oCall 1613
4274: oTypeSNodeType
4275: oChoice 4297
4277: oEmit 49
4279: oJumpForward 4312
4281: oEmit 50
4283: oJumpForward 4312
4285: oEmit 51
4287: oJumpForward 4312
4289: oError 16
4291: oJumpForward 4312
4293: oEmit 52
4295: oJumpForward 4312
4297: Choice Lookup Table
          22   4293
          17   4289
          20   4289
          21   4285
          19   4281
          18   4277
4310: oError 17
4312: oTypeSPop
4313: oInputChoice 4321
4315: oJumpForward 4329
4317: oJumpForward 4327
4319: oJumpForward 4327
4321: Choice Lookup Table
          12   4319
          14   4315
4326: oEndChoice
4327: oJumpBack 4272
4329: oJumpForward 4334
4331: Choice Lookup Table
          13   4272
4334: oReturn
4335: oLocalSpace 0
4337: oReturn
4338: oLocalSpace 0
4340: oReturn
4341: oLocalSpace 1
4343: oGetAddrLocal 1
4345: oPushResult
4346: oTypeSNodeType
4347: oAssign
4348: oTypeSPop
4349: oGetLocal 1
4351: oPushResult
4352: oTypeSNodeType
4353: oPushResult
4354: equal_node_type
4355: oPop 2
4357: oChoice 4363
4359: oError 14
4361: oJumpForward 4366
4363: Choice Lookup Table
           0   4359
4366: oReturn
4367: oLocalSpace 0
4369: oTypeSNodeType
4370: oChoice 4374
4372: oJumpForward 4379
4374: Choice Lookup Table
          18   4372
4377: oError 7
4379: oTypeSPop
4380: oReturn
4381: oLocalSpace 0
4383: oTypeSNodeType
4384: oChoice 4388
4386: oJumpForward 4393
4388: Choice Lookup Table
          18   4386
4391: oError 7
4393: oReturn
4394: oLocalSpace 0
4396: oTypeSNodeType
4397: oChoice 4401
4399: oJumpForward 4406
4401: Choice Lookup Table
          19   4399
4404: oError 8
4406: oTypeSPop
4407: oReturn
4408: oLocalSpace 0
4410: oTypeSNodeType
4411: oChoice 4415
4413: oJumpForward 4420
4415: Choice Lookup Table
          19   4413
4418: oError 8
4420: oReturn
4421: oLocalSpace 1
4423: oGetAddrLocal 1
4425: oPushResult
4426: oGetParam 2
4428: oPushResult
4429: oNodeNew
4430: oPop 1
4432: oAssign
4433: oGetLocal 1
4435: oPushResult
4436: oSetResult 2
4438: oPushResult
4439: oGetParam 1
4441: oPushResult
4442: oNodeSetInt
4443: oPop 3
4445: oGetLocal 1
4447: oPushResult
4448: oTypeAdd
4449: oPop 1
4451: oGetLocal 1
4453: oReturn
4454: oReturn
4455: oLocalSpace 1
4457: oGetAddrLocal 1
4459: oPushResult
4460: oGetParam 3
4462: oPushResult
4463: oNodeNew
4464: oPop 1
4466: oAssign
4467: oGetLocal 1
4469: oPushResult
4470: oSetResult 4
4472: oPushResult
4473: oGetParam 1
4475: oPushResult
4476: oNodeSetInt
4477: oPop 3
4479: oGetLocal 1
4481: oReturn
4482: oReturn
4483: oLocalSpace 1
4485: oGetAddrLocal 1
4487: oPushResult
4488: oGetParam 1
4490: oPushResult
4491: oSetResult 13
4493: oPushResult
4494: oNodeGet
4495: oPop 2
4497: oAssign
4498: oGetLocal 1
4500: oPushResult
4501: oNodeNull
4502: oPop 1
4504: oChoice 4560
4506: oGetAddrLocal 1
4508: oPushResult
4509: oSetResult 22
4511: oPushResult
4512: oNodeNew
4513: oPop 1
4515: oAssign
4516: oGetLocal 1
4518: oPushResult
4519: oSetResult 14
4521: oPushResult
4522: oGetParam 1
4524: oPushResult
4525: oNodeSet
4526: oPop 3
4528: oGetLocal 1
4530: oPushResult
4531: oSetResult 2
4533: oPushResult
4534: oSetResult 8
4536: oPushResult
4537: oNodeSetInt
4538: oPop 3
4540: oGetLocal 1
4542: oPushResult
4543: oTypeAdd
4544: oPop 1
4546: oGetParam 1
4548: oPushResult
4549: oSetResult 13
4551: oPushResult
4552: oGetLocal 1
4554: oPushResult
4555: oNodeSet
4556: oPop 3
4558: oJumpForward 4563
4560: Choice Lookup Table
           1   4506
4563: oGetLocal 1
4565: oReturn
4566: oReturn
4567: oLocalSpace 0
4569: oGetParam 1
4571: oPushResult
4572: oNodeType
4573: oPop 1
4575: oChoice 4604
4577: oSetResult 0
4579: oReturn
4580: oJumpForward 4618
4582: oSetResult 0
4584: oReturn
4585: oJumpForward 4618
4587: oSetResult 0
4589: oReturn
4590: oJumpForward 4618
4592: oGetParam 1
4594: oPushResult
4595: oSetResult 16
4597: oPushResult
4598: oNodeGetInt
4599: oPop 2
4601: oReturn
4602: oJumpForward 4618
4604: Choice Lookup Table
          24   4592
          20   4587
          19   4582
          18   4577
4613: oError 3
4615: oSetResult 0
4617: oReturn
4618: oReturn
4619: oLocalSpace 0
4621: oGetParam 1
4623: oPushResult
4624: oSetResult 6
4626: oPushResult
4627: oNodeGetInt
4628: oPop 2
4630: oPushResult
4631: oEmitInt
4632: oPop 1
4634: oReturn
4635: oLocalSpace 1
4637: oGetAddrGlobal 2
4639: oPushResult
4640: oSetResult 17
4642: oPushResult
4643: oSetResult 4
4645: oPushResult
4646: oCall 4421
4648: oPop 2
4650: oAssign
4651: oGetAddrGlobal 3
4653: oPushResult
4654: oSetResult 18
4656: oPushResult
4657: oSetResult 4
4659: oPushResult
4660: oCall 4421
4662: oPop 2
4664: oAssign
4665: oGetAddrGlobal 4
4667: oPushResult
4668: oSetResult 19
4670: oPushResult
4671: oSetResult 1
4673: oPushResult
4674: oCall 4421
4676: oPop 2
4678: oAssign
4679: oGetAddrGlobal 5
4681: oPushResult
4682: oSetResult 20
4684: oPushResult
4685: oSetResult 1
4687: oPushResult
4688: oCall 4421
4690: oPop 2
4692: oAssign
4693: oGetAddrGlobal 6
4695: oPushResult
4696: oSetResult 21
4698: oPushResult
4699: oSetResult 256
4701: oPushResult
4702: oCall 4421
4704: oPop 2
4706: oAssign
4707: oGetAddrLocal 1
4709: oPushResult
4710: oSetResult 10
4712: oPushResult
4713: oSetResult 5
4715: oPushResult
4716: oIdAdd_File
4717: oPushResult
4718: oCall 4455
4720: oPop 3
4722: oAssign
4723: oGetLocal 1
4725: oPushResult
4726: oSetResult 5
4728: oPushResult
4729: oGetGlobal 2
4731: oPushResult
4732: oNodeSet
4733: oPop 3
4735: oGetLocal 1
4737: oPushResult
4738: oScopeDeclare
4739: oPop 1
4741: oGetAddrLocal 1
4743: oPushResult
4744: oSetResult 10
4746: oPushResult
4747: oSetResult 5
4749: oPushResult
4750: oIdAdd_Integer
4751: oPushResult
4752: oCall 4455
4754: oPop 3
4756: oAssign
4757: oGetLocal 1
4759: oPushResult
4760: oSetResult 5
4762: oPushResult
4763: oGetGlobal 3
4765: oPushResult
4766: oNodeSet
4767: oPop 3
4769: oGetLocal 1
4771: oPushResult
4772: oScopeDeclare
4773: oPop 1
4775: oGetAddrLocal 1
4777: oPushResult
4778: oSetResult 10
4780: oPushResult
4781: oSetResult 5
4783: oPushResult
4784: oIdAdd_Boolean
4785: oPushResult
4786: oCall 4455
4788: oPop 3
4790: oAssign
4791: oGetLocal 1
4793: oPushResult
4794: oSetResult 5
4796: oPushResult
4797: oGetGlobal 4
4799: oPushResult
4800: oNodeSet
4801: oPop 3
4803: oGetLocal 1
4805: oPushResult
4806: oScopeDeclare
4807: oPop 1
4809: oGetAddrLocal 1
4811: oPushResult
4812: oSetResult 10
4814: oPushResult
4815: oSetResult 5
4817: oPushResult
4818: oIdAdd_Char
4819: oPushResult
4820: oCall 4455
4822: oPop 3
4824: oAssign
4825: oGetLocal 1
4827: oPushResult
4828: oSetResult 5
4830: oPushResult
4831: oGetGlobal 5
4833: oPushResult
4834: oNodeSet
4835: oPop 3
4837: oGetLocal 1
4839: oPushResult
4840: oScopeDeclare
4841: oPop 1
4843: oGetAddrLocal 1
4845: oPushResult
4846: oSetResult 10
4848: oPushResult
4849: oSetResult 5
4851: oPushResult
4852: oIdAdd_String
4853: oPushResult
4854: oCall 4455
4856: oPop 3
4858: oAssign
4859: oGetLocal 1
4861: oPushResult
4862: oSetResult 5
4864: oPushResult
4865: oGetGlobal 6
4867: oPushResult
4868: oNodeSet
4869: oPop 3
4871: oGetLocal 1
4873: oPushResult
4874: oScopeDeclare
4875: oPop 1
4877: oGetAddrLocal 1
4879: oPushResult
4880: oSetResult 9
4882: oPushResult
4883: oSetResult 4
4885: oPushResult
4886: oIdAdd_True
4887: oPushResult
4888: oCall 4455
4890: oPop 3
4892: oAssign
4893: oGetLocal 1
4895: oPushResult
4896: oSetResult 5
4898: oPushResult
4899: oGetGlobal 4
4901: oPushResult
4902: oNodeSet
4903: oPop 3
4905: oGetLocal 1
4907: oPushResult
4908: oSetResult 6
4910: oPushResult
4911: oSetResult 1
4913: oPushResult
4914: oNodeSetInt
4915: oPop 3
4917: oGetLocal 1
4919: oPushResult
4920: oScopeDeclare
4921: oPop 1
4923: oGetAddrLocal 1
4925: oPushResult
4926: oSetResult 9
4928: oPushResult
4929: oSetResult 4
4931: oPushResult
4932: oIdAdd_False
4933: oPushResult
4934: oCall 4455
4936: oPop 3
4938: oAssign
4939: oGetLocal 1
4941: oPushResult
4942: oSetResult 5
4944: oPushResult
4945: oGetGlobal 4
4947: oPushResult
4948: oNodeSet
4949: oPop 3
4951: oGetLocal 1
4953: oPushResult
4954: oSetResult 6
4956: oPushResult
4957: oSetResult 0
4959: oPushResult
4960: oNodeSetInt
4961: oPop 3
4963: oGetLocal 1
4965: oPushResult
4966: oScopeDeclare
4967: oPop 1
4969: oReturn
