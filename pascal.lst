   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pCharLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tSwap             % swap the top two entries on the stack
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubP
   2:    tSubPI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualB
   2:    tNotEqualB
   2:    tGreaterB         % B is uint8_t, so these are unsigned comparisons
   2:    tLessB
   2:    tGreaterEqualB
   2:    tLessEqualB
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too, but I'm moving to tEqualB etc for those
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tGreaterP
   2:    tLessP
   2:    tGreaterEqualP
   2:    tLessEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteShortStr    %  "     "    : write ShortString whose addr is on tos, pop
   2:    tWritePChar       %  "     "    : write a null-terminated string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
   2:    tFile             % <file#> - pascal source file id, for debugging.  I haven't decided yet how I will communicate the corresponding filename.
   2:    tLine             % <line#> - pascal source line number, for debugging
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    eCantUsePredSuccOnEnumWithValueGaps
   2:    eCantDereference
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nTypedConst
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nPointerType
   2: 	nUniversalPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nStrLitType
   2: 	nShortStringType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qCapacity
   2: 	qNameTable
   2: 	qHasGap
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     oMAXINT >> int    % the maximum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % gets/adds a predefined id to the scanner's id table, and returns the id code
   2:     oId_mysystem >> int
   2:     oId_ShortStringAppendShortString >> int
   2:     oId_ShortStringAppendChar >> int
   2:     oId_File >> int
   2:     oId_Integer >> int
   2:     oId_Boolean >> int
   2:     oId_Char >> int
   2:     oId_Byte >> int
   2:     oId_Pointer >> int
   2:     oId_ShortString >> int
   2:     oId_True >> int
   2:     oId_False >> int
   2:     oId_Nil >> int
   2:     oId_Ord >> int
   2:     oId_Chr >> int
   2:     oId_Pred >> int
   2:     oId_Succ >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    oStringAllocShortStringLit( String ) >> int  % alloc global space for ShortString, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      
   2: int     mysystemId               % id of identifier "mysystem"
      
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    PCharType
   2: Node    ByteType
   2: Node    UniversalPointerType
   2: Node    StrLitType
   2: Node    ShortStringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
   2: Node    BuiltIn_Pred
   2: Node    BuiltIn_Succ
      
      % Declarations in unit mysystem that the compiler may refer to directly.
      
   2: Node    System_ShortStringAppendShortString
   2: Node    System_ShortStringAppendChar
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: EnumTypeRef( out Node resultType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: OrdinalHigh( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl, boolean writeable );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
   2: MoveIntoTempShortString >> int;
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
 180:    @UsesMySystem( program )
         % The uses clause may only appear once, immediately after the program declaration.
 187:    [
 187:       | pUses :  @UsesClause( program )
 196:       | * :
 201:    ]
 201:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 208:    oScopeBegin( 0, allocGlobal )
 217:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 222:    oScopeBegin( 0, allocDown )
 231:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 242:    initScope = oScopeCurrent
 247:    oNodeSet( program, qMainRoutineScope, initScope )
 259:    oScopeEnd
      
 260:    @BlockDecls( nGlobalVar )
      
      
 267:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 273:    boolean isMain = true
 279:    @BlockStmt( mainLabel, globalScope, isMain )
      
 292:    oScopeEnd   % main routine scope
      
 293:    '.'
 295:    @CheckForUndefinedLabels
 297:    oScopeEnd   % global scope
 298:    @EndUsedUnits( program )   % used units scopes
 306:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 306: UsesClause( Node user ):
 308:    {
 308:       pIdent
 310:       @Uses( LAST_ID, user )
 319:       [
 319:          | ',' :
 321:          | * :  >
 328:       ]
 328:    }   
 330:    ';'
 333:    ;
      
      
      % Process an implicit "uses mysystem" in every module, except in the mysystem unit itself.
      % (I'm calling the unit mysystem rather than system, so fpc doesn't use it to replace its own system unit.)
      %
 333: UsesMySystem( Node user ):
 335:    [ equal( oNodeGetInt( user, qIdent ), mysystemId )
 352:       | true :  >>
 354:       | * :
 359:    ]
 359:    @Uses( mysystemId, user )
 370:    ;
      
      
      % After processing the mysystem unit interface, grab certain declarations from it
      % that the compiler may want to refer to later.
      %
 370: FindSelectSystemDecls( Node unit ):
 372:    [ equal( oNodeGetInt( unit, qIdent ), mysystemId )
 389:       | true :
 390:          System_ShortStringAppendShortString = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendShortString )
 407:          System_ShortStringAppendChar = oNodeFind( oScopeCurrent, qDecls, qIdent, oId_ShortStringAppendChar )
 424:       | * :
 429:    ]
 430:    ;
      
      
      % The given user module uses a unit with the given id,
      % which may or may not have been loaded already.
      %
 430: Uses( int id, Node user ):
 432:    Node unit = @FindOrCompileUnit( id )
 443:    [ equal_node( unit, Null )
 453:       | false :
 454:          oNodeAddLast( user, qUsedUnits, unit )
      
               % Put a declaration in the current scope, naming the unit and pointing to it.
               % This is to allow references to  <unit>.<identifier_in_unit>
 466:          Node unitRef = oNodeNew( nUnitRef )
 476:          oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 495:          oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 514:          oScopeDeclare( unitRef )
 520:       | * :
 525:    ];
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 526: ResolveUnitRef( inout Node decl ):
 528:    [ oNodeType( decl )
 535:       | nUnitRef :
 536:          Node scope = oNodeGet( decl, qPublicScope )
 549:          '.'
 551:          pIdent
 553:          decl = oScopeFindRequireInScope( scope )
 563:       | * :
 568:    ];
      
      
 569: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 571:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 584:    {
 584:       Node unit = oNodeIterValue( unitIt )
 594:       [ oNodeNull( unit )
 601:          | false :
 602:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 615:          | * :
 620:             >
 622:       ]
 622:       oNodeIterNext( unitIt )
 628:    }
 631:    ;
      
 631: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 633:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 646:    {
 646:       Node unit = oNodeIterValue( unitIt )
 656:       [ oNodeNull( unit )
 663:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 664:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 680:                | true :
 681:                | false :  #eInternalScopeMismatch
 685:             ]
 693:             oScopeEnd
 694:          | * :
 699:             >
 701:       ]
 701:       oNodeIterPrev( unitIt )
 707:    }
 710:    ;
      
      
 710: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 712:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 731:    [ equal_node( unit, Null )
 741:       | false :  >> unit
 745:       | * :
 750:    ]
      
         % If not, search for the source file on disk
 750:    boolean ok = oIncludeUnitFile( id )
 760:    [ ok
 763:       | false :  #eCantFindUnitFile  >> Null
 769:       | * :
 774:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 774:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 780:    oIncludeEnd
 781:    >> unit;
      
      
      
 785: Unit >> Node:
 787:    pUnit
 789:    pIdent
 791:    Node unit = oNodeNew( nUnit )
 801:    oNodeSetInt( unit, qIdent, LAST_ID )
 812:    Node unitImpl = oNodeNew( nUnitImpl )
 822:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 833:    oNodeSet( unit, qImpl, unitImpl )
 845:    ';'
      
         % mandatory sections
      
 847:    pInterface
 849:    @UsesMySystem( unit )
 856:    [
 856:       | pUses :   @UsesClause( unit )
 865:       | * :
 870:    ]
 870:    @EnterUsedUnits( unit )
      
 877:    oScopeBegin( 0, allocGlobal )
 886:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 897:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 902:    oScopeBegin( 0, allocDown )
 911:    initScope = oScopeCurrent
 916:    oNodeSet( unit, qInitRoutineScope, initScope )
 928:    oScopeEnd
      
 929:    @UnitInterface( unit )
 936:    oScopeEnd  % interface scope
      
 937:    pImplementation
 939:    @UsesMySystem( unitImpl )
 946:    [
 946:       | pUses :   @UsesClause( unitImpl )
 955:       | * :
 960:    ]
 960:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 967:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 980:    oScopeBegin( 0, allocGlobal )
 989:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
1000:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
1018:    globalScope = oScopeCurrent
1023:    @UnitImplementation( unit )
      
1030:    [
1030:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
1042:       | * :                @UnitInitialization( unit, false )  % implicit init routine
1057:    ]
1057:    [
1057:       | pFinalization :  @UnitFinalization( unit, true )
1069:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
1084:    ]
1084:    pEnd  '.'
      
1088:    oScopeEnd  % impl scope
1089:    oScopeEnd  % interface scope
1090:    @EndUsedUnits( unitImpl )  % used units scopes
1097:    @EndUsedUnits( unit )
1104:    oNodeAddLast( workspace, qUnits, unit )
1116:    >> unit;
      
      
1120: UnitInterface( Node unit ):
1122:    {[
1122:       | pConst :     @ConstDecl
1126:       | pType :      @TypeDecl
1130:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1139:       | pProcedure :
1141:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1147:          [
1147:             | pExternal :
1149:                @ExternalDecl( decl )
1156:                ';'
1158:             | * :
1163:          ]
      
1163:       | pFunction :
1165:          Node decl = @FuncHeaderDecl
1171:          [
1171:             | pExternal :
1173:                @ExternalDecl( decl )
1180:                ';'
1182:             | * :
1187:          ]
      
1187:       | * :          >
1202:    ]}
1204:    @FindSelectSystemDecls( unit )
1212:    ;
      
1212: UnitImplementation( Node unit ):
1214:    @BlockDecls( nGlobalVar )
1222:    ;
      
      
1222: UnitInitialization( Node unit, boolean hasStmts ):
1224:    Label label = oLabelNew
1229:    .tLabel  oEmitLabel( label )
1237:    oNodeSetLabel( unit, qInitLabel, label )
      
1249:    int patchLS
1249:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1258:    Node scope
1258:    Code initCode
      
1258:    scope = oNodeGet( unit, qPublicScope )
1271:    initCode = oNodeGetCode( scope, qInitCode )
1284:    oEmitCode( initCode )
1290:    oNodeSetCode( scope, qInitCode, codeNull )
      
1302:    scope = oNodeGet( unit, qPrivateScope )
1315:    initCode = oNodeGetCode( scope, qInitCode )
1328:    oEmitCode( initCode )
1334:    oNodeSetCode( scope, qInitCode, codeNull )
      
1346:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1359:    [ hasStmts
1362:       | true :     
1363:          @Statement
1365:          {[
1365:             | ';' :  @Statement
1369:             | * :    >
1376:          ]}
1378:       | * :
1383:    ]
      
1383:    .tReturn
      
1385:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1397:    oPatch( patchLS, localSpace )
1406:    oScopeEnd   % init routine scope, for temporaries
1408:    ;
      
      
1408: UnitFinalization( Node unit, boolean hasStmts ):
1410:    Label label = oLabelNew
1415:    .tLabel  oEmitLabel( label )
1423:    oNodeSetLabel( unit, qFinalLabel, label )
      
1435:    int patchLS
1435:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1444:    oScopeBegin( 0, allocDown )
      
1453:    [ hasStmts
1456:       | true :     
1457:          @Statement
1459:          {[
1459:             | ';' :  @Statement
1463:             | * :    >
1470:          ]}
1472:       | * :
1477:    ]
      
1477:    .tReturn
      
1479:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1491:    oPatch( patchLS, localSpace )
1500:    oScopeEnd   % final routine scope, for temporaries
1502:    ;
      
      
1502: Block( node_type varNodeType, Label labelForBody ):
1504:    @BlockDecls( varNodeType )
1511:    @BlockStmt( labelForBody, oScopeCurrent, false )
1523:    @CheckForUndefinedLabels
1526:    ;
      
      
1526: BlockDecls( node_type varNodeType ):
1528:    {[
1528:       | pConst :     @ConstDecl
1532:       | pType :      @TypeDecl
1536:       | pVar :       @VarDecl( varNodeType )
1545:       | pLabel :     @LabelDecl
1549:       | pProcedure : @ProcDecl
1553:       | pFunction :  @FuncDecl
1557:       | * :          >
1574:    ]}
1576:    @CheckForUndefinedMethods
1579:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1579: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1582:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1582: CheckForUndefinedLabels:
1584:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1596:    {
1596:       Node decl = oNodeIterValue( it )
1606:       [ oNodeNull( decl )
1613:          | false :
1614:          | * :  >
1621:       ]
1621:       [ oNodeType( decl )
1628:          | nLabel :
1629:             [ oNodeGetBoolean( decl, qDefined )
1639:                | false :
1640:                   [ oNodeGetBoolean( decl, qUsed )
1650:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1653:                      | * :
1658:                   ]
1658:                | * :
1663:             ]
1663:          | * :
1668:       ]
1668:       oNodeIterNext( it )
1674:    }
1677:    ;
      
      
1677: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1679:    NodeIter it = oNodeGetIter( workspace, qUnits )
1692:    {
1692:       Node unit = oNodeIterValue( it )
1702:       [ oNodeNull( unit )
1709:          | true :  >
1712:          | false :
1714:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1722:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1737:             .tFreeActuals  oEmitInt( 0 )
1745:             oNodeIterNext( it )
1751:       ]
1759:    };
      
      
1762: FinalizeUnits:
1764:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1777:    {
1777:       Node unit = oNodeIterValue( it )
1787:       [ oNodeNull( unit )
1794:          | true :  >
1797:          | false :
1799:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1807:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1822:             .tFreeActuals  oEmitInt( 0 )
1830:             oNodeIterPrev( it )
1836:       ]
1844:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1847: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1849:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1857:    int patchLS
1857:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1866:    [ isMain
1869:       | true :  @InitializeUnits
1872:       | * :
1877:    ]
      
         % insert any code for initialization of this scope's variables
1877:    Code initCode = oNodeGetCode( varScope, qInitCode )
1890:    oEmitCode( initCode )
1896:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1908:    @Statement
      
1910:    [ isMain
1913:       | true :  @FinalizeUnits
1916:       | * :
1921:    ]
      
1921:    .tReturn
      
1923:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1935:    oPatch( patchLS, localSpace )
1945:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1945: MethodModifiers( Node decl ):
1947:    {[
1947:       | pCdecl :
1949:          oNodeSetBoolean( decl, qCdecl, true )
1961:          ';'
      
1963:       | * : >
1970:    ]}
1973:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1973: GetOrCreateInitCode( Node scope ) >> Code:
1975:    Code initCode = oNodeGetCode( scope, qInitCode )
1988:    [ equal_code( initCode, codeNull )
1998:       | true :
1999:          initCode = oCodeNew
2004:          oNodeSetCode( scope, qInitCode, initCode )
2016:       | * :
2021:    ]
2021:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
2025: ExternalDecl( Node decl ):
2027:    [ equal_zero( @DeclLevel( decl ) )
2039:       | false :  #eExternalMethodCannotBeNested
2042:       | * :
2047:    ]
2047:    oNodeSetBoolean( decl, qExternal, true )
2059:    [
2059:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
2061:          [
2061:             | pName :
2063:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
2065:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
2076:             | * :
2081:          ]
2081:       | * :
2086:    ]
2087:    ;
      
      
2087: ProcHeaderDecl >> Node:
2089:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2091:    boolean redeclaring = false
2097:    Node decl = oScopeFindInCurrentScope
      
2102:    [ oNodeNull( decl )
2109:       | true :
               % first declaration
2110:          decl = @newIdent( nProc, LAST_ID )
2123:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2134:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2136:          redeclaring = true
2142:          [ oNodeGetBoolean( decl, qBodyDefined )
2152:             | true : #eAlreadyDefined
2155:             | * :
2160:          ]
2160:          [ oNodeGetBoolean( decl, qExternal )
2170:             | true : #eAlreadyDefined
2173:             | * :
2178:          ]
2178:          [ oNodeType( decl )
2185:             | nProc :
2186:             | * : #eAlreadyDefined   % wrong kind
2193:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2193:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2212:          oNodeSet( decl, qParams, Null )
2224:    ]
      
2232:    int level = @ScopeLevel
2238:    boolean nested = greater( level, 0 )
2251:    inc( level )
2257:    oScopeBegin( level, allocUp )
2266:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2271:    [ nested
2274:       | true :
2275:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2290:       | * :
2295:    ]
      
2295:    @FormalArgDecl
2297:    oNodeSet( decl, qParams, paramScope )
2309:    oScopeEnd
2310:    ';'
      
2312:    [ redeclaring
2315:       | false : oScopeDeclare( decl )
2322:       | true :  % TO DO: check that qParams is consistent with qOldParams
2324:    ]
      
2332:    @MethodModifiers( decl )
2339:    >> decl;
      
      
2343: ProcDecl:
2345:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2351:    [
2351:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2353:       | pExternal : @ExternalDecl( decl )
      
2362:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2369:          Node paramScope = oNodeGet( decl, qParams )
2382:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2388:          int level = oNodeGetInt( paramScope, qLevel )
2401:          oScopeBegin( level, allocDown )
2410:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2421:          Label label = oNodeGetLabel( decl, qValue )
2434:          @Block( nLocalVar, label )
2444:          oNodeSetBoolean( decl, qBodyDefined, true )
2456:          oScopeEnd
      
2457:          oScopeEnd  % paramScope
2458:    ]
2458:    ';';
      
      
      
2461: FuncHeaderDecl >> Node:
2463:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2465:    boolean redeclaring = false
2471:    Node decl = oScopeFindInCurrentScope
      
2476:    [ oNodeNull( decl )
2483:       | true :
               % first declaration
2484:          decl = @newIdent( nFunc, LAST_ID )
2497:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2508:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2510:          redeclaring = true
2516:          [ oNodeGetBoolean( decl, qBodyDefined )
2526:             | true : #eAlreadyDefined
2529:             | * :
2534:          ]
2534:          [ oNodeType( decl )
2541:             | nFunc :
2542:             | * : #eAlreadyDefined   % wrong kind
2549:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2549:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2568:          oNodeSet( decl, qParams, Null )
2580:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2599:          oNodeSet( decl, qType, Null )
2611:    ]
      
2619:    int level = @ScopeLevel
2625:    boolean nested = greater( level, 0 )
2638:    inc( level )
2644:    oScopeBegin( level, allocUp )
2653:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2658:    [ nested
2661:       | true :
2662:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2677:       | * :
2682:    ]
      
2682:    @FormalArgDecl
2684:    oNodeSet( decl, qParams, paramScope )
      
2696:    ':'
      
2698:    Node theType
2698:    @TypeRef( theType )
2705:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2717:    Node ptrType = @PointerTypeTo( theType )
2728:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2744:    oScopeEnd
2745:    ';'
      
2747:    [ redeclaring
2750:       | false : oScopeDeclare( decl )
2757:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2759:    ]
      
2767:    @MethodModifiers( decl )
      
2774:    >> decl;
      
      
2778: FuncDecl:
2780:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2786:    [
2786:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2788:       | pExternal : @ExternalDecl( decl )
      
2797:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2804:          Node paramScope = oNodeGet( decl, qParams )
2817:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2823:          int level = oNodeGetInt( paramScope, qLevel )
2836:          oScopeBegin( level, allocDown )
2845:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2856:          Label label = oNodeGetLabel( decl, qValue )
2869:          @Block( nLocalVar, label )
2879:          oNodeSetBoolean( decl, qBodyDefined, true )
2891:          oScopeEnd
      
2892:          oScopeEnd  % paramScope
2893:    ]
2893:    ';';
      
      
2896: FormalArgDecl:
2898:    [
2898:       | '(' :
2900:          {
2900:             NodeVec decls = oNodeVecNew
2905:             Node decl
2905:             boolean isInOut = false
      
2911:             [
2911:                | pVar : isInOut = true
2919:                | * :
2924:             ]
      
2924:             {  pIdent
      
2926:                decl = @newIdent( nParam, LAST_ID )
2939:                oNodeSetBoolean( decl, qInOut, isInOut )
2951:                oNodeVecAppend( decls, decl )
      
2960:                [
2960:                   | ':' : >
2964:                   | ',' :
2966:                ]
2974:             }
      
2976:             Node theType
2976:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2983:             Node allocType
2983:             [ isInOut
2986:                | true :   allocType = @PointerTypeTo( theType )
2998:                | * :      allocType = theType
3009:             ]
      
3009:             int i = 0
3015:             {[ equal( i, oNodeVecSize( decls ) )
3029:                | false :
3030:                   decl = oNodeVecElement( decls, i )
      
3043:                   oNodeSet( decl, qType, theType )
3055:                   oScopeDeclare( decl )
3061:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
3077:                   inc( i )
3083:                | * :
3088:                   >
3090:             ]}
      
3092:             oNodeVecDelete( decls )
      
3098:             [
3098:                | ')' : >
3102:                | ';' :
3104:             ]
3112:          }
3114:       | * :
3119:    ];
      
      
3120: ConstDecl:
3122:    {[
3122:       | pIdent :
3124:          [
3124:             | ':' :
3126:                @TypedConstDecl
3128:             | * :
3133:                @UntypedConstDecl
3135:          ]
3135:       | * :
3140:          >
3142:    ]};
      
      
      % Parse an untyped const declaration.
      % We've just accepted the identifier.
      %
3145: UntypedConstDecl:
3147:    Node decl = @newIdent( nConst, LAST_ID )
3160:    '='
      
3162:    @ConstExpr
         % TO DO: currently ConstExpr leaves int result on oValue stack
3164:    int val = oValueTop
3169:    oValuePop
3170:    oNodeSetInt( decl, qValue, val )
      
         % TO DO: different types.  Currently assumes int!
         % Untyped const decl is supposed to allow:
         %   ordinal types, set types, pointer types (but only Nil), real types, char, string.
3182:    oNodeSet( decl, qType, IntegerType )
      
3194:    oScopeDeclare( decl )
3200:    ';'
3203:    ;
      
      
      % Parse a typed const declaration.
      % We've just accepted the identifier and ':'
      %
3203: TypedConstDecl:
3205:    Node decl = @newIdent( nTypedConst, LAST_ID )
      
3218:    Node theType
3218:    @TypeRef( theType )
3225:    oNodeSet( decl, qType, theType )
      
         % TO DO: array and record consts are allocated in global memory,
         % with global offset stored as decl value.
         % Scalar consts are not allocated in memory, and their value is
         % stored directly as the decl value.
      
         % TO DO: skip subranges, similar to oTypeSNodeType.
3237:    [ oNodeType( theType )
3244:       | nBooleanType, nByteType, nCharType, nIntegerType, nEnumType:
               % Parse expression and store value in decl
3245:          '='
      
3247:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3249:          int val = oValueTop
3254:          oValuePop
3255:          oNodeSetInt( decl, qValue, val )
3267:          oScopeDeclare( decl )
3273:          ';'
      
3275:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3277:          #eNotImplemented
      
3279:       | nArrayType, nRecordType :
               % Allocate global space, store address in decl.
               % Push into global scope init code stream (since we'll be issuing code
               % rather than creating static data, at the moment).
               % Parse expression and store in global memory.
3281:          oScopeEnter( globalScope )
3287:          int addr = oScopeAllocType( theType )
3297:          oScopeEnd
3298:          oCodePush( @GetOrCreateInitCode( globalScope ) )
3309:          oNodeSetInt( decl, qValue, addr )
3321:          '='
3323:          @TypedConstInit( theType, addr )
3333:          oCodePop
3334:          oScopeDeclare( decl )
3340:          ';'
3342:    ]
3369:    ;
      
      
      % Parse the initial value of a constant that's being stored in global memory.
      % (An array or record constant, and recursively all its elements.)
      % Given the type, and the address in global memory for the const value.
      % The caller has already pushed into the global init code stream.
      %
3369: TypedConstInit( Node theType, int addr ):
      
         % TO DO: skip subranges, similar to oTypeSNodeTYpe
3371:    [ oNodeType( theType )
3378:       | nArrayType :
3379:          Node baseType = oNodeGet( theType, qBaseType )
3392:          Node indexType = oNodeGet( theType, qIndexType )
3405:          int low = @OrdinalLow( indexType )
3416:          int high = @OrdinalHigh( indexType )
3427:          int elementSize = oNodeGetInt( baseType, qSize )
      
3440:          '('
               % Loop over elements
3442:          int i = low
3448:          {
3448:             @TypedConstInit( baseType, addr )
3458:             [ equal( i, high )
3468:                | true : >
3471:                | false :
3473:             ]
3481:             ','
3483:             addr = add( addr, elementSize )
3496:             inc( i )
3502:          }
3504:          ')'
      
3506:       | nRecordType :
3508:          '('
3510:          Node fieldScope = oNodeGet( theType, qScope )
               % Loop over zero or more named fields.  It's not necessary to name them all.
               % fpc says the names that are given should be in order, but I'm not requiring that.
               % Since this is global memory, uninitialized fields will be left as 0.
3523:          {
3523:             [
3523:                | pIdent :
3525:                | * :  >
3532:             ]
3532:             Node field = oScopeFindRequireInScope( fieldScope )
3542:             ':'
3544:             Node fieldType = oNodeGet( field, qType )
3557:             int fieldAddr = add( addr, oNodeGetInt( field, qValue ) )
3577:             @TypedConstInit( fieldType, fieldAddr )
3587:             [
3587:                | ';' :
3589:                | * :  >
3596:             ]
3596:          }
3598:          ')'
      
3600:       | nBooleanType, nByteType, nCharType:
3602:          .tPushAddrGlobal  oEmitInt( addr )
3610:          @ConstExpr
3612:          .tPushConstI  oEmitInt( oValueTop )
3619:          oValuePop
3620:          .tAssignB
      
3622:       | nIntegerType, nEnumType:
3624:          .tPushAddrGlobal  oEmitInt( addr )
3632:          @ConstExpr
3634:          .tPushConstI  oEmitInt( oValueTop )
3641:          oValuePop
3642:          .tAssignI
      
3644:       | nShortStringType, nFileType, nPointerType, nUniversalPointerType :
3646:          #eNotImplemented
3648:    ]
3675:    ;
      
      
3675: TypeDecl:
3677:    {[
3677:       | pIdent :
3679:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3692:          '='
3694:          Node theType
3694:          @TypeRef( theType )
3701:          oNodeSet( decl, qType, theType )
3713:          oScopeDeclare( decl )
3719:          ';'
3721:       | * :
3726:          >
3728:    ]};
      
3731: VarDecl( node_type varNodeType ):
3733:    {[
3733:       | pIdent :
3735:          NodeVec decls = oNodeVecNew
3740:          Node decl
3740:          {
3740:             decl = @newIdent( varNodeType, LAST_ID )
3753:             oNodeVecAppend( decls, decl )
3762:             [
3762:                | ',' :
3764:                   pIdent
3766:                | * :
3771:                   >
3773:             ]
3773:          }
3775:          ':'
3777:          Node theType
3777:          @TypeRef( theType )
      
3784:          int i = 0
3790:          {[ equal( i, oNodeVecSize( decls ) )
3804:             | false :
3805:                decl = oNodeVecElement( decls, i )
3818:                oNodeSet( decl, qType, theType )
3830:                oScopeDeclareAlloc( decl )
3836:                inc( i )
3842:             | * :
3847:               >
3849:          ]}
      
               % optional initialization
3851:          [
3851:             | '=' :
3853:                [ oNodeVecSize( decls )
3860:                   | 1 :
3861:                   | * :  #eOnlyOneVarCanBeInitialized
3868:                ]
      
                     % we need an initCode stream for this scope
3868:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3878:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3884:                boolean changedScope = false
3890:                [ equal_zero( @ScopeLevel )
3897:                   | true : oScopeEnter( initScope )
3904:                            changedScope = true
3910:                   | * :
3915:                ]
                     % generate assignment in initCode stream
3915:                @LValueVar( decl, true )
3925:                @Expr
3927:                @CoerceType
3929:                @Assign
3931:                [ changedScope
3934:                   | true : oScopeEnd
3936:                   | * :
3941:                ]
3941:                oCodePop
                   
3942:             | * :
3947:          ]
      
3947:          oNodeVecDelete( decls )
3953:          ';'
3955:       | * :
3960:          >
3962:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3965: LabelDecl:
3967:    {
3967:       Node decl
3967:       [
3967:          | pIdent :
3969:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3971:             oChangeIntLitToLabelIdent
3972:       ]
3980:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3993:       Label label = oLabelNew
3998:       oNodeSetLabel( decl, qValue, label )
4010:       oScopeDeclare( decl )
4016:       [
4016:          | ',' :
4018:          | * :
4023:             >
4025:       ]
4025:    }
4027:    ';'
4030:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
4030: TypeRef( out Node resultType ):
4032:    [
4032:       | pIdent :           % previously named type (including intrinsics)
4034:          Node decl = oScopeFindRequire
4039:          @ResolveUnitRef( decl )
4046:          [ oNodeType( decl )
4053:             | nTypeDecl :
4054:                resultType = oNodeGet( decl, qType )
4067:             | * :
4072:                #eNotType
4074:                resultType = IntegerType
4080:          ]
         
4080:       | pArray :
4082:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
4084:          NodeVec dimensions = oNodeVecNew
      
4089:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
4089:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
4099:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
4111:             @ConstExpr
4113:             oNodeSetInt( subrange, qLow, oValueTop )
4124:             oValuePop
4125:             '..'
4127:             @ConstExpr
4129:             oNodeSetInt( subrange, qHigh, oValueTop )
4140:             oValuePop
4141:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
4153:             oTypeAdd( subrange )
      
4159:             Node a = oNodeNew( nArrayType )
4169:             oNodeSet( a, qIndexType, subrange )
      
4181:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
4190:             [
4190:                | ']' : >
4194:                | ',' :
4196:             ]
4204:          }
      
4206:          pOf
4208:          Node baseType
4208:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
4215:          int dim = oNodeVecSize( dimensions )
      
4225:          {
4225:              dec(dim)
      
4231:              Node a = oNodeVecElement( dimensions, dim )
      
4244:              oNodeSet( a, qBaseType, baseType )
4256:              Node subrange = oNodeGet( a, qIndexType )
4269:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
4296:              inc( width )
4302:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
4328:              oTypeAdd( a )
4334:              baseType = a
      
4340:              [ equal_zero(dim)
4347:                  | true:  >
4350:                  | *:
4355:              ]
4355:          }
      
4357:          resultType = oNodeVecElement( dimensions, 0 )
4370:          oNodeVecDelete( dimensions )
      
4376:       | '^' :
4378:          Node theType
4378:          @TypeRef( theType )
4385:          resultType = @PointerTypeTo( theType )
      
4396:       | pRecord :
4398:          resultType = oNodeNew( nRecordType )
4408:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
4417:          @VarDecl( nRecordField )
      
4424:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
4436:          [ equal_zero( size )
4443:             | true : #eRecordEmpty
4446:             | * :
4451:          ]
      
4451:          pEnd
      
4453:          oNodeSet( resultType, qScope, oScopeCurrent )
4464:          oNodeSetInt( resultType, qSize, size )
4476:          oScopeEnd
4477:          oTypeAdd( resultType )
      
      
4483:       | '(' :
               % An enum type declaration.
4485:          @EnumTypeRef( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4492:       | pSet :
4494:          pOf
4496:          Node theType
4496:          @TypeRef( theType )
4503:       | * :       % this works for cases except where expr starts with an id
4518:          @ConstExpr '..' @ConstExpr
4524:    ];
      
      
      % Parse an enum type.
      % We've already accepted the '('
      % Returns the new type.
      %
4525: EnumTypeRef( out Node resultType ):
      
4527:    resultType = oNodeNew( nEnumType )
4537:    int value = 0
4543:    int numValues = 0
4549:    boolean first = true
      
         % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
         % That will let programs use either <val> or <enumType>.<val>
4555:    Node outerScope = oScopeCurrent
4560:    oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
4569:    {
            % TO DO: assert that name not already seen in this scope, i.e. this enum.
            %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
            %  It might be in some other higher/used scope.
4569:       pIdent
4571:       Node decl = @newIdent( nEnumValue, LAST_ID )
4584:       Node decl2 = @newIdent( nEnumValue, LAST_ID )
4597:       oNodeSet( decl, qType, resultType )
4609:       oNodeSet( decl2, qType, resultType )
      
            % build up name table, for i/o
4621:       int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
4634:       oNodeSetInt( decl, qNameOffset, nameOffset )
4646:       oNodeSetInt( decl2, qNameOffset, nameOffset )
4658:       [
4658:          | '=', ':=' :
4660:             @ConstExpr
                  % value must be ascending
                  % this obviously doesn't apply to the first value
4662:             [ equal_zero( numValues )
4669:                | false :
4670:                   [ greater( oValueTop, value )
4679:                      | false :   #eEnumValueNotAscending
4682:                      | * :
4687:                   ]
4687:                | * :
4692:             ]
4692:             [ equal( value, oValueTop )
4701:                | false :
                        % The values differ from 0..N-1.  pred/succ may not be used with this type.
4702:                   oNodeSetBoolean( resultType, qHasGap, true )
4714:                | * :
4719:             ]
4719:             value = oValueTop
4724:             oValuePop
4725:          | * :
4732:       ]
4732:       oNodeSetInt( decl, qValue, value )
4744:       oNodeSetInt( decl2, qValue, value )
4756:       oScopeDeclare( decl )
      
4762:       oScopeEnter( outerScope )
4768:       oScopeDeclare( decl2 )
4774:       oScopeEnd
      
4775:       inc( value )
4781:       inc( numValues )
4787:       [
4787:          | ',' :
4789:          | * :    >
4796:       ]
4796:    }
4798:    ')'
      
4800:    oNodeSet( resultType, qScope, oScopeCurrent )
4811:    oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4823:    oScopeEnd
      
         % Finish creation of the name table
         %    struct {
         %      int    value;
         %      int    padding;
         %      char*  name;
         %    } table[ numValues + 1 ];
         %  final entry will have name == nullptr
         %
         % I'll need to generate init code, to store pointers in global data,
         % since I don't have a relocation mechanism for static data at the moment.
4824:    oCodePush( @GetOrCreateInitCode( globalScope ) )
4835:    oScopeEnter( globalScope )
4841:    int size = multiply( add( numValues, 1 ), 16 )
4861:    int addr = oScopeAlloc( size, 8 )
4874:    oScopeEnd
4875:    oNodeSetInt( resultType, qNameTable, addr )
         % loop over enum values
4887:    NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4907:    {
4907:       Node enumValue = oNodeIterValue( it )
4917:       [ oNodeNull( enumValue )
4924:          | true :  >
4927:          | * :
4932:       ]
4932:       .tPushAddrGlobal  oEmitInt( addr )
4940:       .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4955:       .tAssignI
4957:       addr = add( addr, 8 )
4970:       .tPushAddrGlobal  oEmitInt( addr )
4978:       .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4993:       .tAssignP
4995:       addr = add( addr, 8 )
5008:       oNodeIterNext( it )
5014:    }
         % final table entry
5016:    .tPushAddrGlobal  oEmitInt( addr )
5024:    .tPushConstI  oEmitInt( 0 )
5032:    .tAssignI
5034:    addr = add( addr, 8 )
5047:    .tPushAddrGlobal  oEmitInt( addr )
5055:    .tPushConstI  oEmitInt( 0 )
5063:    .tAssignP
5065:    addr = add( addr, 8 )
5078:    oCodePop
      
5079:    oTypeAdd( resultType )
5086:    ;
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
5086: ConstExpr:
5088:    [
5088:       | pIntLit :
5090:          oValuePush( TOKEN_VALUE )
5095:       | pIdent :
5097:          Node decl = oScopeFindRequire
5102:          @ResolveUnitRef( decl )
5109:          [ oNodeType( decl )
5116:             | nConst :
5117:                oValuePush( oNodeGetInt( decl, qValue ) )
5130:             | * :
5135:                #eNotConst
5137:                oValuePush( 0 )
5143:          ]
5143:       | pMinus :
5145:          @ConstExpr
5147:          oValueNegate
5148:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
5159: Expr:
5161:    Label falseLabel = labelNull
      
5167:    @ExprAllowCF( falseLabel )
5174:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
5182: BooleanExprControlFlow( out Label falseLabel ):
5184:    @ExprAllowCF( falseLabel )
5191:    [ oTypeSNodeType
5193:       | nBooleanCFType :
5194:       | nBooleanType :
               % convert value to control flow
5196:          falseLabel = oLabelNew
5201:          .tJumpFalse  oEmitLabel( falseLabel )
5209:       | * :
5216:          #eNotBoolean
5218:    ]
5218:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
5220: CFToVal( inout Label falseLabel ):
5222:    [ oTypeSNodeType
5224:       | nBooleanCFType :
5225:          Label doneLabel = oLabelNew
5230:          .tPushConstI  oEmitInt( 1 )
5238:          .tJump  oEmitLabel( doneLabel )
5246:          .tLabel  oEmitLabel( falseLabel )
5254:          .tPushConstI  oEmitInt( 0 )
5262:          .tLabel  oEmitLabel( doneLabel )
5270:          oTypeSPop
5271:          oTypeSPush( BooleanType )
5277:          falseLabel = labelNull
5283:       | * :
5288:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
5289: ValToCF( out Label falseLabel ):
5291:    [ oTypeSNodeType
5293:       | nBooleanType :
5294:          falseLabel = oLabelNew
5299:          .tJumpFalse  oEmitLabel( falseLabel )
5307:          oTypeSPop
5308:          oTypeSPush( BooleanCFType )
5314:       | * :
5319:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
5320: ExprAllowCF( out Label falseLabel ):
5322:    @BoolExprAllowCF( falseLabel )
5329:    {[
5329:       | '=' :
5331:          @CFToVal( falseLabel )
5338:          @PromoteToIntOptional
5340:          @BoolExprAllowCF( falseLabel )
5347:          @CFToVal( falseLabel )
5354:          @PromoteToIntOptional
5356:          @MatchTypes
5358:          [ oTypeSNodeType
5360:             | nBooleanType, nCharType :     .tEqualB
5363:             | nIntegerType, nEnumType :     .tEqualI
5367:             | nPointerType, nUniversalPointerType :    .tEqualP
5371:             | nShortStringType, nStrLitType :            #eNotImplemented
5375:             | * :                           #eNotAllowed
5396:          ]
5396:          oTypeSPop
5397:          oTypeSPush( BooleanType )
      
5403:       | '<>' :
5405:          @CFToVal( falseLabel )
5412:          @PromoteToIntOptional
5414:          @BoolExprAllowCF( falseLabel )
5421:          @CFToVal( falseLabel )
5428:          @PromoteToIntOptional
5430:          @MatchTypes
5432:          [ oTypeSNodeType
5434:             | nBooleanType, nCharType :     .tNotEqualB
5437:             | nIntegerType, nEnumType :     .tNotEqualI
5441:             | nPointerType, nUniversalPointerType :    .tNotEqualP
5445:             | nShortStringType, nStrLitType :            #eNotImplemented
5449:             | * :                           #eNotAllowed
5470:          ]
5470:          oTypeSPop
5471:          oTypeSPush( BooleanType )
      
5477:       | '<' :
5479:          @CFToVal( falseLabel )
5486:          @PromoteToIntOptional
5488:          @BoolExprAllowCF( falseLabel )
5495:          @CFToVal( falseLabel )
5502:          @PromoteToIntOptional
5504:          @MatchTypes
5506:          [ oTypeSNodeType
5508:             | nBooleanType, nCharType :     .tLessB
5511:             | nIntegerType, nEnumType :     .tLessI
5515:             | nPointerType, nUniversalPointerType :   .tLessP
5519:             | nShortStringType, nStrLitType :            #eNotImplemented
5523:             | * :                           #eNotAllowed
5544:          ]
5544:          oTypeSPop
5545:          oTypeSPush( BooleanType )
      
5551:       | '>' :
5553:          @CFToVal( falseLabel )
5560:          @PromoteToIntOptional
5562:          @BoolExprAllowCF( falseLabel )
5569:          @CFToVal( falseLabel )
5576:          @PromoteToIntOptional
5578:          @MatchTypes
5580:          [ oTypeSNodeType
5582:             | nBooleanType, nCharType :     .tGreaterB
5585:             | nIntegerType, nEnumType :     .tGreaterI
5589:             | nPointerType, nUniversalPointerType :   .tGreaterP
5593:             | nShortStringType, nStrLitType :            #eNotImplemented
5597:             | * :                           #eNotAllowed
5618:          ]
5618:          oTypeSPop
5619:          oTypeSPush( BooleanType )
      
5625:       | '<=' :
5627:          @CFToVal( falseLabel )
5634:          @PromoteToIntOptional
5636:          @BoolExprAllowCF( falseLabel )
5643:          @CFToVal( falseLabel )
5650:          @PromoteToIntOptional
5652:          @MatchTypes
5654:          [ oTypeSNodeType
5656:             | nBooleanType, nCharType :     .tLessEqualB
5659:             | nIntegerType, nEnumType :     .tLessEqualI
5663:             | nPointerType, nUniversalPointerType :   .tLessEqualP
5667:             | nShortStringType, nStrLitType :            #eNotImplemented
5671:             | * :                           #eNotAllowed
5692:          ]
5692:          oTypeSPop
5693:          oTypeSPush( BooleanType )
      
5699:       | '>=' :
5701:          @CFToVal( falseLabel )
5708:          @PromoteToIntOptional
5710:          @BoolExprAllowCF( falseLabel )
5717:          @CFToVal( falseLabel )
5724:          @PromoteToIntOptional
5726:          @MatchTypes
5728:          [ oTypeSNodeType
5730:             | nBooleanType, nCharType :     .tGreaterEqualB
5733:             | nIntegerType, nEnumType :     .tGreaterEqualI
5737:             | nPointerType, nUniversalPointerType :   .tGreaterEqualP
5741:             | nShortStringType, nStrLitType :            #eNotImplemented
5745:             | * :                           #eNotAllowed
5766:          ]
5766:          oTypeSPop
5767:          oTypeSPush( BooleanType )
      
5773:       | * :
5788:          >
5790:    ]};
      
      
5793: BoolExprAllowCF( out Label falseLabel ):
5795:    Label trueLabel = labelNull
      
5801:    @BoolTermAllowCF( falseLabel )
5808:    {[
5808:       | pOr :
5810:          [ oTypeSNodeType
5812:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5813:                [ equal_label( trueLabel, labelNull )
5823:                   | true :  trueLabel = oLabelNew
5829:                   | * :
5834:                ]
5834:                .tJump  oEmitLabel( trueLabel )
5842:             | nBooleanType :
5844:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5851:                [ equal_label( trueLabel, labelNull )
5861:                   | true :  trueLabel = oLabelNew
5867:                   | * :
5872:                ]
5872:                .tJump  oEmitLabel( trueLabel )
5880:             | * : #eNotBoolean
5889:          ]
5889:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5890:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5898:          falseLabel = labelNull
5904:          @BoolTermAllowCF( falseLabel )
      
5911:          [ oTypeSNodeType
5913:             | nBooleanCFType :
5914:             | nBooleanType :
5916:                @ValToCF( falseLabel )
5923:             | * : #eNotBoolean
5932:          ]
      
5932:          oTypeSPop
5933:          oTypeSPush( BooleanCFType )
      
5939:       | * :
5944:          >
5946:    ]}
      
         % any short-circuit trues jump here to the end
5948:    [ equal_label( trueLabel, labelNull )
5958:       | false :
5959:          .tLabel  oEmitLabel( trueLabel )
5967:       | * :
5972:    ]
5973:    ;
      
      
5973: BoolTermAllowCF( out Label falseLabel ):
5975:    Label overallFalseLabel = labelNull
      
5981:    @BoolFactorAllowCF( falseLabel )
5988:    {[
5988:       | pAnd :
5990:          [ oTypeSNodeType
5992:             | nBooleanCFType :
5993:             | nBooleanType :
5995:                @ValToCF( falseLabel )
6002:             | * :
6009:                #eNotBoolean
6011:          ]
6011:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
6012:          [ equal_label( overallFalseLabel, labelNull )
6022:             | true :
6023:                overallFalseLabel = oLabelNew
6028:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
6042:                falseLabel = overallFalseLabel
6048:             | * :
6053:          ]
      
6053:          Label factorFalseLabel = labelNull
6059:          @BoolFactorAllowCF( factorFalseLabel )
      
6066:          [ oTypeSNodeType
6068:             | nBooleanCFType :
6069:             | nBooleanType :
6071:                @ValToCF( factorFalseLabel )
6078:             | * : #eNotBoolean
6087:          ]
6087:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
6101:       | * :
6106:          >
6108:    ]};
      
6111: BoolFactorAllowCF( out Label falseLabel ):
6113:    [
6113:       | pNot :
6115:          Label factorFalseLabel = labelNull
      
6121:          @BoolFactorAllowCF( factorFalseLabel )
6128:          [ oTypeSNodeType
6130:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
6131:                falseLabel = oLabelNew
6136:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
6144:                .tLabel  oEmitLabel( factorFalseLabel )
      
6152:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
6154:                .tNot
      
6156:             | * : #eNotBoolean
6165:          ]
      
6165:       | * :
6170:          @ArithExprAllowCF( falseLabel )
6177:    ];
      
6178: ArithExprAllowCF( out Label falseLabel ):
6180:    boolean first = true
6186:    int tempStrOffset
      
6186:    @TermAllowCF( falseLabel )
6193:    {[
6193:       | '+' :
6195:          [ oTypeSNodeType
6197:             | nIntegerType, nByteType :
6198:                @PromoteToIntPop
6200:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
      
6207:                [ oTypeSNodeType
6209:                   | nPointerType, nUniversalPointerType :
                           % int + ptr
6210:                      .tSwap
                           % leave only the ptr type on the type stack (int was already popped above)
6212:                      @PointerAddition
6214:                   | * :
6221:                      @PromoteToInt
6223:                      .tAddI
6225:                ]
      
6225:             | nShortStringType, nStrLitType, nCharType :
                     % String concatenation
6227:                [ first
6230:                   | true :  % move into a temp string, so subsequent term(s) can further modify it.
6231:                             tempStrOffset = @MoveIntoTempShortString
6237:                             first = false
6243:                   | * :
6248:                ]
6248:                @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6255:                [ oTypeSNodeType
6257:                   | nShortStringType, nStrLitType :
6258:                      @ShortStringAppendShortString
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6260:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6268:                      oTypeSPush( ShortStringType )
6274:                   | nCharType :
6276:                      @ShortStringAppendChar
                           % Have to re-push the temp string.
                           % If we ever have .tDup then the append method could do it and we wouldn't need this
6278:                      .tPushAddrLocal  oEmitInt( tempStrOffset )
6286:                      oTypeSPush( ShortStringType )
6292:                   | * :
6301:                      #eTypeMismatch
6303:                      oTypeSPop
6304:                ]
      
6304:             | nPointerType, nUniversalPointerType :
6306:                @TermAllowCF( falseLabel )   % actually not allowing CF
6313:                @PromoteToIntPop
6315:                @PointerAddition
      
6317:             | * :
6334:                #eNotAllowed
6336:          ]
      
6336:       | '-' :
6338:          [ oTypeSNodeType
6340:             | nIntegerType, nByteType :
6341:                @PromoteToIntPop
6343:                @TermAllowCF( falseLabel )
6350:                @PromoteToInt
6352:                .tSubI
      
6354:             | nPointerType, nUniversalPointerType :
6356:                @TermAllowCF( falseLabel )
6363:                [ oTypeSNodeType
6365:                   | nIntegerType, nByteType :
6366:                      @PromoteToIntPop
6368:                      @PointerSubInt
6370:                   | nPointerType, nUniversalPointerType :
6372:                      @MatchTypes
6374:                      @PointerSubPointer
6376:                   | * :
6387:                      #eNotAllowed
6389:                ]
      
6389:             | * :  #eNotAllowed
      
6402:          ]
6402:       | * :
6409:          >
6411:    ]};
      
6414: TermAllowCF( out Label falseLabel ):
6416:    @FactorAllowCF( falseLabel )
6423:    {[
6423:       | pTimes :
6425:          @PromoteToIntPop
6427:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
6434:          @PromoteToInt
6436:          .tMultI
6438:       | pDivide :
6440:          @PromoteToIntPop
6442:          @FactorAllowCF( falseLabel )
6449:          @PromoteToInt
6451:          .tDivI
6453:       | * :
6460:          >
6462:    ]};
      
6465: FactorAllowCF( out Label falseLabel ):
6467:    [
6467:       | pPlus :
6469:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
6476:          @PromoteToInt
6478:       | pMinus :
6480:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
6487:          @PromoteToInt
6489:          .tNegI
6491:       | * :
6498:          @PrimaryAllowCF( falseLabel )
6505:    ];
      
6506: PrimaryAllowCF( out Label falseLabel ):
6508:    [
6508:       | pIntLit :
6510:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6517:          oTypeSPush( IntegerType )
      
6523:       | pCharLit :
6525:          .tPushConstI  oEmitInt( TOKEN_VALUE )
6532:          oTypeSPush( CharType )
      
6538:       | '(' :
6540:          @ExprAllowCF( falseLabel )
6547:          ')'
      
6549:       | pStrLit :
6551:          int addr = oStringAllocShortStringLit( CURRENT_STRLIT )     % store in global data
6560:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: consider defining a ShortString type with the exact capacity used.
               % But, I don't think it should matter here, since nobody should be assigning to this string.
6568:          oTypeSPush( StrLitType )
               % This seems unlikely, but the strlit may be followed by
               % array indexing.  Handle this the same way we would with a variable expression (see VarExpr)
               % First, advance the pointer by index if any
6574:          @LValueIndexes
               % get final value of dereferencing, if any
6576:          @FetchVar
      
6578:       | pIdent :
6580:          Node decl = oScopeFindRequire
6585:          @ResolveUnitRef( decl )
6592:          Node theType
      
6592:          [ oNodeType( decl )
6599:             | nFunc :
6600:                @Call( decl )
      
6607:             | nBuiltInFunc :
6609:                @CallBuiltInFunc( decl )
      
6616:             | nConst, nEnumValue :
6618:                theType = oNodeGet( decl, qType )
6631:                oTypeSPush( theType )
6637:                [ oTypeSNodeType
6639:                   | nIntegerType, nEnumType, nBooleanType :
6640:                      .tPushConstI @EmitValue( decl )
6649:                   | nPointerType, nUniversalPointerType :
                           % We have one pointer const, Nil.  It's pushed as I.
6651:                      .tPushConstI @EmitValue( decl )
6660:                   | * :
6673:                      #eNotImplemented
6675:                ]
      
6675:             | nGlobalVar, nLocalVar, nParam, nTypedConst :
6677:                @VarExpr( decl )
      
6684:             | * :
6703:                #eNotValue
6705:                oTypeSPush( IntegerType )
6711:          ]
      
6711:       | '@' :        % @var -- pointer to var
6713:          pIdent
      
6715:          Node decl = oScopeFindRequire
6720:          @ResolveUnitRef( decl )
6727:          Node theType
      
               % writeable is false because we're not on the left hand side of an assignment,
               % or passign into a var parameter.  So it's ok to take the address of a typed const.
6727:          @LValueVar( decl, false )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
6737:          theType = oTypeSTop
6742:          oTypeSPop
6743:          Node ptrType = @PointerTypeTo( theType )
6754:          oTypeSPush( ptrType )
      
6760:       | * :
6775:          #eNotValue
6777:          oTypeSPush( IntegerType )
6783:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
6784: VarExpr( Node decl ):
6786:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
6799:    int uplevels = @DeclUpLevels( decl )
      
6810:    oTypeSPush( theType )
6816:    [ oTypeSNodeType
6818:       | nIntegerType, nEnumType :
6819:          [ oNodeType( decl )
6826:             | nGlobalVar, nTypedConst :   .tPushGlobalI  @EmitValue( decl )
6836:             | nLocalVar :
6838:                [ equal_zero( uplevels )
6845:                   | true :  .tPushLocalI  @EmitValue( decl )
6855:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
6875:                ]
6875:             | nParam :
6877:                [ oNodeGetBoolean( decl, qInOut )
6887:                   | true :    % VAR param points to the var.  Auto dereference.
6888:                      [ equal_zero( uplevels )
6895:                         | true :  .tPushParamP  @EmitValue( decl )
6905:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6925:                      ]
6925:                      .tFetchI
6927:                   | * :
6932:                      [ equal_zero( uplevels )
6939:                         | true :  .tPushParamI  @EmitValue( decl )
6949:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6969:                      ]
6969:                ]
6969:          ]
      
6981:       | nBooleanType, nByteType, nCharType :
6983:          [ oNodeType( decl )
6990:             | nGlobalVar, nTypedConst :   .tPushGlobalB  @EmitValue( decl )
7000:             | nLocalVar :
7002:                [ equal_zero( uplevels )
7009:                   | true :  .tPushLocalB  @EmitValue( decl )
7019:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
7039:                ]
7039:             | nParam :
7041:                [ oNodeGetBoolean( decl, qInOut )
7051:                   | true :    % VAR param points to the var.  Auto dereference.
7052:                      [ equal_zero( uplevels )
7059:                         | true :  .tPushParamP  @EmitValue( decl )
7069:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7089:                      ]
7089:                      .tFetchB
7091:                   | * :
7096:                      [ equal_zero( uplevels )
7103:                         | true :  .tPushParamB  @EmitValue( decl )
7113:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
7133:                      ]
7133:                ]
7133:          ]
      
7145:       | nFileType :
7147:          #eNotImplemented
      
7149:       | nPointerType, nUniversalPointerType :
7151:          [ oNodeType( decl )
7158:             | nGlobalVar, nTypedConst :   .tPushGlobalP @EmitValue( decl )
7168:             | nLocalVar :
7170:                [ equal_zero( uplevels )
7177:                   | true :  .tPushLocalP  @EmitValue( decl )
7187:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
7207:                ]
7207:             | nParam :
7209:                [ oNodeGetBoolean( decl, qInOut )
7219:                   | true :    % VAR param points to the var.  Auto dereference.
7220:                      [ equal_zero( uplevels )
7227:                         | true :  .tPushParamP  @EmitValue( decl )
7237:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7257:                      ]
7257:                      .tFetchP
7259:                   | * :
7264:                      [ equal_zero( uplevels )
7271:                         | true :  .tPushParamP  @EmitValue( decl )
7281:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7301:                      ]
7301:                ]               
7301:          ]
7313:          [
7313:             | '^' :             % dereferenced
7315:                oTypeSPop
7316:                oTypeSPush( oNodeGet( theType, qBaseType ) )
7329:                @LValueIndexes
7331:                @FetchVar
7333:             | '[' :             % dereferencing pointer like an array [0..] of baseType
7335:                @PointerArraySubscript
                     % modify addr for any subsequent subscripts, field references, etc
7337:                @LValueIndexes
7339:                @FetchVar
7341:             | * :               % just ptr value alone
7348:          ]
      
7348:       | nArrayType, nRecordType, nShortStringType :
               % compound type
               % first, push addr of start of var
7350:          [ oNodeType( decl )
7357:             | nGlobalVar, nTypedConst :   .tPushAddrGlobal @EmitValue( decl )
7367:             | nLocalVar :
7369:                [ equal_zero( uplevels )
7376:                   | true :  .tPushAddrLocal  @EmitValue( decl )
7386:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
7406:                ]
7406:             | nParam :
7408:                [ oNodeGetBoolean( decl, qInOut )
7418:                   | true :    % VAR param points to the var.  Auto dereference.
7419:                      [ equal_zero( uplevels )
7426:                         | true :  .tPushParamP  @EmitValue( decl )
7436:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
7456:                      ]
7456:                   | * :
7461:                      [ equal_zero( uplevels )
7468:                         | true :  .tPushAddrParam  @EmitValue( decl )
7478:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
7498:                      ]
7498:                ]
7498:          ]
               % modify addr for subscripts, field references, etc
7510:          @LValueIndexes
               % get final value
7512:          @FetchVar
7514:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
7541: FetchVar:
7543:    [ oTypeSNodeType
7545:       | nIntegerType, nEnumType :  .tFetchI
7548:       | nBooleanType, nByteType, nCharType :  .tFetchB
7552:       | nFileType :   #eNotImplemented
7556:       | nPointerType :             .tFetchP
7560:       | nUniversalPointerType :    #eCantDereference
7564:       | nArrayType, nRecordType, nStrLitType, nShortStringType :  % compound type; leave as addr
7566:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
7595: LValueIndexes:
7597:    {[
7597:       | '[' :
7599:          [ oTypeSNodeType
7601:             | nArrayType :    @ArraySubscripts
7604:             | nPointerType :  @PointerArraySubscript
7608:             | nStrLitType, nShortStringType :  @ShortStringArraySubscript
7612:             | * :             #eNotArray
7625:          ]
7625:       | '.' :       @RecordFieldRef
7629:       | '^' :       @PointerDeref   % TO DO: I suspect I don't have logic right here
                                          % about precondition and using .tFetchP
                                          % Ideally this should take over for the ^ in VarExpr too.
7633:       | * :         >
7644:    ]};
      
7647: ArraySubscripts:
7649:    [ oTypeSNodeType
7651:       | nArrayType :
7652:       | * :       #eNotArray
7659:    ]
7659:    {
7659:       [ oTypeSNodeType
7661:          | nArrayType :
7662:          | * :    #eTooManySubscripts
7669:       ]
      
            % low subscript of this dimension
7669:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
7686:       Node baseType
7686:       baseType = oNodeGet( oTypeSTop, qBaseType )
7698:       oTypeSPop
7699:       oTypeSPush( baseType )
      
7705:       @Expr
7707:       @RequireIntPop
            % adjust for low subscript
7709:       [ equal_zero( low )
7716:          | false :
7717:             .tPushConstI oEmitInt( low ) .tSubI
7727:          | * :
7732:       ]
      
            % multiply by element size
7732:       int size = oNodeGetInt( baseType, qSize )
7745:       [ equal( size, 1 )
7755:          | false :
7756:             .tPushConstI oEmitInt( size ) .tMultI
7766:          | * :
7771:       ]
      
            % update start address
7771:       .tAddPI
7773:       [
7773:          | ']' :  >
7777:          | ',' :
7779:       ]
7787:    };
      
      
      % pointer[index] - similar to array[index] where index counts from 0.
      % On entry, the pointer value is on the stack, and pointer type is on the type stack.
      % We've already accepted the '['.
      % On exit, the address of the pointed-to element is on the stack,
      % and the element type is on the type stack.
      %
7790: PointerArraySubscript:
7792:    [ oTypeSNodeType
7794:       | nPointerType :
7795:       | * :    #eCantDereference
7802:    ]
         % replace type stack with base type
7802:    Node baseType = oNodeGet( oTypeSTop, qBaseType )
7814:    oTypeSPop
7815:    oTypeSPush( baseType )
         
7821:    @Expr
7823:    @RequireIntPop
         % multiply by element size
7825:    int size = oNodeGetInt( baseType, qSize )
7838:    [ equal( size, 1 )
7848:       | false :
7849:          .tPushConstI  oEmitInt( size )  .tMultI
7859:       | * :
7864:    ]
         % update start address
7864:    .tAddPI
7866:    ']';
      
      
      % Specialization of array indexing for ShortString.
      % We treat the starting index as 0 so that str[1] sees the first string char,
      % past the length byte.
      %
7869: ShortStringArraySubscript:
7871:    [ oTypeSNodeType
7873:       | nStrLitType, nShortStringType :
7874:       | * :    #eCantDereference
7883:    ]
7883:    oTypeSPop
7884:    oTypeSPush( CharType )
7890:    @Expr
7892:    @RequireIntPop
7894:    .tAddPI
7896:    ']';
      
      
7899: RecordFieldRef:
7901:    [ oTypeSNodeType
7903:       | nRecordType :
7904:       | * :    #eNotRecord
7911:    ]
7911:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
7923:    pIdent
7925:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
7930:    [ oNodeType( field )
7937:       | nRecordField :
7938:       | * :   #eNotRecordField
7945:    ]
7945:    oScopeEnd
7946:    int offset = oNodeGetInt( field, qValue )
7959:    [ equal_zero( offset )
7966:       | false :
7967:          .tPushConstI oEmitInt( offset ) .tAddPI
7977:       | * :
7982:    ]
      
         % replace the type on the type stack, with the field type
7982:    oTypeSPop
7983:    oTypeSPush( oNodeGet( field, qType ) )
7997:    ;
      
      
      % On entry, expr stack has ptr, and integer index above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr advanced to that index
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
7997: PointerAddition:
7999:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8011:    int elementSize = oNodeGetInt( elementType, qSize )
8024:    [ equal( elementSize, 1 )
8034:       | false :
8035:          .tPushConstI  oEmitInt( elementSize )
8043:          .tMultI
8045:       | * :
8050:    ]
8050:    .tAddPI
8053:    ;
      
      
      % On entry, expr stack has ptr, and integer above it.
      % The type stack has just the pointer type.
      % Pop those, and push the ptr decremented by that integer
      % (scaled by the pointed-to element size).
      % Leaves the pointer type on the type stack.
      %
8053: PointerSubInt:
8055:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8067:    int elementSize = oNodeGetInt( elementType, qSize )
8080:    [ equal( elementSize, 1 )
8090:       | false :
8091:          .tPushConstI  oEmitInt( elementSize )
8099:          .tMultI
8101:       | * :
8106:    ]
8106:    .tSubPI
8109:    ;
      
      
      % On entry, expr stack has two pointers, P1 and P2 above it.
      % The type stack has the type of P1.  (The type of P2 was already matched to P1.)
      % Replace the pointers on the expression stack with P1 - P2, scaled by the
      % pointed-to element size.  Type stack switched to integer.
      % 
8109: PointerSubPointer:
8111:    .tSubP
8113:    Node elementType = oNodeGet( oTypeSTop, qBaseType )
8125:    int elementSize = oNodeGetInt( elementType, qSize )
8138:    [ equal( elementSize, 1 )
8148:       | false :
8149:          .tPushConstI  oEmitInt( elementSize )
8157:          .tDivI
8159:       | * :
8164:    ]
8164:    oTypeSPop
8165:    oTypeSPush( IntegerType )
8172:    ;
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
8172: PointerDeref:
8174:    [ oTypeSNodeType
8176:       | nPointerType :
8177:       | nUniversalPointerType :   #eCantDereference
8181:       | * :       #eNotPointer
8190:    ]
8190:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
8192:    Node theType = oTypeSTop
8197:    oTypeSPop
8198:    oTypeSPush( oNodeGet( theType, qBaseType ) )
8212:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
8212: CoerceType:
8214:    node_type nt = oTypeSNodeType
8219:    oTypeSPop
8220:    [ equal_node_type( nt, oTypeSNodeType )
8229:       | false :
               % Can we implicitly convert the value to the desired type?
8230:          [ oTypeSNodeType
8232:             | nIntegerType :
8233:                [ nt
8236:                   | nByteType :   .tCastBtoI  >>
8240:                   | * :
8245:                ]
8245:             | nByteType :
8247:                [ nt
8250:                   | nIntegerType :   .tCastItoB  >>
8254:                   | * :
8259:                ]
8259:             | nPointerType :
8261:                [ nt
8264:                   | nUniversalPointerType :  >>
8266:                   | nStrLitType :
8268:                      [ equal_node( oTypeSTop, PCharType )
8277:                         | true :
                                 % PChar := 'strlit' i.e. point at strlit[1]
8278:                            .tPushConstI  oEmitInt(1)  .tAddPI  >>
8289:                         | * :
8294:                      ]
8294:                   | * :
8301:                ]
8301:             | nUniversalPointerType :
8303:                [ nt
8306:                   | nPointerType :  >>
8308:                   | * :
8313:                ]
8313:             | nShortStringType :
8315:                [ nt
8318:                   | nStrLitType :  >>
8320:                   | * :
8325:                ]
8325:             | * :
8338:          ]
8338:          #eTypeMismatch
8340:       | * :
8345:    ];
      
      
      % Given a ShortString, StrLit, or Char on the expression stack
      % (and type on the type stack).  Move the value into a new temporary ShortString.
      % Leave that temp string and type on the stacks.
      % Also returns the offset of the temp string.
      %
8346: MoveIntoTempShortString >> int:
8348:    int tempOffset = oScopeAllocType( ShortStringType )
         % copy the value
8358:    [ oTypeSNodeType
8360:       | nShortStringType, nStrLitType :
8361:          .tPushAddrLocal  oEmitInt( tempOffset )
               % put temp addr under value addr
8369:          .tSwap
               % TO DO: we could just copy length + 1, but tCopy takes a fixed #bytes
8371:          .tCopy  oEmitInt( oNodeGetInt( ShortStringType, qSize ) )
8386:       | nCharType :
               % temp[0] = 1
8388:          .tPushAddrLocal  oEmitInt( tempOffset )
8396:          .tPushConstI  oEmitInt( 1 )
8404:          .tAssignB
               % temp[1] = value
8406:          .tPushAddrLocal  oEmitInt( add( tempOffset, 1 ) )
8421:          .tSwap
8423:          .tAssignB
8425:       | * :   #eTypeMismatch
8436:    ]
8436:    oTypeSPop
         % Leave the temp ShortString on the expr stack and type stack
8437:    .tPushAddrLocal  oEmitInt( tempOffset )
8445:    oTypeSPush( ShortStringType )
8451:    >> tempOffset;
      
      
      % Top of expr stack / type stack is ShortString B.
      % Under it is ShortString A.
      % Change A to append the contents of B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8455: ShortStringAppendShortString:
         % TO DO: ideally I would do this directly with tcode.  But I think I need some more
         % enhancements for that to work well.   Meanwhile, generate a call to a method.
         % For the moment, I'll implement the method in Pascal, in the mysystem unit.
8457:    .tAllocActuals  oEmitInt( 16 )
8465:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignP
8477:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8489:    .tCall   @EmitValue( System_ShortStringAppendShortString )
         % TO DO: Ideally I would leave A on the expr stack / type stack.
         %  But I can't really do that without dup, which I hesitate to add.
         %  I'll have the caller push A again themselves.
8498:    .tFreeActuals  oEmitInt( 16 )
8506:    oTypeSPop
8507:    oTypeSPop
8509:    ;
      
      % Top of expr stack / type stack is Char B.
      % Under it is ShortString A.
      % Change A to append char B to it (truncating if necessary).
      % Removes both A and B from the expr stack / type stack.
      %
8509: ShortStringAppendChar:
         % Note at the moment I don't align params
8511:    .tAllocActuals  oEmitInt( 12 )
8519:    .tPushAddrActual  oEmitInt( 8 )  .tSwap  .tAssignI
8531:    .tPushAddrActual  oEmitInt( 0 )  .tSwap  .tAssignP
8543:    .tCall  @EmitValue( System_ShortStringAppendChar )
8552:    .tFreeActuals  oEmitInt( 12 )
8560:    oTypeSPop
8561:    oTypeSPop
8563:    ;
      
      
      % Called on first use of an extern method
      %
8563: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
8565:    int strAddr
8565:    String externalName = oNodeGetString( method, qExternalName )
8578:    [ equal_string( externalName, stringNull )
8588:       | true :
8589:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
8610:       | false :
8612:          strAddr = oStringAllocLit( externalName )
8622:    ]
8630:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
8646:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
8646: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
8648:    [ oNodeGetBoolean( method, qExternal )
8658:       | true :
8659:          [ oNodeGetBoolean( method, qUsed )
8669:             | false :
                     % define the extern label on first use
8670:                @DefineExternLabel( method )
8677:             | * :
8682:          ]
8682:      | * :
8687:    ]
8687:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
8699:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
8712:    Node resultType
8712:    int tempOffset
      
8712:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
8729:    [ isFunc
8732:       | true :
8733:          resultType = oNodeGet( method, qType )
8746:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
8756:       | * :
8761:    ]
         
      
8761:    Node paramScope = oNodeGet( method, qParams )
8774:    int actualsSize = oNodeGetInt( paramScope, qSize )
8787:    [ cdecl
8790:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
8799:       | false :  .tAllocActuals  oEmitInt( actualsSize )
8809:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
8817:    [ greater( @DeclLevel( method ), 0 )
8832:       | true :
8833:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
8841:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
8860:          .tAssignP
8862:       | * :
8867:    ]
      
      
8867:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
8880:    Node param = oNodeIterValue( paramIter )
8890:    [
8890:       | '(' :
            
8892:          {
8892:             [ oNodeNull( param )
8899:                | true : >
8902:                | * :
8907:             ]
      
8907:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
8920:             .tPushAddrActual oEmitInt( offset )
8928:             oTypeSPush( oNodeGet( param, qType ) )
      
8941:             [ oNodeGetBoolean( param, qInOut )
8951:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
8952:                           @LValueExpr( true )
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
8959:                           @MatchTypes
      
8961:                           .tAssignP
      
8963:                | false :  @Expr
8967:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
8969:                           [ oTypeSNodeType
8971:                              | nIntegerType, nEnumType : .tAssignI
8974:                              | nBooleanType, nByteType, nCharType :  .tAssignB
8978:                              | nFileType :   #eNotImplemented
8982:                              | nPointerType, nUniversalPointerType :  .tAssignP
8986:                              | nArrayType, nRecordType, nShortStringType :
                                       % compound types: copy value into actuals space
8988:                                  int size = oNodeGetInt( oTypeSTop, qSize )
9000:                                  .tCopy  oEmitInt( size )    % multi-word copy
9008:                           ]
9034:             ]
9042:             oTypeSPop
      
9043:             oNodeIterNext( paramIter )
9049:             param = oNodeIterValue( paramIter )
9059:             [ oNodeNull( param )
9066:                | true :  >
9069:                | false :
9071:             ]
      
9079:             ','
9081:          }
      
9083:          ')'
      
9085:       | * :
9090:    ]
      
9090:    [ oNodeNull( param )
9097:       | false :    #eMissingParameter
9100:       | * :
9105:    ]
      
9105:    [ isFunc
9108:       | true :
               % Pass result temp as an additional VAR parameter.
9109:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
9124:          .tPushAddrLocal  oEmitInt( tempOffset )
9132:          .tAssignP
9134:       | * :
9139:    ]
      
9139:    [ cdecl
9142:       | true :
9143:          .tCallCdecl  @EmitValue( method )
9152:       | false :
9154:          .tCall   @EmitValue( method )
9163:    ]
      
9171:    [ isFunc
9174:       | true :
               % push return value from temp
9175:          oTypeSPush( resultType )
      
9181:          [ oTypeSNodeType
9183:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
9192:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
9202:             | nFileType :  #eNotImplemented
9206:             | nPointerType, nUniversalPointerType :   .tPushLocalP  oEmitInt( tempOffset )
9216:             | nArrayType, nRecordType, nShortStringType :   % compound type: push address
9218:                                .tPushAddrLocal  oEmitInt( tempOffset )
9226:          ]
9252:       | * :
9257:    ]
         
9257:    .tFreeActuals  oEmitInt( actualsSize )
9266:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
9266: CallBuiltInFunc( Node method ):
      
         % Ord(x)
9268:    [ oNodeEqual( method, BuiltIn_Ord )
9278:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
9279:          '('
9281:          @Expr
9283:          [ oTypeSNodeType
9285:             | nIntegerType, nEnumType :
9286:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
9290:             | * :  #eTypeMismatch
9305:          ]
9305:          oTypeSPop
9306:          oTypeSPush( IntegerType )
9312:          ')'
9314:          >>
9315:       | * :
9320:    ]
      
         % Chr(x)
9320:    [ oNodeEqual( method, BuiltIn_Chr )
9330:       | true :
               % parameter is integer
               % result is char
9331:          '('
9333:          @Expr
9335:          [ oTypeSNodeType
9337:             | nIntegerType :    .tCastItoB
9340:             | nByteType :
9342:             | * :  #eTypeMismatch
9351:          ]
9351:          oTypeSPop
9352:          oTypeSPush( CharType )
9358:          ')'
9360:          >>
9361:       | * :
9366:    ]
      
         % Pred(x)
9366:    [ oNodeEqual( method, BuiltIn_Pred )
9376:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9377:          '('
9379:          @Expr
9381:          [ oTypeSNodeType
9383:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9384:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9393:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9396:                   | * :
9401:                ]
9401:             | * :  #eTypeMismatch
9408:          ]
9408:          .tDecI
9410:          ')'
9412:          >>
9413:       | * :
9418:    ]
      
         % Succ(x)
9418:    [ oNodeEqual( method, BuiltIn_Succ )
9428:       | true :
               % parameter is any enum type, as long as it has values 0..N-1
               % result is the same enum type
9429:          '('
9431:          @Expr
9433:          [ oTypeSNodeType
9435:             | nEnumType :
                     % TO DO: does this skip past type aliases?
                     % TO DO: what if using pred/succ on a subrange type?
9436:                [ oNodeGetBoolean( oTypeSTop, qHasGap )
9445:                   | true :   #eCantUsePredSuccOnEnumWithValueGaps
9448:                   | * :
9453:                ]
9453:             | * :  #eTypeMismatch
9460:          ]
9460:          .tIncI
9462:          ')'
9464:          >>
9465:       | * :
9470:    ]
      
9470:    #eNotImplemented
9473:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
9473: Statement:
9475:    [
9475:       | pWriteln :     @WritelnStmt
9479:       | pWrite :       @WriteStmt
9483:       | pReadln :      @ReadlnStmt
9487:       | pRead :        @ReadStmt
9491:       | pIf :          @IfStmt
9495:       | pWhile :       @WhileStmt
9499:       | pFor :         @ForStmt
9503:       | pRepeat :      @RepeatStmt
9507:       | pBreak :       @BreakStmt
9511:       | pContinue :    @ContinueStmt
9515:       | pBegin :       @BeginStmt
9519:       | pIdent :       @LabelOrAssignOrCallStmt
9523:       | pGoto :        @GotoStmt
9527:       | pIntLit :      % should be an integer label
9529:                        oChangeIntLitToLabelIdent
9530:                        @LabelOrAssignOrCallStmt
9532:       | * :            % null statement : don't accept any tokens
9563:    ];
      
      
9564: LabelOrAssignOrCallStmt:
9566:    Node decl = oScopeFindRequire
9571:    @ResolveUnitRef( decl )
9578:    [ oNodeType( decl )
9585:       | nLabel :                          @LabelDefinition( decl )
9593:                                           @Statement
9595:       | nProc :                           @Call( decl )
9604:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
9613:       | nFunc :                           @AssignResultStmt( decl )
9622:       | * :                               #eBadStatement
9639:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
9640: LabelDefinition( Node decl ):
9642:    [ oNodeGetBoolean( decl, qDefined )
9652:       | true :  #eAlreadyDefined
9655:       | * :
9660:    ]
9660:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
9675:    oNodeSetBoolean( decl, qDefined, true )
9687:    ':'
9690:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
9690: AssignStmt( Node decl ):
      
9692:    @LValueVar( decl, true )
9702:    ':=' 
9704:    @Expr
9706:    @CoerceType
9708:    @Assign
9711:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack (already coerced to the lvalue type),
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
9711: Assign:
9713:    [ oTypeSNodeType
9715:       | nIntegerType, nEnumType :  .tAssignI
9718:       | nBooleanType, nByteType, nCharType :  .tAssignB
9722:       | nFileType :   #eNotImplemented
9726:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9730:       | nArrayType, nRecordType, nShortStringType :
                % TO DO: for ShortString, allow destination to be smaller capacity,
                % and truncate the copied value/length.
9732:           int size = oNodeGetInt( oTypeSTop, qSize )
9744:           .tCopy  oEmitInt( size )    % multi-word copy
9752:    ]
9778:    oTypeSPop
9780:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
9780: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
9782:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
9798:       | false :   #eNotCurrentFunction
9801:       | * :
9806:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
9806:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
9821:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
9834:    ':='
9836:    @Expr
9838:    @CoerceType
9840:    [ oTypeSNodeType
9842:       | nIntegerType, nEnumType : .tAssignI
9845:       | nBooleanType, nByteType, nCharType :  .tAssignB
9849:       | nFileType :   #eNotImplemented
9853:       | nPointerType, nUniversalPointerType :  .tAssignP
            % compound var assigns; addrs of src, dest on stack
9857:       | nArrayType, nRecordType, nShortStringType :
9859:           int size = oNodeGetInt( oTypeSTop, qSize )
9871:           .tCopy  oEmitInt( size )    % multi-word copy
9879:    ]
9905:    oTypeSPop
9907:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      % If writeable is false, the expression won't be written to, so may access a
      % typed const.
      %
9907: LValueExpr( boolean writeable ):
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
9909:    pIdent
9911:    Node decl = oScopeFindRequire
9916:    @ResolveUnitRef( decl )
9923:    [ oNodeType( decl )
9930:       | nGlobalVar, nLocalVar, nParam, nTypedConst :
9931:       | * :  #eNotVar
9944:    ]
9944:    @LValueVar( decl, writeable )
9955:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
9955: LValueVar( Node decl, boolean writeable ):
9957:    [ oNodeType( decl )
9964:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
9974:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
9985:       | nParam :
9987:          [ oNodeGetBoolean( decl, qInOut )
9997:             | true :   % VAR param points to variable.  No dereference.
9998:                        .tPushParamP @EmitValue( decl )
10007:             | * :      .tPushAddrParam @EmitValue( decl )
10021:          ]
10021:       | nTypedConst :
10023:          [ writeable
10026:             | false :  .tPushAddrGlobal @EmitValue( decl )                       
10036:             | * :      #eNotVar
10043:          ]
10043:       | * :            #eNotVar
10056:    ]
      
10056:    oTypeSPush( oNodeGet( decl, qType ) )
      
         % handle subscripts, if any.
         % There is one case that I'm not fitting into the pattern nicely, so need to
         % check for specially here:  if lvalue var is a pointer variable, and is
         % followed by [index], we need to dereference the pointer variable before applying
         % the index.  This is different from handling of [index] on an rvalue expression.
         % Right now I have LValueIndexes working for both lvalue and rvalue (composite types)
         % so can't easily add this behavior in there.
         % TO DO: probably I need separate rules LValueIndexes and RValueIndexes.
         %    This might also explain my confusion about handling of deref operator in LValueIndexes vs rvalue expr,
         %    and having separate rules might clear that up better.
      
10069:    [ oTypeSNodeType
10071:       | nPointerType :
10072:          [
10072:             | '[' :
                     % dereference the pointer var first
10074:                .tFetchP
10076:                @PointerArraySubscript
10078:             | * :
10083:          ]
10083:       | * :
10088:    ]
         % additional subscripts, if any
10088:    @LValueIndexes
10091:    ;
      
      
10091: IncVar( Node decl ):
10093:    @LValueVar( decl, true )
10103:    @RequireIntPop
10105:    @VarExpr( decl )
10112:    oTypeSPop
10113:    .tIncI
10115:    .tAssignI;
      
10118: DecVar( Node decl ):
10120:    @LValueVar( decl, true )
10130:    @RequireIntPop
10132:    @VarExpr( decl )
10139:    oTypeSPop
10140:    .tDecI
10142:    .tAssignI;
      
      
10145: IfStmt:
10147:    Label falseLabel = labelNull
      
10153:    @BooleanExprControlFlow( falseLabel )
10160:    pThen
10162:    @Statement
10164:    [
10164:       | pElse :
10166:          Label doneLabel = oLabelNew
      
10171:          .tJump  oEmitLabel( doneLabel )
10179:          .tLabel oEmitLabel( falseLabel )
10187:          @Statement
10189:          .tLabel oEmitLabel( doneLabel )
      
10197:       | * :
10202:          .tLabel oEmitLabel( falseLabel )
10210:    ];
      
      
10211: ForStmt:
10213:    pIdent
      
10215:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
10220:    @LValueVar( decl, true )
10230:    @RequireIntPop
      
10232:    ':='
      
10234:    @Expr
10236:    @RequireIntPop
10238:    .tAssignI
      
10240:    Label breakLabel = oLabelNew
      
10245:    Label checkLabel = oLabelNew
10250:    .tJump  oEmitLabel( checkLabel )
      
10258:    Label continueLabel = oLabelNew
10263:    .tLabel  oEmitLabel( continueLabel )
10271:    [
10271:       | pTo :
10273:          @IncVar( decl )
10280:          .tLabel  oEmitLabel( checkLabel )
10288:          @VarExpr( decl )  oTypeSPop
10296:          @Expr
10298:          @RequireIntPop
10300:          .tGreaterI
10302:          .tJumpTrue  oEmitLabel( breakLabel )
10310:       | pDownto :
10312:          @DecVar( decl )
10319:          .tLabel  oEmitLabel( checkLabel )
10327:          @VarExpr( decl )  oTypeSPop
10335:          @Expr
10337:          @RequireIntPop
10339:          .tLessI
10341:          .tJumpTrue  oEmitLabel( breakLabel )
10349:    ]
10357:    oLoopPush( continueLabel, breakLabel )
10366:    pDo
10368:    @Statement
10370:    .tJump  oEmitLabel( continueLabel )
10378:    .tLabel  oEmitLabel( breakLabel )
10386:    oLoopPop;
      
      
10388: RepeatStmt:
10390:    Label continueLabel = oLabelNew
10395:    .tLabel  oEmitLabel( continueLabel )
      
10403:    Label breakLabel = oLabelNew
      
10408:    oLoopPush( continueLabel, breakLabel )
10417:    @Statement
10419:    {[
10419:       | ';' :
10421:          @Statement
10423:       | pUntil :
10425:          Label falseLabel
10425:          @BooleanExprControlFlow( falseLabel )
10432:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
10446:          >
10448:    ]}
10458:    .tLabel  oEmitLabel( breakLabel )
10466:    oLoopPop;
      
      
10468: WhileStmt:
10470:    Label continueLabel = oLabelNew
10475:    .tLabel  oEmitLabel( continueLabel )
      
10483:    Label breakLabel
10483:    @BooleanExprControlFlow( breakLabel )
      
10490:    oLoopPush( continueLabel, breakLabel )
10499:    pDo
10501:    @Statement
10503:    .tJump  oEmitLabel( continueLabel )
10511:    .tLabel  oEmitLabel( breakLabel )
10519:    oLoopPop;
      
      
10521: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
10523:    [ equal_label( oLoopContinueLabel, labelNull )
10532:       | true :
10533:          #eNotInALoop
10535:       | false :
10537:          .tJump  oEmitLabel( oLoopContinueLabel )
10544:    ];
      
      
10553: BreakStmt:
10555:    [ equal_label( oLoopBreakLabel, labelNull )
10564:       | true :
10565:          #eNotInALoop
10567:       | false :
10569:          .tJump  oEmitLabel( oLoopBreakLabel )
10576:    ];
      
      
10585: GotoStmt:
10587:    [
10587:       | pIdent :
10589:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
10591:          oChangeIntLitToLabelIdent
10592:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
10600:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
10609:    oNodeSetBoolean( decl, qUsed, true )
10621:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
10637:    ;
      
      
10637: BeginStmt:
10639:    @Statement
10641:    {[
10641:       | ';' :   @Statement
10645:       | pEnd :  >
10649:    ]};
      
      
10660: WritelnStmt:
10662:    @WriteStmt
10664:    .tWriteCR;
      
      
10667: WriteStmt:
10669:    [
10669:       | '(' :
10671:          {
10671:             @Expr
10673:             [ oTypeSNodeType
10675:                | nIntegerType :             .tWriteI
10678:                | nBooleanType :             .tWriteBool
10682:                | nByteType :                .tCastBtoI  .tWriteI
10688:                | nCharType :                .tWriteChar
10692:                | nShortStringType, nStrLitType :   .tWriteShortStr
10696:                | nFileType :                #eNotImplemented
10700:                | nEnumType :
                        % write name via table lookup
10702:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
10716:                   .tWriteEnum
10718:                | nPointerType :
10720:                   [ equal_node( oTypeSTop, PCharType )
10729:                      | true :               .tWritePChar
10732:                      | * :                  .tWriteP
10739:                   ]
10739:                | nUniversalPointerType :    .tWriteP
10743:                | * :                        #eNotAllowed
10768:             ]
10768:             oTypeSPop
10769:             [
10769:                | ')' : >
10773:                | ',' :
10775:             ]
10783:          }
10785:       | * :
10790:    ];
      
      
10791: ReadlnStmt:      % ***
         % TO DO
10794:    ;
      
10794: ReadStmt:
         % TO DO
10797:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
10797: ScopeLevel >> int:
10799:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
10809: DeclLevel( Node decl ) >> int:
10811:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
10829: DeclUpLevels( Node decl ) >> int:
10831:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
10847: MatchTypes:
10849:    node_type nt = oTypeSNodeType
10854:    oTypeSPop
10855:    [ equal_node_type( nt, oTypeSNodeType )
10864:       | false :
               % Some implicit conversion is allowed even here
10865:          [ oTypeSNodeType
10867:             | nPointerType :
10868:                [ nt
10871:                   | nUniversalPointerType :  >>
10873:                   | * :
10878:                ]
10878:             | nUniversalPointerType :
10880:                [ nt
10883:                   | nPointerType :  >>
10885:                   | * :
10890:                ]
10890:             | * :
10897:          ]
10897:          #eTypeMismatch
10899:       | * :
10904:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
10905: RequireIntPop:
10907:    [ oTypeSNodeType
10909:       | nIntegerType :
10910:       | * :          #eNotInteger
10917:    ]
10917:    oTypeSPop;
      
10919: RequireInt:
10921:    [ oTypeSNodeType
10923:       | nIntegerType :
10924:       | * :          #eNotInteger
10931:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
10932: PromoteToIntPop:
10934:    [ oTypeSNodeType
10936:       | nIntegerType :
10937:       | nByteType :        .tCastBtoI
10941:       | * :                #eNotInteger
10950:    ]
10950:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
10952: PromoteToInt:
10954:    [ oTypeSNodeType
10956:       | nIntegerType :
10957:       | nByteType :        .tCastBtoI
10961:                            oTypeSPop
10962:                            oTypeSPush( IntegerType )
10968:       | * :                #eNotInteger
10977:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
10978: PromoteToIntOptional:
10980:    [ oTypeSNodeType
10982:       | nByteType :        .tCastBtoI
10985:                            oTypeSPop
10986:                            oTypeSPush( IntegerType )
10992:       | * :
10997:    ];
      
      
      
      
10998: RequireBoolPop:
11000:    [ oTypeSNodeType
11002:       | nBooleanType :
11003:       | * :          #eNotBoolean
11010:    ]
11010:    oTypeSPop;
      
11012: RequireBool:
11014:    [ oTypeSNodeType
11016:       | nBooleanType :
11017:       | * :          #eNotBoolean
11024:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
11025: newType( node_type nt, int size ) >> Node:
11027:   Node node = oNodeNew( nt )
11037:   oNodeSetInt( node, qSize, size )
11049:   oTypeAdd( node )
11055:   >> node
11059:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
11059: newIdent( node_type nt, int id ) >> Node:
11061:   Node t = oNodeNew( nt )
11071:   oNodeSetInt( t, qIdent, id )
11083:   >> t
11087:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
11087: PointerTypeTo( Node theType ) >> Node:
11089:    Node ptrType = oNodeGet( theType, qPointerType )
11102:    [ oNodeNull( ptrType )
11109:       | true :
11110:          ptrType = oNodeNew( nPointerType )
11120:          oNodeSet( ptrType, qBaseType, theType )
11132:          oNodeSetInt( ptrType, qSize, 8 )
11144:          oTypeAdd( ptrType )
11150:          oNodeSet( theType, qPointerType, ptrType )
11162:       | * :
11167:    ]
11167:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
11171: OrdinalLow( Node theType ) >> int:
11173:    [ oNodeType( theType )
11180:       | nIntegerType :  >> oMININT
11183:       | nBooleanType :  >> 0
11188:       | nCharType :     >> 0
11193:       | nEnumType :
11195:          Node enumScope = oNodeGet( theType, qScope )
11208:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
11225:          >> oNodeGetInt( first, qValue )
11235:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
11247:       | * :             #eNotOrdinalType
11262:                         >> 0
11265:    ];
      
      
      % Return the high value of an ordinal type
      %
11266: OrdinalHigh( Node theType ) >> int:
11268:    [ oNodeType( theType )
11275:       | nIntegerType :  >> oMAXINT
11278:       | nBooleanType :  >> 1
11283:       | nCharType :     >> 255
11288:       | nEnumType :
11290:          Node enumScope = oNodeGet( theType, qScope )
11303:          Node last = oNodeIterValue( oNodeGetIterLast( enumScope, qDecls ) )
11320:          >> oNodeGetInt( last, qValue )
11330:       | nSubrangeType : >> oNodeGetInt( theType, qHigh )
11342:       | * :             #eNotOrdinalType
11357:                         >> 0
11360:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
11361: EmitValue( Node decl ):
11363:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
11377: DeclareBuiltInFunc( int id ) >> Node:
11379:    Node decl = @newIdent( nBuiltInFunc, id )
11393:    oScopeDeclare( decl )
11399:    >> decl;
      
      
11403: installBuiltIns:
      
         % "mysystem" is the name of a unit that will be available everywhere.
         % Add its name to the id table so we can easily spot the name later.
11405:    mysystemId = oId_mysystem
      
         % install built-in types
11410:    FileType = @newType( nFileType, 4 )
11424:    IntegerType = @newType( nIntegerType, 4 )
11438:    BooleanType = @newType( nBooleanType, 1 )
11452:    BooleanCFType = @newType( nBooleanCFType, 1 )
11466:    CharType = @newType( nCharType, 1 )
11480:    PCharType = @PointerTypeTo( CharType )
11491:    ByteType = @newType( nByteType, 1 )
         % Universal pointer says base type Byte, but this is only for the sake of
         % pointer arithmetic.  It doesn't matter otherwise, because this type cannot be dereferened.
11505:    UniversalPointerType = @newType( nUniversalPointerType, 8 )
11519:    oNodeSet( UniversalPointerType, qBaseType, ByteType )
         % StrLitType is stored with both a length byte and null termination, so it can be assigned to
         % both a ShortString and a PChar.  StrLits longer than 255 characters appear truncated when
         % referenced as a ShortString, but not when referenced as a PChar.
11531:    StrLitType = @newType( nStrLitType, 256 )
         % ShortString is the original Pascal string type: an array of characters, not null-terminated,
         % with the first byte recording the current length.
         % The default ShortString type has capacity for 255 characters.  The user may define
         % additional ShortString types with smaller capacities.
         % The first character can be accessed as myString[1].
11545:    ShortStringType = @newType( nShortStringType, 256 )
11559:    oNodeSetInt( ShortStringType, qCapacity, 255 )
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oId_File
      
11571:    Node t
      
11571:    t = @newIdent( nTypeDecl, oId_File )
11584:    oNodeSet( t, qType, FileType )
11596:    oScopeDeclare( t )
      
11602:    t = @newIdent( nTypeDecl, oId_Integer )
11615:    oNodeSet( t, qType, IntegerType )
11627:    oScopeDeclare( t )
      
11633:    t = @newIdent( nTypeDecl, oId_Boolean )
11646:    oNodeSet( t, qType, BooleanType )
11658:    oScopeDeclare( t )
      
11664:    t = @newIdent( nTypeDecl, oId_Char )
11677:    oNodeSet( t, qType, CharType )
11689:    oScopeDeclare( t )
      
11695:    t = @newIdent( nTypeDecl, oId_Byte )
11708:    oNodeSet( t, qType, ByteType )
11720:    oScopeDeclare( t )
      
11726:    t = @newIdent( nTypeDecl, oId_Pointer )
11739:    oNodeSet( t, qType, UniversalPointerType )
11751:    oScopeDeclare( t )
      
11757:    t = @newIdent( nTypeDecl, oId_ShortString )
11770:    oNodeSet( t, qType, ShortStringType )
11782:    oScopeDeclare( t )
      
         % Built-in constants
      
11788:    t = @newIdent( nConst, oId_True )
11801:    oNodeSet( t, qType, BooleanType )
11813:    oNodeSetInt( t, qValue, 1 )
11825:    oScopeDeclare( t )
      
11831:    t = @newIdent( nConst, oId_False )
11844:    oNodeSet( t, qType, BooleanType )
11856:    oNodeSetInt( t, qValue, 0 )
11868:    oScopeDeclare( t )
      
11874:    t = @newIdent( nConst, oId_Nil )
11887:    oNodeSet( t, qType, UniversalPointerType )
11899:    oNodeSetInt( t, qValue, 0 )
11911:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
11917:    BuiltIn_Ord = @DeclareBuiltInFunc( oId_Ord )
11927:    BuiltIn_Chr = @DeclareBuiltInFunc( oId_Chr )
11937:    BuiltIn_Pred = @DeclareBuiltInFunc( oId_Pred )
11947:    BuiltIn_Succ = @DeclareBuiltInFunc( oId_Succ )
11958:    ;
      
11958: end
      
11958: 

Generated code:

   0: oGlobalSpace 21
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 11403
  25: oEmit 67
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 61
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 64
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 63
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 66
  64: oInput 28
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 11059
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 5
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 13
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 11059
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 5
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 15
 173: oJumpForward 178
 175: Choice Lookup Table
          14    103
 178: oInput 5
 180: oGetLocal 4
 182: oPushResult
 183: oCall 333
 185: oPop 1
 187: oInputChoice 198
 189: oGetLocal 4
 191: oPushResult
 192: oCall 306
 194: oPop 1
 196: oJumpForward 201
 198: Choice Lookup Table
          57    189
 201: oGetLocal 4
 203: oPushResult
 204: oCall 569
 206: oPop 1
 208: oSetResult 0
 210: oPushResult
 211: oSetResult 0
 213: oPushResult
 214: oScopeBegin
 215: oPop 2
 217: oGetAddrGlobal 2
 219: oPushResult
 220: oScopeCurrent
 221: oAssign
 222: oSetResult 0
 224: oPushResult
 225: oSetResult 1
 227: oPushResult
 228: oScopeBegin
 229: oPop 2
 231: oScopeCurrent
 232: oPushResult
 233: oSetResult 16
 235: oPushResult
 236: oGetGlobal 2
 238: oPushResult
 239: oNodeSet
 240: oPop 3
 242: oGetAddrGlobal 3
 244: oPushResult
 245: oScopeCurrent
 246: oAssign
 247: oGetLocal 4
 249: oPushResult
 250: oSetResult 7
 252: oPushResult
 253: oGetGlobal 3
 255: oPushResult
 256: oNodeSet
 257: oPop 3
 259: oScopeEnd
 260: oSetResult 20
 262: oPushResult
 263: oCall 1526
 265: oPop 1
 267: oGetGlobal 3
 269: oPushResult
 270: oScopeEnter
 271: oPop 1
 273: oGetAddrLocal 5
 275: oPushResult
 276: oSetResult 1
 278: oAssign
 279: oGetLocal 3
 281: oPushResult
 282: oGetGlobal 2
 284: oPushResult
 285: oGetLocal 5
 287: oPushResult
 288: oCall 1847
 290: oPop 3
 292: oScopeEnd
 293: oInput 20
 295: oCall 1582
 297: oScopeEnd
 298: oGetLocal 4
 300: oPushResult
 301: oCall 631
 303: oPop 1
 305: oReturn
 306: oLocalSpace 0
 308: oInput 0
 310: LAST_ID
 311: oPushResult
 312: oGetParam 1
 314: oPushResult
 315: oCall 430
 317: oPop 2
 319: oInputChoice 323
 321: oJumpForward 328
 323: Choice Lookup Table
          13    321
 326: oJumpForward 330
 328: oJumpBack 308
 330: oInput 5
 332: oReturn
 333: oLocalSpace 0
 335: oGetParam 1
 337: oPushResult
 338: oSetResult 4
 340: oPushResult
 341: oNodeGetInt
 342: oPop 2
 344: oPushResult
 345: oGetGlobal 4
 347: oPushResult
 348: equal
 349: oPop 2
 351: oChoice 356
 353: oReturn
 354: oJumpForward 359
 356: Choice Lookup Table
           1    353
 359: oGetGlobal 4
 361: oPushResult
 362: oGetParam 1
 364: oPushResult
 365: oCall 430
 367: oPop 2
 369: oReturn
 370: oLocalSpace 0
 372: oGetParam 1
 374: oPushResult
 375: oSetResult 4
 377: oPushResult
 378: oNodeGetInt
 379: oPop 2
 381: oPushResult
 382: oGetGlobal 4
 384: oPushResult
 385: equal
 386: oPop 2
 388: oChoice 426
 390: oGetAddrGlobal 19
 392: oPushResult
 393: oScopeCurrent
 394: oPushResult
 395: oSetResult 15
 397: oPushResult
 398: oSetResult 4
 400: oPushResult
 401: oId_ShortStringAppendShortString
 402: oPushResult
 403: oNodeFind
 404: oPop 4
 406: oAssign
 407: oGetAddrGlobal 20
 409: oPushResult
 410: oScopeCurrent
 411: oPushResult
 412: oSetResult 15
 414: oPushResult
 415: oSetResult 4
 417: oPushResult
 418: oId_ShortStringAppendChar
 419: oPushResult
 420: oNodeFind
 421: oPop 4
 423: oAssign
 424: oJumpForward 429
 426: Choice Lookup Table
           1    390
 429: oReturn
 430: oLocalSpace 2
 432: oGetAddrLocal 1
 434: oPushResult
 435: oGetParam 2
 437: oPushResult
 438: oCall 710
 440: oPop 1
 442: oAssign
 443: oGetLocal 1
 445: oPushResult
 446: oSetResult 0
 448: oPushResult
 449: equal_node
 450: oPop 2
 452: oChoice 522
 454: oGetParam 1
 456: oPushResult
 457: oSetResult 5
 459: oPushResult
 460: oGetLocal 1
 462: oPushResult
 463: oNodeAddLast
 464: oPop 3
 466: oGetAddrLocal 2
 468: oPushResult
 469: oSetResult 10
 471: oPushResult
 472: oNodeNew
 473: oPop 1
 475: oAssign
 476: oGetLocal 2
 478: oPushResult
 479: oSetResult 4
 481: oPushResult
 482: oGetLocal 1
 484: oPushResult
 485: oSetResult 4
 487: oPushResult
 488: oNodeGetInt
 489: oPop 2
 491: oPushResult
 492: oNodeSetInt
 493: oPop 3
 495: oGetLocal 2
 497: oPushResult
 498: oSetResult 9
 500: oPushResult
 501: oGetLocal 1
 503: oPushResult
 504: oSetResult 9
 506: oPushResult
 507: oNodeGet
 508: oPop 2
 510: oPushResult
 511: oNodeSet
 512: oPop 3
 514: oGetLocal 2
 516: oPushResult
 517: oScopeDeclare
 518: oPop 1
 520: oJumpForward 525
 522: Choice Lookup Table
           0    454
 525: oReturn
 526: oLocalSpace 1
 528: oGetFromParam 1
 530: oPushResult
 531: oNodeType
 532: oPop 1
 534: oChoice 565
 536: oGetAddrLocal 1
 538: oPushResult
 539: oGetFromParam 1
 541: oPushResult
 542: oSetResult 9
 544: oPushResult
 545: oNodeGet
 546: oPop 2
 548: oAssign
 549: oInput 20
 551: oInput 0
 553: oGetParam 1
 555: oPushResult
 556: oGetLocal 1
 558: oPushResult
 559: oScopeFindRequireInScope
 560: oPop 1
 562: oAssign
 563: oJumpForward 568
 565: Choice Lookup Table
          10    536
 568: oReturn
 569: oLocalSpace 2
 571: oGetAddrLocal 1
 573: oPushResult
 574: oGetParam 1
 576: oPushResult
 577: oSetResult 5
 579: oPushResult
 580: oNodeGetIter
 581: oPop 2
 583: oAssign
 584: oGetAddrLocal 2
 586: oPushResult
 587: oGetLocal 1
 589: oPushResult
 590: oNodeIterValue
 591: oPop 1
 593: oAssign
 594: oGetLocal 2
 596: oPushResult
 597: oNodeNull
 598: oPop 1
 600: oChoice 617
 602: oGetLocal 2
 604: oPushResult
 605: oSetResult 9
 607: oPushResult
 608: oNodeGet
 609: oPop 2
 611: oPushResult
 612: oScopeEnter
 613: oPop 1
 615: oJumpForward 622
 617: Choice Lookup Table
           0    602
 620: oJumpForward 630
 622: oGetAddrLocal 1
 624: oPushResult
 625: oNodeIterNext
 626: oPop 1
 628: oJumpBack 584
 630: oReturn
 631: oLocalSpace 2
 633: oGetAddrLocal 1
 635: oPushResult
 636: oGetParam 1
 638: oPushResult
 639: oSetResult 5
 641: oPushResult
 642: oNodeGetIterLast
 643: oPop 2
 645: oAssign
 646: oGetAddrLocal 2
 648: oPushResult
 649: oGetLocal 1
 651: oPushResult
 652: oNodeIterValue
 653: oPop 1
 655: oAssign
 656: oGetLocal 2
 658: oPushResult
 659: oNodeNull
 660: oPop 1
 662: oChoice 696
 664: oScopeCurrent
 665: oPushResult
 666: oGetLocal 2
 668: oPushResult
 669: oSetResult 9
 671: oPushResult
 672: oNodeGet
 673: oPop 2
 675: oPushResult
 676: oNodeEqual
 677: oPop 2
 679: oChoice 687
 681: oJumpForward 693
 683: oError 25
 685: oJumpForward 693
 687: Choice Lookup Table
           0    683
           1    681
 692: oEndChoice
 693: oScopeEnd
 694: oJumpForward 701
 696: Choice Lookup Table
           0    664
 699: oJumpForward 709
 701: oGetAddrLocal 1
 703: oPushResult
 704: oNodeIterPrev
 705: oPop 1
 707: oJumpBack 646
 709: oReturn
 710: oLocalSpace 2
 712: oGetAddrLocal 1
 714: oPushResult
 715: oGetGlobal 1
 717: oPushResult
 718: oSetResult 1
 720: oPushResult
 721: oSetResult 4
 723: oPushResult
 724: oGetParam 1
 726: oPushResult
 727: oNodeFind
 728: oPop 4
 730: oAssign
 731: oGetLocal 1
 733: oPushResult
 734: oSetResult 0
 736: oPushResult
 737: equal_node
 738: oPop 2
 740: oChoice 747
 742: oGetLocal 1
 744: oReturn
 745: oJumpForward 750
 747: Choice Lookup Table
           0    742
 750: oGetAddrLocal 2
 752: oPushResult
 753: oGetParam 1
 755: oPushResult
 756: oIncludeUnitFile
 757: oPop 1
 759: oAssign
 760: oGetLocal 2
 762: oChoice 771
 764: oError 24
 766: oSetResult 0
 768: oReturn
 769: oJumpForward 774
 771: Choice Lookup Table
           0    764
 774: oGetAddrLocal 1
 776: oPushResult
 777: oCall 785
 779: oAssign
 780: oIncludeEnd
 781: oGetLocal 1
 783: oReturn
 784: oReturn
 785: oLocalSpace 2
 787: oInput 58
 789: oInput 0
 791: oGetAddrLocal 1
 793: oPushResult
 794: oSetResult 5
 796: oPushResult
 797: oNodeNew
 798: oPop 1
 800: oAssign
 801: oGetLocal 1
 803: oPushResult
 804: oSetResult 4
 806: oPushResult
 807: LAST_ID
 808: oPushResult
 809: oNodeSetInt
 810: oPop 3
 812: oGetAddrLocal 2
 814: oPushResult
 815: oSetResult 6
 817: oPushResult
 818: oNodeNew
 819: oPop 1
 821: oAssign
 822: oGetLocal 2
 824: oPushResult
 825: oSetResult 4
 827: oPushResult
 828: LAST_ID
 829: oPushResult
 830: oNodeSetInt
 831: oPop 3
 833: oGetLocal 1
 835: oPushResult
 836: oSetResult 8
 838: oPushResult
 839: oGetLocal 2
 841: oPushResult
 842: oNodeSet
 843: oPop 3
 845: oInput 5
 847: oInput 59
 849: oGetLocal 1
 851: oPushResult
 852: oCall 333
 854: oPop 1
 856: oInputChoice 867
 858: oGetLocal 1
 860: oPushResult
 861: oCall 306
 863: oPop 1
 865: oJumpForward 870
 867: Choice Lookup Table
          57    858
 870: oGetLocal 1
 872: oPushResult
 873: oCall 569
 875: oPop 1
 877: oSetResult 0
 879: oPushResult
 880: oSetResult 0
 882: oPushResult
 883: oScopeBegin
 884: oPop 2
 886: oGetLocal 1
 888: oPushResult
 889: oSetResult 9
 891: oPushResult
 892: oScopeCurrent
 893: oPushResult
 894: oNodeSet
 895: oPop 3
 897: oGetAddrGlobal 2
 899: oPushResult
 900: oScopeCurrent
 901: oAssign
 902: oSetResult 0
 904: oPushResult
 905: oSetResult 1
 907: oPushResult
 908: oScopeBegin
 909: oPop 2
 911: oGetAddrGlobal 3
 913: oPushResult
 914: oScopeCurrent
 915: oAssign
 916: oGetLocal 1
 918: oPushResult
 919: oSetResult 13
 921: oPushResult
 922: oGetGlobal 3
 924: oPushResult
 925: oNodeSet
 926: oPop 3
 928: oScopeEnd
 929: oGetLocal 1
 931: oPushResult
 932: oCall 1120
 934: oPop 1
 936: oScopeEnd
 937: oInput 60
 939: oGetLocal 2
 941: oPushResult
 942: oCall 333
 944: oPop 1
 946: oInputChoice 957
 948: oGetLocal 2
 950: oPushResult
 951: oCall 306
 953: oPop 1
 955: oJumpForward 960
 957: Choice Lookup Table
          57    948
 960: oGetLocal 2
 962: oPushResult
 963: oCall 569
 965: oPop 1
 967: oGetLocal 1
 969: oPushResult
 970: oSetResult 9
 972: oPushResult
 973: oNodeGet
 974: oPop 2
 976: oPushResult
 977: oScopeEnter
 978: oPop 1
 980: oSetResult 0
 982: oPushResult
 983: oSetResult 0
 985: oPushResult
 986: oScopeBegin
 987: oPop 2
 989: oGetLocal 1
 991: oPushResult
 992: oSetResult 10
 994: oPushResult
 995: oScopeCurrent
 996: oPushResult
 997: oNodeSet
 998: oPop 3
1000: oScopeCurrent
1001: oPushResult
1002: oSetResult 16
1004: oPushResult
1005: oGetLocal 1
1007: oPushResult
1008: oSetResult 9
1010: oPushResult
1011: oNodeGet
1012: oPop 2
1014: oPushResult
1015: oNodeSet
1016: oPop 3
1018: oGetAddrGlobal 2
1020: oPushResult
1021: oScopeCurrent
1022: oAssign
1023: oGetLocal 1
1025: oPushResult
1026: oCall 1212
1028: oPop 1
1030: oInputChoice 1044
1032: oGetLocal 1
1034: oPushResult
1035: oSetResult 1
1037: oPushResult
1038: oCall 1222
1040: oPop 2
1042: oJumpForward 1057
1044: Choice Lookup Table
          61   1032
1047: oGetLocal 1
1049: oPushResult
1050: oSetResult 0
1052: oPushResult
1053: oCall 1222
1055: oPop 2
1057: oInputChoice 1071
1059: oGetLocal 1
1061: oPushResult
1062: oSetResult 1
1064: oPushResult
1065: oCall 1408
1067: oPop 2
1069: oJumpForward 1084
1071: Choice Lookup Table
          62   1059
1074: oGetLocal 1
1076: oPushResult
1077: oSetResult 0
1079: oPushResult
1080: oCall 1408
1082: oPop 2
1084: oInput 36
1086: oInput 20
1088: oScopeEnd
1089: oScopeEnd
1090: oGetLocal 2
1092: oPushResult
1093: oCall 631
1095: oPop 1
1097: oGetLocal 1
1099: oPushResult
1100: oCall 631
1102: oPop 1
1104: oGetGlobal 1
1106: oPushResult
1107: oSetResult 1
1109: oPushResult
1110: oGetLocal 1
1112: oPushResult
1113: oNodeAddLast
1114: oPop 3
1116: oGetLocal 1
1118: oReturn
1119: oReturn
1120: oLocalSpace 2
1122: oInputChoice 1189
1124: oCall 3120
1126: oJumpForward 1202
1128: oCall 3675
1130: oJumpForward 1202
1132: oSetResult 20
1134: oPushResult
1135: oCall 3731
1137: oPop 1
1139: oJumpForward 1202
1141: oGetAddrLocal 1
1143: oPushResult
1144: oCall 2087
1146: oAssign
1147: oInputChoice 1160
1149: oGetLocal 1
1151: oPushResult
1152: oCall 2025
1154: oPop 1
1156: oInput 5
1158: oJumpForward 1163
1160: Choice Lookup Table
          68   1149
1163: oJumpForward 1202
1165: oGetAddrLocal 2
1167: oPushResult
1168: oCall 2461
1170: oAssign
1171: oInputChoice 1184
1173: oGetLocal 2
1175: oPushResult
1176: oCall 2025
1178: oPop 1
1180: oInput 5
1182: oJumpForward 1187
1184: Choice Lookup Table
          68   1173
1187: oJumpForward 1202
1189: Choice Lookup Table
          30   1165
          29   1141
          33   1132
          32   1128
          31   1124
1200: oJumpForward 1204
1202: oJumpBack 1122
1204: oGetParam 1
1206: oPushResult
1207: oCall 370
1209: oPop 1
1211: oReturn
1212: oLocalSpace 0
1214: oSetResult 20
1216: oPushResult
1217: oCall 1526
1219: oPop 1
1221: oReturn
1222: oLocalSpace 5
1224: oGetAddrLocal 1
1226: oPushResult
1227: oLabelNew
1228: oAssign
1229: oEmit 71
1231: oGetLocal 1
1233: oPushResult
1234: oEmitLabel
1235: oPop 1
1237: oGetParam 2
1239: oPushResult
1240: oSetResult 11
1242: oPushResult
1243: oGetLocal 1
1245: oPushResult
1246: oNodeSetLabel
1247: oPop 3
1249: oEmit 67
1251: oGetAddrLocal 2
1253: oPushResult
1254: Here
1255: oAssign
1256: oEmit 84
1258: oGetAddrLocal 3
1260: oPushResult
1261: oGetParam 2
1263: oPushResult
1264: oSetResult 9
1266: oPushResult
1267: oNodeGet
1268: oPop 2
1270: oAssign
1271: oGetAddrLocal 4
1273: oPushResult
1274: oGetLocal 3
1276: oPushResult
1277: oSetResult 19
1279: oPushResult
1280: oNodeGetCode
1281: oPop 2
1283: oAssign
1284: oGetLocal 4
1286: oPushResult
1287: oEmitCode
1288: oPop 1
1290: oGetLocal 3
1292: oPushResult
1293: oSetResult 19
1295: oPushResult
1296: oSetResult 0
1298: oPushResult
1299: oNodeSetCode
1300: oPop 3
1302: oGetAddrLocal 3
1304: oPushResult
1305: oGetParam 2
1307: oPushResult
1308: oSetResult 10
1310: oPushResult
1311: oNodeGet
1312: oPop 2
1314: oAssign
1315: oGetAddrLocal 4
1317: oPushResult
1318: oGetLocal 3
1320: oPushResult
1321: oSetResult 19
1323: oPushResult
1324: oNodeGetCode
1325: oPop 2
1327: oAssign
1328: oGetLocal 4
1330: oPushResult
1331: oEmitCode
1332: oPop 1
1334: oGetLocal 3
1336: oPushResult
1337: oSetResult 19
1339: oPushResult
1340: oSetResult 0
1342: oPushResult
1343: oNodeSetCode
1344: oPop 3
1346: oGetParam 2
1348: oPushResult
1349: oSetResult 13
1351: oPushResult
1352: oNodeGet
1353: oPop 2
1355: oPushResult
1356: oScopeEnter
1357: oPop 1
1359: oGetParam 1
1361: oChoice 1380
1363: oCall 9473
1365: oInputChoice 1371
1367: oCall 9473
1369: oJumpForward 1376
1371: Choice Lookup Table
           5   1367
1374: oJumpForward 1378
1376: oJumpBack 1365
1378: oJumpForward 1383
1380: Choice Lookup Table
           1   1363
1383: oEmit 66
1385: oGetAddrLocal 5
1387: oPushResult
1388: oScopeCurrent
1389: oPushResult
1390: oSetResult 17
1392: oPushResult
1393: oNodeGetInt
1394: oPop 2
1396: oAssign
1397: oGetLocal 2
1399: oPushResult
1400: oGetLocal 5
1402: oPushResult
1403: oPatch
1404: oPop 2
1406: oScopeEnd
1407: oReturn
1408: oLocalSpace 3
1410: oGetAddrLocal 1
1412: oPushResult
1413: oLabelNew
1414: oAssign
1415: oEmit 71
1417: oGetLocal 1
1419: oPushResult
1420: oEmitLabel
1421: oPop 1
1423: oGetParam 2
1425: oPushResult
1426: oSetResult 12
1428: oPushResult
1429: oGetLocal 1
1431: oPushResult
1432: oNodeSetLabel
1433: oPop 3
1435: oEmit 67
1437: oGetAddrLocal 2
1439: oPushResult
1440: Here
1441: oAssign
1442: oEmit 84
1444: oSetResult 0
1446: oPushResult
1447: oSetResult 1
1449: oPushResult
1450: oScopeBegin
1451: oPop 2
1453: oGetParam 1
1455: oChoice 1474
1457: oCall 9473
1459: oInputChoice 1465
1461: oCall 9473
1463: oJumpForward 1470
1465: Choice Lookup Table
           5   1461
1468: oJumpForward 1472
1470: oJumpBack 1459
1472: oJumpForward 1477
1474: Choice Lookup Table
           1   1457
1477: oEmit 66
1479: oGetAddrLocal 3
1481: oPushResult
1482: oScopeCurrent
1483: oPushResult
1484: oSetResult 17
1486: oPushResult
1487: oNodeGetInt
1488: oPop 2
1490: oAssign
1491: oGetLocal 2
1493: oPushResult
1494: oGetLocal 3
1496: oPushResult
1497: oPatch
1498: oPop 2
1500: oScopeEnd
1501: oReturn
1502: oLocalSpace 0
1504: oGetParam 2
1506: oPushResult
1507: oCall 1526
1509: oPop 1
1511: oGetParam 1
1513: oPushResult
1514: oScopeCurrent
1515: oPushResult
1516: oSetResult 0
1518: oPushResult
1519: oCall 1847
1521: oPop 3
1523: oCall 1582
1525: oReturn
1526: oLocalSpace 0
1528: oInputChoice 1559
1530: oCall 3120
1532: oJumpForward 1574
1534: oCall 3675
1536: oJumpForward 1574
1538: oGetParam 1
1540: oPushResult
1541: oCall 3731
1543: oPop 1
1545: oJumpForward 1574
1547: oCall 3965
1549: oJumpForward 1574
1551: oCall 2343
1553: oJumpForward 1574
1555: oCall 2778
1557: oJumpForward 1574
1559: Choice Lookup Table
          30   1555
          29   1551
          34   1547
          33   1538
          32   1534
          31   1530
1572: oJumpForward 1576
1574: oJumpBack 1528
1576: oCall 1579
1578: oReturn
1579: oLocalSpace 0
1581: oReturn
1582: oLocalSpace 2
1584: oGetAddrLocal 1
1586: oPushResult
1587: oScopeCurrent
1588: oPushResult
1589: oSetResult 15
1591: oPushResult
1592: oNodeGetIter
1593: oPop 2
1595: oAssign
1596: oGetAddrLocal 2
1598: oPushResult
1599: oGetLocal 1
1601: oPushResult
1602: oNodeIterValue
1603: oPop 1
1605: oAssign
1606: oGetLocal 2
1608: oPushResult
1609: oNodeNull
1610: oPop 1
1612: oChoice 1616
1614: oJumpForward 1621
1616: Choice Lookup Table
           0   1614
1619: oJumpForward 1676
1621: oGetLocal 2
1623: oPushResult
1624: oNodeType
1625: oPop 1
1627: oChoice 1665
1629: oGetLocal 2
1631: oPushResult
1632: oSetResult 34
1634: oPushResult
1635: oNodeGetBoolean
1636: oPop 2
1638: oChoice 1660
1640: oGetLocal 2
1642: oPushResult
1643: oSetResult 28
1645: oPushResult
1646: oNodeGetBoolean
1647: oPop 2
1649: oChoice 1655
1651: oError 27
1653: oJumpForward 1658
1655: Choice Lookup Table
           1   1651
1658: oJumpForward 1663
1660: Choice Lookup Table
           0   1640
1663: oJumpForward 1668
1665: Choice Lookup Table
          25   1629
1668: oGetAddrLocal 1
1670: oPushResult
1671: oNodeIterNext
1672: oPop 1
1674: oJumpBack 1596
1676: oReturn
1677: oLocalSpace 2
1679: oGetAddrLocal 1
1681: oPushResult
1682: oGetGlobal 1
1684: oPushResult
1685: oSetResult 1
1687: oPushResult
1688: oNodeGetIter
1689: oPop 2
1691: oAssign
1692: oGetAddrLocal 2
1694: oPushResult
1695: oGetLocal 1
1697: oPushResult
1698: oNodeIterValue
1699: oPop 1
1701: oAssign
1702: oGetLocal 2
1704: oPushResult
1705: oNodeNull
1706: oPop 1
1708: oChoice 1753
1710: oJumpForward 1761
1712: oJumpForward 1759
1714: oEmit 61
1716: oSetResult 0
1718: oPushResult
1719: oEmitInt
1720: oPop 1
1722: oEmit 64
1724: oGetLocal 2
1726: oPushResult
1727: oSetResult 11
1729: oPushResult
1730: oNodeGetLabel
1731: oPop 2
1733: oPushResult
1734: oEmitLabel
1735: oPop 1
1737: oEmit 63
1739: oSetResult 0
1741: oPushResult
1742: oEmitInt
1743: oPop 1
1745: oGetAddrLocal 1
1747: oPushResult
1748: oNodeIterNext
1749: oPop 1
1751: oJumpForward 1759
1753: Choice Lookup Table
           0   1714
           1   1710
1758: oEndChoice
1759: oJumpBack 1692
1761: oReturn
1762: oLocalSpace 2
1764: oGetAddrLocal 1
1766: oPushResult
1767: oGetGlobal 1
1769: oPushResult
1770: oSetResult 1
1772: oPushResult
1773: oNodeGetIterLast
1774: oPop 2
1776: oAssign
1777: oGetAddrLocal 2
1779: oPushResult
1780: oGetLocal 1
1782: oPushResult
1783: oNodeIterValue
1784: oPop 1
1786: oAssign
1787: oGetLocal 2
1789: oPushResult
1790: oNodeNull
1791: oPop 1
1793: oChoice 1838
1795: oJumpForward 1846
1797: oJumpForward 1844
1799: oEmit 61
1801: oSetResult 0
1803: oPushResult
1804: oEmitInt
1805: oPop 1
1807: oEmit 64
1809: oGetLocal 2
1811: oPushResult
1812: oSetResult 12
1814: oPushResult
1815: oNodeGetLabel
1816: oPop 2
1818: oPushResult
1819: oEmitLabel
1820: oPop 1
1822: oEmit 63
1824: oSetResult 0
1826: oPushResult
1827: oEmitInt
1828: oPop 1
1830: oGetAddrLocal 1
1832: oPushResult
1833: oNodeIterPrev
1834: oPop 1
1836: oJumpForward 1844
1838: Choice Lookup Table
           0   1799
           1   1795
1843: oEndChoice
1844: oJumpBack 1777
1846: oReturn
1847: oLocalSpace 3
1849: oEmit 71
1851: oGetParam 3
1853: oPushResult
1854: oEmitLabel
1855: oPop 1
1857: oEmit 67
1859: oGetAddrLocal 1
1861: oPushResult
1862: Here
1863: oAssign
1864: oEmit 84
1866: oGetParam 1
1868: oChoice 1874
1870: oCall 1677
1872: oJumpForward 1877
1874: Choice Lookup Table
           1   1870
1877: oGetAddrLocal 2
1879: oPushResult
1880: oGetParam 2
1882: oPushResult
1883: oSetResult 19
1885: oPushResult
1886: oNodeGetCode
1887: oPop 2
1889: oAssign
1890: oGetLocal 2
1892: oPushResult
1893: oEmitCode
1894: oPop 1
1896: oGetParam 2
1898: oPushResult
1899: oSetResult 19
1901: oPushResult
1902: oSetResult 0
1904: oPushResult
1905: oNodeSetCode
1906: oPop 3
1908: oCall 9473
1910: oGetParam 1
1912: oChoice 1918
1914: oCall 1762
1916: oJumpForward 1921
1918: Choice Lookup Table
           1   1914
1921: oEmit 66
1923: oGetAddrLocal 3
1925: oPushResult
1926: oScopeCurrent
1927: oPushResult
1928: oSetResult 17
1930: oPushResult
1931: oNodeGetInt
1932: oPop 2
1934: oAssign
1935: oGetLocal 1
1937: oPushResult
1938: oGetLocal 3
1940: oPushResult
1941: oPatch
1942: oPop 2
1944: oReturn
1945: oLocalSpace 0
1947: oInputChoice 1965
1949: oGetParam 1
1951: oPushResult
1952: oSetResult 27
1954: oPushResult
1955: oSetResult 1
1957: oPushResult
1958: oNodeSetBoolean
1959: oPop 3
1961: oInput 5
1963: oJumpForward 1970
1965: Choice Lookup Table
          70   1949
1968: oJumpForward 1972
1970: oJumpBack 1947
1972: oReturn
1973: oLocalSpace 1
1975: oGetAddrLocal 1
1977: oPushResult
1978: oGetParam 1
1980: oPushResult
1981: oSetResult 19
1983: oPushResult
1984: oNodeGetCode
1985: oPop 2
1987: oAssign
1988: oGetLocal 1
1990: oPushResult
1991: oSetResult 0
1993: oPushResult
1994: equal_code
1995: oPop 2
1997: oChoice 2018
1999: oGetAddrLocal 1
2001: oPushResult
2002: oCodeNew
2003: oAssign
2004: oGetParam 1
2006: oPushResult
2007: oSetResult 19
2009: oPushResult
2010: oGetLocal 1
2012: oPushResult
2013: oNodeSetCode
2014: oPop 3
2016: oJumpForward 2021
2018: Choice Lookup Table
           1   1999
2021: oGetLocal 1
2023: oReturn
2024: oReturn
2025: oLocalSpace 0
2027: oGetParam 1
2029: oPushResult
2030: oCall 10809
2032: oPop 1
2034: oPushResult
2035: equal_zero
2036: oPop 1
2038: oChoice 2044
2040: oError 23
2042: oJumpForward 2047
2044: Choice Lookup Table
           0   2040
2047: oGetParam 1
2049: oPushResult
2050: oSetResult 25
2052: oPushResult
2053: oSetResult 1
2055: oPushResult
2056: oNodeSetBoolean
2057: oPop 3
2059: oInputChoice 2083
2061: oInputChoice 2078
2063: oInput 2
2065: oGetParam 1
2067: oPushResult
2068: oSetResult 26
2070: oPushResult
2071: CURRENT_STRLIT
2072: oPushResult
2073: oNodeSetString
2074: oPop 3
2076: oJumpForward 2081
2078: Choice Lookup Table
          69   2063
2081: oJumpForward 2086
2083: Choice Lookup Table
           2   2061
2086: oReturn
2087: oLocalSpace 6
2089: oInput 0
2091: oGetAddrLocal 1
2093: oPushResult
2094: oSetResult 0
2096: oAssign
2097: oGetAddrLocal 2
2099: oPushResult
2100: oScopeFindInCurrentScope
2101: oAssign
2102: oGetLocal 2
2104: oPushResult
2105: oNodeNull
2106: oPop 1
2108: oChoice 2226
2110: oGetAddrLocal 2
2112: oPushResult
2113: oSetResult 12
2115: oPushResult
2116: LAST_ID
2117: oPushResult
2118: oCall 11059
2120: oPop 2
2122: oAssign
2123: oGetLocal 2
2125: oPushResult
2126: oSetResult 22
2128: oPushResult
2129: oLabelNew
2130: oPushResult
2131: oNodeSetLabel
2132: oPop 3
2134: oJumpForward 2232
2136: oGetAddrLocal 1
2138: oPushResult
2139: oSetResult 1
2141: oAssign
2142: oGetLocal 2
2144: oPushResult
2145: oSetResult 24
2147: oPushResult
2148: oNodeGetBoolean
2149: oPop 2
2151: oChoice 2157
2153: oError 21
2155: oJumpForward 2160
2157: Choice Lookup Table
           1   2153
2160: oGetLocal 2
2162: oPushResult
2163: oSetResult 25
2165: oPushResult
2166: oNodeGetBoolean
2167: oPop 2
2169: oChoice 2175
2171: oError 21
2173: oJumpForward 2178
2175: Choice Lookup Table
           1   2171
2178: oGetLocal 2
2180: oPushResult
2181: oNodeType
2182: oPop 1
2184: oChoice 2188
2186: oJumpForward 2193
2188: Choice Lookup Table
          12   2186
2191: oError 21
2193: oGetLocal 2
2195: oPushResult
2196: oSetResult 29
2198: oPushResult
2199: oGetLocal 2
2201: oPushResult
2202: oSetResult 23
2204: oPushResult
2205: oNodeGet
2206: oPop 2
2208: oPushResult
2209: oNodeSet
2210: oPop 3
2212: oGetLocal 2
2214: oPushResult
2215: oSetResult 23
2217: oPushResult
2218: oSetResult 0
2220: oPushResult
2221: oNodeSet
2222: oPop 3
2224: oJumpForward 2232
2226: Choice Lookup Table
           0   2136
           1   2110
2231: oEndChoice
2232: oGetAddrLocal 3
2234: oPushResult
2235: oCall 10797
2237: oAssign
2238: oGetAddrLocal 4
2240: oPushResult
2241: oGetLocal 3
2243: oPushResult
2244: oSetResult 0
2246: oPushResult
2247: greater
2248: oPop 2
2250: oAssign
2251: oGetAddrLocal 3
2253: oPushResult
2254: inc
2255: oPop 1
2257: oGetLocal 3
2259: oPushResult
2260: oSetResult 2
2262: oPushResult
2263: oScopeBegin
2264: oPop 2
2266: oGetAddrLocal 5
2268: oPushResult
2269: oScopeCurrent
2270: oAssign
2271: oGetLocal 4
2273: oChoice 2292
2275: oGetAddrLocal 6
2277: oPushResult
2278: oGetGlobal 6
2280: oPushResult
2281: oCall 11087
2283: oPop 1
2285: oPushResult
2286: oScopeAllocType
2287: oPop 1
2289: oAssign
2290: oJumpForward 2295
2292: Choice Lookup Table
           1   2275
2295: oCall 2896
2297: oGetLocal 2
2299: oPushResult
2300: oSetResult 23
2302: oPushResult
2303: oGetLocal 5
2305: oPushResult
2306: oNodeSet
2307: oPop 3
2309: oScopeEnd
2310: oInput 5
2312: oGetLocal 1
2314: oChoice 2326
2316: oGetLocal 2
2318: oPushResult
2319: oScopeDeclare
2320: oPop 1
2322: oJumpForward 2332
2324: oJumpForward 2332
2326: Choice Lookup Table
           1   2324
           0   2316
2331: oEndChoice
2332: oGetLocal 2
2334: oPushResult
2335: oCall 1945
2337: oPop 1
2339: oGetLocal 2
2341: oReturn
2342: oReturn
2343: oLocalSpace 4
2345: oGetAddrLocal 1
2347: oPushResult
2348: oCall 2087
2350: oAssign
2351: oInputChoice 2364
2353: oJumpForward 2458
2355: oGetLocal 1
2357: oPushResult
2358: oCall 2025
2360: oPop 1
2362: oJumpForward 2458
2364: Choice Lookup Table
          68   2355
          67   2353
2369: oGetAddrLocal 2
2371: oPushResult
2372: oGetLocal 1
2374: oPushResult
2375: oSetResult 23
2377: oPushResult
2378: oNodeGet
2379: oPop 2
2381: oAssign
2382: oGetLocal 2
2384: oPushResult
2385: oScopeEnter
2386: oPop 1
2388: oGetAddrLocal 3
2390: oPushResult
2391: oGetLocal 2
2393: oPushResult
2394: oSetResult 14
2396: oPushResult
2397: oNodeGetInt
2398: oPop 2
2400: oAssign
2401: oGetLocal 3
2403: oPushResult
2404: oSetResult 1
2406: oPushResult
2407: oScopeBegin
2408: oPop 2
2410: oGetLocal 1
2412: oPushResult
2413: oSetResult 6
2415: oPushResult
2416: oScopeCurrent
2417: oPushResult
2418: oNodeSet
2419: oPop 3
2421: oGetAddrLocal 4
2423: oPushResult
2424: oGetLocal 1
2426: oPushResult
2427: oSetResult 22
2429: oPushResult
2430: oNodeGetLabel
2431: oPop 2
2433: oAssign
2434: oSetResult 21
2436: oPushResult
2437: oGetLocal 4
2439: oPushResult
2440: oCall 1502
2442: oPop 2
2444: oGetLocal 1
2446: oPushResult
2447: oSetResult 24
2449: oPushResult
2450: oSetResult 1
2452: oPushResult
2453: oNodeSetBoolean
2454: oPop 3
2456: oScopeEnd
2457: oScopeEnd
2458: oInput 5
2460: oReturn
2461: oLocalSpace 8
2463: oInput 0
2465: oGetAddrLocal 1
2467: oPushResult
2468: oSetResult 0
2470: oAssign
2471: oGetAddrLocal 2
2473: oPushResult
2474: oScopeFindInCurrentScope
2475: oAssign
2476: oGetLocal 2
2478: oPushResult
2479: oNodeNull
2480: oPop 1
2482: oChoice 2613
2484: oGetAddrLocal 2
2486: oPushResult
2487: oSetResult 13
2489: oPushResult
2490: LAST_ID
2491: oPushResult
2492: oCall 11059
2494: oPop 2
2496: oAssign
2497: oGetLocal 2
2499: oPushResult
2500: oSetResult 22
2502: oPushResult
2503: oLabelNew
2504: oPushResult
2505: oNodeSetLabel
2506: oPop 3
2508: oJumpForward 2619
2510: oGetAddrLocal 1
2512: oPushResult
2513: oSetResult 1
2515: oAssign
2516: oGetLocal 2
2518: oPushResult
2519: oSetResult 24
2521: oPushResult
2522: oNodeGetBoolean
2523: oPop 2
2525: oChoice 2531
2527: oError 21
2529: oJumpForward 2534
2531: Choice Lookup Table
           1   2527
2534: oGetLocal 2
2536: oPushResult
2537: oNodeType
2538: oPop 1
2540: oChoice 2544
2542: oJumpForward 2549
2544: Choice Lookup Table
          13   2542
2547: oError 21
2549: oGetLocal 2
2551: oPushResult
2552: oSetResult 29
2554: oPushResult
2555: oGetLocal 2
2557: oPushResult
2558: oSetResult 23
2560: oPushResult
2561: oNodeGet
2562: oPop 2
2564: oPushResult
2565: oNodeSet
2566: oPop 3
2568: oGetLocal 2
2570: oPushResult
2571: oSetResult 23
2573: oPushResult
2574: oSetResult 0
2576: oPushResult
2577: oNodeSet
2578: oPop 3
2580: oGetLocal 2
2582: oPushResult
2583: oSetResult 30
2585: oPushResult
2586: oGetLocal 2
2588: oPushResult
2589: oSetResult 21
2591: oPushResult
2592: oNodeGet
2593: oPop 2
2595: oPushResult
2596: oNodeSet
2597: oPop 3
2599: oGetLocal 2
2601: oPushResult
2602: oSetResult 21
2604: oPushResult
2605: oSetResult 0
2607: oPushResult
2608: oNodeSet
2609: oPop 3
2611: oJumpForward 2619
2613: Choice Lookup Table
           0   2510
           1   2484
2618: oEndChoice
2619: oGetAddrLocal 3
2621: oPushResult
2622: oCall 10797
2624: oAssign
2625: oGetAddrLocal 4
2627: oPushResult
2628: oGetLocal 3
2630: oPushResult
2631: oSetResult 0
2633: oPushResult
2634: greater
2635: oPop 2
2637: oAssign
2638: oGetAddrLocal 3
2640: oPushResult
2641: inc
2642: oPop 1
2644: oGetLocal 3
2646: oPushResult
2647: oSetResult 2
2649: oPushResult
2650: oScopeBegin
2651: oPop 2
2653: oGetAddrLocal 5
2655: oPushResult
2656: oScopeCurrent
2657: oAssign
2658: oGetLocal 4
2660: oChoice 2679
2662: oGetAddrLocal 6
2664: oPushResult
2665: oGetGlobal 6
2667: oPushResult
2668: oCall 11087
2670: oPop 1
2672: oPushResult
2673: oScopeAllocType
2674: oPop 1
2676: oAssign
2677: oJumpForward 2682
2679: Choice Lookup Table
           1   2662
2682: oCall 2896
2684: oGetLocal 2
2686: oPushResult
2687: oSetResult 23
2689: oPushResult
2690: oGetLocal 5
2692: oPushResult
2693: oNodeSet
2694: oPop 3
2696: oInput 12
2698: oGetAddrLocal 7
2700: oPushResult
2701: oCall 4030
2703: oPop 1
2705: oGetLocal 2
2707: oPushResult
2708: oSetResult 21
2710: oPushResult
2711: oGetLocal 7
2713: oPushResult
2714: oNodeSet
2715: oPop 3
2717: oGetAddrLocal 8
2719: oPushResult
2720: oGetLocal 7
2722: oPushResult
2723: oCall 11087
2725: oPop 1
2727: oAssign
2728: oGetLocal 2
2730: oPushResult
2731: oSetResult 31
2733: oPushResult
2734: oGetLocal 8
2736: oPushResult
2737: oScopeAllocType
2738: oPop 1
2740: oPushResult
2741: oNodeSetInt
2742: oPop 3
2744: oScopeEnd
2745: oInput 5
2747: oGetLocal 1
2749: oChoice 2761
2751: oGetLocal 2
2753: oPushResult
2754: oScopeDeclare
2755: oPop 1
2757: oJumpForward 2767
2759: oJumpForward 2767
2761: Choice Lookup Table
           1   2759
           0   2751
2766: oEndChoice
2767: oGetLocal 2
2769: oPushResult
2770: oCall 1945
2772: oPop 1
2774: oGetLocal 2
2776: oReturn
2777: oReturn
2778: oLocalSpace 4
2780: oGetAddrLocal 1
2782: oPushResult
2783: oCall 2461
2785: oAssign
2786: oInputChoice 2799
2788: oJumpForward 2893
2790: oGetLocal 1
2792: oPushResult
2793: oCall 2025
2795: oPop 1
2797: oJumpForward 2893
2799: Choice Lookup Table
          68   2790
          67   2788
2804: oGetAddrLocal 2
2806: oPushResult
2807: oGetLocal 1
2809: oPushResult
2810: oSetResult 23
2812: oPushResult
2813: oNodeGet
2814: oPop 2
2816: oAssign
2817: oGetLocal 2
2819: oPushResult
2820: oScopeEnter
2821: oPop 1
2823: oGetAddrLocal 3
2825: oPushResult
2826: oGetLocal 2
2828: oPushResult
2829: oSetResult 14
2831: oPushResult
2832: oNodeGetInt
2833: oPop 2
2835: oAssign
2836: oGetLocal 3
2838: oPushResult
2839: oSetResult 1
2841: oPushResult
2842: oScopeBegin
2843: oPop 2
2845: oGetLocal 1
2847: oPushResult
2848: oSetResult 6
2850: oPushResult
2851: oScopeCurrent
2852: oPushResult
2853: oNodeSet
2854: oPop 3
2856: oGetAddrLocal 4
2858: oPushResult
2859: oGetLocal 1
2861: oPushResult
2862: oSetResult 22
2864: oPushResult
2865: oNodeGetLabel
2866: oPop 2
2868: oAssign
2869: oSetResult 21
2871: oPushResult
2872: oGetLocal 4
2874: oPushResult
2875: oCall 1502
2877: oPop 2
2879: oGetLocal 1
2881: oPushResult
2882: oSetResult 24
2884: oPushResult
2885: oSetResult 1
2887: oPushResult
2888: oNodeSetBoolean
2889: oPop 3
2891: oScopeEnd
2892: oScopeEnd
2893: oInput 5
2895: oReturn
2896: oLocalSpace 6
2898: oInputChoice 3116
2900: oGetAddrLocal 1
2902: oPushResult
2903: oNodeVecNew
2904: oAssign
2905: oGetAddrLocal 3
2907: oPushResult
2908: oSetResult 0
2910: oAssign
2911: oInputChoice 2921
2913: oGetAddrLocal 3
2915: oPushResult
2916: oSetResult 1
2918: oAssign
2919: oJumpForward 2924
2921: Choice Lookup Table
          33   2913
2924: oInput 0
2926: oGetAddrLocal 2
2928: oPushResult
2929: oSetResult 23
2931: oPushResult
2932: LAST_ID
2933: oPushResult
2934: oCall 11059
2936: oPop 2
2938: oAssign
2939: oGetLocal 2
2941: oPushResult
2942: oSetResult 33
2944: oPushResult
2945: oGetLocal 3
2947: oPushResult
2948: oNodeSetBoolean
2949: oPop 3
2951: oGetLocal 1
2953: oPushResult
2954: oGetLocal 2
2956: oPushResult
2957: oNodeVecAppend
2958: oPop 2
2960: oInputChoice 2968
2962: oJumpForward 2976
2964: oJumpForward 2974
2966: oJumpForward 2974
2968: Choice Lookup Table
          13   2966
          12   2962
2973: oEndChoice
2974: oJumpBack 2924
2976: oGetAddrLocal 4
2978: oPushResult
2979: oCall 4030
2981: oPop 1
2983: oGetLocal 3
2985: oChoice 3000
2987: oGetAddrLocal 5
2989: oPushResult
2990: oGetLocal 4
2992: oPushResult
2993: oCall 11087
2995: oPop 1
2997: oAssign
2998: oJumpForward 3009
3000: Choice Lookup Table
           1   2987
3003: oGetAddrLocal 5
3005: oPushResult
3006: oGetLocal 4
3008: oAssign
3009: oGetAddrLocal 6
3011: oPushResult
3012: oSetResult 0
3014: oAssign
3015: oGetLocal 6
3017: oPushResult
3018: oGetLocal 1
3020: oPushResult
3021: oNodeVecSize
3022: oPop 1
3024: oPushResult
3025: equal
3026: oPop 2
3028: oChoice 3085
3030: oGetAddrLocal 2
3032: oPushResult
3033: oGetLocal 1
3035: oPushResult
3036: oGetLocal 6
3038: oPushResult
3039: oNodeVecElement
3040: oPop 2
3042: oAssign
3043: oGetLocal 2
3045: oPushResult
3046: oSetResult 21
3048: oPushResult
3049: oGetLocal 4
3051: oPushResult
3052: oNodeSet
3053: oPop 3
3055: oGetLocal 2
3057: oPushResult
3058: oScopeDeclare
3059: oPop 1
3061: oGetLocal 2
3063: oPushResult
3064: oSetResult 22
3066: oPushResult
3067: oGetLocal 5
3069: oPushResult
3070: oScopeAllocType
3071: oPop 1
3073: oPushResult
3074: oNodeSetInt
3075: oPop 3
3077: oGetAddrLocal 6
3079: oPushResult
3080: inc
3081: oPop 1
3083: oJumpForward 3090
3085: Choice Lookup Table
           0   3030
3088: oJumpForward 3092
3090: oJumpBack 3015
3092: oGetLocal 1
3094: oPushResult
3095: oNodeVecDelete
3096: oPop 1
3098: oInputChoice 3106
3100: oJumpForward 3114
3102: oJumpForward 3112
3104: oJumpForward 3112
3106: Choice Lookup Table
           5   3104
          15   3100
3111: oEndChoice
3112: oJumpBack 2900
3114: oJumpForward 3119
3116: Choice Lookup Table
          14   2900
3119: oReturn
3120: oLocalSpace 0
3122: oInputChoice 3137
3124: oInputChoice 3130
3126: oCall 3203
3128: oJumpForward 3135
3130: Choice Lookup Table
          12   3126
3133: oCall 3145
3135: oJumpForward 3142
3137: Choice Lookup Table
           0   3124
3140: oJumpForward 3144
3142: oJumpBack 3122
3144: oReturn
3145: oLocalSpace 2
3147: oGetAddrLocal 1
3149: oPushResult
3150: oSetResult 16
3152: oPushResult
3153: LAST_ID
3154: oPushResult
3155: oCall 11059
3157: oPop 2
3159: oAssign
3160: oInput 6
3162: oCall 5086
3164: oGetAddrLocal 2
3166: oPushResult
3167: oValueTop
3168: oAssign
3169: oValuePop
3170: oGetLocal 1
3172: oPushResult
3173: oSetResult 22
3175: oPushResult
3176: oGetLocal 2
3178: oPushResult
3179: oNodeSetInt
3180: oPop 3
3182: oGetLocal 1
3184: oPushResult
3185: oSetResult 21
3187: oPushResult
3188: oGetGlobal 6
3190: oPushResult
3191: oNodeSet
3192: oPop 3
3194: oGetLocal 1
3196: oPushResult
3197: oScopeDeclare
3198: oPop 1
3200: oInput 5
3202: oReturn
3203: oLocalSpace 4
3205: oGetAddrLocal 1
3207: oPushResult
3208: oSetResult 24
3210: oPushResult
3211: LAST_ID
3212: oPushResult
3213: oCall 11059
3215: oPop 2
3217: oAssign
3218: oGetAddrLocal 2
3220: oPushResult
3221: oCall 4030
3223: oPop 1
3225: oGetLocal 1
3227: oPushResult
3228: oSetResult 21
3230: oPushResult
3231: oGetLocal 2
3233: oPushResult
3234: oNodeSet
3235: oPop 3
3237: oGetLocal 2
3239: oPushResult
3240: oNodeType
3241: oPop 1
3243: oChoice 3344
3245: oInput 6
3247: oCall 5086
3249: oGetAddrLocal 3
3251: oPushResult
3252: oValueTop
3253: oAssign
3254: oValuePop
3255: oGetLocal 1
3257: oPushResult
3258: oSetResult 22
3260: oPushResult
3261: oGetLocal 3
3263: oPushResult
3264: oNodeSetInt
3265: oPop 3
3267: oGetLocal 1
3269: oPushResult
3270: oScopeDeclare
3271: oPop 1
3273: oInput 5
3275: oJumpForward 3368
3277: oError 16
3279: oJumpForward 3368
3281: oGetGlobal 2
3283: oPushResult
3284: oScopeEnter
3285: oPop 1
3287: oGetAddrLocal 4
3289: oPushResult
3290: oGetLocal 2
3292: oPushResult
3293: oScopeAllocType
3294: oPop 1
3296: oAssign
3297: oScopeEnd
3298: oGetGlobal 2
3300: oPushResult
3301: oCall 1973
3303: oPop 1
3305: oPushResult
3306: oCodePush
3307: oPop 1
3309: oGetLocal 1
3311: oPushResult
3312: oSetResult 22
3314: oPushResult
3315: oGetLocal 4
3317: oPushResult
3318: oNodeSetInt
3319: oPop 3
3321: oInput 6
3323: oGetLocal 2
3325: oPushResult
3326: oGetLocal 4
3328: oPushResult
3329: oCall 3369
3331: oPop 2
3333: oCodePop
3334: oGetLocal 1
3336: oPushResult
3337: oScopeDeclare
3338: oPop 1
3340: oInput 5
3342: oJumpForward 3368
3344: Choice Lookup Table
          37   3281
          35   3281
          34   3277
          33   3277
          27   3277
          39   3277
          40   3245
          28   3245
          32   3245
          29   3245
          30   3245
3367: oEndChoice
3368: oReturn
3369: oLocalSpace 10
3371: oGetParam 2
3373: oPushResult
3374: oNodeType
3375: oPop 1
3377: oChoice 3650
3379: oGetAddrLocal 1
3381: oPushResult
3382: oGetParam 2
3384: oPushResult
3385: oSetResult 36
3387: oPushResult
3388: oNodeGet
3389: oPop 2
3391: oAssign
3392: oGetAddrLocal 2
3394: oPushResult
3395: oGetParam 2
3397: oPushResult
3398: oSetResult 37
3400: oPushResult
3401: oNodeGet
3402: oPop 2
3404: oAssign
3405: oGetAddrLocal 3
3407: oPushResult
3408: oGetLocal 2
3410: oPushResult
3411: oCall 11171
3413: oPop 1
3415: oAssign
3416: oGetAddrLocal 4
3418: oPushResult
3419: oGetLocal 2
3421: oPushResult
3422: oCall 11266
3424: oPop 1
3426: oAssign
3427: oGetAddrLocal 5
3429: oPushResult
3430: oGetLocal 1
3432: oPushResult
3433: oSetResult 17
3435: oPushResult
3436: oNodeGetInt
3437: oPop 2
3439: oAssign
3440: oInput 14
3442: oGetAddrLocal 6
3444: oPushResult
3445: oGetLocal 3
3447: oAssign
3448: oGetLocal 1
3450: oPushResult
3451: oGetParam 1
3453: oPushResult
3454: oCall 3369
3456: oPop 2
3458: oGetLocal 6
3460: oPushResult
3461: oGetLocal 4
3463: oPushResult
3464: equal
3465: oPop 2
3467: oChoice 3475
3469: oJumpForward 3504
3471: oJumpForward 3481
3473: oJumpForward 3481
3475: Choice Lookup Table
           0   3473
           1   3469
3480: oEndChoice
3481: oInput 13
3483: oGetAddrParam 1
3485: oPushResult
3486: oGetParam 1
3488: oPushResult
3489: oGetLocal 5
3491: oPushResult
3492: add
3493: oPop 2
3495: oAssign
3496: oGetAddrLocal 6
3498: oPushResult
3499: inc
3500: oPop 1
3502: oJumpBack 3448
3504: oInput 15
3506: oJumpForward 3674
3508: oInput 14
3510: oGetAddrLocal 7
3512: oPushResult
3513: oGetParam 2
3515: oPushResult
3516: oSetResult 40
3518: oPushResult
3519: oNodeGet
3520: oPop 2
3522: oAssign
3523: oInputChoice 3527
3525: oJumpForward 3532
3527: Choice Lookup Table
           0   3525
3530: oJumpForward 3598
3532: oGetAddrLocal 8
3534: oPushResult
3535: oGetLocal 7
3537: oPushResult
3538: oScopeFindRequireInScope
3539: oPop 1
3541: oAssign
3542: oInput 12
3544: oGetAddrLocal 9
3546: oPushResult
3547: oGetLocal 8
3549: oPushResult
3550: oSetResult 21
3552: oPushResult
3553: oNodeGet
3554: oPop 2
3556: oAssign
3557: oGetAddrLocal 10
3559: oPushResult
3560: oGetParam 1
3562: oPushResult
3563: oGetLocal 8
3565: oPushResult
3566: oSetResult 22
3568: oPushResult
3569: oNodeGetInt
3570: oPop 2
3572: oPushResult
3573: add
3574: oPop 2
3576: oAssign
3577: oGetLocal 9
3579: oPushResult
3580: oGetLocal 10
3582: oPushResult
3583: oCall 3369
3585: oPop 2
3587: oInputChoice 3591
3589: oJumpForward 3596
3591: Choice Lookup Table
           5   3589
3594: oJumpForward 3598
3596: oJumpBack 3523
3598: oInput 15
3600: oJumpForward 3674
3602: oEmit 16
3604: oGetParam 1
3606: oPushResult
3607: oEmitInt
3608: oPop 1
3610: oCall 5086
3612: oEmit 15
3614: oValueTop
3615: oPushResult
3616: oEmitInt
3617: oPop 1
3619: oValuePop
3620: oEmit 27
3622: oJumpForward 3674
3624: oEmit 16
3626: oGetParam 1
3628: oPushResult
3629: oEmitInt
3630: oPop 1
3632: oCall 5086
3634: oEmit 15
3636: oValueTop
3637: oPushResult
3638: oEmitInt
3639: oPop 1
3641: oValuePop
3642: oEmit 26
3644: oJumpForward 3674
3646: oError 16
3648: oJumpForward 3674
3650: Choice Lookup Table
          34   3646
          33   3646
          27   3646
          39   3646
          40   3624
          28   3624
          32   3602
          29   3602
          30   3602
          37   3508
          35   3379
3673: oEndChoice
3674: oReturn
3675: oLocalSpace 2
3677: oInputChoice 3723
3679: oGetAddrLocal 1
3681: oPushResult
3682: oSetResult 18
3684: oPushResult
3685: LAST_ID
3686: oPushResult
3687: oCall 11059
3689: oPop 2
3691: oAssign
3692: oInput 6
3694: oGetAddrLocal 2
3696: oPushResult
3697: oCall 4030
3699: oPop 1
3701: oGetLocal 1
3703: oPushResult
3704: oSetResult 21
3706: oPushResult
3707: oGetLocal 2
3709: oPushResult
3710: oNodeSet
3711: oPop 3
3713: oGetLocal 1
3715: oPushResult
3716: oScopeDeclare
3717: oPop 1
3719: oInput 5
3721: oJumpForward 3728
3723: Choice Lookup Table
           0   3679
3726: oJumpForward 3730
3728: oJumpBack 3677
3730: oReturn
3731: oLocalSpace 6
3733: oInputChoice 3957
3735: oGetAddrLocal 1
3737: oPushResult
3738: oNodeVecNew
3739: oAssign
3740: oGetAddrLocal 2
3742: oPushResult
3743: oGetParam 1
3745: oPushResult
3746: LAST_ID
3747: oPushResult
3748: oCall 11059
3750: oPop 2
3752: oAssign
3753: oGetLocal 1
3755: oPushResult
3756: oGetLocal 2
3758: oPushResult
3759: oNodeVecAppend
3760: oPop 2
3762: oInputChoice 3768
3764: oInput 0
3766: oJumpForward 3773
3768: Choice Lookup Table
          13   3764
3771: oJumpForward 3775
3773: oJumpBack 3740
3775: oInput 12
3777: oGetAddrLocal 3
3779: oPushResult
3780: oCall 4030
3782: oPop 1
3784: oGetAddrLocal 4
3786: oPushResult
3787: oSetResult 0
3789: oAssign
3790: oGetLocal 4
3792: oPushResult
3793: oGetLocal 1
3795: oPushResult
3796: oNodeVecSize
3797: oPop 1
3799: oPushResult
3800: equal
3801: oPop 2
3803: oChoice 3844
3805: oGetAddrLocal 2
3807: oPushResult
3808: oGetLocal 1
3810: oPushResult
3811: oGetLocal 4
3813: oPushResult
3814: oNodeVecElement
3815: oPop 2
3817: oAssign
3818: oGetLocal 2
3820: oPushResult
3821: oSetResult 21
3823: oPushResult
3824: oGetLocal 3
3826: oPushResult
3827: oNodeSet
3828: oPop 3
3830: oGetLocal 2
3832: oPushResult
3833: oScopeDeclareAlloc
3834: oPop 1
3836: oGetAddrLocal 4
3838: oPushResult
3839: inc
3840: oPop 1
3842: oJumpForward 3849
3844: Choice Lookup Table
           0   3805
3847: oJumpForward 3851
3849: oJumpBack 3790
3851: oInputChoice 3944
3853: oGetLocal 1
3855: oPushResult
3856: oNodeVecSize
3857: oPop 1
3859: oChoice 3863
3861: oJumpForward 3868
3863: Choice Lookup Table
           1   3861
3866: oError 22
3868: oGetAddrLocal 5
3870: oPushResult
3871: oScopeCurrent
3872: oPushResult
3873: oCall 1973
3875: oPop 1
3877: oAssign
3878: oGetLocal 5
3880: oPushResult
3881: oCodePush
3882: oPop 1
3884: oGetAddrLocal 6
3886: oPushResult
3887: oSetResult 0
3889: oAssign
3890: oCall 10797
3892: oPushResult
3893: equal_zero
3894: oPop 1
3896: oChoice 3912
3898: oGetGlobal 3
3900: oPushResult
3901: oScopeEnter
3902: oPop 1
3904: oGetAddrLocal 6
3906: oPushResult
3907: oSetResult 1
3909: oAssign
3910: oJumpForward 3915
3912: Choice Lookup Table
           1   3898
3915: oGetLocal 2
3917: oPushResult
3918: oSetResult 1
3920: oPushResult
3921: oCall 9955
3923: oPop 2
3925: oCall 5159
3927: oCall 8212
3929: oCall 9711
3931: oGetLocal 6
3933: oChoice 3938
3935: oScopeEnd
3936: oJumpForward 3941
3938: Choice Lookup Table
           1   3935
3941: oCodePop
3942: oJumpForward 3947
3944: Choice Lookup Table
           6   3853
3947: oGetLocal 1
3949: oPushResult
3950: oNodeVecDelete
3951: oPop 1
3953: oInput 5
3955: oJumpForward 3962
3957: Choice Lookup Table
           0   3735
3960: oJumpForward 3964
3962: oJumpBack 3733
3964: oReturn
3965: oLocalSpace 2
3967: oInputChoice 3974
3969: oJumpForward 3980
3971: oChangeIntLitToLabelIdent
3972: oJumpForward 3980
3974: Choice Lookup Table
           1   3971
           0   3969
3979: oEndChoice
3980: oGetAddrLocal 1
3982: oPushResult
3983: oSetResult 25
3985: oPushResult
3986: LAST_ID
3987: oPushResult
3988: oCall 11059
3990: oPop 2
3992: oAssign
3993: oGetAddrLocal 2
3995: oPushResult
3996: oLabelNew
3997: oAssign
3998: oGetLocal 1
4000: oPushResult
4001: oSetResult 22
4003: oPushResult
4004: oGetLocal 2
4006: oPushResult
4007: oNodeSetLabel
4008: oPop 3
4010: oGetLocal 1
4012: oPushResult
4013: oScopeDeclare
4014: oPop 1
4016: oInputChoice 4020
4018: oJumpForward 4025
4020: Choice Lookup Table
          13   4018
4023: oJumpForward 4027
4025: oJumpBack 3967
4027: oInput 5
4029: oReturn
4030: oLocalSpace 12
4032: oInputChoice 4505
4034: oGetAddrLocal 1
4036: oPushResult
4037: oScopeFindRequire
4038: oAssign
4039: oGetAddrLocal 1
4041: oPushResult
4042: oCall 526
4044: oPop 1
4046: oGetLocal 1
4048: oPushResult
4049: oNodeType
4050: oPop 1
4052: oChoice 4069
4054: oGetParam 1
4056: oPushResult
4057: oGetLocal 1
4059: oPushResult
4060: oSetResult 21
4062: oPushResult
4063: oNodeGet
4064: oPop 2
4066: oAssign
4067: oJumpForward 4080
4069: Choice Lookup Table
          18   4054
4072: oError 2
4074: oGetParam 1
4076: oPushResult
4077: oGetGlobal 6
4079: oAssign
4080: oJumpForward 4524
4082: oInput 16
4084: oGetAddrLocal 2
4086: oPushResult
4087: oNodeVecNew
4088: oAssign
4089: oGetAddrLocal 3
4091: oPushResult
4092: oSetResult 36
4094: oPushResult
4095: oNodeNew
4096: oPop 1
4098: oAssign
4099: oGetLocal 3
4101: oPushResult
4102: oSetResult 36
4104: oPushResult
4105: oGetGlobal 6
4107: oPushResult
4108: oNodeSet
4109: oPop 3
4111: oCall 5086
4113: oGetLocal 3
4115: oPushResult
4116: oSetResult 38
4118: oPushResult
4119: oValueTop
4120: oPushResult
4121: oNodeSetInt
4122: oPop 3
4124: oValuePop
4125: oInput 21
4127: oCall 5086
4129: oGetLocal 3
4131: oPushResult
4132: oSetResult 39
4134: oPushResult
4135: oValueTop
4136: oPushResult
4137: oNodeSetInt
4138: oPop 3
4140: oValuePop
4141: oGetLocal 3
4143: oPushResult
4144: oSetResult 17
4146: oPushResult
4147: oSetResult 4
4149: oPushResult
4150: oNodeSetInt
4151: oPop 3
4153: oGetLocal 3
4155: oPushResult
4156: oTypeAdd
4157: oPop 1
4159: oGetAddrLocal 4
4161: oPushResult
4162: oSetResult 35
4164: oPushResult
4165: oNodeNew
4166: oPop 1
4168: oAssign
4169: oGetLocal 4
4171: oPushResult
4172: oSetResult 37
4174: oPushResult
4175: oGetLocal 3
4177: oPushResult
4178: oNodeSet
4179: oPop 3
4181: oGetLocal 2
4183: oPushResult
4184: oGetLocal 4
4186: oPushResult
4187: oNodeVecAppend
4188: oPop 2
4190: oInputChoice 4198
4192: oJumpForward 4206
4194: oJumpForward 4204
4196: oJumpForward 4204
4198: Choice Lookup Table
          13   4196
          17   4192
4203: oEndChoice
4204: oJumpBack 4089
4206: oInput 40
4208: oGetAddrLocal 5
4210: oPushResult
4211: oCall 4030
4213: oPop 1
4215: oGetAddrLocal 6
4217: oPushResult
4218: oGetLocal 2
4220: oPushResult
4221: oNodeVecSize
4222: oPop 1
4224: oAssign
4225: oGetAddrLocal 6
4227: oPushResult
4228: dec
4229: oPop 1
4231: oGetAddrLocal 7
4233: oPushResult
4234: oGetLocal 2
4236: oPushResult
4237: oGetLocal 6
4239: oPushResult
4240: oNodeVecElement
4241: oPop 2
4243: oAssign
4244: oGetLocal 7
4246: oPushResult
4247: oSetResult 36
4249: oPushResult
4250: oGetLocal 5
4252: oPushResult
4253: oNodeSet
4254: oPop 3
4256: oGetAddrLocal 8
4258: oPushResult
4259: oGetLocal 7
4261: oPushResult
4262: oSetResult 37
4264: oPushResult
4265: oNodeGet
4266: oPop 2
4268: oAssign
4269: oGetAddrLocal 9
4271: oPushResult
4272: oGetLocal 8
4274: oPushResult
4275: oSetResult 39
4277: oPushResult
4278: oNodeGetInt
4279: oPop 2
4281: oPushResult
4282: oGetLocal 8
4284: oPushResult
4285: oSetResult 38
4287: oPushResult
4288: oNodeGetInt
4289: oPop 2
4291: oPushResult
4292: subtract
4293: oPop 2
4295: oAssign
4296: oGetAddrLocal 9
4298: oPushResult
4299: inc
4300: oPop 1
4302: oGetLocal 7
4304: oPushResult
4305: oSetResult 17
4307: oPushResult
4308: oGetLocal 9
4310: oPushResult
4311: oGetLocal 5
4313: oPushResult
4314: oSetResult 17
4316: oPushResult
4317: oNodeGetInt
4318: oPop 2
4320: oPushResult
4321: multiply
4322: oPop 2
4324: oPushResult
4325: oNodeSetInt
4326: oPop 3
4328: oGetLocal 7
4330: oPushResult
4331: oTypeAdd
4332: oPop 1
4334: oGetAddrLocal 5
4336: oPushResult
4337: oGetLocal 7
4339: oAssign
4340: oGetLocal 6
4342: oPushResult
4343: equal_zero
4344: oPop 1
4346: oChoice 4352
4348: oJumpForward 4357
4350: oJumpForward 4355
4352: Choice Lookup Table
           1   4348
4355: oJumpBack 4225
4357: oGetParam 1
4359: oPushResult
4360: oGetLocal 2
4362: oPushResult
4363: oSetResult 0
4365: oPushResult
4366: oNodeVecElement
4367: oPop 2
4369: oAssign
4370: oGetLocal 2
4372: oPushResult
4373: oNodeVecDelete
4374: oPop 1
4376: oJumpForward 4524
4378: oGetAddrLocal 10
4380: oPushResult
4381: oCall 4030
4383: oPop 1
4385: oGetParam 1
4387: oPushResult
4388: oGetLocal 10
4390: oPushResult
4391: oCall 11087
4393: oPop 1
4395: oAssign
4396: oJumpForward 4524
4398: oGetParam 1
4400: oPushResult
4401: oSetResult 37
4403: oPushResult
4404: oNodeNew
4405: oPop 1
4407: oAssign
4408: oSetResult -1
4410: oPushResult
4411: oSetResult 2
4413: oPushResult
4414: oScopeBegin
4415: oPop 2
4417: oSetResult 22
4419: oPushResult
4420: oCall 3731
4422: oPop 1
4424: oGetAddrLocal 11
4426: oPushResult
4427: oScopeCurrent
4428: oPushResult
4429: oSetResult 17
4431: oPushResult
4432: oNodeGetInt
4433: oPop 2
4435: oAssign
4436: oGetLocal 11
4438: oPushResult
4439: equal_zero
4440: oPop 1
4442: oChoice 4448
4444: oError 19
4446: oJumpForward 4451
4448: Choice Lookup Table
           1   4444
4451: oInput 36
4453: oGetFromParam 1
4455: oPushResult
4456: oSetResult 40
4458: oPushResult
4459: oScopeCurrent
4460: oPushResult
4461: oNodeSet
4462: oPop 3
4464: oGetFromParam 1
4466: oPushResult
4467: oSetResult 17
4469: oPushResult
4470: oGetLocal 11
4472: oPushResult
4473: oNodeSetInt
4474: oPop 3
4476: oScopeEnd
4477: oGetFromParam 1
4479: oPushResult
4480: oTypeAdd
4481: oPop 1
4483: oJumpForward 4524
4485: oGetParam 1
4487: oPushResult
4488: oCall 4525
4490: oPop 1
4492: oJumpForward 4524
4494: oInput 40
4496: oGetAddrLocal 12
4498: oPushResult
4499: oCall 4030
4501: oPop 1
4503: oJumpForward 4524
4505: Choice Lookup Table
          39   4494
          14   4485
          38   4398
          18   4378
          37   4082
           0   4034
4518: oCall 5086
4520: oInput 21
4522: oCall 5086
4524: oReturn
4525: oLocalSpace 11
4527: oGetParam 1
4529: oPushResult
4530: oSetResult 40
4532: oPushResult
4533: oNodeNew
4534: oPop 1
4536: oAssign
4537: oGetAddrLocal 1
4539: oPushResult
4540: oSetResult 0
4542: oAssign
4543: oGetAddrLocal 2
4545: oPushResult
4546: oSetResult 0
4548: oAssign
4549: oGetAddrLocal 3
4551: oPushResult
4552: oSetResult 1
4554: oAssign
4555: oGetAddrLocal 4
4557: oPushResult
4558: oScopeCurrent
4559: oAssign
4560: oSetResult -1
4562: oPushResult
4563: oSetResult 2
4565: oPushResult
4566: oScopeBegin
4567: oPop 2
4569: oInput 0
4571: oGetAddrLocal 5
4573: oPushResult
4574: oSetResult 17
4576: oPushResult
4577: LAST_ID
4578: oPushResult
4579: oCall 11059
4581: oPop 2
4583: oAssign
4584: oGetAddrLocal 6
4586: oPushResult
4587: oSetResult 17
4589: oPushResult
4590: LAST_ID
4591: oPushResult
4592: oCall 11059
4594: oPop 2
4596: oAssign
4597: oGetLocal 5
4599: oPushResult
4600: oSetResult 21
4602: oPushResult
4603: oGetFromParam 1
4605: oPushResult
4606: oNodeSet
4607: oPop 3
4609: oGetLocal 6
4611: oPushResult
4612: oSetResult 21
4614: oPushResult
4615: oGetFromParam 1
4617: oPushResult
4618: oNodeSet
4619: oPop 3
4621: oGetAddrLocal 7
4623: oPushResult
4624: LAST_ID
4625: oPushResult
4626: ID_STRING
4627: oPop 1
4629: oPushResult
4630: oStringAllocLit
4631: oPop 1
4633: oAssign
4634: oGetLocal 5
4636: oPushResult
4637: oSetResult 32
4639: oPushResult
4640: oGetLocal 7
4642: oPushResult
4643: oNodeSetInt
4644: oPop 3
4646: oGetLocal 6
4648: oPushResult
4649: oSetResult 32
4651: oPushResult
4652: oGetLocal 7
4654: oPushResult
4655: oNodeSetInt
4656: oPop 3
4658: oInputChoice 4727
4660: oCall 5086
4662: oGetLocal 2
4664: oPushResult
4665: equal_zero
4666: oPop 1
4668: oChoice 4689
4670: oValueTop
4671: oPushResult
4672: oGetLocal 1
4674: oPushResult
4675: greater
4676: oPop 2
4678: oChoice 4684
4680: oError 26
4682: oJumpForward 4687
4684: Choice Lookup Table
           0   4680
4687: oJumpForward 4692
4689: Choice Lookup Table
           0   4670
4692: oGetLocal 1
4694: oPushResult
4695: oValueTop
4696: oPushResult
4697: equal
4698: oPop 2
4700: oChoice 4716
4702: oGetFromParam 1
4704: oPushResult
4705: oSetResult 43
4707: oPushResult
4708: oSetResult 1
4710: oPushResult
4711: oNodeSetBoolean
4712: oPop 3
4714: oJumpForward 4719
4716: Choice Lookup Table
           0   4702
4719: oGetAddrLocal 1
4721: oPushResult
4722: oValueTop
4723: oAssign
4724: oValuePop
4725: oJumpForward 4732
4727: Choice Lookup Table
           4   4660
           6   4660
4732: oGetLocal 5
4734: oPushResult
4735: oSetResult 22
4737: oPushResult
4738: oGetLocal 1
4740: oPushResult
4741: oNodeSetInt
4742: oPop 3
4744: oGetLocal 6
4746: oPushResult
4747: oSetResult 22
4749: oPushResult
4750: oGetLocal 1
4752: oPushResult
4753: oNodeSetInt
4754: oPop 3
4756: oGetLocal 5
4758: oPushResult
4759: oScopeDeclare
4760: oPop 1
4762: oGetLocal 4
4764: oPushResult
4765: oScopeEnter
4766: oPop 1
4768: oGetLocal 6
4770: oPushResult
4771: oScopeDeclare
4772: oPop 1
4774: oScopeEnd
4775: oGetAddrLocal 1
4777: oPushResult
4778: inc
4779: oPop 1
4781: oGetAddrLocal 2
4783: oPushResult
4784: inc
4785: oPop 1
4787: oInputChoice 4791
4789: oJumpForward 4796
4791: Choice Lookup Table
          13   4789
4794: oJumpForward 4798
4796: oJumpBack 4569
4798: oInput 15
4800: oGetFromParam 1
4802: oPushResult
4803: oSetResult 40
4805: oPushResult
4806: oScopeCurrent
4807: oPushResult
4808: oNodeSet
4809: oPop 3
4811: oGetFromParam 1
4813: oPushResult
4814: oSetResult 17
4816: oPushResult
4817: oSetResult 4
4819: oPushResult
4820: oNodeSetInt
4821: oPop 3
4823: oScopeEnd
4824: oGetGlobal 2
4826: oPushResult
4827: oCall 1973
4829: oPop 1
4831: oPushResult
4832: oCodePush
4833: oPop 1
4835: oGetGlobal 2
4837: oPushResult
4838: oScopeEnter
4839: oPop 1
4841: oGetAddrLocal 8
4843: oPushResult
4844: oGetLocal 2
4846: oPushResult
4847: oSetResult 1
4849: oPushResult
4850: add
4851: oPop 2
4853: oPushResult
4854: oSetResult 16
4856: oPushResult
4857: multiply
4858: oPop 2
4860: oAssign
4861: oGetAddrLocal 9
4863: oPushResult
4864: oGetLocal 8
4866: oPushResult
4867: oSetResult 8
4869: oPushResult
4870: oScopeAlloc
4871: oPop 2
4873: oAssign
4874: oScopeEnd
4875: oGetFromParam 1
4877: oPushResult
4878: oSetResult 42
4880: oPushResult
4881: oGetLocal 9
4883: oPushResult
4884: oNodeSetInt
4885: oPop 3
4887: oGetAddrLocal 10
4889: oPushResult
4890: oGetFromParam 1
4892: oPushResult
4893: oSetResult 40
4895: oPushResult
4896: oNodeGet
4897: oPop 2
4899: oPushResult
4900: oSetResult 15
4902: oPushResult
4903: oNodeGetIter
4904: oPop 2
4906: oAssign
4907: oGetAddrLocal 11
4909: oPushResult
4910: oGetLocal 10
4912: oPushResult
4913: oNodeIterValue
4914: oPop 1
4916: oAssign
4917: oGetLocal 11
4919: oPushResult
4920: oNodeNull
4921: oPop 1
4923: oChoice 4929
4925: oJumpForward 5016
4927: oJumpForward 4932
4929: Choice Lookup Table
           1   4925
4932: oEmit 16
4934: oGetLocal 9
4936: oPushResult
4937: oEmitInt
4938: oPop 1
4940: oEmit 15
4942: oGetLocal 11
4944: oPushResult
4945: oSetResult 22
4947: oPushResult
4948: oNodeGetInt
4949: oPop 2
4951: oPushResult
4952: oEmitInt
4953: oPop 1
4955: oEmit 26
4957: oGetAddrLocal 9
4959: oPushResult
4960: oGetLocal 9
4962: oPushResult
4963: oSetResult 8
4965: oPushResult
4966: add
4967: oPop 2
4969: oAssign
4970: oEmit 16
4972: oGetLocal 9
4974: oPushResult
4975: oEmitInt
4976: oPop 1
4978: oEmit 16
4980: oGetLocal 11
4982: oPushResult
4983: oSetResult 32
4985: oPushResult
4986: oNodeGetInt
4987: oPop 2
4989: oPushResult
4990: oEmitInt
4991: oPop 1
4993: oEmit 28
4995: oGetAddrLocal 9
4997: oPushResult
4998: oGetLocal 9
5000: oPushResult
5001: oSetResult 8
5003: oPushResult
5004: add
5005: oPop 2
5007: oAssign
5008: oGetAddrLocal 10
5010: oPushResult
5011: oNodeIterNext
5012: oPop 1
5014: oJumpBack 4907
5016: oEmit 16
5018: oGetLocal 9
5020: oPushResult
5021: oEmitInt
5022: oPop 1
5024: oEmit 15
5026: oSetResult 0
5028: oPushResult
5029: oEmitInt
5030: oPop 1
5032: oEmit 26
5034: oGetAddrLocal 9
5036: oPushResult
5037: oGetLocal 9
5039: oPushResult
5040: oSetResult 8
5042: oPushResult
5043: add
5044: oPop 2
5046: oAssign
5047: oEmit 16
5049: oGetLocal 9
5051: oPushResult
5052: oEmitInt
5053: oPop 1
5055: oEmit 15
5057: oSetResult 0
5059: oPushResult
5060: oEmitInt
5061: oPop 1
5063: oEmit 28
5065: oGetAddrLocal 9
5067: oPushResult
5068: oGetLocal 9
5070: oPushResult
5071: oSetResult 8
5073: oPushResult
5074: add
5075: oPop 2
5077: oAssign
5078: oCodePop
5079: oGetFromParam 1
5081: oPushResult
5082: oTypeAdd
5083: oPop 1
5085: oReturn
5086: oLocalSpace 1
5088: oInputChoice 5150
5090: TOKEN_VALUE
5091: oPushResult
5092: oValuePush
5093: oPop 1
5095: oJumpForward 5158
5097: oGetAddrLocal 1
5099: oPushResult
5100: oScopeFindRequire
5101: oAssign
5102: oGetAddrLocal 1
5104: oPushResult
5105: oCall 526
5107: oPop 1
5109: oGetLocal 1
5111: oPushResult
5112: oNodeType
5113: oPop 1
5115: oChoice 5132
5117: oGetLocal 1
5119: oPushResult
5120: oSetResult 22
5122: oPushResult
5123: oNodeGetInt
5124: oPop 2
5126: oPushResult
5127: oValuePush
5128: oPop 1
5130: oJumpForward 5143
5132: Choice Lookup Table
          16   5117
5135: oError 1
5137: oSetResult 0
5139: oPushResult
5140: oValuePush
5141: oPop 1
5143: oJumpForward 5158
5145: oCall 5086
5147: oValueNegate
5148: oJumpForward 5158
5150: Choice Lookup Table
          25   5145
           0   5097
           1   5090
5157: oEndChoice
5158: oReturn
5159: oLocalSpace 1
5161: oGetAddrLocal 1
5163: oPushResult
5164: oSetResult 0
5166: oAssign
5167: oGetAddrLocal 1
5169: oPushResult
5170: oCall 5320
5172: oPop 1
5174: oGetAddrLocal 1
5176: oPushResult
5177: oCall 5220
5179: oPop 1
5181: oReturn
5182: oLocalSpace 0
5184: oGetParam 1
5186: oPushResult
5187: oCall 5320
5189: oPop 1
5191: oTypeSNodeType
5192: oChoice 5211
5194: oJumpForward 5218
5196: oGetParam 1
5198: oPushResult
5199: oLabelNew
5200: oAssign
5201: oEmit 70
5203: oGetFromParam 1
5205: oPushResult
5206: oEmitLabel
5207: oPop 1
5209: oJumpForward 5218
5211: Choice Lookup Table
          30   5196
          31   5194
5216: oError 8
5218: oTypeSPop
5219: oReturn
5220: oLocalSpace 1
5222: oTypeSNodeType
5223: oChoice 5285
5225: oGetAddrLocal 1
5227: oPushResult
5228: oLabelNew
5229: oAssign
5230: oEmit 15
5232: oSetResult 1
5234: oPushResult
5235: oEmitInt
5236: oPop 1
5238: oEmit 68
5240: oGetLocal 1
5242: oPushResult
5243: oEmitLabel
5244: oPop 1
5246: oEmit 71
5248: oGetFromParam 1
5250: oPushResult
5251: oEmitLabel
5252: oPop 1
5254: oEmit 15
5256: oSetResult 0
5258: oPushResult
5259: oEmitInt
5260: oPop 1
5262: oEmit 71
5264: oGetLocal 1
5266: oPushResult
5267: oEmitLabel
5268: oPop 1
5270: oTypeSPop
5271: oGetGlobal 7
5273: oPushResult
5274: oTypeSPush
5275: oPop 1
5277: oGetParam 1
5279: oPushResult
5280: oSetResult 0
5282: oAssign
5283: oJumpForward 5288
5285: Choice Lookup Table
          31   5225
5288: oReturn
5289: oLocalSpace 0
5291: oTypeSNodeType
5292: oChoice 5316
5294: oGetParam 1
5296: oPushResult
5297: oLabelNew
5298: oAssign
5299: oEmit 70
5301: oGetFromParam 1
5303: oPushResult
5304: oEmitLabel
5305: oPop 1
5307: oTypeSPop
5308: oGetGlobal 8
5310: oPushResult
5311: oTypeSPush
5312: oPop 1
5314: oJumpForward 5319
5316: Choice Lookup Table
          30   5294
5319: oReturn
5320: oLocalSpace 0
5322: oGetParam 1
5324: oPushResult
5325: oCall 5793
5327: oPop 1
5329: oInputChoice 5775
5331: oGetParam 1
5333: oPushResult
5334: oCall 5220
5336: oPop 1
5338: oCall 10978
5340: oGetParam 1
5342: oPushResult
5343: oCall 5793
5345: oPop 1
5347: oGetParam 1
5349: oPushResult
5350: oCall 5220
5352: oPop 1
5354: oCall 10978
5356: oCall 10847
5358: oTypeSNodeType
5359: oChoice 5377
5361: oEmit 43
5363: oJumpForward 5396
5365: oEmit 49
5367: oJumpForward 5396
5369: oEmit 55
5371: oJumpForward 5396
5373: oError 16
5375: oJumpForward 5396
5377: Choice Lookup Table
          38   5373
          39   5373
          34   5369
          33   5369
          40   5365
          28   5365
          32   5361
          30   5361
5394: oError 17
5396: oTypeSPop
5397: oGetGlobal 7
5399: oPushResult
5400: oTypeSPush
5401: oPop 1
5403: oJumpForward 5790
5405: oGetParam 1
5407: oPushResult
5408: oCall 5220
5410: oPop 1
5412: oCall 10978
5414: oGetParam 1
5416: oPushResult
5417: oCall 5793
5419: oPop 1
5421: oGetParam 1
5423: oPushResult
5424: oCall 5220
5426: oPop 1
5428: oCall 10978
5430: oCall 10847
5432: oTypeSNodeType
5433: oChoice 5451
5435: oEmit 44
5437: oJumpForward 5470
5439: oEmit 50
5441: oJumpForward 5470
5443: oEmit 56
5445: oJumpForward 5470
5447: oError 16
5449: oJumpForward 5470
5451: Choice Lookup Table
          38   5447
          39   5447
          34   5443
          33   5443
          40   5439
          28   5439
          32   5435
          30   5435
5468: oError 17
5470: oTypeSPop
5471: oGetGlobal 7
5473: oPushResult
5474: oTypeSPush
5475: oPop 1
5477: oJumpForward 5790
5479: oGetParam 1
5481: oPushResult
5482: oCall 5220
5484: oPop 1
5486: oCall 10978
5488: oGetParam 1
5490: oPushResult
5491: oCall 5793
5493: oPop 1
5495: oGetParam 1
5497: oPushResult
5498: oCall 5220
5500: oPop 1
5502: oCall 10978
5504: oCall 10847
5506: oTypeSNodeType
5507: oChoice 5525
5509: oEmit 46
5511: oJumpForward 5544
5513: oEmit 52
5515: oJumpForward 5544
5517: oEmit 58
5519: oJumpForward 5544
5521: oError 16
5523: oJumpForward 5544
5525: Choice Lookup Table
          38   5521
          39   5521
          34   5517
          33   5517
          40   5513
          28   5513
          32   5509
          30   5509
5542: oError 17
5544: oTypeSPop
5545: oGetGlobal 7
5547: oPushResult
5548: oTypeSPush
5549: oPop 1
5551: oJumpForward 5790
5553: oGetParam 1
5555: oPushResult
5556: oCall 5220
5558: oPop 1
5560: oCall 10978
5562: oGetParam 1
5564: oPushResult
5565: oCall 5793
5567: oPop 1
5569: oGetParam 1
5571: oPushResult
5572: oCall 5220
5574: oPop 1
5576: oCall 10978
5578: oCall 10847
5580: oTypeSNodeType
5581: oChoice 5599
5583: oEmit 45
5585: oJumpForward 5618
5587: oEmit 51
5589: oJumpForward 5618
5591: oEmit 57
5593: oJumpForward 5618
5595: oError 16
5597: oJumpForward 5618
5599: Choice Lookup Table
          38   5595
          39   5595
          34   5591
          33   5591
          40   5587
          28   5587
          32   5583
          30   5583
5616: oError 17
5618: oTypeSPop
5619: oGetGlobal 7
5621: oPushResult
5622: oTypeSPush
5623: oPop 1
5625: oJumpForward 5790
5627: oGetParam 1
5629: oPushResult
5630: oCall 5220
5632: oPop 1
5634: oCall 10978
5636: oGetParam 1
5638: oPushResult
5639: oCall 5793
5641: oPop 1
5643: oGetParam 1
5645: oPushResult
5646: oCall 5220
5648: oPop 1
5650: oCall 10978
5652: oCall 10847
5654: oTypeSNodeType
5655: oChoice 5673
5657: oEmit 48
5659: oJumpForward 5692
5661: oEmit 54
5663: oJumpForward 5692
5665: oEmit 60
5667: oJumpForward 5692
5669: oError 16
5671: oJumpForward 5692
5673: Choice Lookup Table
          38   5669
          39   5669
          34   5665
          33   5665
          40   5661
          28   5661
          32   5657
          30   5657
5690: oError 17
5692: oTypeSPop
5693: oGetGlobal 7
5695: oPushResult
5696: oTypeSPush
5697: oPop 1
5699: oJumpForward 5790
5701: oGetParam 1
5703: oPushResult
5704: oCall 5220
5706: oPop 1
5708: oCall 10978
5710: oGetParam 1
5712: oPushResult
5713: oCall 5793
5715: oPop 1
5717: oGetParam 1
5719: oPushResult
5720: oCall 5220
5722: oPop 1
5724: oCall 10978
5726: oCall 10847
5728: oTypeSNodeType
5729: oChoice 5747
5731: oEmit 47
5733: oJumpForward 5766
5735: oEmit 53
5737: oJumpForward 5766
5739: oEmit 59
5741: oJumpForward 5766
5743: oError 16
5745: oJumpForward 5766
5747: Choice Lookup Table
          38   5743
          39   5743
          34   5739
          33   5739
          40   5735
          28   5735
          32   5731
          30   5731
5764: oError 17
5766: oTypeSPop
5767: oGetGlobal 7
5769: oPushResult
5770: oTypeSPush
5771: oPop 1
5773: oJumpForward 5790
5775: Choice Lookup Table
          11   5701
          10   5627
           9   5553
           8   5479
           7   5405
           6   5331
5788: oJumpForward 5792
5790: oJumpBack 5329
5792: oReturn
5793: oLocalSpace 1
5795: oGetAddrLocal 1
5797: oPushResult
5798: oSetResult 0
5800: oAssign
5801: oGetParam 1
5803: oPushResult
5804: oCall 5973
5806: oPop 1
5808: oInputChoice 5941
5810: oTypeSNodeType
5811: oChoice 5882
5813: oGetLocal 1
5815: oPushResult
5816: oSetResult 0
5818: oPushResult
5819: equal_label
5820: oPop 2
5822: oChoice 5831
5824: oGetAddrLocal 1
5826: oPushResult
5827: oLabelNew
5828: oAssign
5829: oJumpForward 5834
5831: Choice Lookup Table
           1   5824
5834: oEmit 68
5836: oGetLocal 1
5838: oPushResult
5839: oEmitLabel
5840: oPop 1
5842: oJumpForward 5889
5844: oGetParam 1
5846: oPushResult
5847: oCall 5289
5849: oPop 1
5851: oGetLocal 1
5853: oPushResult
5854: oSetResult 0
5856: oPushResult
5857: equal_label
5858: oPop 2
5860: oChoice 5869
5862: oGetAddrLocal 1
5864: oPushResult
5865: oLabelNew
5866: oAssign
5867: oJumpForward 5872
5869: Choice Lookup Table
           1   5862
5872: oEmit 68
5874: oGetLocal 1
5876: oPushResult
5877: oEmitLabel
5878: oPop 1
5880: oJumpForward 5889
5882: Choice Lookup Table
          30   5844
          31   5813
5887: oError 8
5889: oTypeSPop
5890: oEmit 71
5892: oGetFromParam 1
5894: oPushResult
5895: oEmitLabel
5896: oPop 1
5898: oGetParam 1
5900: oPushResult
5901: oSetResult 0
5903: oAssign
5904: oGetParam 1
5906: oPushResult
5907: oCall 5973
5909: oPop 1
5911: oTypeSNodeType
5912: oChoice 5925
5914: oJumpForward 5932
5916: oGetParam 1
5918: oPushResult
5919: oCall 5289
5921: oPop 1
5923: oJumpForward 5932
5925: Choice Lookup Table
          30   5916
          31   5914
5930: oError 8
5932: oTypeSPop
5933: oGetGlobal 8
5935: oPushResult
5936: oTypeSPush
5937: oPop 1
5939: oJumpForward 5946
5941: Choice Lookup Table
          55   5810
5944: oJumpForward 5948
5946: oJumpBack 5808
5948: oGetLocal 1
5950: oPushResult
5951: oSetResult 0
5953: oPushResult
5954: equal_label
5955: oPop 2
5957: oChoice 5969
5959: oEmit 71
5961: oGetLocal 1
5963: oPushResult
5964: oEmitLabel
5965: oPop 1
5967: oJumpForward 5972
5969: Choice Lookup Table
           0   5959
5972: oReturn
5973: oLocalSpace 2
5975: oGetAddrLocal 1
5977: oPushResult
5978: oSetResult 0
5980: oAssign
5981: oGetParam 1
5983: oPushResult
5984: oCall 6111
5986: oPop 1
5988: oInputChoice 6103
5990: oTypeSNodeType
5991: oChoice 6004
5993: oJumpForward 6011
5995: oGetParam 1
5997: oPushResult
5998: oCall 5289
6000: oPop 1
6002: oJumpForward 6011
6004: Choice Lookup Table
          30   5995
          31   5993
6009: oError 8
6011: oTypeSPop
6012: oGetLocal 1
6014: oPushResult
6015: oSetResult 0
6017: oPushResult
6018: equal_label
6019: oPop 2
6021: oChoice 6050
6023: oGetAddrLocal 1
6025: oPushResult
6026: oLabelNew
6027: oAssign
6028: oEmit 72
6030: oGetFromParam 1
6032: oPushResult
6033: oEmitLabel
6034: oPop 1
6036: oGetLocal 1
6038: oPushResult
6039: oEmitLabel
6040: oPop 1
6042: oGetParam 1
6044: oPushResult
6045: oGetLocal 1
6047: oAssign
6048: oJumpForward 6053
6050: Choice Lookup Table
           1   6023
6053: oGetAddrLocal 2
6055: oPushResult
6056: oSetResult 0
6058: oAssign
6059: oGetAddrLocal 2
6061: oPushResult
6062: oCall 6111
6064: oPop 1
6066: oTypeSNodeType
6067: oChoice 6080
6069: oJumpForward 6087
6071: oGetAddrLocal 2
6073: oPushResult
6074: oCall 5289
6076: oPop 1
6078: oJumpForward 6087
6080: Choice Lookup Table
          30   6071
          31   6069
6085: oError 8
6087: oEmit 72
6089: oGetLocal 2
6091: oPushResult
6092: oEmitLabel
6093: oPop 1
6095: oGetLocal 1
6097: oPushResult
6098: oEmitLabel
6099: oPop 1
6101: oJumpForward 6108
6103: Choice Lookup Table
          54   5990
6106: oJumpForward 6110
6108: oJumpBack 5988
6110: oReturn
6111: oLocalSpace 1
6113: oInputChoice 6167
6115: oGetAddrLocal 1
6117: oPushResult
6118: oSetResult 0
6120: oAssign
6121: oGetAddrLocal 1
6123: oPushResult
6124: oCall 6111
6126: oPop 1
6128: oTypeSNodeType
6129: oChoice 6158
6131: oGetParam 1
6133: oPushResult
6134: oLabelNew
6135: oAssign
6136: oEmit 68
6138: oGetFromParam 1
6140: oPushResult
6141: oEmitLabel
6142: oPop 1
6144: oEmit 71
6146: oGetLocal 1
6148: oPushResult
6149: oEmitLabel
6150: oPop 1
6152: oJumpForward 6165
6154: oEmit 42
6156: oJumpForward 6165
6158: Choice Lookup Table
          30   6154
          31   6131
6163: oError 8
6165: oJumpForward 6177
6167: Choice Lookup Table
          56   6115
6170: oGetParam 1
6172: oPushResult
6173: oCall 6178
6175: oPop 1
6177: oReturn
6178: oLocalSpace 2
6180: oGetAddrLocal 1
6182: oPushResult
6183: oSetResult 1
6185: oAssign
6186: oGetParam 1
6188: oPushResult
6189: oCall 6414
6191: oPop 1
6193: oInputChoice 6404
6195: oTypeSNodeType
6196: oChoice 6319
6198: oCall 10932
6200: oGetParam 1
6202: oPushResult
6203: oCall 6414
6205: oPop 1
6207: oTypeSNodeType
6208: oChoice 6216
6210: oEmit 22
6212: oCall 7997
6214: oJumpForward 6225
6216: Choice Lookup Table
          34   6210
          33   6210
6221: oCall 10952
6223: oEmit 37
6225: oJumpForward 6336
6227: oGetLocal 1
6229: oChoice 6245
6231: oGetAddrLocal 2
6233: oPushResult
6234: oCall 8346
6236: oAssign
6237: oGetAddrLocal 1
6239: oPushResult
6240: oSetResult 0
6242: oAssign
6243: oJumpForward 6248
6245: Choice Lookup Table
           1   6231
6248: oGetParam 1
6250: oPushResult
6251: oCall 6414
6253: oPop 1
6255: oTypeSNodeType
6256: oChoice 6294
6258: oCall 8455
6260: oEmit 17
6262: oGetLocal 2
6264: oPushResult
6265: oEmitInt
6266: oPop 1
6268: oGetGlobal 14
6270: oPushResult
6271: oTypeSPush
6272: oPop 1
6274: oJumpForward 6304
6276: oCall 8509
6278: oEmit 17
6280: oGetLocal 2
6282: oPushResult
6283: oEmitInt
6284: oPop 1
6286: oGetGlobal 14
6288: oPushResult
6289: oTypeSPush
6290: oPop 1
6292: oJumpForward 6304
6294: Choice Lookup Table
          32   6276
          38   6258
          39   6258
6301: oError 14
6303: oTypeSPop
6304: oJumpForward 6336
6306: oGetParam 1
6308: oPushResult
6309: oCall 6414
6311: oPop 1
6313: oCall 10932
6315: oCall 7997
6317: oJumpForward 6336
6319: Choice Lookup Table
          34   6306
          33   6306
          32   6227
          38   6227
          39   6227
          29   6198
          28   6198
6334: oError 17
6336: oJumpForward 6411
6338: oTypeSNodeType
6339: oChoice 6391
6341: oCall 10932
6343: oGetParam 1
6345: oPushResult
6346: oCall 6414
6348: oPop 1
6350: oCall 10952
6352: oEmit 40
6354: oJumpForward 6402
6356: oGetParam 1
6358: oPushResult
6359: oCall 6414
6361: oPop 1
6363: oTypeSNodeType
6364: oChoice 6378
6366: oCall 10932
6368: oCall 8053
6370: oJumpForward 6389
6372: oCall 10847
6374: oCall 8109
6376: oJumpForward 6389
6378: Choice Lookup Table
          34   6372
          33   6372
          29   6366
          28   6366
6387: oError 17
6389: oJumpForward 6402
6391: Choice Lookup Table
          34   6356
          33   6356
          29   6341
          28   6341
6400: oError 17
6402: oJumpForward 6411
6404: Choice Lookup Table
          25   6338
          24   6195
6409: oJumpForward 6413
6411: oJumpBack 6193
6413: oReturn
6414: oLocalSpace 0
6416: oGetParam 1
6418: oPushResult
6419: oCall 6465
6421: oPop 1
6423: oInputChoice 6455
6425: oCall 10932
6427: oGetParam 1
6429: oPushResult
6430: oCall 6465
6432: oPop 1
6434: oCall 10952
6436: oEmit 34
6438: oJumpForward 6462
6440: oCall 10932
6442: oGetParam 1
6444: oPushResult
6445: oCall 6465
6447: oPop 1
6449: oCall 10952
6451: oEmit 35
6453: oJumpForward 6462
6455: Choice Lookup Table
          23   6440
          22   6425
6460: oJumpForward 6464
6462: oJumpBack 6423
6464: oReturn
6465: oLocalSpace 0
6467: oInputChoice 6493
6469: oGetParam 1
6471: oPushResult
6472: oCall 6506
6474: oPop 1
6476: oCall 10952
6478: oJumpForward 6505
6480: oGetParam 1
6482: oPushResult
6483: oCall 6506
6485: oPop 1
6487: oCall 10952
6489: oEmit 41
6491: oJumpForward 6505
6493: Choice Lookup Table
          25   6480
          24   6469
6498: oGetParam 1
6500: oPushResult
6501: oCall 6506
6503: oPop 1
6505: oReturn
6506: oLocalSpace 6
6508: oInputChoice 6762
6510: oEmit 15
6512: TOKEN_VALUE
6513: oPushResult
6514: oEmitInt
6515: oPop 1
6517: oGetGlobal 6
6519: oPushResult
6520: oTypeSPush
6521: oPop 1
6523: oJumpForward 6783
6525: oEmit 15
6527: TOKEN_VALUE
6528: oPushResult
6529: oEmitInt
6530: oPop 1
6532: oGetGlobal 9
6534: oPushResult
6535: oTypeSPush
6536: oPop 1
6538: oJumpForward 6783
6540: oGetParam 1
6542: oPushResult
6543: oCall 5320
6545: oPop 1
6547: oInput 15
6549: oJumpForward 6783
6551: oGetAddrLocal 1
6553: oPushResult
6554: CURRENT_STRLIT
6555: oPushResult
6556: oStringAllocShortStringLit
6557: oPop 1
6559: oAssign
6560: oEmit 16
6562: oGetLocal 1
6564: oPushResult
6565: oEmitInt
6566: oPop 1
6568: oGetGlobal 13
6570: oPushResult
6571: oTypeSPush
6572: oPop 1
6574: oCall 7595
6576: oCall 7541
6578: oJumpForward 6783
6580: oGetAddrLocal 2
6582: oPushResult
6583: oScopeFindRequire
6584: oAssign
6585: oGetAddrLocal 2
6587: oPushResult
6588: oCall 526
6590: oPop 1
6592: oGetLocal 2
6594: oPushResult
6595: oNodeType
6596: oPop 1
6598: oChoice 6686
6600: oGetLocal 2
6602: oPushResult
6603: oCall 8646
6605: oPop 1
6607: oJumpForward 6711
6609: oGetLocal 2
6611: oPushResult
6612: oCall 9266
6614: oPop 1
6616: oJumpForward 6711
6618: oGetAddrLocal 3
6620: oPushResult
6621: oGetLocal 2
6623: oPushResult
6624: oSetResult 21
6626: oPushResult
6627: oNodeGet
6628: oPop 2
6630: oAssign
6631: oGetLocal 3
6633: oPushResult
6634: oTypeSPush
6635: oPop 1
6637: oTypeSNodeType
6638: oChoice 6662
6640: oEmit 15
6642: oGetLocal 2
6644: oPushResult
6645: oCall 11361
6647: oPop 1
6649: oJumpForward 6675
6651: oEmit 15
6653: oGetLocal 2
6655: oPushResult
6656: oCall 11361
6658: oPop 1
6660: oJumpForward 6675
6662: Choice Lookup Table
          34   6651
          33   6651
          30   6640
          40   6640
          28   6640
6673: oError 16
6675: oJumpForward 6711
6677: oGetLocal 2
6679: oPushResult
6680: oCall 6784
6682: oPop 1
6684: oJumpForward 6711
6686: Choice Lookup Table
          24   6677
          23   6677
          21   6677
          20   6677
          17   6618
          16   6618
          14   6609
          13   6600
6703: oError 6
6705: oGetGlobal 6
6707: oPushResult
6708: oTypeSPush
6709: oPop 1
6711: oJumpForward 6783
6713: oInput 0
6715: oGetAddrLocal 4
6717: oPushResult
6718: oScopeFindRequire
6719: oAssign
6720: oGetAddrLocal 4
6722: oPushResult
6723: oCall 526
6725: oPop 1
6727: oGetLocal 4
6729: oPushResult
6730: oSetResult 0
6732: oPushResult
6733: oCall 9955
6735: oPop 2
6737: oGetAddrLocal 5
6739: oPushResult
6740: oTypeSTop
6741: oAssign
6742: oTypeSPop
6743: oGetAddrLocal 6
6745: oPushResult
6746: oGetLocal 5
6748: oPushResult
6749: oCall 11087
6751: oPop 1
6753: oAssign
6754: oGetLocal 6
6756: oPushResult
6757: oTypeSPush
6758: oPop 1
6760: oJumpForward 6783
6762: Choice Lookup Table
          19   6713
           0   6580
           2   6551
          14   6540
           3   6525
           1   6510
6775: oError 6
6777: oGetGlobal 6
6779: oPushResult
6780: oTypeSPush
6781: oPop 1
6783: oReturn
6784: oLocalSpace 2
6786: oGetAddrLocal 1
6788: oPushResult
6789: oGetParam 1
6791: oPushResult
6792: oSetResult 21
6794: oPushResult
6795: oNodeGet
6796: oPop 2
6798: oAssign
6799: oGetAddrLocal 2
6801: oPushResult
6802: oGetParam 1
6804: oPushResult
6805: oCall 10829
6807: oPop 1
6809: oAssign
6810: oGetLocal 1
6812: oPushResult
6813: oTypeSPush
6814: oPop 1
6816: oTypeSNodeType
6817: oChoice 7516
6819: oGetParam 1
6821: oPushResult
6822: oNodeType
6823: oPop 1
6825: oChoice 6971
6827: oEmit 0
6829: oGetParam 1
6831: oPushResult
6832: oCall 11361
6834: oPop 1
6836: oJumpForward 6981
6838: oGetLocal 2
6840: oPushResult
6841: equal_zero
6842: oPop 1
6844: oChoice 6857
6846: oEmit 3
6848: oGetParam 1
6850: oPushResult
6851: oCall 11361
6853: oPop 1
6855: oJumpForward 6875
6857: Choice Lookup Table
           1   6846
6860: oEmit 9
6862: oGetLocal 2
6864: oPushResult
6865: oEmitInt
6866: oPop 1
6868: oGetParam 1
6870: oPushResult
6871: oCall 11361
6873: oPop 1
6875: oJumpForward 6981
6877: oGetParam 1
6879: oPushResult
6880: oSetResult 33
6882: oPushResult
6883: oNodeGetBoolean
6884: oPop 2
6886: oChoice 6929
6888: oGetLocal 2
6890: oPushResult
6891: equal_zero
6892: oPop 1
6894: oChoice 6907
6896: oEmit 8
6898: oGetParam 1
6900: oPushResult
6901: oCall 11361
6903: oPop 1
6905: oJumpForward 6925
6907: Choice Lookup Table
           1   6896
6910: oEmit 14
6912: oGetLocal 2
6914: oPushResult
6915: oEmitInt
6916: oPop 1
6918: oGetParam 1
6920: oPushResult
6921: oCall 11361
6923: oPop 1
6925: oEmit 23
6927: oJumpForward 6969
6929: Choice Lookup Table
           1   6888
6932: oGetLocal 2
6934: oPushResult
6935: equal_zero
6936: oPop 1
6938: oChoice 6951
6940: oEmit 6
6942: oGetParam 1
6944: oPushResult
6945: oCall 11361
6947: oPop 1
6949: oJumpForward 6969
6951: Choice Lookup Table
           1   6940
6954: oEmit 12
6956: oGetLocal 2
6958: oPushResult
6959: oEmitInt
6960: oPop 1
6962: oGetParam 1
6964: oPushResult
6965: oCall 11361
6967: oPop 1
6969: oJumpForward 6981
6971: Choice Lookup Table
          23   6877
          21   6838
          24   6827
          20   6827
6980: oEndChoice
6981: oJumpForward 7540
6983: oGetParam 1
6985: oPushResult
6986: oNodeType
6987: oPop 1
6989: oChoice 7135
6991: oEmit 1
6993: oGetParam 1
6995: oPushResult
6996: oCall 11361
6998: oPop 1
7000: oJumpForward 7145
7002: oGetLocal 2
7004: oPushResult
7005: equal_zero
7006: oPop 1
7008: oChoice 7021
7010: oEmit 4
7012: oGetParam 1
7014: oPushResult
7015: oCall 11361
7017: oPop 1
7019: oJumpForward 7039
7021: Choice Lookup Table
           1   7010
7024: oEmit 10
7026: oGetLocal 2
7028: oPushResult
7029: oEmitInt
7030: oPop 1
7032: oGetParam 1
7034: oPushResult
7035: oCall 11361
7037: oPop 1
7039: oJumpForward 7145
7041: oGetParam 1
7043: oPushResult
7044: oSetResult 33
7046: oPushResult
7047: oNodeGetBoolean
7048: oPop 2
7050: oChoice 7093
7052: oGetLocal 2
7054: oPushResult
7055: equal_zero
7056: oPop 1
7058: oChoice 7071
7060: oEmit 8
7062: oGetParam 1
7064: oPushResult
7065: oCall 11361
7067: oPop 1
7069: oJumpForward 7089
7071: Choice Lookup Table
           1   7060
7074: oEmit 14
7076: oGetLocal 2
7078: oPushResult
7079: oEmitInt
7080: oPop 1
7082: oGetParam 1
7084: oPushResult
7085: oCall 11361
7087: oPop 1
7089: oEmit 24
7091: oJumpForward 7133
7093: Choice Lookup Table
           1   7052
7096: oGetLocal 2
7098: oPushResult
7099: equal_zero
7100: oPop 1
7102: oChoice 7115
7104: oEmit 7
7106: oGetParam 1
7108: oPushResult
7109: oCall 11361
7111: oPop 1
7113: oJumpForward 7133
7115: Choice Lookup Table
           1   7104
7118: oEmit 13
7120: oGetLocal 2
7122: oPushResult
7123: oEmitInt
7124: oPop 1
7126: oGetParam 1
7128: oPushResult
7129: oCall 11361
7131: oPop 1
7133: oJumpForward 7145
7135: Choice Lookup Table
          23   7041
          21   7002
          24   6991
          20   6991
7144: oEndChoice
7145: oJumpForward 7540
7147: oError 16
7149: oJumpForward 7540
7151: oGetParam 1
7153: oPushResult
7154: oNodeType
7155: oPop 1
7157: oChoice 7303
7159: oEmit 2
7161: oGetParam 1
7163: oPushResult
7164: oCall 11361
7166: oPop 1
7168: oJumpForward 7313
7170: oGetLocal 2
7172: oPushResult
7173: equal_zero
7174: oPop 1
7176: oChoice 7189
7178: oEmit 5
7180: oGetParam 1
7182: oPushResult
7183: oCall 11361
7185: oPop 1
7187: oJumpForward 7207
7189: Choice Lookup Table
           1   7178
7192: oEmit 11
7194: oGetLocal 2
7196: oPushResult
7197: oEmitInt
7198: oPop 1
7200: oGetParam 1
7202: oPushResult
7203: oCall 11361
7205: oPop 1
7207: oJumpForward 7313
7209: oGetParam 1
7211: oPushResult
7212: oSetResult 33
7214: oPushResult
7215: oNodeGetBoolean
7216: oPop 2
7218: oChoice 7261
7220: oGetLocal 2
7222: oPushResult
7223: equal_zero
7224: oPop 1
7226: oChoice 7239
7228: oEmit 8
7230: oGetParam 1
7232: oPushResult
7233: oCall 11361
7235: oPop 1
7237: oJumpForward 7257
7239: Choice Lookup Table
           1   7228
7242: oEmit 14
7244: oGetLocal 2
7246: oPushResult
7247: oEmitInt
7248: oPop 1
7250: oGetParam 1
7252: oPushResult
7253: oCall 11361
7255: oPop 1
7257: oEmit 25
7259: oJumpForward 7301
7261: Choice Lookup Table
           1   7220
7264: oGetLocal 2
7266: oPushResult
7267: equal_zero
7268: oPop 1
7270: oChoice 7283
7272: oEmit 8
7274: oGetParam 1
7276: oPushResult
7277: oCall 11361
7279: oPop 1
7281: oJumpForward 7301
7283: Choice Lookup Table
           1   7272
7286: oEmit 14
7288: oGetLocal 2
7290: oPushResult
7291: oEmitInt
7292: oPop 1
7294: oGetParam 1
7296: oPushResult
7297: oCall 11361
7299: oPop 1
7301: oJumpForward 7313
7303: Choice Lookup Table
          23   7209
          21   7170
          24   7159
          20   7159
7312: oEndChoice
7313: oInputChoice 7343
7315: oTypeSPop
7316: oGetLocal 1
7318: oPushResult
7319: oSetResult 36
7321: oPushResult
7322: oNodeGet
7323: oPop 2
7325: oPushResult
7326: oTypeSPush
7327: oPop 1
7329: oCall 7595
7331: oCall 7541
7333: oJumpForward 7348
7335: oCall 7790
7337: oCall 7595
7339: oCall 7541
7341: oJumpForward 7348
7343: Choice Lookup Table
          16   7335
          18   7315
7348: oJumpForward 7540
7350: oGetParam 1
7352: oPushResult
7353: oNodeType
7354: oPop 1
7356: oChoice 7500
7358: oEmit 16
7360: oGetParam 1
7362: oPushResult
7363: oCall 11361
7365: oPop 1
7367: oJumpForward 7510
7369: oGetLocal 2
7371: oPushResult
7372: equal_zero
7373: oPop 1
7375: oChoice 7388
7377: oEmit 17
7379: oGetParam 1
7381: oPushResult
7382: oCall 11361
7384: oPop 1
7386: oJumpForward 7406
7388: Choice Lookup Table
           1   7377
7391: oEmit 20
7393: oGetLocal 2
7395: oPushResult
7396: oEmitInt
7397: oPop 1
7399: oGetParam 1
7401: oPushResult
7402: oCall 11361
7404: oPop 1
7406: oJumpForward 7510
7408: oGetParam 1
7410: oPushResult
7411: oSetResult 33
7413: oPushResult
7414: oNodeGetBoolean
7415: oPop 2
7417: oChoice 7458
7419: oGetLocal 2
7421: oPushResult
7422: equal_zero
7423: oPop 1
7425: oChoice 7438
7427: oEmit 8
7429: oGetParam 1
7431: oPushResult
7432: oCall 11361
7434: oPop 1
7436: oJumpForward 7456
7438: Choice Lookup Table
           1   7427
7441: oEmit 14
7443: oGetLocal 2
7445: oPushResult
7446: oEmitInt
7447: oPop 1
7449: oGetParam 1
7451: oPushResult
7452: oCall 11361
7454: oPop 1
7456: oJumpForward 7498
7458: Choice Lookup Table
           1   7419
7461: oGetLocal 2
7463: oPushResult
7464: equal_zero
7465: oPop 1
7467: oChoice 7480
7469: oEmit 18
7471: oGetParam 1
7473: oPushResult
7474: oCall 11361
7476: oPop 1
7478: oJumpForward 7498
7480: Choice Lookup Table
           1   7469
7483: oEmit 21
7485: oGetLocal 2
7487: oPushResult
7488: oEmitInt
7489: oPop 1
7491: oGetParam 1
7493: oPushResult
7494: oCall 11361
7496: oPop 1
7498: oJumpForward 7510
7500: Choice Lookup Table
          23   7408
          21   7369
          24   7358
          20   7358
7509: oEndChoice
7510: oCall 7595
7512: oCall 7541
7514: oJumpForward 7540
7516: Choice Lookup Table
          39   7350
          37   7350
          35   7350
          34   7151
          33   7151
          27   7147
          32   6983
          29   6983
          30   6983
          40   6819
          28   6819
7539: oEndChoice
7540: oReturn
7541: oLocalSpace 0
7543: oTypeSNodeType
7544: oChoice 7568
7546: oEmit 23
7548: oJumpForward 7594
7550: oEmit 24
7552: oJumpForward 7594
7554: oError 16
7556: oJumpForward 7594
7558: oEmit 25
7560: oJumpForward 7594
7562: oError 29
7564: oJumpForward 7594
7566: oJumpForward 7594
7568: Choice Lookup Table
          39   7566
          38   7566
          37   7566
          35   7566
          34   7562
          33   7558
          27   7554
          32   7550
          29   7550
          30   7550
          40   7546
          28   7546
7593: oEndChoice
7594: oReturn
7595: oLocalSpace 0
7597: oInputChoice 7635
7599: oTypeSNodeType
7600: oChoice 7614
7602: oCall 7647
7604: oJumpForward 7625
7606: oCall 7790
7608: oJumpForward 7625
7610: oCall 7869
7612: oJumpForward 7625
7614: Choice Lookup Table
          39   7610
          38   7610
          33   7606
          35   7602
7623: oError 10
7625: oJumpForward 7644
7627: oCall 7899
7629: oJumpForward 7644
7631: oCall 8172
7633: oJumpForward 7644
7635: Choice Lookup Table
          18   7631
          20   7627
          16   7599
7642: oJumpForward 7646
7644: oJumpBack 7597
7646: oReturn
7647: oLocalSpace 3
7649: oTypeSNodeType
7650: oChoice 7654
7652: oJumpForward 7659
7654: Choice Lookup Table
          35   7652
7657: oError 10
7659: oTypeSNodeType
7660: oChoice 7664
7662: oJumpForward 7669
7664: Choice Lookup Table
          35   7662
7667: oError 13
7669: oGetAddrLocal 1
7671: oPushResult
7672: oTypeSTop
7673: oPushResult
7674: oSetResult 37
7676: oPushResult
7677: oNodeGet
7678: oPop 2
7680: oPushResult
7681: oCall 11171
7683: oPop 1
7685: oAssign
7686: oGetAddrLocal 2
7688: oPushResult
7689: oTypeSTop
7690: oPushResult
7691: oSetResult 36
7693: oPushResult
7694: oNodeGet
7695: oPop 2
7697: oAssign
7698: oTypeSPop
7699: oGetLocal 2
7701: oPushResult
7702: oTypeSPush
7703: oPop 1
7705: oCall 5159
7707: oCall 10905
7709: oGetLocal 1
7711: oPushResult
7712: equal_zero
7713: oPop 1
7715: oChoice 7729
7717: oEmit 15
7719: oGetLocal 1
7721: oPushResult
7722: oEmitInt
7723: oPop 1
7725: oEmit 40
7727: oJumpForward 7732
7729: Choice Lookup Table
           0   7717
7732: oGetAddrLocal 3
7734: oPushResult
7735: oGetLocal 2
7737: oPushResult
7738: oSetResult 17
7740: oPushResult
7741: oNodeGetInt
7742: oPop 2
7744: oAssign
7745: oGetLocal 3
7747: oPushResult
7748: oSetResult 1
7750: oPushResult
7751: equal
7752: oPop 2
7754: oChoice 7768
7756: oEmit 15
7758: oGetLocal 3
7760: oPushResult
7761: oEmitInt
7762: oPop 1
7764: oEmit 34
7766: oJumpForward 7771
7768: Choice Lookup Table
           0   7756
7771: oEmit 36
7773: oInputChoice 7781
7775: oJumpForward 7789
7777: oJumpForward 7787
7779: oJumpForward 7787
7781: Choice Lookup Table
          13   7779
          17   7775
7786: oEndChoice
7787: oJumpBack 7659
7789: oReturn
7790: oLocalSpace 2
7792: oTypeSNodeType
7793: oChoice 7797
7795: oJumpForward 7802
7797: Choice Lookup Table
          33   7795
7800: oError 29
7802: oGetAddrLocal 1
7804: oPushResult
7805: oTypeSTop
7806: oPushResult
7807: oSetResult 36
7809: oPushResult
7810: oNodeGet
7811: oPop 2
7813: oAssign
7814: oTypeSPop
7815: oGetLocal 1
7817: oPushResult
7818: oTypeSPush
7819: oPop 1
7821: oCall 5159
7823: oCall 10905
7825: oGetAddrLocal 2
7827: oPushResult
7828: oGetLocal 1
7830: oPushResult
7831: oSetResult 17
7833: oPushResult
7834: oNodeGetInt
7835: oPop 2
7837: oAssign
7838: oGetLocal 2
7840: oPushResult
7841: oSetResult 1
7843: oPushResult
7844: equal
7845: oPop 2
7847: oChoice 7861
7849: oEmit 15
7851: oGetLocal 2
7853: oPushResult
7854: oEmitInt
7855: oPop 1
7857: oEmit 34
7859: oJumpForward 7864
7861: Choice Lookup Table
           0   7849
7864: oEmit 36
7866: oInput 17
7868: oReturn
7869: oLocalSpace 0
7871: oTypeSNodeType
7872: oChoice 7876
7874: oJumpForward 7883
7876: Choice Lookup Table
          39   7874
          38   7874
7881: oError 29
7883: oTypeSPop
7884: oGetGlobal 9
7886: oPushResult
7887: oTypeSPush
7888: oPop 1
7890: oCall 5159
7892: oCall 10905
7894: oEmit 36
7896: oInput 17
7898: oReturn
7899: oLocalSpace 2
7901: oTypeSNodeType
7902: oChoice 7906
7904: oJumpForward 7911
7906: Choice Lookup Table
          37   7904
7909: oError 11
7911: oTypeSTop
7912: oPushResult
7913: oSetResult 40
7915: oPushResult
7916: oNodeGet
7917: oPop 2
7919: oPushResult
7920: oScopeEnter
7921: oPop 1
7923: oInput 0
7925: oGetAddrLocal 1
7927: oPushResult
7928: oScopeFindRequire
7929: oAssign
7930: oGetLocal 1
7932: oPushResult
7933: oNodeType
7934: oPop 1
7936: oChoice 7940
7938: oJumpForward 7945
7940: Choice Lookup Table
          22   7938
7943: oError 12
7945: oScopeEnd
7946: oGetAddrLocal 2
7948: oPushResult
7949: oGetLocal 1
7951: oPushResult
7952: oSetResult 22
7954: oPushResult
7955: oNodeGetInt
7956: oPop 2
7958: oAssign
7959: oGetLocal 2
7961: oPushResult
7962: equal_zero
7963: oPop 1
7965: oChoice 7979
7967: oEmit 15
7969: oGetLocal 2
7971: oPushResult
7972: oEmitInt
7973: oPop 1
7975: oEmit 36
7977: oJumpForward 7982
7979: Choice Lookup Table
           0   7967
7982: oTypeSPop
7983: oGetLocal 1
7985: oPushResult
7986: oSetResult 21
7988: oPushResult
7989: oNodeGet
7990: oPop 2
7992: oPushResult
7993: oTypeSPush
7994: oPop 1
7996: oReturn
7997: oLocalSpace 2
7999: oGetAddrLocal 1
8001: oPushResult
8002: oTypeSTop
8003: oPushResult
8004: oSetResult 36
8006: oPushResult
8007: oNodeGet
8008: oPop 2
8010: oAssign
8011: oGetAddrLocal 2
8013: oPushResult
8014: oGetLocal 1
8016: oPushResult
8017: oSetResult 17
8019: oPushResult
8020: oNodeGetInt
8021: oPop 2
8023: oAssign
8024: oGetLocal 2
8026: oPushResult
8027: oSetResult 1
8029: oPushResult
8030: equal
8031: oPop 2
8033: oChoice 8047
8035: oEmit 15
8037: oGetLocal 2
8039: oPushResult
8040: oEmitInt
8041: oPop 1
8043: oEmit 34
8045: oJumpForward 8050
8047: Choice Lookup Table
           0   8035
8050: oEmit 36
8052: oReturn
8053: oLocalSpace 2
8055: oGetAddrLocal 1
8057: oPushResult
8058: oTypeSTop
8059: oPushResult
8060: oSetResult 36
8062: oPushResult
8063: oNodeGet
8064: oPop 2
8066: oAssign
8067: oGetAddrLocal 2
8069: oPushResult
8070: oGetLocal 1
8072: oPushResult
8073: oSetResult 17
8075: oPushResult
8076: oNodeGetInt
8077: oPop 2
8079: oAssign
8080: oGetLocal 2
8082: oPushResult
8083: oSetResult 1
8085: oPushResult
8086: equal
8087: oPop 2
8089: oChoice 8103
8091: oEmit 15
8093: oGetLocal 2
8095: oPushResult
8096: oEmitInt
8097: oPop 1
8099: oEmit 34
8101: oJumpForward 8106
8103: Choice Lookup Table
           0   8091
8106: oEmit 39
8108: oReturn
8109: oLocalSpace 2
8111: oEmit 38
8113: oGetAddrLocal 1
8115: oPushResult
8116: oTypeSTop
8117: oPushResult
8118: oSetResult 36
8120: oPushResult
8121: oNodeGet
8122: oPop 2
8124: oAssign
8125: oGetAddrLocal 2
8127: oPushResult
8128: oGetLocal 1
8130: oPushResult
8131: oSetResult 17
8133: oPushResult
8134: oNodeGetInt
8135: oPop 2
8137: oAssign
8138: oGetLocal 2
8140: oPushResult
8141: oSetResult 1
8143: oPushResult
8144: equal
8145: oPop 2
8147: oChoice 8161
8149: oEmit 15
8151: oGetLocal 2
8153: oPushResult
8154: oEmitInt
8155: oPop 1
8157: oEmit 35
8159: oJumpForward 8164
8161: Choice Lookup Table
           0   8149
8164: oTypeSPop
8165: oGetGlobal 6
8167: oPushResult
8168: oTypeSPush
8169: oPop 1
8171: oReturn
8172: oLocalSpace 1
8174: oTypeSNodeType
8175: oChoice 8183
8177: oJumpForward 8190
8179: oError 29
8181: oJumpForward 8190
8183: Choice Lookup Table
          34   8179
          33   8177
8188: oError 9
8190: oEmit 25
8192: oGetAddrLocal 1
8194: oPushResult
8195: oTypeSTop
8196: oAssign
8197: oTypeSPop
8198: oGetLocal 1
8200: oPushResult
8201: oSetResult 36
8203: oPushResult
8204: oNodeGet
8205: oPop 2
8207: oPushResult
8208: oTypeSPush
8209: oPop 1
8211: oReturn
8212: oLocalSpace 1
8214: oGetAddrLocal 1
8216: oPushResult
8217: oTypeSNodeType
8218: oAssign
8219: oTypeSPop
8220: oGetLocal 1
8222: oPushResult
8223: oTypeSNodeType
8224: oPushResult
8225: equal_node_type
8226: oPop 2
8228: oChoice 8342
8230: oTypeSNodeType
8231: oChoice 8327
8233: oGetLocal 1
8235: oChoice 8242
8237: oEmit 30
8239: oReturn
8240: oJumpForward 8245
8242: Choice Lookup Table
          29   8237
8245: oJumpForward 8338
8247: oGetLocal 1
8249: oChoice 8256
8251: oEmit 31
8253: oReturn
8254: oJumpForward 8259
8256: Choice Lookup Table
          28   8251
8259: oJumpForward 8338
8261: oGetLocal 1
8263: oChoice 8296
8265: oReturn
8266: oJumpForward 8301
8268: oTypeSTop
8269: oPushResult
8270: oGetGlobal 10
8272: oPushResult
8273: equal_node
8274: oPop 2
8276: oChoice 8291
8278: oEmit 15
8280: oSetResult 1
8282: oPushResult
8283: oEmitInt
8284: oPop 1
8286: oEmit 36
8288: oReturn
8289: oJumpForward 8294
8291: Choice Lookup Table
           1   8278
8294: oJumpForward 8301
8296: Choice Lookup Table
          38   8268
          34   8265
8301: oJumpForward 8338
8303: oGetLocal 1
8305: oChoice 8310
8307: oReturn
8308: oJumpForward 8313
8310: Choice Lookup Table
          33   8307
8313: oJumpForward 8338
8315: oGetLocal 1
8317: oChoice 8322
8319: oReturn
8320: oJumpForward 8325
8322: Choice Lookup Table
          38   8319
8325: oJumpForward 8338
8327: Choice Lookup Table
          39   8315
          34   8303
          33   8261
          29   8247
          28   8233
8338: oError 14
8340: oJumpForward 8345
8342: Choice Lookup Table
           0   8230
8345: oReturn
8346: oLocalSpace 1
8348: oGetAddrLocal 1
8350: oPushResult
8351: oGetGlobal 14
8353: oPushResult
8354: oScopeAllocType
8355: oPop 1
8357: oAssign
8358: oTypeSNodeType
8359: oChoice 8427
8361: oEmit 17
8363: oGetLocal 1
8365: oPushResult
8366: oEmitInt
8367: oPop 1
8369: oEmit 22
8371: oEmit 29
8373: oGetGlobal 14
8375: oPushResult
8376: oSetResult 17
8378: oPushResult
8379: oNodeGetInt
8380: oPop 2
8382: oPushResult
8383: oEmitInt
8384: oPop 1
8386: oJumpForward 8436
8388: oEmit 17
8390: oGetLocal 1
8392: oPushResult
8393: oEmitInt
8394: oPop 1
8396: oEmit 15
8398: oSetResult 1
8400: oPushResult
8401: oEmitInt
8402: oPop 1
8404: oEmit 27
8406: oEmit 17
8408: oGetLocal 1
8410: oPushResult
8411: oSetResult 1
8413: oPushResult
8414: add
8415: oPop 2
8417: oPushResult
8418: oEmitInt
8419: oPop 1
8421: oEmit 22
8423: oEmit 27
8425: oJumpForward 8436
8427: Choice Lookup Table
          32   8388
          38   8361
          39   8361
8434: oError 14
8436: oTypeSPop
8437: oEmit 17
8439: oGetLocal 1
8441: oPushResult
8442: oEmitInt
8443: oPop 1
8445: oGetGlobal 14
8447: oPushResult
8448: oTypeSPush
8449: oPop 1
8451: oGetLocal 1
8453: oReturn
8454: oReturn
8455: oLocalSpace 0
8457: oEmit 61
8459: oSetResult 16
8461: oPushResult
8462: oEmitInt
8463: oPop 1
8465: oEmit 19
8467: oSetResult 8
8469: oPushResult
8470: oEmitInt
8471: oPop 1
8473: oEmit 22
8475: oEmit 28
8477: oEmit 19
8479: oSetResult 0
8481: oPushResult
8482: oEmitInt
8483: oPop 1
8485: oEmit 22
8487: oEmit 28
8489: oEmit 64
8491: oGetGlobal 19
8493: oPushResult
8494: oCall 11361
8496: oPop 1
8498: oEmit 63
8500: oSetResult 16
8502: oPushResult
8503: oEmitInt
8504: oPop 1
8506: oTypeSPop
8507: oTypeSPop
8508: oReturn
8509: oLocalSpace 0
8511: oEmit 61
8513: oSetResult 12
8515: oPushResult
8516: oEmitInt
8517: oPop 1
8519: oEmit 19
8521: oSetResult 8
8523: oPushResult
8524: oEmitInt
8525: oPop 1
8527: oEmit 22
8529: oEmit 26
8531: oEmit 19
8533: oSetResult 0
8535: oPushResult
8536: oEmitInt
8537: oPop 1
8539: oEmit 22
8541: oEmit 28
8543: oEmit 64
8545: oGetGlobal 20
8547: oPushResult
8548: oCall 11361
8550: oPop 1
8552: oEmit 63
8554: oSetResult 12
8556: oPushResult
8557: oEmitInt
8558: oPop 1
8560: oTypeSPop
8561: oTypeSPop
8562: oReturn
8563: oLocalSpace 2
8565: oGetAddrLocal 2
8567: oPushResult
8568: oGetParam 1
8570: oPushResult
8571: oSetResult 26
8573: oPushResult
8574: oNodeGetString
8575: oPop 2
8577: oAssign
8578: oGetLocal 2
8580: oPushResult
8581: oSetResult 0
8583: oPushResult
8584: equal_string
8585: oPop 2
8587: oChoice 8624
8589: oGetAddrLocal 1
8591: oPushResult
8592: oGetParam 1
8594: oPushResult
8595: oSetResult 4
8597: oPushResult
8598: oNodeGetInt
8599: oPop 2
8601: oPushResult
8602: ID_STRING
8603: oPop 1
8605: oPushResult
8606: oStringAllocLit
8607: oPop 1
8609: oAssign
8610: oJumpForward 8630
8612: oGetAddrLocal 1
8614: oPushResult
8615: oGetLocal 2
8617: oPushResult
8618: oStringAllocLit
8619: oPop 1
8621: oAssign
8622: oJumpForward 8630
8624: Choice Lookup Table
           0   8612
           1   8589
8629: oEndChoice
8630: oEmit 73
8632: oGetParam 1
8634: oPushResult
8635: oCall 11361
8637: oPop 1
8639: oGetLocal 1
8641: oPushResult
8642: oEmitInt
8643: oPop 1
8645: oReturn
8646: oLocalSpace 10
8648: oGetParam 1
8650: oPushResult
8651: oSetResult 25
8653: oPushResult
8654: oNodeGetBoolean
8655: oPop 2
8657: oChoice 8684
8659: oGetParam 1
8661: oPushResult
8662: oSetResult 28
8664: oPushResult
8665: oNodeGetBoolean
8666: oPop 2
8668: oChoice 8679
8670: oGetParam 1
8672: oPushResult
8673: oCall 8563
8675: oPop 1
8677: oJumpForward 8682
8679: Choice Lookup Table
           0   8670
8682: oJumpForward 8687
8684: Choice Lookup Table
           1   8659
8687: oGetParam 1
8689: oPushResult
8690: oSetResult 28
8692: oPushResult
8693: oSetResult 1
8695: oPushResult
8696: oNodeSetBoolean
8697: oPop 3
8699: oGetAddrLocal 1
8701: oPushResult
8702: oGetParam 1
8704: oPushResult
8705: oSetResult 27
8707: oPushResult
8708: oNodeGetBoolean
8709: oPop 2
8711: oAssign
8712: oGetAddrLocal 4
8714: oPushResult
8715: oGetParam 1
8717: oPushResult
8718: oNodeType
8719: oPop 1
8721: oPushResult
8722: oSetResult 13
8724: oPushResult
8725: equal_node_type
8726: oPop 2
8728: oAssign
8729: oGetLocal 4
8731: oChoice 8758
8733: oGetAddrLocal 2
8735: oPushResult
8736: oGetParam 1
8738: oPushResult
8739: oSetResult 21
8741: oPushResult
8742: oNodeGet
8743: oPop 2
8745: oAssign
8746: oGetAddrLocal 3
8748: oPushResult
8749: oGetLocal 2
8751: oPushResult
8752: oScopeAllocType
8753: oPop 1
8755: oAssign
8756: oJumpForward 8761
8758: Choice Lookup Table
           1   8733
8761: oGetAddrLocal 5
8763: oPushResult
8764: oGetParam 1
8766: oPushResult
8767: oSetResult 23
8769: oPushResult
8770: oNodeGet
8771: oPop 2
8773: oAssign
8774: oGetAddrLocal 6
8776: oPushResult
8777: oGetLocal 5
8779: oPushResult
8780: oSetResult 17
8782: oPushResult
8783: oNodeGetInt
8784: oPop 2
8786: oAssign
8787: oGetLocal 1
8789: oChoice 8811
8791: oEmit 62
8793: oGetLocal 6
8795: oPushResult
8796: oEmitInt
8797: oPop 1
8799: oJumpForward 8817
8801: oEmit 61
8803: oGetLocal 6
8805: oPushResult
8806: oEmitInt
8807: oPop 1
8809: oJumpForward 8817
8811: Choice Lookup Table
           0   8801
           1   8791
8816: oEndChoice
8817: oGetParam 1
8819: oPushResult
8820: oCall 10809
8822: oPop 1
8824: oPushResult
8825: oSetResult 0
8827: oPushResult
8828: greater
8829: oPop 2
8831: oChoice 8864
8833: oEmit 19
8835: oSetResult 0
8837: oPushResult
8838: oEmitInt
8839: oPop 1
8841: oEmit 20
8843: oGetParam 1
8845: oPushResult
8846: oCall 10829
8848: oPop 1
8850: oPushResult
8851: oEmitInt
8852: oPop 1
8854: oSetResult 0
8856: oPushResult
8857: oEmitInt
8858: oPop 1
8860: oEmit 28
8862: oJumpForward 8867
8864: Choice Lookup Table
           1   8833
8867: oGetAddrLocal 7
8869: oPushResult
8870: oGetLocal 5
8872: oPushResult
8873: oSetResult 15
8875: oPushResult
8876: oNodeGetIter
8877: oPop 2
8879: oAssign
8880: oGetAddrLocal 8
8882: oPushResult
8883: oGetLocal 7
8885: oPushResult
8886: oNodeIterValue
8887: oPop 1
8889: oAssign
8890: oInputChoice 9087
8892: oGetLocal 8
8894: oPushResult
8895: oNodeNull
8896: oPop 1
8898: oChoice 8904
8900: oJumpForward 9083
8902: oJumpForward 8907
8904: Choice Lookup Table
           1   8900
8907: oGetAddrLocal 9
8909: oPushResult
8910: oGetLocal 8
8912: oPushResult
8913: oSetResult 22
8915: oPushResult
8916: oNodeGetInt
8917: oPop 2
8919: oAssign
8920: oEmit 19
8922: oGetLocal 9
8924: oPushResult
8925: oEmitInt
8926: oPop 1
8928: oGetLocal 8
8930: oPushResult
8931: oSetResult 21
8933: oPushResult
8934: oNodeGet
8935: oPop 2
8937: oPushResult
8938: oTypeSPush
8939: oPop 1
8941: oGetLocal 8
8943: oPushResult
8944: oSetResult 33
8946: oPushResult
8947: oNodeGetBoolean
8948: oPop 2
8950: oChoice 9036
8952: oSetResult 1
8954: oPushResult
8955: oCall 9907
8957: oPop 1
8959: oCall 10847
8961: oEmit 28
8963: oJumpForward 9042
8965: oCall 5159
8967: oCall 8212
8969: oTypeSNodeType
8970: oChoice 9010
8972: oEmit 26
8974: oJumpForward 9034
8976: oEmit 27
8978: oJumpForward 9034
8980: oError 16
8982: oJumpForward 9034
8984: oEmit 28
8986: oJumpForward 9034
8988: oGetAddrLocal 10
8990: oPushResult
8991: oTypeSTop
8992: oPushResult
8993: oSetResult 17
8995: oPushResult
8996: oNodeGetInt
8997: oPop 2
8999: oAssign
9000: oEmit 29
9002: oGetLocal 10
9004: oPushResult
9005: oEmitInt
9006: oPop 1
9008: oJumpForward 9034
9010: Choice Lookup Table
          39   8988
          37   8988
          35   8988
          34   8984
          33   8984
          27   8980
          32   8976
          29   8976
          30   8976
          40   8972
          28   8972
9033: oEndChoice
9034: oJumpForward 9042
9036: Choice Lookup Table
           0   8965
           1   8952
9041: oEndChoice
9042: oTypeSPop
9043: oGetAddrLocal 7
9045: oPushResult
9046: oNodeIterNext
9047: oPop 1
9049: oGetAddrLocal 8
9051: oPushResult
9052: oGetLocal 7
9054: oPushResult
9055: oNodeIterValue
9056: oPop 1
9058: oAssign
9059: oGetLocal 8
9061: oPushResult
9062: oNodeNull
9063: oPop 1
9065: oChoice 9073
9067: oJumpForward 9083
9069: oJumpForward 9079
9071: oJumpForward 9079
9073: Choice Lookup Table
           0   9071
           1   9067
9078: oEndChoice
9079: oInput 13
9081: oJumpBack 8892
9083: oInput 15
9085: oJumpForward 9090
9087: Choice Lookup Table
          14   8892
9090: oGetLocal 8
9092: oPushResult
9093: oNodeNull
9094: oPop 1
9096: oChoice 9102
9098: oError 15
9100: oJumpForward 9105
9102: Choice Lookup Table
           0   9098
9105: oGetLocal 4
9107: oChoice 9136
9109: oEmit 19
9111: oGetParam 1
9113: oPushResult
9114: oSetResult 31
9116: oPushResult
9117: oNodeGetInt
9118: oPop 2
9120: oPushResult
9121: oEmitInt
9122: oPop 1
9124: oEmit 17
9126: oGetLocal 3
9128: oPushResult
9129: oEmitInt
9130: oPop 1
9132: oEmit 28
9134: oJumpForward 9139
9136: Choice Lookup Table
           1   9109
9139: oGetLocal 1
9141: oChoice 9165
9143: oEmit 65
9145: oGetParam 1
9147: oPushResult
9148: oCall 11361
9150: oPop 1
9152: oJumpForward 9171
9154: oEmit 64
9156: oGetParam 1
9158: oPushResult
9159: oCall 11361
9161: oPop 1
9163: oJumpForward 9171
9165: Choice Lookup Table
           0   9154
           1   9143
9170: oEndChoice
9171: oGetLocal 4
9173: oChoice 9254
9175: oGetLocal 2
9177: oPushResult
9178: oTypeSPush
9179: oPop 1
9181: oTypeSNodeType
9182: oChoice 9228
9184: oEmit 3
9186: oGetLocal 3
9188: oPushResult
9189: oEmitInt
9190: oPop 1
9192: oJumpForward 9252
9194: oEmit 4
9196: oGetLocal 3
9198: oPushResult
9199: oEmitInt
9200: oPop 1
9202: oJumpForward 9252
9204: oError 16
9206: oJumpForward 9252
9208: oEmit 5
9210: oGetLocal 3
9212: oPushResult
9213: oEmitInt
9214: oPop 1
9216: oJumpForward 9252
9218: oEmit 17
9220: oGetLocal 3
9222: oPushResult
9223: oEmitInt
9224: oPop 1
9226: oJumpForward 9252
9228: Choice Lookup Table
          39   9218
          37   9218
          35   9218
          34   9208
          33   9208
          27   9204
          32   9194
          29   9194
          30   9194
          40   9184
          28   9184
9251: oEndChoice
9252: oJumpForward 9257
9254: Choice Lookup Table
           1   9175
9257: oEmit 63
9259: oGetLocal 6
9261: oPushResult
9262: oEmitInt
9263: oPop 1
9265: oReturn
9266: oLocalSpace 0
9268: oGetParam 1
9270: oPushResult
9271: oGetGlobal 15
9273: oPushResult
9274: oNodeEqual
9275: oPop 2
9277: oChoice 9317
9279: oInput 14
9281: oCall 5159
9283: oTypeSNodeType
9284: oChoice 9292
9286: oJumpForward 9305
9288: oEmit 30
9290: oJumpForward 9305
9292: Choice Lookup Table
          32   9288
          29   9288
          30   9288
          40   9286
          28   9286
9303: oError 14
9305: oTypeSPop
9306: oGetGlobal 6
9308: oPushResult
9309: oTypeSPush
9310: oPop 1
9312: oInput 15
9314: oReturn
9315: oJumpForward 9320
9317: Choice Lookup Table
           1   9279
9320: oGetParam 1
9322: oPushResult
9323: oGetGlobal 16
9325: oPushResult
9326: oNodeEqual
9327: oPop 2
9329: oChoice 9363
9331: oInput 14
9333: oCall 5159
9335: oTypeSNodeType
9336: oChoice 9344
9338: oEmit 31
9340: oJumpForward 9351
9342: oJumpForward 9351
9344: Choice Lookup Table
          29   9342
          28   9338
9349: oError 14
9351: oTypeSPop
9352: oGetGlobal 9
9354: oPushResult
9355: oTypeSPush
9356: oPop 1
9358: oInput 15
9360: oReturn
9361: oJumpForward 9366
9363: Choice Lookup Table
           1   9331
9366: oGetParam 1
9368: oPushResult
9369: oGetGlobal 17
9371: oPushResult
9372: oNodeEqual
9373: oPop 2
9375: oChoice 9415
9377: oInput 14
9379: oCall 5159
9381: oTypeSNodeType
9382: oChoice 9403
9384: oTypeSTop
9385: oPushResult
9386: oSetResult 43
9388: oPushResult
9389: oNodeGetBoolean
9390: oPop 2
9392: oChoice 9398
9394: oError 28
9396: oJumpForward 9401
9398: Choice Lookup Table
           1   9394
9401: oJumpForward 9408
9403: Choice Lookup Table
          40   9384
9406: oError 14
9408: oEmit 33
9410: oInput 15
9412: oReturn
9413: oJumpForward 9418
9415: Choice Lookup Table
           1   9377
9418: oGetParam 1
9420: oPushResult
9421: oGetGlobal 18
9423: oPushResult
9424: oNodeEqual
9425: oPop 2
9427: oChoice 9467
9429: oInput 14
9431: oCall 5159
9433: oTypeSNodeType
9434: oChoice 9455
9436: oTypeSTop
9437: oPushResult
9438: oSetResult 43
9440: oPushResult
9441: oNodeGetBoolean
9442: oPop 2
9444: oChoice 9450
9446: oError 28
9448: oJumpForward 9453
9450: Choice Lookup Table
           1   9446
9453: oJumpForward 9460
9455: Choice Lookup Table
          40   9436
9458: oError 14
9460: oEmit 32
9462: oInput 15
9464: oReturn
9465: oJumpForward 9470
9467: Choice Lookup Table
           1   9429
9470: oError 16
9472: oReturn
9473: oLocalSpace 0
9475: oInputChoice 9534
9477: oCall 10660
9479: oJumpForward 9563
9481: oCall 10667
9483: oJumpForward 9563
9485: oCall 10791
9487: oJumpForward 9563
9489: oCall 10794
9491: oJumpForward 9563
9493: oCall 10145
9495: oJumpForward 9563
9497: oCall 10468
9499: oJumpForward 9563
9501: oCall 10211
9503: oJumpForward 9563
9505: oCall 10388
9507: oJumpForward 9563
9509: oCall 10553
9511: oJumpForward 9563
9513: oCall 10521
9515: oJumpForward 9563
9517: oCall 10637
9519: oJumpForward 9563
9521: oCall 9564
9523: oJumpForward 9563
9525: oCall 10585
9527: oJumpForward 9563
9529: oChangeIntLitToLabelIdent
9530: oCall 9564
9532: oJumpForward 9563
9534: Choice Lookup Table
           1   9529
          53   9525
           0   9521
          35   9517
          51   9513
          52   9509
          49   9505
          44   9501
          48   9497
          41   9493
          66   9489
          65   9485
          64   9481
          63   9477
9563: oReturn
9564: oLocalSpace 1
9566: oGetAddrLocal 1
9568: oPushResult
9569: oScopeFindRequire
9570: oAssign
9571: oGetAddrLocal 1
9573: oPushResult
9574: oCall 526
9576: oPop 1
9578: oGetLocal 1
9580: oPushResult
9581: oNodeType
9582: oPop 1
9584: oChoice 9624
9586: oGetLocal 1
9588: oPushResult
9589: oCall 9640
9591: oPop 1
9593: oCall 9473
9595: oJumpForward 9639
9597: oGetLocal 1
9599: oPushResult
9600: oCall 8646
9602: oPop 1
9604: oJumpForward 9639
9606: oGetLocal 1
9608: oPushResult
9609: oCall 9690
9611: oPop 1
9613: oJumpForward 9639
9615: oGetLocal 1
9617: oPushResult
9618: oCall 9780
9620: oPop 1
9622: oJumpForward 9639
9624: Choice Lookup Table
          13   9615
          23   9606
          21   9606
          20   9606
          12   9597
          25   9586
9637: oError 0
9639: oReturn
9640: oLocalSpace 0
9642: oGetParam 1
9644: oPushResult
9645: oSetResult 34
9647: oPushResult
9648: oNodeGetBoolean
9649: oPop 2
9651: oChoice 9657
9653: oError 21
9655: oJumpForward 9660
9657: Choice Lookup Table
           1   9653
9660: oEmit 71
9662: oGetParam 1
9664: oPushResult
9665: oSetResult 22
9667: oPushResult
9668: oNodeGetLabel
9669: oPop 2
9671: oPushResult
9672: oEmitLabel
9673: oPop 1
9675: oGetParam 1
9677: oPushResult
9678: oSetResult 34
9680: oPushResult
9681: oSetResult 1
9683: oPushResult
9684: oNodeSetBoolean
9685: oPop 3
9687: oInput 12
9689: oReturn
9690: oLocalSpace 0
9692: oGetParam 1
9694: oPushResult
9695: oSetResult 1
9697: oPushResult
9698: oCall 9955
9700: oPop 2
9702: oInput 4
9704: oCall 5159
9706: oCall 8212
9708: oCall 9711
9710: oReturn
9711: oLocalSpace 1
9713: oTypeSNodeType
9714: oChoice 9754
9716: oEmit 26
9718: oJumpForward 9778
9720: oEmit 27
9722: oJumpForward 9778
9724: oError 16
9726: oJumpForward 9778
9728: oEmit 28
9730: oJumpForward 9778
9732: oGetAddrLocal 1
9734: oPushResult
9735: oTypeSTop
9736: oPushResult
9737: oSetResult 17
9739: oPushResult
9740: oNodeGetInt
9741: oPop 2
9743: oAssign
9744: oEmit 29
9746: oGetLocal 1
9748: oPushResult
9749: oEmitInt
9750: oPop 1
9752: oJumpForward 9778
9754: Choice Lookup Table
          39   9732
          37   9732
          35   9732
          34   9728
          33   9728
          27   9724
          32   9720
          29   9720
          30   9720
          40   9716
          28   9716
9777: oEndChoice
9778: oTypeSPop
9779: oReturn
9780: oLocalSpace 1
9782: oGetParam 1
9784: oPushResult
9785: oSetResult 6
9787: oPushResult
9788: oNodeGet
9789: oPop 2
9791: oPushResult
9792: oScopeCurrent
9793: oPushResult
9794: oNodeEqual
9795: oPop 2
9797: oChoice 9803
9799: oError 20
9801: oJumpForward 9806
9803: Choice Lookup Table
           0   9799
9806: oEmit 8
9808: oGetParam 1
9810: oPushResult
9811: oSetResult 31
9813: oPushResult
9814: oNodeGetInt
9815: oPop 2
9817: oPushResult
9818: oEmitInt
9819: oPop 1
9821: oGetParam 1
9823: oPushResult
9824: oSetResult 21
9826: oPushResult
9827: oNodeGet
9828: oPop 2
9830: oPushResult
9831: oTypeSPush
9832: oPop 1
9834: oInput 4
9836: oCall 5159
9838: oCall 8212
9840: oTypeSNodeType
9841: oChoice 9881
9843: oEmit 26
9845: oJumpForward 9905
9847: oEmit 27
9849: oJumpForward 9905
9851: oError 16
9853: oJumpForward 9905
9855: oEmit 28
9857: oJumpForward 9905
9859: oGetAddrLocal 1
9861: oPushResult
9862: oTypeSTop
9863: oPushResult
9864: oSetResult 17
9866: oPushResult
9867: oNodeGetInt
9868: oPop 2
9870: oAssign
9871: oEmit 29
9873: oGetLocal 1
9875: oPushResult
9876: oEmitInt
9877: oPop 1
9879: oJumpForward 9905
9881: Choice Lookup Table
          39   9859
          37   9859
          35   9859
          34   9855
          33   9855
          27   9851
          32   9847
          29   9847
          30   9847
          40   9843
          28   9843
9904: oEndChoice
9905: oTypeSPop
9906: oReturn
9907: oLocalSpace 1
9909: oInput 0
9911: oGetAddrLocal 1
9913: oPushResult
9914: oScopeFindRequire
9915: oAssign
9916: oGetAddrLocal 1
9918: oPushResult
9919: oCall 526
9921: oPop 1
9923: oGetLocal 1
9925: oPushResult
9926: oNodeType
9927: oPop 1
9929: oChoice 9933
9931: oJumpForward 9944
9933: Choice Lookup Table
          24   9931
          23   9931
          21   9931
          20   9931
9942: oError 4
9944: oGetLocal 1
9946: oPushResult
9947: oGetParam 1
9949: oPushResult
9950: oCall 9955
9952: oPop 2
9954: oReturn
9955: oLocalSpace 0
9957: oGetParam 2
9959: oPushResult
9960: oNodeType
9961: oPop 1
9963: oChoice 10045
9965: oEmit 16
9967: oGetParam 2
9969: oPushResult
9970: oCall 11361
9972: oPop 1
9974: oJumpForward 10056
9976: oEmit 17
9978: oGetParam 2
9980: oPushResult
9981: oCall 11361
9983: oPop 1
9985: oJumpForward 10056
9987: oGetParam 2
9989: oPushResult
9990: oSetResult 33
9992: oPushResult
9993: oNodeGetBoolean
9994: oPop 2
9996: oChoice 10009
9998: oEmit 8
10000: oGetParam 2
10002: oPushResult
10003: oCall 11361
10005: oPop 1
10007: oJumpForward 10021
10009: Choice Lookup Table
           1   9998
10012: oEmit 18
10014: oGetParam 2
10016: oPushResult
10017: oCall 11361
10019: oPop 1
10021: oJumpForward 10056
10023: oGetParam 1
10025: oChoice 10038
10027: oEmit 16
10029: oGetParam 2
10031: oPushResult
10032: oCall 11361
10034: oPop 1
10036: oJumpForward 10043
10038: Choice Lookup Table
           0   10027
10041: oError 4
10043: oJumpForward 10056
10045: Choice Lookup Table
          24   10023
          23   9987
          21   9976
          20   9965
10054: oError 4
10056: oGetParam 2
10058: oPushResult
10059: oSetResult 21
10061: oPushResult
10062: oNodeGet
10063: oPop 2
10065: oPushResult
10066: oTypeSPush
10067: oPop 1
10069: oTypeSNodeType
10070: oChoice 10085
10072: oInputChoice 10080
10074: oEmit 25
10076: oCall 7790
10078: oJumpForward 10083
10080: Choice Lookup Table
          16   10074
10083: oJumpForward 10088
10085: Choice Lookup Table
          33   10072
10088: oCall 7595
10090: oReturn
10091: oLocalSpace 0
10093: oGetParam 1
10095: oPushResult
10096: oSetResult 1
10098: oPushResult
10099: oCall 9955
10101: oPop 2
10103: oCall 10905
10105: oGetParam 1
10107: oPushResult
10108: oCall 6784
10110: oPop 1
10112: oTypeSPop
10113: oEmit 32
10115: oEmit 26
10117: oReturn
10118: oLocalSpace 0
10120: oGetParam 1
10122: oPushResult
10123: oSetResult 1
10125: oPushResult
10126: oCall 9955
10128: oPop 2
10130: oCall 10905
10132: oGetParam 1
10134: oPushResult
10135: oCall 6784
10137: oPop 1
10139: oTypeSPop
10140: oEmit 33
10142: oEmit 26
10144: oReturn
10145: oLocalSpace 2
10147: oGetAddrLocal 1
10149: oPushResult
10150: oSetResult 0
10152: oAssign
10153: oGetAddrLocal 1
10155: oPushResult
10156: oCall 5182
10158: oPop 1
10160: oInput 42
10162: oCall 9473
10164: oInputChoice 10199
10166: oGetAddrLocal 2
10168: oPushResult
10169: oLabelNew
10170: oAssign
10171: oEmit 68
10173: oGetLocal 2
10175: oPushResult
10176: oEmitLabel
10177: oPop 1
10179: oEmit 71
10181: oGetLocal 1
10183: oPushResult
10184: oEmitLabel
10185: oPop 1
10187: oCall 9473
10189: oEmit 71
10191: oGetLocal 2
10193: oPushResult
10194: oEmitLabel
10195: oPop 1
10197: oJumpForward 10210
10199: Choice Lookup Table
          43   10166
10202: oEmit 71
10204: oGetLocal 1
10206: oPushResult
10207: oEmitLabel
10208: oPop 1
10210: oReturn
10211: oLocalSpace 4
10213: oInput 0
10215: oGetAddrLocal 1
10217: oPushResult
10218: oScopeFindRequire
10219: oAssign
10220: oGetLocal 1
10222: oPushResult
10223: oSetResult 1
10225: oPushResult
10226: oCall 9955
10228: oPop 2
10230: oCall 10905
10232: oInput 4
10234: oCall 5159
10236: oCall 10905
10238: oEmit 26
10240: oGetAddrLocal 2
10242: oPushResult
10243: oLabelNew
10244: oAssign
10245: oGetAddrLocal 3
10247: oPushResult
10248: oLabelNew
10249: oAssign
10250: oEmit 68
10252: oGetLocal 3
10254: oPushResult
10255: oEmitLabel
10256: oPop 1
10258: oGetAddrLocal 4
10260: oPushResult
10261: oLabelNew
10262: oAssign
10263: oEmit 71
10265: oGetLocal 4
10267: oPushResult
10268: oEmitLabel
10269: oPop 1
10271: oInputChoice 10351
10273: oGetLocal 1
10275: oPushResult
10276: oCall 10091
10278: oPop 1
10280: oEmit 71
10282: oGetLocal 3
10284: oPushResult
10285: oEmitLabel
10286: oPop 1
10288: oGetLocal 1
10290: oPushResult
10291: oCall 6784
10293: oPop 1
10295: oTypeSPop
10296: oCall 5159
10298: oCall 10905
10300: oEmit 51
10302: oEmit 69
10304: oGetLocal 2
10306: oPushResult
10307: oEmitLabel
10308: oPop 1
10310: oJumpForward 10357
10312: oGetLocal 1
10314: oPushResult
10315: oCall 10118
10317: oPop 1
10319: oEmit 71
10321: oGetLocal 3
10323: oPushResult
10324: oEmitLabel
10325: oPop 1
10327: oGetLocal 1
10329: oPushResult
10330: oCall 6784
10332: oPop 1
10334: oTypeSPop
10335: oCall 5159
10337: oCall 10905
10339: oEmit 52
10341: oEmit 69
10343: oGetLocal 2
10345: oPushResult
10346: oEmitLabel
10347: oPop 1
10349: oJumpForward 10357
10351: Choice Lookup Table
          46   10312
          45   10273
10356: oEndChoice
10357: oGetLocal 4
10359: oPushResult
10360: oGetLocal 2
10362: oPushResult
10363: oLoopPush
10364: oPop 2
10366: oInput 47
10368: oCall 9473
10370: oEmit 68
10372: oGetLocal 4
10374: oPushResult
10375: oEmitLabel
10376: oPop 1
10378: oEmit 71
10380: oGetLocal 2
10382: oPushResult
10383: oEmitLabel
10384: oPop 1
10386: oLoopPop
10387: oReturn
10388: oLocalSpace 3
10390: oGetAddrLocal 1
10392: oPushResult
10393: oLabelNew
10394: oAssign
10395: oEmit 71
10397: oGetLocal 1
10399: oPushResult
10400: oEmitLabel
10401: oPop 1
10403: oGetAddrLocal 2
10405: oPushResult
10406: oLabelNew
10407: oAssign
10408: oGetLocal 1
10410: oPushResult
10411: oGetLocal 2
10413: oPushResult
10414: oLoopPush
10415: oPop 2
10417: oCall 9473
10419: oInputChoice 10450
10421: oCall 9473
10423: oJumpForward 10456
10425: oGetAddrLocal 3
10427: oPushResult
10428: oCall 5182
10430: oPop 1
10432: oEmit 72
10434: oGetLocal 3
10436: oPushResult
10437: oEmitLabel
10438: oPop 1
10440: oGetLocal 1
10442: oPushResult
10443: oEmitLabel
10444: oPop 1
10446: oJumpForward 10458
10448: oJumpForward 10456
10450: Choice Lookup Table
          50   10425
           5   10421
10455: oEndChoice
10456: oJumpBack 10419
10458: oEmit 71
10460: oGetLocal 2
10462: oPushResult
10463: oEmitLabel
10464: oPop 1
10466: oLoopPop
10467: oReturn
10468: oLocalSpace 2
10470: oGetAddrLocal 1
10472: oPushResult
10473: oLabelNew
10474: oAssign
10475: oEmit 71
10477: oGetLocal 1
10479: oPushResult
10480: oEmitLabel
10481: oPop 1
10483: oGetAddrLocal 2
10485: oPushResult
10486: oCall 5182
10488: oPop 1
10490: oGetLocal 1
10492: oPushResult
10493: oGetLocal 2
10495: oPushResult
10496: oLoopPush
10497: oPop 2
10499: oInput 47
10501: oCall 9473
10503: oEmit 68
10505: oGetLocal 1
10507: oPushResult
10508: oEmitLabel
10509: oPop 1
10511: oEmit 71
10513: oGetLocal 2
10515: oPushResult
10516: oEmitLabel
10517: oPop 1
10519: oLoopPop
10520: oReturn
10521: oLocalSpace 0
10523: oLoopContinueLabel
10524: oPushResult
10525: oSetResult 0
10527: oPushResult
10528: equal_label
10529: oPop 2
10531: oChoice 10546
10533: oError 18
10535: oJumpForward 10552
10537: oEmit 68
10539: oLoopContinueLabel
10540: oPushResult
10541: oEmitLabel
10542: oPop 1
10544: oJumpForward 10552
10546: Choice Lookup Table
           0   10537
           1   10533
10551: oEndChoice
10552: oReturn
10553: oLocalSpace 0
10555: oLoopBreakLabel
10556: oPushResult
10557: oSetResult 0
10559: oPushResult
10560: equal_label
10561: oPop 2
10563: oChoice 10578
10565: oError 18
10567: oJumpForward 10584
10569: oEmit 68
10571: oLoopBreakLabel
10572: oPushResult
10573: oEmitLabel
10574: oPop 1
10576: oJumpForward 10584
10578: Choice Lookup Table
           0   10569
           1   10565
10583: oEndChoice
10584: oReturn
10585: oLocalSpace 1
10587: oInputChoice 10594
10589: oJumpForward 10600
10591: oChangeIntLitToLabelIdent
10592: oJumpForward 10600
10594: Choice Lookup Table
           1   10591
           0   10589
10599: oEndChoice
10600: oGetAddrLocal 1
10602: oPushResult
10603: oScopeCurrent
10604: oPushResult
10605: oScopeFindRequireInScope
10606: oPop 1
10608: oAssign
10609: oGetLocal 1
10611: oPushResult
10612: oSetResult 28
10614: oPushResult
10615: oSetResult 1
10617: oPushResult
10618: oNodeSetBoolean
10619: oPop 3
10621: oEmit 68
10623: oGetLocal 1
10625: oPushResult
10626: oSetResult 22
10628: oPushResult
10629: oNodeGetLabel
10630: oPop 2
10632: oPushResult
10633: oEmitLabel
10634: oPop 1
10636: oReturn
10637: oLocalSpace 0
10639: oCall 9473
10641: oInputChoice 10651
10643: oCall 9473
10645: oJumpForward 10657
10647: oJumpForward 10659
10649: oJumpForward 10657
10651: Choice Lookup Table
          36   10647
           5   10643
10656: oEndChoice
10657: oJumpBack 10641
10659: oReturn
10660: oLocalSpace 0
10662: oCall 10667
10664: oEmit 81
10666: oReturn
10667: oLocalSpace 0
10669: oInputChoice 10787
10671: oCall 5159
10673: oTypeSNodeType
10674: oChoice 10745
10676: oEmit 74
10678: oJumpForward 10768
10680: oEmit 75
10682: oJumpForward 10768
10684: oEmit 30
10686: oEmit 74
10688: oJumpForward 10768
10690: oEmit 76
10692: oJumpForward 10768
10694: oEmit 77
10696: oJumpForward 10768
10698: oError 16
10700: oJumpForward 10768
10702: oEmit 16
10704: oTypeSTop
10705: oPushResult
10706: oSetResult 42
10708: oPushResult
10709: oNodeGetInt
10710: oPop 2
10712: oPushResult
10713: oEmitInt
10714: oPop 1
10716: oEmit 80
10718: oJumpForward 10768
10720: oTypeSTop
10721: oPushResult
10722: oGetGlobal 10
10724: oPushResult
10725: equal_node
10726: oPop 2
10728: oChoice 10734
10730: oEmit 78
10732: oJumpForward 10739
10734: Choice Lookup Table
           1   10730
10737: oEmit 79
10739: oJumpForward 10768
10741: oEmit 79
10743: oJumpForward 10768
10745: Choice Lookup Table
          34   10741
          33   10720
          40   10702
          27   10698
          38   10694
          39   10694
          32   10690
          29   10684
          30   10680
          28   10676
10766: oError 17
10768: oTypeSPop
10769: oInputChoice 10777
10771: oJumpForward 10785
10773: oJumpForward 10783
10775: oJumpForward 10783
10777: Choice Lookup Table
          13   10775
          15   10771
10782: oEndChoice
10783: oJumpBack 10671
10785: oJumpForward 10790
10787: Choice Lookup Table
          14   10671
10790: oReturn
10791: oLocalSpace 0
10793: oReturn
10794: oLocalSpace 0
10796: oReturn
10797: oLocalSpace 0
10799: oScopeCurrent
10800: oPushResult
10801: oSetResult 14
10803: oPushResult
10804: oNodeGetInt
10805: oPop 2
10807: oReturn
10808: oReturn
10809: oLocalSpace 0
10811: oGetParam 1
10813: oPushResult
10814: oSetResult 20
10816: oPushResult
10817: oNodeGet
10818: oPop 2
10820: oPushResult
10821: oSetResult 14
10823: oPushResult
10824: oNodeGetInt
10825: oPop 2
10827: oReturn
10828: oReturn
10829: oLocalSpace 0
10831: oCall 10797
10833: oPushResult
10834: oGetParam 1
10836: oPushResult
10837: oCall 10809
10839: oPop 1
10841: oPushResult
10842: subtract
10843: oPop 2
10845: oReturn
10846: oReturn
10847: oLocalSpace 1
10849: oGetAddrLocal 1
10851: oPushResult
10852: oTypeSNodeType
10853: oAssign
10854: oTypeSPop
10855: oGetLocal 1
10857: oPushResult
10858: oTypeSNodeType
10859: oPushResult
10860: equal_node_type
10861: oPop 2
10863: oChoice 10901
10865: oTypeSNodeType
10866: oChoice 10892
10868: oGetLocal 1
10870: oChoice 10875
10872: oReturn
10873: oJumpForward 10878
10875: Choice Lookup Table
          34   10872
10878: oJumpForward 10897
10880: oGetLocal 1
10882: oChoice 10887
10884: oReturn
10885: oJumpForward 10890
10887: Choice Lookup Table
          33   10884
10890: oJumpForward 10897
10892: Choice Lookup Table
          34   10880
          33   10868
10897: oError 14
10899: oJumpForward 10904
10901: Choice Lookup Table
           0   10865
10904: oReturn
10905: oLocalSpace 0
10907: oTypeSNodeType
10908: oChoice 10912
10910: oJumpForward 10917
10912: Choice Lookup Table
          28   10910
10915: oError 7
10917: oTypeSPop
10918: oReturn
10919: oLocalSpace 0
10921: oTypeSNodeType
10922: oChoice 10926
10924: oJumpForward 10931
10926: Choice Lookup Table
          28   10924
10929: oError 7
10931: oReturn
10932: oLocalSpace 0
10934: oTypeSNodeType
10935: oChoice 10943
10937: oJumpForward 10950
10939: oEmit 30
10941: oJumpForward 10950
10943: Choice Lookup Table
          29   10939
          28   10937
10948: oError 7
10950: oTypeSPop
10951: oReturn
10952: oLocalSpace 0
10954: oTypeSNodeType
10955: oChoice 10970
10957: oJumpForward 10977
10959: oEmit 30
10961: oTypeSPop
10962: oGetGlobal 6
10964: oPushResult
10965: oTypeSPush
10966: oPop 1
10968: oJumpForward 10977
10970: Choice Lookup Table
          29   10959
          28   10957
10975: oError 7
10977: oReturn
10978: oLocalSpace 0
10980: oTypeSNodeType
10981: oChoice 10994
10983: oEmit 30
10985: oTypeSPop
10986: oGetGlobal 6
10988: oPushResult
10989: oTypeSPush
10990: oPop 1
10992: oJumpForward 10997
10994: Choice Lookup Table
          29   10983
10997: oReturn
10998: oLocalSpace 0
11000: oTypeSNodeType
11001: oChoice 11005
11003: oJumpForward 11010
11005: Choice Lookup Table
          30   11003
11008: oError 8
11010: oTypeSPop
11011: oReturn
11012: oLocalSpace 0
11014: oTypeSNodeType
11015: oChoice 11019
11017: oJumpForward 11024
11019: Choice Lookup Table
          30   11017
11022: oError 8
11024: oReturn
11025: oLocalSpace 1
11027: oGetAddrLocal 1
11029: oPushResult
11030: oGetParam 2
11032: oPushResult
11033: oNodeNew
11034: oPop 1
11036: oAssign
11037: oGetLocal 1
11039: oPushResult
11040: oSetResult 17
11042: oPushResult
11043: oGetParam 1
11045: oPushResult
11046: oNodeSetInt
11047: oPop 3
11049: oGetLocal 1
11051: oPushResult
11052: oTypeAdd
11053: oPop 1
11055: oGetLocal 1
11057: oReturn
11058: oReturn
11059: oLocalSpace 1
11061: oGetAddrLocal 1
11063: oPushResult
11064: oGetParam 2
11066: oPushResult
11067: oNodeNew
11068: oPop 1
11070: oAssign
11071: oGetLocal 1
11073: oPushResult
11074: oSetResult 4
11076: oPushResult
11077: oGetParam 1
11079: oPushResult
11080: oNodeSetInt
11081: oPop 3
11083: oGetLocal 1
11085: oReturn
11086: oReturn
11087: oLocalSpace 1
11089: oGetAddrLocal 1
11091: oPushResult
11092: oGetParam 1
11094: oPushResult
11095: oSetResult 35
11097: oPushResult
11098: oNodeGet
11099: oPop 2
11101: oAssign
11102: oGetLocal 1
11104: oPushResult
11105: oNodeNull
11106: oPop 1
11108: oChoice 11164
11110: oGetAddrLocal 1
11112: oPushResult
11113: oSetResult 33
11115: oPushResult
11116: oNodeNew
11117: oPop 1
11119: oAssign
11120: oGetLocal 1
11122: oPushResult
11123: oSetResult 36
11125: oPushResult
11126: oGetParam 1
11128: oPushResult
11129: oNodeSet
11130: oPop 3
11132: oGetLocal 1
11134: oPushResult
11135: oSetResult 17
11137: oPushResult
11138: oSetResult 8
11140: oPushResult
11141: oNodeSetInt
11142: oPop 3
11144: oGetLocal 1
11146: oPushResult
11147: oTypeAdd
11148: oPop 1
11150: oGetParam 1
11152: oPushResult
11153: oSetResult 35
11155: oPushResult
11156: oGetLocal 1
11158: oPushResult
11159: oNodeSet
11160: oPop 3
11162: oJumpForward 11167
11164: Choice Lookup Table
           1   11110
11167: oGetLocal 1
11169: oReturn
11170: oReturn
11171: oLocalSpace 2
11173: oGetParam 1
11175: oPushResult
11176: oNodeType
11177: oPop 1
11179: oChoice 11249
11181: oMININT
11182: oReturn
11183: oJumpForward 11265
11185: oSetResult 0
11187: oReturn
11188: oJumpForward 11265
11190: oSetResult 0
11192: oReturn
11193: oJumpForward 11265
11195: oGetAddrLocal 1
11197: oPushResult
11198: oGetParam 1
11200: oPushResult
11201: oSetResult 40
11203: oPushResult
11204: oNodeGet
11205: oPop 2
11207: oAssign
11208: oGetAddrLocal 2
11210: oPushResult
11211: oGetLocal 1
11213: oPushResult
11214: oSetResult 15
11216: oPushResult
11217: oNodeGetIter
11218: oPop 2
11220: oPushResult
11221: oNodeIterValue
11222: oPop 1
11224: oAssign
11225: oGetLocal 2
11227: oPushResult
11228: oSetResult 22
11230: oPushResult
11231: oNodeGetInt
11232: oPop 2
11234: oReturn
11235: oJumpForward 11265
11237: oGetParam 1
11239: oPushResult
11240: oSetResult 38
11242: oPushResult
11243: oNodeGetInt
11244: oPop 2
11246: oReturn
11247: oJumpForward 11265
11249: Choice Lookup Table
          36   11237
          40   11195
          32   11190
          30   11185
          28   11181
11260: oError 3
11262: oSetResult 0
11264: oReturn
11265: oReturn
11266: oLocalSpace 2
11268: oGetParam 1
11270: oPushResult
11271: oNodeType
11272: oPop 1
11274: oChoice 11344
11276: oMAXINT
11277: oReturn
11278: oJumpForward 11360
11280: oSetResult 1
11282: oReturn
11283: oJumpForward 11360
11285: oSetResult 255
11287: oReturn
11288: oJumpForward 11360
11290: oGetAddrLocal 1
11292: oPushResult
11293: oGetParam 1
11295: oPushResult
11296: oSetResult 40
11298: oPushResult
11299: oNodeGet
11300: oPop 2
11302: oAssign
11303: oGetAddrLocal 2
11305: oPushResult
11306: oGetLocal 1
11308: oPushResult
11309: oSetResult 15
11311: oPushResult
11312: oNodeGetIterLast
11313: oPop 2
11315: oPushResult
11316: oNodeIterValue
11317: oPop 1
11319: oAssign
11320: oGetLocal 2
11322: oPushResult
11323: oSetResult 22
11325: oPushResult
11326: oNodeGetInt
11327: oPop 2
11329: oReturn
11330: oJumpForward 11360
11332: oGetParam 1
11334: oPushResult
11335: oSetResult 39
11337: oPushResult
11338: oNodeGetInt
11339: oPop 2
11341: oReturn
11342: oJumpForward 11360
11344: Choice Lookup Table
          36   11332
          40   11290
          32   11285
          30   11280
          28   11276
11355: oError 3
11357: oSetResult 0
11359: oReturn
11360: oReturn
11361: oLocalSpace 0
11363: oGetParam 1
11365: oPushResult
11366: oSetResult 22
11368: oPushResult
11369: oNodeGetInt
11370: oPop 2
11372: oPushResult
11373: oEmitInt
11374: oPop 1
11376: oReturn
11377: oLocalSpace 1
11379: oGetAddrLocal 1
11381: oPushResult
11382: oSetResult 14
11384: oPushResult
11385: oGetParam 1
11387: oPushResult
11388: oCall 11059
11390: oPop 2
11392: oAssign
11393: oGetLocal 1
11395: oPushResult
11396: oScopeDeclare
11397: oPop 1
11399: oGetLocal 1
11401: oReturn
11402: oReturn
11403: oLocalSpace 1
11405: oGetAddrGlobal 4
11407: oPushResult
11408: oId_mysystem
11409: oAssign
11410: oGetAddrGlobal 5
11412: oPushResult
11413: oSetResult 27
11415: oPushResult
11416: oSetResult 4
11418: oPushResult
11419: oCall 11025
11421: oPop 2
11423: oAssign
11424: oGetAddrGlobal 6
11426: oPushResult
11427: oSetResult 28
11429: oPushResult
11430: oSetResult 4
11432: oPushResult
11433: oCall 11025
11435: oPop 2
11437: oAssign
11438: oGetAddrGlobal 7
11440: oPushResult
11441: oSetResult 30
11443: oPushResult
11444: oSetResult 1
11446: oPushResult
11447: oCall 11025
11449: oPop 2
11451: oAssign
11452: oGetAddrGlobal 8
11454: oPushResult
11455: oSetResult 31
11457: oPushResult
11458: oSetResult 1
11460: oPushResult
11461: oCall 11025
11463: oPop 2
11465: oAssign
11466: oGetAddrGlobal 9
11468: oPushResult
11469: oSetResult 32
11471: oPushResult
11472: oSetResult 1
11474: oPushResult
11475: oCall 11025
11477: oPop 2
11479: oAssign
11480: oGetAddrGlobal 10
11482: oPushResult
11483: oGetGlobal 9
11485: oPushResult
11486: oCall 11087
11488: oPop 1
11490: oAssign
11491: oGetAddrGlobal 11
11493: oPushResult
11494: oSetResult 29
11496: oPushResult
11497: oSetResult 1
11499: oPushResult
11500: oCall 11025
11502: oPop 2
11504: oAssign
11505: oGetAddrGlobal 12
11507: oPushResult
11508: oSetResult 34
11510: oPushResult
11511: oSetResult 8
11513: oPushResult
11514: oCall 11025
11516: oPop 2
11518: oAssign
11519: oGetGlobal 12
11521: oPushResult
11522: oSetResult 36
11524: oPushResult
11525: oGetGlobal 11
11527: oPushResult
11528: oNodeSet
11529: oPop 3
11531: oGetAddrGlobal 13
11533: oPushResult
11534: oSetResult 38
11536: oPushResult
11537: oSetResult 256
11539: oPushResult
11540: oCall 11025
11542: oPop 2
11544: oAssign
11545: oGetAddrGlobal 14
11547: oPushResult
11548: oSetResult 39
11550: oPushResult
11551: oSetResult 256
11553: oPushResult
11554: oCall 11025
11556: oPop 2
11558: oAssign
11559: oGetGlobal 14
11561: oPushResult
11562: oSetResult 41
11564: oPushResult
11565: oSetResult 255
11567: oPushResult
11568: oNodeSetInt
11569: oPop 3
11571: oGetAddrLocal 1
11573: oPushResult
11574: oSetResult 18
11576: oPushResult
11577: oId_File
11578: oPushResult
11579: oCall 11059
11581: oPop 2
11583: oAssign
11584: oGetLocal 1
11586: oPushResult
11587: oSetResult 21
11589: oPushResult
11590: oGetGlobal 5
11592: oPushResult
11593: oNodeSet
11594: oPop 3
11596: oGetLocal 1
11598: oPushResult
11599: oScopeDeclare
11600: oPop 1
11602: oGetAddrLocal 1
11604: oPushResult
11605: oSetResult 18
11607: oPushResult
11608: oId_Integer
11609: oPushResult
11610: oCall 11059
11612: oPop 2
11614: oAssign
11615: oGetLocal 1
11617: oPushResult
11618: oSetResult 21
11620: oPushResult
11621: oGetGlobal 6
11623: oPushResult
11624: oNodeSet
11625: oPop 3
11627: oGetLocal 1
11629: oPushResult
11630: oScopeDeclare
11631: oPop 1
11633: oGetAddrLocal 1
11635: oPushResult
11636: oSetResult 18
11638: oPushResult
11639: oId_Boolean
11640: oPushResult
11641: oCall 11059
11643: oPop 2
11645: oAssign
11646: oGetLocal 1
11648: oPushResult
11649: oSetResult 21
11651: oPushResult
11652: oGetGlobal 7
11654: oPushResult
11655: oNodeSet
11656: oPop 3
11658: oGetLocal 1
11660: oPushResult
11661: oScopeDeclare
11662: oPop 1
11664: oGetAddrLocal 1
11666: oPushResult
11667: oSetResult 18
11669: oPushResult
11670: oId_Char
11671: oPushResult
11672: oCall 11059
11674: oPop 2
11676: oAssign
11677: oGetLocal 1
11679: oPushResult
11680: oSetResult 21
11682: oPushResult
11683: oGetGlobal 9
11685: oPushResult
11686: oNodeSet
11687: oPop 3
11689: oGetLocal 1
11691: oPushResult
11692: oScopeDeclare
11693: oPop 1
11695: oGetAddrLocal 1
11697: oPushResult
11698: oSetResult 18
11700: oPushResult
11701: oId_Byte
11702: oPushResult
11703: oCall 11059
11705: oPop 2
11707: oAssign
11708: oGetLocal 1
11710: oPushResult
11711: oSetResult 21
11713: oPushResult
11714: oGetGlobal 11
11716: oPushResult
11717: oNodeSet
11718: oPop 3
11720: oGetLocal 1
11722: oPushResult
11723: oScopeDeclare
11724: oPop 1
11726: oGetAddrLocal 1
11728: oPushResult
11729: oSetResult 18
11731: oPushResult
11732: oId_Pointer
11733: oPushResult
11734: oCall 11059
11736: oPop 2
11738: oAssign
11739: oGetLocal 1
11741: oPushResult
11742: oSetResult 21
11744: oPushResult
11745: oGetGlobal 12
11747: oPushResult
11748: oNodeSet
11749: oPop 3
11751: oGetLocal 1
11753: oPushResult
11754: oScopeDeclare
11755: oPop 1
11757: oGetAddrLocal 1
11759: oPushResult
11760: oSetResult 18
11762: oPushResult
11763: oId_ShortString
11764: oPushResult
11765: oCall 11059
11767: oPop 2
11769: oAssign
11770: oGetLocal 1
11772: oPushResult
11773: oSetResult 21
11775: oPushResult
11776: oGetGlobal 14
11778: oPushResult
11779: oNodeSet
11780: oPop 3
11782: oGetLocal 1
11784: oPushResult
11785: oScopeDeclare
11786: oPop 1
11788: oGetAddrLocal 1
11790: oPushResult
11791: oSetResult 16
11793: oPushResult
11794: oId_True
11795: oPushResult
11796: oCall 11059
11798: oPop 2
11800: oAssign
11801: oGetLocal 1
11803: oPushResult
11804: oSetResult 21
11806: oPushResult
11807: oGetGlobal 7
11809: oPushResult
11810: oNodeSet
11811: oPop 3
11813: oGetLocal 1
11815: oPushResult
11816: oSetResult 22
11818: oPushResult
11819: oSetResult 1
11821: oPushResult
11822: oNodeSetInt
11823: oPop 3
11825: oGetLocal 1
11827: oPushResult
11828: oScopeDeclare
11829: oPop 1
11831: oGetAddrLocal 1
11833: oPushResult
11834: oSetResult 16
11836: oPushResult
11837: oId_False
11838: oPushResult
11839: oCall 11059
11841: oPop 2
11843: oAssign
11844: oGetLocal 1
11846: oPushResult
11847: oSetResult 21
11849: oPushResult
11850: oGetGlobal 7
11852: oPushResult
11853: oNodeSet
11854: oPop 3
11856: oGetLocal 1
11858: oPushResult
11859: oSetResult 22
11861: oPushResult
11862: oSetResult 0
11864: oPushResult
11865: oNodeSetInt
11866: oPop 3
11868: oGetLocal 1
11870: oPushResult
11871: oScopeDeclare
11872: oPop 1
11874: oGetAddrLocal 1
11876: oPushResult
11877: oSetResult 16
11879: oPushResult
11880: oId_Nil
11881: oPushResult
11882: oCall 11059
11884: oPop 2
11886: oAssign
11887: oGetLocal 1
11889: oPushResult
11890: oSetResult 21
11892: oPushResult
11893: oGetGlobal 12
11895: oPushResult
11896: oNodeSet
11897: oPop 3
11899: oGetLocal 1
11901: oPushResult
11902: oSetResult 22
11904: oPushResult
11905: oSetResult 0
11907: oPushResult
11908: oNodeSetInt
11909: oPop 3
11911: oGetLocal 1
11913: oPushResult
11914: oScopeDeclare
11915: oPop 1
11917: oGetAddrGlobal 15
11919: oPushResult
11920: oId_Ord
11921: oPushResult
11922: oCall 11377
11924: oPop 1
11926: oAssign
11927: oGetAddrGlobal 16
11929: oPushResult
11930: oId_Chr
11931: oPushResult
11932: oCall 11377
11934: oPop 1
11936: oAssign
11937: oGetAddrGlobal 17
11939: oPushResult
11940: oId_Pred
11941: oPushResult
11942: oCall 11377
11944: oPop 1
11946: oAssign
11947: oGetAddrGlobal 18
11949: oPushResult
11950: oId_Succ
11951: oPushResult
11952: oCall 11377
11954: oPop 1
11956: oAssign
11957: oReturn
