   2: title: 'Pascal Compiler 1.1.5 -- Jan 01 ''90';
         
      %
      %  Pascal.ssl
      %
      %  Pascal Compiler for the Amiga, by Steve Rice.
      %
      %  HISTORY
      %    11Sep89   First version, framework of parser.
      %    18Sep89   Added some semantic mechanisms.
      %    21Sep89   Added simple type references; expressions generate code.
      %    22Sep89   Allocate variable addresses as they're declared.
      %    24Sep89   Added arrays, pointers.
      %    27Sep89   Added for statement.
      %    23Oct89   Fixed for statement, so CYCLE goes to next step.
      %    01Jan90   Added string literals
      %    09Sep22   I have returned.  Migrate symbol table to schema, to ease development.
      %    01Oct22   Language: Switch from cycle/exit (Mac Pascal extension) to continue/break (Borland).
      %
      %  NOTES
      %    -  The 'value' of a var symbol is its allocated address.
      %    -  References to vars of intrinsic types, and pointer types,
      %       pushes the value of the var on the expr stack.  Referenecs to
      %       vars of compound types (arrays, records...) pushes the address
      %       on the expr stack.
      %    -  Just as there is only one type table entry for a given (named) type,
      %       there is only one type table entry for a pointer to a named type.
      %       When a pointer type is declared, a field in the TT entry of the
      %       type pointed to will be set to indicate the TT entry of the pointer
      %       to that type (0 means none defined yet).  When evaluating the
      %       expression @x, the type in that field in the entry for the type of x
      %       will be used (unless it's 0, in which case a new TT entry will be
      %       created).
      %
      %
      %  MISSING
      %
      %    - Consider non-ISO extensions.  e.g. 
      %      Dynamic arrays.  Objects.  But, perhaps stick to my old goal, standard Pascal.
      %
      %  PASCAL DOCS
      %      Here's some handy language material:
      %      https://www.freepascal.org/docs-html/ref/ref.html
      %      https://www.freepascal.org/docs-html/prog/prog.html
      %      https://en.wikipedia.org/wiki/Turbo_Pascal
      %      https://en.wikipedia.org/wiki/Pascal_(programming_language)#Standards
      %      http://www.standardpascaline.org/
      %
      
   2: input:
   2:    pIdent
   2:    pIntLit
   2:    pStrLit
   2:    pAssign       ':='
   2:    pSemiColon    ';'
   2:    pEqual        '='
   2:    pNotEqual     '<>'
   2:    pLess         '<'
   2:    pGreater      '>'
   2:    pLessEqual    '<='
   2:    pGreaterEqual '>='
   2:    pColon        ':'
   2:    pComma        ','
   2:    pLParen       '('
   2:    pRParen       ')'
   2:    pLSquare      '['
   2:    pRSquare      ']'
   2:    pCarat        '^'
   2:    pAt           '@'
   2:    pDot          '.'
   2:    pDotDot       '..'
   2:    pTimes        '*'
   2:    pDivide       '/'
   2:    pPlus         '+'
   2:    pMinus        '-'
   2:    pEof
   2:    pInvalid
      
      %  keywords  (built-in types 'integer', 'byte', 'char', etc, are not keywords,
      %             type constructors 'array', 'record', 'set' are keywords,
      %             pseudo-procedures 'writeln', 'readln' are keywords)
      %
      %             forward/external/name/cdecl appear in method modifiers, in fpc grammar.
      %             I'm making them keywords to simplify parsing, but could reconsider.
      
   2:    pProgram
   2:    pProcedure
   2:    pFunction
   2:    pConst
   2:    pType
   2:    pVar
   2:    pLabel
   2:    pBegin
   2:    pEnd
   2:    pArray
   2:    pRecord
   2:    pSet
   2:    pOf
   2:    pIf
   2:    pThen
   2:    pElse
   2:    pFor
   2:    pTo
   2:    pDownto
   2:    pDo
   2:    pWhile
   2:    pRepeat
   2:    pUntil
   2:    pContinue
   2:    pBreak
   2:    pGoto
   2:    pAnd
   2:    pOr
   2:    pNot
   2:    pUses
   2:    pUnit
   2:    pInterface
   2:    pImplementation
   2:    pInitialization
   2:    pFinalization
   2:    pWriteln
   2:    pWrite
   2:    pReadln
   2:    pRead
      
   2:    pForward
   2:    pExternal
   2:    pName
   2:    pCdecl
   2:    ;
      
      
   2: output:
      
      %  Instructions for a stack machine (all vars are 32-bit integers)
      
   2:    tPushGlobalI      % <ptr> - push int value read from ptr
   2:    tPushGlobalB      % <ptr> - push byte value read from ptr
   2:    tPushGlobalP      % <ptr> - push ptr value read from ptr
   2:    tPushLocalI       % <offset> - push int value read from local var in current scope
   2:    tPushLocalB       % <offset> - push byte value read from local var in current scope
   2:    tPushLocalP       % <offset> - push ptr value read from local var in current scope
   2:    tPushParamI       % <offset> - push int value read from param in current scope
   2:    tPushParamB       % <offset> - push byte value read from param in current scope
   2:    tPushParamP       % <offset> - push ptr value read from param in current scope
   2:    tPushUpLocalI     % <uplevels> <offset> - push int value read from local var in a parent static scope
   2:    tPushUpLocalB     % <uplevels> <offset> - push byte value read from local var in a parent static scope
   2:    tPushUpLocalP     % <uplevels> <offset> - push ptr value read from local var in a parent static scope
   2:    tPushUpParamI     % <uplevels> <offset> - push int value read from param in a parent static scope
   2:    tPushUpParamB     % <uplevels> <offset> - push byte value read from param in a parent static scope
   2:    tPushUpParamP     % <uplevels> <offset> - push ptr value read from param in a parent static scope
   2:    tPushConstI       % <int> - push int value on stack (NOTE, used for BOOLEAN too)
   2:    tPushAddrGlobal   % <offset> - push ptr to global var (same as tPushConstP)
   2:    tPushAddrLocal    % <offset> - push ptr to local var
   2:    tPushAddrParam    % <offset> - push ptr to formal param (used by method to see its param)
   2:    tPushAddrActual   % <offset> - push ptr to actual param, in actuals space (used by caller)
   2:    tPushAddrUpLocal  % <uplevels> <offset> - push ptr to local var in a parent static scope
   2:    tPushAddrUpParam  % <uplevels> <offset> - push ptr to formal param in a parent static scope
   2:    tFetchI           % pop ptr from stack, and push int value it points to
   2:    tFetchB           %    "      "      "     "     byte  "   "    "
   2:    tFetchP           %    "      "      "     "     ptr   "   "    "   
   2:    tAssignI          % assign int value on top of stack to addr under it (pop both)
   2:    tAssignB          %   "    byte   "    "   "  "   "    "    "   "   "
   2:    tAssignP          %   "    ptr    "    "   "  "   "    "    "   "   "
   2:    tCopy             % <#bytes> - copy bytes.  tos=src, 2nd=dest (pop 2)
   2:    tCastBtoI         % zero-extend uint8_t to int32_t
   2:    tCastItoB         % truncate int32_t to uint8_t
   2:    tIncI             % increment int value on top of expr stack
   2:    tDecI             % decrement int value on top of expr stack
   2:    tMultI            % multiply top two integers (replacing with result)
   2:    tDivI
   2:    tAddPI            % add ptr (2nd value) and int (top value), resulting in a ptr
   2:    tAddI
   2:    tSubI
   2:    tNegI             % top entry *= -1
   2:    tNot              % negate top boolean
   2:    tEqualI           % top two entries equal? (pop 2, push 1) (true=1)
   2:    tNotEqualI        %    NOTE, these all work for booleans too
   2:    tGreaterI         % 2nd entry greater than top entry? (pop 2, push answer)
   2:    tLessI  
   2:    tGreaterEqualI
   2:    tLessEqualI
   2:    tEqualP           % two two pointer values equal? (pop 2, push 1) (true=1)
   2:    tNotEqualP
   2:    tAllocActuals     % <#bytes> - make space on call stack for actual params (adjusting call stack sp)
   2:    tAllocActualsCdecl  % <#bytes> - starting a call to a cdecl method.  tcode still describes my own calling convention.
   2:    tFreeActuals      % <#bytes> - discard space on call stack allocated by tAllocActuals
   2:    tCall             % <label#>
   2:    tCallCdecl        % <label#> - call a method using native (C) calling convention. Only supported for extern labels.
   2:    tReturn
   2:    tEnter            % <#bytes> - start a stack frame on the call stack, reserving #bytes of local variable space
   2:    tJump             % <label#>
   2:    tJumpTrue         % <label#>  (pops top of stack, jumps if true)
   2:    tJumpFalse        % <label#>  (pops top of stack, jumps if false)
   2:    tLabel            % <label#> - define label# at the current address
   2:    tLabelAlias       % <label#> <aliasToLabel#> - defines label to be an alias of another label
   2:    tLabelExtern      % <label#> <offsetToStrLit> - defines label to mean an extern symbol, whose name is in global data
   2:    tWriteI           % for writeln : write integer on tos, pop
   2:    tWriteBool        %  "     "    : write TRUE/FALSE, pop
   2:    tWriteChar        %  "     "    : write char, pop
   2:    tWriteStr         %  "     "    : write string whose addr is on tos, pop
   2:    tWriteP           %  "     "    : write ptr var whose addr is on tos, pop
   2:    tWriteEnum        %  "     "    : write enum name.  Name table on tos, value under it, pop both
   2:    tWriteCR          %  "     "    : write cr
      
      %  Other:
      
   2:    tSpace            % emit a hole, to be patched later
   2:    ;
      
   2: error:
   2:    eBadStatement
   2:    eNotConst
   2:    eNotType
   2:    eNotOrdinalType
   2:    eNotVar
   2:    eNotIntVar
   2:    eNotValue
   2:    eNotInteger
   2:    eNotBoolean
   2:    eNotPointer
   2:    eNotArray
   2:    eNotRecord
   2:    eNotRecordField
   2:    eTooManySubscripts
   2:    eTypeMismatch
   2:    eMissingParameter
   2:    eNotImplemented
   2:    eNotAllowed
   2:    eNotInALoop
   2:    eRecordEmpty
   2:    eNotCurrentFunction
   2:    eAlreadyDefined
   2:    eOnlyOneVarCanBeInitialized
   2:    eExternalMethodCannotBeNested
   2:    eCantFindUnitFile
   2:    eInternalScopeMismatch
   2:    eEnumValueNotAscending
   2:    eUsedButNotDefined
   2:    ;
      
   2: include 'pascal_schema.ssl'
      
      % Generated automatically by schema
      
   2: type node_type:
   2: 	nINVALID
   2: 	Object
   2: 	nWorkspace
   2: 	nModule
   2: 	nProgram
   2: 	nUnit
   2: 	nUnitImpl
   2: 	nScope
   2: 	nDeclaration
   2: 	nIdent
   2: 	nUnitRef
   2: 	nMethod
   2: 	nProc
   2: 	nFunc
   2: 	nBuiltInFunc
   2: 	nBuiltInProc
   2: 	nConst
   2: 	nEnumValue
   2: 	nTypeDecl
   2: 	nVar
   2: 	nGlobalVar
   2: 	nLocalVar
   2: 	nRecordField
   2: 	nParam
   2: 	nLabel
   2: 	nType
   2: 	nFileType
   2: 	nIntegerType
   2: 	nByteType
   2: 	nBooleanType
   2: 	nBooleanCFType
   2: 	nCharType
   2: 	nStringType
   2: 	nPointerType
   2: 	nArrayType
   2: 	nSubrangeType
   2: 	nRecordType
   2: 	nEnumType
   2: 	nSetType
   2: 	;
      
   2: type node_attribute:
   2: 	qINVALID
   2: 	qUnits
   2: 	qProgram
   2: 	qGlobalSize
   2: 	qIdent
   2: 	qUsedUnits
   2: 	qChildScope
   2: 	qMainRoutineScope
   2: 	qImpl
   2: 	qPublicScope
   2: 	qPrivateScope
   2: 	qInitLabel
   2: 	qFinalLabel
   2: 	qInitRoutineScope
   2: 	qLevel
   2: 	qDecls
   2: 	qExtends
   2: 	qSize
   2: 	qAllocMode
   2: 	qInitCode
   2: 	qParentScope
   2: 	qType
   2: 	qValue
   2: 	qParams
   2: 	qBodyDefined
   2: 	qExternal
   2: 	qExternalName
   2: 	qCdecl
   2: 	qUsed
   2: 	qOldParams
   2: 	qOldType
   2: 	qResultOffset
   2: 	qNameOffset
   2: 	qInOut
   2: 	qDefined
   2: 	qPointerType
   2: 	qBaseType
   2: 	qIndexType
   2: 	qLow
   2: 	qHigh
   2: 	qScope
   2: 	qNameTable
   2: 	;
      
      
   2: type Node:     % A pointer to a node in the schema database (symbol database)
   2:    Null = 0
   2:    ;
      
   2: type NodeIter:   % An iterator over nodes in a list, in the schema database
   2:    NullIter = 0
   2:    ;
      
   2: type NodeVec:  % A pointer to a vector of Node.  See mechanism node_vec_mech
   2:    NullVec = 0
   2:    ;
      
   2: type boolean:
   2:    false    = 0
   2:    true     = 1;
      
      % intrinsic types & type constructs
      
   2: type typ:
   2:    tyNone     = 0    % in ptrTyp field of TT, means no ptr to type defined
   2:    tyInteger
   2:    tyBoolean
   2:    tyChar
   2:    tyString
   2:    tyFile            % tyInteger..tyFile are scalars (types on their own)
   2:    tyPointer         % following are type constructor classes...
   2:    tyArray           %   (they are not type#'s)
   2:    tyRecord
   2:    tyParams          % like record; a collection of proc/func params
   2:    tySet;
      
   2: type Label:
   2:    labelNull = 0;
      
      % An output code stream.
   2: type Code:
   2:    codeNull = 0
   2:    codeDefault = 1
   2:    ;
      
      % A string
   2: type String:
   2:    stringNull = 0
   2:    ;
      
      % allocation modes for oScopeBegin
   2: type AllocMode:
   2:    allocGlobal = 0  % allocate from global data
   2:    allocDown        % allocate down the stack
   2:    allocUp          % allocate up the stack
   2:    ;
      
      % Some general schema node operations.
      % node_type and node_attribute are defined in generated file pascal_schema.ssl included above.
      %
   2: mechanism node_mech:
   2:     oNodeNew (node_type) >> Node         % create new node
   2:     oNodeSet (Node, node_attribute, Node)   % set Node attribute of node
   2:     oNodeSetString (Node, node_attribute, String)
   2:     oNodeSetInt (Node, node_attribute, int) % set int attribute of node
   2:     oNodeSetBoolean (Node, node_attribute, boolean)
   2:     oNodeSetLabel( Node, node_attribute, Label )  % set Label attribute of node
   2:     oNodeSetCode( Node, node_attribute, Code )    % set Code attribute of node
   2:     oNodeAddLast( Node, node_attribute, Node value )  % append to a List attribute of node
   2:     oNodeGet (Node, node_attribute) >> Node    % get Node attribute of node
   2:     oNodeGetString (Node, node_attribute) >> String
   2:     oNodeGetInt (Node, node_attribute) >> int  % get int attribute of node
   2:     oNodeGetBoolean (Node, node_attribute) >> boolean  % get int attribute of node
   2:     oNodeGetLabel (Node, node_attribute) >> Label      % get Label attribute of node
   2:     oNodeGetCode (Node, node_attribute) >> Code        % get code stream attribute of node
   2:     oNodeNull (Node) >> boolean          % is node null?
   2:     oNodeFind (Node, node_attribute listAttr, node_attribute valueAttr, int value) >> Node  % find node with value in list
   2:     oNodeGetIter (Node, node_attribute) >> NodeIter   % get an iterator over nodes in a List attribute
   2:     oNodeGetIterLast (Node, node_attribute) >> NodeIter  % get an iterator over nodes in a List, starting at last
   2:     oNodeIterValue (NodeIter) >> Node             % the node that iter is referring to (NodeNull if no more nodes)
   2:     oNodeIterNext (inout NodeIter)                % advance iterator through list
   2:     oNodeIterPrev (inout NodeIter)                % advance iterator backwards through list
   2:     oNodeType (Node) >> node_type        % return node type of node
   2:     oNodeEqual (Node, Node) >> boolean   % compare two nodes for equality
                                               % (i.e. same node, not just same contents)
   2:     ;
      
      
      % Manipulate a temporary vector of Node
      %
   2: mechanism node_vec_mech:
   2:     oNodeVecNew >> NodeVec
   2:     oNodeVecDelete( NodeVec nv )
   2:     oNodeVecAppend( NodeVec nv, Node n )
   2:     oNodeVecSize( NodeVec nv ) >> int                % how many elements
   2:     oNodeVecElement( NodeVec nv, int idx ) >> Node   % element at index idx (0..size-1)
   2:     ;
      
      
      
   2: mechanism emit_mech:
   2:     oEmitInt( int )              % emit int into the generated code
   2:     oEmitLabel( Label )
   2:     oEmitCode( Code )            % append a code stream to the current code stream
   2:     Here >> int                  % current address in the generated code
                                       %   (only usable in the default code stream)
   2:     oPatch( int addr, int val )  % patch an int into address in the generated code
                                       %   (only usable in the default code stream)
   2:     ;
      
   2: mechanism math:
   2:     inc (inout int)
   2:     dec (inout int)
   2:     negate (int) >> int
   2:     add( int x, int y ) >> int
   2:     subtract( int x, int y ) >> int     % x - y
   2:     multiply( int x, int y ) >> int     % x * y
   2:     equal( int x, int y ) >> boolean
   2:     equal_zero (int) >> boolean
   2:     equal_node( Node, Node ) >> boolean
   2:     equal_string( String, String ) >> boolean
   2:     equal_node_type (node_type, node_type) >> boolean     % Want equal_<type> for every type
   2:     equal_label( Label, Label ) >> boolean
   2:     equal_code( Code, Code ) >> boolean
   2:     greater( int x, int y ) >> boolean
   2:     oMININT >> int    % the minimum 32-bit integer.
   2:     ;
      
   2: mechanism more_builtins:      % These should be built-in SSL operations
   2:     TOKEN_VALUE >> int        % value of just accepted token, e.g. IntLit token
   2:     LAST_ID >> int            % id number of last accepted identifier
   2:     ID_STRING( int id ) >> String       % text name of identifier with given id
   2:     CURRENT_STRLIT >> String            % text value of just-accepted string literal
   2:     ;
      
   2: mechanism workspace_mech:
   2:     oWorkspaceNew >> Node
   2:     ;
      
   2: mechanism scope_mech:
   2:     oScopeBegin( int level, AllocMode )  % create a new scope. Subsequent declarations will go here.
                                               %  level = static scope depth (0 = globals)
   2:     oScopeEnter( Node scope )            % enter an existing scope.
   2:     oScopeEnd                            % end current scope. Subsequent declarations will go to previous scope.
   2:     oScopeCurrent >> Node                % returns current scope
   2:     oScopeDeclare( Node decl )           % add declaration to current scope.
   2:     oScopeDeclareAlloc( Node decl )      % add declaration to current scope, and allocate space according to its type
   2:     oScopeAllocType( Node theType ) >> int   % allocate space for type in current scope, and return its address
   2:     oScopeAlloc( int size, int align ) >> int % allocate bytes, with given alignment in bytes 
   2:     oScopeFind >> Node                   % find declaration of last accepted identifier.  Returns Null if not found.
   2:     oScopeFindRequire >> Node            % find declaration of last accepted identifier.  Error if not found.
   2:     oScopeFindInCurrentScope >> Node     % find declaration of last accepted identifier, only within the current scope.  Null if not found.
   2:     oScopeFindRequireInScope( Node scope ) >> Node  % find decl of last accepted identifier, only within the given scope.  Error it not found.
   2:     ;
      
   2: mechanism type_mech:
   2:     oTypeAdd( Node node )     % add the given nType to the type table
   2:     ;
      
   2: mechanism type_stack_mech:
   2:     oTypeSPush( Node node )
   2:     oTypeSPop
   2:     oTypeSTop >> Node
   2:     oTypeSNodeType >> node_type          % node_type of the node on top of type stack, skipping subranges
   2:     ;
      
      
   2: mechanism id_mech:
          % adds a predefined id to the scanner's id table, and returns the id code
   2:     oIdAdd_File >> int
   2:     oIdAdd_Integer >> int
   2:     oIdAdd_Boolean >> int
   2:     oIdAdd_Char >> int
   2:     oIdAdd_Byte >> int
   2:     oIdAdd_String >> int
   2:     oIdAdd_True >> int
   2:     oIdAdd_False >> int
   2:     oIdAdd_Ord >> int
   2:     oIdAdd_Chr >> int
   2:     oChangeIntLitToLabelIdent    % change current token from pIntLit to pIdent "_label_<intlit>"
   2:     ;
      
      
      
   2: mechanism label_mech:
   2:    oLabelNew >> Label
   2:    ;
      
   2: mechanism code_mech:
   2:    oCodeNew >> Code         % create a new empty code stream
   2:    oCodePush( Code )        % change the current output code stream to the given one
   2:    oCodePop                 % restore the current code stream to the previous one
   2:    ;
      
   2: mechanism include_mech:
   2:    oIncludeUnitFile( int id ) >> boolean  % search for <unit>.pas and include it.
                                                % returns false if can't find.
   2:    oIncludeEnd              % stop including the current file
   2:    ;
      
      
   2: mechanism count :
   2:    oCountPush(int)          % start a new counter, with initial value
   2:    oCountInc
   2:    oCountDec
   2:    oCountIsZero >> boolean
   2:    oCountPop;
      
      
   2: mechanism value :              % value stack, to calc. const expr's
   2:    oValuePush(int)             % push an explicit int lit
   2:    oValueNegate                % negate top value
   2:    oValueTop >> int            % get top value on value stack
   2:    oValuePop;
      
   2: mechanism string :
   2:    oStringAllocLit( String ) >> int      % alloc global space for strlit, return address
   2:    ;
      
      % track labels for the loop we're in, if any
   2: mechanism loop_mech:
   2:    oLoopPush( Label continueLabel, Label breakLabel )
   2:    oLoopContinueLabel >> Label
   2:    oLoopBreakLabel >> Label
   2:    oLoopPop
   2:    ;
      
      % for hacky debugging
   2: mechanism msg_mech:
   2:    oMsg( int num )             % print message "oMsg <num>"
   2:    oMsgTrace( int num )        % print message "oMsg <num>" followed by ssl traceback
   2:    oMsgNode( Node node )       % print node
   2:    oMsgNodeLong( Node node )   % print node with more detail
   2:    oMsgNodeVec( NodeVec vec )  % print node vec
   2:    ;
      
      
   2: rules
      
      % ----------------------------- Global Variables ----------------------------
      
   2: Node    workspace              % root of database
   2: Node    globalScope            % scope for globals in the current module
   2: Node    initScope              % scope for temporaries global var init,
                                     % and program main stmt / unit initialization stmts
      % built-in nTypes
   2: Node    FileType
   2: Node    IntegerType
   2: Node    BooleanType
   2: Node    BooleanCFType
   2: Node    CharType
   2: Node    ByteType
   2: Node    StringType
      
      % nBuiltInFunc
   2: Node    BuiltIn_Ord
   2: Node    BuiltIn_Chr
      
      
      % -------------------------- Forward Declarations -------------------------
      
   2: Block( node_type varNodeType, Label labelForBody );
   2: BlockDecls( node_type varNodeType );
   2: BlockStmt( Label labelForBody, Node varScope, boolean isMain );
   2: VarDecl( node_type varNodeType );
   2: newType( node_type nt, int size ) >> Node;
   2: newIdent( node_type nt, int id ) >> Node;
   2: EmitValue( Node decl );
   2: TypeRef( out Node theType );
   2: PointerTypeTo( Node theType ) >> Node;
   2: OrdinalLow( Node theType ) >> int;
   2: AssignStmt( Node decl );
   2: BooleanExprControlFlow( out Label falseLabel );
   2: ExprAllowCF( out Label falseLabel );
   2: BoolExprAllowCF( out Label falseLabel );
   2: BoolTermAllowCF( out Label falseLabel );
   2: BoolFactorAllowCF( out Label falseLabel );
   2: ArithExprAllowCF( out Label falseLabel );
   2: TermAllowCF( out Label falseLabel );
   2: FactorAllowCF( out Label falseLabel );
   2: PrimaryAllowCF( out Label falseLabel );
      
   2: VarExpr( Node decl );
   2: LValueVar( Node decl );
   2: IncVar( Node decl );
   2: DecVar( Node decl );
      
   2: CFToVal( inout Label falseLabel );
   2: ValToCF( out Label falseLabel );
      
   2: DeclLevel( Node decl ) >> int;
   2: DeclUpLevels( Node decl ) >> int;
      
      % ----------------------------- Declarations ----------------------------
      
   2: Program:
   4:    Node t
      
   4:    workspace = oWorkspaceNew
      
         % root scope is used for builtins e.g. Integer,
         % and is a parent to any used units, and the program's own global scope.
   9:    oScopeBegin( 0, allocGlobal )
  18:    Node rootScope = oScopeCurrent
      
  23:    @installBuiltIns
      
         % Start by calling the main program routine.
      
         % This dummy call to main needs to look like a normal method itself,
         % so jit can align the stack properly.  So we need .tEnter,
         % and .tAllocActuals / .tFreeActuals.
  25:    .tEnter  oEmitInt( 0 )
  33:    Label mainLabel = oLabelNew
      
  38:    .tAllocActuals  oEmitInt( 0 )
  46:    .tCall  oEmitLabel( mainLabel )
  54:    .tFreeActuals  oEmitInt( 0 )
  62:    .tReturn
      
  64:    pProgram
  66:    pIdent
      
  68:    Node program = oNodeNew( nProgram )
  78:    oNodeSetInt( program, qIdent, LAST_ID )
  89:    oNodeSet( workspace, qProgram, program )
      
      
 101:    [
 101:       | '(' :
 103:          pIdent      % input, output files
      
 105:          t = @newIdent( nVar, LAST_ID )
 118:          oNodeSet( t, qType, FileType )
 130:          oScopeDeclareAlloc( t )
               % TO DO: I shouldn't declare the files in root scope.
               %        Should save them for program's global scope.
      
 136:          ','
 138:          pIdent
      
 140:          t = @newIdent( nVar, LAST_ID )
 153:          oNodeSet( t, qType, FileType )
 165:          oScopeDeclareAlloc( t )
      
 171:          ')'
 173:       | * :
 178:    ]
 178:    ';'
      
         % The uses clause may only appear once, immediately after the program declaration.
 180:    [
 180:       | pUses :  @UsesClause( program )
 189:       | * :
 194:    ]
 194:    @EnterUsedUnits( program )
      
         % Global scope for the program, below any used units.
 201:    oScopeBegin( 0, allocGlobal )
 210:    globalScope = oScopeCurrent
      
         % A new scope just for temporaries in the main routine
         % Create it up front, in case it's needed by variable initialization exprs.
         % But we won't stay in it here.
         % Note we say it extends the global scope, so that during main statement evaluation
         % any user labels declared in the global scope are considered to be part of the current scope.
 215:    oScopeBegin( 0, allocDown )
 224:    oNodeSet( oScopeCurrent, qExtends, globalScope )
 235:    initScope = oScopeCurrent
 240:    oNodeSet( program, qMainRoutineScope, initScope )
 252:    oScopeEnd
      
 253:    @BlockDecls( nGlobalVar )
      
      
 260:    oScopeEnter( initScope )
      
         % The block statement includes a stack frame, and enter/return,
         % even for the main routine.
         % That will be necessary for temporaries allocated in the main routine.
      
         % isMain means we'll generate calls to the unit init/final methods in here too.
         % Alternatively we could do that in a higher level method that calls main.
 266:    boolean isMain = true
 272:    @BlockStmt( mainLabel, globalScope, isMain )
      
 285:    oScopeEnd   % main routine scope
      
 286:    '.'
 288:    @CheckForUndefinedLabels
 290:    oScopeEnd   % global scope
 291:    @EndUsedUnits( program )   % used units scopes
 299:    ;
      
      
      % The uses clause is a list of units required by the user program or unit.
      % We will find and compile the named units (unless already loaded).
      % We do not make the unit interface visible to the user, the caller will do so later.
 299: UsesClause( Node user ):
 301:    {
 301:       pIdent
 303:       Node unit = @FindOrCompileUnit( LAST_ID )
 313:       [ equal_node( unit, Null )
 323:          | false :
 324:             oNodeAddLast( user, qUsedUnits, unit )
      
                  % Put a declaration in the current scope, naming the unit and pointing to it.
                  % This is to allow references to  <unit>.<identifier_in_unit>
 336:             Node unitRef = oNodeNew( nUnitRef )
 346:             oNodeSetInt( unitRef, qIdent, oNodeGetInt( unit, qIdent ) )
 365:             oNodeSet( unitRef, qPublicScope, oNodeGet( unit, qPublicScope ) )
 384:             oScopeDeclare( unitRef )
 390:          | * :
 395:       ]
 395:       [
 395:          | ',' :
 397:          | * :  >
 404:       ]
 404:    }   
 406:    ';'
 409:    ;
      
      
      % If the given decl is for an nUnitRef, the program is using syntax <unit>.<identifier>
      % Parse the rest of that to find the intended decl.
      %
 409: ResolveUnitRef( inout Node decl ):
 411:    [ oNodeType( decl )
 418:       | nUnitRef :
 419:          Node scope = oNodeGet( decl, qPublicScope )
 432:          '.'
 434:          pIdent
 436:          decl = oScopeFindRequireInScope( scope )
 446:       | * :
 451:    ];
      
      
 452: EnterUsedUnits( Node user ):
         % Make the used units' public scopes directly visible.
         % This is done after the units are all compiled, so they don't interfere with each other incorrectly.
         % Units later in the list have priority.
 454:    NodeIter unitIt = oNodeGetIter( user, qUsedUnits )
 467:    {
 467:       Node unit = oNodeIterValue( unitIt )
 477:       [ oNodeNull( unit )
 484:          | false :
 485:             oScopeEnter( oNodeGet( unit, qPublicScope ) )
 498:          | * :
 503:             >
 505:       ]
 505:       oNodeIterNext( unitIt )
 511:    }
 514:    ;
      
 514: EndUsedUnits( Node user ):
         % Leave the units' public scopes, so no longer visible.
 516:    NodeIter unitIt = oNodeGetIterLast( user, qUsedUnits )
 529:    {
 529:       Node unit = oNodeIterValue( unitIt )
 539:       [ oNodeNull( unit )
 546:          | false :
                  % Consistency check.  Make sure our scope enter / end have lined up correctly.
 547:             [ oNodeEqual( oScopeCurrent, oNodeGet( unit, qPublicScope ) )
 563:                | true :
 564:                | false :  #eInternalScopeMismatch
 568:             ]
 576:             oScopeEnd
 577:          | * :
 582:             >
 584:       ]
 584:       oNodeIterPrev( unitIt )
 590:    }
 593:    ;
      
      
 593: FindOrCompileUnit( int id ) >> Node:
         % We might have this unit loaded already
 595:    Node unit = oNodeFind( workspace, qUnits, qIdent, id )
 614:    [ equal_node( unit, Null )
 624:       | false :  >> unit
 628:       | * :
 633:    ]
      
         % If not, search for the source file on disk
 633:    boolean ok = oIncludeUnitFile( id )
 643:    [ ok
 646:       | false :  #eCantFindUnitFile  >> Null
 652:       | * :
 657:    ]
      
         % compile it, adding it into the workspace
         % then return it.
 657:    unit = @Unit
      
         % TO DO: ensure we are at pEof
         % end the include
 663:    oIncludeEnd
 664:    >> unit;
      
      
      
 668: Unit >> Node:
 670:    pUnit
 672:    pIdent
 674:    Node unit = oNodeNew( nUnit )
 684:    oNodeSetInt( unit, qIdent, LAST_ID )
 695:    Node unitImpl = oNodeNew( nUnitImpl )
 705:    oNodeSetInt( unitImpl, qIdent, LAST_ID )
 716:    oNodeSet( unit, qImpl, unitImpl )
 728:    ';'
      
         % mandatory sections
      
 730:    pInterface
 732:    [
 732:       | pUses :   @UsesClause( unit )
 741:       | * :
 746:    ]
 746:    @EnterUsedUnits( unit )
      
 753:    oScopeBegin( 0, allocGlobal )
 762:    oNodeSet( unit, qPublicScope, oScopeCurrent )
 773:    globalScope = oScopeCurrent
      
         % A scope for temporaries needed by variable initialization
 778:    oScopeBegin( 0, allocDown )
 787:    initScope = oScopeCurrent
 792:    oNodeSet( unit, qInitRoutineScope, initScope )
 804:    oScopeEnd
      
 805:    @UnitInterface( unit )
 812:    oScopeEnd  % interface scope
      
 813:    pImplementation
 815:    [
 815:       | pUses :   @UsesClause( unitImpl )
 824:       | * :
 829:    ]
 829:    @EnterUsedUnits( unitImpl )
         % re-enter interface scope after impl's uses.  interface still has priority.
 836:    oScopeEnter( oNodeGet( unit, qPublicScope ) )
         
 849:    oScopeBegin( 0, allocGlobal )
 858:    oNodeSet( unit, qPrivateScope, oScopeCurrent )
 869:    oNodeSet( oScopeCurrent, qExtends, oNodeGet( unit, qPublicScope ) )
 887:    globalScope = oScopeCurrent
 892:    @UnitImplementation( unit )
      
 899:    [
 899:       | pInitialization :  @UnitInitialization( unit, true )   % init routine with statements from init section
 911:       | * :                @UnitInitialization( unit, false )  % implicit init routine
 926:    ]
 926:    [
 926:       | pFinalization :  @UnitFinalization( unit, true )
 938:       | * :              @UnitFinalization( unit, false )   % implicit final routine, may be handy later
 953:    ]
 953:    pEnd  '.'
      
 957:    oScopeEnd  % impl scope
 958:    oScopeEnd  % interface scope
 959:    @EndUsedUnits( unitImpl )  % used units scopes
 966:    @EndUsedUnits( unit )
 973:    oNodeAddLast( workspace, qUnits, unit )
 985:    >> unit;
      
      
 989: UnitInterface( Node unit ):
 991:    {[
 991:       | pConst :     @ConstDecl
 995:       | pType :      @TypeDecl
 999:       | pVar :       @VarDecl( nGlobalVar )
            % label declaration not allowed in interface
      
1008:       | pProcedure :
1010:          Node decl = @ProcHeaderDecl
               % despite syntax diagrams, fpc does allow external clause on methods in unit interface,
               % even though this clause is an alternative for the body statement.
1016:          [
1016:             | pExternal :
1018:                @ExternalDecl( decl )
1025:                ';'
1027:             | * :
1032:          ]
      
1032:       | pFunction :
1034:          Node decl = @FuncHeaderDecl
1040:          [
1040:             | pExternal :
1042:                @ExternalDecl( decl )
1049:                ';'
1051:             | * :
1056:          ]
      
1056:       | * :          >
1071:    ]}
1074:    ;
      
1074: UnitImplementation( Node unit ):
1076:    @BlockDecls( nGlobalVar )
1084:    ;
      
      
1084: UnitInitialization( Node unit, boolean hasStmts ):
1086:    Label label = oLabelNew
1091:    .tLabel  oEmitLabel( label )
1099:    oNodeSetLabel( unit, qInitLabel, label )
      
1111:    int patchLS
1111:    .tEnter  patchLS = Here  .tSpace
      
         % insert any code for initialization of this unit's variables.
         
1120:    Node scope
1120:    Code initCode
      
1120:    scope = oNodeGet( unit, qPublicScope )
1133:    initCode = oNodeGetCode( scope, qInitCode )
1146:    oEmitCode( initCode )
1152:    oNodeSetCode( scope, qInitCode, codeNull )
      
1164:    scope = oNodeGet( unit, qPrivateScope )
1177:    initCode = oNodeGetCode( scope, qInitCode )
1190:    oEmitCode( initCode )
1196:    oNodeSetCode( scope, qInitCode, codeNull )
      
1208:    oScopeEnter( oNodeGet( unit, qInitRoutineScope ) )
      
1221:    [ hasStmts
1224:       | true :     
1225:          @Statement
1227:          {[
1227:             | ';' :  @Statement
1231:             | * :    >
1238:          ]}
1240:       | * :
1245:    ]
      
1245:    .tReturn
      
1247:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1259:    oPatch( patchLS, localSpace )
1268:    oScopeEnd   % init routine scope, for temporaries
1270:    ;
      
      
1270: UnitFinalization( Node unit, boolean hasStmts ):
1272:    Label label = oLabelNew
1277:    .tLabel  oEmitLabel( label )
1285:    oNodeSetLabel( unit, qFinalLabel, label )
      
1297:    int patchLS
1297:    .tEnter  patchLS = Here  .tSpace
      
         % final routine scope, for temporaries
1306:    oScopeBegin( 0, allocDown )
      
1315:    [ hasStmts
1318:       | true :     
1319:          @Statement
1321:          {[
1321:             | ';' :  @Statement
1325:             | * :    >
1332:          ]}
1334:       | * :
1339:    ]
      
1339:    .tReturn
      
1341:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1353:    oPatch( patchLS, localSpace )
1362:    oScopeEnd   % final routine scope, for temporaries
1364:    ;
      
      
1364: Block( node_type varNodeType, Label labelForBody ):
1366:    @BlockDecls( varNodeType )
1373:    @BlockStmt( labelForBody, oScopeCurrent, false )
1385:    @CheckForUndefinedLabels
1388:    ;
      
      
1388: BlockDecls( node_type varNodeType ):
1390:    {[
1390:       | pConst :     @ConstDecl
1394:       | pType :      @TypeDecl
1398:       | pVar :       @VarDecl( varNodeType )
1407:       | pLabel :     @LabelDecl
1411:       | pProcedure : @ProcDecl
1415:       | pFunction :  @FuncDecl
1419:       | * :          >
1436:    ]}
1438:    @CheckForUndefinedMethods
1441:    ;
      
      
      % were there any procedures or functions declared in this scope
      % that were never defined?
1441: CheckForUndefinedMethods:
         % TO DO
         % Note: disregard methods marked external
1444:    ;
      
      % were there any labels declared in the current scope, and used,
      % but never defined (as the prefix of a stement)?
      %
1444: CheckForUndefinedLabels:
1446:    NodeIter it = oNodeGetIter( oScopeCurrent, qDecls )
1458:    {
1458:       Node decl = oNodeIterValue( it )
1468:       [ oNodeNull( decl )
1475:          | false :
1476:          | * :  >
1483:       ]
1483:       [ oNodeType( decl )
1490:          | nLabel :
1491:             [ oNodeGetBoolean( decl, qDefined )
1501:                | false :
1502:                   [ oNodeGetBoolean( decl, qUsed )
1512:                      | true :    #eUsedButNotDefined  % TO DO: give the decl in the message
1515:                      | * :
1520:                   ]
1520:                | * :
1525:             ]
1525:          | * :
1530:       ]
1530:       oNodeIterNext( it )
1536:    }
1539:    ;
      
      
1539: InitializeUnits:
         % call init routine of each loaded unit, in the order they were loaded
         % (used directly or indirectly by the main program).
1541:    NodeIter it = oNodeGetIter( workspace, qUnits )
1554:    {
1554:       Node unit = oNodeIterValue( it )
1564:       [ oNodeNull( unit )
1571:          | true :  >
1574:          | false :
1576:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1584:             .tCall  oEmitLabel( oNodeGetLabel( unit, qInitLabel ) )
1599:             .tFreeActuals  oEmitInt( 0 )
1607:             oNodeIterNext( it )
1613:       ]
1621:    };
      
      
1624: FinalizeUnits:
1626:    NodeIter it = oNodeGetIterLast( workspace, qUnits )
1639:    {
1639:       Node unit = oNodeIterValue( it )
1649:       [ oNodeNull( unit )
1656:          | true :  >
1659:          | false :
1661:             .tAllocActuals  oEmitInt( 0 )  % not sure I need this. maybe for stack alignment.
1669:             .tCall  oEmitLabel( oNodeGetLabel( unit, qFinalLabel ) )
1684:             .tFreeActuals  oEmitInt( 0 )
1692:             oNodeIterPrev( it )
1698:       ]
1706:    };
      
      
      % Given the scope of vars in this block.
      % Usually it's the current scope, but it's a bit different for the main statement.
      %
1709: BlockStmt( Label labelForBody, Node varScope, boolean isMain ):
1711:    .tLabel  oEmitLabel( labelForBody )
      
         % Proc, func, and main routine all start with tEnter
         % to create a stack frame.  This will be used for temporaries
         % (and local vars in the case of proc, func).
      
1719:    int patchLS
1719:    .tEnter  patchLS = Here  .tSpace
      
         % If we're generating the program main method,
         % add in calls to the loaded units' initialization and finalization.
1728:    [ isMain
1731:       | true :  @InitializeUnits
1734:       | * :
1739:    ]
      
         % insert any code for initialization of this scope's variables
1739:    Code initCode = oNodeGetCode( varScope, qInitCode )
1752:    oEmitCode( initCode )
1758:    oNodeSetCode( varScope, qInitCode, codeNull )
      
1770:    @Statement
      
1772:    [ isMain
1775:       | true :  @FinalizeUnits
1778:       | * :
1783:    ]
      
1783:    .tReturn
      
1785:    int localSpace = oNodeGetInt( oScopeCurrent, qSize )
1797:    oPatch( patchLS, localSpace )
1807:    ;
      
      
      % modifers that may appear on a proc/function declaration.
      %
1807: MethodModifiers( Node decl ):
1809:    {[
1809:       | pCdecl :
1811:          oNodeSetBoolean( decl, qCdecl, true )
1823:          ';'
      
1825:       | * : >
1832:    ]}
1835:    ;
      
      
      % We need an initCode code stream for the given scope.
      % Create it if not present yet.  Return it.
      % (This will be used for variable initialization.)
      %
1835: GetOrCreateInitCode( Node scope ) >> Code:
1837:    Code initCode = oNodeGetCode( scope, qInitCode )
1850:    [ equal_code( initCode, codeNull )
1860:       | true :
1861:          initCode = oCodeNew
1866:          oNodeSetCode( scope, qInitCode, initCode )
1878:       | * :
1883:    ]
1883:    >> initCode;
      
      
      % external method resides in an external object file
      % (or in my system, the built-in runtime library).
      % The method has a label, as usual, which callers will use.
      % But we define that label with .tLabelExtern rather than .tLabel.
      %
      % Note, I'll hold off on issuing the .tLabelExtern until we see that
      % the external method is actually called.  Otherwise we'd fill each output file
      % with all the external method names in my included libraries, which seems dumb.
      %
      % Note this is fpc syntax.  I'm not sure about other Pascals.
      %
1887: ExternalDecl( Node decl ):
1889:    [ equal_zero( @DeclLevel( decl ) )
1901:       | false :  #eExternalMethodCannotBeNested
1904:       | * :
1909:    ]
1909:    oNodeSetBoolean( decl, qExternal, true )
1921:    [
1921:       | pStrLit :
               % that was the optional library name containing the method.
               % TO DO: I'm currently ignoring this.
1923:          [
1923:             | pName :
1925:                pStrLit
                     % that was the optional method name defined in that library,
                     % which might differ from the Pascal name.
1927:                oNodeSetString( decl, qExternalName, CURRENT_STRLIT )
1938:             | * :
1943:          ]
1943:       | * :
1948:    ]
1949:    ;
      
      
1949: ProcHeaderDecl >> Node:
1951:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
1953:    boolean redeclaring = false
1959:    Node decl = oScopeFindInCurrentScope
      
1964:    [ oNodeNull( decl )
1971:       | true :
               % first declaration
1972:          decl = @newIdent( nProc, LAST_ID )
1985:          oNodeSetLabel( decl, qValue, oLabelNew )
      
1996:       | false :
               % we already have a declaration.
               % Keep it, and its label.
1998:          redeclaring = true
2004:          [ oNodeGetBoolean( decl, qBodyDefined )
2014:             | true : #eAlreadyDefined
2017:             | * :
2022:          ]
2022:          [ oNodeGetBoolean( decl, qExternal )
2032:             | true : #eAlreadyDefined
2035:             | * :
2040:          ]
2040:          [ oNodeType( decl )
2047:             | nProc :
2048:             | * : #eAlreadyDefined   % wrong kind
2055:          ]
               % Move the existing param scope aside, so we can check that the
               % new one is consistent.  And, the body will want to see the new one
               % since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2055:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2074:          oNodeSet( decl, qParams, Null )
2086:    ]
      
2094:    int level = @ScopeLevel
2100:    boolean nested = greater( level, 0 )
2113:    inc( level )
2119:    oScopeBegin( level, allocUp )
2128:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2133:    [ nested
2136:       | true :
2137:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2152:       | * :
2157:    ]
      
2157:    @FormalArgDecl
2159:    oNodeSet( decl, qParams, paramScope )
2171:    oScopeEnd
2172:    ';'
      
2174:    [ redeclaring
2177:       | false : oScopeDeclare( decl )
2184:       | true :  % TO DO: check that qParams is consistent with qOldParams
2186:    ]
      
2194:    @MethodModifiers( decl )
2201:    >> decl;
      
      
2205: ProcDecl:
2207:    Node decl = @ProcHeaderDecl
      
         % Body may be a statement, "forward", "external".
         % Note, this syntax is based on FPC, and I'm not sure if other Pascals are similar.
         % FPC says that forward, external, cdecl, name, etc are not reserved words -
         % I think this means the user may declare other things with those names, but if so the
         % original meaning is lost.  I'll make them keywords for simplicity, for now
         % (just not too happy about "name").
      
2213:    [
2213:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2215:       | pExternal : @ExternalDecl( decl )
      
2224:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2231:          Node paramScope = oNodeGet( decl, qParams )
2244:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the proc
2250:          int level = oNodeGetInt( paramScope, qLevel )
2263:          oScopeBegin( level, allocDown )
2272:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2283:          Label label = oNodeGetLabel( decl, qValue )
2296:          @Block( nLocalVar, label )
2306:          oNodeSetBoolean( decl, qBodyDefined, true )
2318:          oScopeEnd
      
2319:          oScopeEnd  % paramScope
2320:    ]
2320:    ';';
      
      
      
2323: FuncHeaderDecl >> Node:
2325:    pIdent
      
         % If we already have a forward declaration, we'll modify that decl
         % instead of creating a second symbol table entry.
         % (Alternatively could delete or hide the old entry.)
2327:    boolean redeclaring = false
2333:    Node decl = oScopeFindInCurrentScope
      
2338:    [ oNodeNull( decl )
2345:       | true :
               % first declaration
2346:          decl = @newIdent( nFunc, LAST_ID )
2359:          oNodeSetLabel( decl, qValue, oLabelNew )
      
2370:       | false :
               % we already have a declaration.
               % Keep it, and its label.
2372:          redeclaring = true
2378:          [ oNodeGetBoolean( decl, qBodyDefined )
2388:             | true : #eAlreadyDefined
2391:             | * :
2396:          ]
2396:          [ oNodeType( decl )
2403:             | nFunc :
2404:             | * : #eAlreadyDefined   % wrong kind
2411:          ]
               % Move the existing param scope and return value aside,
               % so we can check that the new one is consistent.
               % And, the body will want to see the new one since the names might differ.
               % TO DO: If qOldParams already set, we have multiple forward decls,
               % which I believe is supposed to be an error.
2411:          oNodeSet( decl, qOldParams, oNodeGet( decl, qParams ) )
2430:          oNodeSet( decl, qParams, Null )
2442:          oNodeSet( decl, qOldType, oNodeGet( decl, qType ) )
2461:          oNodeSet( decl, qType, Null )
2473:    ]
      
2481:    int level = @ScopeLevel
2487:    boolean nested = greater( level, 0 )
2500:    inc( level )
2506:    oScopeBegin( level, allocUp )
2515:    Node paramScope = oScopeCurrent
      
         % A nested method has a hidden first param for the parent static scope.
         % This won't appear in the param decls list, just reserve space for it.
         % It's first so the static chain is always at a fixed offset from the frame pointer.
2520:    [ nested
2523:       | true :
2524:          int offset = oScopeAllocType( @PointerTypeTo( IntegerType ) )   % arbitrary ptr type
2539:       | * :
2544:    ]
      
2544:    @FormalArgDecl
2546:    oNodeSet( decl, qParams, paramScope )
      
2558:    ':'
      
2560:    Node theType
2560:    @TypeRef( theType )
2567:    oNodeSet( decl, qType, theType )
      
         % The function's param space gets an additional pointer,
         % which will point to a temporary in the caller's scope.
         % This pointer is essentially a VAR param, but I won't create an nParam for it.
      
2579:    Node ptrType = @PointerTypeTo( theType )
2590:    oNodeSetInt( decl, qResultOffset, oScopeAllocType( ptrType ) )
2606:    oScopeEnd
2607:    ';'
      
2609:    [ redeclaring
2612:       | false : oScopeDeclare( decl )
2619:       | true :  % TO DO: check that qParams is consistent with qOldParams
                      % and qType is consistent with qOldType
2621:    ]
      
2629:    @MethodModifiers( decl )
      
2636:    >> decl;
      
      
2640: FuncDecl:
2642:    Node decl = @FuncHeaderDecl
      
         % Body may be a statement, "forward", "external".
2648:    [
2648:       | pForward :
               % Nothing to do.  We simply won't set qBodyDefined.
      
2650:       | pExternal : @ExternalDecl( decl )
      
2659:       | * :
               % Body statement
      
               % Enter the params scope again, so params are visible in body.
               % TO DO: Perhaps I could mark the scope read-only at this point.
2666:          Node paramScope = oNodeGet( decl, qParams )
2679:          oScopeEnter( paramScope )
      
               % Start scope for declarations within the func
2685:          int level = oNodeGetInt( paramScope, qLevel )
2698:          oScopeBegin( level, allocDown )
2707:          oNodeSet( decl, qChildScope, oScopeCurrent )
      
2718:          Label label = oNodeGetLabel( decl, qValue )
2731:          @Block( nLocalVar, label )
2741:          oNodeSetBoolean( decl, qBodyDefined, true )
2753:          oScopeEnd
      
2754:          oScopeEnd  % paramScope
2755:    ]
2755:    ';';
      
      
2758: FormalArgDecl:
2760:    [
2760:       | '(' :
2762:          {
2762:             NodeVec decls = oNodeVecNew
2767:             Node decl
2767:             boolean isInOut = false
      
2773:             [
2773:                | pVar : isInOut = true
2781:                | * :
2786:             ]
      
2786:             {  pIdent
      
2788:                decl = @newIdent( nParam, LAST_ID )
2801:                oNodeSetBoolean( decl, qInOut, isInOut )
2813:                oNodeVecAppend( decls, decl )
      
2822:                [
2822:                   | ':' : >
2826:                   | ',' :
2828:                ]
2836:             }
      
2838:             Node theType
2838:             @TypeRef( theType )
      
                  % VAR param is declared with its given type, but allocated as a pointer.
2845:             Node allocType
2845:             [ isInOut
2848:                | true :   allocType = @PointerTypeTo( theType )
2860:                | * :      allocType = theType
2871:             ]
      
2871:             int i = 0
2877:             {[ equal( i, oNodeVecSize( decls ) )
2891:                | false :
2892:                   decl = oNodeVecElement( decls, i )
      
2905:                   oNodeSet( decl, qType, theType )
2917:                   oScopeDeclare( decl )
2923:                   oNodeSetInt( decl, qValue, oScopeAllocType( allocType ) )
2939:                   inc( i )
2945:                | * :
2950:                   >
2952:             ]}
      
2954:             oNodeVecDelete( decls )
      
2960:             [
2960:                | ')' : >
2964:                | ';' :
2966:             ]
2974:          }
2976:       | * :
2981:    ];
      
2982: ConstDecl:
2984:    {[
2984:       | pIdent :
2986:          Node decl = @newIdent( nConst, LAST_ID )
2999:          '='
      
3001:          @ConstExpr
               % TO DO: currently ConstExpr leaves int result on oValue stack
3003:          int val = oValueTop
3008:          oValuePop
3009:          oNodeSetInt( decl, qValue, val )
      
               % TO DO: different types.  Currently assumes int!
3021:          oNodeSet( decl, qType, IntegerType )
      
3033:          oScopeDeclare( decl )
3039:          ';'
3041:       | * :
3046:          >
3048:    ]};
      
3051: TypeDecl:
3053:    {[
3053:       | pIdent :
3055:          Node decl = @newIdent( nTypeDecl, LAST_ID )
3068:          '='
3070:          Node theType
3070:          @TypeRef( theType )
3077:          oNodeSet( decl, qType, theType )
3089:          oScopeDeclare( decl )
3095:          ';'
3097:       | * :
3102:          >
3104:    ]};
      
3107: VarDecl( node_type varNodeType ):
3109:    {[
3109:       | pIdent :
3111:          NodeVec decls = oNodeVecNew
3116:          Node decl
3116:          {
3116:             decl = @newIdent( varNodeType, LAST_ID )
3129:             oNodeVecAppend( decls, decl )
3138:             [
3138:                | ',' :
3140:                   pIdent
3142:                | * :
3147:                   >
3149:             ]
3149:          }
3151:          ':'
3153:          Node theType
3153:          @TypeRef( theType )
      
3160:          int i = 0
3166:          {[ equal( i, oNodeVecSize( decls ) )
3180:             | false :
3181:                decl = oNodeVecElement( decls, i )
3194:                oNodeSet( decl, qType, theType )
3206:                oScopeDeclareAlloc( decl )
3212:                inc( i )
3218:             | * :
3223:               >
3225:          ]}
      
               % optional initialization
3227:          [
3227:             | '=' :
3229:                [ oNodeVecSize( decls )
3236:                   | 1 :
3237:                   | * :  #eOnlyOneVarCanBeInitialized
3244:                ]
      
                     % we need an initCode stream for this scope
3244:                Code initCode = @GetOrCreateInitCode( oScopeCurrent )
3254:                oCodePush( initCode )
      
                     % currently the global level has two scopes:
                     % the one for declarations e.g. vars and methods,
                     % and a second one for temporaries needed by the main block stmt.
                     % During evaluation of the init expr, we need to be in the 2nd scope
                     % in case the expression requires temporaries
                     % (so the temporaries get allocated in the right scope).
                     % TO DO: Maybe I should make the global scope the special case, instead.
3260:                boolean changedScope = false
3266:                [ equal_zero( @ScopeLevel )
3273:                   | true : oScopeEnter( initScope )
3280:                            changedScope = true
3286:                   | * :
3291:                ]
                     % generate assignment in initCode stream
3291:                @LValueVar( decl )
3298:                @Expr
3300:                @MatchTypes
3302:                @Assign
3304:                [ changedScope
3307:                   | true : oScopeEnd
3309:                   | * :
3314:                ]
3314:                oCodePop
                   
3315:             | * :
3320:          ]
      
3320:          oNodeVecDelete( decls )
3326:          ';'
3328:       | * :
3333:          >
3335:    ]};
      
      
      % Parse a list of label declarations.
      % We'll create a tcode label at declaration time, for each user label.
      % If the user label is an integer, we'll record it as _label_<int> in the decl.
      %
3338: LabelDecl:
3340:    {
3340:       Node decl
3340:       [
3340:          | pIdent :
3342:          | pIntLit :
                  % Replace token with identifier "_label_<intlit>"
3344:             oChangeIntLitToLabelIdent
3345:       ]
3353:       decl = @newIdent( nLabel, LAST_ID )
            % TO DO: ensure not already declared in this scope.
            %        Or maybe that can be part of oScopeDeclare.
3366:       Label label = oLabelNew
3371:       oNodeSetLabel( decl, qValue, label )
3383:       oScopeDeclare( decl )
3389:       [
3389:          | ',' :
3391:          | * :
3396:             >
3398:       ]
3398:    }
3400:    ';'
3403:    ;
      
      
      % Parse a type reference, returning the nType.
      % This will add types to the type table, as needed.
      %
      % Style question - at the moment I think callers look clearer if we use
      % an out param here, rather than a return value.
      %
3403: TypeRef( out Node resultType ):
3405:    [
3405:       | pIdent :           % previously named type (including intrinsics)
3407:          Node decl = oScopeFindRequire
3412:          @ResolveUnitRef( decl )
3419:          [ oNodeType( decl )
3426:             | nTypeDecl :
3427:                resultType = oNodeGet( decl, qType )
3440:             | * :
3445:                #eNotType
3447:                resultType = IntegerType
3453:          ]
         
3453:       | pArray :
3455:          '['
      
               % A multi-dimensional array is represented as a chain
               %    array [subrange1] of array [subrange2] of elementType
      
               % First, we build a vector of nArray's, each with one subrange as its index type,
               % but without setting the "of" type or size.
      
3457:          NodeVec dimensions = oNodeVecNew
      
3462:          {
                  % to do: probably should use general subrange parsing, incl minimal size value
                  %   In fact, supposed to parse ordinal_type here.  all ordinal types have a static low, high.
                  %   Not necessary to be a subrange.
      
3462:             Node subrange = oNodeNew( nSubrangeType )
                  % TO DO: currently assuming subrange of integer
3472:             oNodeSet( subrange, qBaseType, IntegerType )
      
                  % TO DO: currently ConstExpr leaves int result on oValue stack
3484:             @ConstExpr
3486:             oNodeSetInt( subrange, qLow, oValueTop )
3497:             oValuePop
3498:             '..'
3500:             @ConstExpr
3502:             oNodeSetInt( subrange, qHigh, oValueTop )
3513:             oValuePop
3514:             oNodeSetInt( subrange, qSize, 4 )   % maybe don't need
      
3526:             oTypeAdd( subrange )
      
3532:             Node a = oNodeNew( nArrayType )
3542:             oNodeSet( a, qIndexType, subrange )
      
3554:             oNodeVecAppend( dimensions, a )
                  % I'll hold off on adding 'a' to the type table since not fully formed yet
      
3563:             [
3563:                | ']' : >
3567:                | ',' :
3569:             ]
3577:          }
      
3579:          pOf
3581:          Node baseType
3581:          @TypeRef( baseType )
      
               % Work backwards through the dimensions,
               % hooking up the 'of' type and calculating the size.
               % At each iteration, baseType is the 'of' type.
      
3588:          int dim = oNodeVecSize( dimensions )
      
3598:          {
3598:              dec(dim)
      
3604:              Node a = oNodeVecElement( dimensions, dim )
      
3617:              oNodeSet( a, qBaseType, baseType )
3629:              Node subrange = oNodeGet( a, qIndexType )
3642:              int width = subtract( oNodeGetInt( subrange, qHigh ), oNodeGetInt( subrange, qLow ) )
3669:              inc( width )
3675:              oNodeSetInt( a, qSize, multiply( width, oNodeGetInt( baseType, qSize ) ) )
      
3701:              oTypeAdd( a )
3707:              baseType = a
      
3713:              [ equal_zero(dim)
3720:                  | true:  >
3723:                  | *:
3728:              ]
3728:          }
      
3730:          resultType = oNodeVecElement( dimensions, 0 )
3743:          oNodeVecDelete( dimensions )
      
3749:       | '^' :
3751:          Node theType
3751:          @TypeRef( theType )
3758:          resultType = @PointerTypeTo( theType )
      
3769:       | pRecord :
3771:          resultType = oNodeNew( nRecordType )
3781:          oScopeBegin( -1, allocUp )    % level is meaningless here
      
3790:          @VarDecl( nRecordField )
      
3797:          int size = oNodeGetInt( oScopeCurrent, qSize )
               % to do: padding
3809:          [ equal_zero( size )
3816:             | true : #eRecordEmpty
3819:             | * :
3824:          ]
      
3824:          pEnd
      
3826:          oNodeSet( resultType, qScope, oScopeCurrent )
3837:          oNodeSetInt( resultType, qSize, size )
3849:          oScopeEnd
3850:          oTypeAdd( resultType )
      
      
3856:       | '(' :
               % An enum type declaration.
3858:          resultType = oNodeNew( nEnumType )
3868:          int value = 0
3874:          int numValues = 0
3880:          boolean first = true
      
               % We'll declare the enum values in two scopes: the current scope, and a scope nested in the enum type.
               % That will let programs use either <val> or <enumType>.<val>
3886:          Node outerScope = oScopeCurrent
3891:          oScopeBegin( -1, allocUp )   % level is meaningless, and we won't use allocate
      
3900:          {
                  % TO DO: assert that name not already seen in this scope, i.e. this enum.
                  %  And possibly not in the outerScope either, since that probably wouldn't count as shadowing.
                  %  It might be in some other higher/used scope.
3900:             pIdent
3902:             Node decl = @newIdent( nEnumValue, LAST_ID )
3915:             Node decl2 = @newIdent( nEnumValue, LAST_ID )
3928:             oNodeSet( decl, qType, resultType )
3940:             oNodeSet( decl2, qType, resultType )
      
                  % build up name table, for i/o
3952:             int nameOffset = oStringAllocLit( ID_STRING( LAST_ID ) )
3965:             oNodeSetInt( decl, qNameOffset, nameOffset )
3977:             oNodeSetInt( decl2, qNameOffset, nameOffset )
3989:             [
3989:                | '=', ':=' :
3991:                   @ConstExpr
                        % value must be ascending
                        % this obviously doesn't apply to the first value
3993:                   [ equal_zero( numValues )
4000:                      | false :
4001:                         [ greater( oValueTop, value )
4010:                            | false :   #eEnumValueNotAscending
4013:                            | * :
4018:                         ]
4018:                      | * :
4023:                   ]
4023:                   value = oValueTop
4028:                   oValuePop
4029:                | * :
4036:             ]
4036:             oNodeSetInt( decl, qValue, value )
4048:             oNodeSetInt( decl2, qValue, value )
4060:             oScopeDeclare( decl )
      
4066:             oScopeEnter( outerScope )
4072:             oScopeDeclare( decl2 )
4078:             oScopeEnd
      
4079:             inc( value )
4085:             inc( numValues )
4091:             [
4091:                | ',' :
4093:                | * :    >
4100:             ]
4100:          }
4102:          ')'
      
4104:          oNodeSet( resultType, qScope, oScopeCurrent )
4115:          oNodeSetInt( resultType, qSize, 4 )   % always integer sized
4127:          oScopeEnd
      
               % Finish creation of the name table
               %    struct {
               %      int    value;
               %      int    padding;
               %      char*  name;
               %    } table[ numValues + 1 ];
               %  final entry will have name == nullptr
               %
               % I'll need to generate init code, to store pointers in global data,
               % since I don't have a relocation mechanism for static data at the moment.
4128:          oCodePush( @GetOrCreateInitCode( globalScope ) )
4139:          oScopeEnter( globalScope )
4145:          int size = multiply( add( numValues, 1 ), 16 )
4165:          int addr = oScopeAlloc( size, 8 )
4178:          oScopeEnd
4179:          oNodeSetInt( resultType, qNameTable, addr )
               % loop over enum values
4191:          NodeIter it = oNodeGetIter( oNodeGet( resultType, qScope ), qDecls )
4211:          {
4211:             Node enumValue = oNodeIterValue( it )
4221:             [ oNodeNull( enumValue )
4228:                | true :  >
4231:                | * :
4236:             ]
4236:             .tPushAddrGlobal  oEmitInt( addr )
4244:             .tPushConstI  oEmitInt( oNodeGetInt( enumValue, qValue ) )
4259:             .tAssignI
4261:             addr = add( addr, 8 )
4274:             .tPushAddrGlobal  oEmitInt( addr )
4282:             .tPushAddrGlobal  oEmitInt( oNodeGetInt( enumValue, qNameOffset ) )
4297:             .tAssignP
4299:             addr = add( addr, 8 )
4312:             oNodeIterNext( it )
4318:          }
               % final table entry
4320:          .tPushAddrGlobal  oEmitInt( addr )
4328:          .tPushConstI  oEmitInt( 0 )
4336:          .tAssignI
4338:          addr = add( addr, 8 )
4351:          .tPushAddrGlobal  oEmitInt( addr )
4359:          .tPushConstI  oEmitInt( 0 )
4367:          .tAssignP
4369:          addr = add( addr, 8 )
4382:          oCodePop
      
4383:          oTypeAdd( resultType )
      
      
            % *** TO DO: following type constructors are not implemented *** 
4389:       | pSet :
4391:          pOf
4393:          Node theType
4393:          @TypeRef( theType )
4400:       | * :       % this works for cases except where expr starts with an id
4415:          @ConstExpr '..' @ConstExpr
4421:    ];
      
      
      % --------------------------- Const Expressions --------------------------
      
      % Constant expressions: currently, only literal integers or previously
      % named constant integers are supported, possibly with a negation.
      % Constant expressions are evaluated at compile time.
      
4422: ConstExpr:
4424:    [
4424:       | pIntLit :
4426:          oValuePush( TOKEN_VALUE )
4431:       | pIdent :
4433:          Node decl = oScopeFindRequire
4438:          @ResolveUnitRef( decl )
4445:          [ oNodeType( decl )
4452:             | nConst :
4453:                oValuePush( oNodeGetInt( decl, qValue ) )
4466:             | * :
4471:                #eNotConst
4473:                oValuePush( 0 )
4479:          ]
4479:       | pMinus :
4481:          @ConstExpr
4483:          oValueNegate
4484:    ];
      
      
      
      % ------------------------------ Expressions -----------------------------
      
      % There are two wrappers leading into expression parsing:
      %   Expr()
      %   BooleanExprControlFlow( out Label falseLabel )
      %
      % Expr always produces a value on the runtime expr stack,
      % and pushes its type on the type stack.
      %
      % BooleanExprControlFlow always generates control-flow code.
      % It does not push a value on the runtime expr stack.
      % It does not push a type on the type stack.
      % The control flow code ends up at Here if the expr is true,
      % and jumps to falseLabel if the expr is false.
      % This rule allocates falseLabel, and passes it back.
      % The caller will need to define its location.
      %
      % The internal methods of expr parsing may produce a mix of
      % values and control flow, depending on the operators seen.
      % We don't always do one or the other, hoping to be efficient for
      % cases like   "func_call( bool_var1, bool_var2 )"
      % as well as  "if bool_expr1 or bool_expr2 then ...".
      % If a subexpression rule produces control flow, it will allocate a
      % falseLabel and pass it back up.  And it will push the
      % result type as BooleanCFType, to distinguish from BooleanType
      % which corresponds with a boolean value on the expr stack.
      % 
      % Note that my expression parsing is broken into more levels than
      % grammars describe for Pascal precedence levels.  This follows my
      % original parser implementation.  I think my rationale was that
      % operators from the levels that I split up couldn't have been
      % mixed anyway, since they require different data types
      % (e.g. boolean vs int/real).  And splitting them up simplified
      % my code.  But, I should revisit this.
      %
      
      
      % Public entry point:
      %
      % Parse an expression, leaving a value on the runtime expr stack
      % and its type on the type stack.
      %
      % This rule does not export control flow (though it may generate
      % control flow internally for subexpressions).
      %
4495: Expr:
4497:    Label falseLabel = labelNull
      
4503:    @ExprAllowCF( falseLabel )
4510:    @CFToVal( falseLabel );
      
      
      % Public entry point:
      %
      % Parse a Boolean expression, producing control flow code rather than a value.
      % Does not leave a value on the runtime expr stack.
      % Does not leave a type on the type stack.
      %
      % If the expression is true, the code will fall through to the end (Here).
      % If the expression is false, the code will jump to the given falseLabel,
      % which this rule will allocate but not define the location for.
      % The caller must do so.
      %
4518: BooleanExprControlFlow( out Label falseLabel ):
4520:    @ExprAllowCF( falseLabel )
4527:    [ oTypeSNodeType
4529:       | nBooleanCFType :
4530:       | nBooleanType :
               % convert value to control flow
4532:          falseLabel = oLabelNew
4537:          .tJumpFalse  oEmitLabel( falseLabel )
4545:       | * :
4552:          #eNotBoolean
4554:    ]
4554:    oTypeSPop;
      
      
      % If the current expr result is control flow, convert it to a value.
      % falseLabel is the label that had been used by the control flow.
      % On return it will be set to labelNull.
      %
4556: CFToVal( inout Label falseLabel ):
4558:    [ oTypeSNodeType
4560:       | nBooleanCFType :
4561:          Label doneLabel = oLabelNew
4566:          .tPushConstI  oEmitInt( 1 )
4574:          .tJump  oEmitLabel( doneLabel )
4582:          .tLabel  oEmitLabel( falseLabel )
4590:          .tPushConstI  oEmitInt( 0 )
4598:          .tLabel  oEmitLabel( doneLabel )
4606:          oTypeSPop
4607:          oTypeSPush( BooleanType )
4613:          falseLabel = labelNull
4619:       | * :
4624:    ];
      
      
      % If the current expr result is boolean value, convert it to control flow.
      % falseLabel will be allocated by this rule and passed back.
      % The caller must define its location.
      %
4625: ValToCF( out Label falseLabel ):
4627:    [ oTypeSNodeType
4629:       | nBooleanType :
4630:          falseLabel = oLabelNew
4635:          .tJumpFalse  oEmitLabel( falseLabel )
4643:          oTypeSPop
4644:          oTypeSPush( BooleanCFType )
4650:       | * :
4655:    ];
      
      
      % Parse an expression.  It may produce a value on the expr stack,
      % or control flow, depending on what's seen in the expression.
      % Leaves the expression type on the type stack.
      %
      % If the expression produces control flow, the expression type will be
      % nBooleanCFType.  In this case, a true value falls through to Here,
      % and a false value jumps to falseLabel.  This rule will allocate falseLabel
      % and return it, but will not define its location; the caller must do so.
      %
      % If the expression produces a value, the value will be left on the
      % expression stack, and the type will be some type other than nBooleanCFType.
      % In this case, falseLabel is ignored.
      %
4656: ExprAllowCF( out Label falseLabel ):
4658:    @BoolExprAllowCF( falseLabel )
4665:    {[
4665:       | '=' :
4667:          @CFToVal( falseLabel )
4674:          @PromoteToIntOptional
4676:          @BoolExprAllowCF( falseLabel )
4683:          @CFToVal( falseLabel )
4690:          @PromoteToIntOptional
4692:          @MatchTypes
4694:          [ oTypeSNodeType
4696:             | nIntegerType, nEnumType, nBooleanType :  .tEqualI
4699:             | nPointerType :                .tEqualP
4703:             | nCharType, nStringType :      #eNotImplemented
4707:             | * :                           #eNotAllowed
4724:          ]
4724:          oTypeSPop
4725:          oTypeSPush( BooleanType )
      
4731:       | '<>' :
4733:          @CFToVal( falseLabel )
4740:          @PromoteToIntOptional
4742:          @BoolExprAllowCF( falseLabel )
4749:          @CFToVal( falseLabel )
4756:          @PromoteToIntOptional
4758:          @MatchTypes
4760:          [ oTypeSNodeType
4762:             | nIntegerType, nEnumType, nBooleanType :  .tNotEqualI
4765:             | nPointerType :                .tNotEqualP
4769:             | nCharType, nStringType :      #eNotImplemented
4773:             | * :                           #eNotAllowed
4790:          ]
4790:          oTypeSPop
4791:          oTypeSPush( BooleanType )
      
4797:       | '<' :
4799:          @CFToVal( falseLabel )
4806:          @PromoteToIntOptional
4808:          @BoolExprAllowCF( falseLabel )
4815:          @CFToVal( falseLabel )
4822:          @PromoteToIntOptional
4824:          @MatchTypes
4826:          [ oTypeSNodeType
4828:             | nIntegerType, nEnumType, nBooleanType :  .tLessI
4831:             | nCharType, nStringType :      #eNotImplemented
4835:             | * :                           #eNotAllowed
4850:          ]
4850:          oTypeSPop
4851:          oTypeSPush( BooleanType )
      
4857:       | '>' :
4859:          @CFToVal( falseLabel )
4866:          @PromoteToIntOptional
4868:          @BoolExprAllowCF( falseLabel )
4875:          @CFToVal( falseLabel )
4882:          @PromoteToIntOptional
4884:          @MatchTypes
4886:          [ oTypeSNodeType
4888:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterI
4891:             | nCharType, nStringType :      #eNotImplemented
4895:             | * :                           #eNotAllowed
4910:          ]
4910:          oTypeSPop
4911:          oTypeSPush( BooleanType )
      
4917:       | '<=' :
4919:          @CFToVal( falseLabel )
4926:          @PromoteToIntOptional
4928:          @BoolExprAllowCF( falseLabel )
4935:          @CFToVal( falseLabel )
4942:          @PromoteToIntOptional
4944:          @MatchTypes
4946:          [ oTypeSNodeType
4948:             | nIntegerType, nEnumType, nBooleanType :  .tLessEqualI
4951:             | nCharType, nStringType :      #eNotImplemented
4955:             | * :                           #eNotAllowed
4970:          ]
4970:          oTypeSPop
4971:          oTypeSPush( BooleanType )
      
4977:       | '>=' :
4979:          @CFToVal( falseLabel )
4986:          @PromoteToIntOptional
4988:          @BoolExprAllowCF( falseLabel )
4995:          @CFToVal( falseLabel )
5002:          @PromoteToIntOptional
5004:          @MatchTypes
5006:          [ oTypeSNodeType
5008:             | nIntegerType, nEnumType, nBooleanType :  .tGreaterEqualI
5011:             | nCharType, nStringType :      #eNotImplemented
5015:             | * :                           #eNotAllowed
5030:          ]
5030:          oTypeSPop
5031:          oTypeSPush( BooleanType )
      
5037:       | * :
5052:          >
5054:    ]};
      
      
5057: BoolExprAllowCF( out Label falseLabel ):
5059:    Label trueLabel = labelNull
      
5065:    @BoolTermAllowCF( falseLabel )
5072:    {[
5072:       | pOr :
5074:          [ oTypeSNodeType
5076:             | nBooleanCFType :
                     % We are true here. Jump ahead to done
5077:                [ equal_label( trueLabel, labelNull )
5087:                   | true :  trueLabel = oLabelNew
5093:                   | * :
5098:                ]
5098:                .tJump  oEmitLabel( trueLabel )
5106:             | nBooleanType :
5108:                @ValToCF( falseLabel )
                     % We are true here. Jump ahead to done
5115:                [ equal_label( trueLabel, labelNull )
5125:                   | true :  trueLabel = oLabelNew
5131:                   | * :
5136:                ]
5136:                .tJump  oEmitLabel( trueLabel )
5144:             | * : #eNotBoolean
5153:          ]
5153:          oTypeSPop
      
               % false in previous term will jump here, to try this alternative term
5154:          .tLabel  oEmitLabel( falseLabel )
      
               % we'll get a new falseLabel for this term
5162:          falseLabel = labelNull
5168:          @BoolTermAllowCF( falseLabel )
      
5175:          [ oTypeSNodeType
5177:             | nBooleanCFType :
5178:             | nBooleanType :
5180:                @ValToCF( falseLabel )
5187:             | * : #eNotBoolean
5196:          ]
      
5196:          oTypeSPop
5197:          oTypeSPush( BooleanCFType )
      
5203:       | * :
5208:          >
5210:    ]}
      
         % any short-circuit trues jump here to the end
5212:    [ equal_label( trueLabel, labelNull )
5222:       | false :
5223:          .tLabel  oEmitLabel( trueLabel )
5231:       | * :
5236:    ]
5237:    ;
      
      
5237: BoolTermAllowCF( out Label falseLabel ):
5239:    Label overallFalseLabel = labelNull
      
5245:    @BoolFactorAllowCF( falseLabel )
5252:    {[
5252:       | pAnd :
5254:          [ oTypeSNodeType
5256:             | nBooleanCFType :
5257:             | nBooleanType :
5259:                @ValToCF( falseLabel )
5266:             | * :
5273:                #eNotBoolean
5275:          ]
5275:          oTypeSPop
      
               % We're going to have a different falseLabel for each term,
               % because we let each rule allocate its own (rather than accepting labels passed in).
               % And in this case we want them all to go to the same place,
               % to be determined by the caller.
               %
               % I'll allow for label aliases.  This will be more optimal than generating
               % multiple private false-handling code segments, that the true path would have to
               % jump around.  That would be hard to eliminate afterwards.
      
5276:          [ equal_label( overallFalseLabel, labelNull )
5286:             | true :
5287:                overallFalseLabel = oLabelNew
5292:                .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( overallFalseLabel )
5306:                falseLabel = overallFalseLabel
5312:             | * :
5317:          ]
      
5317:          Label factorFalseLabel = labelNull
5323:          @BoolFactorAllowCF( factorFalseLabel )
      
5330:          [ oTypeSNodeType
5332:             | nBooleanCFType :
5333:             | nBooleanType :
5335:                @ValToCF( factorFalseLabel )
5342:             | * : #eNotBoolean
5351:          ]
5351:         .tLabelAlias  oEmitLabel( factorFalseLabel )  oEmitLabel( overallFalseLabel )
      
5365:       | * :
5370:          >
5372:    ]};
      
5375: BoolFactorAllowCF( out Label falseLabel ):
5377:    [
5377:       | pNot :
5379:          Label factorFalseLabel = labelNull
      
5385:          @BoolFactorAllowCF( factorFalseLabel )
5392:          [ oTypeSNodeType
5394:             | nBooleanCFType :
                     % We have control flow, and are sitting at the point that has value false.
5395:                falseLabel = oLabelNew
5400:                .tJump  oEmitLabel( falseLabel )
                     % The true path jumps here
5408:                .tLabel  oEmitLabel( factorFalseLabel )
      
5416:             | nBooleanType :
                     % I have a value.  I'll leave it as a value, rather than create control flow.
                     % See how this goes.
5418:                .tNot
      
5420:             | * : #eNotBoolean
5429:          ]
      
5429:       | * :
5434:          @ArithExprAllowCF( falseLabel )
5441:    ];
      
5442: ArithExprAllowCF( out Label falseLabel ):
5444:    @TermAllowCF( falseLabel )
5451:    {[
5451:       | pPlus :
5453:          @PromoteToIntPop
5455:          @TermAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5462:          @PromoteToInt
5464:          .tAddI
5466:       | pMinus :
5468:          @PromoteToIntPop
5470:          @TermAllowCF( falseLabel )
5477:          @PromoteToInt
5479:          .tSubI
5481:       | * :
5488:          >
5490:    ]};
      
5493: TermAllowCF( out Label falseLabel ):
5495:    @FactorAllowCF( falseLabel )
5502:    {[
5502:       | pTimes :
5504:          @PromoteToIntPop
5506:          @FactorAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
5513:          @PromoteToInt
5515:          .tMultI
5517:       | pDivide :
5519:          @PromoteToIntPop
5521:          @FactorAllowCF( falseLabel )
5528:          @PromoteToInt
5530:          .tDivI
5532:       | * :
5539:          >
5541:    ]};
      
5544: FactorAllowCF( out Label falseLabel ):
5546:    [
5546:       | pPlus :
5548:          @PrimaryAllowCF( falseLabel )  % actually not allowing CF, will be caught by type check
               % TO DO: unary +/- is supposed to leave expression type as-is.
5555:          @PromoteToInt
5557:       | pMinus :
5559:          @PrimaryAllowCF( falseLabel )
               % TO DO: unary +/- is supposed to leave expression type as-is.
5566:          @PromoteToInt
5568:          .tNegI
5570:       | * :
5577:          @PrimaryAllowCF( falseLabel )
5584:    ];
      
5585: PrimaryAllowCF( out Label falseLabel ):
5587:    [
5587:       | pIntLit :
5589:          .tPushConstI  oEmitInt( TOKEN_VALUE )
5596:          oTypeSPush( IntegerType )
      
5602:       | '(' :
5604:          @ExprAllowCF( falseLabel )
5611:          ')'
      
5613:       | pStrLit :
5615:          int addr = oStringAllocLit( CURRENT_STRLIT )     % store in global data
5624:          .tPushAddrGlobal oEmitInt( addr )
               % TO DO: do we need to create a type with the literal's length?
5632:          oTypeSPush( StringType )
      
5638:       | pIdent :
5640:          Node decl = oScopeFindRequire
5645:          @ResolveUnitRef( decl )
5652:          Node theType
      
5652:          [ oNodeType( decl )
5659:             | nFunc :
5660:                @Call( decl )
      
5667:             | nBuiltInFunc :
5669:                @CallBuiltInFunc( decl )
      
5676:             | nConst, nEnumValue :
5678:                theType = oNodeGet( decl, qType )
5691:                oTypeSPush( theType )
5697:                [ oTypeSNodeType
5699:                   | nIntegerType, nEnumType, nBooleanType :
5700:                      .tPushConstI @EmitValue( decl )
5709:                   | * :
5718:                      #eNotImplemented
5720:                ]
      
5720:             | nGlobalVar, nLocalVar, nParam :
5722:                @VarExpr( decl )
      
5729:             | * :
5746:                #eNotValue
5748:                oTypeSPush( IntegerType )
5754:          ]
      
5754:       | '@' :        % @var -- pointer to var
5756:          pIdent
      
5758:          Node decl = oScopeFindRequire
5763:          @ResolveUnitRef( decl )
5770:          Node theType
      
5770:          @LValueVar( decl )
      
               % The above leaves the pointed-to type on type stack.
               % Replace with ptr-to-<type>.
5777:          theType = oTypeSTop
5782:          oTypeSPop
5783:          Node ptrType = @PointerTypeTo( theType )
5794:          oTypeSPush( ptrType )
      
5800:       | * :
5813:          #eNotValue
5815:          oTypeSPush( IntegerType )
5821:    ];
      
      
      % Parse a variable expression, given the declaration of the
      % just-accepted identifier.
      % Leaves the value on the expression stack, and type on the type stack.
      %
5822: VarExpr( Node decl ):
5824:    Node theType = oNodeGet( decl, qType )
         % how many levels up the static scope? Will ignore for globals.
5837:    int uplevels = @DeclUpLevels( decl )
      
5848:    oTypeSPush( theType )
5854:    [ oTypeSNodeType
5856:       | nIntegerType, nEnumType :
5857:          [ oNodeType( decl )
5864:             | nGlobalVar :   .tPushGlobalI  @EmitValue( decl )
5874:             | nLocalVar :
5876:                [ equal_zero( uplevels )
5883:                   | true :  .tPushLocalI  @EmitValue( decl )
5893:                   | * :     .tPushUpLocalI  oEmitInt( uplevels )  @EmitValue( decl )
5913:                ]
5913:             | nParam :
5915:                [ oNodeGetBoolean( decl, qInOut )
5925:                   | true :    % VAR param points to the var.  Auto dereference.
5926:                      [ equal_zero( uplevels )
5933:                         | true :  .tPushParamP  @EmitValue( decl )
5943:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
5963:                      ]
5963:                      .tFetchI
5965:                   | * :
5970:                      [ equal_zero( uplevels )
5977:                         | true :  .tPushParamI  @EmitValue( decl )
5987:                         | * :     .tPushUpParamI  oEmitInt( uplevels )  @EmitValue( decl )
6007:                      ]
6007:                ]
6007:          ]
      
6017:       | nBooleanType, nByteType, nCharType :
6019:          [ oNodeType( decl )
6026:             | nGlobalVar :   .tPushGlobalB  @EmitValue( decl )
6036:             | nLocalVar :
6038:                [ equal_zero( uplevels )
6045:                   | true :  .tPushLocalB  @EmitValue( decl )
6055:                   | * :     .tPushUpLocalB  oEmitInt( uplevels )  @EmitValue( decl )
6075:                ]
6075:             | nParam :
6077:                [ oNodeGetBoolean( decl, qInOut )
6087:                   | true :    % VAR param points to the var.  Auto dereference.
6088:                      [ equal_zero( uplevels )
6095:                         | true :  .tPushParamP  @EmitValue( decl )
6105:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6125:                      ]
6125:                      .tFetchB
6127:                   | * :
6132:                      [ equal_zero( uplevels )
6139:                         | true :  .tPushParamB  @EmitValue( decl )
6149:                         | * :     .tPushUpParamB  oEmitInt( uplevels )  @EmitValue( decl )
6169:                      ]
6169:                ]
6169:          ]
      
6179:       | nStringType, nFileType :
6181:          #eNotImplemented
      
6183:       | nPointerType :
6185:          [ oNodeType( decl )
6192:             | nGlobalVar :   .tPushGlobalP @EmitValue( decl )
6202:             | nLocalVar :
6204:                [ equal_zero( uplevels )
6211:                   | true :  .tPushLocalP  @EmitValue( decl )
6221:                   | * :     .tPushUpLocalP  oEmitInt( uplevels )  @EmitValue( decl )
6241:                ]
6241:             | nParam :
6243:                [ oNodeGetBoolean( decl, qInOut )
6253:                   | true :    % VAR param points to the var.  Auto dereference.
6254:                      [ equal_zero( uplevels )
6261:                         | true :  .tPushParamP  @EmitValue( decl )
6271:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6291:                      ]
6291:                      .tFetchP
6293:                   | * :
6298:                      [ equal_zero( uplevels )
6305:                         | true :  .tPushParamP  @EmitValue( decl )
6315:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6335:                      ]
6335:                ]
6335:          ]
6345:          [
6345:             | '^' :             % dereferenced
6347:                oTypeSPop
6348:                oTypeSPush( oNodeGet( theType, qBaseType ) )
6361:                @LValueIndexes
6363:                @FetchVar
6365:             | * :               % just ptr value alone
6370:          ]
      
6370:       | nArrayType, nRecordType :
               % compound type
               % first, push addr of start of var
6372:          [ oNodeType( decl )
6379:             | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
6389:             | nLocalVar :
6391:                [ equal_zero( uplevels )
6398:                   | true :  .tPushAddrLocal  @EmitValue( decl )
6408:                   | * :     .tPushAddrUpLocal  oEmitInt( uplevels )  @EmitValue( decl )
6428:                ]
6428:             | nParam :
6430:                [ oNodeGetBoolean( decl, qInOut )
6440:                   | true :    % VAR param points to the var.  Auto dereference.
6441:                      [ equal_zero( uplevels )
6448:                         | true :  .tPushParamP  @EmitValue( decl )
6458:                         | * :     .tPushUpParamP  oEmitInt( uplevels )  @EmitValue( decl )
6478:                      ]
6478:                   | * :
6483:                      [ equal_zero( uplevels )
6490:                         | true :  .tPushAddrParam  @EmitValue( decl )
6500:                         | * :     .tPushAddrUpParam  oEmitInt( uplevels )  @EmitValue( decl )
6520:                      ]
6520:                ]
6520:          ]
               % modify addr for subscripts, field references, etc
6530:          @LValueIndexes
               % get final value
6532:          @FetchVar
6534:    ];
      
      
      % Addr of start of var is on expr stack; type is on type stack.
      % Replace expr stack with value of var.
      % (In the case of compound vars, this remains as the addr of the var).
      
6559: FetchVar:
6561:    [ oTypeSNodeType
6563:       | nIntegerType, nEnumType :  .tFetchI
6566:       | nBooleanType, nByteType, nCharType :  .tFetchB
6570:       | nStringType, nFileType :   #eNotImplemented
6574:       | nPointerType :             .tFetchP
6578:       | nArrayType, nRecordType :  % compound type; leave as addr
6580:    ];
      
      
      % Addr of start of var is already on run stack, and type is on type stack.
      % Read subscripts, record fields, etc, to get final addr on run stack, and final type
      % on type stack.
      
6605: LValueIndexes:
6607:    {[
6607:       | '[' :       @ArraySubscripts
6611:       | '.' :       @RecordFieldRef
6615:       | '^' :       @PointerDeref
6619:       | * :         >
6630:    ]};
      
6633: ArraySubscripts:
6635:    [ oTypeSNodeType
6637:       | nArrayType :
6638:       | * :       #eNotArray
6645:    ]
6645:    {
6645:       [ oTypeSNodeType
6647:          | nArrayType :
6648:          | * :    #eTooManySubscripts
6655:       ]
      
            % low subscript of this dimension
6655:       int low = @OrdinalLow( oNodeGet( oTypeSTop, qIndexType ) )
      
            % replace type stack with next dimension, or OF type
6672:       Node baseType
6672:       baseType = oNodeGet( oTypeSTop, qBaseType )
6684:       oTypeSPop
6685:       oTypeSPush( baseType )
      
6691:       @Expr
6693:       @RequireIntPop
            % adjust for low subscript
6695:       [ equal_zero( low )
6702:          | false :
6703:             .tPushConstI oEmitInt( low ) .tSubI
6713:          | * :
6718:       ]
      
            % multiply by element size
6718:       int size = oNodeGetInt( baseType, qSize )
6731:       [ equal( size, 1 )
6741:          | false :
6742:             .tPushConstI oEmitInt( size ) .tMultI
6752:          | * :
6757:       ]
      
            % update start address
6757:       .tAddPI
6759:       [
6759:          | ']' :  >
6763:          | ',' :
6765:       ]
6773:    };
      
      
6776: RecordFieldRef:
6778:    [ oTypeSNodeType
6780:       | nRecordType :
6781:       | * :    #eNotRecord
6788:    ]
6788:    oScopeEnter( oNodeGet( oTypeSTop, qScope ) )
6800:    pIdent
6802:    Node field = oScopeFindRequire
         % oScopeFind searches all open scopes, so make sure we found nRecordField
         % which could only be seen in the local scope we entered above.
6807:    [ oNodeType( field )
6814:       | nRecordField :
6815:       | * :   #eNotRecordField
6822:    ]
6822:    oScopeEnd
6823:    int offset = oNodeGetInt( field, qValue )
6836:    [ equal_zero( offset )
6843:       | false :
6844:          .tPushConstI oEmitInt( offset ) .tAddPI
6854:       | * :
6859:    ]
      
         % replace the type on the type stack, with the field type
6859:    oTypeSPop
6860:    oTypeSPush( oNodeGet( field, qType ) )
6874:    ;
      
      
      % ptr deref on left side, i.e. BEFORE addr of ptr var is on stack,
      %                              AFTER addr of thing pointed to is on stack
6874: PointerDeref:
6876:    [ oTypeSNodeType
6878:       | nPointerType :
6879:       | * :       #eNotPointer
6886:    ]
6886:    .tFetchP           % now addr on stack is addr of what we're pointing to
      
6888:    Node theType = oTypeSTop
6893:    oTypeSPop
6894:    oTypeSPush( oNodeGet( theType, qBaseType ) )
6908:    ;
      
      
      % The expr stack contains a value whose type is on top of the type stack.
      % Generate code to coerce the value to the type under it in the type stack
      % (pop the type stack, leaving only the desired type).
      % This is used for assignment.
      %
6908: CoerceType:
6910:    node_type nt = oTypeSNodeType
6915:    oTypeSPop
6916:    [ equal_node_type( nt, oTypeSNodeType )
6925:       | false :
               % Can we implicitly convert the value to the desired type?
6926:          [ oTypeSNodeType
6928:             | nIntegerType :
6929:                [ nt
6932:                   | nByteType :   .tCastBtoI  >>
6936:                   | * :
6941:                ]
6941:             | nByteType :
6943:                [ nt
6946:                   | nIntegerType :   .tCastItoB  >>
6950:                   | * :
6955:                ]
6955:             | * :
6962:          ]
6962:          #eTypeMismatch
6964:       | * :
6969:    ];
      
      
      % Called on first use of an extern method
      %
6970: DefineExternLabel( Node method ):
         % The extern name might be given explicitly, otherwise the pascal method name.
6972:    int strAddr
6972:    String externalName = oNodeGetString( method, qExternalName )
6985:    [ equal_string( externalName, stringNull )
6995:       | true :
6996:          strAddr = oStringAllocLit( ID_STRING( oNodeGetInt( method, qIdent ) ) )
7017:       | false :
7019:          strAddr = oStringAllocLit( externalName )
7029:    ]
7037:    .tLabelExtern  @EmitValue( method )  oEmitInt( strAddr )
7053:    ;
      
      
      % Parse a call, given an nProc or nFunc for the just-accepted identifier.
      % If a func, this will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7053: Call( Node method ):
      
         % Prior to first call, issue extern label for a called method.
         % I don't want to issue .tLabelExtern for unused methods, that seems inefficient.
7055:    [ oNodeGetBoolean( method, qExternal )
7065:       | true :
7066:          [ oNodeGetBoolean( method, qUsed )
7076:             | false :
                     % define the extern label on first use
7077:                @DefineExternLabel( method )
7084:             | * :
7089:          ]
7089:      | * :
7094:    ]
7094:    oNodeSetBoolean( method, qUsed, true )
      
         % If the method has a cdecl modifier, the back end will need to use the native
         % calling convention, instead of my own.  But, the convention varies by platform,
         % so the front end won't assume what it needs.  I'll still generate the normal tcode
         % that copies values into actuals space on the stack.
         % However, to help the back end, I will at least use a different instruction for the
         % allocation of the actuals space, and for the actual call.
         %
         % p.s. I only support cdecl on external methods, because I don't have a way
         % to let my own Pascal methods read params passed in with the cdecl calling convention.
         %
7106:    boolean cdecl = oNodeGetBoolean( method, qCdecl )
      
         % If this is a function, we will allocate a temporary
         % in the current scope, to hold the result value.
         % And pass a pointer to that temporary as an extra parameter.
7119:    Node resultType
7119:    int tempOffset
      
7119:    boolean isFunc = equal_node_type( oNodeType( method ), nFunc )
      
7136:    [ isFunc
7139:       | true :
7140:          resultType = oNodeGet( method, qType )
7153:          tempOffset = oScopeAllocType( resultType )
               % TO DO: we could manage temp allocation, so temp space can be reused
               %        by different code branches.
7163:       | * :
7168:    ]
         
      
7168:    Node paramScope = oNodeGet( method, qParams )
7181:    int actualsSize = oNodeGetInt( paramScope, qSize )
7194:    [ cdecl
7197:       | true : .tAllocActualsCdecl  oEmitInt( actualsSize )
7206:       | false :  .tAllocActuals  oEmitInt( actualsSize )
7216:    ]
      
         % If method is nested, it takes a hidden first parameter:
         % a pointer to the frame of the static scope in which the method is declared.
         % The location of a scope's frame is equivalent to offset 0 in the scope's locals space
         % (since local offsets are relative to the scope's frame pointer).
         %
         % The nested method may be in a higher scope (upLevels > 1),
         % or a sibling of the method we're in (upLevels = 1),
         % or an immediate child of the current method (upLevels = 0).
         %
         % To understand the upLevels computation, remember that a method's declaration
         % and its contents (variables, nested functions, and body statement)
         % are in two different scopes.
      
7224:    [ greater( @DeclLevel( method ), 0 )
7239:       | true :
7240:          .tPushAddrActual  oEmitInt( 0 )    % hidden param is at param offset 0
7248:          .tPushAddrUpLocal  oEmitInt( @DeclUpLevels( method ) )  oEmitInt( 0 )
7267:          .tAssignP
7269:       | * :
7274:    ]
      
      
7274:    NodeIter paramIter = oNodeGetIter( paramScope, qDecls )
7287:    Node param = oNodeIterValue( paramIter )
7297:    [
7297:       | '(' :
            
7299:          {
7299:             [ oNodeNull( param )
7306:                | true : >
7309:                | * :
7314:             ]
      
7314:             int offset = oNodeGetInt( param, qValue )
      
                  % Assign actual value to spot in actuals space
7327:             .tPushAddrActual oEmitInt( offset )
7335:             oTypeSPush( oNodeGet( param, qType ) )
      
7348:             [ oNodeGetBoolean( param, qInOut )
7358:                | true :   % A VAR param.
                                % The actual is a pointer to the value.
                                % The type on the type stack (pushed above) is for the pointed-to value.
      
7359:                           @LValueExpr
                                % Addr of the referenced variable is on the expr stack,
                                % type of the variable is on the type stack.
      
                                % Match types more exactly. It's not sufficient to be assign compatible
                                % since the method will be assigning to the actual using the param type.
                                % Maybe something like type contents must match, incl subrange bounds.
7361:                           @MatchTypes
      
7363:                           .tAssignP
      
7365:                | false :  @Expr
7369:                           @CoerceType
                                
                                % Assign to offset in actuals space
      
7371:                           [ oTypeSNodeType
7373:                              | nIntegerType, nEnumType : .tAssignI
7376:                              | nBooleanType, nByteType, nCharType :  .tAssignB
7380:                              | nStringType, nFileType :   #eNotImplemented
7384:                              | nPointerType :            .tAssignP
7388:                              | nArrayType, nRecordType :
                                       % compound types: copy value into actuals space
7390:                                  int size = oNodeGetInt( oTypeSTop, qSize )
7402:                                  .tCopy  oEmitInt( size )    % multi-word copy
7410:                           ]
7434:             ]
7442:             oTypeSPop
      
7443:             oNodeIterNext( paramIter )
7449:             param = oNodeIterValue( paramIter )
7459:             [ oNodeNull( param )
7466:                | true :  >
7469:                | false :
7471:             ]
      
7479:             ','
7481:          }
      
7483:          ')'
      
7485:       | * :
7490:    ]
      
7490:    [ oNodeNull( param )
7497:       | false :    #eMissingParameter
7500:       | * :
7505:    ]
      
7505:    [ isFunc
7508:       | true :
               % Pass result temp as an additional VAR parameter.
7509:          .tPushAddrActual oEmitInt( oNodeGetInt( method, qResultOffset ) )
7524:          .tPushAddrLocal  oEmitInt( tempOffset )
7532:          .tAssignP
7534:       | * :
7539:    ]
      
7539:    [ cdecl
7542:       | true :
7543:          .tCallCdecl  @EmitValue( method )
7552:       | false :
7554:          .tCall   @EmitValue( method )
7563:    ]
      
7571:    [ isFunc
7574:       | true :
               % push return value from temp
7575:          oTypeSPush( resultType )
      
7581:          [ oTypeSNodeType
7583:             | nIntegerType, nEnumType :   .tPushLocalI  oEmitInt( tempOffset )
7592:             | nBooleanType, nByteType, nCharType :   .tPushLocalB  oEmitInt( tempOffset )
7602:             | nStringType, nFileType :  #eNotImplemented
7606:             | nPointerType :   .tPushLocalP  oEmitInt( tempOffset )
7616:             | nArrayType, nRecordType :   % compound type: push address
7618:                                .tPushAddrLocal  oEmitInt( tempOffset )
7626:          ]
7650:       | * :
7655:    ]
         
7655:    .tFreeActuals  oEmitInt( actualsSize )
7664:    ;
      
      
      % Parse a call to a built-in function, identified by the just-accepted identifier.
      % This will also generate the code to push the return value on the expr stack,
      % and push the return type on the type stack.
      %
7664: CallBuiltInFunc( Node method ):
      
         % Ord(x)
7666:    [ oNodeEqual( method, BuiltIn_Ord )
7676:       | true :
               % parameter is any scalar type (including boolean, enum, char)
               % result is integer
7677:          '('
7679:          @Expr
7681:          [ oTypeSNodeType
7683:             | nIntegerType, nEnumType :
7684:             | nBooleanType, nByteType, nCharType :  .tCastBtoI
7688:             | * :  #eTypeMismatch
7703:          ]
7703:          oTypeSPop
7704:          oTypeSPush( IntegerType )
7710:          ')'
7712:          >>
7713:       | * :
7718:    ]
      
         % Chr(x)
7718:    [ oNodeEqual( method, BuiltIn_Chr )
7728:       | true :
               % parameter is integer
               % result is char
7729:          '('
7731:          @Expr
7733:          [ oTypeSNodeType
7735:             | nIntegerType :    .tCastItoB
7738:             | nByteType :
7740:             | * :  #eTypeMismatch
7749:          ]
7749:          oTypeSPop
7750:          oTypeSPush( CharType )
7756:          ')'
7758:          >>
7759:       | * :
7764:    ]
      
7764:    #eNotImplemented
7767:    ;
      
      
      % ------------------------------ Statements -----------------------------
      
7767: Statement:
7769:    [
7769:       | pWriteln :     @WritelnStmt
7773:       | pWrite :       @WriteStmt
7777:       | pReadln :      @ReadlnStmt
7781:       | pRead :        @ReadStmt
7785:       | pIf :          @IfStmt
7789:       | pWhile :       @WhileStmt
7793:       | pFor :         @ForStmt
7797:       | pRepeat :      @RepeatStmt
7801:       | pBreak :       @BreakStmt
7805:       | pContinue :    @ContinueStmt
7809:       | pBegin :       @BeginStmt
7813:       | pIdent :       @LabelOrAssignOrCallStmt
7817:       | pGoto :        @GotoStmt
7821:       | pIntLit :      % should be an integer label
7823:                        oChangeIntLitToLabelIdent
7824:                        @LabelOrAssignOrCallStmt
7826:       | * :            % null statement : don't accept any tokens
7857:    ];
      
      
7858: LabelOrAssignOrCallStmt:
7860:    Node decl = oScopeFindRequire
7865:    @ResolveUnitRef( decl )
7872:    [ oNodeType( decl )
7879:       | nLabel :                          @LabelDefinition( decl )
7887:                                           @Statement
7889:       | nProc :                           @Call( decl )
7898:       | nGlobalVar, nLocalVar, nParam :   @AssignStmt( decl )
7907:       | nFunc :                           @AssignResultStmt( decl )
7916:       | * :                               #eBadStatement
7933:    ];
      
      
      % Parse a "label:" prefix in front of a statement.
      %
7934: LabelDefinition( Node decl ):
7936:    [ oNodeGetBoolean( decl, qDefined )
7946:       | true :  #eAlreadyDefined
7949:       | * :
7954:    ]
7954:    .tLabel  oEmitLabel( oNodeGetLabel( decl, qValue ) )
7969:    oNodeSetBoolean( decl, qDefined, true )
7981:    ':'
7984:    ;
      
      
      % Given decl, the just-accepted first identifier on the left hand side.
      %
7984: AssignStmt( Node decl ):
      
7986:    @LValueVar( decl )
7993:    ':=' 
7995:    @Expr
7997:    @CoerceType
7999:    @Assign
8002:    ;
      
      
      % Performs a raw assignment.
      % Given lvalue 2nd on stack, and expr value top of stack,
      % and type of both of these on the type stack,
      % perform the assignment and pop the type off the type stack.
      %
8002: Assign:
8004:    [ oTypeSNodeType
8006:       | nIntegerType, nEnumType :  .tAssignI
8009:       | nBooleanType, nByteType, nCharType :  .tAssignB
8013:       | nStringType, nFileType :   #eNotImplemented
8017:       | nPointerType :             .tAssignP
            % compound var assigns; addrs of src, dest on stack
8021:       | nArrayType, nRecordType :
8023:           int size = oNodeGetInt( oTypeSTop, qSize )
8035:           .tCopy  oEmitInt( size )    % multi-word copy
8043:    ]
8067:    oTypeSPop
8069:    ;
      
      % Given nFunc for the just-accepted identifier on the left hand side.
      % Parse an assignment that represents assignment of the function result.
      %
8069: AssignResultStmt( Node funcDecl ):
         % Only allowed to assign the result of the immediately enclosing function, I think.
8071:    [ oNodeEqual( oNodeGet( funcDecl, qChildScope ), oScopeCurrent )
8087:       | false :   #eNotCurrentFunction
8090:       | * :
8095:    ]
      
         % Result value is stored in the caller's space, via a hidden VAR parameter.
8095:    .tPushParamP  oEmitInt( oNodeGetInt( funcDecl, qResultOffset ) )
8110:    oTypeSPush( oNodeGet( funcDecl, qType ) )
      
8123:    ':='
8125:    @Expr
8127:    @CoerceType
8129:    [ oTypeSNodeType
8131:       | nIntegerType, nEnumType : .tAssignI
8134:       | nBooleanType, nByteType, nCharType :  .tAssignB
8138:       | nStringType, nFileType :   #eNotImplemented
8142:       | nPointerType :            .tAssignP
            % compound var assigns; addrs of src, dest on stack
8146:       | nArrayType, nRecordType :
8148:           int size = oNodeGetInt( oTypeSTop, qSize )
8160:           .tCopy  oEmitInt( size )    % multi-word copy
8168:    ]
8192:    oTypeSPop
8194:    ;
      
      
      
      % Parse an lvalue expression, from scratch.
      % This is an expression that may appear on the left side of an assignment.
      % Leaves the address of the value on the expr stack,
      % and the type of the value at that address on the type stack.
      %
8194: LValueExpr:
         % At the moment, all lvalue expressions start with a variable name.
         % I think there can also be typecasts, not supported yet.  Check standard syntax.
8196:    pIdent
8198:    Node decl = oScopeFindRequire
8203:    @ResolveUnitRef( decl )
8210:    [ oNodeType( decl )
8217:       | nGlobalVar, nLocalVar, nParam :
8218:       | * :  #eNotVar
8229:    ]
8229:    @LValueVar( decl )
8237:    ;
      
      
      % Parse an lvalue expression (e.g. left side of an assign statement)
      % that starts with the just-accepted identifier indicated by the given decl.
      % Leaves the lvalue address on the expression stack,
      % and the type of the value at that address on the type stack.
      %
8237: LValueVar( Node decl ):
8239:    [ oNodeType( decl )
8246:       | nGlobalVar :   .tPushAddrGlobal @EmitValue( decl )
8256:       | nLocalVar :    .tPushAddrLocal @EmitValue( decl )
8267:       | nParam :
8269:          [ oNodeGetBoolean( decl, qInOut )
8279:             | true :   % VAR param points to variable.  No dereference.
8280:                        .tPushParamP @EmitValue( decl )
8289:             | * :      .tPushAddrParam @EmitValue( decl )
8303:          ]
8303:       | * :            #eNotVar
8314:    ]
      
8314:    oTypeSPush( oNodeGet( decl, qType ) )
8327:    @LValueIndexes        % handle subscripts, if any
8330:    ;
      
      
8330: IncVar( Node decl ):
8332:    @LValueVar( decl )
8339:    @RequireIntPop
8341:    @VarExpr( decl )
8348:    oTypeSPop
8349:    .tIncI
8351:    .tAssignI;
      
8354: DecVar( Node decl ):
8356:    @LValueVar( decl )
8363:    @RequireIntPop
8365:    @VarExpr( decl )
8372:    oTypeSPop
8373:    .tDecI
8375:    .tAssignI;
      
      
8378: IfStmt:
8380:    Label falseLabel = labelNull
      
8386:    @BooleanExprControlFlow( falseLabel )
8393:    pThen
8395:    @Statement
8397:    [
8397:       | pElse :
8399:          Label doneLabel = oLabelNew
      
8404:          .tJump  oEmitLabel( doneLabel )
8412:          .tLabel oEmitLabel( falseLabel )
8420:          @Statement
8422:          .tLabel oEmitLabel( doneLabel )
      
8430:       | * :
8435:          .tLabel oEmitLabel( falseLabel )
8443:    ];
      
      
8444: ForStmt:
8446:    pIdent
      
8448:    Node decl = oScopeFindRequire
         % TO DO: disallow use of a compound variable field.
         %        Could do that by disallowing use of LValueIndexes,
         %        or by double-checking the decl's qType here.
         % TO DO: I think I read somewhere that the variable must be in current scope.
8453:    @LValueVar( decl )
8460:    @RequireIntPop
      
8462:    ':='
      
8464:    @Expr
8466:    @RequireIntPop
8468:    .tAssignI
      
8470:    Label breakLabel = oLabelNew
      
8475:    Label checkLabel = oLabelNew
8480:    .tJump  oEmitLabel( checkLabel )
      
8488:    Label continueLabel = oLabelNew
8493:    .tLabel  oEmitLabel( continueLabel )
8501:    [
8501:       | pTo :
8503:          @IncVar( decl )
8510:          .tLabel  oEmitLabel( checkLabel )
8518:          @VarExpr( decl )  oTypeSPop
8526:          @Expr
8528:          @RequireIntPop
8530:          .tGreaterI
8532:          .tJumpTrue  oEmitLabel( breakLabel )
8540:       | pDownto :
8542:          @DecVar( decl )
8549:          .tLabel  oEmitLabel( checkLabel )
8557:          @VarExpr( decl )  oTypeSPop
8565:          @Expr
8567:          @RequireIntPop
8569:          .tLessI
8571:          .tJumpTrue  oEmitLabel( breakLabel )
8579:    ]
8587:    oLoopPush( continueLabel, breakLabel )
8596:    pDo
8598:    @Statement
8600:    .tJump  oEmitLabel( continueLabel )
8608:    .tLabel  oEmitLabel( breakLabel )
8616:    oLoopPop;
      
      
8618: RepeatStmt:
8620:    Label continueLabel = oLabelNew
8625:    .tLabel  oEmitLabel( continueLabel )
      
8633:    Label breakLabel = oLabelNew
      
8638:    oLoopPush( continueLabel, breakLabel )
8647:    @Statement
8649:    {[
8649:       | ';' :
8651:          @Statement
8653:       | pUntil :
8655:          Label falseLabel
8655:          @BooleanExprControlFlow( falseLabel )
8662:          .tLabelAlias  oEmitLabel( falseLabel )  oEmitLabel( continueLabel )
8676:          >
8678:    ]}
8688:    .tLabel  oEmitLabel( breakLabel )
8696:    oLoopPop;
      
      
8698: WhileStmt:
8700:    Label continueLabel = oLabelNew
8705:    .tLabel  oEmitLabel( continueLabel )
      
8713:    Label breakLabel
8713:    @BooleanExprControlFlow( breakLabel )
      
8720:    oLoopPush( continueLabel, breakLabel )
8729:    pDo
8731:    @Statement
8733:    .tJump  oEmitLabel( continueLabel )
8741:    .tLabel  oEmitLabel( breakLabel )
8749:    oLoopPop;
      
      
8751: ContinueStmt:                     % NOTE, for repeat..until, skips test (??)
8753:    [ equal_label( oLoopContinueLabel, labelNull )
8762:       | true :
8763:          #eNotInALoop
8765:       | false :
8767:          .tJump  oEmitLabel( oLoopContinueLabel )
8774:    ];
      
      
8783: BreakStmt:
8785:    [ equal_label( oLoopBreakLabel, labelNull )
8794:       | true :
8795:          #eNotInALoop
8797:       | false :
8799:          .tJump  oEmitLabel( oLoopBreakLabel )
8806:    ];
      
      
8815: GotoStmt:
8817:    [
8817:       | pIdent :
8819:       | pIntLit :
               % Replace token with identifier "_label_<intlit>"
8821:          oChangeIntLitToLabelIdent
8822:    ]
      
         % Some pascals have rules about where you can jump (to a sibling statement or
         % higher level statement in the block, but not into a lower lower level statement.)
         % fpc just says "jumping into a nested statement can have strange effects."
         % I'm going to follow that and not prohibit any goto, as long as it's in the same block.
      
         % Label must be declared in the same block (same scope) it is used.
         % Some pascals allow non-local goto, but we do not.
         % That would require more tracking of dynamic scope, to unwind stack.
         % Note: in main program statement, this relies on the temporaries scope extending
         %  the main scope (where a label declaration would occur).
8830:    Node decl = oScopeFindRequireInScope( oScopeCurrent )
8839:    oNodeSetBoolean( decl, qUsed, true )
8851:    .tJump  oEmitLabel( oNodeGetLabel( decl, qValue ) )
8867:    ;
      
      
8867: BeginStmt:
8869:    @Statement
8871:    {[
8871:       | ';' :   @Statement
8875:       | pEnd :  >
8879:    ]};
      
      
8890: WritelnStmt:
8892:    @WriteStmt
8894:    .tWriteCR;
      
      
8897: WriteStmt:
8899:    [
8899:       | '(' :
8901:          {
8901:             @Expr
8903:             [ oTypeSNodeType
8905:                | nIntegerType :             .tWriteI
8908:                | nBooleanType :             .tWriteBool
8912:                | nByteType :                .tCastBtoI  .tWriteI
8918:                | nCharType :                .tWriteChar
8922:                | nStringType :              .tWriteStr
8926:                | nFileType :                #eNotImplemented
8930:                | nEnumType :
                        % write name via table lookup
8932:                   .tPushAddrGlobal  oEmitInt( oNodeGetInt( oTypeSTop, qNameTable ) )
8946:                   .tWriteEnum
8948:                | nPointerType :             .tWriteP
8952:                | * :                        #eNotAllowed
8973:             ]
8973:             oTypeSPop
8974:             [
8974:                | ')' : >
8978:                | ',' :
8980:             ]
8988:          }
8990:       | * :
8995:    ];
      
      
8996: ReadlnStmt:      % ***
         % TO DO
8999:    ;
      
8999: ReadStmt:
         % TO DO
9002:    ;
      
      % -------------------------------- Utilities -------------------------------
      
      % Return the static scope level of the current scope
      %
9002: ScopeLevel >> int:
9004:    >> oNodeGetInt( oScopeCurrent, qLevel );
      
      % Return the static scope level of the given declaration
      %
9014: DeclLevel( Node decl ) >> int:
9016:    >> oNodeGetInt( oNodeGet( decl, qParentScope ), qLevel );
         
      
      % How many levels higher is the given declaration from the current scope?
      %
9034: DeclUpLevels( Node decl ) >> int:
9036:    >> subtract( @ScopeLevel, @DeclLevel( decl ) );
      
      
      % Require that the top two types on the type stack are matching (ignoring subranges).
      % Pop one of them, leaving only one.
      %
9052: MatchTypes:
9054:    node_type nt = oTypeSNodeType
9059:    oTypeSPop
9060:    [ equal_node_type( nt, oTypeSNodeType )
9069:       | false :
9070:          #eTypeMismatch
9072:       | * :
9077:    ];
      
      
      % Require that the top type on the type stack is integer (ignoring subranges).
      % Pop it.
      %
9078: RequireIntPop:
9080:    [ oTypeSNodeType
9082:       | nIntegerType :
9083:       | * :          #eNotInteger
9090:    ]
9090:    oTypeSPop;
      
9092: RequireInt:
9094:    [ oTypeSNodeType
9096:       | nIntegerType :
9097:       | * :          #eNotInteger
9104:    ];
      
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Pop the type stack.
      %
9105: PromoteToIntPop:
9107:    [ oTypeSNodeType
9109:       | nIntegerType :
9110:       | nByteType :        .tCastBtoI
9114:       | * :                #eNotInteger
9123:    ]
9123:    oTypeSPop;
      
      % Convert the top value to integer (if it isn't already).
      % It must be implicitly convertable to integer.
      % Leave integer on the type stack.
      %
9125: PromoteToInt:
9127:    [ oTypeSNodeType
9129:       | nIntegerType :
9130:       | nByteType :        .tCastBtoI
9134:                            oTypeSPop
9135:                            oTypeSPush( IntegerType )
9141:       | * :                #eNotInteger
9150:    ];
      
      
      % If the top value is implicitly convertable to integer, do so.
      % Otherwise leave it as-is.
      %
9151: PromoteToIntOptional:
9153:    [ oTypeSNodeType
9155:       | nByteType :        .tCastBtoI
9158:                            oTypeSPop
9159:                            oTypeSPush( IntegerType )
9165:       | * :
9170:    ];
      
      
      
      
9171: RequireBoolPop:
9173:    [ oTypeSNodeType
9175:       | nBooleanType :
9176:       | * :          #eNotBoolean
9183:    ]
9183:    oTypeSPop;
      
9185: RequireBool:
9187:    [ oTypeSNodeType
9189:       | nBooleanType :
9190:       | * :          #eNotBoolean
9197:    ];
      
      
      % Create and return a new nType of the given node_type, adding it to the type table.
      %
9198: newType( node_type nt, int size ) >> Node:
9200:   Node node = oNodeNew( nt )
9210:   oNodeSetInt( node, qSize, size )
9222:   oTypeAdd( node )
9228:   >> node
9232:   ;
      
      
      % Create and return a new nIdent of the given node_type, with the given ident id.
      % Does not add it to any scope.
      %
9232: newIdent( node_type nt, int id ) >> Node:
9234:   Node t = oNodeNew( nt )
9244:   oNodeSetInt( t, qIdent, id )
9256:   >> t
9260:   ;
      
      
      % Return an nType representing a pointer to the given type.
      % (Creates a new type if necessary.)
      %
9260: PointerTypeTo( Node theType ) >> Node:
9262:    Node ptrType = oNodeGet( theType, qPointerType )
9275:    [ oNodeNull( ptrType )
9282:       | true :
9283:          ptrType = oNodeNew( nPointerType )
9293:          oNodeSet( ptrType, qBaseType, theType )
9305:          oNodeSetInt( ptrType, qSize, 8 )
9317:          oTypeAdd( ptrType )
9323:          oNodeSet( theType, qPointerType, ptrType )
9335:       | * :
9340:    ]
9340:    >> ptrType;
      
      
      % Return the low value of an ordinal type
      %
9344: OrdinalLow( Node theType ) >> int:
9346:    [ oNodeType( theType )
9353:       | nIntegerType :  >> oMININT
9356:       | nBooleanType :  >> 0
9361:       | nCharType :     >> 0
9366:       | nEnumType :
9368:          Node enumScope = oNodeGet( theType, qScope )
9381:          Node first = oNodeIterValue( oNodeGetIter( enumScope, qDecls ) )
9398:          >> oNodeGetInt( first, qValue )
9408:       | nSubrangeType : >> oNodeGetInt( theType, qLow )
9420:       | * :             #eNotOrdinalType
9435:                         >> 0
9438:    ];
      
      
      % Emit the value in a declaration.
      % For a constant integer, this is the constant value.
      % For a global variable, this is the global address.
      % For a local variable, this is the local address relative to the call stack frame.
      %
9439: EmitValue( Node decl ):
9441:     oEmitInt( oNodeGetInt( decl, qValue ));
      
      
9455: installBuiltIns:
      
         % install built-in types
9457:    FileType = @newType( nFileType, 4 )
9471:    IntegerType = @newType( nIntegerType, 4 )
9485:    BooleanType = @newType( nBooleanType, 1 )
9499:    BooleanCFType = @newType( nBooleanCFType, 1 )
9513:    CharType = @newType( nCharType, 1 )
9527:    ByteType = @newType( nByteType, 1 )
9541:    StringType = @newType( nStringType, 256 )    % string with default length 256
      
         % Declare those type identifiers.
         % SSL doesn't support strings, so need help from operations e.g. oIdAdd_File
      
9555:    Node t
      
9555:    t = @newIdent( nTypeDecl, oIdAdd_File )
9568:    oNodeSet( t, qType, FileType )
9580:    oScopeDeclare( t )
      
9586:    t = @newIdent( nTypeDecl, oIdAdd_Integer )
9599:    oNodeSet( t, qType, IntegerType )
9611:    oScopeDeclare( t )
      
9617:    t = @newIdent( nTypeDecl, oIdAdd_Boolean )
9630:    oNodeSet( t, qType, BooleanType )
9642:    oScopeDeclare( t )
      
9648:    t = @newIdent( nTypeDecl, oIdAdd_Char )
9661:    oNodeSet( t, qType, CharType )
9673:    oScopeDeclare( t )
      
9679:    t = @newIdent( nTypeDecl, oIdAdd_Byte )
9692:    oNodeSet( t, qType, ByteType )
9704:    oScopeDeclare( t )
      
9710:    t = @newIdent( nTypeDecl, oIdAdd_String )
9723:    oNodeSet( t, qType, StringType )
9735:    oScopeDeclare( t )
      
         % Built-in constants
      
9741:    t = @newIdent( nConst, oIdAdd_True )
9754:    oNodeSet( t, qType, BooleanType )
9766:    oNodeSetInt( t, qValue, 1 )
9778:    oScopeDeclare( t )
      
9784:    t = @newIdent( nConst, oIdAdd_False )
9797:    oNodeSet( t, qType, BooleanType )
9809:    oNodeSetInt( t, qValue, 0 )
9821:    oScopeDeclare( t )
      
         % Built-in methods
         % These aren't declared like normal methods, because they may have
         % special rules for parameter types (e.g. any scalar type).
         % Calls to these methods will be handled specially by the compiler.
      
9827:    BuiltIn_Ord = @newIdent( nBuiltInFunc, oIdAdd_Ord )
9840:    oScopeDeclare( BuiltIn_Ord )
9846:    BuiltIn_Chr = @newIdent( nBuiltInFunc, oIdAdd_Chr )
9859:    oScopeDeclare( BuiltIn_Chr )
9866:    ;
      
9866: end
      
9866: 

Generated code:

   0: oGlobalSpace 13
   2: oLocalSpace 5
   4: oGetAddrGlobal 1
   6: oPushResult
   7: oWorkspaceNew
   8: oAssign
   9: oSetResult 0
  11: oPushResult
  12: oSetResult 0
  14: oPushResult
  15: oScopeBegin
  16: oPop 2
  18: oGetAddrLocal 2
  20: oPushResult
  21: oScopeCurrent
  22: oAssign
  23: oCall 9455
  25: oEmit 54
  27: oSetResult 0
  29: oPushResult
  30: oEmitInt
  31: oPop 1
  33: oGetAddrLocal 3
  35: oPushResult
  36: oLabelNew
  37: oAssign
  38: oEmit 48
  40: oSetResult 0
  42: oPushResult
  43: oEmitInt
  44: oPop 1
  46: oEmit 51
  48: oGetLocal 3
  50: oPushResult
  51: oEmitLabel
  52: oPop 1
  54: oEmit 50
  56: oSetResult 0
  58: oPushResult
  59: oEmitInt
  60: oPop 1
  62: oEmit 53
  64: oInput 27
  66: oInput 0
  68: oGetAddrLocal 4
  70: oPushResult
  71: oSetResult 4
  73: oPushResult
  74: oNodeNew
  75: oPop 1
  77: oAssign
  78: oGetLocal 4
  80: oPushResult
  81: oSetResult 4
  83: oPushResult
  84: LAST_ID
  85: oPushResult
  86: oNodeSetInt
  87: oPop 3
  89: oGetGlobal 1
  91: oPushResult
  92: oSetResult 2
  94: oPushResult
  95: oGetLocal 4
  97: oPushResult
  98: oNodeSet
  99: oPop 3
 101: oInputChoice 175
 103: oInput 0
 105: oGetAddrLocal 1
 107: oPushResult
 108: oSetResult 19
 110: oPushResult
 111: LAST_ID
 112: oPushResult
 113: oCall 9232
 115: oPop 2
 117: oAssign
 118: oGetLocal 1
 120: oPushResult
 121: oSetResult 21
 123: oPushResult
 124: oGetGlobal 4
 126: oPushResult
 127: oNodeSet
 128: oPop 3
 130: oGetLocal 1
 132: oPushResult
 133: oScopeDeclareAlloc
 134: oPop 1
 136: oInput 12
 138: oInput 0
 140: oGetAddrLocal 1
 142: oPushResult
 143: oSetResult 19
 145: oPushResult
 146: LAST_ID
 147: oPushResult
 148: oCall 9232
 150: oPop 2
 152: oAssign
 153: oGetLocal 1
 155: oPushResult
 156: oSetResult 21
 158: oPushResult
 159: oGetGlobal 4
 161: oPushResult
 162: oNodeSet
 163: oPop 3
 165: oGetLocal 1
 167: oPushResult
 168: oScopeDeclareAlloc
 169: oPop 1
 171: oInput 14
 173: oJumpForward 178
 175: Choice Lookup Table
          13    103
 178: oInput 4
 180: oInputChoice 191
 182: oGetLocal 4
 184: oPushResult
 185: oCall 299
 187: oPop 1
 189: oJumpForward 194
 191: Choice Lookup Table
          56    182
 194: oGetLocal 4
 196: oPushResult
 197: oCall 452
 199: oPop 1
 201: oSetResult 0
 203: oPushResult
 204: oSetResult 0
 206: oPushResult
 207: oScopeBegin
 208: oPop 2
 210: oGetAddrGlobal 2
 212: oPushResult
 213: oScopeCurrent
 214: oAssign
 215: oSetResult 0
 217: oPushResult
 218: oSetResult 1
 220: oPushResult
 221: oScopeBegin
 222: oPop 2
 224: oScopeCurrent
 225: oPushResult
 226: oSetResult 16
 228: oPushResult
 229: oGetGlobal 2
 231: oPushResult
 232: oNodeSet
 233: oPop 3
 235: oGetAddrGlobal 3
 237: oPushResult
 238: oScopeCurrent
 239: oAssign
 240: oGetLocal 4
 242: oPushResult
 243: oSetResult 7
 245: oPushResult
 246: oGetGlobal 3
 248: oPushResult
 249: oNodeSet
 250: oPop 3
 252: oScopeEnd
 253: oSetResult 20
 255: oPushResult
 256: oCall 1388
 258: oPop 1
 260: oGetGlobal 3
 262: oPushResult
 263: oScopeEnter
 264: oPop 1
 266: oGetAddrLocal 5
 268: oPushResult
 269: oSetResult 1
 271: oAssign
 272: oGetLocal 3
 274: oPushResult
 275: oGetGlobal 2
 277: oPushResult
 278: oGetLocal 5
 280: oPushResult
 281: oCall 1709
 283: oPop 3
 285: oScopeEnd
 286: oInput 19
 288: oCall 1444
 290: oScopeEnd
 291: oGetLocal 4
 293: oPushResult
 294: oCall 514
 296: oPop 1
 298: oReturn
 299: oLocalSpace 2
 301: oInput 0
 303: oGetAddrLocal 1
 305: oPushResult
 306: LAST_ID
 307: oPushResult
 308: oCall 593
 310: oPop 1
 312: oAssign
 313: oGetLocal 1
 315: oPushResult
 316: oSetResult 0
 318: oPushResult
 319: equal_node
 320: oPop 2
 322: oChoice 392
 324: oGetParam 1
 326: oPushResult
 327: oSetResult 5
 329: oPushResult
 330: oGetLocal 1
 332: oPushResult
 333: oNodeAddLast
 334: oPop 3
 336: oGetAddrLocal 2
 338: oPushResult
 339: oSetResult 10
 341: oPushResult
 342: oNodeNew
 343: oPop 1
 345: oAssign
 346: oGetLocal 2
 348: oPushResult
 349: oSetResult 4
 351: oPushResult
 352: oGetLocal 1
 354: oPushResult
 355: oSetResult 4
 357: oPushResult
 358: oNodeGetInt
 359: oPop 2
 361: oPushResult
 362: oNodeSetInt
 363: oPop 3
 365: oGetLocal 2
 367: oPushResult
 368: oSetResult 9
 370: oPushResult
 371: oGetLocal 1
 373: oPushResult
 374: oSetResult 9
 376: oPushResult
 377: oNodeGet
 378: oPop 2
 380: oPushResult
 381: oNodeSet
 382: oPop 3
 384: oGetLocal 2
 386: oPushResult
 387: oScopeDeclare
 388: oPop 1
 390: oJumpForward 395
 392: Choice Lookup Table
           0    324
 395: oInputChoice 399
 397: oJumpForward 404
 399: Choice Lookup Table
          12    397
 402: oJumpForward 406
 404: oJumpBack 301
 406: oInput 4
 408: oReturn
 409: oLocalSpace 1
 411: oGetFromParam 1
 413: oPushResult
 414: oNodeType
 415: oPop 1
 417: oChoice 448
 419: oGetAddrLocal 1
 421: oPushResult
 422: oGetFromParam 1
 424: oPushResult
 425: oSetResult 9
 427: oPushResult
 428: oNodeGet
 429: oPop 2
 431: oAssign
 432: oInput 19
 434: oInput 0
 436: oGetParam 1
 438: oPushResult
 439: oGetLocal 1
 441: oPushResult
 442: oScopeFindRequireInScope
 443: oPop 1
 445: oAssign
 446: oJumpForward 451
 448: Choice Lookup Table
          10    419
 451: oReturn
 452: oLocalSpace 2
 454: oGetAddrLocal 1
 456: oPushResult
 457: oGetParam 1
 459: oPushResult
 460: oSetResult 5
 462: oPushResult
 463: oNodeGetIter
 464: oPop 2
 466: oAssign
 467: oGetAddrLocal 2
 469: oPushResult
 470: oGetLocal 1
 472: oPushResult
 473: oNodeIterValue
 474: oPop 1
 476: oAssign
 477: oGetLocal 2
 479: oPushResult
 480: oNodeNull
 481: oPop 1
 483: oChoice 500
 485: oGetLocal 2
 487: oPushResult
 488: oSetResult 9
 490: oPushResult
 491: oNodeGet
 492: oPop 2
 494: oPushResult
 495: oScopeEnter
 496: oPop 1
 498: oJumpForward 505
 500: Choice Lookup Table
           0    485
 503: oJumpForward 513
 505: oGetAddrLocal 1
 507: oPushResult
 508: oNodeIterNext
 509: oPop 1
 511: oJumpBack 467
 513: oReturn
 514: oLocalSpace 2
 516: oGetAddrLocal 1
 518: oPushResult
 519: oGetParam 1
 521: oPushResult
 522: oSetResult 5
 524: oPushResult
 525: oNodeGetIterLast
 526: oPop 2
 528: oAssign
 529: oGetAddrLocal 2
 531: oPushResult
 532: oGetLocal 1
 534: oPushResult
 535: oNodeIterValue
 536: oPop 1
 538: oAssign
 539: oGetLocal 2
 541: oPushResult
 542: oNodeNull
 543: oPop 1
 545: oChoice 579
 547: oScopeCurrent
 548: oPushResult
 549: oGetLocal 2
 551: oPushResult
 552: oSetResult 9
 554: oPushResult
 555: oNodeGet
 556: oPop 2
 558: oPushResult
 559: oNodeEqual
 560: oPop 2
 562: oChoice 570
 564: oJumpForward 576
 566: oError 25
 568: oJumpForward 576
 570: Choice Lookup Table
           0    566
           1    564
 575: oEndChoice
 576: oScopeEnd
 577: oJumpForward 584
 579: Choice Lookup Table
           0    547
 582: oJumpForward 592
 584: oGetAddrLocal 1
 586: oPushResult
 587: oNodeIterPrev
 588: oPop 1
 590: oJumpBack 529
 592: oReturn
 593: oLocalSpace 2
 595: oGetAddrLocal 1
 597: oPushResult
 598: oGetGlobal 1
 600: oPushResult
 601: oSetResult 1
 603: oPushResult
 604: oSetResult 4
 606: oPushResult
 607: oGetParam 1
 609: oPushResult
 610: oNodeFind
 611: oPop 4
 613: oAssign
 614: oGetLocal 1
 616: oPushResult
 617: oSetResult 0
 619: oPushResult
 620: equal_node
 621: oPop 2
 623: oChoice 630
 625: oGetLocal 1
 627: oReturn
 628: oJumpForward 633
 630: Choice Lookup Table
           0    625
 633: oGetAddrLocal 2
 635: oPushResult
 636: oGetParam 1
 638: oPushResult
 639: oIncludeUnitFile
 640: oPop 1
 642: oAssign
 643: oGetLocal 2
 645: oChoice 654
 647: oError 24
 649: oSetResult 0
 651: oReturn
 652: oJumpForward 657
 654: Choice Lookup Table
           0    647
 657: oGetAddrLocal 1
 659: oPushResult
 660: oCall 668
 662: oAssign
 663: oIncludeEnd
 664: oGetLocal 1
 666: oReturn
 667: oReturn
 668: oLocalSpace 2
 670: oInput 57
 672: oInput 0
 674: oGetAddrLocal 1
 676: oPushResult
 677: oSetResult 5
 679: oPushResult
 680: oNodeNew
 681: oPop 1
 683: oAssign
 684: oGetLocal 1
 686: oPushResult
 687: oSetResult 4
 689: oPushResult
 690: LAST_ID
 691: oPushResult
 692: oNodeSetInt
 693: oPop 3
 695: oGetAddrLocal 2
 697: oPushResult
 698: oSetResult 6
 700: oPushResult
 701: oNodeNew
 702: oPop 1
 704: oAssign
 705: oGetLocal 2
 707: oPushResult
 708: oSetResult 4
 710: oPushResult
 711: LAST_ID
 712: oPushResult
 713: oNodeSetInt
 714: oPop 3
 716: oGetLocal 1
 718: oPushResult
 719: oSetResult 8
 721: oPushResult
 722: oGetLocal 2
 724: oPushResult
 725: oNodeSet
 726: oPop 3
 728: oInput 4
 730: oInput 58
 732: oInputChoice 743
 734: oGetLocal 1
 736: oPushResult
 737: oCall 299
 739: oPop 1
 741: oJumpForward 746
 743: Choice Lookup Table
          56    734
 746: oGetLocal 1
 748: oPushResult
 749: oCall 452
 751: oPop 1
 753: oSetResult 0
 755: oPushResult
 756: oSetResult 0
 758: oPushResult
 759: oScopeBegin
 760: oPop 2
 762: oGetLocal 1
 764: oPushResult
 765: oSetResult 9
 767: oPushResult
 768: oScopeCurrent
 769: oPushResult
 770: oNodeSet
 771: oPop 3
 773: oGetAddrGlobal 2
 775: oPushResult
 776: oScopeCurrent
 777: oAssign
 778: oSetResult 0
 780: oPushResult
 781: oSetResult 1
 783: oPushResult
 784: oScopeBegin
 785: oPop 2
 787: oGetAddrGlobal 3
 789: oPushResult
 790: oScopeCurrent
 791: oAssign
 792: oGetLocal 1
 794: oPushResult
 795: oSetResult 13
 797: oPushResult
 798: oGetGlobal 3
 800: oPushResult
 801: oNodeSet
 802: oPop 3
 804: oScopeEnd
 805: oGetLocal 1
 807: oPushResult
 808: oCall 989
 810: oPop 1
 812: oScopeEnd
 813: oInput 59
 815: oInputChoice 826
 817: oGetLocal 2
 819: oPushResult
 820: oCall 299
 822: oPop 1
 824: oJumpForward 829
 826: Choice Lookup Table
          56    817
 829: oGetLocal 2
 831: oPushResult
 832: oCall 452
 834: oPop 1
 836: oGetLocal 1
 838: oPushResult
 839: oSetResult 9
 841: oPushResult
 842: oNodeGet
 843: oPop 2
 845: oPushResult
 846: oScopeEnter
 847: oPop 1
 849: oSetResult 0
 851: oPushResult
 852: oSetResult 0
 854: oPushResult
 855: oScopeBegin
 856: oPop 2
 858: oGetLocal 1
 860: oPushResult
 861: oSetResult 10
 863: oPushResult
 864: oScopeCurrent
 865: oPushResult
 866: oNodeSet
 867: oPop 3
 869: oScopeCurrent
 870: oPushResult
 871: oSetResult 16
 873: oPushResult
 874: oGetLocal 1
 876: oPushResult
 877: oSetResult 9
 879: oPushResult
 880: oNodeGet
 881: oPop 2
 883: oPushResult
 884: oNodeSet
 885: oPop 3
 887: oGetAddrGlobal 2
 889: oPushResult
 890: oScopeCurrent
 891: oAssign
 892: oGetLocal 1
 894: oPushResult
 895: oCall 1074
 897: oPop 1
 899: oInputChoice 913
 901: oGetLocal 1
 903: oPushResult
 904: oSetResult 1
 906: oPushResult
 907: oCall 1084
 909: oPop 2
 911: oJumpForward 926
 913: Choice Lookup Table
          60    901
 916: oGetLocal 1
 918: oPushResult
 919: oSetResult 0
 921: oPushResult
 922: oCall 1084
 924: oPop 2
 926: oInputChoice 940
 928: oGetLocal 1
 930: oPushResult
 931: oSetResult 1
 933: oPushResult
 934: oCall 1270
 936: oPop 2
 938: oJumpForward 953
 940: Choice Lookup Table
          61    928
 943: oGetLocal 1
 945: oPushResult
 946: oSetResult 0
 948: oPushResult
 949: oCall 1270
 951: oPop 2
 953: oInput 35
 955: oInput 19
 957: oScopeEnd
 958: oScopeEnd
 959: oGetLocal 2
 961: oPushResult
 962: oCall 514
 964: oPop 1
 966: oGetLocal 1
 968: oPushResult
 969: oCall 514
 971: oPop 1
 973: oGetGlobal 1
 975: oPushResult
 976: oSetResult 1
 978: oPushResult
 979: oGetLocal 1
 981: oPushResult
 982: oNodeAddLast
 983: oPop 3
 985: oGetLocal 1
 987: oReturn
 988: oReturn
 989: oLocalSpace 2
 991: oInputChoice 1058
 993: oCall 2982
 995: oJumpForward 1071
 997: oCall 3051
 999: oJumpForward 1071
1001: oSetResult 20
1003: oPushResult
1004: oCall 3107
1006: oPop 1
1008: oJumpForward 1071
1010: oGetAddrLocal 1
1012: oPushResult
1013: oCall 1949
1015: oAssign
1016: oInputChoice 1029
1018: oGetLocal 1
1020: oPushResult
1021: oCall 1887
1023: oPop 1
1025: oInput 4
1027: oJumpForward 1032
1029: Choice Lookup Table
          67   1018
1032: oJumpForward 1071
1034: oGetAddrLocal 2
1036: oPushResult
1037: oCall 2323
1039: oAssign
1040: oInputChoice 1053
1042: oGetLocal 2
1044: oPushResult
1045: oCall 1887
1047: oPop 1
1049: oInput 4
1051: oJumpForward 1056
1053: Choice Lookup Table
          67   1042
1056: oJumpForward 1071
1058: Choice Lookup Table
          29   1034
          28   1010
          32   1001
          31    997
          30    993
1069: oJumpForward 1073
1071: oJumpBack 991
1073: oReturn
1074: oLocalSpace 0
1076: oSetResult 20
1078: oPushResult
1079: oCall 1388
1081: oPop 1
1083: oReturn
1084: oLocalSpace 5
1086: oGetAddrLocal 1
1088: oPushResult
1089: oLabelNew
1090: oAssign
1091: oEmit 58
1093: oGetLocal 1
1095: oPushResult
1096: oEmitLabel
1097: oPop 1
1099: oGetParam 2
1101: oPushResult
1102: oSetResult 11
1104: oPushResult
1105: oGetLocal 1
1107: oPushResult
1108: oNodeSetLabel
1109: oPop 3
1111: oEmit 54
1113: oGetAddrLocal 2
1115: oPushResult
1116: Here
1117: oAssign
1118: oEmit 68
1120: oGetAddrLocal 3
1122: oPushResult
1123: oGetParam 2
1125: oPushResult
1126: oSetResult 9
1128: oPushResult
1129: oNodeGet
1130: oPop 2
1132: oAssign
1133: oGetAddrLocal 4
1135: oPushResult
1136: oGetLocal 3
1138: oPushResult
1139: oSetResult 19
1141: oPushResult
1142: oNodeGetCode
1143: oPop 2
1145: oAssign
1146: oGetLocal 4
1148: oPushResult
1149: oEmitCode
1150: oPop 1
1152: oGetLocal 3
1154: oPushResult
1155: oSetResult 19
1157: oPushResult
1158: oSetResult 0
1160: oPushResult
1161: oNodeSetCode
1162: oPop 3
1164: oGetAddrLocal 3
1166: oPushResult
1167: oGetParam 2
1169: oPushResult
1170: oSetResult 10
1172: oPushResult
1173: oNodeGet
1174: oPop 2
1176: oAssign
1177: oGetAddrLocal 4
1179: oPushResult
1180: oGetLocal 3
1182: oPushResult
1183: oSetResult 19
1185: oPushResult
1186: oNodeGetCode
1187: oPop 2
1189: oAssign
1190: oGetLocal 4
1192: oPushResult
1193: oEmitCode
1194: oPop 1
1196: oGetLocal 3
1198: oPushResult
1199: oSetResult 19
1201: oPushResult
1202: oSetResult 0
1204: oPushResult
1205: oNodeSetCode
1206: oPop 3
1208: oGetParam 2
1210: oPushResult
1211: oSetResult 13
1213: oPushResult
1214: oNodeGet
1215: oPop 2
1217: oPushResult
1218: oScopeEnter
1219: oPop 1
1221: oGetParam 1
1223: oChoice 1242
1225: oCall 7767
1227: oInputChoice 1233
1229: oCall 7767
1231: oJumpForward 1238
1233: Choice Lookup Table
           4   1229
1236: oJumpForward 1240
1238: oJumpBack 1227
1240: oJumpForward 1245
1242: Choice Lookup Table
           1   1225
1245: oEmit 53
1247: oGetAddrLocal 5
1249: oPushResult
1250: oScopeCurrent
1251: oPushResult
1252: oSetResult 17
1254: oPushResult
1255: oNodeGetInt
1256: oPop 2
1258: oAssign
1259: oGetLocal 2
1261: oPushResult
1262: oGetLocal 5
1264: oPushResult
1265: oPatch
1266: oPop 2
1268: oScopeEnd
1269: oReturn
1270: oLocalSpace 3
1272: oGetAddrLocal 1
1274: oPushResult
1275: oLabelNew
1276: oAssign
1277: oEmit 58
1279: oGetLocal 1
1281: oPushResult
1282: oEmitLabel
1283: oPop 1
1285: oGetParam 2
1287: oPushResult
1288: oSetResult 12
1290: oPushResult
1291: oGetLocal 1
1293: oPushResult
1294: oNodeSetLabel
1295: oPop 3
1297: oEmit 54
1299: oGetAddrLocal 2
1301: oPushResult
1302: Here
1303: oAssign
1304: oEmit 68
1306: oSetResult 0
1308: oPushResult
1309: oSetResult 1
1311: oPushResult
1312: oScopeBegin
1313: oPop 2
1315: oGetParam 1
1317: oChoice 1336
1319: oCall 7767
1321: oInputChoice 1327
1323: oCall 7767
1325: oJumpForward 1332
1327: Choice Lookup Table
           4   1323
1330: oJumpForward 1334
1332: oJumpBack 1321
1334: oJumpForward 1339
1336: Choice Lookup Table
           1   1319
1339: oEmit 53
1341: oGetAddrLocal 3
1343: oPushResult
1344: oScopeCurrent
1345: oPushResult
1346: oSetResult 17
1348: oPushResult
1349: oNodeGetInt
1350: oPop 2
1352: oAssign
1353: oGetLocal 2
1355: oPushResult
1356: oGetLocal 3
1358: oPushResult
1359: oPatch
1360: oPop 2
1362: oScopeEnd
1363: oReturn
1364: oLocalSpace 0
1366: oGetParam 2
1368: oPushResult
1369: oCall 1388
1371: oPop 1
1373: oGetParam 1
1375: oPushResult
1376: oScopeCurrent
1377: oPushResult
1378: oSetResult 0
1380: oPushResult
1381: oCall 1709
1383: oPop 3
1385: oCall 1444
1387: oReturn
1388: oLocalSpace 0
1390: oInputChoice 1421
1392: oCall 2982
1394: oJumpForward 1436
1396: oCall 3051
1398: oJumpForward 1436
1400: oGetParam 1
1402: oPushResult
1403: oCall 3107
1405: oPop 1
1407: oJumpForward 1436
1409: oCall 3338
1411: oJumpForward 1436
1413: oCall 2205
1415: oJumpForward 1436
1417: oCall 2640
1419: oJumpForward 1436
1421: Choice Lookup Table
          29   1417
          28   1413
          33   1409
          32   1400
          31   1396
          30   1392
1434: oJumpForward 1438
1436: oJumpBack 1390
1438: oCall 1441
1440: oReturn
1441: oLocalSpace 0
1443: oReturn
1444: oLocalSpace 2
1446: oGetAddrLocal 1
1448: oPushResult
1449: oScopeCurrent
1450: oPushResult
1451: oSetResult 15
1453: oPushResult
1454: oNodeGetIter
1455: oPop 2
1457: oAssign
1458: oGetAddrLocal 2
1460: oPushResult
1461: oGetLocal 1
1463: oPushResult
1464: oNodeIterValue
1465: oPop 1
1467: oAssign
1468: oGetLocal 2
1470: oPushResult
1471: oNodeNull
1472: oPop 1
1474: oChoice 1478
1476: oJumpForward 1483
1478: Choice Lookup Table
           0   1476
1481: oJumpForward 1538
1483: oGetLocal 2
1485: oPushResult
1486: oNodeType
1487: oPop 1
1489: oChoice 1527
1491: oGetLocal 2
1493: oPushResult
1494: oSetResult 34
1496: oPushResult
1497: oNodeGetBoolean
1498: oPop 2
1500: oChoice 1522
1502: oGetLocal 2
1504: oPushResult
1505: oSetResult 28
1507: oPushResult
1508: oNodeGetBoolean
1509: oPop 2
1511: oChoice 1517
1513: oError 27
1515: oJumpForward 1520
1517: Choice Lookup Table
           1   1513
1520: oJumpForward 1525
1522: Choice Lookup Table
           0   1502
1525: oJumpForward 1530
1527: Choice Lookup Table
          24   1491
1530: oGetAddrLocal 1
1532: oPushResult
1533: oNodeIterNext
1534: oPop 1
1536: oJumpBack 1458
1538: oReturn
1539: oLocalSpace 2
1541: oGetAddrLocal 1
1543: oPushResult
1544: oGetGlobal 1
1546: oPushResult
1547: oSetResult 1
1549: oPushResult
1550: oNodeGetIter
1551: oPop 2
1553: oAssign
1554: oGetAddrLocal 2
1556: oPushResult
1557: oGetLocal 1
1559: oPushResult
1560: oNodeIterValue
1561: oPop 1
1563: oAssign
1564: oGetLocal 2
1566: oPushResult
1567: oNodeNull
1568: oPop 1
1570: oChoice 1615
1572: oJumpForward 1623
1574: oJumpForward 1621
1576: oEmit 48
1578: oSetResult 0
1580: oPushResult
1581: oEmitInt
1582: oPop 1
1584: oEmit 51
1586: oGetLocal 2
1588: oPushResult
1589: oSetResult 11
1591: oPushResult
1592: oNodeGetLabel
1593: oPop 2
1595: oPushResult
1596: oEmitLabel
1597: oPop 1
1599: oEmit 50
1601: oSetResult 0
1603: oPushResult
1604: oEmitInt
1605: oPop 1
1607: oGetAddrLocal 1
1609: oPushResult
1610: oNodeIterNext
1611: oPop 1
1613: oJumpForward 1621
1615: Choice Lookup Table
           0   1576
           1   1572
1620: oEndChoice
1621: oJumpBack 1554
1623: oReturn
1624: oLocalSpace 2
1626: oGetAddrLocal 1
1628: oPushResult
1629: oGetGlobal 1
1631: oPushResult
1632: oSetResult 1
1634: oPushResult
1635: oNodeGetIterLast
1636: oPop 2
1638: oAssign
1639: oGetAddrLocal 2
1641: oPushResult
1642: oGetLocal 1
1644: oPushResult
1645: oNodeIterValue
1646: oPop 1
1648: oAssign
1649: oGetLocal 2
1651: oPushResult
1652: oNodeNull
1653: oPop 1
1655: oChoice 1700
1657: oJumpForward 1708
1659: oJumpForward 1706
1661: oEmit 48
1663: oSetResult 0
1665: oPushResult
1666: oEmitInt
1667: oPop 1
1669: oEmit 51
1671: oGetLocal 2
1673: oPushResult
1674: oSetResult 12
1676: oPushResult
1677: oNodeGetLabel
1678: oPop 2
1680: oPushResult
1681: oEmitLabel
1682: oPop 1
1684: oEmit 50
1686: oSetResult 0
1688: oPushResult
1689: oEmitInt
1690: oPop 1
1692: oGetAddrLocal 1
1694: oPushResult
1695: oNodeIterPrev
1696: oPop 1
1698: oJumpForward 1706
1700: Choice Lookup Table
           0   1661
           1   1657
1705: oEndChoice
1706: oJumpBack 1639
1708: oReturn
1709: oLocalSpace 3
1711: oEmit 58
1713: oGetParam 3
1715: oPushResult
1716: oEmitLabel
1717: oPop 1
1719: oEmit 54
1721: oGetAddrLocal 1
1723: oPushResult
1724: Here
1725: oAssign
1726: oEmit 68
1728: oGetParam 1
1730: oChoice 1736
1732: oCall 1539
1734: oJumpForward 1739
1736: Choice Lookup Table
           1   1732
1739: oGetAddrLocal 2
1741: oPushResult
1742: oGetParam 2
1744: oPushResult
1745: oSetResult 19
1747: oPushResult
1748: oNodeGetCode
1749: oPop 2
1751: oAssign
1752: oGetLocal 2
1754: oPushResult
1755: oEmitCode
1756: oPop 1
1758: oGetParam 2
1760: oPushResult
1761: oSetResult 19
1763: oPushResult
1764: oSetResult 0
1766: oPushResult
1767: oNodeSetCode
1768: oPop 3
1770: oCall 7767
1772: oGetParam 1
1774: oChoice 1780
1776: oCall 1624
1778: oJumpForward 1783
1780: Choice Lookup Table
           1   1776
1783: oEmit 53
1785: oGetAddrLocal 3
1787: oPushResult
1788: oScopeCurrent
1789: oPushResult
1790: oSetResult 17
1792: oPushResult
1793: oNodeGetInt
1794: oPop 2
1796: oAssign
1797: oGetLocal 1
1799: oPushResult
1800: oGetLocal 3
1802: oPushResult
1803: oPatch
1804: oPop 2
1806: oReturn
1807: oLocalSpace 0
1809: oInputChoice 1827
1811: oGetParam 1
1813: oPushResult
1814: oSetResult 27
1816: oPushResult
1817: oSetResult 1
1819: oPushResult
1820: oNodeSetBoolean
1821: oPop 3
1823: oInput 4
1825: oJumpForward 1832
1827: Choice Lookup Table
          69   1811
1830: oJumpForward 1834
1832: oJumpBack 1809
1834: oReturn
1835: oLocalSpace 1
1837: oGetAddrLocal 1
1839: oPushResult
1840: oGetParam 1
1842: oPushResult
1843: oSetResult 19
1845: oPushResult
1846: oNodeGetCode
1847: oPop 2
1849: oAssign
1850: oGetLocal 1
1852: oPushResult
1853: oSetResult 0
1855: oPushResult
1856: equal_code
1857: oPop 2
1859: oChoice 1880
1861: oGetAddrLocal 1
1863: oPushResult
1864: oCodeNew
1865: oAssign
1866: oGetParam 1
1868: oPushResult
1869: oSetResult 19
1871: oPushResult
1872: oGetLocal 1
1874: oPushResult
1875: oNodeSetCode
1876: oPop 3
1878: oJumpForward 1883
1880: Choice Lookup Table
           1   1861
1883: oGetLocal 1
1885: oReturn
1886: oReturn
1887: oLocalSpace 0
1889: oGetParam 1
1891: oPushResult
1892: oCall 9014
1894: oPop 1
1896: oPushResult
1897: equal_zero
1898: oPop 1
1900: oChoice 1906
1902: oError 23
1904: oJumpForward 1909
1906: Choice Lookup Table
           0   1902
1909: oGetParam 1
1911: oPushResult
1912: oSetResult 25
1914: oPushResult
1915: oSetResult 1
1917: oPushResult
1918: oNodeSetBoolean
1919: oPop 3
1921: oInputChoice 1945
1923: oInputChoice 1940
1925: oInput 2
1927: oGetParam 1
1929: oPushResult
1930: oSetResult 26
1932: oPushResult
1933: CURRENT_STRLIT
1934: oPushResult
1935: oNodeSetString
1936: oPop 3
1938: oJumpForward 1943
1940: Choice Lookup Table
          68   1925
1943: oJumpForward 1948
1945: Choice Lookup Table
           2   1923
1948: oReturn
1949: oLocalSpace 6
1951: oInput 0
1953: oGetAddrLocal 1
1955: oPushResult
1956: oSetResult 0
1958: oAssign
1959: oGetAddrLocal 2
1961: oPushResult
1962: oScopeFindInCurrentScope
1963: oAssign
1964: oGetLocal 2
1966: oPushResult
1967: oNodeNull
1968: oPop 1
1970: oChoice 2088
1972: oGetAddrLocal 2
1974: oPushResult
1975: oSetResult 12
1977: oPushResult
1978: LAST_ID
1979: oPushResult
1980: oCall 9232
1982: oPop 2
1984: oAssign
1985: oGetLocal 2
1987: oPushResult
1988: oSetResult 22
1990: oPushResult
1991: oLabelNew
1992: oPushResult
1993: oNodeSetLabel
1994: oPop 3
1996: oJumpForward 2094
1998: oGetAddrLocal 1
2000: oPushResult
2001: oSetResult 1
2003: oAssign
2004: oGetLocal 2
2006: oPushResult
2007: oSetResult 24
2009: oPushResult
2010: oNodeGetBoolean
2011: oPop 2
2013: oChoice 2019
2015: oError 21
2017: oJumpForward 2022
2019: Choice Lookup Table
           1   2015
2022: oGetLocal 2
2024: oPushResult
2025: oSetResult 25
2027: oPushResult
2028: oNodeGetBoolean
2029: oPop 2
2031: oChoice 2037
2033: oError 21
2035: oJumpForward 2040
2037: Choice Lookup Table
           1   2033
2040: oGetLocal 2
2042: oPushResult
2043: oNodeType
2044: oPop 1
2046: oChoice 2050
2048: oJumpForward 2055
2050: Choice Lookup Table
          12   2048
2053: oError 21
2055: oGetLocal 2
2057: oPushResult
2058: oSetResult 29
2060: oPushResult
2061: oGetLocal 2
2063: oPushResult
2064: oSetResult 23
2066: oPushResult
2067: oNodeGet
2068: oPop 2
2070: oPushResult
2071: oNodeSet
2072: oPop 3
2074: oGetLocal 2
2076: oPushResult
2077: oSetResult 23
2079: oPushResult
2080: oSetResult 0
2082: oPushResult
2083: oNodeSet
2084: oPop 3
2086: oJumpForward 2094
2088: Choice Lookup Table
           0   1998
           1   1972
2093: oEndChoice
2094: oGetAddrLocal 3
2096: oPushResult
2097: oCall 9002
2099: oAssign
2100: oGetAddrLocal 4
2102: oPushResult
2103: oGetLocal 3
2105: oPushResult
2106: oSetResult 0
2108: oPushResult
2109: greater
2110: oPop 2
2112: oAssign
2113: oGetAddrLocal 3
2115: oPushResult
2116: inc
2117: oPop 1
2119: oGetLocal 3
2121: oPushResult
2122: oSetResult 2
2124: oPushResult
2125: oScopeBegin
2126: oPop 2
2128: oGetAddrLocal 5
2130: oPushResult
2131: oScopeCurrent
2132: oAssign
2133: oGetLocal 4
2135: oChoice 2154
2137: oGetAddrLocal 6
2139: oPushResult
2140: oGetGlobal 5
2142: oPushResult
2143: oCall 9260
2145: oPop 1
2147: oPushResult
2148: oScopeAllocType
2149: oPop 1
2151: oAssign
2152: oJumpForward 2157
2154: Choice Lookup Table
           1   2137
2157: oCall 2758
2159: oGetLocal 2
2161: oPushResult
2162: oSetResult 23
2164: oPushResult
2165: oGetLocal 5
2167: oPushResult
2168: oNodeSet
2169: oPop 3
2171: oScopeEnd
2172: oInput 4
2174: oGetLocal 1
2176: oChoice 2188
2178: oGetLocal 2
2180: oPushResult
2181: oScopeDeclare
2182: oPop 1
2184: oJumpForward 2194
2186: oJumpForward 2194
2188: Choice Lookup Table
           1   2186
           0   2178
2193: oEndChoice
2194: oGetLocal 2
2196: oPushResult
2197: oCall 1807
2199: oPop 1
2201: oGetLocal 2
2203: oReturn
2204: oReturn
2205: oLocalSpace 4
2207: oGetAddrLocal 1
2209: oPushResult
2210: oCall 1949
2212: oAssign
2213: oInputChoice 2226
2215: oJumpForward 2320
2217: oGetLocal 1
2219: oPushResult
2220: oCall 1887
2222: oPop 1
2224: oJumpForward 2320
2226: Choice Lookup Table
          67   2217
          66   2215
2231: oGetAddrLocal 2
2233: oPushResult
2234: oGetLocal 1
2236: oPushResult
2237: oSetResult 23
2239: oPushResult
2240: oNodeGet
2241: oPop 2
2243: oAssign
2244: oGetLocal 2
2246: oPushResult
2247: oScopeEnter
2248: oPop 1
2250: oGetAddrLocal 3
2252: oPushResult
2253: oGetLocal 2
2255: oPushResult
2256: oSetResult 14
2258: oPushResult
2259: oNodeGetInt
2260: oPop 2
2262: oAssign
2263: oGetLocal 3
2265: oPushResult
2266: oSetResult 1
2268: oPushResult
2269: oScopeBegin
2270: oPop 2
2272: oGetLocal 1
2274: oPushResult
2275: oSetResult 6
2277: oPushResult
2278: oScopeCurrent
2279: oPushResult
2280: oNodeSet
2281: oPop 3
2283: oGetAddrLocal 4
2285: oPushResult
2286: oGetLocal 1
2288: oPushResult
2289: oSetResult 22
2291: oPushResult
2292: oNodeGetLabel
2293: oPop 2
2295: oAssign
2296: oSetResult 21
2298: oPushResult
2299: oGetLocal 4
2301: oPushResult
2302: oCall 1364
2304: oPop 2
2306: oGetLocal 1
2308: oPushResult
2309: oSetResult 24
2311: oPushResult
2312: oSetResult 1
2314: oPushResult
2315: oNodeSetBoolean
2316: oPop 3
2318: oScopeEnd
2319: oScopeEnd
2320: oInput 4
2322: oReturn
2323: oLocalSpace 8
2325: oInput 0
2327: oGetAddrLocal 1
2329: oPushResult
2330: oSetResult 0
2332: oAssign
2333: oGetAddrLocal 2
2335: oPushResult
2336: oScopeFindInCurrentScope
2337: oAssign
2338: oGetLocal 2
2340: oPushResult
2341: oNodeNull
2342: oPop 1
2344: oChoice 2475
2346: oGetAddrLocal 2
2348: oPushResult
2349: oSetResult 13
2351: oPushResult
2352: LAST_ID
2353: oPushResult
2354: oCall 9232
2356: oPop 2
2358: oAssign
2359: oGetLocal 2
2361: oPushResult
2362: oSetResult 22
2364: oPushResult
2365: oLabelNew
2366: oPushResult
2367: oNodeSetLabel
2368: oPop 3
2370: oJumpForward 2481
2372: oGetAddrLocal 1
2374: oPushResult
2375: oSetResult 1
2377: oAssign
2378: oGetLocal 2
2380: oPushResult
2381: oSetResult 24
2383: oPushResult
2384: oNodeGetBoolean
2385: oPop 2
2387: oChoice 2393
2389: oError 21
2391: oJumpForward 2396
2393: Choice Lookup Table
           1   2389
2396: oGetLocal 2
2398: oPushResult
2399: oNodeType
2400: oPop 1
2402: oChoice 2406
2404: oJumpForward 2411
2406: Choice Lookup Table
          13   2404
2409: oError 21
2411: oGetLocal 2
2413: oPushResult
2414: oSetResult 29
2416: oPushResult
2417: oGetLocal 2
2419: oPushResult
2420: oSetResult 23
2422: oPushResult
2423: oNodeGet
2424: oPop 2
2426: oPushResult
2427: oNodeSet
2428: oPop 3
2430: oGetLocal 2
2432: oPushResult
2433: oSetResult 23
2435: oPushResult
2436: oSetResult 0
2438: oPushResult
2439: oNodeSet
2440: oPop 3
2442: oGetLocal 2
2444: oPushResult
2445: oSetResult 30
2447: oPushResult
2448: oGetLocal 2
2450: oPushResult
2451: oSetResult 21
2453: oPushResult
2454: oNodeGet
2455: oPop 2
2457: oPushResult
2458: oNodeSet
2459: oPop 3
2461: oGetLocal 2
2463: oPushResult
2464: oSetResult 21
2466: oPushResult
2467: oSetResult 0
2469: oPushResult
2470: oNodeSet
2471: oPop 3
2473: oJumpForward 2481
2475: Choice Lookup Table
           0   2372
           1   2346
2480: oEndChoice
2481: oGetAddrLocal 3
2483: oPushResult
2484: oCall 9002
2486: oAssign
2487: oGetAddrLocal 4
2489: oPushResult
2490: oGetLocal 3
2492: oPushResult
2493: oSetResult 0
2495: oPushResult
2496: greater
2497: oPop 2
2499: oAssign
2500: oGetAddrLocal 3
2502: oPushResult
2503: inc
2504: oPop 1
2506: oGetLocal 3
2508: oPushResult
2509: oSetResult 2
2511: oPushResult
2512: oScopeBegin
2513: oPop 2
2515: oGetAddrLocal 5
2517: oPushResult
2518: oScopeCurrent
2519: oAssign
2520: oGetLocal 4
2522: oChoice 2541
2524: oGetAddrLocal 6
2526: oPushResult
2527: oGetGlobal 5
2529: oPushResult
2530: oCall 9260
2532: oPop 1
2534: oPushResult
2535: oScopeAllocType
2536: oPop 1
2538: oAssign
2539: oJumpForward 2544
2541: Choice Lookup Table
           1   2524
2544: oCall 2758
2546: oGetLocal 2
2548: oPushResult
2549: oSetResult 23
2551: oPushResult
2552: oGetLocal 5
2554: oPushResult
2555: oNodeSet
2556: oPop 3
2558: oInput 11
2560: oGetAddrLocal 7
2562: oPushResult
2563: oCall 3403
2565: oPop 1
2567: oGetLocal 2
2569: oPushResult
2570: oSetResult 21
2572: oPushResult
2573: oGetLocal 7
2575: oPushResult
2576: oNodeSet
2577: oPop 3
2579: oGetAddrLocal 8
2581: oPushResult
2582: oGetLocal 7
2584: oPushResult
2585: oCall 9260
2587: oPop 1
2589: oAssign
2590: oGetLocal 2
2592: oPushResult
2593: oSetResult 31
2595: oPushResult
2596: oGetLocal 8
2598: oPushResult
2599: oScopeAllocType
2600: oPop 1
2602: oPushResult
2603: oNodeSetInt
2604: oPop 3
2606: oScopeEnd
2607: oInput 4
2609: oGetLocal 1
2611: oChoice 2623
2613: oGetLocal 2
2615: oPushResult
2616: oScopeDeclare
2617: oPop 1
2619: oJumpForward 2629
2621: oJumpForward 2629
2623: Choice Lookup Table
           1   2621
           0   2613
2628: oEndChoice
2629: oGetLocal 2
2631: oPushResult
2632: oCall 1807
2634: oPop 1
2636: oGetLocal 2
2638: oReturn
2639: oReturn
2640: oLocalSpace 4
2642: oGetAddrLocal 1
2644: oPushResult
2645: oCall 2323
2647: oAssign
2648: oInputChoice 2661
2650: oJumpForward 2755
2652: oGetLocal 1
2654: oPushResult
2655: oCall 1887
2657: oPop 1
2659: oJumpForward 2755
2661: Choice Lookup Table
          67   2652
          66   2650
2666: oGetAddrLocal 2
2668: oPushResult
2669: oGetLocal 1
2671: oPushResult
2672: oSetResult 23
2674: oPushResult
2675: oNodeGet
2676: oPop 2
2678: oAssign
2679: oGetLocal 2
2681: oPushResult
2682: oScopeEnter
2683: oPop 1
2685: oGetAddrLocal 3
2687: oPushResult
2688: oGetLocal 2
2690: oPushResult
2691: oSetResult 14
2693: oPushResult
2694: oNodeGetInt
2695: oPop 2
2697: oAssign
2698: oGetLocal 3
2700: oPushResult
2701: oSetResult 1
2703: oPushResult
2704: oScopeBegin
2705: oPop 2
2707: oGetLocal 1
2709: oPushResult
2710: oSetResult 6
2712: oPushResult
2713: oScopeCurrent
2714: oPushResult
2715: oNodeSet
2716: oPop 3
2718: oGetAddrLocal 4
2720: oPushResult
2721: oGetLocal 1
2723: oPushResult
2724: oSetResult 22
2726: oPushResult
2727: oNodeGetLabel
2728: oPop 2
2730: oAssign
2731: oSetResult 21
2733: oPushResult
2734: oGetLocal 4
2736: oPushResult
2737: oCall 1364
2739: oPop 2
2741: oGetLocal 1
2743: oPushResult
2744: oSetResult 24
2746: oPushResult
2747: oSetResult 1
2749: oPushResult
2750: oNodeSetBoolean
2751: oPop 3
2753: oScopeEnd
2754: oScopeEnd
2755: oInput 4
2757: oReturn
2758: oLocalSpace 6
2760: oInputChoice 2978
2762: oGetAddrLocal 1
2764: oPushResult
2765: oNodeVecNew
2766: oAssign
2767: oGetAddrLocal 3
2769: oPushResult
2770: oSetResult 0
2772: oAssign
2773: oInputChoice 2783
2775: oGetAddrLocal 3
2777: oPushResult
2778: oSetResult 1
2780: oAssign
2781: oJumpForward 2786
2783: Choice Lookup Table
          32   2775
2786: oInput 0
2788: oGetAddrLocal 2
2790: oPushResult
2791: oSetResult 23
2793: oPushResult
2794: LAST_ID
2795: oPushResult
2796: oCall 9232
2798: oPop 2
2800: oAssign
2801: oGetLocal 2
2803: oPushResult
2804: oSetResult 33
2806: oPushResult
2807: oGetLocal 3
2809: oPushResult
2810: oNodeSetBoolean
2811: oPop 3
2813: oGetLocal 1
2815: oPushResult
2816: oGetLocal 2
2818: oPushResult
2819: oNodeVecAppend
2820: oPop 2
2822: oInputChoice 2830
2824: oJumpForward 2838
2826: oJumpForward 2836
2828: oJumpForward 2836
2830: Choice Lookup Table
          12   2828
          11   2824
2835: oEndChoice
2836: oJumpBack 2786
2838: oGetAddrLocal 4
2840: oPushResult
2841: oCall 3403
2843: oPop 1
2845: oGetLocal 3
2847: oChoice 2862
2849: oGetAddrLocal 5
2851: oPushResult
2852: oGetLocal 4
2854: oPushResult
2855: oCall 9260
2857: oPop 1
2859: oAssign
2860: oJumpForward 2871
2862: Choice Lookup Table
           1   2849
2865: oGetAddrLocal 5
2867: oPushResult
2868: oGetLocal 4
2870: oAssign
2871: oGetAddrLocal 6
2873: oPushResult
2874: oSetResult 0
2876: oAssign
2877: oGetLocal 6
2879: oPushResult
2880: oGetLocal 1
2882: oPushResult
2883: oNodeVecSize
2884: oPop 1
2886: oPushResult
2887: equal
2888: oPop 2
2890: oChoice 2947
2892: oGetAddrLocal 2
2894: oPushResult
2895: oGetLocal 1
2897: oPushResult
2898: oGetLocal 6
2900: oPushResult
2901: oNodeVecElement
2902: oPop 2
2904: oAssign
2905: oGetLocal 2
2907: oPushResult
2908: oSetResult 21
2910: oPushResult
2911: oGetLocal 4
2913: oPushResult
2914: oNodeSet
2915: oPop 3
2917: oGetLocal 2
2919: oPushResult
2920: oScopeDeclare
2921: oPop 1
2923: oGetLocal 2
2925: oPushResult
2926: oSetResult 22
2928: oPushResult
2929: oGetLocal 5
2931: oPushResult
2932: oScopeAllocType
2933: oPop 1
2935: oPushResult
2936: oNodeSetInt
2937: oPop 3
2939: oGetAddrLocal 6
2941: oPushResult
2942: inc
2943: oPop 1
2945: oJumpForward 2952
2947: Choice Lookup Table
           0   2892
2950: oJumpForward 2954
2952: oJumpBack 2877
2954: oGetLocal 1
2956: oPushResult
2957: oNodeVecDelete
2958: oPop 1
2960: oInputChoice 2968
2962: oJumpForward 2976
2964: oJumpForward 2974
2966: oJumpForward 2974
2968: Choice Lookup Table
           4   2966
          14   2962
2973: oEndChoice
2974: oJumpBack 2762
2976: oJumpForward 2981
2978: Choice Lookup Table
          13   2762
2981: oReturn
2982: oLocalSpace 2
2984: oInputChoice 3043
2986: oGetAddrLocal 1
2988: oPushResult
2989: oSetResult 16
2991: oPushResult
2992: LAST_ID
2993: oPushResult
2994: oCall 9232
2996: oPop 2
2998: oAssign
2999: oInput 5
3001: oCall 4422
3003: oGetAddrLocal 2
3005: oPushResult
3006: oValueTop
3007: oAssign
3008: oValuePop
3009: oGetLocal 1
3011: oPushResult
3012: oSetResult 22
3014: oPushResult
3015: oGetLocal 2
3017: oPushResult
3018: oNodeSetInt
3019: oPop 3
3021: oGetLocal 1
3023: oPushResult
3024: oSetResult 21
3026: oPushResult
3027: oGetGlobal 5
3029: oPushResult
3030: oNodeSet
3031: oPop 3
3033: oGetLocal 1
3035: oPushResult
3036: oScopeDeclare
3037: oPop 1
3039: oInput 4
3041: oJumpForward 3048
3043: Choice Lookup Table
           0   2986
3046: oJumpForward 3050
3048: oJumpBack 2984
3050: oReturn
3051: oLocalSpace 2
3053: oInputChoice 3099
3055: oGetAddrLocal 1
3057: oPushResult
3058: oSetResult 18
3060: oPushResult
3061: LAST_ID
3062: oPushResult
3063: oCall 9232
3065: oPop 2
3067: oAssign
3068: oInput 5
3070: oGetAddrLocal 2
3072: oPushResult
3073: oCall 3403
3075: oPop 1
3077: oGetLocal 1
3079: oPushResult
3080: oSetResult 21
3082: oPushResult
3083: oGetLocal 2
3085: oPushResult
3086: oNodeSet
3087: oPop 3
3089: oGetLocal 1
3091: oPushResult
3092: oScopeDeclare
3093: oPop 1
3095: oInput 4
3097: oJumpForward 3104
3099: Choice Lookup Table
           0   3055
3102: oJumpForward 3106
3104: oJumpBack 3053
3106: oReturn
3107: oLocalSpace 6
3109: oInputChoice 3330
3111: oGetAddrLocal 1
3113: oPushResult
3114: oNodeVecNew
3115: oAssign
3116: oGetAddrLocal 2
3118: oPushResult
3119: oGetParam 1
3121: oPushResult
3122: LAST_ID
3123: oPushResult
3124: oCall 9232
3126: oPop 2
3128: oAssign
3129: oGetLocal 1
3131: oPushResult
3132: oGetLocal 2
3134: oPushResult
3135: oNodeVecAppend
3136: oPop 2
3138: oInputChoice 3144
3140: oInput 0
3142: oJumpForward 3149
3144: Choice Lookup Table
          12   3140
3147: oJumpForward 3151
3149: oJumpBack 3116
3151: oInput 11
3153: oGetAddrLocal 3
3155: oPushResult
3156: oCall 3403
3158: oPop 1
3160: oGetAddrLocal 4
3162: oPushResult
3163: oSetResult 0
3165: oAssign
3166: oGetLocal 4
3168: oPushResult
3169: oGetLocal 1
3171: oPushResult
3172: oNodeVecSize
3173: oPop 1
3175: oPushResult
3176: equal
3177: oPop 2
3179: oChoice 3220
3181: oGetAddrLocal 2
3183: oPushResult
3184: oGetLocal 1
3186: oPushResult
3187: oGetLocal 4
3189: oPushResult
3190: oNodeVecElement
3191: oPop 2
3193: oAssign
3194: oGetLocal 2
3196: oPushResult
3197: oSetResult 21
3199: oPushResult
3200: oGetLocal 3
3202: oPushResult
3203: oNodeSet
3204: oPop 3
3206: oGetLocal 2
3208: oPushResult
3209: oScopeDeclareAlloc
3210: oPop 1
3212: oGetAddrLocal 4
3214: oPushResult
3215: inc
3216: oPop 1
3218: oJumpForward 3225
3220: Choice Lookup Table
           0   3181
3223: oJumpForward 3227
3225: oJumpBack 3166
3227: oInputChoice 3317
3229: oGetLocal 1
3231: oPushResult
3232: oNodeVecSize
3233: oPop 1
3235: oChoice 3239
3237: oJumpForward 3244
3239: Choice Lookup Table
           1   3237
3242: oError 22
3244: oGetAddrLocal 5
3246: oPushResult
3247: oScopeCurrent
3248: oPushResult
3249: oCall 1835
3251: oPop 1
3253: oAssign
3254: oGetLocal 5
3256: oPushResult
3257: oCodePush
3258: oPop 1
3260: oGetAddrLocal 6
3262: oPushResult
3263: oSetResult 0
3265: oAssign
3266: oCall 9002
3268: oPushResult
3269: equal_zero
3270: oPop 1
3272: oChoice 3288
3274: oGetGlobal 3
3276: oPushResult
3277: oScopeEnter
3278: oPop 1
3280: oGetAddrLocal 6
3282: oPushResult
3283: oSetResult 1
3285: oAssign
3286: oJumpForward 3291
3288: Choice Lookup Table
           1   3274
3291: oGetLocal 2
3293: oPushResult
3294: oCall 8237
3296: oPop 1
3298: oCall 4495
3300: oCall 9052
3302: oCall 8002
3304: oGetLocal 6
3306: oChoice 3311
3308: oScopeEnd
3309: oJumpForward 3314
3311: Choice Lookup Table
           1   3308
3314: oCodePop
3315: oJumpForward 3320
3317: Choice Lookup Table
           5   3229
3320: oGetLocal 1
3322: oPushResult
3323: oNodeVecDelete
3324: oPop 1
3326: oInput 4
3328: oJumpForward 3335
3330: Choice Lookup Table
           0   3111
3333: oJumpForward 3337
3335: oJumpBack 3109
3337: oReturn
3338: oLocalSpace 2
3340: oInputChoice 3347
3342: oJumpForward 3353
3344: oChangeIntLitToLabelIdent
3345: oJumpForward 3353
3347: Choice Lookup Table
           1   3344
           0   3342
3352: oEndChoice
3353: oGetAddrLocal 1
3355: oPushResult
3356: oSetResult 24
3358: oPushResult
3359: LAST_ID
3360: oPushResult
3361: oCall 9232
3363: oPop 2
3365: oAssign
3366: oGetAddrLocal 2
3368: oPushResult
3369: oLabelNew
3370: oAssign
3371: oGetLocal 1
3373: oPushResult
3374: oSetResult 22
3376: oPushResult
3377: oGetLocal 2
3379: oPushResult
3380: oNodeSetLabel
3381: oPop 3
3383: oGetLocal 1
3385: oPushResult
3386: oScopeDeclare
3387: oPop 1
3389: oInputChoice 3393
3391: oJumpForward 3398
3393: Choice Lookup Table
          12   3391
3396: oJumpForward 3400
3398: oJumpBack 3340
3400: oInput 4
3402: oReturn
3403: oLocalSpace 23
3405: oInputChoice 4402
3407: oGetAddrLocal 1
3409: oPushResult
3410: oScopeFindRequire
3411: oAssign
3412: oGetAddrLocal 1
3414: oPushResult
3415: oCall 409
3417: oPop 1
3419: oGetLocal 1
3421: oPushResult
3422: oNodeType
3423: oPop 1
3425: oChoice 3442
3427: oGetParam 1
3429: oPushResult
3430: oGetLocal 1
3432: oPushResult
3433: oSetResult 21
3435: oPushResult
3436: oNodeGet
3437: oPop 2
3439: oAssign
3440: oJumpForward 3453
3442: Choice Lookup Table
          18   3427
3445: oError 2
3447: oGetParam 1
3449: oPushResult
3450: oGetGlobal 5
3452: oAssign
3453: oJumpForward 4421
3455: oInput 15
3457: oGetAddrLocal 2
3459: oPushResult
3460: oNodeVecNew
3461: oAssign
3462: oGetAddrLocal 3
3464: oPushResult
3465: oSetResult 35
3467: oPushResult
3468: oNodeNew
3469: oPop 1
3471: oAssign
3472: oGetLocal 3
3474: oPushResult
3475: oSetResult 36
3477: oPushResult
3478: oGetGlobal 5
3480: oPushResult
3481: oNodeSet
3482: oPop 3
3484: oCall 4422
3486: oGetLocal 3
3488: oPushResult
3489: oSetResult 38
3491: oPushResult
3492: oValueTop
3493: oPushResult
3494: oNodeSetInt
3495: oPop 3
3497: oValuePop
3498: oInput 20
3500: oCall 4422
3502: oGetLocal 3
3504: oPushResult
3505: oSetResult 39
3507: oPushResult
3508: oValueTop
3509: oPushResult
3510: oNodeSetInt
3511: oPop 3
3513: oValuePop
3514: oGetLocal 3
3516: oPushResult
3517: oSetResult 17
3519: oPushResult
3520: oSetResult 4
3522: oPushResult
3523: oNodeSetInt
3524: oPop 3
3526: oGetLocal 3
3528: oPushResult
3529: oTypeAdd
3530: oPop 1
3532: oGetAddrLocal 4
3534: oPushResult
3535: oSetResult 34
3537: oPushResult
3538: oNodeNew
3539: oPop 1
3541: oAssign
3542: oGetLocal 4
3544: oPushResult
3545: oSetResult 37
3547: oPushResult
3548: oGetLocal 3
3550: oPushResult
3551: oNodeSet
3552: oPop 3
3554: oGetLocal 2
3556: oPushResult
3557: oGetLocal 4
3559: oPushResult
3560: oNodeVecAppend
3561: oPop 2
3563: oInputChoice 3571
3565: oJumpForward 3579
3567: oJumpForward 3577
3569: oJumpForward 3577
3571: Choice Lookup Table
          12   3569
          16   3565
3576: oEndChoice
3577: oJumpBack 3462
3579: oInput 39
3581: oGetAddrLocal 5
3583: oPushResult
3584: oCall 3403
3586: oPop 1
3588: oGetAddrLocal 6
3590: oPushResult
3591: oGetLocal 2
3593: oPushResult
3594: oNodeVecSize
3595: oPop 1
3597: oAssign
3598: oGetAddrLocal 6
3600: oPushResult
3601: dec
3602: oPop 1
3604: oGetAddrLocal 7
3606: oPushResult
3607: oGetLocal 2
3609: oPushResult
3610: oGetLocal 6
3612: oPushResult
3613: oNodeVecElement
3614: oPop 2
3616: oAssign
3617: oGetLocal 7
3619: oPushResult
3620: oSetResult 36
3622: oPushResult
3623: oGetLocal 5
3625: oPushResult
3626: oNodeSet
3627: oPop 3
3629: oGetAddrLocal 8
3631: oPushResult
3632: oGetLocal 7
3634: oPushResult
3635: oSetResult 37
3637: oPushResult
3638: oNodeGet
3639: oPop 2
3641: oAssign
3642: oGetAddrLocal 9
3644: oPushResult
3645: oGetLocal 8
3647: oPushResult
3648: oSetResult 39
3650: oPushResult
3651: oNodeGetInt
3652: oPop 2
3654: oPushResult
3655: oGetLocal 8
3657: oPushResult
3658: oSetResult 38
3660: oPushResult
3661: oNodeGetInt
3662: oPop 2
3664: oPushResult
3665: subtract
3666: oPop 2
3668: oAssign
3669: oGetAddrLocal 9
3671: oPushResult
3672: inc
3673: oPop 1
3675: oGetLocal 7
3677: oPushResult
3678: oSetResult 17
3680: oPushResult
3681: oGetLocal 9
3683: oPushResult
3684: oGetLocal 5
3686: oPushResult
3687: oSetResult 17
3689: oPushResult
3690: oNodeGetInt
3691: oPop 2
3693: oPushResult
3694: multiply
3695: oPop 2
3697: oPushResult
3698: oNodeSetInt
3699: oPop 3
3701: oGetLocal 7
3703: oPushResult
3704: oTypeAdd
3705: oPop 1
3707: oGetAddrLocal 5
3709: oPushResult
3710: oGetLocal 7
3712: oAssign
3713: oGetLocal 6
3715: oPushResult
3716: equal_zero
3717: oPop 1
3719: oChoice 3725
3721: oJumpForward 3730
3723: oJumpForward 3728
3725: Choice Lookup Table
           1   3721
3728: oJumpBack 3598
3730: oGetParam 1
3732: oPushResult
3733: oGetLocal 2
3735: oPushResult
3736: oSetResult 0
3738: oPushResult
3739: oNodeVecElement
3740: oPop 2
3742: oAssign
3743: oGetLocal 2
3745: oPushResult
3746: oNodeVecDelete
3747: oPop 1
3749: oJumpForward 4421
3751: oGetAddrLocal 10
3753: oPushResult
3754: oCall 3403
3756: oPop 1
3758: oGetParam 1
3760: oPushResult
3761: oGetLocal 10
3763: oPushResult
3764: oCall 9260
3766: oPop 1
3768: oAssign
3769: oJumpForward 4421
3771: oGetParam 1
3773: oPushResult
3774: oSetResult 36
3776: oPushResult
3777: oNodeNew
3778: oPop 1
3780: oAssign
3781: oSetResult -1
3783: oPushResult
3784: oSetResult 2
3786: oPushResult
3787: oScopeBegin
3788: oPop 2
3790: oSetResult 22
3792: oPushResult
3793: oCall 3107
3795: oPop 1
3797: oGetAddrLocal 11
3799: oPushResult
3800: oScopeCurrent
3801: oPushResult
3802: oSetResult 17
3804: oPushResult
3805: oNodeGetInt
3806: oPop 2
3808: oAssign
3809: oGetLocal 11
3811: oPushResult
3812: equal_zero
3813: oPop 1
3815: oChoice 3821
3817: oError 19
3819: oJumpForward 3824
3821: Choice Lookup Table
           1   3817
3824: oInput 35
3826: oGetFromParam 1
3828: oPushResult
3829: oSetResult 40
3831: oPushResult
3832: oScopeCurrent
3833: oPushResult
3834: oNodeSet
3835: oPop 3
3837: oGetFromParam 1
3839: oPushResult
3840: oSetResult 17
3842: oPushResult
3843: oGetLocal 11
3845: oPushResult
3846: oNodeSetInt
3847: oPop 3
3849: oScopeEnd
3850: oGetFromParam 1
3852: oPushResult
3853: oTypeAdd
3854: oPop 1
3856: oJumpForward 4421
3858: oGetParam 1
3860: oPushResult
3861: oSetResult 37
3863: oPushResult
3864: oNodeNew
3865: oPop 1
3867: oAssign
3868: oGetAddrLocal 12
3870: oPushResult
3871: oSetResult 0
3873: oAssign
3874: oGetAddrLocal 13
3876: oPushResult
3877: oSetResult 0
3879: oAssign
3880: oGetAddrLocal 14
3882: oPushResult
3883: oSetResult 1
3885: oAssign
3886: oGetAddrLocal 15
3888: oPushResult
3889: oScopeCurrent
3890: oAssign
3891: oSetResult -1
3893: oPushResult
3894: oSetResult 2
3896: oPushResult
3897: oScopeBegin
3898: oPop 2
3900: oInput 0
3902: oGetAddrLocal 16
3904: oPushResult
3905: oSetResult 17
3907: oPushResult
3908: LAST_ID
3909: oPushResult
3910: oCall 9232
3912: oPop 2
3914: oAssign
3915: oGetAddrLocal 17
3917: oPushResult
3918: oSetResult 17
3920: oPushResult
3921: LAST_ID
3922: oPushResult
3923: oCall 9232
3925: oPop 2
3927: oAssign
3928: oGetLocal 16
3930: oPushResult
3931: oSetResult 21
3933: oPushResult
3934: oGetFromParam 1
3936: oPushResult
3937: oNodeSet
3938: oPop 3
3940: oGetLocal 17
3942: oPushResult
3943: oSetResult 21
3945: oPushResult
3946: oGetFromParam 1
3948: oPushResult
3949: oNodeSet
3950: oPop 3
3952: oGetAddrLocal 18
3954: oPushResult
3955: LAST_ID
3956: oPushResult
3957: ID_STRING
3958: oPop 1
3960: oPushResult
3961: oStringAllocLit
3962: oPop 1
3964: oAssign
3965: oGetLocal 16
3967: oPushResult
3968: oSetResult 32
3970: oPushResult
3971: oGetLocal 18
3973: oPushResult
3974: oNodeSetInt
3975: oPop 3
3977: oGetLocal 17
3979: oPushResult
3980: oSetResult 32
3982: oPushResult
3983: oGetLocal 18
3985: oPushResult
3986: oNodeSetInt
3987: oPop 3
3989: oInputChoice 4031
3991: oCall 4422
3993: oGetLocal 13
3995: oPushResult
3996: equal_zero
3997: oPop 1
3999: oChoice 4020
4001: oValueTop
4002: oPushResult
4003: oGetLocal 12
4005: oPushResult
4006: greater
4007: oPop 2
4009: oChoice 4015
4011: oError 26
4013: oJumpForward 4018
4015: Choice Lookup Table
           0   4011
4018: oJumpForward 4023
4020: Choice Lookup Table
           0   4001
4023: oGetAddrLocal 12
4025: oPushResult
4026: oValueTop
4027: oAssign
4028: oValuePop
4029: oJumpForward 4036
4031: Choice Lookup Table
           3   3991
           5   3991
4036: oGetLocal 16
4038: oPushResult
4039: oSetResult 22
4041: oPushResult
4042: oGetLocal 12
4044: oPushResult
4045: oNodeSetInt
4046: oPop 3
4048: oGetLocal 17
4050: oPushResult
4051: oSetResult 22
4053: oPushResult
4054: oGetLocal 12
4056: oPushResult
4057: oNodeSetInt
4058: oPop 3
4060: oGetLocal 16
4062: oPushResult
4063: oScopeDeclare
4064: oPop 1
4066: oGetLocal 15
4068: oPushResult
4069: oScopeEnter
4070: oPop 1
4072: oGetLocal 17
4074: oPushResult
4075: oScopeDeclare
4076: oPop 1
4078: oScopeEnd
4079: oGetAddrLocal 12
4081: oPushResult
4082: inc
4083: oPop 1
4085: oGetAddrLocal 13
4087: oPushResult
4088: inc
4089: oPop 1
4091: oInputChoice 4095
4093: oJumpForward 4100
4095: Choice Lookup Table
          12   4093
4098: oJumpForward 4102
4100: oJumpBack 3900
4102: oInput 14
4104: oGetFromParam 1
4106: oPushResult
4107: oSetResult 40
4109: oPushResult
4110: oScopeCurrent
4111: oPushResult
4112: oNodeSet
4113: oPop 3
4115: oGetFromParam 1
4117: oPushResult
4118: oSetResult 17
4120: oPushResult
4121: oSetResult 4
4123: oPushResult
4124: oNodeSetInt
4125: oPop 3
4127: oScopeEnd
4128: oGetGlobal 2
4130: oPushResult
4131: oCall 1835
4133: oPop 1
4135: oPushResult
4136: oCodePush
4137: oPop 1
4139: oGetGlobal 2
4141: oPushResult
4142: oScopeEnter
4143: oPop 1
4145: oGetAddrLocal 19
4147: oPushResult
4148: oGetLocal 13
4150: oPushResult
4151: oSetResult 1
4153: oPushResult
4154: add
4155: oPop 2
4157: oPushResult
4158: oSetResult 16
4160: oPushResult
4161: multiply
4162: oPop 2
4164: oAssign
4165: oGetAddrLocal 20
4167: oPushResult
4168: oGetLocal 19
4170: oPushResult
4171: oSetResult 8
4173: oPushResult
4174: oScopeAlloc
4175: oPop 2
4177: oAssign
4178: oScopeEnd
4179: oGetFromParam 1
4181: oPushResult
4182: oSetResult 41
4184: oPushResult
4185: oGetLocal 20
4187: oPushResult
4188: oNodeSetInt
4189: oPop 3
4191: oGetAddrLocal 21
4193: oPushResult
4194: oGetFromParam 1
4196: oPushResult
4197: oSetResult 40
4199: oPushResult
4200: oNodeGet
4201: oPop 2
4203: oPushResult
4204: oSetResult 15
4206: oPushResult
4207: oNodeGetIter
4208: oPop 2
4210: oAssign
4211: oGetAddrLocal 22
4213: oPushResult
4214: oGetLocal 21
4216: oPushResult
4217: oNodeIterValue
4218: oPop 1
4220: oAssign
4221: oGetLocal 22
4223: oPushResult
4224: oNodeNull
4225: oPop 1
4227: oChoice 4233
4229: oJumpForward 4320
4231: oJumpForward 4236
4233: Choice Lookup Table
           1   4229
4236: oEmit 16
4238: oGetLocal 20
4240: oPushResult
4241: oEmitInt
4242: oPop 1
4244: oEmit 15
4246: oGetLocal 22
4248: oPushResult
4249: oSetResult 22
4251: oPushResult
4252: oNodeGetInt
4253: oPop 2
4255: oPushResult
4256: oEmitInt
4257: oPop 1
4259: oEmit 25
4261: oGetAddrLocal 20
4263: oPushResult
4264: oGetLocal 20
4266: oPushResult
4267: oSetResult 8
4269: oPushResult
4270: add
4271: oPop 2
4273: oAssign
4274: oEmit 16
4276: oGetLocal 20
4278: oPushResult
4279: oEmitInt
4280: oPop 1
4282: oEmit 16
4284: oGetLocal 22
4286: oPushResult
4287: oSetResult 32
4289: oPushResult
4290: oNodeGetInt
4291: oPop 2
4293: oPushResult
4294: oEmitInt
4295: oPop 1
4297: oEmit 27
4299: oGetAddrLocal 20
4301: oPushResult
4302: oGetLocal 20
4304: oPushResult
4305: oSetResult 8
4307: oPushResult
4308: add
4309: oPop 2
4311: oAssign
4312: oGetAddrLocal 21
4314: oPushResult
4315: oNodeIterNext
4316: oPop 1
4318: oJumpBack 4211
4320: oEmit 16
4322: oGetLocal 20
4324: oPushResult
4325: oEmitInt
4326: oPop 1
4328: oEmit 15
4330: oSetResult 0
4332: oPushResult
4333: oEmitInt
4334: oPop 1
4336: oEmit 25
4338: oGetAddrLocal 20
4340: oPushResult
4341: oGetLocal 20
4343: oPushResult
4344: oSetResult 8
4346: oPushResult
4347: add
4348: oPop 2
4350: oAssign
4351: oEmit 16
4353: oGetLocal 20
4355: oPushResult
4356: oEmitInt
4357: oPop 1
4359: oEmit 15
4361: oSetResult 0
4363: oPushResult
4364: oEmitInt
4365: oPop 1
4367: oEmit 27
4369: oGetAddrLocal 20
4371: oPushResult
4372: oGetLocal 20
4374: oPushResult
4375: oSetResult 8
4377: oPushResult
4378: add
4379: oPop 2
4381: oAssign
4382: oCodePop
4383: oGetFromParam 1
4385: oPushResult
4386: oTypeAdd
4387: oPop 1
4389: oJumpForward 4421
4391: oInput 39
4393: oGetAddrLocal 23
4395: oPushResult
4396: oCall 3403
4398: oPop 1
4400: oJumpForward 4421
4402: Choice Lookup Table
          38   4391
          13   3858
          37   3771
          17   3751
          36   3455
           0   3407
4415: oCall 4422
4417: oInput 20
4419: oCall 4422
4421: oReturn
4422: oLocalSpace 1
4424: oInputChoice 4486
4426: TOKEN_VALUE
4427: oPushResult
4428: oValuePush
4429: oPop 1
4431: oJumpForward 4494
4433: oGetAddrLocal 1
4435: oPushResult
4436: oScopeFindRequire
4437: oAssign
4438: oGetAddrLocal 1
4440: oPushResult
4441: oCall 409
4443: oPop 1
4445: oGetLocal 1
4447: oPushResult
4448: oNodeType
4449: oPop 1
4451: oChoice 4468
4453: oGetLocal 1
4455: oPushResult
4456: oSetResult 22
4458: oPushResult
4459: oNodeGetInt
4460: oPop 2
4462: oPushResult
4463: oValuePush
4464: oPop 1
4466: oJumpForward 4479
4468: Choice Lookup Table
          16   4453
4471: oError 1
4473: oSetResult 0
4475: oPushResult
4476: oValuePush
4477: oPop 1
4479: oJumpForward 4494
4481: oCall 4422
4483: oValueNegate
4484: oJumpForward 4494
4486: Choice Lookup Table
          24   4481
           0   4433
           1   4426
4493: oEndChoice
4494: oReturn
4495: oLocalSpace 1
4497: oGetAddrLocal 1
4499: oPushResult
4500: oSetResult 0
4502: oAssign
4503: oGetAddrLocal 1
4505: oPushResult
4506: oCall 4656
4508: oPop 1
4510: oGetAddrLocal 1
4512: oPushResult
4513: oCall 4556
4515: oPop 1
4517: oReturn
4518: oLocalSpace 0
4520: oGetParam 1
4522: oPushResult
4523: oCall 4656
4525: oPop 1
4527: oTypeSNodeType
4528: oChoice 4547
4530: oJumpForward 4554
4532: oGetParam 1
4534: oPushResult
4535: oLabelNew
4536: oAssign
4537: oEmit 57
4539: oGetFromParam 1
4541: oPushResult
4542: oEmitLabel
4543: oPop 1
4545: oJumpForward 4554
4547: Choice Lookup Table
          29   4532
          30   4530
4552: oError 8
4554: oTypeSPop
4555: oReturn
4556: oLocalSpace 1
4558: oTypeSNodeType
4559: oChoice 4621
4561: oGetAddrLocal 1
4563: oPushResult
4564: oLabelNew
4565: oAssign
4566: oEmit 15
4568: oSetResult 1
4570: oPushResult
4571: oEmitInt
4572: oPop 1
4574: oEmit 55
4576: oGetLocal 1
4578: oPushResult
4579: oEmitLabel
4580: oPop 1
4582: oEmit 58
4584: oGetFromParam 1
4586: oPushResult
4587: oEmitLabel
4588: oPop 1
4590: oEmit 15
4592: oSetResult 0
4594: oPushResult
4595: oEmitInt
4596: oPop 1
4598: oEmit 58
4600: oGetLocal 1
4602: oPushResult
4603: oEmitLabel
4604: oPop 1
4606: oTypeSPop
4607: oGetGlobal 6
4609: oPushResult
4610: oTypeSPush
4611: oPop 1
4613: oGetParam 1
4615: oPushResult
4616: oSetResult 0
4618: oAssign
4619: oJumpForward 4624
4621: Choice Lookup Table
          30   4561
4624: oReturn
4625: oLocalSpace 0
4627: oTypeSNodeType
4628: oChoice 4652
4630: oGetParam 1
4632: oPushResult
4633: oLabelNew
4634: oAssign
4635: oEmit 57
4637: oGetFromParam 1
4639: oPushResult
4640: oEmitLabel
4641: oPop 1
4643: oTypeSPop
4644: oGetGlobal 7
4646: oPushResult
4647: oTypeSPush
4648: oPop 1
4650: oJumpForward 4655
4652: Choice Lookup Table
          29   4630
4655: oReturn
4656: oLocalSpace 0
4658: oGetParam 1
4660: oPushResult
4661: oCall 5057
4663: oPop 1
4665: oInputChoice 5039
4667: oGetParam 1
4669: oPushResult
4670: oCall 4556
4672: oPop 1
4674: oCall 9151
4676: oGetParam 1
4678: oPushResult
4679: oCall 5057
4681: oPop 1
4683: oGetParam 1
4685: oPushResult
4686: oCall 4556
4688: oPop 1
4690: oCall 9151
4692: oCall 9052
4694: oTypeSNodeType
4695: oChoice 4709
4697: oEmit 40
4699: oJumpForward 4724
4701: oEmit 46
4703: oJumpForward 4724
4705: oError 16
4707: oJumpForward 4724
4709: Choice Lookup Table
          32   4705
          31   4705
          33   4701
          29   4697
          37   4697
          27   4697
4722: oError 17
4724: oTypeSPop
4725: oGetGlobal 6
4727: oPushResult
4728: oTypeSPush
4729: oPop 1
4731: oJumpForward 5054
4733: oGetParam 1
4735: oPushResult
4736: oCall 4556
4738: oPop 1
4740: oCall 9151
4742: oGetParam 1
4744: oPushResult
4745: oCall 5057
4747: oPop 1
4749: oGetParam 1
4751: oPushResult
4752: oCall 4556
4754: oPop 1
4756: oCall 9151
4758: oCall 9052
4760: oTypeSNodeType
4761: oChoice 4775
4763: oEmit 41
4765: oJumpForward 4790
4767: oEmit 47
4769: oJumpForward 4790
4771: oError 16
4773: oJumpForward 4790
4775: Choice Lookup Table
          32   4771
          31   4771
          33   4767
          29   4763
          37   4763
          27   4763
4788: oError 17
4790: oTypeSPop
4791: oGetGlobal 6
4793: oPushResult
4794: oTypeSPush
4795: oPop 1
4797: oJumpForward 5054
4799: oGetParam 1
4801: oPushResult
4802: oCall 4556
4804: oPop 1
4806: oCall 9151
4808: oGetParam 1
4810: oPushResult
4811: oCall 5057
4813: oPop 1
4815: oGetParam 1
4817: oPushResult
4818: oCall 4556
4820: oPop 1
4822: oCall 9151
4824: oCall 9052
4826: oTypeSNodeType
4827: oChoice 4837
4829: oEmit 43
4831: oJumpForward 4850
4833: oError 16
4835: oJumpForward 4850
4837: Choice Lookup Table
          32   4833
          31   4833
          29   4829
          37   4829
          27   4829
4848: oError 17
4850: oTypeSPop
4851: oGetGlobal 6
4853: oPushResult
4854: oTypeSPush
4855: oPop 1
4857: oJumpForward 5054
4859: oGetParam 1
4861: oPushResult
4862: oCall 4556
4864: oPop 1
4866: oCall 9151
4868: oGetParam 1
4870: oPushResult
4871: oCall 5057
4873: oPop 1
4875: oGetParam 1
4877: oPushResult
4878: oCall 4556
4880: oPop 1
4882: oCall 9151
4884: oCall 9052
4886: oTypeSNodeType
4887: oChoice 4897
4889: oEmit 42
4891: oJumpForward 4910
4893: oError 16
4895: oJumpForward 4910
4897: Choice Lookup Table
          32   4893
          31   4893
          29   4889
          37   4889
          27   4889
4908: oError 17
4910: oTypeSPop
4911: oGetGlobal 6
4913: oPushResult
4914: oTypeSPush
4915: oPop 1
4917: oJumpForward 5054
4919: oGetParam 1
4921: oPushResult
4922: oCall 4556
4924: oPop 1
4926: oCall 9151
4928: oGetParam 1
4930: oPushResult
4931: oCall 5057
4933: oPop 1
4935: oGetParam 1
4937: oPushResult
4938: oCall 4556
4940: oPop 1
4942: oCall 9151
4944: oCall 9052
4946: oTypeSNodeType
4947: oChoice 4957
4949: oEmit 45
4951: oJumpForward 4970
4953: oError 16
4955: oJumpForward 4970
4957: Choice Lookup Table
          32   4953
          31   4953
          29   4949
          37   4949
          27   4949
4968: oError 17
4970: oTypeSPop
4971: oGetGlobal 6
4973: oPushResult
4974: oTypeSPush
4975: oPop 1
4977: oJumpForward 5054
4979: oGetParam 1
4981: oPushResult
4982: oCall 4556
4984: oPop 1
4986: oCall 9151
4988: oGetParam 1
4990: oPushResult
4991: oCall 5057
4993: oPop 1
4995: oGetParam 1
4997: oPushResult
4998: oCall 4556
5000: oPop 1
5002: oCall 9151
5004: oCall 9052
5006: oTypeSNodeType
5007: oChoice 5017
5009: oEmit 44
5011: oJumpForward 5030
5013: oError 16
5015: oJumpForward 5030
5017: Choice Lookup Table
          32   5013
          31   5013
          29   5009
          37   5009
          27   5009
5028: oError 17
5030: oTypeSPop
5031: oGetGlobal 6
5033: oPushResult
5034: oTypeSPush
5035: oPop 1
5037: oJumpForward 5054
5039: Choice Lookup Table
          10   4979
           9   4919
           8   4859
           7   4799
           6   4733
           5   4667
5052: oJumpForward 5056
5054: oJumpBack 4665
5056: oReturn
5057: oLocalSpace 1
5059: oGetAddrLocal 1
5061: oPushResult
5062: oSetResult 0
5064: oAssign
5065: oGetParam 1
5067: oPushResult
5068: oCall 5237
5070: oPop 1
5072: oInputChoice 5205
5074: oTypeSNodeType
5075: oChoice 5146
5077: oGetLocal 1
5079: oPushResult
5080: oSetResult 0
5082: oPushResult
5083: equal_label
5084: oPop 2
5086: oChoice 5095
5088: oGetAddrLocal 1
5090: oPushResult
5091: oLabelNew
5092: oAssign
5093: oJumpForward 5098
5095: Choice Lookup Table
           1   5088
5098: oEmit 55
5100: oGetLocal 1
5102: oPushResult
5103: oEmitLabel
5104: oPop 1
5106: oJumpForward 5153
5108: oGetParam 1
5110: oPushResult
5111: oCall 4625
5113: oPop 1
5115: oGetLocal 1
5117: oPushResult
5118: oSetResult 0
5120: oPushResult
5121: equal_label
5122: oPop 2
5124: oChoice 5133
5126: oGetAddrLocal 1
5128: oPushResult
5129: oLabelNew
5130: oAssign
5131: oJumpForward 5136
5133: Choice Lookup Table
           1   5126
5136: oEmit 55
5138: oGetLocal 1
5140: oPushResult
5141: oEmitLabel
5142: oPop 1
5144: oJumpForward 5153
5146: Choice Lookup Table
          29   5108
          30   5077
5151: oError 8
5153: oTypeSPop
5154: oEmit 58
5156: oGetFromParam 1
5158: oPushResult
5159: oEmitLabel
5160: oPop 1
5162: oGetParam 1
5164: oPushResult
5165: oSetResult 0
5167: oAssign
5168: oGetParam 1
5170: oPushResult
5171: oCall 5237
5173: oPop 1
5175: oTypeSNodeType
5176: oChoice 5189
5178: oJumpForward 5196
5180: oGetParam 1
5182: oPushResult
5183: oCall 4625
5185: oPop 1
5187: oJumpForward 5196
5189: Choice Lookup Table
          29   5180
          30   5178
5194: oError 8
5196: oTypeSPop
5197: oGetGlobal 7
5199: oPushResult
5200: oTypeSPush
5201: oPop 1
5203: oJumpForward 5210
5205: Choice Lookup Table
          54   5074
5208: oJumpForward 5212
5210: oJumpBack 5072
5212: oGetLocal 1
5214: oPushResult
5215: oSetResult 0
5217: oPushResult
5218: equal_label
5219: oPop 2
5221: oChoice 5233
5223: oEmit 58
5225: oGetLocal 1
5227: oPushResult
5228: oEmitLabel
5229: oPop 1
5231: oJumpForward 5236
5233: Choice Lookup Table
           0   5223
5236: oReturn
5237: oLocalSpace 2
5239: oGetAddrLocal 1
5241: oPushResult
5242: oSetResult 0
5244: oAssign
5245: oGetParam 1
5247: oPushResult
5248: oCall 5375
5250: oPop 1
5252: oInputChoice 5367
5254: oTypeSNodeType
5255: oChoice 5268
5257: oJumpForward 5275
5259: oGetParam 1
5261: oPushResult
5262: oCall 4625
5264: oPop 1
5266: oJumpForward 5275
5268: Choice Lookup Table
          29   5259
          30   5257
5273: oError 8
5275: oTypeSPop
5276: oGetLocal 1
5278: oPushResult
5279: oSetResult 0
5281: oPushResult
5282: equal_label
5283: oPop 2
5285: oChoice 5314
5287: oGetAddrLocal 1
5289: oPushResult
5290: oLabelNew
5291: oAssign
5292: oEmit 59
5294: oGetFromParam 1
5296: oPushResult
5297: oEmitLabel
5298: oPop 1
5300: oGetLocal 1
5302: oPushResult
5303: oEmitLabel
5304: oPop 1
5306: oGetParam 1
5308: oPushResult
5309: oGetLocal 1
5311: oAssign
5312: oJumpForward 5317
5314: Choice Lookup Table
           1   5287
5317: oGetAddrLocal 2
5319: oPushResult
5320: oSetResult 0
5322: oAssign
5323: oGetAddrLocal 2
5325: oPushResult
5326: oCall 5375
5328: oPop 1
5330: oTypeSNodeType
5331: oChoice 5344
5333: oJumpForward 5351
5335: oGetAddrLocal 2
5337: oPushResult
5338: oCall 4625
5340: oPop 1
5342: oJumpForward 5351
5344: Choice Lookup Table
          29   5335
          30   5333
5349: oError 8
5351: oEmit 59
5353: oGetLocal 2
5355: oPushResult
5356: oEmitLabel
5357: oPop 1
5359: oGetLocal 1
5361: oPushResult
5362: oEmitLabel
5363: oPop 1
5365: oJumpForward 5372
5367: Choice Lookup Table
          53   5254
5370: oJumpForward 5374
5372: oJumpBack 5252
5374: oReturn
5375: oLocalSpace 1
5377: oInputChoice 5431
5379: oGetAddrLocal 1
5381: oPushResult
5382: oSetResult 0
5384: oAssign
5385: oGetAddrLocal 1
5387: oPushResult
5388: oCall 5375
5390: oPop 1
5392: oTypeSNodeType
5393: oChoice 5422
5395: oGetParam 1
5397: oPushResult
5398: oLabelNew
5399: oAssign
5400: oEmit 55
5402: oGetFromParam 1
5404: oPushResult
5405: oEmitLabel
5406: oPop 1
5408: oEmit 58
5410: oGetLocal 1
5412: oPushResult
5413: oEmitLabel
5414: oPop 1
5416: oJumpForward 5429
5418: oEmit 39
5420: oJumpForward 5429
5422: Choice Lookup Table
          29   5418
          30   5395
5427: oError 8
5429: oJumpForward 5441
5431: Choice Lookup Table
          55   5379
5434: oGetParam 1
5436: oPushResult
5437: oCall 5442
5439: oPop 1
5441: oReturn
5442: oLocalSpace 0
5444: oGetParam 1
5446: oPushResult
5447: oCall 5493
5449: oPop 1
5451: oInputChoice 5483
5453: oCall 9105
5455: oGetParam 1
5457: oPushResult
5458: oCall 5493
5460: oPop 1
5462: oCall 9125
5464: oEmit 36
5466: oJumpForward 5490
5468: oCall 9105
5470: oGetParam 1
5472: oPushResult
5473: oCall 5493
5475: oPop 1
5477: oCall 9125
5479: oEmit 37
5481: oJumpForward 5490
5483: Choice Lookup Table
          24   5468
          23   5453
5488: oJumpForward 5492
5490: oJumpBack 5451
5492: oReturn
5493: oLocalSpace 0
5495: oGetParam 1
5497: oPushResult
5498: oCall 5544
5500: oPop 1
5502: oInputChoice 5534
5504: oCall 9105
5506: oGetParam 1
5508: oPushResult
5509: oCall 5544
5511: oPop 1
5513: oCall 9125
5515: oEmit 33
5517: oJumpForward 5541
5519: oCall 9105
5521: oGetParam 1
5523: oPushResult
5524: oCall 5544
5526: oPop 1
5528: oCall 9125
5530: oEmit 34
5532: oJumpForward 5541
5534: Choice Lookup Table
          22   5519
          21   5504
5539: oJumpForward 5543
5541: oJumpBack 5502
5543: oReturn
5544: oLocalSpace 0
5546: oInputChoice 5572
5548: oGetParam 1
5550: oPushResult
5551: oCall 5585
5553: oPop 1
5555: oCall 9125
5557: oJumpForward 5584
5559: oGetParam 1
5561: oPushResult
5562: oCall 5585
5564: oPop 1
5566: oCall 9125
5568: oEmit 38
5570: oJumpForward 5584
5572: Choice Lookup Table
          24   5559
          23   5548
5577: oGetParam 1
5579: oPushResult
5580: oCall 5585
5582: oPop 1
5584: oReturn
5585: oLocalSpace 6
5587: oInputChoice 5802
5589: oEmit 15
5591: TOKEN_VALUE
5592: oPushResult
5593: oEmitInt
5594: oPop 1
5596: oGetGlobal 5
5598: oPushResult
5599: oTypeSPush
5600: oPop 1
5602: oJumpForward 5821
5604: oGetParam 1
5606: oPushResult
5607: oCall 4656
5609: oPop 1
5611: oInput 14
5613: oJumpForward 5821
5615: oGetAddrLocal 1
5617: oPushResult
5618: CURRENT_STRLIT
5619: oPushResult
5620: oStringAllocLit
5621: oPop 1
5623: oAssign
5624: oEmit 16
5626: oGetLocal 1
5628: oPushResult
5629: oEmitInt
5630: oPop 1
5632: oGetGlobal 10
5634: oPushResult
5635: oTypeSPush
5636: oPop 1
5638: oJumpForward 5821
5640: oGetAddrLocal 2
5642: oPushResult
5643: oScopeFindRequire
5644: oAssign
5645: oGetAddrLocal 2
5647: oPushResult
5648: oCall 409
5650: oPop 1
5652: oGetLocal 2
5654: oPushResult
5655: oNodeType
5656: oPop 1
5658: oChoice 5731
5660: oGetLocal 2
5662: oPushResult
5663: oCall 7053
5665: oPop 1
5667: oJumpForward 5754
5669: oGetLocal 2
5671: oPushResult
5672: oCall 7664
5674: oPop 1
5676: oJumpForward 5754
5678: oGetAddrLocal 3
5680: oPushResult
5681: oGetLocal 2
5683: oPushResult
5684: oSetResult 21
5686: oPushResult
5687: oNodeGet
5688: oPop 2
5690: oAssign
5691: oGetLocal 3
5693: oPushResult
5694: oTypeSPush
5695: oPop 1
5697: oTypeSNodeType
5698: oChoice 5711
5700: oEmit 15
5702: oGetLocal 2
5704: oPushResult
5705: oCall 9439
5707: oPop 1
5709: oJumpForward 5720
5711: Choice Lookup Table
          29   5700
          37   5700
          27   5700
5718: oError 16
5720: oJumpForward 5754
5722: oGetLocal 2
5724: oPushResult
5725: oCall 5822
5727: oPop 1
5729: oJumpForward 5754
5731: Choice Lookup Table
          23   5722
          21   5722
          20   5722
          17   5678
          16   5678
          14   5669
          13   5660
5746: oError 6
5748: oGetGlobal 5
5750: oPushResult
5751: oTypeSPush
5752: oPop 1
5754: oJumpForward 5821
5756: oInput 0
5758: oGetAddrLocal 4
5760: oPushResult
5761: oScopeFindRequire
5762: oAssign
5763: oGetAddrLocal 4
5765: oPushResult
5766: oCall 409
5768: oPop 1
5770: oGetLocal 4
5772: oPushResult
5773: oCall 8237
5775: oPop 1
5777: oGetAddrLocal 5
5779: oPushResult
5780: oTypeSTop
5781: oAssign
5782: oTypeSPop
5783: oGetAddrLocal 6
5785: oPushResult
5786: oGetLocal 5
5788: oPushResult
5789: oCall 9260
5791: oPop 1
5793: oAssign
5794: oGetLocal 6
5796: oPushResult
5797: oTypeSPush
5798: oPop 1
5800: oJumpForward 5821
5802: Choice Lookup Table
          18   5756
           0   5640
           2   5615
          13   5604
           1   5589
5813: oError 6
5815: oGetGlobal 5
5817: oPushResult
5818: oTypeSPush
5819: oPop 1
5821: oReturn
5822: oLocalSpace 2
5824: oGetAddrLocal 1
5826: oPushResult
5827: oGetParam 1
5829: oPushResult
5830: oSetResult 21
5832: oPushResult
5833: oNodeGet
5834: oPop 2
5836: oAssign
5837: oGetAddrLocal 2
5839: oPushResult
5840: oGetParam 1
5842: oPushResult
5843: oCall 9034
5845: oPop 1
5847: oAssign
5848: oGetLocal 1
5850: oPushResult
5851: oTypeSPush
5852: oPop 1
5854: oTypeSNodeType
5855: oChoice 6536
5857: oGetParam 1
5859: oPushResult
5860: oNodeType
5861: oPop 1
5863: oChoice 6009
5865: oEmit 0
5867: oGetParam 1
5869: oPushResult
5870: oCall 9439
5872: oPop 1
5874: oJumpForward 6017
5876: oGetLocal 2
5878: oPushResult
5879: equal_zero
5880: oPop 1
5882: oChoice 5895
5884: oEmit 3
5886: oGetParam 1
5888: oPushResult
5889: oCall 9439
5891: oPop 1
5893: oJumpForward 5913
5895: Choice Lookup Table
           1   5884
5898: oEmit 9
5900: oGetLocal 2
5902: oPushResult
5903: oEmitInt
5904: oPop 1
5906: oGetParam 1
5908: oPushResult
5909: oCall 9439
5911: oPop 1
5913: oJumpForward 6017
5915: oGetParam 1
5917: oPushResult
5918: oSetResult 33
5920: oPushResult
5921: oNodeGetBoolean
5922: oPop 2
5924: oChoice 5967
5926: oGetLocal 2
5928: oPushResult
5929: equal_zero
5930: oPop 1
5932: oChoice 5945
5934: oEmit 8
5936: oGetParam 1
5938: oPushResult
5939: oCall 9439
5941: oPop 1
5943: oJumpForward 5963
5945: Choice Lookup Table
           1   5934
5948: oEmit 14
5950: oGetLocal 2
5952: oPushResult
5953: oEmitInt
5954: oPop 1
5956: oGetParam 1
5958: oPushResult
5959: oCall 9439
5961: oPop 1
5963: oEmit 22
5965: oJumpForward 6007
5967: Choice Lookup Table
           1   5926
5970: oGetLocal 2
5972: oPushResult
5973: equal_zero
5974: oPop 1
5976: oChoice 5989
5978: oEmit 6
5980: oGetParam 1
5982: oPushResult
5983: oCall 9439
5985: oPop 1
5987: oJumpForward 6007
5989: Choice Lookup Table
           1   5978
5992: oEmit 12
5994: oGetLocal 2
5996: oPushResult
5997: oEmitInt
5998: oPop 1
6000: oGetParam 1
6002: oPushResult
6003: oCall 9439
6005: oPop 1
6007: oJumpForward 6017
6009: Choice Lookup Table
          23   5915
          21   5876
          20   5865
6016: oEndChoice
6017: oJumpForward 6558
6019: oGetParam 1
6021: oPushResult
6022: oNodeType
6023: oPop 1
6025: oChoice 6171
6027: oEmit 1
6029: oGetParam 1
6031: oPushResult
6032: oCall 9439
6034: oPop 1
6036: oJumpForward 6179
6038: oGetLocal 2
6040: oPushResult
6041: equal_zero
6042: oPop 1
6044: oChoice 6057
6046: oEmit 4
6048: oGetParam 1
6050: oPushResult
6051: oCall 9439
6053: oPop 1
6055: oJumpForward 6075
6057: Choice Lookup Table
           1   6046
6060: oEmit 10
6062: oGetLocal 2
6064: oPushResult
6065: oEmitInt
6066: oPop 1
6068: oGetParam 1
6070: oPushResult
6071: oCall 9439
6073: oPop 1
6075: oJumpForward 6179
6077: oGetParam 1
6079: oPushResult
6080: oSetResult 33
6082: oPushResult
6083: oNodeGetBoolean
6084: oPop 2
6086: oChoice 6129
6088: oGetLocal 2
6090: oPushResult
6091: equal_zero
6092: oPop 1
6094: oChoice 6107
6096: oEmit 8
6098: oGetParam 1
6100: oPushResult
6101: oCall 9439
6103: oPop 1
6105: oJumpForward 6125
6107: Choice Lookup Table
           1   6096
6110: oEmit 14
6112: oGetLocal 2
6114: oPushResult
6115: oEmitInt
6116: oPop 1
6118: oGetParam 1
6120: oPushResult
6121: oCall 9439
6123: oPop 1
6125: oEmit 23
6127: oJumpForward 6169
6129: Choice Lookup Table
           1   6088
6132: oGetLocal 2
6134: oPushResult
6135: equal_zero
6136: oPop 1
6138: oChoice 6151
6140: oEmit 7
6142: oGetParam 1
6144: oPushResult
6145: oCall 9439
6147: oPop 1
6149: oJumpForward 6169
6151: Choice Lookup Table
           1   6140
6154: oEmit 13
6156: oGetLocal 2
6158: oPushResult
6159: oEmitInt
6160: oPop 1
6162: oGetParam 1
6164: oPushResult
6165: oCall 9439
6167: oPop 1
6169: oJumpForward 6179
6171: Choice Lookup Table
          23   6077
          21   6038
          20   6027
6178: oEndChoice
6179: oJumpForward 6558
6181: oError 16
6183: oJumpForward 6558
6185: oGetParam 1
6187: oPushResult
6188: oNodeType
6189: oPop 1
6191: oChoice 6337
6193: oEmit 2
6195: oGetParam 1
6197: oPushResult
6198: oCall 9439
6200: oPop 1
6202: oJumpForward 6345
6204: oGetLocal 2
6206: oPushResult
6207: equal_zero
6208: oPop 1
6210: oChoice 6223
6212: oEmit 5
6214: oGetParam 1
6216: oPushResult
6217: oCall 9439
6219: oPop 1
6221: oJumpForward 6241
6223: Choice Lookup Table
           1   6212
6226: oEmit 11
6228: oGetLocal 2
6230: oPushResult
6231: oEmitInt
6232: oPop 1
6234: oGetParam 1
6236: oPushResult
6237: oCall 9439
6239: oPop 1
6241: oJumpForward 6345
6243: oGetParam 1
6245: oPushResult
6246: oSetResult 33
6248: oPushResult
6249: oNodeGetBoolean
6250: oPop 2
6252: oChoice 6295
6254: oGetLocal 2
6256: oPushResult
6257: equal_zero
6258: oPop 1
6260: oChoice 6273
6262: oEmit 8
6264: oGetParam 1
6266: oPushResult
6267: oCall 9439
6269: oPop 1
6271: oJumpForward 6291
6273: Choice Lookup Table
           1   6262
6276: oEmit 14
6278: oGetLocal 2
6280: oPushResult
6281: oEmitInt
6282: oPop 1
6284: oGetParam 1
6286: oPushResult
6287: oCall 9439
6289: oPop 1
6291: oEmit 24
6293: oJumpForward 6335
6295: Choice Lookup Table
           1   6254
6298: oGetLocal 2
6300: oPushResult
6301: equal_zero
6302: oPop 1
6304: oChoice 6317
6306: oEmit 8
6308: oGetParam 1
6310: oPushResult
6311: oCall 9439
6313: oPop 1
6315: oJumpForward 6335
6317: Choice Lookup Table
           1   6306
6320: oEmit 14
6322: oGetLocal 2
6324: oPushResult
6325: oEmitInt
6326: oPop 1
6328: oGetParam 1
6330: oPushResult
6331: oCall 9439
6333: oPop 1
6335: oJumpForward 6345
6337: Choice Lookup Table
          23   6243
          21   6204
          20   6193
6344: oEndChoice
6345: oInputChoice 6367
6347: oTypeSPop
6348: oGetLocal 1
6350: oPushResult
6351: oSetResult 36
6353: oPushResult
6354: oNodeGet
6355: oPop 2
6357: oPushResult
6358: oTypeSPush
6359: oPop 1
6361: oCall 6605
6363: oCall 6559
6365: oJumpForward 6370
6367: Choice Lookup Table
          17   6347
6370: oJumpForward 6558
6372: oGetParam 1
6374: oPushResult
6375: oNodeType
6376: oPop 1
6378: oChoice 6522
6380: oEmit 16
6382: oGetParam 1
6384: oPushResult
6385: oCall 9439
6387: oPop 1
6389: oJumpForward 6530
6391: oGetLocal 2
6393: oPushResult
6394: equal_zero
6395: oPop 1
6397: oChoice 6410
6399: oEmit 17
6401: oGetParam 1
6403: oPushResult
6404: oCall 9439
6406: oPop 1
6408: oJumpForward 6428
6410: Choice Lookup Table
           1   6399
6413: oEmit 20
6415: oGetLocal 2
6417: oPushResult
6418: oEmitInt
6419: oPop 1
6421: oGetParam 1
6423: oPushResult
6424: oCall 9439
6426: oPop 1
6428: oJumpForward 6530
6430: oGetParam 1
6432: oPushResult
6433: oSetResult 33
6435: oPushResult
6436: oNodeGetBoolean
6437: oPop 2
6439: oChoice 6480
6441: oGetLocal 2
6443: oPushResult
6444: equal_zero
6445: oPop 1
6447: oChoice 6460
6449: oEmit 8
6451: oGetParam 1
6453: oPushResult
6454: oCall 9439
6456: oPop 1
6458: oJumpForward 6478
6460: Choice Lookup Table
           1   6449
6463: oEmit 14
6465: oGetLocal 2
6467: oPushResult
6468: oEmitInt
6469: oPop 1
6471: oGetParam 1
6473: oPushResult
6474: oCall 9439
6476: oPop 1
6478: oJumpForward 6520
6480: Choice Lookup Table
           1   6441
6483: oGetLocal 2
6485: oPushResult
6486: equal_zero
6487: oPop 1
6489: oChoice 6502
6491: oEmit 18
6493: oGetParam 1
6495: oPushResult
6496: oCall 9439
6498: oPop 1
6500: oJumpForward 6520
6502: Choice Lookup Table
           1   6491
6505: oEmit 21
6507: oGetLocal 2
6509: oPushResult
6510: oEmitInt
6511: oPop 1
6513: oGetParam 1
6515: oPushResult
6516: oCall 9439
6518: oPop 1
6520: oJumpForward 6530
6522: Choice Lookup Table
          23   6430
          21   6391
          20   6380
6529: oEndChoice
6530: oCall 6605
6532: oCall 6559
6534: oJumpForward 6558
6536: Choice Lookup Table
          36   6372
          34   6372
          33   6185
          26   6181
          32   6181
          31   6019
          28   6019
          29   6019
          37   5857
          27   5857
6557: oEndChoice
6558: oReturn
6559: oLocalSpace 0
6561: oTypeSNodeType
6562: oChoice 6582
6564: oEmit 22
6566: oJumpForward 6604
6568: oEmit 23
6570: oJumpForward 6604
6572: oError 16
6574: oJumpForward 6604
6576: oEmit 24
6578: oJumpForward 6604
6580: oJumpForward 6604
6582: Choice Lookup Table
          36   6580
          34   6580
          33   6576
          26   6572
          32   6572
          31   6568
          28   6568
          29   6568
          37   6564
          27   6564
6603: oEndChoice
6604: oReturn
6605: oLocalSpace 0
6607: oInputChoice 6621
6609: oCall 6633
6611: oJumpForward 6630
6613: oCall 6776
6615: oJumpForward 6630
6617: oCall 6874
6619: oJumpForward 6630
6621: Choice Lookup Table
          17   6617
          19   6613
          15   6609
6628: oJumpForward 6632
6630: oJumpBack 6607
6632: oReturn
6633: oLocalSpace 3
6635: oTypeSNodeType
6636: oChoice 6640
6638: oJumpForward 6645
6640: Choice Lookup Table
          34   6638
6643: oError 10
6645: oTypeSNodeType
6646: oChoice 6650
6648: oJumpForward 6655
6650: Choice Lookup Table
          34   6648
6653: oError 13
6655: oGetAddrLocal 1
6657: oPushResult
6658: oTypeSTop
6659: oPushResult
6660: oSetResult 37
6662: oPushResult
6663: oNodeGet
6664: oPop 2
6666: oPushResult
6667: oCall 9344
6669: oPop 1
6671: oAssign
6672: oGetAddrLocal 2
6674: oPushResult
6675: oTypeSTop
6676: oPushResult
6677: oSetResult 36
6679: oPushResult
6680: oNodeGet
6681: oPop 2
6683: oAssign
6684: oTypeSPop
6685: oGetLocal 2
6687: oPushResult
6688: oTypeSPush
6689: oPop 1
6691: oCall 4495
6693: oCall 9078
6695: oGetLocal 1
6697: oPushResult
6698: equal_zero
6699: oPop 1
6701: oChoice 6715
6703: oEmit 15
6705: oGetLocal 1
6707: oPushResult
6708: oEmitInt
6709: oPop 1
6711: oEmit 37
6713: oJumpForward 6718
6715: Choice Lookup Table
           0   6703
6718: oGetAddrLocal 3
6720: oPushResult
6721: oGetLocal 2
6723: oPushResult
6724: oSetResult 17
6726: oPushResult
6727: oNodeGetInt
6728: oPop 2
6730: oAssign
6731: oGetLocal 3
6733: oPushResult
6734: oSetResult 1
6736: oPushResult
6737: equal
6738: oPop 2
6740: oChoice 6754
6742: oEmit 15
6744: oGetLocal 3
6746: oPushResult
6747: oEmitInt
6748: oPop 1
6750: oEmit 33
6752: oJumpForward 6757
6754: Choice Lookup Table
           0   6742
6757: oEmit 35
6759: oInputChoice 6767
6761: oJumpForward 6775
6763: oJumpForward 6773
6765: oJumpForward 6773
6767: Choice Lookup Table
          12   6765
          16   6761
6772: oEndChoice
6773: oJumpBack 6645
6775: oReturn
6776: oLocalSpace 2
6778: oTypeSNodeType
6779: oChoice 6783
6781: oJumpForward 6788
6783: Choice Lookup Table
          36   6781
6786: oError 11
6788: oTypeSTop
6789: oPushResult
6790: oSetResult 40
6792: oPushResult
6793: oNodeGet
6794: oPop 2
6796: oPushResult
6797: oScopeEnter
6798: oPop 1
6800: oInput 0
6802: oGetAddrLocal 1
6804: oPushResult
6805: oScopeFindRequire
6806: oAssign
6807: oGetLocal 1
6809: oPushResult
6810: oNodeType
6811: oPop 1
6813: oChoice 6817
6815: oJumpForward 6822
6817: Choice Lookup Table
          22   6815
6820: oError 12
6822: oScopeEnd
6823: oGetAddrLocal 2
6825: oPushResult
6826: oGetLocal 1
6828: oPushResult
6829: oSetResult 22
6831: oPushResult
6832: oNodeGetInt
6833: oPop 2
6835: oAssign
6836: oGetLocal 2
6838: oPushResult
6839: equal_zero
6840: oPop 1
6842: oChoice 6856
6844: oEmit 15
6846: oGetLocal 2
6848: oPushResult
6849: oEmitInt
6850: oPop 1
6852: oEmit 35
6854: oJumpForward 6859
6856: Choice Lookup Table
           0   6844
6859: oTypeSPop
6860: oGetLocal 1
6862: oPushResult
6863: oSetResult 21
6865: oPushResult
6866: oNodeGet
6867: oPop 2
6869: oPushResult
6870: oTypeSPush
6871: oPop 1
6873: oReturn
6874: oLocalSpace 1
6876: oTypeSNodeType
6877: oChoice 6881
6879: oJumpForward 6886
6881: Choice Lookup Table
          33   6879
6884: oError 9
6886: oEmit 24
6888: oGetAddrLocal 1
6890: oPushResult
6891: oTypeSTop
6892: oAssign
6893: oTypeSPop
6894: oGetLocal 1
6896: oPushResult
6897: oSetResult 36
6899: oPushResult
6900: oNodeGet
6901: oPop 2
6903: oPushResult
6904: oTypeSPush
6905: oPop 1
6907: oReturn
6908: oLocalSpace 1
6910: oGetAddrLocal 1
6912: oPushResult
6913: oTypeSNodeType
6914: oAssign
6915: oTypeSPop
6916: oGetLocal 1
6918: oPushResult
6919: oTypeSNodeType
6920: oPushResult
6921: equal_node_type
6922: oPop 2
6924: oChoice 6966
6926: oTypeSNodeType
6927: oChoice 6957
6929: oGetLocal 1
6931: oChoice 6938
6933: oEmit 29
6935: oReturn
6936: oJumpForward 6941
6938: Choice Lookup Table
          28   6933
6941: oJumpForward 6962
6943: oGetLocal 1
6945: oChoice 6952
6947: oEmit 30
6949: oReturn
6950: oJumpForward 6955
6952: Choice Lookup Table
          27   6947
6955: oJumpForward 6962
6957: Choice Lookup Table
          28   6943
          27   6929
6962: oError 14
6964: oJumpForward 6969
6966: Choice Lookup Table
           0   6926
6969: oReturn
6970: oLocalSpace 2
6972: oGetAddrLocal 2
6974: oPushResult
6975: oGetParam 1
6977: oPushResult
6978: oSetResult 26
6980: oPushResult
6981: oNodeGetString
6982: oPop 2
6984: oAssign
6985: oGetLocal 2
6987: oPushResult
6988: oSetResult 0
6990: oPushResult
6991: equal_string
6992: oPop 2
6994: oChoice 7031
6996: oGetAddrLocal 1
6998: oPushResult
6999: oGetParam 1
7001: oPushResult
7002: oSetResult 4
7004: oPushResult
7005: oNodeGetInt
7006: oPop 2
7008: oPushResult
7009: ID_STRING
7010: oPop 1
7012: oPushResult
7013: oStringAllocLit
7014: oPop 1
7016: oAssign
7017: oJumpForward 7037
7019: oGetAddrLocal 1
7021: oPushResult
7022: oGetLocal 2
7024: oPushResult
7025: oStringAllocLit
7026: oPop 1
7028: oAssign
7029: oJumpForward 7037
7031: Choice Lookup Table
           0   7019
           1   6996
7036: oEndChoice
7037: oEmit 60
7039: oGetParam 1
7041: oPushResult
7042: oCall 9439
7044: oPop 1
7046: oGetLocal 1
7048: oPushResult
7049: oEmitInt
7050: oPop 1
7052: oReturn
7053: oLocalSpace 10
7055: oGetParam 1
7057: oPushResult
7058: oSetResult 25
7060: oPushResult
7061: oNodeGetBoolean
7062: oPop 2
7064: oChoice 7091
7066: oGetParam 1
7068: oPushResult
7069: oSetResult 28
7071: oPushResult
7072: oNodeGetBoolean
7073: oPop 2
7075: oChoice 7086
7077: oGetParam 1
7079: oPushResult
7080: oCall 6970
7082: oPop 1
7084: oJumpForward 7089
7086: Choice Lookup Table
           0   7077
7089: oJumpForward 7094
7091: Choice Lookup Table
           1   7066
7094: oGetParam 1
7096: oPushResult
7097: oSetResult 28
7099: oPushResult
7100: oSetResult 1
7102: oPushResult
7103: oNodeSetBoolean
7104: oPop 3
7106: oGetAddrLocal 1
7108: oPushResult
7109: oGetParam 1
7111: oPushResult
7112: oSetResult 27
7114: oPushResult
7115: oNodeGetBoolean
7116: oPop 2
7118: oAssign
7119: oGetAddrLocal 4
7121: oPushResult
7122: oGetParam 1
7124: oPushResult
7125: oNodeType
7126: oPop 1
7128: oPushResult
7129: oSetResult 13
7131: oPushResult
7132: equal_node_type
7133: oPop 2
7135: oAssign
7136: oGetLocal 4
7138: oChoice 7165
7140: oGetAddrLocal 2
7142: oPushResult
7143: oGetParam 1
7145: oPushResult
7146: oSetResult 21
7148: oPushResult
7149: oNodeGet
7150: oPop 2
7152: oAssign
7153: oGetAddrLocal 3
7155: oPushResult
7156: oGetLocal 2
7158: oPushResult
7159: oScopeAllocType
7160: oPop 1
7162: oAssign
7163: oJumpForward 7168
7165: Choice Lookup Table
           1   7140
7168: oGetAddrLocal 5
7170: oPushResult
7171: oGetParam 1
7173: oPushResult
7174: oSetResult 23
7176: oPushResult
7177: oNodeGet
7178: oPop 2
7180: oAssign
7181: oGetAddrLocal 6
7183: oPushResult
7184: oGetLocal 5
7186: oPushResult
7187: oSetResult 17
7189: oPushResult
7190: oNodeGetInt
7191: oPop 2
7193: oAssign
7194: oGetLocal 1
7196: oChoice 7218
7198: oEmit 49
7200: oGetLocal 6
7202: oPushResult
7203: oEmitInt
7204: oPop 1
7206: oJumpForward 7224
7208: oEmit 48
7210: oGetLocal 6
7212: oPushResult
7213: oEmitInt
7214: oPop 1
7216: oJumpForward 7224
7218: Choice Lookup Table
           0   7208
           1   7198
7223: oEndChoice
7224: oGetParam 1
7226: oPushResult
7227: oCall 9014
7229: oPop 1
7231: oPushResult
7232: oSetResult 0
7234: oPushResult
7235: greater
7236: oPop 2
7238: oChoice 7271
7240: oEmit 19
7242: oSetResult 0
7244: oPushResult
7245: oEmitInt
7246: oPop 1
7248: oEmit 20
7250: oGetParam 1
7252: oPushResult
7253: oCall 9034
7255: oPop 1
7257: oPushResult
7258: oEmitInt
7259: oPop 1
7261: oSetResult 0
7263: oPushResult
7264: oEmitInt
7265: oPop 1
7267: oEmit 27
7269: oJumpForward 7274
7271: Choice Lookup Table
           1   7240
7274: oGetAddrLocal 7
7276: oPushResult
7277: oGetLocal 5
7279: oPushResult
7280: oSetResult 15
7282: oPushResult
7283: oNodeGetIter
7284: oPop 2
7286: oAssign
7287: oGetAddrLocal 8
7289: oPushResult
7290: oGetLocal 7
7292: oPushResult
7293: oNodeIterValue
7294: oPop 1
7296: oAssign
7297: oInputChoice 7487
7299: oGetLocal 8
7301: oPushResult
7302: oNodeNull
7303: oPop 1
7305: oChoice 7311
7307: oJumpForward 7483
7309: oJumpForward 7314
7311: Choice Lookup Table
           1   7307
7314: oGetAddrLocal 9
7316: oPushResult
7317: oGetLocal 8
7319: oPushResult
7320: oSetResult 22
7322: oPushResult
7323: oNodeGetInt
7324: oPop 2
7326: oAssign
7327: oEmit 19
7329: oGetLocal 9
7331: oPushResult
7332: oEmitInt
7333: oPop 1
7335: oGetLocal 8
7337: oPushResult
7338: oSetResult 21
7340: oPushResult
7341: oNodeGet
7342: oPop 2
7344: oPushResult
7345: oTypeSPush
7346: oPop 1
7348: oGetLocal 8
7350: oPushResult
7351: oSetResult 33
7353: oPushResult
7354: oNodeGetBoolean
7355: oPop 2
7357: oChoice 7436
7359: oCall 8194
7361: oCall 9052
7363: oEmit 27
7365: oJumpForward 7442
7367: oCall 4495
7369: oCall 6908
7371: oTypeSNodeType
7372: oChoice 7412
7374: oEmit 25
7376: oJumpForward 7434
7378: oEmit 26
7380: oJumpForward 7434
7382: oError 16
7384: oJumpForward 7434
7386: oEmit 27
7388: oJumpForward 7434
7390: oGetAddrLocal 10
7392: oPushResult
7393: oTypeSTop
7394: oPushResult
7395: oSetResult 17
7397: oPushResult
7398: oNodeGetInt
7399: oPop 2
7401: oAssign
7402: oEmit 28
7404: oGetLocal 10
7406: oPushResult
7407: oEmitInt
7408: oPop 1
7410: oJumpForward 7434
7412: Choice Lookup Table
          36   7390
          34   7390
          33   7386
          26   7382
          32   7382
          31   7378
          28   7378
          29   7378
          37   7374
          27   7374
7433: oEndChoice
7434: oJumpForward 7442
7436: Choice Lookup Table
           0   7367
           1   7359
7441: oEndChoice
7442: oTypeSPop
7443: oGetAddrLocal 7
7445: oPushResult
7446: oNodeIterNext
7447: oPop 1
7449: oGetAddrLocal 8
7451: oPushResult
7452: oGetLocal 7
7454: oPushResult
7455: oNodeIterValue
7456: oPop 1
7458: oAssign
7459: oGetLocal 8
7461: oPushResult
7462: oNodeNull
7463: oPop 1
7465: oChoice 7473
7467: oJumpForward 7483
7469: oJumpForward 7479
7471: oJumpForward 7479
7473: Choice Lookup Table
           0   7471
           1   7467
7478: oEndChoice
7479: oInput 12
7481: oJumpBack 7299
7483: oInput 14
7485: oJumpForward 7490
7487: Choice Lookup Table
          13   7299
7490: oGetLocal 8
7492: oPushResult
7493: oNodeNull
7494: oPop 1
7496: oChoice 7502
7498: oError 15
7500: oJumpForward 7505
7502: Choice Lookup Table
           0   7498
7505: oGetLocal 4
7507: oChoice 7536
7509: oEmit 19
7511: oGetParam 1
7513: oPushResult
7514: oSetResult 31
7516: oPushResult
7517: oNodeGetInt
7518: oPop 2
7520: oPushResult
7521: oEmitInt
7522: oPop 1
7524: oEmit 17
7526: oGetLocal 3
7528: oPushResult
7529: oEmitInt
7530: oPop 1
7532: oEmit 27
7534: oJumpForward 7539
7536: Choice Lookup Table
           1   7509
7539: oGetLocal 1
7541: oChoice 7565
7543: oEmit 52
7545: oGetParam 1
7547: oPushResult
7548: oCall 9439
7550: oPop 1
7552: oJumpForward 7571
7554: oEmit 51
7556: oGetParam 1
7558: oPushResult
7559: oCall 9439
7561: oPop 1
7563: oJumpForward 7571
7565: Choice Lookup Table
           0   7554
           1   7543
7570: oEndChoice
7571: oGetLocal 4
7573: oChoice 7652
7575: oGetLocal 2
7577: oPushResult
7578: oTypeSPush
7579: oPop 1
7581: oTypeSNodeType
7582: oChoice 7628
7584: oEmit 3
7586: oGetLocal 3
7588: oPushResult
7589: oEmitInt
7590: oPop 1
7592: oJumpForward 7650
7594: oEmit 4
7596: oGetLocal 3
7598: oPushResult
7599: oEmitInt
7600: oPop 1
7602: oJumpForward 7650
7604: oError 16
7606: oJumpForward 7650
7608: oEmit 5
7610: oGetLocal 3
7612: oPushResult
7613: oEmitInt
7614: oPop 1
7616: oJumpForward 7650
7618: oEmit 17
7620: oGetLocal 3
7622: oPushResult
7623: oEmitInt
7624: oPop 1
7626: oJumpForward 7650
7628: Choice Lookup Table
          36   7618
          34   7618
          33   7608
          26   7604
          32   7604
          31   7594
          28   7594
          29   7594
          37   7584
          27   7584
7649: oEndChoice
7650: oJumpForward 7655
7652: Choice Lookup Table
           1   7575
7655: oEmit 50
7657: oGetLocal 6
7659: oPushResult
7660: oEmitInt
7661: oPop 1
7663: oReturn
7664: oLocalSpace 0
7666: oGetParam 1
7668: oPushResult
7669: oGetGlobal 11
7671: oPushResult
7672: oNodeEqual
7673: oPop 2
7675: oChoice 7715
7677: oInput 13
7679: oCall 4495
7681: oTypeSNodeType
7682: oChoice 7690
7684: oJumpForward 7703
7686: oEmit 29
7688: oJumpForward 7703
7690: Choice Lookup Table
          31   7686
          28   7686
          29   7686
          37   7684
          27   7684
7701: oError 14
7703: oTypeSPop
7704: oGetGlobal 5
7706: oPushResult
7707: oTypeSPush
7708: oPop 1
7710: oInput 14
7712: oReturn
7713: oJumpForward 7718
7715: Choice Lookup Table
           1   7677
7718: oGetParam 1
7720: oPushResult
7721: oGetGlobal 12
7723: oPushResult
7724: oNodeEqual
7725: oPop 2
7727: oChoice 7761
7729: oInput 13
7731: oCall 4495
7733: oTypeSNodeType
7734: oChoice 7742
7736: oEmit 30
7738: oJumpForward 7749
7740: oJumpForward 7749
7742: Choice Lookup Table
          28   7740
          27   7736
7747: oError 14
7749: oTypeSPop
7750: oGetGlobal 8
7752: oPushResult
7753: oTypeSPush
7754: oPop 1
7756: oInput 14
7758: oReturn
7759: oJumpForward 7764
7761: Choice Lookup Table
           1   7729
7764: oError 16
7766: oReturn
7767: oLocalSpace 0
7769: oInputChoice 7828
7771: oCall 8890
7773: oJumpForward 7857
7775: oCall 8897
7777: oJumpForward 7857
7779: oCall 8996
7781: oJumpForward 7857
7783: oCall 8999
7785: oJumpForward 7857
7787: oCall 8378
7789: oJumpForward 7857
7791: oCall 8698
7793: oJumpForward 7857
7795: oCall 8444
7797: oJumpForward 7857
7799: oCall 8618
7801: oJumpForward 7857
7803: oCall 8783
7805: oJumpForward 7857
7807: oCall 8751
7809: oJumpForward 7857
7811: oCall 8867
7813: oJumpForward 7857
7815: oCall 7858
7817: oJumpForward 7857
7819: oCall 8815
7821: oJumpForward 7857
7823: oChangeIntLitToLabelIdent
7824: oCall 7858
7826: oJumpForward 7857
7828: Choice Lookup Table
           1   7823
          52   7819
           0   7815
          34   7811
          50   7807
          51   7803
          48   7799
          43   7795
          47   7791
          40   7787
          65   7783
          64   7779
          63   7775
          62   7771
7857: oReturn
7858: oLocalSpace 1
7860: oGetAddrLocal 1
7862: oPushResult
7863: oScopeFindRequire
7864: oAssign
7865: oGetAddrLocal 1
7867: oPushResult
7868: oCall 409
7870: oPop 1
7872: oGetLocal 1
7874: oPushResult
7875: oNodeType
7876: oPop 1
7878: oChoice 7918
7880: oGetLocal 1
7882: oPushResult
7883: oCall 7934
7885: oPop 1
7887: oCall 7767
7889: oJumpForward 7933
7891: oGetLocal 1
7893: oPushResult
7894: oCall 7053
7896: oPop 1
7898: oJumpForward 7933
7900: oGetLocal 1
7902: oPushResult
7903: oCall 7984
7905: oPop 1
7907: oJumpForward 7933
7909: oGetLocal 1
7911: oPushResult
7912: oCall 8069
7914: oPop 1
7916: oJumpForward 7933
7918: Choice Lookup Table
          13   7909
          23   7900
          21   7900
          20   7900
          12   7891
          24   7880
7931: oError 0
7933: oReturn
7934: oLocalSpace 0
7936: oGetParam 1
7938: oPushResult
7939: oSetResult 34
7941: oPushResult
7942: oNodeGetBoolean
7943: oPop 2
7945: oChoice 7951
7947: oError 21
7949: oJumpForward 7954
7951: Choice Lookup Table
           1   7947
7954: oEmit 58
7956: oGetParam 1
7958: oPushResult
7959: oSetResult 22
7961: oPushResult
7962: oNodeGetLabel
7963: oPop 2
7965: oPushResult
7966: oEmitLabel
7967: oPop 1
7969: oGetParam 1
7971: oPushResult
7972: oSetResult 34
7974: oPushResult
7975: oSetResult 1
7977: oPushResult
7978: oNodeSetBoolean
7979: oPop 3
7981: oInput 11
7983: oReturn
7984: oLocalSpace 0
7986: oGetParam 1
7988: oPushResult
7989: oCall 8237
7991: oPop 1
7993: oInput 3
7995: oCall 4495
7997: oCall 6908
7999: oCall 8002
8001: oReturn
8002: oLocalSpace 1
8004: oTypeSNodeType
8005: oChoice 8045
8007: oEmit 25
8009: oJumpForward 8067
8011: oEmit 26
8013: oJumpForward 8067
8015: oError 16
8017: oJumpForward 8067
8019: oEmit 27
8021: oJumpForward 8067
8023: oGetAddrLocal 1
8025: oPushResult
8026: oTypeSTop
8027: oPushResult
8028: oSetResult 17
8030: oPushResult
8031: oNodeGetInt
8032: oPop 2
8034: oAssign
8035: oEmit 28
8037: oGetLocal 1
8039: oPushResult
8040: oEmitInt
8041: oPop 1
8043: oJumpForward 8067
8045: Choice Lookup Table
          36   8023
          34   8023
          33   8019
          26   8015
          32   8015
          31   8011
          28   8011
          29   8011
          37   8007
          27   8007
8066: oEndChoice
8067: oTypeSPop
8068: oReturn
8069: oLocalSpace 1
8071: oGetParam 1
8073: oPushResult
8074: oSetResult 6
8076: oPushResult
8077: oNodeGet
8078: oPop 2
8080: oPushResult
8081: oScopeCurrent
8082: oPushResult
8083: oNodeEqual
8084: oPop 2
8086: oChoice 8092
8088: oError 20
8090: oJumpForward 8095
8092: Choice Lookup Table
           0   8088
8095: oEmit 8
8097: oGetParam 1
8099: oPushResult
8100: oSetResult 31
8102: oPushResult
8103: oNodeGetInt
8104: oPop 2
8106: oPushResult
8107: oEmitInt
8108: oPop 1
8110: oGetParam 1
8112: oPushResult
8113: oSetResult 21
8115: oPushResult
8116: oNodeGet
8117: oPop 2
8119: oPushResult
8120: oTypeSPush
8121: oPop 1
8123: oInput 3
8125: oCall 4495
8127: oCall 6908
8129: oTypeSNodeType
8130: oChoice 8170
8132: oEmit 25
8134: oJumpForward 8192
8136: oEmit 26
8138: oJumpForward 8192
8140: oError 16
8142: oJumpForward 8192
8144: oEmit 27
8146: oJumpForward 8192
8148: oGetAddrLocal 1
8150: oPushResult
8151: oTypeSTop
8152: oPushResult
8153: oSetResult 17
8155: oPushResult
8156: oNodeGetInt
8157: oPop 2
8159: oAssign
8160: oEmit 28
8162: oGetLocal 1
8164: oPushResult
8165: oEmitInt
8166: oPop 1
8168: oJumpForward 8192
8170: Choice Lookup Table
          36   8148
          34   8148
          33   8144
          26   8140
          32   8140
          31   8136
          28   8136
          29   8136
          37   8132
          27   8132
8191: oEndChoice
8192: oTypeSPop
8193: oReturn
8194: oLocalSpace 1
8196: oInput 0
8198: oGetAddrLocal 1
8200: oPushResult
8201: oScopeFindRequire
8202: oAssign
8203: oGetAddrLocal 1
8205: oPushResult
8206: oCall 409
8208: oPop 1
8210: oGetLocal 1
8212: oPushResult
8213: oNodeType
8214: oPop 1
8216: oChoice 8220
8218: oJumpForward 8229
8220: Choice Lookup Table
          23   8218
          21   8218
          20   8218
8227: oError 4
8229: oGetLocal 1
8231: oPushResult
8232: oCall 8237
8234: oPop 1
8236: oReturn
8237: oLocalSpace 0
8239: oGetParam 1
8241: oPushResult
8242: oNodeType
8243: oPop 1
8245: oChoice 8305
8247: oEmit 16
8249: oGetParam 1
8251: oPushResult
8252: oCall 9439
8254: oPop 1
8256: oJumpForward 8314
8258: oEmit 17
8260: oGetParam 1
8262: oPushResult
8263: oCall 9439
8265: oPop 1
8267: oJumpForward 8314
8269: oGetParam 1
8271: oPushResult
8272: oSetResult 33
8274: oPushResult
8275: oNodeGetBoolean
8276: oPop 2
8278: oChoice 8291
8280: oEmit 8
8282: oGetParam 1
8284: oPushResult
8285: oCall 9439
8287: oPop 1
8289: oJumpForward 8303
8291: Choice Lookup Table
           1   8280
8294: oEmit 18
8296: oGetParam 1
8298: oPushResult
8299: oCall 9439
8301: oPop 1
8303: oJumpForward 8314
8305: Choice Lookup Table
          23   8269
          21   8258
          20   8247
8312: oError 4
8314: oGetParam 1
8316: oPushResult
8317: oSetResult 21
8319: oPushResult
8320: oNodeGet
8321: oPop 2
8323: oPushResult
8324: oTypeSPush
8325: oPop 1
8327: oCall 6605
8329: oReturn
8330: oLocalSpace 0
8332: oGetParam 1
8334: oPushResult
8335: oCall 8237
8337: oPop 1
8339: oCall 9078
8341: oGetParam 1
8343: oPushResult
8344: oCall 5822
8346: oPop 1
8348: oTypeSPop
8349: oEmit 31
8351: oEmit 25
8353: oReturn
8354: oLocalSpace 0
8356: oGetParam 1
8358: oPushResult
8359: oCall 8237
8361: oPop 1
8363: oCall 9078
8365: oGetParam 1
8367: oPushResult
8368: oCall 5822
8370: oPop 1
8372: oTypeSPop
8373: oEmit 32
8375: oEmit 25
8377: oReturn
8378: oLocalSpace 2
8380: oGetAddrLocal 1
8382: oPushResult
8383: oSetResult 0
8385: oAssign
8386: oGetAddrLocal 1
8388: oPushResult
8389: oCall 4518
8391: oPop 1
8393: oInput 41
8395: oCall 7767
8397: oInputChoice 8432
8399: oGetAddrLocal 2
8401: oPushResult
8402: oLabelNew
8403: oAssign
8404: oEmit 55
8406: oGetLocal 2
8408: oPushResult
8409: oEmitLabel
8410: oPop 1
8412: oEmit 58
8414: oGetLocal 1
8416: oPushResult
8417: oEmitLabel
8418: oPop 1
8420: oCall 7767
8422: oEmit 58
8424: oGetLocal 2
8426: oPushResult
8427: oEmitLabel
8428: oPop 1
8430: oJumpForward 8443
8432: Choice Lookup Table
          42   8399
8435: oEmit 58
8437: oGetLocal 1
8439: oPushResult
8440: oEmitLabel
8441: oPop 1
8443: oReturn
8444: oLocalSpace 4
8446: oInput 0
8448: oGetAddrLocal 1
8450: oPushResult
8451: oScopeFindRequire
8452: oAssign
8453: oGetLocal 1
8455: oPushResult
8456: oCall 8237
8458: oPop 1
8460: oCall 9078
8462: oInput 3
8464: oCall 4495
8466: oCall 9078
8468: oEmit 25
8470: oGetAddrLocal 2
8472: oPushResult
8473: oLabelNew
8474: oAssign
8475: oGetAddrLocal 3
8477: oPushResult
8478: oLabelNew
8479: oAssign
8480: oEmit 55
8482: oGetLocal 3
8484: oPushResult
8485: oEmitLabel
8486: oPop 1
8488: oGetAddrLocal 4
8490: oPushResult
8491: oLabelNew
8492: oAssign
8493: oEmit 58
8495: oGetLocal 4
8497: oPushResult
8498: oEmitLabel
8499: oPop 1
8501: oInputChoice 8581
8503: oGetLocal 1
8505: oPushResult
8506: oCall 8330
8508: oPop 1
8510: oEmit 58
8512: oGetLocal 3
8514: oPushResult
8515: oEmitLabel
8516: oPop 1
8518: oGetLocal 1
8520: oPushResult
8521: oCall 5822
8523: oPop 1
8525: oTypeSPop
8526: oCall 4495
8528: oCall 9078
8530: oEmit 42
8532: oEmit 56
8534: oGetLocal 2
8536: oPushResult
8537: oEmitLabel
8538: oPop 1
8540: oJumpForward 8587
8542: oGetLocal 1
8544: oPushResult
8545: oCall 8354
8547: oPop 1
8549: oEmit 58
8551: oGetLocal 3
8553: oPushResult
8554: oEmitLabel
8555: oPop 1
8557: oGetLocal 1
8559: oPushResult
8560: oCall 5822
8562: oPop 1
8564: oTypeSPop
8565: oCall 4495
8567: oCall 9078
8569: oEmit 43
8571: oEmit 56
8573: oGetLocal 2
8575: oPushResult
8576: oEmitLabel
8577: oPop 1
8579: oJumpForward 8587
8581: Choice Lookup Table
          45   8542
          44   8503
8586: oEndChoice
8587: oGetLocal 4
8589: oPushResult
8590: oGetLocal 2
8592: oPushResult
8593: oLoopPush
8594: oPop 2
8596: oInput 46
8598: oCall 7767
8600: oEmit 55
8602: oGetLocal 4
8604: oPushResult
8605: oEmitLabel
8606: oPop 1
8608: oEmit 58
8610: oGetLocal 2
8612: oPushResult
8613: oEmitLabel
8614: oPop 1
8616: oLoopPop
8617: oReturn
8618: oLocalSpace 3
8620: oGetAddrLocal 1
8622: oPushResult
8623: oLabelNew
8624: oAssign
8625: oEmit 58
8627: oGetLocal 1
8629: oPushResult
8630: oEmitLabel
8631: oPop 1
8633: oGetAddrLocal 2
8635: oPushResult
8636: oLabelNew
8637: oAssign
8638: oGetLocal 1
8640: oPushResult
8641: oGetLocal 2
8643: oPushResult
8644: oLoopPush
8645: oPop 2
8647: oCall 7767
8649: oInputChoice 8680
8651: oCall 7767
8653: oJumpForward 8686
8655: oGetAddrLocal 3
8657: oPushResult
8658: oCall 4518
8660: oPop 1
8662: oEmit 59
8664: oGetLocal 3
8666: oPushResult
8667: oEmitLabel
8668: oPop 1
8670: oGetLocal 1
8672: oPushResult
8673: oEmitLabel
8674: oPop 1
8676: oJumpForward 8688
8678: oJumpForward 8686
8680: Choice Lookup Table
          49   8655
           4   8651
8685: oEndChoice
8686: oJumpBack 8649
8688: oEmit 58
8690: oGetLocal 2
8692: oPushResult
8693: oEmitLabel
8694: oPop 1
8696: oLoopPop
8697: oReturn
8698: oLocalSpace 2
8700: oGetAddrLocal 1
8702: oPushResult
8703: oLabelNew
8704: oAssign
8705: oEmit 58
8707: oGetLocal 1
8709: oPushResult
8710: oEmitLabel
8711: oPop 1
8713: oGetAddrLocal 2
8715: oPushResult
8716: oCall 4518
8718: oPop 1
8720: oGetLocal 1
8722: oPushResult
8723: oGetLocal 2
8725: oPushResult
8726: oLoopPush
8727: oPop 2
8729: oInput 46
8731: oCall 7767
8733: oEmit 55
8735: oGetLocal 1
8737: oPushResult
8738: oEmitLabel
8739: oPop 1
8741: oEmit 58
8743: oGetLocal 2
8745: oPushResult
8746: oEmitLabel
8747: oPop 1
8749: oLoopPop
8750: oReturn
8751: oLocalSpace 0
8753: oLoopContinueLabel
8754: oPushResult
8755: oSetResult 0
8757: oPushResult
8758: equal_label
8759: oPop 2
8761: oChoice 8776
8763: oError 18
8765: oJumpForward 8782
8767: oEmit 55
8769: oLoopContinueLabel
8770: oPushResult
8771: oEmitLabel
8772: oPop 1
8774: oJumpForward 8782
8776: Choice Lookup Table
           0   8767
           1   8763
8781: oEndChoice
8782: oReturn
8783: oLocalSpace 0
8785: oLoopBreakLabel
8786: oPushResult
8787: oSetResult 0
8789: oPushResult
8790: equal_label
8791: oPop 2
8793: oChoice 8808
8795: oError 18
8797: oJumpForward 8814
8799: oEmit 55
8801: oLoopBreakLabel
8802: oPushResult
8803: oEmitLabel
8804: oPop 1
8806: oJumpForward 8814
8808: Choice Lookup Table
           0   8799
           1   8795
8813: oEndChoice
8814: oReturn
8815: oLocalSpace 1
8817: oInputChoice 8824
8819: oJumpForward 8830
8821: oChangeIntLitToLabelIdent
8822: oJumpForward 8830
8824: Choice Lookup Table
           1   8821
           0   8819
8829: oEndChoice
8830: oGetAddrLocal 1
8832: oPushResult
8833: oScopeCurrent
8834: oPushResult
8835: oScopeFindRequireInScope
8836: oPop 1
8838: oAssign
8839: oGetLocal 1
8841: oPushResult
8842: oSetResult 28
8844: oPushResult
8845: oSetResult 1
8847: oPushResult
8848: oNodeSetBoolean
8849: oPop 3
8851: oEmit 55
8853: oGetLocal 1
8855: oPushResult
8856: oSetResult 22
8858: oPushResult
8859: oNodeGetLabel
8860: oPop 2
8862: oPushResult
8863: oEmitLabel
8864: oPop 1
8866: oReturn
8867: oLocalSpace 0
8869: oCall 7767
8871: oInputChoice 8881
8873: oCall 7767
8875: oJumpForward 8887
8877: oJumpForward 8889
8879: oJumpForward 8887
8881: Choice Lookup Table
          35   8877
           4   8873
8886: oEndChoice
8887: oJumpBack 8871
8889: oReturn
8890: oLocalSpace 0
8892: oCall 8897
8894: oEmit 67
8896: oReturn
8897: oLocalSpace 0
8899: oInputChoice 8992
8901: oCall 4495
8903: oTypeSNodeType
8904: oChoice 8954
8906: oEmit 61
8908: oJumpForward 8973
8910: oEmit 62
8912: oJumpForward 8973
8914: oEmit 29
8916: oEmit 61
8918: oJumpForward 8973
8920: oEmit 63
8922: oJumpForward 8973
8924: oEmit 64
8926: oJumpForward 8973
8928: oError 16
8930: oJumpForward 8973
8932: oEmit 16
8934: oTypeSTop
8935: oPushResult
8936: oSetResult 41
8938: oPushResult
8939: oNodeGetInt
8940: oPop 2
8942: oPushResult
8943: oEmitInt
8944: oPop 1
8946: oEmit 66
8948: oJumpForward 8973
8950: oEmit 65
8952: oJumpForward 8973
8954: Choice Lookup Table
          33   8950
          37   8932
          26   8928
          32   8924
          31   8920
          28   8914
          29   8910
          27   8906
8971: oError 17
8973: oTypeSPop
8974: oInputChoice 8982
8976: oJumpForward 8990
8978: oJumpForward 8988
8980: oJumpForward 8988
8982: Choice Lookup Table
          12   8980
          14   8976
8987: oEndChoice
8988: oJumpBack 8901
8990: oJumpForward 8995
8992: Choice Lookup Table
          13   8901
8995: oReturn
8996: oLocalSpace 0
8998: oReturn
8999: oLocalSpace 0
9001: oReturn
9002: oLocalSpace 0
9004: oScopeCurrent
9005: oPushResult
9006: oSetResult 14
9008: oPushResult
9009: oNodeGetInt
9010: oPop 2
9012: oReturn
9013: oReturn
9014: oLocalSpace 0
9016: oGetParam 1
9018: oPushResult
9019: oSetResult 20
9021: oPushResult
9022: oNodeGet
9023: oPop 2
9025: oPushResult
9026: oSetResult 14
9028: oPushResult
9029: oNodeGetInt
9030: oPop 2
9032: oReturn
9033: oReturn
9034: oLocalSpace 0
9036: oCall 9002
9038: oPushResult
9039: oGetParam 1
9041: oPushResult
9042: oCall 9014
9044: oPop 1
9046: oPushResult
9047: subtract
9048: oPop 2
9050: oReturn
9051: oReturn
9052: oLocalSpace 1
9054: oGetAddrLocal 1
9056: oPushResult
9057: oTypeSNodeType
9058: oAssign
9059: oTypeSPop
9060: oGetLocal 1
9062: oPushResult
9063: oTypeSNodeType
9064: oPushResult
9065: equal_node_type
9066: oPop 2
9068: oChoice 9074
9070: oError 14
9072: oJumpForward 9077
9074: Choice Lookup Table
           0   9070
9077: oReturn
9078: oLocalSpace 0
9080: oTypeSNodeType
9081: oChoice 9085
9083: oJumpForward 9090
9085: Choice Lookup Table
          27   9083
9088: oError 7
9090: oTypeSPop
9091: oReturn
9092: oLocalSpace 0
9094: oTypeSNodeType
9095: oChoice 9099
9097: oJumpForward 9104
9099: Choice Lookup Table
          27   9097
9102: oError 7
9104: oReturn
9105: oLocalSpace 0
9107: oTypeSNodeType
9108: oChoice 9116
9110: oJumpForward 9123
9112: oEmit 29
9114: oJumpForward 9123
9116: Choice Lookup Table
          28   9112
          27   9110
9121: oError 7
9123: oTypeSPop
9124: oReturn
9125: oLocalSpace 0
9127: oTypeSNodeType
9128: oChoice 9143
9130: oJumpForward 9150
9132: oEmit 29
9134: oTypeSPop
9135: oGetGlobal 5
9137: oPushResult
9138: oTypeSPush
9139: oPop 1
9141: oJumpForward 9150
9143: Choice Lookup Table
          28   9132
          27   9130
9148: oError 7
9150: oReturn
9151: oLocalSpace 0
9153: oTypeSNodeType
9154: oChoice 9167
9156: oEmit 29
9158: oTypeSPop
9159: oGetGlobal 5
9161: oPushResult
9162: oTypeSPush
9163: oPop 1
9165: oJumpForward 9170
9167: Choice Lookup Table
          28   9156
9170: oReturn
9171: oLocalSpace 0
9173: oTypeSNodeType
9174: oChoice 9178
9176: oJumpForward 9183
9178: Choice Lookup Table
          29   9176
9181: oError 8
9183: oTypeSPop
9184: oReturn
9185: oLocalSpace 0
9187: oTypeSNodeType
9188: oChoice 9192
9190: oJumpForward 9197
9192: Choice Lookup Table
          29   9190
9195: oError 8
9197: oReturn
9198: oLocalSpace 1
9200: oGetAddrLocal 1
9202: oPushResult
9203: oGetParam 2
9205: oPushResult
9206: oNodeNew
9207: oPop 1
9209: oAssign
9210: oGetLocal 1
9212: oPushResult
9213: oSetResult 17
9215: oPushResult
9216: oGetParam 1
9218: oPushResult
9219: oNodeSetInt
9220: oPop 3
9222: oGetLocal 1
9224: oPushResult
9225: oTypeAdd
9226: oPop 1
9228: oGetLocal 1
9230: oReturn
9231: oReturn
9232: oLocalSpace 1
9234: oGetAddrLocal 1
9236: oPushResult
9237: oGetParam 2
9239: oPushResult
9240: oNodeNew
9241: oPop 1
9243: oAssign
9244: oGetLocal 1
9246: oPushResult
9247: oSetResult 4
9249: oPushResult
9250: oGetParam 1
9252: oPushResult
9253: oNodeSetInt
9254: oPop 3
9256: oGetLocal 1
9258: oReturn
9259: oReturn
9260: oLocalSpace 1
9262: oGetAddrLocal 1
9264: oPushResult
9265: oGetParam 1
9267: oPushResult
9268: oSetResult 35
9270: oPushResult
9271: oNodeGet
9272: oPop 2
9274: oAssign
9275: oGetLocal 1
9277: oPushResult
9278: oNodeNull
9279: oPop 1
9281: oChoice 9337
9283: oGetAddrLocal 1
9285: oPushResult
9286: oSetResult 33
9288: oPushResult
9289: oNodeNew
9290: oPop 1
9292: oAssign
9293: oGetLocal 1
9295: oPushResult
9296: oSetResult 36
9298: oPushResult
9299: oGetParam 1
9301: oPushResult
9302: oNodeSet
9303: oPop 3
9305: oGetLocal 1
9307: oPushResult
9308: oSetResult 17
9310: oPushResult
9311: oSetResult 8
9313: oPushResult
9314: oNodeSetInt
9315: oPop 3
9317: oGetLocal 1
9319: oPushResult
9320: oTypeAdd
9321: oPop 1
9323: oGetParam 1
9325: oPushResult
9326: oSetResult 35
9328: oPushResult
9329: oGetLocal 1
9331: oPushResult
9332: oNodeSet
9333: oPop 3
9335: oJumpForward 9340
9337: Choice Lookup Table
           1   9283
9340: oGetLocal 1
9342: oReturn
9343: oReturn
9344: oLocalSpace 2
9346: oGetParam 1
9348: oPushResult
9349: oNodeType
9350: oPop 1
9352: oChoice 9422
9354: oMININT
9355: oReturn
9356: oJumpForward 9438
9358: oSetResult 0
9360: oReturn
9361: oJumpForward 9438
9363: oSetResult 0
9365: oReturn
9366: oJumpForward 9438
9368: oGetAddrLocal 1
9370: oPushResult
9371: oGetParam 1
9373: oPushResult
9374: oSetResult 40
9376: oPushResult
9377: oNodeGet
9378: oPop 2
9380: oAssign
9381: oGetAddrLocal 2
9383: oPushResult
9384: oGetLocal 1
9386: oPushResult
9387: oSetResult 15
9389: oPushResult
9390: oNodeGetIter
9391: oPop 2
9393: oPushResult
9394: oNodeIterValue
9395: oPop 1
9397: oAssign
9398: oGetLocal 2
9400: oPushResult
9401: oSetResult 22
9403: oPushResult
9404: oNodeGetInt
9405: oPop 2
9407: oReturn
9408: oJumpForward 9438
9410: oGetParam 1
9412: oPushResult
9413: oSetResult 38
9415: oPushResult
9416: oNodeGetInt
9417: oPop 2
9419: oReturn
9420: oJumpForward 9438
9422: Choice Lookup Table
          35   9410
          37   9368
          31   9363
          29   9358
          27   9354
9433: oError 3
9435: oSetResult 0
9437: oReturn
9438: oReturn
9439: oLocalSpace 0
9441: oGetParam 1
9443: oPushResult
9444: oSetResult 22
9446: oPushResult
9447: oNodeGetInt
9448: oPop 2
9450: oPushResult
9451: oEmitInt
9452: oPop 1
9454: oReturn
9455: oLocalSpace 1
9457: oGetAddrGlobal 4
9459: oPushResult
9460: oSetResult 26
9462: oPushResult
9463: oSetResult 4
9465: oPushResult
9466: oCall 9198
9468: oPop 2
9470: oAssign
9471: oGetAddrGlobal 5
9473: oPushResult
9474: oSetResult 27
9476: oPushResult
9477: oSetResult 4
9479: oPushResult
9480: oCall 9198
9482: oPop 2
9484: oAssign
9485: oGetAddrGlobal 6
9487: oPushResult
9488: oSetResult 29
9490: oPushResult
9491: oSetResult 1
9493: oPushResult
9494: oCall 9198
9496: oPop 2
9498: oAssign
9499: oGetAddrGlobal 7
9501: oPushResult
9502: oSetResult 30
9504: oPushResult
9505: oSetResult 1
9507: oPushResult
9508: oCall 9198
9510: oPop 2
9512: oAssign
9513: oGetAddrGlobal 8
9515: oPushResult
9516: oSetResult 31
9518: oPushResult
9519: oSetResult 1
9521: oPushResult
9522: oCall 9198
9524: oPop 2
9526: oAssign
9527: oGetAddrGlobal 9
9529: oPushResult
9530: oSetResult 28
9532: oPushResult
9533: oSetResult 1
9535: oPushResult
9536: oCall 9198
9538: oPop 2
9540: oAssign
9541: oGetAddrGlobal 10
9543: oPushResult
9544: oSetResult 32
9546: oPushResult
9547: oSetResult 256
9549: oPushResult
9550: oCall 9198
9552: oPop 2
9554: oAssign
9555: oGetAddrLocal 1
9557: oPushResult
9558: oSetResult 18
9560: oPushResult
9561: oIdAdd_File
9562: oPushResult
9563: oCall 9232
9565: oPop 2
9567: oAssign
9568: oGetLocal 1
9570: oPushResult
9571: oSetResult 21
9573: oPushResult
9574: oGetGlobal 4
9576: oPushResult
9577: oNodeSet
9578: oPop 3
9580: oGetLocal 1
9582: oPushResult
9583: oScopeDeclare
9584: oPop 1
9586: oGetAddrLocal 1
9588: oPushResult
9589: oSetResult 18
9591: oPushResult
9592: oIdAdd_Integer
9593: oPushResult
9594: oCall 9232
9596: oPop 2
9598: oAssign
9599: oGetLocal 1
9601: oPushResult
9602: oSetResult 21
9604: oPushResult
9605: oGetGlobal 5
9607: oPushResult
9608: oNodeSet
9609: oPop 3
9611: oGetLocal 1
9613: oPushResult
9614: oScopeDeclare
9615: oPop 1
9617: oGetAddrLocal 1
9619: oPushResult
9620: oSetResult 18
9622: oPushResult
9623: oIdAdd_Boolean
9624: oPushResult
9625: oCall 9232
9627: oPop 2
9629: oAssign
9630: oGetLocal 1
9632: oPushResult
9633: oSetResult 21
9635: oPushResult
9636: oGetGlobal 6
9638: oPushResult
9639: oNodeSet
9640: oPop 3
9642: oGetLocal 1
9644: oPushResult
9645: oScopeDeclare
9646: oPop 1
9648: oGetAddrLocal 1
9650: oPushResult
9651: oSetResult 18
9653: oPushResult
9654: oIdAdd_Char
9655: oPushResult
9656: oCall 9232
9658: oPop 2
9660: oAssign
9661: oGetLocal 1
9663: oPushResult
9664: oSetResult 21
9666: oPushResult
9667: oGetGlobal 8
9669: oPushResult
9670: oNodeSet
9671: oPop 3
9673: oGetLocal 1
9675: oPushResult
9676: oScopeDeclare
9677: oPop 1
9679: oGetAddrLocal 1
9681: oPushResult
9682: oSetResult 18
9684: oPushResult
9685: oIdAdd_Byte
9686: oPushResult
9687: oCall 9232
9689: oPop 2
9691: oAssign
9692: oGetLocal 1
9694: oPushResult
9695: oSetResult 21
9697: oPushResult
9698: oGetGlobal 9
9700: oPushResult
9701: oNodeSet
9702: oPop 3
9704: oGetLocal 1
9706: oPushResult
9707: oScopeDeclare
9708: oPop 1
9710: oGetAddrLocal 1
9712: oPushResult
9713: oSetResult 18
9715: oPushResult
9716: oIdAdd_String
9717: oPushResult
9718: oCall 9232
9720: oPop 2
9722: oAssign
9723: oGetLocal 1
9725: oPushResult
9726: oSetResult 21
9728: oPushResult
9729: oGetGlobal 10
9731: oPushResult
9732: oNodeSet
9733: oPop 3
9735: oGetLocal 1
9737: oPushResult
9738: oScopeDeclare
9739: oPop 1
9741: oGetAddrLocal 1
9743: oPushResult
9744: oSetResult 16
9746: oPushResult
9747: oIdAdd_True
9748: oPushResult
9749: oCall 9232
9751: oPop 2
9753: oAssign
9754: oGetLocal 1
9756: oPushResult
9757: oSetResult 21
9759: oPushResult
9760: oGetGlobal 6
9762: oPushResult
9763: oNodeSet
9764: oPop 3
9766: oGetLocal 1
9768: oPushResult
9769: oSetResult 22
9771: oPushResult
9772: oSetResult 1
9774: oPushResult
9775: oNodeSetInt
9776: oPop 3
9778: oGetLocal 1
9780: oPushResult
9781: oScopeDeclare
9782: oPop 1
9784: oGetAddrLocal 1
9786: oPushResult
9787: oSetResult 16
9789: oPushResult
9790: oIdAdd_False
9791: oPushResult
9792: oCall 9232
9794: oPop 2
9796: oAssign
9797: oGetLocal 1
9799: oPushResult
9800: oSetResult 21
9802: oPushResult
9803: oGetGlobal 6
9805: oPushResult
9806: oNodeSet
9807: oPop 3
9809: oGetLocal 1
9811: oPushResult
9812: oSetResult 22
9814: oPushResult
9815: oSetResult 0
9817: oPushResult
9818: oNodeSetInt
9819: oPop 3
9821: oGetLocal 1
9823: oPushResult
9824: oScopeDeclare
9825: oPop 1
9827: oGetAddrGlobal 11
9829: oPushResult
9830: oSetResult 14
9832: oPushResult
9833: oIdAdd_Ord
9834: oPushResult
9835: oCall 9232
9837: oPop 2
9839: oAssign
9840: oGetGlobal 11
9842: oPushResult
9843: oScopeDeclare
9844: oPop 1
9846: oGetAddrGlobal 12
9848: oPushResult
9849: oSetResult 14
9851: oPushResult
9852: oIdAdd_Chr
9853: oPushResult
9854: oCall 9232
9856: oPop 2
9858: oAssign
9859: oGetGlobal 12
9861: oPushResult
9862: oScopeDeclare
9863: oPop 1
9865: oReturn
